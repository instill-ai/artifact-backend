// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_ai "github.com/instill-ai/artifact-backend/internal/ai"
	artifactpb "github.com/instill-ai/protogen-go/artifact/artifact/v1alpha"
)

// ProviderMock implements mm_ai.Provider
type ProviderMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcClose          func() (err error)
	funcCloseOrigin    string
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mProviderMockClose

	funcConvertToMarkdown          func(ctx context.Context, content []byte, fileType artifactpb.FileType, filename string, prompt string) (cp1 *mm_ai.ConversionResult, err error)
	funcConvertToMarkdownOrigin    string
	inspectFuncConvertToMarkdown   func(ctx context.Context, content []byte, fileType artifactpb.FileType, filename string, prompt string)
	afterConvertToMarkdownCounter  uint64
	beforeConvertToMarkdownCounter uint64
	ConvertToMarkdownMock          mProviderMockConvertToMarkdown

	funcConvertToMarkdownWithCache          func(ctx context.Context, cacheName string, prompt string) (cp1 *mm_ai.ConversionResult, err error)
	funcConvertToMarkdownWithCacheOrigin    string
	inspectFuncConvertToMarkdownWithCache   func(ctx context.Context, cacheName string, prompt string)
	afterConvertToMarkdownWithCacheCounter  uint64
	beforeConvertToMarkdownWithCacheCounter uint64
	ConvertToMarkdownWithCacheMock          mProviderMockConvertToMarkdownWithCache

	funcCreateCache          func(ctx context.Context, content []byte, fileType artifactpb.FileType, filename string, ttl time.Duration) (cp1 *mm_ai.CacheResult, err error)
	funcCreateCacheOrigin    string
	inspectFuncCreateCache   func(ctx context.Context, content []byte, fileType artifactpb.FileType, filename string, ttl time.Duration)
	afterCreateCacheCounter  uint64
	beforeCreateCacheCounter uint64
	CreateCacheMock          mProviderMockCreateCache

	funcDeleteCache          func(ctx context.Context, cacheName string) (err error)
	funcDeleteCacheOrigin    string
	inspectFuncDeleteCache   func(ctx context.Context, cacheName string)
	afterDeleteCacheCounter  uint64
	beforeDeleteCacheCounter uint64
	DeleteCacheMock          mProviderMockDeleteCache

	funcName          func() (s1 string)
	funcNameOrigin    string
	inspectFuncName   func()
	afterNameCounter  uint64
	beforeNameCounter uint64
	NameMock          mProviderMockName

	funcSupportsFileType          func(fileType artifactpb.FileType) (b1 bool)
	funcSupportsFileTypeOrigin    string
	inspectFuncSupportsFileType   func(fileType artifactpb.FileType)
	afterSupportsFileTypeCounter  uint64
	beforeSupportsFileTypeCounter uint64
	SupportsFileTypeMock          mProviderMockSupportsFileType
}

// NewProviderMock returns a mock for mm_ai.Provider
func NewProviderMock(t minimock.Tester) *ProviderMock {
	m := &ProviderMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseMock = mProviderMockClose{mock: m}

	m.ConvertToMarkdownMock = mProviderMockConvertToMarkdown{mock: m}
	m.ConvertToMarkdownMock.callArgs = []*ProviderMockConvertToMarkdownParams{}

	m.ConvertToMarkdownWithCacheMock = mProviderMockConvertToMarkdownWithCache{mock: m}
	m.ConvertToMarkdownWithCacheMock.callArgs = []*ProviderMockConvertToMarkdownWithCacheParams{}

	m.CreateCacheMock = mProviderMockCreateCache{mock: m}
	m.CreateCacheMock.callArgs = []*ProviderMockCreateCacheParams{}

	m.DeleteCacheMock = mProviderMockDeleteCache{mock: m}
	m.DeleteCacheMock.callArgs = []*ProviderMockDeleteCacheParams{}

	m.NameMock = mProviderMockName{mock: m}

	m.SupportsFileTypeMock = mProviderMockSupportsFileType{mock: m}
	m.SupportsFileTypeMock.callArgs = []*ProviderMockSupportsFileTypeParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mProviderMockClose struct {
	optional           bool
	mock               *ProviderMock
	defaultExpectation *ProviderMockCloseExpectation
	expectations       []*ProviderMockCloseExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProviderMockCloseExpectation specifies expectation struct of the Provider.Close
type ProviderMockCloseExpectation struct {
	mock *ProviderMock

	results      *ProviderMockCloseResults
	returnOrigin string
	Counter      uint64
}

// ProviderMockCloseResults contains results of the Provider.Close
type ProviderMockCloseResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClose *mProviderMockClose) Optional() *mProviderMockClose {
	mmClose.optional = true
	return mmClose
}

// Expect sets up expected params for Provider.Close
func (mmClose *mProviderMockClose) Expect() *mProviderMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ProviderMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ProviderMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the Provider.Close
func (mmClose *mProviderMockClose) Inspect(f func()) *mProviderMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for ProviderMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by Provider.Close
func (mmClose *mProviderMockClose) Return(err error) *ProviderMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ProviderMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ProviderMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &ProviderMockCloseResults{err}
	mmClose.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Set uses given function f to mock the Provider.Close method
func (mmClose *mProviderMockClose) Set(f func() (err error)) *ProviderMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the Provider.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the Provider.Close method")
	}

	mmClose.mock.funcClose = f
	mmClose.mock.funcCloseOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Times sets number of times Provider.Close should be invoked
func (mmClose *mProviderMockClose) Times(n uint64) *mProviderMockClose {
	if n == 0 {
		mmClose.mock.t.Fatalf("Times of ProviderMock.Close mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClose.expectedInvocations, n)
	mmClose.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClose
}

func (mmClose *mProviderMockClose) invocationsDone() bool {
	if len(mmClose.expectations) == 0 && mmClose.defaultExpectation == nil && mmClose.mock.funcClose == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClose.mock.afterCloseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClose.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Close implements mm_ai.Provider
func (mmClose *ProviderMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	mmClose.t.Helper()

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the ProviderMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to ProviderMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished ProviderMock.Close invocations
func (mmClose *ProviderMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of ProviderMock.Close invocations
func (mmClose *ProviderMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *ProviderMock) MinimockCloseDone() bool {
	if m.CloseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CloseMock.invocationsDone()
}

// MinimockCloseInspect logs each unmet expectation
func (m *ProviderMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ProviderMock.Close")
		}
	}

	afterCloseCounter := mm_atomic.LoadUint64(&m.afterCloseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to ProviderMock.Close at\n%s", m.CloseMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to ProviderMock.Close at\n%s", m.funcCloseOrigin)
	}

	if !m.CloseMock.invocationsDone() && afterCloseCounter > 0 {
		m.t.Errorf("Expected %d calls to ProviderMock.Close at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CloseMock.expectedInvocations), m.CloseMock.expectedInvocationsOrigin, afterCloseCounter)
	}
}

type mProviderMockConvertToMarkdown struct {
	optional           bool
	mock               *ProviderMock
	defaultExpectation *ProviderMockConvertToMarkdownExpectation
	expectations       []*ProviderMockConvertToMarkdownExpectation

	callArgs []*ProviderMockConvertToMarkdownParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProviderMockConvertToMarkdownExpectation specifies expectation struct of the Provider.ConvertToMarkdown
type ProviderMockConvertToMarkdownExpectation struct {
	mock               *ProviderMock
	params             *ProviderMockConvertToMarkdownParams
	paramPtrs          *ProviderMockConvertToMarkdownParamPtrs
	expectationOrigins ProviderMockConvertToMarkdownExpectationOrigins
	results            *ProviderMockConvertToMarkdownResults
	returnOrigin       string
	Counter            uint64
}

// ProviderMockConvertToMarkdownParams contains parameters of the Provider.ConvertToMarkdown
type ProviderMockConvertToMarkdownParams struct {
	ctx      context.Context
	content  []byte
	fileType artifactpb.FileType
	filename string
	prompt   string
}

// ProviderMockConvertToMarkdownParamPtrs contains pointers to parameters of the Provider.ConvertToMarkdown
type ProviderMockConvertToMarkdownParamPtrs struct {
	ctx      *context.Context
	content  *[]byte
	fileType *artifactpb.FileType
	filename *string
	prompt   *string
}

// ProviderMockConvertToMarkdownResults contains results of the Provider.ConvertToMarkdown
type ProviderMockConvertToMarkdownResults struct {
	cp1 *mm_ai.ConversionResult
	err error
}

// ProviderMockConvertToMarkdownOrigins contains origins of expectations of the Provider.ConvertToMarkdown
type ProviderMockConvertToMarkdownExpectationOrigins struct {
	origin         string
	originCtx      string
	originContent  string
	originFileType string
	originFilename string
	originPrompt   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConvertToMarkdown *mProviderMockConvertToMarkdown) Optional() *mProviderMockConvertToMarkdown {
	mmConvertToMarkdown.optional = true
	return mmConvertToMarkdown
}

// Expect sets up expected params for Provider.ConvertToMarkdown
func (mmConvertToMarkdown *mProviderMockConvertToMarkdown) Expect(ctx context.Context, content []byte, fileType artifactpb.FileType, filename string, prompt string) *mProviderMockConvertToMarkdown {
	if mmConvertToMarkdown.mock.funcConvertToMarkdown != nil {
		mmConvertToMarkdown.mock.t.Fatalf("ProviderMock.ConvertToMarkdown mock is already set by Set")
	}

	if mmConvertToMarkdown.defaultExpectation == nil {
		mmConvertToMarkdown.defaultExpectation = &ProviderMockConvertToMarkdownExpectation{}
	}

	if mmConvertToMarkdown.defaultExpectation.paramPtrs != nil {
		mmConvertToMarkdown.mock.t.Fatalf("ProviderMock.ConvertToMarkdown mock is already set by ExpectParams functions")
	}

	mmConvertToMarkdown.defaultExpectation.params = &ProviderMockConvertToMarkdownParams{ctx, content, fileType, filename, prompt}
	mmConvertToMarkdown.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmConvertToMarkdown.expectations {
		if minimock.Equal(e.params, mmConvertToMarkdown.defaultExpectation.params) {
			mmConvertToMarkdown.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertToMarkdown.defaultExpectation.params)
		}
	}

	return mmConvertToMarkdown
}

// ExpectCtxParam1 sets up expected param ctx for Provider.ConvertToMarkdown
func (mmConvertToMarkdown *mProviderMockConvertToMarkdown) ExpectCtxParam1(ctx context.Context) *mProviderMockConvertToMarkdown {
	if mmConvertToMarkdown.mock.funcConvertToMarkdown != nil {
		mmConvertToMarkdown.mock.t.Fatalf("ProviderMock.ConvertToMarkdown mock is already set by Set")
	}

	if mmConvertToMarkdown.defaultExpectation == nil {
		mmConvertToMarkdown.defaultExpectation = &ProviderMockConvertToMarkdownExpectation{}
	}

	if mmConvertToMarkdown.defaultExpectation.params != nil {
		mmConvertToMarkdown.mock.t.Fatalf("ProviderMock.ConvertToMarkdown mock is already set by Expect")
	}

	if mmConvertToMarkdown.defaultExpectation.paramPtrs == nil {
		mmConvertToMarkdown.defaultExpectation.paramPtrs = &ProviderMockConvertToMarkdownParamPtrs{}
	}
	mmConvertToMarkdown.defaultExpectation.paramPtrs.ctx = &ctx
	mmConvertToMarkdown.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmConvertToMarkdown
}

// ExpectContentParam2 sets up expected param content for Provider.ConvertToMarkdown
func (mmConvertToMarkdown *mProviderMockConvertToMarkdown) ExpectContentParam2(content []byte) *mProviderMockConvertToMarkdown {
	if mmConvertToMarkdown.mock.funcConvertToMarkdown != nil {
		mmConvertToMarkdown.mock.t.Fatalf("ProviderMock.ConvertToMarkdown mock is already set by Set")
	}

	if mmConvertToMarkdown.defaultExpectation == nil {
		mmConvertToMarkdown.defaultExpectation = &ProviderMockConvertToMarkdownExpectation{}
	}

	if mmConvertToMarkdown.defaultExpectation.params != nil {
		mmConvertToMarkdown.mock.t.Fatalf("ProviderMock.ConvertToMarkdown mock is already set by Expect")
	}

	if mmConvertToMarkdown.defaultExpectation.paramPtrs == nil {
		mmConvertToMarkdown.defaultExpectation.paramPtrs = &ProviderMockConvertToMarkdownParamPtrs{}
	}
	mmConvertToMarkdown.defaultExpectation.paramPtrs.content = &content
	mmConvertToMarkdown.defaultExpectation.expectationOrigins.originContent = minimock.CallerInfo(1)

	return mmConvertToMarkdown
}

// ExpectFileTypeParam3 sets up expected param fileType for Provider.ConvertToMarkdown
func (mmConvertToMarkdown *mProviderMockConvertToMarkdown) ExpectFileTypeParam3(fileType artifactpb.FileType) *mProviderMockConvertToMarkdown {
	if mmConvertToMarkdown.mock.funcConvertToMarkdown != nil {
		mmConvertToMarkdown.mock.t.Fatalf("ProviderMock.ConvertToMarkdown mock is already set by Set")
	}

	if mmConvertToMarkdown.defaultExpectation == nil {
		mmConvertToMarkdown.defaultExpectation = &ProviderMockConvertToMarkdownExpectation{}
	}

	if mmConvertToMarkdown.defaultExpectation.params != nil {
		mmConvertToMarkdown.mock.t.Fatalf("ProviderMock.ConvertToMarkdown mock is already set by Expect")
	}

	if mmConvertToMarkdown.defaultExpectation.paramPtrs == nil {
		mmConvertToMarkdown.defaultExpectation.paramPtrs = &ProviderMockConvertToMarkdownParamPtrs{}
	}
	mmConvertToMarkdown.defaultExpectation.paramPtrs.fileType = &fileType
	mmConvertToMarkdown.defaultExpectation.expectationOrigins.originFileType = minimock.CallerInfo(1)

	return mmConvertToMarkdown
}

// ExpectFilenameParam4 sets up expected param filename for Provider.ConvertToMarkdown
func (mmConvertToMarkdown *mProviderMockConvertToMarkdown) ExpectFilenameParam4(filename string) *mProviderMockConvertToMarkdown {
	if mmConvertToMarkdown.mock.funcConvertToMarkdown != nil {
		mmConvertToMarkdown.mock.t.Fatalf("ProviderMock.ConvertToMarkdown mock is already set by Set")
	}

	if mmConvertToMarkdown.defaultExpectation == nil {
		mmConvertToMarkdown.defaultExpectation = &ProviderMockConvertToMarkdownExpectation{}
	}

	if mmConvertToMarkdown.defaultExpectation.params != nil {
		mmConvertToMarkdown.mock.t.Fatalf("ProviderMock.ConvertToMarkdown mock is already set by Expect")
	}

	if mmConvertToMarkdown.defaultExpectation.paramPtrs == nil {
		mmConvertToMarkdown.defaultExpectation.paramPtrs = &ProviderMockConvertToMarkdownParamPtrs{}
	}
	mmConvertToMarkdown.defaultExpectation.paramPtrs.filename = &filename
	mmConvertToMarkdown.defaultExpectation.expectationOrigins.originFilename = minimock.CallerInfo(1)

	return mmConvertToMarkdown
}

// ExpectPromptParam5 sets up expected param prompt for Provider.ConvertToMarkdown
func (mmConvertToMarkdown *mProviderMockConvertToMarkdown) ExpectPromptParam5(prompt string) *mProviderMockConvertToMarkdown {
	if mmConvertToMarkdown.mock.funcConvertToMarkdown != nil {
		mmConvertToMarkdown.mock.t.Fatalf("ProviderMock.ConvertToMarkdown mock is already set by Set")
	}

	if mmConvertToMarkdown.defaultExpectation == nil {
		mmConvertToMarkdown.defaultExpectation = &ProviderMockConvertToMarkdownExpectation{}
	}

	if mmConvertToMarkdown.defaultExpectation.params != nil {
		mmConvertToMarkdown.mock.t.Fatalf("ProviderMock.ConvertToMarkdown mock is already set by Expect")
	}

	if mmConvertToMarkdown.defaultExpectation.paramPtrs == nil {
		mmConvertToMarkdown.defaultExpectation.paramPtrs = &ProviderMockConvertToMarkdownParamPtrs{}
	}
	mmConvertToMarkdown.defaultExpectation.paramPtrs.prompt = &prompt
	mmConvertToMarkdown.defaultExpectation.expectationOrigins.originPrompt = minimock.CallerInfo(1)

	return mmConvertToMarkdown
}

// Inspect accepts an inspector function that has same arguments as the Provider.ConvertToMarkdown
func (mmConvertToMarkdown *mProviderMockConvertToMarkdown) Inspect(f func(ctx context.Context, content []byte, fileType artifactpb.FileType, filename string, prompt string)) *mProviderMockConvertToMarkdown {
	if mmConvertToMarkdown.mock.inspectFuncConvertToMarkdown != nil {
		mmConvertToMarkdown.mock.t.Fatalf("Inspect function is already set for ProviderMock.ConvertToMarkdown")
	}

	mmConvertToMarkdown.mock.inspectFuncConvertToMarkdown = f

	return mmConvertToMarkdown
}

// Return sets up results that will be returned by Provider.ConvertToMarkdown
func (mmConvertToMarkdown *mProviderMockConvertToMarkdown) Return(cp1 *mm_ai.ConversionResult, err error) *ProviderMock {
	if mmConvertToMarkdown.mock.funcConvertToMarkdown != nil {
		mmConvertToMarkdown.mock.t.Fatalf("ProviderMock.ConvertToMarkdown mock is already set by Set")
	}

	if mmConvertToMarkdown.defaultExpectation == nil {
		mmConvertToMarkdown.defaultExpectation = &ProviderMockConvertToMarkdownExpectation{mock: mmConvertToMarkdown.mock}
	}
	mmConvertToMarkdown.defaultExpectation.results = &ProviderMockConvertToMarkdownResults{cp1, err}
	mmConvertToMarkdown.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmConvertToMarkdown.mock
}

// Set uses given function f to mock the Provider.ConvertToMarkdown method
func (mmConvertToMarkdown *mProviderMockConvertToMarkdown) Set(f func(ctx context.Context, content []byte, fileType artifactpb.FileType, filename string, prompt string) (cp1 *mm_ai.ConversionResult, err error)) *ProviderMock {
	if mmConvertToMarkdown.defaultExpectation != nil {
		mmConvertToMarkdown.mock.t.Fatalf("Default expectation is already set for the Provider.ConvertToMarkdown method")
	}

	if len(mmConvertToMarkdown.expectations) > 0 {
		mmConvertToMarkdown.mock.t.Fatalf("Some expectations are already set for the Provider.ConvertToMarkdown method")
	}

	mmConvertToMarkdown.mock.funcConvertToMarkdown = f
	mmConvertToMarkdown.mock.funcConvertToMarkdownOrigin = minimock.CallerInfo(1)
	return mmConvertToMarkdown.mock
}

// When sets expectation for the Provider.ConvertToMarkdown which will trigger the result defined by the following
// Then helper
func (mmConvertToMarkdown *mProviderMockConvertToMarkdown) When(ctx context.Context, content []byte, fileType artifactpb.FileType, filename string, prompt string) *ProviderMockConvertToMarkdownExpectation {
	if mmConvertToMarkdown.mock.funcConvertToMarkdown != nil {
		mmConvertToMarkdown.mock.t.Fatalf("ProviderMock.ConvertToMarkdown mock is already set by Set")
	}

	expectation := &ProviderMockConvertToMarkdownExpectation{
		mock:               mmConvertToMarkdown.mock,
		params:             &ProviderMockConvertToMarkdownParams{ctx, content, fileType, filename, prompt},
		expectationOrigins: ProviderMockConvertToMarkdownExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmConvertToMarkdown.expectations = append(mmConvertToMarkdown.expectations, expectation)
	return expectation
}

// Then sets up Provider.ConvertToMarkdown return parameters for the expectation previously defined by the When method
func (e *ProviderMockConvertToMarkdownExpectation) Then(cp1 *mm_ai.ConversionResult, err error) *ProviderMock {
	e.results = &ProviderMockConvertToMarkdownResults{cp1, err}
	return e.mock
}

// Times sets number of times Provider.ConvertToMarkdown should be invoked
func (mmConvertToMarkdown *mProviderMockConvertToMarkdown) Times(n uint64) *mProviderMockConvertToMarkdown {
	if n == 0 {
		mmConvertToMarkdown.mock.t.Fatalf("Times of ProviderMock.ConvertToMarkdown mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertToMarkdown.expectedInvocations, n)
	mmConvertToMarkdown.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmConvertToMarkdown
}

func (mmConvertToMarkdown *mProviderMockConvertToMarkdown) invocationsDone() bool {
	if len(mmConvertToMarkdown.expectations) == 0 && mmConvertToMarkdown.defaultExpectation == nil && mmConvertToMarkdown.mock.funcConvertToMarkdown == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertToMarkdown.mock.afterConvertToMarkdownCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertToMarkdown.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertToMarkdown implements mm_ai.Provider
func (mmConvertToMarkdown *ProviderMock) ConvertToMarkdown(ctx context.Context, content []byte, fileType artifactpb.FileType, filename string, prompt string) (cp1 *mm_ai.ConversionResult, err error) {
	mm_atomic.AddUint64(&mmConvertToMarkdown.beforeConvertToMarkdownCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertToMarkdown.afterConvertToMarkdownCounter, 1)

	mmConvertToMarkdown.t.Helper()

	if mmConvertToMarkdown.inspectFuncConvertToMarkdown != nil {
		mmConvertToMarkdown.inspectFuncConvertToMarkdown(ctx, content, fileType, filename, prompt)
	}

	mm_params := ProviderMockConvertToMarkdownParams{ctx, content, fileType, filename, prompt}

	// Record call args
	mmConvertToMarkdown.ConvertToMarkdownMock.mutex.Lock()
	mmConvertToMarkdown.ConvertToMarkdownMock.callArgs = append(mmConvertToMarkdown.ConvertToMarkdownMock.callArgs, &mm_params)
	mmConvertToMarkdown.ConvertToMarkdownMock.mutex.Unlock()

	for _, e := range mmConvertToMarkdown.ConvertToMarkdownMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmConvertToMarkdown.ConvertToMarkdownMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertToMarkdown.ConvertToMarkdownMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertToMarkdown.ConvertToMarkdownMock.defaultExpectation.params
		mm_want_ptrs := mmConvertToMarkdown.ConvertToMarkdownMock.defaultExpectation.paramPtrs

		mm_got := ProviderMockConvertToMarkdownParams{ctx, content, fileType, filename, prompt}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConvertToMarkdown.t.Errorf("ProviderMock.ConvertToMarkdown got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertToMarkdown.ConvertToMarkdownMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.content != nil && !minimock.Equal(*mm_want_ptrs.content, mm_got.content) {
				mmConvertToMarkdown.t.Errorf("ProviderMock.ConvertToMarkdown got unexpected parameter content, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertToMarkdown.ConvertToMarkdownMock.defaultExpectation.expectationOrigins.originContent, *mm_want_ptrs.content, mm_got.content, minimock.Diff(*mm_want_ptrs.content, mm_got.content))
			}

			if mm_want_ptrs.fileType != nil && !minimock.Equal(*mm_want_ptrs.fileType, mm_got.fileType) {
				mmConvertToMarkdown.t.Errorf("ProviderMock.ConvertToMarkdown got unexpected parameter fileType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertToMarkdown.ConvertToMarkdownMock.defaultExpectation.expectationOrigins.originFileType, *mm_want_ptrs.fileType, mm_got.fileType, minimock.Diff(*mm_want_ptrs.fileType, mm_got.fileType))
			}

			if mm_want_ptrs.filename != nil && !minimock.Equal(*mm_want_ptrs.filename, mm_got.filename) {
				mmConvertToMarkdown.t.Errorf("ProviderMock.ConvertToMarkdown got unexpected parameter filename, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertToMarkdown.ConvertToMarkdownMock.defaultExpectation.expectationOrigins.originFilename, *mm_want_ptrs.filename, mm_got.filename, minimock.Diff(*mm_want_ptrs.filename, mm_got.filename))
			}

			if mm_want_ptrs.prompt != nil && !minimock.Equal(*mm_want_ptrs.prompt, mm_got.prompt) {
				mmConvertToMarkdown.t.Errorf("ProviderMock.ConvertToMarkdown got unexpected parameter prompt, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertToMarkdown.ConvertToMarkdownMock.defaultExpectation.expectationOrigins.originPrompt, *mm_want_ptrs.prompt, mm_got.prompt, minimock.Diff(*mm_want_ptrs.prompt, mm_got.prompt))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertToMarkdown.t.Errorf("ProviderMock.ConvertToMarkdown got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmConvertToMarkdown.ConvertToMarkdownMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertToMarkdown.ConvertToMarkdownMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertToMarkdown.t.Fatal("No results are set for the ProviderMock.ConvertToMarkdown")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmConvertToMarkdown.funcConvertToMarkdown != nil {
		return mmConvertToMarkdown.funcConvertToMarkdown(ctx, content, fileType, filename, prompt)
	}
	mmConvertToMarkdown.t.Fatalf("Unexpected call to ProviderMock.ConvertToMarkdown. %v %v %v %v %v", ctx, content, fileType, filename, prompt)
	return
}

// ConvertToMarkdownAfterCounter returns a count of finished ProviderMock.ConvertToMarkdown invocations
func (mmConvertToMarkdown *ProviderMock) ConvertToMarkdownAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertToMarkdown.afterConvertToMarkdownCounter)
}

// ConvertToMarkdownBeforeCounter returns a count of ProviderMock.ConvertToMarkdown invocations
func (mmConvertToMarkdown *ProviderMock) ConvertToMarkdownBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertToMarkdown.beforeConvertToMarkdownCounter)
}

// Calls returns a list of arguments used in each call to ProviderMock.ConvertToMarkdown.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertToMarkdown *mProviderMockConvertToMarkdown) Calls() []*ProviderMockConvertToMarkdownParams {
	mmConvertToMarkdown.mutex.RLock()

	argCopy := make([]*ProviderMockConvertToMarkdownParams, len(mmConvertToMarkdown.callArgs))
	copy(argCopy, mmConvertToMarkdown.callArgs)

	mmConvertToMarkdown.mutex.RUnlock()

	return argCopy
}

// MinimockConvertToMarkdownDone returns true if the count of the ConvertToMarkdown invocations corresponds
// the number of defined expectations
func (m *ProviderMock) MinimockConvertToMarkdownDone() bool {
	if m.ConvertToMarkdownMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConvertToMarkdownMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertToMarkdownMock.invocationsDone()
}

// MinimockConvertToMarkdownInspect logs each unmet expectation
func (m *ProviderMock) MinimockConvertToMarkdownInspect() {
	for _, e := range m.ConvertToMarkdownMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProviderMock.ConvertToMarkdown at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterConvertToMarkdownCounter := mm_atomic.LoadUint64(&m.afterConvertToMarkdownCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertToMarkdownMock.defaultExpectation != nil && afterConvertToMarkdownCounter < 1 {
		if m.ConvertToMarkdownMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ProviderMock.ConvertToMarkdown at\n%s", m.ConvertToMarkdownMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ProviderMock.ConvertToMarkdown at\n%s with params: %#v", m.ConvertToMarkdownMock.defaultExpectation.expectationOrigins.origin, *m.ConvertToMarkdownMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertToMarkdown != nil && afterConvertToMarkdownCounter < 1 {
		m.t.Errorf("Expected call to ProviderMock.ConvertToMarkdown at\n%s", m.funcConvertToMarkdownOrigin)
	}

	if !m.ConvertToMarkdownMock.invocationsDone() && afterConvertToMarkdownCounter > 0 {
		m.t.Errorf("Expected %d calls to ProviderMock.ConvertToMarkdown at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertToMarkdownMock.expectedInvocations), m.ConvertToMarkdownMock.expectedInvocationsOrigin, afterConvertToMarkdownCounter)
	}
}

type mProviderMockConvertToMarkdownWithCache struct {
	optional           bool
	mock               *ProviderMock
	defaultExpectation *ProviderMockConvertToMarkdownWithCacheExpectation
	expectations       []*ProviderMockConvertToMarkdownWithCacheExpectation

	callArgs []*ProviderMockConvertToMarkdownWithCacheParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProviderMockConvertToMarkdownWithCacheExpectation specifies expectation struct of the Provider.ConvertToMarkdownWithCache
type ProviderMockConvertToMarkdownWithCacheExpectation struct {
	mock               *ProviderMock
	params             *ProviderMockConvertToMarkdownWithCacheParams
	paramPtrs          *ProviderMockConvertToMarkdownWithCacheParamPtrs
	expectationOrigins ProviderMockConvertToMarkdownWithCacheExpectationOrigins
	results            *ProviderMockConvertToMarkdownWithCacheResults
	returnOrigin       string
	Counter            uint64
}

// ProviderMockConvertToMarkdownWithCacheParams contains parameters of the Provider.ConvertToMarkdownWithCache
type ProviderMockConvertToMarkdownWithCacheParams struct {
	ctx       context.Context
	cacheName string
	prompt    string
}

// ProviderMockConvertToMarkdownWithCacheParamPtrs contains pointers to parameters of the Provider.ConvertToMarkdownWithCache
type ProviderMockConvertToMarkdownWithCacheParamPtrs struct {
	ctx       *context.Context
	cacheName *string
	prompt    *string
}

// ProviderMockConvertToMarkdownWithCacheResults contains results of the Provider.ConvertToMarkdownWithCache
type ProviderMockConvertToMarkdownWithCacheResults struct {
	cp1 *mm_ai.ConversionResult
	err error
}

// ProviderMockConvertToMarkdownWithCacheOrigins contains origins of expectations of the Provider.ConvertToMarkdownWithCache
type ProviderMockConvertToMarkdownWithCacheExpectationOrigins struct {
	origin          string
	originCtx       string
	originCacheName string
	originPrompt    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConvertToMarkdownWithCache *mProviderMockConvertToMarkdownWithCache) Optional() *mProviderMockConvertToMarkdownWithCache {
	mmConvertToMarkdownWithCache.optional = true
	return mmConvertToMarkdownWithCache
}

// Expect sets up expected params for Provider.ConvertToMarkdownWithCache
func (mmConvertToMarkdownWithCache *mProviderMockConvertToMarkdownWithCache) Expect(ctx context.Context, cacheName string, prompt string) *mProviderMockConvertToMarkdownWithCache {
	if mmConvertToMarkdownWithCache.mock.funcConvertToMarkdownWithCache != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithCache mock is already set by Set")
	}

	if mmConvertToMarkdownWithCache.defaultExpectation == nil {
		mmConvertToMarkdownWithCache.defaultExpectation = &ProviderMockConvertToMarkdownWithCacheExpectation{}
	}

	if mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithCache mock is already set by ExpectParams functions")
	}

	mmConvertToMarkdownWithCache.defaultExpectation.params = &ProviderMockConvertToMarkdownWithCacheParams{ctx, cacheName, prompt}
	mmConvertToMarkdownWithCache.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmConvertToMarkdownWithCache.expectations {
		if minimock.Equal(e.params, mmConvertToMarkdownWithCache.defaultExpectation.params) {
			mmConvertToMarkdownWithCache.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertToMarkdownWithCache.defaultExpectation.params)
		}
	}

	return mmConvertToMarkdownWithCache
}

// ExpectCtxParam1 sets up expected param ctx for Provider.ConvertToMarkdownWithCache
func (mmConvertToMarkdownWithCache *mProviderMockConvertToMarkdownWithCache) ExpectCtxParam1(ctx context.Context) *mProviderMockConvertToMarkdownWithCache {
	if mmConvertToMarkdownWithCache.mock.funcConvertToMarkdownWithCache != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithCache mock is already set by Set")
	}

	if mmConvertToMarkdownWithCache.defaultExpectation == nil {
		mmConvertToMarkdownWithCache.defaultExpectation = &ProviderMockConvertToMarkdownWithCacheExpectation{}
	}

	if mmConvertToMarkdownWithCache.defaultExpectation.params != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithCache mock is already set by Expect")
	}

	if mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs == nil {
		mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs = &ProviderMockConvertToMarkdownWithCacheParamPtrs{}
	}
	mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs.ctx = &ctx
	mmConvertToMarkdownWithCache.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmConvertToMarkdownWithCache
}

// ExpectCacheNameParam2 sets up expected param cacheName for Provider.ConvertToMarkdownWithCache
func (mmConvertToMarkdownWithCache *mProviderMockConvertToMarkdownWithCache) ExpectCacheNameParam2(cacheName string) *mProviderMockConvertToMarkdownWithCache {
	if mmConvertToMarkdownWithCache.mock.funcConvertToMarkdownWithCache != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithCache mock is already set by Set")
	}

	if mmConvertToMarkdownWithCache.defaultExpectation == nil {
		mmConvertToMarkdownWithCache.defaultExpectation = &ProviderMockConvertToMarkdownWithCacheExpectation{}
	}

	if mmConvertToMarkdownWithCache.defaultExpectation.params != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithCache mock is already set by Expect")
	}

	if mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs == nil {
		mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs = &ProviderMockConvertToMarkdownWithCacheParamPtrs{}
	}
	mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs.cacheName = &cacheName
	mmConvertToMarkdownWithCache.defaultExpectation.expectationOrigins.originCacheName = minimock.CallerInfo(1)

	return mmConvertToMarkdownWithCache
}

// ExpectPromptParam3 sets up expected param prompt for Provider.ConvertToMarkdownWithCache
func (mmConvertToMarkdownWithCache *mProviderMockConvertToMarkdownWithCache) ExpectPromptParam3(prompt string) *mProviderMockConvertToMarkdownWithCache {
	if mmConvertToMarkdownWithCache.mock.funcConvertToMarkdownWithCache != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithCache mock is already set by Set")
	}

	if mmConvertToMarkdownWithCache.defaultExpectation == nil {
		mmConvertToMarkdownWithCache.defaultExpectation = &ProviderMockConvertToMarkdownWithCacheExpectation{}
	}

	if mmConvertToMarkdownWithCache.defaultExpectation.params != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithCache mock is already set by Expect")
	}

	if mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs == nil {
		mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs = &ProviderMockConvertToMarkdownWithCacheParamPtrs{}
	}
	mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs.prompt = &prompt
	mmConvertToMarkdownWithCache.defaultExpectation.expectationOrigins.originPrompt = minimock.CallerInfo(1)

	return mmConvertToMarkdownWithCache
}

// Inspect accepts an inspector function that has same arguments as the Provider.ConvertToMarkdownWithCache
func (mmConvertToMarkdownWithCache *mProviderMockConvertToMarkdownWithCache) Inspect(f func(ctx context.Context, cacheName string, prompt string)) *mProviderMockConvertToMarkdownWithCache {
	if mmConvertToMarkdownWithCache.mock.inspectFuncConvertToMarkdownWithCache != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("Inspect function is already set for ProviderMock.ConvertToMarkdownWithCache")
	}

	mmConvertToMarkdownWithCache.mock.inspectFuncConvertToMarkdownWithCache = f

	return mmConvertToMarkdownWithCache
}

// Return sets up results that will be returned by Provider.ConvertToMarkdownWithCache
func (mmConvertToMarkdownWithCache *mProviderMockConvertToMarkdownWithCache) Return(cp1 *mm_ai.ConversionResult, err error) *ProviderMock {
	if mmConvertToMarkdownWithCache.mock.funcConvertToMarkdownWithCache != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithCache mock is already set by Set")
	}

	if mmConvertToMarkdownWithCache.defaultExpectation == nil {
		mmConvertToMarkdownWithCache.defaultExpectation = &ProviderMockConvertToMarkdownWithCacheExpectation{mock: mmConvertToMarkdownWithCache.mock}
	}
	mmConvertToMarkdownWithCache.defaultExpectation.results = &ProviderMockConvertToMarkdownWithCacheResults{cp1, err}
	mmConvertToMarkdownWithCache.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmConvertToMarkdownWithCache.mock
}

// Set uses given function f to mock the Provider.ConvertToMarkdownWithCache method
func (mmConvertToMarkdownWithCache *mProviderMockConvertToMarkdownWithCache) Set(f func(ctx context.Context, cacheName string, prompt string) (cp1 *mm_ai.ConversionResult, err error)) *ProviderMock {
	if mmConvertToMarkdownWithCache.defaultExpectation != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("Default expectation is already set for the Provider.ConvertToMarkdownWithCache method")
	}

	if len(mmConvertToMarkdownWithCache.expectations) > 0 {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("Some expectations are already set for the Provider.ConvertToMarkdownWithCache method")
	}

	mmConvertToMarkdownWithCache.mock.funcConvertToMarkdownWithCache = f
	mmConvertToMarkdownWithCache.mock.funcConvertToMarkdownWithCacheOrigin = minimock.CallerInfo(1)
	return mmConvertToMarkdownWithCache.mock
}

// When sets expectation for the Provider.ConvertToMarkdownWithCache which will trigger the result defined by the following
// Then helper
func (mmConvertToMarkdownWithCache *mProviderMockConvertToMarkdownWithCache) When(ctx context.Context, cacheName string, prompt string) *ProviderMockConvertToMarkdownWithCacheExpectation {
	if mmConvertToMarkdownWithCache.mock.funcConvertToMarkdownWithCache != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithCache mock is already set by Set")
	}

	expectation := &ProviderMockConvertToMarkdownWithCacheExpectation{
		mock:               mmConvertToMarkdownWithCache.mock,
		params:             &ProviderMockConvertToMarkdownWithCacheParams{ctx, cacheName, prompt},
		expectationOrigins: ProviderMockConvertToMarkdownWithCacheExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmConvertToMarkdownWithCache.expectations = append(mmConvertToMarkdownWithCache.expectations, expectation)
	return expectation
}

// Then sets up Provider.ConvertToMarkdownWithCache return parameters for the expectation previously defined by the When method
func (e *ProviderMockConvertToMarkdownWithCacheExpectation) Then(cp1 *mm_ai.ConversionResult, err error) *ProviderMock {
	e.results = &ProviderMockConvertToMarkdownWithCacheResults{cp1, err}
	return e.mock
}

// Times sets number of times Provider.ConvertToMarkdownWithCache should be invoked
func (mmConvertToMarkdownWithCache *mProviderMockConvertToMarkdownWithCache) Times(n uint64) *mProviderMockConvertToMarkdownWithCache {
	if n == 0 {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("Times of ProviderMock.ConvertToMarkdownWithCache mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertToMarkdownWithCache.expectedInvocations, n)
	mmConvertToMarkdownWithCache.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmConvertToMarkdownWithCache
}

func (mmConvertToMarkdownWithCache *mProviderMockConvertToMarkdownWithCache) invocationsDone() bool {
	if len(mmConvertToMarkdownWithCache.expectations) == 0 && mmConvertToMarkdownWithCache.defaultExpectation == nil && mmConvertToMarkdownWithCache.mock.funcConvertToMarkdownWithCache == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertToMarkdownWithCache.mock.afterConvertToMarkdownWithCacheCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertToMarkdownWithCache.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertToMarkdownWithCache implements mm_ai.Provider
func (mmConvertToMarkdownWithCache *ProviderMock) ConvertToMarkdownWithCache(ctx context.Context, cacheName string, prompt string) (cp1 *mm_ai.ConversionResult, err error) {
	mm_atomic.AddUint64(&mmConvertToMarkdownWithCache.beforeConvertToMarkdownWithCacheCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertToMarkdownWithCache.afterConvertToMarkdownWithCacheCounter, 1)

	mmConvertToMarkdownWithCache.t.Helper()

	if mmConvertToMarkdownWithCache.inspectFuncConvertToMarkdownWithCache != nil {
		mmConvertToMarkdownWithCache.inspectFuncConvertToMarkdownWithCache(ctx, cacheName, prompt)
	}

	mm_params := ProviderMockConvertToMarkdownWithCacheParams{ctx, cacheName, prompt}

	// Record call args
	mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.mutex.Lock()
	mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.callArgs = append(mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.callArgs, &mm_params)
	mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.mutex.Unlock()

	for _, e := range mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.defaultExpectation.params
		mm_want_ptrs := mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.defaultExpectation.paramPtrs

		mm_got := ProviderMockConvertToMarkdownWithCacheParams{ctx, cacheName, prompt}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConvertToMarkdownWithCache.t.Errorf("ProviderMock.ConvertToMarkdownWithCache got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cacheName != nil && !minimock.Equal(*mm_want_ptrs.cacheName, mm_got.cacheName) {
				mmConvertToMarkdownWithCache.t.Errorf("ProviderMock.ConvertToMarkdownWithCache got unexpected parameter cacheName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.defaultExpectation.expectationOrigins.originCacheName, *mm_want_ptrs.cacheName, mm_got.cacheName, minimock.Diff(*mm_want_ptrs.cacheName, mm_got.cacheName))
			}

			if mm_want_ptrs.prompt != nil && !minimock.Equal(*mm_want_ptrs.prompt, mm_got.prompt) {
				mmConvertToMarkdownWithCache.t.Errorf("ProviderMock.ConvertToMarkdownWithCache got unexpected parameter prompt, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.defaultExpectation.expectationOrigins.originPrompt, *mm_want_ptrs.prompt, mm_got.prompt, minimock.Diff(*mm_want_ptrs.prompt, mm_got.prompt))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertToMarkdownWithCache.t.Errorf("ProviderMock.ConvertToMarkdownWithCache got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertToMarkdownWithCache.t.Fatal("No results are set for the ProviderMock.ConvertToMarkdownWithCache")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmConvertToMarkdownWithCache.funcConvertToMarkdownWithCache != nil {
		return mmConvertToMarkdownWithCache.funcConvertToMarkdownWithCache(ctx, cacheName, prompt)
	}
	mmConvertToMarkdownWithCache.t.Fatalf("Unexpected call to ProviderMock.ConvertToMarkdownWithCache. %v %v %v", ctx, cacheName, prompt)
	return
}

// ConvertToMarkdownWithCacheAfterCounter returns a count of finished ProviderMock.ConvertToMarkdownWithCache invocations
func (mmConvertToMarkdownWithCache *ProviderMock) ConvertToMarkdownWithCacheAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertToMarkdownWithCache.afterConvertToMarkdownWithCacheCounter)
}

// ConvertToMarkdownWithCacheBeforeCounter returns a count of ProviderMock.ConvertToMarkdownWithCache invocations
func (mmConvertToMarkdownWithCache *ProviderMock) ConvertToMarkdownWithCacheBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertToMarkdownWithCache.beforeConvertToMarkdownWithCacheCounter)
}

// Calls returns a list of arguments used in each call to ProviderMock.ConvertToMarkdownWithCache.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertToMarkdownWithCache *mProviderMockConvertToMarkdownWithCache) Calls() []*ProviderMockConvertToMarkdownWithCacheParams {
	mmConvertToMarkdownWithCache.mutex.RLock()

	argCopy := make([]*ProviderMockConvertToMarkdownWithCacheParams, len(mmConvertToMarkdownWithCache.callArgs))
	copy(argCopy, mmConvertToMarkdownWithCache.callArgs)

	mmConvertToMarkdownWithCache.mutex.RUnlock()

	return argCopy
}

// MinimockConvertToMarkdownWithCacheDone returns true if the count of the ConvertToMarkdownWithCache invocations corresponds
// the number of defined expectations
func (m *ProviderMock) MinimockConvertToMarkdownWithCacheDone() bool {
	if m.ConvertToMarkdownWithCacheMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConvertToMarkdownWithCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertToMarkdownWithCacheMock.invocationsDone()
}

// MinimockConvertToMarkdownWithCacheInspect logs each unmet expectation
func (m *ProviderMock) MinimockConvertToMarkdownWithCacheInspect() {
	for _, e := range m.ConvertToMarkdownWithCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProviderMock.ConvertToMarkdownWithCache at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterConvertToMarkdownWithCacheCounter := mm_atomic.LoadUint64(&m.afterConvertToMarkdownWithCacheCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertToMarkdownWithCacheMock.defaultExpectation != nil && afterConvertToMarkdownWithCacheCounter < 1 {
		if m.ConvertToMarkdownWithCacheMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ProviderMock.ConvertToMarkdownWithCache at\n%s", m.ConvertToMarkdownWithCacheMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ProviderMock.ConvertToMarkdownWithCache at\n%s with params: %#v", m.ConvertToMarkdownWithCacheMock.defaultExpectation.expectationOrigins.origin, *m.ConvertToMarkdownWithCacheMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertToMarkdownWithCache != nil && afterConvertToMarkdownWithCacheCounter < 1 {
		m.t.Errorf("Expected call to ProviderMock.ConvertToMarkdownWithCache at\n%s", m.funcConvertToMarkdownWithCacheOrigin)
	}

	if !m.ConvertToMarkdownWithCacheMock.invocationsDone() && afterConvertToMarkdownWithCacheCounter > 0 {
		m.t.Errorf("Expected %d calls to ProviderMock.ConvertToMarkdownWithCache at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertToMarkdownWithCacheMock.expectedInvocations), m.ConvertToMarkdownWithCacheMock.expectedInvocationsOrigin, afterConvertToMarkdownWithCacheCounter)
	}
}

type mProviderMockCreateCache struct {
	optional           bool
	mock               *ProviderMock
	defaultExpectation *ProviderMockCreateCacheExpectation
	expectations       []*ProviderMockCreateCacheExpectation

	callArgs []*ProviderMockCreateCacheParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProviderMockCreateCacheExpectation specifies expectation struct of the Provider.CreateCache
type ProviderMockCreateCacheExpectation struct {
	mock               *ProviderMock
	params             *ProviderMockCreateCacheParams
	paramPtrs          *ProviderMockCreateCacheParamPtrs
	expectationOrigins ProviderMockCreateCacheExpectationOrigins
	results            *ProviderMockCreateCacheResults
	returnOrigin       string
	Counter            uint64
}

// ProviderMockCreateCacheParams contains parameters of the Provider.CreateCache
type ProviderMockCreateCacheParams struct {
	ctx      context.Context
	content  []byte
	fileType artifactpb.FileType
	filename string
	ttl      time.Duration
}

// ProviderMockCreateCacheParamPtrs contains pointers to parameters of the Provider.CreateCache
type ProviderMockCreateCacheParamPtrs struct {
	ctx      *context.Context
	content  *[]byte
	fileType *artifactpb.FileType
	filename *string
	ttl      *time.Duration
}

// ProviderMockCreateCacheResults contains results of the Provider.CreateCache
type ProviderMockCreateCacheResults struct {
	cp1 *mm_ai.CacheResult
	err error
}

// ProviderMockCreateCacheOrigins contains origins of expectations of the Provider.CreateCache
type ProviderMockCreateCacheExpectationOrigins struct {
	origin         string
	originCtx      string
	originContent  string
	originFileType string
	originFilename string
	originTtl      string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateCache *mProviderMockCreateCache) Optional() *mProviderMockCreateCache {
	mmCreateCache.optional = true
	return mmCreateCache
}

// Expect sets up expected params for Provider.CreateCache
func (mmCreateCache *mProviderMockCreateCache) Expect(ctx context.Context, content []byte, fileType artifactpb.FileType, filename string, ttl time.Duration) *mProviderMockCreateCache {
	if mmCreateCache.mock.funcCreateCache != nil {
		mmCreateCache.mock.t.Fatalf("ProviderMock.CreateCache mock is already set by Set")
	}

	if mmCreateCache.defaultExpectation == nil {
		mmCreateCache.defaultExpectation = &ProviderMockCreateCacheExpectation{}
	}

	if mmCreateCache.defaultExpectation.paramPtrs != nil {
		mmCreateCache.mock.t.Fatalf("ProviderMock.CreateCache mock is already set by ExpectParams functions")
	}

	mmCreateCache.defaultExpectation.params = &ProviderMockCreateCacheParams{ctx, content, fileType, filename, ttl}
	mmCreateCache.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateCache.expectations {
		if minimock.Equal(e.params, mmCreateCache.defaultExpectation.params) {
			mmCreateCache.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateCache.defaultExpectation.params)
		}
	}

	return mmCreateCache
}

// ExpectCtxParam1 sets up expected param ctx for Provider.CreateCache
func (mmCreateCache *mProviderMockCreateCache) ExpectCtxParam1(ctx context.Context) *mProviderMockCreateCache {
	if mmCreateCache.mock.funcCreateCache != nil {
		mmCreateCache.mock.t.Fatalf("ProviderMock.CreateCache mock is already set by Set")
	}

	if mmCreateCache.defaultExpectation == nil {
		mmCreateCache.defaultExpectation = &ProviderMockCreateCacheExpectation{}
	}

	if mmCreateCache.defaultExpectation.params != nil {
		mmCreateCache.mock.t.Fatalf("ProviderMock.CreateCache mock is already set by Expect")
	}

	if mmCreateCache.defaultExpectation.paramPtrs == nil {
		mmCreateCache.defaultExpectation.paramPtrs = &ProviderMockCreateCacheParamPtrs{}
	}
	mmCreateCache.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateCache.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateCache
}

// ExpectContentParam2 sets up expected param content for Provider.CreateCache
func (mmCreateCache *mProviderMockCreateCache) ExpectContentParam2(content []byte) *mProviderMockCreateCache {
	if mmCreateCache.mock.funcCreateCache != nil {
		mmCreateCache.mock.t.Fatalf("ProviderMock.CreateCache mock is already set by Set")
	}

	if mmCreateCache.defaultExpectation == nil {
		mmCreateCache.defaultExpectation = &ProviderMockCreateCacheExpectation{}
	}

	if mmCreateCache.defaultExpectation.params != nil {
		mmCreateCache.mock.t.Fatalf("ProviderMock.CreateCache mock is already set by Expect")
	}

	if mmCreateCache.defaultExpectation.paramPtrs == nil {
		mmCreateCache.defaultExpectation.paramPtrs = &ProviderMockCreateCacheParamPtrs{}
	}
	mmCreateCache.defaultExpectation.paramPtrs.content = &content
	mmCreateCache.defaultExpectation.expectationOrigins.originContent = minimock.CallerInfo(1)

	return mmCreateCache
}

// ExpectFileTypeParam3 sets up expected param fileType for Provider.CreateCache
func (mmCreateCache *mProviderMockCreateCache) ExpectFileTypeParam3(fileType artifactpb.FileType) *mProviderMockCreateCache {
	if mmCreateCache.mock.funcCreateCache != nil {
		mmCreateCache.mock.t.Fatalf("ProviderMock.CreateCache mock is already set by Set")
	}

	if mmCreateCache.defaultExpectation == nil {
		mmCreateCache.defaultExpectation = &ProviderMockCreateCacheExpectation{}
	}

	if mmCreateCache.defaultExpectation.params != nil {
		mmCreateCache.mock.t.Fatalf("ProviderMock.CreateCache mock is already set by Expect")
	}

	if mmCreateCache.defaultExpectation.paramPtrs == nil {
		mmCreateCache.defaultExpectation.paramPtrs = &ProviderMockCreateCacheParamPtrs{}
	}
	mmCreateCache.defaultExpectation.paramPtrs.fileType = &fileType
	mmCreateCache.defaultExpectation.expectationOrigins.originFileType = minimock.CallerInfo(1)

	return mmCreateCache
}

// ExpectFilenameParam4 sets up expected param filename for Provider.CreateCache
func (mmCreateCache *mProviderMockCreateCache) ExpectFilenameParam4(filename string) *mProviderMockCreateCache {
	if mmCreateCache.mock.funcCreateCache != nil {
		mmCreateCache.mock.t.Fatalf("ProviderMock.CreateCache mock is already set by Set")
	}

	if mmCreateCache.defaultExpectation == nil {
		mmCreateCache.defaultExpectation = &ProviderMockCreateCacheExpectation{}
	}

	if mmCreateCache.defaultExpectation.params != nil {
		mmCreateCache.mock.t.Fatalf("ProviderMock.CreateCache mock is already set by Expect")
	}

	if mmCreateCache.defaultExpectation.paramPtrs == nil {
		mmCreateCache.defaultExpectation.paramPtrs = &ProviderMockCreateCacheParamPtrs{}
	}
	mmCreateCache.defaultExpectation.paramPtrs.filename = &filename
	mmCreateCache.defaultExpectation.expectationOrigins.originFilename = minimock.CallerInfo(1)

	return mmCreateCache
}

// ExpectTtlParam5 sets up expected param ttl for Provider.CreateCache
func (mmCreateCache *mProviderMockCreateCache) ExpectTtlParam5(ttl time.Duration) *mProviderMockCreateCache {
	if mmCreateCache.mock.funcCreateCache != nil {
		mmCreateCache.mock.t.Fatalf("ProviderMock.CreateCache mock is already set by Set")
	}

	if mmCreateCache.defaultExpectation == nil {
		mmCreateCache.defaultExpectation = &ProviderMockCreateCacheExpectation{}
	}

	if mmCreateCache.defaultExpectation.params != nil {
		mmCreateCache.mock.t.Fatalf("ProviderMock.CreateCache mock is already set by Expect")
	}

	if mmCreateCache.defaultExpectation.paramPtrs == nil {
		mmCreateCache.defaultExpectation.paramPtrs = &ProviderMockCreateCacheParamPtrs{}
	}
	mmCreateCache.defaultExpectation.paramPtrs.ttl = &ttl
	mmCreateCache.defaultExpectation.expectationOrigins.originTtl = minimock.CallerInfo(1)

	return mmCreateCache
}

// Inspect accepts an inspector function that has same arguments as the Provider.CreateCache
func (mmCreateCache *mProviderMockCreateCache) Inspect(f func(ctx context.Context, content []byte, fileType artifactpb.FileType, filename string, ttl time.Duration)) *mProviderMockCreateCache {
	if mmCreateCache.mock.inspectFuncCreateCache != nil {
		mmCreateCache.mock.t.Fatalf("Inspect function is already set for ProviderMock.CreateCache")
	}

	mmCreateCache.mock.inspectFuncCreateCache = f

	return mmCreateCache
}

// Return sets up results that will be returned by Provider.CreateCache
func (mmCreateCache *mProviderMockCreateCache) Return(cp1 *mm_ai.CacheResult, err error) *ProviderMock {
	if mmCreateCache.mock.funcCreateCache != nil {
		mmCreateCache.mock.t.Fatalf("ProviderMock.CreateCache mock is already set by Set")
	}

	if mmCreateCache.defaultExpectation == nil {
		mmCreateCache.defaultExpectation = &ProviderMockCreateCacheExpectation{mock: mmCreateCache.mock}
	}
	mmCreateCache.defaultExpectation.results = &ProviderMockCreateCacheResults{cp1, err}
	mmCreateCache.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateCache.mock
}

// Set uses given function f to mock the Provider.CreateCache method
func (mmCreateCache *mProviderMockCreateCache) Set(f func(ctx context.Context, content []byte, fileType artifactpb.FileType, filename string, ttl time.Duration) (cp1 *mm_ai.CacheResult, err error)) *ProviderMock {
	if mmCreateCache.defaultExpectation != nil {
		mmCreateCache.mock.t.Fatalf("Default expectation is already set for the Provider.CreateCache method")
	}

	if len(mmCreateCache.expectations) > 0 {
		mmCreateCache.mock.t.Fatalf("Some expectations are already set for the Provider.CreateCache method")
	}

	mmCreateCache.mock.funcCreateCache = f
	mmCreateCache.mock.funcCreateCacheOrigin = minimock.CallerInfo(1)
	return mmCreateCache.mock
}

// When sets expectation for the Provider.CreateCache which will trigger the result defined by the following
// Then helper
func (mmCreateCache *mProviderMockCreateCache) When(ctx context.Context, content []byte, fileType artifactpb.FileType, filename string, ttl time.Duration) *ProviderMockCreateCacheExpectation {
	if mmCreateCache.mock.funcCreateCache != nil {
		mmCreateCache.mock.t.Fatalf("ProviderMock.CreateCache mock is already set by Set")
	}

	expectation := &ProviderMockCreateCacheExpectation{
		mock:               mmCreateCache.mock,
		params:             &ProviderMockCreateCacheParams{ctx, content, fileType, filename, ttl},
		expectationOrigins: ProviderMockCreateCacheExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateCache.expectations = append(mmCreateCache.expectations, expectation)
	return expectation
}

// Then sets up Provider.CreateCache return parameters for the expectation previously defined by the When method
func (e *ProviderMockCreateCacheExpectation) Then(cp1 *mm_ai.CacheResult, err error) *ProviderMock {
	e.results = &ProviderMockCreateCacheResults{cp1, err}
	return e.mock
}

// Times sets number of times Provider.CreateCache should be invoked
func (mmCreateCache *mProviderMockCreateCache) Times(n uint64) *mProviderMockCreateCache {
	if n == 0 {
		mmCreateCache.mock.t.Fatalf("Times of ProviderMock.CreateCache mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateCache.expectedInvocations, n)
	mmCreateCache.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateCache
}

func (mmCreateCache *mProviderMockCreateCache) invocationsDone() bool {
	if len(mmCreateCache.expectations) == 0 && mmCreateCache.defaultExpectation == nil && mmCreateCache.mock.funcCreateCache == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateCache.mock.afterCreateCacheCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateCache.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateCache implements mm_ai.Provider
func (mmCreateCache *ProviderMock) CreateCache(ctx context.Context, content []byte, fileType artifactpb.FileType, filename string, ttl time.Duration) (cp1 *mm_ai.CacheResult, err error) {
	mm_atomic.AddUint64(&mmCreateCache.beforeCreateCacheCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateCache.afterCreateCacheCounter, 1)

	mmCreateCache.t.Helper()

	if mmCreateCache.inspectFuncCreateCache != nil {
		mmCreateCache.inspectFuncCreateCache(ctx, content, fileType, filename, ttl)
	}

	mm_params := ProviderMockCreateCacheParams{ctx, content, fileType, filename, ttl}

	// Record call args
	mmCreateCache.CreateCacheMock.mutex.Lock()
	mmCreateCache.CreateCacheMock.callArgs = append(mmCreateCache.CreateCacheMock.callArgs, &mm_params)
	mmCreateCache.CreateCacheMock.mutex.Unlock()

	for _, e := range mmCreateCache.CreateCacheMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCreateCache.CreateCacheMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateCache.CreateCacheMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateCache.CreateCacheMock.defaultExpectation.params
		mm_want_ptrs := mmCreateCache.CreateCacheMock.defaultExpectation.paramPtrs

		mm_got := ProviderMockCreateCacheParams{ctx, content, fileType, filename, ttl}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateCache.t.Errorf("ProviderMock.CreateCache got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCache.CreateCacheMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.content != nil && !minimock.Equal(*mm_want_ptrs.content, mm_got.content) {
				mmCreateCache.t.Errorf("ProviderMock.CreateCache got unexpected parameter content, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCache.CreateCacheMock.defaultExpectation.expectationOrigins.originContent, *mm_want_ptrs.content, mm_got.content, minimock.Diff(*mm_want_ptrs.content, mm_got.content))
			}

			if mm_want_ptrs.fileType != nil && !minimock.Equal(*mm_want_ptrs.fileType, mm_got.fileType) {
				mmCreateCache.t.Errorf("ProviderMock.CreateCache got unexpected parameter fileType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCache.CreateCacheMock.defaultExpectation.expectationOrigins.originFileType, *mm_want_ptrs.fileType, mm_got.fileType, minimock.Diff(*mm_want_ptrs.fileType, mm_got.fileType))
			}

			if mm_want_ptrs.filename != nil && !minimock.Equal(*mm_want_ptrs.filename, mm_got.filename) {
				mmCreateCache.t.Errorf("ProviderMock.CreateCache got unexpected parameter filename, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCache.CreateCacheMock.defaultExpectation.expectationOrigins.originFilename, *mm_want_ptrs.filename, mm_got.filename, minimock.Diff(*mm_want_ptrs.filename, mm_got.filename))
			}

			if mm_want_ptrs.ttl != nil && !minimock.Equal(*mm_want_ptrs.ttl, mm_got.ttl) {
				mmCreateCache.t.Errorf("ProviderMock.CreateCache got unexpected parameter ttl, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCache.CreateCacheMock.defaultExpectation.expectationOrigins.originTtl, *mm_want_ptrs.ttl, mm_got.ttl, minimock.Diff(*mm_want_ptrs.ttl, mm_got.ttl))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateCache.t.Errorf("ProviderMock.CreateCache got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateCache.CreateCacheMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateCache.CreateCacheMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateCache.t.Fatal("No results are set for the ProviderMock.CreateCache")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCreateCache.funcCreateCache != nil {
		return mmCreateCache.funcCreateCache(ctx, content, fileType, filename, ttl)
	}
	mmCreateCache.t.Fatalf("Unexpected call to ProviderMock.CreateCache. %v %v %v %v %v", ctx, content, fileType, filename, ttl)
	return
}

// CreateCacheAfterCounter returns a count of finished ProviderMock.CreateCache invocations
func (mmCreateCache *ProviderMock) CreateCacheAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCache.afterCreateCacheCounter)
}

// CreateCacheBeforeCounter returns a count of ProviderMock.CreateCache invocations
func (mmCreateCache *ProviderMock) CreateCacheBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCache.beforeCreateCacheCounter)
}

// Calls returns a list of arguments used in each call to ProviderMock.CreateCache.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateCache *mProviderMockCreateCache) Calls() []*ProviderMockCreateCacheParams {
	mmCreateCache.mutex.RLock()

	argCopy := make([]*ProviderMockCreateCacheParams, len(mmCreateCache.callArgs))
	copy(argCopy, mmCreateCache.callArgs)

	mmCreateCache.mutex.RUnlock()

	return argCopy
}

// MinimockCreateCacheDone returns true if the count of the CreateCache invocations corresponds
// the number of defined expectations
func (m *ProviderMock) MinimockCreateCacheDone() bool {
	if m.CreateCacheMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateCacheMock.invocationsDone()
}

// MinimockCreateCacheInspect logs each unmet expectation
func (m *ProviderMock) MinimockCreateCacheInspect() {
	for _, e := range m.CreateCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProviderMock.CreateCache at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCacheCounter := mm_atomic.LoadUint64(&m.afterCreateCacheCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateCacheMock.defaultExpectation != nil && afterCreateCacheCounter < 1 {
		if m.CreateCacheMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ProviderMock.CreateCache at\n%s", m.CreateCacheMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ProviderMock.CreateCache at\n%s with params: %#v", m.CreateCacheMock.defaultExpectation.expectationOrigins.origin, *m.CreateCacheMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateCache != nil && afterCreateCacheCounter < 1 {
		m.t.Errorf("Expected call to ProviderMock.CreateCache at\n%s", m.funcCreateCacheOrigin)
	}

	if !m.CreateCacheMock.invocationsDone() && afterCreateCacheCounter > 0 {
		m.t.Errorf("Expected %d calls to ProviderMock.CreateCache at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateCacheMock.expectedInvocations), m.CreateCacheMock.expectedInvocationsOrigin, afterCreateCacheCounter)
	}
}

type mProviderMockDeleteCache struct {
	optional           bool
	mock               *ProviderMock
	defaultExpectation *ProviderMockDeleteCacheExpectation
	expectations       []*ProviderMockDeleteCacheExpectation

	callArgs []*ProviderMockDeleteCacheParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProviderMockDeleteCacheExpectation specifies expectation struct of the Provider.DeleteCache
type ProviderMockDeleteCacheExpectation struct {
	mock               *ProviderMock
	params             *ProviderMockDeleteCacheParams
	paramPtrs          *ProviderMockDeleteCacheParamPtrs
	expectationOrigins ProviderMockDeleteCacheExpectationOrigins
	results            *ProviderMockDeleteCacheResults
	returnOrigin       string
	Counter            uint64
}

// ProviderMockDeleteCacheParams contains parameters of the Provider.DeleteCache
type ProviderMockDeleteCacheParams struct {
	ctx       context.Context
	cacheName string
}

// ProviderMockDeleteCacheParamPtrs contains pointers to parameters of the Provider.DeleteCache
type ProviderMockDeleteCacheParamPtrs struct {
	ctx       *context.Context
	cacheName *string
}

// ProviderMockDeleteCacheResults contains results of the Provider.DeleteCache
type ProviderMockDeleteCacheResults struct {
	err error
}

// ProviderMockDeleteCacheOrigins contains origins of expectations of the Provider.DeleteCache
type ProviderMockDeleteCacheExpectationOrigins struct {
	origin          string
	originCtx       string
	originCacheName string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteCache *mProviderMockDeleteCache) Optional() *mProviderMockDeleteCache {
	mmDeleteCache.optional = true
	return mmDeleteCache
}

// Expect sets up expected params for Provider.DeleteCache
func (mmDeleteCache *mProviderMockDeleteCache) Expect(ctx context.Context, cacheName string) *mProviderMockDeleteCache {
	if mmDeleteCache.mock.funcDeleteCache != nil {
		mmDeleteCache.mock.t.Fatalf("ProviderMock.DeleteCache mock is already set by Set")
	}

	if mmDeleteCache.defaultExpectation == nil {
		mmDeleteCache.defaultExpectation = &ProviderMockDeleteCacheExpectation{}
	}

	if mmDeleteCache.defaultExpectation.paramPtrs != nil {
		mmDeleteCache.mock.t.Fatalf("ProviderMock.DeleteCache mock is already set by ExpectParams functions")
	}

	mmDeleteCache.defaultExpectation.params = &ProviderMockDeleteCacheParams{ctx, cacheName}
	mmDeleteCache.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteCache.expectations {
		if minimock.Equal(e.params, mmDeleteCache.defaultExpectation.params) {
			mmDeleteCache.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteCache.defaultExpectation.params)
		}
	}

	return mmDeleteCache
}

// ExpectCtxParam1 sets up expected param ctx for Provider.DeleteCache
func (mmDeleteCache *mProviderMockDeleteCache) ExpectCtxParam1(ctx context.Context) *mProviderMockDeleteCache {
	if mmDeleteCache.mock.funcDeleteCache != nil {
		mmDeleteCache.mock.t.Fatalf("ProviderMock.DeleteCache mock is already set by Set")
	}

	if mmDeleteCache.defaultExpectation == nil {
		mmDeleteCache.defaultExpectation = &ProviderMockDeleteCacheExpectation{}
	}

	if mmDeleteCache.defaultExpectation.params != nil {
		mmDeleteCache.mock.t.Fatalf("ProviderMock.DeleteCache mock is already set by Expect")
	}

	if mmDeleteCache.defaultExpectation.paramPtrs == nil {
		mmDeleteCache.defaultExpectation.paramPtrs = &ProviderMockDeleteCacheParamPtrs{}
	}
	mmDeleteCache.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteCache.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteCache
}

// ExpectCacheNameParam2 sets up expected param cacheName for Provider.DeleteCache
func (mmDeleteCache *mProviderMockDeleteCache) ExpectCacheNameParam2(cacheName string) *mProviderMockDeleteCache {
	if mmDeleteCache.mock.funcDeleteCache != nil {
		mmDeleteCache.mock.t.Fatalf("ProviderMock.DeleteCache mock is already set by Set")
	}

	if mmDeleteCache.defaultExpectation == nil {
		mmDeleteCache.defaultExpectation = &ProviderMockDeleteCacheExpectation{}
	}

	if mmDeleteCache.defaultExpectation.params != nil {
		mmDeleteCache.mock.t.Fatalf("ProviderMock.DeleteCache mock is already set by Expect")
	}

	if mmDeleteCache.defaultExpectation.paramPtrs == nil {
		mmDeleteCache.defaultExpectation.paramPtrs = &ProviderMockDeleteCacheParamPtrs{}
	}
	mmDeleteCache.defaultExpectation.paramPtrs.cacheName = &cacheName
	mmDeleteCache.defaultExpectation.expectationOrigins.originCacheName = minimock.CallerInfo(1)

	return mmDeleteCache
}

// Inspect accepts an inspector function that has same arguments as the Provider.DeleteCache
func (mmDeleteCache *mProviderMockDeleteCache) Inspect(f func(ctx context.Context, cacheName string)) *mProviderMockDeleteCache {
	if mmDeleteCache.mock.inspectFuncDeleteCache != nil {
		mmDeleteCache.mock.t.Fatalf("Inspect function is already set for ProviderMock.DeleteCache")
	}

	mmDeleteCache.mock.inspectFuncDeleteCache = f

	return mmDeleteCache
}

// Return sets up results that will be returned by Provider.DeleteCache
func (mmDeleteCache *mProviderMockDeleteCache) Return(err error) *ProviderMock {
	if mmDeleteCache.mock.funcDeleteCache != nil {
		mmDeleteCache.mock.t.Fatalf("ProviderMock.DeleteCache mock is already set by Set")
	}

	if mmDeleteCache.defaultExpectation == nil {
		mmDeleteCache.defaultExpectation = &ProviderMockDeleteCacheExpectation{mock: mmDeleteCache.mock}
	}
	mmDeleteCache.defaultExpectation.results = &ProviderMockDeleteCacheResults{err}
	mmDeleteCache.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteCache.mock
}

// Set uses given function f to mock the Provider.DeleteCache method
func (mmDeleteCache *mProviderMockDeleteCache) Set(f func(ctx context.Context, cacheName string) (err error)) *ProviderMock {
	if mmDeleteCache.defaultExpectation != nil {
		mmDeleteCache.mock.t.Fatalf("Default expectation is already set for the Provider.DeleteCache method")
	}

	if len(mmDeleteCache.expectations) > 0 {
		mmDeleteCache.mock.t.Fatalf("Some expectations are already set for the Provider.DeleteCache method")
	}

	mmDeleteCache.mock.funcDeleteCache = f
	mmDeleteCache.mock.funcDeleteCacheOrigin = minimock.CallerInfo(1)
	return mmDeleteCache.mock
}

// When sets expectation for the Provider.DeleteCache which will trigger the result defined by the following
// Then helper
func (mmDeleteCache *mProviderMockDeleteCache) When(ctx context.Context, cacheName string) *ProviderMockDeleteCacheExpectation {
	if mmDeleteCache.mock.funcDeleteCache != nil {
		mmDeleteCache.mock.t.Fatalf("ProviderMock.DeleteCache mock is already set by Set")
	}

	expectation := &ProviderMockDeleteCacheExpectation{
		mock:               mmDeleteCache.mock,
		params:             &ProviderMockDeleteCacheParams{ctx, cacheName},
		expectationOrigins: ProviderMockDeleteCacheExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteCache.expectations = append(mmDeleteCache.expectations, expectation)
	return expectation
}

// Then sets up Provider.DeleteCache return parameters for the expectation previously defined by the When method
func (e *ProviderMockDeleteCacheExpectation) Then(err error) *ProviderMock {
	e.results = &ProviderMockDeleteCacheResults{err}
	return e.mock
}

// Times sets number of times Provider.DeleteCache should be invoked
func (mmDeleteCache *mProviderMockDeleteCache) Times(n uint64) *mProviderMockDeleteCache {
	if n == 0 {
		mmDeleteCache.mock.t.Fatalf("Times of ProviderMock.DeleteCache mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteCache.expectedInvocations, n)
	mmDeleteCache.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteCache
}

func (mmDeleteCache *mProviderMockDeleteCache) invocationsDone() bool {
	if len(mmDeleteCache.expectations) == 0 && mmDeleteCache.defaultExpectation == nil && mmDeleteCache.mock.funcDeleteCache == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteCache.mock.afterDeleteCacheCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteCache.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteCache implements mm_ai.Provider
func (mmDeleteCache *ProviderMock) DeleteCache(ctx context.Context, cacheName string) (err error) {
	mm_atomic.AddUint64(&mmDeleteCache.beforeDeleteCacheCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteCache.afterDeleteCacheCounter, 1)

	mmDeleteCache.t.Helper()

	if mmDeleteCache.inspectFuncDeleteCache != nil {
		mmDeleteCache.inspectFuncDeleteCache(ctx, cacheName)
	}

	mm_params := ProviderMockDeleteCacheParams{ctx, cacheName}

	// Record call args
	mmDeleteCache.DeleteCacheMock.mutex.Lock()
	mmDeleteCache.DeleteCacheMock.callArgs = append(mmDeleteCache.DeleteCacheMock.callArgs, &mm_params)
	mmDeleteCache.DeleteCacheMock.mutex.Unlock()

	for _, e := range mmDeleteCache.DeleteCacheMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteCache.DeleteCacheMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteCache.DeleteCacheMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteCache.DeleteCacheMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteCache.DeleteCacheMock.defaultExpectation.paramPtrs

		mm_got := ProviderMockDeleteCacheParams{ctx, cacheName}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteCache.t.Errorf("ProviderMock.DeleteCache got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCache.DeleteCacheMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cacheName != nil && !minimock.Equal(*mm_want_ptrs.cacheName, mm_got.cacheName) {
				mmDeleteCache.t.Errorf("ProviderMock.DeleteCache got unexpected parameter cacheName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCache.DeleteCacheMock.defaultExpectation.expectationOrigins.originCacheName, *mm_want_ptrs.cacheName, mm_got.cacheName, minimock.Diff(*mm_want_ptrs.cacheName, mm_got.cacheName))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteCache.t.Errorf("ProviderMock.DeleteCache got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteCache.DeleteCacheMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteCache.DeleteCacheMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteCache.t.Fatal("No results are set for the ProviderMock.DeleteCache")
		}
		return (*mm_results).err
	}
	if mmDeleteCache.funcDeleteCache != nil {
		return mmDeleteCache.funcDeleteCache(ctx, cacheName)
	}
	mmDeleteCache.t.Fatalf("Unexpected call to ProviderMock.DeleteCache. %v %v", ctx, cacheName)
	return
}

// DeleteCacheAfterCounter returns a count of finished ProviderMock.DeleteCache invocations
func (mmDeleteCache *ProviderMock) DeleteCacheAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCache.afterDeleteCacheCounter)
}

// DeleteCacheBeforeCounter returns a count of ProviderMock.DeleteCache invocations
func (mmDeleteCache *ProviderMock) DeleteCacheBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCache.beforeDeleteCacheCounter)
}

// Calls returns a list of arguments used in each call to ProviderMock.DeleteCache.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteCache *mProviderMockDeleteCache) Calls() []*ProviderMockDeleteCacheParams {
	mmDeleteCache.mutex.RLock()

	argCopy := make([]*ProviderMockDeleteCacheParams, len(mmDeleteCache.callArgs))
	copy(argCopy, mmDeleteCache.callArgs)

	mmDeleteCache.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCacheDone returns true if the count of the DeleteCache invocations corresponds
// the number of defined expectations
func (m *ProviderMock) MinimockDeleteCacheDone() bool {
	if m.DeleteCacheMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteCacheMock.invocationsDone()
}

// MinimockDeleteCacheInspect logs each unmet expectation
func (m *ProviderMock) MinimockDeleteCacheInspect() {
	for _, e := range m.DeleteCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProviderMock.DeleteCache at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCacheCounter := mm_atomic.LoadUint64(&m.afterDeleteCacheCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCacheMock.defaultExpectation != nil && afterDeleteCacheCounter < 1 {
		if m.DeleteCacheMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ProviderMock.DeleteCache at\n%s", m.DeleteCacheMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ProviderMock.DeleteCache at\n%s with params: %#v", m.DeleteCacheMock.defaultExpectation.expectationOrigins.origin, *m.DeleteCacheMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCache != nil && afterDeleteCacheCounter < 1 {
		m.t.Errorf("Expected call to ProviderMock.DeleteCache at\n%s", m.funcDeleteCacheOrigin)
	}

	if !m.DeleteCacheMock.invocationsDone() && afterDeleteCacheCounter > 0 {
		m.t.Errorf("Expected %d calls to ProviderMock.DeleteCache at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteCacheMock.expectedInvocations), m.DeleteCacheMock.expectedInvocationsOrigin, afterDeleteCacheCounter)
	}
}

type mProviderMockName struct {
	optional           bool
	mock               *ProviderMock
	defaultExpectation *ProviderMockNameExpectation
	expectations       []*ProviderMockNameExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProviderMockNameExpectation specifies expectation struct of the Provider.Name
type ProviderMockNameExpectation struct {
	mock *ProviderMock

	results      *ProviderMockNameResults
	returnOrigin string
	Counter      uint64
}

// ProviderMockNameResults contains results of the Provider.Name
type ProviderMockNameResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmName *mProviderMockName) Optional() *mProviderMockName {
	mmName.optional = true
	return mmName
}

// Expect sets up expected params for Provider.Name
func (mmName *mProviderMockName) Expect() *mProviderMockName {
	if mmName.mock.funcName != nil {
		mmName.mock.t.Fatalf("ProviderMock.Name mock is already set by Set")
	}

	if mmName.defaultExpectation == nil {
		mmName.defaultExpectation = &ProviderMockNameExpectation{}
	}

	return mmName
}

// Inspect accepts an inspector function that has same arguments as the Provider.Name
func (mmName *mProviderMockName) Inspect(f func()) *mProviderMockName {
	if mmName.mock.inspectFuncName != nil {
		mmName.mock.t.Fatalf("Inspect function is already set for ProviderMock.Name")
	}

	mmName.mock.inspectFuncName = f

	return mmName
}

// Return sets up results that will be returned by Provider.Name
func (mmName *mProviderMockName) Return(s1 string) *ProviderMock {
	if mmName.mock.funcName != nil {
		mmName.mock.t.Fatalf("ProviderMock.Name mock is already set by Set")
	}

	if mmName.defaultExpectation == nil {
		mmName.defaultExpectation = &ProviderMockNameExpectation{mock: mmName.mock}
	}
	mmName.defaultExpectation.results = &ProviderMockNameResults{s1}
	mmName.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmName.mock
}

// Set uses given function f to mock the Provider.Name method
func (mmName *mProviderMockName) Set(f func() (s1 string)) *ProviderMock {
	if mmName.defaultExpectation != nil {
		mmName.mock.t.Fatalf("Default expectation is already set for the Provider.Name method")
	}

	if len(mmName.expectations) > 0 {
		mmName.mock.t.Fatalf("Some expectations are already set for the Provider.Name method")
	}

	mmName.mock.funcName = f
	mmName.mock.funcNameOrigin = minimock.CallerInfo(1)
	return mmName.mock
}

// Times sets number of times Provider.Name should be invoked
func (mmName *mProviderMockName) Times(n uint64) *mProviderMockName {
	if n == 0 {
		mmName.mock.t.Fatalf("Times of ProviderMock.Name mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmName.expectedInvocations, n)
	mmName.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmName
}

func (mmName *mProviderMockName) invocationsDone() bool {
	if len(mmName.expectations) == 0 && mmName.defaultExpectation == nil && mmName.mock.funcName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmName.mock.afterNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Name implements mm_ai.Provider
func (mmName *ProviderMock) Name() (s1 string) {
	mm_atomic.AddUint64(&mmName.beforeNameCounter, 1)
	defer mm_atomic.AddUint64(&mmName.afterNameCounter, 1)

	mmName.t.Helper()

	if mmName.inspectFuncName != nil {
		mmName.inspectFuncName()
	}

	if mmName.NameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmName.NameMock.defaultExpectation.Counter, 1)

		mm_results := mmName.NameMock.defaultExpectation.results
		if mm_results == nil {
			mmName.t.Fatal("No results are set for the ProviderMock.Name")
		}
		return (*mm_results).s1
	}
	if mmName.funcName != nil {
		return mmName.funcName()
	}
	mmName.t.Fatalf("Unexpected call to ProviderMock.Name.")
	return
}

// NameAfterCounter returns a count of finished ProviderMock.Name invocations
func (mmName *ProviderMock) NameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmName.afterNameCounter)
}

// NameBeforeCounter returns a count of ProviderMock.Name invocations
func (mmName *ProviderMock) NameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmName.beforeNameCounter)
}

// MinimockNameDone returns true if the count of the Name invocations corresponds
// the number of defined expectations
func (m *ProviderMock) MinimockNameDone() bool {
	if m.NameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.NameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.NameMock.invocationsDone()
}

// MinimockNameInspect logs each unmet expectation
func (m *ProviderMock) MinimockNameInspect() {
	for _, e := range m.NameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ProviderMock.Name")
		}
	}

	afterNameCounter := mm_atomic.LoadUint64(&m.afterNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.NameMock.defaultExpectation != nil && afterNameCounter < 1 {
		m.t.Errorf("Expected call to ProviderMock.Name at\n%s", m.NameMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcName != nil && afterNameCounter < 1 {
		m.t.Errorf("Expected call to ProviderMock.Name at\n%s", m.funcNameOrigin)
	}

	if !m.NameMock.invocationsDone() && afterNameCounter > 0 {
		m.t.Errorf("Expected %d calls to ProviderMock.Name at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.NameMock.expectedInvocations), m.NameMock.expectedInvocationsOrigin, afterNameCounter)
	}
}

type mProviderMockSupportsFileType struct {
	optional           bool
	mock               *ProviderMock
	defaultExpectation *ProviderMockSupportsFileTypeExpectation
	expectations       []*ProviderMockSupportsFileTypeExpectation

	callArgs []*ProviderMockSupportsFileTypeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProviderMockSupportsFileTypeExpectation specifies expectation struct of the Provider.SupportsFileType
type ProviderMockSupportsFileTypeExpectation struct {
	mock               *ProviderMock
	params             *ProviderMockSupportsFileTypeParams
	paramPtrs          *ProviderMockSupportsFileTypeParamPtrs
	expectationOrigins ProviderMockSupportsFileTypeExpectationOrigins
	results            *ProviderMockSupportsFileTypeResults
	returnOrigin       string
	Counter            uint64
}

// ProviderMockSupportsFileTypeParams contains parameters of the Provider.SupportsFileType
type ProviderMockSupportsFileTypeParams struct {
	fileType artifactpb.FileType
}

// ProviderMockSupportsFileTypeParamPtrs contains pointers to parameters of the Provider.SupportsFileType
type ProviderMockSupportsFileTypeParamPtrs struct {
	fileType *artifactpb.FileType
}

// ProviderMockSupportsFileTypeResults contains results of the Provider.SupportsFileType
type ProviderMockSupportsFileTypeResults struct {
	b1 bool
}

// ProviderMockSupportsFileTypeOrigins contains origins of expectations of the Provider.SupportsFileType
type ProviderMockSupportsFileTypeExpectationOrigins struct {
	origin         string
	originFileType string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSupportsFileType *mProviderMockSupportsFileType) Optional() *mProviderMockSupportsFileType {
	mmSupportsFileType.optional = true
	return mmSupportsFileType
}

// Expect sets up expected params for Provider.SupportsFileType
func (mmSupportsFileType *mProviderMockSupportsFileType) Expect(fileType artifactpb.FileType) *mProviderMockSupportsFileType {
	if mmSupportsFileType.mock.funcSupportsFileType != nil {
		mmSupportsFileType.mock.t.Fatalf("ProviderMock.SupportsFileType mock is already set by Set")
	}

	if mmSupportsFileType.defaultExpectation == nil {
		mmSupportsFileType.defaultExpectation = &ProviderMockSupportsFileTypeExpectation{}
	}

	if mmSupportsFileType.defaultExpectation.paramPtrs != nil {
		mmSupportsFileType.mock.t.Fatalf("ProviderMock.SupportsFileType mock is already set by ExpectParams functions")
	}

	mmSupportsFileType.defaultExpectation.params = &ProviderMockSupportsFileTypeParams{fileType}
	mmSupportsFileType.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSupportsFileType.expectations {
		if minimock.Equal(e.params, mmSupportsFileType.defaultExpectation.params) {
			mmSupportsFileType.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSupportsFileType.defaultExpectation.params)
		}
	}

	return mmSupportsFileType
}

// ExpectFileTypeParam1 sets up expected param fileType for Provider.SupportsFileType
func (mmSupportsFileType *mProviderMockSupportsFileType) ExpectFileTypeParam1(fileType artifactpb.FileType) *mProviderMockSupportsFileType {
	if mmSupportsFileType.mock.funcSupportsFileType != nil {
		mmSupportsFileType.mock.t.Fatalf("ProviderMock.SupportsFileType mock is already set by Set")
	}

	if mmSupportsFileType.defaultExpectation == nil {
		mmSupportsFileType.defaultExpectation = &ProviderMockSupportsFileTypeExpectation{}
	}

	if mmSupportsFileType.defaultExpectation.params != nil {
		mmSupportsFileType.mock.t.Fatalf("ProviderMock.SupportsFileType mock is already set by Expect")
	}

	if mmSupportsFileType.defaultExpectation.paramPtrs == nil {
		mmSupportsFileType.defaultExpectation.paramPtrs = &ProviderMockSupportsFileTypeParamPtrs{}
	}
	mmSupportsFileType.defaultExpectation.paramPtrs.fileType = &fileType
	mmSupportsFileType.defaultExpectation.expectationOrigins.originFileType = minimock.CallerInfo(1)

	return mmSupportsFileType
}

// Inspect accepts an inspector function that has same arguments as the Provider.SupportsFileType
func (mmSupportsFileType *mProviderMockSupportsFileType) Inspect(f func(fileType artifactpb.FileType)) *mProviderMockSupportsFileType {
	if mmSupportsFileType.mock.inspectFuncSupportsFileType != nil {
		mmSupportsFileType.mock.t.Fatalf("Inspect function is already set for ProviderMock.SupportsFileType")
	}

	mmSupportsFileType.mock.inspectFuncSupportsFileType = f

	return mmSupportsFileType
}

// Return sets up results that will be returned by Provider.SupportsFileType
func (mmSupportsFileType *mProviderMockSupportsFileType) Return(b1 bool) *ProviderMock {
	if mmSupportsFileType.mock.funcSupportsFileType != nil {
		mmSupportsFileType.mock.t.Fatalf("ProviderMock.SupportsFileType mock is already set by Set")
	}

	if mmSupportsFileType.defaultExpectation == nil {
		mmSupportsFileType.defaultExpectation = &ProviderMockSupportsFileTypeExpectation{mock: mmSupportsFileType.mock}
	}
	mmSupportsFileType.defaultExpectation.results = &ProviderMockSupportsFileTypeResults{b1}
	mmSupportsFileType.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSupportsFileType.mock
}

// Set uses given function f to mock the Provider.SupportsFileType method
func (mmSupportsFileType *mProviderMockSupportsFileType) Set(f func(fileType artifactpb.FileType) (b1 bool)) *ProviderMock {
	if mmSupportsFileType.defaultExpectation != nil {
		mmSupportsFileType.mock.t.Fatalf("Default expectation is already set for the Provider.SupportsFileType method")
	}

	if len(mmSupportsFileType.expectations) > 0 {
		mmSupportsFileType.mock.t.Fatalf("Some expectations are already set for the Provider.SupportsFileType method")
	}

	mmSupportsFileType.mock.funcSupportsFileType = f
	mmSupportsFileType.mock.funcSupportsFileTypeOrigin = minimock.CallerInfo(1)
	return mmSupportsFileType.mock
}

// When sets expectation for the Provider.SupportsFileType which will trigger the result defined by the following
// Then helper
func (mmSupportsFileType *mProviderMockSupportsFileType) When(fileType artifactpb.FileType) *ProviderMockSupportsFileTypeExpectation {
	if mmSupportsFileType.mock.funcSupportsFileType != nil {
		mmSupportsFileType.mock.t.Fatalf("ProviderMock.SupportsFileType mock is already set by Set")
	}

	expectation := &ProviderMockSupportsFileTypeExpectation{
		mock:               mmSupportsFileType.mock,
		params:             &ProviderMockSupportsFileTypeParams{fileType},
		expectationOrigins: ProviderMockSupportsFileTypeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSupportsFileType.expectations = append(mmSupportsFileType.expectations, expectation)
	return expectation
}

// Then sets up Provider.SupportsFileType return parameters for the expectation previously defined by the When method
func (e *ProviderMockSupportsFileTypeExpectation) Then(b1 bool) *ProviderMock {
	e.results = &ProviderMockSupportsFileTypeResults{b1}
	return e.mock
}

// Times sets number of times Provider.SupportsFileType should be invoked
func (mmSupportsFileType *mProviderMockSupportsFileType) Times(n uint64) *mProviderMockSupportsFileType {
	if n == 0 {
		mmSupportsFileType.mock.t.Fatalf("Times of ProviderMock.SupportsFileType mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSupportsFileType.expectedInvocations, n)
	mmSupportsFileType.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSupportsFileType
}

func (mmSupportsFileType *mProviderMockSupportsFileType) invocationsDone() bool {
	if len(mmSupportsFileType.expectations) == 0 && mmSupportsFileType.defaultExpectation == nil && mmSupportsFileType.mock.funcSupportsFileType == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSupportsFileType.mock.afterSupportsFileTypeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSupportsFileType.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SupportsFileType implements mm_ai.Provider
func (mmSupportsFileType *ProviderMock) SupportsFileType(fileType artifactpb.FileType) (b1 bool) {
	mm_atomic.AddUint64(&mmSupportsFileType.beforeSupportsFileTypeCounter, 1)
	defer mm_atomic.AddUint64(&mmSupportsFileType.afterSupportsFileTypeCounter, 1)

	mmSupportsFileType.t.Helper()

	if mmSupportsFileType.inspectFuncSupportsFileType != nil {
		mmSupportsFileType.inspectFuncSupportsFileType(fileType)
	}

	mm_params := ProviderMockSupportsFileTypeParams{fileType}

	// Record call args
	mmSupportsFileType.SupportsFileTypeMock.mutex.Lock()
	mmSupportsFileType.SupportsFileTypeMock.callArgs = append(mmSupportsFileType.SupportsFileTypeMock.callArgs, &mm_params)
	mmSupportsFileType.SupportsFileTypeMock.mutex.Unlock()

	for _, e := range mmSupportsFileType.SupportsFileTypeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmSupportsFileType.SupportsFileTypeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSupportsFileType.SupportsFileTypeMock.defaultExpectation.Counter, 1)
		mm_want := mmSupportsFileType.SupportsFileTypeMock.defaultExpectation.params
		mm_want_ptrs := mmSupportsFileType.SupportsFileTypeMock.defaultExpectation.paramPtrs

		mm_got := ProviderMockSupportsFileTypeParams{fileType}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.fileType != nil && !minimock.Equal(*mm_want_ptrs.fileType, mm_got.fileType) {
				mmSupportsFileType.t.Errorf("ProviderMock.SupportsFileType got unexpected parameter fileType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSupportsFileType.SupportsFileTypeMock.defaultExpectation.expectationOrigins.originFileType, *mm_want_ptrs.fileType, mm_got.fileType, minimock.Diff(*mm_want_ptrs.fileType, mm_got.fileType))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSupportsFileType.t.Errorf("ProviderMock.SupportsFileType got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSupportsFileType.SupportsFileTypeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSupportsFileType.SupportsFileTypeMock.defaultExpectation.results
		if mm_results == nil {
			mmSupportsFileType.t.Fatal("No results are set for the ProviderMock.SupportsFileType")
		}
		return (*mm_results).b1
	}
	if mmSupportsFileType.funcSupportsFileType != nil {
		return mmSupportsFileType.funcSupportsFileType(fileType)
	}
	mmSupportsFileType.t.Fatalf("Unexpected call to ProviderMock.SupportsFileType. %v", fileType)
	return
}

// SupportsFileTypeAfterCounter returns a count of finished ProviderMock.SupportsFileType invocations
func (mmSupportsFileType *ProviderMock) SupportsFileTypeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSupportsFileType.afterSupportsFileTypeCounter)
}

// SupportsFileTypeBeforeCounter returns a count of ProviderMock.SupportsFileType invocations
func (mmSupportsFileType *ProviderMock) SupportsFileTypeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSupportsFileType.beforeSupportsFileTypeCounter)
}

// Calls returns a list of arguments used in each call to ProviderMock.SupportsFileType.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSupportsFileType *mProviderMockSupportsFileType) Calls() []*ProviderMockSupportsFileTypeParams {
	mmSupportsFileType.mutex.RLock()

	argCopy := make([]*ProviderMockSupportsFileTypeParams, len(mmSupportsFileType.callArgs))
	copy(argCopy, mmSupportsFileType.callArgs)

	mmSupportsFileType.mutex.RUnlock()

	return argCopy
}

// MinimockSupportsFileTypeDone returns true if the count of the SupportsFileType invocations corresponds
// the number of defined expectations
func (m *ProviderMock) MinimockSupportsFileTypeDone() bool {
	if m.SupportsFileTypeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SupportsFileTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SupportsFileTypeMock.invocationsDone()
}

// MinimockSupportsFileTypeInspect logs each unmet expectation
func (m *ProviderMock) MinimockSupportsFileTypeInspect() {
	for _, e := range m.SupportsFileTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProviderMock.SupportsFileType at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSupportsFileTypeCounter := mm_atomic.LoadUint64(&m.afterSupportsFileTypeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SupportsFileTypeMock.defaultExpectation != nil && afterSupportsFileTypeCounter < 1 {
		if m.SupportsFileTypeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ProviderMock.SupportsFileType at\n%s", m.SupportsFileTypeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ProviderMock.SupportsFileType at\n%s with params: %#v", m.SupportsFileTypeMock.defaultExpectation.expectationOrigins.origin, *m.SupportsFileTypeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSupportsFileType != nil && afterSupportsFileTypeCounter < 1 {
		m.t.Errorf("Expected call to ProviderMock.SupportsFileType at\n%s", m.funcSupportsFileTypeOrigin)
	}

	if !m.SupportsFileTypeMock.invocationsDone() && afterSupportsFileTypeCounter > 0 {
		m.t.Errorf("Expected %d calls to ProviderMock.SupportsFileType at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SupportsFileTypeMock.expectedInvocations), m.SupportsFileTypeMock.expectedInvocationsOrigin, afterSupportsFileTypeCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ProviderMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCloseInspect()

			m.MinimockConvertToMarkdownInspect()

			m.MinimockConvertToMarkdownWithCacheInspect()

			m.MinimockCreateCacheInspect()

			m.MinimockDeleteCacheInspect()

			m.MinimockNameInspect()

			m.MinimockSupportsFileTypeInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ProviderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ProviderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseDone() &&
		m.MinimockConvertToMarkdownDone() &&
		m.MinimockConvertToMarkdownWithCacheDone() &&
		m.MinimockCreateCacheDone() &&
		m.MinimockDeleteCacheDone() &&
		m.MinimockNameDone() &&
		m.MinimockSupportsFileTypeDone()
}
