// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/instill-ai/artifact-backend/pkg/acl"
	"github.com/instill-ai/artifact-backend/pkg/repository"
	"github.com/instill-ai/artifact-backend/pkg/resource"
	mm_service "github.com/instill-ai/artifact-backend/pkg/service"
	"github.com/instill-ai/artifact-backend/pkg/types"
	artifactpb "github.com/instill-ai/protogen-go/artifact/artifact/v1alpha"
	pipelinepb "github.com/instill-ai/protogen-go/pipeline/pipeline/v1beta"
	"github.com/redis/go-redis/v9"
)

// ServiceMock implements mm_service.Service
type ServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcACLClient          func() (ap1 *acl.ACLClient)
	funcACLClientOrigin    string
	inspectFuncACLClient   func()
	afterACLClientCounter  uint64
	beforeACLClientCounter uint64
	ACLClientMock          mServiceMockACLClient

	funcChatWithCache          func(ctx context.Context, cp1 *repository.ChatCacheMetadata, s1 string) (s2 string, err error)
	funcChatWithCacheOrigin    string
	inspectFuncChatWithCache   func(ctx context.Context, cp1 *repository.ChatCacheMetadata, s1 string)
	afterChatWithCacheCounter  uint64
	beforeChatWithCacheCounter uint64
	ChatWithCacheMock          mServiceMockChatWithCache

	funcCheckCatalogUserPermission          func(ctx context.Context, s1 string, s2 string, s3 string) (np1 *resource.Namespace, kp1 *repository.KnowledgeBaseModel, err error)
	funcCheckCatalogUserPermissionOrigin    string
	inspectFuncCheckCatalogUserPermission   func(ctx context.Context, s1 string, s2 string, s3 string)
	afterCheckCatalogUserPermissionCounter  uint64
	beforeCheckCatalogUserPermissionCounter uint64
	CheckCatalogUserPermissionMock          mServiceMockCheckCatalogUserPermission

	funcCheckFilesProcessingStatus          func(ctx context.Context, fa1 []types.FileUIDType) (allCompleted bool, processingCount int, err error)
	funcCheckFilesProcessingStatusOrigin    string
	inspectFuncCheckFilesProcessingStatus   func(ctx context.Context, fa1 []types.FileUIDType)
	afterCheckFilesProcessingStatusCounter  uint64
	beforeCheckFilesProcessingStatusCounter uint64
	CheckFilesProcessingStatusMock          mServiceMockCheckFilesProcessingStatus

	funcCheckNamespacePermission          func(ctx context.Context, np1 *resource.Namespace) (err error)
	funcCheckNamespacePermissionOrigin    string
	inspectFuncCheckNamespacePermission   func(ctx context.Context, np1 *resource.Namespace)
	afterCheckNamespacePermissionCounter  uint64
	beforeCheckNamespacePermissionCounter uint64
	CheckNamespacePermissionMock          mServiceMockCheckNamespacePermission

	funcCleanupFile          func(ctx context.Context, f1 types.FileUIDType, u1 types.UserUIDType, r1 types.RequesterUIDType, s1 string, b1 bool) (err error)
	funcCleanupFileOrigin    string
	inspectFuncCleanupFile   func(ctx context.Context, f1 types.FileUIDType, u1 types.UserUIDType, r1 types.RequesterUIDType, s1 string, b1 bool)
	afterCleanupFileCounter  uint64
	beforeCleanupFileCounter uint64
	CleanupFileMock          mServiceMockCleanupFile

	funcCleanupKnowledgeBase          func(ctx context.Context, k1 types.KBUIDType) (err error)
	funcCleanupKnowledgeBaseOrigin    string
	inspectFuncCleanupKnowledgeBase   func(ctx context.Context, k1 types.KBUIDType)
	afterCleanupKnowledgeBaseCounter  uint64
	beforeCleanupKnowledgeBaseCounter uint64
	CleanupKnowledgeBaseMock          mServiceMockCleanupKnowledgeBase

	funcCreateRepositoryTag          func(ctx context.Context, cp1 *artifactpb.CreateRepositoryTagRequest) (cp2 *artifactpb.CreateRepositoryTagResponse, err error)
	funcCreateRepositoryTagOrigin    string
	inspectFuncCreateRepositoryTag   func(ctx context.Context, cp1 *artifactpb.CreateRepositoryTagRequest)
	afterCreateRepositoryTagCounter  uint64
	beforeCreateRepositoryTagCounter uint64
	CreateRepositoryTagMock          mServiceMockCreateRepositoryTag

	funcDeleteFiles          func(ctx context.Context, s1 string, sa1 []string) (err error)
	funcDeleteFilesOrigin    string
	inspectFuncDeleteFiles   func(ctx context.Context, s1 string, sa1 []string)
	afterDeleteFilesCounter  uint64
	beforeDeleteFilesCounter uint64
	DeleteFilesMock          mServiceMockDeleteFiles

	funcDeleteRepositoryTag          func(ctx context.Context, dp1 *artifactpb.DeleteRepositoryTagRequest) (dp2 *artifactpb.DeleteRepositoryTagResponse, err error)
	funcDeleteRepositoryTagOrigin    string
	inspectFuncDeleteRepositoryTag   func(ctx context.Context, dp1 *artifactpb.DeleteRepositoryTagRequest)
	afterDeleteRepositoryTagCounter  uint64
	beforeDeleteRepositoryTagCounter uint64
	DeleteRepositoryTagMock          mServiceMockDeleteRepositoryTag

	funcEmbedTexts          func(ctx context.Context, sa1 []string, i1 int, m1 map[string][]string) (faa1 [][]float32, err error)
	funcEmbedTextsOrigin    string
	inspectFuncEmbedTexts   func(ctx context.Context, sa1 []string, i1 int, m1 map[string][]string)
	afterEmbedTextsCounter  uint64
	beforeEmbedTextsCounter uint64
	EmbedTextsMock          mServiceMockEmbedTexts

	funcGetChatCacheForFiles          func(ctx context.Context, k1 types.KBUIDType, fa1 []types.FileUIDType) (cp1 *repository.ChatCacheMetadata, err error)
	funcGetChatCacheForFilesOrigin    string
	inspectFuncGetChatCacheForFiles   func(ctx context.Context, k1 types.KBUIDType, fa1 []types.FileUIDType)
	afterGetChatCacheForFilesCounter  uint64
	beforeGetChatCacheForFilesCounter uint64
	GetChatCacheForFilesMock          mServiceMockGetChatCacheForFiles

	funcGetChunksByFile          func(ctx context.Context, kp1 *repository.KnowledgeBaseFileModel) (s1 types.SourceTableType, s2 types.SourceUIDType, ta1 []repository.TextChunkModel, m1 map[types.TextChunkUIDType]types.ContentType, sa1 []string, err error)
	funcGetChunksByFileOrigin    string
	inspectFuncGetChunksByFile   func(ctx context.Context, kp1 *repository.KnowledgeBaseFileModel)
	afterGetChunksByFileCounter  uint64
	beforeGetChunksByFileCounter uint64
	GetChunksByFileMock          mServiceMockGetChunksByFile

	funcGetConvertedFilePathsByFileUID          func(ctx context.Context, k1 types.KBUIDType, f1 types.FileUIDType) (sa1 []string, err error)
	funcGetConvertedFilePathsByFileUIDOrigin    string
	inspectFuncGetConvertedFilePathsByFileUID   func(ctx context.Context, k1 types.KBUIDType, f1 types.FileUIDType)
	afterGetConvertedFilePathsByFileUIDCounter  uint64
	beforeGetConvertedFilePathsByFileUIDCounter uint64
	GetConvertedFilePathsByFileUIDMock          mServiceMockGetConvertedFilePathsByFileUID

	funcGetDownloadURL          func(ctx context.Context, gp1 *artifactpb.GetObjectDownloadURLRequest, n1 types.NamespaceUIDType, s1 string) (gp2 *artifactpb.GetObjectDownloadURLResponse, err error)
	funcGetDownloadURLOrigin    string
	inspectFuncGetDownloadURL   func(ctx context.Context, gp1 *artifactpb.GetObjectDownloadURLRequest, n1 types.NamespaceUIDType, s1 string)
	afterGetDownloadURLCounter  uint64
	beforeGetDownloadURLCounter uint64
	GetDownloadURLMock          mServiceMockGetDownloadURL

	funcGetFilesByPaths          func(ctx context.Context, s1 string, sa1 []string) (fa1 []mm_service.FileContent, err error)
	funcGetFilesByPathsOrigin    string
	inspectFuncGetFilesByPaths   func(ctx context.Context, s1 string, sa1 []string)
	afterGetFilesByPathsCounter  uint64
	beforeGetFilesByPathsCounter uint64
	GetFilesByPathsMock          mServiceMockGetFilesByPaths

	funcGetNamespaceAndCheckPermission          func(ctx context.Context, s1 string) (np1 *resource.Namespace, err error)
	funcGetNamespaceAndCheckPermissionOrigin    string
	inspectFuncGetNamespaceAndCheckPermission   func(ctx context.Context, s1 string)
	afterGetNamespaceAndCheckPermissionCounter  uint64
	beforeGetNamespaceAndCheckPermissionCounter uint64
	GetNamespaceAndCheckPermissionMock          mServiceMockGetNamespaceAndCheckPermission

	funcGetNamespaceByNsID          func(ctx context.Context, s1 string) (np1 *resource.Namespace, err error)
	funcGetNamespaceByNsIDOrigin    string
	inspectFuncGetNamespaceByNsID   func(ctx context.Context, s1 string)
	afterGetNamespaceByNsIDCounter  uint64
	beforeGetNamespaceByNsIDCounter uint64
	GetNamespaceByNsIDMock          mServiceMockGetNamespaceByNsID

	funcGetRepositoryTag          func(ctx context.Context, gp1 *artifactpb.GetRepositoryTagRequest) (gp2 *artifactpb.GetRepositoryTagResponse, err error)
	funcGetRepositoryTagOrigin    string
	inspectFuncGetRepositoryTag   func(ctx context.Context, gp1 *artifactpb.GetRepositoryTagRequest)
	afterGetRepositoryTagCounter  uint64
	beforeGetRepositoryTagCounter uint64
	GetRepositoryTagMock          mServiceMockGetRepositoryTag

	funcGetTextChunkFilePathsByFileUID          func(ctx context.Context, k1 types.KBUIDType, f1 types.FileUIDType) (sa1 []string, err error)
	funcGetTextChunkFilePathsByFileUIDOrigin    string
	inspectFuncGetTextChunkFilePathsByFileUID   func(ctx context.Context, k1 types.KBUIDType, f1 types.FileUIDType)
	afterGetTextChunkFilePathsByFileUIDCounter  uint64
	beforeGetTextChunkFilePathsByFileUIDCounter uint64
	GetTextChunkFilePathsByFileUIDMock          mServiceMockGetTextChunkFilePathsByFileUID

	funcGetUploadURL          func(ctx context.Context, gp1 *artifactpb.GetObjectUploadURLRequest, n1 types.NamespaceUIDType, s1 string, c2 types.CreatorUIDType) (gp2 *artifactpb.GetObjectUploadURLResponse, err error)
	funcGetUploadURLOrigin    string
	inspectFuncGetUploadURL   func(ctx context.Context, gp1 *artifactpb.GetObjectUploadURLRequest, n1 types.NamespaceUIDType, s1 string, c2 types.CreatorUIDType)
	afterGetUploadURLCounter  uint64
	beforeGetUploadURLCounter uint64
	GetUploadURLMock          mServiceMockGetUploadURL

	funcListRepositoryTags          func(ctx context.Context, lp1 *artifactpb.ListRepositoryTagsRequest) (lp2 *artifactpb.ListRepositoryTagsResponse, err error)
	funcListRepositoryTagsOrigin    string
	inspectFuncListRepositoryTags   func(ctx context.Context, lp1 *artifactpb.ListRepositoryTagsRequest)
	afterListRepositoryTagsCounter  uint64
	beforeListRepositoryTagsCounter uint64
	ListRepositoryTagsMock          mServiceMockListRepositoryTags

	funcPipelinePublicClient          func() (p1 pipelinepb.PipelinePublicServiceClient)
	funcPipelinePublicClientOrigin    string
	inspectFuncPipelinePublicClient   func()
	afterPipelinePublicClientCounter  uint64
	beforePipelinePublicClientCounter uint64
	PipelinePublicClientMock          mServiceMockPipelinePublicClient

	funcProcessFile          func(ctx context.Context, k1 types.KBUIDType, fa1 []types.FileUIDType, u1 types.UserUIDType, r1 types.RequesterUIDType) (err error)
	funcProcessFileOrigin    string
	inspectFuncProcessFile   func(ctx context.Context, k1 types.KBUIDType, fa1 []types.FileUIDType, u1 types.UserUIDType, r1 types.RequesterUIDType)
	afterProcessFileCounter  uint64
	beforeProcessFileCounter uint64
	ProcessFileMock          mServiceMockProcessFile

	funcRedisClient          func() (cp1 *redis.Client)
	funcRedisClientOrigin    string
	inspectFuncRedisClient   func()
	afterRedisClientCounter  uint64
	beforeRedisClientCounter uint64
	RedisClientMock          mServiceMockRedisClient

	funcRepository          func() (r1 repository.Repository)
	funcRepositoryOrigin    string
	inspectFuncRepository   func()
	afterRepositoryCounter  uint64
	beforeRepositoryCounter uint64
	RepositoryMock          mServiceMockRepository

	funcSimilarityChunksSearch          func(ctx context.Context, o1 types.OwnerUIDType, sp1 *artifactpb.SimilarityChunksSearchRequest, faa1 [][]float32) (sa1 []mm_service.SimChunk, err error)
	funcSimilarityChunksSearchOrigin    string
	inspectFuncSimilarityChunksSearch   func(ctx context.Context, o1 types.OwnerUIDType, sp1 *artifactpb.SimilarityChunksSearchRequest, faa1 [][]float32)
	afterSimilarityChunksSearchCounter  uint64
	beforeSimilarityChunksSearchCounter uint64
	SimilarityChunksSearchMock          mServiceMockSimilarityChunksSearch
}

// NewServiceMock returns a mock for mm_service.Service
func NewServiceMock(t minimock.Tester) *ServiceMock {
	m := &ServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ACLClientMock = mServiceMockACLClient{mock: m}

	m.ChatWithCacheMock = mServiceMockChatWithCache{mock: m}
	m.ChatWithCacheMock.callArgs = []*ServiceMockChatWithCacheParams{}

	m.CheckCatalogUserPermissionMock = mServiceMockCheckCatalogUserPermission{mock: m}
	m.CheckCatalogUserPermissionMock.callArgs = []*ServiceMockCheckCatalogUserPermissionParams{}

	m.CheckFilesProcessingStatusMock = mServiceMockCheckFilesProcessingStatus{mock: m}
	m.CheckFilesProcessingStatusMock.callArgs = []*ServiceMockCheckFilesProcessingStatusParams{}

	m.CheckNamespacePermissionMock = mServiceMockCheckNamespacePermission{mock: m}
	m.CheckNamespacePermissionMock.callArgs = []*ServiceMockCheckNamespacePermissionParams{}

	m.CleanupFileMock = mServiceMockCleanupFile{mock: m}
	m.CleanupFileMock.callArgs = []*ServiceMockCleanupFileParams{}

	m.CleanupKnowledgeBaseMock = mServiceMockCleanupKnowledgeBase{mock: m}
	m.CleanupKnowledgeBaseMock.callArgs = []*ServiceMockCleanupKnowledgeBaseParams{}

	m.CreateRepositoryTagMock = mServiceMockCreateRepositoryTag{mock: m}
	m.CreateRepositoryTagMock.callArgs = []*ServiceMockCreateRepositoryTagParams{}

	m.DeleteFilesMock = mServiceMockDeleteFiles{mock: m}
	m.DeleteFilesMock.callArgs = []*ServiceMockDeleteFilesParams{}

	m.DeleteRepositoryTagMock = mServiceMockDeleteRepositoryTag{mock: m}
	m.DeleteRepositoryTagMock.callArgs = []*ServiceMockDeleteRepositoryTagParams{}

	m.EmbedTextsMock = mServiceMockEmbedTexts{mock: m}
	m.EmbedTextsMock.callArgs = []*ServiceMockEmbedTextsParams{}

	m.GetChatCacheForFilesMock = mServiceMockGetChatCacheForFiles{mock: m}
	m.GetChatCacheForFilesMock.callArgs = []*ServiceMockGetChatCacheForFilesParams{}

	m.GetChunksByFileMock = mServiceMockGetChunksByFile{mock: m}
	m.GetChunksByFileMock.callArgs = []*ServiceMockGetChunksByFileParams{}

	m.GetConvertedFilePathsByFileUIDMock = mServiceMockGetConvertedFilePathsByFileUID{mock: m}
	m.GetConvertedFilePathsByFileUIDMock.callArgs = []*ServiceMockGetConvertedFilePathsByFileUIDParams{}

	m.GetDownloadURLMock = mServiceMockGetDownloadURL{mock: m}
	m.GetDownloadURLMock.callArgs = []*ServiceMockGetDownloadURLParams{}

	m.GetFilesByPathsMock = mServiceMockGetFilesByPaths{mock: m}
	m.GetFilesByPathsMock.callArgs = []*ServiceMockGetFilesByPathsParams{}

	m.GetNamespaceAndCheckPermissionMock = mServiceMockGetNamespaceAndCheckPermission{mock: m}
	m.GetNamespaceAndCheckPermissionMock.callArgs = []*ServiceMockGetNamespaceAndCheckPermissionParams{}

	m.GetNamespaceByNsIDMock = mServiceMockGetNamespaceByNsID{mock: m}
	m.GetNamespaceByNsIDMock.callArgs = []*ServiceMockGetNamespaceByNsIDParams{}

	m.GetRepositoryTagMock = mServiceMockGetRepositoryTag{mock: m}
	m.GetRepositoryTagMock.callArgs = []*ServiceMockGetRepositoryTagParams{}

	m.GetTextChunkFilePathsByFileUIDMock = mServiceMockGetTextChunkFilePathsByFileUID{mock: m}
	m.GetTextChunkFilePathsByFileUIDMock.callArgs = []*ServiceMockGetTextChunkFilePathsByFileUIDParams{}

	m.GetUploadURLMock = mServiceMockGetUploadURL{mock: m}
	m.GetUploadURLMock.callArgs = []*ServiceMockGetUploadURLParams{}

	m.ListRepositoryTagsMock = mServiceMockListRepositoryTags{mock: m}
	m.ListRepositoryTagsMock.callArgs = []*ServiceMockListRepositoryTagsParams{}

	m.PipelinePublicClientMock = mServiceMockPipelinePublicClient{mock: m}

	m.ProcessFileMock = mServiceMockProcessFile{mock: m}
	m.ProcessFileMock.callArgs = []*ServiceMockProcessFileParams{}

	m.RedisClientMock = mServiceMockRedisClient{mock: m}

	m.RepositoryMock = mServiceMockRepository{mock: m}

	m.SimilarityChunksSearchMock = mServiceMockSimilarityChunksSearch{mock: m}
	m.SimilarityChunksSearchMock.callArgs = []*ServiceMockSimilarityChunksSearchParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mServiceMockACLClient struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockACLClientExpectation
	expectations       []*ServiceMockACLClientExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockACLClientExpectation specifies expectation struct of the Service.ACLClient
type ServiceMockACLClientExpectation struct {
	mock *ServiceMock

	results      *ServiceMockACLClientResults
	returnOrigin string
	Counter      uint64
}

// ServiceMockACLClientResults contains results of the Service.ACLClient
type ServiceMockACLClientResults struct {
	ap1 *acl.ACLClient
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmACLClient *mServiceMockACLClient) Optional() *mServiceMockACLClient {
	mmACLClient.optional = true
	return mmACLClient
}

// Expect sets up expected params for Service.ACLClient
func (mmACLClient *mServiceMockACLClient) Expect() *mServiceMockACLClient {
	if mmACLClient.mock.funcACLClient != nil {
		mmACLClient.mock.t.Fatalf("ServiceMock.ACLClient mock is already set by Set")
	}

	if mmACLClient.defaultExpectation == nil {
		mmACLClient.defaultExpectation = &ServiceMockACLClientExpectation{}
	}

	return mmACLClient
}

// Inspect accepts an inspector function that has same arguments as the Service.ACLClient
func (mmACLClient *mServiceMockACLClient) Inspect(f func()) *mServiceMockACLClient {
	if mmACLClient.mock.inspectFuncACLClient != nil {
		mmACLClient.mock.t.Fatalf("Inspect function is already set for ServiceMock.ACLClient")
	}

	mmACLClient.mock.inspectFuncACLClient = f

	return mmACLClient
}

// Return sets up results that will be returned by Service.ACLClient
func (mmACLClient *mServiceMockACLClient) Return(ap1 *acl.ACLClient) *ServiceMock {
	if mmACLClient.mock.funcACLClient != nil {
		mmACLClient.mock.t.Fatalf("ServiceMock.ACLClient mock is already set by Set")
	}

	if mmACLClient.defaultExpectation == nil {
		mmACLClient.defaultExpectation = &ServiceMockACLClientExpectation{mock: mmACLClient.mock}
	}
	mmACLClient.defaultExpectation.results = &ServiceMockACLClientResults{ap1}
	mmACLClient.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmACLClient.mock
}

// Set uses given function f to mock the Service.ACLClient method
func (mmACLClient *mServiceMockACLClient) Set(f func() (ap1 *acl.ACLClient)) *ServiceMock {
	if mmACLClient.defaultExpectation != nil {
		mmACLClient.mock.t.Fatalf("Default expectation is already set for the Service.ACLClient method")
	}

	if len(mmACLClient.expectations) > 0 {
		mmACLClient.mock.t.Fatalf("Some expectations are already set for the Service.ACLClient method")
	}

	mmACLClient.mock.funcACLClient = f
	mmACLClient.mock.funcACLClientOrigin = minimock.CallerInfo(1)
	return mmACLClient.mock
}

// Times sets number of times Service.ACLClient should be invoked
func (mmACLClient *mServiceMockACLClient) Times(n uint64) *mServiceMockACLClient {
	if n == 0 {
		mmACLClient.mock.t.Fatalf("Times of ServiceMock.ACLClient mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmACLClient.expectedInvocations, n)
	mmACLClient.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmACLClient
}

func (mmACLClient *mServiceMockACLClient) invocationsDone() bool {
	if len(mmACLClient.expectations) == 0 && mmACLClient.defaultExpectation == nil && mmACLClient.mock.funcACLClient == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmACLClient.mock.afterACLClientCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmACLClient.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ACLClient implements mm_service.Service
func (mmACLClient *ServiceMock) ACLClient() (ap1 *acl.ACLClient) {
	mm_atomic.AddUint64(&mmACLClient.beforeACLClientCounter, 1)
	defer mm_atomic.AddUint64(&mmACLClient.afterACLClientCounter, 1)

	mmACLClient.t.Helper()

	if mmACLClient.inspectFuncACLClient != nil {
		mmACLClient.inspectFuncACLClient()
	}

	if mmACLClient.ACLClientMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmACLClient.ACLClientMock.defaultExpectation.Counter, 1)

		mm_results := mmACLClient.ACLClientMock.defaultExpectation.results
		if mm_results == nil {
			mmACLClient.t.Fatal("No results are set for the ServiceMock.ACLClient")
		}
		return (*mm_results).ap1
	}
	if mmACLClient.funcACLClient != nil {
		return mmACLClient.funcACLClient()
	}
	mmACLClient.t.Fatalf("Unexpected call to ServiceMock.ACLClient.")
	return
}

// ACLClientAfterCounter returns a count of finished ServiceMock.ACLClient invocations
func (mmACLClient *ServiceMock) ACLClientAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmACLClient.afterACLClientCounter)
}

// ACLClientBeforeCounter returns a count of ServiceMock.ACLClient invocations
func (mmACLClient *ServiceMock) ACLClientBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmACLClient.beforeACLClientCounter)
}

// MinimockACLClientDone returns true if the count of the ACLClient invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockACLClientDone() bool {
	if m.ACLClientMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ACLClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ACLClientMock.invocationsDone()
}

// MinimockACLClientInspect logs each unmet expectation
func (m *ServiceMock) MinimockACLClientInspect() {
	for _, e := range m.ACLClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServiceMock.ACLClient")
		}
	}

	afterACLClientCounter := mm_atomic.LoadUint64(&m.afterACLClientCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ACLClientMock.defaultExpectation != nil && afterACLClientCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.ACLClient at\n%s", m.ACLClientMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcACLClient != nil && afterACLClientCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.ACLClient at\n%s", m.funcACLClientOrigin)
	}

	if !m.ACLClientMock.invocationsDone() && afterACLClientCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.ACLClient at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ACLClientMock.expectedInvocations), m.ACLClientMock.expectedInvocationsOrigin, afterACLClientCounter)
	}
}

type mServiceMockChatWithCache struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockChatWithCacheExpectation
	expectations       []*ServiceMockChatWithCacheExpectation

	callArgs []*ServiceMockChatWithCacheParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockChatWithCacheExpectation specifies expectation struct of the Service.ChatWithCache
type ServiceMockChatWithCacheExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockChatWithCacheParams
	paramPtrs          *ServiceMockChatWithCacheParamPtrs
	expectationOrigins ServiceMockChatWithCacheExpectationOrigins
	results            *ServiceMockChatWithCacheResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockChatWithCacheParams contains parameters of the Service.ChatWithCache
type ServiceMockChatWithCacheParams struct {
	ctx context.Context
	cp1 *repository.ChatCacheMetadata
	s1  string
}

// ServiceMockChatWithCacheParamPtrs contains pointers to parameters of the Service.ChatWithCache
type ServiceMockChatWithCacheParamPtrs struct {
	ctx *context.Context
	cp1 **repository.ChatCacheMetadata
	s1  *string
}

// ServiceMockChatWithCacheResults contains results of the Service.ChatWithCache
type ServiceMockChatWithCacheResults struct {
	s2  string
	err error
}

// ServiceMockChatWithCacheOrigins contains origins of expectations of the Service.ChatWithCache
type ServiceMockChatWithCacheExpectationOrigins struct {
	origin    string
	originCtx string
	originCp1 string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmChatWithCache *mServiceMockChatWithCache) Optional() *mServiceMockChatWithCache {
	mmChatWithCache.optional = true
	return mmChatWithCache
}

// Expect sets up expected params for Service.ChatWithCache
func (mmChatWithCache *mServiceMockChatWithCache) Expect(ctx context.Context, cp1 *repository.ChatCacheMetadata, s1 string) *mServiceMockChatWithCache {
	if mmChatWithCache.mock.funcChatWithCache != nil {
		mmChatWithCache.mock.t.Fatalf("ServiceMock.ChatWithCache mock is already set by Set")
	}

	if mmChatWithCache.defaultExpectation == nil {
		mmChatWithCache.defaultExpectation = &ServiceMockChatWithCacheExpectation{}
	}

	if mmChatWithCache.defaultExpectation.paramPtrs != nil {
		mmChatWithCache.mock.t.Fatalf("ServiceMock.ChatWithCache mock is already set by ExpectParams functions")
	}

	mmChatWithCache.defaultExpectation.params = &ServiceMockChatWithCacheParams{ctx, cp1, s1}
	mmChatWithCache.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmChatWithCache.expectations {
		if minimock.Equal(e.params, mmChatWithCache.defaultExpectation.params) {
			mmChatWithCache.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChatWithCache.defaultExpectation.params)
		}
	}

	return mmChatWithCache
}

// ExpectCtxParam1 sets up expected param ctx for Service.ChatWithCache
func (mmChatWithCache *mServiceMockChatWithCache) ExpectCtxParam1(ctx context.Context) *mServiceMockChatWithCache {
	if mmChatWithCache.mock.funcChatWithCache != nil {
		mmChatWithCache.mock.t.Fatalf("ServiceMock.ChatWithCache mock is already set by Set")
	}

	if mmChatWithCache.defaultExpectation == nil {
		mmChatWithCache.defaultExpectation = &ServiceMockChatWithCacheExpectation{}
	}

	if mmChatWithCache.defaultExpectation.params != nil {
		mmChatWithCache.mock.t.Fatalf("ServiceMock.ChatWithCache mock is already set by Expect")
	}

	if mmChatWithCache.defaultExpectation.paramPtrs == nil {
		mmChatWithCache.defaultExpectation.paramPtrs = &ServiceMockChatWithCacheParamPtrs{}
	}
	mmChatWithCache.defaultExpectation.paramPtrs.ctx = &ctx
	mmChatWithCache.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmChatWithCache
}

// ExpectCp1Param2 sets up expected param cp1 for Service.ChatWithCache
func (mmChatWithCache *mServiceMockChatWithCache) ExpectCp1Param2(cp1 *repository.ChatCacheMetadata) *mServiceMockChatWithCache {
	if mmChatWithCache.mock.funcChatWithCache != nil {
		mmChatWithCache.mock.t.Fatalf("ServiceMock.ChatWithCache mock is already set by Set")
	}

	if mmChatWithCache.defaultExpectation == nil {
		mmChatWithCache.defaultExpectation = &ServiceMockChatWithCacheExpectation{}
	}

	if mmChatWithCache.defaultExpectation.params != nil {
		mmChatWithCache.mock.t.Fatalf("ServiceMock.ChatWithCache mock is already set by Expect")
	}

	if mmChatWithCache.defaultExpectation.paramPtrs == nil {
		mmChatWithCache.defaultExpectation.paramPtrs = &ServiceMockChatWithCacheParamPtrs{}
	}
	mmChatWithCache.defaultExpectation.paramPtrs.cp1 = &cp1
	mmChatWithCache.defaultExpectation.expectationOrigins.originCp1 = minimock.CallerInfo(1)

	return mmChatWithCache
}

// ExpectS1Param3 sets up expected param s1 for Service.ChatWithCache
func (mmChatWithCache *mServiceMockChatWithCache) ExpectS1Param3(s1 string) *mServiceMockChatWithCache {
	if mmChatWithCache.mock.funcChatWithCache != nil {
		mmChatWithCache.mock.t.Fatalf("ServiceMock.ChatWithCache mock is already set by Set")
	}

	if mmChatWithCache.defaultExpectation == nil {
		mmChatWithCache.defaultExpectation = &ServiceMockChatWithCacheExpectation{}
	}

	if mmChatWithCache.defaultExpectation.params != nil {
		mmChatWithCache.mock.t.Fatalf("ServiceMock.ChatWithCache mock is already set by Expect")
	}

	if mmChatWithCache.defaultExpectation.paramPtrs == nil {
		mmChatWithCache.defaultExpectation.paramPtrs = &ServiceMockChatWithCacheParamPtrs{}
	}
	mmChatWithCache.defaultExpectation.paramPtrs.s1 = &s1
	mmChatWithCache.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmChatWithCache
}

// Inspect accepts an inspector function that has same arguments as the Service.ChatWithCache
func (mmChatWithCache *mServiceMockChatWithCache) Inspect(f func(ctx context.Context, cp1 *repository.ChatCacheMetadata, s1 string)) *mServiceMockChatWithCache {
	if mmChatWithCache.mock.inspectFuncChatWithCache != nil {
		mmChatWithCache.mock.t.Fatalf("Inspect function is already set for ServiceMock.ChatWithCache")
	}

	mmChatWithCache.mock.inspectFuncChatWithCache = f

	return mmChatWithCache
}

// Return sets up results that will be returned by Service.ChatWithCache
func (mmChatWithCache *mServiceMockChatWithCache) Return(s2 string, err error) *ServiceMock {
	if mmChatWithCache.mock.funcChatWithCache != nil {
		mmChatWithCache.mock.t.Fatalf("ServiceMock.ChatWithCache mock is already set by Set")
	}

	if mmChatWithCache.defaultExpectation == nil {
		mmChatWithCache.defaultExpectation = &ServiceMockChatWithCacheExpectation{mock: mmChatWithCache.mock}
	}
	mmChatWithCache.defaultExpectation.results = &ServiceMockChatWithCacheResults{s2, err}
	mmChatWithCache.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmChatWithCache.mock
}

// Set uses given function f to mock the Service.ChatWithCache method
func (mmChatWithCache *mServiceMockChatWithCache) Set(f func(ctx context.Context, cp1 *repository.ChatCacheMetadata, s1 string) (s2 string, err error)) *ServiceMock {
	if mmChatWithCache.defaultExpectation != nil {
		mmChatWithCache.mock.t.Fatalf("Default expectation is already set for the Service.ChatWithCache method")
	}

	if len(mmChatWithCache.expectations) > 0 {
		mmChatWithCache.mock.t.Fatalf("Some expectations are already set for the Service.ChatWithCache method")
	}

	mmChatWithCache.mock.funcChatWithCache = f
	mmChatWithCache.mock.funcChatWithCacheOrigin = minimock.CallerInfo(1)
	return mmChatWithCache.mock
}

// When sets expectation for the Service.ChatWithCache which will trigger the result defined by the following
// Then helper
func (mmChatWithCache *mServiceMockChatWithCache) When(ctx context.Context, cp1 *repository.ChatCacheMetadata, s1 string) *ServiceMockChatWithCacheExpectation {
	if mmChatWithCache.mock.funcChatWithCache != nil {
		mmChatWithCache.mock.t.Fatalf("ServiceMock.ChatWithCache mock is already set by Set")
	}

	expectation := &ServiceMockChatWithCacheExpectation{
		mock:               mmChatWithCache.mock,
		params:             &ServiceMockChatWithCacheParams{ctx, cp1, s1},
		expectationOrigins: ServiceMockChatWithCacheExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmChatWithCache.expectations = append(mmChatWithCache.expectations, expectation)
	return expectation
}

// Then sets up Service.ChatWithCache return parameters for the expectation previously defined by the When method
func (e *ServiceMockChatWithCacheExpectation) Then(s2 string, err error) *ServiceMock {
	e.results = &ServiceMockChatWithCacheResults{s2, err}
	return e.mock
}

// Times sets number of times Service.ChatWithCache should be invoked
func (mmChatWithCache *mServiceMockChatWithCache) Times(n uint64) *mServiceMockChatWithCache {
	if n == 0 {
		mmChatWithCache.mock.t.Fatalf("Times of ServiceMock.ChatWithCache mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmChatWithCache.expectedInvocations, n)
	mmChatWithCache.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmChatWithCache
}

func (mmChatWithCache *mServiceMockChatWithCache) invocationsDone() bool {
	if len(mmChatWithCache.expectations) == 0 && mmChatWithCache.defaultExpectation == nil && mmChatWithCache.mock.funcChatWithCache == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmChatWithCache.mock.afterChatWithCacheCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmChatWithCache.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ChatWithCache implements mm_service.Service
func (mmChatWithCache *ServiceMock) ChatWithCache(ctx context.Context, cp1 *repository.ChatCacheMetadata, s1 string) (s2 string, err error) {
	mm_atomic.AddUint64(&mmChatWithCache.beforeChatWithCacheCounter, 1)
	defer mm_atomic.AddUint64(&mmChatWithCache.afterChatWithCacheCounter, 1)

	mmChatWithCache.t.Helper()

	if mmChatWithCache.inspectFuncChatWithCache != nil {
		mmChatWithCache.inspectFuncChatWithCache(ctx, cp1, s1)
	}

	mm_params := ServiceMockChatWithCacheParams{ctx, cp1, s1}

	// Record call args
	mmChatWithCache.ChatWithCacheMock.mutex.Lock()
	mmChatWithCache.ChatWithCacheMock.callArgs = append(mmChatWithCache.ChatWithCacheMock.callArgs, &mm_params)
	mmChatWithCache.ChatWithCacheMock.mutex.Unlock()

	for _, e := range mmChatWithCache.ChatWithCacheMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2, e.results.err
		}
	}

	if mmChatWithCache.ChatWithCacheMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChatWithCache.ChatWithCacheMock.defaultExpectation.Counter, 1)
		mm_want := mmChatWithCache.ChatWithCacheMock.defaultExpectation.params
		mm_want_ptrs := mmChatWithCache.ChatWithCacheMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockChatWithCacheParams{ctx, cp1, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmChatWithCache.t.Errorf("ServiceMock.ChatWithCache got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChatWithCache.ChatWithCacheMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cp1 != nil && !minimock.Equal(*mm_want_ptrs.cp1, mm_got.cp1) {
				mmChatWithCache.t.Errorf("ServiceMock.ChatWithCache got unexpected parameter cp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChatWithCache.ChatWithCacheMock.defaultExpectation.expectationOrigins.originCp1, *mm_want_ptrs.cp1, mm_got.cp1, minimock.Diff(*mm_want_ptrs.cp1, mm_got.cp1))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmChatWithCache.t.Errorf("ServiceMock.ChatWithCache got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChatWithCache.ChatWithCacheMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChatWithCache.t.Errorf("ServiceMock.ChatWithCache got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmChatWithCache.ChatWithCacheMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChatWithCache.ChatWithCacheMock.defaultExpectation.results
		if mm_results == nil {
			mmChatWithCache.t.Fatal("No results are set for the ServiceMock.ChatWithCache")
		}
		return (*mm_results).s2, (*mm_results).err
	}
	if mmChatWithCache.funcChatWithCache != nil {
		return mmChatWithCache.funcChatWithCache(ctx, cp1, s1)
	}
	mmChatWithCache.t.Fatalf("Unexpected call to ServiceMock.ChatWithCache. %v %v %v", ctx, cp1, s1)
	return
}

// ChatWithCacheAfterCounter returns a count of finished ServiceMock.ChatWithCache invocations
func (mmChatWithCache *ServiceMock) ChatWithCacheAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChatWithCache.afterChatWithCacheCounter)
}

// ChatWithCacheBeforeCounter returns a count of ServiceMock.ChatWithCache invocations
func (mmChatWithCache *ServiceMock) ChatWithCacheBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChatWithCache.beforeChatWithCacheCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.ChatWithCache.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChatWithCache *mServiceMockChatWithCache) Calls() []*ServiceMockChatWithCacheParams {
	mmChatWithCache.mutex.RLock()

	argCopy := make([]*ServiceMockChatWithCacheParams, len(mmChatWithCache.callArgs))
	copy(argCopy, mmChatWithCache.callArgs)

	mmChatWithCache.mutex.RUnlock()

	return argCopy
}

// MinimockChatWithCacheDone returns true if the count of the ChatWithCache invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockChatWithCacheDone() bool {
	if m.ChatWithCacheMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ChatWithCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ChatWithCacheMock.invocationsDone()
}

// MinimockChatWithCacheInspect logs each unmet expectation
func (m *ServiceMock) MinimockChatWithCacheInspect() {
	for _, e := range m.ChatWithCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.ChatWithCache at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterChatWithCacheCounter := mm_atomic.LoadUint64(&m.afterChatWithCacheCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ChatWithCacheMock.defaultExpectation != nil && afterChatWithCacheCounter < 1 {
		if m.ChatWithCacheMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.ChatWithCache at\n%s", m.ChatWithCacheMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.ChatWithCache at\n%s with params: %#v", m.ChatWithCacheMock.defaultExpectation.expectationOrigins.origin, *m.ChatWithCacheMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChatWithCache != nil && afterChatWithCacheCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.ChatWithCache at\n%s", m.funcChatWithCacheOrigin)
	}

	if !m.ChatWithCacheMock.invocationsDone() && afterChatWithCacheCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.ChatWithCache at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ChatWithCacheMock.expectedInvocations), m.ChatWithCacheMock.expectedInvocationsOrigin, afterChatWithCacheCounter)
	}
}

type mServiceMockCheckCatalogUserPermission struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockCheckCatalogUserPermissionExpectation
	expectations       []*ServiceMockCheckCatalogUserPermissionExpectation

	callArgs []*ServiceMockCheckCatalogUserPermissionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockCheckCatalogUserPermissionExpectation specifies expectation struct of the Service.CheckCatalogUserPermission
type ServiceMockCheckCatalogUserPermissionExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockCheckCatalogUserPermissionParams
	paramPtrs          *ServiceMockCheckCatalogUserPermissionParamPtrs
	expectationOrigins ServiceMockCheckCatalogUserPermissionExpectationOrigins
	results            *ServiceMockCheckCatalogUserPermissionResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockCheckCatalogUserPermissionParams contains parameters of the Service.CheckCatalogUserPermission
type ServiceMockCheckCatalogUserPermissionParams struct {
	ctx context.Context
	s1  string
	s2  string
	s3  string
}

// ServiceMockCheckCatalogUserPermissionParamPtrs contains pointers to parameters of the Service.CheckCatalogUserPermission
type ServiceMockCheckCatalogUserPermissionParamPtrs struct {
	ctx *context.Context
	s1  *string
	s2  *string
	s3  *string
}

// ServiceMockCheckCatalogUserPermissionResults contains results of the Service.CheckCatalogUserPermission
type ServiceMockCheckCatalogUserPermissionResults struct {
	np1 *resource.Namespace
	kp1 *repository.KnowledgeBaseModel
	err error
}

// ServiceMockCheckCatalogUserPermissionOrigins contains origins of expectations of the Service.CheckCatalogUserPermission
type ServiceMockCheckCatalogUserPermissionExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
	originS2  string
	originS3  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) Optional() *mServiceMockCheckCatalogUserPermission {
	mmCheckCatalogUserPermission.optional = true
	return mmCheckCatalogUserPermission
}

// Expect sets up expected params for Service.CheckCatalogUserPermission
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) Expect(ctx context.Context, s1 string, s2 string, s3 string) *mServiceMockCheckCatalogUserPermission {
	if mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermission != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Set")
	}

	if mmCheckCatalogUserPermission.defaultExpectation == nil {
		mmCheckCatalogUserPermission.defaultExpectation = &ServiceMockCheckCatalogUserPermissionExpectation{}
	}

	if mmCheckCatalogUserPermission.defaultExpectation.paramPtrs != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by ExpectParams functions")
	}

	mmCheckCatalogUserPermission.defaultExpectation.params = &ServiceMockCheckCatalogUserPermissionParams{ctx, s1, s2, s3}
	mmCheckCatalogUserPermission.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckCatalogUserPermission.expectations {
		if minimock.Equal(e.params, mmCheckCatalogUserPermission.defaultExpectation.params) {
			mmCheckCatalogUserPermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckCatalogUserPermission.defaultExpectation.params)
		}
	}

	return mmCheckCatalogUserPermission
}

// ExpectCtxParam1 sets up expected param ctx for Service.CheckCatalogUserPermission
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) ExpectCtxParam1(ctx context.Context) *mServiceMockCheckCatalogUserPermission {
	if mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermission != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Set")
	}

	if mmCheckCatalogUserPermission.defaultExpectation == nil {
		mmCheckCatalogUserPermission.defaultExpectation = &ServiceMockCheckCatalogUserPermissionExpectation{}
	}

	if mmCheckCatalogUserPermission.defaultExpectation.params != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Expect")
	}

	if mmCheckCatalogUserPermission.defaultExpectation.paramPtrs == nil {
		mmCheckCatalogUserPermission.defaultExpectation.paramPtrs = &ServiceMockCheckCatalogUserPermissionParamPtrs{}
	}
	mmCheckCatalogUserPermission.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckCatalogUserPermission.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckCatalogUserPermission
}

// ExpectS1Param2 sets up expected param s1 for Service.CheckCatalogUserPermission
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) ExpectS1Param2(s1 string) *mServiceMockCheckCatalogUserPermission {
	if mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermission != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Set")
	}

	if mmCheckCatalogUserPermission.defaultExpectation == nil {
		mmCheckCatalogUserPermission.defaultExpectation = &ServiceMockCheckCatalogUserPermissionExpectation{}
	}

	if mmCheckCatalogUserPermission.defaultExpectation.params != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Expect")
	}

	if mmCheckCatalogUserPermission.defaultExpectation.paramPtrs == nil {
		mmCheckCatalogUserPermission.defaultExpectation.paramPtrs = &ServiceMockCheckCatalogUserPermissionParamPtrs{}
	}
	mmCheckCatalogUserPermission.defaultExpectation.paramPtrs.s1 = &s1
	mmCheckCatalogUserPermission.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmCheckCatalogUserPermission
}

// ExpectS2Param3 sets up expected param s2 for Service.CheckCatalogUserPermission
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) ExpectS2Param3(s2 string) *mServiceMockCheckCatalogUserPermission {
	if mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermission != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Set")
	}

	if mmCheckCatalogUserPermission.defaultExpectation == nil {
		mmCheckCatalogUserPermission.defaultExpectation = &ServiceMockCheckCatalogUserPermissionExpectation{}
	}

	if mmCheckCatalogUserPermission.defaultExpectation.params != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Expect")
	}

	if mmCheckCatalogUserPermission.defaultExpectation.paramPtrs == nil {
		mmCheckCatalogUserPermission.defaultExpectation.paramPtrs = &ServiceMockCheckCatalogUserPermissionParamPtrs{}
	}
	mmCheckCatalogUserPermission.defaultExpectation.paramPtrs.s2 = &s2
	mmCheckCatalogUserPermission.defaultExpectation.expectationOrigins.originS2 = minimock.CallerInfo(1)

	return mmCheckCatalogUserPermission
}

// ExpectS3Param4 sets up expected param s3 for Service.CheckCatalogUserPermission
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) ExpectS3Param4(s3 string) *mServiceMockCheckCatalogUserPermission {
	if mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermission != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Set")
	}

	if mmCheckCatalogUserPermission.defaultExpectation == nil {
		mmCheckCatalogUserPermission.defaultExpectation = &ServiceMockCheckCatalogUserPermissionExpectation{}
	}

	if mmCheckCatalogUserPermission.defaultExpectation.params != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Expect")
	}

	if mmCheckCatalogUserPermission.defaultExpectation.paramPtrs == nil {
		mmCheckCatalogUserPermission.defaultExpectation.paramPtrs = &ServiceMockCheckCatalogUserPermissionParamPtrs{}
	}
	mmCheckCatalogUserPermission.defaultExpectation.paramPtrs.s3 = &s3
	mmCheckCatalogUserPermission.defaultExpectation.expectationOrigins.originS3 = minimock.CallerInfo(1)

	return mmCheckCatalogUserPermission
}

// Inspect accepts an inspector function that has same arguments as the Service.CheckCatalogUserPermission
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) Inspect(f func(ctx context.Context, s1 string, s2 string, s3 string)) *mServiceMockCheckCatalogUserPermission {
	if mmCheckCatalogUserPermission.mock.inspectFuncCheckCatalogUserPermission != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("Inspect function is already set for ServiceMock.CheckCatalogUserPermission")
	}

	mmCheckCatalogUserPermission.mock.inspectFuncCheckCatalogUserPermission = f

	return mmCheckCatalogUserPermission
}

// Return sets up results that will be returned by Service.CheckCatalogUserPermission
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) Return(np1 *resource.Namespace, kp1 *repository.KnowledgeBaseModel, err error) *ServiceMock {
	if mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermission != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Set")
	}

	if mmCheckCatalogUserPermission.defaultExpectation == nil {
		mmCheckCatalogUserPermission.defaultExpectation = &ServiceMockCheckCatalogUserPermissionExpectation{mock: mmCheckCatalogUserPermission.mock}
	}
	mmCheckCatalogUserPermission.defaultExpectation.results = &ServiceMockCheckCatalogUserPermissionResults{np1, kp1, err}
	mmCheckCatalogUserPermission.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckCatalogUserPermission.mock
}

// Set uses given function f to mock the Service.CheckCatalogUserPermission method
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) Set(f func(ctx context.Context, s1 string, s2 string, s3 string) (np1 *resource.Namespace, kp1 *repository.KnowledgeBaseModel, err error)) *ServiceMock {
	if mmCheckCatalogUserPermission.defaultExpectation != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("Default expectation is already set for the Service.CheckCatalogUserPermission method")
	}

	if len(mmCheckCatalogUserPermission.expectations) > 0 {
		mmCheckCatalogUserPermission.mock.t.Fatalf("Some expectations are already set for the Service.CheckCatalogUserPermission method")
	}

	mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermission = f
	mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermissionOrigin = minimock.CallerInfo(1)
	return mmCheckCatalogUserPermission.mock
}

// When sets expectation for the Service.CheckCatalogUserPermission which will trigger the result defined by the following
// Then helper
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) When(ctx context.Context, s1 string, s2 string, s3 string) *ServiceMockCheckCatalogUserPermissionExpectation {
	if mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermission != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Set")
	}

	expectation := &ServiceMockCheckCatalogUserPermissionExpectation{
		mock:               mmCheckCatalogUserPermission.mock,
		params:             &ServiceMockCheckCatalogUserPermissionParams{ctx, s1, s2, s3},
		expectationOrigins: ServiceMockCheckCatalogUserPermissionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckCatalogUserPermission.expectations = append(mmCheckCatalogUserPermission.expectations, expectation)
	return expectation
}

// Then sets up Service.CheckCatalogUserPermission return parameters for the expectation previously defined by the When method
func (e *ServiceMockCheckCatalogUserPermissionExpectation) Then(np1 *resource.Namespace, kp1 *repository.KnowledgeBaseModel, err error) *ServiceMock {
	e.results = &ServiceMockCheckCatalogUserPermissionResults{np1, kp1, err}
	return e.mock
}

// Times sets number of times Service.CheckCatalogUserPermission should be invoked
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) Times(n uint64) *mServiceMockCheckCatalogUserPermission {
	if n == 0 {
		mmCheckCatalogUserPermission.mock.t.Fatalf("Times of ServiceMock.CheckCatalogUserPermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckCatalogUserPermission.expectedInvocations, n)
	mmCheckCatalogUserPermission.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckCatalogUserPermission
}

func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) invocationsDone() bool {
	if len(mmCheckCatalogUserPermission.expectations) == 0 && mmCheckCatalogUserPermission.defaultExpectation == nil && mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckCatalogUserPermission.mock.afterCheckCatalogUserPermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckCatalogUserPermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckCatalogUserPermission implements mm_service.Service
func (mmCheckCatalogUserPermission *ServiceMock) CheckCatalogUserPermission(ctx context.Context, s1 string, s2 string, s3 string) (np1 *resource.Namespace, kp1 *repository.KnowledgeBaseModel, err error) {
	mm_atomic.AddUint64(&mmCheckCatalogUserPermission.beforeCheckCatalogUserPermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckCatalogUserPermission.afterCheckCatalogUserPermissionCounter, 1)

	mmCheckCatalogUserPermission.t.Helper()

	if mmCheckCatalogUserPermission.inspectFuncCheckCatalogUserPermission != nil {
		mmCheckCatalogUserPermission.inspectFuncCheckCatalogUserPermission(ctx, s1, s2, s3)
	}

	mm_params := ServiceMockCheckCatalogUserPermissionParams{ctx, s1, s2, s3}

	// Record call args
	mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.mutex.Lock()
	mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.callArgs = append(mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.callArgs, &mm_params)
	mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.mutex.Unlock()

	for _, e := range mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.np1, e.results.kp1, e.results.err
		}
	}

	if mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation.params
		mm_want_ptrs := mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockCheckCatalogUserPermissionParams{ctx, s1, s2, s3}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckCatalogUserPermission.t.Errorf("ServiceMock.CheckCatalogUserPermission got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmCheckCatalogUserPermission.t.Errorf("ServiceMock.CheckCatalogUserPermission got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

			if mm_want_ptrs.s2 != nil && !minimock.Equal(*mm_want_ptrs.s2, mm_got.s2) {
				mmCheckCatalogUserPermission.t.Errorf("ServiceMock.CheckCatalogUserPermission got unexpected parameter s2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation.expectationOrigins.originS2, *mm_want_ptrs.s2, mm_got.s2, minimock.Diff(*mm_want_ptrs.s2, mm_got.s2))
			}

			if mm_want_ptrs.s3 != nil && !minimock.Equal(*mm_want_ptrs.s3, mm_got.s3) {
				mmCheckCatalogUserPermission.t.Errorf("ServiceMock.CheckCatalogUserPermission got unexpected parameter s3, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation.expectationOrigins.originS3, *mm_want_ptrs.s3, mm_got.s3, minimock.Diff(*mm_want_ptrs.s3, mm_got.s3))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckCatalogUserPermission.t.Errorf("ServiceMock.CheckCatalogUserPermission got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckCatalogUserPermission.t.Fatal("No results are set for the ServiceMock.CheckCatalogUserPermission")
		}
		return (*mm_results).np1, (*mm_results).kp1, (*mm_results).err
	}
	if mmCheckCatalogUserPermission.funcCheckCatalogUserPermission != nil {
		return mmCheckCatalogUserPermission.funcCheckCatalogUserPermission(ctx, s1, s2, s3)
	}
	mmCheckCatalogUserPermission.t.Fatalf("Unexpected call to ServiceMock.CheckCatalogUserPermission. %v %v %v %v", ctx, s1, s2, s3)
	return
}

// CheckCatalogUserPermissionAfterCounter returns a count of finished ServiceMock.CheckCatalogUserPermission invocations
func (mmCheckCatalogUserPermission *ServiceMock) CheckCatalogUserPermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckCatalogUserPermission.afterCheckCatalogUserPermissionCounter)
}

// CheckCatalogUserPermissionBeforeCounter returns a count of ServiceMock.CheckCatalogUserPermission invocations
func (mmCheckCatalogUserPermission *ServiceMock) CheckCatalogUserPermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckCatalogUserPermission.beforeCheckCatalogUserPermissionCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.CheckCatalogUserPermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) Calls() []*ServiceMockCheckCatalogUserPermissionParams {
	mmCheckCatalogUserPermission.mutex.RLock()

	argCopy := make([]*ServiceMockCheckCatalogUserPermissionParams, len(mmCheckCatalogUserPermission.callArgs))
	copy(argCopy, mmCheckCatalogUserPermission.callArgs)

	mmCheckCatalogUserPermission.mutex.RUnlock()

	return argCopy
}

// MinimockCheckCatalogUserPermissionDone returns true if the count of the CheckCatalogUserPermission invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCheckCatalogUserPermissionDone() bool {
	if m.CheckCatalogUserPermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckCatalogUserPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckCatalogUserPermissionMock.invocationsDone()
}

// MinimockCheckCatalogUserPermissionInspect logs each unmet expectation
func (m *ServiceMock) MinimockCheckCatalogUserPermissionInspect() {
	for _, e := range m.CheckCatalogUserPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.CheckCatalogUserPermission at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckCatalogUserPermissionCounter := mm_atomic.LoadUint64(&m.afterCheckCatalogUserPermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckCatalogUserPermissionMock.defaultExpectation != nil && afterCheckCatalogUserPermissionCounter < 1 {
		if m.CheckCatalogUserPermissionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.CheckCatalogUserPermission at\n%s", m.CheckCatalogUserPermissionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.CheckCatalogUserPermission at\n%s with params: %#v", m.CheckCatalogUserPermissionMock.defaultExpectation.expectationOrigins.origin, *m.CheckCatalogUserPermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckCatalogUserPermission != nil && afterCheckCatalogUserPermissionCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.CheckCatalogUserPermission at\n%s", m.funcCheckCatalogUserPermissionOrigin)
	}

	if !m.CheckCatalogUserPermissionMock.invocationsDone() && afterCheckCatalogUserPermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.CheckCatalogUserPermission at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckCatalogUserPermissionMock.expectedInvocations), m.CheckCatalogUserPermissionMock.expectedInvocationsOrigin, afterCheckCatalogUserPermissionCounter)
	}
}

type mServiceMockCheckFilesProcessingStatus struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockCheckFilesProcessingStatusExpectation
	expectations       []*ServiceMockCheckFilesProcessingStatusExpectation

	callArgs []*ServiceMockCheckFilesProcessingStatusParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockCheckFilesProcessingStatusExpectation specifies expectation struct of the Service.CheckFilesProcessingStatus
type ServiceMockCheckFilesProcessingStatusExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockCheckFilesProcessingStatusParams
	paramPtrs          *ServiceMockCheckFilesProcessingStatusParamPtrs
	expectationOrigins ServiceMockCheckFilesProcessingStatusExpectationOrigins
	results            *ServiceMockCheckFilesProcessingStatusResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockCheckFilesProcessingStatusParams contains parameters of the Service.CheckFilesProcessingStatus
type ServiceMockCheckFilesProcessingStatusParams struct {
	ctx context.Context
	fa1 []types.FileUIDType
}

// ServiceMockCheckFilesProcessingStatusParamPtrs contains pointers to parameters of the Service.CheckFilesProcessingStatus
type ServiceMockCheckFilesProcessingStatusParamPtrs struct {
	ctx *context.Context
	fa1 *[]types.FileUIDType
}

// ServiceMockCheckFilesProcessingStatusResults contains results of the Service.CheckFilesProcessingStatus
type ServiceMockCheckFilesProcessingStatusResults struct {
	allCompleted    bool
	processingCount int
	err             error
}

// ServiceMockCheckFilesProcessingStatusOrigins contains origins of expectations of the Service.CheckFilesProcessingStatus
type ServiceMockCheckFilesProcessingStatusExpectationOrigins struct {
	origin    string
	originCtx string
	originFa1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckFilesProcessingStatus *mServiceMockCheckFilesProcessingStatus) Optional() *mServiceMockCheckFilesProcessingStatus {
	mmCheckFilesProcessingStatus.optional = true
	return mmCheckFilesProcessingStatus
}

// Expect sets up expected params for Service.CheckFilesProcessingStatus
func (mmCheckFilesProcessingStatus *mServiceMockCheckFilesProcessingStatus) Expect(ctx context.Context, fa1 []types.FileUIDType) *mServiceMockCheckFilesProcessingStatus {
	if mmCheckFilesProcessingStatus.mock.funcCheckFilesProcessingStatus != nil {
		mmCheckFilesProcessingStatus.mock.t.Fatalf("ServiceMock.CheckFilesProcessingStatus mock is already set by Set")
	}

	if mmCheckFilesProcessingStatus.defaultExpectation == nil {
		mmCheckFilesProcessingStatus.defaultExpectation = &ServiceMockCheckFilesProcessingStatusExpectation{}
	}

	if mmCheckFilesProcessingStatus.defaultExpectation.paramPtrs != nil {
		mmCheckFilesProcessingStatus.mock.t.Fatalf("ServiceMock.CheckFilesProcessingStatus mock is already set by ExpectParams functions")
	}

	mmCheckFilesProcessingStatus.defaultExpectation.params = &ServiceMockCheckFilesProcessingStatusParams{ctx, fa1}
	mmCheckFilesProcessingStatus.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckFilesProcessingStatus.expectations {
		if minimock.Equal(e.params, mmCheckFilesProcessingStatus.defaultExpectation.params) {
			mmCheckFilesProcessingStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckFilesProcessingStatus.defaultExpectation.params)
		}
	}

	return mmCheckFilesProcessingStatus
}

// ExpectCtxParam1 sets up expected param ctx for Service.CheckFilesProcessingStatus
func (mmCheckFilesProcessingStatus *mServiceMockCheckFilesProcessingStatus) ExpectCtxParam1(ctx context.Context) *mServiceMockCheckFilesProcessingStatus {
	if mmCheckFilesProcessingStatus.mock.funcCheckFilesProcessingStatus != nil {
		mmCheckFilesProcessingStatus.mock.t.Fatalf("ServiceMock.CheckFilesProcessingStatus mock is already set by Set")
	}

	if mmCheckFilesProcessingStatus.defaultExpectation == nil {
		mmCheckFilesProcessingStatus.defaultExpectation = &ServiceMockCheckFilesProcessingStatusExpectation{}
	}

	if mmCheckFilesProcessingStatus.defaultExpectation.params != nil {
		mmCheckFilesProcessingStatus.mock.t.Fatalf("ServiceMock.CheckFilesProcessingStatus mock is already set by Expect")
	}

	if mmCheckFilesProcessingStatus.defaultExpectation.paramPtrs == nil {
		mmCheckFilesProcessingStatus.defaultExpectation.paramPtrs = &ServiceMockCheckFilesProcessingStatusParamPtrs{}
	}
	mmCheckFilesProcessingStatus.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckFilesProcessingStatus.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckFilesProcessingStatus
}

// ExpectFa1Param2 sets up expected param fa1 for Service.CheckFilesProcessingStatus
func (mmCheckFilesProcessingStatus *mServiceMockCheckFilesProcessingStatus) ExpectFa1Param2(fa1 []types.FileUIDType) *mServiceMockCheckFilesProcessingStatus {
	if mmCheckFilesProcessingStatus.mock.funcCheckFilesProcessingStatus != nil {
		mmCheckFilesProcessingStatus.mock.t.Fatalf("ServiceMock.CheckFilesProcessingStatus mock is already set by Set")
	}

	if mmCheckFilesProcessingStatus.defaultExpectation == nil {
		mmCheckFilesProcessingStatus.defaultExpectation = &ServiceMockCheckFilesProcessingStatusExpectation{}
	}

	if mmCheckFilesProcessingStatus.defaultExpectation.params != nil {
		mmCheckFilesProcessingStatus.mock.t.Fatalf("ServiceMock.CheckFilesProcessingStatus mock is already set by Expect")
	}

	if mmCheckFilesProcessingStatus.defaultExpectation.paramPtrs == nil {
		mmCheckFilesProcessingStatus.defaultExpectation.paramPtrs = &ServiceMockCheckFilesProcessingStatusParamPtrs{}
	}
	mmCheckFilesProcessingStatus.defaultExpectation.paramPtrs.fa1 = &fa1
	mmCheckFilesProcessingStatus.defaultExpectation.expectationOrigins.originFa1 = minimock.CallerInfo(1)

	return mmCheckFilesProcessingStatus
}

// Inspect accepts an inspector function that has same arguments as the Service.CheckFilesProcessingStatus
func (mmCheckFilesProcessingStatus *mServiceMockCheckFilesProcessingStatus) Inspect(f func(ctx context.Context, fa1 []types.FileUIDType)) *mServiceMockCheckFilesProcessingStatus {
	if mmCheckFilesProcessingStatus.mock.inspectFuncCheckFilesProcessingStatus != nil {
		mmCheckFilesProcessingStatus.mock.t.Fatalf("Inspect function is already set for ServiceMock.CheckFilesProcessingStatus")
	}

	mmCheckFilesProcessingStatus.mock.inspectFuncCheckFilesProcessingStatus = f

	return mmCheckFilesProcessingStatus
}

// Return sets up results that will be returned by Service.CheckFilesProcessingStatus
func (mmCheckFilesProcessingStatus *mServiceMockCheckFilesProcessingStatus) Return(allCompleted bool, processingCount int, err error) *ServiceMock {
	if mmCheckFilesProcessingStatus.mock.funcCheckFilesProcessingStatus != nil {
		mmCheckFilesProcessingStatus.mock.t.Fatalf("ServiceMock.CheckFilesProcessingStatus mock is already set by Set")
	}

	if mmCheckFilesProcessingStatus.defaultExpectation == nil {
		mmCheckFilesProcessingStatus.defaultExpectation = &ServiceMockCheckFilesProcessingStatusExpectation{mock: mmCheckFilesProcessingStatus.mock}
	}
	mmCheckFilesProcessingStatus.defaultExpectation.results = &ServiceMockCheckFilesProcessingStatusResults{allCompleted, processingCount, err}
	mmCheckFilesProcessingStatus.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckFilesProcessingStatus.mock
}

// Set uses given function f to mock the Service.CheckFilesProcessingStatus method
func (mmCheckFilesProcessingStatus *mServiceMockCheckFilesProcessingStatus) Set(f func(ctx context.Context, fa1 []types.FileUIDType) (allCompleted bool, processingCount int, err error)) *ServiceMock {
	if mmCheckFilesProcessingStatus.defaultExpectation != nil {
		mmCheckFilesProcessingStatus.mock.t.Fatalf("Default expectation is already set for the Service.CheckFilesProcessingStatus method")
	}

	if len(mmCheckFilesProcessingStatus.expectations) > 0 {
		mmCheckFilesProcessingStatus.mock.t.Fatalf("Some expectations are already set for the Service.CheckFilesProcessingStatus method")
	}

	mmCheckFilesProcessingStatus.mock.funcCheckFilesProcessingStatus = f
	mmCheckFilesProcessingStatus.mock.funcCheckFilesProcessingStatusOrigin = minimock.CallerInfo(1)
	return mmCheckFilesProcessingStatus.mock
}

// When sets expectation for the Service.CheckFilesProcessingStatus which will trigger the result defined by the following
// Then helper
func (mmCheckFilesProcessingStatus *mServiceMockCheckFilesProcessingStatus) When(ctx context.Context, fa1 []types.FileUIDType) *ServiceMockCheckFilesProcessingStatusExpectation {
	if mmCheckFilesProcessingStatus.mock.funcCheckFilesProcessingStatus != nil {
		mmCheckFilesProcessingStatus.mock.t.Fatalf("ServiceMock.CheckFilesProcessingStatus mock is already set by Set")
	}

	expectation := &ServiceMockCheckFilesProcessingStatusExpectation{
		mock:               mmCheckFilesProcessingStatus.mock,
		params:             &ServiceMockCheckFilesProcessingStatusParams{ctx, fa1},
		expectationOrigins: ServiceMockCheckFilesProcessingStatusExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckFilesProcessingStatus.expectations = append(mmCheckFilesProcessingStatus.expectations, expectation)
	return expectation
}

// Then sets up Service.CheckFilesProcessingStatus return parameters for the expectation previously defined by the When method
func (e *ServiceMockCheckFilesProcessingStatusExpectation) Then(allCompleted bool, processingCount int, err error) *ServiceMock {
	e.results = &ServiceMockCheckFilesProcessingStatusResults{allCompleted, processingCount, err}
	return e.mock
}

// Times sets number of times Service.CheckFilesProcessingStatus should be invoked
func (mmCheckFilesProcessingStatus *mServiceMockCheckFilesProcessingStatus) Times(n uint64) *mServiceMockCheckFilesProcessingStatus {
	if n == 0 {
		mmCheckFilesProcessingStatus.mock.t.Fatalf("Times of ServiceMock.CheckFilesProcessingStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckFilesProcessingStatus.expectedInvocations, n)
	mmCheckFilesProcessingStatus.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckFilesProcessingStatus
}

func (mmCheckFilesProcessingStatus *mServiceMockCheckFilesProcessingStatus) invocationsDone() bool {
	if len(mmCheckFilesProcessingStatus.expectations) == 0 && mmCheckFilesProcessingStatus.defaultExpectation == nil && mmCheckFilesProcessingStatus.mock.funcCheckFilesProcessingStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckFilesProcessingStatus.mock.afterCheckFilesProcessingStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckFilesProcessingStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckFilesProcessingStatus implements mm_service.Service
func (mmCheckFilesProcessingStatus *ServiceMock) CheckFilesProcessingStatus(ctx context.Context, fa1 []types.FileUIDType) (allCompleted bool, processingCount int, err error) {
	mm_atomic.AddUint64(&mmCheckFilesProcessingStatus.beforeCheckFilesProcessingStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckFilesProcessingStatus.afterCheckFilesProcessingStatusCounter, 1)

	mmCheckFilesProcessingStatus.t.Helper()

	if mmCheckFilesProcessingStatus.inspectFuncCheckFilesProcessingStatus != nil {
		mmCheckFilesProcessingStatus.inspectFuncCheckFilesProcessingStatus(ctx, fa1)
	}

	mm_params := ServiceMockCheckFilesProcessingStatusParams{ctx, fa1}

	// Record call args
	mmCheckFilesProcessingStatus.CheckFilesProcessingStatusMock.mutex.Lock()
	mmCheckFilesProcessingStatus.CheckFilesProcessingStatusMock.callArgs = append(mmCheckFilesProcessingStatus.CheckFilesProcessingStatusMock.callArgs, &mm_params)
	mmCheckFilesProcessingStatus.CheckFilesProcessingStatusMock.mutex.Unlock()

	for _, e := range mmCheckFilesProcessingStatus.CheckFilesProcessingStatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.allCompleted, e.results.processingCount, e.results.err
		}
	}

	if mmCheckFilesProcessingStatus.CheckFilesProcessingStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckFilesProcessingStatus.CheckFilesProcessingStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckFilesProcessingStatus.CheckFilesProcessingStatusMock.defaultExpectation.params
		mm_want_ptrs := mmCheckFilesProcessingStatus.CheckFilesProcessingStatusMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockCheckFilesProcessingStatusParams{ctx, fa1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckFilesProcessingStatus.t.Errorf("ServiceMock.CheckFilesProcessingStatus got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckFilesProcessingStatus.CheckFilesProcessingStatusMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fa1 != nil && !minimock.Equal(*mm_want_ptrs.fa1, mm_got.fa1) {
				mmCheckFilesProcessingStatus.t.Errorf("ServiceMock.CheckFilesProcessingStatus got unexpected parameter fa1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckFilesProcessingStatus.CheckFilesProcessingStatusMock.defaultExpectation.expectationOrigins.originFa1, *mm_want_ptrs.fa1, mm_got.fa1, minimock.Diff(*mm_want_ptrs.fa1, mm_got.fa1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckFilesProcessingStatus.t.Errorf("ServiceMock.CheckFilesProcessingStatus got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckFilesProcessingStatus.CheckFilesProcessingStatusMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckFilesProcessingStatus.CheckFilesProcessingStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckFilesProcessingStatus.t.Fatal("No results are set for the ServiceMock.CheckFilesProcessingStatus")
		}
		return (*mm_results).allCompleted, (*mm_results).processingCount, (*mm_results).err
	}
	if mmCheckFilesProcessingStatus.funcCheckFilesProcessingStatus != nil {
		return mmCheckFilesProcessingStatus.funcCheckFilesProcessingStatus(ctx, fa1)
	}
	mmCheckFilesProcessingStatus.t.Fatalf("Unexpected call to ServiceMock.CheckFilesProcessingStatus. %v %v", ctx, fa1)
	return
}

// CheckFilesProcessingStatusAfterCounter returns a count of finished ServiceMock.CheckFilesProcessingStatus invocations
func (mmCheckFilesProcessingStatus *ServiceMock) CheckFilesProcessingStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckFilesProcessingStatus.afterCheckFilesProcessingStatusCounter)
}

// CheckFilesProcessingStatusBeforeCounter returns a count of ServiceMock.CheckFilesProcessingStatus invocations
func (mmCheckFilesProcessingStatus *ServiceMock) CheckFilesProcessingStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckFilesProcessingStatus.beforeCheckFilesProcessingStatusCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.CheckFilesProcessingStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckFilesProcessingStatus *mServiceMockCheckFilesProcessingStatus) Calls() []*ServiceMockCheckFilesProcessingStatusParams {
	mmCheckFilesProcessingStatus.mutex.RLock()

	argCopy := make([]*ServiceMockCheckFilesProcessingStatusParams, len(mmCheckFilesProcessingStatus.callArgs))
	copy(argCopy, mmCheckFilesProcessingStatus.callArgs)

	mmCheckFilesProcessingStatus.mutex.RUnlock()

	return argCopy
}

// MinimockCheckFilesProcessingStatusDone returns true if the count of the CheckFilesProcessingStatus invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCheckFilesProcessingStatusDone() bool {
	if m.CheckFilesProcessingStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckFilesProcessingStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckFilesProcessingStatusMock.invocationsDone()
}

// MinimockCheckFilesProcessingStatusInspect logs each unmet expectation
func (m *ServiceMock) MinimockCheckFilesProcessingStatusInspect() {
	for _, e := range m.CheckFilesProcessingStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.CheckFilesProcessingStatus at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckFilesProcessingStatusCounter := mm_atomic.LoadUint64(&m.afterCheckFilesProcessingStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckFilesProcessingStatusMock.defaultExpectation != nil && afterCheckFilesProcessingStatusCounter < 1 {
		if m.CheckFilesProcessingStatusMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.CheckFilesProcessingStatus at\n%s", m.CheckFilesProcessingStatusMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.CheckFilesProcessingStatus at\n%s with params: %#v", m.CheckFilesProcessingStatusMock.defaultExpectation.expectationOrigins.origin, *m.CheckFilesProcessingStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckFilesProcessingStatus != nil && afterCheckFilesProcessingStatusCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.CheckFilesProcessingStatus at\n%s", m.funcCheckFilesProcessingStatusOrigin)
	}

	if !m.CheckFilesProcessingStatusMock.invocationsDone() && afterCheckFilesProcessingStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.CheckFilesProcessingStatus at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckFilesProcessingStatusMock.expectedInvocations), m.CheckFilesProcessingStatusMock.expectedInvocationsOrigin, afterCheckFilesProcessingStatusCounter)
	}
}

type mServiceMockCheckNamespacePermission struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockCheckNamespacePermissionExpectation
	expectations       []*ServiceMockCheckNamespacePermissionExpectation

	callArgs []*ServiceMockCheckNamespacePermissionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockCheckNamespacePermissionExpectation specifies expectation struct of the Service.CheckNamespacePermission
type ServiceMockCheckNamespacePermissionExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockCheckNamespacePermissionParams
	paramPtrs          *ServiceMockCheckNamespacePermissionParamPtrs
	expectationOrigins ServiceMockCheckNamespacePermissionExpectationOrigins
	results            *ServiceMockCheckNamespacePermissionResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockCheckNamespacePermissionParams contains parameters of the Service.CheckNamespacePermission
type ServiceMockCheckNamespacePermissionParams struct {
	ctx context.Context
	np1 *resource.Namespace
}

// ServiceMockCheckNamespacePermissionParamPtrs contains pointers to parameters of the Service.CheckNamespacePermission
type ServiceMockCheckNamespacePermissionParamPtrs struct {
	ctx *context.Context
	np1 **resource.Namespace
}

// ServiceMockCheckNamespacePermissionResults contains results of the Service.CheckNamespacePermission
type ServiceMockCheckNamespacePermissionResults struct {
	err error
}

// ServiceMockCheckNamespacePermissionOrigins contains origins of expectations of the Service.CheckNamespacePermission
type ServiceMockCheckNamespacePermissionExpectationOrigins struct {
	origin    string
	originCtx string
	originNp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) Optional() *mServiceMockCheckNamespacePermission {
	mmCheckNamespacePermission.optional = true
	return mmCheckNamespacePermission
}

// Expect sets up expected params for Service.CheckNamespacePermission
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) Expect(ctx context.Context, np1 *resource.Namespace) *mServiceMockCheckNamespacePermission {
	if mmCheckNamespacePermission.mock.funcCheckNamespacePermission != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("ServiceMock.CheckNamespacePermission mock is already set by Set")
	}

	if mmCheckNamespacePermission.defaultExpectation == nil {
		mmCheckNamespacePermission.defaultExpectation = &ServiceMockCheckNamespacePermissionExpectation{}
	}

	if mmCheckNamespacePermission.defaultExpectation.paramPtrs != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("ServiceMock.CheckNamespacePermission mock is already set by ExpectParams functions")
	}

	mmCheckNamespacePermission.defaultExpectation.params = &ServiceMockCheckNamespacePermissionParams{ctx, np1}
	mmCheckNamespacePermission.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckNamespacePermission.expectations {
		if minimock.Equal(e.params, mmCheckNamespacePermission.defaultExpectation.params) {
			mmCheckNamespacePermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckNamespacePermission.defaultExpectation.params)
		}
	}

	return mmCheckNamespacePermission
}

// ExpectCtxParam1 sets up expected param ctx for Service.CheckNamespacePermission
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) ExpectCtxParam1(ctx context.Context) *mServiceMockCheckNamespacePermission {
	if mmCheckNamespacePermission.mock.funcCheckNamespacePermission != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("ServiceMock.CheckNamespacePermission mock is already set by Set")
	}

	if mmCheckNamespacePermission.defaultExpectation == nil {
		mmCheckNamespacePermission.defaultExpectation = &ServiceMockCheckNamespacePermissionExpectation{}
	}

	if mmCheckNamespacePermission.defaultExpectation.params != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("ServiceMock.CheckNamespacePermission mock is already set by Expect")
	}

	if mmCheckNamespacePermission.defaultExpectation.paramPtrs == nil {
		mmCheckNamespacePermission.defaultExpectation.paramPtrs = &ServiceMockCheckNamespacePermissionParamPtrs{}
	}
	mmCheckNamespacePermission.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckNamespacePermission.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckNamespacePermission
}

// ExpectNp1Param2 sets up expected param np1 for Service.CheckNamespacePermission
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) ExpectNp1Param2(np1 *resource.Namespace) *mServiceMockCheckNamespacePermission {
	if mmCheckNamespacePermission.mock.funcCheckNamespacePermission != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("ServiceMock.CheckNamespacePermission mock is already set by Set")
	}

	if mmCheckNamespacePermission.defaultExpectation == nil {
		mmCheckNamespacePermission.defaultExpectation = &ServiceMockCheckNamespacePermissionExpectation{}
	}

	if mmCheckNamespacePermission.defaultExpectation.params != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("ServiceMock.CheckNamespacePermission mock is already set by Expect")
	}

	if mmCheckNamespacePermission.defaultExpectation.paramPtrs == nil {
		mmCheckNamespacePermission.defaultExpectation.paramPtrs = &ServiceMockCheckNamespacePermissionParamPtrs{}
	}
	mmCheckNamespacePermission.defaultExpectation.paramPtrs.np1 = &np1
	mmCheckNamespacePermission.defaultExpectation.expectationOrigins.originNp1 = minimock.CallerInfo(1)

	return mmCheckNamespacePermission
}

// Inspect accepts an inspector function that has same arguments as the Service.CheckNamespacePermission
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) Inspect(f func(ctx context.Context, np1 *resource.Namespace)) *mServiceMockCheckNamespacePermission {
	if mmCheckNamespacePermission.mock.inspectFuncCheckNamespacePermission != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("Inspect function is already set for ServiceMock.CheckNamespacePermission")
	}

	mmCheckNamespacePermission.mock.inspectFuncCheckNamespacePermission = f

	return mmCheckNamespacePermission
}

// Return sets up results that will be returned by Service.CheckNamespacePermission
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) Return(err error) *ServiceMock {
	if mmCheckNamespacePermission.mock.funcCheckNamespacePermission != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("ServiceMock.CheckNamespacePermission mock is already set by Set")
	}

	if mmCheckNamespacePermission.defaultExpectation == nil {
		mmCheckNamespacePermission.defaultExpectation = &ServiceMockCheckNamespacePermissionExpectation{mock: mmCheckNamespacePermission.mock}
	}
	mmCheckNamespacePermission.defaultExpectation.results = &ServiceMockCheckNamespacePermissionResults{err}
	mmCheckNamespacePermission.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckNamespacePermission.mock
}

// Set uses given function f to mock the Service.CheckNamespacePermission method
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) Set(f func(ctx context.Context, np1 *resource.Namespace) (err error)) *ServiceMock {
	if mmCheckNamespacePermission.defaultExpectation != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("Default expectation is already set for the Service.CheckNamespacePermission method")
	}

	if len(mmCheckNamespacePermission.expectations) > 0 {
		mmCheckNamespacePermission.mock.t.Fatalf("Some expectations are already set for the Service.CheckNamespacePermission method")
	}

	mmCheckNamespacePermission.mock.funcCheckNamespacePermission = f
	mmCheckNamespacePermission.mock.funcCheckNamespacePermissionOrigin = minimock.CallerInfo(1)
	return mmCheckNamespacePermission.mock
}

// When sets expectation for the Service.CheckNamespacePermission which will trigger the result defined by the following
// Then helper
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) When(ctx context.Context, np1 *resource.Namespace) *ServiceMockCheckNamespacePermissionExpectation {
	if mmCheckNamespacePermission.mock.funcCheckNamespacePermission != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("ServiceMock.CheckNamespacePermission mock is already set by Set")
	}

	expectation := &ServiceMockCheckNamespacePermissionExpectation{
		mock:               mmCheckNamespacePermission.mock,
		params:             &ServiceMockCheckNamespacePermissionParams{ctx, np1},
		expectationOrigins: ServiceMockCheckNamespacePermissionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckNamespacePermission.expectations = append(mmCheckNamespacePermission.expectations, expectation)
	return expectation
}

// Then sets up Service.CheckNamespacePermission return parameters for the expectation previously defined by the When method
func (e *ServiceMockCheckNamespacePermissionExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockCheckNamespacePermissionResults{err}
	return e.mock
}

// Times sets number of times Service.CheckNamespacePermission should be invoked
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) Times(n uint64) *mServiceMockCheckNamespacePermission {
	if n == 0 {
		mmCheckNamespacePermission.mock.t.Fatalf("Times of ServiceMock.CheckNamespacePermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckNamespacePermission.expectedInvocations, n)
	mmCheckNamespacePermission.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckNamespacePermission
}

func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) invocationsDone() bool {
	if len(mmCheckNamespacePermission.expectations) == 0 && mmCheckNamespacePermission.defaultExpectation == nil && mmCheckNamespacePermission.mock.funcCheckNamespacePermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckNamespacePermission.mock.afterCheckNamespacePermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckNamespacePermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckNamespacePermission implements mm_service.Service
func (mmCheckNamespacePermission *ServiceMock) CheckNamespacePermission(ctx context.Context, np1 *resource.Namespace) (err error) {
	mm_atomic.AddUint64(&mmCheckNamespacePermission.beforeCheckNamespacePermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckNamespacePermission.afterCheckNamespacePermissionCounter, 1)

	mmCheckNamespacePermission.t.Helper()

	if mmCheckNamespacePermission.inspectFuncCheckNamespacePermission != nil {
		mmCheckNamespacePermission.inspectFuncCheckNamespacePermission(ctx, np1)
	}

	mm_params := ServiceMockCheckNamespacePermissionParams{ctx, np1}

	// Record call args
	mmCheckNamespacePermission.CheckNamespacePermissionMock.mutex.Lock()
	mmCheckNamespacePermission.CheckNamespacePermissionMock.callArgs = append(mmCheckNamespacePermission.CheckNamespacePermissionMock.callArgs, &mm_params)
	mmCheckNamespacePermission.CheckNamespacePermissionMock.mutex.Unlock()

	for _, e := range mmCheckNamespacePermission.CheckNamespacePermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCheckNamespacePermission.CheckNamespacePermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckNamespacePermission.CheckNamespacePermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckNamespacePermission.CheckNamespacePermissionMock.defaultExpectation.params
		mm_want_ptrs := mmCheckNamespacePermission.CheckNamespacePermissionMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockCheckNamespacePermissionParams{ctx, np1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckNamespacePermission.t.Errorf("ServiceMock.CheckNamespacePermission got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckNamespacePermission.CheckNamespacePermissionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.np1 != nil && !minimock.Equal(*mm_want_ptrs.np1, mm_got.np1) {
				mmCheckNamespacePermission.t.Errorf("ServiceMock.CheckNamespacePermission got unexpected parameter np1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckNamespacePermission.CheckNamespacePermissionMock.defaultExpectation.expectationOrigins.originNp1, *mm_want_ptrs.np1, mm_got.np1, minimock.Diff(*mm_want_ptrs.np1, mm_got.np1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckNamespacePermission.t.Errorf("ServiceMock.CheckNamespacePermission got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckNamespacePermission.CheckNamespacePermissionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckNamespacePermission.CheckNamespacePermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckNamespacePermission.t.Fatal("No results are set for the ServiceMock.CheckNamespacePermission")
		}
		return (*mm_results).err
	}
	if mmCheckNamespacePermission.funcCheckNamespacePermission != nil {
		return mmCheckNamespacePermission.funcCheckNamespacePermission(ctx, np1)
	}
	mmCheckNamespacePermission.t.Fatalf("Unexpected call to ServiceMock.CheckNamespacePermission. %v %v", ctx, np1)
	return
}

// CheckNamespacePermissionAfterCounter returns a count of finished ServiceMock.CheckNamespacePermission invocations
func (mmCheckNamespacePermission *ServiceMock) CheckNamespacePermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckNamespacePermission.afterCheckNamespacePermissionCounter)
}

// CheckNamespacePermissionBeforeCounter returns a count of ServiceMock.CheckNamespacePermission invocations
func (mmCheckNamespacePermission *ServiceMock) CheckNamespacePermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckNamespacePermission.beforeCheckNamespacePermissionCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.CheckNamespacePermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) Calls() []*ServiceMockCheckNamespacePermissionParams {
	mmCheckNamespacePermission.mutex.RLock()

	argCopy := make([]*ServiceMockCheckNamespacePermissionParams, len(mmCheckNamespacePermission.callArgs))
	copy(argCopy, mmCheckNamespacePermission.callArgs)

	mmCheckNamespacePermission.mutex.RUnlock()

	return argCopy
}

// MinimockCheckNamespacePermissionDone returns true if the count of the CheckNamespacePermission invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCheckNamespacePermissionDone() bool {
	if m.CheckNamespacePermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckNamespacePermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckNamespacePermissionMock.invocationsDone()
}

// MinimockCheckNamespacePermissionInspect logs each unmet expectation
func (m *ServiceMock) MinimockCheckNamespacePermissionInspect() {
	for _, e := range m.CheckNamespacePermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.CheckNamespacePermission at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckNamespacePermissionCounter := mm_atomic.LoadUint64(&m.afterCheckNamespacePermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckNamespacePermissionMock.defaultExpectation != nil && afterCheckNamespacePermissionCounter < 1 {
		if m.CheckNamespacePermissionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.CheckNamespacePermission at\n%s", m.CheckNamespacePermissionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.CheckNamespacePermission at\n%s with params: %#v", m.CheckNamespacePermissionMock.defaultExpectation.expectationOrigins.origin, *m.CheckNamespacePermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckNamespacePermission != nil && afterCheckNamespacePermissionCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.CheckNamespacePermission at\n%s", m.funcCheckNamespacePermissionOrigin)
	}

	if !m.CheckNamespacePermissionMock.invocationsDone() && afterCheckNamespacePermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.CheckNamespacePermission at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckNamespacePermissionMock.expectedInvocations), m.CheckNamespacePermissionMock.expectedInvocationsOrigin, afterCheckNamespacePermissionCounter)
	}
}

type mServiceMockCleanupFile struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockCleanupFileExpectation
	expectations       []*ServiceMockCleanupFileExpectation

	callArgs []*ServiceMockCleanupFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockCleanupFileExpectation specifies expectation struct of the Service.CleanupFile
type ServiceMockCleanupFileExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockCleanupFileParams
	paramPtrs          *ServiceMockCleanupFileParamPtrs
	expectationOrigins ServiceMockCleanupFileExpectationOrigins
	results            *ServiceMockCleanupFileResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockCleanupFileParams contains parameters of the Service.CleanupFile
type ServiceMockCleanupFileParams struct {
	ctx context.Context
	f1  types.FileUIDType
	u1  types.UserUIDType
	r1  types.RequesterUIDType
	s1  string
	b1  bool
}

// ServiceMockCleanupFileParamPtrs contains pointers to parameters of the Service.CleanupFile
type ServiceMockCleanupFileParamPtrs struct {
	ctx *context.Context
	f1  *types.FileUIDType
	u1  *types.UserUIDType
	r1  *types.RequesterUIDType
	s1  *string
	b1  *bool
}

// ServiceMockCleanupFileResults contains results of the Service.CleanupFile
type ServiceMockCleanupFileResults struct {
	err error
}

// ServiceMockCleanupFileOrigins contains origins of expectations of the Service.CleanupFile
type ServiceMockCleanupFileExpectationOrigins struct {
	origin    string
	originCtx string
	originF1  string
	originU1  string
	originR1  string
	originS1  string
	originB1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCleanupFile *mServiceMockCleanupFile) Optional() *mServiceMockCleanupFile {
	mmCleanupFile.optional = true
	return mmCleanupFile
}

// Expect sets up expected params for Service.CleanupFile
func (mmCleanupFile *mServiceMockCleanupFile) Expect(ctx context.Context, f1 types.FileUIDType, u1 types.UserUIDType, r1 types.RequesterUIDType, s1 string, b1 bool) *mServiceMockCleanupFile {
	if mmCleanupFile.mock.funcCleanupFile != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Set")
	}

	if mmCleanupFile.defaultExpectation == nil {
		mmCleanupFile.defaultExpectation = &ServiceMockCleanupFileExpectation{}
	}

	if mmCleanupFile.defaultExpectation.paramPtrs != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by ExpectParams functions")
	}

	mmCleanupFile.defaultExpectation.params = &ServiceMockCleanupFileParams{ctx, f1, u1, r1, s1, b1}
	mmCleanupFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCleanupFile.expectations {
		if minimock.Equal(e.params, mmCleanupFile.defaultExpectation.params) {
			mmCleanupFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCleanupFile.defaultExpectation.params)
		}
	}

	return mmCleanupFile
}

// ExpectCtxParam1 sets up expected param ctx for Service.CleanupFile
func (mmCleanupFile *mServiceMockCleanupFile) ExpectCtxParam1(ctx context.Context) *mServiceMockCleanupFile {
	if mmCleanupFile.mock.funcCleanupFile != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Set")
	}

	if mmCleanupFile.defaultExpectation == nil {
		mmCleanupFile.defaultExpectation = &ServiceMockCleanupFileExpectation{}
	}

	if mmCleanupFile.defaultExpectation.params != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Expect")
	}

	if mmCleanupFile.defaultExpectation.paramPtrs == nil {
		mmCleanupFile.defaultExpectation.paramPtrs = &ServiceMockCleanupFileParamPtrs{}
	}
	mmCleanupFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmCleanupFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCleanupFile
}

// ExpectF1Param2 sets up expected param f1 for Service.CleanupFile
func (mmCleanupFile *mServiceMockCleanupFile) ExpectF1Param2(f1 types.FileUIDType) *mServiceMockCleanupFile {
	if mmCleanupFile.mock.funcCleanupFile != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Set")
	}

	if mmCleanupFile.defaultExpectation == nil {
		mmCleanupFile.defaultExpectation = &ServiceMockCleanupFileExpectation{}
	}

	if mmCleanupFile.defaultExpectation.params != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Expect")
	}

	if mmCleanupFile.defaultExpectation.paramPtrs == nil {
		mmCleanupFile.defaultExpectation.paramPtrs = &ServiceMockCleanupFileParamPtrs{}
	}
	mmCleanupFile.defaultExpectation.paramPtrs.f1 = &f1
	mmCleanupFile.defaultExpectation.expectationOrigins.originF1 = minimock.CallerInfo(1)

	return mmCleanupFile
}

// ExpectU1Param3 sets up expected param u1 for Service.CleanupFile
func (mmCleanupFile *mServiceMockCleanupFile) ExpectU1Param3(u1 types.UserUIDType) *mServiceMockCleanupFile {
	if mmCleanupFile.mock.funcCleanupFile != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Set")
	}

	if mmCleanupFile.defaultExpectation == nil {
		mmCleanupFile.defaultExpectation = &ServiceMockCleanupFileExpectation{}
	}

	if mmCleanupFile.defaultExpectation.params != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Expect")
	}

	if mmCleanupFile.defaultExpectation.paramPtrs == nil {
		mmCleanupFile.defaultExpectation.paramPtrs = &ServiceMockCleanupFileParamPtrs{}
	}
	mmCleanupFile.defaultExpectation.paramPtrs.u1 = &u1
	mmCleanupFile.defaultExpectation.expectationOrigins.originU1 = minimock.CallerInfo(1)

	return mmCleanupFile
}

// ExpectR1Param4 sets up expected param r1 for Service.CleanupFile
func (mmCleanupFile *mServiceMockCleanupFile) ExpectR1Param4(r1 types.RequesterUIDType) *mServiceMockCleanupFile {
	if mmCleanupFile.mock.funcCleanupFile != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Set")
	}

	if mmCleanupFile.defaultExpectation == nil {
		mmCleanupFile.defaultExpectation = &ServiceMockCleanupFileExpectation{}
	}

	if mmCleanupFile.defaultExpectation.params != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Expect")
	}

	if mmCleanupFile.defaultExpectation.paramPtrs == nil {
		mmCleanupFile.defaultExpectation.paramPtrs = &ServiceMockCleanupFileParamPtrs{}
	}
	mmCleanupFile.defaultExpectation.paramPtrs.r1 = &r1
	mmCleanupFile.defaultExpectation.expectationOrigins.originR1 = minimock.CallerInfo(1)

	return mmCleanupFile
}

// ExpectS1Param5 sets up expected param s1 for Service.CleanupFile
func (mmCleanupFile *mServiceMockCleanupFile) ExpectS1Param5(s1 string) *mServiceMockCleanupFile {
	if mmCleanupFile.mock.funcCleanupFile != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Set")
	}

	if mmCleanupFile.defaultExpectation == nil {
		mmCleanupFile.defaultExpectation = &ServiceMockCleanupFileExpectation{}
	}

	if mmCleanupFile.defaultExpectation.params != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Expect")
	}

	if mmCleanupFile.defaultExpectation.paramPtrs == nil {
		mmCleanupFile.defaultExpectation.paramPtrs = &ServiceMockCleanupFileParamPtrs{}
	}
	mmCleanupFile.defaultExpectation.paramPtrs.s1 = &s1
	mmCleanupFile.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmCleanupFile
}

// ExpectB1Param6 sets up expected param b1 for Service.CleanupFile
func (mmCleanupFile *mServiceMockCleanupFile) ExpectB1Param6(b1 bool) *mServiceMockCleanupFile {
	if mmCleanupFile.mock.funcCleanupFile != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Set")
	}

	if mmCleanupFile.defaultExpectation == nil {
		mmCleanupFile.defaultExpectation = &ServiceMockCleanupFileExpectation{}
	}

	if mmCleanupFile.defaultExpectation.params != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Expect")
	}

	if mmCleanupFile.defaultExpectation.paramPtrs == nil {
		mmCleanupFile.defaultExpectation.paramPtrs = &ServiceMockCleanupFileParamPtrs{}
	}
	mmCleanupFile.defaultExpectation.paramPtrs.b1 = &b1
	mmCleanupFile.defaultExpectation.expectationOrigins.originB1 = minimock.CallerInfo(1)

	return mmCleanupFile
}

// Inspect accepts an inspector function that has same arguments as the Service.CleanupFile
func (mmCleanupFile *mServiceMockCleanupFile) Inspect(f func(ctx context.Context, f1 types.FileUIDType, u1 types.UserUIDType, r1 types.RequesterUIDType, s1 string, b1 bool)) *mServiceMockCleanupFile {
	if mmCleanupFile.mock.inspectFuncCleanupFile != nil {
		mmCleanupFile.mock.t.Fatalf("Inspect function is already set for ServiceMock.CleanupFile")
	}

	mmCleanupFile.mock.inspectFuncCleanupFile = f

	return mmCleanupFile
}

// Return sets up results that will be returned by Service.CleanupFile
func (mmCleanupFile *mServiceMockCleanupFile) Return(err error) *ServiceMock {
	if mmCleanupFile.mock.funcCleanupFile != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Set")
	}

	if mmCleanupFile.defaultExpectation == nil {
		mmCleanupFile.defaultExpectation = &ServiceMockCleanupFileExpectation{mock: mmCleanupFile.mock}
	}
	mmCleanupFile.defaultExpectation.results = &ServiceMockCleanupFileResults{err}
	mmCleanupFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCleanupFile.mock
}

// Set uses given function f to mock the Service.CleanupFile method
func (mmCleanupFile *mServiceMockCleanupFile) Set(f func(ctx context.Context, f1 types.FileUIDType, u1 types.UserUIDType, r1 types.RequesterUIDType, s1 string, b1 bool) (err error)) *ServiceMock {
	if mmCleanupFile.defaultExpectation != nil {
		mmCleanupFile.mock.t.Fatalf("Default expectation is already set for the Service.CleanupFile method")
	}

	if len(mmCleanupFile.expectations) > 0 {
		mmCleanupFile.mock.t.Fatalf("Some expectations are already set for the Service.CleanupFile method")
	}

	mmCleanupFile.mock.funcCleanupFile = f
	mmCleanupFile.mock.funcCleanupFileOrigin = minimock.CallerInfo(1)
	return mmCleanupFile.mock
}

// When sets expectation for the Service.CleanupFile which will trigger the result defined by the following
// Then helper
func (mmCleanupFile *mServiceMockCleanupFile) When(ctx context.Context, f1 types.FileUIDType, u1 types.UserUIDType, r1 types.RequesterUIDType, s1 string, b1 bool) *ServiceMockCleanupFileExpectation {
	if mmCleanupFile.mock.funcCleanupFile != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Set")
	}

	expectation := &ServiceMockCleanupFileExpectation{
		mock:               mmCleanupFile.mock,
		params:             &ServiceMockCleanupFileParams{ctx, f1, u1, r1, s1, b1},
		expectationOrigins: ServiceMockCleanupFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCleanupFile.expectations = append(mmCleanupFile.expectations, expectation)
	return expectation
}

// Then sets up Service.CleanupFile return parameters for the expectation previously defined by the When method
func (e *ServiceMockCleanupFileExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockCleanupFileResults{err}
	return e.mock
}

// Times sets number of times Service.CleanupFile should be invoked
func (mmCleanupFile *mServiceMockCleanupFile) Times(n uint64) *mServiceMockCleanupFile {
	if n == 0 {
		mmCleanupFile.mock.t.Fatalf("Times of ServiceMock.CleanupFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCleanupFile.expectedInvocations, n)
	mmCleanupFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCleanupFile
}

func (mmCleanupFile *mServiceMockCleanupFile) invocationsDone() bool {
	if len(mmCleanupFile.expectations) == 0 && mmCleanupFile.defaultExpectation == nil && mmCleanupFile.mock.funcCleanupFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCleanupFile.mock.afterCleanupFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCleanupFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CleanupFile implements mm_service.Service
func (mmCleanupFile *ServiceMock) CleanupFile(ctx context.Context, f1 types.FileUIDType, u1 types.UserUIDType, r1 types.RequesterUIDType, s1 string, b1 bool) (err error) {
	mm_atomic.AddUint64(&mmCleanupFile.beforeCleanupFileCounter, 1)
	defer mm_atomic.AddUint64(&mmCleanupFile.afterCleanupFileCounter, 1)

	mmCleanupFile.t.Helper()

	if mmCleanupFile.inspectFuncCleanupFile != nil {
		mmCleanupFile.inspectFuncCleanupFile(ctx, f1, u1, r1, s1, b1)
	}

	mm_params := ServiceMockCleanupFileParams{ctx, f1, u1, r1, s1, b1}

	// Record call args
	mmCleanupFile.CleanupFileMock.mutex.Lock()
	mmCleanupFile.CleanupFileMock.callArgs = append(mmCleanupFile.CleanupFileMock.callArgs, &mm_params)
	mmCleanupFile.CleanupFileMock.mutex.Unlock()

	for _, e := range mmCleanupFile.CleanupFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCleanupFile.CleanupFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCleanupFile.CleanupFileMock.defaultExpectation.Counter, 1)
		mm_want := mmCleanupFile.CleanupFileMock.defaultExpectation.params
		mm_want_ptrs := mmCleanupFile.CleanupFileMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockCleanupFileParams{ctx, f1, u1, r1, s1, b1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCleanupFile.t.Errorf("ServiceMock.CleanupFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCleanupFile.CleanupFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.f1 != nil && !minimock.Equal(*mm_want_ptrs.f1, mm_got.f1) {
				mmCleanupFile.t.Errorf("ServiceMock.CleanupFile got unexpected parameter f1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCleanupFile.CleanupFileMock.defaultExpectation.expectationOrigins.originF1, *mm_want_ptrs.f1, mm_got.f1, minimock.Diff(*mm_want_ptrs.f1, mm_got.f1))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmCleanupFile.t.Errorf("ServiceMock.CleanupFile got unexpected parameter u1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCleanupFile.CleanupFileMock.defaultExpectation.expectationOrigins.originU1, *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

			if mm_want_ptrs.r1 != nil && !minimock.Equal(*mm_want_ptrs.r1, mm_got.r1) {
				mmCleanupFile.t.Errorf("ServiceMock.CleanupFile got unexpected parameter r1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCleanupFile.CleanupFileMock.defaultExpectation.expectationOrigins.originR1, *mm_want_ptrs.r1, mm_got.r1, minimock.Diff(*mm_want_ptrs.r1, mm_got.r1))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmCleanupFile.t.Errorf("ServiceMock.CleanupFile got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCleanupFile.CleanupFileMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

			if mm_want_ptrs.b1 != nil && !minimock.Equal(*mm_want_ptrs.b1, mm_got.b1) {
				mmCleanupFile.t.Errorf("ServiceMock.CleanupFile got unexpected parameter b1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCleanupFile.CleanupFileMock.defaultExpectation.expectationOrigins.originB1, *mm_want_ptrs.b1, mm_got.b1, minimock.Diff(*mm_want_ptrs.b1, mm_got.b1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCleanupFile.t.Errorf("ServiceMock.CleanupFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCleanupFile.CleanupFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCleanupFile.CleanupFileMock.defaultExpectation.results
		if mm_results == nil {
			mmCleanupFile.t.Fatal("No results are set for the ServiceMock.CleanupFile")
		}
		return (*mm_results).err
	}
	if mmCleanupFile.funcCleanupFile != nil {
		return mmCleanupFile.funcCleanupFile(ctx, f1, u1, r1, s1, b1)
	}
	mmCleanupFile.t.Fatalf("Unexpected call to ServiceMock.CleanupFile. %v %v %v %v %v %v", ctx, f1, u1, r1, s1, b1)
	return
}

// CleanupFileAfterCounter returns a count of finished ServiceMock.CleanupFile invocations
func (mmCleanupFile *ServiceMock) CleanupFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCleanupFile.afterCleanupFileCounter)
}

// CleanupFileBeforeCounter returns a count of ServiceMock.CleanupFile invocations
func (mmCleanupFile *ServiceMock) CleanupFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCleanupFile.beforeCleanupFileCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.CleanupFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCleanupFile *mServiceMockCleanupFile) Calls() []*ServiceMockCleanupFileParams {
	mmCleanupFile.mutex.RLock()

	argCopy := make([]*ServiceMockCleanupFileParams, len(mmCleanupFile.callArgs))
	copy(argCopy, mmCleanupFile.callArgs)

	mmCleanupFile.mutex.RUnlock()

	return argCopy
}

// MinimockCleanupFileDone returns true if the count of the CleanupFile invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCleanupFileDone() bool {
	if m.CleanupFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CleanupFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CleanupFileMock.invocationsDone()
}

// MinimockCleanupFileInspect logs each unmet expectation
func (m *ServiceMock) MinimockCleanupFileInspect() {
	for _, e := range m.CleanupFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.CleanupFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCleanupFileCounter := mm_atomic.LoadUint64(&m.afterCleanupFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CleanupFileMock.defaultExpectation != nil && afterCleanupFileCounter < 1 {
		if m.CleanupFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.CleanupFile at\n%s", m.CleanupFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.CleanupFile at\n%s with params: %#v", m.CleanupFileMock.defaultExpectation.expectationOrigins.origin, *m.CleanupFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCleanupFile != nil && afterCleanupFileCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.CleanupFile at\n%s", m.funcCleanupFileOrigin)
	}

	if !m.CleanupFileMock.invocationsDone() && afterCleanupFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.CleanupFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CleanupFileMock.expectedInvocations), m.CleanupFileMock.expectedInvocationsOrigin, afterCleanupFileCounter)
	}
}

type mServiceMockCleanupKnowledgeBase struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockCleanupKnowledgeBaseExpectation
	expectations       []*ServiceMockCleanupKnowledgeBaseExpectation

	callArgs []*ServiceMockCleanupKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockCleanupKnowledgeBaseExpectation specifies expectation struct of the Service.CleanupKnowledgeBase
type ServiceMockCleanupKnowledgeBaseExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockCleanupKnowledgeBaseParams
	paramPtrs          *ServiceMockCleanupKnowledgeBaseParamPtrs
	expectationOrigins ServiceMockCleanupKnowledgeBaseExpectationOrigins
	results            *ServiceMockCleanupKnowledgeBaseResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockCleanupKnowledgeBaseParams contains parameters of the Service.CleanupKnowledgeBase
type ServiceMockCleanupKnowledgeBaseParams struct {
	ctx context.Context
	k1  types.KBUIDType
}

// ServiceMockCleanupKnowledgeBaseParamPtrs contains pointers to parameters of the Service.CleanupKnowledgeBase
type ServiceMockCleanupKnowledgeBaseParamPtrs struct {
	ctx *context.Context
	k1  *types.KBUIDType
}

// ServiceMockCleanupKnowledgeBaseResults contains results of the Service.CleanupKnowledgeBase
type ServiceMockCleanupKnowledgeBaseResults struct {
	err error
}

// ServiceMockCleanupKnowledgeBaseOrigins contains origins of expectations of the Service.CleanupKnowledgeBase
type ServiceMockCleanupKnowledgeBaseExpectationOrigins struct {
	origin    string
	originCtx string
	originK1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCleanupKnowledgeBase *mServiceMockCleanupKnowledgeBase) Optional() *mServiceMockCleanupKnowledgeBase {
	mmCleanupKnowledgeBase.optional = true
	return mmCleanupKnowledgeBase
}

// Expect sets up expected params for Service.CleanupKnowledgeBase
func (mmCleanupKnowledgeBase *mServiceMockCleanupKnowledgeBase) Expect(ctx context.Context, k1 types.KBUIDType) *mServiceMockCleanupKnowledgeBase {
	if mmCleanupKnowledgeBase.mock.funcCleanupKnowledgeBase != nil {
		mmCleanupKnowledgeBase.mock.t.Fatalf("ServiceMock.CleanupKnowledgeBase mock is already set by Set")
	}

	if mmCleanupKnowledgeBase.defaultExpectation == nil {
		mmCleanupKnowledgeBase.defaultExpectation = &ServiceMockCleanupKnowledgeBaseExpectation{}
	}

	if mmCleanupKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmCleanupKnowledgeBase.mock.t.Fatalf("ServiceMock.CleanupKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmCleanupKnowledgeBase.defaultExpectation.params = &ServiceMockCleanupKnowledgeBaseParams{ctx, k1}
	mmCleanupKnowledgeBase.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCleanupKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmCleanupKnowledgeBase.defaultExpectation.params) {
			mmCleanupKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCleanupKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmCleanupKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for Service.CleanupKnowledgeBase
func (mmCleanupKnowledgeBase *mServiceMockCleanupKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mServiceMockCleanupKnowledgeBase {
	if mmCleanupKnowledgeBase.mock.funcCleanupKnowledgeBase != nil {
		mmCleanupKnowledgeBase.mock.t.Fatalf("ServiceMock.CleanupKnowledgeBase mock is already set by Set")
	}

	if mmCleanupKnowledgeBase.defaultExpectation == nil {
		mmCleanupKnowledgeBase.defaultExpectation = &ServiceMockCleanupKnowledgeBaseExpectation{}
	}

	if mmCleanupKnowledgeBase.defaultExpectation.params != nil {
		mmCleanupKnowledgeBase.mock.t.Fatalf("ServiceMock.CleanupKnowledgeBase mock is already set by Expect")
	}

	if mmCleanupKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCleanupKnowledgeBase.defaultExpectation.paramPtrs = &ServiceMockCleanupKnowledgeBaseParamPtrs{}
	}
	mmCleanupKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx
	mmCleanupKnowledgeBase.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCleanupKnowledgeBase
}

// ExpectK1Param2 sets up expected param k1 for Service.CleanupKnowledgeBase
func (mmCleanupKnowledgeBase *mServiceMockCleanupKnowledgeBase) ExpectK1Param2(k1 types.KBUIDType) *mServiceMockCleanupKnowledgeBase {
	if mmCleanupKnowledgeBase.mock.funcCleanupKnowledgeBase != nil {
		mmCleanupKnowledgeBase.mock.t.Fatalf("ServiceMock.CleanupKnowledgeBase mock is already set by Set")
	}

	if mmCleanupKnowledgeBase.defaultExpectation == nil {
		mmCleanupKnowledgeBase.defaultExpectation = &ServiceMockCleanupKnowledgeBaseExpectation{}
	}

	if mmCleanupKnowledgeBase.defaultExpectation.params != nil {
		mmCleanupKnowledgeBase.mock.t.Fatalf("ServiceMock.CleanupKnowledgeBase mock is already set by Expect")
	}

	if mmCleanupKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCleanupKnowledgeBase.defaultExpectation.paramPtrs = &ServiceMockCleanupKnowledgeBaseParamPtrs{}
	}
	mmCleanupKnowledgeBase.defaultExpectation.paramPtrs.k1 = &k1
	mmCleanupKnowledgeBase.defaultExpectation.expectationOrigins.originK1 = minimock.CallerInfo(1)

	return mmCleanupKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the Service.CleanupKnowledgeBase
func (mmCleanupKnowledgeBase *mServiceMockCleanupKnowledgeBase) Inspect(f func(ctx context.Context, k1 types.KBUIDType)) *mServiceMockCleanupKnowledgeBase {
	if mmCleanupKnowledgeBase.mock.inspectFuncCleanupKnowledgeBase != nil {
		mmCleanupKnowledgeBase.mock.t.Fatalf("Inspect function is already set for ServiceMock.CleanupKnowledgeBase")
	}

	mmCleanupKnowledgeBase.mock.inspectFuncCleanupKnowledgeBase = f

	return mmCleanupKnowledgeBase
}

// Return sets up results that will be returned by Service.CleanupKnowledgeBase
func (mmCleanupKnowledgeBase *mServiceMockCleanupKnowledgeBase) Return(err error) *ServiceMock {
	if mmCleanupKnowledgeBase.mock.funcCleanupKnowledgeBase != nil {
		mmCleanupKnowledgeBase.mock.t.Fatalf("ServiceMock.CleanupKnowledgeBase mock is already set by Set")
	}

	if mmCleanupKnowledgeBase.defaultExpectation == nil {
		mmCleanupKnowledgeBase.defaultExpectation = &ServiceMockCleanupKnowledgeBaseExpectation{mock: mmCleanupKnowledgeBase.mock}
	}
	mmCleanupKnowledgeBase.defaultExpectation.results = &ServiceMockCleanupKnowledgeBaseResults{err}
	mmCleanupKnowledgeBase.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCleanupKnowledgeBase.mock
}

// Set uses given function f to mock the Service.CleanupKnowledgeBase method
func (mmCleanupKnowledgeBase *mServiceMockCleanupKnowledgeBase) Set(f func(ctx context.Context, k1 types.KBUIDType) (err error)) *ServiceMock {
	if mmCleanupKnowledgeBase.defaultExpectation != nil {
		mmCleanupKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the Service.CleanupKnowledgeBase method")
	}

	if len(mmCleanupKnowledgeBase.expectations) > 0 {
		mmCleanupKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the Service.CleanupKnowledgeBase method")
	}

	mmCleanupKnowledgeBase.mock.funcCleanupKnowledgeBase = f
	mmCleanupKnowledgeBase.mock.funcCleanupKnowledgeBaseOrigin = minimock.CallerInfo(1)
	return mmCleanupKnowledgeBase.mock
}

// When sets expectation for the Service.CleanupKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmCleanupKnowledgeBase *mServiceMockCleanupKnowledgeBase) When(ctx context.Context, k1 types.KBUIDType) *ServiceMockCleanupKnowledgeBaseExpectation {
	if mmCleanupKnowledgeBase.mock.funcCleanupKnowledgeBase != nil {
		mmCleanupKnowledgeBase.mock.t.Fatalf("ServiceMock.CleanupKnowledgeBase mock is already set by Set")
	}

	expectation := &ServiceMockCleanupKnowledgeBaseExpectation{
		mock:               mmCleanupKnowledgeBase.mock,
		params:             &ServiceMockCleanupKnowledgeBaseParams{ctx, k1},
		expectationOrigins: ServiceMockCleanupKnowledgeBaseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCleanupKnowledgeBase.expectations = append(mmCleanupKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up Service.CleanupKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *ServiceMockCleanupKnowledgeBaseExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockCleanupKnowledgeBaseResults{err}
	return e.mock
}

// Times sets number of times Service.CleanupKnowledgeBase should be invoked
func (mmCleanupKnowledgeBase *mServiceMockCleanupKnowledgeBase) Times(n uint64) *mServiceMockCleanupKnowledgeBase {
	if n == 0 {
		mmCleanupKnowledgeBase.mock.t.Fatalf("Times of ServiceMock.CleanupKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCleanupKnowledgeBase.expectedInvocations, n)
	mmCleanupKnowledgeBase.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCleanupKnowledgeBase
}

func (mmCleanupKnowledgeBase *mServiceMockCleanupKnowledgeBase) invocationsDone() bool {
	if len(mmCleanupKnowledgeBase.expectations) == 0 && mmCleanupKnowledgeBase.defaultExpectation == nil && mmCleanupKnowledgeBase.mock.funcCleanupKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCleanupKnowledgeBase.mock.afterCleanupKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCleanupKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CleanupKnowledgeBase implements mm_service.Service
func (mmCleanupKnowledgeBase *ServiceMock) CleanupKnowledgeBase(ctx context.Context, k1 types.KBUIDType) (err error) {
	mm_atomic.AddUint64(&mmCleanupKnowledgeBase.beforeCleanupKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmCleanupKnowledgeBase.afterCleanupKnowledgeBaseCounter, 1)

	mmCleanupKnowledgeBase.t.Helper()

	if mmCleanupKnowledgeBase.inspectFuncCleanupKnowledgeBase != nil {
		mmCleanupKnowledgeBase.inspectFuncCleanupKnowledgeBase(ctx, k1)
	}

	mm_params := ServiceMockCleanupKnowledgeBaseParams{ctx, k1}

	// Record call args
	mmCleanupKnowledgeBase.CleanupKnowledgeBaseMock.mutex.Lock()
	mmCleanupKnowledgeBase.CleanupKnowledgeBaseMock.callArgs = append(mmCleanupKnowledgeBase.CleanupKnowledgeBaseMock.callArgs, &mm_params)
	mmCleanupKnowledgeBase.CleanupKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmCleanupKnowledgeBase.CleanupKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCleanupKnowledgeBase.CleanupKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCleanupKnowledgeBase.CleanupKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmCleanupKnowledgeBase.CleanupKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmCleanupKnowledgeBase.CleanupKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockCleanupKnowledgeBaseParams{ctx, k1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCleanupKnowledgeBase.t.Errorf("ServiceMock.CleanupKnowledgeBase got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCleanupKnowledgeBase.CleanupKnowledgeBaseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.k1 != nil && !minimock.Equal(*mm_want_ptrs.k1, mm_got.k1) {
				mmCleanupKnowledgeBase.t.Errorf("ServiceMock.CleanupKnowledgeBase got unexpected parameter k1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCleanupKnowledgeBase.CleanupKnowledgeBaseMock.defaultExpectation.expectationOrigins.originK1, *mm_want_ptrs.k1, mm_got.k1, minimock.Diff(*mm_want_ptrs.k1, mm_got.k1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCleanupKnowledgeBase.t.Errorf("ServiceMock.CleanupKnowledgeBase got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCleanupKnowledgeBase.CleanupKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCleanupKnowledgeBase.CleanupKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmCleanupKnowledgeBase.t.Fatal("No results are set for the ServiceMock.CleanupKnowledgeBase")
		}
		return (*mm_results).err
	}
	if mmCleanupKnowledgeBase.funcCleanupKnowledgeBase != nil {
		return mmCleanupKnowledgeBase.funcCleanupKnowledgeBase(ctx, k1)
	}
	mmCleanupKnowledgeBase.t.Fatalf("Unexpected call to ServiceMock.CleanupKnowledgeBase. %v %v", ctx, k1)
	return
}

// CleanupKnowledgeBaseAfterCounter returns a count of finished ServiceMock.CleanupKnowledgeBase invocations
func (mmCleanupKnowledgeBase *ServiceMock) CleanupKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCleanupKnowledgeBase.afterCleanupKnowledgeBaseCounter)
}

// CleanupKnowledgeBaseBeforeCounter returns a count of ServiceMock.CleanupKnowledgeBase invocations
func (mmCleanupKnowledgeBase *ServiceMock) CleanupKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCleanupKnowledgeBase.beforeCleanupKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.CleanupKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCleanupKnowledgeBase *mServiceMockCleanupKnowledgeBase) Calls() []*ServiceMockCleanupKnowledgeBaseParams {
	mmCleanupKnowledgeBase.mutex.RLock()

	argCopy := make([]*ServiceMockCleanupKnowledgeBaseParams, len(mmCleanupKnowledgeBase.callArgs))
	copy(argCopy, mmCleanupKnowledgeBase.callArgs)

	mmCleanupKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockCleanupKnowledgeBaseDone returns true if the count of the CleanupKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCleanupKnowledgeBaseDone() bool {
	if m.CleanupKnowledgeBaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CleanupKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CleanupKnowledgeBaseMock.invocationsDone()
}

// MinimockCleanupKnowledgeBaseInspect logs each unmet expectation
func (m *ServiceMock) MinimockCleanupKnowledgeBaseInspect() {
	for _, e := range m.CleanupKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.CleanupKnowledgeBase at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCleanupKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterCleanupKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CleanupKnowledgeBaseMock.defaultExpectation != nil && afterCleanupKnowledgeBaseCounter < 1 {
		if m.CleanupKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.CleanupKnowledgeBase at\n%s", m.CleanupKnowledgeBaseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.CleanupKnowledgeBase at\n%s with params: %#v", m.CleanupKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *m.CleanupKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCleanupKnowledgeBase != nil && afterCleanupKnowledgeBaseCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.CleanupKnowledgeBase at\n%s", m.funcCleanupKnowledgeBaseOrigin)
	}

	if !m.CleanupKnowledgeBaseMock.invocationsDone() && afterCleanupKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.CleanupKnowledgeBase at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CleanupKnowledgeBaseMock.expectedInvocations), m.CleanupKnowledgeBaseMock.expectedInvocationsOrigin, afterCleanupKnowledgeBaseCounter)
	}
}

type mServiceMockCreateRepositoryTag struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockCreateRepositoryTagExpectation
	expectations       []*ServiceMockCreateRepositoryTagExpectation

	callArgs []*ServiceMockCreateRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockCreateRepositoryTagExpectation specifies expectation struct of the Service.CreateRepositoryTag
type ServiceMockCreateRepositoryTagExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockCreateRepositoryTagParams
	paramPtrs          *ServiceMockCreateRepositoryTagParamPtrs
	expectationOrigins ServiceMockCreateRepositoryTagExpectationOrigins
	results            *ServiceMockCreateRepositoryTagResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockCreateRepositoryTagParams contains parameters of the Service.CreateRepositoryTag
type ServiceMockCreateRepositoryTagParams struct {
	ctx context.Context
	cp1 *artifactpb.CreateRepositoryTagRequest
}

// ServiceMockCreateRepositoryTagParamPtrs contains pointers to parameters of the Service.CreateRepositoryTag
type ServiceMockCreateRepositoryTagParamPtrs struct {
	ctx *context.Context
	cp1 **artifactpb.CreateRepositoryTagRequest
}

// ServiceMockCreateRepositoryTagResults contains results of the Service.CreateRepositoryTag
type ServiceMockCreateRepositoryTagResults struct {
	cp2 *artifactpb.CreateRepositoryTagResponse
	err error
}

// ServiceMockCreateRepositoryTagOrigins contains origins of expectations of the Service.CreateRepositoryTag
type ServiceMockCreateRepositoryTagExpectationOrigins struct {
	origin    string
	originCtx string
	originCp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) Optional() *mServiceMockCreateRepositoryTag {
	mmCreateRepositoryTag.optional = true
	return mmCreateRepositoryTag
}

// Expect sets up expected params for Service.CreateRepositoryTag
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) Expect(ctx context.Context, cp1 *artifactpb.CreateRepositoryTagRequest) *mServiceMockCreateRepositoryTag {
	if mmCreateRepositoryTag.mock.funcCreateRepositoryTag != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("ServiceMock.CreateRepositoryTag mock is already set by Set")
	}

	if mmCreateRepositoryTag.defaultExpectation == nil {
		mmCreateRepositoryTag.defaultExpectation = &ServiceMockCreateRepositoryTagExpectation{}
	}

	if mmCreateRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("ServiceMock.CreateRepositoryTag mock is already set by ExpectParams functions")
	}

	mmCreateRepositoryTag.defaultExpectation.params = &ServiceMockCreateRepositoryTagParams{ctx, cp1}
	mmCreateRepositoryTag.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateRepositoryTag.expectations {
		if minimock.Equal(e.params, mmCreateRepositoryTag.defaultExpectation.params) {
			mmCreateRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateRepositoryTag.defaultExpectation.params)
		}
	}

	return mmCreateRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for Service.CreateRepositoryTag
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) ExpectCtxParam1(ctx context.Context) *mServiceMockCreateRepositoryTag {
	if mmCreateRepositoryTag.mock.funcCreateRepositoryTag != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("ServiceMock.CreateRepositoryTag mock is already set by Set")
	}

	if mmCreateRepositoryTag.defaultExpectation == nil {
		mmCreateRepositoryTag.defaultExpectation = &ServiceMockCreateRepositoryTagExpectation{}
	}

	if mmCreateRepositoryTag.defaultExpectation.params != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("ServiceMock.CreateRepositoryTag mock is already set by Expect")
	}

	if mmCreateRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmCreateRepositoryTag.defaultExpectation.paramPtrs = &ServiceMockCreateRepositoryTagParamPtrs{}
	}
	mmCreateRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateRepositoryTag.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateRepositoryTag
}

// ExpectCp1Param2 sets up expected param cp1 for Service.CreateRepositoryTag
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) ExpectCp1Param2(cp1 *artifactpb.CreateRepositoryTagRequest) *mServiceMockCreateRepositoryTag {
	if mmCreateRepositoryTag.mock.funcCreateRepositoryTag != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("ServiceMock.CreateRepositoryTag mock is already set by Set")
	}

	if mmCreateRepositoryTag.defaultExpectation == nil {
		mmCreateRepositoryTag.defaultExpectation = &ServiceMockCreateRepositoryTagExpectation{}
	}

	if mmCreateRepositoryTag.defaultExpectation.params != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("ServiceMock.CreateRepositoryTag mock is already set by Expect")
	}

	if mmCreateRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmCreateRepositoryTag.defaultExpectation.paramPtrs = &ServiceMockCreateRepositoryTagParamPtrs{}
	}
	mmCreateRepositoryTag.defaultExpectation.paramPtrs.cp1 = &cp1
	mmCreateRepositoryTag.defaultExpectation.expectationOrigins.originCp1 = minimock.CallerInfo(1)

	return mmCreateRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the Service.CreateRepositoryTag
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) Inspect(f func(ctx context.Context, cp1 *artifactpb.CreateRepositoryTagRequest)) *mServiceMockCreateRepositoryTag {
	if mmCreateRepositoryTag.mock.inspectFuncCreateRepositoryTag != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("Inspect function is already set for ServiceMock.CreateRepositoryTag")
	}

	mmCreateRepositoryTag.mock.inspectFuncCreateRepositoryTag = f

	return mmCreateRepositoryTag
}

// Return sets up results that will be returned by Service.CreateRepositoryTag
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) Return(cp2 *artifactpb.CreateRepositoryTagResponse, err error) *ServiceMock {
	if mmCreateRepositoryTag.mock.funcCreateRepositoryTag != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("ServiceMock.CreateRepositoryTag mock is already set by Set")
	}

	if mmCreateRepositoryTag.defaultExpectation == nil {
		mmCreateRepositoryTag.defaultExpectation = &ServiceMockCreateRepositoryTagExpectation{mock: mmCreateRepositoryTag.mock}
	}
	mmCreateRepositoryTag.defaultExpectation.results = &ServiceMockCreateRepositoryTagResults{cp2, err}
	mmCreateRepositoryTag.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateRepositoryTag.mock
}

// Set uses given function f to mock the Service.CreateRepositoryTag method
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) Set(f func(ctx context.Context, cp1 *artifactpb.CreateRepositoryTagRequest) (cp2 *artifactpb.CreateRepositoryTagResponse, err error)) *ServiceMock {
	if mmCreateRepositoryTag.defaultExpectation != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("Default expectation is already set for the Service.CreateRepositoryTag method")
	}

	if len(mmCreateRepositoryTag.expectations) > 0 {
		mmCreateRepositoryTag.mock.t.Fatalf("Some expectations are already set for the Service.CreateRepositoryTag method")
	}

	mmCreateRepositoryTag.mock.funcCreateRepositoryTag = f
	mmCreateRepositoryTag.mock.funcCreateRepositoryTagOrigin = minimock.CallerInfo(1)
	return mmCreateRepositoryTag.mock
}

// When sets expectation for the Service.CreateRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) When(ctx context.Context, cp1 *artifactpb.CreateRepositoryTagRequest) *ServiceMockCreateRepositoryTagExpectation {
	if mmCreateRepositoryTag.mock.funcCreateRepositoryTag != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("ServiceMock.CreateRepositoryTag mock is already set by Set")
	}

	expectation := &ServiceMockCreateRepositoryTagExpectation{
		mock:               mmCreateRepositoryTag.mock,
		params:             &ServiceMockCreateRepositoryTagParams{ctx, cp1},
		expectationOrigins: ServiceMockCreateRepositoryTagExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateRepositoryTag.expectations = append(mmCreateRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up Service.CreateRepositoryTag return parameters for the expectation previously defined by the When method
func (e *ServiceMockCreateRepositoryTagExpectation) Then(cp2 *artifactpb.CreateRepositoryTagResponse, err error) *ServiceMock {
	e.results = &ServiceMockCreateRepositoryTagResults{cp2, err}
	return e.mock
}

// Times sets number of times Service.CreateRepositoryTag should be invoked
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) Times(n uint64) *mServiceMockCreateRepositoryTag {
	if n == 0 {
		mmCreateRepositoryTag.mock.t.Fatalf("Times of ServiceMock.CreateRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateRepositoryTag.expectedInvocations, n)
	mmCreateRepositoryTag.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateRepositoryTag
}

func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) invocationsDone() bool {
	if len(mmCreateRepositoryTag.expectations) == 0 && mmCreateRepositoryTag.defaultExpectation == nil && mmCreateRepositoryTag.mock.funcCreateRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateRepositoryTag.mock.afterCreateRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateRepositoryTag implements mm_service.Service
func (mmCreateRepositoryTag *ServiceMock) CreateRepositoryTag(ctx context.Context, cp1 *artifactpb.CreateRepositoryTagRequest) (cp2 *artifactpb.CreateRepositoryTagResponse, err error) {
	mm_atomic.AddUint64(&mmCreateRepositoryTag.beforeCreateRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateRepositoryTag.afterCreateRepositoryTagCounter, 1)

	mmCreateRepositoryTag.t.Helper()

	if mmCreateRepositoryTag.inspectFuncCreateRepositoryTag != nil {
		mmCreateRepositoryTag.inspectFuncCreateRepositoryTag(ctx, cp1)
	}

	mm_params := ServiceMockCreateRepositoryTagParams{ctx, cp1}

	// Record call args
	mmCreateRepositoryTag.CreateRepositoryTagMock.mutex.Lock()
	mmCreateRepositoryTag.CreateRepositoryTagMock.callArgs = append(mmCreateRepositoryTag.CreateRepositoryTagMock.callArgs, &mm_params)
	mmCreateRepositoryTag.CreateRepositoryTagMock.mutex.Unlock()

	for _, e := range mmCreateRepositoryTag.CreateRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp2, e.results.err
		}
	}

	if mmCreateRepositoryTag.CreateRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateRepositoryTag.CreateRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateRepositoryTag.CreateRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmCreateRepositoryTag.CreateRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockCreateRepositoryTagParams{ctx, cp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateRepositoryTag.t.Errorf("ServiceMock.CreateRepositoryTag got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateRepositoryTag.CreateRepositoryTagMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cp1 != nil && !minimock.Equal(*mm_want_ptrs.cp1, mm_got.cp1) {
				mmCreateRepositoryTag.t.Errorf("ServiceMock.CreateRepositoryTag got unexpected parameter cp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateRepositoryTag.CreateRepositoryTagMock.defaultExpectation.expectationOrigins.originCp1, *mm_want_ptrs.cp1, mm_got.cp1, minimock.Diff(*mm_want_ptrs.cp1, mm_got.cp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateRepositoryTag.t.Errorf("ServiceMock.CreateRepositoryTag got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateRepositoryTag.CreateRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateRepositoryTag.CreateRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateRepositoryTag.t.Fatal("No results are set for the ServiceMock.CreateRepositoryTag")
		}
		return (*mm_results).cp2, (*mm_results).err
	}
	if mmCreateRepositoryTag.funcCreateRepositoryTag != nil {
		return mmCreateRepositoryTag.funcCreateRepositoryTag(ctx, cp1)
	}
	mmCreateRepositoryTag.t.Fatalf("Unexpected call to ServiceMock.CreateRepositoryTag. %v %v", ctx, cp1)
	return
}

// CreateRepositoryTagAfterCounter returns a count of finished ServiceMock.CreateRepositoryTag invocations
func (mmCreateRepositoryTag *ServiceMock) CreateRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateRepositoryTag.afterCreateRepositoryTagCounter)
}

// CreateRepositoryTagBeforeCounter returns a count of ServiceMock.CreateRepositoryTag invocations
func (mmCreateRepositoryTag *ServiceMock) CreateRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateRepositoryTag.beforeCreateRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.CreateRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) Calls() []*ServiceMockCreateRepositoryTagParams {
	mmCreateRepositoryTag.mutex.RLock()

	argCopy := make([]*ServiceMockCreateRepositoryTagParams, len(mmCreateRepositoryTag.callArgs))
	copy(argCopy, mmCreateRepositoryTag.callArgs)

	mmCreateRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockCreateRepositoryTagDone returns true if the count of the CreateRepositoryTag invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCreateRepositoryTagDone() bool {
	if m.CreateRepositoryTagMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateRepositoryTagMock.invocationsDone()
}

// MinimockCreateRepositoryTagInspect logs each unmet expectation
func (m *ServiceMock) MinimockCreateRepositoryTagInspect() {
	for _, e := range m.CreateRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.CreateRepositoryTag at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterCreateRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateRepositoryTagMock.defaultExpectation != nil && afterCreateRepositoryTagCounter < 1 {
		if m.CreateRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.CreateRepositoryTag at\n%s", m.CreateRepositoryTagMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.CreateRepositoryTag at\n%s with params: %#v", m.CreateRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *m.CreateRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateRepositoryTag != nil && afterCreateRepositoryTagCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.CreateRepositoryTag at\n%s", m.funcCreateRepositoryTagOrigin)
	}

	if !m.CreateRepositoryTagMock.invocationsDone() && afterCreateRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.CreateRepositoryTag at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateRepositoryTagMock.expectedInvocations), m.CreateRepositoryTagMock.expectedInvocationsOrigin, afterCreateRepositoryTagCounter)
	}
}

type mServiceMockDeleteFiles struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockDeleteFilesExpectation
	expectations       []*ServiceMockDeleteFilesExpectation

	callArgs []*ServiceMockDeleteFilesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockDeleteFilesExpectation specifies expectation struct of the Service.DeleteFiles
type ServiceMockDeleteFilesExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockDeleteFilesParams
	paramPtrs          *ServiceMockDeleteFilesParamPtrs
	expectationOrigins ServiceMockDeleteFilesExpectationOrigins
	results            *ServiceMockDeleteFilesResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockDeleteFilesParams contains parameters of the Service.DeleteFiles
type ServiceMockDeleteFilesParams struct {
	ctx context.Context
	s1  string
	sa1 []string
}

// ServiceMockDeleteFilesParamPtrs contains pointers to parameters of the Service.DeleteFiles
type ServiceMockDeleteFilesParamPtrs struct {
	ctx *context.Context
	s1  *string
	sa1 *[]string
}

// ServiceMockDeleteFilesResults contains results of the Service.DeleteFiles
type ServiceMockDeleteFilesResults struct {
	err error
}

// ServiceMockDeleteFilesOrigins contains origins of expectations of the Service.DeleteFiles
type ServiceMockDeleteFilesExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
	originSa1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteFiles *mServiceMockDeleteFiles) Optional() *mServiceMockDeleteFiles {
	mmDeleteFiles.optional = true
	return mmDeleteFiles
}

// Expect sets up expected params for Service.DeleteFiles
func (mmDeleteFiles *mServiceMockDeleteFiles) Expect(ctx context.Context, s1 string, sa1 []string) *mServiceMockDeleteFiles {
	if mmDeleteFiles.mock.funcDeleteFiles != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by Set")
	}

	if mmDeleteFiles.defaultExpectation == nil {
		mmDeleteFiles.defaultExpectation = &ServiceMockDeleteFilesExpectation{}
	}

	if mmDeleteFiles.defaultExpectation.paramPtrs != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by ExpectParams functions")
	}

	mmDeleteFiles.defaultExpectation.params = &ServiceMockDeleteFilesParams{ctx, s1, sa1}
	mmDeleteFiles.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteFiles.expectations {
		if minimock.Equal(e.params, mmDeleteFiles.defaultExpectation.params) {
			mmDeleteFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteFiles.defaultExpectation.params)
		}
	}

	return mmDeleteFiles
}

// ExpectCtxParam1 sets up expected param ctx for Service.DeleteFiles
func (mmDeleteFiles *mServiceMockDeleteFiles) ExpectCtxParam1(ctx context.Context) *mServiceMockDeleteFiles {
	if mmDeleteFiles.mock.funcDeleteFiles != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by Set")
	}

	if mmDeleteFiles.defaultExpectation == nil {
		mmDeleteFiles.defaultExpectation = &ServiceMockDeleteFilesExpectation{}
	}

	if mmDeleteFiles.defaultExpectation.params != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by Expect")
	}

	if mmDeleteFiles.defaultExpectation.paramPtrs == nil {
		mmDeleteFiles.defaultExpectation.paramPtrs = &ServiceMockDeleteFilesParamPtrs{}
	}
	mmDeleteFiles.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteFiles.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteFiles
}

// ExpectS1Param2 sets up expected param s1 for Service.DeleteFiles
func (mmDeleteFiles *mServiceMockDeleteFiles) ExpectS1Param2(s1 string) *mServiceMockDeleteFiles {
	if mmDeleteFiles.mock.funcDeleteFiles != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by Set")
	}

	if mmDeleteFiles.defaultExpectation == nil {
		mmDeleteFiles.defaultExpectation = &ServiceMockDeleteFilesExpectation{}
	}

	if mmDeleteFiles.defaultExpectation.params != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by Expect")
	}

	if mmDeleteFiles.defaultExpectation.paramPtrs == nil {
		mmDeleteFiles.defaultExpectation.paramPtrs = &ServiceMockDeleteFilesParamPtrs{}
	}
	mmDeleteFiles.defaultExpectation.paramPtrs.s1 = &s1
	mmDeleteFiles.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmDeleteFiles
}

// ExpectSa1Param3 sets up expected param sa1 for Service.DeleteFiles
func (mmDeleteFiles *mServiceMockDeleteFiles) ExpectSa1Param3(sa1 []string) *mServiceMockDeleteFiles {
	if mmDeleteFiles.mock.funcDeleteFiles != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by Set")
	}

	if mmDeleteFiles.defaultExpectation == nil {
		mmDeleteFiles.defaultExpectation = &ServiceMockDeleteFilesExpectation{}
	}

	if mmDeleteFiles.defaultExpectation.params != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by Expect")
	}

	if mmDeleteFiles.defaultExpectation.paramPtrs == nil {
		mmDeleteFiles.defaultExpectation.paramPtrs = &ServiceMockDeleteFilesParamPtrs{}
	}
	mmDeleteFiles.defaultExpectation.paramPtrs.sa1 = &sa1
	mmDeleteFiles.defaultExpectation.expectationOrigins.originSa1 = minimock.CallerInfo(1)

	return mmDeleteFiles
}

// Inspect accepts an inspector function that has same arguments as the Service.DeleteFiles
func (mmDeleteFiles *mServiceMockDeleteFiles) Inspect(f func(ctx context.Context, s1 string, sa1 []string)) *mServiceMockDeleteFiles {
	if mmDeleteFiles.mock.inspectFuncDeleteFiles != nil {
		mmDeleteFiles.mock.t.Fatalf("Inspect function is already set for ServiceMock.DeleteFiles")
	}

	mmDeleteFiles.mock.inspectFuncDeleteFiles = f

	return mmDeleteFiles
}

// Return sets up results that will be returned by Service.DeleteFiles
func (mmDeleteFiles *mServiceMockDeleteFiles) Return(err error) *ServiceMock {
	if mmDeleteFiles.mock.funcDeleteFiles != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by Set")
	}

	if mmDeleteFiles.defaultExpectation == nil {
		mmDeleteFiles.defaultExpectation = &ServiceMockDeleteFilesExpectation{mock: mmDeleteFiles.mock}
	}
	mmDeleteFiles.defaultExpectation.results = &ServiceMockDeleteFilesResults{err}
	mmDeleteFiles.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteFiles.mock
}

// Set uses given function f to mock the Service.DeleteFiles method
func (mmDeleteFiles *mServiceMockDeleteFiles) Set(f func(ctx context.Context, s1 string, sa1 []string) (err error)) *ServiceMock {
	if mmDeleteFiles.defaultExpectation != nil {
		mmDeleteFiles.mock.t.Fatalf("Default expectation is already set for the Service.DeleteFiles method")
	}

	if len(mmDeleteFiles.expectations) > 0 {
		mmDeleteFiles.mock.t.Fatalf("Some expectations are already set for the Service.DeleteFiles method")
	}

	mmDeleteFiles.mock.funcDeleteFiles = f
	mmDeleteFiles.mock.funcDeleteFilesOrigin = minimock.CallerInfo(1)
	return mmDeleteFiles.mock
}

// When sets expectation for the Service.DeleteFiles which will trigger the result defined by the following
// Then helper
func (mmDeleteFiles *mServiceMockDeleteFiles) When(ctx context.Context, s1 string, sa1 []string) *ServiceMockDeleteFilesExpectation {
	if mmDeleteFiles.mock.funcDeleteFiles != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by Set")
	}

	expectation := &ServiceMockDeleteFilesExpectation{
		mock:               mmDeleteFiles.mock,
		params:             &ServiceMockDeleteFilesParams{ctx, s1, sa1},
		expectationOrigins: ServiceMockDeleteFilesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteFiles.expectations = append(mmDeleteFiles.expectations, expectation)
	return expectation
}

// Then sets up Service.DeleteFiles return parameters for the expectation previously defined by the When method
func (e *ServiceMockDeleteFilesExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockDeleteFilesResults{err}
	return e.mock
}

// Times sets number of times Service.DeleteFiles should be invoked
func (mmDeleteFiles *mServiceMockDeleteFiles) Times(n uint64) *mServiceMockDeleteFiles {
	if n == 0 {
		mmDeleteFiles.mock.t.Fatalf("Times of ServiceMock.DeleteFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteFiles.expectedInvocations, n)
	mmDeleteFiles.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteFiles
}

func (mmDeleteFiles *mServiceMockDeleteFiles) invocationsDone() bool {
	if len(mmDeleteFiles.expectations) == 0 && mmDeleteFiles.defaultExpectation == nil && mmDeleteFiles.mock.funcDeleteFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteFiles.mock.afterDeleteFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteFiles implements mm_service.Service
func (mmDeleteFiles *ServiceMock) DeleteFiles(ctx context.Context, s1 string, sa1 []string) (err error) {
	mm_atomic.AddUint64(&mmDeleteFiles.beforeDeleteFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteFiles.afterDeleteFilesCounter, 1)

	mmDeleteFiles.t.Helper()

	if mmDeleteFiles.inspectFuncDeleteFiles != nil {
		mmDeleteFiles.inspectFuncDeleteFiles(ctx, s1, sa1)
	}

	mm_params := ServiceMockDeleteFilesParams{ctx, s1, sa1}

	// Record call args
	mmDeleteFiles.DeleteFilesMock.mutex.Lock()
	mmDeleteFiles.DeleteFilesMock.callArgs = append(mmDeleteFiles.DeleteFilesMock.callArgs, &mm_params)
	mmDeleteFiles.DeleteFilesMock.mutex.Unlock()

	for _, e := range mmDeleteFiles.DeleteFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteFiles.DeleteFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteFiles.DeleteFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteFiles.DeleteFilesMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteFiles.DeleteFilesMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockDeleteFilesParams{ctx, s1, sa1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteFiles.t.Errorf("ServiceMock.DeleteFiles got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFiles.DeleteFilesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmDeleteFiles.t.Errorf("ServiceMock.DeleteFiles got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFiles.DeleteFilesMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

			if mm_want_ptrs.sa1 != nil && !minimock.Equal(*mm_want_ptrs.sa1, mm_got.sa1) {
				mmDeleteFiles.t.Errorf("ServiceMock.DeleteFiles got unexpected parameter sa1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFiles.DeleteFilesMock.defaultExpectation.expectationOrigins.originSa1, *mm_want_ptrs.sa1, mm_got.sa1, minimock.Diff(*mm_want_ptrs.sa1, mm_got.sa1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteFiles.t.Errorf("ServiceMock.DeleteFiles got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteFiles.DeleteFilesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteFiles.DeleteFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteFiles.t.Fatal("No results are set for the ServiceMock.DeleteFiles")
		}
		return (*mm_results).err
	}
	if mmDeleteFiles.funcDeleteFiles != nil {
		return mmDeleteFiles.funcDeleteFiles(ctx, s1, sa1)
	}
	mmDeleteFiles.t.Fatalf("Unexpected call to ServiceMock.DeleteFiles. %v %v %v", ctx, s1, sa1)
	return
}

// DeleteFilesAfterCounter returns a count of finished ServiceMock.DeleteFiles invocations
func (mmDeleteFiles *ServiceMock) DeleteFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFiles.afterDeleteFilesCounter)
}

// DeleteFilesBeforeCounter returns a count of ServiceMock.DeleteFiles invocations
func (mmDeleteFiles *ServiceMock) DeleteFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFiles.beforeDeleteFilesCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.DeleteFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteFiles *mServiceMockDeleteFiles) Calls() []*ServiceMockDeleteFilesParams {
	mmDeleteFiles.mutex.RLock()

	argCopy := make([]*ServiceMockDeleteFilesParams, len(mmDeleteFiles.callArgs))
	copy(argCopy, mmDeleteFiles.callArgs)

	mmDeleteFiles.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteFilesDone returns true if the count of the DeleteFiles invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockDeleteFilesDone() bool {
	if m.DeleteFilesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteFilesMock.invocationsDone()
}

// MinimockDeleteFilesInspect logs each unmet expectation
func (m *ServiceMock) MinimockDeleteFilesInspect() {
	for _, e := range m.DeleteFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.DeleteFiles at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteFilesCounter := mm_atomic.LoadUint64(&m.afterDeleteFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFilesMock.defaultExpectation != nil && afterDeleteFilesCounter < 1 {
		if m.DeleteFilesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.DeleteFiles at\n%s", m.DeleteFilesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.DeleteFiles at\n%s with params: %#v", m.DeleteFilesMock.defaultExpectation.expectationOrigins.origin, *m.DeleteFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFiles != nil && afterDeleteFilesCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.DeleteFiles at\n%s", m.funcDeleteFilesOrigin)
	}

	if !m.DeleteFilesMock.invocationsDone() && afterDeleteFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.DeleteFiles at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteFilesMock.expectedInvocations), m.DeleteFilesMock.expectedInvocationsOrigin, afterDeleteFilesCounter)
	}
}

type mServiceMockDeleteRepositoryTag struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockDeleteRepositoryTagExpectation
	expectations       []*ServiceMockDeleteRepositoryTagExpectation

	callArgs []*ServiceMockDeleteRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockDeleteRepositoryTagExpectation specifies expectation struct of the Service.DeleteRepositoryTag
type ServiceMockDeleteRepositoryTagExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockDeleteRepositoryTagParams
	paramPtrs          *ServiceMockDeleteRepositoryTagParamPtrs
	expectationOrigins ServiceMockDeleteRepositoryTagExpectationOrigins
	results            *ServiceMockDeleteRepositoryTagResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockDeleteRepositoryTagParams contains parameters of the Service.DeleteRepositoryTag
type ServiceMockDeleteRepositoryTagParams struct {
	ctx context.Context
	dp1 *artifactpb.DeleteRepositoryTagRequest
}

// ServiceMockDeleteRepositoryTagParamPtrs contains pointers to parameters of the Service.DeleteRepositoryTag
type ServiceMockDeleteRepositoryTagParamPtrs struct {
	ctx *context.Context
	dp1 **artifactpb.DeleteRepositoryTagRequest
}

// ServiceMockDeleteRepositoryTagResults contains results of the Service.DeleteRepositoryTag
type ServiceMockDeleteRepositoryTagResults struct {
	dp2 *artifactpb.DeleteRepositoryTagResponse
	err error
}

// ServiceMockDeleteRepositoryTagOrigins contains origins of expectations of the Service.DeleteRepositoryTag
type ServiceMockDeleteRepositoryTagExpectationOrigins struct {
	origin    string
	originCtx string
	originDp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) Optional() *mServiceMockDeleteRepositoryTag {
	mmDeleteRepositoryTag.optional = true
	return mmDeleteRepositoryTag
}

// Expect sets up expected params for Service.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) Expect(ctx context.Context, dp1 *artifactpb.DeleteRepositoryTagRequest) *mServiceMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("ServiceMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &ServiceMockDeleteRepositoryTagExpectation{}
	}

	if mmDeleteRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("ServiceMock.DeleteRepositoryTag mock is already set by ExpectParams functions")
	}

	mmDeleteRepositoryTag.defaultExpectation.params = &ServiceMockDeleteRepositoryTagParams{ctx, dp1}
	mmDeleteRepositoryTag.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteRepositoryTag.expectations {
		if minimock.Equal(e.params, mmDeleteRepositoryTag.defaultExpectation.params) {
			mmDeleteRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteRepositoryTag.defaultExpectation.params)
		}
	}

	return mmDeleteRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for Service.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) ExpectCtxParam1(ctx context.Context) *mServiceMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("ServiceMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &ServiceMockDeleteRepositoryTagExpectation{}
	}

	if mmDeleteRepositoryTag.defaultExpectation.params != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("ServiceMock.DeleteRepositoryTag mock is already set by Expect")
	}

	if mmDeleteRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmDeleteRepositoryTag.defaultExpectation.paramPtrs = &ServiceMockDeleteRepositoryTagParamPtrs{}
	}
	mmDeleteRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteRepositoryTag.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteRepositoryTag
}

// ExpectDp1Param2 sets up expected param dp1 for Service.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) ExpectDp1Param2(dp1 *artifactpb.DeleteRepositoryTagRequest) *mServiceMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("ServiceMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &ServiceMockDeleteRepositoryTagExpectation{}
	}

	if mmDeleteRepositoryTag.defaultExpectation.params != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("ServiceMock.DeleteRepositoryTag mock is already set by Expect")
	}

	if mmDeleteRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmDeleteRepositoryTag.defaultExpectation.paramPtrs = &ServiceMockDeleteRepositoryTagParamPtrs{}
	}
	mmDeleteRepositoryTag.defaultExpectation.paramPtrs.dp1 = &dp1
	mmDeleteRepositoryTag.defaultExpectation.expectationOrigins.originDp1 = minimock.CallerInfo(1)

	return mmDeleteRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the Service.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) Inspect(f func(ctx context.Context, dp1 *artifactpb.DeleteRepositoryTagRequest)) *mServiceMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.inspectFuncDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("Inspect function is already set for ServiceMock.DeleteRepositoryTag")
	}

	mmDeleteRepositoryTag.mock.inspectFuncDeleteRepositoryTag = f

	return mmDeleteRepositoryTag
}

// Return sets up results that will be returned by Service.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) Return(dp2 *artifactpb.DeleteRepositoryTagResponse, err error) *ServiceMock {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("ServiceMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &ServiceMockDeleteRepositoryTagExpectation{mock: mmDeleteRepositoryTag.mock}
	}
	mmDeleteRepositoryTag.defaultExpectation.results = &ServiceMockDeleteRepositoryTagResults{dp2, err}
	mmDeleteRepositoryTag.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteRepositoryTag.mock
}

// Set uses given function f to mock the Service.DeleteRepositoryTag method
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) Set(f func(ctx context.Context, dp1 *artifactpb.DeleteRepositoryTagRequest) (dp2 *artifactpb.DeleteRepositoryTagResponse, err error)) *ServiceMock {
	if mmDeleteRepositoryTag.defaultExpectation != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("Default expectation is already set for the Service.DeleteRepositoryTag method")
	}

	if len(mmDeleteRepositoryTag.expectations) > 0 {
		mmDeleteRepositoryTag.mock.t.Fatalf("Some expectations are already set for the Service.DeleteRepositoryTag method")
	}

	mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag = f
	mmDeleteRepositoryTag.mock.funcDeleteRepositoryTagOrigin = minimock.CallerInfo(1)
	return mmDeleteRepositoryTag.mock
}

// When sets expectation for the Service.DeleteRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) When(ctx context.Context, dp1 *artifactpb.DeleteRepositoryTagRequest) *ServiceMockDeleteRepositoryTagExpectation {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("ServiceMock.DeleteRepositoryTag mock is already set by Set")
	}

	expectation := &ServiceMockDeleteRepositoryTagExpectation{
		mock:               mmDeleteRepositoryTag.mock,
		params:             &ServiceMockDeleteRepositoryTagParams{ctx, dp1},
		expectationOrigins: ServiceMockDeleteRepositoryTagExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteRepositoryTag.expectations = append(mmDeleteRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up Service.DeleteRepositoryTag return parameters for the expectation previously defined by the When method
func (e *ServiceMockDeleteRepositoryTagExpectation) Then(dp2 *artifactpb.DeleteRepositoryTagResponse, err error) *ServiceMock {
	e.results = &ServiceMockDeleteRepositoryTagResults{dp2, err}
	return e.mock
}

// Times sets number of times Service.DeleteRepositoryTag should be invoked
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) Times(n uint64) *mServiceMockDeleteRepositoryTag {
	if n == 0 {
		mmDeleteRepositoryTag.mock.t.Fatalf("Times of ServiceMock.DeleteRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteRepositoryTag.expectedInvocations, n)
	mmDeleteRepositoryTag.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteRepositoryTag
}

func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) invocationsDone() bool {
	if len(mmDeleteRepositoryTag.expectations) == 0 && mmDeleteRepositoryTag.defaultExpectation == nil && mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteRepositoryTag.mock.afterDeleteRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteRepositoryTag implements mm_service.Service
func (mmDeleteRepositoryTag *ServiceMock) DeleteRepositoryTag(ctx context.Context, dp1 *artifactpb.DeleteRepositoryTagRequest) (dp2 *artifactpb.DeleteRepositoryTagResponse, err error) {
	mm_atomic.AddUint64(&mmDeleteRepositoryTag.beforeDeleteRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteRepositoryTag.afterDeleteRepositoryTagCounter, 1)

	mmDeleteRepositoryTag.t.Helper()

	if mmDeleteRepositoryTag.inspectFuncDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.inspectFuncDeleteRepositoryTag(ctx, dp1)
	}

	mm_params := ServiceMockDeleteRepositoryTagParams{ctx, dp1}

	// Record call args
	mmDeleteRepositoryTag.DeleteRepositoryTagMock.mutex.Lock()
	mmDeleteRepositoryTag.DeleteRepositoryTagMock.callArgs = append(mmDeleteRepositoryTag.DeleteRepositoryTagMock.callArgs, &mm_params)
	mmDeleteRepositoryTag.DeleteRepositoryTagMock.mutex.Unlock()

	for _, e := range mmDeleteRepositoryTag.DeleteRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp2, e.results.err
		}
	}

	if mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockDeleteRepositoryTagParams{ctx, dp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteRepositoryTag.t.Errorf("ServiceMock.DeleteRepositoryTag got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dp1 != nil && !minimock.Equal(*mm_want_ptrs.dp1, mm_got.dp1) {
				mmDeleteRepositoryTag.t.Errorf("ServiceMock.DeleteRepositoryTag got unexpected parameter dp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.expectationOrigins.originDp1, *mm_want_ptrs.dp1, mm_got.dp1, minimock.Diff(*mm_want_ptrs.dp1, mm_got.dp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteRepositoryTag.t.Errorf("ServiceMock.DeleteRepositoryTag got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteRepositoryTag.t.Fatal("No results are set for the ServiceMock.DeleteRepositoryTag")
		}
		return (*mm_results).dp2, (*mm_results).err
	}
	if mmDeleteRepositoryTag.funcDeleteRepositoryTag != nil {
		return mmDeleteRepositoryTag.funcDeleteRepositoryTag(ctx, dp1)
	}
	mmDeleteRepositoryTag.t.Fatalf("Unexpected call to ServiceMock.DeleteRepositoryTag. %v %v", ctx, dp1)
	return
}

// DeleteRepositoryTagAfterCounter returns a count of finished ServiceMock.DeleteRepositoryTag invocations
func (mmDeleteRepositoryTag *ServiceMock) DeleteRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRepositoryTag.afterDeleteRepositoryTagCounter)
}

// DeleteRepositoryTagBeforeCounter returns a count of ServiceMock.DeleteRepositoryTag invocations
func (mmDeleteRepositoryTag *ServiceMock) DeleteRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRepositoryTag.beforeDeleteRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.DeleteRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) Calls() []*ServiceMockDeleteRepositoryTagParams {
	mmDeleteRepositoryTag.mutex.RLock()

	argCopy := make([]*ServiceMockDeleteRepositoryTagParams, len(mmDeleteRepositoryTag.callArgs))
	copy(argCopy, mmDeleteRepositoryTag.callArgs)

	mmDeleteRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteRepositoryTagDone returns true if the count of the DeleteRepositoryTag invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockDeleteRepositoryTagDone() bool {
	if m.DeleteRepositoryTagMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteRepositoryTagMock.invocationsDone()
}

// MinimockDeleteRepositoryTagInspect logs each unmet expectation
func (m *ServiceMock) MinimockDeleteRepositoryTagInspect() {
	for _, e := range m.DeleteRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.DeleteRepositoryTag at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterDeleteRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteRepositoryTagMock.defaultExpectation != nil && afterDeleteRepositoryTagCounter < 1 {
		if m.DeleteRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.DeleteRepositoryTag at\n%s", m.DeleteRepositoryTagMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.DeleteRepositoryTag at\n%s with params: %#v", m.DeleteRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *m.DeleteRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteRepositoryTag != nil && afterDeleteRepositoryTagCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.DeleteRepositoryTag at\n%s", m.funcDeleteRepositoryTagOrigin)
	}

	if !m.DeleteRepositoryTagMock.invocationsDone() && afterDeleteRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.DeleteRepositoryTag at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteRepositoryTagMock.expectedInvocations), m.DeleteRepositoryTagMock.expectedInvocationsOrigin, afterDeleteRepositoryTagCounter)
	}
}

type mServiceMockEmbedTexts struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockEmbedTextsExpectation
	expectations       []*ServiceMockEmbedTextsExpectation

	callArgs []*ServiceMockEmbedTextsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockEmbedTextsExpectation specifies expectation struct of the Service.EmbedTexts
type ServiceMockEmbedTextsExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockEmbedTextsParams
	paramPtrs          *ServiceMockEmbedTextsParamPtrs
	expectationOrigins ServiceMockEmbedTextsExpectationOrigins
	results            *ServiceMockEmbedTextsResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockEmbedTextsParams contains parameters of the Service.EmbedTexts
type ServiceMockEmbedTextsParams struct {
	ctx context.Context
	sa1 []string
	i1  int
	m1  map[string][]string
}

// ServiceMockEmbedTextsParamPtrs contains pointers to parameters of the Service.EmbedTexts
type ServiceMockEmbedTextsParamPtrs struct {
	ctx *context.Context
	sa1 *[]string
	i1  *int
	m1  *map[string][]string
}

// ServiceMockEmbedTextsResults contains results of the Service.EmbedTexts
type ServiceMockEmbedTextsResults struct {
	faa1 [][]float32
	err  error
}

// ServiceMockEmbedTextsOrigins contains origins of expectations of the Service.EmbedTexts
type ServiceMockEmbedTextsExpectationOrigins struct {
	origin    string
	originCtx string
	originSa1 string
	originI1  string
	originM1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmEmbedTexts *mServiceMockEmbedTexts) Optional() *mServiceMockEmbedTexts {
	mmEmbedTexts.optional = true
	return mmEmbedTexts
}

// Expect sets up expected params for Service.EmbedTexts
func (mmEmbedTexts *mServiceMockEmbedTexts) Expect(ctx context.Context, sa1 []string, i1 int, m1 map[string][]string) *mServiceMockEmbedTexts {
	if mmEmbedTexts.mock.funcEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("ServiceMock.EmbedTexts mock is already set by Set")
	}

	if mmEmbedTexts.defaultExpectation == nil {
		mmEmbedTexts.defaultExpectation = &ServiceMockEmbedTextsExpectation{}
	}

	if mmEmbedTexts.defaultExpectation.paramPtrs != nil {
		mmEmbedTexts.mock.t.Fatalf("ServiceMock.EmbedTexts mock is already set by ExpectParams functions")
	}

	mmEmbedTexts.defaultExpectation.params = &ServiceMockEmbedTextsParams{ctx, sa1, i1, m1}
	mmEmbedTexts.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmEmbedTexts.expectations {
		if minimock.Equal(e.params, mmEmbedTexts.defaultExpectation.params) {
			mmEmbedTexts.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEmbedTexts.defaultExpectation.params)
		}
	}

	return mmEmbedTexts
}

// ExpectCtxParam1 sets up expected param ctx for Service.EmbedTexts
func (mmEmbedTexts *mServiceMockEmbedTexts) ExpectCtxParam1(ctx context.Context) *mServiceMockEmbedTexts {
	if mmEmbedTexts.mock.funcEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("ServiceMock.EmbedTexts mock is already set by Set")
	}

	if mmEmbedTexts.defaultExpectation == nil {
		mmEmbedTexts.defaultExpectation = &ServiceMockEmbedTextsExpectation{}
	}

	if mmEmbedTexts.defaultExpectation.params != nil {
		mmEmbedTexts.mock.t.Fatalf("ServiceMock.EmbedTexts mock is already set by Expect")
	}

	if mmEmbedTexts.defaultExpectation.paramPtrs == nil {
		mmEmbedTexts.defaultExpectation.paramPtrs = &ServiceMockEmbedTextsParamPtrs{}
	}
	mmEmbedTexts.defaultExpectation.paramPtrs.ctx = &ctx
	mmEmbedTexts.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmEmbedTexts
}

// ExpectSa1Param2 sets up expected param sa1 for Service.EmbedTexts
func (mmEmbedTexts *mServiceMockEmbedTexts) ExpectSa1Param2(sa1 []string) *mServiceMockEmbedTexts {
	if mmEmbedTexts.mock.funcEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("ServiceMock.EmbedTexts mock is already set by Set")
	}

	if mmEmbedTexts.defaultExpectation == nil {
		mmEmbedTexts.defaultExpectation = &ServiceMockEmbedTextsExpectation{}
	}

	if mmEmbedTexts.defaultExpectation.params != nil {
		mmEmbedTexts.mock.t.Fatalf("ServiceMock.EmbedTexts mock is already set by Expect")
	}

	if mmEmbedTexts.defaultExpectation.paramPtrs == nil {
		mmEmbedTexts.defaultExpectation.paramPtrs = &ServiceMockEmbedTextsParamPtrs{}
	}
	mmEmbedTexts.defaultExpectation.paramPtrs.sa1 = &sa1
	mmEmbedTexts.defaultExpectation.expectationOrigins.originSa1 = minimock.CallerInfo(1)

	return mmEmbedTexts
}

// ExpectI1Param3 sets up expected param i1 for Service.EmbedTexts
func (mmEmbedTexts *mServiceMockEmbedTexts) ExpectI1Param3(i1 int) *mServiceMockEmbedTexts {
	if mmEmbedTexts.mock.funcEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("ServiceMock.EmbedTexts mock is already set by Set")
	}

	if mmEmbedTexts.defaultExpectation == nil {
		mmEmbedTexts.defaultExpectation = &ServiceMockEmbedTextsExpectation{}
	}

	if mmEmbedTexts.defaultExpectation.params != nil {
		mmEmbedTexts.mock.t.Fatalf("ServiceMock.EmbedTexts mock is already set by Expect")
	}

	if mmEmbedTexts.defaultExpectation.paramPtrs == nil {
		mmEmbedTexts.defaultExpectation.paramPtrs = &ServiceMockEmbedTextsParamPtrs{}
	}
	mmEmbedTexts.defaultExpectation.paramPtrs.i1 = &i1
	mmEmbedTexts.defaultExpectation.expectationOrigins.originI1 = minimock.CallerInfo(1)

	return mmEmbedTexts
}

// ExpectM1Param4 sets up expected param m1 for Service.EmbedTexts
func (mmEmbedTexts *mServiceMockEmbedTexts) ExpectM1Param4(m1 map[string][]string) *mServiceMockEmbedTexts {
	if mmEmbedTexts.mock.funcEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("ServiceMock.EmbedTexts mock is already set by Set")
	}

	if mmEmbedTexts.defaultExpectation == nil {
		mmEmbedTexts.defaultExpectation = &ServiceMockEmbedTextsExpectation{}
	}

	if mmEmbedTexts.defaultExpectation.params != nil {
		mmEmbedTexts.mock.t.Fatalf("ServiceMock.EmbedTexts mock is already set by Expect")
	}

	if mmEmbedTexts.defaultExpectation.paramPtrs == nil {
		mmEmbedTexts.defaultExpectation.paramPtrs = &ServiceMockEmbedTextsParamPtrs{}
	}
	mmEmbedTexts.defaultExpectation.paramPtrs.m1 = &m1
	mmEmbedTexts.defaultExpectation.expectationOrigins.originM1 = minimock.CallerInfo(1)

	return mmEmbedTexts
}

// Inspect accepts an inspector function that has same arguments as the Service.EmbedTexts
func (mmEmbedTexts *mServiceMockEmbedTexts) Inspect(f func(ctx context.Context, sa1 []string, i1 int, m1 map[string][]string)) *mServiceMockEmbedTexts {
	if mmEmbedTexts.mock.inspectFuncEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("Inspect function is already set for ServiceMock.EmbedTexts")
	}

	mmEmbedTexts.mock.inspectFuncEmbedTexts = f

	return mmEmbedTexts
}

// Return sets up results that will be returned by Service.EmbedTexts
func (mmEmbedTexts *mServiceMockEmbedTexts) Return(faa1 [][]float32, err error) *ServiceMock {
	if mmEmbedTexts.mock.funcEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("ServiceMock.EmbedTexts mock is already set by Set")
	}

	if mmEmbedTexts.defaultExpectation == nil {
		mmEmbedTexts.defaultExpectation = &ServiceMockEmbedTextsExpectation{mock: mmEmbedTexts.mock}
	}
	mmEmbedTexts.defaultExpectation.results = &ServiceMockEmbedTextsResults{faa1, err}
	mmEmbedTexts.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmEmbedTexts.mock
}

// Set uses given function f to mock the Service.EmbedTexts method
func (mmEmbedTexts *mServiceMockEmbedTexts) Set(f func(ctx context.Context, sa1 []string, i1 int, m1 map[string][]string) (faa1 [][]float32, err error)) *ServiceMock {
	if mmEmbedTexts.defaultExpectation != nil {
		mmEmbedTexts.mock.t.Fatalf("Default expectation is already set for the Service.EmbedTexts method")
	}

	if len(mmEmbedTexts.expectations) > 0 {
		mmEmbedTexts.mock.t.Fatalf("Some expectations are already set for the Service.EmbedTexts method")
	}

	mmEmbedTexts.mock.funcEmbedTexts = f
	mmEmbedTexts.mock.funcEmbedTextsOrigin = minimock.CallerInfo(1)
	return mmEmbedTexts.mock
}

// When sets expectation for the Service.EmbedTexts which will trigger the result defined by the following
// Then helper
func (mmEmbedTexts *mServiceMockEmbedTexts) When(ctx context.Context, sa1 []string, i1 int, m1 map[string][]string) *ServiceMockEmbedTextsExpectation {
	if mmEmbedTexts.mock.funcEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("ServiceMock.EmbedTexts mock is already set by Set")
	}

	expectation := &ServiceMockEmbedTextsExpectation{
		mock:               mmEmbedTexts.mock,
		params:             &ServiceMockEmbedTextsParams{ctx, sa1, i1, m1},
		expectationOrigins: ServiceMockEmbedTextsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmEmbedTexts.expectations = append(mmEmbedTexts.expectations, expectation)
	return expectation
}

// Then sets up Service.EmbedTexts return parameters for the expectation previously defined by the When method
func (e *ServiceMockEmbedTextsExpectation) Then(faa1 [][]float32, err error) *ServiceMock {
	e.results = &ServiceMockEmbedTextsResults{faa1, err}
	return e.mock
}

// Times sets number of times Service.EmbedTexts should be invoked
func (mmEmbedTexts *mServiceMockEmbedTexts) Times(n uint64) *mServiceMockEmbedTexts {
	if n == 0 {
		mmEmbedTexts.mock.t.Fatalf("Times of ServiceMock.EmbedTexts mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmEmbedTexts.expectedInvocations, n)
	mmEmbedTexts.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmEmbedTexts
}

func (mmEmbedTexts *mServiceMockEmbedTexts) invocationsDone() bool {
	if len(mmEmbedTexts.expectations) == 0 && mmEmbedTexts.defaultExpectation == nil && mmEmbedTexts.mock.funcEmbedTexts == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmEmbedTexts.mock.afterEmbedTextsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmEmbedTexts.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// EmbedTexts implements mm_service.Service
func (mmEmbedTexts *ServiceMock) EmbedTexts(ctx context.Context, sa1 []string, i1 int, m1 map[string][]string) (faa1 [][]float32, err error) {
	mm_atomic.AddUint64(&mmEmbedTexts.beforeEmbedTextsCounter, 1)
	defer mm_atomic.AddUint64(&mmEmbedTexts.afterEmbedTextsCounter, 1)

	mmEmbedTexts.t.Helper()

	if mmEmbedTexts.inspectFuncEmbedTexts != nil {
		mmEmbedTexts.inspectFuncEmbedTexts(ctx, sa1, i1, m1)
	}

	mm_params := ServiceMockEmbedTextsParams{ctx, sa1, i1, m1}

	// Record call args
	mmEmbedTexts.EmbedTextsMock.mutex.Lock()
	mmEmbedTexts.EmbedTextsMock.callArgs = append(mmEmbedTexts.EmbedTextsMock.callArgs, &mm_params)
	mmEmbedTexts.EmbedTextsMock.mutex.Unlock()

	for _, e := range mmEmbedTexts.EmbedTextsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.faa1, e.results.err
		}
	}

	if mmEmbedTexts.EmbedTextsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEmbedTexts.EmbedTextsMock.defaultExpectation.Counter, 1)
		mm_want := mmEmbedTexts.EmbedTextsMock.defaultExpectation.params
		mm_want_ptrs := mmEmbedTexts.EmbedTextsMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockEmbedTextsParams{ctx, sa1, i1, m1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmEmbedTexts.t.Errorf("ServiceMock.EmbedTexts got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEmbedTexts.EmbedTextsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sa1 != nil && !minimock.Equal(*mm_want_ptrs.sa1, mm_got.sa1) {
				mmEmbedTexts.t.Errorf("ServiceMock.EmbedTexts got unexpected parameter sa1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEmbedTexts.EmbedTextsMock.defaultExpectation.expectationOrigins.originSa1, *mm_want_ptrs.sa1, mm_got.sa1, minimock.Diff(*mm_want_ptrs.sa1, mm_got.sa1))
			}

			if mm_want_ptrs.i1 != nil && !minimock.Equal(*mm_want_ptrs.i1, mm_got.i1) {
				mmEmbedTexts.t.Errorf("ServiceMock.EmbedTexts got unexpected parameter i1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEmbedTexts.EmbedTextsMock.defaultExpectation.expectationOrigins.originI1, *mm_want_ptrs.i1, mm_got.i1, minimock.Diff(*mm_want_ptrs.i1, mm_got.i1))
			}

			if mm_want_ptrs.m1 != nil && !minimock.Equal(*mm_want_ptrs.m1, mm_got.m1) {
				mmEmbedTexts.t.Errorf("ServiceMock.EmbedTexts got unexpected parameter m1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEmbedTexts.EmbedTextsMock.defaultExpectation.expectationOrigins.originM1, *mm_want_ptrs.m1, mm_got.m1, minimock.Diff(*mm_want_ptrs.m1, mm_got.m1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEmbedTexts.t.Errorf("ServiceMock.EmbedTexts got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmEmbedTexts.EmbedTextsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEmbedTexts.EmbedTextsMock.defaultExpectation.results
		if mm_results == nil {
			mmEmbedTexts.t.Fatal("No results are set for the ServiceMock.EmbedTexts")
		}
		return (*mm_results).faa1, (*mm_results).err
	}
	if mmEmbedTexts.funcEmbedTexts != nil {
		return mmEmbedTexts.funcEmbedTexts(ctx, sa1, i1, m1)
	}
	mmEmbedTexts.t.Fatalf("Unexpected call to ServiceMock.EmbedTexts. %v %v %v %v", ctx, sa1, i1, m1)
	return
}

// EmbedTextsAfterCounter returns a count of finished ServiceMock.EmbedTexts invocations
func (mmEmbedTexts *ServiceMock) EmbedTextsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEmbedTexts.afterEmbedTextsCounter)
}

// EmbedTextsBeforeCounter returns a count of ServiceMock.EmbedTexts invocations
func (mmEmbedTexts *ServiceMock) EmbedTextsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEmbedTexts.beforeEmbedTextsCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.EmbedTexts.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEmbedTexts *mServiceMockEmbedTexts) Calls() []*ServiceMockEmbedTextsParams {
	mmEmbedTexts.mutex.RLock()

	argCopy := make([]*ServiceMockEmbedTextsParams, len(mmEmbedTexts.callArgs))
	copy(argCopy, mmEmbedTexts.callArgs)

	mmEmbedTexts.mutex.RUnlock()

	return argCopy
}

// MinimockEmbedTextsDone returns true if the count of the EmbedTexts invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockEmbedTextsDone() bool {
	if m.EmbedTextsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.EmbedTextsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.EmbedTextsMock.invocationsDone()
}

// MinimockEmbedTextsInspect logs each unmet expectation
func (m *ServiceMock) MinimockEmbedTextsInspect() {
	for _, e := range m.EmbedTextsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.EmbedTexts at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterEmbedTextsCounter := mm_atomic.LoadUint64(&m.afterEmbedTextsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.EmbedTextsMock.defaultExpectation != nil && afterEmbedTextsCounter < 1 {
		if m.EmbedTextsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.EmbedTexts at\n%s", m.EmbedTextsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.EmbedTexts at\n%s with params: %#v", m.EmbedTextsMock.defaultExpectation.expectationOrigins.origin, *m.EmbedTextsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEmbedTexts != nil && afterEmbedTextsCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.EmbedTexts at\n%s", m.funcEmbedTextsOrigin)
	}

	if !m.EmbedTextsMock.invocationsDone() && afterEmbedTextsCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.EmbedTexts at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.EmbedTextsMock.expectedInvocations), m.EmbedTextsMock.expectedInvocationsOrigin, afterEmbedTextsCounter)
	}
}

type mServiceMockGetChatCacheForFiles struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetChatCacheForFilesExpectation
	expectations       []*ServiceMockGetChatCacheForFilesExpectation

	callArgs []*ServiceMockGetChatCacheForFilesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetChatCacheForFilesExpectation specifies expectation struct of the Service.GetChatCacheForFiles
type ServiceMockGetChatCacheForFilesExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetChatCacheForFilesParams
	paramPtrs          *ServiceMockGetChatCacheForFilesParamPtrs
	expectationOrigins ServiceMockGetChatCacheForFilesExpectationOrigins
	results            *ServiceMockGetChatCacheForFilesResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetChatCacheForFilesParams contains parameters of the Service.GetChatCacheForFiles
type ServiceMockGetChatCacheForFilesParams struct {
	ctx context.Context
	k1  types.KBUIDType
	fa1 []types.FileUIDType
}

// ServiceMockGetChatCacheForFilesParamPtrs contains pointers to parameters of the Service.GetChatCacheForFiles
type ServiceMockGetChatCacheForFilesParamPtrs struct {
	ctx *context.Context
	k1  *types.KBUIDType
	fa1 *[]types.FileUIDType
}

// ServiceMockGetChatCacheForFilesResults contains results of the Service.GetChatCacheForFiles
type ServiceMockGetChatCacheForFilesResults struct {
	cp1 *repository.ChatCacheMetadata
	err error
}

// ServiceMockGetChatCacheForFilesOrigins contains origins of expectations of the Service.GetChatCacheForFiles
type ServiceMockGetChatCacheForFilesExpectationOrigins struct {
	origin    string
	originCtx string
	originK1  string
	originFa1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetChatCacheForFiles *mServiceMockGetChatCacheForFiles) Optional() *mServiceMockGetChatCacheForFiles {
	mmGetChatCacheForFiles.optional = true
	return mmGetChatCacheForFiles
}

// Expect sets up expected params for Service.GetChatCacheForFiles
func (mmGetChatCacheForFiles *mServiceMockGetChatCacheForFiles) Expect(ctx context.Context, k1 types.KBUIDType, fa1 []types.FileUIDType) *mServiceMockGetChatCacheForFiles {
	if mmGetChatCacheForFiles.mock.funcGetChatCacheForFiles != nil {
		mmGetChatCacheForFiles.mock.t.Fatalf("ServiceMock.GetChatCacheForFiles mock is already set by Set")
	}

	if mmGetChatCacheForFiles.defaultExpectation == nil {
		mmGetChatCacheForFiles.defaultExpectation = &ServiceMockGetChatCacheForFilesExpectation{}
	}

	if mmGetChatCacheForFiles.defaultExpectation.paramPtrs != nil {
		mmGetChatCacheForFiles.mock.t.Fatalf("ServiceMock.GetChatCacheForFiles mock is already set by ExpectParams functions")
	}

	mmGetChatCacheForFiles.defaultExpectation.params = &ServiceMockGetChatCacheForFilesParams{ctx, k1, fa1}
	mmGetChatCacheForFiles.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetChatCacheForFiles.expectations {
		if minimock.Equal(e.params, mmGetChatCacheForFiles.defaultExpectation.params) {
			mmGetChatCacheForFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChatCacheForFiles.defaultExpectation.params)
		}
	}

	return mmGetChatCacheForFiles
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetChatCacheForFiles
func (mmGetChatCacheForFiles *mServiceMockGetChatCacheForFiles) ExpectCtxParam1(ctx context.Context) *mServiceMockGetChatCacheForFiles {
	if mmGetChatCacheForFiles.mock.funcGetChatCacheForFiles != nil {
		mmGetChatCacheForFiles.mock.t.Fatalf("ServiceMock.GetChatCacheForFiles mock is already set by Set")
	}

	if mmGetChatCacheForFiles.defaultExpectation == nil {
		mmGetChatCacheForFiles.defaultExpectation = &ServiceMockGetChatCacheForFilesExpectation{}
	}

	if mmGetChatCacheForFiles.defaultExpectation.params != nil {
		mmGetChatCacheForFiles.mock.t.Fatalf("ServiceMock.GetChatCacheForFiles mock is already set by Expect")
	}

	if mmGetChatCacheForFiles.defaultExpectation.paramPtrs == nil {
		mmGetChatCacheForFiles.defaultExpectation.paramPtrs = &ServiceMockGetChatCacheForFilesParamPtrs{}
	}
	mmGetChatCacheForFiles.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetChatCacheForFiles.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetChatCacheForFiles
}

// ExpectK1Param2 sets up expected param k1 for Service.GetChatCacheForFiles
func (mmGetChatCacheForFiles *mServiceMockGetChatCacheForFiles) ExpectK1Param2(k1 types.KBUIDType) *mServiceMockGetChatCacheForFiles {
	if mmGetChatCacheForFiles.mock.funcGetChatCacheForFiles != nil {
		mmGetChatCacheForFiles.mock.t.Fatalf("ServiceMock.GetChatCacheForFiles mock is already set by Set")
	}

	if mmGetChatCacheForFiles.defaultExpectation == nil {
		mmGetChatCacheForFiles.defaultExpectation = &ServiceMockGetChatCacheForFilesExpectation{}
	}

	if mmGetChatCacheForFiles.defaultExpectation.params != nil {
		mmGetChatCacheForFiles.mock.t.Fatalf("ServiceMock.GetChatCacheForFiles mock is already set by Expect")
	}

	if mmGetChatCacheForFiles.defaultExpectation.paramPtrs == nil {
		mmGetChatCacheForFiles.defaultExpectation.paramPtrs = &ServiceMockGetChatCacheForFilesParamPtrs{}
	}
	mmGetChatCacheForFiles.defaultExpectation.paramPtrs.k1 = &k1
	mmGetChatCacheForFiles.defaultExpectation.expectationOrigins.originK1 = minimock.CallerInfo(1)

	return mmGetChatCacheForFiles
}

// ExpectFa1Param3 sets up expected param fa1 for Service.GetChatCacheForFiles
func (mmGetChatCacheForFiles *mServiceMockGetChatCacheForFiles) ExpectFa1Param3(fa1 []types.FileUIDType) *mServiceMockGetChatCacheForFiles {
	if mmGetChatCacheForFiles.mock.funcGetChatCacheForFiles != nil {
		mmGetChatCacheForFiles.mock.t.Fatalf("ServiceMock.GetChatCacheForFiles mock is already set by Set")
	}

	if mmGetChatCacheForFiles.defaultExpectation == nil {
		mmGetChatCacheForFiles.defaultExpectation = &ServiceMockGetChatCacheForFilesExpectation{}
	}

	if mmGetChatCacheForFiles.defaultExpectation.params != nil {
		mmGetChatCacheForFiles.mock.t.Fatalf("ServiceMock.GetChatCacheForFiles mock is already set by Expect")
	}

	if mmGetChatCacheForFiles.defaultExpectation.paramPtrs == nil {
		mmGetChatCacheForFiles.defaultExpectation.paramPtrs = &ServiceMockGetChatCacheForFilesParamPtrs{}
	}
	mmGetChatCacheForFiles.defaultExpectation.paramPtrs.fa1 = &fa1
	mmGetChatCacheForFiles.defaultExpectation.expectationOrigins.originFa1 = minimock.CallerInfo(1)

	return mmGetChatCacheForFiles
}

// Inspect accepts an inspector function that has same arguments as the Service.GetChatCacheForFiles
func (mmGetChatCacheForFiles *mServiceMockGetChatCacheForFiles) Inspect(f func(ctx context.Context, k1 types.KBUIDType, fa1 []types.FileUIDType)) *mServiceMockGetChatCacheForFiles {
	if mmGetChatCacheForFiles.mock.inspectFuncGetChatCacheForFiles != nil {
		mmGetChatCacheForFiles.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetChatCacheForFiles")
	}

	mmGetChatCacheForFiles.mock.inspectFuncGetChatCacheForFiles = f

	return mmGetChatCacheForFiles
}

// Return sets up results that will be returned by Service.GetChatCacheForFiles
func (mmGetChatCacheForFiles *mServiceMockGetChatCacheForFiles) Return(cp1 *repository.ChatCacheMetadata, err error) *ServiceMock {
	if mmGetChatCacheForFiles.mock.funcGetChatCacheForFiles != nil {
		mmGetChatCacheForFiles.mock.t.Fatalf("ServiceMock.GetChatCacheForFiles mock is already set by Set")
	}

	if mmGetChatCacheForFiles.defaultExpectation == nil {
		mmGetChatCacheForFiles.defaultExpectation = &ServiceMockGetChatCacheForFilesExpectation{mock: mmGetChatCacheForFiles.mock}
	}
	mmGetChatCacheForFiles.defaultExpectation.results = &ServiceMockGetChatCacheForFilesResults{cp1, err}
	mmGetChatCacheForFiles.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetChatCacheForFiles.mock
}

// Set uses given function f to mock the Service.GetChatCacheForFiles method
func (mmGetChatCacheForFiles *mServiceMockGetChatCacheForFiles) Set(f func(ctx context.Context, k1 types.KBUIDType, fa1 []types.FileUIDType) (cp1 *repository.ChatCacheMetadata, err error)) *ServiceMock {
	if mmGetChatCacheForFiles.defaultExpectation != nil {
		mmGetChatCacheForFiles.mock.t.Fatalf("Default expectation is already set for the Service.GetChatCacheForFiles method")
	}

	if len(mmGetChatCacheForFiles.expectations) > 0 {
		mmGetChatCacheForFiles.mock.t.Fatalf("Some expectations are already set for the Service.GetChatCacheForFiles method")
	}

	mmGetChatCacheForFiles.mock.funcGetChatCacheForFiles = f
	mmGetChatCacheForFiles.mock.funcGetChatCacheForFilesOrigin = minimock.CallerInfo(1)
	return mmGetChatCacheForFiles.mock
}

// When sets expectation for the Service.GetChatCacheForFiles which will trigger the result defined by the following
// Then helper
func (mmGetChatCacheForFiles *mServiceMockGetChatCacheForFiles) When(ctx context.Context, k1 types.KBUIDType, fa1 []types.FileUIDType) *ServiceMockGetChatCacheForFilesExpectation {
	if mmGetChatCacheForFiles.mock.funcGetChatCacheForFiles != nil {
		mmGetChatCacheForFiles.mock.t.Fatalf("ServiceMock.GetChatCacheForFiles mock is already set by Set")
	}

	expectation := &ServiceMockGetChatCacheForFilesExpectation{
		mock:               mmGetChatCacheForFiles.mock,
		params:             &ServiceMockGetChatCacheForFilesParams{ctx, k1, fa1},
		expectationOrigins: ServiceMockGetChatCacheForFilesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetChatCacheForFiles.expectations = append(mmGetChatCacheForFiles.expectations, expectation)
	return expectation
}

// Then sets up Service.GetChatCacheForFiles return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetChatCacheForFilesExpectation) Then(cp1 *repository.ChatCacheMetadata, err error) *ServiceMock {
	e.results = &ServiceMockGetChatCacheForFilesResults{cp1, err}
	return e.mock
}

// Times sets number of times Service.GetChatCacheForFiles should be invoked
func (mmGetChatCacheForFiles *mServiceMockGetChatCacheForFiles) Times(n uint64) *mServiceMockGetChatCacheForFiles {
	if n == 0 {
		mmGetChatCacheForFiles.mock.t.Fatalf("Times of ServiceMock.GetChatCacheForFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetChatCacheForFiles.expectedInvocations, n)
	mmGetChatCacheForFiles.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetChatCacheForFiles
}

func (mmGetChatCacheForFiles *mServiceMockGetChatCacheForFiles) invocationsDone() bool {
	if len(mmGetChatCacheForFiles.expectations) == 0 && mmGetChatCacheForFiles.defaultExpectation == nil && mmGetChatCacheForFiles.mock.funcGetChatCacheForFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetChatCacheForFiles.mock.afterGetChatCacheForFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetChatCacheForFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetChatCacheForFiles implements mm_service.Service
func (mmGetChatCacheForFiles *ServiceMock) GetChatCacheForFiles(ctx context.Context, k1 types.KBUIDType, fa1 []types.FileUIDType) (cp1 *repository.ChatCacheMetadata, err error) {
	mm_atomic.AddUint64(&mmGetChatCacheForFiles.beforeGetChatCacheForFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChatCacheForFiles.afterGetChatCacheForFilesCounter, 1)

	mmGetChatCacheForFiles.t.Helper()

	if mmGetChatCacheForFiles.inspectFuncGetChatCacheForFiles != nil {
		mmGetChatCacheForFiles.inspectFuncGetChatCacheForFiles(ctx, k1, fa1)
	}

	mm_params := ServiceMockGetChatCacheForFilesParams{ctx, k1, fa1}

	// Record call args
	mmGetChatCacheForFiles.GetChatCacheForFilesMock.mutex.Lock()
	mmGetChatCacheForFiles.GetChatCacheForFilesMock.callArgs = append(mmGetChatCacheForFiles.GetChatCacheForFilesMock.callArgs, &mm_params)
	mmGetChatCacheForFiles.GetChatCacheForFilesMock.mutex.Unlock()

	for _, e := range mmGetChatCacheForFiles.GetChatCacheForFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetChatCacheForFiles.GetChatCacheForFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChatCacheForFiles.GetChatCacheForFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChatCacheForFiles.GetChatCacheForFilesMock.defaultExpectation.params
		mm_want_ptrs := mmGetChatCacheForFiles.GetChatCacheForFilesMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetChatCacheForFilesParams{ctx, k1, fa1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetChatCacheForFiles.t.Errorf("ServiceMock.GetChatCacheForFiles got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChatCacheForFiles.GetChatCacheForFilesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.k1 != nil && !minimock.Equal(*mm_want_ptrs.k1, mm_got.k1) {
				mmGetChatCacheForFiles.t.Errorf("ServiceMock.GetChatCacheForFiles got unexpected parameter k1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChatCacheForFiles.GetChatCacheForFilesMock.defaultExpectation.expectationOrigins.originK1, *mm_want_ptrs.k1, mm_got.k1, minimock.Diff(*mm_want_ptrs.k1, mm_got.k1))
			}

			if mm_want_ptrs.fa1 != nil && !minimock.Equal(*mm_want_ptrs.fa1, mm_got.fa1) {
				mmGetChatCacheForFiles.t.Errorf("ServiceMock.GetChatCacheForFiles got unexpected parameter fa1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChatCacheForFiles.GetChatCacheForFilesMock.defaultExpectation.expectationOrigins.originFa1, *mm_want_ptrs.fa1, mm_got.fa1, minimock.Diff(*mm_want_ptrs.fa1, mm_got.fa1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChatCacheForFiles.t.Errorf("ServiceMock.GetChatCacheForFiles got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetChatCacheForFiles.GetChatCacheForFilesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChatCacheForFiles.GetChatCacheForFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChatCacheForFiles.t.Fatal("No results are set for the ServiceMock.GetChatCacheForFiles")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetChatCacheForFiles.funcGetChatCacheForFiles != nil {
		return mmGetChatCacheForFiles.funcGetChatCacheForFiles(ctx, k1, fa1)
	}
	mmGetChatCacheForFiles.t.Fatalf("Unexpected call to ServiceMock.GetChatCacheForFiles. %v %v %v", ctx, k1, fa1)
	return
}

// GetChatCacheForFilesAfterCounter returns a count of finished ServiceMock.GetChatCacheForFiles invocations
func (mmGetChatCacheForFiles *ServiceMock) GetChatCacheForFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatCacheForFiles.afterGetChatCacheForFilesCounter)
}

// GetChatCacheForFilesBeforeCounter returns a count of ServiceMock.GetChatCacheForFiles invocations
func (mmGetChatCacheForFiles *ServiceMock) GetChatCacheForFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatCacheForFiles.beforeGetChatCacheForFilesCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetChatCacheForFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChatCacheForFiles *mServiceMockGetChatCacheForFiles) Calls() []*ServiceMockGetChatCacheForFilesParams {
	mmGetChatCacheForFiles.mutex.RLock()

	argCopy := make([]*ServiceMockGetChatCacheForFilesParams, len(mmGetChatCacheForFiles.callArgs))
	copy(argCopy, mmGetChatCacheForFiles.callArgs)

	mmGetChatCacheForFiles.mutex.RUnlock()

	return argCopy
}

// MinimockGetChatCacheForFilesDone returns true if the count of the GetChatCacheForFiles invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetChatCacheForFilesDone() bool {
	if m.GetChatCacheForFilesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetChatCacheForFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetChatCacheForFilesMock.invocationsDone()
}

// MinimockGetChatCacheForFilesInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetChatCacheForFilesInspect() {
	for _, e := range m.GetChatCacheForFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetChatCacheForFiles at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetChatCacheForFilesCounter := mm_atomic.LoadUint64(&m.afterGetChatCacheForFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatCacheForFilesMock.defaultExpectation != nil && afterGetChatCacheForFilesCounter < 1 {
		if m.GetChatCacheForFilesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetChatCacheForFiles at\n%s", m.GetChatCacheForFilesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetChatCacheForFiles at\n%s with params: %#v", m.GetChatCacheForFilesMock.defaultExpectation.expectationOrigins.origin, *m.GetChatCacheForFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChatCacheForFiles != nil && afterGetChatCacheForFilesCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetChatCacheForFiles at\n%s", m.funcGetChatCacheForFilesOrigin)
	}

	if !m.GetChatCacheForFilesMock.invocationsDone() && afterGetChatCacheForFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetChatCacheForFiles at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetChatCacheForFilesMock.expectedInvocations), m.GetChatCacheForFilesMock.expectedInvocationsOrigin, afterGetChatCacheForFilesCounter)
	}
}

type mServiceMockGetChunksByFile struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetChunksByFileExpectation
	expectations       []*ServiceMockGetChunksByFileExpectation

	callArgs []*ServiceMockGetChunksByFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetChunksByFileExpectation specifies expectation struct of the Service.GetChunksByFile
type ServiceMockGetChunksByFileExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetChunksByFileParams
	paramPtrs          *ServiceMockGetChunksByFileParamPtrs
	expectationOrigins ServiceMockGetChunksByFileExpectationOrigins
	results            *ServiceMockGetChunksByFileResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetChunksByFileParams contains parameters of the Service.GetChunksByFile
type ServiceMockGetChunksByFileParams struct {
	ctx context.Context
	kp1 *repository.KnowledgeBaseFileModel
}

// ServiceMockGetChunksByFileParamPtrs contains pointers to parameters of the Service.GetChunksByFile
type ServiceMockGetChunksByFileParamPtrs struct {
	ctx *context.Context
	kp1 **repository.KnowledgeBaseFileModel
}

// ServiceMockGetChunksByFileResults contains results of the Service.GetChunksByFile
type ServiceMockGetChunksByFileResults struct {
	s1  types.SourceTableType
	s2  types.SourceUIDType
	ta1 []repository.TextChunkModel
	m1  map[types.TextChunkUIDType]types.ContentType
	sa1 []string
	err error
}

// ServiceMockGetChunksByFileOrigins contains origins of expectations of the Service.GetChunksByFile
type ServiceMockGetChunksByFileExpectationOrigins struct {
	origin    string
	originCtx string
	originKp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetChunksByFile *mServiceMockGetChunksByFile) Optional() *mServiceMockGetChunksByFile {
	mmGetChunksByFile.optional = true
	return mmGetChunksByFile
}

// Expect sets up expected params for Service.GetChunksByFile
func (mmGetChunksByFile *mServiceMockGetChunksByFile) Expect(ctx context.Context, kp1 *repository.KnowledgeBaseFileModel) *mServiceMockGetChunksByFile {
	if mmGetChunksByFile.mock.funcGetChunksByFile != nil {
		mmGetChunksByFile.mock.t.Fatalf("ServiceMock.GetChunksByFile mock is already set by Set")
	}

	if mmGetChunksByFile.defaultExpectation == nil {
		mmGetChunksByFile.defaultExpectation = &ServiceMockGetChunksByFileExpectation{}
	}

	if mmGetChunksByFile.defaultExpectation.paramPtrs != nil {
		mmGetChunksByFile.mock.t.Fatalf("ServiceMock.GetChunksByFile mock is already set by ExpectParams functions")
	}

	mmGetChunksByFile.defaultExpectation.params = &ServiceMockGetChunksByFileParams{ctx, kp1}
	mmGetChunksByFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetChunksByFile.expectations {
		if minimock.Equal(e.params, mmGetChunksByFile.defaultExpectation.params) {
			mmGetChunksByFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChunksByFile.defaultExpectation.params)
		}
	}

	return mmGetChunksByFile
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetChunksByFile
func (mmGetChunksByFile *mServiceMockGetChunksByFile) ExpectCtxParam1(ctx context.Context) *mServiceMockGetChunksByFile {
	if mmGetChunksByFile.mock.funcGetChunksByFile != nil {
		mmGetChunksByFile.mock.t.Fatalf("ServiceMock.GetChunksByFile mock is already set by Set")
	}

	if mmGetChunksByFile.defaultExpectation == nil {
		mmGetChunksByFile.defaultExpectation = &ServiceMockGetChunksByFileExpectation{}
	}

	if mmGetChunksByFile.defaultExpectation.params != nil {
		mmGetChunksByFile.mock.t.Fatalf("ServiceMock.GetChunksByFile mock is already set by Expect")
	}

	if mmGetChunksByFile.defaultExpectation.paramPtrs == nil {
		mmGetChunksByFile.defaultExpectation.paramPtrs = &ServiceMockGetChunksByFileParamPtrs{}
	}
	mmGetChunksByFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetChunksByFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetChunksByFile
}

// ExpectKp1Param2 sets up expected param kp1 for Service.GetChunksByFile
func (mmGetChunksByFile *mServiceMockGetChunksByFile) ExpectKp1Param2(kp1 *repository.KnowledgeBaseFileModel) *mServiceMockGetChunksByFile {
	if mmGetChunksByFile.mock.funcGetChunksByFile != nil {
		mmGetChunksByFile.mock.t.Fatalf("ServiceMock.GetChunksByFile mock is already set by Set")
	}

	if mmGetChunksByFile.defaultExpectation == nil {
		mmGetChunksByFile.defaultExpectation = &ServiceMockGetChunksByFileExpectation{}
	}

	if mmGetChunksByFile.defaultExpectation.params != nil {
		mmGetChunksByFile.mock.t.Fatalf("ServiceMock.GetChunksByFile mock is already set by Expect")
	}

	if mmGetChunksByFile.defaultExpectation.paramPtrs == nil {
		mmGetChunksByFile.defaultExpectation.paramPtrs = &ServiceMockGetChunksByFileParamPtrs{}
	}
	mmGetChunksByFile.defaultExpectation.paramPtrs.kp1 = &kp1
	mmGetChunksByFile.defaultExpectation.expectationOrigins.originKp1 = minimock.CallerInfo(1)

	return mmGetChunksByFile
}

// Inspect accepts an inspector function that has same arguments as the Service.GetChunksByFile
func (mmGetChunksByFile *mServiceMockGetChunksByFile) Inspect(f func(ctx context.Context, kp1 *repository.KnowledgeBaseFileModel)) *mServiceMockGetChunksByFile {
	if mmGetChunksByFile.mock.inspectFuncGetChunksByFile != nil {
		mmGetChunksByFile.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetChunksByFile")
	}

	mmGetChunksByFile.mock.inspectFuncGetChunksByFile = f

	return mmGetChunksByFile
}

// Return sets up results that will be returned by Service.GetChunksByFile
func (mmGetChunksByFile *mServiceMockGetChunksByFile) Return(s1 types.SourceTableType, s2 types.SourceUIDType, ta1 []repository.TextChunkModel, m1 map[types.TextChunkUIDType]types.ContentType, sa1 []string, err error) *ServiceMock {
	if mmGetChunksByFile.mock.funcGetChunksByFile != nil {
		mmGetChunksByFile.mock.t.Fatalf("ServiceMock.GetChunksByFile mock is already set by Set")
	}

	if mmGetChunksByFile.defaultExpectation == nil {
		mmGetChunksByFile.defaultExpectation = &ServiceMockGetChunksByFileExpectation{mock: mmGetChunksByFile.mock}
	}
	mmGetChunksByFile.defaultExpectation.results = &ServiceMockGetChunksByFileResults{s1, s2, ta1, m1, sa1, err}
	mmGetChunksByFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetChunksByFile.mock
}

// Set uses given function f to mock the Service.GetChunksByFile method
func (mmGetChunksByFile *mServiceMockGetChunksByFile) Set(f func(ctx context.Context, kp1 *repository.KnowledgeBaseFileModel) (s1 types.SourceTableType, s2 types.SourceUIDType, ta1 []repository.TextChunkModel, m1 map[types.TextChunkUIDType]types.ContentType, sa1 []string, err error)) *ServiceMock {
	if mmGetChunksByFile.defaultExpectation != nil {
		mmGetChunksByFile.mock.t.Fatalf("Default expectation is already set for the Service.GetChunksByFile method")
	}

	if len(mmGetChunksByFile.expectations) > 0 {
		mmGetChunksByFile.mock.t.Fatalf("Some expectations are already set for the Service.GetChunksByFile method")
	}

	mmGetChunksByFile.mock.funcGetChunksByFile = f
	mmGetChunksByFile.mock.funcGetChunksByFileOrigin = minimock.CallerInfo(1)
	return mmGetChunksByFile.mock
}

// When sets expectation for the Service.GetChunksByFile which will trigger the result defined by the following
// Then helper
func (mmGetChunksByFile *mServiceMockGetChunksByFile) When(ctx context.Context, kp1 *repository.KnowledgeBaseFileModel) *ServiceMockGetChunksByFileExpectation {
	if mmGetChunksByFile.mock.funcGetChunksByFile != nil {
		mmGetChunksByFile.mock.t.Fatalf("ServiceMock.GetChunksByFile mock is already set by Set")
	}

	expectation := &ServiceMockGetChunksByFileExpectation{
		mock:               mmGetChunksByFile.mock,
		params:             &ServiceMockGetChunksByFileParams{ctx, kp1},
		expectationOrigins: ServiceMockGetChunksByFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetChunksByFile.expectations = append(mmGetChunksByFile.expectations, expectation)
	return expectation
}

// Then sets up Service.GetChunksByFile return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetChunksByFileExpectation) Then(s1 types.SourceTableType, s2 types.SourceUIDType, ta1 []repository.TextChunkModel, m1 map[types.TextChunkUIDType]types.ContentType, sa1 []string, err error) *ServiceMock {
	e.results = &ServiceMockGetChunksByFileResults{s1, s2, ta1, m1, sa1, err}
	return e.mock
}

// Times sets number of times Service.GetChunksByFile should be invoked
func (mmGetChunksByFile *mServiceMockGetChunksByFile) Times(n uint64) *mServiceMockGetChunksByFile {
	if n == 0 {
		mmGetChunksByFile.mock.t.Fatalf("Times of ServiceMock.GetChunksByFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetChunksByFile.expectedInvocations, n)
	mmGetChunksByFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetChunksByFile
}

func (mmGetChunksByFile *mServiceMockGetChunksByFile) invocationsDone() bool {
	if len(mmGetChunksByFile.expectations) == 0 && mmGetChunksByFile.defaultExpectation == nil && mmGetChunksByFile.mock.funcGetChunksByFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetChunksByFile.mock.afterGetChunksByFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetChunksByFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetChunksByFile implements mm_service.Service
func (mmGetChunksByFile *ServiceMock) GetChunksByFile(ctx context.Context, kp1 *repository.KnowledgeBaseFileModel) (s1 types.SourceTableType, s2 types.SourceUIDType, ta1 []repository.TextChunkModel, m1 map[types.TextChunkUIDType]types.ContentType, sa1 []string, err error) {
	mm_atomic.AddUint64(&mmGetChunksByFile.beforeGetChunksByFileCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChunksByFile.afterGetChunksByFileCounter, 1)

	mmGetChunksByFile.t.Helper()

	if mmGetChunksByFile.inspectFuncGetChunksByFile != nil {
		mmGetChunksByFile.inspectFuncGetChunksByFile(ctx, kp1)
	}

	mm_params := ServiceMockGetChunksByFileParams{ctx, kp1}

	// Record call args
	mmGetChunksByFile.GetChunksByFileMock.mutex.Lock()
	mmGetChunksByFile.GetChunksByFileMock.callArgs = append(mmGetChunksByFile.GetChunksByFileMock.callArgs, &mm_params)
	mmGetChunksByFile.GetChunksByFileMock.mutex.Unlock()

	for _, e := range mmGetChunksByFile.GetChunksByFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.s2, e.results.ta1, e.results.m1, e.results.sa1, e.results.err
		}
	}

	if mmGetChunksByFile.GetChunksByFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChunksByFile.GetChunksByFileMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChunksByFile.GetChunksByFileMock.defaultExpectation.params
		mm_want_ptrs := mmGetChunksByFile.GetChunksByFileMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetChunksByFileParams{ctx, kp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetChunksByFile.t.Errorf("ServiceMock.GetChunksByFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChunksByFile.GetChunksByFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kp1 != nil && !minimock.Equal(*mm_want_ptrs.kp1, mm_got.kp1) {
				mmGetChunksByFile.t.Errorf("ServiceMock.GetChunksByFile got unexpected parameter kp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChunksByFile.GetChunksByFileMock.defaultExpectation.expectationOrigins.originKp1, *mm_want_ptrs.kp1, mm_got.kp1, minimock.Diff(*mm_want_ptrs.kp1, mm_got.kp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChunksByFile.t.Errorf("ServiceMock.GetChunksByFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetChunksByFile.GetChunksByFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChunksByFile.GetChunksByFileMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChunksByFile.t.Fatal("No results are set for the ServiceMock.GetChunksByFile")
		}
		return (*mm_results).s1, (*mm_results).s2, (*mm_results).ta1, (*mm_results).m1, (*mm_results).sa1, (*mm_results).err
	}
	if mmGetChunksByFile.funcGetChunksByFile != nil {
		return mmGetChunksByFile.funcGetChunksByFile(ctx, kp1)
	}
	mmGetChunksByFile.t.Fatalf("Unexpected call to ServiceMock.GetChunksByFile. %v %v", ctx, kp1)
	return
}

// GetChunksByFileAfterCounter returns a count of finished ServiceMock.GetChunksByFile invocations
func (mmGetChunksByFile *ServiceMock) GetChunksByFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChunksByFile.afterGetChunksByFileCounter)
}

// GetChunksByFileBeforeCounter returns a count of ServiceMock.GetChunksByFile invocations
func (mmGetChunksByFile *ServiceMock) GetChunksByFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChunksByFile.beforeGetChunksByFileCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetChunksByFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChunksByFile *mServiceMockGetChunksByFile) Calls() []*ServiceMockGetChunksByFileParams {
	mmGetChunksByFile.mutex.RLock()

	argCopy := make([]*ServiceMockGetChunksByFileParams, len(mmGetChunksByFile.callArgs))
	copy(argCopy, mmGetChunksByFile.callArgs)

	mmGetChunksByFile.mutex.RUnlock()

	return argCopy
}

// MinimockGetChunksByFileDone returns true if the count of the GetChunksByFile invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetChunksByFileDone() bool {
	if m.GetChunksByFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetChunksByFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetChunksByFileMock.invocationsDone()
}

// MinimockGetChunksByFileInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetChunksByFileInspect() {
	for _, e := range m.GetChunksByFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetChunksByFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetChunksByFileCounter := mm_atomic.LoadUint64(&m.afterGetChunksByFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetChunksByFileMock.defaultExpectation != nil && afterGetChunksByFileCounter < 1 {
		if m.GetChunksByFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetChunksByFile at\n%s", m.GetChunksByFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetChunksByFile at\n%s with params: %#v", m.GetChunksByFileMock.defaultExpectation.expectationOrigins.origin, *m.GetChunksByFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChunksByFile != nil && afterGetChunksByFileCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetChunksByFile at\n%s", m.funcGetChunksByFileOrigin)
	}

	if !m.GetChunksByFileMock.invocationsDone() && afterGetChunksByFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetChunksByFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetChunksByFileMock.expectedInvocations), m.GetChunksByFileMock.expectedInvocationsOrigin, afterGetChunksByFileCounter)
	}
}

type mServiceMockGetConvertedFilePathsByFileUID struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetConvertedFilePathsByFileUIDExpectation
	expectations       []*ServiceMockGetConvertedFilePathsByFileUIDExpectation

	callArgs []*ServiceMockGetConvertedFilePathsByFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetConvertedFilePathsByFileUIDExpectation specifies expectation struct of the Service.GetConvertedFilePathsByFileUID
type ServiceMockGetConvertedFilePathsByFileUIDExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetConvertedFilePathsByFileUIDParams
	paramPtrs          *ServiceMockGetConvertedFilePathsByFileUIDParamPtrs
	expectationOrigins ServiceMockGetConvertedFilePathsByFileUIDExpectationOrigins
	results            *ServiceMockGetConvertedFilePathsByFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetConvertedFilePathsByFileUIDParams contains parameters of the Service.GetConvertedFilePathsByFileUID
type ServiceMockGetConvertedFilePathsByFileUIDParams struct {
	ctx context.Context
	k1  types.KBUIDType
	f1  types.FileUIDType
}

// ServiceMockGetConvertedFilePathsByFileUIDParamPtrs contains pointers to parameters of the Service.GetConvertedFilePathsByFileUID
type ServiceMockGetConvertedFilePathsByFileUIDParamPtrs struct {
	ctx *context.Context
	k1  *types.KBUIDType
	f1  *types.FileUIDType
}

// ServiceMockGetConvertedFilePathsByFileUIDResults contains results of the Service.GetConvertedFilePathsByFileUID
type ServiceMockGetConvertedFilePathsByFileUIDResults struct {
	sa1 []string
	err error
}

// ServiceMockGetConvertedFilePathsByFileUIDOrigins contains origins of expectations of the Service.GetConvertedFilePathsByFileUID
type ServiceMockGetConvertedFilePathsByFileUIDExpectationOrigins struct {
	origin    string
	originCtx string
	originK1  string
	originF1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetConvertedFilePathsByFileUID *mServiceMockGetConvertedFilePathsByFileUID) Optional() *mServiceMockGetConvertedFilePathsByFileUID {
	mmGetConvertedFilePathsByFileUID.optional = true
	return mmGetConvertedFilePathsByFileUID
}

// Expect sets up expected params for Service.GetConvertedFilePathsByFileUID
func (mmGetConvertedFilePathsByFileUID *mServiceMockGetConvertedFilePathsByFileUID) Expect(ctx context.Context, k1 types.KBUIDType, f1 types.FileUIDType) *mServiceMockGetConvertedFilePathsByFileUID {
	if mmGetConvertedFilePathsByFileUID.mock.funcGetConvertedFilePathsByFileUID != nil {
		mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetConvertedFilePathsByFileUID mock is already set by Set")
	}

	if mmGetConvertedFilePathsByFileUID.defaultExpectation == nil {
		mmGetConvertedFilePathsByFileUID.defaultExpectation = &ServiceMockGetConvertedFilePathsByFileUIDExpectation{}
	}

	if mmGetConvertedFilePathsByFileUID.defaultExpectation.paramPtrs != nil {
		mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetConvertedFilePathsByFileUID mock is already set by ExpectParams functions")
	}

	mmGetConvertedFilePathsByFileUID.defaultExpectation.params = &ServiceMockGetConvertedFilePathsByFileUIDParams{ctx, k1, f1}
	mmGetConvertedFilePathsByFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetConvertedFilePathsByFileUID.expectations {
		if minimock.Equal(e.params, mmGetConvertedFilePathsByFileUID.defaultExpectation.params) {
			mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetConvertedFilePathsByFileUID.defaultExpectation.params)
		}
	}

	return mmGetConvertedFilePathsByFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetConvertedFilePathsByFileUID
func (mmGetConvertedFilePathsByFileUID *mServiceMockGetConvertedFilePathsByFileUID) ExpectCtxParam1(ctx context.Context) *mServiceMockGetConvertedFilePathsByFileUID {
	if mmGetConvertedFilePathsByFileUID.mock.funcGetConvertedFilePathsByFileUID != nil {
		mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetConvertedFilePathsByFileUID mock is already set by Set")
	}

	if mmGetConvertedFilePathsByFileUID.defaultExpectation == nil {
		mmGetConvertedFilePathsByFileUID.defaultExpectation = &ServiceMockGetConvertedFilePathsByFileUIDExpectation{}
	}

	if mmGetConvertedFilePathsByFileUID.defaultExpectation.params != nil {
		mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetConvertedFilePathsByFileUID mock is already set by Expect")
	}

	if mmGetConvertedFilePathsByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetConvertedFilePathsByFileUID.defaultExpectation.paramPtrs = &ServiceMockGetConvertedFilePathsByFileUIDParamPtrs{}
	}
	mmGetConvertedFilePathsByFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetConvertedFilePathsByFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetConvertedFilePathsByFileUID
}

// ExpectK1Param2 sets up expected param k1 for Service.GetConvertedFilePathsByFileUID
func (mmGetConvertedFilePathsByFileUID *mServiceMockGetConvertedFilePathsByFileUID) ExpectK1Param2(k1 types.KBUIDType) *mServiceMockGetConvertedFilePathsByFileUID {
	if mmGetConvertedFilePathsByFileUID.mock.funcGetConvertedFilePathsByFileUID != nil {
		mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetConvertedFilePathsByFileUID mock is already set by Set")
	}

	if mmGetConvertedFilePathsByFileUID.defaultExpectation == nil {
		mmGetConvertedFilePathsByFileUID.defaultExpectation = &ServiceMockGetConvertedFilePathsByFileUIDExpectation{}
	}

	if mmGetConvertedFilePathsByFileUID.defaultExpectation.params != nil {
		mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetConvertedFilePathsByFileUID mock is already set by Expect")
	}

	if mmGetConvertedFilePathsByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetConvertedFilePathsByFileUID.defaultExpectation.paramPtrs = &ServiceMockGetConvertedFilePathsByFileUIDParamPtrs{}
	}
	mmGetConvertedFilePathsByFileUID.defaultExpectation.paramPtrs.k1 = &k1
	mmGetConvertedFilePathsByFileUID.defaultExpectation.expectationOrigins.originK1 = minimock.CallerInfo(1)

	return mmGetConvertedFilePathsByFileUID
}

// ExpectF1Param3 sets up expected param f1 for Service.GetConvertedFilePathsByFileUID
func (mmGetConvertedFilePathsByFileUID *mServiceMockGetConvertedFilePathsByFileUID) ExpectF1Param3(f1 types.FileUIDType) *mServiceMockGetConvertedFilePathsByFileUID {
	if mmGetConvertedFilePathsByFileUID.mock.funcGetConvertedFilePathsByFileUID != nil {
		mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetConvertedFilePathsByFileUID mock is already set by Set")
	}

	if mmGetConvertedFilePathsByFileUID.defaultExpectation == nil {
		mmGetConvertedFilePathsByFileUID.defaultExpectation = &ServiceMockGetConvertedFilePathsByFileUIDExpectation{}
	}

	if mmGetConvertedFilePathsByFileUID.defaultExpectation.params != nil {
		mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetConvertedFilePathsByFileUID mock is already set by Expect")
	}

	if mmGetConvertedFilePathsByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetConvertedFilePathsByFileUID.defaultExpectation.paramPtrs = &ServiceMockGetConvertedFilePathsByFileUIDParamPtrs{}
	}
	mmGetConvertedFilePathsByFileUID.defaultExpectation.paramPtrs.f1 = &f1
	mmGetConvertedFilePathsByFileUID.defaultExpectation.expectationOrigins.originF1 = minimock.CallerInfo(1)

	return mmGetConvertedFilePathsByFileUID
}

// Inspect accepts an inspector function that has same arguments as the Service.GetConvertedFilePathsByFileUID
func (mmGetConvertedFilePathsByFileUID *mServiceMockGetConvertedFilePathsByFileUID) Inspect(f func(ctx context.Context, k1 types.KBUIDType, f1 types.FileUIDType)) *mServiceMockGetConvertedFilePathsByFileUID {
	if mmGetConvertedFilePathsByFileUID.mock.inspectFuncGetConvertedFilePathsByFileUID != nil {
		mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetConvertedFilePathsByFileUID")
	}

	mmGetConvertedFilePathsByFileUID.mock.inspectFuncGetConvertedFilePathsByFileUID = f

	return mmGetConvertedFilePathsByFileUID
}

// Return sets up results that will be returned by Service.GetConvertedFilePathsByFileUID
func (mmGetConvertedFilePathsByFileUID *mServiceMockGetConvertedFilePathsByFileUID) Return(sa1 []string, err error) *ServiceMock {
	if mmGetConvertedFilePathsByFileUID.mock.funcGetConvertedFilePathsByFileUID != nil {
		mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetConvertedFilePathsByFileUID mock is already set by Set")
	}

	if mmGetConvertedFilePathsByFileUID.defaultExpectation == nil {
		mmGetConvertedFilePathsByFileUID.defaultExpectation = &ServiceMockGetConvertedFilePathsByFileUIDExpectation{mock: mmGetConvertedFilePathsByFileUID.mock}
	}
	mmGetConvertedFilePathsByFileUID.defaultExpectation.results = &ServiceMockGetConvertedFilePathsByFileUIDResults{sa1, err}
	mmGetConvertedFilePathsByFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetConvertedFilePathsByFileUID.mock
}

// Set uses given function f to mock the Service.GetConvertedFilePathsByFileUID method
func (mmGetConvertedFilePathsByFileUID *mServiceMockGetConvertedFilePathsByFileUID) Set(f func(ctx context.Context, k1 types.KBUIDType, f1 types.FileUIDType) (sa1 []string, err error)) *ServiceMock {
	if mmGetConvertedFilePathsByFileUID.defaultExpectation != nil {
		mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("Default expectation is already set for the Service.GetConvertedFilePathsByFileUID method")
	}

	if len(mmGetConvertedFilePathsByFileUID.expectations) > 0 {
		mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("Some expectations are already set for the Service.GetConvertedFilePathsByFileUID method")
	}

	mmGetConvertedFilePathsByFileUID.mock.funcGetConvertedFilePathsByFileUID = f
	mmGetConvertedFilePathsByFileUID.mock.funcGetConvertedFilePathsByFileUIDOrigin = minimock.CallerInfo(1)
	return mmGetConvertedFilePathsByFileUID.mock
}

// When sets expectation for the Service.GetConvertedFilePathsByFileUID which will trigger the result defined by the following
// Then helper
func (mmGetConvertedFilePathsByFileUID *mServiceMockGetConvertedFilePathsByFileUID) When(ctx context.Context, k1 types.KBUIDType, f1 types.FileUIDType) *ServiceMockGetConvertedFilePathsByFileUIDExpectation {
	if mmGetConvertedFilePathsByFileUID.mock.funcGetConvertedFilePathsByFileUID != nil {
		mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetConvertedFilePathsByFileUID mock is already set by Set")
	}

	expectation := &ServiceMockGetConvertedFilePathsByFileUIDExpectation{
		mock:               mmGetConvertedFilePathsByFileUID.mock,
		params:             &ServiceMockGetConvertedFilePathsByFileUIDParams{ctx, k1, f1},
		expectationOrigins: ServiceMockGetConvertedFilePathsByFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetConvertedFilePathsByFileUID.expectations = append(mmGetConvertedFilePathsByFileUID.expectations, expectation)
	return expectation
}

// Then sets up Service.GetConvertedFilePathsByFileUID return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetConvertedFilePathsByFileUIDExpectation) Then(sa1 []string, err error) *ServiceMock {
	e.results = &ServiceMockGetConvertedFilePathsByFileUIDResults{sa1, err}
	return e.mock
}

// Times sets number of times Service.GetConvertedFilePathsByFileUID should be invoked
func (mmGetConvertedFilePathsByFileUID *mServiceMockGetConvertedFilePathsByFileUID) Times(n uint64) *mServiceMockGetConvertedFilePathsByFileUID {
	if n == 0 {
		mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("Times of ServiceMock.GetConvertedFilePathsByFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetConvertedFilePathsByFileUID.expectedInvocations, n)
	mmGetConvertedFilePathsByFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetConvertedFilePathsByFileUID
}

func (mmGetConvertedFilePathsByFileUID *mServiceMockGetConvertedFilePathsByFileUID) invocationsDone() bool {
	if len(mmGetConvertedFilePathsByFileUID.expectations) == 0 && mmGetConvertedFilePathsByFileUID.defaultExpectation == nil && mmGetConvertedFilePathsByFileUID.mock.funcGetConvertedFilePathsByFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetConvertedFilePathsByFileUID.mock.afterGetConvertedFilePathsByFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetConvertedFilePathsByFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetConvertedFilePathsByFileUID implements mm_service.Service
func (mmGetConvertedFilePathsByFileUID *ServiceMock) GetConvertedFilePathsByFileUID(ctx context.Context, k1 types.KBUIDType, f1 types.FileUIDType) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmGetConvertedFilePathsByFileUID.beforeGetConvertedFilePathsByFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetConvertedFilePathsByFileUID.afterGetConvertedFilePathsByFileUIDCounter, 1)

	mmGetConvertedFilePathsByFileUID.t.Helper()

	if mmGetConvertedFilePathsByFileUID.inspectFuncGetConvertedFilePathsByFileUID != nil {
		mmGetConvertedFilePathsByFileUID.inspectFuncGetConvertedFilePathsByFileUID(ctx, k1, f1)
	}

	mm_params := ServiceMockGetConvertedFilePathsByFileUIDParams{ctx, k1, f1}

	// Record call args
	mmGetConvertedFilePathsByFileUID.GetConvertedFilePathsByFileUIDMock.mutex.Lock()
	mmGetConvertedFilePathsByFileUID.GetConvertedFilePathsByFileUIDMock.callArgs = append(mmGetConvertedFilePathsByFileUID.GetConvertedFilePathsByFileUIDMock.callArgs, &mm_params)
	mmGetConvertedFilePathsByFileUID.GetConvertedFilePathsByFileUIDMock.mutex.Unlock()

	for _, e := range mmGetConvertedFilePathsByFileUID.GetConvertedFilePathsByFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmGetConvertedFilePathsByFileUID.GetConvertedFilePathsByFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetConvertedFilePathsByFileUID.GetConvertedFilePathsByFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetConvertedFilePathsByFileUID.GetConvertedFilePathsByFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetConvertedFilePathsByFileUID.GetConvertedFilePathsByFileUIDMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetConvertedFilePathsByFileUIDParams{ctx, k1, f1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetConvertedFilePathsByFileUID.t.Errorf("ServiceMock.GetConvertedFilePathsByFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetConvertedFilePathsByFileUID.GetConvertedFilePathsByFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.k1 != nil && !minimock.Equal(*mm_want_ptrs.k1, mm_got.k1) {
				mmGetConvertedFilePathsByFileUID.t.Errorf("ServiceMock.GetConvertedFilePathsByFileUID got unexpected parameter k1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetConvertedFilePathsByFileUID.GetConvertedFilePathsByFileUIDMock.defaultExpectation.expectationOrigins.originK1, *mm_want_ptrs.k1, mm_got.k1, minimock.Diff(*mm_want_ptrs.k1, mm_got.k1))
			}

			if mm_want_ptrs.f1 != nil && !minimock.Equal(*mm_want_ptrs.f1, mm_got.f1) {
				mmGetConvertedFilePathsByFileUID.t.Errorf("ServiceMock.GetConvertedFilePathsByFileUID got unexpected parameter f1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetConvertedFilePathsByFileUID.GetConvertedFilePathsByFileUIDMock.defaultExpectation.expectationOrigins.originF1, *mm_want_ptrs.f1, mm_got.f1, minimock.Diff(*mm_want_ptrs.f1, mm_got.f1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetConvertedFilePathsByFileUID.t.Errorf("ServiceMock.GetConvertedFilePathsByFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetConvertedFilePathsByFileUID.GetConvertedFilePathsByFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetConvertedFilePathsByFileUID.GetConvertedFilePathsByFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetConvertedFilePathsByFileUID.t.Fatal("No results are set for the ServiceMock.GetConvertedFilePathsByFileUID")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmGetConvertedFilePathsByFileUID.funcGetConvertedFilePathsByFileUID != nil {
		return mmGetConvertedFilePathsByFileUID.funcGetConvertedFilePathsByFileUID(ctx, k1, f1)
	}
	mmGetConvertedFilePathsByFileUID.t.Fatalf("Unexpected call to ServiceMock.GetConvertedFilePathsByFileUID. %v %v %v", ctx, k1, f1)
	return
}

// GetConvertedFilePathsByFileUIDAfterCounter returns a count of finished ServiceMock.GetConvertedFilePathsByFileUID invocations
func (mmGetConvertedFilePathsByFileUID *ServiceMock) GetConvertedFilePathsByFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConvertedFilePathsByFileUID.afterGetConvertedFilePathsByFileUIDCounter)
}

// GetConvertedFilePathsByFileUIDBeforeCounter returns a count of ServiceMock.GetConvertedFilePathsByFileUID invocations
func (mmGetConvertedFilePathsByFileUID *ServiceMock) GetConvertedFilePathsByFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConvertedFilePathsByFileUID.beforeGetConvertedFilePathsByFileUIDCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetConvertedFilePathsByFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetConvertedFilePathsByFileUID *mServiceMockGetConvertedFilePathsByFileUID) Calls() []*ServiceMockGetConvertedFilePathsByFileUIDParams {
	mmGetConvertedFilePathsByFileUID.mutex.RLock()

	argCopy := make([]*ServiceMockGetConvertedFilePathsByFileUIDParams, len(mmGetConvertedFilePathsByFileUID.callArgs))
	copy(argCopy, mmGetConvertedFilePathsByFileUID.callArgs)

	mmGetConvertedFilePathsByFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetConvertedFilePathsByFileUIDDone returns true if the count of the GetConvertedFilePathsByFileUID invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetConvertedFilePathsByFileUIDDone() bool {
	if m.GetConvertedFilePathsByFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetConvertedFilePathsByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetConvertedFilePathsByFileUIDMock.invocationsDone()
}

// MinimockGetConvertedFilePathsByFileUIDInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetConvertedFilePathsByFileUIDInspect() {
	for _, e := range m.GetConvertedFilePathsByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetConvertedFilePathsByFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetConvertedFilePathsByFileUIDCounter := mm_atomic.LoadUint64(&m.afterGetConvertedFilePathsByFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetConvertedFilePathsByFileUIDMock.defaultExpectation != nil && afterGetConvertedFilePathsByFileUIDCounter < 1 {
		if m.GetConvertedFilePathsByFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetConvertedFilePathsByFileUID at\n%s", m.GetConvertedFilePathsByFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetConvertedFilePathsByFileUID at\n%s with params: %#v", m.GetConvertedFilePathsByFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetConvertedFilePathsByFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetConvertedFilePathsByFileUID != nil && afterGetConvertedFilePathsByFileUIDCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetConvertedFilePathsByFileUID at\n%s", m.funcGetConvertedFilePathsByFileUIDOrigin)
	}

	if !m.GetConvertedFilePathsByFileUIDMock.invocationsDone() && afterGetConvertedFilePathsByFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetConvertedFilePathsByFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetConvertedFilePathsByFileUIDMock.expectedInvocations), m.GetConvertedFilePathsByFileUIDMock.expectedInvocationsOrigin, afterGetConvertedFilePathsByFileUIDCounter)
	}
}

type mServiceMockGetDownloadURL struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetDownloadURLExpectation
	expectations       []*ServiceMockGetDownloadURLExpectation

	callArgs []*ServiceMockGetDownloadURLParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetDownloadURLExpectation specifies expectation struct of the Service.GetDownloadURL
type ServiceMockGetDownloadURLExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetDownloadURLParams
	paramPtrs          *ServiceMockGetDownloadURLParamPtrs
	expectationOrigins ServiceMockGetDownloadURLExpectationOrigins
	results            *ServiceMockGetDownloadURLResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetDownloadURLParams contains parameters of the Service.GetDownloadURL
type ServiceMockGetDownloadURLParams struct {
	ctx context.Context
	gp1 *artifactpb.GetObjectDownloadURLRequest
	n1  types.NamespaceUIDType
	s1  string
}

// ServiceMockGetDownloadURLParamPtrs contains pointers to parameters of the Service.GetDownloadURL
type ServiceMockGetDownloadURLParamPtrs struct {
	ctx *context.Context
	gp1 **artifactpb.GetObjectDownloadURLRequest
	n1  *types.NamespaceUIDType
	s1  *string
}

// ServiceMockGetDownloadURLResults contains results of the Service.GetDownloadURL
type ServiceMockGetDownloadURLResults struct {
	gp2 *artifactpb.GetObjectDownloadURLResponse
	err error
}

// ServiceMockGetDownloadURLOrigins contains origins of expectations of the Service.GetDownloadURL
type ServiceMockGetDownloadURLExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
	originN1  string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetDownloadURL *mServiceMockGetDownloadURL) Optional() *mServiceMockGetDownloadURL {
	mmGetDownloadURL.optional = true
	return mmGetDownloadURL
}

// Expect sets up expected params for Service.GetDownloadURL
func (mmGetDownloadURL *mServiceMockGetDownloadURL) Expect(ctx context.Context, gp1 *artifactpb.GetObjectDownloadURLRequest, n1 types.NamespaceUIDType, s1 string) *mServiceMockGetDownloadURL {
	if mmGetDownloadURL.mock.funcGetDownloadURL != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Set")
	}

	if mmGetDownloadURL.defaultExpectation == nil {
		mmGetDownloadURL.defaultExpectation = &ServiceMockGetDownloadURLExpectation{}
	}

	if mmGetDownloadURL.defaultExpectation.paramPtrs != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by ExpectParams functions")
	}

	mmGetDownloadURL.defaultExpectation.params = &ServiceMockGetDownloadURLParams{ctx, gp1, n1, s1}
	mmGetDownloadURL.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetDownloadURL.expectations {
		if minimock.Equal(e.params, mmGetDownloadURL.defaultExpectation.params) {
			mmGetDownloadURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetDownloadURL.defaultExpectation.params)
		}
	}

	return mmGetDownloadURL
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetDownloadURL
func (mmGetDownloadURL *mServiceMockGetDownloadURL) ExpectCtxParam1(ctx context.Context) *mServiceMockGetDownloadURL {
	if mmGetDownloadURL.mock.funcGetDownloadURL != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Set")
	}

	if mmGetDownloadURL.defaultExpectation == nil {
		mmGetDownloadURL.defaultExpectation = &ServiceMockGetDownloadURLExpectation{}
	}

	if mmGetDownloadURL.defaultExpectation.params != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Expect")
	}

	if mmGetDownloadURL.defaultExpectation.paramPtrs == nil {
		mmGetDownloadURL.defaultExpectation.paramPtrs = &ServiceMockGetDownloadURLParamPtrs{}
	}
	mmGetDownloadURL.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetDownloadURL.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetDownloadURL
}

// ExpectGp1Param2 sets up expected param gp1 for Service.GetDownloadURL
func (mmGetDownloadURL *mServiceMockGetDownloadURL) ExpectGp1Param2(gp1 *artifactpb.GetObjectDownloadURLRequest) *mServiceMockGetDownloadURL {
	if mmGetDownloadURL.mock.funcGetDownloadURL != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Set")
	}

	if mmGetDownloadURL.defaultExpectation == nil {
		mmGetDownloadURL.defaultExpectation = &ServiceMockGetDownloadURLExpectation{}
	}

	if mmGetDownloadURL.defaultExpectation.params != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Expect")
	}

	if mmGetDownloadURL.defaultExpectation.paramPtrs == nil {
		mmGetDownloadURL.defaultExpectation.paramPtrs = &ServiceMockGetDownloadURLParamPtrs{}
	}
	mmGetDownloadURL.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetDownloadURL.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetDownloadURL
}

// ExpectN1Param3 sets up expected param n1 for Service.GetDownloadURL
func (mmGetDownloadURL *mServiceMockGetDownloadURL) ExpectN1Param3(n1 types.NamespaceUIDType) *mServiceMockGetDownloadURL {
	if mmGetDownloadURL.mock.funcGetDownloadURL != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Set")
	}

	if mmGetDownloadURL.defaultExpectation == nil {
		mmGetDownloadURL.defaultExpectation = &ServiceMockGetDownloadURLExpectation{}
	}

	if mmGetDownloadURL.defaultExpectation.params != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Expect")
	}

	if mmGetDownloadURL.defaultExpectation.paramPtrs == nil {
		mmGetDownloadURL.defaultExpectation.paramPtrs = &ServiceMockGetDownloadURLParamPtrs{}
	}
	mmGetDownloadURL.defaultExpectation.paramPtrs.n1 = &n1
	mmGetDownloadURL.defaultExpectation.expectationOrigins.originN1 = minimock.CallerInfo(1)

	return mmGetDownloadURL
}

// ExpectS1Param4 sets up expected param s1 for Service.GetDownloadURL
func (mmGetDownloadURL *mServiceMockGetDownloadURL) ExpectS1Param4(s1 string) *mServiceMockGetDownloadURL {
	if mmGetDownloadURL.mock.funcGetDownloadURL != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Set")
	}

	if mmGetDownloadURL.defaultExpectation == nil {
		mmGetDownloadURL.defaultExpectation = &ServiceMockGetDownloadURLExpectation{}
	}

	if mmGetDownloadURL.defaultExpectation.params != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Expect")
	}

	if mmGetDownloadURL.defaultExpectation.paramPtrs == nil {
		mmGetDownloadURL.defaultExpectation.paramPtrs = &ServiceMockGetDownloadURLParamPtrs{}
	}
	mmGetDownloadURL.defaultExpectation.paramPtrs.s1 = &s1
	mmGetDownloadURL.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmGetDownloadURL
}

// Inspect accepts an inspector function that has same arguments as the Service.GetDownloadURL
func (mmGetDownloadURL *mServiceMockGetDownloadURL) Inspect(f func(ctx context.Context, gp1 *artifactpb.GetObjectDownloadURLRequest, n1 types.NamespaceUIDType, s1 string)) *mServiceMockGetDownloadURL {
	if mmGetDownloadURL.mock.inspectFuncGetDownloadURL != nil {
		mmGetDownloadURL.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetDownloadURL")
	}

	mmGetDownloadURL.mock.inspectFuncGetDownloadURL = f

	return mmGetDownloadURL
}

// Return sets up results that will be returned by Service.GetDownloadURL
func (mmGetDownloadURL *mServiceMockGetDownloadURL) Return(gp2 *artifactpb.GetObjectDownloadURLResponse, err error) *ServiceMock {
	if mmGetDownloadURL.mock.funcGetDownloadURL != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Set")
	}

	if mmGetDownloadURL.defaultExpectation == nil {
		mmGetDownloadURL.defaultExpectation = &ServiceMockGetDownloadURLExpectation{mock: mmGetDownloadURL.mock}
	}
	mmGetDownloadURL.defaultExpectation.results = &ServiceMockGetDownloadURLResults{gp2, err}
	mmGetDownloadURL.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetDownloadURL.mock
}

// Set uses given function f to mock the Service.GetDownloadURL method
func (mmGetDownloadURL *mServiceMockGetDownloadURL) Set(f func(ctx context.Context, gp1 *artifactpb.GetObjectDownloadURLRequest, n1 types.NamespaceUIDType, s1 string) (gp2 *artifactpb.GetObjectDownloadURLResponse, err error)) *ServiceMock {
	if mmGetDownloadURL.defaultExpectation != nil {
		mmGetDownloadURL.mock.t.Fatalf("Default expectation is already set for the Service.GetDownloadURL method")
	}

	if len(mmGetDownloadURL.expectations) > 0 {
		mmGetDownloadURL.mock.t.Fatalf("Some expectations are already set for the Service.GetDownloadURL method")
	}

	mmGetDownloadURL.mock.funcGetDownloadURL = f
	mmGetDownloadURL.mock.funcGetDownloadURLOrigin = minimock.CallerInfo(1)
	return mmGetDownloadURL.mock
}

// When sets expectation for the Service.GetDownloadURL which will trigger the result defined by the following
// Then helper
func (mmGetDownloadURL *mServiceMockGetDownloadURL) When(ctx context.Context, gp1 *artifactpb.GetObjectDownloadURLRequest, n1 types.NamespaceUIDType, s1 string) *ServiceMockGetDownloadURLExpectation {
	if mmGetDownloadURL.mock.funcGetDownloadURL != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Set")
	}

	expectation := &ServiceMockGetDownloadURLExpectation{
		mock:               mmGetDownloadURL.mock,
		params:             &ServiceMockGetDownloadURLParams{ctx, gp1, n1, s1},
		expectationOrigins: ServiceMockGetDownloadURLExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetDownloadURL.expectations = append(mmGetDownloadURL.expectations, expectation)
	return expectation
}

// Then sets up Service.GetDownloadURL return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetDownloadURLExpectation) Then(gp2 *artifactpb.GetObjectDownloadURLResponse, err error) *ServiceMock {
	e.results = &ServiceMockGetDownloadURLResults{gp2, err}
	return e.mock
}

// Times sets number of times Service.GetDownloadURL should be invoked
func (mmGetDownloadURL *mServiceMockGetDownloadURL) Times(n uint64) *mServiceMockGetDownloadURL {
	if n == 0 {
		mmGetDownloadURL.mock.t.Fatalf("Times of ServiceMock.GetDownloadURL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetDownloadURL.expectedInvocations, n)
	mmGetDownloadURL.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetDownloadURL
}

func (mmGetDownloadURL *mServiceMockGetDownloadURL) invocationsDone() bool {
	if len(mmGetDownloadURL.expectations) == 0 && mmGetDownloadURL.defaultExpectation == nil && mmGetDownloadURL.mock.funcGetDownloadURL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetDownloadURL.mock.afterGetDownloadURLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetDownloadURL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetDownloadURL implements mm_service.Service
func (mmGetDownloadURL *ServiceMock) GetDownloadURL(ctx context.Context, gp1 *artifactpb.GetObjectDownloadURLRequest, n1 types.NamespaceUIDType, s1 string) (gp2 *artifactpb.GetObjectDownloadURLResponse, err error) {
	mm_atomic.AddUint64(&mmGetDownloadURL.beforeGetDownloadURLCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDownloadURL.afterGetDownloadURLCounter, 1)

	mmGetDownloadURL.t.Helper()

	if mmGetDownloadURL.inspectFuncGetDownloadURL != nil {
		mmGetDownloadURL.inspectFuncGetDownloadURL(ctx, gp1, n1, s1)
	}

	mm_params := ServiceMockGetDownloadURLParams{ctx, gp1, n1, s1}

	// Record call args
	mmGetDownloadURL.GetDownloadURLMock.mutex.Lock()
	mmGetDownloadURL.GetDownloadURLMock.callArgs = append(mmGetDownloadURL.GetDownloadURLMock.callArgs, &mm_params)
	mmGetDownloadURL.GetDownloadURLMock.mutex.Unlock()

	for _, e := range mmGetDownloadURL.GetDownloadURLMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetDownloadURL.GetDownloadURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDownloadURL.GetDownloadURLMock.defaultExpectation.Counter, 1)
		mm_want := mmGetDownloadURL.GetDownloadURLMock.defaultExpectation.params
		mm_want_ptrs := mmGetDownloadURL.GetDownloadURLMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetDownloadURLParams{ctx, gp1, n1, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetDownloadURL.t.Errorf("ServiceMock.GetDownloadURL got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetDownloadURL.GetDownloadURLMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetDownloadURL.t.Errorf("ServiceMock.GetDownloadURL got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetDownloadURL.GetDownloadURLMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

			if mm_want_ptrs.n1 != nil && !minimock.Equal(*mm_want_ptrs.n1, mm_got.n1) {
				mmGetDownloadURL.t.Errorf("ServiceMock.GetDownloadURL got unexpected parameter n1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetDownloadURL.GetDownloadURLMock.defaultExpectation.expectationOrigins.originN1, *mm_want_ptrs.n1, mm_got.n1, minimock.Diff(*mm_want_ptrs.n1, mm_got.n1))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmGetDownloadURL.t.Errorf("ServiceMock.GetDownloadURL got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetDownloadURL.GetDownloadURLMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetDownloadURL.t.Errorf("ServiceMock.GetDownloadURL got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetDownloadURL.GetDownloadURLMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetDownloadURL.GetDownloadURLMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDownloadURL.t.Fatal("No results are set for the ServiceMock.GetDownloadURL")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetDownloadURL.funcGetDownloadURL != nil {
		return mmGetDownloadURL.funcGetDownloadURL(ctx, gp1, n1, s1)
	}
	mmGetDownloadURL.t.Fatalf("Unexpected call to ServiceMock.GetDownloadURL. %v %v %v %v", ctx, gp1, n1, s1)
	return
}

// GetDownloadURLAfterCounter returns a count of finished ServiceMock.GetDownloadURL invocations
func (mmGetDownloadURL *ServiceMock) GetDownloadURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDownloadURL.afterGetDownloadURLCounter)
}

// GetDownloadURLBeforeCounter returns a count of ServiceMock.GetDownloadURL invocations
func (mmGetDownloadURL *ServiceMock) GetDownloadURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDownloadURL.beforeGetDownloadURLCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetDownloadURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetDownloadURL *mServiceMockGetDownloadURL) Calls() []*ServiceMockGetDownloadURLParams {
	mmGetDownloadURL.mutex.RLock()

	argCopy := make([]*ServiceMockGetDownloadURLParams, len(mmGetDownloadURL.callArgs))
	copy(argCopy, mmGetDownloadURL.callArgs)

	mmGetDownloadURL.mutex.RUnlock()

	return argCopy
}

// MinimockGetDownloadURLDone returns true if the count of the GetDownloadURL invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetDownloadURLDone() bool {
	if m.GetDownloadURLMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetDownloadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetDownloadURLMock.invocationsDone()
}

// MinimockGetDownloadURLInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetDownloadURLInspect() {
	for _, e := range m.GetDownloadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetDownloadURL at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetDownloadURLCounter := mm_atomic.LoadUint64(&m.afterGetDownloadURLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetDownloadURLMock.defaultExpectation != nil && afterGetDownloadURLCounter < 1 {
		if m.GetDownloadURLMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetDownloadURL at\n%s", m.GetDownloadURLMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetDownloadURL at\n%s with params: %#v", m.GetDownloadURLMock.defaultExpectation.expectationOrigins.origin, *m.GetDownloadURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDownloadURL != nil && afterGetDownloadURLCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetDownloadURL at\n%s", m.funcGetDownloadURLOrigin)
	}

	if !m.GetDownloadURLMock.invocationsDone() && afterGetDownloadURLCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetDownloadURL at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetDownloadURLMock.expectedInvocations), m.GetDownloadURLMock.expectedInvocationsOrigin, afterGetDownloadURLCounter)
	}
}

type mServiceMockGetFilesByPaths struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetFilesByPathsExpectation
	expectations       []*ServiceMockGetFilesByPathsExpectation

	callArgs []*ServiceMockGetFilesByPathsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetFilesByPathsExpectation specifies expectation struct of the Service.GetFilesByPaths
type ServiceMockGetFilesByPathsExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetFilesByPathsParams
	paramPtrs          *ServiceMockGetFilesByPathsParamPtrs
	expectationOrigins ServiceMockGetFilesByPathsExpectationOrigins
	results            *ServiceMockGetFilesByPathsResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetFilesByPathsParams contains parameters of the Service.GetFilesByPaths
type ServiceMockGetFilesByPathsParams struct {
	ctx context.Context
	s1  string
	sa1 []string
}

// ServiceMockGetFilesByPathsParamPtrs contains pointers to parameters of the Service.GetFilesByPaths
type ServiceMockGetFilesByPathsParamPtrs struct {
	ctx *context.Context
	s1  *string
	sa1 *[]string
}

// ServiceMockGetFilesByPathsResults contains results of the Service.GetFilesByPaths
type ServiceMockGetFilesByPathsResults struct {
	fa1 []mm_service.FileContent
	err error
}

// ServiceMockGetFilesByPathsOrigins contains origins of expectations of the Service.GetFilesByPaths
type ServiceMockGetFilesByPathsExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
	originSa1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) Optional() *mServiceMockGetFilesByPaths {
	mmGetFilesByPaths.optional = true
	return mmGetFilesByPaths
}

// Expect sets up expected params for Service.GetFilesByPaths
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) Expect(ctx context.Context, s1 string, sa1 []string) *mServiceMockGetFilesByPaths {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by Set")
	}

	if mmGetFilesByPaths.defaultExpectation == nil {
		mmGetFilesByPaths.defaultExpectation = &ServiceMockGetFilesByPathsExpectation{}
	}

	if mmGetFilesByPaths.defaultExpectation.paramPtrs != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by ExpectParams functions")
	}

	mmGetFilesByPaths.defaultExpectation.params = &ServiceMockGetFilesByPathsParams{ctx, s1, sa1}
	mmGetFilesByPaths.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetFilesByPaths.expectations {
		if minimock.Equal(e.params, mmGetFilesByPaths.defaultExpectation.params) {
			mmGetFilesByPaths.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFilesByPaths.defaultExpectation.params)
		}
	}

	return mmGetFilesByPaths
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetFilesByPaths
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) ExpectCtxParam1(ctx context.Context) *mServiceMockGetFilesByPaths {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by Set")
	}

	if mmGetFilesByPaths.defaultExpectation == nil {
		mmGetFilesByPaths.defaultExpectation = &ServiceMockGetFilesByPathsExpectation{}
	}

	if mmGetFilesByPaths.defaultExpectation.params != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by Expect")
	}

	if mmGetFilesByPaths.defaultExpectation.paramPtrs == nil {
		mmGetFilesByPaths.defaultExpectation.paramPtrs = &ServiceMockGetFilesByPathsParamPtrs{}
	}
	mmGetFilesByPaths.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetFilesByPaths.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetFilesByPaths
}

// ExpectS1Param2 sets up expected param s1 for Service.GetFilesByPaths
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) ExpectS1Param2(s1 string) *mServiceMockGetFilesByPaths {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by Set")
	}

	if mmGetFilesByPaths.defaultExpectation == nil {
		mmGetFilesByPaths.defaultExpectation = &ServiceMockGetFilesByPathsExpectation{}
	}

	if mmGetFilesByPaths.defaultExpectation.params != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by Expect")
	}

	if mmGetFilesByPaths.defaultExpectation.paramPtrs == nil {
		mmGetFilesByPaths.defaultExpectation.paramPtrs = &ServiceMockGetFilesByPathsParamPtrs{}
	}
	mmGetFilesByPaths.defaultExpectation.paramPtrs.s1 = &s1
	mmGetFilesByPaths.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmGetFilesByPaths
}

// ExpectSa1Param3 sets up expected param sa1 for Service.GetFilesByPaths
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) ExpectSa1Param3(sa1 []string) *mServiceMockGetFilesByPaths {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by Set")
	}

	if mmGetFilesByPaths.defaultExpectation == nil {
		mmGetFilesByPaths.defaultExpectation = &ServiceMockGetFilesByPathsExpectation{}
	}

	if mmGetFilesByPaths.defaultExpectation.params != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by Expect")
	}

	if mmGetFilesByPaths.defaultExpectation.paramPtrs == nil {
		mmGetFilesByPaths.defaultExpectation.paramPtrs = &ServiceMockGetFilesByPathsParamPtrs{}
	}
	mmGetFilesByPaths.defaultExpectation.paramPtrs.sa1 = &sa1
	mmGetFilesByPaths.defaultExpectation.expectationOrigins.originSa1 = minimock.CallerInfo(1)

	return mmGetFilesByPaths
}

// Inspect accepts an inspector function that has same arguments as the Service.GetFilesByPaths
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) Inspect(f func(ctx context.Context, s1 string, sa1 []string)) *mServiceMockGetFilesByPaths {
	if mmGetFilesByPaths.mock.inspectFuncGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetFilesByPaths")
	}

	mmGetFilesByPaths.mock.inspectFuncGetFilesByPaths = f

	return mmGetFilesByPaths
}

// Return sets up results that will be returned by Service.GetFilesByPaths
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) Return(fa1 []mm_service.FileContent, err error) *ServiceMock {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by Set")
	}

	if mmGetFilesByPaths.defaultExpectation == nil {
		mmGetFilesByPaths.defaultExpectation = &ServiceMockGetFilesByPathsExpectation{mock: mmGetFilesByPaths.mock}
	}
	mmGetFilesByPaths.defaultExpectation.results = &ServiceMockGetFilesByPathsResults{fa1, err}
	mmGetFilesByPaths.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetFilesByPaths.mock
}

// Set uses given function f to mock the Service.GetFilesByPaths method
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) Set(f func(ctx context.Context, s1 string, sa1 []string) (fa1 []mm_service.FileContent, err error)) *ServiceMock {
	if mmGetFilesByPaths.defaultExpectation != nil {
		mmGetFilesByPaths.mock.t.Fatalf("Default expectation is already set for the Service.GetFilesByPaths method")
	}

	if len(mmGetFilesByPaths.expectations) > 0 {
		mmGetFilesByPaths.mock.t.Fatalf("Some expectations are already set for the Service.GetFilesByPaths method")
	}

	mmGetFilesByPaths.mock.funcGetFilesByPaths = f
	mmGetFilesByPaths.mock.funcGetFilesByPathsOrigin = minimock.CallerInfo(1)
	return mmGetFilesByPaths.mock
}

// When sets expectation for the Service.GetFilesByPaths which will trigger the result defined by the following
// Then helper
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) When(ctx context.Context, s1 string, sa1 []string) *ServiceMockGetFilesByPathsExpectation {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by Set")
	}

	expectation := &ServiceMockGetFilesByPathsExpectation{
		mock:               mmGetFilesByPaths.mock,
		params:             &ServiceMockGetFilesByPathsParams{ctx, s1, sa1},
		expectationOrigins: ServiceMockGetFilesByPathsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetFilesByPaths.expectations = append(mmGetFilesByPaths.expectations, expectation)
	return expectation
}

// Then sets up Service.GetFilesByPaths return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetFilesByPathsExpectation) Then(fa1 []mm_service.FileContent, err error) *ServiceMock {
	e.results = &ServiceMockGetFilesByPathsResults{fa1, err}
	return e.mock
}

// Times sets number of times Service.GetFilesByPaths should be invoked
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) Times(n uint64) *mServiceMockGetFilesByPaths {
	if n == 0 {
		mmGetFilesByPaths.mock.t.Fatalf("Times of ServiceMock.GetFilesByPaths mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFilesByPaths.expectedInvocations, n)
	mmGetFilesByPaths.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetFilesByPaths
}

func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) invocationsDone() bool {
	if len(mmGetFilesByPaths.expectations) == 0 && mmGetFilesByPaths.defaultExpectation == nil && mmGetFilesByPaths.mock.funcGetFilesByPaths == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFilesByPaths.mock.afterGetFilesByPathsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFilesByPaths.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFilesByPaths implements mm_service.Service
func (mmGetFilesByPaths *ServiceMock) GetFilesByPaths(ctx context.Context, s1 string, sa1 []string) (fa1 []mm_service.FileContent, err error) {
	mm_atomic.AddUint64(&mmGetFilesByPaths.beforeGetFilesByPathsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFilesByPaths.afterGetFilesByPathsCounter, 1)

	mmGetFilesByPaths.t.Helper()

	if mmGetFilesByPaths.inspectFuncGetFilesByPaths != nil {
		mmGetFilesByPaths.inspectFuncGetFilesByPaths(ctx, s1, sa1)
	}

	mm_params := ServiceMockGetFilesByPathsParams{ctx, s1, sa1}

	// Record call args
	mmGetFilesByPaths.GetFilesByPathsMock.mutex.Lock()
	mmGetFilesByPaths.GetFilesByPathsMock.callArgs = append(mmGetFilesByPaths.GetFilesByPathsMock.callArgs, &mm_params)
	mmGetFilesByPaths.GetFilesByPathsMock.mutex.Unlock()

	for _, e := range mmGetFilesByPaths.GetFilesByPathsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.fa1, e.results.err
		}
	}

	if mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.params
		mm_want_ptrs := mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetFilesByPathsParams{ctx, s1, sa1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFilesByPaths.t.Errorf("ServiceMock.GetFilesByPaths got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmGetFilesByPaths.t.Errorf("ServiceMock.GetFilesByPaths got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

			if mm_want_ptrs.sa1 != nil && !minimock.Equal(*mm_want_ptrs.sa1, mm_got.sa1) {
				mmGetFilesByPaths.t.Errorf("ServiceMock.GetFilesByPaths got unexpected parameter sa1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.expectationOrigins.originSa1, *mm_want_ptrs.sa1, mm_got.sa1, minimock.Diff(*mm_want_ptrs.sa1, mm_got.sa1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFilesByPaths.t.Errorf("ServiceMock.GetFilesByPaths got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFilesByPaths.t.Fatal("No results are set for the ServiceMock.GetFilesByPaths")
		}
		return (*mm_results).fa1, (*mm_results).err
	}
	if mmGetFilesByPaths.funcGetFilesByPaths != nil {
		return mmGetFilesByPaths.funcGetFilesByPaths(ctx, s1, sa1)
	}
	mmGetFilesByPaths.t.Fatalf("Unexpected call to ServiceMock.GetFilesByPaths. %v %v %v", ctx, s1, sa1)
	return
}

// GetFilesByPathsAfterCounter returns a count of finished ServiceMock.GetFilesByPaths invocations
func (mmGetFilesByPaths *ServiceMock) GetFilesByPathsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFilesByPaths.afterGetFilesByPathsCounter)
}

// GetFilesByPathsBeforeCounter returns a count of ServiceMock.GetFilesByPaths invocations
func (mmGetFilesByPaths *ServiceMock) GetFilesByPathsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFilesByPaths.beforeGetFilesByPathsCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetFilesByPaths.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) Calls() []*ServiceMockGetFilesByPathsParams {
	mmGetFilesByPaths.mutex.RLock()

	argCopy := make([]*ServiceMockGetFilesByPathsParams, len(mmGetFilesByPaths.callArgs))
	copy(argCopy, mmGetFilesByPaths.callArgs)

	mmGetFilesByPaths.mutex.RUnlock()

	return argCopy
}

// MinimockGetFilesByPathsDone returns true if the count of the GetFilesByPaths invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetFilesByPathsDone() bool {
	if m.GetFilesByPathsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFilesByPathsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFilesByPathsMock.invocationsDone()
}

// MinimockGetFilesByPathsInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetFilesByPathsInspect() {
	for _, e := range m.GetFilesByPathsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetFilesByPaths at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetFilesByPathsCounter := mm_atomic.LoadUint64(&m.afterGetFilesByPathsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFilesByPathsMock.defaultExpectation != nil && afterGetFilesByPathsCounter < 1 {
		if m.GetFilesByPathsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetFilesByPaths at\n%s", m.GetFilesByPathsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetFilesByPaths at\n%s with params: %#v", m.GetFilesByPathsMock.defaultExpectation.expectationOrigins.origin, *m.GetFilesByPathsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFilesByPaths != nil && afterGetFilesByPathsCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetFilesByPaths at\n%s", m.funcGetFilesByPathsOrigin)
	}

	if !m.GetFilesByPathsMock.invocationsDone() && afterGetFilesByPathsCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetFilesByPaths at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetFilesByPathsMock.expectedInvocations), m.GetFilesByPathsMock.expectedInvocationsOrigin, afterGetFilesByPathsCounter)
	}
}

type mServiceMockGetNamespaceAndCheckPermission struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetNamespaceAndCheckPermissionExpectation
	expectations       []*ServiceMockGetNamespaceAndCheckPermissionExpectation

	callArgs []*ServiceMockGetNamespaceAndCheckPermissionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetNamespaceAndCheckPermissionExpectation specifies expectation struct of the Service.GetNamespaceAndCheckPermission
type ServiceMockGetNamespaceAndCheckPermissionExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetNamespaceAndCheckPermissionParams
	paramPtrs          *ServiceMockGetNamespaceAndCheckPermissionParamPtrs
	expectationOrigins ServiceMockGetNamespaceAndCheckPermissionExpectationOrigins
	results            *ServiceMockGetNamespaceAndCheckPermissionResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetNamespaceAndCheckPermissionParams contains parameters of the Service.GetNamespaceAndCheckPermission
type ServiceMockGetNamespaceAndCheckPermissionParams struct {
	ctx context.Context
	s1  string
}

// ServiceMockGetNamespaceAndCheckPermissionParamPtrs contains pointers to parameters of the Service.GetNamespaceAndCheckPermission
type ServiceMockGetNamespaceAndCheckPermissionParamPtrs struct {
	ctx *context.Context
	s1  *string
}

// ServiceMockGetNamespaceAndCheckPermissionResults contains results of the Service.GetNamespaceAndCheckPermission
type ServiceMockGetNamespaceAndCheckPermissionResults struct {
	np1 *resource.Namespace
	err error
}

// ServiceMockGetNamespaceAndCheckPermissionOrigins contains origins of expectations of the Service.GetNamespaceAndCheckPermission
type ServiceMockGetNamespaceAndCheckPermissionExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) Optional() *mServiceMockGetNamespaceAndCheckPermission {
	mmGetNamespaceAndCheckPermission.optional = true
	return mmGetNamespaceAndCheckPermission
}

// Expect sets up expected params for Service.GetNamespaceAndCheckPermission
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) Expect(ctx context.Context, s1 string) *mServiceMockGetNamespaceAndCheckPermission {
	if mmGetNamespaceAndCheckPermission.mock.funcGetNamespaceAndCheckPermission != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("ServiceMock.GetNamespaceAndCheckPermission mock is already set by Set")
	}

	if mmGetNamespaceAndCheckPermission.defaultExpectation == nil {
		mmGetNamespaceAndCheckPermission.defaultExpectation = &ServiceMockGetNamespaceAndCheckPermissionExpectation{}
	}

	if mmGetNamespaceAndCheckPermission.defaultExpectation.paramPtrs != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("ServiceMock.GetNamespaceAndCheckPermission mock is already set by ExpectParams functions")
	}

	mmGetNamespaceAndCheckPermission.defaultExpectation.params = &ServiceMockGetNamespaceAndCheckPermissionParams{ctx, s1}
	mmGetNamespaceAndCheckPermission.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetNamespaceAndCheckPermission.expectations {
		if minimock.Equal(e.params, mmGetNamespaceAndCheckPermission.defaultExpectation.params) {
			mmGetNamespaceAndCheckPermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetNamespaceAndCheckPermission.defaultExpectation.params)
		}
	}

	return mmGetNamespaceAndCheckPermission
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetNamespaceAndCheckPermission
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) ExpectCtxParam1(ctx context.Context) *mServiceMockGetNamespaceAndCheckPermission {
	if mmGetNamespaceAndCheckPermission.mock.funcGetNamespaceAndCheckPermission != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("ServiceMock.GetNamespaceAndCheckPermission mock is already set by Set")
	}

	if mmGetNamespaceAndCheckPermission.defaultExpectation == nil {
		mmGetNamespaceAndCheckPermission.defaultExpectation = &ServiceMockGetNamespaceAndCheckPermissionExpectation{}
	}

	if mmGetNamespaceAndCheckPermission.defaultExpectation.params != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("ServiceMock.GetNamespaceAndCheckPermission mock is already set by Expect")
	}

	if mmGetNamespaceAndCheckPermission.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceAndCheckPermission.defaultExpectation.paramPtrs = &ServiceMockGetNamespaceAndCheckPermissionParamPtrs{}
	}
	mmGetNamespaceAndCheckPermission.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetNamespaceAndCheckPermission.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetNamespaceAndCheckPermission
}

// ExpectS1Param2 sets up expected param s1 for Service.GetNamespaceAndCheckPermission
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) ExpectS1Param2(s1 string) *mServiceMockGetNamespaceAndCheckPermission {
	if mmGetNamespaceAndCheckPermission.mock.funcGetNamespaceAndCheckPermission != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("ServiceMock.GetNamespaceAndCheckPermission mock is already set by Set")
	}

	if mmGetNamespaceAndCheckPermission.defaultExpectation == nil {
		mmGetNamespaceAndCheckPermission.defaultExpectation = &ServiceMockGetNamespaceAndCheckPermissionExpectation{}
	}

	if mmGetNamespaceAndCheckPermission.defaultExpectation.params != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("ServiceMock.GetNamespaceAndCheckPermission mock is already set by Expect")
	}

	if mmGetNamespaceAndCheckPermission.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceAndCheckPermission.defaultExpectation.paramPtrs = &ServiceMockGetNamespaceAndCheckPermissionParamPtrs{}
	}
	mmGetNamespaceAndCheckPermission.defaultExpectation.paramPtrs.s1 = &s1
	mmGetNamespaceAndCheckPermission.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmGetNamespaceAndCheckPermission
}

// Inspect accepts an inspector function that has same arguments as the Service.GetNamespaceAndCheckPermission
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) Inspect(f func(ctx context.Context, s1 string)) *mServiceMockGetNamespaceAndCheckPermission {
	if mmGetNamespaceAndCheckPermission.mock.inspectFuncGetNamespaceAndCheckPermission != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetNamespaceAndCheckPermission")
	}

	mmGetNamespaceAndCheckPermission.mock.inspectFuncGetNamespaceAndCheckPermission = f

	return mmGetNamespaceAndCheckPermission
}

// Return sets up results that will be returned by Service.GetNamespaceAndCheckPermission
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) Return(np1 *resource.Namespace, err error) *ServiceMock {
	if mmGetNamespaceAndCheckPermission.mock.funcGetNamespaceAndCheckPermission != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("ServiceMock.GetNamespaceAndCheckPermission mock is already set by Set")
	}

	if mmGetNamespaceAndCheckPermission.defaultExpectation == nil {
		mmGetNamespaceAndCheckPermission.defaultExpectation = &ServiceMockGetNamespaceAndCheckPermissionExpectation{mock: mmGetNamespaceAndCheckPermission.mock}
	}
	mmGetNamespaceAndCheckPermission.defaultExpectation.results = &ServiceMockGetNamespaceAndCheckPermissionResults{np1, err}
	mmGetNamespaceAndCheckPermission.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceAndCheckPermission.mock
}

// Set uses given function f to mock the Service.GetNamespaceAndCheckPermission method
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) Set(f func(ctx context.Context, s1 string) (np1 *resource.Namespace, err error)) *ServiceMock {
	if mmGetNamespaceAndCheckPermission.defaultExpectation != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("Default expectation is already set for the Service.GetNamespaceAndCheckPermission method")
	}

	if len(mmGetNamespaceAndCheckPermission.expectations) > 0 {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("Some expectations are already set for the Service.GetNamespaceAndCheckPermission method")
	}

	mmGetNamespaceAndCheckPermission.mock.funcGetNamespaceAndCheckPermission = f
	mmGetNamespaceAndCheckPermission.mock.funcGetNamespaceAndCheckPermissionOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceAndCheckPermission.mock
}

// When sets expectation for the Service.GetNamespaceAndCheckPermission which will trigger the result defined by the following
// Then helper
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) When(ctx context.Context, s1 string) *ServiceMockGetNamespaceAndCheckPermissionExpectation {
	if mmGetNamespaceAndCheckPermission.mock.funcGetNamespaceAndCheckPermission != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("ServiceMock.GetNamespaceAndCheckPermission mock is already set by Set")
	}

	expectation := &ServiceMockGetNamespaceAndCheckPermissionExpectation{
		mock:               mmGetNamespaceAndCheckPermission.mock,
		params:             &ServiceMockGetNamespaceAndCheckPermissionParams{ctx, s1},
		expectationOrigins: ServiceMockGetNamespaceAndCheckPermissionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetNamespaceAndCheckPermission.expectations = append(mmGetNamespaceAndCheckPermission.expectations, expectation)
	return expectation
}

// Then sets up Service.GetNamespaceAndCheckPermission return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetNamespaceAndCheckPermissionExpectation) Then(np1 *resource.Namespace, err error) *ServiceMock {
	e.results = &ServiceMockGetNamespaceAndCheckPermissionResults{np1, err}
	return e.mock
}

// Times sets number of times Service.GetNamespaceAndCheckPermission should be invoked
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) Times(n uint64) *mServiceMockGetNamespaceAndCheckPermission {
	if n == 0 {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("Times of ServiceMock.GetNamespaceAndCheckPermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetNamespaceAndCheckPermission.expectedInvocations, n)
	mmGetNamespaceAndCheckPermission.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceAndCheckPermission
}

func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) invocationsDone() bool {
	if len(mmGetNamespaceAndCheckPermission.expectations) == 0 && mmGetNamespaceAndCheckPermission.defaultExpectation == nil && mmGetNamespaceAndCheckPermission.mock.funcGetNamespaceAndCheckPermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetNamespaceAndCheckPermission.mock.afterGetNamespaceAndCheckPermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetNamespaceAndCheckPermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetNamespaceAndCheckPermission implements mm_service.Service
func (mmGetNamespaceAndCheckPermission *ServiceMock) GetNamespaceAndCheckPermission(ctx context.Context, s1 string) (np1 *resource.Namespace, err error) {
	mm_atomic.AddUint64(&mmGetNamespaceAndCheckPermission.beforeGetNamespaceAndCheckPermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNamespaceAndCheckPermission.afterGetNamespaceAndCheckPermissionCounter, 1)

	mmGetNamespaceAndCheckPermission.t.Helper()

	if mmGetNamespaceAndCheckPermission.inspectFuncGetNamespaceAndCheckPermission != nil {
		mmGetNamespaceAndCheckPermission.inspectFuncGetNamespaceAndCheckPermission(ctx, s1)
	}

	mm_params := ServiceMockGetNamespaceAndCheckPermissionParams{ctx, s1}

	// Record call args
	mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.mutex.Lock()
	mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.callArgs = append(mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.callArgs, &mm_params)
	mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.mutex.Unlock()

	for _, e := range mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.np1, e.results.err
		}
	}

	if mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.defaultExpectation.params
		mm_want_ptrs := mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetNamespaceAndCheckPermissionParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetNamespaceAndCheckPermission.t.Errorf("ServiceMock.GetNamespaceAndCheckPermission got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmGetNamespaceAndCheckPermission.t.Errorf("ServiceMock.GetNamespaceAndCheckPermission got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetNamespaceAndCheckPermission.t.Errorf("ServiceMock.GetNamespaceAndCheckPermission got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNamespaceAndCheckPermission.t.Fatal("No results are set for the ServiceMock.GetNamespaceAndCheckPermission")
		}
		return (*mm_results).np1, (*mm_results).err
	}
	if mmGetNamespaceAndCheckPermission.funcGetNamespaceAndCheckPermission != nil {
		return mmGetNamespaceAndCheckPermission.funcGetNamespaceAndCheckPermission(ctx, s1)
	}
	mmGetNamespaceAndCheckPermission.t.Fatalf("Unexpected call to ServiceMock.GetNamespaceAndCheckPermission. %v %v", ctx, s1)
	return
}

// GetNamespaceAndCheckPermissionAfterCounter returns a count of finished ServiceMock.GetNamespaceAndCheckPermission invocations
func (mmGetNamespaceAndCheckPermission *ServiceMock) GetNamespaceAndCheckPermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceAndCheckPermission.afterGetNamespaceAndCheckPermissionCounter)
}

// GetNamespaceAndCheckPermissionBeforeCounter returns a count of ServiceMock.GetNamespaceAndCheckPermission invocations
func (mmGetNamespaceAndCheckPermission *ServiceMock) GetNamespaceAndCheckPermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceAndCheckPermission.beforeGetNamespaceAndCheckPermissionCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetNamespaceAndCheckPermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) Calls() []*ServiceMockGetNamespaceAndCheckPermissionParams {
	mmGetNamespaceAndCheckPermission.mutex.RLock()

	argCopy := make([]*ServiceMockGetNamespaceAndCheckPermissionParams, len(mmGetNamespaceAndCheckPermission.callArgs))
	copy(argCopy, mmGetNamespaceAndCheckPermission.callArgs)

	mmGetNamespaceAndCheckPermission.mutex.RUnlock()

	return argCopy
}

// MinimockGetNamespaceAndCheckPermissionDone returns true if the count of the GetNamespaceAndCheckPermission invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetNamespaceAndCheckPermissionDone() bool {
	if m.GetNamespaceAndCheckPermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetNamespaceAndCheckPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetNamespaceAndCheckPermissionMock.invocationsDone()
}

// MinimockGetNamespaceAndCheckPermissionInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetNamespaceAndCheckPermissionInspect() {
	for _, e := range m.GetNamespaceAndCheckPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetNamespaceAndCheckPermission at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetNamespaceAndCheckPermissionCounter := mm_atomic.LoadUint64(&m.afterGetNamespaceAndCheckPermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetNamespaceAndCheckPermissionMock.defaultExpectation != nil && afterGetNamespaceAndCheckPermissionCounter < 1 {
		if m.GetNamespaceAndCheckPermissionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetNamespaceAndCheckPermission at\n%s", m.GetNamespaceAndCheckPermissionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetNamespaceAndCheckPermission at\n%s with params: %#v", m.GetNamespaceAndCheckPermissionMock.defaultExpectation.expectationOrigins.origin, *m.GetNamespaceAndCheckPermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNamespaceAndCheckPermission != nil && afterGetNamespaceAndCheckPermissionCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetNamespaceAndCheckPermission at\n%s", m.funcGetNamespaceAndCheckPermissionOrigin)
	}

	if !m.GetNamespaceAndCheckPermissionMock.invocationsDone() && afterGetNamespaceAndCheckPermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetNamespaceAndCheckPermission at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetNamespaceAndCheckPermissionMock.expectedInvocations), m.GetNamespaceAndCheckPermissionMock.expectedInvocationsOrigin, afterGetNamespaceAndCheckPermissionCounter)
	}
}

type mServiceMockGetNamespaceByNsID struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetNamespaceByNsIDExpectation
	expectations       []*ServiceMockGetNamespaceByNsIDExpectation

	callArgs []*ServiceMockGetNamespaceByNsIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetNamespaceByNsIDExpectation specifies expectation struct of the Service.GetNamespaceByNsID
type ServiceMockGetNamespaceByNsIDExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetNamespaceByNsIDParams
	paramPtrs          *ServiceMockGetNamespaceByNsIDParamPtrs
	expectationOrigins ServiceMockGetNamespaceByNsIDExpectationOrigins
	results            *ServiceMockGetNamespaceByNsIDResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetNamespaceByNsIDParams contains parameters of the Service.GetNamespaceByNsID
type ServiceMockGetNamespaceByNsIDParams struct {
	ctx context.Context
	s1  string
}

// ServiceMockGetNamespaceByNsIDParamPtrs contains pointers to parameters of the Service.GetNamespaceByNsID
type ServiceMockGetNamespaceByNsIDParamPtrs struct {
	ctx *context.Context
	s1  *string
}

// ServiceMockGetNamespaceByNsIDResults contains results of the Service.GetNamespaceByNsID
type ServiceMockGetNamespaceByNsIDResults struct {
	np1 *resource.Namespace
	err error
}

// ServiceMockGetNamespaceByNsIDOrigins contains origins of expectations of the Service.GetNamespaceByNsID
type ServiceMockGetNamespaceByNsIDExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) Optional() *mServiceMockGetNamespaceByNsID {
	mmGetNamespaceByNsID.optional = true
	return mmGetNamespaceByNsID
}

// Expect sets up expected params for Service.GetNamespaceByNsID
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) Expect(ctx context.Context, s1 string) *mServiceMockGetNamespaceByNsID {
	if mmGetNamespaceByNsID.mock.funcGetNamespaceByNsID != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("ServiceMock.GetNamespaceByNsID mock is already set by Set")
	}

	if mmGetNamespaceByNsID.defaultExpectation == nil {
		mmGetNamespaceByNsID.defaultExpectation = &ServiceMockGetNamespaceByNsIDExpectation{}
	}

	if mmGetNamespaceByNsID.defaultExpectation.paramPtrs != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("ServiceMock.GetNamespaceByNsID mock is already set by ExpectParams functions")
	}

	mmGetNamespaceByNsID.defaultExpectation.params = &ServiceMockGetNamespaceByNsIDParams{ctx, s1}
	mmGetNamespaceByNsID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetNamespaceByNsID.expectations {
		if minimock.Equal(e.params, mmGetNamespaceByNsID.defaultExpectation.params) {
			mmGetNamespaceByNsID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetNamespaceByNsID.defaultExpectation.params)
		}
	}

	return mmGetNamespaceByNsID
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetNamespaceByNsID
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) ExpectCtxParam1(ctx context.Context) *mServiceMockGetNamespaceByNsID {
	if mmGetNamespaceByNsID.mock.funcGetNamespaceByNsID != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("ServiceMock.GetNamespaceByNsID mock is already set by Set")
	}

	if mmGetNamespaceByNsID.defaultExpectation == nil {
		mmGetNamespaceByNsID.defaultExpectation = &ServiceMockGetNamespaceByNsIDExpectation{}
	}

	if mmGetNamespaceByNsID.defaultExpectation.params != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("ServiceMock.GetNamespaceByNsID mock is already set by Expect")
	}

	if mmGetNamespaceByNsID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceByNsID.defaultExpectation.paramPtrs = &ServiceMockGetNamespaceByNsIDParamPtrs{}
	}
	mmGetNamespaceByNsID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetNamespaceByNsID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetNamespaceByNsID
}

// ExpectS1Param2 sets up expected param s1 for Service.GetNamespaceByNsID
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) ExpectS1Param2(s1 string) *mServiceMockGetNamespaceByNsID {
	if mmGetNamespaceByNsID.mock.funcGetNamespaceByNsID != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("ServiceMock.GetNamespaceByNsID mock is already set by Set")
	}

	if mmGetNamespaceByNsID.defaultExpectation == nil {
		mmGetNamespaceByNsID.defaultExpectation = &ServiceMockGetNamespaceByNsIDExpectation{}
	}

	if mmGetNamespaceByNsID.defaultExpectation.params != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("ServiceMock.GetNamespaceByNsID mock is already set by Expect")
	}

	if mmGetNamespaceByNsID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceByNsID.defaultExpectation.paramPtrs = &ServiceMockGetNamespaceByNsIDParamPtrs{}
	}
	mmGetNamespaceByNsID.defaultExpectation.paramPtrs.s1 = &s1
	mmGetNamespaceByNsID.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmGetNamespaceByNsID
}

// Inspect accepts an inspector function that has same arguments as the Service.GetNamespaceByNsID
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) Inspect(f func(ctx context.Context, s1 string)) *mServiceMockGetNamespaceByNsID {
	if mmGetNamespaceByNsID.mock.inspectFuncGetNamespaceByNsID != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetNamespaceByNsID")
	}

	mmGetNamespaceByNsID.mock.inspectFuncGetNamespaceByNsID = f

	return mmGetNamespaceByNsID
}

// Return sets up results that will be returned by Service.GetNamespaceByNsID
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) Return(np1 *resource.Namespace, err error) *ServiceMock {
	if mmGetNamespaceByNsID.mock.funcGetNamespaceByNsID != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("ServiceMock.GetNamespaceByNsID mock is already set by Set")
	}

	if mmGetNamespaceByNsID.defaultExpectation == nil {
		mmGetNamespaceByNsID.defaultExpectation = &ServiceMockGetNamespaceByNsIDExpectation{mock: mmGetNamespaceByNsID.mock}
	}
	mmGetNamespaceByNsID.defaultExpectation.results = &ServiceMockGetNamespaceByNsIDResults{np1, err}
	mmGetNamespaceByNsID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceByNsID.mock
}

// Set uses given function f to mock the Service.GetNamespaceByNsID method
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) Set(f func(ctx context.Context, s1 string) (np1 *resource.Namespace, err error)) *ServiceMock {
	if mmGetNamespaceByNsID.defaultExpectation != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("Default expectation is already set for the Service.GetNamespaceByNsID method")
	}

	if len(mmGetNamespaceByNsID.expectations) > 0 {
		mmGetNamespaceByNsID.mock.t.Fatalf("Some expectations are already set for the Service.GetNamespaceByNsID method")
	}

	mmGetNamespaceByNsID.mock.funcGetNamespaceByNsID = f
	mmGetNamespaceByNsID.mock.funcGetNamespaceByNsIDOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceByNsID.mock
}

// When sets expectation for the Service.GetNamespaceByNsID which will trigger the result defined by the following
// Then helper
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) When(ctx context.Context, s1 string) *ServiceMockGetNamespaceByNsIDExpectation {
	if mmGetNamespaceByNsID.mock.funcGetNamespaceByNsID != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("ServiceMock.GetNamespaceByNsID mock is already set by Set")
	}

	expectation := &ServiceMockGetNamespaceByNsIDExpectation{
		mock:               mmGetNamespaceByNsID.mock,
		params:             &ServiceMockGetNamespaceByNsIDParams{ctx, s1},
		expectationOrigins: ServiceMockGetNamespaceByNsIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetNamespaceByNsID.expectations = append(mmGetNamespaceByNsID.expectations, expectation)
	return expectation
}

// Then sets up Service.GetNamespaceByNsID return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetNamespaceByNsIDExpectation) Then(np1 *resource.Namespace, err error) *ServiceMock {
	e.results = &ServiceMockGetNamespaceByNsIDResults{np1, err}
	return e.mock
}

// Times sets number of times Service.GetNamespaceByNsID should be invoked
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) Times(n uint64) *mServiceMockGetNamespaceByNsID {
	if n == 0 {
		mmGetNamespaceByNsID.mock.t.Fatalf("Times of ServiceMock.GetNamespaceByNsID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetNamespaceByNsID.expectedInvocations, n)
	mmGetNamespaceByNsID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceByNsID
}

func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) invocationsDone() bool {
	if len(mmGetNamespaceByNsID.expectations) == 0 && mmGetNamespaceByNsID.defaultExpectation == nil && mmGetNamespaceByNsID.mock.funcGetNamespaceByNsID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetNamespaceByNsID.mock.afterGetNamespaceByNsIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetNamespaceByNsID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetNamespaceByNsID implements mm_service.Service
func (mmGetNamespaceByNsID *ServiceMock) GetNamespaceByNsID(ctx context.Context, s1 string) (np1 *resource.Namespace, err error) {
	mm_atomic.AddUint64(&mmGetNamespaceByNsID.beforeGetNamespaceByNsIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNamespaceByNsID.afterGetNamespaceByNsIDCounter, 1)

	mmGetNamespaceByNsID.t.Helper()

	if mmGetNamespaceByNsID.inspectFuncGetNamespaceByNsID != nil {
		mmGetNamespaceByNsID.inspectFuncGetNamespaceByNsID(ctx, s1)
	}

	mm_params := ServiceMockGetNamespaceByNsIDParams{ctx, s1}

	// Record call args
	mmGetNamespaceByNsID.GetNamespaceByNsIDMock.mutex.Lock()
	mmGetNamespaceByNsID.GetNamespaceByNsIDMock.callArgs = append(mmGetNamespaceByNsID.GetNamespaceByNsIDMock.callArgs, &mm_params)
	mmGetNamespaceByNsID.GetNamespaceByNsIDMock.mutex.Unlock()

	for _, e := range mmGetNamespaceByNsID.GetNamespaceByNsIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.np1, e.results.err
		}
	}

	if mmGetNamespaceByNsID.GetNamespaceByNsIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNamespaceByNsID.GetNamespaceByNsIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetNamespaceByNsID.GetNamespaceByNsIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetNamespaceByNsID.GetNamespaceByNsIDMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetNamespaceByNsIDParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetNamespaceByNsID.t.Errorf("ServiceMock.GetNamespaceByNsID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceByNsID.GetNamespaceByNsIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmGetNamespaceByNsID.t.Errorf("ServiceMock.GetNamespaceByNsID got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceByNsID.GetNamespaceByNsIDMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetNamespaceByNsID.t.Errorf("ServiceMock.GetNamespaceByNsID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetNamespaceByNsID.GetNamespaceByNsIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetNamespaceByNsID.GetNamespaceByNsIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNamespaceByNsID.t.Fatal("No results are set for the ServiceMock.GetNamespaceByNsID")
		}
		return (*mm_results).np1, (*mm_results).err
	}
	if mmGetNamespaceByNsID.funcGetNamespaceByNsID != nil {
		return mmGetNamespaceByNsID.funcGetNamespaceByNsID(ctx, s1)
	}
	mmGetNamespaceByNsID.t.Fatalf("Unexpected call to ServiceMock.GetNamespaceByNsID. %v %v", ctx, s1)
	return
}

// GetNamespaceByNsIDAfterCounter returns a count of finished ServiceMock.GetNamespaceByNsID invocations
func (mmGetNamespaceByNsID *ServiceMock) GetNamespaceByNsIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceByNsID.afterGetNamespaceByNsIDCounter)
}

// GetNamespaceByNsIDBeforeCounter returns a count of ServiceMock.GetNamespaceByNsID invocations
func (mmGetNamespaceByNsID *ServiceMock) GetNamespaceByNsIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceByNsID.beforeGetNamespaceByNsIDCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetNamespaceByNsID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) Calls() []*ServiceMockGetNamespaceByNsIDParams {
	mmGetNamespaceByNsID.mutex.RLock()

	argCopy := make([]*ServiceMockGetNamespaceByNsIDParams, len(mmGetNamespaceByNsID.callArgs))
	copy(argCopy, mmGetNamespaceByNsID.callArgs)

	mmGetNamespaceByNsID.mutex.RUnlock()

	return argCopy
}

// MinimockGetNamespaceByNsIDDone returns true if the count of the GetNamespaceByNsID invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetNamespaceByNsIDDone() bool {
	if m.GetNamespaceByNsIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetNamespaceByNsIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetNamespaceByNsIDMock.invocationsDone()
}

// MinimockGetNamespaceByNsIDInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetNamespaceByNsIDInspect() {
	for _, e := range m.GetNamespaceByNsIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetNamespaceByNsID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetNamespaceByNsIDCounter := mm_atomic.LoadUint64(&m.afterGetNamespaceByNsIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetNamespaceByNsIDMock.defaultExpectation != nil && afterGetNamespaceByNsIDCounter < 1 {
		if m.GetNamespaceByNsIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetNamespaceByNsID at\n%s", m.GetNamespaceByNsIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetNamespaceByNsID at\n%s with params: %#v", m.GetNamespaceByNsIDMock.defaultExpectation.expectationOrigins.origin, *m.GetNamespaceByNsIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNamespaceByNsID != nil && afterGetNamespaceByNsIDCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetNamespaceByNsID at\n%s", m.funcGetNamespaceByNsIDOrigin)
	}

	if !m.GetNamespaceByNsIDMock.invocationsDone() && afterGetNamespaceByNsIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetNamespaceByNsID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetNamespaceByNsIDMock.expectedInvocations), m.GetNamespaceByNsIDMock.expectedInvocationsOrigin, afterGetNamespaceByNsIDCounter)
	}
}

type mServiceMockGetRepositoryTag struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetRepositoryTagExpectation
	expectations       []*ServiceMockGetRepositoryTagExpectation

	callArgs []*ServiceMockGetRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetRepositoryTagExpectation specifies expectation struct of the Service.GetRepositoryTag
type ServiceMockGetRepositoryTagExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetRepositoryTagParams
	paramPtrs          *ServiceMockGetRepositoryTagParamPtrs
	expectationOrigins ServiceMockGetRepositoryTagExpectationOrigins
	results            *ServiceMockGetRepositoryTagResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetRepositoryTagParams contains parameters of the Service.GetRepositoryTag
type ServiceMockGetRepositoryTagParams struct {
	ctx context.Context
	gp1 *artifactpb.GetRepositoryTagRequest
}

// ServiceMockGetRepositoryTagParamPtrs contains pointers to parameters of the Service.GetRepositoryTag
type ServiceMockGetRepositoryTagParamPtrs struct {
	ctx *context.Context
	gp1 **artifactpb.GetRepositoryTagRequest
}

// ServiceMockGetRepositoryTagResults contains results of the Service.GetRepositoryTag
type ServiceMockGetRepositoryTagResults struct {
	gp2 *artifactpb.GetRepositoryTagResponse
	err error
}

// ServiceMockGetRepositoryTagOrigins contains origins of expectations of the Service.GetRepositoryTag
type ServiceMockGetRepositoryTagExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) Optional() *mServiceMockGetRepositoryTag {
	mmGetRepositoryTag.optional = true
	return mmGetRepositoryTag
}

// Expect sets up expected params for Service.GetRepositoryTag
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) Expect(ctx context.Context, gp1 *artifactpb.GetRepositoryTagRequest) *mServiceMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("ServiceMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &ServiceMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmGetRepositoryTag.mock.t.Fatalf("ServiceMock.GetRepositoryTag mock is already set by ExpectParams functions")
	}

	mmGetRepositoryTag.defaultExpectation.params = &ServiceMockGetRepositoryTagParams{ctx, gp1}
	mmGetRepositoryTag.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetRepositoryTag.expectations {
		if minimock.Equal(e.params, mmGetRepositoryTag.defaultExpectation.params) {
			mmGetRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRepositoryTag.defaultExpectation.params)
		}
	}

	return mmGetRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetRepositoryTag
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) ExpectCtxParam1(ctx context.Context) *mServiceMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("ServiceMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &ServiceMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.params != nil {
		mmGetRepositoryTag.mock.t.Fatalf("ServiceMock.GetRepositoryTag mock is already set by Expect")
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmGetRepositoryTag.defaultExpectation.paramPtrs = &ServiceMockGetRepositoryTagParamPtrs{}
	}
	mmGetRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetRepositoryTag.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetRepositoryTag
}

// ExpectGp1Param2 sets up expected param gp1 for Service.GetRepositoryTag
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) ExpectGp1Param2(gp1 *artifactpb.GetRepositoryTagRequest) *mServiceMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("ServiceMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &ServiceMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.params != nil {
		mmGetRepositoryTag.mock.t.Fatalf("ServiceMock.GetRepositoryTag mock is already set by Expect")
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmGetRepositoryTag.defaultExpectation.paramPtrs = &ServiceMockGetRepositoryTagParamPtrs{}
	}
	mmGetRepositoryTag.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetRepositoryTag.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the Service.GetRepositoryTag
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) Inspect(f func(ctx context.Context, gp1 *artifactpb.GetRepositoryTagRequest)) *mServiceMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.inspectFuncGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetRepositoryTag")
	}

	mmGetRepositoryTag.mock.inspectFuncGetRepositoryTag = f

	return mmGetRepositoryTag
}

// Return sets up results that will be returned by Service.GetRepositoryTag
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) Return(gp2 *artifactpb.GetRepositoryTagResponse, err error) *ServiceMock {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("ServiceMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &ServiceMockGetRepositoryTagExpectation{mock: mmGetRepositoryTag.mock}
	}
	mmGetRepositoryTag.defaultExpectation.results = &ServiceMockGetRepositoryTagResults{gp2, err}
	mmGetRepositoryTag.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetRepositoryTag.mock
}

// Set uses given function f to mock the Service.GetRepositoryTag method
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) Set(f func(ctx context.Context, gp1 *artifactpb.GetRepositoryTagRequest) (gp2 *artifactpb.GetRepositoryTagResponse, err error)) *ServiceMock {
	if mmGetRepositoryTag.defaultExpectation != nil {
		mmGetRepositoryTag.mock.t.Fatalf("Default expectation is already set for the Service.GetRepositoryTag method")
	}

	if len(mmGetRepositoryTag.expectations) > 0 {
		mmGetRepositoryTag.mock.t.Fatalf("Some expectations are already set for the Service.GetRepositoryTag method")
	}

	mmGetRepositoryTag.mock.funcGetRepositoryTag = f
	mmGetRepositoryTag.mock.funcGetRepositoryTagOrigin = minimock.CallerInfo(1)
	return mmGetRepositoryTag.mock
}

// When sets expectation for the Service.GetRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) When(ctx context.Context, gp1 *artifactpb.GetRepositoryTagRequest) *ServiceMockGetRepositoryTagExpectation {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("ServiceMock.GetRepositoryTag mock is already set by Set")
	}

	expectation := &ServiceMockGetRepositoryTagExpectation{
		mock:               mmGetRepositoryTag.mock,
		params:             &ServiceMockGetRepositoryTagParams{ctx, gp1},
		expectationOrigins: ServiceMockGetRepositoryTagExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetRepositoryTag.expectations = append(mmGetRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up Service.GetRepositoryTag return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetRepositoryTagExpectation) Then(gp2 *artifactpb.GetRepositoryTagResponse, err error) *ServiceMock {
	e.results = &ServiceMockGetRepositoryTagResults{gp2, err}
	return e.mock
}

// Times sets number of times Service.GetRepositoryTag should be invoked
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) Times(n uint64) *mServiceMockGetRepositoryTag {
	if n == 0 {
		mmGetRepositoryTag.mock.t.Fatalf("Times of ServiceMock.GetRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRepositoryTag.expectedInvocations, n)
	mmGetRepositoryTag.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetRepositoryTag
}

func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) invocationsDone() bool {
	if len(mmGetRepositoryTag.expectations) == 0 && mmGetRepositoryTag.defaultExpectation == nil && mmGetRepositoryTag.mock.funcGetRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRepositoryTag.mock.afterGetRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRepositoryTag implements mm_service.Service
func (mmGetRepositoryTag *ServiceMock) GetRepositoryTag(ctx context.Context, gp1 *artifactpb.GetRepositoryTagRequest) (gp2 *artifactpb.GetRepositoryTagResponse, err error) {
	mm_atomic.AddUint64(&mmGetRepositoryTag.beforeGetRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRepositoryTag.afterGetRepositoryTagCounter, 1)

	mmGetRepositoryTag.t.Helper()

	if mmGetRepositoryTag.inspectFuncGetRepositoryTag != nil {
		mmGetRepositoryTag.inspectFuncGetRepositoryTag(ctx, gp1)
	}

	mm_params := ServiceMockGetRepositoryTagParams{ctx, gp1}

	// Record call args
	mmGetRepositoryTag.GetRepositoryTagMock.mutex.Lock()
	mmGetRepositoryTag.GetRepositoryTagMock.callArgs = append(mmGetRepositoryTag.GetRepositoryTagMock.callArgs, &mm_params)
	mmGetRepositoryTag.GetRepositoryTagMock.mutex.Unlock()

	for _, e := range mmGetRepositoryTag.GetRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetRepositoryTagParams{ctx, gp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetRepositoryTag.t.Errorf("ServiceMock.GetRepositoryTag got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetRepositoryTag.t.Errorf("ServiceMock.GetRepositoryTag got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRepositoryTag.t.Errorf("ServiceMock.GetRepositoryTag got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRepositoryTag.t.Fatal("No results are set for the ServiceMock.GetRepositoryTag")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetRepositoryTag.funcGetRepositoryTag != nil {
		return mmGetRepositoryTag.funcGetRepositoryTag(ctx, gp1)
	}
	mmGetRepositoryTag.t.Fatalf("Unexpected call to ServiceMock.GetRepositoryTag. %v %v", ctx, gp1)
	return
}

// GetRepositoryTagAfterCounter returns a count of finished ServiceMock.GetRepositoryTag invocations
func (mmGetRepositoryTag *ServiceMock) GetRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRepositoryTag.afterGetRepositoryTagCounter)
}

// GetRepositoryTagBeforeCounter returns a count of ServiceMock.GetRepositoryTag invocations
func (mmGetRepositoryTag *ServiceMock) GetRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRepositoryTag.beforeGetRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) Calls() []*ServiceMockGetRepositoryTagParams {
	mmGetRepositoryTag.mutex.RLock()

	argCopy := make([]*ServiceMockGetRepositoryTagParams, len(mmGetRepositoryTag.callArgs))
	copy(argCopy, mmGetRepositoryTag.callArgs)

	mmGetRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockGetRepositoryTagDone returns true if the count of the GetRepositoryTag invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetRepositoryTagDone() bool {
	if m.GetRepositoryTagMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRepositoryTagMock.invocationsDone()
}

// MinimockGetRepositoryTagInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetRepositoryTagInspect() {
	for _, e := range m.GetRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetRepositoryTag at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterGetRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRepositoryTagMock.defaultExpectation != nil && afterGetRepositoryTagCounter < 1 {
		if m.GetRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetRepositoryTag at\n%s", m.GetRepositoryTagMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetRepositoryTag at\n%s with params: %#v", m.GetRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *m.GetRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRepositoryTag != nil && afterGetRepositoryTagCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetRepositoryTag at\n%s", m.funcGetRepositoryTagOrigin)
	}

	if !m.GetRepositoryTagMock.invocationsDone() && afterGetRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetRepositoryTag at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetRepositoryTagMock.expectedInvocations), m.GetRepositoryTagMock.expectedInvocationsOrigin, afterGetRepositoryTagCounter)
	}
}

type mServiceMockGetTextChunkFilePathsByFileUID struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetTextChunkFilePathsByFileUIDExpectation
	expectations       []*ServiceMockGetTextChunkFilePathsByFileUIDExpectation

	callArgs []*ServiceMockGetTextChunkFilePathsByFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetTextChunkFilePathsByFileUIDExpectation specifies expectation struct of the Service.GetTextChunkFilePathsByFileUID
type ServiceMockGetTextChunkFilePathsByFileUIDExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetTextChunkFilePathsByFileUIDParams
	paramPtrs          *ServiceMockGetTextChunkFilePathsByFileUIDParamPtrs
	expectationOrigins ServiceMockGetTextChunkFilePathsByFileUIDExpectationOrigins
	results            *ServiceMockGetTextChunkFilePathsByFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetTextChunkFilePathsByFileUIDParams contains parameters of the Service.GetTextChunkFilePathsByFileUID
type ServiceMockGetTextChunkFilePathsByFileUIDParams struct {
	ctx context.Context
	k1  types.KBUIDType
	f1  types.FileUIDType
}

// ServiceMockGetTextChunkFilePathsByFileUIDParamPtrs contains pointers to parameters of the Service.GetTextChunkFilePathsByFileUID
type ServiceMockGetTextChunkFilePathsByFileUIDParamPtrs struct {
	ctx *context.Context
	k1  *types.KBUIDType
	f1  *types.FileUIDType
}

// ServiceMockGetTextChunkFilePathsByFileUIDResults contains results of the Service.GetTextChunkFilePathsByFileUID
type ServiceMockGetTextChunkFilePathsByFileUIDResults struct {
	sa1 []string
	err error
}

// ServiceMockGetTextChunkFilePathsByFileUIDOrigins contains origins of expectations of the Service.GetTextChunkFilePathsByFileUID
type ServiceMockGetTextChunkFilePathsByFileUIDExpectationOrigins struct {
	origin    string
	originCtx string
	originK1  string
	originF1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetTextChunkFilePathsByFileUID *mServiceMockGetTextChunkFilePathsByFileUID) Optional() *mServiceMockGetTextChunkFilePathsByFileUID {
	mmGetTextChunkFilePathsByFileUID.optional = true
	return mmGetTextChunkFilePathsByFileUID
}

// Expect sets up expected params for Service.GetTextChunkFilePathsByFileUID
func (mmGetTextChunkFilePathsByFileUID *mServiceMockGetTextChunkFilePathsByFileUID) Expect(ctx context.Context, k1 types.KBUIDType, f1 types.FileUIDType) *mServiceMockGetTextChunkFilePathsByFileUID {
	if mmGetTextChunkFilePathsByFileUID.mock.funcGetTextChunkFilePathsByFileUID != nil {
		mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetTextChunkFilePathsByFileUID mock is already set by Set")
	}

	if mmGetTextChunkFilePathsByFileUID.defaultExpectation == nil {
		mmGetTextChunkFilePathsByFileUID.defaultExpectation = &ServiceMockGetTextChunkFilePathsByFileUIDExpectation{}
	}

	if mmGetTextChunkFilePathsByFileUID.defaultExpectation.paramPtrs != nil {
		mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetTextChunkFilePathsByFileUID mock is already set by ExpectParams functions")
	}

	mmGetTextChunkFilePathsByFileUID.defaultExpectation.params = &ServiceMockGetTextChunkFilePathsByFileUIDParams{ctx, k1, f1}
	mmGetTextChunkFilePathsByFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetTextChunkFilePathsByFileUID.expectations {
		if minimock.Equal(e.params, mmGetTextChunkFilePathsByFileUID.defaultExpectation.params) {
			mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTextChunkFilePathsByFileUID.defaultExpectation.params)
		}
	}

	return mmGetTextChunkFilePathsByFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetTextChunkFilePathsByFileUID
func (mmGetTextChunkFilePathsByFileUID *mServiceMockGetTextChunkFilePathsByFileUID) ExpectCtxParam1(ctx context.Context) *mServiceMockGetTextChunkFilePathsByFileUID {
	if mmGetTextChunkFilePathsByFileUID.mock.funcGetTextChunkFilePathsByFileUID != nil {
		mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetTextChunkFilePathsByFileUID mock is already set by Set")
	}

	if mmGetTextChunkFilePathsByFileUID.defaultExpectation == nil {
		mmGetTextChunkFilePathsByFileUID.defaultExpectation = &ServiceMockGetTextChunkFilePathsByFileUIDExpectation{}
	}

	if mmGetTextChunkFilePathsByFileUID.defaultExpectation.params != nil {
		mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetTextChunkFilePathsByFileUID mock is already set by Expect")
	}

	if mmGetTextChunkFilePathsByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetTextChunkFilePathsByFileUID.defaultExpectation.paramPtrs = &ServiceMockGetTextChunkFilePathsByFileUIDParamPtrs{}
	}
	mmGetTextChunkFilePathsByFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetTextChunkFilePathsByFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetTextChunkFilePathsByFileUID
}

// ExpectK1Param2 sets up expected param k1 for Service.GetTextChunkFilePathsByFileUID
func (mmGetTextChunkFilePathsByFileUID *mServiceMockGetTextChunkFilePathsByFileUID) ExpectK1Param2(k1 types.KBUIDType) *mServiceMockGetTextChunkFilePathsByFileUID {
	if mmGetTextChunkFilePathsByFileUID.mock.funcGetTextChunkFilePathsByFileUID != nil {
		mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetTextChunkFilePathsByFileUID mock is already set by Set")
	}

	if mmGetTextChunkFilePathsByFileUID.defaultExpectation == nil {
		mmGetTextChunkFilePathsByFileUID.defaultExpectation = &ServiceMockGetTextChunkFilePathsByFileUIDExpectation{}
	}

	if mmGetTextChunkFilePathsByFileUID.defaultExpectation.params != nil {
		mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetTextChunkFilePathsByFileUID mock is already set by Expect")
	}

	if mmGetTextChunkFilePathsByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetTextChunkFilePathsByFileUID.defaultExpectation.paramPtrs = &ServiceMockGetTextChunkFilePathsByFileUIDParamPtrs{}
	}
	mmGetTextChunkFilePathsByFileUID.defaultExpectation.paramPtrs.k1 = &k1
	mmGetTextChunkFilePathsByFileUID.defaultExpectation.expectationOrigins.originK1 = minimock.CallerInfo(1)

	return mmGetTextChunkFilePathsByFileUID
}

// ExpectF1Param3 sets up expected param f1 for Service.GetTextChunkFilePathsByFileUID
func (mmGetTextChunkFilePathsByFileUID *mServiceMockGetTextChunkFilePathsByFileUID) ExpectF1Param3(f1 types.FileUIDType) *mServiceMockGetTextChunkFilePathsByFileUID {
	if mmGetTextChunkFilePathsByFileUID.mock.funcGetTextChunkFilePathsByFileUID != nil {
		mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetTextChunkFilePathsByFileUID mock is already set by Set")
	}

	if mmGetTextChunkFilePathsByFileUID.defaultExpectation == nil {
		mmGetTextChunkFilePathsByFileUID.defaultExpectation = &ServiceMockGetTextChunkFilePathsByFileUIDExpectation{}
	}

	if mmGetTextChunkFilePathsByFileUID.defaultExpectation.params != nil {
		mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetTextChunkFilePathsByFileUID mock is already set by Expect")
	}

	if mmGetTextChunkFilePathsByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetTextChunkFilePathsByFileUID.defaultExpectation.paramPtrs = &ServiceMockGetTextChunkFilePathsByFileUIDParamPtrs{}
	}
	mmGetTextChunkFilePathsByFileUID.defaultExpectation.paramPtrs.f1 = &f1
	mmGetTextChunkFilePathsByFileUID.defaultExpectation.expectationOrigins.originF1 = minimock.CallerInfo(1)

	return mmGetTextChunkFilePathsByFileUID
}

// Inspect accepts an inspector function that has same arguments as the Service.GetTextChunkFilePathsByFileUID
func (mmGetTextChunkFilePathsByFileUID *mServiceMockGetTextChunkFilePathsByFileUID) Inspect(f func(ctx context.Context, k1 types.KBUIDType, f1 types.FileUIDType)) *mServiceMockGetTextChunkFilePathsByFileUID {
	if mmGetTextChunkFilePathsByFileUID.mock.inspectFuncGetTextChunkFilePathsByFileUID != nil {
		mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetTextChunkFilePathsByFileUID")
	}

	mmGetTextChunkFilePathsByFileUID.mock.inspectFuncGetTextChunkFilePathsByFileUID = f

	return mmGetTextChunkFilePathsByFileUID
}

// Return sets up results that will be returned by Service.GetTextChunkFilePathsByFileUID
func (mmGetTextChunkFilePathsByFileUID *mServiceMockGetTextChunkFilePathsByFileUID) Return(sa1 []string, err error) *ServiceMock {
	if mmGetTextChunkFilePathsByFileUID.mock.funcGetTextChunkFilePathsByFileUID != nil {
		mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetTextChunkFilePathsByFileUID mock is already set by Set")
	}

	if mmGetTextChunkFilePathsByFileUID.defaultExpectation == nil {
		mmGetTextChunkFilePathsByFileUID.defaultExpectation = &ServiceMockGetTextChunkFilePathsByFileUIDExpectation{mock: mmGetTextChunkFilePathsByFileUID.mock}
	}
	mmGetTextChunkFilePathsByFileUID.defaultExpectation.results = &ServiceMockGetTextChunkFilePathsByFileUIDResults{sa1, err}
	mmGetTextChunkFilePathsByFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetTextChunkFilePathsByFileUID.mock
}

// Set uses given function f to mock the Service.GetTextChunkFilePathsByFileUID method
func (mmGetTextChunkFilePathsByFileUID *mServiceMockGetTextChunkFilePathsByFileUID) Set(f func(ctx context.Context, k1 types.KBUIDType, f1 types.FileUIDType) (sa1 []string, err error)) *ServiceMock {
	if mmGetTextChunkFilePathsByFileUID.defaultExpectation != nil {
		mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("Default expectation is already set for the Service.GetTextChunkFilePathsByFileUID method")
	}

	if len(mmGetTextChunkFilePathsByFileUID.expectations) > 0 {
		mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("Some expectations are already set for the Service.GetTextChunkFilePathsByFileUID method")
	}

	mmGetTextChunkFilePathsByFileUID.mock.funcGetTextChunkFilePathsByFileUID = f
	mmGetTextChunkFilePathsByFileUID.mock.funcGetTextChunkFilePathsByFileUIDOrigin = minimock.CallerInfo(1)
	return mmGetTextChunkFilePathsByFileUID.mock
}

// When sets expectation for the Service.GetTextChunkFilePathsByFileUID which will trigger the result defined by the following
// Then helper
func (mmGetTextChunkFilePathsByFileUID *mServiceMockGetTextChunkFilePathsByFileUID) When(ctx context.Context, k1 types.KBUIDType, f1 types.FileUIDType) *ServiceMockGetTextChunkFilePathsByFileUIDExpectation {
	if mmGetTextChunkFilePathsByFileUID.mock.funcGetTextChunkFilePathsByFileUID != nil {
		mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetTextChunkFilePathsByFileUID mock is already set by Set")
	}

	expectation := &ServiceMockGetTextChunkFilePathsByFileUIDExpectation{
		mock:               mmGetTextChunkFilePathsByFileUID.mock,
		params:             &ServiceMockGetTextChunkFilePathsByFileUIDParams{ctx, k1, f1},
		expectationOrigins: ServiceMockGetTextChunkFilePathsByFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetTextChunkFilePathsByFileUID.expectations = append(mmGetTextChunkFilePathsByFileUID.expectations, expectation)
	return expectation
}

// Then sets up Service.GetTextChunkFilePathsByFileUID return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetTextChunkFilePathsByFileUIDExpectation) Then(sa1 []string, err error) *ServiceMock {
	e.results = &ServiceMockGetTextChunkFilePathsByFileUIDResults{sa1, err}
	return e.mock
}

// Times sets number of times Service.GetTextChunkFilePathsByFileUID should be invoked
func (mmGetTextChunkFilePathsByFileUID *mServiceMockGetTextChunkFilePathsByFileUID) Times(n uint64) *mServiceMockGetTextChunkFilePathsByFileUID {
	if n == 0 {
		mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("Times of ServiceMock.GetTextChunkFilePathsByFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTextChunkFilePathsByFileUID.expectedInvocations, n)
	mmGetTextChunkFilePathsByFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetTextChunkFilePathsByFileUID
}

func (mmGetTextChunkFilePathsByFileUID *mServiceMockGetTextChunkFilePathsByFileUID) invocationsDone() bool {
	if len(mmGetTextChunkFilePathsByFileUID.expectations) == 0 && mmGetTextChunkFilePathsByFileUID.defaultExpectation == nil && mmGetTextChunkFilePathsByFileUID.mock.funcGetTextChunkFilePathsByFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTextChunkFilePathsByFileUID.mock.afterGetTextChunkFilePathsByFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTextChunkFilePathsByFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTextChunkFilePathsByFileUID implements mm_service.Service
func (mmGetTextChunkFilePathsByFileUID *ServiceMock) GetTextChunkFilePathsByFileUID(ctx context.Context, k1 types.KBUIDType, f1 types.FileUIDType) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmGetTextChunkFilePathsByFileUID.beforeGetTextChunkFilePathsByFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTextChunkFilePathsByFileUID.afterGetTextChunkFilePathsByFileUIDCounter, 1)

	mmGetTextChunkFilePathsByFileUID.t.Helper()

	if mmGetTextChunkFilePathsByFileUID.inspectFuncGetTextChunkFilePathsByFileUID != nil {
		mmGetTextChunkFilePathsByFileUID.inspectFuncGetTextChunkFilePathsByFileUID(ctx, k1, f1)
	}

	mm_params := ServiceMockGetTextChunkFilePathsByFileUIDParams{ctx, k1, f1}

	// Record call args
	mmGetTextChunkFilePathsByFileUID.GetTextChunkFilePathsByFileUIDMock.mutex.Lock()
	mmGetTextChunkFilePathsByFileUID.GetTextChunkFilePathsByFileUIDMock.callArgs = append(mmGetTextChunkFilePathsByFileUID.GetTextChunkFilePathsByFileUIDMock.callArgs, &mm_params)
	mmGetTextChunkFilePathsByFileUID.GetTextChunkFilePathsByFileUIDMock.mutex.Unlock()

	for _, e := range mmGetTextChunkFilePathsByFileUID.GetTextChunkFilePathsByFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmGetTextChunkFilePathsByFileUID.GetTextChunkFilePathsByFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTextChunkFilePathsByFileUID.GetTextChunkFilePathsByFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTextChunkFilePathsByFileUID.GetTextChunkFilePathsByFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetTextChunkFilePathsByFileUID.GetTextChunkFilePathsByFileUIDMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetTextChunkFilePathsByFileUIDParams{ctx, k1, f1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTextChunkFilePathsByFileUID.t.Errorf("ServiceMock.GetTextChunkFilePathsByFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTextChunkFilePathsByFileUID.GetTextChunkFilePathsByFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.k1 != nil && !minimock.Equal(*mm_want_ptrs.k1, mm_got.k1) {
				mmGetTextChunkFilePathsByFileUID.t.Errorf("ServiceMock.GetTextChunkFilePathsByFileUID got unexpected parameter k1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTextChunkFilePathsByFileUID.GetTextChunkFilePathsByFileUIDMock.defaultExpectation.expectationOrigins.originK1, *mm_want_ptrs.k1, mm_got.k1, minimock.Diff(*mm_want_ptrs.k1, mm_got.k1))
			}

			if mm_want_ptrs.f1 != nil && !minimock.Equal(*mm_want_ptrs.f1, mm_got.f1) {
				mmGetTextChunkFilePathsByFileUID.t.Errorf("ServiceMock.GetTextChunkFilePathsByFileUID got unexpected parameter f1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTextChunkFilePathsByFileUID.GetTextChunkFilePathsByFileUIDMock.defaultExpectation.expectationOrigins.originF1, *mm_want_ptrs.f1, mm_got.f1, minimock.Diff(*mm_want_ptrs.f1, mm_got.f1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTextChunkFilePathsByFileUID.t.Errorf("ServiceMock.GetTextChunkFilePathsByFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetTextChunkFilePathsByFileUID.GetTextChunkFilePathsByFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTextChunkFilePathsByFileUID.GetTextChunkFilePathsByFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTextChunkFilePathsByFileUID.t.Fatal("No results are set for the ServiceMock.GetTextChunkFilePathsByFileUID")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmGetTextChunkFilePathsByFileUID.funcGetTextChunkFilePathsByFileUID != nil {
		return mmGetTextChunkFilePathsByFileUID.funcGetTextChunkFilePathsByFileUID(ctx, k1, f1)
	}
	mmGetTextChunkFilePathsByFileUID.t.Fatalf("Unexpected call to ServiceMock.GetTextChunkFilePathsByFileUID. %v %v %v", ctx, k1, f1)
	return
}

// GetTextChunkFilePathsByFileUIDAfterCounter returns a count of finished ServiceMock.GetTextChunkFilePathsByFileUID invocations
func (mmGetTextChunkFilePathsByFileUID *ServiceMock) GetTextChunkFilePathsByFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTextChunkFilePathsByFileUID.afterGetTextChunkFilePathsByFileUIDCounter)
}

// GetTextChunkFilePathsByFileUIDBeforeCounter returns a count of ServiceMock.GetTextChunkFilePathsByFileUID invocations
func (mmGetTextChunkFilePathsByFileUID *ServiceMock) GetTextChunkFilePathsByFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTextChunkFilePathsByFileUID.beforeGetTextChunkFilePathsByFileUIDCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetTextChunkFilePathsByFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTextChunkFilePathsByFileUID *mServiceMockGetTextChunkFilePathsByFileUID) Calls() []*ServiceMockGetTextChunkFilePathsByFileUIDParams {
	mmGetTextChunkFilePathsByFileUID.mutex.RLock()

	argCopy := make([]*ServiceMockGetTextChunkFilePathsByFileUIDParams, len(mmGetTextChunkFilePathsByFileUID.callArgs))
	copy(argCopy, mmGetTextChunkFilePathsByFileUID.callArgs)

	mmGetTextChunkFilePathsByFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetTextChunkFilePathsByFileUIDDone returns true if the count of the GetTextChunkFilePathsByFileUID invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetTextChunkFilePathsByFileUIDDone() bool {
	if m.GetTextChunkFilePathsByFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetTextChunkFilePathsByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTextChunkFilePathsByFileUIDMock.invocationsDone()
}

// MinimockGetTextChunkFilePathsByFileUIDInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetTextChunkFilePathsByFileUIDInspect() {
	for _, e := range m.GetTextChunkFilePathsByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetTextChunkFilePathsByFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetTextChunkFilePathsByFileUIDCounter := mm_atomic.LoadUint64(&m.afterGetTextChunkFilePathsByFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTextChunkFilePathsByFileUIDMock.defaultExpectation != nil && afterGetTextChunkFilePathsByFileUIDCounter < 1 {
		if m.GetTextChunkFilePathsByFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetTextChunkFilePathsByFileUID at\n%s", m.GetTextChunkFilePathsByFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetTextChunkFilePathsByFileUID at\n%s with params: %#v", m.GetTextChunkFilePathsByFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetTextChunkFilePathsByFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTextChunkFilePathsByFileUID != nil && afterGetTextChunkFilePathsByFileUIDCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetTextChunkFilePathsByFileUID at\n%s", m.funcGetTextChunkFilePathsByFileUIDOrigin)
	}

	if !m.GetTextChunkFilePathsByFileUIDMock.invocationsDone() && afterGetTextChunkFilePathsByFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetTextChunkFilePathsByFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetTextChunkFilePathsByFileUIDMock.expectedInvocations), m.GetTextChunkFilePathsByFileUIDMock.expectedInvocationsOrigin, afterGetTextChunkFilePathsByFileUIDCounter)
	}
}

type mServiceMockGetUploadURL struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetUploadURLExpectation
	expectations       []*ServiceMockGetUploadURLExpectation

	callArgs []*ServiceMockGetUploadURLParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetUploadURLExpectation specifies expectation struct of the Service.GetUploadURL
type ServiceMockGetUploadURLExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetUploadURLParams
	paramPtrs          *ServiceMockGetUploadURLParamPtrs
	expectationOrigins ServiceMockGetUploadURLExpectationOrigins
	results            *ServiceMockGetUploadURLResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetUploadURLParams contains parameters of the Service.GetUploadURL
type ServiceMockGetUploadURLParams struct {
	ctx context.Context
	gp1 *artifactpb.GetObjectUploadURLRequest
	n1  types.NamespaceUIDType
	s1  string
	c2  types.CreatorUIDType
}

// ServiceMockGetUploadURLParamPtrs contains pointers to parameters of the Service.GetUploadURL
type ServiceMockGetUploadURLParamPtrs struct {
	ctx *context.Context
	gp1 **artifactpb.GetObjectUploadURLRequest
	n1  *types.NamespaceUIDType
	s1  *string
	c2  *types.CreatorUIDType
}

// ServiceMockGetUploadURLResults contains results of the Service.GetUploadURL
type ServiceMockGetUploadURLResults struct {
	gp2 *artifactpb.GetObjectUploadURLResponse
	err error
}

// ServiceMockGetUploadURLOrigins contains origins of expectations of the Service.GetUploadURL
type ServiceMockGetUploadURLExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
	originN1  string
	originS1  string
	originC2  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUploadURL *mServiceMockGetUploadURL) Optional() *mServiceMockGetUploadURL {
	mmGetUploadURL.optional = true
	return mmGetUploadURL
}

// Expect sets up expected params for Service.GetUploadURL
func (mmGetUploadURL *mServiceMockGetUploadURL) Expect(ctx context.Context, gp1 *artifactpb.GetObjectUploadURLRequest, n1 types.NamespaceUIDType, s1 string, c2 types.CreatorUIDType) *mServiceMockGetUploadURL {
	if mmGetUploadURL.mock.funcGetUploadURL != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Set")
	}

	if mmGetUploadURL.defaultExpectation == nil {
		mmGetUploadURL.defaultExpectation = &ServiceMockGetUploadURLExpectation{}
	}

	if mmGetUploadURL.defaultExpectation.paramPtrs != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by ExpectParams functions")
	}

	mmGetUploadURL.defaultExpectation.params = &ServiceMockGetUploadURLParams{ctx, gp1, n1, s1, c2}
	mmGetUploadURL.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUploadURL.expectations {
		if minimock.Equal(e.params, mmGetUploadURL.defaultExpectation.params) {
			mmGetUploadURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUploadURL.defaultExpectation.params)
		}
	}

	return mmGetUploadURL
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetUploadURL
func (mmGetUploadURL *mServiceMockGetUploadURL) ExpectCtxParam1(ctx context.Context) *mServiceMockGetUploadURL {
	if mmGetUploadURL.mock.funcGetUploadURL != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Set")
	}

	if mmGetUploadURL.defaultExpectation == nil {
		mmGetUploadURL.defaultExpectation = &ServiceMockGetUploadURLExpectation{}
	}

	if mmGetUploadURL.defaultExpectation.params != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Expect")
	}

	if mmGetUploadURL.defaultExpectation.paramPtrs == nil {
		mmGetUploadURL.defaultExpectation.paramPtrs = &ServiceMockGetUploadURLParamPtrs{}
	}
	mmGetUploadURL.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUploadURL.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUploadURL
}

// ExpectGp1Param2 sets up expected param gp1 for Service.GetUploadURL
func (mmGetUploadURL *mServiceMockGetUploadURL) ExpectGp1Param2(gp1 *artifactpb.GetObjectUploadURLRequest) *mServiceMockGetUploadURL {
	if mmGetUploadURL.mock.funcGetUploadURL != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Set")
	}

	if mmGetUploadURL.defaultExpectation == nil {
		mmGetUploadURL.defaultExpectation = &ServiceMockGetUploadURLExpectation{}
	}

	if mmGetUploadURL.defaultExpectation.params != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Expect")
	}

	if mmGetUploadURL.defaultExpectation.paramPtrs == nil {
		mmGetUploadURL.defaultExpectation.paramPtrs = &ServiceMockGetUploadURLParamPtrs{}
	}
	mmGetUploadURL.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetUploadURL.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetUploadURL
}

// ExpectN1Param3 sets up expected param n1 for Service.GetUploadURL
func (mmGetUploadURL *mServiceMockGetUploadURL) ExpectN1Param3(n1 types.NamespaceUIDType) *mServiceMockGetUploadURL {
	if mmGetUploadURL.mock.funcGetUploadURL != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Set")
	}

	if mmGetUploadURL.defaultExpectation == nil {
		mmGetUploadURL.defaultExpectation = &ServiceMockGetUploadURLExpectation{}
	}

	if mmGetUploadURL.defaultExpectation.params != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Expect")
	}

	if mmGetUploadURL.defaultExpectation.paramPtrs == nil {
		mmGetUploadURL.defaultExpectation.paramPtrs = &ServiceMockGetUploadURLParamPtrs{}
	}
	mmGetUploadURL.defaultExpectation.paramPtrs.n1 = &n1
	mmGetUploadURL.defaultExpectation.expectationOrigins.originN1 = minimock.CallerInfo(1)

	return mmGetUploadURL
}

// ExpectS1Param4 sets up expected param s1 for Service.GetUploadURL
func (mmGetUploadURL *mServiceMockGetUploadURL) ExpectS1Param4(s1 string) *mServiceMockGetUploadURL {
	if mmGetUploadURL.mock.funcGetUploadURL != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Set")
	}

	if mmGetUploadURL.defaultExpectation == nil {
		mmGetUploadURL.defaultExpectation = &ServiceMockGetUploadURLExpectation{}
	}

	if mmGetUploadURL.defaultExpectation.params != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Expect")
	}

	if mmGetUploadURL.defaultExpectation.paramPtrs == nil {
		mmGetUploadURL.defaultExpectation.paramPtrs = &ServiceMockGetUploadURLParamPtrs{}
	}
	mmGetUploadURL.defaultExpectation.paramPtrs.s1 = &s1
	mmGetUploadURL.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmGetUploadURL
}

// ExpectC2Param5 sets up expected param c2 for Service.GetUploadURL
func (mmGetUploadURL *mServiceMockGetUploadURL) ExpectC2Param5(c2 types.CreatorUIDType) *mServiceMockGetUploadURL {
	if mmGetUploadURL.mock.funcGetUploadURL != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Set")
	}

	if mmGetUploadURL.defaultExpectation == nil {
		mmGetUploadURL.defaultExpectation = &ServiceMockGetUploadURLExpectation{}
	}

	if mmGetUploadURL.defaultExpectation.params != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Expect")
	}

	if mmGetUploadURL.defaultExpectation.paramPtrs == nil {
		mmGetUploadURL.defaultExpectation.paramPtrs = &ServiceMockGetUploadURLParamPtrs{}
	}
	mmGetUploadURL.defaultExpectation.paramPtrs.c2 = &c2
	mmGetUploadURL.defaultExpectation.expectationOrigins.originC2 = minimock.CallerInfo(1)

	return mmGetUploadURL
}

// Inspect accepts an inspector function that has same arguments as the Service.GetUploadURL
func (mmGetUploadURL *mServiceMockGetUploadURL) Inspect(f func(ctx context.Context, gp1 *artifactpb.GetObjectUploadURLRequest, n1 types.NamespaceUIDType, s1 string, c2 types.CreatorUIDType)) *mServiceMockGetUploadURL {
	if mmGetUploadURL.mock.inspectFuncGetUploadURL != nil {
		mmGetUploadURL.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetUploadURL")
	}

	mmGetUploadURL.mock.inspectFuncGetUploadURL = f

	return mmGetUploadURL
}

// Return sets up results that will be returned by Service.GetUploadURL
func (mmGetUploadURL *mServiceMockGetUploadURL) Return(gp2 *artifactpb.GetObjectUploadURLResponse, err error) *ServiceMock {
	if mmGetUploadURL.mock.funcGetUploadURL != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Set")
	}

	if mmGetUploadURL.defaultExpectation == nil {
		mmGetUploadURL.defaultExpectation = &ServiceMockGetUploadURLExpectation{mock: mmGetUploadURL.mock}
	}
	mmGetUploadURL.defaultExpectation.results = &ServiceMockGetUploadURLResults{gp2, err}
	mmGetUploadURL.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUploadURL.mock
}

// Set uses given function f to mock the Service.GetUploadURL method
func (mmGetUploadURL *mServiceMockGetUploadURL) Set(f func(ctx context.Context, gp1 *artifactpb.GetObjectUploadURLRequest, n1 types.NamespaceUIDType, s1 string, c2 types.CreatorUIDType) (gp2 *artifactpb.GetObjectUploadURLResponse, err error)) *ServiceMock {
	if mmGetUploadURL.defaultExpectation != nil {
		mmGetUploadURL.mock.t.Fatalf("Default expectation is already set for the Service.GetUploadURL method")
	}

	if len(mmGetUploadURL.expectations) > 0 {
		mmGetUploadURL.mock.t.Fatalf("Some expectations are already set for the Service.GetUploadURL method")
	}

	mmGetUploadURL.mock.funcGetUploadURL = f
	mmGetUploadURL.mock.funcGetUploadURLOrigin = minimock.CallerInfo(1)
	return mmGetUploadURL.mock
}

// When sets expectation for the Service.GetUploadURL which will trigger the result defined by the following
// Then helper
func (mmGetUploadURL *mServiceMockGetUploadURL) When(ctx context.Context, gp1 *artifactpb.GetObjectUploadURLRequest, n1 types.NamespaceUIDType, s1 string, c2 types.CreatorUIDType) *ServiceMockGetUploadURLExpectation {
	if mmGetUploadURL.mock.funcGetUploadURL != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Set")
	}

	expectation := &ServiceMockGetUploadURLExpectation{
		mock:               mmGetUploadURL.mock,
		params:             &ServiceMockGetUploadURLParams{ctx, gp1, n1, s1, c2},
		expectationOrigins: ServiceMockGetUploadURLExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUploadURL.expectations = append(mmGetUploadURL.expectations, expectation)
	return expectation
}

// Then sets up Service.GetUploadURL return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetUploadURLExpectation) Then(gp2 *artifactpb.GetObjectUploadURLResponse, err error) *ServiceMock {
	e.results = &ServiceMockGetUploadURLResults{gp2, err}
	return e.mock
}

// Times sets number of times Service.GetUploadURL should be invoked
func (mmGetUploadURL *mServiceMockGetUploadURL) Times(n uint64) *mServiceMockGetUploadURL {
	if n == 0 {
		mmGetUploadURL.mock.t.Fatalf("Times of ServiceMock.GetUploadURL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUploadURL.expectedInvocations, n)
	mmGetUploadURL.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUploadURL
}

func (mmGetUploadURL *mServiceMockGetUploadURL) invocationsDone() bool {
	if len(mmGetUploadURL.expectations) == 0 && mmGetUploadURL.defaultExpectation == nil && mmGetUploadURL.mock.funcGetUploadURL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUploadURL.mock.afterGetUploadURLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUploadURL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUploadURL implements mm_service.Service
func (mmGetUploadURL *ServiceMock) GetUploadURL(ctx context.Context, gp1 *artifactpb.GetObjectUploadURLRequest, n1 types.NamespaceUIDType, s1 string, c2 types.CreatorUIDType) (gp2 *artifactpb.GetObjectUploadURLResponse, err error) {
	mm_atomic.AddUint64(&mmGetUploadURL.beforeGetUploadURLCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUploadURL.afterGetUploadURLCounter, 1)

	mmGetUploadURL.t.Helper()

	if mmGetUploadURL.inspectFuncGetUploadURL != nil {
		mmGetUploadURL.inspectFuncGetUploadURL(ctx, gp1, n1, s1, c2)
	}

	mm_params := ServiceMockGetUploadURLParams{ctx, gp1, n1, s1, c2}

	// Record call args
	mmGetUploadURL.GetUploadURLMock.mutex.Lock()
	mmGetUploadURL.GetUploadURLMock.callArgs = append(mmGetUploadURL.GetUploadURLMock.callArgs, &mm_params)
	mmGetUploadURL.GetUploadURLMock.mutex.Unlock()

	for _, e := range mmGetUploadURL.GetUploadURLMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetUploadURL.GetUploadURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUploadURL.GetUploadURLMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUploadURL.GetUploadURLMock.defaultExpectation.params
		mm_want_ptrs := mmGetUploadURL.GetUploadURLMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetUploadURLParams{ctx, gp1, n1, s1, c2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUploadURL.t.Errorf("ServiceMock.GetUploadURL got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUploadURL.GetUploadURLMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetUploadURL.t.Errorf("ServiceMock.GetUploadURL got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUploadURL.GetUploadURLMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

			if mm_want_ptrs.n1 != nil && !minimock.Equal(*mm_want_ptrs.n1, mm_got.n1) {
				mmGetUploadURL.t.Errorf("ServiceMock.GetUploadURL got unexpected parameter n1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUploadURL.GetUploadURLMock.defaultExpectation.expectationOrigins.originN1, *mm_want_ptrs.n1, mm_got.n1, minimock.Diff(*mm_want_ptrs.n1, mm_got.n1))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmGetUploadURL.t.Errorf("ServiceMock.GetUploadURL got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUploadURL.GetUploadURLMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

			if mm_want_ptrs.c2 != nil && !minimock.Equal(*mm_want_ptrs.c2, mm_got.c2) {
				mmGetUploadURL.t.Errorf("ServiceMock.GetUploadURL got unexpected parameter c2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUploadURL.GetUploadURLMock.defaultExpectation.expectationOrigins.originC2, *mm_want_ptrs.c2, mm_got.c2, minimock.Diff(*mm_want_ptrs.c2, mm_got.c2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUploadURL.t.Errorf("ServiceMock.GetUploadURL got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUploadURL.GetUploadURLMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUploadURL.GetUploadURLMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUploadURL.t.Fatal("No results are set for the ServiceMock.GetUploadURL")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetUploadURL.funcGetUploadURL != nil {
		return mmGetUploadURL.funcGetUploadURL(ctx, gp1, n1, s1, c2)
	}
	mmGetUploadURL.t.Fatalf("Unexpected call to ServiceMock.GetUploadURL. %v %v %v %v %v", ctx, gp1, n1, s1, c2)
	return
}

// GetUploadURLAfterCounter returns a count of finished ServiceMock.GetUploadURL invocations
func (mmGetUploadURL *ServiceMock) GetUploadURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUploadURL.afterGetUploadURLCounter)
}

// GetUploadURLBeforeCounter returns a count of ServiceMock.GetUploadURL invocations
func (mmGetUploadURL *ServiceMock) GetUploadURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUploadURL.beforeGetUploadURLCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetUploadURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUploadURL *mServiceMockGetUploadURL) Calls() []*ServiceMockGetUploadURLParams {
	mmGetUploadURL.mutex.RLock()

	argCopy := make([]*ServiceMockGetUploadURLParams, len(mmGetUploadURL.callArgs))
	copy(argCopy, mmGetUploadURL.callArgs)

	mmGetUploadURL.mutex.RUnlock()

	return argCopy
}

// MinimockGetUploadURLDone returns true if the count of the GetUploadURL invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetUploadURLDone() bool {
	if m.GetUploadURLMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUploadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUploadURLMock.invocationsDone()
}

// MinimockGetUploadURLInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetUploadURLInspect() {
	for _, e := range m.GetUploadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetUploadURL at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUploadURLCounter := mm_atomic.LoadUint64(&m.afterGetUploadURLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUploadURLMock.defaultExpectation != nil && afterGetUploadURLCounter < 1 {
		if m.GetUploadURLMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetUploadURL at\n%s", m.GetUploadURLMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetUploadURL at\n%s with params: %#v", m.GetUploadURLMock.defaultExpectation.expectationOrigins.origin, *m.GetUploadURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUploadURL != nil && afterGetUploadURLCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetUploadURL at\n%s", m.funcGetUploadURLOrigin)
	}

	if !m.GetUploadURLMock.invocationsDone() && afterGetUploadURLCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetUploadURL at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUploadURLMock.expectedInvocations), m.GetUploadURLMock.expectedInvocationsOrigin, afterGetUploadURLCounter)
	}
}

type mServiceMockListRepositoryTags struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockListRepositoryTagsExpectation
	expectations       []*ServiceMockListRepositoryTagsExpectation

	callArgs []*ServiceMockListRepositoryTagsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockListRepositoryTagsExpectation specifies expectation struct of the Service.ListRepositoryTags
type ServiceMockListRepositoryTagsExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockListRepositoryTagsParams
	paramPtrs          *ServiceMockListRepositoryTagsParamPtrs
	expectationOrigins ServiceMockListRepositoryTagsExpectationOrigins
	results            *ServiceMockListRepositoryTagsResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockListRepositoryTagsParams contains parameters of the Service.ListRepositoryTags
type ServiceMockListRepositoryTagsParams struct {
	ctx context.Context
	lp1 *artifactpb.ListRepositoryTagsRequest
}

// ServiceMockListRepositoryTagsParamPtrs contains pointers to parameters of the Service.ListRepositoryTags
type ServiceMockListRepositoryTagsParamPtrs struct {
	ctx *context.Context
	lp1 **artifactpb.ListRepositoryTagsRequest
}

// ServiceMockListRepositoryTagsResults contains results of the Service.ListRepositoryTags
type ServiceMockListRepositoryTagsResults struct {
	lp2 *artifactpb.ListRepositoryTagsResponse
	err error
}

// ServiceMockListRepositoryTagsOrigins contains origins of expectations of the Service.ListRepositoryTags
type ServiceMockListRepositoryTagsExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListRepositoryTags *mServiceMockListRepositoryTags) Optional() *mServiceMockListRepositoryTags {
	mmListRepositoryTags.optional = true
	return mmListRepositoryTags
}

// Expect sets up expected params for Service.ListRepositoryTags
func (mmListRepositoryTags *mServiceMockListRepositoryTags) Expect(ctx context.Context, lp1 *artifactpb.ListRepositoryTagsRequest) *mServiceMockListRepositoryTags {
	if mmListRepositoryTags.mock.funcListRepositoryTags != nil {
		mmListRepositoryTags.mock.t.Fatalf("ServiceMock.ListRepositoryTags mock is already set by Set")
	}

	if mmListRepositoryTags.defaultExpectation == nil {
		mmListRepositoryTags.defaultExpectation = &ServiceMockListRepositoryTagsExpectation{}
	}

	if mmListRepositoryTags.defaultExpectation.paramPtrs != nil {
		mmListRepositoryTags.mock.t.Fatalf("ServiceMock.ListRepositoryTags mock is already set by ExpectParams functions")
	}

	mmListRepositoryTags.defaultExpectation.params = &ServiceMockListRepositoryTagsParams{ctx, lp1}
	mmListRepositoryTags.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListRepositoryTags.expectations {
		if minimock.Equal(e.params, mmListRepositoryTags.defaultExpectation.params) {
			mmListRepositoryTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListRepositoryTags.defaultExpectation.params)
		}
	}

	return mmListRepositoryTags
}

// ExpectCtxParam1 sets up expected param ctx for Service.ListRepositoryTags
func (mmListRepositoryTags *mServiceMockListRepositoryTags) ExpectCtxParam1(ctx context.Context) *mServiceMockListRepositoryTags {
	if mmListRepositoryTags.mock.funcListRepositoryTags != nil {
		mmListRepositoryTags.mock.t.Fatalf("ServiceMock.ListRepositoryTags mock is already set by Set")
	}

	if mmListRepositoryTags.defaultExpectation == nil {
		mmListRepositoryTags.defaultExpectation = &ServiceMockListRepositoryTagsExpectation{}
	}

	if mmListRepositoryTags.defaultExpectation.params != nil {
		mmListRepositoryTags.mock.t.Fatalf("ServiceMock.ListRepositoryTags mock is already set by Expect")
	}

	if mmListRepositoryTags.defaultExpectation.paramPtrs == nil {
		mmListRepositoryTags.defaultExpectation.paramPtrs = &ServiceMockListRepositoryTagsParamPtrs{}
	}
	mmListRepositoryTags.defaultExpectation.paramPtrs.ctx = &ctx
	mmListRepositoryTags.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListRepositoryTags
}

// ExpectLp1Param2 sets up expected param lp1 for Service.ListRepositoryTags
func (mmListRepositoryTags *mServiceMockListRepositoryTags) ExpectLp1Param2(lp1 *artifactpb.ListRepositoryTagsRequest) *mServiceMockListRepositoryTags {
	if mmListRepositoryTags.mock.funcListRepositoryTags != nil {
		mmListRepositoryTags.mock.t.Fatalf("ServiceMock.ListRepositoryTags mock is already set by Set")
	}

	if mmListRepositoryTags.defaultExpectation == nil {
		mmListRepositoryTags.defaultExpectation = &ServiceMockListRepositoryTagsExpectation{}
	}

	if mmListRepositoryTags.defaultExpectation.params != nil {
		mmListRepositoryTags.mock.t.Fatalf("ServiceMock.ListRepositoryTags mock is already set by Expect")
	}

	if mmListRepositoryTags.defaultExpectation.paramPtrs == nil {
		mmListRepositoryTags.defaultExpectation.paramPtrs = &ServiceMockListRepositoryTagsParamPtrs{}
	}
	mmListRepositoryTags.defaultExpectation.paramPtrs.lp1 = &lp1
	mmListRepositoryTags.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmListRepositoryTags
}

// Inspect accepts an inspector function that has same arguments as the Service.ListRepositoryTags
func (mmListRepositoryTags *mServiceMockListRepositoryTags) Inspect(f func(ctx context.Context, lp1 *artifactpb.ListRepositoryTagsRequest)) *mServiceMockListRepositoryTags {
	if mmListRepositoryTags.mock.inspectFuncListRepositoryTags != nil {
		mmListRepositoryTags.mock.t.Fatalf("Inspect function is already set for ServiceMock.ListRepositoryTags")
	}

	mmListRepositoryTags.mock.inspectFuncListRepositoryTags = f

	return mmListRepositoryTags
}

// Return sets up results that will be returned by Service.ListRepositoryTags
func (mmListRepositoryTags *mServiceMockListRepositoryTags) Return(lp2 *artifactpb.ListRepositoryTagsResponse, err error) *ServiceMock {
	if mmListRepositoryTags.mock.funcListRepositoryTags != nil {
		mmListRepositoryTags.mock.t.Fatalf("ServiceMock.ListRepositoryTags mock is already set by Set")
	}

	if mmListRepositoryTags.defaultExpectation == nil {
		mmListRepositoryTags.defaultExpectation = &ServiceMockListRepositoryTagsExpectation{mock: mmListRepositoryTags.mock}
	}
	mmListRepositoryTags.defaultExpectation.results = &ServiceMockListRepositoryTagsResults{lp2, err}
	mmListRepositoryTags.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListRepositoryTags.mock
}

// Set uses given function f to mock the Service.ListRepositoryTags method
func (mmListRepositoryTags *mServiceMockListRepositoryTags) Set(f func(ctx context.Context, lp1 *artifactpb.ListRepositoryTagsRequest) (lp2 *artifactpb.ListRepositoryTagsResponse, err error)) *ServiceMock {
	if mmListRepositoryTags.defaultExpectation != nil {
		mmListRepositoryTags.mock.t.Fatalf("Default expectation is already set for the Service.ListRepositoryTags method")
	}

	if len(mmListRepositoryTags.expectations) > 0 {
		mmListRepositoryTags.mock.t.Fatalf("Some expectations are already set for the Service.ListRepositoryTags method")
	}

	mmListRepositoryTags.mock.funcListRepositoryTags = f
	mmListRepositoryTags.mock.funcListRepositoryTagsOrigin = minimock.CallerInfo(1)
	return mmListRepositoryTags.mock
}

// When sets expectation for the Service.ListRepositoryTags which will trigger the result defined by the following
// Then helper
func (mmListRepositoryTags *mServiceMockListRepositoryTags) When(ctx context.Context, lp1 *artifactpb.ListRepositoryTagsRequest) *ServiceMockListRepositoryTagsExpectation {
	if mmListRepositoryTags.mock.funcListRepositoryTags != nil {
		mmListRepositoryTags.mock.t.Fatalf("ServiceMock.ListRepositoryTags mock is already set by Set")
	}

	expectation := &ServiceMockListRepositoryTagsExpectation{
		mock:               mmListRepositoryTags.mock,
		params:             &ServiceMockListRepositoryTagsParams{ctx, lp1},
		expectationOrigins: ServiceMockListRepositoryTagsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListRepositoryTags.expectations = append(mmListRepositoryTags.expectations, expectation)
	return expectation
}

// Then sets up Service.ListRepositoryTags return parameters for the expectation previously defined by the When method
func (e *ServiceMockListRepositoryTagsExpectation) Then(lp2 *artifactpb.ListRepositoryTagsResponse, err error) *ServiceMock {
	e.results = &ServiceMockListRepositoryTagsResults{lp2, err}
	return e.mock
}

// Times sets number of times Service.ListRepositoryTags should be invoked
func (mmListRepositoryTags *mServiceMockListRepositoryTags) Times(n uint64) *mServiceMockListRepositoryTags {
	if n == 0 {
		mmListRepositoryTags.mock.t.Fatalf("Times of ServiceMock.ListRepositoryTags mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListRepositoryTags.expectedInvocations, n)
	mmListRepositoryTags.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListRepositoryTags
}

func (mmListRepositoryTags *mServiceMockListRepositoryTags) invocationsDone() bool {
	if len(mmListRepositoryTags.expectations) == 0 && mmListRepositoryTags.defaultExpectation == nil && mmListRepositoryTags.mock.funcListRepositoryTags == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListRepositoryTags.mock.afterListRepositoryTagsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListRepositoryTags.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListRepositoryTags implements mm_service.Service
func (mmListRepositoryTags *ServiceMock) ListRepositoryTags(ctx context.Context, lp1 *artifactpb.ListRepositoryTagsRequest) (lp2 *artifactpb.ListRepositoryTagsResponse, err error) {
	mm_atomic.AddUint64(&mmListRepositoryTags.beforeListRepositoryTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmListRepositoryTags.afterListRepositoryTagsCounter, 1)

	mmListRepositoryTags.t.Helper()

	if mmListRepositoryTags.inspectFuncListRepositoryTags != nil {
		mmListRepositoryTags.inspectFuncListRepositoryTags(ctx, lp1)
	}

	mm_params := ServiceMockListRepositoryTagsParams{ctx, lp1}

	// Record call args
	mmListRepositoryTags.ListRepositoryTagsMock.mutex.Lock()
	mmListRepositoryTags.ListRepositoryTagsMock.callArgs = append(mmListRepositoryTags.ListRepositoryTagsMock.callArgs, &mm_params)
	mmListRepositoryTags.ListRepositoryTagsMock.mutex.Unlock()

	for _, e := range mmListRepositoryTags.ListRepositoryTagsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmListRepositoryTags.ListRepositoryTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListRepositoryTags.ListRepositoryTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmListRepositoryTags.ListRepositoryTagsMock.defaultExpectation.params
		mm_want_ptrs := mmListRepositoryTags.ListRepositoryTagsMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockListRepositoryTagsParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListRepositoryTags.t.Errorf("ServiceMock.ListRepositoryTags got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListRepositoryTags.ListRepositoryTagsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmListRepositoryTags.t.Errorf("ServiceMock.ListRepositoryTags got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListRepositoryTags.ListRepositoryTagsMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListRepositoryTags.t.Errorf("ServiceMock.ListRepositoryTags got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListRepositoryTags.ListRepositoryTagsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListRepositoryTags.ListRepositoryTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmListRepositoryTags.t.Fatal("No results are set for the ServiceMock.ListRepositoryTags")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmListRepositoryTags.funcListRepositoryTags != nil {
		return mmListRepositoryTags.funcListRepositoryTags(ctx, lp1)
	}
	mmListRepositoryTags.t.Fatalf("Unexpected call to ServiceMock.ListRepositoryTags. %v %v", ctx, lp1)
	return
}

// ListRepositoryTagsAfterCounter returns a count of finished ServiceMock.ListRepositoryTags invocations
func (mmListRepositoryTags *ServiceMock) ListRepositoryTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListRepositoryTags.afterListRepositoryTagsCounter)
}

// ListRepositoryTagsBeforeCounter returns a count of ServiceMock.ListRepositoryTags invocations
func (mmListRepositoryTags *ServiceMock) ListRepositoryTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListRepositoryTags.beforeListRepositoryTagsCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.ListRepositoryTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListRepositoryTags *mServiceMockListRepositoryTags) Calls() []*ServiceMockListRepositoryTagsParams {
	mmListRepositoryTags.mutex.RLock()

	argCopy := make([]*ServiceMockListRepositoryTagsParams, len(mmListRepositoryTags.callArgs))
	copy(argCopy, mmListRepositoryTags.callArgs)

	mmListRepositoryTags.mutex.RUnlock()

	return argCopy
}

// MinimockListRepositoryTagsDone returns true if the count of the ListRepositoryTags invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockListRepositoryTagsDone() bool {
	if m.ListRepositoryTagsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListRepositoryTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListRepositoryTagsMock.invocationsDone()
}

// MinimockListRepositoryTagsInspect logs each unmet expectation
func (m *ServiceMock) MinimockListRepositoryTagsInspect() {
	for _, e := range m.ListRepositoryTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.ListRepositoryTags at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListRepositoryTagsCounter := mm_atomic.LoadUint64(&m.afterListRepositoryTagsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListRepositoryTagsMock.defaultExpectation != nil && afterListRepositoryTagsCounter < 1 {
		if m.ListRepositoryTagsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.ListRepositoryTags at\n%s", m.ListRepositoryTagsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.ListRepositoryTags at\n%s with params: %#v", m.ListRepositoryTagsMock.defaultExpectation.expectationOrigins.origin, *m.ListRepositoryTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListRepositoryTags != nil && afterListRepositoryTagsCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.ListRepositoryTags at\n%s", m.funcListRepositoryTagsOrigin)
	}

	if !m.ListRepositoryTagsMock.invocationsDone() && afterListRepositoryTagsCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.ListRepositoryTags at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListRepositoryTagsMock.expectedInvocations), m.ListRepositoryTagsMock.expectedInvocationsOrigin, afterListRepositoryTagsCounter)
	}
}

type mServiceMockPipelinePublicClient struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockPipelinePublicClientExpectation
	expectations       []*ServiceMockPipelinePublicClientExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockPipelinePublicClientExpectation specifies expectation struct of the Service.PipelinePublicClient
type ServiceMockPipelinePublicClientExpectation struct {
	mock *ServiceMock

	results      *ServiceMockPipelinePublicClientResults
	returnOrigin string
	Counter      uint64
}

// ServiceMockPipelinePublicClientResults contains results of the Service.PipelinePublicClient
type ServiceMockPipelinePublicClientResults struct {
	p1 pipelinepb.PipelinePublicServiceClient
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPipelinePublicClient *mServiceMockPipelinePublicClient) Optional() *mServiceMockPipelinePublicClient {
	mmPipelinePublicClient.optional = true
	return mmPipelinePublicClient
}

// Expect sets up expected params for Service.PipelinePublicClient
func (mmPipelinePublicClient *mServiceMockPipelinePublicClient) Expect() *mServiceMockPipelinePublicClient {
	if mmPipelinePublicClient.mock.funcPipelinePublicClient != nil {
		mmPipelinePublicClient.mock.t.Fatalf("ServiceMock.PipelinePublicClient mock is already set by Set")
	}

	if mmPipelinePublicClient.defaultExpectation == nil {
		mmPipelinePublicClient.defaultExpectation = &ServiceMockPipelinePublicClientExpectation{}
	}

	return mmPipelinePublicClient
}

// Inspect accepts an inspector function that has same arguments as the Service.PipelinePublicClient
func (mmPipelinePublicClient *mServiceMockPipelinePublicClient) Inspect(f func()) *mServiceMockPipelinePublicClient {
	if mmPipelinePublicClient.mock.inspectFuncPipelinePublicClient != nil {
		mmPipelinePublicClient.mock.t.Fatalf("Inspect function is already set for ServiceMock.PipelinePublicClient")
	}

	mmPipelinePublicClient.mock.inspectFuncPipelinePublicClient = f

	return mmPipelinePublicClient
}

// Return sets up results that will be returned by Service.PipelinePublicClient
func (mmPipelinePublicClient *mServiceMockPipelinePublicClient) Return(p1 pipelinepb.PipelinePublicServiceClient) *ServiceMock {
	if mmPipelinePublicClient.mock.funcPipelinePublicClient != nil {
		mmPipelinePublicClient.mock.t.Fatalf("ServiceMock.PipelinePublicClient mock is already set by Set")
	}

	if mmPipelinePublicClient.defaultExpectation == nil {
		mmPipelinePublicClient.defaultExpectation = &ServiceMockPipelinePublicClientExpectation{mock: mmPipelinePublicClient.mock}
	}
	mmPipelinePublicClient.defaultExpectation.results = &ServiceMockPipelinePublicClientResults{p1}
	mmPipelinePublicClient.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPipelinePublicClient.mock
}

// Set uses given function f to mock the Service.PipelinePublicClient method
func (mmPipelinePublicClient *mServiceMockPipelinePublicClient) Set(f func() (p1 pipelinepb.PipelinePublicServiceClient)) *ServiceMock {
	if mmPipelinePublicClient.defaultExpectation != nil {
		mmPipelinePublicClient.mock.t.Fatalf("Default expectation is already set for the Service.PipelinePublicClient method")
	}

	if len(mmPipelinePublicClient.expectations) > 0 {
		mmPipelinePublicClient.mock.t.Fatalf("Some expectations are already set for the Service.PipelinePublicClient method")
	}

	mmPipelinePublicClient.mock.funcPipelinePublicClient = f
	mmPipelinePublicClient.mock.funcPipelinePublicClientOrigin = minimock.CallerInfo(1)
	return mmPipelinePublicClient.mock
}

// Times sets number of times Service.PipelinePublicClient should be invoked
func (mmPipelinePublicClient *mServiceMockPipelinePublicClient) Times(n uint64) *mServiceMockPipelinePublicClient {
	if n == 0 {
		mmPipelinePublicClient.mock.t.Fatalf("Times of ServiceMock.PipelinePublicClient mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPipelinePublicClient.expectedInvocations, n)
	mmPipelinePublicClient.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPipelinePublicClient
}

func (mmPipelinePublicClient *mServiceMockPipelinePublicClient) invocationsDone() bool {
	if len(mmPipelinePublicClient.expectations) == 0 && mmPipelinePublicClient.defaultExpectation == nil && mmPipelinePublicClient.mock.funcPipelinePublicClient == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPipelinePublicClient.mock.afterPipelinePublicClientCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPipelinePublicClient.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PipelinePublicClient implements mm_service.Service
func (mmPipelinePublicClient *ServiceMock) PipelinePublicClient() (p1 pipelinepb.PipelinePublicServiceClient) {
	mm_atomic.AddUint64(&mmPipelinePublicClient.beforePipelinePublicClientCounter, 1)
	defer mm_atomic.AddUint64(&mmPipelinePublicClient.afterPipelinePublicClientCounter, 1)

	mmPipelinePublicClient.t.Helper()

	if mmPipelinePublicClient.inspectFuncPipelinePublicClient != nil {
		mmPipelinePublicClient.inspectFuncPipelinePublicClient()
	}

	if mmPipelinePublicClient.PipelinePublicClientMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPipelinePublicClient.PipelinePublicClientMock.defaultExpectation.Counter, 1)

		mm_results := mmPipelinePublicClient.PipelinePublicClientMock.defaultExpectation.results
		if mm_results == nil {
			mmPipelinePublicClient.t.Fatal("No results are set for the ServiceMock.PipelinePublicClient")
		}
		return (*mm_results).p1
	}
	if mmPipelinePublicClient.funcPipelinePublicClient != nil {
		return mmPipelinePublicClient.funcPipelinePublicClient()
	}
	mmPipelinePublicClient.t.Fatalf("Unexpected call to ServiceMock.PipelinePublicClient.")
	return
}

// PipelinePublicClientAfterCounter returns a count of finished ServiceMock.PipelinePublicClient invocations
func (mmPipelinePublicClient *ServiceMock) PipelinePublicClientAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPipelinePublicClient.afterPipelinePublicClientCounter)
}

// PipelinePublicClientBeforeCounter returns a count of ServiceMock.PipelinePublicClient invocations
func (mmPipelinePublicClient *ServiceMock) PipelinePublicClientBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPipelinePublicClient.beforePipelinePublicClientCounter)
}

// MinimockPipelinePublicClientDone returns true if the count of the PipelinePublicClient invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockPipelinePublicClientDone() bool {
	if m.PipelinePublicClientMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PipelinePublicClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PipelinePublicClientMock.invocationsDone()
}

// MinimockPipelinePublicClientInspect logs each unmet expectation
func (m *ServiceMock) MinimockPipelinePublicClientInspect() {
	for _, e := range m.PipelinePublicClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServiceMock.PipelinePublicClient")
		}
	}

	afterPipelinePublicClientCounter := mm_atomic.LoadUint64(&m.afterPipelinePublicClientCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PipelinePublicClientMock.defaultExpectation != nil && afterPipelinePublicClientCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.PipelinePublicClient at\n%s", m.PipelinePublicClientMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPipelinePublicClient != nil && afterPipelinePublicClientCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.PipelinePublicClient at\n%s", m.funcPipelinePublicClientOrigin)
	}

	if !m.PipelinePublicClientMock.invocationsDone() && afterPipelinePublicClientCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.PipelinePublicClient at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PipelinePublicClientMock.expectedInvocations), m.PipelinePublicClientMock.expectedInvocationsOrigin, afterPipelinePublicClientCounter)
	}
}

type mServiceMockProcessFile struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockProcessFileExpectation
	expectations       []*ServiceMockProcessFileExpectation

	callArgs []*ServiceMockProcessFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockProcessFileExpectation specifies expectation struct of the Service.ProcessFile
type ServiceMockProcessFileExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockProcessFileParams
	paramPtrs          *ServiceMockProcessFileParamPtrs
	expectationOrigins ServiceMockProcessFileExpectationOrigins
	results            *ServiceMockProcessFileResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockProcessFileParams contains parameters of the Service.ProcessFile
type ServiceMockProcessFileParams struct {
	ctx context.Context
	k1  types.KBUIDType
	fa1 []types.FileUIDType
	u1  types.UserUIDType
	r1  types.RequesterUIDType
}

// ServiceMockProcessFileParamPtrs contains pointers to parameters of the Service.ProcessFile
type ServiceMockProcessFileParamPtrs struct {
	ctx *context.Context
	k1  *types.KBUIDType
	fa1 *[]types.FileUIDType
	u1  *types.UserUIDType
	r1  *types.RequesterUIDType
}

// ServiceMockProcessFileResults contains results of the Service.ProcessFile
type ServiceMockProcessFileResults struct {
	err error
}

// ServiceMockProcessFileOrigins contains origins of expectations of the Service.ProcessFile
type ServiceMockProcessFileExpectationOrigins struct {
	origin    string
	originCtx string
	originK1  string
	originFa1 string
	originU1  string
	originR1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmProcessFile *mServiceMockProcessFile) Optional() *mServiceMockProcessFile {
	mmProcessFile.optional = true
	return mmProcessFile
}

// Expect sets up expected params for Service.ProcessFile
func (mmProcessFile *mServiceMockProcessFile) Expect(ctx context.Context, k1 types.KBUIDType, fa1 []types.FileUIDType, u1 types.UserUIDType, r1 types.RequesterUIDType) *mServiceMockProcessFile {
	if mmProcessFile.mock.funcProcessFile != nil {
		mmProcessFile.mock.t.Fatalf("ServiceMock.ProcessFile mock is already set by Set")
	}

	if mmProcessFile.defaultExpectation == nil {
		mmProcessFile.defaultExpectation = &ServiceMockProcessFileExpectation{}
	}

	if mmProcessFile.defaultExpectation.paramPtrs != nil {
		mmProcessFile.mock.t.Fatalf("ServiceMock.ProcessFile mock is already set by ExpectParams functions")
	}

	mmProcessFile.defaultExpectation.params = &ServiceMockProcessFileParams{ctx, k1, fa1, u1, r1}
	mmProcessFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmProcessFile.expectations {
		if minimock.Equal(e.params, mmProcessFile.defaultExpectation.params) {
			mmProcessFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmProcessFile.defaultExpectation.params)
		}
	}

	return mmProcessFile
}

// ExpectCtxParam1 sets up expected param ctx for Service.ProcessFile
func (mmProcessFile *mServiceMockProcessFile) ExpectCtxParam1(ctx context.Context) *mServiceMockProcessFile {
	if mmProcessFile.mock.funcProcessFile != nil {
		mmProcessFile.mock.t.Fatalf("ServiceMock.ProcessFile mock is already set by Set")
	}

	if mmProcessFile.defaultExpectation == nil {
		mmProcessFile.defaultExpectation = &ServiceMockProcessFileExpectation{}
	}

	if mmProcessFile.defaultExpectation.params != nil {
		mmProcessFile.mock.t.Fatalf("ServiceMock.ProcessFile mock is already set by Expect")
	}

	if mmProcessFile.defaultExpectation.paramPtrs == nil {
		mmProcessFile.defaultExpectation.paramPtrs = &ServiceMockProcessFileParamPtrs{}
	}
	mmProcessFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmProcessFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmProcessFile
}

// ExpectK1Param2 sets up expected param k1 for Service.ProcessFile
func (mmProcessFile *mServiceMockProcessFile) ExpectK1Param2(k1 types.KBUIDType) *mServiceMockProcessFile {
	if mmProcessFile.mock.funcProcessFile != nil {
		mmProcessFile.mock.t.Fatalf("ServiceMock.ProcessFile mock is already set by Set")
	}

	if mmProcessFile.defaultExpectation == nil {
		mmProcessFile.defaultExpectation = &ServiceMockProcessFileExpectation{}
	}

	if mmProcessFile.defaultExpectation.params != nil {
		mmProcessFile.mock.t.Fatalf("ServiceMock.ProcessFile mock is already set by Expect")
	}

	if mmProcessFile.defaultExpectation.paramPtrs == nil {
		mmProcessFile.defaultExpectation.paramPtrs = &ServiceMockProcessFileParamPtrs{}
	}
	mmProcessFile.defaultExpectation.paramPtrs.k1 = &k1
	mmProcessFile.defaultExpectation.expectationOrigins.originK1 = minimock.CallerInfo(1)

	return mmProcessFile
}

// ExpectFa1Param3 sets up expected param fa1 for Service.ProcessFile
func (mmProcessFile *mServiceMockProcessFile) ExpectFa1Param3(fa1 []types.FileUIDType) *mServiceMockProcessFile {
	if mmProcessFile.mock.funcProcessFile != nil {
		mmProcessFile.mock.t.Fatalf("ServiceMock.ProcessFile mock is already set by Set")
	}

	if mmProcessFile.defaultExpectation == nil {
		mmProcessFile.defaultExpectation = &ServiceMockProcessFileExpectation{}
	}

	if mmProcessFile.defaultExpectation.params != nil {
		mmProcessFile.mock.t.Fatalf("ServiceMock.ProcessFile mock is already set by Expect")
	}

	if mmProcessFile.defaultExpectation.paramPtrs == nil {
		mmProcessFile.defaultExpectation.paramPtrs = &ServiceMockProcessFileParamPtrs{}
	}
	mmProcessFile.defaultExpectation.paramPtrs.fa1 = &fa1
	mmProcessFile.defaultExpectation.expectationOrigins.originFa1 = minimock.CallerInfo(1)

	return mmProcessFile
}

// ExpectU1Param4 sets up expected param u1 for Service.ProcessFile
func (mmProcessFile *mServiceMockProcessFile) ExpectU1Param4(u1 types.UserUIDType) *mServiceMockProcessFile {
	if mmProcessFile.mock.funcProcessFile != nil {
		mmProcessFile.mock.t.Fatalf("ServiceMock.ProcessFile mock is already set by Set")
	}

	if mmProcessFile.defaultExpectation == nil {
		mmProcessFile.defaultExpectation = &ServiceMockProcessFileExpectation{}
	}

	if mmProcessFile.defaultExpectation.params != nil {
		mmProcessFile.mock.t.Fatalf("ServiceMock.ProcessFile mock is already set by Expect")
	}

	if mmProcessFile.defaultExpectation.paramPtrs == nil {
		mmProcessFile.defaultExpectation.paramPtrs = &ServiceMockProcessFileParamPtrs{}
	}
	mmProcessFile.defaultExpectation.paramPtrs.u1 = &u1
	mmProcessFile.defaultExpectation.expectationOrigins.originU1 = minimock.CallerInfo(1)

	return mmProcessFile
}

// ExpectR1Param5 sets up expected param r1 for Service.ProcessFile
func (mmProcessFile *mServiceMockProcessFile) ExpectR1Param5(r1 types.RequesterUIDType) *mServiceMockProcessFile {
	if mmProcessFile.mock.funcProcessFile != nil {
		mmProcessFile.mock.t.Fatalf("ServiceMock.ProcessFile mock is already set by Set")
	}

	if mmProcessFile.defaultExpectation == nil {
		mmProcessFile.defaultExpectation = &ServiceMockProcessFileExpectation{}
	}

	if mmProcessFile.defaultExpectation.params != nil {
		mmProcessFile.mock.t.Fatalf("ServiceMock.ProcessFile mock is already set by Expect")
	}

	if mmProcessFile.defaultExpectation.paramPtrs == nil {
		mmProcessFile.defaultExpectation.paramPtrs = &ServiceMockProcessFileParamPtrs{}
	}
	mmProcessFile.defaultExpectation.paramPtrs.r1 = &r1
	mmProcessFile.defaultExpectation.expectationOrigins.originR1 = minimock.CallerInfo(1)

	return mmProcessFile
}

// Inspect accepts an inspector function that has same arguments as the Service.ProcessFile
func (mmProcessFile *mServiceMockProcessFile) Inspect(f func(ctx context.Context, k1 types.KBUIDType, fa1 []types.FileUIDType, u1 types.UserUIDType, r1 types.RequesterUIDType)) *mServiceMockProcessFile {
	if mmProcessFile.mock.inspectFuncProcessFile != nil {
		mmProcessFile.mock.t.Fatalf("Inspect function is already set for ServiceMock.ProcessFile")
	}

	mmProcessFile.mock.inspectFuncProcessFile = f

	return mmProcessFile
}

// Return sets up results that will be returned by Service.ProcessFile
func (mmProcessFile *mServiceMockProcessFile) Return(err error) *ServiceMock {
	if mmProcessFile.mock.funcProcessFile != nil {
		mmProcessFile.mock.t.Fatalf("ServiceMock.ProcessFile mock is already set by Set")
	}

	if mmProcessFile.defaultExpectation == nil {
		mmProcessFile.defaultExpectation = &ServiceMockProcessFileExpectation{mock: mmProcessFile.mock}
	}
	mmProcessFile.defaultExpectation.results = &ServiceMockProcessFileResults{err}
	mmProcessFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmProcessFile.mock
}

// Set uses given function f to mock the Service.ProcessFile method
func (mmProcessFile *mServiceMockProcessFile) Set(f func(ctx context.Context, k1 types.KBUIDType, fa1 []types.FileUIDType, u1 types.UserUIDType, r1 types.RequesterUIDType) (err error)) *ServiceMock {
	if mmProcessFile.defaultExpectation != nil {
		mmProcessFile.mock.t.Fatalf("Default expectation is already set for the Service.ProcessFile method")
	}

	if len(mmProcessFile.expectations) > 0 {
		mmProcessFile.mock.t.Fatalf("Some expectations are already set for the Service.ProcessFile method")
	}

	mmProcessFile.mock.funcProcessFile = f
	mmProcessFile.mock.funcProcessFileOrigin = minimock.CallerInfo(1)
	return mmProcessFile.mock
}

// When sets expectation for the Service.ProcessFile which will trigger the result defined by the following
// Then helper
func (mmProcessFile *mServiceMockProcessFile) When(ctx context.Context, k1 types.KBUIDType, fa1 []types.FileUIDType, u1 types.UserUIDType, r1 types.RequesterUIDType) *ServiceMockProcessFileExpectation {
	if mmProcessFile.mock.funcProcessFile != nil {
		mmProcessFile.mock.t.Fatalf("ServiceMock.ProcessFile mock is already set by Set")
	}

	expectation := &ServiceMockProcessFileExpectation{
		mock:               mmProcessFile.mock,
		params:             &ServiceMockProcessFileParams{ctx, k1, fa1, u1, r1},
		expectationOrigins: ServiceMockProcessFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmProcessFile.expectations = append(mmProcessFile.expectations, expectation)
	return expectation
}

// Then sets up Service.ProcessFile return parameters for the expectation previously defined by the When method
func (e *ServiceMockProcessFileExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockProcessFileResults{err}
	return e.mock
}

// Times sets number of times Service.ProcessFile should be invoked
func (mmProcessFile *mServiceMockProcessFile) Times(n uint64) *mServiceMockProcessFile {
	if n == 0 {
		mmProcessFile.mock.t.Fatalf("Times of ServiceMock.ProcessFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmProcessFile.expectedInvocations, n)
	mmProcessFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmProcessFile
}

func (mmProcessFile *mServiceMockProcessFile) invocationsDone() bool {
	if len(mmProcessFile.expectations) == 0 && mmProcessFile.defaultExpectation == nil && mmProcessFile.mock.funcProcessFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmProcessFile.mock.afterProcessFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmProcessFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ProcessFile implements mm_service.Service
func (mmProcessFile *ServiceMock) ProcessFile(ctx context.Context, k1 types.KBUIDType, fa1 []types.FileUIDType, u1 types.UserUIDType, r1 types.RequesterUIDType) (err error) {
	mm_atomic.AddUint64(&mmProcessFile.beforeProcessFileCounter, 1)
	defer mm_atomic.AddUint64(&mmProcessFile.afterProcessFileCounter, 1)

	mmProcessFile.t.Helper()

	if mmProcessFile.inspectFuncProcessFile != nil {
		mmProcessFile.inspectFuncProcessFile(ctx, k1, fa1, u1, r1)
	}

	mm_params := ServiceMockProcessFileParams{ctx, k1, fa1, u1, r1}

	// Record call args
	mmProcessFile.ProcessFileMock.mutex.Lock()
	mmProcessFile.ProcessFileMock.callArgs = append(mmProcessFile.ProcessFileMock.callArgs, &mm_params)
	mmProcessFile.ProcessFileMock.mutex.Unlock()

	for _, e := range mmProcessFile.ProcessFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmProcessFile.ProcessFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProcessFile.ProcessFileMock.defaultExpectation.Counter, 1)
		mm_want := mmProcessFile.ProcessFileMock.defaultExpectation.params
		mm_want_ptrs := mmProcessFile.ProcessFileMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockProcessFileParams{ctx, k1, fa1, u1, r1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmProcessFile.t.Errorf("ServiceMock.ProcessFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProcessFile.ProcessFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.k1 != nil && !minimock.Equal(*mm_want_ptrs.k1, mm_got.k1) {
				mmProcessFile.t.Errorf("ServiceMock.ProcessFile got unexpected parameter k1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProcessFile.ProcessFileMock.defaultExpectation.expectationOrigins.originK1, *mm_want_ptrs.k1, mm_got.k1, minimock.Diff(*mm_want_ptrs.k1, mm_got.k1))
			}

			if mm_want_ptrs.fa1 != nil && !minimock.Equal(*mm_want_ptrs.fa1, mm_got.fa1) {
				mmProcessFile.t.Errorf("ServiceMock.ProcessFile got unexpected parameter fa1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProcessFile.ProcessFileMock.defaultExpectation.expectationOrigins.originFa1, *mm_want_ptrs.fa1, mm_got.fa1, minimock.Diff(*mm_want_ptrs.fa1, mm_got.fa1))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmProcessFile.t.Errorf("ServiceMock.ProcessFile got unexpected parameter u1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProcessFile.ProcessFileMock.defaultExpectation.expectationOrigins.originU1, *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

			if mm_want_ptrs.r1 != nil && !minimock.Equal(*mm_want_ptrs.r1, mm_got.r1) {
				mmProcessFile.t.Errorf("ServiceMock.ProcessFile got unexpected parameter r1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProcessFile.ProcessFileMock.defaultExpectation.expectationOrigins.originR1, *mm_want_ptrs.r1, mm_got.r1, minimock.Diff(*mm_want_ptrs.r1, mm_got.r1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmProcessFile.t.Errorf("ServiceMock.ProcessFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmProcessFile.ProcessFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmProcessFile.ProcessFileMock.defaultExpectation.results
		if mm_results == nil {
			mmProcessFile.t.Fatal("No results are set for the ServiceMock.ProcessFile")
		}
		return (*mm_results).err
	}
	if mmProcessFile.funcProcessFile != nil {
		return mmProcessFile.funcProcessFile(ctx, k1, fa1, u1, r1)
	}
	mmProcessFile.t.Fatalf("Unexpected call to ServiceMock.ProcessFile. %v %v %v %v %v", ctx, k1, fa1, u1, r1)
	return
}

// ProcessFileAfterCounter returns a count of finished ServiceMock.ProcessFile invocations
func (mmProcessFile *ServiceMock) ProcessFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessFile.afterProcessFileCounter)
}

// ProcessFileBeforeCounter returns a count of ServiceMock.ProcessFile invocations
func (mmProcessFile *ServiceMock) ProcessFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessFile.beforeProcessFileCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.ProcessFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmProcessFile *mServiceMockProcessFile) Calls() []*ServiceMockProcessFileParams {
	mmProcessFile.mutex.RLock()

	argCopy := make([]*ServiceMockProcessFileParams, len(mmProcessFile.callArgs))
	copy(argCopy, mmProcessFile.callArgs)

	mmProcessFile.mutex.RUnlock()

	return argCopy
}

// MinimockProcessFileDone returns true if the count of the ProcessFile invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockProcessFileDone() bool {
	if m.ProcessFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ProcessFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ProcessFileMock.invocationsDone()
}

// MinimockProcessFileInspect logs each unmet expectation
func (m *ServiceMock) MinimockProcessFileInspect() {
	for _, e := range m.ProcessFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.ProcessFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterProcessFileCounter := mm_atomic.LoadUint64(&m.afterProcessFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ProcessFileMock.defaultExpectation != nil && afterProcessFileCounter < 1 {
		if m.ProcessFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.ProcessFile at\n%s", m.ProcessFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.ProcessFile at\n%s with params: %#v", m.ProcessFileMock.defaultExpectation.expectationOrigins.origin, *m.ProcessFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProcessFile != nil && afterProcessFileCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.ProcessFile at\n%s", m.funcProcessFileOrigin)
	}

	if !m.ProcessFileMock.invocationsDone() && afterProcessFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.ProcessFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ProcessFileMock.expectedInvocations), m.ProcessFileMock.expectedInvocationsOrigin, afterProcessFileCounter)
	}
}

type mServiceMockRedisClient struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockRedisClientExpectation
	expectations       []*ServiceMockRedisClientExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockRedisClientExpectation specifies expectation struct of the Service.RedisClient
type ServiceMockRedisClientExpectation struct {
	mock *ServiceMock

	results      *ServiceMockRedisClientResults
	returnOrigin string
	Counter      uint64
}

// ServiceMockRedisClientResults contains results of the Service.RedisClient
type ServiceMockRedisClientResults struct {
	cp1 *redis.Client
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRedisClient *mServiceMockRedisClient) Optional() *mServiceMockRedisClient {
	mmRedisClient.optional = true
	return mmRedisClient
}

// Expect sets up expected params for Service.RedisClient
func (mmRedisClient *mServiceMockRedisClient) Expect() *mServiceMockRedisClient {
	if mmRedisClient.mock.funcRedisClient != nil {
		mmRedisClient.mock.t.Fatalf("ServiceMock.RedisClient mock is already set by Set")
	}

	if mmRedisClient.defaultExpectation == nil {
		mmRedisClient.defaultExpectation = &ServiceMockRedisClientExpectation{}
	}

	return mmRedisClient
}

// Inspect accepts an inspector function that has same arguments as the Service.RedisClient
func (mmRedisClient *mServiceMockRedisClient) Inspect(f func()) *mServiceMockRedisClient {
	if mmRedisClient.mock.inspectFuncRedisClient != nil {
		mmRedisClient.mock.t.Fatalf("Inspect function is already set for ServiceMock.RedisClient")
	}

	mmRedisClient.mock.inspectFuncRedisClient = f

	return mmRedisClient
}

// Return sets up results that will be returned by Service.RedisClient
func (mmRedisClient *mServiceMockRedisClient) Return(cp1 *redis.Client) *ServiceMock {
	if mmRedisClient.mock.funcRedisClient != nil {
		mmRedisClient.mock.t.Fatalf("ServiceMock.RedisClient mock is already set by Set")
	}

	if mmRedisClient.defaultExpectation == nil {
		mmRedisClient.defaultExpectation = &ServiceMockRedisClientExpectation{mock: mmRedisClient.mock}
	}
	mmRedisClient.defaultExpectation.results = &ServiceMockRedisClientResults{cp1}
	mmRedisClient.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRedisClient.mock
}

// Set uses given function f to mock the Service.RedisClient method
func (mmRedisClient *mServiceMockRedisClient) Set(f func() (cp1 *redis.Client)) *ServiceMock {
	if mmRedisClient.defaultExpectation != nil {
		mmRedisClient.mock.t.Fatalf("Default expectation is already set for the Service.RedisClient method")
	}

	if len(mmRedisClient.expectations) > 0 {
		mmRedisClient.mock.t.Fatalf("Some expectations are already set for the Service.RedisClient method")
	}

	mmRedisClient.mock.funcRedisClient = f
	mmRedisClient.mock.funcRedisClientOrigin = minimock.CallerInfo(1)
	return mmRedisClient.mock
}

// Times sets number of times Service.RedisClient should be invoked
func (mmRedisClient *mServiceMockRedisClient) Times(n uint64) *mServiceMockRedisClient {
	if n == 0 {
		mmRedisClient.mock.t.Fatalf("Times of ServiceMock.RedisClient mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRedisClient.expectedInvocations, n)
	mmRedisClient.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRedisClient
}

func (mmRedisClient *mServiceMockRedisClient) invocationsDone() bool {
	if len(mmRedisClient.expectations) == 0 && mmRedisClient.defaultExpectation == nil && mmRedisClient.mock.funcRedisClient == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRedisClient.mock.afterRedisClientCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRedisClient.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RedisClient implements mm_service.Service
func (mmRedisClient *ServiceMock) RedisClient() (cp1 *redis.Client) {
	mm_atomic.AddUint64(&mmRedisClient.beforeRedisClientCounter, 1)
	defer mm_atomic.AddUint64(&mmRedisClient.afterRedisClientCounter, 1)

	mmRedisClient.t.Helper()

	if mmRedisClient.inspectFuncRedisClient != nil {
		mmRedisClient.inspectFuncRedisClient()
	}

	if mmRedisClient.RedisClientMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRedisClient.RedisClientMock.defaultExpectation.Counter, 1)

		mm_results := mmRedisClient.RedisClientMock.defaultExpectation.results
		if mm_results == nil {
			mmRedisClient.t.Fatal("No results are set for the ServiceMock.RedisClient")
		}
		return (*mm_results).cp1
	}
	if mmRedisClient.funcRedisClient != nil {
		return mmRedisClient.funcRedisClient()
	}
	mmRedisClient.t.Fatalf("Unexpected call to ServiceMock.RedisClient.")
	return
}

// RedisClientAfterCounter returns a count of finished ServiceMock.RedisClient invocations
func (mmRedisClient *ServiceMock) RedisClientAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRedisClient.afterRedisClientCounter)
}

// RedisClientBeforeCounter returns a count of ServiceMock.RedisClient invocations
func (mmRedisClient *ServiceMock) RedisClientBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRedisClient.beforeRedisClientCounter)
}

// MinimockRedisClientDone returns true if the count of the RedisClient invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockRedisClientDone() bool {
	if m.RedisClientMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RedisClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RedisClientMock.invocationsDone()
}

// MinimockRedisClientInspect logs each unmet expectation
func (m *ServiceMock) MinimockRedisClientInspect() {
	for _, e := range m.RedisClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServiceMock.RedisClient")
		}
	}

	afterRedisClientCounter := mm_atomic.LoadUint64(&m.afterRedisClientCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RedisClientMock.defaultExpectation != nil && afterRedisClientCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.RedisClient at\n%s", m.RedisClientMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRedisClient != nil && afterRedisClientCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.RedisClient at\n%s", m.funcRedisClientOrigin)
	}

	if !m.RedisClientMock.invocationsDone() && afterRedisClientCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.RedisClient at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RedisClientMock.expectedInvocations), m.RedisClientMock.expectedInvocationsOrigin, afterRedisClientCounter)
	}
}

type mServiceMockRepository struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockRepositoryExpectation
	expectations       []*ServiceMockRepositoryExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockRepositoryExpectation specifies expectation struct of the Service.Repository
type ServiceMockRepositoryExpectation struct {
	mock *ServiceMock

	results      *ServiceMockRepositoryResults
	returnOrigin string
	Counter      uint64
}

// ServiceMockRepositoryResults contains results of the Service.Repository
type ServiceMockRepositoryResults struct {
	r1 repository.Repository
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRepository *mServiceMockRepository) Optional() *mServiceMockRepository {
	mmRepository.optional = true
	return mmRepository
}

// Expect sets up expected params for Service.Repository
func (mmRepository *mServiceMockRepository) Expect() *mServiceMockRepository {
	if mmRepository.mock.funcRepository != nil {
		mmRepository.mock.t.Fatalf("ServiceMock.Repository mock is already set by Set")
	}

	if mmRepository.defaultExpectation == nil {
		mmRepository.defaultExpectation = &ServiceMockRepositoryExpectation{}
	}

	return mmRepository
}

// Inspect accepts an inspector function that has same arguments as the Service.Repository
func (mmRepository *mServiceMockRepository) Inspect(f func()) *mServiceMockRepository {
	if mmRepository.mock.inspectFuncRepository != nil {
		mmRepository.mock.t.Fatalf("Inspect function is already set for ServiceMock.Repository")
	}

	mmRepository.mock.inspectFuncRepository = f

	return mmRepository
}

// Return sets up results that will be returned by Service.Repository
func (mmRepository *mServiceMockRepository) Return(r1 repository.Repository) *ServiceMock {
	if mmRepository.mock.funcRepository != nil {
		mmRepository.mock.t.Fatalf("ServiceMock.Repository mock is already set by Set")
	}

	if mmRepository.defaultExpectation == nil {
		mmRepository.defaultExpectation = &ServiceMockRepositoryExpectation{mock: mmRepository.mock}
	}
	mmRepository.defaultExpectation.results = &ServiceMockRepositoryResults{r1}
	mmRepository.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRepository.mock
}

// Set uses given function f to mock the Service.Repository method
func (mmRepository *mServiceMockRepository) Set(f func() (r1 repository.Repository)) *ServiceMock {
	if mmRepository.defaultExpectation != nil {
		mmRepository.mock.t.Fatalf("Default expectation is already set for the Service.Repository method")
	}

	if len(mmRepository.expectations) > 0 {
		mmRepository.mock.t.Fatalf("Some expectations are already set for the Service.Repository method")
	}

	mmRepository.mock.funcRepository = f
	mmRepository.mock.funcRepositoryOrigin = minimock.CallerInfo(1)
	return mmRepository.mock
}

// Times sets number of times Service.Repository should be invoked
func (mmRepository *mServiceMockRepository) Times(n uint64) *mServiceMockRepository {
	if n == 0 {
		mmRepository.mock.t.Fatalf("Times of ServiceMock.Repository mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRepository.expectedInvocations, n)
	mmRepository.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRepository
}

func (mmRepository *mServiceMockRepository) invocationsDone() bool {
	if len(mmRepository.expectations) == 0 && mmRepository.defaultExpectation == nil && mmRepository.mock.funcRepository == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRepository.mock.afterRepositoryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRepository.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Repository implements mm_service.Service
func (mmRepository *ServiceMock) Repository() (r1 repository.Repository) {
	mm_atomic.AddUint64(&mmRepository.beforeRepositoryCounter, 1)
	defer mm_atomic.AddUint64(&mmRepository.afterRepositoryCounter, 1)

	mmRepository.t.Helper()

	if mmRepository.inspectFuncRepository != nil {
		mmRepository.inspectFuncRepository()
	}

	if mmRepository.RepositoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRepository.RepositoryMock.defaultExpectation.Counter, 1)

		mm_results := mmRepository.RepositoryMock.defaultExpectation.results
		if mm_results == nil {
			mmRepository.t.Fatal("No results are set for the ServiceMock.Repository")
		}
		return (*mm_results).r1
	}
	if mmRepository.funcRepository != nil {
		return mmRepository.funcRepository()
	}
	mmRepository.t.Fatalf("Unexpected call to ServiceMock.Repository.")
	return
}

// RepositoryAfterCounter returns a count of finished ServiceMock.Repository invocations
func (mmRepository *ServiceMock) RepositoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRepository.afterRepositoryCounter)
}

// RepositoryBeforeCounter returns a count of ServiceMock.Repository invocations
func (mmRepository *ServiceMock) RepositoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRepository.beforeRepositoryCounter)
}

// MinimockRepositoryDone returns true if the count of the Repository invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockRepositoryDone() bool {
	if m.RepositoryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RepositoryMock.invocationsDone()
}

// MinimockRepositoryInspect logs each unmet expectation
func (m *ServiceMock) MinimockRepositoryInspect() {
	for _, e := range m.RepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServiceMock.Repository")
		}
	}

	afterRepositoryCounter := mm_atomic.LoadUint64(&m.afterRepositoryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RepositoryMock.defaultExpectation != nil && afterRepositoryCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.Repository at\n%s", m.RepositoryMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRepository != nil && afterRepositoryCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.Repository at\n%s", m.funcRepositoryOrigin)
	}

	if !m.RepositoryMock.invocationsDone() && afterRepositoryCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.Repository at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RepositoryMock.expectedInvocations), m.RepositoryMock.expectedInvocationsOrigin, afterRepositoryCounter)
	}
}

type mServiceMockSimilarityChunksSearch struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockSimilarityChunksSearchExpectation
	expectations       []*ServiceMockSimilarityChunksSearchExpectation

	callArgs []*ServiceMockSimilarityChunksSearchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockSimilarityChunksSearchExpectation specifies expectation struct of the Service.SimilarityChunksSearch
type ServiceMockSimilarityChunksSearchExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockSimilarityChunksSearchParams
	paramPtrs          *ServiceMockSimilarityChunksSearchParamPtrs
	expectationOrigins ServiceMockSimilarityChunksSearchExpectationOrigins
	results            *ServiceMockSimilarityChunksSearchResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockSimilarityChunksSearchParams contains parameters of the Service.SimilarityChunksSearch
type ServiceMockSimilarityChunksSearchParams struct {
	ctx  context.Context
	o1   types.OwnerUIDType
	sp1  *artifactpb.SimilarityChunksSearchRequest
	faa1 [][]float32
}

// ServiceMockSimilarityChunksSearchParamPtrs contains pointers to parameters of the Service.SimilarityChunksSearch
type ServiceMockSimilarityChunksSearchParamPtrs struct {
	ctx  *context.Context
	o1   *types.OwnerUIDType
	sp1  **artifactpb.SimilarityChunksSearchRequest
	faa1 *[][]float32
}

// ServiceMockSimilarityChunksSearchResults contains results of the Service.SimilarityChunksSearch
type ServiceMockSimilarityChunksSearchResults struct {
	sa1 []mm_service.SimChunk
	err error
}

// ServiceMockSimilarityChunksSearchOrigins contains origins of expectations of the Service.SimilarityChunksSearch
type ServiceMockSimilarityChunksSearchExpectationOrigins struct {
	origin     string
	originCtx  string
	originO1   string
	originSp1  string
	originFaa1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) Optional() *mServiceMockSimilarityChunksSearch {
	mmSimilarityChunksSearch.optional = true
	return mmSimilarityChunksSearch
}

// Expect sets up expected params for Service.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) Expect(ctx context.Context, o1 types.OwnerUIDType, sp1 *artifactpb.SimilarityChunksSearchRequest, faa1 [][]float32) *mServiceMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ServiceMockSimilarityChunksSearchExpectation{}
	}

	if mmSimilarityChunksSearch.defaultExpectation.paramPtrs != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by ExpectParams functions")
	}

	mmSimilarityChunksSearch.defaultExpectation.params = &ServiceMockSimilarityChunksSearchParams{ctx, o1, sp1, faa1}
	mmSimilarityChunksSearch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSimilarityChunksSearch.expectations {
		if minimock.Equal(e.params, mmSimilarityChunksSearch.defaultExpectation.params) {
			mmSimilarityChunksSearch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSimilarityChunksSearch.defaultExpectation.params)
		}
	}

	return mmSimilarityChunksSearch
}

// ExpectCtxParam1 sets up expected param ctx for Service.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) ExpectCtxParam1(ctx context.Context) *mServiceMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ServiceMockSimilarityChunksSearchExpectation{}
	}

	if mmSimilarityChunksSearch.defaultExpectation.params != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Expect")
	}

	if mmSimilarityChunksSearch.defaultExpectation.paramPtrs == nil {
		mmSimilarityChunksSearch.defaultExpectation.paramPtrs = &ServiceMockSimilarityChunksSearchParamPtrs{}
	}
	mmSimilarityChunksSearch.defaultExpectation.paramPtrs.ctx = &ctx
	mmSimilarityChunksSearch.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSimilarityChunksSearch
}

// ExpectO1Param2 sets up expected param o1 for Service.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) ExpectO1Param2(o1 types.OwnerUIDType) *mServiceMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ServiceMockSimilarityChunksSearchExpectation{}
	}

	if mmSimilarityChunksSearch.defaultExpectation.params != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Expect")
	}

	if mmSimilarityChunksSearch.defaultExpectation.paramPtrs == nil {
		mmSimilarityChunksSearch.defaultExpectation.paramPtrs = &ServiceMockSimilarityChunksSearchParamPtrs{}
	}
	mmSimilarityChunksSearch.defaultExpectation.paramPtrs.o1 = &o1
	mmSimilarityChunksSearch.defaultExpectation.expectationOrigins.originO1 = minimock.CallerInfo(1)

	return mmSimilarityChunksSearch
}

// ExpectSp1Param3 sets up expected param sp1 for Service.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) ExpectSp1Param3(sp1 *artifactpb.SimilarityChunksSearchRequest) *mServiceMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ServiceMockSimilarityChunksSearchExpectation{}
	}

	if mmSimilarityChunksSearch.defaultExpectation.params != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Expect")
	}

	if mmSimilarityChunksSearch.defaultExpectation.paramPtrs == nil {
		mmSimilarityChunksSearch.defaultExpectation.paramPtrs = &ServiceMockSimilarityChunksSearchParamPtrs{}
	}
	mmSimilarityChunksSearch.defaultExpectation.paramPtrs.sp1 = &sp1
	mmSimilarityChunksSearch.defaultExpectation.expectationOrigins.originSp1 = minimock.CallerInfo(1)

	return mmSimilarityChunksSearch
}

// ExpectFaa1Param4 sets up expected param faa1 for Service.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) ExpectFaa1Param4(faa1 [][]float32) *mServiceMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ServiceMockSimilarityChunksSearchExpectation{}
	}

	if mmSimilarityChunksSearch.defaultExpectation.params != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Expect")
	}

	if mmSimilarityChunksSearch.defaultExpectation.paramPtrs == nil {
		mmSimilarityChunksSearch.defaultExpectation.paramPtrs = &ServiceMockSimilarityChunksSearchParamPtrs{}
	}
	mmSimilarityChunksSearch.defaultExpectation.paramPtrs.faa1 = &faa1
	mmSimilarityChunksSearch.defaultExpectation.expectationOrigins.originFaa1 = minimock.CallerInfo(1)

	return mmSimilarityChunksSearch
}

// Inspect accepts an inspector function that has same arguments as the Service.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) Inspect(f func(ctx context.Context, o1 types.OwnerUIDType, sp1 *artifactpb.SimilarityChunksSearchRequest, faa1 [][]float32)) *mServiceMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.inspectFuncSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("Inspect function is already set for ServiceMock.SimilarityChunksSearch")
	}

	mmSimilarityChunksSearch.mock.inspectFuncSimilarityChunksSearch = f

	return mmSimilarityChunksSearch
}

// Return sets up results that will be returned by Service.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) Return(sa1 []mm_service.SimChunk, err error) *ServiceMock {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ServiceMockSimilarityChunksSearchExpectation{mock: mmSimilarityChunksSearch.mock}
	}
	mmSimilarityChunksSearch.defaultExpectation.results = &ServiceMockSimilarityChunksSearchResults{sa1, err}
	mmSimilarityChunksSearch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSimilarityChunksSearch.mock
}

// Set uses given function f to mock the Service.SimilarityChunksSearch method
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) Set(f func(ctx context.Context, o1 types.OwnerUIDType, sp1 *artifactpb.SimilarityChunksSearchRequest, faa1 [][]float32) (sa1 []mm_service.SimChunk, err error)) *ServiceMock {
	if mmSimilarityChunksSearch.defaultExpectation != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("Default expectation is already set for the Service.SimilarityChunksSearch method")
	}

	if len(mmSimilarityChunksSearch.expectations) > 0 {
		mmSimilarityChunksSearch.mock.t.Fatalf("Some expectations are already set for the Service.SimilarityChunksSearch method")
	}

	mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch = f
	mmSimilarityChunksSearch.mock.funcSimilarityChunksSearchOrigin = minimock.CallerInfo(1)
	return mmSimilarityChunksSearch.mock
}

// When sets expectation for the Service.SimilarityChunksSearch which will trigger the result defined by the following
// Then helper
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) When(ctx context.Context, o1 types.OwnerUIDType, sp1 *artifactpb.SimilarityChunksSearchRequest, faa1 [][]float32) *ServiceMockSimilarityChunksSearchExpectation {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Set")
	}

	expectation := &ServiceMockSimilarityChunksSearchExpectation{
		mock:               mmSimilarityChunksSearch.mock,
		params:             &ServiceMockSimilarityChunksSearchParams{ctx, o1, sp1, faa1},
		expectationOrigins: ServiceMockSimilarityChunksSearchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSimilarityChunksSearch.expectations = append(mmSimilarityChunksSearch.expectations, expectation)
	return expectation
}

// Then sets up Service.SimilarityChunksSearch return parameters for the expectation previously defined by the When method
func (e *ServiceMockSimilarityChunksSearchExpectation) Then(sa1 []mm_service.SimChunk, err error) *ServiceMock {
	e.results = &ServiceMockSimilarityChunksSearchResults{sa1, err}
	return e.mock
}

// Times sets number of times Service.SimilarityChunksSearch should be invoked
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) Times(n uint64) *mServiceMockSimilarityChunksSearch {
	if n == 0 {
		mmSimilarityChunksSearch.mock.t.Fatalf("Times of ServiceMock.SimilarityChunksSearch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSimilarityChunksSearch.expectedInvocations, n)
	mmSimilarityChunksSearch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSimilarityChunksSearch
}

func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) invocationsDone() bool {
	if len(mmSimilarityChunksSearch.expectations) == 0 && mmSimilarityChunksSearch.defaultExpectation == nil && mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSimilarityChunksSearch.mock.afterSimilarityChunksSearchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSimilarityChunksSearch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SimilarityChunksSearch implements mm_service.Service
func (mmSimilarityChunksSearch *ServiceMock) SimilarityChunksSearch(ctx context.Context, o1 types.OwnerUIDType, sp1 *artifactpb.SimilarityChunksSearchRequest, faa1 [][]float32) (sa1 []mm_service.SimChunk, err error) {
	mm_atomic.AddUint64(&mmSimilarityChunksSearch.beforeSimilarityChunksSearchCounter, 1)
	defer mm_atomic.AddUint64(&mmSimilarityChunksSearch.afterSimilarityChunksSearchCounter, 1)

	mmSimilarityChunksSearch.t.Helper()

	if mmSimilarityChunksSearch.inspectFuncSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.inspectFuncSimilarityChunksSearch(ctx, o1, sp1, faa1)
	}

	mm_params := ServiceMockSimilarityChunksSearchParams{ctx, o1, sp1, faa1}

	// Record call args
	mmSimilarityChunksSearch.SimilarityChunksSearchMock.mutex.Lock()
	mmSimilarityChunksSearch.SimilarityChunksSearchMock.callArgs = append(mmSimilarityChunksSearch.SimilarityChunksSearchMock.callArgs, &mm_params)
	mmSimilarityChunksSearch.SimilarityChunksSearchMock.mutex.Unlock()

	for _, e := range mmSimilarityChunksSearch.SimilarityChunksSearchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.Counter, 1)
		mm_want := mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.params
		mm_want_ptrs := mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockSimilarityChunksSearchParams{ctx, o1, sp1, faa1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSimilarityChunksSearch.t.Errorf("ServiceMock.SimilarityChunksSearch got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.o1 != nil && !minimock.Equal(*mm_want_ptrs.o1, mm_got.o1) {
				mmSimilarityChunksSearch.t.Errorf("ServiceMock.SimilarityChunksSearch got unexpected parameter o1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.expectationOrigins.originO1, *mm_want_ptrs.o1, mm_got.o1, minimock.Diff(*mm_want_ptrs.o1, mm_got.o1))
			}

			if mm_want_ptrs.sp1 != nil && !minimock.Equal(*mm_want_ptrs.sp1, mm_got.sp1) {
				mmSimilarityChunksSearch.t.Errorf("ServiceMock.SimilarityChunksSearch got unexpected parameter sp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.expectationOrigins.originSp1, *mm_want_ptrs.sp1, mm_got.sp1, minimock.Diff(*mm_want_ptrs.sp1, mm_got.sp1))
			}

			if mm_want_ptrs.faa1 != nil && !minimock.Equal(*mm_want_ptrs.faa1, mm_got.faa1) {
				mmSimilarityChunksSearch.t.Errorf("ServiceMock.SimilarityChunksSearch got unexpected parameter faa1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.expectationOrigins.originFaa1, *mm_want_ptrs.faa1, mm_got.faa1, minimock.Diff(*mm_want_ptrs.faa1, mm_got.faa1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSimilarityChunksSearch.t.Errorf("ServiceMock.SimilarityChunksSearch got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.results
		if mm_results == nil {
			mmSimilarityChunksSearch.t.Fatal("No results are set for the ServiceMock.SimilarityChunksSearch")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmSimilarityChunksSearch.funcSimilarityChunksSearch != nil {
		return mmSimilarityChunksSearch.funcSimilarityChunksSearch(ctx, o1, sp1, faa1)
	}
	mmSimilarityChunksSearch.t.Fatalf("Unexpected call to ServiceMock.SimilarityChunksSearch. %v %v %v %v", ctx, o1, sp1, faa1)
	return
}

// SimilarityChunksSearchAfterCounter returns a count of finished ServiceMock.SimilarityChunksSearch invocations
func (mmSimilarityChunksSearch *ServiceMock) SimilarityChunksSearchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSimilarityChunksSearch.afterSimilarityChunksSearchCounter)
}

// SimilarityChunksSearchBeforeCounter returns a count of ServiceMock.SimilarityChunksSearch invocations
func (mmSimilarityChunksSearch *ServiceMock) SimilarityChunksSearchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSimilarityChunksSearch.beforeSimilarityChunksSearchCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.SimilarityChunksSearch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) Calls() []*ServiceMockSimilarityChunksSearchParams {
	mmSimilarityChunksSearch.mutex.RLock()

	argCopy := make([]*ServiceMockSimilarityChunksSearchParams, len(mmSimilarityChunksSearch.callArgs))
	copy(argCopy, mmSimilarityChunksSearch.callArgs)

	mmSimilarityChunksSearch.mutex.RUnlock()

	return argCopy
}

// MinimockSimilarityChunksSearchDone returns true if the count of the SimilarityChunksSearch invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockSimilarityChunksSearchDone() bool {
	if m.SimilarityChunksSearchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SimilarityChunksSearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SimilarityChunksSearchMock.invocationsDone()
}

// MinimockSimilarityChunksSearchInspect logs each unmet expectation
func (m *ServiceMock) MinimockSimilarityChunksSearchInspect() {
	for _, e := range m.SimilarityChunksSearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.SimilarityChunksSearch at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSimilarityChunksSearchCounter := mm_atomic.LoadUint64(&m.afterSimilarityChunksSearchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SimilarityChunksSearchMock.defaultExpectation != nil && afterSimilarityChunksSearchCounter < 1 {
		if m.SimilarityChunksSearchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.SimilarityChunksSearch at\n%s", m.SimilarityChunksSearchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.SimilarityChunksSearch at\n%s with params: %#v", m.SimilarityChunksSearchMock.defaultExpectation.expectationOrigins.origin, *m.SimilarityChunksSearchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSimilarityChunksSearch != nil && afterSimilarityChunksSearchCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.SimilarityChunksSearch at\n%s", m.funcSimilarityChunksSearchOrigin)
	}

	if !m.SimilarityChunksSearchMock.invocationsDone() && afterSimilarityChunksSearchCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.SimilarityChunksSearch at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SimilarityChunksSearchMock.expectedInvocations), m.SimilarityChunksSearchMock.expectedInvocationsOrigin, afterSimilarityChunksSearchCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockACLClientInspect()

			m.MinimockChatWithCacheInspect()

			m.MinimockCheckCatalogUserPermissionInspect()

			m.MinimockCheckFilesProcessingStatusInspect()

			m.MinimockCheckNamespacePermissionInspect()

			m.MinimockCleanupFileInspect()

			m.MinimockCleanupKnowledgeBaseInspect()

			m.MinimockCreateRepositoryTagInspect()

			m.MinimockDeleteFilesInspect()

			m.MinimockDeleteRepositoryTagInspect()

			m.MinimockEmbedTextsInspect()

			m.MinimockGetChatCacheForFilesInspect()

			m.MinimockGetChunksByFileInspect()

			m.MinimockGetConvertedFilePathsByFileUIDInspect()

			m.MinimockGetDownloadURLInspect()

			m.MinimockGetFilesByPathsInspect()

			m.MinimockGetNamespaceAndCheckPermissionInspect()

			m.MinimockGetNamespaceByNsIDInspect()

			m.MinimockGetRepositoryTagInspect()

			m.MinimockGetTextChunkFilePathsByFileUIDInspect()

			m.MinimockGetUploadURLInspect()

			m.MinimockListRepositoryTagsInspect()

			m.MinimockPipelinePublicClientInspect()

			m.MinimockProcessFileInspect()

			m.MinimockRedisClientInspect()

			m.MinimockRepositoryInspect()

			m.MinimockSimilarityChunksSearchInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockACLClientDone() &&
		m.MinimockChatWithCacheDone() &&
		m.MinimockCheckCatalogUserPermissionDone() &&
		m.MinimockCheckFilesProcessingStatusDone() &&
		m.MinimockCheckNamespacePermissionDone() &&
		m.MinimockCleanupFileDone() &&
		m.MinimockCleanupKnowledgeBaseDone() &&
		m.MinimockCreateRepositoryTagDone() &&
		m.MinimockDeleteFilesDone() &&
		m.MinimockDeleteRepositoryTagDone() &&
		m.MinimockEmbedTextsDone() &&
		m.MinimockGetChatCacheForFilesDone() &&
		m.MinimockGetChunksByFileDone() &&
		m.MinimockGetConvertedFilePathsByFileUIDDone() &&
		m.MinimockGetDownloadURLDone() &&
		m.MinimockGetFilesByPathsDone() &&
		m.MinimockGetNamespaceAndCheckPermissionDone() &&
		m.MinimockGetNamespaceByNsIDDone() &&
		m.MinimockGetRepositoryTagDone() &&
		m.MinimockGetTextChunkFilePathsByFileUIDDone() &&
		m.MinimockGetUploadURLDone() &&
		m.MinimockListRepositoryTagsDone() &&
		m.MinimockPipelinePublicClientDone() &&
		m.MinimockProcessFileDone() &&
		m.MinimockRedisClientDone() &&
		m.MinimockRepositoryDone() &&
		m.MinimockSimilarityChunksSearchDone()
}
