// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gofrs/uuid"
	"github.com/gojuno/minimock/v3"
	"github.com/instill-ai/artifact-backend/pkg/acl"
	"github.com/instill-ai/artifact-backend/pkg/minio"
	"github.com/instill-ai/artifact-backend/pkg/repository"
	"github.com/instill-ai/artifact-backend/pkg/resource"
	mm_service "github.com/instill-ai/artifact-backend/pkg/service"
	artifactpb "github.com/instill-ai/protogen-go/artifact/artifact/v1alpha"
	"github.com/redis/go-redis/v9"
)

// ServiceMock implements mm_service.Service
type ServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcACLClient          func() (ap1 *acl.ACLClient)
	funcACLClientOrigin    string
	inspectFuncACLClient   func()
	afterACLClientCounter  uint64
	beforeACLClientCounter uint64
	ACLClientMock          mServiceMockACLClient

	funcCheckCatalogUserPermission          func(ctx context.Context, s1 string, s2 string, s3 string) (np1 *resource.Namespace, kp1 *repository.KnowledgeBase, err error)
	funcCheckCatalogUserPermissionOrigin    string
	inspectFuncCheckCatalogUserPermission   func(ctx context.Context, s1 string, s2 string, s3 string)
	afterCheckCatalogUserPermissionCounter  uint64
	beforeCheckCatalogUserPermissionCounter uint64
	CheckCatalogUserPermissionMock          mServiceMockCheckCatalogUserPermission

	funcCheckNamespacePermission          func(ctx context.Context, np1 *resource.Namespace) (err error)
	funcCheckNamespacePermissionOrigin    string
	inspectFuncCheckNamespacePermission   func(ctx context.Context, np1 *resource.Namespace)
	afterCheckNamespacePermissionCounter  uint64
	beforeCheckNamespacePermissionCounter uint64
	CheckNamespacePermissionMock          mServiceMockCheckNamespacePermission

	funcChunkMarkdownPipe          func(ctx context.Context, s1 string) (cp1 *mm_service.ChunkingResult, err error)
	funcChunkMarkdownPipeOrigin    string
	inspectFuncChunkMarkdownPipe   func(ctx context.Context, s1 string)
	afterChunkMarkdownPipeCounter  uint64
	beforeChunkMarkdownPipeCounter uint64
	ChunkMarkdownPipeMock          mServiceMockChunkMarkdownPipe

	funcChunkTextPipe          func(ctx context.Context, s1 string) (cp1 *mm_service.ChunkingResult, err error)
	funcChunkTextPipeOrigin    string
	inspectFuncChunkTextPipe   func(ctx context.Context, s1 string)
	afterChunkTextPipeCounter  uint64
	beforeChunkTextPipeCounter uint64
	ChunkTextPipeMock          mServiceMockChunkTextPipe

	funcCleanupFileWorkflow          func() (c1 mm_service.CleanupFileWorkflow)
	funcCleanupFileWorkflowOrigin    string
	inspectFuncCleanupFileWorkflow   func()
	afterCleanupFileWorkflowCounter  uint64
	beforeCleanupFileWorkflowCounter uint64
	CleanupFileWorkflowMock          mServiceMockCleanupFileWorkflow

	funcCleanupKnowledgeBaseWorkflow          func() (c1 mm_service.CleanupKnowledgeBaseWorkflow)
	funcCleanupKnowledgeBaseWorkflowOrigin    string
	inspectFuncCleanupKnowledgeBaseWorkflow   func()
	afterCleanupKnowledgeBaseWorkflowCounter  uint64
	beforeCleanupKnowledgeBaseWorkflowCounter uint64
	CleanupKnowledgeBaseWorkflowMock          mServiceMockCleanupKnowledgeBaseWorkflow

	funcConvertToMDPipe          func(ctx context.Context, m1 mm_service.MDConversionParams) (mp1 *mm_service.MDConversionResult, err error)
	funcConvertToMDPipeOrigin    string
	inspectFuncConvertToMDPipe   func(ctx context.Context, m1 mm_service.MDConversionParams)
	afterConvertToMDPipeCounter  uint64
	beforeConvertToMDPipeCounter uint64
	ConvertToMDPipeMock          mServiceMockConvertToMDPipe

	funcCreateRepositoryTag          func(ctx context.Context, cp1 *artifactpb.CreateRepositoryTagRequest) (cp2 *artifactpb.CreateRepositoryTagResponse, err error)
	funcCreateRepositoryTagOrigin    string
	inspectFuncCreateRepositoryTag   func(ctx context.Context, cp1 *artifactpb.CreateRepositoryTagRequest)
	afterCreateRepositoryTagCounter  uint64
	beforeCreateRepositoryTagCounter uint64
	CreateRepositoryTagMock          mServiceMockCreateRepositoryTag

	funcDeleteConvertedFileByFileUID          func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) (err error)
	funcDeleteConvertedFileByFileUIDOrigin    string
	inspectFuncDeleteConvertedFileByFileUID   func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID)
	afterDeleteConvertedFileByFileUIDCounter  uint64
	beforeDeleteConvertedFileByFileUIDCounter uint64
	DeleteConvertedFileByFileUIDMock          mServiceMockDeleteConvertedFileByFileUID

	funcDeleteFiles          func(ctx context.Context, s1 string, sa1 []string) (err error)
	funcDeleteFilesOrigin    string
	inspectFuncDeleteFiles   func(ctx context.Context, s1 string, sa1 []string)
	afterDeleteFilesCounter  uint64
	beforeDeleteFilesCounter uint64
	DeleteFilesMock          mServiceMockDeleteFiles

	funcDeleteFilesWithPrefix          func(ctx context.Context, s1 string, s2 string) (err error)
	funcDeleteFilesWithPrefixOrigin    string
	inspectFuncDeleteFilesWithPrefix   func(ctx context.Context, s1 string, s2 string)
	afterDeleteFilesWithPrefixCounter  uint64
	beforeDeleteFilesWithPrefixCounter uint64
	DeleteFilesWithPrefixMock          mServiceMockDeleteFilesWithPrefix

	funcDeleteFilesWorkflow          func() (d1 mm_service.DeleteFilesWorkflow)
	funcDeleteFilesWorkflowOrigin    string
	inspectFuncDeleteFilesWorkflow   func()
	afterDeleteFilesWorkflowCounter  uint64
	beforeDeleteFilesWorkflowCounter uint64
	DeleteFilesWorkflowMock          mServiceMockDeleteFilesWorkflow

	funcDeleteKnowledgeBase          func(ctx context.Context, s1 string) (err error)
	funcDeleteKnowledgeBaseOrigin    string
	inspectFuncDeleteKnowledgeBase   func(ctx context.Context, s1 string)
	afterDeleteKnowledgeBaseCounter  uint64
	beforeDeleteKnowledgeBaseCounter uint64
	DeleteKnowledgeBaseMock          mServiceMockDeleteKnowledgeBase

	funcDeleteRepositoryTag          func(ctx context.Context, dp1 *artifactpb.DeleteRepositoryTagRequest) (dp2 *artifactpb.DeleteRepositoryTagResponse, err error)
	funcDeleteRepositoryTagOrigin    string
	inspectFuncDeleteRepositoryTag   func(ctx context.Context, dp1 *artifactpb.DeleteRepositoryTagRequest)
	afterDeleteRepositoryTagCounter  uint64
	beforeDeleteRepositoryTagCounter uint64
	DeleteRepositoryTagMock          mServiceMockDeleteRepositoryTag

	funcDeleteTextChunksByFileUID          func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) (err error)
	funcDeleteTextChunksByFileUIDOrigin    string
	inspectFuncDeleteTextChunksByFileUID   func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID)
	afterDeleteTextChunksByFileUIDCounter  uint64
	beforeDeleteTextChunksByFileUIDCounter uint64
	DeleteTextChunksByFileUIDMock          mServiceMockDeleteTextChunksByFileUID

	funcEmbedTextsWorkflow          func() (e1 mm_service.EmbedTextsWorkflow)
	funcEmbedTextsWorkflowOrigin    string
	inspectFuncEmbedTextsWorkflow   func()
	afterEmbedTextsWorkflowCounter  uint64
	beforeEmbedTextsWorkflowCounter uint64
	EmbedTextsWorkflowMock          mServiceMockEmbedTextsWorkflow

	funcEmbeddingTextBatch          func(ctx context.Context, sa1 []string) (faa1 [][]float32, err error)
	funcEmbeddingTextBatchOrigin    string
	inspectFuncEmbeddingTextBatch   func(ctx context.Context, sa1 []string)
	afterEmbeddingTextBatchCounter  uint64
	beforeEmbeddingTextBatchCounter uint64
	EmbeddingTextBatchMock          mServiceMockEmbeddingTextBatch

	funcEmbeddingTextPipe          func(ctx context.Context, sa1 []string) (faa1 [][]float32, err error)
	funcEmbeddingTextPipeOrigin    string
	inspectFuncEmbeddingTextPipe   func(ctx context.Context, sa1 []string)
	afterEmbeddingTextPipeCounter  uint64
	beforeEmbeddingTextPipeCounter uint64
	EmbeddingTextPipeMock          mServiceMockEmbeddingTextPipe

	funcGenerateSummary          func(ctx context.Context, s1 string, s2 string) (s3 string, err error)
	funcGenerateSummaryOrigin    string
	inspectFuncGenerateSummary   func(ctx context.Context, s1 string, s2 string)
	afterGenerateSummaryCounter  uint64
	beforeGenerateSummaryCounter uint64
	GenerateSummaryMock          mServiceMockGenerateSummary

	funcGetChunksByFile          func(ctx context.Context, kp1 *repository.KnowledgeBaseFile) (s1 mm_service.SourceTableType, s2 mm_service.SourceIDType, ta1 []repository.TextChunk, m1 map[mm_service.ChunkUIDType]mm_service.ContentType, sa1 []string, err error)
	funcGetChunksByFileOrigin    string
	inspectFuncGetChunksByFile   func(ctx context.Context, kp1 *repository.KnowledgeBaseFile)
	afterGetChunksByFileCounter  uint64
	beforeGetChunksByFileCounter uint64
	GetChunksByFileMock          mServiceMockGetChunksByFile

	funcGetDownloadURL          func(ctx context.Context, gp1 *artifactpb.GetObjectDownloadURLRequest, u1 uuid.UUID, s1 string) (gp2 *artifactpb.GetObjectDownloadURLResponse, err error)
	funcGetDownloadURLOrigin    string
	inspectFuncGetDownloadURL   func(ctx context.Context, gp1 *artifactpb.GetObjectDownloadURLRequest, u1 uuid.UUID, s1 string)
	afterGetDownloadURLCounter  uint64
	beforeGetDownloadURLCounter uint64
	GetDownloadURLMock          mServiceMockGetDownloadURL

	funcGetFilesByPaths          func(ctx context.Context, s1 string, sa1 []string) (fa1 []mm_service.FileContent, err error)
	funcGetFilesByPathsOrigin    string
	inspectFuncGetFilesByPaths   func(ctx context.Context, s1 string, sa1 []string)
	afterGetFilesByPathsCounter  uint64
	beforeGetFilesByPathsCounter uint64
	GetFilesByPathsMock          mServiceMockGetFilesByPaths

	funcGetFilesWorkflow          func() (g1 mm_service.GetFilesWorkflow)
	funcGetFilesWorkflowOrigin    string
	inspectFuncGetFilesWorkflow   func()
	afterGetFilesWorkflowCounter  uint64
	beforeGetFilesWorkflowCounter uint64
	GetFilesWorkflowMock          mServiceMockGetFilesWorkflow

	funcGetNamespaceAndCheckPermission          func(ctx context.Context, s1 string) (np1 *resource.Namespace, err error)
	funcGetNamespaceAndCheckPermissionOrigin    string
	inspectFuncGetNamespaceAndCheckPermission   func(ctx context.Context, s1 string)
	afterGetNamespaceAndCheckPermissionCounter  uint64
	beforeGetNamespaceAndCheckPermissionCounter uint64
	GetNamespaceAndCheckPermissionMock          mServiceMockGetNamespaceAndCheckPermission

	funcGetNamespaceByNsID          func(ctx context.Context, s1 string) (np1 *resource.Namespace, err error)
	funcGetNamespaceByNsIDOrigin    string
	inspectFuncGetNamespaceByNsID   func(ctx context.Context, s1 string)
	afterGetNamespaceByNsIDCounter  uint64
	beforeGetNamespaceByNsIDCounter uint64
	GetNamespaceByNsIDMock          mServiceMockGetNamespaceByNsID

	funcGetRepositoryTag          func(ctx context.Context, gp1 *artifactpb.GetRepositoryTagRequest) (gp2 *artifactpb.GetRepositoryTagResponse, err error)
	funcGetRepositoryTagOrigin    string
	inspectFuncGetRepositoryTag   func(ctx context.Context, gp1 *artifactpb.GetRepositoryTagRequest)
	afterGetRepositoryTagCounter  uint64
	beforeGetRepositoryTagCounter uint64
	GetRepositoryTagMock          mServiceMockGetRepositoryTag

	funcGetUploadURL          func(ctx context.Context, gp1 *artifactpb.GetObjectUploadURLRequest, u1 uuid.UUID, s1 string, u2 uuid.UUID) (gp2 *artifactpb.GetObjectUploadURLResponse, err error)
	funcGetUploadURLOrigin    string
	inspectFuncGetUploadURL   func(ctx context.Context, gp1 *artifactpb.GetObjectUploadURLRequest, u1 uuid.UUID, s1 string, u2 uuid.UUID)
	afterGetUploadURLCounter  uint64
	beforeGetUploadURLCounter uint64
	GetUploadURLMock          mServiceMockGetUploadURL

	funcListRepositoryTags          func(ctx context.Context, lp1 *artifactpb.ListRepositoryTagsRequest) (lp2 *artifactpb.ListRepositoryTagsResponse, err error)
	funcListRepositoryTagsOrigin    string
	inspectFuncListRepositoryTags   func(ctx context.Context, lp1 *artifactpb.ListRepositoryTagsRequest)
	afterListRepositoryTagsCounter  uint64
	beforeListRepositoryTagsCounter uint64
	ListRepositoryTagsMock          mServiceMockListRepositoryTags

	funcMinIO          func() (m1 minio.MinioI)
	funcMinIOOrigin    string
	inspectFuncMinIO   func()
	afterMinIOCounter  uint64
	beforeMinIOCounter uint64
	MinIOMock          mServiceMockMinIO

	funcProcessFileWorkflow          func() (p1 mm_service.ProcessFileWorkflow)
	funcProcessFileWorkflowOrigin    string
	inspectFuncProcessFileWorkflow   func()
	afterProcessFileWorkflowCounter  uint64
	beforeProcessFileWorkflowCounter uint64
	ProcessFileWorkflowMock          mServiceMockProcessFileWorkflow

	funcQuestionAnsweringPipe          func(ctx context.Context, s1 string, sa1 []string) (s2 string, err error)
	funcQuestionAnsweringPipeOrigin    string
	inspectFuncQuestionAnsweringPipe   func(ctx context.Context, s1 string, sa1 []string)
	afterQuestionAnsweringPipeCounter  uint64
	beforeQuestionAnsweringPipeCounter uint64
	QuestionAnsweringPipeMock          mServiceMockQuestionAnsweringPipe

	funcRedisClient          func() (cp1 *redis.Client)
	funcRedisClientOrigin    string
	inspectFuncRedisClient   func()
	afterRedisClientCounter  uint64
	beforeRedisClientCounter uint64
	RedisClientMock          mServiceMockRedisClient

	funcRepository          func() (r1 repository.RepositoryI)
	funcRepositoryOrigin    string
	inspectFuncRepository   func()
	afterRepositoryCounter  uint64
	beforeRepositoryCounter uint64
	RepositoryMock          mServiceMockRepository

	funcSimilarityChunksSearch          func(ctx context.Context, u1 uuid.UUID, sp1 *artifactpb.SimilarityChunksSearchRequest) (sa1 []mm_service.SimChunk, err error)
	funcSimilarityChunksSearchOrigin    string
	inspectFuncSimilarityChunksSearch   func(ctx context.Context, u1 uuid.UUID, sp1 *artifactpb.SimilarityChunksSearchRequest)
	afterSimilarityChunksSearchCounter  uint64
	beforeSimilarityChunksSearchCounter uint64
	SimilarityChunksSearchMock          mServiceMockSimilarityChunksSearch

	funcTriggerCleanupKnowledgeBaseWorkflow          func(ctx context.Context, s1 string) (err error)
	funcTriggerCleanupKnowledgeBaseWorkflowOrigin    string
	inspectFuncTriggerCleanupKnowledgeBaseWorkflow   func(ctx context.Context, s1 string)
	afterTriggerCleanupKnowledgeBaseWorkflowCounter  uint64
	beforeTriggerCleanupKnowledgeBaseWorkflowCounter uint64
	TriggerCleanupKnowledgeBaseWorkflowMock          mServiceMockTriggerCleanupKnowledgeBaseWorkflow

	funcVectorDB          func() (v1 mm_service.VectorDatabase)
	funcVectorDBOrigin    string
	inspectFuncVectorDB   func()
	afterVectorDBCounter  uint64
	beforeVectorDBCounter uint64
	VectorDBMock          mServiceMockVectorDB
}

// NewServiceMock returns a mock for mm_service.Service
func NewServiceMock(t minimock.Tester) *ServiceMock {
	m := &ServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ACLClientMock = mServiceMockACLClient{mock: m}

	m.CheckCatalogUserPermissionMock = mServiceMockCheckCatalogUserPermission{mock: m}
	m.CheckCatalogUserPermissionMock.callArgs = []*ServiceMockCheckCatalogUserPermissionParams{}

	m.CheckNamespacePermissionMock = mServiceMockCheckNamespacePermission{mock: m}
	m.CheckNamespacePermissionMock.callArgs = []*ServiceMockCheckNamespacePermissionParams{}

	m.ChunkMarkdownPipeMock = mServiceMockChunkMarkdownPipe{mock: m}
	m.ChunkMarkdownPipeMock.callArgs = []*ServiceMockChunkMarkdownPipeParams{}

	m.ChunkTextPipeMock = mServiceMockChunkTextPipe{mock: m}
	m.ChunkTextPipeMock.callArgs = []*ServiceMockChunkTextPipeParams{}

	m.CleanupFileWorkflowMock = mServiceMockCleanupFileWorkflow{mock: m}

	m.CleanupKnowledgeBaseWorkflowMock = mServiceMockCleanupKnowledgeBaseWorkflow{mock: m}

	m.ConvertToMDPipeMock = mServiceMockConvertToMDPipe{mock: m}
	m.ConvertToMDPipeMock.callArgs = []*ServiceMockConvertToMDPipeParams{}

	m.CreateRepositoryTagMock = mServiceMockCreateRepositoryTag{mock: m}
	m.CreateRepositoryTagMock.callArgs = []*ServiceMockCreateRepositoryTagParams{}

	m.DeleteConvertedFileByFileUIDMock = mServiceMockDeleteConvertedFileByFileUID{mock: m}
	m.DeleteConvertedFileByFileUIDMock.callArgs = []*ServiceMockDeleteConvertedFileByFileUIDParams{}

	m.DeleteFilesMock = mServiceMockDeleteFiles{mock: m}
	m.DeleteFilesMock.callArgs = []*ServiceMockDeleteFilesParams{}

	m.DeleteFilesWithPrefixMock = mServiceMockDeleteFilesWithPrefix{mock: m}
	m.DeleteFilesWithPrefixMock.callArgs = []*ServiceMockDeleteFilesWithPrefixParams{}

	m.DeleteFilesWorkflowMock = mServiceMockDeleteFilesWorkflow{mock: m}

	m.DeleteKnowledgeBaseMock = mServiceMockDeleteKnowledgeBase{mock: m}
	m.DeleteKnowledgeBaseMock.callArgs = []*ServiceMockDeleteKnowledgeBaseParams{}

	m.DeleteRepositoryTagMock = mServiceMockDeleteRepositoryTag{mock: m}
	m.DeleteRepositoryTagMock.callArgs = []*ServiceMockDeleteRepositoryTagParams{}

	m.DeleteTextChunksByFileUIDMock = mServiceMockDeleteTextChunksByFileUID{mock: m}
	m.DeleteTextChunksByFileUIDMock.callArgs = []*ServiceMockDeleteTextChunksByFileUIDParams{}

	m.EmbedTextsWorkflowMock = mServiceMockEmbedTextsWorkflow{mock: m}

	m.EmbeddingTextBatchMock = mServiceMockEmbeddingTextBatch{mock: m}
	m.EmbeddingTextBatchMock.callArgs = []*ServiceMockEmbeddingTextBatchParams{}

	m.EmbeddingTextPipeMock = mServiceMockEmbeddingTextPipe{mock: m}
	m.EmbeddingTextPipeMock.callArgs = []*ServiceMockEmbeddingTextPipeParams{}

	m.GenerateSummaryMock = mServiceMockGenerateSummary{mock: m}
	m.GenerateSummaryMock.callArgs = []*ServiceMockGenerateSummaryParams{}

	m.GetChunksByFileMock = mServiceMockGetChunksByFile{mock: m}
	m.GetChunksByFileMock.callArgs = []*ServiceMockGetChunksByFileParams{}

	m.GetDownloadURLMock = mServiceMockGetDownloadURL{mock: m}
	m.GetDownloadURLMock.callArgs = []*ServiceMockGetDownloadURLParams{}

	m.GetFilesByPathsMock = mServiceMockGetFilesByPaths{mock: m}
	m.GetFilesByPathsMock.callArgs = []*ServiceMockGetFilesByPathsParams{}

	m.GetFilesWorkflowMock = mServiceMockGetFilesWorkflow{mock: m}

	m.GetNamespaceAndCheckPermissionMock = mServiceMockGetNamespaceAndCheckPermission{mock: m}
	m.GetNamespaceAndCheckPermissionMock.callArgs = []*ServiceMockGetNamespaceAndCheckPermissionParams{}

	m.GetNamespaceByNsIDMock = mServiceMockGetNamespaceByNsID{mock: m}
	m.GetNamespaceByNsIDMock.callArgs = []*ServiceMockGetNamespaceByNsIDParams{}

	m.GetRepositoryTagMock = mServiceMockGetRepositoryTag{mock: m}
	m.GetRepositoryTagMock.callArgs = []*ServiceMockGetRepositoryTagParams{}

	m.GetUploadURLMock = mServiceMockGetUploadURL{mock: m}
	m.GetUploadURLMock.callArgs = []*ServiceMockGetUploadURLParams{}

	m.ListRepositoryTagsMock = mServiceMockListRepositoryTags{mock: m}
	m.ListRepositoryTagsMock.callArgs = []*ServiceMockListRepositoryTagsParams{}

	m.MinIOMock = mServiceMockMinIO{mock: m}

	m.ProcessFileWorkflowMock = mServiceMockProcessFileWorkflow{mock: m}

	m.QuestionAnsweringPipeMock = mServiceMockQuestionAnsweringPipe{mock: m}
	m.QuestionAnsweringPipeMock.callArgs = []*ServiceMockQuestionAnsweringPipeParams{}

	m.RedisClientMock = mServiceMockRedisClient{mock: m}

	m.RepositoryMock = mServiceMockRepository{mock: m}

	m.SimilarityChunksSearchMock = mServiceMockSimilarityChunksSearch{mock: m}
	m.SimilarityChunksSearchMock.callArgs = []*ServiceMockSimilarityChunksSearchParams{}

	m.TriggerCleanupKnowledgeBaseWorkflowMock = mServiceMockTriggerCleanupKnowledgeBaseWorkflow{mock: m}
	m.TriggerCleanupKnowledgeBaseWorkflowMock.callArgs = []*ServiceMockTriggerCleanupKnowledgeBaseWorkflowParams{}

	m.VectorDBMock = mServiceMockVectorDB{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mServiceMockACLClient struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockACLClientExpectation
	expectations       []*ServiceMockACLClientExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockACLClientExpectation specifies expectation struct of the Service.ACLClient
type ServiceMockACLClientExpectation struct {
	mock *ServiceMock

	results      *ServiceMockACLClientResults
	returnOrigin string
	Counter      uint64
}

// ServiceMockACLClientResults contains results of the Service.ACLClient
type ServiceMockACLClientResults struct {
	ap1 *acl.ACLClient
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmACLClient *mServiceMockACLClient) Optional() *mServiceMockACLClient {
	mmACLClient.optional = true
	return mmACLClient
}

// Expect sets up expected params for Service.ACLClient
func (mmACLClient *mServiceMockACLClient) Expect() *mServiceMockACLClient {
	if mmACLClient.mock.funcACLClient != nil {
		mmACLClient.mock.t.Fatalf("ServiceMock.ACLClient mock is already set by Set")
	}

	if mmACLClient.defaultExpectation == nil {
		mmACLClient.defaultExpectation = &ServiceMockACLClientExpectation{}
	}

	return mmACLClient
}

// Inspect accepts an inspector function that has same arguments as the Service.ACLClient
func (mmACLClient *mServiceMockACLClient) Inspect(f func()) *mServiceMockACLClient {
	if mmACLClient.mock.inspectFuncACLClient != nil {
		mmACLClient.mock.t.Fatalf("Inspect function is already set for ServiceMock.ACLClient")
	}

	mmACLClient.mock.inspectFuncACLClient = f

	return mmACLClient
}

// Return sets up results that will be returned by Service.ACLClient
func (mmACLClient *mServiceMockACLClient) Return(ap1 *acl.ACLClient) *ServiceMock {
	if mmACLClient.mock.funcACLClient != nil {
		mmACLClient.mock.t.Fatalf("ServiceMock.ACLClient mock is already set by Set")
	}

	if mmACLClient.defaultExpectation == nil {
		mmACLClient.defaultExpectation = &ServiceMockACLClientExpectation{mock: mmACLClient.mock}
	}
	mmACLClient.defaultExpectation.results = &ServiceMockACLClientResults{ap1}
	mmACLClient.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmACLClient.mock
}

// Set uses given function f to mock the Service.ACLClient method
func (mmACLClient *mServiceMockACLClient) Set(f func() (ap1 *acl.ACLClient)) *ServiceMock {
	if mmACLClient.defaultExpectation != nil {
		mmACLClient.mock.t.Fatalf("Default expectation is already set for the Service.ACLClient method")
	}

	if len(mmACLClient.expectations) > 0 {
		mmACLClient.mock.t.Fatalf("Some expectations are already set for the Service.ACLClient method")
	}

	mmACLClient.mock.funcACLClient = f
	mmACLClient.mock.funcACLClientOrigin = minimock.CallerInfo(1)
	return mmACLClient.mock
}

// Times sets number of times Service.ACLClient should be invoked
func (mmACLClient *mServiceMockACLClient) Times(n uint64) *mServiceMockACLClient {
	if n == 0 {
		mmACLClient.mock.t.Fatalf("Times of ServiceMock.ACLClient mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmACLClient.expectedInvocations, n)
	mmACLClient.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmACLClient
}

func (mmACLClient *mServiceMockACLClient) invocationsDone() bool {
	if len(mmACLClient.expectations) == 0 && mmACLClient.defaultExpectation == nil && mmACLClient.mock.funcACLClient == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmACLClient.mock.afterACLClientCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmACLClient.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ACLClient implements mm_service.Service
func (mmACLClient *ServiceMock) ACLClient() (ap1 *acl.ACLClient) {
	mm_atomic.AddUint64(&mmACLClient.beforeACLClientCounter, 1)
	defer mm_atomic.AddUint64(&mmACLClient.afterACLClientCounter, 1)

	mmACLClient.t.Helper()

	if mmACLClient.inspectFuncACLClient != nil {
		mmACLClient.inspectFuncACLClient()
	}

	if mmACLClient.ACLClientMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmACLClient.ACLClientMock.defaultExpectation.Counter, 1)

		mm_results := mmACLClient.ACLClientMock.defaultExpectation.results
		if mm_results == nil {
			mmACLClient.t.Fatal("No results are set for the ServiceMock.ACLClient")
		}
		return (*mm_results).ap1
	}
	if mmACLClient.funcACLClient != nil {
		return mmACLClient.funcACLClient()
	}
	mmACLClient.t.Fatalf("Unexpected call to ServiceMock.ACLClient.")
	return
}

// ACLClientAfterCounter returns a count of finished ServiceMock.ACLClient invocations
func (mmACLClient *ServiceMock) ACLClientAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmACLClient.afterACLClientCounter)
}

// ACLClientBeforeCounter returns a count of ServiceMock.ACLClient invocations
func (mmACLClient *ServiceMock) ACLClientBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmACLClient.beforeACLClientCounter)
}

// MinimockACLClientDone returns true if the count of the ACLClient invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockACLClientDone() bool {
	if m.ACLClientMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ACLClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ACLClientMock.invocationsDone()
}

// MinimockACLClientInspect logs each unmet expectation
func (m *ServiceMock) MinimockACLClientInspect() {
	for _, e := range m.ACLClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServiceMock.ACLClient")
		}
	}

	afterACLClientCounter := mm_atomic.LoadUint64(&m.afterACLClientCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ACLClientMock.defaultExpectation != nil && afterACLClientCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.ACLClient at\n%s", m.ACLClientMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcACLClient != nil && afterACLClientCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.ACLClient at\n%s", m.funcACLClientOrigin)
	}

	if !m.ACLClientMock.invocationsDone() && afterACLClientCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.ACLClient at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ACLClientMock.expectedInvocations), m.ACLClientMock.expectedInvocationsOrigin, afterACLClientCounter)
	}
}

type mServiceMockCheckCatalogUserPermission struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockCheckCatalogUserPermissionExpectation
	expectations       []*ServiceMockCheckCatalogUserPermissionExpectation

	callArgs []*ServiceMockCheckCatalogUserPermissionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockCheckCatalogUserPermissionExpectation specifies expectation struct of the Service.CheckCatalogUserPermission
type ServiceMockCheckCatalogUserPermissionExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockCheckCatalogUserPermissionParams
	paramPtrs          *ServiceMockCheckCatalogUserPermissionParamPtrs
	expectationOrigins ServiceMockCheckCatalogUserPermissionExpectationOrigins
	results            *ServiceMockCheckCatalogUserPermissionResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockCheckCatalogUserPermissionParams contains parameters of the Service.CheckCatalogUserPermission
type ServiceMockCheckCatalogUserPermissionParams struct {
	ctx context.Context
	s1  string
	s2  string
	s3  string
}

// ServiceMockCheckCatalogUserPermissionParamPtrs contains pointers to parameters of the Service.CheckCatalogUserPermission
type ServiceMockCheckCatalogUserPermissionParamPtrs struct {
	ctx *context.Context
	s1  *string
	s2  *string
	s3  *string
}

// ServiceMockCheckCatalogUserPermissionResults contains results of the Service.CheckCatalogUserPermission
type ServiceMockCheckCatalogUserPermissionResults struct {
	np1 *resource.Namespace
	kp1 *repository.KnowledgeBase
	err error
}

// ServiceMockCheckCatalogUserPermissionOrigins contains origins of expectations of the Service.CheckCatalogUserPermission
type ServiceMockCheckCatalogUserPermissionExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
	originS2  string
	originS3  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) Optional() *mServiceMockCheckCatalogUserPermission {
	mmCheckCatalogUserPermission.optional = true
	return mmCheckCatalogUserPermission
}

// Expect sets up expected params for Service.CheckCatalogUserPermission
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) Expect(ctx context.Context, s1 string, s2 string, s3 string) *mServiceMockCheckCatalogUserPermission {
	if mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermission != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Set")
	}

	if mmCheckCatalogUserPermission.defaultExpectation == nil {
		mmCheckCatalogUserPermission.defaultExpectation = &ServiceMockCheckCatalogUserPermissionExpectation{}
	}

	if mmCheckCatalogUserPermission.defaultExpectation.paramPtrs != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by ExpectParams functions")
	}

	mmCheckCatalogUserPermission.defaultExpectation.params = &ServiceMockCheckCatalogUserPermissionParams{ctx, s1, s2, s3}
	mmCheckCatalogUserPermission.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckCatalogUserPermission.expectations {
		if minimock.Equal(e.params, mmCheckCatalogUserPermission.defaultExpectation.params) {
			mmCheckCatalogUserPermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckCatalogUserPermission.defaultExpectation.params)
		}
	}

	return mmCheckCatalogUserPermission
}

// ExpectCtxParam1 sets up expected param ctx for Service.CheckCatalogUserPermission
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) ExpectCtxParam1(ctx context.Context) *mServiceMockCheckCatalogUserPermission {
	if mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermission != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Set")
	}

	if mmCheckCatalogUserPermission.defaultExpectation == nil {
		mmCheckCatalogUserPermission.defaultExpectation = &ServiceMockCheckCatalogUserPermissionExpectation{}
	}

	if mmCheckCatalogUserPermission.defaultExpectation.params != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Expect")
	}

	if mmCheckCatalogUserPermission.defaultExpectation.paramPtrs == nil {
		mmCheckCatalogUserPermission.defaultExpectation.paramPtrs = &ServiceMockCheckCatalogUserPermissionParamPtrs{}
	}
	mmCheckCatalogUserPermission.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckCatalogUserPermission.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckCatalogUserPermission
}

// ExpectS1Param2 sets up expected param s1 for Service.CheckCatalogUserPermission
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) ExpectS1Param2(s1 string) *mServiceMockCheckCatalogUserPermission {
	if mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermission != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Set")
	}

	if mmCheckCatalogUserPermission.defaultExpectation == nil {
		mmCheckCatalogUserPermission.defaultExpectation = &ServiceMockCheckCatalogUserPermissionExpectation{}
	}

	if mmCheckCatalogUserPermission.defaultExpectation.params != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Expect")
	}

	if mmCheckCatalogUserPermission.defaultExpectation.paramPtrs == nil {
		mmCheckCatalogUserPermission.defaultExpectation.paramPtrs = &ServiceMockCheckCatalogUserPermissionParamPtrs{}
	}
	mmCheckCatalogUserPermission.defaultExpectation.paramPtrs.s1 = &s1
	mmCheckCatalogUserPermission.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmCheckCatalogUserPermission
}

// ExpectS2Param3 sets up expected param s2 for Service.CheckCatalogUserPermission
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) ExpectS2Param3(s2 string) *mServiceMockCheckCatalogUserPermission {
	if mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermission != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Set")
	}

	if mmCheckCatalogUserPermission.defaultExpectation == nil {
		mmCheckCatalogUserPermission.defaultExpectation = &ServiceMockCheckCatalogUserPermissionExpectation{}
	}

	if mmCheckCatalogUserPermission.defaultExpectation.params != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Expect")
	}

	if mmCheckCatalogUserPermission.defaultExpectation.paramPtrs == nil {
		mmCheckCatalogUserPermission.defaultExpectation.paramPtrs = &ServiceMockCheckCatalogUserPermissionParamPtrs{}
	}
	mmCheckCatalogUserPermission.defaultExpectation.paramPtrs.s2 = &s2
	mmCheckCatalogUserPermission.defaultExpectation.expectationOrigins.originS2 = minimock.CallerInfo(1)

	return mmCheckCatalogUserPermission
}

// ExpectS3Param4 sets up expected param s3 for Service.CheckCatalogUserPermission
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) ExpectS3Param4(s3 string) *mServiceMockCheckCatalogUserPermission {
	if mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermission != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Set")
	}

	if mmCheckCatalogUserPermission.defaultExpectation == nil {
		mmCheckCatalogUserPermission.defaultExpectation = &ServiceMockCheckCatalogUserPermissionExpectation{}
	}

	if mmCheckCatalogUserPermission.defaultExpectation.params != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Expect")
	}

	if mmCheckCatalogUserPermission.defaultExpectation.paramPtrs == nil {
		mmCheckCatalogUserPermission.defaultExpectation.paramPtrs = &ServiceMockCheckCatalogUserPermissionParamPtrs{}
	}
	mmCheckCatalogUserPermission.defaultExpectation.paramPtrs.s3 = &s3
	mmCheckCatalogUserPermission.defaultExpectation.expectationOrigins.originS3 = minimock.CallerInfo(1)

	return mmCheckCatalogUserPermission
}

// Inspect accepts an inspector function that has same arguments as the Service.CheckCatalogUserPermission
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) Inspect(f func(ctx context.Context, s1 string, s2 string, s3 string)) *mServiceMockCheckCatalogUserPermission {
	if mmCheckCatalogUserPermission.mock.inspectFuncCheckCatalogUserPermission != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("Inspect function is already set for ServiceMock.CheckCatalogUserPermission")
	}

	mmCheckCatalogUserPermission.mock.inspectFuncCheckCatalogUserPermission = f

	return mmCheckCatalogUserPermission
}

// Return sets up results that will be returned by Service.CheckCatalogUserPermission
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) Return(np1 *resource.Namespace, kp1 *repository.KnowledgeBase, err error) *ServiceMock {
	if mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermission != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Set")
	}

	if mmCheckCatalogUserPermission.defaultExpectation == nil {
		mmCheckCatalogUserPermission.defaultExpectation = &ServiceMockCheckCatalogUserPermissionExpectation{mock: mmCheckCatalogUserPermission.mock}
	}
	mmCheckCatalogUserPermission.defaultExpectation.results = &ServiceMockCheckCatalogUserPermissionResults{np1, kp1, err}
	mmCheckCatalogUserPermission.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckCatalogUserPermission.mock
}

// Set uses given function f to mock the Service.CheckCatalogUserPermission method
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) Set(f func(ctx context.Context, s1 string, s2 string, s3 string) (np1 *resource.Namespace, kp1 *repository.KnowledgeBase, err error)) *ServiceMock {
	if mmCheckCatalogUserPermission.defaultExpectation != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("Default expectation is already set for the Service.CheckCatalogUserPermission method")
	}

	if len(mmCheckCatalogUserPermission.expectations) > 0 {
		mmCheckCatalogUserPermission.mock.t.Fatalf("Some expectations are already set for the Service.CheckCatalogUserPermission method")
	}

	mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermission = f
	mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermissionOrigin = minimock.CallerInfo(1)
	return mmCheckCatalogUserPermission.mock
}

// When sets expectation for the Service.CheckCatalogUserPermission which will trigger the result defined by the following
// Then helper
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) When(ctx context.Context, s1 string, s2 string, s3 string) *ServiceMockCheckCatalogUserPermissionExpectation {
	if mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermission != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Set")
	}

	expectation := &ServiceMockCheckCatalogUserPermissionExpectation{
		mock:               mmCheckCatalogUserPermission.mock,
		params:             &ServiceMockCheckCatalogUserPermissionParams{ctx, s1, s2, s3},
		expectationOrigins: ServiceMockCheckCatalogUserPermissionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckCatalogUserPermission.expectations = append(mmCheckCatalogUserPermission.expectations, expectation)
	return expectation
}

// Then sets up Service.CheckCatalogUserPermission return parameters for the expectation previously defined by the When method
func (e *ServiceMockCheckCatalogUserPermissionExpectation) Then(np1 *resource.Namespace, kp1 *repository.KnowledgeBase, err error) *ServiceMock {
	e.results = &ServiceMockCheckCatalogUserPermissionResults{np1, kp1, err}
	return e.mock
}

// Times sets number of times Service.CheckCatalogUserPermission should be invoked
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) Times(n uint64) *mServiceMockCheckCatalogUserPermission {
	if n == 0 {
		mmCheckCatalogUserPermission.mock.t.Fatalf("Times of ServiceMock.CheckCatalogUserPermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckCatalogUserPermission.expectedInvocations, n)
	mmCheckCatalogUserPermission.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckCatalogUserPermission
}

func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) invocationsDone() bool {
	if len(mmCheckCatalogUserPermission.expectations) == 0 && mmCheckCatalogUserPermission.defaultExpectation == nil && mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckCatalogUserPermission.mock.afterCheckCatalogUserPermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckCatalogUserPermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckCatalogUserPermission implements mm_service.Service
func (mmCheckCatalogUserPermission *ServiceMock) CheckCatalogUserPermission(ctx context.Context, s1 string, s2 string, s3 string) (np1 *resource.Namespace, kp1 *repository.KnowledgeBase, err error) {
	mm_atomic.AddUint64(&mmCheckCatalogUserPermission.beforeCheckCatalogUserPermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckCatalogUserPermission.afterCheckCatalogUserPermissionCounter, 1)

	mmCheckCatalogUserPermission.t.Helper()

	if mmCheckCatalogUserPermission.inspectFuncCheckCatalogUserPermission != nil {
		mmCheckCatalogUserPermission.inspectFuncCheckCatalogUserPermission(ctx, s1, s2, s3)
	}

	mm_params := ServiceMockCheckCatalogUserPermissionParams{ctx, s1, s2, s3}

	// Record call args
	mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.mutex.Lock()
	mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.callArgs = append(mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.callArgs, &mm_params)
	mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.mutex.Unlock()

	for _, e := range mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.np1, e.results.kp1, e.results.err
		}
	}

	if mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation.params
		mm_want_ptrs := mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockCheckCatalogUserPermissionParams{ctx, s1, s2, s3}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckCatalogUserPermission.t.Errorf("ServiceMock.CheckCatalogUserPermission got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmCheckCatalogUserPermission.t.Errorf("ServiceMock.CheckCatalogUserPermission got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

			if mm_want_ptrs.s2 != nil && !minimock.Equal(*mm_want_ptrs.s2, mm_got.s2) {
				mmCheckCatalogUserPermission.t.Errorf("ServiceMock.CheckCatalogUserPermission got unexpected parameter s2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation.expectationOrigins.originS2, *mm_want_ptrs.s2, mm_got.s2, minimock.Diff(*mm_want_ptrs.s2, mm_got.s2))
			}

			if mm_want_ptrs.s3 != nil && !minimock.Equal(*mm_want_ptrs.s3, mm_got.s3) {
				mmCheckCatalogUserPermission.t.Errorf("ServiceMock.CheckCatalogUserPermission got unexpected parameter s3, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation.expectationOrigins.originS3, *mm_want_ptrs.s3, mm_got.s3, minimock.Diff(*mm_want_ptrs.s3, mm_got.s3))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckCatalogUserPermission.t.Errorf("ServiceMock.CheckCatalogUserPermission got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckCatalogUserPermission.t.Fatal("No results are set for the ServiceMock.CheckCatalogUserPermission")
		}
		return (*mm_results).np1, (*mm_results).kp1, (*mm_results).err
	}
	if mmCheckCatalogUserPermission.funcCheckCatalogUserPermission != nil {
		return mmCheckCatalogUserPermission.funcCheckCatalogUserPermission(ctx, s1, s2, s3)
	}
	mmCheckCatalogUserPermission.t.Fatalf("Unexpected call to ServiceMock.CheckCatalogUserPermission. %v %v %v %v", ctx, s1, s2, s3)
	return
}

// CheckCatalogUserPermissionAfterCounter returns a count of finished ServiceMock.CheckCatalogUserPermission invocations
func (mmCheckCatalogUserPermission *ServiceMock) CheckCatalogUserPermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckCatalogUserPermission.afterCheckCatalogUserPermissionCounter)
}

// CheckCatalogUserPermissionBeforeCounter returns a count of ServiceMock.CheckCatalogUserPermission invocations
func (mmCheckCatalogUserPermission *ServiceMock) CheckCatalogUserPermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckCatalogUserPermission.beforeCheckCatalogUserPermissionCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.CheckCatalogUserPermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) Calls() []*ServiceMockCheckCatalogUserPermissionParams {
	mmCheckCatalogUserPermission.mutex.RLock()

	argCopy := make([]*ServiceMockCheckCatalogUserPermissionParams, len(mmCheckCatalogUserPermission.callArgs))
	copy(argCopy, mmCheckCatalogUserPermission.callArgs)

	mmCheckCatalogUserPermission.mutex.RUnlock()

	return argCopy
}

// MinimockCheckCatalogUserPermissionDone returns true if the count of the CheckCatalogUserPermission invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCheckCatalogUserPermissionDone() bool {
	if m.CheckCatalogUserPermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckCatalogUserPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckCatalogUserPermissionMock.invocationsDone()
}

// MinimockCheckCatalogUserPermissionInspect logs each unmet expectation
func (m *ServiceMock) MinimockCheckCatalogUserPermissionInspect() {
	for _, e := range m.CheckCatalogUserPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.CheckCatalogUserPermission at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckCatalogUserPermissionCounter := mm_atomic.LoadUint64(&m.afterCheckCatalogUserPermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckCatalogUserPermissionMock.defaultExpectation != nil && afterCheckCatalogUserPermissionCounter < 1 {
		if m.CheckCatalogUserPermissionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.CheckCatalogUserPermission at\n%s", m.CheckCatalogUserPermissionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.CheckCatalogUserPermission at\n%s with params: %#v", m.CheckCatalogUserPermissionMock.defaultExpectation.expectationOrigins.origin, *m.CheckCatalogUserPermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckCatalogUserPermission != nil && afterCheckCatalogUserPermissionCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.CheckCatalogUserPermission at\n%s", m.funcCheckCatalogUserPermissionOrigin)
	}

	if !m.CheckCatalogUserPermissionMock.invocationsDone() && afterCheckCatalogUserPermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.CheckCatalogUserPermission at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckCatalogUserPermissionMock.expectedInvocations), m.CheckCatalogUserPermissionMock.expectedInvocationsOrigin, afterCheckCatalogUserPermissionCounter)
	}
}

type mServiceMockCheckNamespacePermission struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockCheckNamespacePermissionExpectation
	expectations       []*ServiceMockCheckNamespacePermissionExpectation

	callArgs []*ServiceMockCheckNamespacePermissionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockCheckNamespacePermissionExpectation specifies expectation struct of the Service.CheckNamespacePermission
type ServiceMockCheckNamespacePermissionExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockCheckNamespacePermissionParams
	paramPtrs          *ServiceMockCheckNamespacePermissionParamPtrs
	expectationOrigins ServiceMockCheckNamespacePermissionExpectationOrigins
	results            *ServiceMockCheckNamespacePermissionResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockCheckNamespacePermissionParams contains parameters of the Service.CheckNamespacePermission
type ServiceMockCheckNamespacePermissionParams struct {
	ctx context.Context
	np1 *resource.Namespace
}

// ServiceMockCheckNamespacePermissionParamPtrs contains pointers to parameters of the Service.CheckNamespacePermission
type ServiceMockCheckNamespacePermissionParamPtrs struct {
	ctx *context.Context
	np1 **resource.Namespace
}

// ServiceMockCheckNamespacePermissionResults contains results of the Service.CheckNamespacePermission
type ServiceMockCheckNamespacePermissionResults struct {
	err error
}

// ServiceMockCheckNamespacePermissionOrigins contains origins of expectations of the Service.CheckNamespacePermission
type ServiceMockCheckNamespacePermissionExpectationOrigins struct {
	origin    string
	originCtx string
	originNp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) Optional() *mServiceMockCheckNamespacePermission {
	mmCheckNamespacePermission.optional = true
	return mmCheckNamespacePermission
}

// Expect sets up expected params for Service.CheckNamespacePermission
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) Expect(ctx context.Context, np1 *resource.Namespace) *mServiceMockCheckNamespacePermission {
	if mmCheckNamespacePermission.mock.funcCheckNamespacePermission != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("ServiceMock.CheckNamespacePermission mock is already set by Set")
	}

	if mmCheckNamespacePermission.defaultExpectation == nil {
		mmCheckNamespacePermission.defaultExpectation = &ServiceMockCheckNamespacePermissionExpectation{}
	}

	if mmCheckNamespacePermission.defaultExpectation.paramPtrs != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("ServiceMock.CheckNamespacePermission mock is already set by ExpectParams functions")
	}

	mmCheckNamespacePermission.defaultExpectation.params = &ServiceMockCheckNamespacePermissionParams{ctx, np1}
	mmCheckNamespacePermission.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckNamespacePermission.expectations {
		if minimock.Equal(e.params, mmCheckNamespacePermission.defaultExpectation.params) {
			mmCheckNamespacePermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckNamespacePermission.defaultExpectation.params)
		}
	}

	return mmCheckNamespacePermission
}

// ExpectCtxParam1 sets up expected param ctx for Service.CheckNamespacePermission
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) ExpectCtxParam1(ctx context.Context) *mServiceMockCheckNamespacePermission {
	if mmCheckNamespacePermission.mock.funcCheckNamespacePermission != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("ServiceMock.CheckNamespacePermission mock is already set by Set")
	}

	if mmCheckNamespacePermission.defaultExpectation == nil {
		mmCheckNamespacePermission.defaultExpectation = &ServiceMockCheckNamespacePermissionExpectation{}
	}

	if mmCheckNamespacePermission.defaultExpectation.params != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("ServiceMock.CheckNamespacePermission mock is already set by Expect")
	}

	if mmCheckNamespacePermission.defaultExpectation.paramPtrs == nil {
		mmCheckNamespacePermission.defaultExpectation.paramPtrs = &ServiceMockCheckNamespacePermissionParamPtrs{}
	}
	mmCheckNamespacePermission.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckNamespacePermission.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckNamespacePermission
}

// ExpectNp1Param2 sets up expected param np1 for Service.CheckNamespacePermission
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) ExpectNp1Param2(np1 *resource.Namespace) *mServiceMockCheckNamespacePermission {
	if mmCheckNamespacePermission.mock.funcCheckNamespacePermission != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("ServiceMock.CheckNamespacePermission mock is already set by Set")
	}

	if mmCheckNamespacePermission.defaultExpectation == nil {
		mmCheckNamespacePermission.defaultExpectation = &ServiceMockCheckNamespacePermissionExpectation{}
	}

	if mmCheckNamespacePermission.defaultExpectation.params != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("ServiceMock.CheckNamespacePermission mock is already set by Expect")
	}

	if mmCheckNamespacePermission.defaultExpectation.paramPtrs == nil {
		mmCheckNamespacePermission.defaultExpectation.paramPtrs = &ServiceMockCheckNamespacePermissionParamPtrs{}
	}
	mmCheckNamespacePermission.defaultExpectation.paramPtrs.np1 = &np1
	mmCheckNamespacePermission.defaultExpectation.expectationOrigins.originNp1 = minimock.CallerInfo(1)

	return mmCheckNamespacePermission
}

// Inspect accepts an inspector function that has same arguments as the Service.CheckNamespacePermission
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) Inspect(f func(ctx context.Context, np1 *resource.Namespace)) *mServiceMockCheckNamespacePermission {
	if mmCheckNamespacePermission.mock.inspectFuncCheckNamespacePermission != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("Inspect function is already set for ServiceMock.CheckNamespacePermission")
	}

	mmCheckNamespacePermission.mock.inspectFuncCheckNamespacePermission = f

	return mmCheckNamespacePermission
}

// Return sets up results that will be returned by Service.CheckNamespacePermission
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) Return(err error) *ServiceMock {
	if mmCheckNamespacePermission.mock.funcCheckNamespacePermission != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("ServiceMock.CheckNamespacePermission mock is already set by Set")
	}

	if mmCheckNamespacePermission.defaultExpectation == nil {
		mmCheckNamespacePermission.defaultExpectation = &ServiceMockCheckNamespacePermissionExpectation{mock: mmCheckNamespacePermission.mock}
	}
	mmCheckNamespacePermission.defaultExpectation.results = &ServiceMockCheckNamespacePermissionResults{err}
	mmCheckNamespacePermission.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckNamespacePermission.mock
}

// Set uses given function f to mock the Service.CheckNamespacePermission method
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) Set(f func(ctx context.Context, np1 *resource.Namespace) (err error)) *ServiceMock {
	if mmCheckNamespacePermission.defaultExpectation != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("Default expectation is already set for the Service.CheckNamespacePermission method")
	}

	if len(mmCheckNamespacePermission.expectations) > 0 {
		mmCheckNamespacePermission.mock.t.Fatalf("Some expectations are already set for the Service.CheckNamespacePermission method")
	}

	mmCheckNamespacePermission.mock.funcCheckNamespacePermission = f
	mmCheckNamespacePermission.mock.funcCheckNamespacePermissionOrigin = minimock.CallerInfo(1)
	return mmCheckNamespacePermission.mock
}

// When sets expectation for the Service.CheckNamespacePermission which will trigger the result defined by the following
// Then helper
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) When(ctx context.Context, np1 *resource.Namespace) *ServiceMockCheckNamespacePermissionExpectation {
	if mmCheckNamespacePermission.mock.funcCheckNamespacePermission != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("ServiceMock.CheckNamespacePermission mock is already set by Set")
	}

	expectation := &ServiceMockCheckNamespacePermissionExpectation{
		mock:               mmCheckNamespacePermission.mock,
		params:             &ServiceMockCheckNamespacePermissionParams{ctx, np1},
		expectationOrigins: ServiceMockCheckNamespacePermissionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckNamespacePermission.expectations = append(mmCheckNamespacePermission.expectations, expectation)
	return expectation
}

// Then sets up Service.CheckNamespacePermission return parameters for the expectation previously defined by the When method
func (e *ServiceMockCheckNamespacePermissionExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockCheckNamespacePermissionResults{err}
	return e.mock
}

// Times sets number of times Service.CheckNamespacePermission should be invoked
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) Times(n uint64) *mServiceMockCheckNamespacePermission {
	if n == 0 {
		mmCheckNamespacePermission.mock.t.Fatalf("Times of ServiceMock.CheckNamespacePermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckNamespacePermission.expectedInvocations, n)
	mmCheckNamespacePermission.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckNamespacePermission
}

func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) invocationsDone() bool {
	if len(mmCheckNamespacePermission.expectations) == 0 && mmCheckNamespacePermission.defaultExpectation == nil && mmCheckNamespacePermission.mock.funcCheckNamespacePermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckNamespacePermission.mock.afterCheckNamespacePermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckNamespacePermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckNamespacePermission implements mm_service.Service
func (mmCheckNamespacePermission *ServiceMock) CheckNamespacePermission(ctx context.Context, np1 *resource.Namespace) (err error) {
	mm_atomic.AddUint64(&mmCheckNamespacePermission.beforeCheckNamespacePermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckNamespacePermission.afterCheckNamespacePermissionCounter, 1)

	mmCheckNamespacePermission.t.Helper()

	if mmCheckNamespacePermission.inspectFuncCheckNamespacePermission != nil {
		mmCheckNamespacePermission.inspectFuncCheckNamespacePermission(ctx, np1)
	}

	mm_params := ServiceMockCheckNamespacePermissionParams{ctx, np1}

	// Record call args
	mmCheckNamespacePermission.CheckNamespacePermissionMock.mutex.Lock()
	mmCheckNamespacePermission.CheckNamespacePermissionMock.callArgs = append(mmCheckNamespacePermission.CheckNamespacePermissionMock.callArgs, &mm_params)
	mmCheckNamespacePermission.CheckNamespacePermissionMock.mutex.Unlock()

	for _, e := range mmCheckNamespacePermission.CheckNamespacePermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCheckNamespacePermission.CheckNamespacePermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckNamespacePermission.CheckNamespacePermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckNamespacePermission.CheckNamespacePermissionMock.defaultExpectation.params
		mm_want_ptrs := mmCheckNamespacePermission.CheckNamespacePermissionMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockCheckNamespacePermissionParams{ctx, np1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckNamespacePermission.t.Errorf("ServiceMock.CheckNamespacePermission got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckNamespacePermission.CheckNamespacePermissionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.np1 != nil && !minimock.Equal(*mm_want_ptrs.np1, mm_got.np1) {
				mmCheckNamespacePermission.t.Errorf("ServiceMock.CheckNamespacePermission got unexpected parameter np1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckNamespacePermission.CheckNamespacePermissionMock.defaultExpectation.expectationOrigins.originNp1, *mm_want_ptrs.np1, mm_got.np1, minimock.Diff(*mm_want_ptrs.np1, mm_got.np1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckNamespacePermission.t.Errorf("ServiceMock.CheckNamespacePermission got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckNamespacePermission.CheckNamespacePermissionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckNamespacePermission.CheckNamespacePermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckNamespacePermission.t.Fatal("No results are set for the ServiceMock.CheckNamespacePermission")
		}
		return (*mm_results).err
	}
	if mmCheckNamespacePermission.funcCheckNamespacePermission != nil {
		return mmCheckNamespacePermission.funcCheckNamespacePermission(ctx, np1)
	}
	mmCheckNamespacePermission.t.Fatalf("Unexpected call to ServiceMock.CheckNamespacePermission. %v %v", ctx, np1)
	return
}

// CheckNamespacePermissionAfterCounter returns a count of finished ServiceMock.CheckNamespacePermission invocations
func (mmCheckNamespacePermission *ServiceMock) CheckNamespacePermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckNamespacePermission.afterCheckNamespacePermissionCounter)
}

// CheckNamespacePermissionBeforeCounter returns a count of ServiceMock.CheckNamespacePermission invocations
func (mmCheckNamespacePermission *ServiceMock) CheckNamespacePermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckNamespacePermission.beforeCheckNamespacePermissionCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.CheckNamespacePermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) Calls() []*ServiceMockCheckNamespacePermissionParams {
	mmCheckNamespacePermission.mutex.RLock()

	argCopy := make([]*ServiceMockCheckNamespacePermissionParams, len(mmCheckNamespacePermission.callArgs))
	copy(argCopy, mmCheckNamespacePermission.callArgs)

	mmCheckNamespacePermission.mutex.RUnlock()

	return argCopy
}

// MinimockCheckNamespacePermissionDone returns true if the count of the CheckNamespacePermission invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCheckNamespacePermissionDone() bool {
	if m.CheckNamespacePermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckNamespacePermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckNamespacePermissionMock.invocationsDone()
}

// MinimockCheckNamespacePermissionInspect logs each unmet expectation
func (m *ServiceMock) MinimockCheckNamespacePermissionInspect() {
	for _, e := range m.CheckNamespacePermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.CheckNamespacePermission at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckNamespacePermissionCounter := mm_atomic.LoadUint64(&m.afterCheckNamespacePermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckNamespacePermissionMock.defaultExpectation != nil && afterCheckNamespacePermissionCounter < 1 {
		if m.CheckNamespacePermissionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.CheckNamespacePermission at\n%s", m.CheckNamespacePermissionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.CheckNamespacePermission at\n%s with params: %#v", m.CheckNamespacePermissionMock.defaultExpectation.expectationOrigins.origin, *m.CheckNamespacePermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckNamespacePermission != nil && afterCheckNamespacePermissionCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.CheckNamespacePermission at\n%s", m.funcCheckNamespacePermissionOrigin)
	}

	if !m.CheckNamespacePermissionMock.invocationsDone() && afterCheckNamespacePermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.CheckNamespacePermission at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckNamespacePermissionMock.expectedInvocations), m.CheckNamespacePermissionMock.expectedInvocationsOrigin, afterCheckNamespacePermissionCounter)
	}
}

type mServiceMockChunkMarkdownPipe struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockChunkMarkdownPipeExpectation
	expectations       []*ServiceMockChunkMarkdownPipeExpectation

	callArgs []*ServiceMockChunkMarkdownPipeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockChunkMarkdownPipeExpectation specifies expectation struct of the Service.ChunkMarkdownPipe
type ServiceMockChunkMarkdownPipeExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockChunkMarkdownPipeParams
	paramPtrs          *ServiceMockChunkMarkdownPipeParamPtrs
	expectationOrigins ServiceMockChunkMarkdownPipeExpectationOrigins
	results            *ServiceMockChunkMarkdownPipeResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockChunkMarkdownPipeParams contains parameters of the Service.ChunkMarkdownPipe
type ServiceMockChunkMarkdownPipeParams struct {
	ctx context.Context
	s1  string
}

// ServiceMockChunkMarkdownPipeParamPtrs contains pointers to parameters of the Service.ChunkMarkdownPipe
type ServiceMockChunkMarkdownPipeParamPtrs struct {
	ctx *context.Context
	s1  *string
}

// ServiceMockChunkMarkdownPipeResults contains results of the Service.ChunkMarkdownPipe
type ServiceMockChunkMarkdownPipeResults struct {
	cp1 *mm_service.ChunkingResult
	err error
}

// ServiceMockChunkMarkdownPipeOrigins contains origins of expectations of the Service.ChunkMarkdownPipe
type ServiceMockChunkMarkdownPipeExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmChunkMarkdownPipe *mServiceMockChunkMarkdownPipe) Optional() *mServiceMockChunkMarkdownPipe {
	mmChunkMarkdownPipe.optional = true
	return mmChunkMarkdownPipe
}

// Expect sets up expected params for Service.ChunkMarkdownPipe
func (mmChunkMarkdownPipe *mServiceMockChunkMarkdownPipe) Expect(ctx context.Context, s1 string) *mServiceMockChunkMarkdownPipe {
	if mmChunkMarkdownPipe.mock.funcChunkMarkdownPipe != nil {
		mmChunkMarkdownPipe.mock.t.Fatalf("ServiceMock.ChunkMarkdownPipe mock is already set by Set")
	}

	if mmChunkMarkdownPipe.defaultExpectation == nil {
		mmChunkMarkdownPipe.defaultExpectation = &ServiceMockChunkMarkdownPipeExpectation{}
	}

	if mmChunkMarkdownPipe.defaultExpectation.paramPtrs != nil {
		mmChunkMarkdownPipe.mock.t.Fatalf("ServiceMock.ChunkMarkdownPipe mock is already set by ExpectParams functions")
	}

	mmChunkMarkdownPipe.defaultExpectation.params = &ServiceMockChunkMarkdownPipeParams{ctx, s1}
	mmChunkMarkdownPipe.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmChunkMarkdownPipe.expectations {
		if minimock.Equal(e.params, mmChunkMarkdownPipe.defaultExpectation.params) {
			mmChunkMarkdownPipe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChunkMarkdownPipe.defaultExpectation.params)
		}
	}

	return mmChunkMarkdownPipe
}

// ExpectCtxParam1 sets up expected param ctx for Service.ChunkMarkdownPipe
func (mmChunkMarkdownPipe *mServiceMockChunkMarkdownPipe) ExpectCtxParam1(ctx context.Context) *mServiceMockChunkMarkdownPipe {
	if mmChunkMarkdownPipe.mock.funcChunkMarkdownPipe != nil {
		mmChunkMarkdownPipe.mock.t.Fatalf("ServiceMock.ChunkMarkdownPipe mock is already set by Set")
	}

	if mmChunkMarkdownPipe.defaultExpectation == nil {
		mmChunkMarkdownPipe.defaultExpectation = &ServiceMockChunkMarkdownPipeExpectation{}
	}

	if mmChunkMarkdownPipe.defaultExpectation.params != nil {
		mmChunkMarkdownPipe.mock.t.Fatalf("ServiceMock.ChunkMarkdownPipe mock is already set by Expect")
	}

	if mmChunkMarkdownPipe.defaultExpectation.paramPtrs == nil {
		mmChunkMarkdownPipe.defaultExpectation.paramPtrs = &ServiceMockChunkMarkdownPipeParamPtrs{}
	}
	mmChunkMarkdownPipe.defaultExpectation.paramPtrs.ctx = &ctx
	mmChunkMarkdownPipe.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmChunkMarkdownPipe
}

// ExpectS1Param2 sets up expected param s1 for Service.ChunkMarkdownPipe
func (mmChunkMarkdownPipe *mServiceMockChunkMarkdownPipe) ExpectS1Param2(s1 string) *mServiceMockChunkMarkdownPipe {
	if mmChunkMarkdownPipe.mock.funcChunkMarkdownPipe != nil {
		mmChunkMarkdownPipe.mock.t.Fatalf("ServiceMock.ChunkMarkdownPipe mock is already set by Set")
	}

	if mmChunkMarkdownPipe.defaultExpectation == nil {
		mmChunkMarkdownPipe.defaultExpectation = &ServiceMockChunkMarkdownPipeExpectation{}
	}

	if mmChunkMarkdownPipe.defaultExpectation.params != nil {
		mmChunkMarkdownPipe.mock.t.Fatalf("ServiceMock.ChunkMarkdownPipe mock is already set by Expect")
	}

	if mmChunkMarkdownPipe.defaultExpectation.paramPtrs == nil {
		mmChunkMarkdownPipe.defaultExpectation.paramPtrs = &ServiceMockChunkMarkdownPipeParamPtrs{}
	}
	mmChunkMarkdownPipe.defaultExpectation.paramPtrs.s1 = &s1
	mmChunkMarkdownPipe.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmChunkMarkdownPipe
}

// Inspect accepts an inspector function that has same arguments as the Service.ChunkMarkdownPipe
func (mmChunkMarkdownPipe *mServiceMockChunkMarkdownPipe) Inspect(f func(ctx context.Context, s1 string)) *mServiceMockChunkMarkdownPipe {
	if mmChunkMarkdownPipe.mock.inspectFuncChunkMarkdownPipe != nil {
		mmChunkMarkdownPipe.mock.t.Fatalf("Inspect function is already set for ServiceMock.ChunkMarkdownPipe")
	}

	mmChunkMarkdownPipe.mock.inspectFuncChunkMarkdownPipe = f

	return mmChunkMarkdownPipe
}

// Return sets up results that will be returned by Service.ChunkMarkdownPipe
func (mmChunkMarkdownPipe *mServiceMockChunkMarkdownPipe) Return(cp1 *mm_service.ChunkingResult, err error) *ServiceMock {
	if mmChunkMarkdownPipe.mock.funcChunkMarkdownPipe != nil {
		mmChunkMarkdownPipe.mock.t.Fatalf("ServiceMock.ChunkMarkdownPipe mock is already set by Set")
	}

	if mmChunkMarkdownPipe.defaultExpectation == nil {
		mmChunkMarkdownPipe.defaultExpectation = &ServiceMockChunkMarkdownPipeExpectation{mock: mmChunkMarkdownPipe.mock}
	}
	mmChunkMarkdownPipe.defaultExpectation.results = &ServiceMockChunkMarkdownPipeResults{cp1, err}
	mmChunkMarkdownPipe.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmChunkMarkdownPipe.mock
}

// Set uses given function f to mock the Service.ChunkMarkdownPipe method
func (mmChunkMarkdownPipe *mServiceMockChunkMarkdownPipe) Set(f func(ctx context.Context, s1 string) (cp1 *mm_service.ChunkingResult, err error)) *ServiceMock {
	if mmChunkMarkdownPipe.defaultExpectation != nil {
		mmChunkMarkdownPipe.mock.t.Fatalf("Default expectation is already set for the Service.ChunkMarkdownPipe method")
	}

	if len(mmChunkMarkdownPipe.expectations) > 0 {
		mmChunkMarkdownPipe.mock.t.Fatalf("Some expectations are already set for the Service.ChunkMarkdownPipe method")
	}

	mmChunkMarkdownPipe.mock.funcChunkMarkdownPipe = f
	mmChunkMarkdownPipe.mock.funcChunkMarkdownPipeOrigin = minimock.CallerInfo(1)
	return mmChunkMarkdownPipe.mock
}

// When sets expectation for the Service.ChunkMarkdownPipe which will trigger the result defined by the following
// Then helper
func (mmChunkMarkdownPipe *mServiceMockChunkMarkdownPipe) When(ctx context.Context, s1 string) *ServiceMockChunkMarkdownPipeExpectation {
	if mmChunkMarkdownPipe.mock.funcChunkMarkdownPipe != nil {
		mmChunkMarkdownPipe.mock.t.Fatalf("ServiceMock.ChunkMarkdownPipe mock is already set by Set")
	}

	expectation := &ServiceMockChunkMarkdownPipeExpectation{
		mock:               mmChunkMarkdownPipe.mock,
		params:             &ServiceMockChunkMarkdownPipeParams{ctx, s1},
		expectationOrigins: ServiceMockChunkMarkdownPipeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmChunkMarkdownPipe.expectations = append(mmChunkMarkdownPipe.expectations, expectation)
	return expectation
}

// Then sets up Service.ChunkMarkdownPipe return parameters for the expectation previously defined by the When method
func (e *ServiceMockChunkMarkdownPipeExpectation) Then(cp1 *mm_service.ChunkingResult, err error) *ServiceMock {
	e.results = &ServiceMockChunkMarkdownPipeResults{cp1, err}
	return e.mock
}

// Times sets number of times Service.ChunkMarkdownPipe should be invoked
func (mmChunkMarkdownPipe *mServiceMockChunkMarkdownPipe) Times(n uint64) *mServiceMockChunkMarkdownPipe {
	if n == 0 {
		mmChunkMarkdownPipe.mock.t.Fatalf("Times of ServiceMock.ChunkMarkdownPipe mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmChunkMarkdownPipe.expectedInvocations, n)
	mmChunkMarkdownPipe.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmChunkMarkdownPipe
}

func (mmChunkMarkdownPipe *mServiceMockChunkMarkdownPipe) invocationsDone() bool {
	if len(mmChunkMarkdownPipe.expectations) == 0 && mmChunkMarkdownPipe.defaultExpectation == nil && mmChunkMarkdownPipe.mock.funcChunkMarkdownPipe == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmChunkMarkdownPipe.mock.afterChunkMarkdownPipeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmChunkMarkdownPipe.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ChunkMarkdownPipe implements mm_service.Service
func (mmChunkMarkdownPipe *ServiceMock) ChunkMarkdownPipe(ctx context.Context, s1 string) (cp1 *mm_service.ChunkingResult, err error) {
	mm_atomic.AddUint64(&mmChunkMarkdownPipe.beforeChunkMarkdownPipeCounter, 1)
	defer mm_atomic.AddUint64(&mmChunkMarkdownPipe.afterChunkMarkdownPipeCounter, 1)

	mmChunkMarkdownPipe.t.Helper()

	if mmChunkMarkdownPipe.inspectFuncChunkMarkdownPipe != nil {
		mmChunkMarkdownPipe.inspectFuncChunkMarkdownPipe(ctx, s1)
	}

	mm_params := ServiceMockChunkMarkdownPipeParams{ctx, s1}

	// Record call args
	mmChunkMarkdownPipe.ChunkMarkdownPipeMock.mutex.Lock()
	mmChunkMarkdownPipe.ChunkMarkdownPipeMock.callArgs = append(mmChunkMarkdownPipe.ChunkMarkdownPipeMock.callArgs, &mm_params)
	mmChunkMarkdownPipe.ChunkMarkdownPipeMock.mutex.Unlock()

	for _, e := range mmChunkMarkdownPipe.ChunkMarkdownPipeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmChunkMarkdownPipe.ChunkMarkdownPipeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChunkMarkdownPipe.ChunkMarkdownPipeMock.defaultExpectation.Counter, 1)
		mm_want := mmChunkMarkdownPipe.ChunkMarkdownPipeMock.defaultExpectation.params
		mm_want_ptrs := mmChunkMarkdownPipe.ChunkMarkdownPipeMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockChunkMarkdownPipeParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmChunkMarkdownPipe.t.Errorf("ServiceMock.ChunkMarkdownPipe got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChunkMarkdownPipe.ChunkMarkdownPipeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmChunkMarkdownPipe.t.Errorf("ServiceMock.ChunkMarkdownPipe got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChunkMarkdownPipe.ChunkMarkdownPipeMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChunkMarkdownPipe.t.Errorf("ServiceMock.ChunkMarkdownPipe got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmChunkMarkdownPipe.ChunkMarkdownPipeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChunkMarkdownPipe.ChunkMarkdownPipeMock.defaultExpectation.results
		if mm_results == nil {
			mmChunkMarkdownPipe.t.Fatal("No results are set for the ServiceMock.ChunkMarkdownPipe")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmChunkMarkdownPipe.funcChunkMarkdownPipe != nil {
		return mmChunkMarkdownPipe.funcChunkMarkdownPipe(ctx, s1)
	}
	mmChunkMarkdownPipe.t.Fatalf("Unexpected call to ServiceMock.ChunkMarkdownPipe. %v %v", ctx, s1)
	return
}

// ChunkMarkdownPipeAfterCounter returns a count of finished ServiceMock.ChunkMarkdownPipe invocations
func (mmChunkMarkdownPipe *ServiceMock) ChunkMarkdownPipeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChunkMarkdownPipe.afterChunkMarkdownPipeCounter)
}

// ChunkMarkdownPipeBeforeCounter returns a count of ServiceMock.ChunkMarkdownPipe invocations
func (mmChunkMarkdownPipe *ServiceMock) ChunkMarkdownPipeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChunkMarkdownPipe.beforeChunkMarkdownPipeCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.ChunkMarkdownPipe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChunkMarkdownPipe *mServiceMockChunkMarkdownPipe) Calls() []*ServiceMockChunkMarkdownPipeParams {
	mmChunkMarkdownPipe.mutex.RLock()

	argCopy := make([]*ServiceMockChunkMarkdownPipeParams, len(mmChunkMarkdownPipe.callArgs))
	copy(argCopy, mmChunkMarkdownPipe.callArgs)

	mmChunkMarkdownPipe.mutex.RUnlock()

	return argCopy
}

// MinimockChunkMarkdownPipeDone returns true if the count of the ChunkMarkdownPipe invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockChunkMarkdownPipeDone() bool {
	if m.ChunkMarkdownPipeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ChunkMarkdownPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ChunkMarkdownPipeMock.invocationsDone()
}

// MinimockChunkMarkdownPipeInspect logs each unmet expectation
func (m *ServiceMock) MinimockChunkMarkdownPipeInspect() {
	for _, e := range m.ChunkMarkdownPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.ChunkMarkdownPipe at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterChunkMarkdownPipeCounter := mm_atomic.LoadUint64(&m.afterChunkMarkdownPipeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ChunkMarkdownPipeMock.defaultExpectation != nil && afterChunkMarkdownPipeCounter < 1 {
		if m.ChunkMarkdownPipeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.ChunkMarkdownPipe at\n%s", m.ChunkMarkdownPipeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.ChunkMarkdownPipe at\n%s with params: %#v", m.ChunkMarkdownPipeMock.defaultExpectation.expectationOrigins.origin, *m.ChunkMarkdownPipeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChunkMarkdownPipe != nil && afterChunkMarkdownPipeCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.ChunkMarkdownPipe at\n%s", m.funcChunkMarkdownPipeOrigin)
	}

	if !m.ChunkMarkdownPipeMock.invocationsDone() && afterChunkMarkdownPipeCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.ChunkMarkdownPipe at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ChunkMarkdownPipeMock.expectedInvocations), m.ChunkMarkdownPipeMock.expectedInvocationsOrigin, afterChunkMarkdownPipeCounter)
	}
}

type mServiceMockChunkTextPipe struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockChunkTextPipeExpectation
	expectations       []*ServiceMockChunkTextPipeExpectation

	callArgs []*ServiceMockChunkTextPipeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockChunkTextPipeExpectation specifies expectation struct of the Service.ChunkTextPipe
type ServiceMockChunkTextPipeExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockChunkTextPipeParams
	paramPtrs          *ServiceMockChunkTextPipeParamPtrs
	expectationOrigins ServiceMockChunkTextPipeExpectationOrigins
	results            *ServiceMockChunkTextPipeResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockChunkTextPipeParams contains parameters of the Service.ChunkTextPipe
type ServiceMockChunkTextPipeParams struct {
	ctx context.Context
	s1  string
}

// ServiceMockChunkTextPipeParamPtrs contains pointers to parameters of the Service.ChunkTextPipe
type ServiceMockChunkTextPipeParamPtrs struct {
	ctx *context.Context
	s1  *string
}

// ServiceMockChunkTextPipeResults contains results of the Service.ChunkTextPipe
type ServiceMockChunkTextPipeResults struct {
	cp1 *mm_service.ChunkingResult
	err error
}

// ServiceMockChunkTextPipeOrigins contains origins of expectations of the Service.ChunkTextPipe
type ServiceMockChunkTextPipeExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmChunkTextPipe *mServiceMockChunkTextPipe) Optional() *mServiceMockChunkTextPipe {
	mmChunkTextPipe.optional = true
	return mmChunkTextPipe
}

// Expect sets up expected params for Service.ChunkTextPipe
func (mmChunkTextPipe *mServiceMockChunkTextPipe) Expect(ctx context.Context, s1 string) *mServiceMockChunkTextPipe {
	if mmChunkTextPipe.mock.funcChunkTextPipe != nil {
		mmChunkTextPipe.mock.t.Fatalf("ServiceMock.ChunkTextPipe mock is already set by Set")
	}

	if mmChunkTextPipe.defaultExpectation == nil {
		mmChunkTextPipe.defaultExpectation = &ServiceMockChunkTextPipeExpectation{}
	}

	if mmChunkTextPipe.defaultExpectation.paramPtrs != nil {
		mmChunkTextPipe.mock.t.Fatalf("ServiceMock.ChunkTextPipe mock is already set by ExpectParams functions")
	}

	mmChunkTextPipe.defaultExpectation.params = &ServiceMockChunkTextPipeParams{ctx, s1}
	mmChunkTextPipe.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmChunkTextPipe.expectations {
		if minimock.Equal(e.params, mmChunkTextPipe.defaultExpectation.params) {
			mmChunkTextPipe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChunkTextPipe.defaultExpectation.params)
		}
	}

	return mmChunkTextPipe
}

// ExpectCtxParam1 sets up expected param ctx for Service.ChunkTextPipe
func (mmChunkTextPipe *mServiceMockChunkTextPipe) ExpectCtxParam1(ctx context.Context) *mServiceMockChunkTextPipe {
	if mmChunkTextPipe.mock.funcChunkTextPipe != nil {
		mmChunkTextPipe.mock.t.Fatalf("ServiceMock.ChunkTextPipe mock is already set by Set")
	}

	if mmChunkTextPipe.defaultExpectation == nil {
		mmChunkTextPipe.defaultExpectation = &ServiceMockChunkTextPipeExpectation{}
	}

	if mmChunkTextPipe.defaultExpectation.params != nil {
		mmChunkTextPipe.mock.t.Fatalf("ServiceMock.ChunkTextPipe mock is already set by Expect")
	}

	if mmChunkTextPipe.defaultExpectation.paramPtrs == nil {
		mmChunkTextPipe.defaultExpectation.paramPtrs = &ServiceMockChunkTextPipeParamPtrs{}
	}
	mmChunkTextPipe.defaultExpectation.paramPtrs.ctx = &ctx
	mmChunkTextPipe.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmChunkTextPipe
}

// ExpectS1Param2 sets up expected param s1 for Service.ChunkTextPipe
func (mmChunkTextPipe *mServiceMockChunkTextPipe) ExpectS1Param2(s1 string) *mServiceMockChunkTextPipe {
	if mmChunkTextPipe.mock.funcChunkTextPipe != nil {
		mmChunkTextPipe.mock.t.Fatalf("ServiceMock.ChunkTextPipe mock is already set by Set")
	}

	if mmChunkTextPipe.defaultExpectation == nil {
		mmChunkTextPipe.defaultExpectation = &ServiceMockChunkTextPipeExpectation{}
	}

	if mmChunkTextPipe.defaultExpectation.params != nil {
		mmChunkTextPipe.mock.t.Fatalf("ServiceMock.ChunkTextPipe mock is already set by Expect")
	}

	if mmChunkTextPipe.defaultExpectation.paramPtrs == nil {
		mmChunkTextPipe.defaultExpectation.paramPtrs = &ServiceMockChunkTextPipeParamPtrs{}
	}
	mmChunkTextPipe.defaultExpectation.paramPtrs.s1 = &s1
	mmChunkTextPipe.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmChunkTextPipe
}

// Inspect accepts an inspector function that has same arguments as the Service.ChunkTextPipe
func (mmChunkTextPipe *mServiceMockChunkTextPipe) Inspect(f func(ctx context.Context, s1 string)) *mServiceMockChunkTextPipe {
	if mmChunkTextPipe.mock.inspectFuncChunkTextPipe != nil {
		mmChunkTextPipe.mock.t.Fatalf("Inspect function is already set for ServiceMock.ChunkTextPipe")
	}

	mmChunkTextPipe.mock.inspectFuncChunkTextPipe = f

	return mmChunkTextPipe
}

// Return sets up results that will be returned by Service.ChunkTextPipe
func (mmChunkTextPipe *mServiceMockChunkTextPipe) Return(cp1 *mm_service.ChunkingResult, err error) *ServiceMock {
	if mmChunkTextPipe.mock.funcChunkTextPipe != nil {
		mmChunkTextPipe.mock.t.Fatalf("ServiceMock.ChunkTextPipe mock is already set by Set")
	}

	if mmChunkTextPipe.defaultExpectation == nil {
		mmChunkTextPipe.defaultExpectation = &ServiceMockChunkTextPipeExpectation{mock: mmChunkTextPipe.mock}
	}
	mmChunkTextPipe.defaultExpectation.results = &ServiceMockChunkTextPipeResults{cp1, err}
	mmChunkTextPipe.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmChunkTextPipe.mock
}

// Set uses given function f to mock the Service.ChunkTextPipe method
func (mmChunkTextPipe *mServiceMockChunkTextPipe) Set(f func(ctx context.Context, s1 string) (cp1 *mm_service.ChunkingResult, err error)) *ServiceMock {
	if mmChunkTextPipe.defaultExpectation != nil {
		mmChunkTextPipe.mock.t.Fatalf("Default expectation is already set for the Service.ChunkTextPipe method")
	}

	if len(mmChunkTextPipe.expectations) > 0 {
		mmChunkTextPipe.mock.t.Fatalf("Some expectations are already set for the Service.ChunkTextPipe method")
	}

	mmChunkTextPipe.mock.funcChunkTextPipe = f
	mmChunkTextPipe.mock.funcChunkTextPipeOrigin = minimock.CallerInfo(1)
	return mmChunkTextPipe.mock
}

// When sets expectation for the Service.ChunkTextPipe which will trigger the result defined by the following
// Then helper
func (mmChunkTextPipe *mServiceMockChunkTextPipe) When(ctx context.Context, s1 string) *ServiceMockChunkTextPipeExpectation {
	if mmChunkTextPipe.mock.funcChunkTextPipe != nil {
		mmChunkTextPipe.mock.t.Fatalf("ServiceMock.ChunkTextPipe mock is already set by Set")
	}

	expectation := &ServiceMockChunkTextPipeExpectation{
		mock:               mmChunkTextPipe.mock,
		params:             &ServiceMockChunkTextPipeParams{ctx, s1},
		expectationOrigins: ServiceMockChunkTextPipeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmChunkTextPipe.expectations = append(mmChunkTextPipe.expectations, expectation)
	return expectation
}

// Then sets up Service.ChunkTextPipe return parameters for the expectation previously defined by the When method
func (e *ServiceMockChunkTextPipeExpectation) Then(cp1 *mm_service.ChunkingResult, err error) *ServiceMock {
	e.results = &ServiceMockChunkTextPipeResults{cp1, err}
	return e.mock
}

// Times sets number of times Service.ChunkTextPipe should be invoked
func (mmChunkTextPipe *mServiceMockChunkTextPipe) Times(n uint64) *mServiceMockChunkTextPipe {
	if n == 0 {
		mmChunkTextPipe.mock.t.Fatalf("Times of ServiceMock.ChunkTextPipe mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmChunkTextPipe.expectedInvocations, n)
	mmChunkTextPipe.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmChunkTextPipe
}

func (mmChunkTextPipe *mServiceMockChunkTextPipe) invocationsDone() bool {
	if len(mmChunkTextPipe.expectations) == 0 && mmChunkTextPipe.defaultExpectation == nil && mmChunkTextPipe.mock.funcChunkTextPipe == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmChunkTextPipe.mock.afterChunkTextPipeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmChunkTextPipe.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ChunkTextPipe implements mm_service.Service
func (mmChunkTextPipe *ServiceMock) ChunkTextPipe(ctx context.Context, s1 string) (cp1 *mm_service.ChunkingResult, err error) {
	mm_atomic.AddUint64(&mmChunkTextPipe.beforeChunkTextPipeCounter, 1)
	defer mm_atomic.AddUint64(&mmChunkTextPipe.afterChunkTextPipeCounter, 1)

	mmChunkTextPipe.t.Helper()

	if mmChunkTextPipe.inspectFuncChunkTextPipe != nil {
		mmChunkTextPipe.inspectFuncChunkTextPipe(ctx, s1)
	}

	mm_params := ServiceMockChunkTextPipeParams{ctx, s1}

	// Record call args
	mmChunkTextPipe.ChunkTextPipeMock.mutex.Lock()
	mmChunkTextPipe.ChunkTextPipeMock.callArgs = append(mmChunkTextPipe.ChunkTextPipeMock.callArgs, &mm_params)
	mmChunkTextPipe.ChunkTextPipeMock.mutex.Unlock()

	for _, e := range mmChunkTextPipe.ChunkTextPipeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmChunkTextPipe.ChunkTextPipeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChunkTextPipe.ChunkTextPipeMock.defaultExpectation.Counter, 1)
		mm_want := mmChunkTextPipe.ChunkTextPipeMock.defaultExpectation.params
		mm_want_ptrs := mmChunkTextPipe.ChunkTextPipeMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockChunkTextPipeParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmChunkTextPipe.t.Errorf("ServiceMock.ChunkTextPipe got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChunkTextPipe.ChunkTextPipeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmChunkTextPipe.t.Errorf("ServiceMock.ChunkTextPipe got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChunkTextPipe.ChunkTextPipeMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChunkTextPipe.t.Errorf("ServiceMock.ChunkTextPipe got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmChunkTextPipe.ChunkTextPipeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChunkTextPipe.ChunkTextPipeMock.defaultExpectation.results
		if mm_results == nil {
			mmChunkTextPipe.t.Fatal("No results are set for the ServiceMock.ChunkTextPipe")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmChunkTextPipe.funcChunkTextPipe != nil {
		return mmChunkTextPipe.funcChunkTextPipe(ctx, s1)
	}
	mmChunkTextPipe.t.Fatalf("Unexpected call to ServiceMock.ChunkTextPipe. %v %v", ctx, s1)
	return
}

// ChunkTextPipeAfterCounter returns a count of finished ServiceMock.ChunkTextPipe invocations
func (mmChunkTextPipe *ServiceMock) ChunkTextPipeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChunkTextPipe.afterChunkTextPipeCounter)
}

// ChunkTextPipeBeforeCounter returns a count of ServiceMock.ChunkTextPipe invocations
func (mmChunkTextPipe *ServiceMock) ChunkTextPipeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChunkTextPipe.beforeChunkTextPipeCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.ChunkTextPipe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChunkTextPipe *mServiceMockChunkTextPipe) Calls() []*ServiceMockChunkTextPipeParams {
	mmChunkTextPipe.mutex.RLock()

	argCopy := make([]*ServiceMockChunkTextPipeParams, len(mmChunkTextPipe.callArgs))
	copy(argCopy, mmChunkTextPipe.callArgs)

	mmChunkTextPipe.mutex.RUnlock()

	return argCopy
}

// MinimockChunkTextPipeDone returns true if the count of the ChunkTextPipe invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockChunkTextPipeDone() bool {
	if m.ChunkTextPipeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ChunkTextPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ChunkTextPipeMock.invocationsDone()
}

// MinimockChunkTextPipeInspect logs each unmet expectation
func (m *ServiceMock) MinimockChunkTextPipeInspect() {
	for _, e := range m.ChunkTextPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.ChunkTextPipe at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterChunkTextPipeCounter := mm_atomic.LoadUint64(&m.afterChunkTextPipeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ChunkTextPipeMock.defaultExpectation != nil && afterChunkTextPipeCounter < 1 {
		if m.ChunkTextPipeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.ChunkTextPipe at\n%s", m.ChunkTextPipeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.ChunkTextPipe at\n%s with params: %#v", m.ChunkTextPipeMock.defaultExpectation.expectationOrigins.origin, *m.ChunkTextPipeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChunkTextPipe != nil && afterChunkTextPipeCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.ChunkTextPipe at\n%s", m.funcChunkTextPipeOrigin)
	}

	if !m.ChunkTextPipeMock.invocationsDone() && afterChunkTextPipeCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.ChunkTextPipe at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ChunkTextPipeMock.expectedInvocations), m.ChunkTextPipeMock.expectedInvocationsOrigin, afterChunkTextPipeCounter)
	}
}

type mServiceMockCleanupFileWorkflow struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockCleanupFileWorkflowExpectation
	expectations       []*ServiceMockCleanupFileWorkflowExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockCleanupFileWorkflowExpectation specifies expectation struct of the Service.CleanupFileWorkflow
type ServiceMockCleanupFileWorkflowExpectation struct {
	mock *ServiceMock

	results      *ServiceMockCleanupFileWorkflowResults
	returnOrigin string
	Counter      uint64
}

// ServiceMockCleanupFileWorkflowResults contains results of the Service.CleanupFileWorkflow
type ServiceMockCleanupFileWorkflowResults struct {
	c1 mm_service.CleanupFileWorkflow
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCleanupFileWorkflow *mServiceMockCleanupFileWorkflow) Optional() *mServiceMockCleanupFileWorkflow {
	mmCleanupFileWorkflow.optional = true
	return mmCleanupFileWorkflow
}

// Expect sets up expected params for Service.CleanupFileWorkflow
func (mmCleanupFileWorkflow *mServiceMockCleanupFileWorkflow) Expect() *mServiceMockCleanupFileWorkflow {
	if mmCleanupFileWorkflow.mock.funcCleanupFileWorkflow != nil {
		mmCleanupFileWorkflow.mock.t.Fatalf("ServiceMock.CleanupFileWorkflow mock is already set by Set")
	}

	if mmCleanupFileWorkflow.defaultExpectation == nil {
		mmCleanupFileWorkflow.defaultExpectation = &ServiceMockCleanupFileWorkflowExpectation{}
	}

	return mmCleanupFileWorkflow
}

// Inspect accepts an inspector function that has same arguments as the Service.CleanupFileWorkflow
func (mmCleanupFileWorkflow *mServiceMockCleanupFileWorkflow) Inspect(f func()) *mServiceMockCleanupFileWorkflow {
	if mmCleanupFileWorkflow.mock.inspectFuncCleanupFileWorkflow != nil {
		mmCleanupFileWorkflow.mock.t.Fatalf("Inspect function is already set for ServiceMock.CleanupFileWorkflow")
	}

	mmCleanupFileWorkflow.mock.inspectFuncCleanupFileWorkflow = f

	return mmCleanupFileWorkflow
}

// Return sets up results that will be returned by Service.CleanupFileWorkflow
func (mmCleanupFileWorkflow *mServiceMockCleanupFileWorkflow) Return(c1 mm_service.CleanupFileWorkflow) *ServiceMock {
	if mmCleanupFileWorkflow.mock.funcCleanupFileWorkflow != nil {
		mmCleanupFileWorkflow.mock.t.Fatalf("ServiceMock.CleanupFileWorkflow mock is already set by Set")
	}

	if mmCleanupFileWorkflow.defaultExpectation == nil {
		mmCleanupFileWorkflow.defaultExpectation = &ServiceMockCleanupFileWorkflowExpectation{mock: mmCleanupFileWorkflow.mock}
	}
	mmCleanupFileWorkflow.defaultExpectation.results = &ServiceMockCleanupFileWorkflowResults{c1}
	mmCleanupFileWorkflow.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCleanupFileWorkflow.mock
}

// Set uses given function f to mock the Service.CleanupFileWorkflow method
func (mmCleanupFileWorkflow *mServiceMockCleanupFileWorkflow) Set(f func() (c1 mm_service.CleanupFileWorkflow)) *ServiceMock {
	if mmCleanupFileWorkflow.defaultExpectation != nil {
		mmCleanupFileWorkflow.mock.t.Fatalf("Default expectation is already set for the Service.CleanupFileWorkflow method")
	}

	if len(mmCleanupFileWorkflow.expectations) > 0 {
		mmCleanupFileWorkflow.mock.t.Fatalf("Some expectations are already set for the Service.CleanupFileWorkflow method")
	}

	mmCleanupFileWorkflow.mock.funcCleanupFileWorkflow = f
	mmCleanupFileWorkflow.mock.funcCleanupFileWorkflowOrigin = minimock.CallerInfo(1)
	return mmCleanupFileWorkflow.mock
}

// Times sets number of times Service.CleanupFileWorkflow should be invoked
func (mmCleanupFileWorkflow *mServiceMockCleanupFileWorkflow) Times(n uint64) *mServiceMockCleanupFileWorkflow {
	if n == 0 {
		mmCleanupFileWorkflow.mock.t.Fatalf("Times of ServiceMock.CleanupFileWorkflow mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCleanupFileWorkflow.expectedInvocations, n)
	mmCleanupFileWorkflow.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCleanupFileWorkflow
}

func (mmCleanupFileWorkflow *mServiceMockCleanupFileWorkflow) invocationsDone() bool {
	if len(mmCleanupFileWorkflow.expectations) == 0 && mmCleanupFileWorkflow.defaultExpectation == nil && mmCleanupFileWorkflow.mock.funcCleanupFileWorkflow == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCleanupFileWorkflow.mock.afterCleanupFileWorkflowCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCleanupFileWorkflow.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CleanupFileWorkflow implements mm_service.Service
func (mmCleanupFileWorkflow *ServiceMock) CleanupFileWorkflow() (c1 mm_service.CleanupFileWorkflow) {
	mm_atomic.AddUint64(&mmCleanupFileWorkflow.beforeCleanupFileWorkflowCounter, 1)
	defer mm_atomic.AddUint64(&mmCleanupFileWorkflow.afterCleanupFileWorkflowCounter, 1)

	mmCleanupFileWorkflow.t.Helper()

	if mmCleanupFileWorkflow.inspectFuncCleanupFileWorkflow != nil {
		mmCleanupFileWorkflow.inspectFuncCleanupFileWorkflow()
	}

	if mmCleanupFileWorkflow.CleanupFileWorkflowMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCleanupFileWorkflow.CleanupFileWorkflowMock.defaultExpectation.Counter, 1)

		mm_results := mmCleanupFileWorkflow.CleanupFileWorkflowMock.defaultExpectation.results
		if mm_results == nil {
			mmCleanupFileWorkflow.t.Fatal("No results are set for the ServiceMock.CleanupFileWorkflow")
		}
		return (*mm_results).c1
	}
	if mmCleanupFileWorkflow.funcCleanupFileWorkflow != nil {
		return mmCleanupFileWorkflow.funcCleanupFileWorkflow()
	}
	mmCleanupFileWorkflow.t.Fatalf("Unexpected call to ServiceMock.CleanupFileWorkflow.")
	return
}

// CleanupFileWorkflowAfterCounter returns a count of finished ServiceMock.CleanupFileWorkflow invocations
func (mmCleanupFileWorkflow *ServiceMock) CleanupFileWorkflowAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCleanupFileWorkflow.afterCleanupFileWorkflowCounter)
}

// CleanupFileWorkflowBeforeCounter returns a count of ServiceMock.CleanupFileWorkflow invocations
func (mmCleanupFileWorkflow *ServiceMock) CleanupFileWorkflowBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCleanupFileWorkflow.beforeCleanupFileWorkflowCounter)
}

// MinimockCleanupFileWorkflowDone returns true if the count of the CleanupFileWorkflow invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCleanupFileWorkflowDone() bool {
	if m.CleanupFileWorkflowMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CleanupFileWorkflowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CleanupFileWorkflowMock.invocationsDone()
}

// MinimockCleanupFileWorkflowInspect logs each unmet expectation
func (m *ServiceMock) MinimockCleanupFileWorkflowInspect() {
	for _, e := range m.CleanupFileWorkflowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServiceMock.CleanupFileWorkflow")
		}
	}

	afterCleanupFileWorkflowCounter := mm_atomic.LoadUint64(&m.afterCleanupFileWorkflowCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CleanupFileWorkflowMock.defaultExpectation != nil && afterCleanupFileWorkflowCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.CleanupFileWorkflow at\n%s", m.CleanupFileWorkflowMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCleanupFileWorkflow != nil && afterCleanupFileWorkflowCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.CleanupFileWorkflow at\n%s", m.funcCleanupFileWorkflowOrigin)
	}

	if !m.CleanupFileWorkflowMock.invocationsDone() && afterCleanupFileWorkflowCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.CleanupFileWorkflow at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CleanupFileWorkflowMock.expectedInvocations), m.CleanupFileWorkflowMock.expectedInvocationsOrigin, afterCleanupFileWorkflowCounter)
	}
}

type mServiceMockCleanupKnowledgeBaseWorkflow struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockCleanupKnowledgeBaseWorkflowExpectation
	expectations       []*ServiceMockCleanupKnowledgeBaseWorkflowExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockCleanupKnowledgeBaseWorkflowExpectation specifies expectation struct of the Service.CleanupKnowledgeBaseWorkflow
type ServiceMockCleanupKnowledgeBaseWorkflowExpectation struct {
	mock *ServiceMock

	results      *ServiceMockCleanupKnowledgeBaseWorkflowResults
	returnOrigin string
	Counter      uint64
}

// ServiceMockCleanupKnowledgeBaseWorkflowResults contains results of the Service.CleanupKnowledgeBaseWorkflow
type ServiceMockCleanupKnowledgeBaseWorkflowResults struct {
	c1 mm_service.CleanupKnowledgeBaseWorkflow
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCleanupKnowledgeBaseWorkflow *mServiceMockCleanupKnowledgeBaseWorkflow) Optional() *mServiceMockCleanupKnowledgeBaseWorkflow {
	mmCleanupKnowledgeBaseWorkflow.optional = true
	return mmCleanupKnowledgeBaseWorkflow
}

// Expect sets up expected params for Service.CleanupKnowledgeBaseWorkflow
func (mmCleanupKnowledgeBaseWorkflow *mServiceMockCleanupKnowledgeBaseWorkflow) Expect() *mServiceMockCleanupKnowledgeBaseWorkflow {
	if mmCleanupKnowledgeBaseWorkflow.mock.funcCleanupKnowledgeBaseWorkflow != nil {
		mmCleanupKnowledgeBaseWorkflow.mock.t.Fatalf("ServiceMock.CleanupKnowledgeBaseWorkflow mock is already set by Set")
	}

	if mmCleanupKnowledgeBaseWorkflow.defaultExpectation == nil {
		mmCleanupKnowledgeBaseWorkflow.defaultExpectation = &ServiceMockCleanupKnowledgeBaseWorkflowExpectation{}
	}

	return mmCleanupKnowledgeBaseWorkflow
}

// Inspect accepts an inspector function that has same arguments as the Service.CleanupKnowledgeBaseWorkflow
func (mmCleanupKnowledgeBaseWorkflow *mServiceMockCleanupKnowledgeBaseWorkflow) Inspect(f func()) *mServiceMockCleanupKnowledgeBaseWorkflow {
	if mmCleanupKnowledgeBaseWorkflow.mock.inspectFuncCleanupKnowledgeBaseWorkflow != nil {
		mmCleanupKnowledgeBaseWorkflow.mock.t.Fatalf("Inspect function is already set for ServiceMock.CleanupKnowledgeBaseWorkflow")
	}

	mmCleanupKnowledgeBaseWorkflow.mock.inspectFuncCleanupKnowledgeBaseWorkflow = f

	return mmCleanupKnowledgeBaseWorkflow
}

// Return sets up results that will be returned by Service.CleanupKnowledgeBaseWorkflow
func (mmCleanupKnowledgeBaseWorkflow *mServiceMockCleanupKnowledgeBaseWorkflow) Return(c1 mm_service.CleanupKnowledgeBaseWorkflow) *ServiceMock {
	if mmCleanupKnowledgeBaseWorkflow.mock.funcCleanupKnowledgeBaseWorkflow != nil {
		mmCleanupKnowledgeBaseWorkflow.mock.t.Fatalf("ServiceMock.CleanupKnowledgeBaseWorkflow mock is already set by Set")
	}

	if mmCleanupKnowledgeBaseWorkflow.defaultExpectation == nil {
		mmCleanupKnowledgeBaseWorkflow.defaultExpectation = &ServiceMockCleanupKnowledgeBaseWorkflowExpectation{mock: mmCleanupKnowledgeBaseWorkflow.mock}
	}
	mmCleanupKnowledgeBaseWorkflow.defaultExpectation.results = &ServiceMockCleanupKnowledgeBaseWorkflowResults{c1}
	mmCleanupKnowledgeBaseWorkflow.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCleanupKnowledgeBaseWorkflow.mock
}

// Set uses given function f to mock the Service.CleanupKnowledgeBaseWorkflow method
func (mmCleanupKnowledgeBaseWorkflow *mServiceMockCleanupKnowledgeBaseWorkflow) Set(f func() (c1 mm_service.CleanupKnowledgeBaseWorkflow)) *ServiceMock {
	if mmCleanupKnowledgeBaseWorkflow.defaultExpectation != nil {
		mmCleanupKnowledgeBaseWorkflow.mock.t.Fatalf("Default expectation is already set for the Service.CleanupKnowledgeBaseWorkflow method")
	}

	if len(mmCleanupKnowledgeBaseWorkflow.expectations) > 0 {
		mmCleanupKnowledgeBaseWorkflow.mock.t.Fatalf("Some expectations are already set for the Service.CleanupKnowledgeBaseWorkflow method")
	}

	mmCleanupKnowledgeBaseWorkflow.mock.funcCleanupKnowledgeBaseWorkflow = f
	mmCleanupKnowledgeBaseWorkflow.mock.funcCleanupKnowledgeBaseWorkflowOrigin = minimock.CallerInfo(1)
	return mmCleanupKnowledgeBaseWorkflow.mock
}

// Times sets number of times Service.CleanupKnowledgeBaseWorkflow should be invoked
func (mmCleanupKnowledgeBaseWorkflow *mServiceMockCleanupKnowledgeBaseWorkflow) Times(n uint64) *mServiceMockCleanupKnowledgeBaseWorkflow {
	if n == 0 {
		mmCleanupKnowledgeBaseWorkflow.mock.t.Fatalf("Times of ServiceMock.CleanupKnowledgeBaseWorkflow mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCleanupKnowledgeBaseWorkflow.expectedInvocations, n)
	mmCleanupKnowledgeBaseWorkflow.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCleanupKnowledgeBaseWorkflow
}

func (mmCleanupKnowledgeBaseWorkflow *mServiceMockCleanupKnowledgeBaseWorkflow) invocationsDone() bool {
	if len(mmCleanupKnowledgeBaseWorkflow.expectations) == 0 && mmCleanupKnowledgeBaseWorkflow.defaultExpectation == nil && mmCleanupKnowledgeBaseWorkflow.mock.funcCleanupKnowledgeBaseWorkflow == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCleanupKnowledgeBaseWorkflow.mock.afterCleanupKnowledgeBaseWorkflowCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCleanupKnowledgeBaseWorkflow.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CleanupKnowledgeBaseWorkflow implements mm_service.Service
func (mmCleanupKnowledgeBaseWorkflow *ServiceMock) CleanupKnowledgeBaseWorkflow() (c1 mm_service.CleanupKnowledgeBaseWorkflow) {
	mm_atomic.AddUint64(&mmCleanupKnowledgeBaseWorkflow.beforeCleanupKnowledgeBaseWorkflowCounter, 1)
	defer mm_atomic.AddUint64(&mmCleanupKnowledgeBaseWorkflow.afterCleanupKnowledgeBaseWorkflowCounter, 1)

	mmCleanupKnowledgeBaseWorkflow.t.Helper()

	if mmCleanupKnowledgeBaseWorkflow.inspectFuncCleanupKnowledgeBaseWorkflow != nil {
		mmCleanupKnowledgeBaseWorkflow.inspectFuncCleanupKnowledgeBaseWorkflow()
	}

	if mmCleanupKnowledgeBaseWorkflow.CleanupKnowledgeBaseWorkflowMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCleanupKnowledgeBaseWorkflow.CleanupKnowledgeBaseWorkflowMock.defaultExpectation.Counter, 1)

		mm_results := mmCleanupKnowledgeBaseWorkflow.CleanupKnowledgeBaseWorkflowMock.defaultExpectation.results
		if mm_results == nil {
			mmCleanupKnowledgeBaseWorkflow.t.Fatal("No results are set for the ServiceMock.CleanupKnowledgeBaseWorkflow")
		}
		return (*mm_results).c1
	}
	if mmCleanupKnowledgeBaseWorkflow.funcCleanupKnowledgeBaseWorkflow != nil {
		return mmCleanupKnowledgeBaseWorkflow.funcCleanupKnowledgeBaseWorkflow()
	}
	mmCleanupKnowledgeBaseWorkflow.t.Fatalf("Unexpected call to ServiceMock.CleanupKnowledgeBaseWorkflow.")
	return
}

// CleanupKnowledgeBaseWorkflowAfterCounter returns a count of finished ServiceMock.CleanupKnowledgeBaseWorkflow invocations
func (mmCleanupKnowledgeBaseWorkflow *ServiceMock) CleanupKnowledgeBaseWorkflowAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCleanupKnowledgeBaseWorkflow.afterCleanupKnowledgeBaseWorkflowCounter)
}

// CleanupKnowledgeBaseWorkflowBeforeCounter returns a count of ServiceMock.CleanupKnowledgeBaseWorkflow invocations
func (mmCleanupKnowledgeBaseWorkflow *ServiceMock) CleanupKnowledgeBaseWorkflowBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCleanupKnowledgeBaseWorkflow.beforeCleanupKnowledgeBaseWorkflowCounter)
}

// MinimockCleanupKnowledgeBaseWorkflowDone returns true if the count of the CleanupKnowledgeBaseWorkflow invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCleanupKnowledgeBaseWorkflowDone() bool {
	if m.CleanupKnowledgeBaseWorkflowMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CleanupKnowledgeBaseWorkflowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CleanupKnowledgeBaseWorkflowMock.invocationsDone()
}

// MinimockCleanupKnowledgeBaseWorkflowInspect logs each unmet expectation
func (m *ServiceMock) MinimockCleanupKnowledgeBaseWorkflowInspect() {
	for _, e := range m.CleanupKnowledgeBaseWorkflowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServiceMock.CleanupKnowledgeBaseWorkflow")
		}
	}

	afterCleanupKnowledgeBaseWorkflowCounter := mm_atomic.LoadUint64(&m.afterCleanupKnowledgeBaseWorkflowCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CleanupKnowledgeBaseWorkflowMock.defaultExpectation != nil && afterCleanupKnowledgeBaseWorkflowCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.CleanupKnowledgeBaseWorkflow at\n%s", m.CleanupKnowledgeBaseWorkflowMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCleanupKnowledgeBaseWorkflow != nil && afterCleanupKnowledgeBaseWorkflowCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.CleanupKnowledgeBaseWorkflow at\n%s", m.funcCleanupKnowledgeBaseWorkflowOrigin)
	}

	if !m.CleanupKnowledgeBaseWorkflowMock.invocationsDone() && afterCleanupKnowledgeBaseWorkflowCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.CleanupKnowledgeBaseWorkflow at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CleanupKnowledgeBaseWorkflowMock.expectedInvocations), m.CleanupKnowledgeBaseWorkflowMock.expectedInvocationsOrigin, afterCleanupKnowledgeBaseWorkflowCounter)
	}
}

type mServiceMockConvertToMDPipe struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockConvertToMDPipeExpectation
	expectations       []*ServiceMockConvertToMDPipeExpectation

	callArgs []*ServiceMockConvertToMDPipeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockConvertToMDPipeExpectation specifies expectation struct of the Service.ConvertToMDPipe
type ServiceMockConvertToMDPipeExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockConvertToMDPipeParams
	paramPtrs          *ServiceMockConvertToMDPipeParamPtrs
	expectationOrigins ServiceMockConvertToMDPipeExpectationOrigins
	results            *ServiceMockConvertToMDPipeResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockConvertToMDPipeParams contains parameters of the Service.ConvertToMDPipe
type ServiceMockConvertToMDPipeParams struct {
	ctx context.Context
	m1  mm_service.MDConversionParams
}

// ServiceMockConvertToMDPipeParamPtrs contains pointers to parameters of the Service.ConvertToMDPipe
type ServiceMockConvertToMDPipeParamPtrs struct {
	ctx *context.Context
	m1  *mm_service.MDConversionParams
}

// ServiceMockConvertToMDPipeResults contains results of the Service.ConvertToMDPipe
type ServiceMockConvertToMDPipeResults struct {
	mp1 *mm_service.MDConversionResult
	err error
}

// ServiceMockConvertToMDPipeOrigins contains origins of expectations of the Service.ConvertToMDPipe
type ServiceMockConvertToMDPipeExpectationOrigins struct {
	origin    string
	originCtx string
	originM1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConvertToMDPipe *mServiceMockConvertToMDPipe) Optional() *mServiceMockConvertToMDPipe {
	mmConvertToMDPipe.optional = true
	return mmConvertToMDPipe
}

// Expect sets up expected params for Service.ConvertToMDPipe
func (mmConvertToMDPipe *mServiceMockConvertToMDPipe) Expect(ctx context.Context, m1 mm_service.MDConversionParams) *mServiceMockConvertToMDPipe {
	if mmConvertToMDPipe.mock.funcConvertToMDPipe != nil {
		mmConvertToMDPipe.mock.t.Fatalf("ServiceMock.ConvertToMDPipe mock is already set by Set")
	}

	if mmConvertToMDPipe.defaultExpectation == nil {
		mmConvertToMDPipe.defaultExpectation = &ServiceMockConvertToMDPipeExpectation{}
	}

	if mmConvertToMDPipe.defaultExpectation.paramPtrs != nil {
		mmConvertToMDPipe.mock.t.Fatalf("ServiceMock.ConvertToMDPipe mock is already set by ExpectParams functions")
	}

	mmConvertToMDPipe.defaultExpectation.params = &ServiceMockConvertToMDPipeParams{ctx, m1}
	mmConvertToMDPipe.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmConvertToMDPipe.expectations {
		if minimock.Equal(e.params, mmConvertToMDPipe.defaultExpectation.params) {
			mmConvertToMDPipe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertToMDPipe.defaultExpectation.params)
		}
	}

	return mmConvertToMDPipe
}

// ExpectCtxParam1 sets up expected param ctx for Service.ConvertToMDPipe
func (mmConvertToMDPipe *mServiceMockConvertToMDPipe) ExpectCtxParam1(ctx context.Context) *mServiceMockConvertToMDPipe {
	if mmConvertToMDPipe.mock.funcConvertToMDPipe != nil {
		mmConvertToMDPipe.mock.t.Fatalf("ServiceMock.ConvertToMDPipe mock is already set by Set")
	}

	if mmConvertToMDPipe.defaultExpectation == nil {
		mmConvertToMDPipe.defaultExpectation = &ServiceMockConvertToMDPipeExpectation{}
	}

	if mmConvertToMDPipe.defaultExpectation.params != nil {
		mmConvertToMDPipe.mock.t.Fatalf("ServiceMock.ConvertToMDPipe mock is already set by Expect")
	}

	if mmConvertToMDPipe.defaultExpectation.paramPtrs == nil {
		mmConvertToMDPipe.defaultExpectation.paramPtrs = &ServiceMockConvertToMDPipeParamPtrs{}
	}
	mmConvertToMDPipe.defaultExpectation.paramPtrs.ctx = &ctx
	mmConvertToMDPipe.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmConvertToMDPipe
}

// ExpectM1Param2 sets up expected param m1 for Service.ConvertToMDPipe
func (mmConvertToMDPipe *mServiceMockConvertToMDPipe) ExpectM1Param2(m1 mm_service.MDConversionParams) *mServiceMockConvertToMDPipe {
	if mmConvertToMDPipe.mock.funcConvertToMDPipe != nil {
		mmConvertToMDPipe.mock.t.Fatalf("ServiceMock.ConvertToMDPipe mock is already set by Set")
	}

	if mmConvertToMDPipe.defaultExpectation == nil {
		mmConvertToMDPipe.defaultExpectation = &ServiceMockConvertToMDPipeExpectation{}
	}

	if mmConvertToMDPipe.defaultExpectation.params != nil {
		mmConvertToMDPipe.mock.t.Fatalf("ServiceMock.ConvertToMDPipe mock is already set by Expect")
	}

	if mmConvertToMDPipe.defaultExpectation.paramPtrs == nil {
		mmConvertToMDPipe.defaultExpectation.paramPtrs = &ServiceMockConvertToMDPipeParamPtrs{}
	}
	mmConvertToMDPipe.defaultExpectation.paramPtrs.m1 = &m1
	mmConvertToMDPipe.defaultExpectation.expectationOrigins.originM1 = minimock.CallerInfo(1)

	return mmConvertToMDPipe
}

// Inspect accepts an inspector function that has same arguments as the Service.ConvertToMDPipe
func (mmConvertToMDPipe *mServiceMockConvertToMDPipe) Inspect(f func(ctx context.Context, m1 mm_service.MDConversionParams)) *mServiceMockConvertToMDPipe {
	if mmConvertToMDPipe.mock.inspectFuncConvertToMDPipe != nil {
		mmConvertToMDPipe.mock.t.Fatalf("Inspect function is already set for ServiceMock.ConvertToMDPipe")
	}

	mmConvertToMDPipe.mock.inspectFuncConvertToMDPipe = f

	return mmConvertToMDPipe
}

// Return sets up results that will be returned by Service.ConvertToMDPipe
func (mmConvertToMDPipe *mServiceMockConvertToMDPipe) Return(mp1 *mm_service.MDConversionResult, err error) *ServiceMock {
	if mmConvertToMDPipe.mock.funcConvertToMDPipe != nil {
		mmConvertToMDPipe.mock.t.Fatalf("ServiceMock.ConvertToMDPipe mock is already set by Set")
	}

	if mmConvertToMDPipe.defaultExpectation == nil {
		mmConvertToMDPipe.defaultExpectation = &ServiceMockConvertToMDPipeExpectation{mock: mmConvertToMDPipe.mock}
	}
	mmConvertToMDPipe.defaultExpectation.results = &ServiceMockConvertToMDPipeResults{mp1, err}
	mmConvertToMDPipe.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmConvertToMDPipe.mock
}

// Set uses given function f to mock the Service.ConvertToMDPipe method
func (mmConvertToMDPipe *mServiceMockConvertToMDPipe) Set(f func(ctx context.Context, m1 mm_service.MDConversionParams) (mp1 *mm_service.MDConversionResult, err error)) *ServiceMock {
	if mmConvertToMDPipe.defaultExpectation != nil {
		mmConvertToMDPipe.mock.t.Fatalf("Default expectation is already set for the Service.ConvertToMDPipe method")
	}

	if len(mmConvertToMDPipe.expectations) > 0 {
		mmConvertToMDPipe.mock.t.Fatalf("Some expectations are already set for the Service.ConvertToMDPipe method")
	}

	mmConvertToMDPipe.mock.funcConvertToMDPipe = f
	mmConvertToMDPipe.mock.funcConvertToMDPipeOrigin = minimock.CallerInfo(1)
	return mmConvertToMDPipe.mock
}

// When sets expectation for the Service.ConvertToMDPipe which will trigger the result defined by the following
// Then helper
func (mmConvertToMDPipe *mServiceMockConvertToMDPipe) When(ctx context.Context, m1 mm_service.MDConversionParams) *ServiceMockConvertToMDPipeExpectation {
	if mmConvertToMDPipe.mock.funcConvertToMDPipe != nil {
		mmConvertToMDPipe.mock.t.Fatalf("ServiceMock.ConvertToMDPipe mock is already set by Set")
	}

	expectation := &ServiceMockConvertToMDPipeExpectation{
		mock:               mmConvertToMDPipe.mock,
		params:             &ServiceMockConvertToMDPipeParams{ctx, m1},
		expectationOrigins: ServiceMockConvertToMDPipeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmConvertToMDPipe.expectations = append(mmConvertToMDPipe.expectations, expectation)
	return expectation
}

// Then sets up Service.ConvertToMDPipe return parameters for the expectation previously defined by the When method
func (e *ServiceMockConvertToMDPipeExpectation) Then(mp1 *mm_service.MDConversionResult, err error) *ServiceMock {
	e.results = &ServiceMockConvertToMDPipeResults{mp1, err}
	return e.mock
}

// Times sets number of times Service.ConvertToMDPipe should be invoked
func (mmConvertToMDPipe *mServiceMockConvertToMDPipe) Times(n uint64) *mServiceMockConvertToMDPipe {
	if n == 0 {
		mmConvertToMDPipe.mock.t.Fatalf("Times of ServiceMock.ConvertToMDPipe mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertToMDPipe.expectedInvocations, n)
	mmConvertToMDPipe.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmConvertToMDPipe
}

func (mmConvertToMDPipe *mServiceMockConvertToMDPipe) invocationsDone() bool {
	if len(mmConvertToMDPipe.expectations) == 0 && mmConvertToMDPipe.defaultExpectation == nil && mmConvertToMDPipe.mock.funcConvertToMDPipe == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertToMDPipe.mock.afterConvertToMDPipeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertToMDPipe.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertToMDPipe implements mm_service.Service
func (mmConvertToMDPipe *ServiceMock) ConvertToMDPipe(ctx context.Context, m1 mm_service.MDConversionParams) (mp1 *mm_service.MDConversionResult, err error) {
	mm_atomic.AddUint64(&mmConvertToMDPipe.beforeConvertToMDPipeCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertToMDPipe.afterConvertToMDPipeCounter, 1)

	mmConvertToMDPipe.t.Helper()

	if mmConvertToMDPipe.inspectFuncConvertToMDPipe != nil {
		mmConvertToMDPipe.inspectFuncConvertToMDPipe(ctx, m1)
	}

	mm_params := ServiceMockConvertToMDPipeParams{ctx, m1}

	// Record call args
	mmConvertToMDPipe.ConvertToMDPipeMock.mutex.Lock()
	mmConvertToMDPipe.ConvertToMDPipeMock.callArgs = append(mmConvertToMDPipe.ConvertToMDPipeMock.callArgs, &mm_params)
	mmConvertToMDPipe.ConvertToMDPipeMock.mutex.Unlock()

	for _, e := range mmConvertToMDPipe.ConvertToMDPipeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmConvertToMDPipe.ConvertToMDPipeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertToMDPipe.ConvertToMDPipeMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertToMDPipe.ConvertToMDPipeMock.defaultExpectation.params
		mm_want_ptrs := mmConvertToMDPipe.ConvertToMDPipeMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockConvertToMDPipeParams{ctx, m1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConvertToMDPipe.t.Errorf("ServiceMock.ConvertToMDPipe got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertToMDPipe.ConvertToMDPipeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.m1 != nil && !minimock.Equal(*mm_want_ptrs.m1, mm_got.m1) {
				mmConvertToMDPipe.t.Errorf("ServiceMock.ConvertToMDPipe got unexpected parameter m1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertToMDPipe.ConvertToMDPipeMock.defaultExpectation.expectationOrigins.originM1, *mm_want_ptrs.m1, mm_got.m1, minimock.Diff(*mm_want_ptrs.m1, mm_got.m1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertToMDPipe.t.Errorf("ServiceMock.ConvertToMDPipe got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmConvertToMDPipe.ConvertToMDPipeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertToMDPipe.ConvertToMDPipeMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertToMDPipe.t.Fatal("No results are set for the ServiceMock.ConvertToMDPipe")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmConvertToMDPipe.funcConvertToMDPipe != nil {
		return mmConvertToMDPipe.funcConvertToMDPipe(ctx, m1)
	}
	mmConvertToMDPipe.t.Fatalf("Unexpected call to ServiceMock.ConvertToMDPipe. %v %v", ctx, m1)
	return
}

// ConvertToMDPipeAfterCounter returns a count of finished ServiceMock.ConvertToMDPipe invocations
func (mmConvertToMDPipe *ServiceMock) ConvertToMDPipeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertToMDPipe.afterConvertToMDPipeCounter)
}

// ConvertToMDPipeBeforeCounter returns a count of ServiceMock.ConvertToMDPipe invocations
func (mmConvertToMDPipe *ServiceMock) ConvertToMDPipeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertToMDPipe.beforeConvertToMDPipeCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.ConvertToMDPipe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertToMDPipe *mServiceMockConvertToMDPipe) Calls() []*ServiceMockConvertToMDPipeParams {
	mmConvertToMDPipe.mutex.RLock()

	argCopy := make([]*ServiceMockConvertToMDPipeParams, len(mmConvertToMDPipe.callArgs))
	copy(argCopy, mmConvertToMDPipe.callArgs)

	mmConvertToMDPipe.mutex.RUnlock()

	return argCopy
}

// MinimockConvertToMDPipeDone returns true if the count of the ConvertToMDPipe invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockConvertToMDPipeDone() bool {
	if m.ConvertToMDPipeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConvertToMDPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertToMDPipeMock.invocationsDone()
}

// MinimockConvertToMDPipeInspect logs each unmet expectation
func (m *ServiceMock) MinimockConvertToMDPipeInspect() {
	for _, e := range m.ConvertToMDPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.ConvertToMDPipe at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterConvertToMDPipeCounter := mm_atomic.LoadUint64(&m.afterConvertToMDPipeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertToMDPipeMock.defaultExpectation != nil && afterConvertToMDPipeCounter < 1 {
		if m.ConvertToMDPipeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.ConvertToMDPipe at\n%s", m.ConvertToMDPipeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.ConvertToMDPipe at\n%s with params: %#v", m.ConvertToMDPipeMock.defaultExpectation.expectationOrigins.origin, *m.ConvertToMDPipeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertToMDPipe != nil && afterConvertToMDPipeCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.ConvertToMDPipe at\n%s", m.funcConvertToMDPipeOrigin)
	}

	if !m.ConvertToMDPipeMock.invocationsDone() && afterConvertToMDPipeCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.ConvertToMDPipe at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertToMDPipeMock.expectedInvocations), m.ConvertToMDPipeMock.expectedInvocationsOrigin, afterConvertToMDPipeCounter)
	}
}

type mServiceMockCreateRepositoryTag struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockCreateRepositoryTagExpectation
	expectations       []*ServiceMockCreateRepositoryTagExpectation

	callArgs []*ServiceMockCreateRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockCreateRepositoryTagExpectation specifies expectation struct of the Service.CreateRepositoryTag
type ServiceMockCreateRepositoryTagExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockCreateRepositoryTagParams
	paramPtrs          *ServiceMockCreateRepositoryTagParamPtrs
	expectationOrigins ServiceMockCreateRepositoryTagExpectationOrigins
	results            *ServiceMockCreateRepositoryTagResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockCreateRepositoryTagParams contains parameters of the Service.CreateRepositoryTag
type ServiceMockCreateRepositoryTagParams struct {
	ctx context.Context
	cp1 *artifactpb.CreateRepositoryTagRequest
}

// ServiceMockCreateRepositoryTagParamPtrs contains pointers to parameters of the Service.CreateRepositoryTag
type ServiceMockCreateRepositoryTagParamPtrs struct {
	ctx *context.Context
	cp1 **artifactpb.CreateRepositoryTagRequest
}

// ServiceMockCreateRepositoryTagResults contains results of the Service.CreateRepositoryTag
type ServiceMockCreateRepositoryTagResults struct {
	cp2 *artifactpb.CreateRepositoryTagResponse
	err error
}

// ServiceMockCreateRepositoryTagOrigins contains origins of expectations of the Service.CreateRepositoryTag
type ServiceMockCreateRepositoryTagExpectationOrigins struct {
	origin    string
	originCtx string
	originCp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) Optional() *mServiceMockCreateRepositoryTag {
	mmCreateRepositoryTag.optional = true
	return mmCreateRepositoryTag
}

// Expect sets up expected params for Service.CreateRepositoryTag
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) Expect(ctx context.Context, cp1 *artifactpb.CreateRepositoryTagRequest) *mServiceMockCreateRepositoryTag {
	if mmCreateRepositoryTag.mock.funcCreateRepositoryTag != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("ServiceMock.CreateRepositoryTag mock is already set by Set")
	}

	if mmCreateRepositoryTag.defaultExpectation == nil {
		mmCreateRepositoryTag.defaultExpectation = &ServiceMockCreateRepositoryTagExpectation{}
	}

	if mmCreateRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("ServiceMock.CreateRepositoryTag mock is already set by ExpectParams functions")
	}

	mmCreateRepositoryTag.defaultExpectation.params = &ServiceMockCreateRepositoryTagParams{ctx, cp1}
	mmCreateRepositoryTag.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateRepositoryTag.expectations {
		if minimock.Equal(e.params, mmCreateRepositoryTag.defaultExpectation.params) {
			mmCreateRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateRepositoryTag.defaultExpectation.params)
		}
	}

	return mmCreateRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for Service.CreateRepositoryTag
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) ExpectCtxParam1(ctx context.Context) *mServiceMockCreateRepositoryTag {
	if mmCreateRepositoryTag.mock.funcCreateRepositoryTag != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("ServiceMock.CreateRepositoryTag mock is already set by Set")
	}

	if mmCreateRepositoryTag.defaultExpectation == nil {
		mmCreateRepositoryTag.defaultExpectation = &ServiceMockCreateRepositoryTagExpectation{}
	}

	if mmCreateRepositoryTag.defaultExpectation.params != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("ServiceMock.CreateRepositoryTag mock is already set by Expect")
	}

	if mmCreateRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmCreateRepositoryTag.defaultExpectation.paramPtrs = &ServiceMockCreateRepositoryTagParamPtrs{}
	}
	mmCreateRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateRepositoryTag.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateRepositoryTag
}

// ExpectCp1Param2 sets up expected param cp1 for Service.CreateRepositoryTag
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) ExpectCp1Param2(cp1 *artifactpb.CreateRepositoryTagRequest) *mServiceMockCreateRepositoryTag {
	if mmCreateRepositoryTag.mock.funcCreateRepositoryTag != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("ServiceMock.CreateRepositoryTag mock is already set by Set")
	}

	if mmCreateRepositoryTag.defaultExpectation == nil {
		mmCreateRepositoryTag.defaultExpectation = &ServiceMockCreateRepositoryTagExpectation{}
	}

	if mmCreateRepositoryTag.defaultExpectation.params != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("ServiceMock.CreateRepositoryTag mock is already set by Expect")
	}

	if mmCreateRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmCreateRepositoryTag.defaultExpectation.paramPtrs = &ServiceMockCreateRepositoryTagParamPtrs{}
	}
	mmCreateRepositoryTag.defaultExpectation.paramPtrs.cp1 = &cp1
	mmCreateRepositoryTag.defaultExpectation.expectationOrigins.originCp1 = minimock.CallerInfo(1)

	return mmCreateRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the Service.CreateRepositoryTag
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) Inspect(f func(ctx context.Context, cp1 *artifactpb.CreateRepositoryTagRequest)) *mServiceMockCreateRepositoryTag {
	if mmCreateRepositoryTag.mock.inspectFuncCreateRepositoryTag != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("Inspect function is already set for ServiceMock.CreateRepositoryTag")
	}

	mmCreateRepositoryTag.mock.inspectFuncCreateRepositoryTag = f

	return mmCreateRepositoryTag
}

// Return sets up results that will be returned by Service.CreateRepositoryTag
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) Return(cp2 *artifactpb.CreateRepositoryTagResponse, err error) *ServiceMock {
	if mmCreateRepositoryTag.mock.funcCreateRepositoryTag != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("ServiceMock.CreateRepositoryTag mock is already set by Set")
	}

	if mmCreateRepositoryTag.defaultExpectation == nil {
		mmCreateRepositoryTag.defaultExpectation = &ServiceMockCreateRepositoryTagExpectation{mock: mmCreateRepositoryTag.mock}
	}
	mmCreateRepositoryTag.defaultExpectation.results = &ServiceMockCreateRepositoryTagResults{cp2, err}
	mmCreateRepositoryTag.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateRepositoryTag.mock
}

// Set uses given function f to mock the Service.CreateRepositoryTag method
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) Set(f func(ctx context.Context, cp1 *artifactpb.CreateRepositoryTagRequest) (cp2 *artifactpb.CreateRepositoryTagResponse, err error)) *ServiceMock {
	if mmCreateRepositoryTag.defaultExpectation != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("Default expectation is already set for the Service.CreateRepositoryTag method")
	}

	if len(mmCreateRepositoryTag.expectations) > 0 {
		mmCreateRepositoryTag.mock.t.Fatalf("Some expectations are already set for the Service.CreateRepositoryTag method")
	}

	mmCreateRepositoryTag.mock.funcCreateRepositoryTag = f
	mmCreateRepositoryTag.mock.funcCreateRepositoryTagOrigin = minimock.CallerInfo(1)
	return mmCreateRepositoryTag.mock
}

// When sets expectation for the Service.CreateRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) When(ctx context.Context, cp1 *artifactpb.CreateRepositoryTagRequest) *ServiceMockCreateRepositoryTagExpectation {
	if mmCreateRepositoryTag.mock.funcCreateRepositoryTag != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("ServiceMock.CreateRepositoryTag mock is already set by Set")
	}

	expectation := &ServiceMockCreateRepositoryTagExpectation{
		mock:               mmCreateRepositoryTag.mock,
		params:             &ServiceMockCreateRepositoryTagParams{ctx, cp1},
		expectationOrigins: ServiceMockCreateRepositoryTagExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateRepositoryTag.expectations = append(mmCreateRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up Service.CreateRepositoryTag return parameters for the expectation previously defined by the When method
func (e *ServiceMockCreateRepositoryTagExpectation) Then(cp2 *artifactpb.CreateRepositoryTagResponse, err error) *ServiceMock {
	e.results = &ServiceMockCreateRepositoryTagResults{cp2, err}
	return e.mock
}

// Times sets number of times Service.CreateRepositoryTag should be invoked
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) Times(n uint64) *mServiceMockCreateRepositoryTag {
	if n == 0 {
		mmCreateRepositoryTag.mock.t.Fatalf("Times of ServiceMock.CreateRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateRepositoryTag.expectedInvocations, n)
	mmCreateRepositoryTag.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateRepositoryTag
}

func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) invocationsDone() bool {
	if len(mmCreateRepositoryTag.expectations) == 0 && mmCreateRepositoryTag.defaultExpectation == nil && mmCreateRepositoryTag.mock.funcCreateRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateRepositoryTag.mock.afterCreateRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateRepositoryTag implements mm_service.Service
func (mmCreateRepositoryTag *ServiceMock) CreateRepositoryTag(ctx context.Context, cp1 *artifactpb.CreateRepositoryTagRequest) (cp2 *artifactpb.CreateRepositoryTagResponse, err error) {
	mm_atomic.AddUint64(&mmCreateRepositoryTag.beforeCreateRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateRepositoryTag.afterCreateRepositoryTagCounter, 1)

	mmCreateRepositoryTag.t.Helper()

	if mmCreateRepositoryTag.inspectFuncCreateRepositoryTag != nil {
		mmCreateRepositoryTag.inspectFuncCreateRepositoryTag(ctx, cp1)
	}

	mm_params := ServiceMockCreateRepositoryTagParams{ctx, cp1}

	// Record call args
	mmCreateRepositoryTag.CreateRepositoryTagMock.mutex.Lock()
	mmCreateRepositoryTag.CreateRepositoryTagMock.callArgs = append(mmCreateRepositoryTag.CreateRepositoryTagMock.callArgs, &mm_params)
	mmCreateRepositoryTag.CreateRepositoryTagMock.mutex.Unlock()

	for _, e := range mmCreateRepositoryTag.CreateRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp2, e.results.err
		}
	}

	if mmCreateRepositoryTag.CreateRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateRepositoryTag.CreateRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateRepositoryTag.CreateRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmCreateRepositoryTag.CreateRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockCreateRepositoryTagParams{ctx, cp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateRepositoryTag.t.Errorf("ServiceMock.CreateRepositoryTag got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateRepositoryTag.CreateRepositoryTagMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cp1 != nil && !minimock.Equal(*mm_want_ptrs.cp1, mm_got.cp1) {
				mmCreateRepositoryTag.t.Errorf("ServiceMock.CreateRepositoryTag got unexpected parameter cp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateRepositoryTag.CreateRepositoryTagMock.defaultExpectation.expectationOrigins.originCp1, *mm_want_ptrs.cp1, mm_got.cp1, minimock.Diff(*mm_want_ptrs.cp1, mm_got.cp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateRepositoryTag.t.Errorf("ServiceMock.CreateRepositoryTag got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateRepositoryTag.CreateRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateRepositoryTag.CreateRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateRepositoryTag.t.Fatal("No results are set for the ServiceMock.CreateRepositoryTag")
		}
		return (*mm_results).cp2, (*mm_results).err
	}
	if mmCreateRepositoryTag.funcCreateRepositoryTag != nil {
		return mmCreateRepositoryTag.funcCreateRepositoryTag(ctx, cp1)
	}
	mmCreateRepositoryTag.t.Fatalf("Unexpected call to ServiceMock.CreateRepositoryTag. %v %v", ctx, cp1)
	return
}

// CreateRepositoryTagAfterCounter returns a count of finished ServiceMock.CreateRepositoryTag invocations
func (mmCreateRepositoryTag *ServiceMock) CreateRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateRepositoryTag.afterCreateRepositoryTagCounter)
}

// CreateRepositoryTagBeforeCounter returns a count of ServiceMock.CreateRepositoryTag invocations
func (mmCreateRepositoryTag *ServiceMock) CreateRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateRepositoryTag.beforeCreateRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.CreateRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) Calls() []*ServiceMockCreateRepositoryTagParams {
	mmCreateRepositoryTag.mutex.RLock()

	argCopy := make([]*ServiceMockCreateRepositoryTagParams, len(mmCreateRepositoryTag.callArgs))
	copy(argCopy, mmCreateRepositoryTag.callArgs)

	mmCreateRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockCreateRepositoryTagDone returns true if the count of the CreateRepositoryTag invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCreateRepositoryTagDone() bool {
	if m.CreateRepositoryTagMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateRepositoryTagMock.invocationsDone()
}

// MinimockCreateRepositoryTagInspect logs each unmet expectation
func (m *ServiceMock) MinimockCreateRepositoryTagInspect() {
	for _, e := range m.CreateRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.CreateRepositoryTag at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterCreateRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateRepositoryTagMock.defaultExpectation != nil && afterCreateRepositoryTagCounter < 1 {
		if m.CreateRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.CreateRepositoryTag at\n%s", m.CreateRepositoryTagMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.CreateRepositoryTag at\n%s with params: %#v", m.CreateRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *m.CreateRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateRepositoryTag != nil && afterCreateRepositoryTagCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.CreateRepositoryTag at\n%s", m.funcCreateRepositoryTagOrigin)
	}

	if !m.CreateRepositoryTagMock.invocationsDone() && afterCreateRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.CreateRepositoryTag at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateRepositoryTagMock.expectedInvocations), m.CreateRepositoryTagMock.expectedInvocationsOrigin, afterCreateRepositoryTagCounter)
	}
}

type mServiceMockDeleteConvertedFileByFileUID struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockDeleteConvertedFileByFileUIDExpectation
	expectations       []*ServiceMockDeleteConvertedFileByFileUIDExpectation

	callArgs []*ServiceMockDeleteConvertedFileByFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockDeleteConvertedFileByFileUIDExpectation specifies expectation struct of the Service.DeleteConvertedFileByFileUID
type ServiceMockDeleteConvertedFileByFileUIDExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockDeleteConvertedFileByFileUIDParams
	paramPtrs          *ServiceMockDeleteConvertedFileByFileUIDParamPtrs
	expectationOrigins ServiceMockDeleteConvertedFileByFileUIDExpectationOrigins
	results            *ServiceMockDeleteConvertedFileByFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockDeleteConvertedFileByFileUIDParams contains parameters of the Service.DeleteConvertedFileByFileUID
type ServiceMockDeleteConvertedFileByFileUIDParams struct {
	ctx context.Context
	u1  uuid.UUID
	u2  uuid.UUID
}

// ServiceMockDeleteConvertedFileByFileUIDParamPtrs contains pointers to parameters of the Service.DeleteConvertedFileByFileUID
type ServiceMockDeleteConvertedFileByFileUIDParamPtrs struct {
	ctx *context.Context
	u1  *uuid.UUID
	u2  *uuid.UUID
}

// ServiceMockDeleteConvertedFileByFileUIDResults contains results of the Service.DeleteConvertedFileByFileUID
type ServiceMockDeleteConvertedFileByFileUIDResults struct {
	err error
}

// ServiceMockDeleteConvertedFileByFileUIDOrigins contains origins of expectations of the Service.DeleteConvertedFileByFileUID
type ServiceMockDeleteConvertedFileByFileUIDExpectationOrigins struct {
	origin    string
	originCtx string
	originU1  string
	originU2  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteConvertedFileByFileUID *mServiceMockDeleteConvertedFileByFileUID) Optional() *mServiceMockDeleteConvertedFileByFileUID {
	mmDeleteConvertedFileByFileUID.optional = true
	return mmDeleteConvertedFileByFileUID
}

// Expect sets up expected params for Service.DeleteConvertedFileByFileUID
func (mmDeleteConvertedFileByFileUID *mServiceMockDeleteConvertedFileByFileUID) Expect(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) *mServiceMockDeleteConvertedFileByFileUID {
	if mmDeleteConvertedFileByFileUID.mock.funcDeleteConvertedFileByFileUID != nil {
		mmDeleteConvertedFileByFileUID.mock.t.Fatalf("ServiceMock.DeleteConvertedFileByFileUID mock is already set by Set")
	}

	if mmDeleteConvertedFileByFileUID.defaultExpectation == nil {
		mmDeleteConvertedFileByFileUID.defaultExpectation = &ServiceMockDeleteConvertedFileByFileUIDExpectation{}
	}

	if mmDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs != nil {
		mmDeleteConvertedFileByFileUID.mock.t.Fatalf("ServiceMock.DeleteConvertedFileByFileUID mock is already set by ExpectParams functions")
	}

	mmDeleteConvertedFileByFileUID.defaultExpectation.params = &ServiceMockDeleteConvertedFileByFileUIDParams{ctx, u1, u2}
	mmDeleteConvertedFileByFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteConvertedFileByFileUID.expectations {
		if minimock.Equal(e.params, mmDeleteConvertedFileByFileUID.defaultExpectation.params) {
			mmDeleteConvertedFileByFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteConvertedFileByFileUID.defaultExpectation.params)
		}
	}

	return mmDeleteConvertedFileByFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Service.DeleteConvertedFileByFileUID
func (mmDeleteConvertedFileByFileUID *mServiceMockDeleteConvertedFileByFileUID) ExpectCtxParam1(ctx context.Context) *mServiceMockDeleteConvertedFileByFileUID {
	if mmDeleteConvertedFileByFileUID.mock.funcDeleteConvertedFileByFileUID != nil {
		mmDeleteConvertedFileByFileUID.mock.t.Fatalf("ServiceMock.DeleteConvertedFileByFileUID mock is already set by Set")
	}

	if mmDeleteConvertedFileByFileUID.defaultExpectation == nil {
		mmDeleteConvertedFileByFileUID.defaultExpectation = &ServiceMockDeleteConvertedFileByFileUIDExpectation{}
	}

	if mmDeleteConvertedFileByFileUID.defaultExpectation.params != nil {
		mmDeleteConvertedFileByFileUID.mock.t.Fatalf("ServiceMock.DeleteConvertedFileByFileUID mock is already set by Expect")
	}

	if mmDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs == nil {
		mmDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs = &ServiceMockDeleteConvertedFileByFileUIDParamPtrs{}
	}
	mmDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteConvertedFileByFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteConvertedFileByFileUID
}

// ExpectU1Param2 sets up expected param u1 for Service.DeleteConvertedFileByFileUID
func (mmDeleteConvertedFileByFileUID *mServiceMockDeleteConvertedFileByFileUID) ExpectU1Param2(u1 uuid.UUID) *mServiceMockDeleteConvertedFileByFileUID {
	if mmDeleteConvertedFileByFileUID.mock.funcDeleteConvertedFileByFileUID != nil {
		mmDeleteConvertedFileByFileUID.mock.t.Fatalf("ServiceMock.DeleteConvertedFileByFileUID mock is already set by Set")
	}

	if mmDeleteConvertedFileByFileUID.defaultExpectation == nil {
		mmDeleteConvertedFileByFileUID.defaultExpectation = &ServiceMockDeleteConvertedFileByFileUIDExpectation{}
	}

	if mmDeleteConvertedFileByFileUID.defaultExpectation.params != nil {
		mmDeleteConvertedFileByFileUID.mock.t.Fatalf("ServiceMock.DeleteConvertedFileByFileUID mock is already set by Expect")
	}

	if mmDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs == nil {
		mmDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs = &ServiceMockDeleteConvertedFileByFileUIDParamPtrs{}
	}
	mmDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs.u1 = &u1
	mmDeleteConvertedFileByFileUID.defaultExpectation.expectationOrigins.originU1 = minimock.CallerInfo(1)

	return mmDeleteConvertedFileByFileUID
}

// ExpectU2Param3 sets up expected param u2 for Service.DeleteConvertedFileByFileUID
func (mmDeleteConvertedFileByFileUID *mServiceMockDeleteConvertedFileByFileUID) ExpectU2Param3(u2 uuid.UUID) *mServiceMockDeleteConvertedFileByFileUID {
	if mmDeleteConvertedFileByFileUID.mock.funcDeleteConvertedFileByFileUID != nil {
		mmDeleteConvertedFileByFileUID.mock.t.Fatalf("ServiceMock.DeleteConvertedFileByFileUID mock is already set by Set")
	}

	if mmDeleteConvertedFileByFileUID.defaultExpectation == nil {
		mmDeleteConvertedFileByFileUID.defaultExpectation = &ServiceMockDeleteConvertedFileByFileUIDExpectation{}
	}

	if mmDeleteConvertedFileByFileUID.defaultExpectation.params != nil {
		mmDeleteConvertedFileByFileUID.mock.t.Fatalf("ServiceMock.DeleteConvertedFileByFileUID mock is already set by Expect")
	}

	if mmDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs == nil {
		mmDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs = &ServiceMockDeleteConvertedFileByFileUIDParamPtrs{}
	}
	mmDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs.u2 = &u2
	mmDeleteConvertedFileByFileUID.defaultExpectation.expectationOrigins.originU2 = minimock.CallerInfo(1)

	return mmDeleteConvertedFileByFileUID
}

// Inspect accepts an inspector function that has same arguments as the Service.DeleteConvertedFileByFileUID
func (mmDeleteConvertedFileByFileUID *mServiceMockDeleteConvertedFileByFileUID) Inspect(f func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID)) *mServiceMockDeleteConvertedFileByFileUID {
	if mmDeleteConvertedFileByFileUID.mock.inspectFuncDeleteConvertedFileByFileUID != nil {
		mmDeleteConvertedFileByFileUID.mock.t.Fatalf("Inspect function is already set for ServiceMock.DeleteConvertedFileByFileUID")
	}

	mmDeleteConvertedFileByFileUID.mock.inspectFuncDeleteConvertedFileByFileUID = f

	return mmDeleteConvertedFileByFileUID
}

// Return sets up results that will be returned by Service.DeleteConvertedFileByFileUID
func (mmDeleteConvertedFileByFileUID *mServiceMockDeleteConvertedFileByFileUID) Return(err error) *ServiceMock {
	if mmDeleteConvertedFileByFileUID.mock.funcDeleteConvertedFileByFileUID != nil {
		mmDeleteConvertedFileByFileUID.mock.t.Fatalf("ServiceMock.DeleteConvertedFileByFileUID mock is already set by Set")
	}

	if mmDeleteConvertedFileByFileUID.defaultExpectation == nil {
		mmDeleteConvertedFileByFileUID.defaultExpectation = &ServiceMockDeleteConvertedFileByFileUIDExpectation{mock: mmDeleteConvertedFileByFileUID.mock}
	}
	mmDeleteConvertedFileByFileUID.defaultExpectation.results = &ServiceMockDeleteConvertedFileByFileUIDResults{err}
	mmDeleteConvertedFileByFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteConvertedFileByFileUID.mock
}

// Set uses given function f to mock the Service.DeleteConvertedFileByFileUID method
func (mmDeleteConvertedFileByFileUID *mServiceMockDeleteConvertedFileByFileUID) Set(f func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) (err error)) *ServiceMock {
	if mmDeleteConvertedFileByFileUID.defaultExpectation != nil {
		mmDeleteConvertedFileByFileUID.mock.t.Fatalf("Default expectation is already set for the Service.DeleteConvertedFileByFileUID method")
	}

	if len(mmDeleteConvertedFileByFileUID.expectations) > 0 {
		mmDeleteConvertedFileByFileUID.mock.t.Fatalf("Some expectations are already set for the Service.DeleteConvertedFileByFileUID method")
	}

	mmDeleteConvertedFileByFileUID.mock.funcDeleteConvertedFileByFileUID = f
	mmDeleteConvertedFileByFileUID.mock.funcDeleteConvertedFileByFileUIDOrigin = minimock.CallerInfo(1)
	return mmDeleteConvertedFileByFileUID.mock
}

// When sets expectation for the Service.DeleteConvertedFileByFileUID which will trigger the result defined by the following
// Then helper
func (mmDeleteConvertedFileByFileUID *mServiceMockDeleteConvertedFileByFileUID) When(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) *ServiceMockDeleteConvertedFileByFileUIDExpectation {
	if mmDeleteConvertedFileByFileUID.mock.funcDeleteConvertedFileByFileUID != nil {
		mmDeleteConvertedFileByFileUID.mock.t.Fatalf("ServiceMock.DeleteConvertedFileByFileUID mock is already set by Set")
	}

	expectation := &ServiceMockDeleteConvertedFileByFileUIDExpectation{
		mock:               mmDeleteConvertedFileByFileUID.mock,
		params:             &ServiceMockDeleteConvertedFileByFileUIDParams{ctx, u1, u2},
		expectationOrigins: ServiceMockDeleteConvertedFileByFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteConvertedFileByFileUID.expectations = append(mmDeleteConvertedFileByFileUID.expectations, expectation)
	return expectation
}

// Then sets up Service.DeleteConvertedFileByFileUID return parameters for the expectation previously defined by the When method
func (e *ServiceMockDeleteConvertedFileByFileUIDExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockDeleteConvertedFileByFileUIDResults{err}
	return e.mock
}

// Times sets number of times Service.DeleteConvertedFileByFileUID should be invoked
func (mmDeleteConvertedFileByFileUID *mServiceMockDeleteConvertedFileByFileUID) Times(n uint64) *mServiceMockDeleteConvertedFileByFileUID {
	if n == 0 {
		mmDeleteConvertedFileByFileUID.mock.t.Fatalf("Times of ServiceMock.DeleteConvertedFileByFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteConvertedFileByFileUID.expectedInvocations, n)
	mmDeleteConvertedFileByFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteConvertedFileByFileUID
}

func (mmDeleteConvertedFileByFileUID *mServiceMockDeleteConvertedFileByFileUID) invocationsDone() bool {
	if len(mmDeleteConvertedFileByFileUID.expectations) == 0 && mmDeleteConvertedFileByFileUID.defaultExpectation == nil && mmDeleteConvertedFileByFileUID.mock.funcDeleteConvertedFileByFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteConvertedFileByFileUID.mock.afterDeleteConvertedFileByFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteConvertedFileByFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteConvertedFileByFileUID implements mm_service.Service
func (mmDeleteConvertedFileByFileUID *ServiceMock) DeleteConvertedFileByFileUID(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteConvertedFileByFileUID.beforeDeleteConvertedFileByFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteConvertedFileByFileUID.afterDeleteConvertedFileByFileUIDCounter, 1)

	mmDeleteConvertedFileByFileUID.t.Helper()

	if mmDeleteConvertedFileByFileUID.inspectFuncDeleteConvertedFileByFileUID != nil {
		mmDeleteConvertedFileByFileUID.inspectFuncDeleteConvertedFileByFileUID(ctx, u1, u2)
	}

	mm_params := ServiceMockDeleteConvertedFileByFileUIDParams{ctx, u1, u2}

	// Record call args
	mmDeleteConvertedFileByFileUID.DeleteConvertedFileByFileUIDMock.mutex.Lock()
	mmDeleteConvertedFileByFileUID.DeleteConvertedFileByFileUIDMock.callArgs = append(mmDeleteConvertedFileByFileUID.DeleteConvertedFileByFileUIDMock.callArgs, &mm_params)
	mmDeleteConvertedFileByFileUID.DeleteConvertedFileByFileUIDMock.mutex.Unlock()

	for _, e := range mmDeleteConvertedFileByFileUID.DeleteConvertedFileByFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteConvertedFileByFileUID.DeleteConvertedFileByFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteConvertedFileByFileUID.DeleteConvertedFileByFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteConvertedFileByFileUID.DeleteConvertedFileByFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteConvertedFileByFileUID.DeleteConvertedFileByFileUIDMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockDeleteConvertedFileByFileUIDParams{ctx, u1, u2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteConvertedFileByFileUID.t.Errorf("ServiceMock.DeleteConvertedFileByFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteConvertedFileByFileUID.DeleteConvertedFileByFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmDeleteConvertedFileByFileUID.t.Errorf("ServiceMock.DeleteConvertedFileByFileUID got unexpected parameter u1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteConvertedFileByFileUID.DeleteConvertedFileByFileUIDMock.defaultExpectation.expectationOrigins.originU1, *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

			if mm_want_ptrs.u2 != nil && !minimock.Equal(*mm_want_ptrs.u2, mm_got.u2) {
				mmDeleteConvertedFileByFileUID.t.Errorf("ServiceMock.DeleteConvertedFileByFileUID got unexpected parameter u2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteConvertedFileByFileUID.DeleteConvertedFileByFileUIDMock.defaultExpectation.expectationOrigins.originU2, *mm_want_ptrs.u2, mm_got.u2, minimock.Diff(*mm_want_ptrs.u2, mm_got.u2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteConvertedFileByFileUID.t.Errorf("ServiceMock.DeleteConvertedFileByFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteConvertedFileByFileUID.DeleteConvertedFileByFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteConvertedFileByFileUID.DeleteConvertedFileByFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteConvertedFileByFileUID.t.Fatal("No results are set for the ServiceMock.DeleteConvertedFileByFileUID")
		}
		return (*mm_results).err
	}
	if mmDeleteConvertedFileByFileUID.funcDeleteConvertedFileByFileUID != nil {
		return mmDeleteConvertedFileByFileUID.funcDeleteConvertedFileByFileUID(ctx, u1, u2)
	}
	mmDeleteConvertedFileByFileUID.t.Fatalf("Unexpected call to ServiceMock.DeleteConvertedFileByFileUID. %v %v %v", ctx, u1, u2)
	return
}

// DeleteConvertedFileByFileUIDAfterCounter returns a count of finished ServiceMock.DeleteConvertedFileByFileUID invocations
func (mmDeleteConvertedFileByFileUID *ServiceMock) DeleteConvertedFileByFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteConvertedFileByFileUID.afterDeleteConvertedFileByFileUIDCounter)
}

// DeleteConvertedFileByFileUIDBeforeCounter returns a count of ServiceMock.DeleteConvertedFileByFileUID invocations
func (mmDeleteConvertedFileByFileUID *ServiceMock) DeleteConvertedFileByFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteConvertedFileByFileUID.beforeDeleteConvertedFileByFileUIDCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.DeleteConvertedFileByFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteConvertedFileByFileUID *mServiceMockDeleteConvertedFileByFileUID) Calls() []*ServiceMockDeleteConvertedFileByFileUIDParams {
	mmDeleteConvertedFileByFileUID.mutex.RLock()

	argCopy := make([]*ServiceMockDeleteConvertedFileByFileUIDParams, len(mmDeleteConvertedFileByFileUID.callArgs))
	copy(argCopy, mmDeleteConvertedFileByFileUID.callArgs)

	mmDeleteConvertedFileByFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteConvertedFileByFileUIDDone returns true if the count of the DeleteConvertedFileByFileUID invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockDeleteConvertedFileByFileUIDDone() bool {
	if m.DeleteConvertedFileByFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteConvertedFileByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteConvertedFileByFileUIDMock.invocationsDone()
}

// MinimockDeleteConvertedFileByFileUIDInspect logs each unmet expectation
func (m *ServiceMock) MinimockDeleteConvertedFileByFileUIDInspect() {
	for _, e := range m.DeleteConvertedFileByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.DeleteConvertedFileByFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteConvertedFileByFileUIDCounter := mm_atomic.LoadUint64(&m.afterDeleteConvertedFileByFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteConvertedFileByFileUIDMock.defaultExpectation != nil && afterDeleteConvertedFileByFileUIDCounter < 1 {
		if m.DeleteConvertedFileByFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.DeleteConvertedFileByFileUID at\n%s", m.DeleteConvertedFileByFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.DeleteConvertedFileByFileUID at\n%s with params: %#v", m.DeleteConvertedFileByFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.DeleteConvertedFileByFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteConvertedFileByFileUID != nil && afterDeleteConvertedFileByFileUIDCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.DeleteConvertedFileByFileUID at\n%s", m.funcDeleteConvertedFileByFileUIDOrigin)
	}

	if !m.DeleteConvertedFileByFileUIDMock.invocationsDone() && afterDeleteConvertedFileByFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.DeleteConvertedFileByFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteConvertedFileByFileUIDMock.expectedInvocations), m.DeleteConvertedFileByFileUIDMock.expectedInvocationsOrigin, afterDeleteConvertedFileByFileUIDCounter)
	}
}

type mServiceMockDeleteFiles struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockDeleteFilesExpectation
	expectations       []*ServiceMockDeleteFilesExpectation

	callArgs []*ServiceMockDeleteFilesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockDeleteFilesExpectation specifies expectation struct of the Service.DeleteFiles
type ServiceMockDeleteFilesExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockDeleteFilesParams
	paramPtrs          *ServiceMockDeleteFilesParamPtrs
	expectationOrigins ServiceMockDeleteFilesExpectationOrigins
	results            *ServiceMockDeleteFilesResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockDeleteFilesParams contains parameters of the Service.DeleteFiles
type ServiceMockDeleteFilesParams struct {
	ctx context.Context
	s1  string
	sa1 []string
}

// ServiceMockDeleteFilesParamPtrs contains pointers to parameters of the Service.DeleteFiles
type ServiceMockDeleteFilesParamPtrs struct {
	ctx *context.Context
	s1  *string
	sa1 *[]string
}

// ServiceMockDeleteFilesResults contains results of the Service.DeleteFiles
type ServiceMockDeleteFilesResults struct {
	err error
}

// ServiceMockDeleteFilesOrigins contains origins of expectations of the Service.DeleteFiles
type ServiceMockDeleteFilesExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
	originSa1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteFiles *mServiceMockDeleteFiles) Optional() *mServiceMockDeleteFiles {
	mmDeleteFiles.optional = true
	return mmDeleteFiles
}

// Expect sets up expected params for Service.DeleteFiles
func (mmDeleteFiles *mServiceMockDeleteFiles) Expect(ctx context.Context, s1 string, sa1 []string) *mServiceMockDeleteFiles {
	if mmDeleteFiles.mock.funcDeleteFiles != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by Set")
	}

	if mmDeleteFiles.defaultExpectation == nil {
		mmDeleteFiles.defaultExpectation = &ServiceMockDeleteFilesExpectation{}
	}

	if mmDeleteFiles.defaultExpectation.paramPtrs != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by ExpectParams functions")
	}

	mmDeleteFiles.defaultExpectation.params = &ServiceMockDeleteFilesParams{ctx, s1, sa1}
	mmDeleteFiles.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteFiles.expectations {
		if minimock.Equal(e.params, mmDeleteFiles.defaultExpectation.params) {
			mmDeleteFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteFiles.defaultExpectation.params)
		}
	}

	return mmDeleteFiles
}

// ExpectCtxParam1 sets up expected param ctx for Service.DeleteFiles
func (mmDeleteFiles *mServiceMockDeleteFiles) ExpectCtxParam1(ctx context.Context) *mServiceMockDeleteFiles {
	if mmDeleteFiles.mock.funcDeleteFiles != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by Set")
	}

	if mmDeleteFiles.defaultExpectation == nil {
		mmDeleteFiles.defaultExpectation = &ServiceMockDeleteFilesExpectation{}
	}

	if mmDeleteFiles.defaultExpectation.params != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by Expect")
	}

	if mmDeleteFiles.defaultExpectation.paramPtrs == nil {
		mmDeleteFiles.defaultExpectation.paramPtrs = &ServiceMockDeleteFilesParamPtrs{}
	}
	mmDeleteFiles.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteFiles.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteFiles
}

// ExpectS1Param2 sets up expected param s1 for Service.DeleteFiles
func (mmDeleteFiles *mServiceMockDeleteFiles) ExpectS1Param2(s1 string) *mServiceMockDeleteFiles {
	if mmDeleteFiles.mock.funcDeleteFiles != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by Set")
	}

	if mmDeleteFiles.defaultExpectation == nil {
		mmDeleteFiles.defaultExpectation = &ServiceMockDeleteFilesExpectation{}
	}

	if mmDeleteFiles.defaultExpectation.params != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by Expect")
	}

	if mmDeleteFiles.defaultExpectation.paramPtrs == nil {
		mmDeleteFiles.defaultExpectation.paramPtrs = &ServiceMockDeleteFilesParamPtrs{}
	}
	mmDeleteFiles.defaultExpectation.paramPtrs.s1 = &s1
	mmDeleteFiles.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmDeleteFiles
}

// ExpectSa1Param3 sets up expected param sa1 for Service.DeleteFiles
func (mmDeleteFiles *mServiceMockDeleteFiles) ExpectSa1Param3(sa1 []string) *mServiceMockDeleteFiles {
	if mmDeleteFiles.mock.funcDeleteFiles != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by Set")
	}

	if mmDeleteFiles.defaultExpectation == nil {
		mmDeleteFiles.defaultExpectation = &ServiceMockDeleteFilesExpectation{}
	}

	if mmDeleteFiles.defaultExpectation.params != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by Expect")
	}

	if mmDeleteFiles.defaultExpectation.paramPtrs == nil {
		mmDeleteFiles.defaultExpectation.paramPtrs = &ServiceMockDeleteFilesParamPtrs{}
	}
	mmDeleteFiles.defaultExpectation.paramPtrs.sa1 = &sa1
	mmDeleteFiles.defaultExpectation.expectationOrigins.originSa1 = minimock.CallerInfo(1)

	return mmDeleteFiles
}

// Inspect accepts an inspector function that has same arguments as the Service.DeleteFiles
func (mmDeleteFiles *mServiceMockDeleteFiles) Inspect(f func(ctx context.Context, s1 string, sa1 []string)) *mServiceMockDeleteFiles {
	if mmDeleteFiles.mock.inspectFuncDeleteFiles != nil {
		mmDeleteFiles.mock.t.Fatalf("Inspect function is already set for ServiceMock.DeleteFiles")
	}

	mmDeleteFiles.mock.inspectFuncDeleteFiles = f

	return mmDeleteFiles
}

// Return sets up results that will be returned by Service.DeleteFiles
func (mmDeleteFiles *mServiceMockDeleteFiles) Return(err error) *ServiceMock {
	if mmDeleteFiles.mock.funcDeleteFiles != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by Set")
	}

	if mmDeleteFiles.defaultExpectation == nil {
		mmDeleteFiles.defaultExpectation = &ServiceMockDeleteFilesExpectation{mock: mmDeleteFiles.mock}
	}
	mmDeleteFiles.defaultExpectation.results = &ServiceMockDeleteFilesResults{err}
	mmDeleteFiles.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteFiles.mock
}

// Set uses given function f to mock the Service.DeleteFiles method
func (mmDeleteFiles *mServiceMockDeleteFiles) Set(f func(ctx context.Context, s1 string, sa1 []string) (err error)) *ServiceMock {
	if mmDeleteFiles.defaultExpectation != nil {
		mmDeleteFiles.mock.t.Fatalf("Default expectation is already set for the Service.DeleteFiles method")
	}

	if len(mmDeleteFiles.expectations) > 0 {
		mmDeleteFiles.mock.t.Fatalf("Some expectations are already set for the Service.DeleteFiles method")
	}

	mmDeleteFiles.mock.funcDeleteFiles = f
	mmDeleteFiles.mock.funcDeleteFilesOrigin = minimock.CallerInfo(1)
	return mmDeleteFiles.mock
}

// When sets expectation for the Service.DeleteFiles which will trigger the result defined by the following
// Then helper
func (mmDeleteFiles *mServiceMockDeleteFiles) When(ctx context.Context, s1 string, sa1 []string) *ServiceMockDeleteFilesExpectation {
	if mmDeleteFiles.mock.funcDeleteFiles != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by Set")
	}

	expectation := &ServiceMockDeleteFilesExpectation{
		mock:               mmDeleteFiles.mock,
		params:             &ServiceMockDeleteFilesParams{ctx, s1, sa1},
		expectationOrigins: ServiceMockDeleteFilesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteFiles.expectations = append(mmDeleteFiles.expectations, expectation)
	return expectation
}

// Then sets up Service.DeleteFiles return parameters for the expectation previously defined by the When method
func (e *ServiceMockDeleteFilesExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockDeleteFilesResults{err}
	return e.mock
}

// Times sets number of times Service.DeleteFiles should be invoked
func (mmDeleteFiles *mServiceMockDeleteFiles) Times(n uint64) *mServiceMockDeleteFiles {
	if n == 0 {
		mmDeleteFiles.mock.t.Fatalf("Times of ServiceMock.DeleteFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteFiles.expectedInvocations, n)
	mmDeleteFiles.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteFiles
}

func (mmDeleteFiles *mServiceMockDeleteFiles) invocationsDone() bool {
	if len(mmDeleteFiles.expectations) == 0 && mmDeleteFiles.defaultExpectation == nil && mmDeleteFiles.mock.funcDeleteFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteFiles.mock.afterDeleteFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteFiles implements mm_service.Service
func (mmDeleteFiles *ServiceMock) DeleteFiles(ctx context.Context, s1 string, sa1 []string) (err error) {
	mm_atomic.AddUint64(&mmDeleteFiles.beforeDeleteFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteFiles.afterDeleteFilesCounter, 1)

	mmDeleteFiles.t.Helper()

	if mmDeleteFiles.inspectFuncDeleteFiles != nil {
		mmDeleteFiles.inspectFuncDeleteFiles(ctx, s1, sa1)
	}

	mm_params := ServiceMockDeleteFilesParams{ctx, s1, sa1}

	// Record call args
	mmDeleteFiles.DeleteFilesMock.mutex.Lock()
	mmDeleteFiles.DeleteFilesMock.callArgs = append(mmDeleteFiles.DeleteFilesMock.callArgs, &mm_params)
	mmDeleteFiles.DeleteFilesMock.mutex.Unlock()

	for _, e := range mmDeleteFiles.DeleteFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteFiles.DeleteFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteFiles.DeleteFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteFiles.DeleteFilesMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteFiles.DeleteFilesMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockDeleteFilesParams{ctx, s1, sa1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteFiles.t.Errorf("ServiceMock.DeleteFiles got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFiles.DeleteFilesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmDeleteFiles.t.Errorf("ServiceMock.DeleteFiles got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFiles.DeleteFilesMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

			if mm_want_ptrs.sa1 != nil && !minimock.Equal(*mm_want_ptrs.sa1, mm_got.sa1) {
				mmDeleteFiles.t.Errorf("ServiceMock.DeleteFiles got unexpected parameter sa1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFiles.DeleteFilesMock.defaultExpectation.expectationOrigins.originSa1, *mm_want_ptrs.sa1, mm_got.sa1, minimock.Diff(*mm_want_ptrs.sa1, mm_got.sa1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteFiles.t.Errorf("ServiceMock.DeleteFiles got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteFiles.DeleteFilesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteFiles.DeleteFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteFiles.t.Fatal("No results are set for the ServiceMock.DeleteFiles")
		}
		return (*mm_results).err
	}
	if mmDeleteFiles.funcDeleteFiles != nil {
		return mmDeleteFiles.funcDeleteFiles(ctx, s1, sa1)
	}
	mmDeleteFiles.t.Fatalf("Unexpected call to ServiceMock.DeleteFiles. %v %v %v", ctx, s1, sa1)
	return
}

// DeleteFilesAfterCounter returns a count of finished ServiceMock.DeleteFiles invocations
func (mmDeleteFiles *ServiceMock) DeleteFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFiles.afterDeleteFilesCounter)
}

// DeleteFilesBeforeCounter returns a count of ServiceMock.DeleteFiles invocations
func (mmDeleteFiles *ServiceMock) DeleteFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFiles.beforeDeleteFilesCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.DeleteFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteFiles *mServiceMockDeleteFiles) Calls() []*ServiceMockDeleteFilesParams {
	mmDeleteFiles.mutex.RLock()

	argCopy := make([]*ServiceMockDeleteFilesParams, len(mmDeleteFiles.callArgs))
	copy(argCopy, mmDeleteFiles.callArgs)

	mmDeleteFiles.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteFilesDone returns true if the count of the DeleteFiles invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockDeleteFilesDone() bool {
	if m.DeleteFilesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteFilesMock.invocationsDone()
}

// MinimockDeleteFilesInspect logs each unmet expectation
func (m *ServiceMock) MinimockDeleteFilesInspect() {
	for _, e := range m.DeleteFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.DeleteFiles at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteFilesCounter := mm_atomic.LoadUint64(&m.afterDeleteFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFilesMock.defaultExpectation != nil && afterDeleteFilesCounter < 1 {
		if m.DeleteFilesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.DeleteFiles at\n%s", m.DeleteFilesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.DeleteFiles at\n%s with params: %#v", m.DeleteFilesMock.defaultExpectation.expectationOrigins.origin, *m.DeleteFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFiles != nil && afterDeleteFilesCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.DeleteFiles at\n%s", m.funcDeleteFilesOrigin)
	}

	if !m.DeleteFilesMock.invocationsDone() && afterDeleteFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.DeleteFiles at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteFilesMock.expectedInvocations), m.DeleteFilesMock.expectedInvocationsOrigin, afterDeleteFilesCounter)
	}
}

type mServiceMockDeleteFilesWithPrefix struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockDeleteFilesWithPrefixExpectation
	expectations       []*ServiceMockDeleteFilesWithPrefixExpectation

	callArgs []*ServiceMockDeleteFilesWithPrefixParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockDeleteFilesWithPrefixExpectation specifies expectation struct of the Service.DeleteFilesWithPrefix
type ServiceMockDeleteFilesWithPrefixExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockDeleteFilesWithPrefixParams
	paramPtrs          *ServiceMockDeleteFilesWithPrefixParamPtrs
	expectationOrigins ServiceMockDeleteFilesWithPrefixExpectationOrigins
	results            *ServiceMockDeleteFilesWithPrefixResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockDeleteFilesWithPrefixParams contains parameters of the Service.DeleteFilesWithPrefix
type ServiceMockDeleteFilesWithPrefixParams struct {
	ctx context.Context
	s1  string
	s2  string
}

// ServiceMockDeleteFilesWithPrefixParamPtrs contains pointers to parameters of the Service.DeleteFilesWithPrefix
type ServiceMockDeleteFilesWithPrefixParamPtrs struct {
	ctx *context.Context
	s1  *string
	s2  *string
}

// ServiceMockDeleteFilesWithPrefixResults contains results of the Service.DeleteFilesWithPrefix
type ServiceMockDeleteFilesWithPrefixResults struct {
	err error
}

// ServiceMockDeleteFilesWithPrefixOrigins contains origins of expectations of the Service.DeleteFilesWithPrefix
type ServiceMockDeleteFilesWithPrefixExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
	originS2  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteFilesWithPrefix *mServiceMockDeleteFilesWithPrefix) Optional() *mServiceMockDeleteFilesWithPrefix {
	mmDeleteFilesWithPrefix.optional = true
	return mmDeleteFilesWithPrefix
}

// Expect sets up expected params for Service.DeleteFilesWithPrefix
func (mmDeleteFilesWithPrefix *mServiceMockDeleteFilesWithPrefix) Expect(ctx context.Context, s1 string, s2 string) *mServiceMockDeleteFilesWithPrefix {
	if mmDeleteFilesWithPrefix.mock.funcDeleteFilesWithPrefix != nil {
		mmDeleteFilesWithPrefix.mock.t.Fatalf("ServiceMock.DeleteFilesWithPrefix mock is already set by Set")
	}

	if mmDeleteFilesWithPrefix.defaultExpectation == nil {
		mmDeleteFilesWithPrefix.defaultExpectation = &ServiceMockDeleteFilesWithPrefixExpectation{}
	}

	if mmDeleteFilesWithPrefix.defaultExpectation.paramPtrs != nil {
		mmDeleteFilesWithPrefix.mock.t.Fatalf("ServiceMock.DeleteFilesWithPrefix mock is already set by ExpectParams functions")
	}

	mmDeleteFilesWithPrefix.defaultExpectation.params = &ServiceMockDeleteFilesWithPrefixParams{ctx, s1, s2}
	mmDeleteFilesWithPrefix.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteFilesWithPrefix.expectations {
		if minimock.Equal(e.params, mmDeleteFilesWithPrefix.defaultExpectation.params) {
			mmDeleteFilesWithPrefix.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteFilesWithPrefix.defaultExpectation.params)
		}
	}

	return mmDeleteFilesWithPrefix
}

// ExpectCtxParam1 sets up expected param ctx for Service.DeleteFilesWithPrefix
func (mmDeleteFilesWithPrefix *mServiceMockDeleteFilesWithPrefix) ExpectCtxParam1(ctx context.Context) *mServiceMockDeleteFilesWithPrefix {
	if mmDeleteFilesWithPrefix.mock.funcDeleteFilesWithPrefix != nil {
		mmDeleteFilesWithPrefix.mock.t.Fatalf("ServiceMock.DeleteFilesWithPrefix mock is already set by Set")
	}

	if mmDeleteFilesWithPrefix.defaultExpectation == nil {
		mmDeleteFilesWithPrefix.defaultExpectation = &ServiceMockDeleteFilesWithPrefixExpectation{}
	}

	if mmDeleteFilesWithPrefix.defaultExpectation.params != nil {
		mmDeleteFilesWithPrefix.mock.t.Fatalf("ServiceMock.DeleteFilesWithPrefix mock is already set by Expect")
	}

	if mmDeleteFilesWithPrefix.defaultExpectation.paramPtrs == nil {
		mmDeleteFilesWithPrefix.defaultExpectation.paramPtrs = &ServiceMockDeleteFilesWithPrefixParamPtrs{}
	}
	mmDeleteFilesWithPrefix.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteFilesWithPrefix.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteFilesWithPrefix
}

// ExpectS1Param2 sets up expected param s1 for Service.DeleteFilesWithPrefix
func (mmDeleteFilesWithPrefix *mServiceMockDeleteFilesWithPrefix) ExpectS1Param2(s1 string) *mServiceMockDeleteFilesWithPrefix {
	if mmDeleteFilesWithPrefix.mock.funcDeleteFilesWithPrefix != nil {
		mmDeleteFilesWithPrefix.mock.t.Fatalf("ServiceMock.DeleteFilesWithPrefix mock is already set by Set")
	}

	if mmDeleteFilesWithPrefix.defaultExpectation == nil {
		mmDeleteFilesWithPrefix.defaultExpectation = &ServiceMockDeleteFilesWithPrefixExpectation{}
	}

	if mmDeleteFilesWithPrefix.defaultExpectation.params != nil {
		mmDeleteFilesWithPrefix.mock.t.Fatalf("ServiceMock.DeleteFilesWithPrefix mock is already set by Expect")
	}

	if mmDeleteFilesWithPrefix.defaultExpectation.paramPtrs == nil {
		mmDeleteFilesWithPrefix.defaultExpectation.paramPtrs = &ServiceMockDeleteFilesWithPrefixParamPtrs{}
	}
	mmDeleteFilesWithPrefix.defaultExpectation.paramPtrs.s1 = &s1
	mmDeleteFilesWithPrefix.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmDeleteFilesWithPrefix
}

// ExpectS2Param3 sets up expected param s2 for Service.DeleteFilesWithPrefix
func (mmDeleteFilesWithPrefix *mServiceMockDeleteFilesWithPrefix) ExpectS2Param3(s2 string) *mServiceMockDeleteFilesWithPrefix {
	if mmDeleteFilesWithPrefix.mock.funcDeleteFilesWithPrefix != nil {
		mmDeleteFilesWithPrefix.mock.t.Fatalf("ServiceMock.DeleteFilesWithPrefix mock is already set by Set")
	}

	if mmDeleteFilesWithPrefix.defaultExpectation == nil {
		mmDeleteFilesWithPrefix.defaultExpectation = &ServiceMockDeleteFilesWithPrefixExpectation{}
	}

	if mmDeleteFilesWithPrefix.defaultExpectation.params != nil {
		mmDeleteFilesWithPrefix.mock.t.Fatalf("ServiceMock.DeleteFilesWithPrefix mock is already set by Expect")
	}

	if mmDeleteFilesWithPrefix.defaultExpectation.paramPtrs == nil {
		mmDeleteFilesWithPrefix.defaultExpectation.paramPtrs = &ServiceMockDeleteFilesWithPrefixParamPtrs{}
	}
	mmDeleteFilesWithPrefix.defaultExpectation.paramPtrs.s2 = &s2
	mmDeleteFilesWithPrefix.defaultExpectation.expectationOrigins.originS2 = minimock.CallerInfo(1)

	return mmDeleteFilesWithPrefix
}

// Inspect accepts an inspector function that has same arguments as the Service.DeleteFilesWithPrefix
func (mmDeleteFilesWithPrefix *mServiceMockDeleteFilesWithPrefix) Inspect(f func(ctx context.Context, s1 string, s2 string)) *mServiceMockDeleteFilesWithPrefix {
	if mmDeleteFilesWithPrefix.mock.inspectFuncDeleteFilesWithPrefix != nil {
		mmDeleteFilesWithPrefix.mock.t.Fatalf("Inspect function is already set for ServiceMock.DeleteFilesWithPrefix")
	}

	mmDeleteFilesWithPrefix.mock.inspectFuncDeleteFilesWithPrefix = f

	return mmDeleteFilesWithPrefix
}

// Return sets up results that will be returned by Service.DeleteFilesWithPrefix
func (mmDeleteFilesWithPrefix *mServiceMockDeleteFilesWithPrefix) Return(err error) *ServiceMock {
	if mmDeleteFilesWithPrefix.mock.funcDeleteFilesWithPrefix != nil {
		mmDeleteFilesWithPrefix.mock.t.Fatalf("ServiceMock.DeleteFilesWithPrefix mock is already set by Set")
	}

	if mmDeleteFilesWithPrefix.defaultExpectation == nil {
		mmDeleteFilesWithPrefix.defaultExpectation = &ServiceMockDeleteFilesWithPrefixExpectation{mock: mmDeleteFilesWithPrefix.mock}
	}
	mmDeleteFilesWithPrefix.defaultExpectation.results = &ServiceMockDeleteFilesWithPrefixResults{err}
	mmDeleteFilesWithPrefix.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteFilesWithPrefix.mock
}

// Set uses given function f to mock the Service.DeleteFilesWithPrefix method
func (mmDeleteFilesWithPrefix *mServiceMockDeleteFilesWithPrefix) Set(f func(ctx context.Context, s1 string, s2 string) (err error)) *ServiceMock {
	if mmDeleteFilesWithPrefix.defaultExpectation != nil {
		mmDeleteFilesWithPrefix.mock.t.Fatalf("Default expectation is already set for the Service.DeleteFilesWithPrefix method")
	}

	if len(mmDeleteFilesWithPrefix.expectations) > 0 {
		mmDeleteFilesWithPrefix.mock.t.Fatalf("Some expectations are already set for the Service.DeleteFilesWithPrefix method")
	}

	mmDeleteFilesWithPrefix.mock.funcDeleteFilesWithPrefix = f
	mmDeleteFilesWithPrefix.mock.funcDeleteFilesWithPrefixOrigin = minimock.CallerInfo(1)
	return mmDeleteFilesWithPrefix.mock
}

// When sets expectation for the Service.DeleteFilesWithPrefix which will trigger the result defined by the following
// Then helper
func (mmDeleteFilesWithPrefix *mServiceMockDeleteFilesWithPrefix) When(ctx context.Context, s1 string, s2 string) *ServiceMockDeleteFilesWithPrefixExpectation {
	if mmDeleteFilesWithPrefix.mock.funcDeleteFilesWithPrefix != nil {
		mmDeleteFilesWithPrefix.mock.t.Fatalf("ServiceMock.DeleteFilesWithPrefix mock is already set by Set")
	}

	expectation := &ServiceMockDeleteFilesWithPrefixExpectation{
		mock:               mmDeleteFilesWithPrefix.mock,
		params:             &ServiceMockDeleteFilesWithPrefixParams{ctx, s1, s2},
		expectationOrigins: ServiceMockDeleteFilesWithPrefixExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteFilesWithPrefix.expectations = append(mmDeleteFilesWithPrefix.expectations, expectation)
	return expectation
}

// Then sets up Service.DeleteFilesWithPrefix return parameters for the expectation previously defined by the When method
func (e *ServiceMockDeleteFilesWithPrefixExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockDeleteFilesWithPrefixResults{err}
	return e.mock
}

// Times sets number of times Service.DeleteFilesWithPrefix should be invoked
func (mmDeleteFilesWithPrefix *mServiceMockDeleteFilesWithPrefix) Times(n uint64) *mServiceMockDeleteFilesWithPrefix {
	if n == 0 {
		mmDeleteFilesWithPrefix.mock.t.Fatalf("Times of ServiceMock.DeleteFilesWithPrefix mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteFilesWithPrefix.expectedInvocations, n)
	mmDeleteFilesWithPrefix.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteFilesWithPrefix
}

func (mmDeleteFilesWithPrefix *mServiceMockDeleteFilesWithPrefix) invocationsDone() bool {
	if len(mmDeleteFilesWithPrefix.expectations) == 0 && mmDeleteFilesWithPrefix.defaultExpectation == nil && mmDeleteFilesWithPrefix.mock.funcDeleteFilesWithPrefix == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteFilesWithPrefix.mock.afterDeleteFilesWithPrefixCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteFilesWithPrefix.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteFilesWithPrefix implements mm_service.Service
func (mmDeleteFilesWithPrefix *ServiceMock) DeleteFilesWithPrefix(ctx context.Context, s1 string, s2 string) (err error) {
	mm_atomic.AddUint64(&mmDeleteFilesWithPrefix.beforeDeleteFilesWithPrefixCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteFilesWithPrefix.afterDeleteFilesWithPrefixCounter, 1)

	mmDeleteFilesWithPrefix.t.Helper()

	if mmDeleteFilesWithPrefix.inspectFuncDeleteFilesWithPrefix != nil {
		mmDeleteFilesWithPrefix.inspectFuncDeleteFilesWithPrefix(ctx, s1, s2)
	}

	mm_params := ServiceMockDeleteFilesWithPrefixParams{ctx, s1, s2}

	// Record call args
	mmDeleteFilesWithPrefix.DeleteFilesWithPrefixMock.mutex.Lock()
	mmDeleteFilesWithPrefix.DeleteFilesWithPrefixMock.callArgs = append(mmDeleteFilesWithPrefix.DeleteFilesWithPrefixMock.callArgs, &mm_params)
	mmDeleteFilesWithPrefix.DeleteFilesWithPrefixMock.mutex.Unlock()

	for _, e := range mmDeleteFilesWithPrefix.DeleteFilesWithPrefixMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteFilesWithPrefix.DeleteFilesWithPrefixMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteFilesWithPrefix.DeleteFilesWithPrefixMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteFilesWithPrefix.DeleteFilesWithPrefixMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteFilesWithPrefix.DeleteFilesWithPrefixMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockDeleteFilesWithPrefixParams{ctx, s1, s2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteFilesWithPrefix.t.Errorf("ServiceMock.DeleteFilesWithPrefix got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFilesWithPrefix.DeleteFilesWithPrefixMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmDeleteFilesWithPrefix.t.Errorf("ServiceMock.DeleteFilesWithPrefix got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFilesWithPrefix.DeleteFilesWithPrefixMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

			if mm_want_ptrs.s2 != nil && !minimock.Equal(*mm_want_ptrs.s2, mm_got.s2) {
				mmDeleteFilesWithPrefix.t.Errorf("ServiceMock.DeleteFilesWithPrefix got unexpected parameter s2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFilesWithPrefix.DeleteFilesWithPrefixMock.defaultExpectation.expectationOrigins.originS2, *mm_want_ptrs.s2, mm_got.s2, minimock.Diff(*mm_want_ptrs.s2, mm_got.s2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteFilesWithPrefix.t.Errorf("ServiceMock.DeleteFilesWithPrefix got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteFilesWithPrefix.DeleteFilesWithPrefixMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteFilesWithPrefix.DeleteFilesWithPrefixMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteFilesWithPrefix.t.Fatal("No results are set for the ServiceMock.DeleteFilesWithPrefix")
		}
		return (*mm_results).err
	}
	if mmDeleteFilesWithPrefix.funcDeleteFilesWithPrefix != nil {
		return mmDeleteFilesWithPrefix.funcDeleteFilesWithPrefix(ctx, s1, s2)
	}
	mmDeleteFilesWithPrefix.t.Fatalf("Unexpected call to ServiceMock.DeleteFilesWithPrefix. %v %v %v", ctx, s1, s2)
	return
}

// DeleteFilesWithPrefixAfterCounter returns a count of finished ServiceMock.DeleteFilesWithPrefix invocations
func (mmDeleteFilesWithPrefix *ServiceMock) DeleteFilesWithPrefixAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFilesWithPrefix.afterDeleteFilesWithPrefixCounter)
}

// DeleteFilesWithPrefixBeforeCounter returns a count of ServiceMock.DeleteFilesWithPrefix invocations
func (mmDeleteFilesWithPrefix *ServiceMock) DeleteFilesWithPrefixBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFilesWithPrefix.beforeDeleteFilesWithPrefixCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.DeleteFilesWithPrefix.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteFilesWithPrefix *mServiceMockDeleteFilesWithPrefix) Calls() []*ServiceMockDeleteFilesWithPrefixParams {
	mmDeleteFilesWithPrefix.mutex.RLock()

	argCopy := make([]*ServiceMockDeleteFilesWithPrefixParams, len(mmDeleteFilesWithPrefix.callArgs))
	copy(argCopy, mmDeleteFilesWithPrefix.callArgs)

	mmDeleteFilesWithPrefix.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteFilesWithPrefixDone returns true if the count of the DeleteFilesWithPrefix invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockDeleteFilesWithPrefixDone() bool {
	if m.DeleteFilesWithPrefixMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteFilesWithPrefixMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteFilesWithPrefixMock.invocationsDone()
}

// MinimockDeleteFilesWithPrefixInspect logs each unmet expectation
func (m *ServiceMock) MinimockDeleteFilesWithPrefixInspect() {
	for _, e := range m.DeleteFilesWithPrefixMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.DeleteFilesWithPrefix at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteFilesWithPrefixCounter := mm_atomic.LoadUint64(&m.afterDeleteFilesWithPrefixCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFilesWithPrefixMock.defaultExpectation != nil && afterDeleteFilesWithPrefixCounter < 1 {
		if m.DeleteFilesWithPrefixMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.DeleteFilesWithPrefix at\n%s", m.DeleteFilesWithPrefixMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.DeleteFilesWithPrefix at\n%s with params: %#v", m.DeleteFilesWithPrefixMock.defaultExpectation.expectationOrigins.origin, *m.DeleteFilesWithPrefixMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFilesWithPrefix != nil && afterDeleteFilesWithPrefixCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.DeleteFilesWithPrefix at\n%s", m.funcDeleteFilesWithPrefixOrigin)
	}

	if !m.DeleteFilesWithPrefixMock.invocationsDone() && afterDeleteFilesWithPrefixCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.DeleteFilesWithPrefix at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteFilesWithPrefixMock.expectedInvocations), m.DeleteFilesWithPrefixMock.expectedInvocationsOrigin, afterDeleteFilesWithPrefixCounter)
	}
}

type mServiceMockDeleteFilesWorkflow struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockDeleteFilesWorkflowExpectation
	expectations       []*ServiceMockDeleteFilesWorkflowExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockDeleteFilesWorkflowExpectation specifies expectation struct of the Service.DeleteFilesWorkflow
type ServiceMockDeleteFilesWorkflowExpectation struct {
	mock *ServiceMock

	results      *ServiceMockDeleteFilesWorkflowResults
	returnOrigin string
	Counter      uint64
}

// ServiceMockDeleteFilesWorkflowResults contains results of the Service.DeleteFilesWorkflow
type ServiceMockDeleteFilesWorkflowResults struct {
	d1 mm_service.DeleteFilesWorkflow
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteFilesWorkflow *mServiceMockDeleteFilesWorkflow) Optional() *mServiceMockDeleteFilesWorkflow {
	mmDeleteFilesWorkflow.optional = true
	return mmDeleteFilesWorkflow
}

// Expect sets up expected params for Service.DeleteFilesWorkflow
func (mmDeleteFilesWorkflow *mServiceMockDeleteFilesWorkflow) Expect() *mServiceMockDeleteFilesWorkflow {
	if mmDeleteFilesWorkflow.mock.funcDeleteFilesWorkflow != nil {
		mmDeleteFilesWorkflow.mock.t.Fatalf("ServiceMock.DeleteFilesWorkflow mock is already set by Set")
	}

	if mmDeleteFilesWorkflow.defaultExpectation == nil {
		mmDeleteFilesWorkflow.defaultExpectation = &ServiceMockDeleteFilesWorkflowExpectation{}
	}

	return mmDeleteFilesWorkflow
}

// Inspect accepts an inspector function that has same arguments as the Service.DeleteFilesWorkflow
func (mmDeleteFilesWorkflow *mServiceMockDeleteFilesWorkflow) Inspect(f func()) *mServiceMockDeleteFilesWorkflow {
	if mmDeleteFilesWorkflow.mock.inspectFuncDeleteFilesWorkflow != nil {
		mmDeleteFilesWorkflow.mock.t.Fatalf("Inspect function is already set for ServiceMock.DeleteFilesWorkflow")
	}

	mmDeleteFilesWorkflow.mock.inspectFuncDeleteFilesWorkflow = f

	return mmDeleteFilesWorkflow
}

// Return sets up results that will be returned by Service.DeleteFilesWorkflow
func (mmDeleteFilesWorkflow *mServiceMockDeleteFilesWorkflow) Return(d1 mm_service.DeleteFilesWorkflow) *ServiceMock {
	if mmDeleteFilesWorkflow.mock.funcDeleteFilesWorkflow != nil {
		mmDeleteFilesWorkflow.mock.t.Fatalf("ServiceMock.DeleteFilesWorkflow mock is already set by Set")
	}

	if mmDeleteFilesWorkflow.defaultExpectation == nil {
		mmDeleteFilesWorkflow.defaultExpectation = &ServiceMockDeleteFilesWorkflowExpectation{mock: mmDeleteFilesWorkflow.mock}
	}
	mmDeleteFilesWorkflow.defaultExpectation.results = &ServiceMockDeleteFilesWorkflowResults{d1}
	mmDeleteFilesWorkflow.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteFilesWorkflow.mock
}

// Set uses given function f to mock the Service.DeleteFilesWorkflow method
func (mmDeleteFilesWorkflow *mServiceMockDeleteFilesWorkflow) Set(f func() (d1 mm_service.DeleteFilesWorkflow)) *ServiceMock {
	if mmDeleteFilesWorkflow.defaultExpectation != nil {
		mmDeleteFilesWorkflow.mock.t.Fatalf("Default expectation is already set for the Service.DeleteFilesWorkflow method")
	}

	if len(mmDeleteFilesWorkflow.expectations) > 0 {
		mmDeleteFilesWorkflow.mock.t.Fatalf("Some expectations are already set for the Service.DeleteFilesWorkflow method")
	}

	mmDeleteFilesWorkflow.mock.funcDeleteFilesWorkflow = f
	mmDeleteFilesWorkflow.mock.funcDeleteFilesWorkflowOrigin = minimock.CallerInfo(1)
	return mmDeleteFilesWorkflow.mock
}

// Times sets number of times Service.DeleteFilesWorkflow should be invoked
func (mmDeleteFilesWorkflow *mServiceMockDeleteFilesWorkflow) Times(n uint64) *mServiceMockDeleteFilesWorkflow {
	if n == 0 {
		mmDeleteFilesWorkflow.mock.t.Fatalf("Times of ServiceMock.DeleteFilesWorkflow mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteFilesWorkflow.expectedInvocations, n)
	mmDeleteFilesWorkflow.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteFilesWorkflow
}

func (mmDeleteFilesWorkflow *mServiceMockDeleteFilesWorkflow) invocationsDone() bool {
	if len(mmDeleteFilesWorkflow.expectations) == 0 && mmDeleteFilesWorkflow.defaultExpectation == nil && mmDeleteFilesWorkflow.mock.funcDeleteFilesWorkflow == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteFilesWorkflow.mock.afterDeleteFilesWorkflowCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteFilesWorkflow.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteFilesWorkflow implements mm_service.Service
func (mmDeleteFilesWorkflow *ServiceMock) DeleteFilesWorkflow() (d1 mm_service.DeleteFilesWorkflow) {
	mm_atomic.AddUint64(&mmDeleteFilesWorkflow.beforeDeleteFilesWorkflowCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteFilesWorkflow.afterDeleteFilesWorkflowCounter, 1)

	mmDeleteFilesWorkflow.t.Helper()

	if mmDeleteFilesWorkflow.inspectFuncDeleteFilesWorkflow != nil {
		mmDeleteFilesWorkflow.inspectFuncDeleteFilesWorkflow()
	}

	if mmDeleteFilesWorkflow.DeleteFilesWorkflowMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteFilesWorkflow.DeleteFilesWorkflowMock.defaultExpectation.Counter, 1)

		mm_results := mmDeleteFilesWorkflow.DeleteFilesWorkflowMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteFilesWorkflow.t.Fatal("No results are set for the ServiceMock.DeleteFilesWorkflow")
		}
		return (*mm_results).d1
	}
	if mmDeleteFilesWorkflow.funcDeleteFilesWorkflow != nil {
		return mmDeleteFilesWorkflow.funcDeleteFilesWorkflow()
	}
	mmDeleteFilesWorkflow.t.Fatalf("Unexpected call to ServiceMock.DeleteFilesWorkflow.")
	return
}

// DeleteFilesWorkflowAfterCounter returns a count of finished ServiceMock.DeleteFilesWorkflow invocations
func (mmDeleteFilesWorkflow *ServiceMock) DeleteFilesWorkflowAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFilesWorkflow.afterDeleteFilesWorkflowCounter)
}

// DeleteFilesWorkflowBeforeCounter returns a count of ServiceMock.DeleteFilesWorkflow invocations
func (mmDeleteFilesWorkflow *ServiceMock) DeleteFilesWorkflowBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFilesWorkflow.beforeDeleteFilesWorkflowCounter)
}

// MinimockDeleteFilesWorkflowDone returns true if the count of the DeleteFilesWorkflow invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockDeleteFilesWorkflowDone() bool {
	if m.DeleteFilesWorkflowMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteFilesWorkflowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteFilesWorkflowMock.invocationsDone()
}

// MinimockDeleteFilesWorkflowInspect logs each unmet expectation
func (m *ServiceMock) MinimockDeleteFilesWorkflowInspect() {
	for _, e := range m.DeleteFilesWorkflowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServiceMock.DeleteFilesWorkflow")
		}
	}

	afterDeleteFilesWorkflowCounter := mm_atomic.LoadUint64(&m.afterDeleteFilesWorkflowCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFilesWorkflowMock.defaultExpectation != nil && afterDeleteFilesWorkflowCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.DeleteFilesWorkflow at\n%s", m.DeleteFilesWorkflowMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFilesWorkflow != nil && afterDeleteFilesWorkflowCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.DeleteFilesWorkflow at\n%s", m.funcDeleteFilesWorkflowOrigin)
	}

	if !m.DeleteFilesWorkflowMock.invocationsDone() && afterDeleteFilesWorkflowCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.DeleteFilesWorkflow at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteFilesWorkflowMock.expectedInvocations), m.DeleteFilesWorkflowMock.expectedInvocationsOrigin, afterDeleteFilesWorkflowCounter)
	}
}

type mServiceMockDeleteKnowledgeBase struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockDeleteKnowledgeBaseExpectation
	expectations       []*ServiceMockDeleteKnowledgeBaseExpectation

	callArgs []*ServiceMockDeleteKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockDeleteKnowledgeBaseExpectation specifies expectation struct of the Service.DeleteKnowledgeBase
type ServiceMockDeleteKnowledgeBaseExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockDeleteKnowledgeBaseParams
	paramPtrs          *ServiceMockDeleteKnowledgeBaseParamPtrs
	expectationOrigins ServiceMockDeleteKnowledgeBaseExpectationOrigins
	results            *ServiceMockDeleteKnowledgeBaseResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockDeleteKnowledgeBaseParams contains parameters of the Service.DeleteKnowledgeBase
type ServiceMockDeleteKnowledgeBaseParams struct {
	ctx context.Context
	s1  string
}

// ServiceMockDeleteKnowledgeBaseParamPtrs contains pointers to parameters of the Service.DeleteKnowledgeBase
type ServiceMockDeleteKnowledgeBaseParamPtrs struct {
	ctx *context.Context
	s1  *string
}

// ServiceMockDeleteKnowledgeBaseResults contains results of the Service.DeleteKnowledgeBase
type ServiceMockDeleteKnowledgeBaseResults struct {
	err error
}

// ServiceMockDeleteKnowledgeBaseOrigins contains origins of expectations of the Service.DeleteKnowledgeBase
type ServiceMockDeleteKnowledgeBaseExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteKnowledgeBase *mServiceMockDeleteKnowledgeBase) Optional() *mServiceMockDeleteKnowledgeBase {
	mmDeleteKnowledgeBase.optional = true
	return mmDeleteKnowledgeBase
}

// Expect sets up expected params for Service.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mServiceMockDeleteKnowledgeBase) Expect(ctx context.Context, s1 string) *mServiceMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("ServiceMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &ServiceMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("ServiceMock.DeleteKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmDeleteKnowledgeBase.defaultExpectation.params = &ServiceMockDeleteKnowledgeBaseParams{ctx, s1}
	mmDeleteKnowledgeBase.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmDeleteKnowledgeBase.defaultExpectation.params) {
			mmDeleteKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmDeleteKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for Service.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mServiceMockDeleteKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mServiceMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("ServiceMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &ServiceMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.params != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("ServiceMock.DeleteKnowledgeBase mock is already set by Expect")
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBase.defaultExpectation.paramPtrs = &ServiceMockDeleteKnowledgeBaseParamPtrs{}
	}
	mmDeleteKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteKnowledgeBase.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteKnowledgeBase
}

// ExpectS1Param2 sets up expected param s1 for Service.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mServiceMockDeleteKnowledgeBase) ExpectS1Param2(s1 string) *mServiceMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("ServiceMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &ServiceMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.params != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("ServiceMock.DeleteKnowledgeBase mock is already set by Expect")
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBase.defaultExpectation.paramPtrs = &ServiceMockDeleteKnowledgeBaseParamPtrs{}
	}
	mmDeleteKnowledgeBase.defaultExpectation.paramPtrs.s1 = &s1
	mmDeleteKnowledgeBase.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmDeleteKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the Service.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mServiceMockDeleteKnowledgeBase) Inspect(f func(ctx context.Context, s1 string)) *mServiceMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.inspectFuncDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Inspect function is already set for ServiceMock.DeleteKnowledgeBase")
	}

	mmDeleteKnowledgeBase.mock.inspectFuncDeleteKnowledgeBase = f

	return mmDeleteKnowledgeBase
}

// Return sets up results that will be returned by Service.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mServiceMockDeleteKnowledgeBase) Return(err error) *ServiceMock {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("ServiceMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &ServiceMockDeleteKnowledgeBaseExpectation{mock: mmDeleteKnowledgeBase.mock}
	}
	mmDeleteKnowledgeBase.defaultExpectation.results = &ServiceMockDeleteKnowledgeBaseResults{err}
	mmDeleteKnowledgeBase.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBase.mock
}

// Set uses given function f to mock the Service.DeleteKnowledgeBase method
func (mmDeleteKnowledgeBase *mServiceMockDeleteKnowledgeBase) Set(f func(ctx context.Context, s1 string) (err error)) *ServiceMock {
	if mmDeleteKnowledgeBase.defaultExpectation != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the Service.DeleteKnowledgeBase method")
	}

	if len(mmDeleteKnowledgeBase.expectations) > 0 {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the Service.DeleteKnowledgeBase method")
	}

	mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase = f
	mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBaseOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBase.mock
}

// When sets expectation for the Service.DeleteKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmDeleteKnowledgeBase *mServiceMockDeleteKnowledgeBase) When(ctx context.Context, s1 string) *ServiceMockDeleteKnowledgeBaseExpectation {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("ServiceMock.DeleteKnowledgeBase mock is already set by Set")
	}

	expectation := &ServiceMockDeleteKnowledgeBaseExpectation{
		mock:               mmDeleteKnowledgeBase.mock,
		params:             &ServiceMockDeleteKnowledgeBaseParams{ctx, s1},
		expectationOrigins: ServiceMockDeleteKnowledgeBaseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteKnowledgeBase.expectations = append(mmDeleteKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up Service.DeleteKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *ServiceMockDeleteKnowledgeBaseExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockDeleteKnowledgeBaseResults{err}
	return e.mock
}

// Times sets number of times Service.DeleteKnowledgeBase should be invoked
func (mmDeleteKnowledgeBase *mServiceMockDeleteKnowledgeBase) Times(n uint64) *mServiceMockDeleteKnowledgeBase {
	if n == 0 {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Times of ServiceMock.DeleteKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteKnowledgeBase.expectedInvocations, n)
	mmDeleteKnowledgeBase.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBase
}

func (mmDeleteKnowledgeBase *mServiceMockDeleteKnowledgeBase) invocationsDone() bool {
	if len(mmDeleteKnowledgeBase.expectations) == 0 && mmDeleteKnowledgeBase.defaultExpectation == nil && mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.mock.afterDeleteKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteKnowledgeBase implements mm_service.Service
func (mmDeleteKnowledgeBase *ServiceMock) DeleteKnowledgeBase(ctx context.Context, s1 string) (err error) {
	mm_atomic.AddUint64(&mmDeleteKnowledgeBase.beforeDeleteKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteKnowledgeBase.afterDeleteKnowledgeBaseCounter, 1)

	mmDeleteKnowledgeBase.t.Helper()

	if mmDeleteKnowledgeBase.inspectFuncDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.inspectFuncDeleteKnowledgeBase(ctx, s1)
	}

	mm_params := ServiceMockDeleteKnowledgeBaseParams{ctx, s1}

	// Record call args
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.mutex.Lock()
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.callArgs = append(mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.callArgs, &mm_params)
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockDeleteKnowledgeBaseParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteKnowledgeBase.t.Errorf("ServiceMock.DeleteKnowledgeBase got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmDeleteKnowledgeBase.t.Errorf("ServiceMock.DeleteKnowledgeBase got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteKnowledgeBase.t.Errorf("ServiceMock.DeleteKnowledgeBase got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteKnowledgeBase.t.Fatal("No results are set for the ServiceMock.DeleteKnowledgeBase")
		}
		return (*mm_results).err
	}
	if mmDeleteKnowledgeBase.funcDeleteKnowledgeBase != nil {
		return mmDeleteKnowledgeBase.funcDeleteKnowledgeBase(ctx, s1)
	}
	mmDeleteKnowledgeBase.t.Fatalf("Unexpected call to ServiceMock.DeleteKnowledgeBase. %v %v", ctx, s1)
	return
}

// DeleteKnowledgeBaseAfterCounter returns a count of finished ServiceMock.DeleteKnowledgeBase invocations
func (mmDeleteKnowledgeBase *ServiceMock) DeleteKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.afterDeleteKnowledgeBaseCounter)
}

// DeleteKnowledgeBaseBeforeCounter returns a count of ServiceMock.DeleteKnowledgeBase invocations
func (mmDeleteKnowledgeBase *ServiceMock) DeleteKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.beforeDeleteKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.DeleteKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteKnowledgeBase *mServiceMockDeleteKnowledgeBase) Calls() []*ServiceMockDeleteKnowledgeBaseParams {
	mmDeleteKnowledgeBase.mutex.RLock()

	argCopy := make([]*ServiceMockDeleteKnowledgeBaseParams, len(mmDeleteKnowledgeBase.callArgs))
	copy(argCopy, mmDeleteKnowledgeBase.callArgs)

	mmDeleteKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteKnowledgeBaseDone returns true if the count of the DeleteKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockDeleteKnowledgeBaseDone() bool {
	if m.DeleteKnowledgeBaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteKnowledgeBaseMock.invocationsDone()
}

// MinimockDeleteKnowledgeBaseInspect logs each unmet expectation
func (m *ServiceMock) MinimockDeleteKnowledgeBaseInspect() {
	for _, e := range m.DeleteKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.DeleteKnowledgeBase at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterDeleteKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteKnowledgeBaseMock.defaultExpectation != nil && afterDeleteKnowledgeBaseCounter < 1 {
		if m.DeleteKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.DeleteKnowledgeBase at\n%s", m.DeleteKnowledgeBaseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.DeleteKnowledgeBase at\n%s with params: %#v", m.DeleteKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *m.DeleteKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteKnowledgeBase != nil && afterDeleteKnowledgeBaseCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.DeleteKnowledgeBase at\n%s", m.funcDeleteKnowledgeBaseOrigin)
	}

	if !m.DeleteKnowledgeBaseMock.invocationsDone() && afterDeleteKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.DeleteKnowledgeBase at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteKnowledgeBaseMock.expectedInvocations), m.DeleteKnowledgeBaseMock.expectedInvocationsOrigin, afterDeleteKnowledgeBaseCounter)
	}
}

type mServiceMockDeleteRepositoryTag struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockDeleteRepositoryTagExpectation
	expectations       []*ServiceMockDeleteRepositoryTagExpectation

	callArgs []*ServiceMockDeleteRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockDeleteRepositoryTagExpectation specifies expectation struct of the Service.DeleteRepositoryTag
type ServiceMockDeleteRepositoryTagExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockDeleteRepositoryTagParams
	paramPtrs          *ServiceMockDeleteRepositoryTagParamPtrs
	expectationOrigins ServiceMockDeleteRepositoryTagExpectationOrigins
	results            *ServiceMockDeleteRepositoryTagResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockDeleteRepositoryTagParams contains parameters of the Service.DeleteRepositoryTag
type ServiceMockDeleteRepositoryTagParams struct {
	ctx context.Context
	dp1 *artifactpb.DeleteRepositoryTagRequest
}

// ServiceMockDeleteRepositoryTagParamPtrs contains pointers to parameters of the Service.DeleteRepositoryTag
type ServiceMockDeleteRepositoryTagParamPtrs struct {
	ctx *context.Context
	dp1 **artifactpb.DeleteRepositoryTagRequest
}

// ServiceMockDeleteRepositoryTagResults contains results of the Service.DeleteRepositoryTag
type ServiceMockDeleteRepositoryTagResults struct {
	dp2 *artifactpb.DeleteRepositoryTagResponse
	err error
}

// ServiceMockDeleteRepositoryTagOrigins contains origins of expectations of the Service.DeleteRepositoryTag
type ServiceMockDeleteRepositoryTagExpectationOrigins struct {
	origin    string
	originCtx string
	originDp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) Optional() *mServiceMockDeleteRepositoryTag {
	mmDeleteRepositoryTag.optional = true
	return mmDeleteRepositoryTag
}

// Expect sets up expected params for Service.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) Expect(ctx context.Context, dp1 *artifactpb.DeleteRepositoryTagRequest) *mServiceMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("ServiceMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &ServiceMockDeleteRepositoryTagExpectation{}
	}

	if mmDeleteRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("ServiceMock.DeleteRepositoryTag mock is already set by ExpectParams functions")
	}

	mmDeleteRepositoryTag.defaultExpectation.params = &ServiceMockDeleteRepositoryTagParams{ctx, dp1}
	mmDeleteRepositoryTag.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteRepositoryTag.expectations {
		if minimock.Equal(e.params, mmDeleteRepositoryTag.defaultExpectation.params) {
			mmDeleteRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteRepositoryTag.defaultExpectation.params)
		}
	}

	return mmDeleteRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for Service.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) ExpectCtxParam1(ctx context.Context) *mServiceMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("ServiceMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &ServiceMockDeleteRepositoryTagExpectation{}
	}

	if mmDeleteRepositoryTag.defaultExpectation.params != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("ServiceMock.DeleteRepositoryTag mock is already set by Expect")
	}

	if mmDeleteRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmDeleteRepositoryTag.defaultExpectation.paramPtrs = &ServiceMockDeleteRepositoryTagParamPtrs{}
	}
	mmDeleteRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteRepositoryTag.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteRepositoryTag
}

// ExpectDp1Param2 sets up expected param dp1 for Service.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) ExpectDp1Param2(dp1 *artifactpb.DeleteRepositoryTagRequest) *mServiceMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("ServiceMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &ServiceMockDeleteRepositoryTagExpectation{}
	}

	if mmDeleteRepositoryTag.defaultExpectation.params != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("ServiceMock.DeleteRepositoryTag mock is already set by Expect")
	}

	if mmDeleteRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmDeleteRepositoryTag.defaultExpectation.paramPtrs = &ServiceMockDeleteRepositoryTagParamPtrs{}
	}
	mmDeleteRepositoryTag.defaultExpectation.paramPtrs.dp1 = &dp1
	mmDeleteRepositoryTag.defaultExpectation.expectationOrigins.originDp1 = minimock.CallerInfo(1)

	return mmDeleteRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the Service.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) Inspect(f func(ctx context.Context, dp1 *artifactpb.DeleteRepositoryTagRequest)) *mServiceMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.inspectFuncDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("Inspect function is already set for ServiceMock.DeleteRepositoryTag")
	}

	mmDeleteRepositoryTag.mock.inspectFuncDeleteRepositoryTag = f

	return mmDeleteRepositoryTag
}

// Return sets up results that will be returned by Service.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) Return(dp2 *artifactpb.DeleteRepositoryTagResponse, err error) *ServiceMock {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("ServiceMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &ServiceMockDeleteRepositoryTagExpectation{mock: mmDeleteRepositoryTag.mock}
	}
	mmDeleteRepositoryTag.defaultExpectation.results = &ServiceMockDeleteRepositoryTagResults{dp2, err}
	mmDeleteRepositoryTag.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteRepositoryTag.mock
}

// Set uses given function f to mock the Service.DeleteRepositoryTag method
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) Set(f func(ctx context.Context, dp1 *artifactpb.DeleteRepositoryTagRequest) (dp2 *artifactpb.DeleteRepositoryTagResponse, err error)) *ServiceMock {
	if mmDeleteRepositoryTag.defaultExpectation != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("Default expectation is already set for the Service.DeleteRepositoryTag method")
	}

	if len(mmDeleteRepositoryTag.expectations) > 0 {
		mmDeleteRepositoryTag.mock.t.Fatalf("Some expectations are already set for the Service.DeleteRepositoryTag method")
	}

	mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag = f
	mmDeleteRepositoryTag.mock.funcDeleteRepositoryTagOrigin = minimock.CallerInfo(1)
	return mmDeleteRepositoryTag.mock
}

// When sets expectation for the Service.DeleteRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) When(ctx context.Context, dp1 *artifactpb.DeleteRepositoryTagRequest) *ServiceMockDeleteRepositoryTagExpectation {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("ServiceMock.DeleteRepositoryTag mock is already set by Set")
	}

	expectation := &ServiceMockDeleteRepositoryTagExpectation{
		mock:               mmDeleteRepositoryTag.mock,
		params:             &ServiceMockDeleteRepositoryTagParams{ctx, dp1},
		expectationOrigins: ServiceMockDeleteRepositoryTagExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteRepositoryTag.expectations = append(mmDeleteRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up Service.DeleteRepositoryTag return parameters for the expectation previously defined by the When method
func (e *ServiceMockDeleteRepositoryTagExpectation) Then(dp2 *artifactpb.DeleteRepositoryTagResponse, err error) *ServiceMock {
	e.results = &ServiceMockDeleteRepositoryTagResults{dp2, err}
	return e.mock
}

// Times sets number of times Service.DeleteRepositoryTag should be invoked
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) Times(n uint64) *mServiceMockDeleteRepositoryTag {
	if n == 0 {
		mmDeleteRepositoryTag.mock.t.Fatalf("Times of ServiceMock.DeleteRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteRepositoryTag.expectedInvocations, n)
	mmDeleteRepositoryTag.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteRepositoryTag
}

func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) invocationsDone() bool {
	if len(mmDeleteRepositoryTag.expectations) == 0 && mmDeleteRepositoryTag.defaultExpectation == nil && mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteRepositoryTag.mock.afterDeleteRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteRepositoryTag implements mm_service.Service
func (mmDeleteRepositoryTag *ServiceMock) DeleteRepositoryTag(ctx context.Context, dp1 *artifactpb.DeleteRepositoryTagRequest) (dp2 *artifactpb.DeleteRepositoryTagResponse, err error) {
	mm_atomic.AddUint64(&mmDeleteRepositoryTag.beforeDeleteRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteRepositoryTag.afterDeleteRepositoryTagCounter, 1)

	mmDeleteRepositoryTag.t.Helper()

	if mmDeleteRepositoryTag.inspectFuncDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.inspectFuncDeleteRepositoryTag(ctx, dp1)
	}

	mm_params := ServiceMockDeleteRepositoryTagParams{ctx, dp1}

	// Record call args
	mmDeleteRepositoryTag.DeleteRepositoryTagMock.mutex.Lock()
	mmDeleteRepositoryTag.DeleteRepositoryTagMock.callArgs = append(mmDeleteRepositoryTag.DeleteRepositoryTagMock.callArgs, &mm_params)
	mmDeleteRepositoryTag.DeleteRepositoryTagMock.mutex.Unlock()

	for _, e := range mmDeleteRepositoryTag.DeleteRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp2, e.results.err
		}
	}

	if mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockDeleteRepositoryTagParams{ctx, dp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteRepositoryTag.t.Errorf("ServiceMock.DeleteRepositoryTag got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dp1 != nil && !minimock.Equal(*mm_want_ptrs.dp1, mm_got.dp1) {
				mmDeleteRepositoryTag.t.Errorf("ServiceMock.DeleteRepositoryTag got unexpected parameter dp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.expectationOrigins.originDp1, *mm_want_ptrs.dp1, mm_got.dp1, minimock.Diff(*mm_want_ptrs.dp1, mm_got.dp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteRepositoryTag.t.Errorf("ServiceMock.DeleteRepositoryTag got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteRepositoryTag.t.Fatal("No results are set for the ServiceMock.DeleteRepositoryTag")
		}
		return (*mm_results).dp2, (*mm_results).err
	}
	if mmDeleteRepositoryTag.funcDeleteRepositoryTag != nil {
		return mmDeleteRepositoryTag.funcDeleteRepositoryTag(ctx, dp1)
	}
	mmDeleteRepositoryTag.t.Fatalf("Unexpected call to ServiceMock.DeleteRepositoryTag. %v %v", ctx, dp1)
	return
}

// DeleteRepositoryTagAfterCounter returns a count of finished ServiceMock.DeleteRepositoryTag invocations
func (mmDeleteRepositoryTag *ServiceMock) DeleteRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRepositoryTag.afterDeleteRepositoryTagCounter)
}

// DeleteRepositoryTagBeforeCounter returns a count of ServiceMock.DeleteRepositoryTag invocations
func (mmDeleteRepositoryTag *ServiceMock) DeleteRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRepositoryTag.beforeDeleteRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.DeleteRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) Calls() []*ServiceMockDeleteRepositoryTagParams {
	mmDeleteRepositoryTag.mutex.RLock()

	argCopy := make([]*ServiceMockDeleteRepositoryTagParams, len(mmDeleteRepositoryTag.callArgs))
	copy(argCopy, mmDeleteRepositoryTag.callArgs)

	mmDeleteRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteRepositoryTagDone returns true if the count of the DeleteRepositoryTag invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockDeleteRepositoryTagDone() bool {
	if m.DeleteRepositoryTagMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteRepositoryTagMock.invocationsDone()
}

// MinimockDeleteRepositoryTagInspect logs each unmet expectation
func (m *ServiceMock) MinimockDeleteRepositoryTagInspect() {
	for _, e := range m.DeleteRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.DeleteRepositoryTag at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterDeleteRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteRepositoryTagMock.defaultExpectation != nil && afterDeleteRepositoryTagCounter < 1 {
		if m.DeleteRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.DeleteRepositoryTag at\n%s", m.DeleteRepositoryTagMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.DeleteRepositoryTag at\n%s with params: %#v", m.DeleteRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *m.DeleteRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteRepositoryTag != nil && afterDeleteRepositoryTagCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.DeleteRepositoryTag at\n%s", m.funcDeleteRepositoryTagOrigin)
	}

	if !m.DeleteRepositoryTagMock.invocationsDone() && afterDeleteRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.DeleteRepositoryTag at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteRepositoryTagMock.expectedInvocations), m.DeleteRepositoryTagMock.expectedInvocationsOrigin, afterDeleteRepositoryTagCounter)
	}
}

type mServiceMockDeleteTextChunksByFileUID struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockDeleteTextChunksByFileUIDExpectation
	expectations       []*ServiceMockDeleteTextChunksByFileUIDExpectation

	callArgs []*ServiceMockDeleteTextChunksByFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockDeleteTextChunksByFileUIDExpectation specifies expectation struct of the Service.DeleteTextChunksByFileUID
type ServiceMockDeleteTextChunksByFileUIDExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockDeleteTextChunksByFileUIDParams
	paramPtrs          *ServiceMockDeleteTextChunksByFileUIDParamPtrs
	expectationOrigins ServiceMockDeleteTextChunksByFileUIDExpectationOrigins
	results            *ServiceMockDeleteTextChunksByFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockDeleteTextChunksByFileUIDParams contains parameters of the Service.DeleteTextChunksByFileUID
type ServiceMockDeleteTextChunksByFileUIDParams struct {
	ctx context.Context
	u1  uuid.UUID
	u2  uuid.UUID
}

// ServiceMockDeleteTextChunksByFileUIDParamPtrs contains pointers to parameters of the Service.DeleteTextChunksByFileUID
type ServiceMockDeleteTextChunksByFileUIDParamPtrs struct {
	ctx *context.Context
	u1  *uuid.UUID
	u2  *uuid.UUID
}

// ServiceMockDeleteTextChunksByFileUIDResults contains results of the Service.DeleteTextChunksByFileUID
type ServiceMockDeleteTextChunksByFileUIDResults struct {
	err error
}

// ServiceMockDeleteTextChunksByFileUIDOrigins contains origins of expectations of the Service.DeleteTextChunksByFileUID
type ServiceMockDeleteTextChunksByFileUIDExpectationOrigins struct {
	origin    string
	originCtx string
	originU1  string
	originU2  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteTextChunksByFileUID *mServiceMockDeleteTextChunksByFileUID) Optional() *mServiceMockDeleteTextChunksByFileUID {
	mmDeleteTextChunksByFileUID.optional = true
	return mmDeleteTextChunksByFileUID
}

// Expect sets up expected params for Service.DeleteTextChunksByFileUID
func (mmDeleteTextChunksByFileUID *mServiceMockDeleteTextChunksByFileUID) Expect(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) *mServiceMockDeleteTextChunksByFileUID {
	if mmDeleteTextChunksByFileUID.mock.funcDeleteTextChunksByFileUID != nil {
		mmDeleteTextChunksByFileUID.mock.t.Fatalf("ServiceMock.DeleteTextChunksByFileUID mock is already set by Set")
	}

	if mmDeleteTextChunksByFileUID.defaultExpectation == nil {
		mmDeleteTextChunksByFileUID.defaultExpectation = &ServiceMockDeleteTextChunksByFileUIDExpectation{}
	}

	if mmDeleteTextChunksByFileUID.defaultExpectation.paramPtrs != nil {
		mmDeleteTextChunksByFileUID.mock.t.Fatalf("ServiceMock.DeleteTextChunksByFileUID mock is already set by ExpectParams functions")
	}

	mmDeleteTextChunksByFileUID.defaultExpectation.params = &ServiceMockDeleteTextChunksByFileUIDParams{ctx, u1, u2}
	mmDeleteTextChunksByFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteTextChunksByFileUID.expectations {
		if minimock.Equal(e.params, mmDeleteTextChunksByFileUID.defaultExpectation.params) {
			mmDeleteTextChunksByFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteTextChunksByFileUID.defaultExpectation.params)
		}
	}

	return mmDeleteTextChunksByFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Service.DeleteTextChunksByFileUID
func (mmDeleteTextChunksByFileUID *mServiceMockDeleteTextChunksByFileUID) ExpectCtxParam1(ctx context.Context) *mServiceMockDeleteTextChunksByFileUID {
	if mmDeleteTextChunksByFileUID.mock.funcDeleteTextChunksByFileUID != nil {
		mmDeleteTextChunksByFileUID.mock.t.Fatalf("ServiceMock.DeleteTextChunksByFileUID mock is already set by Set")
	}

	if mmDeleteTextChunksByFileUID.defaultExpectation == nil {
		mmDeleteTextChunksByFileUID.defaultExpectation = &ServiceMockDeleteTextChunksByFileUIDExpectation{}
	}

	if mmDeleteTextChunksByFileUID.defaultExpectation.params != nil {
		mmDeleteTextChunksByFileUID.mock.t.Fatalf("ServiceMock.DeleteTextChunksByFileUID mock is already set by Expect")
	}

	if mmDeleteTextChunksByFileUID.defaultExpectation.paramPtrs == nil {
		mmDeleteTextChunksByFileUID.defaultExpectation.paramPtrs = &ServiceMockDeleteTextChunksByFileUIDParamPtrs{}
	}
	mmDeleteTextChunksByFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteTextChunksByFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteTextChunksByFileUID
}

// ExpectU1Param2 sets up expected param u1 for Service.DeleteTextChunksByFileUID
func (mmDeleteTextChunksByFileUID *mServiceMockDeleteTextChunksByFileUID) ExpectU1Param2(u1 uuid.UUID) *mServiceMockDeleteTextChunksByFileUID {
	if mmDeleteTextChunksByFileUID.mock.funcDeleteTextChunksByFileUID != nil {
		mmDeleteTextChunksByFileUID.mock.t.Fatalf("ServiceMock.DeleteTextChunksByFileUID mock is already set by Set")
	}

	if mmDeleteTextChunksByFileUID.defaultExpectation == nil {
		mmDeleteTextChunksByFileUID.defaultExpectation = &ServiceMockDeleteTextChunksByFileUIDExpectation{}
	}

	if mmDeleteTextChunksByFileUID.defaultExpectation.params != nil {
		mmDeleteTextChunksByFileUID.mock.t.Fatalf("ServiceMock.DeleteTextChunksByFileUID mock is already set by Expect")
	}

	if mmDeleteTextChunksByFileUID.defaultExpectation.paramPtrs == nil {
		mmDeleteTextChunksByFileUID.defaultExpectation.paramPtrs = &ServiceMockDeleteTextChunksByFileUIDParamPtrs{}
	}
	mmDeleteTextChunksByFileUID.defaultExpectation.paramPtrs.u1 = &u1
	mmDeleteTextChunksByFileUID.defaultExpectation.expectationOrigins.originU1 = minimock.CallerInfo(1)

	return mmDeleteTextChunksByFileUID
}

// ExpectU2Param3 sets up expected param u2 for Service.DeleteTextChunksByFileUID
func (mmDeleteTextChunksByFileUID *mServiceMockDeleteTextChunksByFileUID) ExpectU2Param3(u2 uuid.UUID) *mServiceMockDeleteTextChunksByFileUID {
	if mmDeleteTextChunksByFileUID.mock.funcDeleteTextChunksByFileUID != nil {
		mmDeleteTextChunksByFileUID.mock.t.Fatalf("ServiceMock.DeleteTextChunksByFileUID mock is already set by Set")
	}

	if mmDeleteTextChunksByFileUID.defaultExpectation == nil {
		mmDeleteTextChunksByFileUID.defaultExpectation = &ServiceMockDeleteTextChunksByFileUIDExpectation{}
	}

	if mmDeleteTextChunksByFileUID.defaultExpectation.params != nil {
		mmDeleteTextChunksByFileUID.mock.t.Fatalf("ServiceMock.DeleteTextChunksByFileUID mock is already set by Expect")
	}

	if mmDeleteTextChunksByFileUID.defaultExpectation.paramPtrs == nil {
		mmDeleteTextChunksByFileUID.defaultExpectation.paramPtrs = &ServiceMockDeleteTextChunksByFileUIDParamPtrs{}
	}
	mmDeleteTextChunksByFileUID.defaultExpectation.paramPtrs.u2 = &u2
	mmDeleteTextChunksByFileUID.defaultExpectation.expectationOrigins.originU2 = minimock.CallerInfo(1)

	return mmDeleteTextChunksByFileUID
}

// Inspect accepts an inspector function that has same arguments as the Service.DeleteTextChunksByFileUID
func (mmDeleteTextChunksByFileUID *mServiceMockDeleteTextChunksByFileUID) Inspect(f func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID)) *mServiceMockDeleteTextChunksByFileUID {
	if mmDeleteTextChunksByFileUID.mock.inspectFuncDeleteTextChunksByFileUID != nil {
		mmDeleteTextChunksByFileUID.mock.t.Fatalf("Inspect function is already set for ServiceMock.DeleteTextChunksByFileUID")
	}

	mmDeleteTextChunksByFileUID.mock.inspectFuncDeleteTextChunksByFileUID = f

	return mmDeleteTextChunksByFileUID
}

// Return sets up results that will be returned by Service.DeleteTextChunksByFileUID
func (mmDeleteTextChunksByFileUID *mServiceMockDeleteTextChunksByFileUID) Return(err error) *ServiceMock {
	if mmDeleteTextChunksByFileUID.mock.funcDeleteTextChunksByFileUID != nil {
		mmDeleteTextChunksByFileUID.mock.t.Fatalf("ServiceMock.DeleteTextChunksByFileUID mock is already set by Set")
	}

	if mmDeleteTextChunksByFileUID.defaultExpectation == nil {
		mmDeleteTextChunksByFileUID.defaultExpectation = &ServiceMockDeleteTextChunksByFileUIDExpectation{mock: mmDeleteTextChunksByFileUID.mock}
	}
	mmDeleteTextChunksByFileUID.defaultExpectation.results = &ServiceMockDeleteTextChunksByFileUIDResults{err}
	mmDeleteTextChunksByFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteTextChunksByFileUID.mock
}

// Set uses given function f to mock the Service.DeleteTextChunksByFileUID method
func (mmDeleteTextChunksByFileUID *mServiceMockDeleteTextChunksByFileUID) Set(f func(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) (err error)) *ServiceMock {
	if mmDeleteTextChunksByFileUID.defaultExpectation != nil {
		mmDeleteTextChunksByFileUID.mock.t.Fatalf("Default expectation is already set for the Service.DeleteTextChunksByFileUID method")
	}

	if len(mmDeleteTextChunksByFileUID.expectations) > 0 {
		mmDeleteTextChunksByFileUID.mock.t.Fatalf("Some expectations are already set for the Service.DeleteTextChunksByFileUID method")
	}

	mmDeleteTextChunksByFileUID.mock.funcDeleteTextChunksByFileUID = f
	mmDeleteTextChunksByFileUID.mock.funcDeleteTextChunksByFileUIDOrigin = minimock.CallerInfo(1)
	return mmDeleteTextChunksByFileUID.mock
}

// When sets expectation for the Service.DeleteTextChunksByFileUID which will trigger the result defined by the following
// Then helper
func (mmDeleteTextChunksByFileUID *mServiceMockDeleteTextChunksByFileUID) When(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) *ServiceMockDeleteTextChunksByFileUIDExpectation {
	if mmDeleteTextChunksByFileUID.mock.funcDeleteTextChunksByFileUID != nil {
		mmDeleteTextChunksByFileUID.mock.t.Fatalf("ServiceMock.DeleteTextChunksByFileUID mock is already set by Set")
	}

	expectation := &ServiceMockDeleteTextChunksByFileUIDExpectation{
		mock:               mmDeleteTextChunksByFileUID.mock,
		params:             &ServiceMockDeleteTextChunksByFileUIDParams{ctx, u1, u2},
		expectationOrigins: ServiceMockDeleteTextChunksByFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteTextChunksByFileUID.expectations = append(mmDeleteTextChunksByFileUID.expectations, expectation)
	return expectation
}

// Then sets up Service.DeleteTextChunksByFileUID return parameters for the expectation previously defined by the When method
func (e *ServiceMockDeleteTextChunksByFileUIDExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockDeleteTextChunksByFileUIDResults{err}
	return e.mock
}

// Times sets number of times Service.DeleteTextChunksByFileUID should be invoked
func (mmDeleteTextChunksByFileUID *mServiceMockDeleteTextChunksByFileUID) Times(n uint64) *mServiceMockDeleteTextChunksByFileUID {
	if n == 0 {
		mmDeleteTextChunksByFileUID.mock.t.Fatalf("Times of ServiceMock.DeleteTextChunksByFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteTextChunksByFileUID.expectedInvocations, n)
	mmDeleteTextChunksByFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteTextChunksByFileUID
}

func (mmDeleteTextChunksByFileUID *mServiceMockDeleteTextChunksByFileUID) invocationsDone() bool {
	if len(mmDeleteTextChunksByFileUID.expectations) == 0 && mmDeleteTextChunksByFileUID.defaultExpectation == nil && mmDeleteTextChunksByFileUID.mock.funcDeleteTextChunksByFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteTextChunksByFileUID.mock.afterDeleteTextChunksByFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteTextChunksByFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteTextChunksByFileUID implements mm_service.Service
func (mmDeleteTextChunksByFileUID *ServiceMock) DeleteTextChunksByFileUID(ctx context.Context, u1 uuid.UUID, u2 uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteTextChunksByFileUID.beforeDeleteTextChunksByFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteTextChunksByFileUID.afterDeleteTextChunksByFileUIDCounter, 1)

	mmDeleteTextChunksByFileUID.t.Helper()

	if mmDeleteTextChunksByFileUID.inspectFuncDeleteTextChunksByFileUID != nil {
		mmDeleteTextChunksByFileUID.inspectFuncDeleteTextChunksByFileUID(ctx, u1, u2)
	}

	mm_params := ServiceMockDeleteTextChunksByFileUIDParams{ctx, u1, u2}

	// Record call args
	mmDeleteTextChunksByFileUID.DeleteTextChunksByFileUIDMock.mutex.Lock()
	mmDeleteTextChunksByFileUID.DeleteTextChunksByFileUIDMock.callArgs = append(mmDeleteTextChunksByFileUID.DeleteTextChunksByFileUIDMock.callArgs, &mm_params)
	mmDeleteTextChunksByFileUID.DeleteTextChunksByFileUIDMock.mutex.Unlock()

	for _, e := range mmDeleteTextChunksByFileUID.DeleteTextChunksByFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteTextChunksByFileUID.DeleteTextChunksByFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteTextChunksByFileUID.DeleteTextChunksByFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteTextChunksByFileUID.DeleteTextChunksByFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteTextChunksByFileUID.DeleteTextChunksByFileUIDMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockDeleteTextChunksByFileUIDParams{ctx, u1, u2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteTextChunksByFileUID.t.Errorf("ServiceMock.DeleteTextChunksByFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteTextChunksByFileUID.DeleteTextChunksByFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmDeleteTextChunksByFileUID.t.Errorf("ServiceMock.DeleteTextChunksByFileUID got unexpected parameter u1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteTextChunksByFileUID.DeleteTextChunksByFileUIDMock.defaultExpectation.expectationOrigins.originU1, *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

			if mm_want_ptrs.u2 != nil && !minimock.Equal(*mm_want_ptrs.u2, mm_got.u2) {
				mmDeleteTextChunksByFileUID.t.Errorf("ServiceMock.DeleteTextChunksByFileUID got unexpected parameter u2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteTextChunksByFileUID.DeleteTextChunksByFileUIDMock.defaultExpectation.expectationOrigins.originU2, *mm_want_ptrs.u2, mm_got.u2, minimock.Diff(*mm_want_ptrs.u2, mm_got.u2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteTextChunksByFileUID.t.Errorf("ServiceMock.DeleteTextChunksByFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteTextChunksByFileUID.DeleteTextChunksByFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteTextChunksByFileUID.DeleteTextChunksByFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteTextChunksByFileUID.t.Fatal("No results are set for the ServiceMock.DeleteTextChunksByFileUID")
		}
		return (*mm_results).err
	}
	if mmDeleteTextChunksByFileUID.funcDeleteTextChunksByFileUID != nil {
		return mmDeleteTextChunksByFileUID.funcDeleteTextChunksByFileUID(ctx, u1, u2)
	}
	mmDeleteTextChunksByFileUID.t.Fatalf("Unexpected call to ServiceMock.DeleteTextChunksByFileUID. %v %v %v", ctx, u1, u2)
	return
}

// DeleteTextChunksByFileUIDAfterCounter returns a count of finished ServiceMock.DeleteTextChunksByFileUID invocations
func (mmDeleteTextChunksByFileUID *ServiceMock) DeleteTextChunksByFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteTextChunksByFileUID.afterDeleteTextChunksByFileUIDCounter)
}

// DeleteTextChunksByFileUIDBeforeCounter returns a count of ServiceMock.DeleteTextChunksByFileUID invocations
func (mmDeleteTextChunksByFileUID *ServiceMock) DeleteTextChunksByFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteTextChunksByFileUID.beforeDeleteTextChunksByFileUIDCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.DeleteTextChunksByFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteTextChunksByFileUID *mServiceMockDeleteTextChunksByFileUID) Calls() []*ServiceMockDeleteTextChunksByFileUIDParams {
	mmDeleteTextChunksByFileUID.mutex.RLock()

	argCopy := make([]*ServiceMockDeleteTextChunksByFileUIDParams, len(mmDeleteTextChunksByFileUID.callArgs))
	copy(argCopy, mmDeleteTextChunksByFileUID.callArgs)

	mmDeleteTextChunksByFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteTextChunksByFileUIDDone returns true if the count of the DeleteTextChunksByFileUID invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockDeleteTextChunksByFileUIDDone() bool {
	if m.DeleteTextChunksByFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteTextChunksByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteTextChunksByFileUIDMock.invocationsDone()
}

// MinimockDeleteTextChunksByFileUIDInspect logs each unmet expectation
func (m *ServiceMock) MinimockDeleteTextChunksByFileUIDInspect() {
	for _, e := range m.DeleteTextChunksByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.DeleteTextChunksByFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteTextChunksByFileUIDCounter := mm_atomic.LoadUint64(&m.afterDeleteTextChunksByFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteTextChunksByFileUIDMock.defaultExpectation != nil && afterDeleteTextChunksByFileUIDCounter < 1 {
		if m.DeleteTextChunksByFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.DeleteTextChunksByFileUID at\n%s", m.DeleteTextChunksByFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.DeleteTextChunksByFileUID at\n%s with params: %#v", m.DeleteTextChunksByFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.DeleteTextChunksByFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteTextChunksByFileUID != nil && afterDeleteTextChunksByFileUIDCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.DeleteTextChunksByFileUID at\n%s", m.funcDeleteTextChunksByFileUIDOrigin)
	}

	if !m.DeleteTextChunksByFileUIDMock.invocationsDone() && afterDeleteTextChunksByFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.DeleteTextChunksByFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteTextChunksByFileUIDMock.expectedInvocations), m.DeleteTextChunksByFileUIDMock.expectedInvocationsOrigin, afterDeleteTextChunksByFileUIDCounter)
	}
}

type mServiceMockEmbedTextsWorkflow struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockEmbedTextsWorkflowExpectation
	expectations       []*ServiceMockEmbedTextsWorkflowExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockEmbedTextsWorkflowExpectation specifies expectation struct of the Service.EmbedTextsWorkflow
type ServiceMockEmbedTextsWorkflowExpectation struct {
	mock *ServiceMock

	results      *ServiceMockEmbedTextsWorkflowResults
	returnOrigin string
	Counter      uint64
}

// ServiceMockEmbedTextsWorkflowResults contains results of the Service.EmbedTextsWorkflow
type ServiceMockEmbedTextsWorkflowResults struct {
	e1 mm_service.EmbedTextsWorkflow
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmEmbedTextsWorkflow *mServiceMockEmbedTextsWorkflow) Optional() *mServiceMockEmbedTextsWorkflow {
	mmEmbedTextsWorkflow.optional = true
	return mmEmbedTextsWorkflow
}

// Expect sets up expected params for Service.EmbedTextsWorkflow
func (mmEmbedTextsWorkflow *mServiceMockEmbedTextsWorkflow) Expect() *mServiceMockEmbedTextsWorkflow {
	if mmEmbedTextsWorkflow.mock.funcEmbedTextsWorkflow != nil {
		mmEmbedTextsWorkflow.mock.t.Fatalf("ServiceMock.EmbedTextsWorkflow mock is already set by Set")
	}

	if mmEmbedTextsWorkflow.defaultExpectation == nil {
		mmEmbedTextsWorkflow.defaultExpectation = &ServiceMockEmbedTextsWorkflowExpectation{}
	}

	return mmEmbedTextsWorkflow
}

// Inspect accepts an inspector function that has same arguments as the Service.EmbedTextsWorkflow
func (mmEmbedTextsWorkflow *mServiceMockEmbedTextsWorkflow) Inspect(f func()) *mServiceMockEmbedTextsWorkflow {
	if mmEmbedTextsWorkflow.mock.inspectFuncEmbedTextsWorkflow != nil {
		mmEmbedTextsWorkflow.mock.t.Fatalf("Inspect function is already set for ServiceMock.EmbedTextsWorkflow")
	}

	mmEmbedTextsWorkflow.mock.inspectFuncEmbedTextsWorkflow = f

	return mmEmbedTextsWorkflow
}

// Return sets up results that will be returned by Service.EmbedTextsWorkflow
func (mmEmbedTextsWorkflow *mServiceMockEmbedTextsWorkflow) Return(e1 mm_service.EmbedTextsWorkflow) *ServiceMock {
	if mmEmbedTextsWorkflow.mock.funcEmbedTextsWorkflow != nil {
		mmEmbedTextsWorkflow.mock.t.Fatalf("ServiceMock.EmbedTextsWorkflow mock is already set by Set")
	}

	if mmEmbedTextsWorkflow.defaultExpectation == nil {
		mmEmbedTextsWorkflow.defaultExpectation = &ServiceMockEmbedTextsWorkflowExpectation{mock: mmEmbedTextsWorkflow.mock}
	}
	mmEmbedTextsWorkflow.defaultExpectation.results = &ServiceMockEmbedTextsWorkflowResults{e1}
	mmEmbedTextsWorkflow.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmEmbedTextsWorkflow.mock
}

// Set uses given function f to mock the Service.EmbedTextsWorkflow method
func (mmEmbedTextsWorkflow *mServiceMockEmbedTextsWorkflow) Set(f func() (e1 mm_service.EmbedTextsWorkflow)) *ServiceMock {
	if mmEmbedTextsWorkflow.defaultExpectation != nil {
		mmEmbedTextsWorkflow.mock.t.Fatalf("Default expectation is already set for the Service.EmbedTextsWorkflow method")
	}

	if len(mmEmbedTextsWorkflow.expectations) > 0 {
		mmEmbedTextsWorkflow.mock.t.Fatalf("Some expectations are already set for the Service.EmbedTextsWorkflow method")
	}

	mmEmbedTextsWorkflow.mock.funcEmbedTextsWorkflow = f
	mmEmbedTextsWorkflow.mock.funcEmbedTextsWorkflowOrigin = minimock.CallerInfo(1)
	return mmEmbedTextsWorkflow.mock
}

// Times sets number of times Service.EmbedTextsWorkflow should be invoked
func (mmEmbedTextsWorkflow *mServiceMockEmbedTextsWorkflow) Times(n uint64) *mServiceMockEmbedTextsWorkflow {
	if n == 0 {
		mmEmbedTextsWorkflow.mock.t.Fatalf("Times of ServiceMock.EmbedTextsWorkflow mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmEmbedTextsWorkflow.expectedInvocations, n)
	mmEmbedTextsWorkflow.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmEmbedTextsWorkflow
}

func (mmEmbedTextsWorkflow *mServiceMockEmbedTextsWorkflow) invocationsDone() bool {
	if len(mmEmbedTextsWorkflow.expectations) == 0 && mmEmbedTextsWorkflow.defaultExpectation == nil && mmEmbedTextsWorkflow.mock.funcEmbedTextsWorkflow == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmEmbedTextsWorkflow.mock.afterEmbedTextsWorkflowCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmEmbedTextsWorkflow.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// EmbedTextsWorkflow implements mm_service.Service
func (mmEmbedTextsWorkflow *ServiceMock) EmbedTextsWorkflow() (e1 mm_service.EmbedTextsWorkflow) {
	mm_atomic.AddUint64(&mmEmbedTextsWorkflow.beforeEmbedTextsWorkflowCounter, 1)
	defer mm_atomic.AddUint64(&mmEmbedTextsWorkflow.afterEmbedTextsWorkflowCounter, 1)

	mmEmbedTextsWorkflow.t.Helper()

	if mmEmbedTextsWorkflow.inspectFuncEmbedTextsWorkflow != nil {
		mmEmbedTextsWorkflow.inspectFuncEmbedTextsWorkflow()
	}

	if mmEmbedTextsWorkflow.EmbedTextsWorkflowMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEmbedTextsWorkflow.EmbedTextsWorkflowMock.defaultExpectation.Counter, 1)

		mm_results := mmEmbedTextsWorkflow.EmbedTextsWorkflowMock.defaultExpectation.results
		if mm_results == nil {
			mmEmbedTextsWorkflow.t.Fatal("No results are set for the ServiceMock.EmbedTextsWorkflow")
		}
		return (*mm_results).e1
	}
	if mmEmbedTextsWorkflow.funcEmbedTextsWorkflow != nil {
		return mmEmbedTextsWorkflow.funcEmbedTextsWorkflow()
	}
	mmEmbedTextsWorkflow.t.Fatalf("Unexpected call to ServiceMock.EmbedTextsWorkflow.")
	return
}

// EmbedTextsWorkflowAfterCounter returns a count of finished ServiceMock.EmbedTextsWorkflow invocations
func (mmEmbedTextsWorkflow *ServiceMock) EmbedTextsWorkflowAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEmbedTextsWorkflow.afterEmbedTextsWorkflowCounter)
}

// EmbedTextsWorkflowBeforeCounter returns a count of ServiceMock.EmbedTextsWorkflow invocations
func (mmEmbedTextsWorkflow *ServiceMock) EmbedTextsWorkflowBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEmbedTextsWorkflow.beforeEmbedTextsWorkflowCounter)
}

// MinimockEmbedTextsWorkflowDone returns true if the count of the EmbedTextsWorkflow invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockEmbedTextsWorkflowDone() bool {
	if m.EmbedTextsWorkflowMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.EmbedTextsWorkflowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.EmbedTextsWorkflowMock.invocationsDone()
}

// MinimockEmbedTextsWorkflowInspect logs each unmet expectation
func (m *ServiceMock) MinimockEmbedTextsWorkflowInspect() {
	for _, e := range m.EmbedTextsWorkflowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServiceMock.EmbedTextsWorkflow")
		}
	}

	afterEmbedTextsWorkflowCounter := mm_atomic.LoadUint64(&m.afterEmbedTextsWorkflowCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.EmbedTextsWorkflowMock.defaultExpectation != nil && afterEmbedTextsWorkflowCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.EmbedTextsWorkflow at\n%s", m.EmbedTextsWorkflowMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEmbedTextsWorkflow != nil && afterEmbedTextsWorkflowCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.EmbedTextsWorkflow at\n%s", m.funcEmbedTextsWorkflowOrigin)
	}

	if !m.EmbedTextsWorkflowMock.invocationsDone() && afterEmbedTextsWorkflowCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.EmbedTextsWorkflow at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.EmbedTextsWorkflowMock.expectedInvocations), m.EmbedTextsWorkflowMock.expectedInvocationsOrigin, afterEmbedTextsWorkflowCounter)
	}
}

type mServiceMockEmbeddingTextBatch struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockEmbeddingTextBatchExpectation
	expectations       []*ServiceMockEmbeddingTextBatchExpectation

	callArgs []*ServiceMockEmbeddingTextBatchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockEmbeddingTextBatchExpectation specifies expectation struct of the Service.EmbeddingTextBatch
type ServiceMockEmbeddingTextBatchExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockEmbeddingTextBatchParams
	paramPtrs          *ServiceMockEmbeddingTextBatchParamPtrs
	expectationOrigins ServiceMockEmbeddingTextBatchExpectationOrigins
	results            *ServiceMockEmbeddingTextBatchResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockEmbeddingTextBatchParams contains parameters of the Service.EmbeddingTextBatch
type ServiceMockEmbeddingTextBatchParams struct {
	ctx context.Context
	sa1 []string
}

// ServiceMockEmbeddingTextBatchParamPtrs contains pointers to parameters of the Service.EmbeddingTextBatch
type ServiceMockEmbeddingTextBatchParamPtrs struct {
	ctx *context.Context
	sa1 *[]string
}

// ServiceMockEmbeddingTextBatchResults contains results of the Service.EmbeddingTextBatch
type ServiceMockEmbeddingTextBatchResults struct {
	faa1 [][]float32
	err  error
}

// ServiceMockEmbeddingTextBatchOrigins contains origins of expectations of the Service.EmbeddingTextBatch
type ServiceMockEmbeddingTextBatchExpectationOrigins struct {
	origin    string
	originCtx string
	originSa1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmEmbeddingTextBatch *mServiceMockEmbeddingTextBatch) Optional() *mServiceMockEmbeddingTextBatch {
	mmEmbeddingTextBatch.optional = true
	return mmEmbeddingTextBatch
}

// Expect sets up expected params for Service.EmbeddingTextBatch
func (mmEmbeddingTextBatch *mServiceMockEmbeddingTextBatch) Expect(ctx context.Context, sa1 []string) *mServiceMockEmbeddingTextBatch {
	if mmEmbeddingTextBatch.mock.funcEmbeddingTextBatch != nil {
		mmEmbeddingTextBatch.mock.t.Fatalf("ServiceMock.EmbeddingTextBatch mock is already set by Set")
	}

	if mmEmbeddingTextBatch.defaultExpectation == nil {
		mmEmbeddingTextBatch.defaultExpectation = &ServiceMockEmbeddingTextBatchExpectation{}
	}

	if mmEmbeddingTextBatch.defaultExpectation.paramPtrs != nil {
		mmEmbeddingTextBatch.mock.t.Fatalf("ServiceMock.EmbeddingTextBatch mock is already set by ExpectParams functions")
	}

	mmEmbeddingTextBatch.defaultExpectation.params = &ServiceMockEmbeddingTextBatchParams{ctx, sa1}
	mmEmbeddingTextBatch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmEmbeddingTextBatch.expectations {
		if minimock.Equal(e.params, mmEmbeddingTextBatch.defaultExpectation.params) {
			mmEmbeddingTextBatch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEmbeddingTextBatch.defaultExpectation.params)
		}
	}

	return mmEmbeddingTextBatch
}

// ExpectCtxParam1 sets up expected param ctx for Service.EmbeddingTextBatch
func (mmEmbeddingTextBatch *mServiceMockEmbeddingTextBatch) ExpectCtxParam1(ctx context.Context) *mServiceMockEmbeddingTextBatch {
	if mmEmbeddingTextBatch.mock.funcEmbeddingTextBatch != nil {
		mmEmbeddingTextBatch.mock.t.Fatalf("ServiceMock.EmbeddingTextBatch mock is already set by Set")
	}

	if mmEmbeddingTextBatch.defaultExpectation == nil {
		mmEmbeddingTextBatch.defaultExpectation = &ServiceMockEmbeddingTextBatchExpectation{}
	}

	if mmEmbeddingTextBatch.defaultExpectation.params != nil {
		mmEmbeddingTextBatch.mock.t.Fatalf("ServiceMock.EmbeddingTextBatch mock is already set by Expect")
	}

	if mmEmbeddingTextBatch.defaultExpectation.paramPtrs == nil {
		mmEmbeddingTextBatch.defaultExpectation.paramPtrs = &ServiceMockEmbeddingTextBatchParamPtrs{}
	}
	mmEmbeddingTextBatch.defaultExpectation.paramPtrs.ctx = &ctx
	mmEmbeddingTextBatch.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmEmbeddingTextBatch
}

// ExpectSa1Param2 sets up expected param sa1 for Service.EmbeddingTextBatch
func (mmEmbeddingTextBatch *mServiceMockEmbeddingTextBatch) ExpectSa1Param2(sa1 []string) *mServiceMockEmbeddingTextBatch {
	if mmEmbeddingTextBatch.mock.funcEmbeddingTextBatch != nil {
		mmEmbeddingTextBatch.mock.t.Fatalf("ServiceMock.EmbeddingTextBatch mock is already set by Set")
	}

	if mmEmbeddingTextBatch.defaultExpectation == nil {
		mmEmbeddingTextBatch.defaultExpectation = &ServiceMockEmbeddingTextBatchExpectation{}
	}

	if mmEmbeddingTextBatch.defaultExpectation.params != nil {
		mmEmbeddingTextBatch.mock.t.Fatalf("ServiceMock.EmbeddingTextBatch mock is already set by Expect")
	}

	if mmEmbeddingTextBatch.defaultExpectation.paramPtrs == nil {
		mmEmbeddingTextBatch.defaultExpectation.paramPtrs = &ServiceMockEmbeddingTextBatchParamPtrs{}
	}
	mmEmbeddingTextBatch.defaultExpectation.paramPtrs.sa1 = &sa1
	mmEmbeddingTextBatch.defaultExpectation.expectationOrigins.originSa1 = minimock.CallerInfo(1)

	return mmEmbeddingTextBatch
}

// Inspect accepts an inspector function that has same arguments as the Service.EmbeddingTextBatch
func (mmEmbeddingTextBatch *mServiceMockEmbeddingTextBatch) Inspect(f func(ctx context.Context, sa1 []string)) *mServiceMockEmbeddingTextBatch {
	if mmEmbeddingTextBatch.mock.inspectFuncEmbeddingTextBatch != nil {
		mmEmbeddingTextBatch.mock.t.Fatalf("Inspect function is already set for ServiceMock.EmbeddingTextBatch")
	}

	mmEmbeddingTextBatch.mock.inspectFuncEmbeddingTextBatch = f

	return mmEmbeddingTextBatch
}

// Return sets up results that will be returned by Service.EmbeddingTextBatch
func (mmEmbeddingTextBatch *mServiceMockEmbeddingTextBatch) Return(faa1 [][]float32, err error) *ServiceMock {
	if mmEmbeddingTextBatch.mock.funcEmbeddingTextBatch != nil {
		mmEmbeddingTextBatch.mock.t.Fatalf("ServiceMock.EmbeddingTextBatch mock is already set by Set")
	}

	if mmEmbeddingTextBatch.defaultExpectation == nil {
		mmEmbeddingTextBatch.defaultExpectation = &ServiceMockEmbeddingTextBatchExpectation{mock: mmEmbeddingTextBatch.mock}
	}
	mmEmbeddingTextBatch.defaultExpectation.results = &ServiceMockEmbeddingTextBatchResults{faa1, err}
	mmEmbeddingTextBatch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmEmbeddingTextBatch.mock
}

// Set uses given function f to mock the Service.EmbeddingTextBatch method
func (mmEmbeddingTextBatch *mServiceMockEmbeddingTextBatch) Set(f func(ctx context.Context, sa1 []string) (faa1 [][]float32, err error)) *ServiceMock {
	if mmEmbeddingTextBatch.defaultExpectation != nil {
		mmEmbeddingTextBatch.mock.t.Fatalf("Default expectation is already set for the Service.EmbeddingTextBatch method")
	}

	if len(mmEmbeddingTextBatch.expectations) > 0 {
		mmEmbeddingTextBatch.mock.t.Fatalf("Some expectations are already set for the Service.EmbeddingTextBatch method")
	}

	mmEmbeddingTextBatch.mock.funcEmbeddingTextBatch = f
	mmEmbeddingTextBatch.mock.funcEmbeddingTextBatchOrigin = minimock.CallerInfo(1)
	return mmEmbeddingTextBatch.mock
}

// When sets expectation for the Service.EmbeddingTextBatch which will trigger the result defined by the following
// Then helper
func (mmEmbeddingTextBatch *mServiceMockEmbeddingTextBatch) When(ctx context.Context, sa1 []string) *ServiceMockEmbeddingTextBatchExpectation {
	if mmEmbeddingTextBatch.mock.funcEmbeddingTextBatch != nil {
		mmEmbeddingTextBatch.mock.t.Fatalf("ServiceMock.EmbeddingTextBatch mock is already set by Set")
	}

	expectation := &ServiceMockEmbeddingTextBatchExpectation{
		mock:               mmEmbeddingTextBatch.mock,
		params:             &ServiceMockEmbeddingTextBatchParams{ctx, sa1},
		expectationOrigins: ServiceMockEmbeddingTextBatchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmEmbeddingTextBatch.expectations = append(mmEmbeddingTextBatch.expectations, expectation)
	return expectation
}

// Then sets up Service.EmbeddingTextBatch return parameters for the expectation previously defined by the When method
func (e *ServiceMockEmbeddingTextBatchExpectation) Then(faa1 [][]float32, err error) *ServiceMock {
	e.results = &ServiceMockEmbeddingTextBatchResults{faa1, err}
	return e.mock
}

// Times sets number of times Service.EmbeddingTextBatch should be invoked
func (mmEmbeddingTextBatch *mServiceMockEmbeddingTextBatch) Times(n uint64) *mServiceMockEmbeddingTextBatch {
	if n == 0 {
		mmEmbeddingTextBatch.mock.t.Fatalf("Times of ServiceMock.EmbeddingTextBatch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmEmbeddingTextBatch.expectedInvocations, n)
	mmEmbeddingTextBatch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmEmbeddingTextBatch
}

func (mmEmbeddingTextBatch *mServiceMockEmbeddingTextBatch) invocationsDone() bool {
	if len(mmEmbeddingTextBatch.expectations) == 0 && mmEmbeddingTextBatch.defaultExpectation == nil && mmEmbeddingTextBatch.mock.funcEmbeddingTextBatch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmEmbeddingTextBatch.mock.afterEmbeddingTextBatchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmEmbeddingTextBatch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// EmbeddingTextBatch implements mm_service.Service
func (mmEmbeddingTextBatch *ServiceMock) EmbeddingTextBatch(ctx context.Context, sa1 []string) (faa1 [][]float32, err error) {
	mm_atomic.AddUint64(&mmEmbeddingTextBatch.beforeEmbeddingTextBatchCounter, 1)
	defer mm_atomic.AddUint64(&mmEmbeddingTextBatch.afterEmbeddingTextBatchCounter, 1)

	mmEmbeddingTextBatch.t.Helper()

	if mmEmbeddingTextBatch.inspectFuncEmbeddingTextBatch != nil {
		mmEmbeddingTextBatch.inspectFuncEmbeddingTextBatch(ctx, sa1)
	}

	mm_params := ServiceMockEmbeddingTextBatchParams{ctx, sa1}

	// Record call args
	mmEmbeddingTextBatch.EmbeddingTextBatchMock.mutex.Lock()
	mmEmbeddingTextBatch.EmbeddingTextBatchMock.callArgs = append(mmEmbeddingTextBatch.EmbeddingTextBatchMock.callArgs, &mm_params)
	mmEmbeddingTextBatch.EmbeddingTextBatchMock.mutex.Unlock()

	for _, e := range mmEmbeddingTextBatch.EmbeddingTextBatchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.faa1, e.results.err
		}
	}

	if mmEmbeddingTextBatch.EmbeddingTextBatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEmbeddingTextBatch.EmbeddingTextBatchMock.defaultExpectation.Counter, 1)
		mm_want := mmEmbeddingTextBatch.EmbeddingTextBatchMock.defaultExpectation.params
		mm_want_ptrs := mmEmbeddingTextBatch.EmbeddingTextBatchMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockEmbeddingTextBatchParams{ctx, sa1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmEmbeddingTextBatch.t.Errorf("ServiceMock.EmbeddingTextBatch got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEmbeddingTextBatch.EmbeddingTextBatchMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sa1 != nil && !minimock.Equal(*mm_want_ptrs.sa1, mm_got.sa1) {
				mmEmbeddingTextBatch.t.Errorf("ServiceMock.EmbeddingTextBatch got unexpected parameter sa1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEmbeddingTextBatch.EmbeddingTextBatchMock.defaultExpectation.expectationOrigins.originSa1, *mm_want_ptrs.sa1, mm_got.sa1, minimock.Diff(*mm_want_ptrs.sa1, mm_got.sa1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEmbeddingTextBatch.t.Errorf("ServiceMock.EmbeddingTextBatch got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmEmbeddingTextBatch.EmbeddingTextBatchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEmbeddingTextBatch.EmbeddingTextBatchMock.defaultExpectation.results
		if mm_results == nil {
			mmEmbeddingTextBatch.t.Fatal("No results are set for the ServiceMock.EmbeddingTextBatch")
		}
		return (*mm_results).faa1, (*mm_results).err
	}
	if mmEmbeddingTextBatch.funcEmbeddingTextBatch != nil {
		return mmEmbeddingTextBatch.funcEmbeddingTextBatch(ctx, sa1)
	}
	mmEmbeddingTextBatch.t.Fatalf("Unexpected call to ServiceMock.EmbeddingTextBatch. %v %v", ctx, sa1)
	return
}

// EmbeddingTextBatchAfterCounter returns a count of finished ServiceMock.EmbeddingTextBatch invocations
func (mmEmbeddingTextBatch *ServiceMock) EmbeddingTextBatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEmbeddingTextBatch.afterEmbeddingTextBatchCounter)
}

// EmbeddingTextBatchBeforeCounter returns a count of ServiceMock.EmbeddingTextBatch invocations
func (mmEmbeddingTextBatch *ServiceMock) EmbeddingTextBatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEmbeddingTextBatch.beforeEmbeddingTextBatchCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.EmbeddingTextBatch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEmbeddingTextBatch *mServiceMockEmbeddingTextBatch) Calls() []*ServiceMockEmbeddingTextBatchParams {
	mmEmbeddingTextBatch.mutex.RLock()

	argCopy := make([]*ServiceMockEmbeddingTextBatchParams, len(mmEmbeddingTextBatch.callArgs))
	copy(argCopy, mmEmbeddingTextBatch.callArgs)

	mmEmbeddingTextBatch.mutex.RUnlock()

	return argCopy
}

// MinimockEmbeddingTextBatchDone returns true if the count of the EmbeddingTextBatch invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockEmbeddingTextBatchDone() bool {
	if m.EmbeddingTextBatchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.EmbeddingTextBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.EmbeddingTextBatchMock.invocationsDone()
}

// MinimockEmbeddingTextBatchInspect logs each unmet expectation
func (m *ServiceMock) MinimockEmbeddingTextBatchInspect() {
	for _, e := range m.EmbeddingTextBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.EmbeddingTextBatch at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterEmbeddingTextBatchCounter := mm_atomic.LoadUint64(&m.afterEmbeddingTextBatchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.EmbeddingTextBatchMock.defaultExpectation != nil && afterEmbeddingTextBatchCounter < 1 {
		if m.EmbeddingTextBatchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.EmbeddingTextBatch at\n%s", m.EmbeddingTextBatchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.EmbeddingTextBatch at\n%s with params: %#v", m.EmbeddingTextBatchMock.defaultExpectation.expectationOrigins.origin, *m.EmbeddingTextBatchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEmbeddingTextBatch != nil && afterEmbeddingTextBatchCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.EmbeddingTextBatch at\n%s", m.funcEmbeddingTextBatchOrigin)
	}

	if !m.EmbeddingTextBatchMock.invocationsDone() && afterEmbeddingTextBatchCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.EmbeddingTextBatch at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.EmbeddingTextBatchMock.expectedInvocations), m.EmbeddingTextBatchMock.expectedInvocationsOrigin, afterEmbeddingTextBatchCounter)
	}
}

type mServiceMockEmbeddingTextPipe struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockEmbeddingTextPipeExpectation
	expectations       []*ServiceMockEmbeddingTextPipeExpectation

	callArgs []*ServiceMockEmbeddingTextPipeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockEmbeddingTextPipeExpectation specifies expectation struct of the Service.EmbeddingTextPipe
type ServiceMockEmbeddingTextPipeExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockEmbeddingTextPipeParams
	paramPtrs          *ServiceMockEmbeddingTextPipeParamPtrs
	expectationOrigins ServiceMockEmbeddingTextPipeExpectationOrigins
	results            *ServiceMockEmbeddingTextPipeResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockEmbeddingTextPipeParams contains parameters of the Service.EmbeddingTextPipe
type ServiceMockEmbeddingTextPipeParams struct {
	ctx context.Context
	sa1 []string
}

// ServiceMockEmbeddingTextPipeParamPtrs contains pointers to parameters of the Service.EmbeddingTextPipe
type ServiceMockEmbeddingTextPipeParamPtrs struct {
	ctx *context.Context
	sa1 *[]string
}

// ServiceMockEmbeddingTextPipeResults contains results of the Service.EmbeddingTextPipe
type ServiceMockEmbeddingTextPipeResults struct {
	faa1 [][]float32
	err  error
}

// ServiceMockEmbeddingTextPipeOrigins contains origins of expectations of the Service.EmbeddingTextPipe
type ServiceMockEmbeddingTextPipeExpectationOrigins struct {
	origin    string
	originCtx string
	originSa1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmEmbeddingTextPipe *mServiceMockEmbeddingTextPipe) Optional() *mServiceMockEmbeddingTextPipe {
	mmEmbeddingTextPipe.optional = true
	return mmEmbeddingTextPipe
}

// Expect sets up expected params for Service.EmbeddingTextPipe
func (mmEmbeddingTextPipe *mServiceMockEmbeddingTextPipe) Expect(ctx context.Context, sa1 []string) *mServiceMockEmbeddingTextPipe {
	if mmEmbeddingTextPipe.mock.funcEmbeddingTextPipe != nil {
		mmEmbeddingTextPipe.mock.t.Fatalf("ServiceMock.EmbeddingTextPipe mock is already set by Set")
	}

	if mmEmbeddingTextPipe.defaultExpectation == nil {
		mmEmbeddingTextPipe.defaultExpectation = &ServiceMockEmbeddingTextPipeExpectation{}
	}

	if mmEmbeddingTextPipe.defaultExpectation.paramPtrs != nil {
		mmEmbeddingTextPipe.mock.t.Fatalf("ServiceMock.EmbeddingTextPipe mock is already set by ExpectParams functions")
	}

	mmEmbeddingTextPipe.defaultExpectation.params = &ServiceMockEmbeddingTextPipeParams{ctx, sa1}
	mmEmbeddingTextPipe.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmEmbeddingTextPipe.expectations {
		if minimock.Equal(e.params, mmEmbeddingTextPipe.defaultExpectation.params) {
			mmEmbeddingTextPipe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEmbeddingTextPipe.defaultExpectation.params)
		}
	}

	return mmEmbeddingTextPipe
}

// ExpectCtxParam1 sets up expected param ctx for Service.EmbeddingTextPipe
func (mmEmbeddingTextPipe *mServiceMockEmbeddingTextPipe) ExpectCtxParam1(ctx context.Context) *mServiceMockEmbeddingTextPipe {
	if mmEmbeddingTextPipe.mock.funcEmbeddingTextPipe != nil {
		mmEmbeddingTextPipe.mock.t.Fatalf("ServiceMock.EmbeddingTextPipe mock is already set by Set")
	}

	if mmEmbeddingTextPipe.defaultExpectation == nil {
		mmEmbeddingTextPipe.defaultExpectation = &ServiceMockEmbeddingTextPipeExpectation{}
	}

	if mmEmbeddingTextPipe.defaultExpectation.params != nil {
		mmEmbeddingTextPipe.mock.t.Fatalf("ServiceMock.EmbeddingTextPipe mock is already set by Expect")
	}

	if mmEmbeddingTextPipe.defaultExpectation.paramPtrs == nil {
		mmEmbeddingTextPipe.defaultExpectation.paramPtrs = &ServiceMockEmbeddingTextPipeParamPtrs{}
	}
	mmEmbeddingTextPipe.defaultExpectation.paramPtrs.ctx = &ctx
	mmEmbeddingTextPipe.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmEmbeddingTextPipe
}

// ExpectSa1Param2 sets up expected param sa1 for Service.EmbeddingTextPipe
func (mmEmbeddingTextPipe *mServiceMockEmbeddingTextPipe) ExpectSa1Param2(sa1 []string) *mServiceMockEmbeddingTextPipe {
	if mmEmbeddingTextPipe.mock.funcEmbeddingTextPipe != nil {
		mmEmbeddingTextPipe.mock.t.Fatalf("ServiceMock.EmbeddingTextPipe mock is already set by Set")
	}

	if mmEmbeddingTextPipe.defaultExpectation == nil {
		mmEmbeddingTextPipe.defaultExpectation = &ServiceMockEmbeddingTextPipeExpectation{}
	}

	if mmEmbeddingTextPipe.defaultExpectation.params != nil {
		mmEmbeddingTextPipe.mock.t.Fatalf("ServiceMock.EmbeddingTextPipe mock is already set by Expect")
	}

	if mmEmbeddingTextPipe.defaultExpectation.paramPtrs == nil {
		mmEmbeddingTextPipe.defaultExpectation.paramPtrs = &ServiceMockEmbeddingTextPipeParamPtrs{}
	}
	mmEmbeddingTextPipe.defaultExpectation.paramPtrs.sa1 = &sa1
	mmEmbeddingTextPipe.defaultExpectation.expectationOrigins.originSa1 = minimock.CallerInfo(1)

	return mmEmbeddingTextPipe
}

// Inspect accepts an inspector function that has same arguments as the Service.EmbeddingTextPipe
func (mmEmbeddingTextPipe *mServiceMockEmbeddingTextPipe) Inspect(f func(ctx context.Context, sa1 []string)) *mServiceMockEmbeddingTextPipe {
	if mmEmbeddingTextPipe.mock.inspectFuncEmbeddingTextPipe != nil {
		mmEmbeddingTextPipe.mock.t.Fatalf("Inspect function is already set for ServiceMock.EmbeddingTextPipe")
	}

	mmEmbeddingTextPipe.mock.inspectFuncEmbeddingTextPipe = f

	return mmEmbeddingTextPipe
}

// Return sets up results that will be returned by Service.EmbeddingTextPipe
func (mmEmbeddingTextPipe *mServiceMockEmbeddingTextPipe) Return(faa1 [][]float32, err error) *ServiceMock {
	if mmEmbeddingTextPipe.mock.funcEmbeddingTextPipe != nil {
		mmEmbeddingTextPipe.mock.t.Fatalf("ServiceMock.EmbeddingTextPipe mock is already set by Set")
	}

	if mmEmbeddingTextPipe.defaultExpectation == nil {
		mmEmbeddingTextPipe.defaultExpectation = &ServiceMockEmbeddingTextPipeExpectation{mock: mmEmbeddingTextPipe.mock}
	}
	mmEmbeddingTextPipe.defaultExpectation.results = &ServiceMockEmbeddingTextPipeResults{faa1, err}
	mmEmbeddingTextPipe.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmEmbeddingTextPipe.mock
}

// Set uses given function f to mock the Service.EmbeddingTextPipe method
func (mmEmbeddingTextPipe *mServiceMockEmbeddingTextPipe) Set(f func(ctx context.Context, sa1 []string) (faa1 [][]float32, err error)) *ServiceMock {
	if mmEmbeddingTextPipe.defaultExpectation != nil {
		mmEmbeddingTextPipe.mock.t.Fatalf("Default expectation is already set for the Service.EmbeddingTextPipe method")
	}

	if len(mmEmbeddingTextPipe.expectations) > 0 {
		mmEmbeddingTextPipe.mock.t.Fatalf("Some expectations are already set for the Service.EmbeddingTextPipe method")
	}

	mmEmbeddingTextPipe.mock.funcEmbeddingTextPipe = f
	mmEmbeddingTextPipe.mock.funcEmbeddingTextPipeOrigin = minimock.CallerInfo(1)
	return mmEmbeddingTextPipe.mock
}

// When sets expectation for the Service.EmbeddingTextPipe which will trigger the result defined by the following
// Then helper
func (mmEmbeddingTextPipe *mServiceMockEmbeddingTextPipe) When(ctx context.Context, sa1 []string) *ServiceMockEmbeddingTextPipeExpectation {
	if mmEmbeddingTextPipe.mock.funcEmbeddingTextPipe != nil {
		mmEmbeddingTextPipe.mock.t.Fatalf("ServiceMock.EmbeddingTextPipe mock is already set by Set")
	}

	expectation := &ServiceMockEmbeddingTextPipeExpectation{
		mock:               mmEmbeddingTextPipe.mock,
		params:             &ServiceMockEmbeddingTextPipeParams{ctx, sa1},
		expectationOrigins: ServiceMockEmbeddingTextPipeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmEmbeddingTextPipe.expectations = append(mmEmbeddingTextPipe.expectations, expectation)
	return expectation
}

// Then sets up Service.EmbeddingTextPipe return parameters for the expectation previously defined by the When method
func (e *ServiceMockEmbeddingTextPipeExpectation) Then(faa1 [][]float32, err error) *ServiceMock {
	e.results = &ServiceMockEmbeddingTextPipeResults{faa1, err}
	return e.mock
}

// Times sets number of times Service.EmbeddingTextPipe should be invoked
func (mmEmbeddingTextPipe *mServiceMockEmbeddingTextPipe) Times(n uint64) *mServiceMockEmbeddingTextPipe {
	if n == 0 {
		mmEmbeddingTextPipe.mock.t.Fatalf("Times of ServiceMock.EmbeddingTextPipe mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmEmbeddingTextPipe.expectedInvocations, n)
	mmEmbeddingTextPipe.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmEmbeddingTextPipe
}

func (mmEmbeddingTextPipe *mServiceMockEmbeddingTextPipe) invocationsDone() bool {
	if len(mmEmbeddingTextPipe.expectations) == 0 && mmEmbeddingTextPipe.defaultExpectation == nil && mmEmbeddingTextPipe.mock.funcEmbeddingTextPipe == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmEmbeddingTextPipe.mock.afterEmbeddingTextPipeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmEmbeddingTextPipe.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// EmbeddingTextPipe implements mm_service.Service
func (mmEmbeddingTextPipe *ServiceMock) EmbeddingTextPipe(ctx context.Context, sa1 []string) (faa1 [][]float32, err error) {
	mm_atomic.AddUint64(&mmEmbeddingTextPipe.beforeEmbeddingTextPipeCounter, 1)
	defer mm_atomic.AddUint64(&mmEmbeddingTextPipe.afterEmbeddingTextPipeCounter, 1)

	mmEmbeddingTextPipe.t.Helper()

	if mmEmbeddingTextPipe.inspectFuncEmbeddingTextPipe != nil {
		mmEmbeddingTextPipe.inspectFuncEmbeddingTextPipe(ctx, sa1)
	}

	mm_params := ServiceMockEmbeddingTextPipeParams{ctx, sa1}

	// Record call args
	mmEmbeddingTextPipe.EmbeddingTextPipeMock.mutex.Lock()
	mmEmbeddingTextPipe.EmbeddingTextPipeMock.callArgs = append(mmEmbeddingTextPipe.EmbeddingTextPipeMock.callArgs, &mm_params)
	mmEmbeddingTextPipe.EmbeddingTextPipeMock.mutex.Unlock()

	for _, e := range mmEmbeddingTextPipe.EmbeddingTextPipeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.faa1, e.results.err
		}
	}

	if mmEmbeddingTextPipe.EmbeddingTextPipeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEmbeddingTextPipe.EmbeddingTextPipeMock.defaultExpectation.Counter, 1)
		mm_want := mmEmbeddingTextPipe.EmbeddingTextPipeMock.defaultExpectation.params
		mm_want_ptrs := mmEmbeddingTextPipe.EmbeddingTextPipeMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockEmbeddingTextPipeParams{ctx, sa1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmEmbeddingTextPipe.t.Errorf("ServiceMock.EmbeddingTextPipe got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEmbeddingTextPipe.EmbeddingTextPipeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sa1 != nil && !minimock.Equal(*mm_want_ptrs.sa1, mm_got.sa1) {
				mmEmbeddingTextPipe.t.Errorf("ServiceMock.EmbeddingTextPipe got unexpected parameter sa1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEmbeddingTextPipe.EmbeddingTextPipeMock.defaultExpectation.expectationOrigins.originSa1, *mm_want_ptrs.sa1, mm_got.sa1, minimock.Diff(*mm_want_ptrs.sa1, mm_got.sa1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEmbeddingTextPipe.t.Errorf("ServiceMock.EmbeddingTextPipe got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmEmbeddingTextPipe.EmbeddingTextPipeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEmbeddingTextPipe.EmbeddingTextPipeMock.defaultExpectation.results
		if mm_results == nil {
			mmEmbeddingTextPipe.t.Fatal("No results are set for the ServiceMock.EmbeddingTextPipe")
		}
		return (*mm_results).faa1, (*mm_results).err
	}
	if mmEmbeddingTextPipe.funcEmbeddingTextPipe != nil {
		return mmEmbeddingTextPipe.funcEmbeddingTextPipe(ctx, sa1)
	}
	mmEmbeddingTextPipe.t.Fatalf("Unexpected call to ServiceMock.EmbeddingTextPipe. %v %v", ctx, sa1)
	return
}

// EmbeddingTextPipeAfterCounter returns a count of finished ServiceMock.EmbeddingTextPipe invocations
func (mmEmbeddingTextPipe *ServiceMock) EmbeddingTextPipeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEmbeddingTextPipe.afterEmbeddingTextPipeCounter)
}

// EmbeddingTextPipeBeforeCounter returns a count of ServiceMock.EmbeddingTextPipe invocations
func (mmEmbeddingTextPipe *ServiceMock) EmbeddingTextPipeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEmbeddingTextPipe.beforeEmbeddingTextPipeCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.EmbeddingTextPipe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEmbeddingTextPipe *mServiceMockEmbeddingTextPipe) Calls() []*ServiceMockEmbeddingTextPipeParams {
	mmEmbeddingTextPipe.mutex.RLock()

	argCopy := make([]*ServiceMockEmbeddingTextPipeParams, len(mmEmbeddingTextPipe.callArgs))
	copy(argCopy, mmEmbeddingTextPipe.callArgs)

	mmEmbeddingTextPipe.mutex.RUnlock()

	return argCopy
}

// MinimockEmbeddingTextPipeDone returns true if the count of the EmbeddingTextPipe invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockEmbeddingTextPipeDone() bool {
	if m.EmbeddingTextPipeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.EmbeddingTextPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.EmbeddingTextPipeMock.invocationsDone()
}

// MinimockEmbeddingTextPipeInspect logs each unmet expectation
func (m *ServiceMock) MinimockEmbeddingTextPipeInspect() {
	for _, e := range m.EmbeddingTextPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.EmbeddingTextPipe at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterEmbeddingTextPipeCounter := mm_atomic.LoadUint64(&m.afterEmbeddingTextPipeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.EmbeddingTextPipeMock.defaultExpectation != nil && afterEmbeddingTextPipeCounter < 1 {
		if m.EmbeddingTextPipeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.EmbeddingTextPipe at\n%s", m.EmbeddingTextPipeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.EmbeddingTextPipe at\n%s with params: %#v", m.EmbeddingTextPipeMock.defaultExpectation.expectationOrigins.origin, *m.EmbeddingTextPipeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEmbeddingTextPipe != nil && afterEmbeddingTextPipeCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.EmbeddingTextPipe at\n%s", m.funcEmbeddingTextPipeOrigin)
	}

	if !m.EmbeddingTextPipeMock.invocationsDone() && afterEmbeddingTextPipeCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.EmbeddingTextPipe at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.EmbeddingTextPipeMock.expectedInvocations), m.EmbeddingTextPipeMock.expectedInvocationsOrigin, afterEmbeddingTextPipeCounter)
	}
}

type mServiceMockGenerateSummary struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGenerateSummaryExpectation
	expectations       []*ServiceMockGenerateSummaryExpectation

	callArgs []*ServiceMockGenerateSummaryParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGenerateSummaryExpectation specifies expectation struct of the Service.GenerateSummary
type ServiceMockGenerateSummaryExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGenerateSummaryParams
	paramPtrs          *ServiceMockGenerateSummaryParamPtrs
	expectationOrigins ServiceMockGenerateSummaryExpectationOrigins
	results            *ServiceMockGenerateSummaryResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGenerateSummaryParams contains parameters of the Service.GenerateSummary
type ServiceMockGenerateSummaryParams struct {
	ctx context.Context
	s1  string
	s2  string
}

// ServiceMockGenerateSummaryParamPtrs contains pointers to parameters of the Service.GenerateSummary
type ServiceMockGenerateSummaryParamPtrs struct {
	ctx *context.Context
	s1  *string
	s2  *string
}

// ServiceMockGenerateSummaryResults contains results of the Service.GenerateSummary
type ServiceMockGenerateSummaryResults struct {
	s3  string
	err error
}

// ServiceMockGenerateSummaryOrigins contains origins of expectations of the Service.GenerateSummary
type ServiceMockGenerateSummaryExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
	originS2  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGenerateSummary *mServiceMockGenerateSummary) Optional() *mServiceMockGenerateSummary {
	mmGenerateSummary.optional = true
	return mmGenerateSummary
}

// Expect sets up expected params for Service.GenerateSummary
func (mmGenerateSummary *mServiceMockGenerateSummary) Expect(ctx context.Context, s1 string, s2 string) *mServiceMockGenerateSummary {
	if mmGenerateSummary.mock.funcGenerateSummary != nil {
		mmGenerateSummary.mock.t.Fatalf("ServiceMock.GenerateSummary mock is already set by Set")
	}

	if mmGenerateSummary.defaultExpectation == nil {
		mmGenerateSummary.defaultExpectation = &ServiceMockGenerateSummaryExpectation{}
	}

	if mmGenerateSummary.defaultExpectation.paramPtrs != nil {
		mmGenerateSummary.mock.t.Fatalf("ServiceMock.GenerateSummary mock is already set by ExpectParams functions")
	}

	mmGenerateSummary.defaultExpectation.params = &ServiceMockGenerateSummaryParams{ctx, s1, s2}
	mmGenerateSummary.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGenerateSummary.expectations {
		if minimock.Equal(e.params, mmGenerateSummary.defaultExpectation.params) {
			mmGenerateSummary.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGenerateSummary.defaultExpectation.params)
		}
	}

	return mmGenerateSummary
}

// ExpectCtxParam1 sets up expected param ctx for Service.GenerateSummary
func (mmGenerateSummary *mServiceMockGenerateSummary) ExpectCtxParam1(ctx context.Context) *mServiceMockGenerateSummary {
	if mmGenerateSummary.mock.funcGenerateSummary != nil {
		mmGenerateSummary.mock.t.Fatalf("ServiceMock.GenerateSummary mock is already set by Set")
	}

	if mmGenerateSummary.defaultExpectation == nil {
		mmGenerateSummary.defaultExpectation = &ServiceMockGenerateSummaryExpectation{}
	}

	if mmGenerateSummary.defaultExpectation.params != nil {
		mmGenerateSummary.mock.t.Fatalf("ServiceMock.GenerateSummary mock is already set by Expect")
	}

	if mmGenerateSummary.defaultExpectation.paramPtrs == nil {
		mmGenerateSummary.defaultExpectation.paramPtrs = &ServiceMockGenerateSummaryParamPtrs{}
	}
	mmGenerateSummary.defaultExpectation.paramPtrs.ctx = &ctx
	mmGenerateSummary.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGenerateSummary
}

// ExpectS1Param2 sets up expected param s1 for Service.GenerateSummary
func (mmGenerateSummary *mServiceMockGenerateSummary) ExpectS1Param2(s1 string) *mServiceMockGenerateSummary {
	if mmGenerateSummary.mock.funcGenerateSummary != nil {
		mmGenerateSummary.mock.t.Fatalf("ServiceMock.GenerateSummary mock is already set by Set")
	}

	if mmGenerateSummary.defaultExpectation == nil {
		mmGenerateSummary.defaultExpectation = &ServiceMockGenerateSummaryExpectation{}
	}

	if mmGenerateSummary.defaultExpectation.params != nil {
		mmGenerateSummary.mock.t.Fatalf("ServiceMock.GenerateSummary mock is already set by Expect")
	}

	if mmGenerateSummary.defaultExpectation.paramPtrs == nil {
		mmGenerateSummary.defaultExpectation.paramPtrs = &ServiceMockGenerateSummaryParamPtrs{}
	}
	mmGenerateSummary.defaultExpectation.paramPtrs.s1 = &s1
	mmGenerateSummary.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmGenerateSummary
}

// ExpectS2Param3 sets up expected param s2 for Service.GenerateSummary
func (mmGenerateSummary *mServiceMockGenerateSummary) ExpectS2Param3(s2 string) *mServiceMockGenerateSummary {
	if mmGenerateSummary.mock.funcGenerateSummary != nil {
		mmGenerateSummary.mock.t.Fatalf("ServiceMock.GenerateSummary mock is already set by Set")
	}

	if mmGenerateSummary.defaultExpectation == nil {
		mmGenerateSummary.defaultExpectation = &ServiceMockGenerateSummaryExpectation{}
	}

	if mmGenerateSummary.defaultExpectation.params != nil {
		mmGenerateSummary.mock.t.Fatalf("ServiceMock.GenerateSummary mock is already set by Expect")
	}

	if mmGenerateSummary.defaultExpectation.paramPtrs == nil {
		mmGenerateSummary.defaultExpectation.paramPtrs = &ServiceMockGenerateSummaryParamPtrs{}
	}
	mmGenerateSummary.defaultExpectation.paramPtrs.s2 = &s2
	mmGenerateSummary.defaultExpectation.expectationOrigins.originS2 = minimock.CallerInfo(1)

	return mmGenerateSummary
}

// Inspect accepts an inspector function that has same arguments as the Service.GenerateSummary
func (mmGenerateSummary *mServiceMockGenerateSummary) Inspect(f func(ctx context.Context, s1 string, s2 string)) *mServiceMockGenerateSummary {
	if mmGenerateSummary.mock.inspectFuncGenerateSummary != nil {
		mmGenerateSummary.mock.t.Fatalf("Inspect function is already set for ServiceMock.GenerateSummary")
	}

	mmGenerateSummary.mock.inspectFuncGenerateSummary = f

	return mmGenerateSummary
}

// Return sets up results that will be returned by Service.GenerateSummary
func (mmGenerateSummary *mServiceMockGenerateSummary) Return(s3 string, err error) *ServiceMock {
	if mmGenerateSummary.mock.funcGenerateSummary != nil {
		mmGenerateSummary.mock.t.Fatalf("ServiceMock.GenerateSummary mock is already set by Set")
	}

	if mmGenerateSummary.defaultExpectation == nil {
		mmGenerateSummary.defaultExpectation = &ServiceMockGenerateSummaryExpectation{mock: mmGenerateSummary.mock}
	}
	mmGenerateSummary.defaultExpectation.results = &ServiceMockGenerateSummaryResults{s3, err}
	mmGenerateSummary.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGenerateSummary.mock
}

// Set uses given function f to mock the Service.GenerateSummary method
func (mmGenerateSummary *mServiceMockGenerateSummary) Set(f func(ctx context.Context, s1 string, s2 string) (s3 string, err error)) *ServiceMock {
	if mmGenerateSummary.defaultExpectation != nil {
		mmGenerateSummary.mock.t.Fatalf("Default expectation is already set for the Service.GenerateSummary method")
	}

	if len(mmGenerateSummary.expectations) > 0 {
		mmGenerateSummary.mock.t.Fatalf("Some expectations are already set for the Service.GenerateSummary method")
	}

	mmGenerateSummary.mock.funcGenerateSummary = f
	mmGenerateSummary.mock.funcGenerateSummaryOrigin = minimock.CallerInfo(1)
	return mmGenerateSummary.mock
}

// When sets expectation for the Service.GenerateSummary which will trigger the result defined by the following
// Then helper
func (mmGenerateSummary *mServiceMockGenerateSummary) When(ctx context.Context, s1 string, s2 string) *ServiceMockGenerateSummaryExpectation {
	if mmGenerateSummary.mock.funcGenerateSummary != nil {
		mmGenerateSummary.mock.t.Fatalf("ServiceMock.GenerateSummary mock is already set by Set")
	}

	expectation := &ServiceMockGenerateSummaryExpectation{
		mock:               mmGenerateSummary.mock,
		params:             &ServiceMockGenerateSummaryParams{ctx, s1, s2},
		expectationOrigins: ServiceMockGenerateSummaryExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGenerateSummary.expectations = append(mmGenerateSummary.expectations, expectation)
	return expectation
}

// Then sets up Service.GenerateSummary return parameters for the expectation previously defined by the When method
func (e *ServiceMockGenerateSummaryExpectation) Then(s3 string, err error) *ServiceMock {
	e.results = &ServiceMockGenerateSummaryResults{s3, err}
	return e.mock
}

// Times sets number of times Service.GenerateSummary should be invoked
func (mmGenerateSummary *mServiceMockGenerateSummary) Times(n uint64) *mServiceMockGenerateSummary {
	if n == 0 {
		mmGenerateSummary.mock.t.Fatalf("Times of ServiceMock.GenerateSummary mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGenerateSummary.expectedInvocations, n)
	mmGenerateSummary.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGenerateSummary
}

func (mmGenerateSummary *mServiceMockGenerateSummary) invocationsDone() bool {
	if len(mmGenerateSummary.expectations) == 0 && mmGenerateSummary.defaultExpectation == nil && mmGenerateSummary.mock.funcGenerateSummary == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGenerateSummary.mock.afterGenerateSummaryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGenerateSummary.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GenerateSummary implements mm_service.Service
func (mmGenerateSummary *ServiceMock) GenerateSummary(ctx context.Context, s1 string, s2 string) (s3 string, err error) {
	mm_atomic.AddUint64(&mmGenerateSummary.beforeGenerateSummaryCounter, 1)
	defer mm_atomic.AddUint64(&mmGenerateSummary.afterGenerateSummaryCounter, 1)

	mmGenerateSummary.t.Helper()

	if mmGenerateSummary.inspectFuncGenerateSummary != nil {
		mmGenerateSummary.inspectFuncGenerateSummary(ctx, s1, s2)
	}

	mm_params := ServiceMockGenerateSummaryParams{ctx, s1, s2}

	// Record call args
	mmGenerateSummary.GenerateSummaryMock.mutex.Lock()
	mmGenerateSummary.GenerateSummaryMock.callArgs = append(mmGenerateSummary.GenerateSummaryMock.callArgs, &mm_params)
	mmGenerateSummary.GenerateSummaryMock.mutex.Unlock()

	for _, e := range mmGenerateSummary.GenerateSummaryMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s3, e.results.err
		}
	}

	if mmGenerateSummary.GenerateSummaryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGenerateSummary.GenerateSummaryMock.defaultExpectation.Counter, 1)
		mm_want := mmGenerateSummary.GenerateSummaryMock.defaultExpectation.params
		mm_want_ptrs := mmGenerateSummary.GenerateSummaryMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGenerateSummaryParams{ctx, s1, s2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGenerateSummary.t.Errorf("ServiceMock.GenerateSummary got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGenerateSummary.GenerateSummaryMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmGenerateSummary.t.Errorf("ServiceMock.GenerateSummary got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGenerateSummary.GenerateSummaryMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

			if mm_want_ptrs.s2 != nil && !minimock.Equal(*mm_want_ptrs.s2, mm_got.s2) {
				mmGenerateSummary.t.Errorf("ServiceMock.GenerateSummary got unexpected parameter s2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGenerateSummary.GenerateSummaryMock.defaultExpectation.expectationOrigins.originS2, *mm_want_ptrs.s2, mm_got.s2, minimock.Diff(*mm_want_ptrs.s2, mm_got.s2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGenerateSummary.t.Errorf("ServiceMock.GenerateSummary got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGenerateSummary.GenerateSummaryMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGenerateSummary.GenerateSummaryMock.defaultExpectation.results
		if mm_results == nil {
			mmGenerateSummary.t.Fatal("No results are set for the ServiceMock.GenerateSummary")
		}
		return (*mm_results).s3, (*mm_results).err
	}
	if mmGenerateSummary.funcGenerateSummary != nil {
		return mmGenerateSummary.funcGenerateSummary(ctx, s1, s2)
	}
	mmGenerateSummary.t.Fatalf("Unexpected call to ServiceMock.GenerateSummary. %v %v %v", ctx, s1, s2)
	return
}

// GenerateSummaryAfterCounter returns a count of finished ServiceMock.GenerateSummary invocations
func (mmGenerateSummary *ServiceMock) GenerateSummaryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGenerateSummary.afterGenerateSummaryCounter)
}

// GenerateSummaryBeforeCounter returns a count of ServiceMock.GenerateSummary invocations
func (mmGenerateSummary *ServiceMock) GenerateSummaryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGenerateSummary.beforeGenerateSummaryCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GenerateSummary.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGenerateSummary *mServiceMockGenerateSummary) Calls() []*ServiceMockGenerateSummaryParams {
	mmGenerateSummary.mutex.RLock()

	argCopy := make([]*ServiceMockGenerateSummaryParams, len(mmGenerateSummary.callArgs))
	copy(argCopy, mmGenerateSummary.callArgs)

	mmGenerateSummary.mutex.RUnlock()

	return argCopy
}

// MinimockGenerateSummaryDone returns true if the count of the GenerateSummary invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGenerateSummaryDone() bool {
	if m.GenerateSummaryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GenerateSummaryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GenerateSummaryMock.invocationsDone()
}

// MinimockGenerateSummaryInspect logs each unmet expectation
func (m *ServiceMock) MinimockGenerateSummaryInspect() {
	for _, e := range m.GenerateSummaryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GenerateSummary at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGenerateSummaryCounter := mm_atomic.LoadUint64(&m.afterGenerateSummaryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GenerateSummaryMock.defaultExpectation != nil && afterGenerateSummaryCounter < 1 {
		if m.GenerateSummaryMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GenerateSummary at\n%s", m.GenerateSummaryMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GenerateSummary at\n%s with params: %#v", m.GenerateSummaryMock.defaultExpectation.expectationOrigins.origin, *m.GenerateSummaryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGenerateSummary != nil && afterGenerateSummaryCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GenerateSummary at\n%s", m.funcGenerateSummaryOrigin)
	}

	if !m.GenerateSummaryMock.invocationsDone() && afterGenerateSummaryCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GenerateSummary at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GenerateSummaryMock.expectedInvocations), m.GenerateSummaryMock.expectedInvocationsOrigin, afterGenerateSummaryCounter)
	}
}

type mServiceMockGetChunksByFile struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetChunksByFileExpectation
	expectations       []*ServiceMockGetChunksByFileExpectation

	callArgs []*ServiceMockGetChunksByFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetChunksByFileExpectation specifies expectation struct of the Service.GetChunksByFile
type ServiceMockGetChunksByFileExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetChunksByFileParams
	paramPtrs          *ServiceMockGetChunksByFileParamPtrs
	expectationOrigins ServiceMockGetChunksByFileExpectationOrigins
	results            *ServiceMockGetChunksByFileResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetChunksByFileParams contains parameters of the Service.GetChunksByFile
type ServiceMockGetChunksByFileParams struct {
	ctx context.Context
	kp1 *repository.KnowledgeBaseFile
}

// ServiceMockGetChunksByFileParamPtrs contains pointers to parameters of the Service.GetChunksByFile
type ServiceMockGetChunksByFileParamPtrs struct {
	ctx *context.Context
	kp1 **repository.KnowledgeBaseFile
}

// ServiceMockGetChunksByFileResults contains results of the Service.GetChunksByFile
type ServiceMockGetChunksByFileResults struct {
	s1  mm_service.SourceTableType
	s2  mm_service.SourceIDType
	ta1 []repository.TextChunk
	m1  map[mm_service.ChunkUIDType]mm_service.ContentType
	sa1 []string
	err error
}

// ServiceMockGetChunksByFileOrigins contains origins of expectations of the Service.GetChunksByFile
type ServiceMockGetChunksByFileExpectationOrigins struct {
	origin    string
	originCtx string
	originKp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetChunksByFile *mServiceMockGetChunksByFile) Optional() *mServiceMockGetChunksByFile {
	mmGetChunksByFile.optional = true
	return mmGetChunksByFile
}

// Expect sets up expected params for Service.GetChunksByFile
func (mmGetChunksByFile *mServiceMockGetChunksByFile) Expect(ctx context.Context, kp1 *repository.KnowledgeBaseFile) *mServiceMockGetChunksByFile {
	if mmGetChunksByFile.mock.funcGetChunksByFile != nil {
		mmGetChunksByFile.mock.t.Fatalf("ServiceMock.GetChunksByFile mock is already set by Set")
	}

	if mmGetChunksByFile.defaultExpectation == nil {
		mmGetChunksByFile.defaultExpectation = &ServiceMockGetChunksByFileExpectation{}
	}

	if mmGetChunksByFile.defaultExpectation.paramPtrs != nil {
		mmGetChunksByFile.mock.t.Fatalf("ServiceMock.GetChunksByFile mock is already set by ExpectParams functions")
	}

	mmGetChunksByFile.defaultExpectation.params = &ServiceMockGetChunksByFileParams{ctx, kp1}
	mmGetChunksByFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetChunksByFile.expectations {
		if minimock.Equal(e.params, mmGetChunksByFile.defaultExpectation.params) {
			mmGetChunksByFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChunksByFile.defaultExpectation.params)
		}
	}

	return mmGetChunksByFile
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetChunksByFile
func (mmGetChunksByFile *mServiceMockGetChunksByFile) ExpectCtxParam1(ctx context.Context) *mServiceMockGetChunksByFile {
	if mmGetChunksByFile.mock.funcGetChunksByFile != nil {
		mmGetChunksByFile.mock.t.Fatalf("ServiceMock.GetChunksByFile mock is already set by Set")
	}

	if mmGetChunksByFile.defaultExpectation == nil {
		mmGetChunksByFile.defaultExpectation = &ServiceMockGetChunksByFileExpectation{}
	}

	if mmGetChunksByFile.defaultExpectation.params != nil {
		mmGetChunksByFile.mock.t.Fatalf("ServiceMock.GetChunksByFile mock is already set by Expect")
	}

	if mmGetChunksByFile.defaultExpectation.paramPtrs == nil {
		mmGetChunksByFile.defaultExpectation.paramPtrs = &ServiceMockGetChunksByFileParamPtrs{}
	}
	mmGetChunksByFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetChunksByFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetChunksByFile
}

// ExpectKp1Param2 sets up expected param kp1 for Service.GetChunksByFile
func (mmGetChunksByFile *mServiceMockGetChunksByFile) ExpectKp1Param2(kp1 *repository.KnowledgeBaseFile) *mServiceMockGetChunksByFile {
	if mmGetChunksByFile.mock.funcGetChunksByFile != nil {
		mmGetChunksByFile.mock.t.Fatalf("ServiceMock.GetChunksByFile mock is already set by Set")
	}

	if mmGetChunksByFile.defaultExpectation == nil {
		mmGetChunksByFile.defaultExpectation = &ServiceMockGetChunksByFileExpectation{}
	}

	if mmGetChunksByFile.defaultExpectation.params != nil {
		mmGetChunksByFile.mock.t.Fatalf("ServiceMock.GetChunksByFile mock is already set by Expect")
	}

	if mmGetChunksByFile.defaultExpectation.paramPtrs == nil {
		mmGetChunksByFile.defaultExpectation.paramPtrs = &ServiceMockGetChunksByFileParamPtrs{}
	}
	mmGetChunksByFile.defaultExpectation.paramPtrs.kp1 = &kp1
	mmGetChunksByFile.defaultExpectation.expectationOrigins.originKp1 = minimock.CallerInfo(1)

	return mmGetChunksByFile
}

// Inspect accepts an inspector function that has same arguments as the Service.GetChunksByFile
func (mmGetChunksByFile *mServiceMockGetChunksByFile) Inspect(f func(ctx context.Context, kp1 *repository.KnowledgeBaseFile)) *mServiceMockGetChunksByFile {
	if mmGetChunksByFile.mock.inspectFuncGetChunksByFile != nil {
		mmGetChunksByFile.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetChunksByFile")
	}

	mmGetChunksByFile.mock.inspectFuncGetChunksByFile = f

	return mmGetChunksByFile
}

// Return sets up results that will be returned by Service.GetChunksByFile
func (mmGetChunksByFile *mServiceMockGetChunksByFile) Return(s1 mm_service.SourceTableType, s2 mm_service.SourceIDType, ta1 []repository.TextChunk, m1 map[mm_service.ChunkUIDType]mm_service.ContentType, sa1 []string, err error) *ServiceMock {
	if mmGetChunksByFile.mock.funcGetChunksByFile != nil {
		mmGetChunksByFile.mock.t.Fatalf("ServiceMock.GetChunksByFile mock is already set by Set")
	}

	if mmGetChunksByFile.defaultExpectation == nil {
		mmGetChunksByFile.defaultExpectation = &ServiceMockGetChunksByFileExpectation{mock: mmGetChunksByFile.mock}
	}
	mmGetChunksByFile.defaultExpectation.results = &ServiceMockGetChunksByFileResults{s1, s2, ta1, m1, sa1, err}
	mmGetChunksByFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetChunksByFile.mock
}

// Set uses given function f to mock the Service.GetChunksByFile method
func (mmGetChunksByFile *mServiceMockGetChunksByFile) Set(f func(ctx context.Context, kp1 *repository.KnowledgeBaseFile) (s1 mm_service.SourceTableType, s2 mm_service.SourceIDType, ta1 []repository.TextChunk, m1 map[mm_service.ChunkUIDType]mm_service.ContentType, sa1 []string, err error)) *ServiceMock {
	if mmGetChunksByFile.defaultExpectation != nil {
		mmGetChunksByFile.mock.t.Fatalf("Default expectation is already set for the Service.GetChunksByFile method")
	}

	if len(mmGetChunksByFile.expectations) > 0 {
		mmGetChunksByFile.mock.t.Fatalf("Some expectations are already set for the Service.GetChunksByFile method")
	}

	mmGetChunksByFile.mock.funcGetChunksByFile = f
	mmGetChunksByFile.mock.funcGetChunksByFileOrigin = minimock.CallerInfo(1)
	return mmGetChunksByFile.mock
}

// When sets expectation for the Service.GetChunksByFile which will trigger the result defined by the following
// Then helper
func (mmGetChunksByFile *mServiceMockGetChunksByFile) When(ctx context.Context, kp1 *repository.KnowledgeBaseFile) *ServiceMockGetChunksByFileExpectation {
	if mmGetChunksByFile.mock.funcGetChunksByFile != nil {
		mmGetChunksByFile.mock.t.Fatalf("ServiceMock.GetChunksByFile mock is already set by Set")
	}

	expectation := &ServiceMockGetChunksByFileExpectation{
		mock:               mmGetChunksByFile.mock,
		params:             &ServiceMockGetChunksByFileParams{ctx, kp1},
		expectationOrigins: ServiceMockGetChunksByFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetChunksByFile.expectations = append(mmGetChunksByFile.expectations, expectation)
	return expectation
}

// Then sets up Service.GetChunksByFile return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetChunksByFileExpectation) Then(s1 mm_service.SourceTableType, s2 mm_service.SourceIDType, ta1 []repository.TextChunk, m1 map[mm_service.ChunkUIDType]mm_service.ContentType, sa1 []string, err error) *ServiceMock {
	e.results = &ServiceMockGetChunksByFileResults{s1, s2, ta1, m1, sa1, err}
	return e.mock
}

// Times sets number of times Service.GetChunksByFile should be invoked
func (mmGetChunksByFile *mServiceMockGetChunksByFile) Times(n uint64) *mServiceMockGetChunksByFile {
	if n == 0 {
		mmGetChunksByFile.mock.t.Fatalf("Times of ServiceMock.GetChunksByFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetChunksByFile.expectedInvocations, n)
	mmGetChunksByFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetChunksByFile
}

func (mmGetChunksByFile *mServiceMockGetChunksByFile) invocationsDone() bool {
	if len(mmGetChunksByFile.expectations) == 0 && mmGetChunksByFile.defaultExpectation == nil && mmGetChunksByFile.mock.funcGetChunksByFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetChunksByFile.mock.afterGetChunksByFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetChunksByFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetChunksByFile implements mm_service.Service
func (mmGetChunksByFile *ServiceMock) GetChunksByFile(ctx context.Context, kp1 *repository.KnowledgeBaseFile) (s1 mm_service.SourceTableType, s2 mm_service.SourceIDType, ta1 []repository.TextChunk, m1 map[mm_service.ChunkUIDType]mm_service.ContentType, sa1 []string, err error) {
	mm_atomic.AddUint64(&mmGetChunksByFile.beforeGetChunksByFileCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChunksByFile.afterGetChunksByFileCounter, 1)

	mmGetChunksByFile.t.Helper()

	if mmGetChunksByFile.inspectFuncGetChunksByFile != nil {
		mmGetChunksByFile.inspectFuncGetChunksByFile(ctx, kp1)
	}

	mm_params := ServiceMockGetChunksByFileParams{ctx, kp1}

	// Record call args
	mmGetChunksByFile.GetChunksByFileMock.mutex.Lock()
	mmGetChunksByFile.GetChunksByFileMock.callArgs = append(mmGetChunksByFile.GetChunksByFileMock.callArgs, &mm_params)
	mmGetChunksByFile.GetChunksByFileMock.mutex.Unlock()

	for _, e := range mmGetChunksByFile.GetChunksByFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.s2, e.results.ta1, e.results.m1, e.results.sa1, e.results.err
		}
	}

	if mmGetChunksByFile.GetChunksByFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChunksByFile.GetChunksByFileMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChunksByFile.GetChunksByFileMock.defaultExpectation.params
		mm_want_ptrs := mmGetChunksByFile.GetChunksByFileMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetChunksByFileParams{ctx, kp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetChunksByFile.t.Errorf("ServiceMock.GetChunksByFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChunksByFile.GetChunksByFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kp1 != nil && !minimock.Equal(*mm_want_ptrs.kp1, mm_got.kp1) {
				mmGetChunksByFile.t.Errorf("ServiceMock.GetChunksByFile got unexpected parameter kp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChunksByFile.GetChunksByFileMock.defaultExpectation.expectationOrigins.originKp1, *mm_want_ptrs.kp1, mm_got.kp1, minimock.Diff(*mm_want_ptrs.kp1, mm_got.kp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChunksByFile.t.Errorf("ServiceMock.GetChunksByFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetChunksByFile.GetChunksByFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChunksByFile.GetChunksByFileMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChunksByFile.t.Fatal("No results are set for the ServiceMock.GetChunksByFile")
		}
		return (*mm_results).s1, (*mm_results).s2, (*mm_results).ta1, (*mm_results).m1, (*mm_results).sa1, (*mm_results).err
	}
	if mmGetChunksByFile.funcGetChunksByFile != nil {
		return mmGetChunksByFile.funcGetChunksByFile(ctx, kp1)
	}
	mmGetChunksByFile.t.Fatalf("Unexpected call to ServiceMock.GetChunksByFile. %v %v", ctx, kp1)
	return
}

// GetChunksByFileAfterCounter returns a count of finished ServiceMock.GetChunksByFile invocations
func (mmGetChunksByFile *ServiceMock) GetChunksByFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChunksByFile.afterGetChunksByFileCounter)
}

// GetChunksByFileBeforeCounter returns a count of ServiceMock.GetChunksByFile invocations
func (mmGetChunksByFile *ServiceMock) GetChunksByFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChunksByFile.beforeGetChunksByFileCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetChunksByFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChunksByFile *mServiceMockGetChunksByFile) Calls() []*ServiceMockGetChunksByFileParams {
	mmGetChunksByFile.mutex.RLock()

	argCopy := make([]*ServiceMockGetChunksByFileParams, len(mmGetChunksByFile.callArgs))
	copy(argCopy, mmGetChunksByFile.callArgs)

	mmGetChunksByFile.mutex.RUnlock()

	return argCopy
}

// MinimockGetChunksByFileDone returns true if the count of the GetChunksByFile invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetChunksByFileDone() bool {
	if m.GetChunksByFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetChunksByFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetChunksByFileMock.invocationsDone()
}

// MinimockGetChunksByFileInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetChunksByFileInspect() {
	for _, e := range m.GetChunksByFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetChunksByFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetChunksByFileCounter := mm_atomic.LoadUint64(&m.afterGetChunksByFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetChunksByFileMock.defaultExpectation != nil && afterGetChunksByFileCounter < 1 {
		if m.GetChunksByFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetChunksByFile at\n%s", m.GetChunksByFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetChunksByFile at\n%s with params: %#v", m.GetChunksByFileMock.defaultExpectation.expectationOrigins.origin, *m.GetChunksByFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChunksByFile != nil && afterGetChunksByFileCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetChunksByFile at\n%s", m.funcGetChunksByFileOrigin)
	}

	if !m.GetChunksByFileMock.invocationsDone() && afterGetChunksByFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetChunksByFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetChunksByFileMock.expectedInvocations), m.GetChunksByFileMock.expectedInvocationsOrigin, afterGetChunksByFileCounter)
	}
}

type mServiceMockGetDownloadURL struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetDownloadURLExpectation
	expectations       []*ServiceMockGetDownloadURLExpectation

	callArgs []*ServiceMockGetDownloadURLParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetDownloadURLExpectation specifies expectation struct of the Service.GetDownloadURL
type ServiceMockGetDownloadURLExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetDownloadURLParams
	paramPtrs          *ServiceMockGetDownloadURLParamPtrs
	expectationOrigins ServiceMockGetDownloadURLExpectationOrigins
	results            *ServiceMockGetDownloadURLResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetDownloadURLParams contains parameters of the Service.GetDownloadURL
type ServiceMockGetDownloadURLParams struct {
	ctx context.Context
	gp1 *artifactpb.GetObjectDownloadURLRequest
	u1  uuid.UUID
	s1  string
}

// ServiceMockGetDownloadURLParamPtrs contains pointers to parameters of the Service.GetDownloadURL
type ServiceMockGetDownloadURLParamPtrs struct {
	ctx *context.Context
	gp1 **artifactpb.GetObjectDownloadURLRequest
	u1  *uuid.UUID
	s1  *string
}

// ServiceMockGetDownloadURLResults contains results of the Service.GetDownloadURL
type ServiceMockGetDownloadURLResults struct {
	gp2 *artifactpb.GetObjectDownloadURLResponse
	err error
}

// ServiceMockGetDownloadURLOrigins contains origins of expectations of the Service.GetDownloadURL
type ServiceMockGetDownloadURLExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
	originU1  string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetDownloadURL *mServiceMockGetDownloadURL) Optional() *mServiceMockGetDownloadURL {
	mmGetDownloadURL.optional = true
	return mmGetDownloadURL
}

// Expect sets up expected params for Service.GetDownloadURL
func (mmGetDownloadURL *mServiceMockGetDownloadURL) Expect(ctx context.Context, gp1 *artifactpb.GetObjectDownloadURLRequest, u1 uuid.UUID, s1 string) *mServiceMockGetDownloadURL {
	if mmGetDownloadURL.mock.funcGetDownloadURL != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Set")
	}

	if mmGetDownloadURL.defaultExpectation == nil {
		mmGetDownloadURL.defaultExpectation = &ServiceMockGetDownloadURLExpectation{}
	}

	if mmGetDownloadURL.defaultExpectation.paramPtrs != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by ExpectParams functions")
	}

	mmGetDownloadURL.defaultExpectation.params = &ServiceMockGetDownloadURLParams{ctx, gp1, u1, s1}
	mmGetDownloadURL.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetDownloadURL.expectations {
		if minimock.Equal(e.params, mmGetDownloadURL.defaultExpectation.params) {
			mmGetDownloadURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetDownloadURL.defaultExpectation.params)
		}
	}

	return mmGetDownloadURL
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetDownloadURL
func (mmGetDownloadURL *mServiceMockGetDownloadURL) ExpectCtxParam1(ctx context.Context) *mServiceMockGetDownloadURL {
	if mmGetDownloadURL.mock.funcGetDownloadURL != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Set")
	}

	if mmGetDownloadURL.defaultExpectation == nil {
		mmGetDownloadURL.defaultExpectation = &ServiceMockGetDownloadURLExpectation{}
	}

	if mmGetDownloadURL.defaultExpectation.params != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Expect")
	}

	if mmGetDownloadURL.defaultExpectation.paramPtrs == nil {
		mmGetDownloadURL.defaultExpectation.paramPtrs = &ServiceMockGetDownloadURLParamPtrs{}
	}
	mmGetDownloadURL.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetDownloadURL.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetDownloadURL
}

// ExpectGp1Param2 sets up expected param gp1 for Service.GetDownloadURL
func (mmGetDownloadURL *mServiceMockGetDownloadURL) ExpectGp1Param2(gp1 *artifactpb.GetObjectDownloadURLRequest) *mServiceMockGetDownloadURL {
	if mmGetDownloadURL.mock.funcGetDownloadURL != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Set")
	}

	if mmGetDownloadURL.defaultExpectation == nil {
		mmGetDownloadURL.defaultExpectation = &ServiceMockGetDownloadURLExpectation{}
	}

	if mmGetDownloadURL.defaultExpectation.params != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Expect")
	}

	if mmGetDownloadURL.defaultExpectation.paramPtrs == nil {
		mmGetDownloadURL.defaultExpectation.paramPtrs = &ServiceMockGetDownloadURLParamPtrs{}
	}
	mmGetDownloadURL.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetDownloadURL.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetDownloadURL
}

// ExpectU1Param3 sets up expected param u1 for Service.GetDownloadURL
func (mmGetDownloadURL *mServiceMockGetDownloadURL) ExpectU1Param3(u1 uuid.UUID) *mServiceMockGetDownloadURL {
	if mmGetDownloadURL.mock.funcGetDownloadURL != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Set")
	}

	if mmGetDownloadURL.defaultExpectation == nil {
		mmGetDownloadURL.defaultExpectation = &ServiceMockGetDownloadURLExpectation{}
	}

	if mmGetDownloadURL.defaultExpectation.params != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Expect")
	}

	if mmGetDownloadURL.defaultExpectation.paramPtrs == nil {
		mmGetDownloadURL.defaultExpectation.paramPtrs = &ServiceMockGetDownloadURLParamPtrs{}
	}
	mmGetDownloadURL.defaultExpectation.paramPtrs.u1 = &u1
	mmGetDownloadURL.defaultExpectation.expectationOrigins.originU1 = minimock.CallerInfo(1)

	return mmGetDownloadURL
}

// ExpectS1Param4 sets up expected param s1 for Service.GetDownloadURL
func (mmGetDownloadURL *mServiceMockGetDownloadURL) ExpectS1Param4(s1 string) *mServiceMockGetDownloadURL {
	if mmGetDownloadURL.mock.funcGetDownloadURL != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Set")
	}

	if mmGetDownloadURL.defaultExpectation == nil {
		mmGetDownloadURL.defaultExpectation = &ServiceMockGetDownloadURLExpectation{}
	}

	if mmGetDownloadURL.defaultExpectation.params != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Expect")
	}

	if mmGetDownloadURL.defaultExpectation.paramPtrs == nil {
		mmGetDownloadURL.defaultExpectation.paramPtrs = &ServiceMockGetDownloadURLParamPtrs{}
	}
	mmGetDownloadURL.defaultExpectation.paramPtrs.s1 = &s1
	mmGetDownloadURL.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmGetDownloadURL
}

// Inspect accepts an inspector function that has same arguments as the Service.GetDownloadURL
func (mmGetDownloadURL *mServiceMockGetDownloadURL) Inspect(f func(ctx context.Context, gp1 *artifactpb.GetObjectDownloadURLRequest, u1 uuid.UUID, s1 string)) *mServiceMockGetDownloadURL {
	if mmGetDownloadURL.mock.inspectFuncGetDownloadURL != nil {
		mmGetDownloadURL.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetDownloadURL")
	}

	mmGetDownloadURL.mock.inspectFuncGetDownloadURL = f

	return mmGetDownloadURL
}

// Return sets up results that will be returned by Service.GetDownloadURL
func (mmGetDownloadURL *mServiceMockGetDownloadURL) Return(gp2 *artifactpb.GetObjectDownloadURLResponse, err error) *ServiceMock {
	if mmGetDownloadURL.mock.funcGetDownloadURL != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Set")
	}

	if mmGetDownloadURL.defaultExpectation == nil {
		mmGetDownloadURL.defaultExpectation = &ServiceMockGetDownloadURLExpectation{mock: mmGetDownloadURL.mock}
	}
	mmGetDownloadURL.defaultExpectation.results = &ServiceMockGetDownloadURLResults{gp2, err}
	mmGetDownloadURL.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetDownloadURL.mock
}

// Set uses given function f to mock the Service.GetDownloadURL method
func (mmGetDownloadURL *mServiceMockGetDownloadURL) Set(f func(ctx context.Context, gp1 *artifactpb.GetObjectDownloadURLRequest, u1 uuid.UUID, s1 string) (gp2 *artifactpb.GetObjectDownloadURLResponse, err error)) *ServiceMock {
	if mmGetDownloadURL.defaultExpectation != nil {
		mmGetDownloadURL.mock.t.Fatalf("Default expectation is already set for the Service.GetDownloadURL method")
	}

	if len(mmGetDownloadURL.expectations) > 0 {
		mmGetDownloadURL.mock.t.Fatalf("Some expectations are already set for the Service.GetDownloadURL method")
	}

	mmGetDownloadURL.mock.funcGetDownloadURL = f
	mmGetDownloadURL.mock.funcGetDownloadURLOrigin = minimock.CallerInfo(1)
	return mmGetDownloadURL.mock
}

// When sets expectation for the Service.GetDownloadURL which will trigger the result defined by the following
// Then helper
func (mmGetDownloadURL *mServiceMockGetDownloadURL) When(ctx context.Context, gp1 *artifactpb.GetObjectDownloadURLRequest, u1 uuid.UUID, s1 string) *ServiceMockGetDownloadURLExpectation {
	if mmGetDownloadURL.mock.funcGetDownloadURL != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Set")
	}

	expectation := &ServiceMockGetDownloadURLExpectation{
		mock:               mmGetDownloadURL.mock,
		params:             &ServiceMockGetDownloadURLParams{ctx, gp1, u1, s1},
		expectationOrigins: ServiceMockGetDownloadURLExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetDownloadURL.expectations = append(mmGetDownloadURL.expectations, expectation)
	return expectation
}

// Then sets up Service.GetDownloadURL return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetDownloadURLExpectation) Then(gp2 *artifactpb.GetObjectDownloadURLResponse, err error) *ServiceMock {
	e.results = &ServiceMockGetDownloadURLResults{gp2, err}
	return e.mock
}

// Times sets number of times Service.GetDownloadURL should be invoked
func (mmGetDownloadURL *mServiceMockGetDownloadURL) Times(n uint64) *mServiceMockGetDownloadURL {
	if n == 0 {
		mmGetDownloadURL.mock.t.Fatalf("Times of ServiceMock.GetDownloadURL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetDownloadURL.expectedInvocations, n)
	mmGetDownloadURL.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetDownloadURL
}

func (mmGetDownloadURL *mServiceMockGetDownloadURL) invocationsDone() bool {
	if len(mmGetDownloadURL.expectations) == 0 && mmGetDownloadURL.defaultExpectation == nil && mmGetDownloadURL.mock.funcGetDownloadURL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetDownloadURL.mock.afterGetDownloadURLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetDownloadURL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetDownloadURL implements mm_service.Service
func (mmGetDownloadURL *ServiceMock) GetDownloadURL(ctx context.Context, gp1 *artifactpb.GetObjectDownloadURLRequest, u1 uuid.UUID, s1 string) (gp2 *artifactpb.GetObjectDownloadURLResponse, err error) {
	mm_atomic.AddUint64(&mmGetDownloadURL.beforeGetDownloadURLCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDownloadURL.afterGetDownloadURLCounter, 1)

	mmGetDownloadURL.t.Helper()

	if mmGetDownloadURL.inspectFuncGetDownloadURL != nil {
		mmGetDownloadURL.inspectFuncGetDownloadURL(ctx, gp1, u1, s1)
	}

	mm_params := ServiceMockGetDownloadURLParams{ctx, gp1, u1, s1}

	// Record call args
	mmGetDownloadURL.GetDownloadURLMock.mutex.Lock()
	mmGetDownloadURL.GetDownloadURLMock.callArgs = append(mmGetDownloadURL.GetDownloadURLMock.callArgs, &mm_params)
	mmGetDownloadURL.GetDownloadURLMock.mutex.Unlock()

	for _, e := range mmGetDownloadURL.GetDownloadURLMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetDownloadURL.GetDownloadURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDownloadURL.GetDownloadURLMock.defaultExpectation.Counter, 1)
		mm_want := mmGetDownloadURL.GetDownloadURLMock.defaultExpectation.params
		mm_want_ptrs := mmGetDownloadURL.GetDownloadURLMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetDownloadURLParams{ctx, gp1, u1, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetDownloadURL.t.Errorf("ServiceMock.GetDownloadURL got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetDownloadURL.GetDownloadURLMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetDownloadURL.t.Errorf("ServiceMock.GetDownloadURL got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetDownloadURL.GetDownloadURLMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmGetDownloadURL.t.Errorf("ServiceMock.GetDownloadURL got unexpected parameter u1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetDownloadURL.GetDownloadURLMock.defaultExpectation.expectationOrigins.originU1, *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmGetDownloadURL.t.Errorf("ServiceMock.GetDownloadURL got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetDownloadURL.GetDownloadURLMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetDownloadURL.t.Errorf("ServiceMock.GetDownloadURL got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetDownloadURL.GetDownloadURLMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetDownloadURL.GetDownloadURLMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDownloadURL.t.Fatal("No results are set for the ServiceMock.GetDownloadURL")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetDownloadURL.funcGetDownloadURL != nil {
		return mmGetDownloadURL.funcGetDownloadURL(ctx, gp1, u1, s1)
	}
	mmGetDownloadURL.t.Fatalf("Unexpected call to ServiceMock.GetDownloadURL. %v %v %v %v", ctx, gp1, u1, s1)
	return
}

// GetDownloadURLAfterCounter returns a count of finished ServiceMock.GetDownloadURL invocations
func (mmGetDownloadURL *ServiceMock) GetDownloadURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDownloadURL.afterGetDownloadURLCounter)
}

// GetDownloadURLBeforeCounter returns a count of ServiceMock.GetDownloadURL invocations
func (mmGetDownloadURL *ServiceMock) GetDownloadURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDownloadURL.beforeGetDownloadURLCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetDownloadURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetDownloadURL *mServiceMockGetDownloadURL) Calls() []*ServiceMockGetDownloadURLParams {
	mmGetDownloadURL.mutex.RLock()

	argCopy := make([]*ServiceMockGetDownloadURLParams, len(mmGetDownloadURL.callArgs))
	copy(argCopy, mmGetDownloadURL.callArgs)

	mmGetDownloadURL.mutex.RUnlock()

	return argCopy
}

// MinimockGetDownloadURLDone returns true if the count of the GetDownloadURL invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetDownloadURLDone() bool {
	if m.GetDownloadURLMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetDownloadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetDownloadURLMock.invocationsDone()
}

// MinimockGetDownloadURLInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetDownloadURLInspect() {
	for _, e := range m.GetDownloadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetDownloadURL at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetDownloadURLCounter := mm_atomic.LoadUint64(&m.afterGetDownloadURLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetDownloadURLMock.defaultExpectation != nil && afterGetDownloadURLCounter < 1 {
		if m.GetDownloadURLMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetDownloadURL at\n%s", m.GetDownloadURLMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetDownloadURL at\n%s with params: %#v", m.GetDownloadURLMock.defaultExpectation.expectationOrigins.origin, *m.GetDownloadURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDownloadURL != nil && afterGetDownloadURLCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetDownloadURL at\n%s", m.funcGetDownloadURLOrigin)
	}

	if !m.GetDownloadURLMock.invocationsDone() && afterGetDownloadURLCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetDownloadURL at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetDownloadURLMock.expectedInvocations), m.GetDownloadURLMock.expectedInvocationsOrigin, afterGetDownloadURLCounter)
	}
}

type mServiceMockGetFilesByPaths struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetFilesByPathsExpectation
	expectations       []*ServiceMockGetFilesByPathsExpectation

	callArgs []*ServiceMockGetFilesByPathsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetFilesByPathsExpectation specifies expectation struct of the Service.GetFilesByPaths
type ServiceMockGetFilesByPathsExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetFilesByPathsParams
	paramPtrs          *ServiceMockGetFilesByPathsParamPtrs
	expectationOrigins ServiceMockGetFilesByPathsExpectationOrigins
	results            *ServiceMockGetFilesByPathsResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetFilesByPathsParams contains parameters of the Service.GetFilesByPaths
type ServiceMockGetFilesByPathsParams struct {
	ctx context.Context
	s1  string
	sa1 []string
}

// ServiceMockGetFilesByPathsParamPtrs contains pointers to parameters of the Service.GetFilesByPaths
type ServiceMockGetFilesByPathsParamPtrs struct {
	ctx *context.Context
	s1  *string
	sa1 *[]string
}

// ServiceMockGetFilesByPathsResults contains results of the Service.GetFilesByPaths
type ServiceMockGetFilesByPathsResults struct {
	fa1 []mm_service.FileContent
	err error
}

// ServiceMockGetFilesByPathsOrigins contains origins of expectations of the Service.GetFilesByPaths
type ServiceMockGetFilesByPathsExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
	originSa1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) Optional() *mServiceMockGetFilesByPaths {
	mmGetFilesByPaths.optional = true
	return mmGetFilesByPaths
}

// Expect sets up expected params for Service.GetFilesByPaths
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) Expect(ctx context.Context, s1 string, sa1 []string) *mServiceMockGetFilesByPaths {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by Set")
	}

	if mmGetFilesByPaths.defaultExpectation == nil {
		mmGetFilesByPaths.defaultExpectation = &ServiceMockGetFilesByPathsExpectation{}
	}

	if mmGetFilesByPaths.defaultExpectation.paramPtrs != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by ExpectParams functions")
	}

	mmGetFilesByPaths.defaultExpectation.params = &ServiceMockGetFilesByPathsParams{ctx, s1, sa1}
	mmGetFilesByPaths.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetFilesByPaths.expectations {
		if minimock.Equal(e.params, mmGetFilesByPaths.defaultExpectation.params) {
			mmGetFilesByPaths.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFilesByPaths.defaultExpectation.params)
		}
	}

	return mmGetFilesByPaths
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetFilesByPaths
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) ExpectCtxParam1(ctx context.Context) *mServiceMockGetFilesByPaths {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by Set")
	}

	if mmGetFilesByPaths.defaultExpectation == nil {
		mmGetFilesByPaths.defaultExpectation = &ServiceMockGetFilesByPathsExpectation{}
	}

	if mmGetFilesByPaths.defaultExpectation.params != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by Expect")
	}

	if mmGetFilesByPaths.defaultExpectation.paramPtrs == nil {
		mmGetFilesByPaths.defaultExpectation.paramPtrs = &ServiceMockGetFilesByPathsParamPtrs{}
	}
	mmGetFilesByPaths.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetFilesByPaths.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetFilesByPaths
}

// ExpectS1Param2 sets up expected param s1 for Service.GetFilesByPaths
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) ExpectS1Param2(s1 string) *mServiceMockGetFilesByPaths {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by Set")
	}

	if mmGetFilesByPaths.defaultExpectation == nil {
		mmGetFilesByPaths.defaultExpectation = &ServiceMockGetFilesByPathsExpectation{}
	}

	if mmGetFilesByPaths.defaultExpectation.params != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by Expect")
	}

	if mmGetFilesByPaths.defaultExpectation.paramPtrs == nil {
		mmGetFilesByPaths.defaultExpectation.paramPtrs = &ServiceMockGetFilesByPathsParamPtrs{}
	}
	mmGetFilesByPaths.defaultExpectation.paramPtrs.s1 = &s1
	mmGetFilesByPaths.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmGetFilesByPaths
}

// ExpectSa1Param3 sets up expected param sa1 for Service.GetFilesByPaths
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) ExpectSa1Param3(sa1 []string) *mServiceMockGetFilesByPaths {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by Set")
	}

	if mmGetFilesByPaths.defaultExpectation == nil {
		mmGetFilesByPaths.defaultExpectation = &ServiceMockGetFilesByPathsExpectation{}
	}

	if mmGetFilesByPaths.defaultExpectation.params != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by Expect")
	}

	if mmGetFilesByPaths.defaultExpectation.paramPtrs == nil {
		mmGetFilesByPaths.defaultExpectation.paramPtrs = &ServiceMockGetFilesByPathsParamPtrs{}
	}
	mmGetFilesByPaths.defaultExpectation.paramPtrs.sa1 = &sa1
	mmGetFilesByPaths.defaultExpectation.expectationOrigins.originSa1 = minimock.CallerInfo(1)

	return mmGetFilesByPaths
}

// Inspect accepts an inspector function that has same arguments as the Service.GetFilesByPaths
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) Inspect(f func(ctx context.Context, s1 string, sa1 []string)) *mServiceMockGetFilesByPaths {
	if mmGetFilesByPaths.mock.inspectFuncGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetFilesByPaths")
	}

	mmGetFilesByPaths.mock.inspectFuncGetFilesByPaths = f

	return mmGetFilesByPaths
}

// Return sets up results that will be returned by Service.GetFilesByPaths
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) Return(fa1 []mm_service.FileContent, err error) *ServiceMock {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by Set")
	}

	if mmGetFilesByPaths.defaultExpectation == nil {
		mmGetFilesByPaths.defaultExpectation = &ServiceMockGetFilesByPathsExpectation{mock: mmGetFilesByPaths.mock}
	}
	mmGetFilesByPaths.defaultExpectation.results = &ServiceMockGetFilesByPathsResults{fa1, err}
	mmGetFilesByPaths.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetFilesByPaths.mock
}

// Set uses given function f to mock the Service.GetFilesByPaths method
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) Set(f func(ctx context.Context, s1 string, sa1 []string) (fa1 []mm_service.FileContent, err error)) *ServiceMock {
	if mmGetFilesByPaths.defaultExpectation != nil {
		mmGetFilesByPaths.mock.t.Fatalf("Default expectation is already set for the Service.GetFilesByPaths method")
	}

	if len(mmGetFilesByPaths.expectations) > 0 {
		mmGetFilesByPaths.mock.t.Fatalf("Some expectations are already set for the Service.GetFilesByPaths method")
	}

	mmGetFilesByPaths.mock.funcGetFilesByPaths = f
	mmGetFilesByPaths.mock.funcGetFilesByPathsOrigin = minimock.CallerInfo(1)
	return mmGetFilesByPaths.mock
}

// When sets expectation for the Service.GetFilesByPaths which will trigger the result defined by the following
// Then helper
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) When(ctx context.Context, s1 string, sa1 []string) *ServiceMockGetFilesByPathsExpectation {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by Set")
	}

	expectation := &ServiceMockGetFilesByPathsExpectation{
		mock:               mmGetFilesByPaths.mock,
		params:             &ServiceMockGetFilesByPathsParams{ctx, s1, sa1},
		expectationOrigins: ServiceMockGetFilesByPathsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetFilesByPaths.expectations = append(mmGetFilesByPaths.expectations, expectation)
	return expectation
}

// Then sets up Service.GetFilesByPaths return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetFilesByPathsExpectation) Then(fa1 []mm_service.FileContent, err error) *ServiceMock {
	e.results = &ServiceMockGetFilesByPathsResults{fa1, err}
	return e.mock
}

// Times sets number of times Service.GetFilesByPaths should be invoked
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) Times(n uint64) *mServiceMockGetFilesByPaths {
	if n == 0 {
		mmGetFilesByPaths.mock.t.Fatalf("Times of ServiceMock.GetFilesByPaths mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFilesByPaths.expectedInvocations, n)
	mmGetFilesByPaths.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetFilesByPaths
}

func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) invocationsDone() bool {
	if len(mmGetFilesByPaths.expectations) == 0 && mmGetFilesByPaths.defaultExpectation == nil && mmGetFilesByPaths.mock.funcGetFilesByPaths == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFilesByPaths.mock.afterGetFilesByPathsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFilesByPaths.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFilesByPaths implements mm_service.Service
func (mmGetFilesByPaths *ServiceMock) GetFilesByPaths(ctx context.Context, s1 string, sa1 []string) (fa1 []mm_service.FileContent, err error) {
	mm_atomic.AddUint64(&mmGetFilesByPaths.beforeGetFilesByPathsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFilesByPaths.afterGetFilesByPathsCounter, 1)

	mmGetFilesByPaths.t.Helper()

	if mmGetFilesByPaths.inspectFuncGetFilesByPaths != nil {
		mmGetFilesByPaths.inspectFuncGetFilesByPaths(ctx, s1, sa1)
	}

	mm_params := ServiceMockGetFilesByPathsParams{ctx, s1, sa1}

	// Record call args
	mmGetFilesByPaths.GetFilesByPathsMock.mutex.Lock()
	mmGetFilesByPaths.GetFilesByPathsMock.callArgs = append(mmGetFilesByPaths.GetFilesByPathsMock.callArgs, &mm_params)
	mmGetFilesByPaths.GetFilesByPathsMock.mutex.Unlock()

	for _, e := range mmGetFilesByPaths.GetFilesByPathsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.fa1, e.results.err
		}
	}

	if mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.params
		mm_want_ptrs := mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetFilesByPathsParams{ctx, s1, sa1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFilesByPaths.t.Errorf("ServiceMock.GetFilesByPaths got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmGetFilesByPaths.t.Errorf("ServiceMock.GetFilesByPaths got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

			if mm_want_ptrs.sa1 != nil && !minimock.Equal(*mm_want_ptrs.sa1, mm_got.sa1) {
				mmGetFilesByPaths.t.Errorf("ServiceMock.GetFilesByPaths got unexpected parameter sa1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.expectationOrigins.originSa1, *mm_want_ptrs.sa1, mm_got.sa1, minimock.Diff(*mm_want_ptrs.sa1, mm_got.sa1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFilesByPaths.t.Errorf("ServiceMock.GetFilesByPaths got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFilesByPaths.t.Fatal("No results are set for the ServiceMock.GetFilesByPaths")
		}
		return (*mm_results).fa1, (*mm_results).err
	}
	if mmGetFilesByPaths.funcGetFilesByPaths != nil {
		return mmGetFilesByPaths.funcGetFilesByPaths(ctx, s1, sa1)
	}
	mmGetFilesByPaths.t.Fatalf("Unexpected call to ServiceMock.GetFilesByPaths. %v %v %v", ctx, s1, sa1)
	return
}

// GetFilesByPathsAfterCounter returns a count of finished ServiceMock.GetFilesByPaths invocations
func (mmGetFilesByPaths *ServiceMock) GetFilesByPathsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFilesByPaths.afterGetFilesByPathsCounter)
}

// GetFilesByPathsBeforeCounter returns a count of ServiceMock.GetFilesByPaths invocations
func (mmGetFilesByPaths *ServiceMock) GetFilesByPathsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFilesByPaths.beforeGetFilesByPathsCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetFilesByPaths.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) Calls() []*ServiceMockGetFilesByPathsParams {
	mmGetFilesByPaths.mutex.RLock()

	argCopy := make([]*ServiceMockGetFilesByPathsParams, len(mmGetFilesByPaths.callArgs))
	copy(argCopy, mmGetFilesByPaths.callArgs)

	mmGetFilesByPaths.mutex.RUnlock()

	return argCopy
}

// MinimockGetFilesByPathsDone returns true if the count of the GetFilesByPaths invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetFilesByPathsDone() bool {
	if m.GetFilesByPathsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFilesByPathsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFilesByPathsMock.invocationsDone()
}

// MinimockGetFilesByPathsInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetFilesByPathsInspect() {
	for _, e := range m.GetFilesByPathsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetFilesByPaths at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetFilesByPathsCounter := mm_atomic.LoadUint64(&m.afterGetFilesByPathsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFilesByPathsMock.defaultExpectation != nil && afterGetFilesByPathsCounter < 1 {
		if m.GetFilesByPathsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetFilesByPaths at\n%s", m.GetFilesByPathsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetFilesByPaths at\n%s with params: %#v", m.GetFilesByPathsMock.defaultExpectation.expectationOrigins.origin, *m.GetFilesByPathsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFilesByPaths != nil && afterGetFilesByPathsCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetFilesByPaths at\n%s", m.funcGetFilesByPathsOrigin)
	}

	if !m.GetFilesByPathsMock.invocationsDone() && afterGetFilesByPathsCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetFilesByPaths at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetFilesByPathsMock.expectedInvocations), m.GetFilesByPathsMock.expectedInvocationsOrigin, afterGetFilesByPathsCounter)
	}
}

type mServiceMockGetFilesWorkflow struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetFilesWorkflowExpectation
	expectations       []*ServiceMockGetFilesWorkflowExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetFilesWorkflowExpectation specifies expectation struct of the Service.GetFilesWorkflow
type ServiceMockGetFilesWorkflowExpectation struct {
	mock *ServiceMock

	results      *ServiceMockGetFilesWorkflowResults
	returnOrigin string
	Counter      uint64
}

// ServiceMockGetFilesWorkflowResults contains results of the Service.GetFilesWorkflow
type ServiceMockGetFilesWorkflowResults struct {
	g1 mm_service.GetFilesWorkflow
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFilesWorkflow *mServiceMockGetFilesWorkflow) Optional() *mServiceMockGetFilesWorkflow {
	mmGetFilesWorkflow.optional = true
	return mmGetFilesWorkflow
}

// Expect sets up expected params for Service.GetFilesWorkflow
func (mmGetFilesWorkflow *mServiceMockGetFilesWorkflow) Expect() *mServiceMockGetFilesWorkflow {
	if mmGetFilesWorkflow.mock.funcGetFilesWorkflow != nil {
		mmGetFilesWorkflow.mock.t.Fatalf("ServiceMock.GetFilesWorkflow mock is already set by Set")
	}

	if mmGetFilesWorkflow.defaultExpectation == nil {
		mmGetFilesWorkflow.defaultExpectation = &ServiceMockGetFilesWorkflowExpectation{}
	}

	return mmGetFilesWorkflow
}

// Inspect accepts an inspector function that has same arguments as the Service.GetFilesWorkflow
func (mmGetFilesWorkflow *mServiceMockGetFilesWorkflow) Inspect(f func()) *mServiceMockGetFilesWorkflow {
	if mmGetFilesWorkflow.mock.inspectFuncGetFilesWorkflow != nil {
		mmGetFilesWorkflow.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetFilesWorkflow")
	}

	mmGetFilesWorkflow.mock.inspectFuncGetFilesWorkflow = f

	return mmGetFilesWorkflow
}

// Return sets up results that will be returned by Service.GetFilesWorkflow
func (mmGetFilesWorkflow *mServiceMockGetFilesWorkflow) Return(g1 mm_service.GetFilesWorkflow) *ServiceMock {
	if mmGetFilesWorkflow.mock.funcGetFilesWorkflow != nil {
		mmGetFilesWorkflow.mock.t.Fatalf("ServiceMock.GetFilesWorkflow mock is already set by Set")
	}

	if mmGetFilesWorkflow.defaultExpectation == nil {
		mmGetFilesWorkflow.defaultExpectation = &ServiceMockGetFilesWorkflowExpectation{mock: mmGetFilesWorkflow.mock}
	}
	mmGetFilesWorkflow.defaultExpectation.results = &ServiceMockGetFilesWorkflowResults{g1}
	mmGetFilesWorkflow.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetFilesWorkflow.mock
}

// Set uses given function f to mock the Service.GetFilesWorkflow method
func (mmGetFilesWorkflow *mServiceMockGetFilesWorkflow) Set(f func() (g1 mm_service.GetFilesWorkflow)) *ServiceMock {
	if mmGetFilesWorkflow.defaultExpectation != nil {
		mmGetFilesWorkflow.mock.t.Fatalf("Default expectation is already set for the Service.GetFilesWorkflow method")
	}

	if len(mmGetFilesWorkflow.expectations) > 0 {
		mmGetFilesWorkflow.mock.t.Fatalf("Some expectations are already set for the Service.GetFilesWorkflow method")
	}

	mmGetFilesWorkflow.mock.funcGetFilesWorkflow = f
	mmGetFilesWorkflow.mock.funcGetFilesWorkflowOrigin = minimock.CallerInfo(1)
	return mmGetFilesWorkflow.mock
}

// Times sets number of times Service.GetFilesWorkflow should be invoked
func (mmGetFilesWorkflow *mServiceMockGetFilesWorkflow) Times(n uint64) *mServiceMockGetFilesWorkflow {
	if n == 0 {
		mmGetFilesWorkflow.mock.t.Fatalf("Times of ServiceMock.GetFilesWorkflow mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFilesWorkflow.expectedInvocations, n)
	mmGetFilesWorkflow.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetFilesWorkflow
}

func (mmGetFilesWorkflow *mServiceMockGetFilesWorkflow) invocationsDone() bool {
	if len(mmGetFilesWorkflow.expectations) == 0 && mmGetFilesWorkflow.defaultExpectation == nil && mmGetFilesWorkflow.mock.funcGetFilesWorkflow == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFilesWorkflow.mock.afterGetFilesWorkflowCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFilesWorkflow.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFilesWorkflow implements mm_service.Service
func (mmGetFilesWorkflow *ServiceMock) GetFilesWorkflow() (g1 mm_service.GetFilesWorkflow) {
	mm_atomic.AddUint64(&mmGetFilesWorkflow.beforeGetFilesWorkflowCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFilesWorkflow.afterGetFilesWorkflowCounter, 1)

	mmGetFilesWorkflow.t.Helper()

	if mmGetFilesWorkflow.inspectFuncGetFilesWorkflow != nil {
		mmGetFilesWorkflow.inspectFuncGetFilesWorkflow()
	}

	if mmGetFilesWorkflow.GetFilesWorkflowMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFilesWorkflow.GetFilesWorkflowMock.defaultExpectation.Counter, 1)

		mm_results := mmGetFilesWorkflow.GetFilesWorkflowMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFilesWorkflow.t.Fatal("No results are set for the ServiceMock.GetFilesWorkflow")
		}
		return (*mm_results).g1
	}
	if mmGetFilesWorkflow.funcGetFilesWorkflow != nil {
		return mmGetFilesWorkflow.funcGetFilesWorkflow()
	}
	mmGetFilesWorkflow.t.Fatalf("Unexpected call to ServiceMock.GetFilesWorkflow.")
	return
}

// GetFilesWorkflowAfterCounter returns a count of finished ServiceMock.GetFilesWorkflow invocations
func (mmGetFilesWorkflow *ServiceMock) GetFilesWorkflowAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFilesWorkflow.afterGetFilesWorkflowCounter)
}

// GetFilesWorkflowBeforeCounter returns a count of ServiceMock.GetFilesWorkflow invocations
func (mmGetFilesWorkflow *ServiceMock) GetFilesWorkflowBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFilesWorkflow.beforeGetFilesWorkflowCounter)
}

// MinimockGetFilesWorkflowDone returns true if the count of the GetFilesWorkflow invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetFilesWorkflowDone() bool {
	if m.GetFilesWorkflowMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFilesWorkflowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFilesWorkflowMock.invocationsDone()
}

// MinimockGetFilesWorkflowInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetFilesWorkflowInspect() {
	for _, e := range m.GetFilesWorkflowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServiceMock.GetFilesWorkflow")
		}
	}

	afterGetFilesWorkflowCounter := mm_atomic.LoadUint64(&m.afterGetFilesWorkflowCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFilesWorkflowMock.defaultExpectation != nil && afterGetFilesWorkflowCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetFilesWorkflow at\n%s", m.GetFilesWorkflowMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFilesWorkflow != nil && afterGetFilesWorkflowCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetFilesWorkflow at\n%s", m.funcGetFilesWorkflowOrigin)
	}

	if !m.GetFilesWorkflowMock.invocationsDone() && afterGetFilesWorkflowCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetFilesWorkflow at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetFilesWorkflowMock.expectedInvocations), m.GetFilesWorkflowMock.expectedInvocationsOrigin, afterGetFilesWorkflowCounter)
	}
}

type mServiceMockGetNamespaceAndCheckPermission struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetNamespaceAndCheckPermissionExpectation
	expectations       []*ServiceMockGetNamespaceAndCheckPermissionExpectation

	callArgs []*ServiceMockGetNamespaceAndCheckPermissionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetNamespaceAndCheckPermissionExpectation specifies expectation struct of the Service.GetNamespaceAndCheckPermission
type ServiceMockGetNamespaceAndCheckPermissionExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetNamespaceAndCheckPermissionParams
	paramPtrs          *ServiceMockGetNamespaceAndCheckPermissionParamPtrs
	expectationOrigins ServiceMockGetNamespaceAndCheckPermissionExpectationOrigins
	results            *ServiceMockGetNamespaceAndCheckPermissionResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetNamespaceAndCheckPermissionParams contains parameters of the Service.GetNamespaceAndCheckPermission
type ServiceMockGetNamespaceAndCheckPermissionParams struct {
	ctx context.Context
	s1  string
}

// ServiceMockGetNamespaceAndCheckPermissionParamPtrs contains pointers to parameters of the Service.GetNamespaceAndCheckPermission
type ServiceMockGetNamespaceAndCheckPermissionParamPtrs struct {
	ctx *context.Context
	s1  *string
}

// ServiceMockGetNamespaceAndCheckPermissionResults contains results of the Service.GetNamespaceAndCheckPermission
type ServiceMockGetNamespaceAndCheckPermissionResults struct {
	np1 *resource.Namespace
	err error
}

// ServiceMockGetNamespaceAndCheckPermissionOrigins contains origins of expectations of the Service.GetNamespaceAndCheckPermission
type ServiceMockGetNamespaceAndCheckPermissionExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) Optional() *mServiceMockGetNamespaceAndCheckPermission {
	mmGetNamespaceAndCheckPermission.optional = true
	return mmGetNamespaceAndCheckPermission
}

// Expect sets up expected params for Service.GetNamespaceAndCheckPermission
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) Expect(ctx context.Context, s1 string) *mServiceMockGetNamespaceAndCheckPermission {
	if mmGetNamespaceAndCheckPermission.mock.funcGetNamespaceAndCheckPermission != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("ServiceMock.GetNamespaceAndCheckPermission mock is already set by Set")
	}

	if mmGetNamespaceAndCheckPermission.defaultExpectation == nil {
		mmGetNamespaceAndCheckPermission.defaultExpectation = &ServiceMockGetNamespaceAndCheckPermissionExpectation{}
	}

	if mmGetNamespaceAndCheckPermission.defaultExpectation.paramPtrs != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("ServiceMock.GetNamespaceAndCheckPermission mock is already set by ExpectParams functions")
	}

	mmGetNamespaceAndCheckPermission.defaultExpectation.params = &ServiceMockGetNamespaceAndCheckPermissionParams{ctx, s1}
	mmGetNamespaceAndCheckPermission.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetNamespaceAndCheckPermission.expectations {
		if minimock.Equal(e.params, mmGetNamespaceAndCheckPermission.defaultExpectation.params) {
			mmGetNamespaceAndCheckPermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetNamespaceAndCheckPermission.defaultExpectation.params)
		}
	}

	return mmGetNamespaceAndCheckPermission
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetNamespaceAndCheckPermission
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) ExpectCtxParam1(ctx context.Context) *mServiceMockGetNamespaceAndCheckPermission {
	if mmGetNamespaceAndCheckPermission.mock.funcGetNamespaceAndCheckPermission != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("ServiceMock.GetNamespaceAndCheckPermission mock is already set by Set")
	}

	if mmGetNamespaceAndCheckPermission.defaultExpectation == nil {
		mmGetNamespaceAndCheckPermission.defaultExpectation = &ServiceMockGetNamespaceAndCheckPermissionExpectation{}
	}

	if mmGetNamespaceAndCheckPermission.defaultExpectation.params != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("ServiceMock.GetNamespaceAndCheckPermission mock is already set by Expect")
	}

	if mmGetNamespaceAndCheckPermission.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceAndCheckPermission.defaultExpectation.paramPtrs = &ServiceMockGetNamespaceAndCheckPermissionParamPtrs{}
	}
	mmGetNamespaceAndCheckPermission.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetNamespaceAndCheckPermission.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetNamespaceAndCheckPermission
}

// ExpectS1Param2 sets up expected param s1 for Service.GetNamespaceAndCheckPermission
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) ExpectS1Param2(s1 string) *mServiceMockGetNamespaceAndCheckPermission {
	if mmGetNamespaceAndCheckPermission.mock.funcGetNamespaceAndCheckPermission != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("ServiceMock.GetNamespaceAndCheckPermission mock is already set by Set")
	}

	if mmGetNamespaceAndCheckPermission.defaultExpectation == nil {
		mmGetNamespaceAndCheckPermission.defaultExpectation = &ServiceMockGetNamespaceAndCheckPermissionExpectation{}
	}

	if mmGetNamespaceAndCheckPermission.defaultExpectation.params != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("ServiceMock.GetNamespaceAndCheckPermission mock is already set by Expect")
	}

	if mmGetNamespaceAndCheckPermission.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceAndCheckPermission.defaultExpectation.paramPtrs = &ServiceMockGetNamespaceAndCheckPermissionParamPtrs{}
	}
	mmGetNamespaceAndCheckPermission.defaultExpectation.paramPtrs.s1 = &s1
	mmGetNamespaceAndCheckPermission.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmGetNamespaceAndCheckPermission
}

// Inspect accepts an inspector function that has same arguments as the Service.GetNamespaceAndCheckPermission
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) Inspect(f func(ctx context.Context, s1 string)) *mServiceMockGetNamespaceAndCheckPermission {
	if mmGetNamespaceAndCheckPermission.mock.inspectFuncGetNamespaceAndCheckPermission != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetNamespaceAndCheckPermission")
	}

	mmGetNamespaceAndCheckPermission.mock.inspectFuncGetNamespaceAndCheckPermission = f

	return mmGetNamespaceAndCheckPermission
}

// Return sets up results that will be returned by Service.GetNamespaceAndCheckPermission
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) Return(np1 *resource.Namespace, err error) *ServiceMock {
	if mmGetNamespaceAndCheckPermission.mock.funcGetNamespaceAndCheckPermission != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("ServiceMock.GetNamespaceAndCheckPermission mock is already set by Set")
	}

	if mmGetNamespaceAndCheckPermission.defaultExpectation == nil {
		mmGetNamespaceAndCheckPermission.defaultExpectation = &ServiceMockGetNamespaceAndCheckPermissionExpectation{mock: mmGetNamespaceAndCheckPermission.mock}
	}
	mmGetNamespaceAndCheckPermission.defaultExpectation.results = &ServiceMockGetNamespaceAndCheckPermissionResults{np1, err}
	mmGetNamespaceAndCheckPermission.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceAndCheckPermission.mock
}

// Set uses given function f to mock the Service.GetNamespaceAndCheckPermission method
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) Set(f func(ctx context.Context, s1 string) (np1 *resource.Namespace, err error)) *ServiceMock {
	if mmGetNamespaceAndCheckPermission.defaultExpectation != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("Default expectation is already set for the Service.GetNamespaceAndCheckPermission method")
	}

	if len(mmGetNamespaceAndCheckPermission.expectations) > 0 {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("Some expectations are already set for the Service.GetNamespaceAndCheckPermission method")
	}

	mmGetNamespaceAndCheckPermission.mock.funcGetNamespaceAndCheckPermission = f
	mmGetNamespaceAndCheckPermission.mock.funcGetNamespaceAndCheckPermissionOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceAndCheckPermission.mock
}

// When sets expectation for the Service.GetNamespaceAndCheckPermission which will trigger the result defined by the following
// Then helper
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) When(ctx context.Context, s1 string) *ServiceMockGetNamespaceAndCheckPermissionExpectation {
	if mmGetNamespaceAndCheckPermission.mock.funcGetNamespaceAndCheckPermission != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("ServiceMock.GetNamespaceAndCheckPermission mock is already set by Set")
	}

	expectation := &ServiceMockGetNamespaceAndCheckPermissionExpectation{
		mock:               mmGetNamespaceAndCheckPermission.mock,
		params:             &ServiceMockGetNamespaceAndCheckPermissionParams{ctx, s1},
		expectationOrigins: ServiceMockGetNamespaceAndCheckPermissionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetNamespaceAndCheckPermission.expectations = append(mmGetNamespaceAndCheckPermission.expectations, expectation)
	return expectation
}

// Then sets up Service.GetNamespaceAndCheckPermission return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetNamespaceAndCheckPermissionExpectation) Then(np1 *resource.Namespace, err error) *ServiceMock {
	e.results = &ServiceMockGetNamespaceAndCheckPermissionResults{np1, err}
	return e.mock
}

// Times sets number of times Service.GetNamespaceAndCheckPermission should be invoked
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) Times(n uint64) *mServiceMockGetNamespaceAndCheckPermission {
	if n == 0 {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("Times of ServiceMock.GetNamespaceAndCheckPermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetNamespaceAndCheckPermission.expectedInvocations, n)
	mmGetNamespaceAndCheckPermission.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceAndCheckPermission
}

func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) invocationsDone() bool {
	if len(mmGetNamespaceAndCheckPermission.expectations) == 0 && mmGetNamespaceAndCheckPermission.defaultExpectation == nil && mmGetNamespaceAndCheckPermission.mock.funcGetNamespaceAndCheckPermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetNamespaceAndCheckPermission.mock.afterGetNamespaceAndCheckPermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetNamespaceAndCheckPermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetNamespaceAndCheckPermission implements mm_service.Service
func (mmGetNamespaceAndCheckPermission *ServiceMock) GetNamespaceAndCheckPermission(ctx context.Context, s1 string) (np1 *resource.Namespace, err error) {
	mm_atomic.AddUint64(&mmGetNamespaceAndCheckPermission.beforeGetNamespaceAndCheckPermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNamespaceAndCheckPermission.afterGetNamespaceAndCheckPermissionCounter, 1)

	mmGetNamespaceAndCheckPermission.t.Helper()

	if mmGetNamespaceAndCheckPermission.inspectFuncGetNamespaceAndCheckPermission != nil {
		mmGetNamespaceAndCheckPermission.inspectFuncGetNamespaceAndCheckPermission(ctx, s1)
	}

	mm_params := ServiceMockGetNamespaceAndCheckPermissionParams{ctx, s1}

	// Record call args
	mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.mutex.Lock()
	mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.callArgs = append(mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.callArgs, &mm_params)
	mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.mutex.Unlock()

	for _, e := range mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.np1, e.results.err
		}
	}

	if mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.defaultExpectation.params
		mm_want_ptrs := mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetNamespaceAndCheckPermissionParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetNamespaceAndCheckPermission.t.Errorf("ServiceMock.GetNamespaceAndCheckPermission got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmGetNamespaceAndCheckPermission.t.Errorf("ServiceMock.GetNamespaceAndCheckPermission got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetNamespaceAndCheckPermission.t.Errorf("ServiceMock.GetNamespaceAndCheckPermission got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNamespaceAndCheckPermission.t.Fatal("No results are set for the ServiceMock.GetNamespaceAndCheckPermission")
		}
		return (*mm_results).np1, (*mm_results).err
	}
	if mmGetNamespaceAndCheckPermission.funcGetNamespaceAndCheckPermission != nil {
		return mmGetNamespaceAndCheckPermission.funcGetNamespaceAndCheckPermission(ctx, s1)
	}
	mmGetNamespaceAndCheckPermission.t.Fatalf("Unexpected call to ServiceMock.GetNamespaceAndCheckPermission. %v %v", ctx, s1)
	return
}

// GetNamespaceAndCheckPermissionAfterCounter returns a count of finished ServiceMock.GetNamespaceAndCheckPermission invocations
func (mmGetNamespaceAndCheckPermission *ServiceMock) GetNamespaceAndCheckPermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceAndCheckPermission.afterGetNamespaceAndCheckPermissionCounter)
}

// GetNamespaceAndCheckPermissionBeforeCounter returns a count of ServiceMock.GetNamespaceAndCheckPermission invocations
func (mmGetNamespaceAndCheckPermission *ServiceMock) GetNamespaceAndCheckPermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceAndCheckPermission.beforeGetNamespaceAndCheckPermissionCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetNamespaceAndCheckPermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) Calls() []*ServiceMockGetNamespaceAndCheckPermissionParams {
	mmGetNamespaceAndCheckPermission.mutex.RLock()

	argCopy := make([]*ServiceMockGetNamespaceAndCheckPermissionParams, len(mmGetNamespaceAndCheckPermission.callArgs))
	copy(argCopy, mmGetNamespaceAndCheckPermission.callArgs)

	mmGetNamespaceAndCheckPermission.mutex.RUnlock()

	return argCopy
}

// MinimockGetNamespaceAndCheckPermissionDone returns true if the count of the GetNamespaceAndCheckPermission invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetNamespaceAndCheckPermissionDone() bool {
	if m.GetNamespaceAndCheckPermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetNamespaceAndCheckPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetNamespaceAndCheckPermissionMock.invocationsDone()
}

// MinimockGetNamespaceAndCheckPermissionInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetNamespaceAndCheckPermissionInspect() {
	for _, e := range m.GetNamespaceAndCheckPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetNamespaceAndCheckPermission at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetNamespaceAndCheckPermissionCounter := mm_atomic.LoadUint64(&m.afterGetNamespaceAndCheckPermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetNamespaceAndCheckPermissionMock.defaultExpectation != nil && afterGetNamespaceAndCheckPermissionCounter < 1 {
		if m.GetNamespaceAndCheckPermissionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetNamespaceAndCheckPermission at\n%s", m.GetNamespaceAndCheckPermissionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetNamespaceAndCheckPermission at\n%s with params: %#v", m.GetNamespaceAndCheckPermissionMock.defaultExpectation.expectationOrigins.origin, *m.GetNamespaceAndCheckPermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNamespaceAndCheckPermission != nil && afterGetNamespaceAndCheckPermissionCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetNamespaceAndCheckPermission at\n%s", m.funcGetNamespaceAndCheckPermissionOrigin)
	}

	if !m.GetNamespaceAndCheckPermissionMock.invocationsDone() && afterGetNamespaceAndCheckPermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetNamespaceAndCheckPermission at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetNamespaceAndCheckPermissionMock.expectedInvocations), m.GetNamespaceAndCheckPermissionMock.expectedInvocationsOrigin, afterGetNamespaceAndCheckPermissionCounter)
	}
}

type mServiceMockGetNamespaceByNsID struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetNamespaceByNsIDExpectation
	expectations       []*ServiceMockGetNamespaceByNsIDExpectation

	callArgs []*ServiceMockGetNamespaceByNsIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetNamespaceByNsIDExpectation specifies expectation struct of the Service.GetNamespaceByNsID
type ServiceMockGetNamespaceByNsIDExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetNamespaceByNsIDParams
	paramPtrs          *ServiceMockGetNamespaceByNsIDParamPtrs
	expectationOrigins ServiceMockGetNamespaceByNsIDExpectationOrigins
	results            *ServiceMockGetNamespaceByNsIDResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetNamespaceByNsIDParams contains parameters of the Service.GetNamespaceByNsID
type ServiceMockGetNamespaceByNsIDParams struct {
	ctx context.Context
	s1  string
}

// ServiceMockGetNamespaceByNsIDParamPtrs contains pointers to parameters of the Service.GetNamespaceByNsID
type ServiceMockGetNamespaceByNsIDParamPtrs struct {
	ctx *context.Context
	s1  *string
}

// ServiceMockGetNamespaceByNsIDResults contains results of the Service.GetNamespaceByNsID
type ServiceMockGetNamespaceByNsIDResults struct {
	np1 *resource.Namespace
	err error
}

// ServiceMockGetNamespaceByNsIDOrigins contains origins of expectations of the Service.GetNamespaceByNsID
type ServiceMockGetNamespaceByNsIDExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) Optional() *mServiceMockGetNamespaceByNsID {
	mmGetNamespaceByNsID.optional = true
	return mmGetNamespaceByNsID
}

// Expect sets up expected params for Service.GetNamespaceByNsID
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) Expect(ctx context.Context, s1 string) *mServiceMockGetNamespaceByNsID {
	if mmGetNamespaceByNsID.mock.funcGetNamespaceByNsID != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("ServiceMock.GetNamespaceByNsID mock is already set by Set")
	}

	if mmGetNamespaceByNsID.defaultExpectation == nil {
		mmGetNamespaceByNsID.defaultExpectation = &ServiceMockGetNamespaceByNsIDExpectation{}
	}

	if mmGetNamespaceByNsID.defaultExpectation.paramPtrs != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("ServiceMock.GetNamespaceByNsID mock is already set by ExpectParams functions")
	}

	mmGetNamespaceByNsID.defaultExpectation.params = &ServiceMockGetNamespaceByNsIDParams{ctx, s1}
	mmGetNamespaceByNsID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetNamespaceByNsID.expectations {
		if minimock.Equal(e.params, mmGetNamespaceByNsID.defaultExpectation.params) {
			mmGetNamespaceByNsID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetNamespaceByNsID.defaultExpectation.params)
		}
	}

	return mmGetNamespaceByNsID
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetNamespaceByNsID
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) ExpectCtxParam1(ctx context.Context) *mServiceMockGetNamespaceByNsID {
	if mmGetNamespaceByNsID.mock.funcGetNamespaceByNsID != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("ServiceMock.GetNamespaceByNsID mock is already set by Set")
	}

	if mmGetNamespaceByNsID.defaultExpectation == nil {
		mmGetNamespaceByNsID.defaultExpectation = &ServiceMockGetNamespaceByNsIDExpectation{}
	}

	if mmGetNamespaceByNsID.defaultExpectation.params != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("ServiceMock.GetNamespaceByNsID mock is already set by Expect")
	}

	if mmGetNamespaceByNsID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceByNsID.defaultExpectation.paramPtrs = &ServiceMockGetNamespaceByNsIDParamPtrs{}
	}
	mmGetNamespaceByNsID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetNamespaceByNsID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetNamespaceByNsID
}

// ExpectS1Param2 sets up expected param s1 for Service.GetNamespaceByNsID
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) ExpectS1Param2(s1 string) *mServiceMockGetNamespaceByNsID {
	if mmGetNamespaceByNsID.mock.funcGetNamespaceByNsID != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("ServiceMock.GetNamespaceByNsID mock is already set by Set")
	}

	if mmGetNamespaceByNsID.defaultExpectation == nil {
		mmGetNamespaceByNsID.defaultExpectation = &ServiceMockGetNamespaceByNsIDExpectation{}
	}

	if mmGetNamespaceByNsID.defaultExpectation.params != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("ServiceMock.GetNamespaceByNsID mock is already set by Expect")
	}

	if mmGetNamespaceByNsID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceByNsID.defaultExpectation.paramPtrs = &ServiceMockGetNamespaceByNsIDParamPtrs{}
	}
	mmGetNamespaceByNsID.defaultExpectation.paramPtrs.s1 = &s1
	mmGetNamespaceByNsID.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmGetNamespaceByNsID
}

// Inspect accepts an inspector function that has same arguments as the Service.GetNamespaceByNsID
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) Inspect(f func(ctx context.Context, s1 string)) *mServiceMockGetNamespaceByNsID {
	if mmGetNamespaceByNsID.mock.inspectFuncGetNamespaceByNsID != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetNamespaceByNsID")
	}

	mmGetNamespaceByNsID.mock.inspectFuncGetNamespaceByNsID = f

	return mmGetNamespaceByNsID
}

// Return sets up results that will be returned by Service.GetNamespaceByNsID
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) Return(np1 *resource.Namespace, err error) *ServiceMock {
	if mmGetNamespaceByNsID.mock.funcGetNamespaceByNsID != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("ServiceMock.GetNamespaceByNsID mock is already set by Set")
	}

	if mmGetNamespaceByNsID.defaultExpectation == nil {
		mmGetNamespaceByNsID.defaultExpectation = &ServiceMockGetNamespaceByNsIDExpectation{mock: mmGetNamespaceByNsID.mock}
	}
	mmGetNamespaceByNsID.defaultExpectation.results = &ServiceMockGetNamespaceByNsIDResults{np1, err}
	mmGetNamespaceByNsID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceByNsID.mock
}

// Set uses given function f to mock the Service.GetNamespaceByNsID method
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) Set(f func(ctx context.Context, s1 string) (np1 *resource.Namespace, err error)) *ServiceMock {
	if mmGetNamespaceByNsID.defaultExpectation != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("Default expectation is already set for the Service.GetNamespaceByNsID method")
	}

	if len(mmGetNamespaceByNsID.expectations) > 0 {
		mmGetNamespaceByNsID.mock.t.Fatalf("Some expectations are already set for the Service.GetNamespaceByNsID method")
	}

	mmGetNamespaceByNsID.mock.funcGetNamespaceByNsID = f
	mmGetNamespaceByNsID.mock.funcGetNamespaceByNsIDOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceByNsID.mock
}

// When sets expectation for the Service.GetNamespaceByNsID which will trigger the result defined by the following
// Then helper
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) When(ctx context.Context, s1 string) *ServiceMockGetNamespaceByNsIDExpectation {
	if mmGetNamespaceByNsID.mock.funcGetNamespaceByNsID != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("ServiceMock.GetNamespaceByNsID mock is already set by Set")
	}

	expectation := &ServiceMockGetNamespaceByNsIDExpectation{
		mock:               mmGetNamespaceByNsID.mock,
		params:             &ServiceMockGetNamespaceByNsIDParams{ctx, s1},
		expectationOrigins: ServiceMockGetNamespaceByNsIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetNamespaceByNsID.expectations = append(mmGetNamespaceByNsID.expectations, expectation)
	return expectation
}

// Then sets up Service.GetNamespaceByNsID return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetNamespaceByNsIDExpectation) Then(np1 *resource.Namespace, err error) *ServiceMock {
	e.results = &ServiceMockGetNamespaceByNsIDResults{np1, err}
	return e.mock
}

// Times sets number of times Service.GetNamespaceByNsID should be invoked
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) Times(n uint64) *mServiceMockGetNamespaceByNsID {
	if n == 0 {
		mmGetNamespaceByNsID.mock.t.Fatalf("Times of ServiceMock.GetNamespaceByNsID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetNamespaceByNsID.expectedInvocations, n)
	mmGetNamespaceByNsID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceByNsID
}

func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) invocationsDone() bool {
	if len(mmGetNamespaceByNsID.expectations) == 0 && mmGetNamespaceByNsID.defaultExpectation == nil && mmGetNamespaceByNsID.mock.funcGetNamespaceByNsID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetNamespaceByNsID.mock.afterGetNamespaceByNsIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetNamespaceByNsID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetNamespaceByNsID implements mm_service.Service
func (mmGetNamespaceByNsID *ServiceMock) GetNamespaceByNsID(ctx context.Context, s1 string) (np1 *resource.Namespace, err error) {
	mm_atomic.AddUint64(&mmGetNamespaceByNsID.beforeGetNamespaceByNsIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNamespaceByNsID.afterGetNamespaceByNsIDCounter, 1)

	mmGetNamespaceByNsID.t.Helper()

	if mmGetNamespaceByNsID.inspectFuncGetNamespaceByNsID != nil {
		mmGetNamespaceByNsID.inspectFuncGetNamespaceByNsID(ctx, s1)
	}

	mm_params := ServiceMockGetNamespaceByNsIDParams{ctx, s1}

	// Record call args
	mmGetNamespaceByNsID.GetNamespaceByNsIDMock.mutex.Lock()
	mmGetNamespaceByNsID.GetNamespaceByNsIDMock.callArgs = append(mmGetNamespaceByNsID.GetNamespaceByNsIDMock.callArgs, &mm_params)
	mmGetNamespaceByNsID.GetNamespaceByNsIDMock.mutex.Unlock()

	for _, e := range mmGetNamespaceByNsID.GetNamespaceByNsIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.np1, e.results.err
		}
	}

	if mmGetNamespaceByNsID.GetNamespaceByNsIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNamespaceByNsID.GetNamespaceByNsIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetNamespaceByNsID.GetNamespaceByNsIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetNamespaceByNsID.GetNamespaceByNsIDMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetNamespaceByNsIDParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetNamespaceByNsID.t.Errorf("ServiceMock.GetNamespaceByNsID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceByNsID.GetNamespaceByNsIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmGetNamespaceByNsID.t.Errorf("ServiceMock.GetNamespaceByNsID got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceByNsID.GetNamespaceByNsIDMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetNamespaceByNsID.t.Errorf("ServiceMock.GetNamespaceByNsID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetNamespaceByNsID.GetNamespaceByNsIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetNamespaceByNsID.GetNamespaceByNsIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNamespaceByNsID.t.Fatal("No results are set for the ServiceMock.GetNamespaceByNsID")
		}
		return (*mm_results).np1, (*mm_results).err
	}
	if mmGetNamespaceByNsID.funcGetNamespaceByNsID != nil {
		return mmGetNamespaceByNsID.funcGetNamespaceByNsID(ctx, s1)
	}
	mmGetNamespaceByNsID.t.Fatalf("Unexpected call to ServiceMock.GetNamespaceByNsID. %v %v", ctx, s1)
	return
}

// GetNamespaceByNsIDAfterCounter returns a count of finished ServiceMock.GetNamespaceByNsID invocations
func (mmGetNamespaceByNsID *ServiceMock) GetNamespaceByNsIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceByNsID.afterGetNamespaceByNsIDCounter)
}

// GetNamespaceByNsIDBeforeCounter returns a count of ServiceMock.GetNamespaceByNsID invocations
func (mmGetNamespaceByNsID *ServiceMock) GetNamespaceByNsIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceByNsID.beforeGetNamespaceByNsIDCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetNamespaceByNsID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) Calls() []*ServiceMockGetNamespaceByNsIDParams {
	mmGetNamespaceByNsID.mutex.RLock()

	argCopy := make([]*ServiceMockGetNamespaceByNsIDParams, len(mmGetNamespaceByNsID.callArgs))
	copy(argCopy, mmGetNamespaceByNsID.callArgs)

	mmGetNamespaceByNsID.mutex.RUnlock()

	return argCopy
}

// MinimockGetNamespaceByNsIDDone returns true if the count of the GetNamespaceByNsID invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetNamespaceByNsIDDone() bool {
	if m.GetNamespaceByNsIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetNamespaceByNsIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetNamespaceByNsIDMock.invocationsDone()
}

// MinimockGetNamespaceByNsIDInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetNamespaceByNsIDInspect() {
	for _, e := range m.GetNamespaceByNsIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetNamespaceByNsID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetNamespaceByNsIDCounter := mm_atomic.LoadUint64(&m.afterGetNamespaceByNsIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetNamespaceByNsIDMock.defaultExpectation != nil && afterGetNamespaceByNsIDCounter < 1 {
		if m.GetNamespaceByNsIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetNamespaceByNsID at\n%s", m.GetNamespaceByNsIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetNamespaceByNsID at\n%s with params: %#v", m.GetNamespaceByNsIDMock.defaultExpectation.expectationOrigins.origin, *m.GetNamespaceByNsIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNamespaceByNsID != nil && afterGetNamespaceByNsIDCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetNamespaceByNsID at\n%s", m.funcGetNamespaceByNsIDOrigin)
	}

	if !m.GetNamespaceByNsIDMock.invocationsDone() && afterGetNamespaceByNsIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetNamespaceByNsID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetNamespaceByNsIDMock.expectedInvocations), m.GetNamespaceByNsIDMock.expectedInvocationsOrigin, afterGetNamespaceByNsIDCounter)
	}
}

type mServiceMockGetRepositoryTag struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetRepositoryTagExpectation
	expectations       []*ServiceMockGetRepositoryTagExpectation

	callArgs []*ServiceMockGetRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetRepositoryTagExpectation specifies expectation struct of the Service.GetRepositoryTag
type ServiceMockGetRepositoryTagExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetRepositoryTagParams
	paramPtrs          *ServiceMockGetRepositoryTagParamPtrs
	expectationOrigins ServiceMockGetRepositoryTagExpectationOrigins
	results            *ServiceMockGetRepositoryTagResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetRepositoryTagParams contains parameters of the Service.GetRepositoryTag
type ServiceMockGetRepositoryTagParams struct {
	ctx context.Context
	gp1 *artifactpb.GetRepositoryTagRequest
}

// ServiceMockGetRepositoryTagParamPtrs contains pointers to parameters of the Service.GetRepositoryTag
type ServiceMockGetRepositoryTagParamPtrs struct {
	ctx *context.Context
	gp1 **artifactpb.GetRepositoryTagRequest
}

// ServiceMockGetRepositoryTagResults contains results of the Service.GetRepositoryTag
type ServiceMockGetRepositoryTagResults struct {
	gp2 *artifactpb.GetRepositoryTagResponse
	err error
}

// ServiceMockGetRepositoryTagOrigins contains origins of expectations of the Service.GetRepositoryTag
type ServiceMockGetRepositoryTagExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) Optional() *mServiceMockGetRepositoryTag {
	mmGetRepositoryTag.optional = true
	return mmGetRepositoryTag
}

// Expect sets up expected params for Service.GetRepositoryTag
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) Expect(ctx context.Context, gp1 *artifactpb.GetRepositoryTagRequest) *mServiceMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("ServiceMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &ServiceMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmGetRepositoryTag.mock.t.Fatalf("ServiceMock.GetRepositoryTag mock is already set by ExpectParams functions")
	}

	mmGetRepositoryTag.defaultExpectation.params = &ServiceMockGetRepositoryTagParams{ctx, gp1}
	mmGetRepositoryTag.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetRepositoryTag.expectations {
		if minimock.Equal(e.params, mmGetRepositoryTag.defaultExpectation.params) {
			mmGetRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRepositoryTag.defaultExpectation.params)
		}
	}

	return mmGetRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetRepositoryTag
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) ExpectCtxParam1(ctx context.Context) *mServiceMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("ServiceMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &ServiceMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.params != nil {
		mmGetRepositoryTag.mock.t.Fatalf("ServiceMock.GetRepositoryTag mock is already set by Expect")
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmGetRepositoryTag.defaultExpectation.paramPtrs = &ServiceMockGetRepositoryTagParamPtrs{}
	}
	mmGetRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetRepositoryTag.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetRepositoryTag
}

// ExpectGp1Param2 sets up expected param gp1 for Service.GetRepositoryTag
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) ExpectGp1Param2(gp1 *artifactpb.GetRepositoryTagRequest) *mServiceMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("ServiceMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &ServiceMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.params != nil {
		mmGetRepositoryTag.mock.t.Fatalf("ServiceMock.GetRepositoryTag mock is already set by Expect")
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmGetRepositoryTag.defaultExpectation.paramPtrs = &ServiceMockGetRepositoryTagParamPtrs{}
	}
	mmGetRepositoryTag.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetRepositoryTag.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the Service.GetRepositoryTag
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) Inspect(f func(ctx context.Context, gp1 *artifactpb.GetRepositoryTagRequest)) *mServiceMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.inspectFuncGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetRepositoryTag")
	}

	mmGetRepositoryTag.mock.inspectFuncGetRepositoryTag = f

	return mmGetRepositoryTag
}

// Return sets up results that will be returned by Service.GetRepositoryTag
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) Return(gp2 *artifactpb.GetRepositoryTagResponse, err error) *ServiceMock {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("ServiceMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &ServiceMockGetRepositoryTagExpectation{mock: mmGetRepositoryTag.mock}
	}
	mmGetRepositoryTag.defaultExpectation.results = &ServiceMockGetRepositoryTagResults{gp2, err}
	mmGetRepositoryTag.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetRepositoryTag.mock
}

// Set uses given function f to mock the Service.GetRepositoryTag method
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) Set(f func(ctx context.Context, gp1 *artifactpb.GetRepositoryTagRequest) (gp2 *artifactpb.GetRepositoryTagResponse, err error)) *ServiceMock {
	if mmGetRepositoryTag.defaultExpectation != nil {
		mmGetRepositoryTag.mock.t.Fatalf("Default expectation is already set for the Service.GetRepositoryTag method")
	}

	if len(mmGetRepositoryTag.expectations) > 0 {
		mmGetRepositoryTag.mock.t.Fatalf("Some expectations are already set for the Service.GetRepositoryTag method")
	}

	mmGetRepositoryTag.mock.funcGetRepositoryTag = f
	mmGetRepositoryTag.mock.funcGetRepositoryTagOrigin = minimock.CallerInfo(1)
	return mmGetRepositoryTag.mock
}

// When sets expectation for the Service.GetRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) When(ctx context.Context, gp1 *artifactpb.GetRepositoryTagRequest) *ServiceMockGetRepositoryTagExpectation {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("ServiceMock.GetRepositoryTag mock is already set by Set")
	}

	expectation := &ServiceMockGetRepositoryTagExpectation{
		mock:               mmGetRepositoryTag.mock,
		params:             &ServiceMockGetRepositoryTagParams{ctx, gp1},
		expectationOrigins: ServiceMockGetRepositoryTagExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetRepositoryTag.expectations = append(mmGetRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up Service.GetRepositoryTag return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetRepositoryTagExpectation) Then(gp2 *artifactpb.GetRepositoryTagResponse, err error) *ServiceMock {
	e.results = &ServiceMockGetRepositoryTagResults{gp2, err}
	return e.mock
}

// Times sets number of times Service.GetRepositoryTag should be invoked
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) Times(n uint64) *mServiceMockGetRepositoryTag {
	if n == 0 {
		mmGetRepositoryTag.mock.t.Fatalf("Times of ServiceMock.GetRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRepositoryTag.expectedInvocations, n)
	mmGetRepositoryTag.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetRepositoryTag
}

func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) invocationsDone() bool {
	if len(mmGetRepositoryTag.expectations) == 0 && mmGetRepositoryTag.defaultExpectation == nil && mmGetRepositoryTag.mock.funcGetRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRepositoryTag.mock.afterGetRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRepositoryTag implements mm_service.Service
func (mmGetRepositoryTag *ServiceMock) GetRepositoryTag(ctx context.Context, gp1 *artifactpb.GetRepositoryTagRequest) (gp2 *artifactpb.GetRepositoryTagResponse, err error) {
	mm_atomic.AddUint64(&mmGetRepositoryTag.beforeGetRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRepositoryTag.afterGetRepositoryTagCounter, 1)

	mmGetRepositoryTag.t.Helper()

	if mmGetRepositoryTag.inspectFuncGetRepositoryTag != nil {
		mmGetRepositoryTag.inspectFuncGetRepositoryTag(ctx, gp1)
	}

	mm_params := ServiceMockGetRepositoryTagParams{ctx, gp1}

	// Record call args
	mmGetRepositoryTag.GetRepositoryTagMock.mutex.Lock()
	mmGetRepositoryTag.GetRepositoryTagMock.callArgs = append(mmGetRepositoryTag.GetRepositoryTagMock.callArgs, &mm_params)
	mmGetRepositoryTag.GetRepositoryTagMock.mutex.Unlock()

	for _, e := range mmGetRepositoryTag.GetRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetRepositoryTagParams{ctx, gp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetRepositoryTag.t.Errorf("ServiceMock.GetRepositoryTag got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetRepositoryTag.t.Errorf("ServiceMock.GetRepositoryTag got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRepositoryTag.t.Errorf("ServiceMock.GetRepositoryTag got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRepositoryTag.t.Fatal("No results are set for the ServiceMock.GetRepositoryTag")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetRepositoryTag.funcGetRepositoryTag != nil {
		return mmGetRepositoryTag.funcGetRepositoryTag(ctx, gp1)
	}
	mmGetRepositoryTag.t.Fatalf("Unexpected call to ServiceMock.GetRepositoryTag. %v %v", ctx, gp1)
	return
}

// GetRepositoryTagAfterCounter returns a count of finished ServiceMock.GetRepositoryTag invocations
func (mmGetRepositoryTag *ServiceMock) GetRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRepositoryTag.afterGetRepositoryTagCounter)
}

// GetRepositoryTagBeforeCounter returns a count of ServiceMock.GetRepositoryTag invocations
func (mmGetRepositoryTag *ServiceMock) GetRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRepositoryTag.beforeGetRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) Calls() []*ServiceMockGetRepositoryTagParams {
	mmGetRepositoryTag.mutex.RLock()

	argCopy := make([]*ServiceMockGetRepositoryTagParams, len(mmGetRepositoryTag.callArgs))
	copy(argCopy, mmGetRepositoryTag.callArgs)

	mmGetRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockGetRepositoryTagDone returns true if the count of the GetRepositoryTag invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetRepositoryTagDone() bool {
	if m.GetRepositoryTagMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRepositoryTagMock.invocationsDone()
}

// MinimockGetRepositoryTagInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetRepositoryTagInspect() {
	for _, e := range m.GetRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetRepositoryTag at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterGetRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRepositoryTagMock.defaultExpectation != nil && afterGetRepositoryTagCounter < 1 {
		if m.GetRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetRepositoryTag at\n%s", m.GetRepositoryTagMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetRepositoryTag at\n%s with params: %#v", m.GetRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *m.GetRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRepositoryTag != nil && afterGetRepositoryTagCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetRepositoryTag at\n%s", m.funcGetRepositoryTagOrigin)
	}

	if !m.GetRepositoryTagMock.invocationsDone() && afterGetRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetRepositoryTag at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetRepositoryTagMock.expectedInvocations), m.GetRepositoryTagMock.expectedInvocationsOrigin, afterGetRepositoryTagCounter)
	}
}

type mServiceMockGetUploadURL struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetUploadURLExpectation
	expectations       []*ServiceMockGetUploadURLExpectation

	callArgs []*ServiceMockGetUploadURLParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetUploadURLExpectation specifies expectation struct of the Service.GetUploadURL
type ServiceMockGetUploadURLExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetUploadURLParams
	paramPtrs          *ServiceMockGetUploadURLParamPtrs
	expectationOrigins ServiceMockGetUploadURLExpectationOrigins
	results            *ServiceMockGetUploadURLResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetUploadURLParams contains parameters of the Service.GetUploadURL
type ServiceMockGetUploadURLParams struct {
	ctx context.Context
	gp1 *artifactpb.GetObjectUploadURLRequest
	u1  uuid.UUID
	s1  string
	u2  uuid.UUID
}

// ServiceMockGetUploadURLParamPtrs contains pointers to parameters of the Service.GetUploadURL
type ServiceMockGetUploadURLParamPtrs struct {
	ctx *context.Context
	gp1 **artifactpb.GetObjectUploadURLRequest
	u1  *uuid.UUID
	s1  *string
	u2  *uuid.UUID
}

// ServiceMockGetUploadURLResults contains results of the Service.GetUploadURL
type ServiceMockGetUploadURLResults struct {
	gp2 *artifactpb.GetObjectUploadURLResponse
	err error
}

// ServiceMockGetUploadURLOrigins contains origins of expectations of the Service.GetUploadURL
type ServiceMockGetUploadURLExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
	originU1  string
	originS1  string
	originU2  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUploadURL *mServiceMockGetUploadURL) Optional() *mServiceMockGetUploadURL {
	mmGetUploadURL.optional = true
	return mmGetUploadURL
}

// Expect sets up expected params for Service.GetUploadURL
func (mmGetUploadURL *mServiceMockGetUploadURL) Expect(ctx context.Context, gp1 *artifactpb.GetObjectUploadURLRequest, u1 uuid.UUID, s1 string, u2 uuid.UUID) *mServiceMockGetUploadURL {
	if mmGetUploadURL.mock.funcGetUploadURL != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Set")
	}

	if mmGetUploadURL.defaultExpectation == nil {
		mmGetUploadURL.defaultExpectation = &ServiceMockGetUploadURLExpectation{}
	}

	if mmGetUploadURL.defaultExpectation.paramPtrs != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by ExpectParams functions")
	}

	mmGetUploadURL.defaultExpectation.params = &ServiceMockGetUploadURLParams{ctx, gp1, u1, s1, u2}
	mmGetUploadURL.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUploadURL.expectations {
		if minimock.Equal(e.params, mmGetUploadURL.defaultExpectation.params) {
			mmGetUploadURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUploadURL.defaultExpectation.params)
		}
	}

	return mmGetUploadURL
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetUploadURL
func (mmGetUploadURL *mServiceMockGetUploadURL) ExpectCtxParam1(ctx context.Context) *mServiceMockGetUploadURL {
	if mmGetUploadURL.mock.funcGetUploadURL != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Set")
	}

	if mmGetUploadURL.defaultExpectation == nil {
		mmGetUploadURL.defaultExpectation = &ServiceMockGetUploadURLExpectation{}
	}

	if mmGetUploadURL.defaultExpectation.params != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Expect")
	}

	if mmGetUploadURL.defaultExpectation.paramPtrs == nil {
		mmGetUploadURL.defaultExpectation.paramPtrs = &ServiceMockGetUploadURLParamPtrs{}
	}
	mmGetUploadURL.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUploadURL.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUploadURL
}

// ExpectGp1Param2 sets up expected param gp1 for Service.GetUploadURL
func (mmGetUploadURL *mServiceMockGetUploadURL) ExpectGp1Param2(gp1 *artifactpb.GetObjectUploadURLRequest) *mServiceMockGetUploadURL {
	if mmGetUploadURL.mock.funcGetUploadURL != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Set")
	}

	if mmGetUploadURL.defaultExpectation == nil {
		mmGetUploadURL.defaultExpectation = &ServiceMockGetUploadURLExpectation{}
	}

	if mmGetUploadURL.defaultExpectation.params != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Expect")
	}

	if mmGetUploadURL.defaultExpectation.paramPtrs == nil {
		mmGetUploadURL.defaultExpectation.paramPtrs = &ServiceMockGetUploadURLParamPtrs{}
	}
	mmGetUploadURL.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetUploadURL.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetUploadURL
}

// ExpectU1Param3 sets up expected param u1 for Service.GetUploadURL
func (mmGetUploadURL *mServiceMockGetUploadURL) ExpectU1Param3(u1 uuid.UUID) *mServiceMockGetUploadURL {
	if mmGetUploadURL.mock.funcGetUploadURL != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Set")
	}

	if mmGetUploadURL.defaultExpectation == nil {
		mmGetUploadURL.defaultExpectation = &ServiceMockGetUploadURLExpectation{}
	}

	if mmGetUploadURL.defaultExpectation.params != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Expect")
	}

	if mmGetUploadURL.defaultExpectation.paramPtrs == nil {
		mmGetUploadURL.defaultExpectation.paramPtrs = &ServiceMockGetUploadURLParamPtrs{}
	}
	mmGetUploadURL.defaultExpectation.paramPtrs.u1 = &u1
	mmGetUploadURL.defaultExpectation.expectationOrigins.originU1 = minimock.CallerInfo(1)

	return mmGetUploadURL
}

// ExpectS1Param4 sets up expected param s1 for Service.GetUploadURL
func (mmGetUploadURL *mServiceMockGetUploadURL) ExpectS1Param4(s1 string) *mServiceMockGetUploadURL {
	if mmGetUploadURL.mock.funcGetUploadURL != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Set")
	}

	if mmGetUploadURL.defaultExpectation == nil {
		mmGetUploadURL.defaultExpectation = &ServiceMockGetUploadURLExpectation{}
	}

	if mmGetUploadURL.defaultExpectation.params != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Expect")
	}

	if mmGetUploadURL.defaultExpectation.paramPtrs == nil {
		mmGetUploadURL.defaultExpectation.paramPtrs = &ServiceMockGetUploadURLParamPtrs{}
	}
	mmGetUploadURL.defaultExpectation.paramPtrs.s1 = &s1
	mmGetUploadURL.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmGetUploadURL
}

// ExpectU2Param5 sets up expected param u2 for Service.GetUploadURL
func (mmGetUploadURL *mServiceMockGetUploadURL) ExpectU2Param5(u2 uuid.UUID) *mServiceMockGetUploadURL {
	if mmGetUploadURL.mock.funcGetUploadURL != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Set")
	}

	if mmGetUploadURL.defaultExpectation == nil {
		mmGetUploadURL.defaultExpectation = &ServiceMockGetUploadURLExpectation{}
	}

	if mmGetUploadURL.defaultExpectation.params != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Expect")
	}

	if mmGetUploadURL.defaultExpectation.paramPtrs == nil {
		mmGetUploadURL.defaultExpectation.paramPtrs = &ServiceMockGetUploadURLParamPtrs{}
	}
	mmGetUploadURL.defaultExpectation.paramPtrs.u2 = &u2
	mmGetUploadURL.defaultExpectation.expectationOrigins.originU2 = minimock.CallerInfo(1)

	return mmGetUploadURL
}

// Inspect accepts an inspector function that has same arguments as the Service.GetUploadURL
func (mmGetUploadURL *mServiceMockGetUploadURL) Inspect(f func(ctx context.Context, gp1 *artifactpb.GetObjectUploadURLRequest, u1 uuid.UUID, s1 string, u2 uuid.UUID)) *mServiceMockGetUploadURL {
	if mmGetUploadURL.mock.inspectFuncGetUploadURL != nil {
		mmGetUploadURL.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetUploadURL")
	}

	mmGetUploadURL.mock.inspectFuncGetUploadURL = f

	return mmGetUploadURL
}

// Return sets up results that will be returned by Service.GetUploadURL
func (mmGetUploadURL *mServiceMockGetUploadURL) Return(gp2 *artifactpb.GetObjectUploadURLResponse, err error) *ServiceMock {
	if mmGetUploadURL.mock.funcGetUploadURL != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Set")
	}

	if mmGetUploadURL.defaultExpectation == nil {
		mmGetUploadURL.defaultExpectation = &ServiceMockGetUploadURLExpectation{mock: mmGetUploadURL.mock}
	}
	mmGetUploadURL.defaultExpectation.results = &ServiceMockGetUploadURLResults{gp2, err}
	mmGetUploadURL.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUploadURL.mock
}

// Set uses given function f to mock the Service.GetUploadURL method
func (mmGetUploadURL *mServiceMockGetUploadURL) Set(f func(ctx context.Context, gp1 *artifactpb.GetObjectUploadURLRequest, u1 uuid.UUID, s1 string, u2 uuid.UUID) (gp2 *artifactpb.GetObjectUploadURLResponse, err error)) *ServiceMock {
	if mmGetUploadURL.defaultExpectation != nil {
		mmGetUploadURL.mock.t.Fatalf("Default expectation is already set for the Service.GetUploadURL method")
	}

	if len(mmGetUploadURL.expectations) > 0 {
		mmGetUploadURL.mock.t.Fatalf("Some expectations are already set for the Service.GetUploadURL method")
	}

	mmGetUploadURL.mock.funcGetUploadURL = f
	mmGetUploadURL.mock.funcGetUploadURLOrigin = minimock.CallerInfo(1)
	return mmGetUploadURL.mock
}

// When sets expectation for the Service.GetUploadURL which will trigger the result defined by the following
// Then helper
func (mmGetUploadURL *mServiceMockGetUploadURL) When(ctx context.Context, gp1 *artifactpb.GetObjectUploadURLRequest, u1 uuid.UUID, s1 string, u2 uuid.UUID) *ServiceMockGetUploadURLExpectation {
	if mmGetUploadURL.mock.funcGetUploadURL != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Set")
	}

	expectation := &ServiceMockGetUploadURLExpectation{
		mock:               mmGetUploadURL.mock,
		params:             &ServiceMockGetUploadURLParams{ctx, gp1, u1, s1, u2},
		expectationOrigins: ServiceMockGetUploadURLExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUploadURL.expectations = append(mmGetUploadURL.expectations, expectation)
	return expectation
}

// Then sets up Service.GetUploadURL return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetUploadURLExpectation) Then(gp2 *artifactpb.GetObjectUploadURLResponse, err error) *ServiceMock {
	e.results = &ServiceMockGetUploadURLResults{gp2, err}
	return e.mock
}

// Times sets number of times Service.GetUploadURL should be invoked
func (mmGetUploadURL *mServiceMockGetUploadURL) Times(n uint64) *mServiceMockGetUploadURL {
	if n == 0 {
		mmGetUploadURL.mock.t.Fatalf("Times of ServiceMock.GetUploadURL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUploadURL.expectedInvocations, n)
	mmGetUploadURL.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUploadURL
}

func (mmGetUploadURL *mServiceMockGetUploadURL) invocationsDone() bool {
	if len(mmGetUploadURL.expectations) == 0 && mmGetUploadURL.defaultExpectation == nil && mmGetUploadURL.mock.funcGetUploadURL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUploadURL.mock.afterGetUploadURLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUploadURL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUploadURL implements mm_service.Service
func (mmGetUploadURL *ServiceMock) GetUploadURL(ctx context.Context, gp1 *artifactpb.GetObjectUploadURLRequest, u1 uuid.UUID, s1 string, u2 uuid.UUID) (gp2 *artifactpb.GetObjectUploadURLResponse, err error) {
	mm_atomic.AddUint64(&mmGetUploadURL.beforeGetUploadURLCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUploadURL.afterGetUploadURLCounter, 1)

	mmGetUploadURL.t.Helper()

	if mmGetUploadURL.inspectFuncGetUploadURL != nil {
		mmGetUploadURL.inspectFuncGetUploadURL(ctx, gp1, u1, s1, u2)
	}

	mm_params := ServiceMockGetUploadURLParams{ctx, gp1, u1, s1, u2}

	// Record call args
	mmGetUploadURL.GetUploadURLMock.mutex.Lock()
	mmGetUploadURL.GetUploadURLMock.callArgs = append(mmGetUploadURL.GetUploadURLMock.callArgs, &mm_params)
	mmGetUploadURL.GetUploadURLMock.mutex.Unlock()

	for _, e := range mmGetUploadURL.GetUploadURLMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetUploadURL.GetUploadURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUploadURL.GetUploadURLMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUploadURL.GetUploadURLMock.defaultExpectation.params
		mm_want_ptrs := mmGetUploadURL.GetUploadURLMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetUploadURLParams{ctx, gp1, u1, s1, u2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUploadURL.t.Errorf("ServiceMock.GetUploadURL got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUploadURL.GetUploadURLMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetUploadURL.t.Errorf("ServiceMock.GetUploadURL got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUploadURL.GetUploadURLMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmGetUploadURL.t.Errorf("ServiceMock.GetUploadURL got unexpected parameter u1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUploadURL.GetUploadURLMock.defaultExpectation.expectationOrigins.originU1, *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmGetUploadURL.t.Errorf("ServiceMock.GetUploadURL got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUploadURL.GetUploadURLMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

			if mm_want_ptrs.u2 != nil && !minimock.Equal(*mm_want_ptrs.u2, mm_got.u2) {
				mmGetUploadURL.t.Errorf("ServiceMock.GetUploadURL got unexpected parameter u2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUploadURL.GetUploadURLMock.defaultExpectation.expectationOrigins.originU2, *mm_want_ptrs.u2, mm_got.u2, minimock.Diff(*mm_want_ptrs.u2, mm_got.u2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUploadURL.t.Errorf("ServiceMock.GetUploadURL got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUploadURL.GetUploadURLMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUploadURL.GetUploadURLMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUploadURL.t.Fatal("No results are set for the ServiceMock.GetUploadURL")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetUploadURL.funcGetUploadURL != nil {
		return mmGetUploadURL.funcGetUploadURL(ctx, gp1, u1, s1, u2)
	}
	mmGetUploadURL.t.Fatalf("Unexpected call to ServiceMock.GetUploadURL. %v %v %v %v %v", ctx, gp1, u1, s1, u2)
	return
}

// GetUploadURLAfterCounter returns a count of finished ServiceMock.GetUploadURL invocations
func (mmGetUploadURL *ServiceMock) GetUploadURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUploadURL.afterGetUploadURLCounter)
}

// GetUploadURLBeforeCounter returns a count of ServiceMock.GetUploadURL invocations
func (mmGetUploadURL *ServiceMock) GetUploadURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUploadURL.beforeGetUploadURLCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetUploadURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUploadURL *mServiceMockGetUploadURL) Calls() []*ServiceMockGetUploadURLParams {
	mmGetUploadURL.mutex.RLock()

	argCopy := make([]*ServiceMockGetUploadURLParams, len(mmGetUploadURL.callArgs))
	copy(argCopy, mmGetUploadURL.callArgs)

	mmGetUploadURL.mutex.RUnlock()

	return argCopy
}

// MinimockGetUploadURLDone returns true if the count of the GetUploadURL invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetUploadURLDone() bool {
	if m.GetUploadURLMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUploadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUploadURLMock.invocationsDone()
}

// MinimockGetUploadURLInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetUploadURLInspect() {
	for _, e := range m.GetUploadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetUploadURL at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUploadURLCounter := mm_atomic.LoadUint64(&m.afterGetUploadURLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUploadURLMock.defaultExpectation != nil && afterGetUploadURLCounter < 1 {
		if m.GetUploadURLMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetUploadURL at\n%s", m.GetUploadURLMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetUploadURL at\n%s with params: %#v", m.GetUploadURLMock.defaultExpectation.expectationOrigins.origin, *m.GetUploadURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUploadURL != nil && afterGetUploadURLCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetUploadURL at\n%s", m.funcGetUploadURLOrigin)
	}

	if !m.GetUploadURLMock.invocationsDone() && afterGetUploadURLCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetUploadURL at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUploadURLMock.expectedInvocations), m.GetUploadURLMock.expectedInvocationsOrigin, afterGetUploadURLCounter)
	}
}

type mServiceMockListRepositoryTags struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockListRepositoryTagsExpectation
	expectations       []*ServiceMockListRepositoryTagsExpectation

	callArgs []*ServiceMockListRepositoryTagsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockListRepositoryTagsExpectation specifies expectation struct of the Service.ListRepositoryTags
type ServiceMockListRepositoryTagsExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockListRepositoryTagsParams
	paramPtrs          *ServiceMockListRepositoryTagsParamPtrs
	expectationOrigins ServiceMockListRepositoryTagsExpectationOrigins
	results            *ServiceMockListRepositoryTagsResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockListRepositoryTagsParams contains parameters of the Service.ListRepositoryTags
type ServiceMockListRepositoryTagsParams struct {
	ctx context.Context
	lp1 *artifactpb.ListRepositoryTagsRequest
}

// ServiceMockListRepositoryTagsParamPtrs contains pointers to parameters of the Service.ListRepositoryTags
type ServiceMockListRepositoryTagsParamPtrs struct {
	ctx *context.Context
	lp1 **artifactpb.ListRepositoryTagsRequest
}

// ServiceMockListRepositoryTagsResults contains results of the Service.ListRepositoryTags
type ServiceMockListRepositoryTagsResults struct {
	lp2 *artifactpb.ListRepositoryTagsResponse
	err error
}

// ServiceMockListRepositoryTagsOrigins contains origins of expectations of the Service.ListRepositoryTags
type ServiceMockListRepositoryTagsExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListRepositoryTags *mServiceMockListRepositoryTags) Optional() *mServiceMockListRepositoryTags {
	mmListRepositoryTags.optional = true
	return mmListRepositoryTags
}

// Expect sets up expected params for Service.ListRepositoryTags
func (mmListRepositoryTags *mServiceMockListRepositoryTags) Expect(ctx context.Context, lp1 *artifactpb.ListRepositoryTagsRequest) *mServiceMockListRepositoryTags {
	if mmListRepositoryTags.mock.funcListRepositoryTags != nil {
		mmListRepositoryTags.mock.t.Fatalf("ServiceMock.ListRepositoryTags mock is already set by Set")
	}

	if mmListRepositoryTags.defaultExpectation == nil {
		mmListRepositoryTags.defaultExpectation = &ServiceMockListRepositoryTagsExpectation{}
	}

	if mmListRepositoryTags.defaultExpectation.paramPtrs != nil {
		mmListRepositoryTags.mock.t.Fatalf("ServiceMock.ListRepositoryTags mock is already set by ExpectParams functions")
	}

	mmListRepositoryTags.defaultExpectation.params = &ServiceMockListRepositoryTagsParams{ctx, lp1}
	mmListRepositoryTags.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListRepositoryTags.expectations {
		if minimock.Equal(e.params, mmListRepositoryTags.defaultExpectation.params) {
			mmListRepositoryTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListRepositoryTags.defaultExpectation.params)
		}
	}

	return mmListRepositoryTags
}

// ExpectCtxParam1 sets up expected param ctx for Service.ListRepositoryTags
func (mmListRepositoryTags *mServiceMockListRepositoryTags) ExpectCtxParam1(ctx context.Context) *mServiceMockListRepositoryTags {
	if mmListRepositoryTags.mock.funcListRepositoryTags != nil {
		mmListRepositoryTags.mock.t.Fatalf("ServiceMock.ListRepositoryTags mock is already set by Set")
	}

	if mmListRepositoryTags.defaultExpectation == nil {
		mmListRepositoryTags.defaultExpectation = &ServiceMockListRepositoryTagsExpectation{}
	}

	if mmListRepositoryTags.defaultExpectation.params != nil {
		mmListRepositoryTags.mock.t.Fatalf("ServiceMock.ListRepositoryTags mock is already set by Expect")
	}

	if mmListRepositoryTags.defaultExpectation.paramPtrs == nil {
		mmListRepositoryTags.defaultExpectation.paramPtrs = &ServiceMockListRepositoryTagsParamPtrs{}
	}
	mmListRepositoryTags.defaultExpectation.paramPtrs.ctx = &ctx
	mmListRepositoryTags.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListRepositoryTags
}

// ExpectLp1Param2 sets up expected param lp1 for Service.ListRepositoryTags
func (mmListRepositoryTags *mServiceMockListRepositoryTags) ExpectLp1Param2(lp1 *artifactpb.ListRepositoryTagsRequest) *mServiceMockListRepositoryTags {
	if mmListRepositoryTags.mock.funcListRepositoryTags != nil {
		mmListRepositoryTags.mock.t.Fatalf("ServiceMock.ListRepositoryTags mock is already set by Set")
	}

	if mmListRepositoryTags.defaultExpectation == nil {
		mmListRepositoryTags.defaultExpectation = &ServiceMockListRepositoryTagsExpectation{}
	}

	if mmListRepositoryTags.defaultExpectation.params != nil {
		mmListRepositoryTags.mock.t.Fatalf("ServiceMock.ListRepositoryTags mock is already set by Expect")
	}

	if mmListRepositoryTags.defaultExpectation.paramPtrs == nil {
		mmListRepositoryTags.defaultExpectation.paramPtrs = &ServiceMockListRepositoryTagsParamPtrs{}
	}
	mmListRepositoryTags.defaultExpectation.paramPtrs.lp1 = &lp1
	mmListRepositoryTags.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmListRepositoryTags
}

// Inspect accepts an inspector function that has same arguments as the Service.ListRepositoryTags
func (mmListRepositoryTags *mServiceMockListRepositoryTags) Inspect(f func(ctx context.Context, lp1 *artifactpb.ListRepositoryTagsRequest)) *mServiceMockListRepositoryTags {
	if mmListRepositoryTags.mock.inspectFuncListRepositoryTags != nil {
		mmListRepositoryTags.mock.t.Fatalf("Inspect function is already set for ServiceMock.ListRepositoryTags")
	}

	mmListRepositoryTags.mock.inspectFuncListRepositoryTags = f

	return mmListRepositoryTags
}

// Return sets up results that will be returned by Service.ListRepositoryTags
func (mmListRepositoryTags *mServiceMockListRepositoryTags) Return(lp2 *artifactpb.ListRepositoryTagsResponse, err error) *ServiceMock {
	if mmListRepositoryTags.mock.funcListRepositoryTags != nil {
		mmListRepositoryTags.mock.t.Fatalf("ServiceMock.ListRepositoryTags mock is already set by Set")
	}

	if mmListRepositoryTags.defaultExpectation == nil {
		mmListRepositoryTags.defaultExpectation = &ServiceMockListRepositoryTagsExpectation{mock: mmListRepositoryTags.mock}
	}
	mmListRepositoryTags.defaultExpectation.results = &ServiceMockListRepositoryTagsResults{lp2, err}
	mmListRepositoryTags.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListRepositoryTags.mock
}

// Set uses given function f to mock the Service.ListRepositoryTags method
func (mmListRepositoryTags *mServiceMockListRepositoryTags) Set(f func(ctx context.Context, lp1 *artifactpb.ListRepositoryTagsRequest) (lp2 *artifactpb.ListRepositoryTagsResponse, err error)) *ServiceMock {
	if mmListRepositoryTags.defaultExpectation != nil {
		mmListRepositoryTags.mock.t.Fatalf("Default expectation is already set for the Service.ListRepositoryTags method")
	}

	if len(mmListRepositoryTags.expectations) > 0 {
		mmListRepositoryTags.mock.t.Fatalf("Some expectations are already set for the Service.ListRepositoryTags method")
	}

	mmListRepositoryTags.mock.funcListRepositoryTags = f
	mmListRepositoryTags.mock.funcListRepositoryTagsOrigin = minimock.CallerInfo(1)
	return mmListRepositoryTags.mock
}

// When sets expectation for the Service.ListRepositoryTags which will trigger the result defined by the following
// Then helper
func (mmListRepositoryTags *mServiceMockListRepositoryTags) When(ctx context.Context, lp1 *artifactpb.ListRepositoryTagsRequest) *ServiceMockListRepositoryTagsExpectation {
	if mmListRepositoryTags.mock.funcListRepositoryTags != nil {
		mmListRepositoryTags.mock.t.Fatalf("ServiceMock.ListRepositoryTags mock is already set by Set")
	}

	expectation := &ServiceMockListRepositoryTagsExpectation{
		mock:               mmListRepositoryTags.mock,
		params:             &ServiceMockListRepositoryTagsParams{ctx, lp1},
		expectationOrigins: ServiceMockListRepositoryTagsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListRepositoryTags.expectations = append(mmListRepositoryTags.expectations, expectation)
	return expectation
}

// Then sets up Service.ListRepositoryTags return parameters for the expectation previously defined by the When method
func (e *ServiceMockListRepositoryTagsExpectation) Then(lp2 *artifactpb.ListRepositoryTagsResponse, err error) *ServiceMock {
	e.results = &ServiceMockListRepositoryTagsResults{lp2, err}
	return e.mock
}

// Times sets number of times Service.ListRepositoryTags should be invoked
func (mmListRepositoryTags *mServiceMockListRepositoryTags) Times(n uint64) *mServiceMockListRepositoryTags {
	if n == 0 {
		mmListRepositoryTags.mock.t.Fatalf("Times of ServiceMock.ListRepositoryTags mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListRepositoryTags.expectedInvocations, n)
	mmListRepositoryTags.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListRepositoryTags
}

func (mmListRepositoryTags *mServiceMockListRepositoryTags) invocationsDone() bool {
	if len(mmListRepositoryTags.expectations) == 0 && mmListRepositoryTags.defaultExpectation == nil && mmListRepositoryTags.mock.funcListRepositoryTags == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListRepositoryTags.mock.afterListRepositoryTagsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListRepositoryTags.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListRepositoryTags implements mm_service.Service
func (mmListRepositoryTags *ServiceMock) ListRepositoryTags(ctx context.Context, lp1 *artifactpb.ListRepositoryTagsRequest) (lp2 *artifactpb.ListRepositoryTagsResponse, err error) {
	mm_atomic.AddUint64(&mmListRepositoryTags.beforeListRepositoryTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmListRepositoryTags.afterListRepositoryTagsCounter, 1)

	mmListRepositoryTags.t.Helper()

	if mmListRepositoryTags.inspectFuncListRepositoryTags != nil {
		mmListRepositoryTags.inspectFuncListRepositoryTags(ctx, lp1)
	}

	mm_params := ServiceMockListRepositoryTagsParams{ctx, lp1}

	// Record call args
	mmListRepositoryTags.ListRepositoryTagsMock.mutex.Lock()
	mmListRepositoryTags.ListRepositoryTagsMock.callArgs = append(mmListRepositoryTags.ListRepositoryTagsMock.callArgs, &mm_params)
	mmListRepositoryTags.ListRepositoryTagsMock.mutex.Unlock()

	for _, e := range mmListRepositoryTags.ListRepositoryTagsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmListRepositoryTags.ListRepositoryTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListRepositoryTags.ListRepositoryTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmListRepositoryTags.ListRepositoryTagsMock.defaultExpectation.params
		mm_want_ptrs := mmListRepositoryTags.ListRepositoryTagsMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockListRepositoryTagsParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListRepositoryTags.t.Errorf("ServiceMock.ListRepositoryTags got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListRepositoryTags.ListRepositoryTagsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmListRepositoryTags.t.Errorf("ServiceMock.ListRepositoryTags got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListRepositoryTags.ListRepositoryTagsMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListRepositoryTags.t.Errorf("ServiceMock.ListRepositoryTags got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListRepositoryTags.ListRepositoryTagsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListRepositoryTags.ListRepositoryTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmListRepositoryTags.t.Fatal("No results are set for the ServiceMock.ListRepositoryTags")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmListRepositoryTags.funcListRepositoryTags != nil {
		return mmListRepositoryTags.funcListRepositoryTags(ctx, lp1)
	}
	mmListRepositoryTags.t.Fatalf("Unexpected call to ServiceMock.ListRepositoryTags. %v %v", ctx, lp1)
	return
}

// ListRepositoryTagsAfterCounter returns a count of finished ServiceMock.ListRepositoryTags invocations
func (mmListRepositoryTags *ServiceMock) ListRepositoryTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListRepositoryTags.afterListRepositoryTagsCounter)
}

// ListRepositoryTagsBeforeCounter returns a count of ServiceMock.ListRepositoryTags invocations
func (mmListRepositoryTags *ServiceMock) ListRepositoryTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListRepositoryTags.beforeListRepositoryTagsCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.ListRepositoryTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListRepositoryTags *mServiceMockListRepositoryTags) Calls() []*ServiceMockListRepositoryTagsParams {
	mmListRepositoryTags.mutex.RLock()

	argCopy := make([]*ServiceMockListRepositoryTagsParams, len(mmListRepositoryTags.callArgs))
	copy(argCopy, mmListRepositoryTags.callArgs)

	mmListRepositoryTags.mutex.RUnlock()

	return argCopy
}

// MinimockListRepositoryTagsDone returns true if the count of the ListRepositoryTags invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockListRepositoryTagsDone() bool {
	if m.ListRepositoryTagsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListRepositoryTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListRepositoryTagsMock.invocationsDone()
}

// MinimockListRepositoryTagsInspect logs each unmet expectation
func (m *ServiceMock) MinimockListRepositoryTagsInspect() {
	for _, e := range m.ListRepositoryTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.ListRepositoryTags at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListRepositoryTagsCounter := mm_atomic.LoadUint64(&m.afterListRepositoryTagsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListRepositoryTagsMock.defaultExpectation != nil && afterListRepositoryTagsCounter < 1 {
		if m.ListRepositoryTagsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.ListRepositoryTags at\n%s", m.ListRepositoryTagsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.ListRepositoryTags at\n%s with params: %#v", m.ListRepositoryTagsMock.defaultExpectation.expectationOrigins.origin, *m.ListRepositoryTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListRepositoryTags != nil && afterListRepositoryTagsCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.ListRepositoryTags at\n%s", m.funcListRepositoryTagsOrigin)
	}

	if !m.ListRepositoryTagsMock.invocationsDone() && afterListRepositoryTagsCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.ListRepositoryTags at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListRepositoryTagsMock.expectedInvocations), m.ListRepositoryTagsMock.expectedInvocationsOrigin, afterListRepositoryTagsCounter)
	}
}

type mServiceMockMinIO struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockMinIOExpectation
	expectations       []*ServiceMockMinIOExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockMinIOExpectation specifies expectation struct of the Service.MinIO
type ServiceMockMinIOExpectation struct {
	mock *ServiceMock

	results      *ServiceMockMinIOResults
	returnOrigin string
	Counter      uint64
}

// ServiceMockMinIOResults contains results of the Service.MinIO
type ServiceMockMinIOResults struct {
	m1 minio.MinioI
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmMinIO *mServiceMockMinIO) Optional() *mServiceMockMinIO {
	mmMinIO.optional = true
	return mmMinIO
}

// Expect sets up expected params for Service.MinIO
func (mmMinIO *mServiceMockMinIO) Expect() *mServiceMockMinIO {
	if mmMinIO.mock.funcMinIO != nil {
		mmMinIO.mock.t.Fatalf("ServiceMock.MinIO mock is already set by Set")
	}

	if mmMinIO.defaultExpectation == nil {
		mmMinIO.defaultExpectation = &ServiceMockMinIOExpectation{}
	}

	return mmMinIO
}

// Inspect accepts an inspector function that has same arguments as the Service.MinIO
func (mmMinIO *mServiceMockMinIO) Inspect(f func()) *mServiceMockMinIO {
	if mmMinIO.mock.inspectFuncMinIO != nil {
		mmMinIO.mock.t.Fatalf("Inspect function is already set for ServiceMock.MinIO")
	}

	mmMinIO.mock.inspectFuncMinIO = f

	return mmMinIO
}

// Return sets up results that will be returned by Service.MinIO
func (mmMinIO *mServiceMockMinIO) Return(m1 minio.MinioI) *ServiceMock {
	if mmMinIO.mock.funcMinIO != nil {
		mmMinIO.mock.t.Fatalf("ServiceMock.MinIO mock is already set by Set")
	}

	if mmMinIO.defaultExpectation == nil {
		mmMinIO.defaultExpectation = &ServiceMockMinIOExpectation{mock: mmMinIO.mock}
	}
	mmMinIO.defaultExpectation.results = &ServiceMockMinIOResults{m1}
	mmMinIO.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmMinIO.mock
}

// Set uses given function f to mock the Service.MinIO method
func (mmMinIO *mServiceMockMinIO) Set(f func() (m1 minio.MinioI)) *ServiceMock {
	if mmMinIO.defaultExpectation != nil {
		mmMinIO.mock.t.Fatalf("Default expectation is already set for the Service.MinIO method")
	}

	if len(mmMinIO.expectations) > 0 {
		mmMinIO.mock.t.Fatalf("Some expectations are already set for the Service.MinIO method")
	}

	mmMinIO.mock.funcMinIO = f
	mmMinIO.mock.funcMinIOOrigin = minimock.CallerInfo(1)
	return mmMinIO.mock
}

// Times sets number of times Service.MinIO should be invoked
func (mmMinIO *mServiceMockMinIO) Times(n uint64) *mServiceMockMinIO {
	if n == 0 {
		mmMinIO.mock.t.Fatalf("Times of ServiceMock.MinIO mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmMinIO.expectedInvocations, n)
	mmMinIO.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmMinIO
}

func (mmMinIO *mServiceMockMinIO) invocationsDone() bool {
	if len(mmMinIO.expectations) == 0 && mmMinIO.defaultExpectation == nil && mmMinIO.mock.funcMinIO == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmMinIO.mock.afterMinIOCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmMinIO.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// MinIO implements mm_service.Service
func (mmMinIO *ServiceMock) MinIO() (m1 minio.MinioI) {
	mm_atomic.AddUint64(&mmMinIO.beforeMinIOCounter, 1)
	defer mm_atomic.AddUint64(&mmMinIO.afterMinIOCounter, 1)

	mmMinIO.t.Helper()

	if mmMinIO.inspectFuncMinIO != nil {
		mmMinIO.inspectFuncMinIO()
	}

	if mmMinIO.MinIOMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMinIO.MinIOMock.defaultExpectation.Counter, 1)

		mm_results := mmMinIO.MinIOMock.defaultExpectation.results
		if mm_results == nil {
			mmMinIO.t.Fatal("No results are set for the ServiceMock.MinIO")
		}
		return (*mm_results).m1
	}
	if mmMinIO.funcMinIO != nil {
		return mmMinIO.funcMinIO()
	}
	mmMinIO.t.Fatalf("Unexpected call to ServiceMock.MinIO.")
	return
}

// MinIOAfterCounter returns a count of finished ServiceMock.MinIO invocations
func (mmMinIO *ServiceMock) MinIOAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMinIO.afterMinIOCounter)
}

// MinIOBeforeCounter returns a count of ServiceMock.MinIO invocations
func (mmMinIO *ServiceMock) MinIOBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMinIO.beforeMinIOCounter)
}

// MinimockMinIODone returns true if the count of the MinIO invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockMinIODone() bool {
	if m.MinIOMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.MinIOMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.MinIOMock.invocationsDone()
}

// MinimockMinIOInspect logs each unmet expectation
func (m *ServiceMock) MinimockMinIOInspect() {
	for _, e := range m.MinIOMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServiceMock.MinIO")
		}
	}

	afterMinIOCounter := mm_atomic.LoadUint64(&m.afterMinIOCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.MinIOMock.defaultExpectation != nil && afterMinIOCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.MinIO at\n%s", m.MinIOMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMinIO != nil && afterMinIOCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.MinIO at\n%s", m.funcMinIOOrigin)
	}

	if !m.MinIOMock.invocationsDone() && afterMinIOCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.MinIO at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.MinIOMock.expectedInvocations), m.MinIOMock.expectedInvocationsOrigin, afterMinIOCounter)
	}
}

type mServiceMockProcessFileWorkflow struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockProcessFileWorkflowExpectation
	expectations       []*ServiceMockProcessFileWorkflowExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockProcessFileWorkflowExpectation specifies expectation struct of the Service.ProcessFileWorkflow
type ServiceMockProcessFileWorkflowExpectation struct {
	mock *ServiceMock

	results      *ServiceMockProcessFileWorkflowResults
	returnOrigin string
	Counter      uint64
}

// ServiceMockProcessFileWorkflowResults contains results of the Service.ProcessFileWorkflow
type ServiceMockProcessFileWorkflowResults struct {
	p1 mm_service.ProcessFileWorkflow
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmProcessFileWorkflow *mServiceMockProcessFileWorkflow) Optional() *mServiceMockProcessFileWorkflow {
	mmProcessFileWorkflow.optional = true
	return mmProcessFileWorkflow
}

// Expect sets up expected params for Service.ProcessFileWorkflow
func (mmProcessFileWorkflow *mServiceMockProcessFileWorkflow) Expect() *mServiceMockProcessFileWorkflow {
	if mmProcessFileWorkflow.mock.funcProcessFileWorkflow != nil {
		mmProcessFileWorkflow.mock.t.Fatalf("ServiceMock.ProcessFileWorkflow mock is already set by Set")
	}

	if mmProcessFileWorkflow.defaultExpectation == nil {
		mmProcessFileWorkflow.defaultExpectation = &ServiceMockProcessFileWorkflowExpectation{}
	}

	return mmProcessFileWorkflow
}

// Inspect accepts an inspector function that has same arguments as the Service.ProcessFileWorkflow
func (mmProcessFileWorkflow *mServiceMockProcessFileWorkflow) Inspect(f func()) *mServiceMockProcessFileWorkflow {
	if mmProcessFileWorkflow.mock.inspectFuncProcessFileWorkflow != nil {
		mmProcessFileWorkflow.mock.t.Fatalf("Inspect function is already set for ServiceMock.ProcessFileWorkflow")
	}

	mmProcessFileWorkflow.mock.inspectFuncProcessFileWorkflow = f

	return mmProcessFileWorkflow
}

// Return sets up results that will be returned by Service.ProcessFileWorkflow
func (mmProcessFileWorkflow *mServiceMockProcessFileWorkflow) Return(p1 mm_service.ProcessFileWorkflow) *ServiceMock {
	if mmProcessFileWorkflow.mock.funcProcessFileWorkflow != nil {
		mmProcessFileWorkflow.mock.t.Fatalf("ServiceMock.ProcessFileWorkflow mock is already set by Set")
	}

	if mmProcessFileWorkflow.defaultExpectation == nil {
		mmProcessFileWorkflow.defaultExpectation = &ServiceMockProcessFileWorkflowExpectation{mock: mmProcessFileWorkflow.mock}
	}
	mmProcessFileWorkflow.defaultExpectation.results = &ServiceMockProcessFileWorkflowResults{p1}
	mmProcessFileWorkflow.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmProcessFileWorkflow.mock
}

// Set uses given function f to mock the Service.ProcessFileWorkflow method
func (mmProcessFileWorkflow *mServiceMockProcessFileWorkflow) Set(f func() (p1 mm_service.ProcessFileWorkflow)) *ServiceMock {
	if mmProcessFileWorkflow.defaultExpectation != nil {
		mmProcessFileWorkflow.mock.t.Fatalf("Default expectation is already set for the Service.ProcessFileWorkflow method")
	}

	if len(mmProcessFileWorkflow.expectations) > 0 {
		mmProcessFileWorkflow.mock.t.Fatalf("Some expectations are already set for the Service.ProcessFileWorkflow method")
	}

	mmProcessFileWorkflow.mock.funcProcessFileWorkflow = f
	mmProcessFileWorkflow.mock.funcProcessFileWorkflowOrigin = minimock.CallerInfo(1)
	return mmProcessFileWorkflow.mock
}

// Times sets number of times Service.ProcessFileWorkflow should be invoked
func (mmProcessFileWorkflow *mServiceMockProcessFileWorkflow) Times(n uint64) *mServiceMockProcessFileWorkflow {
	if n == 0 {
		mmProcessFileWorkflow.mock.t.Fatalf("Times of ServiceMock.ProcessFileWorkflow mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmProcessFileWorkflow.expectedInvocations, n)
	mmProcessFileWorkflow.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmProcessFileWorkflow
}

func (mmProcessFileWorkflow *mServiceMockProcessFileWorkflow) invocationsDone() bool {
	if len(mmProcessFileWorkflow.expectations) == 0 && mmProcessFileWorkflow.defaultExpectation == nil && mmProcessFileWorkflow.mock.funcProcessFileWorkflow == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmProcessFileWorkflow.mock.afterProcessFileWorkflowCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmProcessFileWorkflow.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ProcessFileWorkflow implements mm_service.Service
func (mmProcessFileWorkflow *ServiceMock) ProcessFileWorkflow() (p1 mm_service.ProcessFileWorkflow) {
	mm_atomic.AddUint64(&mmProcessFileWorkflow.beforeProcessFileWorkflowCounter, 1)
	defer mm_atomic.AddUint64(&mmProcessFileWorkflow.afterProcessFileWorkflowCounter, 1)

	mmProcessFileWorkflow.t.Helper()

	if mmProcessFileWorkflow.inspectFuncProcessFileWorkflow != nil {
		mmProcessFileWorkflow.inspectFuncProcessFileWorkflow()
	}

	if mmProcessFileWorkflow.ProcessFileWorkflowMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProcessFileWorkflow.ProcessFileWorkflowMock.defaultExpectation.Counter, 1)

		mm_results := mmProcessFileWorkflow.ProcessFileWorkflowMock.defaultExpectation.results
		if mm_results == nil {
			mmProcessFileWorkflow.t.Fatal("No results are set for the ServiceMock.ProcessFileWorkflow")
		}
		return (*mm_results).p1
	}
	if mmProcessFileWorkflow.funcProcessFileWorkflow != nil {
		return mmProcessFileWorkflow.funcProcessFileWorkflow()
	}
	mmProcessFileWorkflow.t.Fatalf("Unexpected call to ServiceMock.ProcessFileWorkflow.")
	return
}

// ProcessFileWorkflowAfterCounter returns a count of finished ServiceMock.ProcessFileWorkflow invocations
func (mmProcessFileWorkflow *ServiceMock) ProcessFileWorkflowAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessFileWorkflow.afterProcessFileWorkflowCounter)
}

// ProcessFileWorkflowBeforeCounter returns a count of ServiceMock.ProcessFileWorkflow invocations
func (mmProcessFileWorkflow *ServiceMock) ProcessFileWorkflowBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessFileWorkflow.beforeProcessFileWorkflowCounter)
}

// MinimockProcessFileWorkflowDone returns true if the count of the ProcessFileWorkflow invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockProcessFileWorkflowDone() bool {
	if m.ProcessFileWorkflowMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ProcessFileWorkflowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ProcessFileWorkflowMock.invocationsDone()
}

// MinimockProcessFileWorkflowInspect logs each unmet expectation
func (m *ServiceMock) MinimockProcessFileWorkflowInspect() {
	for _, e := range m.ProcessFileWorkflowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServiceMock.ProcessFileWorkflow")
		}
	}

	afterProcessFileWorkflowCounter := mm_atomic.LoadUint64(&m.afterProcessFileWorkflowCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ProcessFileWorkflowMock.defaultExpectation != nil && afterProcessFileWorkflowCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.ProcessFileWorkflow at\n%s", m.ProcessFileWorkflowMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProcessFileWorkflow != nil && afterProcessFileWorkflowCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.ProcessFileWorkflow at\n%s", m.funcProcessFileWorkflowOrigin)
	}

	if !m.ProcessFileWorkflowMock.invocationsDone() && afterProcessFileWorkflowCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.ProcessFileWorkflow at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ProcessFileWorkflowMock.expectedInvocations), m.ProcessFileWorkflowMock.expectedInvocationsOrigin, afterProcessFileWorkflowCounter)
	}
}

type mServiceMockQuestionAnsweringPipe struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockQuestionAnsweringPipeExpectation
	expectations       []*ServiceMockQuestionAnsweringPipeExpectation

	callArgs []*ServiceMockQuestionAnsweringPipeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockQuestionAnsweringPipeExpectation specifies expectation struct of the Service.QuestionAnsweringPipe
type ServiceMockQuestionAnsweringPipeExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockQuestionAnsweringPipeParams
	paramPtrs          *ServiceMockQuestionAnsweringPipeParamPtrs
	expectationOrigins ServiceMockQuestionAnsweringPipeExpectationOrigins
	results            *ServiceMockQuestionAnsweringPipeResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockQuestionAnsweringPipeParams contains parameters of the Service.QuestionAnsweringPipe
type ServiceMockQuestionAnsweringPipeParams struct {
	ctx context.Context
	s1  string
	sa1 []string
}

// ServiceMockQuestionAnsweringPipeParamPtrs contains pointers to parameters of the Service.QuestionAnsweringPipe
type ServiceMockQuestionAnsweringPipeParamPtrs struct {
	ctx *context.Context
	s1  *string
	sa1 *[]string
}

// ServiceMockQuestionAnsweringPipeResults contains results of the Service.QuestionAnsweringPipe
type ServiceMockQuestionAnsweringPipeResults struct {
	s2  string
	err error
}

// ServiceMockQuestionAnsweringPipeOrigins contains origins of expectations of the Service.QuestionAnsweringPipe
type ServiceMockQuestionAnsweringPipeExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
	originSa1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmQuestionAnsweringPipe *mServiceMockQuestionAnsweringPipe) Optional() *mServiceMockQuestionAnsweringPipe {
	mmQuestionAnsweringPipe.optional = true
	return mmQuestionAnsweringPipe
}

// Expect sets up expected params for Service.QuestionAnsweringPipe
func (mmQuestionAnsweringPipe *mServiceMockQuestionAnsweringPipe) Expect(ctx context.Context, s1 string, sa1 []string) *mServiceMockQuestionAnsweringPipe {
	if mmQuestionAnsweringPipe.mock.funcQuestionAnsweringPipe != nil {
		mmQuestionAnsweringPipe.mock.t.Fatalf("ServiceMock.QuestionAnsweringPipe mock is already set by Set")
	}

	if mmQuestionAnsweringPipe.defaultExpectation == nil {
		mmQuestionAnsweringPipe.defaultExpectation = &ServiceMockQuestionAnsweringPipeExpectation{}
	}

	if mmQuestionAnsweringPipe.defaultExpectation.paramPtrs != nil {
		mmQuestionAnsweringPipe.mock.t.Fatalf("ServiceMock.QuestionAnsweringPipe mock is already set by ExpectParams functions")
	}

	mmQuestionAnsweringPipe.defaultExpectation.params = &ServiceMockQuestionAnsweringPipeParams{ctx, s1, sa1}
	mmQuestionAnsweringPipe.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmQuestionAnsweringPipe.expectations {
		if minimock.Equal(e.params, mmQuestionAnsweringPipe.defaultExpectation.params) {
			mmQuestionAnsweringPipe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQuestionAnsweringPipe.defaultExpectation.params)
		}
	}

	return mmQuestionAnsweringPipe
}

// ExpectCtxParam1 sets up expected param ctx for Service.QuestionAnsweringPipe
func (mmQuestionAnsweringPipe *mServiceMockQuestionAnsweringPipe) ExpectCtxParam1(ctx context.Context) *mServiceMockQuestionAnsweringPipe {
	if mmQuestionAnsweringPipe.mock.funcQuestionAnsweringPipe != nil {
		mmQuestionAnsweringPipe.mock.t.Fatalf("ServiceMock.QuestionAnsweringPipe mock is already set by Set")
	}

	if mmQuestionAnsweringPipe.defaultExpectation == nil {
		mmQuestionAnsweringPipe.defaultExpectation = &ServiceMockQuestionAnsweringPipeExpectation{}
	}

	if mmQuestionAnsweringPipe.defaultExpectation.params != nil {
		mmQuestionAnsweringPipe.mock.t.Fatalf("ServiceMock.QuestionAnsweringPipe mock is already set by Expect")
	}

	if mmQuestionAnsweringPipe.defaultExpectation.paramPtrs == nil {
		mmQuestionAnsweringPipe.defaultExpectation.paramPtrs = &ServiceMockQuestionAnsweringPipeParamPtrs{}
	}
	mmQuestionAnsweringPipe.defaultExpectation.paramPtrs.ctx = &ctx
	mmQuestionAnsweringPipe.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmQuestionAnsweringPipe
}

// ExpectS1Param2 sets up expected param s1 for Service.QuestionAnsweringPipe
func (mmQuestionAnsweringPipe *mServiceMockQuestionAnsweringPipe) ExpectS1Param2(s1 string) *mServiceMockQuestionAnsweringPipe {
	if mmQuestionAnsweringPipe.mock.funcQuestionAnsweringPipe != nil {
		mmQuestionAnsweringPipe.mock.t.Fatalf("ServiceMock.QuestionAnsweringPipe mock is already set by Set")
	}

	if mmQuestionAnsweringPipe.defaultExpectation == nil {
		mmQuestionAnsweringPipe.defaultExpectation = &ServiceMockQuestionAnsweringPipeExpectation{}
	}

	if mmQuestionAnsweringPipe.defaultExpectation.params != nil {
		mmQuestionAnsweringPipe.mock.t.Fatalf("ServiceMock.QuestionAnsweringPipe mock is already set by Expect")
	}

	if mmQuestionAnsweringPipe.defaultExpectation.paramPtrs == nil {
		mmQuestionAnsweringPipe.defaultExpectation.paramPtrs = &ServiceMockQuestionAnsweringPipeParamPtrs{}
	}
	mmQuestionAnsweringPipe.defaultExpectation.paramPtrs.s1 = &s1
	mmQuestionAnsweringPipe.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmQuestionAnsweringPipe
}

// ExpectSa1Param3 sets up expected param sa1 for Service.QuestionAnsweringPipe
func (mmQuestionAnsweringPipe *mServiceMockQuestionAnsweringPipe) ExpectSa1Param3(sa1 []string) *mServiceMockQuestionAnsweringPipe {
	if mmQuestionAnsweringPipe.mock.funcQuestionAnsweringPipe != nil {
		mmQuestionAnsweringPipe.mock.t.Fatalf("ServiceMock.QuestionAnsweringPipe mock is already set by Set")
	}

	if mmQuestionAnsweringPipe.defaultExpectation == nil {
		mmQuestionAnsweringPipe.defaultExpectation = &ServiceMockQuestionAnsweringPipeExpectation{}
	}

	if mmQuestionAnsweringPipe.defaultExpectation.params != nil {
		mmQuestionAnsweringPipe.mock.t.Fatalf("ServiceMock.QuestionAnsweringPipe mock is already set by Expect")
	}

	if mmQuestionAnsweringPipe.defaultExpectation.paramPtrs == nil {
		mmQuestionAnsweringPipe.defaultExpectation.paramPtrs = &ServiceMockQuestionAnsweringPipeParamPtrs{}
	}
	mmQuestionAnsweringPipe.defaultExpectation.paramPtrs.sa1 = &sa1
	mmQuestionAnsweringPipe.defaultExpectation.expectationOrigins.originSa1 = minimock.CallerInfo(1)

	return mmQuestionAnsweringPipe
}

// Inspect accepts an inspector function that has same arguments as the Service.QuestionAnsweringPipe
func (mmQuestionAnsweringPipe *mServiceMockQuestionAnsweringPipe) Inspect(f func(ctx context.Context, s1 string, sa1 []string)) *mServiceMockQuestionAnsweringPipe {
	if mmQuestionAnsweringPipe.mock.inspectFuncQuestionAnsweringPipe != nil {
		mmQuestionAnsweringPipe.mock.t.Fatalf("Inspect function is already set for ServiceMock.QuestionAnsweringPipe")
	}

	mmQuestionAnsweringPipe.mock.inspectFuncQuestionAnsweringPipe = f

	return mmQuestionAnsweringPipe
}

// Return sets up results that will be returned by Service.QuestionAnsweringPipe
func (mmQuestionAnsweringPipe *mServiceMockQuestionAnsweringPipe) Return(s2 string, err error) *ServiceMock {
	if mmQuestionAnsweringPipe.mock.funcQuestionAnsweringPipe != nil {
		mmQuestionAnsweringPipe.mock.t.Fatalf("ServiceMock.QuestionAnsweringPipe mock is already set by Set")
	}

	if mmQuestionAnsweringPipe.defaultExpectation == nil {
		mmQuestionAnsweringPipe.defaultExpectation = &ServiceMockQuestionAnsweringPipeExpectation{mock: mmQuestionAnsweringPipe.mock}
	}
	mmQuestionAnsweringPipe.defaultExpectation.results = &ServiceMockQuestionAnsweringPipeResults{s2, err}
	mmQuestionAnsweringPipe.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmQuestionAnsweringPipe.mock
}

// Set uses given function f to mock the Service.QuestionAnsweringPipe method
func (mmQuestionAnsweringPipe *mServiceMockQuestionAnsweringPipe) Set(f func(ctx context.Context, s1 string, sa1 []string) (s2 string, err error)) *ServiceMock {
	if mmQuestionAnsweringPipe.defaultExpectation != nil {
		mmQuestionAnsweringPipe.mock.t.Fatalf("Default expectation is already set for the Service.QuestionAnsweringPipe method")
	}

	if len(mmQuestionAnsweringPipe.expectations) > 0 {
		mmQuestionAnsweringPipe.mock.t.Fatalf("Some expectations are already set for the Service.QuestionAnsweringPipe method")
	}

	mmQuestionAnsweringPipe.mock.funcQuestionAnsweringPipe = f
	mmQuestionAnsweringPipe.mock.funcQuestionAnsweringPipeOrigin = minimock.CallerInfo(1)
	return mmQuestionAnsweringPipe.mock
}

// When sets expectation for the Service.QuestionAnsweringPipe which will trigger the result defined by the following
// Then helper
func (mmQuestionAnsweringPipe *mServiceMockQuestionAnsweringPipe) When(ctx context.Context, s1 string, sa1 []string) *ServiceMockQuestionAnsweringPipeExpectation {
	if mmQuestionAnsweringPipe.mock.funcQuestionAnsweringPipe != nil {
		mmQuestionAnsweringPipe.mock.t.Fatalf("ServiceMock.QuestionAnsweringPipe mock is already set by Set")
	}

	expectation := &ServiceMockQuestionAnsweringPipeExpectation{
		mock:               mmQuestionAnsweringPipe.mock,
		params:             &ServiceMockQuestionAnsweringPipeParams{ctx, s1, sa1},
		expectationOrigins: ServiceMockQuestionAnsweringPipeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmQuestionAnsweringPipe.expectations = append(mmQuestionAnsweringPipe.expectations, expectation)
	return expectation
}

// Then sets up Service.QuestionAnsweringPipe return parameters for the expectation previously defined by the When method
func (e *ServiceMockQuestionAnsweringPipeExpectation) Then(s2 string, err error) *ServiceMock {
	e.results = &ServiceMockQuestionAnsweringPipeResults{s2, err}
	return e.mock
}

// Times sets number of times Service.QuestionAnsweringPipe should be invoked
func (mmQuestionAnsweringPipe *mServiceMockQuestionAnsweringPipe) Times(n uint64) *mServiceMockQuestionAnsweringPipe {
	if n == 0 {
		mmQuestionAnsweringPipe.mock.t.Fatalf("Times of ServiceMock.QuestionAnsweringPipe mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmQuestionAnsweringPipe.expectedInvocations, n)
	mmQuestionAnsweringPipe.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmQuestionAnsweringPipe
}

func (mmQuestionAnsweringPipe *mServiceMockQuestionAnsweringPipe) invocationsDone() bool {
	if len(mmQuestionAnsweringPipe.expectations) == 0 && mmQuestionAnsweringPipe.defaultExpectation == nil && mmQuestionAnsweringPipe.mock.funcQuestionAnsweringPipe == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmQuestionAnsweringPipe.mock.afterQuestionAnsweringPipeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmQuestionAnsweringPipe.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// QuestionAnsweringPipe implements mm_service.Service
func (mmQuestionAnsweringPipe *ServiceMock) QuestionAnsweringPipe(ctx context.Context, s1 string, sa1 []string) (s2 string, err error) {
	mm_atomic.AddUint64(&mmQuestionAnsweringPipe.beforeQuestionAnsweringPipeCounter, 1)
	defer mm_atomic.AddUint64(&mmQuestionAnsweringPipe.afterQuestionAnsweringPipeCounter, 1)

	mmQuestionAnsweringPipe.t.Helper()

	if mmQuestionAnsweringPipe.inspectFuncQuestionAnsweringPipe != nil {
		mmQuestionAnsweringPipe.inspectFuncQuestionAnsweringPipe(ctx, s1, sa1)
	}

	mm_params := ServiceMockQuestionAnsweringPipeParams{ctx, s1, sa1}

	// Record call args
	mmQuestionAnsweringPipe.QuestionAnsweringPipeMock.mutex.Lock()
	mmQuestionAnsweringPipe.QuestionAnsweringPipeMock.callArgs = append(mmQuestionAnsweringPipe.QuestionAnsweringPipeMock.callArgs, &mm_params)
	mmQuestionAnsweringPipe.QuestionAnsweringPipeMock.mutex.Unlock()

	for _, e := range mmQuestionAnsweringPipe.QuestionAnsweringPipeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2, e.results.err
		}
	}

	if mmQuestionAnsweringPipe.QuestionAnsweringPipeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQuestionAnsweringPipe.QuestionAnsweringPipeMock.defaultExpectation.Counter, 1)
		mm_want := mmQuestionAnsweringPipe.QuestionAnsweringPipeMock.defaultExpectation.params
		mm_want_ptrs := mmQuestionAnsweringPipe.QuestionAnsweringPipeMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockQuestionAnsweringPipeParams{ctx, s1, sa1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmQuestionAnsweringPipe.t.Errorf("ServiceMock.QuestionAnsweringPipe got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQuestionAnsweringPipe.QuestionAnsweringPipeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmQuestionAnsweringPipe.t.Errorf("ServiceMock.QuestionAnsweringPipe got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQuestionAnsweringPipe.QuestionAnsweringPipeMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

			if mm_want_ptrs.sa1 != nil && !minimock.Equal(*mm_want_ptrs.sa1, mm_got.sa1) {
				mmQuestionAnsweringPipe.t.Errorf("ServiceMock.QuestionAnsweringPipe got unexpected parameter sa1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQuestionAnsweringPipe.QuestionAnsweringPipeMock.defaultExpectation.expectationOrigins.originSa1, *mm_want_ptrs.sa1, mm_got.sa1, minimock.Diff(*mm_want_ptrs.sa1, mm_got.sa1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQuestionAnsweringPipe.t.Errorf("ServiceMock.QuestionAnsweringPipe got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmQuestionAnsweringPipe.QuestionAnsweringPipeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQuestionAnsweringPipe.QuestionAnsweringPipeMock.defaultExpectation.results
		if mm_results == nil {
			mmQuestionAnsweringPipe.t.Fatal("No results are set for the ServiceMock.QuestionAnsweringPipe")
		}
		return (*mm_results).s2, (*mm_results).err
	}
	if mmQuestionAnsweringPipe.funcQuestionAnsweringPipe != nil {
		return mmQuestionAnsweringPipe.funcQuestionAnsweringPipe(ctx, s1, sa1)
	}
	mmQuestionAnsweringPipe.t.Fatalf("Unexpected call to ServiceMock.QuestionAnsweringPipe. %v %v %v", ctx, s1, sa1)
	return
}

// QuestionAnsweringPipeAfterCounter returns a count of finished ServiceMock.QuestionAnsweringPipe invocations
func (mmQuestionAnsweringPipe *ServiceMock) QuestionAnsweringPipeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuestionAnsweringPipe.afterQuestionAnsweringPipeCounter)
}

// QuestionAnsweringPipeBeforeCounter returns a count of ServiceMock.QuestionAnsweringPipe invocations
func (mmQuestionAnsweringPipe *ServiceMock) QuestionAnsweringPipeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuestionAnsweringPipe.beforeQuestionAnsweringPipeCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.QuestionAnsweringPipe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQuestionAnsweringPipe *mServiceMockQuestionAnsweringPipe) Calls() []*ServiceMockQuestionAnsweringPipeParams {
	mmQuestionAnsweringPipe.mutex.RLock()

	argCopy := make([]*ServiceMockQuestionAnsweringPipeParams, len(mmQuestionAnsweringPipe.callArgs))
	copy(argCopy, mmQuestionAnsweringPipe.callArgs)

	mmQuestionAnsweringPipe.mutex.RUnlock()

	return argCopy
}

// MinimockQuestionAnsweringPipeDone returns true if the count of the QuestionAnsweringPipe invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockQuestionAnsweringPipeDone() bool {
	if m.QuestionAnsweringPipeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.QuestionAnsweringPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.QuestionAnsweringPipeMock.invocationsDone()
}

// MinimockQuestionAnsweringPipeInspect logs each unmet expectation
func (m *ServiceMock) MinimockQuestionAnsweringPipeInspect() {
	for _, e := range m.QuestionAnsweringPipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.QuestionAnsweringPipe at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterQuestionAnsweringPipeCounter := mm_atomic.LoadUint64(&m.afterQuestionAnsweringPipeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.QuestionAnsweringPipeMock.defaultExpectation != nil && afterQuestionAnsweringPipeCounter < 1 {
		if m.QuestionAnsweringPipeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.QuestionAnsweringPipe at\n%s", m.QuestionAnsweringPipeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.QuestionAnsweringPipe at\n%s with params: %#v", m.QuestionAnsweringPipeMock.defaultExpectation.expectationOrigins.origin, *m.QuestionAnsweringPipeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuestionAnsweringPipe != nil && afterQuestionAnsweringPipeCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.QuestionAnsweringPipe at\n%s", m.funcQuestionAnsweringPipeOrigin)
	}

	if !m.QuestionAnsweringPipeMock.invocationsDone() && afterQuestionAnsweringPipeCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.QuestionAnsweringPipe at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.QuestionAnsweringPipeMock.expectedInvocations), m.QuestionAnsweringPipeMock.expectedInvocationsOrigin, afterQuestionAnsweringPipeCounter)
	}
}

type mServiceMockRedisClient struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockRedisClientExpectation
	expectations       []*ServiceMockRedisClientExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockRedisClientExpectation specifies expectation struct of the Service.RedisClient
type ServiceMockRedisClientExpectation struct {
	mock *ServiceMock

	results      *ServiceMockRedisClientResults
	returnOrigin string
	Counter      uint64
}

// ServiceMockRedisClientResults contains results of the Service.RedisClient
type ServiceMockRedisClientResults struct {
	cp1 *redis.Client
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRedisClient *mServiceMockRedisClient) Optional() *mServiceMockRedisClient {
	mmRedisClient.optional = true
	return mmRedisClient
}

// Expect sets up expected params for Service.RedisClient
func (mmRedisClient *mServiceMockRedisClient) Expect() *mServiceMockRedisClient {
	if mmRedisClient.mock.funcRedisClient != nil {
		mmRedisClient.mock.t.Fatalf("ServiceMock.RedisClient mock is already set by Set")
	}

	if mmRedisClient.defaultExpectation == nil {
		mmRedisClient.defaultExpectation = &ServiceMockRedisClientExpectation{}
	}

	return mmRedisClient
}

// Inspect accepts an inspector function that has same arguments as the Service.RedisClient
func (mmRedisClient *mServiceMockRedisClient) Inspect(f func()) *mServiceMockRedisClient {
	if mmRedisClient.mock.inspectFuncRedisClient != nil {
		mmRedisClient.mock.t.Fatalf("Inspect function is already set for ServiceMock.RedisClient")
	}

	mmRedisClient.mock.inspectFuncRedisClient = f

	return mmRedisClient
}

// Return sets up results that will be returned by Service.RedisClient
func (mmRedisClient *mServiceMockRedisClient) Return(cp1 *redis.Client) *ServiceMock {
	if mmRedisClient.mock.funcRedisClient != nil {
		mmRedisClient.mock.t.Fatalf("ServiceMock.RedisClient mock is already set by Set")
	}

	if mmRedisClient.defaultExpectation == nil {
		mmRedisClient.defaultExpectation = &ServiceMockRedisClientExpectation{mock: mmRedisClient.mock}
	}
	mmRedisClient.defaultExpectation.results = &ServiceMockRedisClientResults{cp1}
	mmRedisClient.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRedisClient.mock
}

// Set uses given function f to mock the Service.RedisClient method
func (mmRedisClient *mServiceMockRedisClient) Set(f func() (cp1 *redis.Client)) *ServiceMock {
	if mmRedisClient.defaultExpectation != nil {
		mmRedisClient.mock.t.Fatalf("Default expectation is already set for the Service.RedisClient method")
	}

	if len(mmRedisClient.expectations) > 0 {
		mmRedisClient.mock.t.Fatalf("Some expectations are already set for the Service.RedisClient method")
	}

	mmRedisClient.mock.funcRedisClient = f
	mmRedisClient.mock.funcRedisClientOrigin = minimock.CallerInfo(1)
	return mmRedisClient.mock
}

// Times sets number of times Service.RedisClient should be invoked
func (mmRedisClient *mServiceMockRedisClient) Times(n uint64) *mServiceMockRedisClient {
	if n == 0 {
		mmRedisClient.mock.t.Fatalf("Times of ServiceMock.RedisClient mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRedisClient.expectedInvocations, n)
	mmRedisClient.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRedisClient
}

func (mmRedisClient *mServiceMockRedisClient) invocationsDone() bool {
	if len(mmRedisClient.expectations) == 0 && mmRedisClient.defaultExpectation == nil && mmRedisClient.mock.funcRedisClient == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRedisClient.mock.afterRedisClientCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRedisClient.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RedisClient implements mm_service.Service
func (mmRedisClient *ServiceMock) RedisClient() (cp1 *redis.Client) {
	mm_atomic.AddUint64(&mmRedisClient.beforeRedisClientCounter, 1)
	defer mm_atomic.AddUint64(&mmRedisClient.afterRedisClientCounter, 1)

	mmRedisClient.t.Helper()

	if mmRedisClient.inspectFuncRedisClient != nil {
		mmRedisClient.inspectFuncRedisClient()
	}

	if mmRedisClient.RedisClientMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRedisClient.RedisClientMock.defaultExpectation.Counter, 1)

		mm_results := mmRedisClient.RedisClientMock.defaultExpectation.results
		if mm_results == nil {
			mmRedisClient.t.Fatal("No results are set for the ServiceMock.RedisClient")
		}
		return (*mm_results).cp1
	}
	if mmRedisClient.funcRedisClient != nil {
		return mmRedisClient.funcRedisClient()
	}
	mmRedisClient.t.Fatalf("Unexpected call to ServiceMock.RedisClient.")
	return
}

// RedisClientAfterCounter returns a count of finished ServiceMock.RedisClient invocations
func (mmRedisClient *ServiceMock) RedisClientAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRedisClient.afterRedisClientCounter)
}

// RedisClientBeforeCounter returns a count of ServiceMock.RedisClient invocations
func (mmRedisClient *ServiceMock) RedisClientBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRedisClient.beforeRedisClientCounter)
}

// MinimockRedisClientDone returns true if the count of the RedisClient invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockRedisClientDone() bool {
	if m.RedisClientMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RedisClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RedisClientMock.invocationsDone()
}

// MinimockRedisClientInspect logs each unmet expectation
func (m *ServiceMock) MinimockRedisClientInspect() {
	for _, e := range m.RedisClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServiceMock.RedisClient")
		}
	}

	afterRedisClientCounter := mm_atomic.LoadUint64(&m.afterRedisClientCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RedisClientMock.defaultExpectation != nil && afterRedisClientCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.RedisClient at\n%s", m.RedisClientMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRedisClient != nil && afterRedisClientCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.RedisClient at\n%s", m.funcRedisClientOrigin)
	}

	if !m.RedisClientMock.invocationsDone() && afterRedisClientCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.RedisClient at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RedisClientMock.expectedInvocations), m.RedisClientMock.expectedInvocationsOrigin, afterRedisClientCounter)
	}
}

type mServiceMockRepository struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockRepositoryExpectation
	expectations       []*ServiceMockRepositoryExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockRepositoryExpectation specifies expectation struct of the Service.Repository
type ServiceMockRepositoryExpectation struct {
	mock *ServiceMock

	results      *ServiceMockRepositoryResults
	returnOrigin string
	Counter      uint64
}

// ServiceMockRepositoryResults contains results of the Service.Repository
type ServiceMockRepositoryResults struct {
	r1 repository.RepositoryI
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRepository *mServiceMockRepository) Optional() *mServiceMockRepository {
	mmRepository.optional = true
	return mmRepository
}

// Expect sets up expected params for Service.Repository
func (mmRepository *mServiceMockRepository) Expect() *mServiceMockRepository {
	if mmRepository.mock.funcRepository != nil {
		mmRepository.mock.t.Fatalf("ServiceMock.Repository mock is already set by Set")
	}

	if mmRepository.defaultExpectation == nil {
		mmRepository.defaultExpectation = &ServiceMockRepositoryExpectation{}
	}

	return mmRepository
}

// Inspect accepts an inspector function that has same arguments as the Service.Repository
func (mmRepository *mServiceMockRepository) Inspect(f func()) *mServiceMockRepository {
	if mmRepository.mock.inspectFuncRepository != nil {
		mmRepository.mock.t.Fatalf("Inspect function is already set for ServiceMock.Repository")
	}

	mmRepository.mock.inspectFuncRepository = f

	return mmRepository
}

// Return sets up results that will be returned by Service.Repository
func (mmRepository *mServiceMockRepository) Return(r1 repository.RepositoryI) *ServiceMock {
	if mmRepository.mock.funcRepository != nil {
		mmRepository.mock.t.Fatalf("ServiceMock.Repository mock is already set by Set")
	}

	if mmRepository.defaultExpectation == nil {
		mmRepository.defaultExpectation = &ServiceMockRepositoryExpectation{mock: mmRepository.mock}
	}
	mmRepository.defaultExpectation.results = &ServiceMockRepositoryResults{r1}
	mmRepository.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRepository.mock
}

// Set uses given function f to mock the Service.Repository method
func (mmRepository *mServiceMockRepository) Set(f func() (r1 repository.RepositoryI)) *ServiceMock {
	if mmRepository.defaultExpectation != nil {
		mmRepository.mock.t.Fatalf("Default expectation is already set for the Service.Repository method")
	}

	if len(mmRepository.expectations) > 0 {
		mmRepository.mock.t.Fatalf("Some expectations are already set for the Service.Repository method")
	}

	mmRepository.mock.funcRepository = f
	mmRepository.mock.funcRepositoryOrigin = minimock.CallerInfo(1)
	return mmRepository.mock
}

// Times sets number of times Service.Repository should be invoked
func (mmRepository *mServiceMockRepository) Times(n uint64) *mServiceMockRepository {
	if n == 0 {
		mmRepository.mock.t.Fatalf("Times of ServiceMock.Repository mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRepository.expectedInvocations, n)
	mmRepository.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRepository
}

func (mmRepository *mServiceMockRepository) invocationsDone() bool {
	if len(mmRepository.expectations) == 0 && mmRepository.defaultExpectation == nil && mmRepository.mock.funcRepository == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRepository.mock.afterRepositoryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRepository.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Repository implements mm_service.Service
func (mmRepository *ServiceMock) Repository() (r1 repository.RepositoryI) {
	mm_atomic.AddUint64(&mmRepository.beforeRepositoryCounter, 1)
	defer mm_atomic.AddUint64(&mmRepository.afterRepositoryCounter, 1)

	mmRepository.t.Helper()

	if mmRepository.inspectFuncRepository != nil {
		mmRepository.inspectFuncRepository()
	}

	if mmRepository.RepositoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRepository.RepositoryMock.defaultExpectation.Counter, 1)

		mm_results := mmRepository.RepositoryMock.defaultExpectation.results
		if mm_results == nil {
			mmRepository.t.Fatal("No results are set for the ServiceMock.Repository")
		}
		return (*mm_results).r1
	}
	if mmRepository.funcRepository != nil {
		return mmRepository.funcRepository()
	}
	mmRepository.t.Fatalf("Unexpected call to ServiceMock.Repository.")
	return
}

// RepositoryAfterCounter returns a count of finished ServiceMock.Repository invocations
func (mmRepository *ServiceMock) RepositoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRepository.afterRepositoryCounter)
}

// RepositoryBeforeCounter returns a count of ServiceMock.Repository invocations
func (mmRepository *ServiceMock) RepositoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRepository.beforeRepositoryCounter)
}

// MinimockRepositoryDone returns true if the count of the Repository invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockRepositoryDone() bool {
	if m.RepositoryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RepositoryMock.invocationsDone()
}

// MinimockRepositoryInspect logs each unmet expectation
func (m *ServiceMock) MinimockRepositoryInspect() {
	for _, e := range m.RepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServiceMock.Repository")
		}
	}

	afterRepositoryCounter := mm_atomic.LoadUint64(&m.afterRepositoryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RepositoryMock.defaultExpectation != nil && afterRepositoryCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.Repository at\n%s", m.RepositoryMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRepository != nil && afterRepositoryCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.Repository at\n%s", m.funcRepositoryOrigin)
	}

	if !m.RepositoryMock.invocationsDone() && afterRepositoryCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.Repository at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RepositoryMock.expectedInvocations), m.RepositoryMock.expectedInvocationsOrigin, afterRepositoryCounter)
	}
}

type mServiceMockSimilarityChunksSearch struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockSimilarityChunksSearchExpectation
	expectations       []*ServiceMockSimilarityChunksSearchExpectation

	callArgs []*ServiceMockSimilarityChunksSearchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockSimilarityChunksSearchExpectation specifies expectation struct of the Service.SimilarityChunksSearch
type ServiceMockSimilarityChunksSearchExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockSimilarityChunksSearchParams
	paramPtrs          *ServiceMockSimilarityChunksSearchParamPtrs
	expectationOrigins ServiceMockSimilarityChunksSearchExpectationOrigins
	results            *ServiceMockSimilarityChunksSearchResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockSimilarityChunksSearchParams contains parameters of the Service.SimilarityChunksSearch
type ServiceMockSimilarityChunksSearchParams struct {
	ctx context.Context
	u1  uuid.UUID
	sp1 *artifactpb.SimilarityChunksSearchRequest
}

// ServiceMockSimilarityChunksSearchParamPtrs contains pointers to parameters of the Service.SimilarityChunksSearch
type ServiceMockSimilarityChunksSearchParamPtrs struct {
	ctx *context.Context
	u1  *uuid.UUID
	sp1 **artifactpb.SimilarityChunksSearchRequest
}

// ServiceMockSimilarityChunksSearchResults contains results of the Service.SimilarityChunksSearch
type ServiceMockSimilarityChunksSearchResults struct {
	sa1 []mm_service.SimChunk
	err error
}

// ServiceMockSimilarityChunksSearchOrigins contains origins of expectations of the Service.SimilarityChunksSearch
type ServiceMockSimilarityChunksSearchExpectationOrigins struct {
	origin    string
	originCtx string
	originU1  string
	originSp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) Optional() *mServiceMockSimilarityChunksSearch {
	mmSimilarityChunksSearch.optional = true
	return mmSimilarityChunksSearch
}

// Expect sets up expected params for Service.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) Expect(ctx context.Context, u1 uuid.UUID, sp1 *artifactpb.SimilarityChunksSearchRequest) *mServiceMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ServiceMockSimilarityChunksSearchExpectation{}
	}

	if mmSimilarityChunksSearch.defaultExpectation.paramPtrs != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by ExpectParams functions")
	}

	mmSimilarityChunksSearch.defaultExpectation.params = &ServiceMockSimilarityChunksSearchParams{ctx, u1, sp1}
	mmSimilarityChunksSearch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSimilarityChunksSearch.expectations {
		if minimock.Equal(e.params, mmSimilarityChunksSearch.defaultExpectation.params) {
			mmSimilarityChunksSearch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSimilarityChunksSearch.defaultExpectation.params)
		}
	}

	return mmSimilarityChunksSearch
}

// ExpectCtxParam1 sets up expected param ctx for Service.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) ExpectCtxParam1(ctx context.Context) *mServiceMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ServiceMockSimilarityChunksSearchExpectation{}
	}

	if mmSimilarityChunksSearch.defaultExpectation.params != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Expect")
	}

	if mmSimilarityChunksSearch.defaultExpectation.paramPtrs == nil {
		mmSimilarityChunksSearch.defaultExpectation.paramPtrs = &ServiceMockSimilarityChunksSearchParamPtrs{}
	}
	mmSimilarityChunksSearch.defaultExpectation.paramPtrs.ctx = &ctx
	mmSimilarityChunksSearch.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSimilarityChunksSearch
}

// ExpectU1Param2 sets up expected param u1 for Service.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) ExpectU1Param2(u1 uuid.UUID) *mServiceMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ServiceMockSimilarityChunksSearchExpectation{}
	}

	if mmSimilarityChunksSearch.defaultExpectation.params != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Expect")
	}

	if mmSimilarityChunksSearch.defaultExpectation.paramPtrs == nil {
		mmSimilarityChunksSearch.defaultExpectation.paramPtrs = &ServiceMockSimilarityChunksSearchParamPtrs{}
	}
	mmSimilarityChunksSearch.defaultExpectation.paramPtrs.u1 = &u1
	mmSimilarityChunksSearch.defaultExpectation.expectationOrigins.originU1 = minimock.CallerInfo(1)

	return mmSimilarityChunksSearch
}

// ExpectSp1Param3 sets up expected param sp1 for Service.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) ExpectSp1Param3(sp1 *artifactpb.SimilarityChunksSearchRequest) *mServiceMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ServiceMockSimilarityChunksSearchExpectation{}
	}

	if mmSimilarityChunksSearch.defaultExpectation.params != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Expect")
	}

	if mmSimilarityChunksSearch.defaultExpectation.paramPtrs == nil {
		mmSimilarityChunksSearch.defaultExpectation.paramPtrs = &ServiceMockSimilarityChunksSearchParamPtrs{}
	}
	mmSimilarityChunksSearch.defaultExpectation.paramPtrs.sp1 = &sp1
	mmSimilarityChunksSearch.defaultExpectation.expectationOrigins.originSp1 = minimock.CallerInfo(1)

	return mmSimilarityChunksSearch
}

// Inspect accepts an inspector function that has same arguments as the Service.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) Inspect(f func(ctx context.Context, u1 uuid.UUID, sp1 *artifactpb.SimilarityChunksSearchRequest)) *mServiceMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.inspectFuncSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("Inspect function is already set for ServiceMock.SimilarityChunksSearch")
	}

	mmSimilarityChunksSearch.mock.inspectFuncSimilarityChunksSearch = f

	return mmSimilarityChunksSearch
}

// Return sets up results that will be returned by Service.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) Return(sa1 []mm_service.SimChunk, err error) *ServiceMock {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ServiceMockSimilarityChunksSearchExpectation{mock: mmSimilarityChunksSearch.mock}
	}
	mmSimilarityChunksSearch.defaultExpectation.results = &ServiceMockSimilarityChunksSearchResults{sa1, err}
	mmSimilarityChunksSearch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSimilarityChunksSearch.mock
}

// Set uses given function f to mock the Service.SimilarityChunksSearch method
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) Set(f func(ctx context.Context, u1 uuid.UUID, sp1 *artifactpb.SimilarityChunksSearchRequest) (sa1 []mm_service.SimChunk, err error)) *ServiceMock {
	if mmSimilarityChunksSearch.defaultExpectation != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("Default expectation is already set for the Service.SimilarityChunksSearch method")
	}

	if len(mmSimilarityChunksSearch.expectations) > 0 {
		mmSimilarityChunksSearch.mock.t.Fatalf("Some expectations are already set for the Service.SimilarityChunksSearch method")
	}

	mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch = f
	mmSimilarityChunksSearch.mock.funcSimilarityChunksSearchOrigin = minimock.CallerInfo(1)
	return mmSimilarityChunksSearch.mock
}

// When sets expectation for the Service.SimilarityChunksSearch which will trigger the result defined by the following
// Then helper
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) When(ctx context.Context, u1 uuid.UUID, sp1 *artifactpb.SimilarityChunksSearchRequest) *ServiceMockSimilarityChunksSearchExpectation {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Set")
	}

	expectation := &ServiceMockSimilarityChunksSearchExpectation{
		mock:               mmSimilarityChunksSearch.mock,
		params:             &ServiceMockSimilarityChunksSearchParams{ctx, u1, sp1},
		expectationOrigins: ServiceMockSimilarityChunksSearchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSimilarityChunksSearch.expectations = append(mmSimilarityChunksSearch.expectations, expectation)
	return expectation
}

// Then sets up Service.SimilarityChunksSearch return parameters for the expectation previously defined by the When method
func (e *ServiceMockSimilarityChunksSearchExpectation) Then(sa1 []mm_service.SimChunk, err error) *ServiceMock {
	e.results = &ServiceMockSimilarityChunksSearchResults{sa1, err}
	return e.mock
}

// Times sets number of times Service.SimilarityChunksSearch should be invoked
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) Times(n uint64) *mServiceMockSimilarityChunksSearch {
	if n == 0 {
		mmSimilarityChunksSearch.mock.t.Fatalf("Times of ServiceMock.SimilarityChunksSearch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSimilarityChunksSearch.expectedInvocations, n)
	mmSimilarityChunksSearch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSimilarityChunksSearch
}

func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) invocationsDone() bool {
	if len(mmSimilarityChunksSearch.expectations) == 0 && mmSimilarityChunksSearch.defaultExpectation == nil && mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSimilarityChunksSearch.mock.afterSimilarityChunksSearchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSimilarityChunksSearch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SimilarityChunksSearch implements mm_service.Service
func (mmSimilarityChunksSearch *ServiceMock) SimilarityChunksSearch(ctx context.Context, u1 uuid.UUID, sp1 *artifactpb.SimilarityChunksSearchRequest) (sa1 []mm_service.SimChunk, err error) {
	mm_atomic.AddUint64(&mmSimilarityChunksSearch.beforeSimilarityChunksSearchCounter, 1)
	defer mm_atomic.AddUint64(&mmSimilarityChunksSearch.afterSimilarityChunksSearchCounter, 1)

	mmSimilarityChunksSearch.t.Helper()

	if mmSimilarityChunksSearch.inspectFuncSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.inspectFuncSimilarityChunksSearch(ctx, u1, sp1)
	}

	mm_params := ServiceMockSimilarityChunksSearchParams{ctx, u1, sp1}

	// Record call args
	mmSimilarityChunksSearch.SimilarityChunksSearchMock.mutex.Lock()
	mmSimilarityChunksSearch.SimilarityChunksSearchMock.callArgs = append(mmSimilarityChunksSearch.SimilarityChunksSearchMock.callArgs, &mm_params)
	mmSimilarityChunksSearch.SimilarityChunksSearchMock.mutex.Unlock()

	for _, e := range mmSimilarityChunksSearch.SimilarityChunksSearchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.Counter, 1)
		mm_want := mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.params
		mm_want_ptrs := mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockSimilarityChunksSearchParams{ctx, u1, sp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSimilarityChunksSearch.t.Errorf("ServiceMock.SimilarityChunksSearch got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmSimilarityChunksSearch.t.Errorf("ServiceMock.SimilarityChunksSearch got unexpected parameter u1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.expectationOrigins.originU1, *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

			if mm_want_ptrs.sp1 != nil && !minimock.Equal(*mm_want_ptrs.sp1, mm_got.sp1) {
				mmSimilarityChunksSearch.t.Errorf("ServiceMock.SimilarityChunksSearch got unexpected parameter sp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.expectationOrigins.originSp1, *mm_want_ptrs.sp1, mm_got.sp1, minimock.Diff(*mm_want_ptrs.sp1, mm_got.sp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSimilarityChunksSearch.t.Errorf("ServiceMock.SimilarityChunksSearch got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.results
		if mm_results == nil {
			mmSimilarityChunksSearch.t.Fatal("No results are set for the ServiceMock.SimilarityChunksSearch")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmSimilarityChunksSearch.funcSimilarityChunksSearch != nil {
		return mmSimilarityChunksSearch.funcSimilarityChunksSearch(ctx, u1, sp1)
	}
	mmSimilarityChunksSearch.t.Fatalf("Unexpected call to ServiceMock.SimilarityChunksSearch. %v %v %v", ctx, u1, sp1)
	return
}

// SimilarityChunksSearchAfterCounter returns a count of finished ServiceMock.SimilarityChunksSearch invocations
func (mmSimilarityChunksSearch *ServiceMock) SimilarityChunksSearchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSimilarityChunksSearch.afterSimilarityChunksSearchCounter)
}

// SimilarityChunksSearchBeforeCounter returns a count of ServiceMock.SimilarityChunksSearch invocations
func (mmSimilarityChunksSearch *ServiceMock) SimilarityChunksSearchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSimilarityChunksSearch.beforeSimilarityChunksSearchCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.SimilarityChunksSearch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) Calls() []*ServiceMockSimilarityChunksSearchParams {
	mmSimilarityChunksSearch.mutex.RLock()

	argCopy := make([]*ServiceMockSimilarityChunksSearchParams, len(mmSimilarityChunksSearch.callArgs))
	copy(argCopy, mmSimilarityChunksSearch.callArgs)

	mmSimilarityChunksSearch.mutex.RUnlock()

	return argCopy
}

// MinimockSimilarityChunksSearchDone returns true if the count of the SimilarityChunksSearch invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockSimilarityChunksSearchDone() bool {
	if m.SimilarityChunksSearchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SimilarityChunksSearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SimilarityChunksSearchMock.invocationsDone()
}

// MinimockSimilarityChunksSearchInspect logs each unmet expectation
func (m *ServiceMock) MinimockSimilarityChunksSearchInspect() {
	for _, e := range m.SimilarityChunksSearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.SimilarityChunksSearch at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSimilarityChunksSearchCounter := mm_atomic.LoadUint64(&m.afterSimilarityChunksSearchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SimilarityChunksSearchMock.defaultExpectation != nil && afterSimilarityChunksSearchCounter < 1 {
		if m.SimilarityChunksSearchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.SimilarityChunksSearch at\n%s", m.SimilarityChunksSearchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.SimilarityChunksSearch at\n%s with params: %#v", m.SimilarityChunksSearchMock.defaultExpectation.expectationOrigins.origin, *m.SimilarityChunksSearchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSimilarityChunksSearch != nil && afterSimilarityChunksSearchCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.SimilarityChunksSearch at\n%s", m.funcSimilarityChunksSearchOrigin)
	}

	if !m.SimilarityChunksSearchMock.invocationsDone() && afterSimilarityChunksSearchCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.SimilarityChunksSearch at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SimilarityChunksSearchMock.expectedInvocations), m.SimilarityChunksSearchMock.expectedInvocationsOrigin, afterSimilarityChunksSearchCounter)
	}
}

type mServiceMockTriggerCleanupKnowledgeBaseWorkflow struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockTriggerCleanupKnowledgeBaseWorkflowExpectation
	expectations       []*ServiceMockTriggerCleanupKnowledgeBaseWorkflowExpectation

	callArgs []*ServiceMockTriggerCleanupKnowledgeBaseWorkflowParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockTriggerCleanupKnowledgeBaseWorkflowExpectation specifies expectation struct of the Service.TriggerCleanupKnowledgeBaseWorkflow
type ServiceMockTriggerCleanupKnowledgeBaseWorkflowExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockTriggerCleanupKnowledgeBaseWorkflowParams
	paramPtrs          *ServiceMockTriggerCleanupKnowledgeBaseWorkflowParamPtrs
	expectationOrigins ServiceMockTriggerCleanupKnowledgeBaseWorkflowExpectationOrigins
	results            *ServiceMockTriggerCleanupKnowledgeBaseWorkflowResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockTriggerCleanupKnowledgeBaseWorkflowParams contains parameters of the Service.TriggerCleanupKnowledgeBaseWorkflow
type ServiceMockTriggerCleanupKnowledgeBaseWorkflowParams struct {
	ctx context.Context
	s1  string
}

// ServiceMockTriggerCleanupKnowledgeBaseWorkflowParamPtrs contains pointers to parameters of the Service.TriggerCleanupKnowledgeBaseWorkflow
type ServiceMockTriggerCleanupKnowledgeBaseWorkflowParamPtrs struct {
	ctx *context.Context
	s1  *string
}

// ServiceMockTriggerCleanupKnowledgeBaseWorkflowResults contains results of the Service.TriggerCleanupKnowledgeBaseWorkflow
type ServiceMockTriggerCleanupKnowledgeBaseWorkflowResults struct {
	err error
}

// ServiceMockTriggerCleanupKnowledgeBaseWorkflowOrigins contains origins of expectations of the Service.TriggerCleanupKnowledgeBaseWorkflow
type ServiceMockTriggerCleanupKnowledgeBaseWorkflowExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTriggerCleanupKnowledgeBaseWorkflow *mServiceMockTriggerCleanupKnowledgeBaseWorkflow) Optional() *mServiceMockTriggerCleanupKnowledgeBaseWorkflow {
	mmTriggerCleanupKnowledgeBaseWorkflow.optional = true
	return mmTriggerCleanupKnowledgeBaseWorkflow
}

// Expect sets up expected params for Service.TriggerCleanupKnowledgeBaseWorkflow
func (mmTriggerCleanupKnowledgeBaseWorkflow *mServiceMockTriggerCleanupKnowledgeBaseWorkflow) Expect(ctx context.Context, s1 string) *mServiceMockTriggerCleanupKnowledgeBaseWorkflow {
	if mmTriggerCleanupKnowledgeBaseWorkflow.mock.funcTriggerCleanupKnowledgeBaseWorkflow != nil {
		mmTriggerCleanupKnowledgeBaseWorkflow.mock.t.Fatalf("ServiceMock.TriggerCleanupKnowledgeBaseWorkflow mock is already set by Set")
	}

	if mmTriggerCleanupKnowledgeBaseWorkflow.defaultExpectation == nil {
		mmTriggerCleanupKnowledgeBaseWorkflow.defaultExpectation = &ServiceMockTriggerCleanupKnowledgeBaseWorkflowExpectation{}
	}

	if mmTriggerCleanupKnowledgeBaseWorkflow.defaultExpectation.paramPtrs != nil {
		mmTriggerCleanupKnowledgeBaseWorkflow.mock.t.Fatalf("ServiceMock.TriggerCleanupKnowledgeBaseWorkflow mock is already set by ExpectParams functions")
	}

	mmTriggerCleanupKnowledgeBaseWorkflow.defaultExpectation.params = &ServiceMockTriggerCleanupKnowledgeBaseWorkflowParams{ctx, s1}
	mmTriggerCleanupKnowledgeBaseWorkflow.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTriggerCleanupKnowledgeBaseWorkflow.expectations {
		if minimock.Equal(e.params, mmTriggerCleanupKnowledgeBaseWorkflow.defaultExpectation.params) {
			mmTriggerCleanupKnowledgeBaseWorkflow.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTriggerCleanupKnowledgeBaseWorkflow.defaultExpectation.params)
		}
	}

	return mmTriggerCleanupKnowledgeBaseWorkflow
}

// ExpectCtxParam1 sets up expected param ctx for Service.TriggerCleanupKnowledgeBaseWorkflow
func (mmTriggerCleanupKnowledgeBaseWorkflow *mServiceMockTriggerCleanupKnowledgeBaseWorkflow) ExpectCtxParam1(ctx context.Context) *mServiceMockTriggerCleanupKnowledgeBaseWorkflow {
	if mmTriggerCleanupKnowledgeBaseWorkflow.mock.funcTriggerCleanupKnowledgeBaseWorkflow != nil {
		mmTriggerCleanupKnowledgeBaseWorkflow.mock.t.Fatalf("ServiceMock.TriggerCleanupKnowledgeBaseWorkflow mock is already set by Set")
	}

	if mmTriggerCleanupKnowledgeBaseWorkflow.defaultExpectation == nil {
		mmTriggerCleanupKnowledgeBaseWorkflow.defaultExpectation = &ServiceMockTriggerCleanupKnowledgeBaseWorkflowExpectation{}
	}

	if mmTriggerCleanupKnowledgeBaseWorkflow.defaultExpectation.params != nil {
		mmTriggerCleanupKnowledgeBaseWorkflow.mock.t.Fatalf("ServiceMock.TriggerCleanupKnowledgeBaseWorkflow mock is already set by Expect")
	}

	if mmTriggerCleanupKnowledgeBaseWorkflow.defaultExpectation.paramPtrs == nil {
		mmTriggerCleanupKnowledgeBaseWorkflow.defaultExpectation.paramPtrs = &ServiceMockTriggerCleanupKnowledgeBaseWorkflowParamPtrs{}
	}
	mmTriggerCleanupKnowledgeBaseWorkflow.defaultExpectation.paramPtrs.ctx = &ctx
	mmTriggerCleanupKnowledgeBaseWorkflow.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmTriggerCleanupKnowledgeBaseWorkflow
}

// ExpectS1Param2 sets up expected param s1 for Service.TriggerCleanupKnowledgeBaseWorkflow
func (mmTriggerCleanupKnowledgeBaseWorkflow *mServiceMockTriggerCleanupKnowledgeBaseWorkflow) ExpectS1Param2(s1 string) *mServiceMockTriggerCleanupKnowledgeBaseWorkflow {
	if mmTriggerCleanupKnowledgeBaseWorkflow.mock.funcTriggerCleanupKnowledgeBaseWorkflow != nil {
		mmTriggerCleanupKnowledgeBaseWorkflow.mock.t.Fatalf("ServiceMock.TriggerCleanupKnowledgeBaseWorkflow mock is already set by Set")
	}

	if mmTriggerCleanupKnowledgeBaseWorkflow.defaultExpectation == nil {
		mmTriggerCleanupKnowledgeBaseWorkflow.defaultExpectation = &ServiceMockTriggerCleanupKnowledgeBaseWorkflowExpectation{}
	}

	if mmTriggerCleanupKnowledgeBaseWorkflow.defaultExpectation.params != nil {
		mmTriggerCleanupKnowledgeBaseWorkflow.mock.t.Fatalf("ServiceMock.TriggerCleanupKnowledgeBaseWorkflow mock is already set by Expect")
	}

	if mmTriggerCleanupKnowledgeBaseWorkflow.defaultExpectation.paramPtrs == nil {
		mmTriggerCleanupKnowledgeBaseWorkflow.defaultExpectation.paramPtrs = &ServiceMockTriggerCleanupKnowledgeBaseWorkflowParamPtrs{}
	}
	mmTriggerCleanupKnowledgeBaseWorkflow.defaultExpectation.paramPtrs.s1 = &s1
	mmTriggerCleanupKnowledgeBaseWorkflow.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmTriggerCleanupKnowledgeBaseWorkflow
}

// Inspect accepts an inspector function that has same arguments as the Service.TriggerCleanupKnowledgeBaseWorkflow
func (mmTriggerCleanupKnowledgeBaseWorkflow *mServiceMockTriggerCleanupKnowledgeBaseWorkflow) Inspect(f func(ctx context.Context, s1 string)) *mServiceMockTriggerCleanupKnowledgeBaseWorkflow {
	if mmTriggerCleanupKnowledgeBaseWorkflow.mock.inspectFuncTriggerCleanupKnowledgeBaseWorkflow != nil {
		mmTriggerCleanupKnowledgeBaseWorkflow.mock.t.Fatalf("Inspect function is already set for ServiceMock.TriggerCleanupKnowledgeBaseWorkflow")
	}

	mmTriggerCleanupKnowledgeBaseWorkflow.mock.inspectFuncTriggerCleanupKnowledgeBaseWorkflow = f

	return mmTriggerCleanupKnowledgeBaseWorkflow
}

// Return sets up results that will be returned by Service.TriggerCleanupKnowledgeBaseWorkflow
func (mmTriggerCleanupKnowledgeBaseWorkflow *mServiceMockTriggerCleanupKnowledgeBaseWorkflow) Return(err error) *ServiceMock {
	if mmTriggerCleanupKnowledgeBaseWorkflow.mock.funcTriggerCleanupKnowledgeBaseWorkflow != nil {
		mmTriggerCleanupKnowledgeBaseWorkflow.mock.t.Fatalf("ServiceMock.TriggerCleanupKnowledgeBaseWorkflow mock is already set by Set")
	}

	if mmTriggerCleanupKnowledgeBaseWorkflow.defaultExpectation == nil {
		mmTriggerCleanupKnowledgeBaseWorkflow.defaultExpectation = &ServiceMockTriggerCleanupKnowledgeBaseWorkflowExpectation{mock: mmTriggerCleanupKnowledgeBaseWorkflow.mock}
	}
	mmTriggerCleanupKnowledgeBaseWorkflow.defaultExpectation.results = &ServiceMockTriggerCleanupKnowledgeBaseWorkflowResults{err}
	mmTriggerCleanupKnowledgeBaseWorkflow.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTriggerCleanupKnowledgeBaseWorkflow.mock
}

// Set uses given function f to mock the Service.TriggerCleanupKnowledgeBaseWorkflow method
func (mmTriggerCleanupKnowledgeBaseWorkflow *mServiceMockTriggerCleanupKnowledgeBaseWorkflow) Set(f func(ctx context.Context, s1 string) (err error)) *ServiceMock {
	if mmTriggerCleanupKnowledgeBaseWorkflow.defaultExpectation != nil {
		mmTriggerCleanupKnowledgeBaseWorkflow.mock.t.Fatalf("Default expectation is already set for the Service.TriggerCleanupKnowledgeBaseWorkflow method")
	}

	if len(mmTriggerCleanupKnowledgeBaseWorkflow.expectations) > 0 {
		mmTriggerCleanupKnowledgeBaseWorkflow.mock.t.Fatalf("Some expectations are already set for the Service.TriggerCleanupKnowledgeBaseWorkflow method")
	}

	mmTriggerCleanupKnowledgeBaseWorkflow.mock.funcTriggerCleanupKnowledgeBaseWorkflow = f
	mmTriggerCleanupKnowledgeBaseWorkflow.mock.funcTriggerCleanupKnowledgeBaseWorkflowOrigin = minimock.CallerInfo(1)
	return mmTriggerCleanupKnowledgeBaseWorkflow.mock
}

// When sets expectation for the Service.TriggerCleanupKnowledgeBaseWorkflow which will trigger the result defined by the following
// Then helper
func (mmTriggerCleanupKnowledgeBaseWorkflow *mServiceMockTriggerCleanupKnowledgeBaseWorkflow) When(ctx context.Context, s1 string) *ServiceMockTriggerCleanupKnowledgeBaseWorkflowExpectation {
	if mmTriggerCleanupKnowledgeBaseWorkflow.mock.funcTriggerCleanupKnowledgeBaseWorkflow != nil {
		mmTriggerCleanupKnowledgeBaseWorkflow.mock.t.Fatalf("ServiceMock.TriggerCleanupKnowledgeBaseWorkflow mock is already set by Set")
	}

	expectation := &ServiceMockTriggerCleanupKnowledgeBaseWorkflowExpectation{
		mock:               mmTriggerCleanupKnowledgeBaseWorkflow.mock,
		params:             &ServiceMockTriggerCleanupKnowledgeBaseWorkflowParams{ctx, s1},
		expectationOrigins: ServiceMockTriggerCleanupKnowledgeBaseWorkflowExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTriggerCleanupKnowledgeBaseWorkflow.expectations = append(mmTriggerCleanupKnowledgeBaseWorkflow.expectations, expectation)
	return expectation
}

// Then sets up Service.TriggerCleanupKnowledgeBaseWorkflow return parameters for the expectation previously defined by the When method
func (e *ServiceMockTriggerCleanupKnowledgeBaseWorkflowExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockTriggerCleanupKnowledgeBaseWorkflowResults{err}
	return e.mock
}

// Times sets number of times Service.TriggerCleanupKnowledgeBaseWorkflow should be invoked
func (mmTriggerCleanupKnowledgeBaseWorkflow *mServiceMockTriggerCleanupKnowledgeBaseWorkflow) Times(n uint64) *mServiceMockTriggerCleanupKnowledgeBaseWorkflow {
	if n == 0 {
		mmTriggerCleanupKnowledgeBaseWorkflow.mock.t.Fatalf("Times of ServiceMock.TriggerCleanupKnowledgeBaseWorkflow mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTriggerCleanupKnowledgeBaseWorkflow.expectedInvocations, n)
	mmTriggerCleanupKnowledgeBaseWorkflow.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTriggerCleanupKnowledgeBaseWorkflow
}

func (mmTriggerCleanupKnowledgeBaseWorkflow *mServiceMockTriggerCleanupKnowledgeBaseWorkflow) invocationsDone() bool {
	if len(mmTriggerCleanupKnowledgeBaseWorkflow.expectations) == 0 && mmTriggerCleanupKnowledgeBaseWorkflow.defaultExpectation == nil && mmTriggerCleanupKnowledgeBaseWorkflow.mock.funcTriggerCleanupKnowledgeBaseWorkflow == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTriggerCleanupKnowledgeBaseWorkflow.mock.afterTriggerCleanupKnowledgeBaseWorkflowCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTriggerCleanupKnowledgeBaseWorkflow.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TriggerCleanupKnowledgeBaseWorkflow implements mm_service.Service
func (mmTriggerCleanupKnowledgeBaseWorkflow *ServiceMock) TriggerCleanupKnowledgeBaseWorkflow(ctx context.Context, s1 string) (err error) {
	mm_atomic.AddUint64(&mmTriggerCleanupKnowledgeBaseWorkflow.beforeTriggerCleanupKnowledgeBaseWorkflowCounter, 1)
	defer mm_atomic.AddUint64(&mmTriggerCleanupKnowledgeBaseWorkflow.afterTriggerCleanupKnowledgeBaseWorkflowCounter, 1)

	mmTriggerCleanupKnowledgeBaseWorkflow.t.Helper()

	if mmTriggerCleanupKnowledgeBaseWorkflow.inspectFuncTriggerCleanupKnowledgeBaseWorkflow != nil {
		mmTriggerCleanupKnowledgeBaseWorkflow.inspectFuncTriggerCleanupKnowledgeBaseWorkflow(ctx, s1)
	}

	mm_params := ServiceMockTriggerCleanupKnowledgeBaseWorkflowParams{ctx, s1}

	// Record call args
	mmTriggerCleanupKnowledgeBaseWorkflow.TriggerCleanupKnowledgeBaseWorkflowMock.mutex.Lock()
	mmTriggerCleanupKnowledgeBaseWorkflow.TriggerCleanupKnowledgeBaseWorkflowMock.callArgs = append(mmTriggerCleanupKnowledgeBaseWorkflow.TriggerCleanupKnowledgeBaseWorkflowMock.callArgs, &mm_params)
	mmTriggerCleanupKnowledgeBaseWorkflow.TriggerCleanupKnowledgeBaseWorkflowMock.mutex.Unlock()

	for _, e := range mmTriggerCleanupKnowledgeBaseWorkflow.TriggerCleanupKnowledgeBaseWorkflowMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmTriggerCleanupKnowledgeBaseWorkflow.TriggerCleanupKnowledgeBaseWorkflowMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTriggerCleanupKnowledgeBaseWorkflow.TriggerCleanupKnowledgeBaseWorkflowMock.defaultExpectation.Counter, 1)
		mm_want := mmTriggerCleanupKnowledgeBaseWorkflow.TriggerCleanupKnowledgeBaseWorkflowMock.defaultExpectation.params
		mm_want_ptrs := mmTriggerCleanupKnowledgeBaseWorkflow.TriggerCleanupKnowledgeBaseWorkflowMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockTriggerCleanupKnowledgeBaseWorkflowParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmTriggerCleanupKnowledgeBaseWorkflow.t.Errorf("ServiceMock.TriggerCleanupKnowledgeBaseWorkflow got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerCleanupKnowledgeBaseWorkflow.TriggerCleanupKnowledgeBaseWorkflowMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmTriggerCleanupKnowledgeBaseWorkflow.t.Errorf("ServiceMock.TriggerCleanupKnowledgeBaseWorkflow got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerCleanupKnowledgeBaseWorkflow.TriggerCleanupKnowledgeBaseWorkflowMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTriggerCleanupKnowledgeBaseWorkflow.t.Errorf("ServiceMock.TriggerCleanupKnowledgeBaseWorkflow got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTriggerCleanupKnowledgeBaseWorkflow.TriggerCleanupKnowledgeBaseWorkflowMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTriggerCleanupKnowledgeBaseWorkflow.TriggerCleanupKnowledgeBaseWorkflowMock.defaultExpectation.results
		if mm_results == nil {
			mmTriggerCleanupKnowledgeBaseWorkflow.t.Fatal("No results are set for the ServiceMock.TriggerCleanupKnowledgeBaseWorkflow")
		}
		return (*mm_results).err
	}
	if mmTriggerCleanupKnowledgeBaseWorkflow.funcTriggerCleanupKnowledgeBaseWorkflow != nil {
		return mmTriggerCleanupKnowledgeBaseWorkflow.funcTriggerCleanupKnowledgeBaseWorkflow(ctx, s1)
	}
	mmTriggerCleanupKnowledgeBaseWorkflow.t.Fatalf("Unexpected call to ServiceMock.TriggerCleanupKnowledgeBaseWorkflow. %v %v", ctx, s1)
	return
}

// TriggerCleanupKnowledgeBaseWorkflowAfterCounter returns a count of finished ServiceMock.TriggerCleanupKnowledgeBaseWorkflow invocations
func (mmTriggerCleanupKnowledgeBaseWorkflow *ServiceMock) TriggerCleanupKnowledgeBaseWorkflowAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerCleanupKnowledgeBaseWorkflow.afterTriggerCleanupKnowledgeBaseWorkflowCounter)
}

// TriggerCleanupKnowledgeBaseWorkflowBeforeCounter returns a count of ServiceMock.TriggerCleanupKnowledgeBaseWorkflow invocations
func (mmTriggerCleanupKnowledgeBaseWorkflow *ServiceMock) TriggerCleanupKnowledgeBaseWorkflowBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerCleanupKnowledgeBaseWorkflow.beforeTriggerCleanupKnowledgeBaseWorkflowCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.TriggerCleanupKnowledgeBaseWorkflow.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTriggerCleanupKnowledgeBaseWorkflow *mServiceMockTriggerCleanupKnowledgeBaseWorkflow) Calls() []*ServiceMockTriggerCleanupKnowledgeBaseWorkflowParams {
	mmTriggerCleanupKnowledgeBaseWorkflow.mutex.RLock()

	argCopy := make([]*ServiceMockTriggerCleanupKnowledgeBaseWorkflowParams, len(mmTriggerCleanupKnowledgeBaseWorkflow.callArgs))
	copy(argCopy, mmTriggerCleanupKnowledgeBaseWorkflow.callArgs)

	mmTriggerCleanupKnowledgeBaseWorkflow.mutex.RUnlock()

	return argCopy
}

// MinimockTriggerCleanupKnowledgeBaseWorkflowDone returns true if the count of the TriggerCleanupKnowledgeBaseWorkflow invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockTriggerCleanupKnowledgeBaseWorkflowDone() bool {
	if m.TriggerCleanupKnowledgeBaseWorkflowMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TriggerCleanupKnowledgeBaseWorkflowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TriggerCleanupKnowledgeBaseWorkflowMock.invocationsDone()
}

// MinimockTriggerCleanupKnowledgeBaseWorkflowInspect logs each unmet expectation
func (m *ServiceMock) MinimockTriggerCleanupKnowledgeBaseWorkflowInspect() {
	for _, e := range m.TriggerCleanupKnowledgeBaseWorkflowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.TriggerCleanupKnowledgeBaseWorkflow at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTriggerCleanupKnowledgeBaseWorkflowCounter := mm_atomic.LoadUint64(&m.afterTriggerCleanupKnowledgeBaseWorkflowCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TriggerCleanupKnowledgeBaseWorkflowMock.defaultExpectation != nil && afterTriggerCleanupKnowledgeBaseWorkflowCounter < 1 {
		if m.TriggerCleanupKnowledgeBaseWorkflowMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.TriggerCleanupKnowledgeBaseWorkflow at\n%s", m.TriggerCleanupKnowledgeBaseWorkflowMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.TriggerCleanupKnowledgeBaseWorkflow at\n%s with params: %#v", m.TriggerCleanupKnowledgeBaseWorkflowMock.defaultExpectation.expectationOrigins.origin, *m.TriggerCleanupKnowledgeBaseWorkflowMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTriggerCleanupKnowledgeBaseWorkflow != nil && afterTriggerCleanupKnowledgeBaseWorkflowCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.TriggerCleanupKnowledgeBaseWorkflow at\n%s", m.funcTriggerCleanupKnowledgeBaseWorkflowOrigin)
	}

	if !m.TriggerCleanupKnowledgeBaseWorkflowMock.invocationsDone() && afterTriggerCleanupKnowledgeBaseWorkflowCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.TriggerCleanupKnowledgeBaseWorkflow at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TriggerCleanupKnowledgeBaseWorkflowMock.expectedInvocations), m.TriggerCleanupKnowledgeBaseWorkflowMock.expectedInvocationsOrigin, afterTriggerCleanupKnowledgeBaseWorkflowCounter)
	}
}

type mServiceMockVectorDB struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockVectorDBExpectation
	expectations       []*ServiceMockVectorDBExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockVectorDBExpectation specifies expectation struct of the Service.VectorDB
type ServiceMockVectorDBExpectation struct {
	mock *ServiceMock

	results      *ServiceMockVectorDBResults
	returnOrigin string
	Counter      uint64
}

// ServiceMockVectorDBResults contains results of the Service.VectorDB
type ServiceMockVectorDBResults struct {
	v1 mm_service.VectorDatabase
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmVectorDB *mServiceMockVectorDB) Optional() *mServiceMockVectorDB {
	mmVectorDB.optional = true
	return mmVectorDB
}

// Expect sets up expected params for Service.VectorDB
func (mmVectorDB *mServiceMockVectorDB) Expect() *mServiceMockVectorDB {
	if mmVectorDB.mock.funcVectorDB != nil {
		mmVectorDB.mock.t.Fatalf("ServiceMock.VectorDB mock is already set by Set")
	}

	if mmVectorDB.defaultExpectation == nil {
		mmVectorDB.defaultExpectation = &ServiceMockVectorDBExpectation{}
	}

	return mmVectorDB
}

// Inspect accepts an inspector function that has same arguments as the Service.VectorDB
func (mmVectorDB *mServiceMockVectorDB) Inspect(f func()) *mServiceMockVectorDB {
	if mmVectorDB.mock.inspectFuncVectorDB != nil {
		mmVectorDB.mock.t.Fatalf("Inspect function is already set for ServiceMock.VectorDB")
	}

	mmVectorDB.mock.inspectFuncVectorDB = f

	return mmVectorDB
}

// Return sets up results that will be returned by Service.VectorDB
func (mmVectorDB *mServiceMockVectorDB) Return(v1 mm_service.VectorDatabase) *ServiceMock {
	if mmVectorDB.mock.funcVectorDB != nil {
		mmVectorDB.mock.t.Fatalf("ServiceMock.VectorDB mock is already set by Set")
	}

	if mmVectorDB.defaultExpectation == nil {
		mmVectorDB.defaultExpectation = &ServiceMockVectorDBExpectation{mock: mmVectorDB.mock}
	}
	mmVectorDB.defaultExpectation.results = &ServiceMockVectorDBResults{v1}
	mmVectorDB.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmVectorDB.mock
}

// Set uses given function f to mock the Service.VectorDB method
func (mmVectorDB *mServiceMockVectorDB) Set(f func() (v1 mm_service.VectorDatabase)) *ServiceMock {
	if mmVectorDB.defaultExpectation != nil {
		mmVectorDB.mock.t.Fatalf("Default expectation is already set for the Service.VectorDB method")
	}

	if len(mmVectorDB.expectations) > 0 {
		mmVectorDB.mock.t.Fatalf("Some expectations are already set for the Service.VectorDB method")
	}

	mmVectorDB.mock.funcVectorDB = f
	mmVectorDB.mock.funcVectorDBOrigin = minimock.CallerInfo(1)
	return mmVectorDB.mock
}

// Times sets number of times Service.VectorDB should be invoked
func (mmVectorDB *mServiceMockVectorDB) Times(n uint64) *mServiceMockVectorDB {
	if n == 0 {
		mmVectorDB.mock.t.Fatalf("Times of ServiceMock.VectorDB mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmVectorDB.expectedInvocations, n)
	mmVectorDB.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmVectorDB
}

func (mmVectorDB *mServiceMockVectorDB) invocationsDone() bool {
	if len(mmVectorDB.expectations) == 0 && mmVectorDB.defaultExpectation == nil && mmVectorDB.mock.funcVectorDB == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmVectorDB.mock.afterVectorDBCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmVectorDB.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// VectorDB implements mm_service.Service
func (mmVectorDB *ServiceMock) VectorDB() (v1 mm_service.VectorDatabase) {
	mm_atomic.AddUint64(&mmVectorDB.beforeVectorDBCounter, 1)
	defer mm_atomic.AddUint64(&mmVectorDB.afterVectorDBCounter, 1)

	mmVectorDB.t.Helper()

	if mmVectorDB.inspectFuncVectorDB != nil {
		mmVectorDB.inspectFuncVectorDB()
	}

	if mmVectorDB.VectorDBMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmVectorDB.VectorDBMock.defaultExpectation.Counter, 1)

		mm_results := mmVectorDB.VectorDBMock.defaultExpectation.results
		if mm_results == nil {
			mmVectorDB.t.Fatal("No results are set for the ServiceMock.VectorDB")
		}
		return (*mm_results).v1
	}
	if mmVectorDB.funcVectorDB != nil {
		return mmVectorDB.funcVectorDB()
	}
	mmVectorDB.t.Fatalf("Unexpected call to ServiceMock.VectorDB.")
	return
}

// VectorDBAfterCounter returns a count of finished ServiceMock.VectorDB invocations
func (mmVectorDB *ServiceMock) VectorDBAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmVectorDB.afterVectorDBCounter)
}

// VectorDBBeforeCounter returns a count of ServiceMock.VectorDB invocations
func (mmVectorDB *ServiceMock) VectorDBBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmVectorDB.beforeVectorDBCounter)
}

// MinimockVectorDBDone returns true if the count of the VectorDB invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockVectorDBDone() bool {
	if m.VectorDBMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.VectorDBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.VectorDBMock.invocationsDone()
}

// MinimockVectorDBInspect logs each unmet expectation
func (m *ServiceMock) MinimockVectorDBInspect() {
	for _, e := range m.VectorDBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServiceMock.VectorDB")
		}
	}

	afterVectorDBCounter := mm_atomic.LoadUint64(&m.afterVectorDBCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.VectorDBMock.defaultExpectation != nil && afterVectorDBCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.VectorDB at\n%s", m.VectorDBMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcVectorDB != nil && afterVectorDBCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.VectorDB at\n%s", m.funcVectorDBOrigin)
	}

	if !m.VectorDBMock.invocationsDone() && afterVectorDBCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.VectorDB at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.VectorDBMock.expectedInvocations), m.VectorDBMock.expectedInvocationsOrigin, afterVectorDBCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockACLClientInspect()

			m.MinimockCheckCatalogUserPermissionInspect()

			m.MinimockCheckNamespacePermissionInspect()

			m.MinimockChunkMarkdownPipeInspect()

			m.MinimockChunkTextPipeInspect()

			m.MinimockCleanupFileWorkflowInspect()

			m.MinimockCleanupKnowledgeBaseWorkflowInspect()

			m.MinimockConvertToMDPipeInspect()

			m.MinimockCreateRepositoryTagInspect()

			m.MinimockDeleteConvertedFileByFileUIDInspect()

			m.MinimockDeleteFilesInspect()

			m.MinimockDeleteFilesWithPrefixInspect()

			m.MinimockDeleteFilesWorkflowInspect()

			m.MinimockDeleteKnowledgeBaseInspect()

			m.MinimockDeleteRepositoryTagInspect()

			m.MinimockDeleteTextChunksByFileUIDInspect()

			m.MinimockEmbedTextsWorkflowInspect()

			m.MinimockEmbeddingTextBatchInspect()

			m.MinimockEmbeddingTextPipeInspect()

			m.MinimockGenerateSummaryInspect()

			m.MinimockGetChunksByFileInspect()

			m.MinimockGetDownloadURLInspect()

			m.MinimockGetFilesByPathsInspect()

			m.MinimockGetFilesWorkflowInspect()

			m.MinimockGetNamespaceAndCheckPermissionInspect()

			m.MinimockGetNamespaceByNsIDInspect()

			m.MinimockGetRepositoryTagInspect()

			m.MinimockGetUploadURLInspect()

			m.MinimockListRepositoryTagsInspect()

			m.MinimockMinIOInspect()

			m.MinimockProcessFileWorkflowInspect()

			m.MinimockQuestionAnsweringPipeInspect()

			m.MinimockRedisClientInspect()

			m.MinimockRepositoryInspect()

			m.MinimockSimilarityChunksSearchInspect()

			m.MinimockTriggerCleanupKnowledgeBaseWorkflowInspect()

			m.MinimockVectorDBInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockACLClientDone() &&
		m.MinimockCheckCatalogUserPermissionDone() &&
		m.MinimockCheckNamespacePermissionDone() &&
		m.MinimockChunkMarkdownPipeDone() &&
		m.MinimockChunkTextPipeDone() &&
		m.MinimockCleanupFileWorkflowDone() &&
		m.MinimockCleanupKnowledgeBaseWorkflowDone() &&
		m.MinimockConvertToMDPipeDone() &&
		m.MinimockCreateRepositoryTagDone() &&
		m.MinimockDeleteConvertedFileByFileUIDDone() &&
		m.MinimockDeleteFilesDone() &&
		m.MinimockDeleteFilesWithPrefixDone() &&
		m.MinimockDeleteFilesWorkflowDone() &&
		m.MinimockDeleteKnowledgeBaseDone() &&
		m.MinimockDeleteRepositoryTagDone() &&
		m.MinimockDeleteTextChunksByFileUIDDone() &&
		m.MinimockEmbedTextsWorkflowDone() &&
		m.MinimockEmbeddingTextBatchDone() &&
		m.MinimockEmbeddingTextPipeDone() &&
		m.MinimockGenerateSummaryDone() &&
		m.MinimockGetChunksByFileDone() &&
		m.MinimockGetDownloadURLDone() &&
		m.MinimockGetFilesByPathsDone() &&
		m.MinimockGetFilesWorkflowDone() &&
		m.MinimockGetNamespaceAndCheckPermissionDone() &&
		m.MinimockGetNamespaceByNsIDDone() &&
		m.MinimockGetRepositoryTagDone() &&
		m.MinimockGetUploadURLDone() &&
		m.MinimockListRepositoryTagsDone() &&
		m.MinimockMinIODone() &&
		m.MinimockProcessFileWorkflowDone() &&
		m.MinimockQuestionAnsweringPipeDone() &&
		m.MinimockRedisClientDone() &&
		m.MinimockRepositoryDone() &&
		m.MinimockSimilarityChunksSearchDone() &&
		m.MinimockTriggerCleanupKnowledgeBaseWorkflowDone() &&
		m.MinimockVectorDBDone()
}
