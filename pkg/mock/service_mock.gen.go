// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/instill-ai/artifact-backend/pkg/acl"
	"github.com/instill-ai/artifact-backend/pkg/repository"
	"github.com/instill-ai/artifact-backend/pkg/resource"
	mm_service "github.com/instill-ai/artifact-backend/pkg/service"
	"github.com/instill-ai/artifact-backend/pkg/types"
	artifactpb "github.com/instill-ai/protogen-go/artifact/artifact/v1alpha"
	pipelinepb "github.com/instill-ai/protogen-go/pipeline/pipeline/v1beta"
	"github.com/redis/go-redis/v9"
)

// ServiceMock implements mm_service.Service
type ServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcACLClient          func() (ap1 *acl.ACLClient)
	funcACLClientOrigin    string
	inspectFuncACLClient   func()
	afterACLClientCounter  uint64
	beforeACLClientCounter uint64
	ACLClientMock          mServiceMockACLClient

	funcAbortKnowledgeBaseUpdateAdmin          func(ctx context.Context, ap1 *artifactpb.AbortKnowledgeBaseUpdateAdminRequest) (ap2 *artifactpb.AbortKnowledgeBaseUpdateAdminResponse, err error)
	funcAbortKnowledgeBaseUpdateAdminOrigin    string
	inspectFuncAbortKnowledgeBaseUpdateAdmin   func(ctx context.Context, ap1 *artifactpb.AbortKnowledgeBaseUpdateAdminRequest)
	afterAbortKnowledgeBaseUpdateAdminCounter  uint64
	beforeAbortKnowledgeBaseUpdateAdminCounter uint64
	AbortKnowledgeBaseUpdateAdminMock          mServiceMockAbortKnowledgeBaseUpdateAdmin

	funcCheckCatalogUserPermission          func(ctx context.Context, s1 string, s2 string, s3 string) (np1 *resource.Namespace, kp1 *repository.KnowledgeBaseModel, err error)
	funcCheckCatalogUserPermissionOrigin    string
	inspectFuncCheckCatalogUserPermission   func(ctx context.Context, s1 string, s2 string, s3 string)
	afterCheckCatalogUserPermissionCounter  uint64
	beforeCheckCatalogUserPermissionCounter uint64
	CheckCatalogUserPermissionMock          mServiceMockCheckCatalogUserPermission

	funcCheckNamespacePermission          func(ctx context.Context, np1 *resource.Namespace) (err error)
	funcCheckNamespacePermissionOrigin    string
	inspectFuncCheckNamespacePermission   func(ctx context.Context, np1 *resource.Namespace)
	afterCheckNamespacePermissionCounter  uint64
	beforeCheckNamespacePermissionCounter uint64
	CheckNamespacePermissionMock          mServiceMockCheckNamespacePermission

	funcCleanupFile          func(ctx context.Context, f1 types.FileUIDType, u1 types.UserUIDType, r1 types.RequesterUIDType, s1 string, b1 bool) (err error)
	funcCleanupFileOrigin    string
	inspectFuncCleanupFile   func(ctx context.Context, f1 types.FileUIDType, u1 types.UserUIDType, r1 types.RequesterUIDType, s1 string, b1 bool)
	afterCleanupFileCounter  uint64
	beforeCleanupFileCounter uint64
	CleanupFileMock          mServiceMockCleanupFile

	funcCleanupKnowledgeBase          func(ctx context.Context, k1 types.KBUIDType) (err error)
	funcCleanupKnowledgeBaseOrigin    string
	inspectFuncCleanupKnowledgeBase   func(ctx context.Context, k1 types.KBUIDType)
	afterCleanupKnowledgeBaseCounter  uint64
	beforeCleanupKnowledgeBaseCounter uint64
	CleanupKnowledgeBaseMock          mServiceMockCleanupKnowledgeBase

	funcCreateRepositoryTag          func(ctx context.Context, cp1 *artifactpb.CreateRepositoryTagRequest) (cp2 *artifactpb.CreateRepositoryTagResponse, err error)
	funcCreateRepositoryTagOrigin    string
	inspectFuncCreateRepositoryTag   func(ctx context.Context, cp1 *artifactpb.CreateRepositoryTagRequest)
	afterCreateRepositoryTagCounter  uint64
	beforeCreateRepositoryTagCounter uint64
	CreateRepositoryTagMock          mServiceMockCreateRepositoryTag

	funcCreateSystemAdmin          func(ctx context.Context, cp1 *artifactpb.CreateSystemAdminRequest) (cp2 *artifactpb.CreateSystemAdminResponse, err error)
	funcCreateSystemAdminOrigin    string
	inspectFuncCreateSystemAdmin   func(ctx context.Context, cp1 *artifactpb.CreateSystemAdminRequest)
	afterCreateSystemAdminCounter  uint64
	beforeCreateSystemAdminCounter uint64
	CreateSystemAdminMock          mServiceMockCreateSystemAdmin

	funcDeleteFiles          func(ctx context.Context, s1 string, sa1 []string) (err error)
	funcDeleteFilesOrigin    string
	inspectFuncDeleteFiles   func(ctx context.Context, s1 string, sa1 []string)
	afterDeleteFilesCounter  uint64
	beforeDeleteFilesCounter uint64
	DeleteFilesMock          mServiceMockDeleteFiles

	funcDeleteRepositoryTag          func(ctx context.Context, dp1 *artifactpb.DeleteRepositoryTagRequest) (dp2 *artifactpb.DeleteRepositoryTagResponse, err error)
	funcDeleteRepositoryTagOrigin    string
	inspectFuncDeleteRepositoryTag   func(ctx context.Context, dp1 *artifactpb.DeleteRepositoryTagRequest)
	afterDeleteRepositoryTagCounter  uint64
	beforeDeleteRepositoryTagCounter uint64
	DeleteRepositoryTagMock          mServiceMockDeleteRepositoryTag

	funcDeleteSystemAdmin          func(ctx context.Context, s1 string) (dp1 *artifactpb.DeleteSystemAdminResponse, err error)
	funcDeleteSystemAdminOrigin    string
	inspectFuncDeleteSystemAdmin   func(ctx context.Context, s1 string)
	afterDeleteSystemAdminCounter  uint64
	beforeDeleteSystemAdminCounter uint64
	DeleteSystemAdminMock          mServiceMockDeleteSystemAdmin

	funcEmbedTexts          func(ctx context.Context, kp1 *types.KBUIDType, sa1 []string, s1 string) (faa1 [][]float32, err error)
	funcEmbedTextsOrigin    string
	inspectFuncEmbedTexts   func(ctx context.Context, kp1 *types.KBUIDType, sa1 []string, s1 string)
	afterEmbedTextsCounter  uint64
	beforeEmbedTextsCounter uint64
	EmbedTextsMock          mServiceMockEmbedTexts

	funcExecuteKnowledgeBaseUpdateAdmin          func(ctx context.Context, ep1 *artifactpb.ExecuteKnowledgeBaseUpdateAdminRequest) (ep2 *artifactpb.ExecuteKnowledgeBaseUpdateAdminResponse, err error)
	funcExecuteKnowledgeBaseUpdateAdminOrigin    string
	inspectFuncExecuteKnowledgeBaseUpdateAdmin   func(ctx context.Context, ep1 *artifactpb.ExecuteKnowledgeBaseUpdateAdminRequest)
	afterExecuteKnowledgeBaseUpdateAdminCounter  uint64
	beforeExecuteKnowledgeBaseUpdateAdminCounter uint64
	ExecuteKnowledgeBaseUpdateAdminMock          mServiceMockExecuteKnowledgeBaseUpdateAdmin

	funcGetChunksByFile          func(ctx context.Context, kp1 *repository.KnowledgeBaseFileModel) (s1 types.SourceTableType, s2 types.SourceUIDType, ta1 []repository.TextChunkModel, sa1 []string, err error)
	funcGetChunksByFileOrigin    string
	inspectFuncGetChunksByFile   func(ctx context.Context, kp1 *repository.KnowledgeBaseFileModel)
	afterGetChunksByFileCounter  uint64
	beforeGetChunksByFileCounter uint64
	GetChunksByFileMock          mServiceMockGetChunksByFile

	funcGetConvertedFilePathsByFileUID          func(ctx context.Context, k1 types.KBUIDType, f1 types.FileUIDType) (sa1 []string, err error)
	funcGetConvertedFilePathsByFileUIDOrigin    string
	inspectFuncGetConvertedFilePathsByFileUID   func(ctx context.Context, k1 types.KBUIDType, f1 types.FileUIDType)
	afterGetConvertedFilePathsByFileUIDCounter  uint64
	beforeGetConvertedFilePathsByFileUIDCounter uint64
	GetConvertedFilePathsByFileUIDMock          mServiceMockGetConvertedFilePathsByFileUID

	funcGetDefaultSystemAdmin          func(ctx context.Context, gp1 *artifactpb.GetDefaultSystemAdminRequest) (gp2 *artifactpb.GetDefaultSystemAdminResponse, err error)
	funcGetDefaultSystemAdminOrigin    string
	inspectFuncGetDefaultSystemAdmin   func(ctx context.Context, gp1 *artifactpb.GetDefaultSystemAdminRequest)
	afterGetDefaultSystemAdminCounter  uint64
	beforeGetDefaultSystemAdminCounter uint64
	GetDefaultSystemAdminMock          mServiceMockGetDefaultSystemAdmin

	funcGetDownloadURL          func(ctx context.Context, gp1 *artifactpb.GetObjectDownloadURLRequest, n1 types.NamespaceUIDType, s1 string) (gp2 *artifactpb.GetObjectDownloadURLResponse, err error)
	funcGetDownloadURLOrigin    string
	inspectFuncGetDownloadURL   func(ctx context.Context, gp1 *artifactpb.GetObjectDownloadURLRequest, n1 types.NamespaceUIDType, s1 string)
	afterGetDownloadURLCounter  uint64
	beforeGetDownloadURLCounter uint64
	GetDownloadURLMock          mServiceMockGetDownloadURL

	funcGetFilesByPaths          func(ctx context.Context, s1 string, sa1 []string) (fa1 []mm_service.FileContent, err error)
	funcGetFilesByPathsOrigin    string
	inspectFuncGetFilesByPaths   func(ctx context.Context, s1 string, sa1 []string)
	afterGetFilesByPathsCounter  uint64
	beforeGetFilesByPathsCounter uint64
	GetFilesByPathsMock          mServiceMockGetFilesByPaths

	funcGetKnowledgeBaseUpdateStatusAdmin          func(ctx context.Context) (gp1 *artifactpb.GetKnowledgeBaseUpdateStatusAdminResponse, err error)
	funcGetKnowledgeBaseUpdateStatusAdminOrigin    string
	inspectFuncGetKnowledgeBaseUpdateStatusAdmin   func(ctx context.Context)
	afterGetKnowledgeBaseUpdateStatusAdminCounter  uint64
	beforeGetKnowledgeBaseUpdateStatusAdminCounter uint64
	GetKnowledgeBaseUpdateStatusAdminMock          mServiceMockGetKnowledgeBaseUpdateStatusAdmin

	funcGetNamespaceAndCheckPermission          func(ctx context.Context, s1 string) (np1 *resource.Namespace, err error)
	funcGetNamespaceAndCheckPermissionOrigin    string
	inspectFuncGetNamespaceAndCheckPermission   func(ctx context.Context, s1 string)
	afterGetNamespaceAndCheckPermissionCounter  uint64
	beforeGetNamespaceAndCheckPermissionCounter uint64
	GetNamespaceAndCheckPermissionMock          mServiceMockGetNamespaceAndCheckPermission

	funcGetNamespaceByNsID          func(ctx context.Context, s1 string) (np1 *resource.Namespace, err error)
	funcGetNamespaceByNsIDOrigin    string
	inspectFuncGetNamespaceByNsID   func(ctx context.Context, s1 string)
	afterGetNamespaceByNsIDCounter  uint64
	beforeGetNamespaceByNsIDCounter uint64
	GetNamespaceByNsIDMock          mServiceMockGetNamespaceByNsID

	funcGetRepositoryTag          func(ctx context.Context, gp1 *artifactpb.GetRepositoryTagRequest) (gp2 *artifactpb.GetRepositoryTagResponse, err error)
	funcGetRepositoryTagOrigin    string
	inspectFuncGetRepositoryTag   func(ctx context.Context, gp1 *artifactpb.GetRepositoryTagRequest)
	afterGetRepositoryTagCounter  uint64
	beforeGetRepositoryTagCounter uint64
	GetRepositoryTagMock          mServiceMockGetRepositoryTag

	funcGetSystemAdmin          func(ctx context.Context, s1 string) (gp1 *artifactpb.GetSystemAdminResponse, err error)
	funcGetSystemAdminOrigin    string
	inspectFuncGetSystemAdmin   func(ctx context.Context, s1 string)
	afterGetSystemAdminCounter  uint64
	beforeGetSystemAdminCounter uint64
	GetSystemAdminMock          mServiceMockGetSystemAdmin

	funcGetTextChunkFilePathsByFileUID          func(ctx context.Context, k1 types.KBUIDType, f1 types.FileUIDType) (sa1 []string, err error)
	funcGetTextChunkFilePathsByFileUIDOrigin    string
	inspectFuncGetTextChunkFilePathsByFileUID   func(ctx context.Context, k1 types.KBUIDType, f1 types.FileUIDType)
	afterGetTextChunkFilePathsByFileUIDCounter  uint64
	beforeGetTextChunkFilePathsByFileUIDCounter uint64
	GetTextChunkFilePathsByFileUIDMock          mServiceMockGetTextChunkFilePathsByFileUID

	funcGetUploadURL          func(ctx context.Context, gp1 *artifactpb.GetObjectUploadURLRequest, n1 types.NamespaceUIDType, s1 string, c2 types.CreatorUIDType) (gp2 *artifactpb.GetObjectUploadURLResponse, err error)
	funcGetUploadURLOrigin    string
	inspectFuncGetUploadURL   func(ctx context.Context, gp1 *artifactpb.GetObjectUploadURLRequest, n1 types.NamespaceUIDType, s1 string, c2 types.CreatorUIDType)
	afterGetUploadURLCounter  uint64
	beforeGetUploadURLCounter uint64
	GetUploadURLMock          mServiceMockGetUploadURL

	funcListRepositoryTags          func(ctx context.Context, lp1 *artifactpb.ListRepositoryTagsRequest) (lp2 *artifactpb.ListRepositoryTagsResponse, err error)
	funcListRepositoryTagsOrigin    string
	inspectFuncListRepositoryTags   func(ctx context.Context, lp1 *artifactpb.ListRepositoryTagsRequest)
	afterListRepositoryTagsCounter  uint64
	beforeListRepositoryTagsCounter uint64
	ListRepositoryTagsMock          mServiceMockListRepositoryTags

	funcListSystemsAdmin          func(ctx context.Context) (lp1 *artifactpb.ListSystemsAdminResponse, err error)
	funcListSystemsAdminOrigin    string
	inspectFuncListSystemsAdmin   func(ctx context.Context)
	afterListSystemsAdminCounter  uint64
	beforeListSystemsAdminCounter uint64
	ListSystemsAdminMock          mServiceMockListSystemsAdmin

	funcPipelinePublicClient          func() (p1 pipelinepb.PipelinePublicServiceClient)
	funcPipelinePublicClientOrigin    string
	inspectFuncPipelinePublicClient   func()
	afterPipelinePublicClientCounter  uint64
	beforePipelinePublicClientCounter uint64
	PipelinePublicClientMock          mServiceMockPipelinePublicClient

	funcProcessFile          func(ctx context.Context, k1 types.KBUIDType, fa1 []types.FileUIDType, u1 types.UserUIDType, r1 types.RequesterUIDType) (err error)
	funcProcessFileOrigin    string
	inspectFuncProcessFile   func(ctx context.Context, k1 types.KBUIDType, fa1 []types.FileUIDType, u1 types.UserUIDType, r1 types.RequesterUIDType)
	afterProcessFileCounter  uint64
	beforeProcessFileCounter uint64
	ProcessFileMock          mServiceMockProcessFile

	funcProcessFileDualMode          func(ctx context.Context, prodKBUID types.KBUIDType, stagingKBUID types.KBUIDType, fileUIDs []types.FileUIDType, userUID types.RequesterUIDType, requesterUID types.RequesterUIDType) (err error)
	funcProcessFileDualModeOrigin    string
	inspectFuncProcessFileDualMode   func(ctx context.Context, prodKBUID types.KBUIDType, stagingKBUID types.KBUIDType, fileUIDs []types.FileUIDType, userUID types.RequesterUIDType, requesterUID types.RequesterUIDType)
	afterProcessFileDualModeCounter  uint64
	beforeProcessFileDualModeCounter uint64
	ProcessFileDualModeMock          mServiceMockProcessFileDualMode

	funcPurgeRollbackAdmin          func(ctx context.Context, o1 types.OwnerUIDType, s1 string) (pp1 *artifactpb.PurgeRollbackAdminResponse, err error)
	funcPurgeRollbackAdminOrigin    string
	inspectFuncPurgeRollbackAdmin   func(ctx context.Context, o1 types.OwnerUIDType, s1 string)
	afterPurgeRollbackAdminCounter  uint64
	beforePurgeRollbackAdminCounter uint64
	PurgeRollbackAdminMock          mServiceMockPurgeRollbackAdmin

	funcRedisClient          func() (cp1 *redis.Client)
	funcRedisClientOrigin    string
	inspectFuncRedisClient   func()
	afterRedisClientCounter  uint64
	beforeRedisClientCounter uint64
	RedisClientMock          mServiceMockRedisClient

	funcRenameSystemAdmin          func(ctx context.Context, rp1 *artifactpb.RenameSystemAdminRequest) (rp2 *artifactpb.RenameSystemAdminResponse, err error)
	funcRenameSystemAdminOrigin    string
	inspectFuncRenameSystemAdmin   func(ctx context.Context, rp1 *artifactpb.RenameSystemAdminRequest)
	afterRenameSystemAdminCounter  uint64
	beforeRenameSystemAdminCounter uint64
	RenameSystemAdminMock          mServiceMockRenameSystemAdmin

	funcRepository          func() (r1 repository.Repository)
	funcRepositoryOrigin    string
	inspectFuncRepository   func()
	afterRepositoryCounter  uint64
	beforeRepositoryCounter uint64
	RepositoryMock          mServiceMockRepository

	funcRollbackAdmin          func(ctx context.Context, o1 types.OwnerUIDType, s1 string) (rp1 *artifactpb.RollbackAdminResponse, err error)
	funcRollbackAdminOrigin    string
	inspectFuncRollbackAdmin   func(ctx context.Context, o1 types.OwnerUIDType, s1 string)
	afterRollbackAdminCounter  uint64
	beforeRollbackAdminCounter uint64
	RollbackAdminMock          mServiceMockRollbackAdmin

	funcSetDefaultSystemAdmin          func(ctx context.Context, sp1 *artifactpb.SetDefaultSystemAdminRequest) (sp2 *artifactpb.SetDefaultSystemAdminResponse, err error)
	funcSetDefaultSystemAdminOrigin    string
	inspectFuncSetDefaultSystemAdmin   func(ctx context.Context, sp1 *artifactpb.SetDefaultSystemAdminRequest)
	afterSetDefaultSystemAdminCounter  uint64
	beforeSetDefaultSystemAdminCounter uint64
	SetDefaultSystemAdminMock          mServiceMockSetDefaultSystemAdmin

	funcSetRollbackRetentionAdmin          func(ctx context.Context, o1 types.OwnerUIDType, s1 string, i1 int32, s2 artifactpb.SetRollbackRetentionAdminRequest_TimeUnit) (sp1 *artifactpb.SetRollbackRetentionAdminResponse, err error)
	funcSetRollbackRetentionAdminOrigin    string
	inspectFuncSetRollbackRetentionAdmin   func(ctx context.Context, o1 types.OwnerUIDType, s1 string, i1 int32, s2 artifactpb.SetRollbackRetentionAdminRequest_TimeUnit)
	afterSetRollbackRetentionAdminCounter  uint64
	beforeSetRollbackRetentionAdminCounter uint64
	SetRollbackRetentionAdminMock          mServiceMockSetRollbackRetentionAdmin

	funcSimilarityChunksSearch          func(ctx context.Context, o1 types.OwnerUIDType, sp1 *artifactpb.SimilarityChunksSearchRequest, faa1 [][]float32) (sa1 []mm_service.SimChunk, err error)
	funcSimilarityChunksSearchOrigin    string
	inspectFuncSimilarityChunksSearch   func(ctx context.Context, o1 types.OwnerUIDType, sp1 *artifactpb.SimilarityChunksSearchRequest, faa1 [][]float32)
	afterSimilarityChunksSearchCounter  uint64
	beforeSimilarityChunksSearchCounter uint64
	SimilarityChunksSearchMock          mServiceMockSimilarityChunksSearch

	funcUpdateSystemAdmin          func(ctx context.Context, up1 *artifactpb.UpdateSystemAdminRequest) (up2 *artifactpb.UpdateSystemAdminResponse, err error)
	funcUpdateSystemAdminOrigin    string
	inspectFuncUpdateSystemAdmin   func(ctx context.Context, up1 *artifactpb.UpdateSystemAdminRequest)
	afterUpdateSystemAdminCounter  uint64
	beforeUpdateSystemAdminCounter uint64
	UpdateSystemAdminMock          mServiceMockUpdateSystemAdmin
}

// NewServiceMock returns a mock for mm_service.Service
func NewServiceMock(t minimock.Tester) *ServiceMock {
	m := &ServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ACLClientMock = mServiceMockACLClient{mock: m}

	m.AbortKnowledgeBaseUpdateAdminMock = mServiceMockAbortKnowledgeBaseUpdateAdmin{mock: m}
	m.AbortKnowledgeBaseUpdateAdminMock.callArgs = []*ServiceMockAbortKnowledgeBaseUpdateAdminParams{}

	m.CheckCatalogUserPermissionMock = mServiceMockCheckCatalogUserPermission{mock: m}
	m.CheckCatalogUserPermissionMock.callArgs = []*ServiceMockCheckCatalogUserPermissionParams{}

	m.CheckNamespacePermissionMock = mServiceMockCheckNamespacePermission{mock: m}
	m.CheckNamespacePermissionMock.callArgs = []*ServiceMockCheckNamespacePermissionParams{}

	m.CleanupFileMock = mServiceMockCleanupFile{mock: m}
	m.CleanupFileMock.callArgs = []*ServiceMockCleanupFileParams{}

	m.CleanupKnowledgeBaseMock = mServiceMockCleanupKnowledgeBase{mock: m}
	m.CleanupKnowledgeBaseMock.callArgs = []*ServiceMockCleanupKnowledgeBaseParams{}

	m.CreateRepositoryTagMock = mServiceMockCreateRepositoryTag{mock: m}
	m.CreateRepositoryTagMock.callArgs = []*ServiceMockCreateRepositoryTagParams{}

	m.CreateSystemAdminMock = mServiceMockCreateSystemAdmin{mock: m}
	m.CreateSystemAdminMock.callArgs = []*ServiceMockCreateSystemAdminParams{}

	m.DeleteFilesMock = mServiceMockDeleteFiles{mock: m}
	m.DeleteFilesMock.callArgs = []*ServiceMockDeleteFilesParams{}

	m.DeleteRepositoryTagMock = mServiceMockDeleteRepositoryTag{mock: m}
	m.DeleteRepositoryTagMock.callArgs = []*ServiceMockDeleteRepositoryTagParams{}

	m.DeleteSystemAdminMock = mServiceMockDeleteSystemAdmin{mock: m}
	m.DeleteSystemAdminMock.callArgs = []*ServiceMockDeleteSystemAdminParams{}

	m.EmbedTextsMock = mServiceMockEmbedTexts{mock: m}
	m.EmbedTextsMock.callArgs = []*ServiceMockEmbedTextsParams{}

	m.ExecuteKnowledgeBaseUpdateAdminMock = mServiceMockExecuteKnowledgeBaseUpdateAdmin{mock: m}
	m.ExecuteKnowledgeBaseUpdateAdminMock.callArgs = []*ServiceMockExecuteKnowledgeBaseUpdateAdminParams{}

	m.GetChunksByFileMock = mServiceMockGetChunksByFile{mock: m}
	m.GetChunksByFileMock.callArgs = []*ServiceMockGetChunksByFileParams{}

	m.GetConvertedFilePathsByFileUIDMock = mServiceMockGetConvertedFilePathsByFileUID{mock: m}
	m.GetConvertedFilePathsByFileUIDMock.callArgs = []*ServiceMockGetConvertedFilePathsByFileUIDParams{}

	m.GetDefaultSystemAdminMock = mServiceMockGetDefaultSystemAdmin{mock: m}
	m.GetDefaultSystemAdminMock.callArgs = []*ServiceMockGetDefaultSystemAdminParams{}

	m.GetDownloadURLMock = mServiceMockGetDownloadURL{mock: m}
	m.GetDownloadURLMock.callArgs = []*ServiceMockGetDownloadURLParams{}

	m.GetFilesByPathsMock = mServiceMockGetFilesByPaths{mock: m}
	m.GetFilesByPathsMock.callArgs = []*ServiceMockGetFilesByPathsParams{}

	m.GetKnowledgeBaseUpdateStatusAdminMock = mServiceMockGetKnowledgeBaseUpdateStatusAdmin{mock: m}
	m.GetKnowledgeBaseUpdateStatusAdminMock.callArgs = []*ServiceMockGetKnowledgeBaseUpdateStatusAdminParams{}

	m.GetNamespaceAndCheckPermissionMock = mServiceMockGetNamespaceAndCheckPermission{mock: m}
	m.GetNamespaceAndCheckPermissionMock.callArgs = []*ServiceMockGetNamespaceAndCheckPermissionParams{}

	m.GetNamespaceByNsIDMock = mServiceMockGetNamespaceByNsID{mock: m}
	m.GetNamespaceByNsIDMock.callArgs = []*ServiceMockGetNamespaceByNsIDParams{}

	m.GetRepositoryTagMock = mServiceMockGetRepositoryTag{mock: m}
	m.GetRepositoryTagMock.callArgs = []*ServiceMockGetRepositoryTagParams{}

	m.GetSystemAdminMock = mServiceMockGetSystemAdmin{mock: m}
	m.GetSystemAdminMock.callArgs = []*ServiceMockGetSystemAdminParams{}

	m.GetTextChunkFilePathsByFileUIDMock = mServiceMockGetTextChunkFilePathsByFileUID{mock: m}
	m.GetTextChunkFilePathsByFileUIDMock.callArgs = []*ServiceMockGetTextChunkFilePathsByFileUIDParams{}

	m.GetUploadURLMock = mServiceMockGetUploadURL{mock: m}
	m.GetUploadURLMock.callArgs = []*ServiceMockGetUploadURLParams{}

	m.ListRepositoryTagsMock = mServiceMockListRepositoryTags{mock: m}
	m.ListRepositoryTagsMock.callArgs = []*ServiceMockListRepositoryTagsParams{}

	m.ListSystemsAdminMock = mServiceMockListSystemsAdmin{mock: m}
	m.ListSystemsAdminMock.callArgs = []*ServiceMockListSystemsAdminParams{}

	m.PipelinePublicClientMock = mServiceMockPipelinePublicClient{mock: m}

	m.ProcessFileMock = mServiceMockProcessFile{mock: m}
	m.ProcessFileMock.callArgs = []*ServiceMockProcessFileParams{}

	m.ProcessFileDualModeMock = mServiceMockProcessFileDualMode{mock: m}
	m.ProcessFileDualModeMock.callArgs = []*ServiceMockProcessFileDualModeParams{}

	m.PurgeRollbackAdminMock = mServiceMockPurgeRollbackAdmin{mock: m}
	m.PurgeRollbackAdminMock.callArgs = []*ServiceMockPurgeRollbackAdminParams{}

	m.RedisClientMock = mServiceMockRedisClient{mock: m}

	m.RenameSystemAdminMock = mServiceMockRenameSystemAdmin{mock: m}
	m.RenameSystemAdminMock.callArgs = []*ServiceMockRenameSystemAdminParams{}

	m.RepositoryMock = mServiceMockRepository{mock: m}

	m.RollbackAdminMock = mServiceMockRollbackAdmin{mock: m}
	m.RollbackAdminMock.callArgs = []*ServiceMockRollbackAdminParams{}

	m.SetDefaultSystemAdminMock = mServiceMockSetDefaultSystemAdmin{mock: m}
	m.SetDefaultSystemAdminMock.callArgs = []*ServiceMockSetDefaultSystemAdminParams{}

	m.SetRollbackRetentionAdminMock = mServiceMockSetRollbackRetentionAdmin{mock: m}
	m.SetRollbackRetentionAdminMock.callArgs = []*ServiceMockSetRollbackRetentionAdminParams{}

	m.SimilarityChunksSearchMock = mServiceMockSimilarityChunksSearch{mock: m}
	m.SimilarityChunksSearchMock.callArgs = []*ServiceMockSimilarityChunksSearchParams{}

	m.UpdateSystemAdminMock = mServiceMockUpdateSystemAdmin{mock: m}
	m.UpdateSystemAdminMock.callArgs = []*ServiceMockUpdateSystemAdminParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mServiceMockACLClient struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockACLClientExpectation
	expectations       []*ServiceMockACLClientExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockACLClientExpectation specifies expectation struct of the Service.ACLClient
type ServiceMockACLClientExpectation struct {
	mock *ServiceMock

	results      *ServiceMockACLClientResults
	returnOrigin string
	Counter      uint64
}

// ServiceMockACLClientResults contains results of the Service.ACLClient
type ServiceMockACLClientResults struct {
	ap1 *acl.ACLClient
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmACLClient *mServiceMockACLClient) Optional() *mServiceMockACLClient {
	mmACLClient.optional = true
	return mmACLClient
}

// Expect sets up expected params for Service.ACLClient
func (mmACLClient *mServiceMockACLClient) Expect() *mServiceMockACLClient {
	if mmACLClient.mock.funcACLClient != nil {
		mmACLClient.mock.t.Fatalf("ServiceMock.ACLClient mock is already set by Set")
	}

	if mmACLClient.defaultExpectation == nil {
		mmACLClient.defaultExpectation = &ServiceMockACLClientExpectation{}
	}

	return mmACLClient
}

// Inspect accepts an inspector function that has same arguments as the Service.ACLClient
func (mmACLClient *mServiceMockACLClient) Inspect(f func()) *mServiceMockACLClient {
	if mmACLClient.mock.inspectFuncACLClient != nil {
		mmACLClient.mock.t.Fatalf("Inspect function is already set for ServiceMock.ACLClient")
	}

	mmACLClient.mock.inspectFuncACLClient = f

	return mmACLClient
}

// Return sets up results that will be returned by Service.ACLClient
func (mmACLClient *mServiceMockACLClient) Return(ap1 *acl.ACLClient) *ServiceMock {
	if mmACLClient.mock.funcACLClient != nil {
		mmACLClient.mock.t.Fatalf("ServiceMock.ACLClient mock is already set by Set")
	}

	if mmACLClient.defaultExpectation == nil {
		mmACLClient.defaultExpectation = &ServiceMockACLClientExpectation{mock: mmACLClient.mock}
	}
	mmACLClient.defaultExpectation.results = &ServiceMockACLClientResults{ap1}
	mmACLClient.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmACLClient.mock
}

// Set uses given function f to mock the Service.ACLClient method
func (mmACLClient *mServiceMockACLClient) Set(f func() (ap1 *acl.ACLClient)) *ServiceMock {
	if mmACLClient.defaultExpectation != nil {
		mmACLClient.mock.t.Fatalf("Default expectation is already set for the Service.ACLClient method")
	}

	if len(mmACLClient.expectations) > 0 {
		mmACLClient.mock.t.Fatalf("Some expectations are already set for the Service.ACLClient method")
	}

	mmACLClient.mock.funcACLClient = f
	mmACLClient.mock.funcACLClientOrigin = minimock.CallerInfo(1)
	return mmACLClient.mock
}

// Times sets number of times Service.ACLClient should be invoked
func (mmACLClient *mServiceMockACLClient) Times(n uint64) *mServiceMockACLClient {
	if n == 0 {
		mmACLClient.mock.t.Fatalf("Times of ServiceMock.ACLClient mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmACLClient.expectedInvocations, n)
	mmACLClient.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmACLClient
}

func (mmACLClient *mServiceMockACLClient) invocationsDone() bool {
	if len(mmACLClient.expectations) == 0 && mmACLClient.defaultExpectation == nil && mmACLClient.mock.funcACLClient == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmACLClient.mock.afterACLClientCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmACLClient.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ACLClient implements mm_service.Service
func (mmACLClient *ServiceMock) ACLClient() (ap1 *acl.ACLClient) {
	mm_atomic.AddUint64(&mmACLClient.beforeACLClientCounter, 1)
	defer mm_atomic.AddUint64(&mmACLClient.afterACLClientCounter, 1)

	mmACLClient.t.Helper()

	if mmACLClient.inspectFuncACLClient != nil {
		mmACLClient.inspectFuncACLClient()
	}

	if mmACLClient.ACLClientMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmACLClient.ACLClientMock.defaultExpectation.Counter, 1)

		mm_results := mmACLClient.ACLClientMock.defaultExpectation.results
		if mm_results == nil {
			mmACLClient.t.Fatal("No results are set for the ServiceMock.ACLClient")
		}
		return (*mm_results).ap1
	}
	if mmACLClient.funcACLClient != nil {
		return mmACLClient.funcACLClient()
	}
	mmACLClient.t.Fatalf("Unexpected call to ServiceMock.ACLClient.")
	return
}

// ACLClientAfterCounter returns a count of finished ServiceMock.ACLClient invocations
func (mmACLClient *ServiceMock) ACLClientAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmACLClient.afterACLClientCounter)
}

// ACLClientBeforeCounter returns a count of ServiceMock.ACLClient invocations
func (mmACLClient *ServiceMock) ACLClientBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmACLClient.beforeACLClientCounter)
}

// MinimockACLClientDone returns true if the count of the ACLClient invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockACLClientDone() bool {
	if m.ACLClientMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ACLClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ACLClientMock.invocationsDone()
}

// MinimockACLClientInspect logs each unmet expectation
func (m *ServiceMock) MinimockACLClientInspect() {
	for _, e := range m.ACLClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServiceMock.ACLClient")
		}
	}

	afterACLClientCounter := mm_atomic.LoadUint64(&m.afterACLClientCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ACLClientMock.defaultExpectation != nil && afterACLClientCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.ACLClient at\n%s", m.ACLClientMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcACLClient != nil && afterACLClientCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.ACLClient at\n%s", m.funcACLClientOrigin)
	}

	if !m.ACLClientMock.invocationsDone() && afterACLClientCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.ACLClient at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ACLClientMock.expectedInvocations), m.ACLClientMock.expectedInvocationsOrigin, afterACLClientCounter)
	}
}

type mServiceMockAbortKnowledgeBaseUpdateAdmin struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockAbortKnowledgeBaseUpdateAdminExpectation
	expectations       []*ServiceMockAbortKnowledgeBaseUpdateAdminExpectation

	callArgs []*ServiceMockAbortKnowledgeBaseUpdateAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockAbortKnowledgeBaseUpdateAdminExpectation specifies expectation struct of the Service.AbortKnowledgeBaseUpdateAdmin
type ServiceMockAbortKnowledgeBaseUpdateAdminExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockAbortKnowledgeBaseUpdateAdminParams
	paramPtrs          *ServiceMockAbortKnowledgeBaseUpdateAdminParamPtrs
	expectationOrigins ServiceMockAbortKnowledgeBaseUpdateAdminExpectationOrigins
	results            *ServiceMockAbortKnowledgeBaseUpdateAdminResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockAbortKnowledgeBaseUpdateAdminParams contains parameters of the Service.AbortKnowledgeBaseUpdateAdmin
type ServiceMockAbortKnowledgeBaseUpdateAdminParams struct {
	ctx context.Context
	ap1 *artifactpb.AbortKnowledgeBaseUpdateAdminRequest
}

// ServiceMockAbortKnowledgeBaseUpdateAdminParamPtrs contains pointers to parameters of the Service.AbortKnowledgeBaseUpdateAdmin
type ServiceMockAbortKnowledgeBaseUpdateAdminParamPtrs struct {
	ctx *context.Context
	ap1 **artifactpb.AbortKnowledgeBaseUpdateAdminRequest
}

// ServiceMockAbortKnowledgeBaseUpdateAdminResults contains results of the Service.AbortKnowledgeBaseUpdateAdmin
type ServiceMockAbortKnowledgeBaseUpdateAdminResults struct {
	ap2 *artifactpb.AbortKnowledgeBaseUpdateAdminResponse
	err error
}

// ServiceMockAbortKnowledgeBaseUpdateAdminOrigins contains origins of expectations of the Service.AbortKnowledgeBaseUpdateAdmin
type ServiceMockAbortKnowledgeBaseUpdateAdminExpectationOrigins struct {
	origin    string
	originCtx string
	originAp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAbortKnowledgeBaseUpdateAdmin *mServiceMockAbortKnowledgeBaseUpdateAdmin) Optional() *mServiceMockAbortKnowledgeBaseUpdateAdmin {
	mmAbortKnowledgeBaseUpdateAdmin.optional = true
	return mmAbortKnowledgeBaseUpdateAdmin
}

// Expect sets up expected params for Service.AbortKnowledgeBaseUpdateAdmin
func (mmAbortKnowledgeBaseUpdateAdmin *mServiceMockAbortKnowledgeBaseUpdateAdmin) Expect(ctx context.Context, ap1 *artifactpb.AbortKnowledgeBaseUpdateAdminRequest) *mServiceMockAbortKnowledgeBaseUpdateAdmin {
	if mmAbortKnowledgeBaseUpdateAdmin.mock.funcAbortKnowledgeBaseUpdateAdmin != nil {
		mmAbortKnowledgeBaseUpdateAdmin.mock.t.Fatalf("ServiceMock.AbortKnowledgeBaseUpdateAdmin mock is already set by Set")
	}

	if mmAbortKnowledgeBaseUpdateAdmin.defaultExpectation == nil {
		mmAbortKnowledgeBaseUpdateAdmin.defaultExpectation = &ServiceMockAbortKnowledgeBaseUpdateAdminExpectation{}
	}

	if mmAbortKnowledgeBaseUpdateAdmin.defaultExpectation.paramPtrs != nil {
		mmAbortKnowledgeBaseUpdateAdmin.mock.t.Fatalf("ServiceMock.AbortKnowledgeBaseUpdateAdmin mock is already set by ExpectParams functions")
	}

	mmAbortKnowledgeBaseUpdateAdmin.defaultExpectation.params = &ServiceMockAbortKnowledgeBaseUpdateAdminParams{ctx, ap1}
	mmAbortKnowledgeBaseUpdateAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAbortKnowledgeBaseUpdateAdmin.expectations {
		if minimock.Equal(e.params, mmAbortKnowledgeBaseUpdateAdmin.defaultExpectation.params) {
			mmAbortKnowledgeBaseUpdateAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAbortKnowledgeBaseUpdateAdmin.defaultExpectation.params)
		}
	}

	return mmAbortKnowledgeBaseUpdateAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Service.AbortKnowledgeBaseUpdateAdmin
func (mmAbortKnowledgeBaseUpdateAdmin *mServiceMockAbortKnowledgeBaseUpdateAdmin) ExpectCtxParam1(ctx context.Context) *mServiceMockAbortKnowledgeBaseUpdateAdmin {
	if mmAbortKnowledgeBaseUpdateAdmin.mock.funcAbortKnowledgeBaseUpdateAdmin != nil {
		mmAbortKnowledgeBaseUpdateAdmin.mock.t.Fatalf("ServiceMock.AbortKnowledgeBaseUpdateAdmin mock is already set by Set")
	}

	if mmAbortKnowledgeBaseUpdateAdmin.defaultExpectation == nil {
		mmAbortKnowledgeBaseUpdateAdmin.defaultExpectation = &ServiceMockAbortKnowledgeBaseUpdateAdminExpectation{}
	}

	if mmAbortKnowledgeBaseUpdateAdmin.defaultExpectation.params != nil {
		mmAbortKnowledgeBaseUpdateAdmin.mock.t.Fatalf("ServiceMock.AbortKnowledgeBaseUpdateAdmin mock is already set by Expect")
	}

	if mmAbortKnowledgeBaseUpdateAdmin.defaultExpectation.paramPtrs == nil {
		mmAbortKnowledgeBaseUpdateAdmin.defaultExpectation.paramPtrs = &ServiceMockAbortKnowledgeBaseUpdateAdminParamPtrs{}
	}
	mmAbortKnowledgeBaseUpdateAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmAbortKnowledgeBaseUpdateAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAbortKnowledgeBaseUpdateAdmin
}

// ExpectAp1Param2 sets up expected param ap1 for Service.AbortKnowledgeBaseUpdateAdmin
func (mmAbortKnowledgeBaseUpdateAdmin *mServiceMockAbortKnowledgeBaseUpdateAdmin) ExpectAp1Param2(ap1 *artifactpb.AbortKnowledgeBaseUpdateAdminRequest) *mServiceMockAbortKnowledgeBaseUpdateAdmin {
	if mmAbortKnowledgeBaseUpdateAdmin.mock.funcAbortKnowledgeBaseUpdateAdmin != nil {
		mmAbortKnowledgeBaseUpdateAdmin.mock.t.Fatalf("ServiceMock.AbortKnowledgeBaseUpdateAdmin mock is already set by Set")
	}

	if mmAbortKnowledgeBaseUpdateAdmin.defaultExpectation == nil {
		mmAbortKnowledgeBaseUpdateAdmin.defaultExpectation = &ServiceMockAbortKnowledgeBaseUpdateAdminExpectation{}
	}

	if mmAbortKnowledgeBaseUpdateAdmin.defaultExpectation.params != nil {
		mmAbortKnowledgeBaseUpdateAdmin.mock.t.Fatalf("ServiceMock.AbortKnowledgeBaseUpdateAdmin mock is already set by Expect")
	}

	if mmAbortKnowledgeBaseUpdateAdmin.defaultExpectation.paramPtrs == nil {
		mmAbortKnowledgeBaseUpdateAdmin.defaultExpectation.paramPtrs = &ServiceMockAbortKnowledgeBaseUpdateAdminParamPtrs{}
	}
	mmAbortKnowledgeBaseUpdateAdmin.defaultExpectation.paramPtrs.ap1 = &ap1
	mmAbortKnowledgeBaseUpdateAdmin.defaultExpectation.expectationOrigins.originAp1 = minimock.CallerInfo(1)

	return mmAbortKnowledgeBaseUpdateAdmin
}

// Inspect accepts an inspector function that has same arguments as the Service.AbortKnowledgeBaseUpdateAdmin
func (mmAbortKnowledgeBaseUpdateAdmin *mServiceMockAbortKnowledgeBaseUpdateAdmin) Inspect(f func(ctx context.Context, ap1 *artifactpb.AbortKnowledgeBaseUpdateAdminRequest)) *mServiceMockAbortKnowledgeBaseUpdateAdmin {
	if mmAbortKnowledgeBaseUpdateAdmin.mock.inspectFuncAbortKnowledgeBaseUpdateAdmin != nil {
		mmAbortKnowledgeBaseUpdateAdmin.mock.t.Fatalf("Inspect function is already set for ServiceMock.AbortKnowledgeBaseUpdateAdmin")
	}

	mmAbortKnowledgeBaseUpdateAdmin.mock.inspectFuncAbortKnowledgeBaseUpdateAdmin = f

	return mmAbortKnowledgeBaseUpdateAdmin
}

// Return sets up results that will be returned by Service.AbortKnowledgeBaseUpdateAdmin
func (mmAbortKnowledgeBaseUpdateAdmin *mServiceMockAbortKnowledgeBaseUpdateAdmin) Return(ap2 *artifactpb.AbortKnowledgeBaseUpdateAdminResponse, err error) *ServiceMock {
	if mmAbortKnowledgeBaseUpdateAdmin.mock.funcAbortKnowledgeBaseUpdateAdmin != nil {
		mmAbortKnowledgeBaseUpdateAdmin.mock.t.Fatalf("ServiceMock.AbortKnowledgeBaseUpdateAdmin mock is already set by Set")
	}

	if mmAbortKnowledgeBaseUpdateAdmin.defaultExpectation == nil {
		mmAbortKnowledgeBaseUpdateAdmin.defaultExpectation = &ServiceMockAbortKnowledgeBaseUpdateAdminExpectation{mock: mmAbortKnowledgeBaseUpdateAdmin.mock}
	}
	mmAbortKnowledgeBaseUpdateAdmin.defaultExpectation.results = &ServiceMockAbortKnowledgeBaseUpdateAdminResults{ap2, err}
	mmAbortKnowledgeBaseUpdateAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAbortKnowledgeBaseUpdateAdmin.mock
}

// Set uses given function f to mock the Service.AbortKnowledgeBaseUpdateAdmin method
func (mmAbortKnowledgeBaseUpdateAdmin *mServiceMockAbortKnowledgeBaseUpdateAdmin) Set(f func(ctx context.Context, ap1 *artifactpb.AbortKnowledgeBaseUpdateAdminRequest) (ap2 *artifactpb.AbortKnowledgeBaseUpdateAdminResponse, err error)) *ServiceMock {
	if mmAbortKnowledgeBaseUpdateAdmin.defaultExpectation != nil {
		mmAbortKnowledgeBaseUpdateAdmin.mock.t.Fatalf("Default expectation is already set for the Service.AbortKnowledgeBaseUpdateAdmin method")
	}

	if len(mmAbortKnowledgeBaseUpdateAdmin.expectations) > 0 {
		mmAbortKnowledgeBaseUpdateAdmin.mock.t.Fatalf("Some expectations are already set for the Service.AbortKnowledgeBaseUpdateAdmin method")
	}

	mmAbortKnowledgeBaseUpdateAdmin.mock.funcAbortKnowledgeBaseUpdateAdmin = f
	mmAbortKnowledgeBaseUpdateAdmin.mock.funcAbortKnowledgeBaseUpdateAdminOrigin = minimock.CallerInfo(1)
	return mmAbortKnowledgeBaseUpdateAdmin.mock
}

// When sets expectation for the Service.AbortKnowledgeBaseUpdateAdmin which will trigger the result defined by the following
// Then helper
func (mmAbortKnowledgeBaseUpdateAdmin *mServiceMockAbortKnowledgeBaseUpdateAdmin) When(ctx context.Context, ap1 *artifactpb.AbortKnowledgeBaseUpdateAdminRequest) *ServiceMockAbortKnowledgeBaseUpdateAdminExpectation {
	if mmAbortKnowledgeBaseUpdateAdmin.mock.funcAbortKnowledgeBaseUpdateAdmin != nil {
		mmAbortKnowledgeBaseUpdateAdmin.mock.t.Fatalf("ServiceMock.AbortKnowledgeBaseUpdateAdmin mock is already set by Set")
	}

	expectation := &ServiceMockAbortKnowledgeBaseUpdateAdminExpectation{
		mock:               mmAbortKnowledgeBaseUpdateAdmin.mock,
		params:             &ServiceMockAbortKnowledgeBaseUpdateAdminParams{ctx, ap1},
		expectationOrigins: ServiceMockAbortKnowledgeBaseUpdateAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAbortKnowledgeBaseUpdateAdmin.expectations = append(mmAbortKnowledgeBaseUpdateAdmin.expectations, expectation)
	return expectation
}

// Then sets up Service.AbortKnowledgeBaseUpdateAdmin return parameters for the expectation previously defined by the When method
func (e *ServiceMockAbortKnowledgeBaseUpdateAdminExpectation) Then(ap2 *artifactpb.AbortKnowledgeBaseUpdateAdminResponse, err error) *ServiceMock {
	e.results = &ServiceMockAbortKnowledgeBaseUpdateAdminResults{ap2, err}
	return e.mock
}

// Times sets number of times Service.AbortKnowledgeBaseUpdateAdmin should be invoked
func (mmAbortKnowledgeBaseUpdateAdmin *mServiceMockAbortKnowledgeBaseUpdateAdmin) Times(n uint64) *mServiceMockAbortKnowledgeBaseUpdateAdmin {
	if n == 0 {
		mmAbortKnowledgeBaseUpdateAdmin.mock.t.Fatalf("Times of ServiceMock.AbortKnowledgeBaseUpdateAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAbortKnowledgeBaseUpdateAdmin.expectedInvocations, n)
	mmAbortKnowledgeBaseUpdateAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAbortKnowledgeBaseUpdateAdmin
}

func (mmAbortKnowledgeBaseUpdateAdmin *mServiceMockAbortKnowledgeBaseUpdateAdmin) invocationsDone() bool {
	if len(mmAbortKnowledgeBaseUpdateAdmin.expectations) == 0 && mmAbortKnowledgeBaseUpdateAdmin.defaultExpectation == nil && mmAbortKnowledgeBaseUpdateAdmin.mock.funcAbortKnowledgeBaseUpdateAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAbortKnowledgeBaseUpdateAdmin.mock.afterAbortKnowledgeBaseUpdateAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAbortKnowledgeBaseUpdateAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AbortKnowledgeBaseUpdateAdmin implements mm_service.Service
func (mmAbortKnowledgeBaseUpdateAdmin *ServiceMock) AbortKnowledgeBaseUpdateAdmin(ctx context.Context, ap1 *artifactpb.AbortKnowledgeBaseUpdateAdminRequest) (ap2 *artifactpb.AbortKnowledgeBaseUpdateAdminResponse, err error) {
	mm_atomic.AddUint64(&mmAbortKnowledgeBaseUpdateAdmin.beforeAbortKnowledgeBaseUpdateAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmAbortKnowledgeBaseUpdateAdmin.afterAbortKnowledgeBaseUpdateAdminCounter, 1)

	mmAbortKnowledgeBaseUpdateAdmin.t.Helper()

	if mmAbortKnowledgeBaseUpdateAdmin.inspectFuncAbortKnowledgeBaseUpdateAdmin != nil {
		mmAbortKnowledgeBaseUpdateAdmin.inspectFuncAbortKnowledgeBaseUpdateAdmin(ctx, ap1)
	}

	mm_params := ServiceMockAbortKnowledgeBaseUpdateAdminParams{ctx, ap1}

	// Record call args
	mmAbortKnowledgeBaseUpdateAdmin.AbortKnowledgeBaseUpdateAdminMock.mutex.Lock()
	mmAbortKnowledgeBaseUpdateAdmin.AbortKnowledgeBaseUpdateAdminMock.callArgs = append(mmAbortKnowledgeBaseUpdateAdmin.AbortKnowledgeBaseUpdateAdminMock.callArgs, &mm_params)
	mmAbortKnowledgeBaseUpdateAdmin.AbortKnowledgeBaseUpdateAdminMock.mutex.Unlock()

	for _, e := range mmAbortKnowledgeBaseUpdateAdmin.AbortKnowledgeBaseUpdateAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap2, e.results.err
		}
	}

	if mmAbortKnowledgeBaseUpdateAdmin.AbortKnowledgeBaseUpdateAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAbortKnowledgeBaseUpdateAdmin.AbortKnowledgeBaseUpdateAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmAbortKnowledgeBaseUpdateAdmin.AbortKnowledgeBaseUpdateAdminMock.defaultExpectation.params
		mm_want_ptrs := mmAbortKnowledgeBaseUpdateAdmin.AbortKnowledgeBaseUpdateAdminMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockAbortKnowledgeBaseUpdateAdminParams{ctx, ap1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAbortKnowledgeBaseUpdateAdmin.t.Errorf("ServiceMock.AbortKnowledgeBaseUpdateAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAbortKnowledgeBaseUpdateAdmin.AbortKnowledgeBaseUpdateAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ap1 != nil && !minimock.Equal(*mm_want_ptrs.ap1, mm_got.ap1) {
				mmAbortKnowledgeBaseUpdateAdmin.t.Errorf("ServiceMock.AbortKnowledgeBaseUpdateAdmin got unexpected parameter ap1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAbortKnowledgeBaseUpdateAdmin.AbortKnowledgeBaseUpdateAdminMock.defaultExpectation.expectationOrigins.originAp1, *mm_want_ptrs.ap1, mm_got.ap1, minimock.Diff(*mm_want_ptrs.ap1, mm_got.ap1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAbortKnowledgeBaseUpdateAdmin.t.Errorf("ServiceMock.AbortKnowledgeBaseUpdateAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAbortKnowledgeBaseUpdateAdmin.AbortKnowledgeBaseUpdateAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAbortKnowledgeBaseUpdateAdmin.AbortKnowledgeBaseUpdateAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmAbortKnowledgeBaseUpdateAdmin.t.Fatal("No results are set for the ServiceMock.AbortKnowledgeBaseUpdateAdmin")
		}
		return (*mm_results).ap2, (*mm_results).err
	}
	if mmAbortKnowledgeBaseUpdateAdmin.funcAbortKnowledgeBaseUpdateAdmin != nil {
		return mmAbortKnowledgeBaseUpdateAdmin.funcAbortKnowledgeBaseUpdateAdmin(ctx, ap1)
	}
	mmAbortKnowledgeBaseUpdateAdmin.t.Fatalf("Unexpected call to ServiceMock.AbortKnowledgeBaseUpdateAdmin. %v %v", ctx, ap1)
	return
}

// AbortKnowledgeBaseUpdateAdminAfterCounter returns a count of finished ServiceMock.AbortKnowledgeBaseUpdateAdmin invocations
func (mmAbortKnowledgeBaseUpdateAdmin *ServiceMock) AbortKnowledgeBaseUpdateAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAbortKnowledgeBaseUpdateAdmin.afterAbortKnowledgeBaseUpdateAdminCounter)
}

// AbortKnowledgeBaseUpdateAdminBeforeCounter returns a count of ServiceMock.AbortKnowledgeBaseUpdateAdmin invocations
func (mmAbortKnowledgeBaseUpdateAdmin *ServiceMock) AbortKnowledgeBaseUpdateAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAbortKnowledgeBaseUpdateAdmin.beforeAbortKnowledgeBaseUpdateAdminCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.AbortKnowledgeBaseUpdateAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAbortKnowledgeBaseUpdateAdmin *mServiceMockAbortKnowledgeBaseUpdateAdmin) Calls() []*ServiceMockAbortKnowledgeBaseUpdateAdminParams {
	mmAbortKnowledgeBaseUpdateAdmin.mutex.RLock()

	argCopy := make([]*ServiceMockAbortKnowledgeBaseUpdateAdminParams, len(mmAbortKnowledgeBaseUpdateAdmin.callArgs))
	copy(argCopy, mmAbortKnowledgeBaseUpdateAdmin.callArgs)

	mmAbortKnowledgeBaseUpdateAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockAbortKnowledgeBaseUpdateAdminDone returns true if the count of the AbortKnowledgeBaseUpdateAdmin invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockAbortKnowledgeBaseUpdateAdminDone() bool {
	if m.AbortKnowledgeBaseUpdateAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AbortKnowledgeBaseUpdateAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AbortKnowledgeBaseUpdateAdminMock.invocationsDone()
}

// MinimockAbortKnowledgeBaseUpdateAdminInspect logs each unmet expectation
func (m *ServiceMock) MinimockAbortKnowledgeBaseUpdateAdminInspect() {
	for _, e := range m.AbortKnowledgeBaseUpdateAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.AbortKnowledgeBaseUpdateAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAbortKnowledgeBaseUpdateAdminCounter := mm_atomic.LoadUint64(&m.afterAbortKnowledgeBaseUpdateAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AbortKnowledgeBaseUpdateAdminMock.defaultExpectation != nil && afterAbortKnowledgeBaseUpdateAdminCounter < 1 {
		if m.AbortKnowledgeBaseUpdateAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.AbortKnowledgeBaseUpdateAdmin at\n%s", m.AbortKnowledgeBaseUpdateAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.AbortKnowledgeBaseUpdateAdmin at\n%s with params: %#v", m.AbortKnowledgeBaseUpdateAdminMock.defaultExpectation.expectationOrigins.origin, *m.AbortKnowledgeBaseUpdateAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAbortKnowledgeBaseUpdateAdmin != nil && afterAbortKnowledgeBaseUpdateAdminCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.AbortKnowledgeBaseUpdateAdmin at\n%s", m.funcAbortKnowledgeBaseUpdateAdminOrigin)
	}

	if !m.AbortKnowledgeBaseUpdateAdminMock.invocationsDone() && afterAbortKnowledgeBaseUpdateAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.AbortKnowledgeBaseUpdateAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AbortKnowledgeBaseUpdateAdminMock.expectedInvocations), m.AbortKnowledgeBaseUpdateAdminMock.expectedInvocationsOrigin, afterAbortKnowledgeBaseUpdateAdminCounter)
	}
}

type mServiceMockCheckCatalogUserPermission struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockCheckCatalogUserPermissionExpectation
	expectations       []*ServiceMockCheckCatalogUserPermissionExpectation

	callArgs []*ServiceMockCheckCatalogUserPermissionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockCheckCatalogUserPermissionExpectation specifies expectation struct of the Service.CheckCatalogUserPermission
type ServiceMockCheckCatalogUserPermissionExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockCheckCatalogUserPermissionParams
	paramPtrs          *ServiceMockCheckCatalogUserPermissionParamPtrs
	expectationOrigins ServiceMockCheckCatalogUserPermissionExpectationOrigins
	results            *ServiceMockCheckCatalogUserPermissionResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockCheckCatalogUserPermissionParams contains parameters of the Service.CheckCatalogUserPermission
type ServiceMockCheckCatalogUserPermissionParams struct {
	ctx context.Context
	s1  string
	s2  string
	s3  string
}

// ServiceMockCheckCatalogUserPermissionParamPtrs contains pointers to parameters of the Service.CheckCatalogUserPermission
type ServiceMockCheckCatalogUserPermissionParamPtrs struct {
	ctx *context.Context
	s1  *string
	s2  *string
	s3  *string
}

// ServiceMockCheckCatalogUserPermissionResults contains results of the Service.CheckCatalogUserPermission
type ServiceMockCheckCatalogUserPermissionResults struct {
	np1 *resource.Namespace
	kp1 *repository.KnowledgeBaseModel
	err error
}

// ServiceMockCheckCatalogUserPermissionOrigins contains origins of expectations of the Service.CheckCatalogUserPermission
type ServiceMockCheckCatalogUserPermissionExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
	originS2  string
	originS3  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) Optional() *mServiceMockCheckCatalogUserPermission {
	mmCheckCatalogUserPermission.optional = true
	return mmCheckCatalogUserPermission
}

// Expect sets up expected params for Service.CheckCatalogUserPermission
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) Expect(ctx context.Context, s1 string, s2 string, s3 string) *mServiceMockCheckCatalogUserPermission {
	if mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermission != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Set")
	}

	if mmCheckCatalogUserPermission.defaultExpectation == nil {
		mmCheckCatalogUserPermission.defaultExpectation = &ServiceMockCheckCatalogUserPermissionExpectation{}
	}

	if mmCheckCatalogUserPermission.defaultExpectation.paramPtrs != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by ExpectParams functions")
	}

	mmCheckCatalogUserPermission.defaultExpectation.params = &ServiceMockCheckCatalogUserPermissionParams{ctx, s1, s2, s3}
	mmCheckCatalogUserPermission.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckCatalogUserPermission.expectations {
		if minimock.Equal(e.params, mmCheckCatalogUserPermission.defaultExpectation.params) {
			mmCheckCatalogUserPermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckCatalogUserPermission.defaultExpectation.params)
		}
	}

	return mmCheckCatalogUserPermission
}

// ExpectCtxParam1 sets up expected param ctx for Service.CheckCatalogUserPermission
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) ExpectCtxParam1(ctx context.Context) *mServiceMockCheckCatalogUserPermission {
	if mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermission != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Set")
	}

	if mmCheckCatalogUserPermission.defaultExpectation == nil {
		mmCheckCatalogUserPermission.defaultExpectation = &ServiceMockCheckCatalogUserPermissionExpectation{}
	}

	if mmCheckCatalogUserPermission.defaultExpectation.params != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Expect")
	}

	if mmCheckCatalogUserPermission.defaultExpectation.paramPtrs == nil {
		mmCheckCatalogUserPermission.defaultExpectation.paramPtrs = &ServiceMockCheckCatalogUserPermissionParamPtrs{}
	}
	mmCheckCatalogUserPermission.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckCatalogUserPermission.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckCatalogUserPermission
}

// ExpectS1Param2 sets up expected param s1 for Service.CheckCatalogUserPermission
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) ExpectS1Param2(s1 string) *mServiceMockCheckCatalogUserPermission {
	if mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermission != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Set")
	}

	if mmCheckCatalogUserPermission.defaultExpectation == nil {
		mmCheckCatalogUserPermission.defaultExpectation = &ServiceMockCheckCatalogUserPermissionExpectation{}
	}

	if mmCheckCatalogUserPermission.defaultExpectation.params != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Expect")
	}

	if mmCheckCatalogUserPermission.defaultExpectation.paramPtrs == nil {
		mmCheckCatalogUserPermission.defaultExpectation.paramPtrs = &ServiceMockCheckCatalogUserPermissionParamPtrs{}
	}
	mmCheckCatalogUserPermission.defaultExpectation.paramPtrs.s1 = &s1
	mmCheckCatalogUserPermission.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmCheckCatalogUserPermission
}

// ExpectS2Param3 sets up expected param s2 for Service.CheckCatalogUserPermission
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) ExpectS2Param3(s2 string) *mServiceMockCheckCatalogUserPermission {
	if mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermission != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Set")
	}

	if mmCheckCatalogUserPermission.defaultExpectation == nil {
		mmCheckCatalogUserPermission.defaultExpectation = &ServiceMockCheckCatalogUserPermissionExpectation{}
	}

	if mmCheckCatalogUserPermission.defaultExpectation.params != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Expect")
	}

	if mmCheckCatalogUserPermission.defaultExpectation.paramPtrs == nil {
		mmCheckCatalogUserPermission.defaultExpectation.paramPtrs = &ServiceMockCheckCatalogUserPermissionParamPtrs{}
	}
	mmCheckCatalogUserPermission.defaultExpectation.paramPtrs.s2 = &s2
	mmCheckCatalogUserPermission.defaultExpectation.expectationOrigins.originS2 = minimock.CallerInfo(1)

	return mmCheckCatalogUserPermission
}

// ExpectS3Param4 sets up expected param s3 for Service.CheckCatalogUserPermission
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) ExpectS3Param4(s3 string) *mServiceMockCheckCatalogUserPermission {
	if mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermission != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Set")
	}

	if mmCheckCatalogUserPermission.defaultExpectation == nil {
		mmCheckCatalogUserPermission.defaultExpectation = &ServiceMockCheckCatalogUserPermissionExpectation{}
	}

	if mmCheckCatalogUserPermission.defaultExpectation.params != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Expect")
	}

	if mmCheckCatalogUserPermission.defaultExpectation.paramPtrs == nil {
		mmCheckCatalogUserPermission.defaultExpectation.paramPtrs = &ServiceMockCheckCatalogUserPermissionParamPtrs{}
	}
	mmCheckCatalogUserPermission.defaultExpectation.paramPtrs.s3 = &s3
	mmCheckCatalogUserPermission.defaultExpectation.expectationOrigins.originS3 = minimock.CallerInfo(1)

	return mmCheckCatalogUserPermission
}

// Inspect accepts an inspector function that has same arguments as the Service.CheckCatalogUserPermission
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) Inspect(f func(ctx context.Context, s1 string, s2 string, s3 string)) *mServiceMockCheckCatalogUserPermission {
	if mmCheckCatalogUserPermission.mock.inspectFuncCheckCatalogUserPermission != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("Inspect function is already set for ServiceMock.CheckCatalogUserPermission")
	}

	mmCheckCatalogUserPermission.mock.inspectFuncCheckCatalogUserPermission = f

	return mmCheckCatalogUserPermission
}

// Return sets up results that will be returned by Service.CheckCatalogUserPermission
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) Return(np1 *resource.Namespace, kp1 *repository.KnowledgeBaseModel, err error) *ServiceMock {
	if mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermission != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Set")
	}

	if mmCheckCatalogUserPermission.defaultExpectation == nil {
		mmCheckCatalogUserPermission.defaultExpectation = &ServiceMockCheckCatalogUserPermissionExpectation{mock: mmCheckCatalogUserPermission.mock}
	}
	mmCheckCatalogUserPermission.defaultExpectation.results = &ServiceMockCheckCatalogUserPermissionResults{np1, kp1, err}
	mmCheckCatalogUserPermission.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckCatalogUserPermission.mock
}

// Set uses given function f to mock the Service.CheckCatalogUserPermission method
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) Set(f func(ctx context.Context, s1 string, s2 string, s3 string) (np1 *resource.Namespace, kp1 *repository.KnowledgeBaseModel, err error)) *ServiceMock {
	if mmCheckCatalogUserPermission.defaultExpectation != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("Default expectation is already set for the Service.CheckCatalogUserPermission method")
	}

	if len(mmCheckCatalogUserPermission.expectations) > 0 {
		mmCheckCatalogUserPermission.mock.t.Fatalf("Some expectations are already set for the Service.CheckCatalogUserPermission method")
	}

	mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermission = f
	mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermissionOrigin = minimock.CallerInfo(1)
	return mmCheckCatalogUserPermission.mock
}

// When sets expectation for the Service.CheckCatalogUserPermission which will trigger the result defined by the following
// Then helper
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) When(ctx context.Context, s1 string, s2 string, s3 string) *ServiceMockCheckCatalogUserPermissionExpectation {
	if mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermission != nil {
		mmCheckCatalogUserPermission.mock.t.Fatalf("ServiceMock.CheckCatalogUserPermission mock is already set by Set")
	}

	expectation := &ServiceMockCheckCatalogUserPermissionExpectation{
		mock:               mmCheckCatalogUserPermission.mock,
		params:             &ServiceMockCheckCatalogUserPermissionParams{ctx, s1, s2, s3},
		expectationOrigins: ServiceMockCheckCatalogUserPermissionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckCatalogUserPermission.expectations = append(mmCheckCatalogUserPermission.expectations, expectation)
	return expectation
}

// Then sets up Service.CheckCatalogUserPermission return parameters for the expectation previously defined by the When method
func (e *ServiceMockCheckCatalogUserPermissionExpectation) Then(np1 *resource.Namespace, kp1 *repository.KnowledgeBaseModel, err error) *ServiceMock {
	e.results = &ServiceMockCheckCatalogUserPermissionResults{np1, kp1, err}
	return e.mock
}

// Times sets number of times Service.CheckCatalogUserPermission should be invoked
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) Times(n uint64) *mServiceMockCheckCatalogUserPermission {
	if n == 0 {
		mmCheckCatalogUserPermission.mock.t.Fatalf("Times of ServiceMock.CheckCatalogUserPermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckCatalogUserPermission.expectedInvocations, n)
	mmCheckCatalogUserPermission.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckCatalogUserPermission
}

func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) invocationsDone() bool {
	if len(mmCheckCatalogUserPermission.expectations) == 0 && mmCheckCatalogUserPermission.defaultExpectation == nil && mmCheckCatalogUserPermission.mock.funcCheckCatalogUserPermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckCatalogUserPermission.mock.afterCheckCatalogUserPermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckCatalogUserPermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckCatalogUserPermission implements mm_service.Service
func (mmCheckCatalogUserPermission *ServiceMock) CheckCatalogUserPermission(ctx context.Context, s1 string, s2 string, s3 string) (np1 *resource.Namespace, kp1 *repository.KnowledgeBaseModel, err error) {
	mm_atomic.AddUint64(&mmCheckCatalogUserPermission.beforeCheckCatalogUserPermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckCatalogUserPermission.afterCheckCatalogUserPermissionCounter, 1)

	mmCheckCatalogUserPermission.t.Helper()

	if mmCheckCatalogUserPermission.inspectFuncCheckCatalogUserPermission != nil {
		mmCheckCatalogUserPermission.inspectFuncCheckCatalogUserPermission(ctx, s1, s2, s3)
	}

	mm_params := ServiceMockCheckCatalogUserPermissionParams{ctx, s1, s2, s3}

	// Record call args
	mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.mutex.Lock()
	mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.callArgs = append(mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.callArgs, &mm_params)
	mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.mutex.Unlock()

	for _, e := range mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.np1, e.results.kp1, e.results.err
		}
	}

	if mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation.params
		mm_want_ptrs := mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockCheckCatalogUserPermissionParams{ctx, s1, s2, s3}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckCatalogUserPermission.t.Errorf("ServiceMock.CheckCatalogUserPermission got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmCheckCatalogUserPermission.t.Errorf("ServiceMock.CheckCatalogUserPermission got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

			if mm_want_ptrs.s2 != nil && !minimock.Equal(*mm_want_ptrs.s2, mm_got.s2) {
				mmCheckCatalogUserPermission.t.Errorf("ServiceMock.CheckCatalogUserPermission got unexpected parameter s2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation.expectationOrigins.originS2, *mm_want_ptrs.s2, mm_got.s2, minimock.Diff(*mm_want_ptrs.s2, mm_got.s2))
			}

			if mm_want_ptrs.s3 != nil && !minimock.Equal(*mm_want_ptrs.s3, mm_got.s3) {
				mmCheckCatalogUserPermission.t.Errorf("ServiceMock.CheckCatalogUserPermission got unexpected parameter s3, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation.expectationOrigins.originS3, *mm_want_ptrs.s3, mm_got.s3, minimock.Diff(*mm_want_ptrs.s3, mm_got.s3))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckCatalogUserPermission.t.Errorf("ServiceMock.CheckCatalogUserPermission got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckCatalogUserPermission.CheckCatalogUserPermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckCatalogUserPermission.t.Fatal("No results are set for the ServiceMock.CheckCatalogUserPermission")
		}
		return (*mm_results).np1, (*mm_results).kp1, (*mm_results).err
	}
	if mmCheckCatalogUserPermission.funcCheckCatalogUserPermission != nil {
		return mmCheckCatalogUserPermission.funcCheckCatalogUserPermission(ctx, s1, s2, s3)
	}
	mmCheckCatalogUserPermission.t.Fatalf("Unexpected call to ServiceMock.CheckCatalogUserPermission. %v %v %v %v", ctx, s1, s2, s3)
	return
}

// CheckCatalogUserPermissionAfterCounter returns a count of finished ServiceMock.CheckCatalogUserPermission invocations
func (mmCheckCatalogUserPermission *ServiceMock) CheckCatalogUserPermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckCatalogUserPermission.afterCheckCatalogUserPermissionCounter)
}

// CheckCatalogUserPermissionBeforeCounter returns a count of ServiceMock.CheckCatalogUserPermission invocations
func (mmCheckCatalogUserPermission *ServiceMock) CheckCatalogUserPermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckCatalogUserPermission.beforeCheckCatalogUserPermissionCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.CheckCatalogUserPermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckCatalogUserPermission *mServiceMockCheckCatalogUserPermission) Calls() []*ServiceMockCheckCatalogUserPermissionParams {
	mmCheckCatalogUserPermission.mutex.RLock()

	argCopy := make([]*ServiceMockCheckCatalogUserPermissionParams, len(mmCheckCatalogUserPermission.callArgs))
	copy(argCopy, mmCheckCatalogUserPermission.callArgs)

	mmCheckCatalogUserPermission.mutex.RUnlock()

	return argCopy
}

// MinimockCheckCatalogUserPermissionDone returns true if the count of the CheckCatalogUserPermission invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCheckCatalogUserPermissionDone() bool {
	if m.CheckCatalogUserPermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckCatalogUserPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckCatalogUserPermissionMock.invocationsDone()
}

// MinimockCheckCatalogUserPermissionInspect logs each unmet expectation
func (m *ServiceMock) MinimockCheckCatalogUserPermissionInspect() {
	for _, e := range m.CheckCatalogUserPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.CheckCatalogUserPermission at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckCatalogUserPermissionCounter := mm_atomic.LoadUint64(&m.afterCheckCatalogUserPermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckCatalogUserPermissionMock.defaultExpectation != nil && afterCheckCatalogUserPermissionCounter < 1 {
		if m.CheckCatalogUserPermissionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.CheckCatalogUserPermission at\n%s", m.CheckCatalogUserPermissionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.CheckCatalogUserPermission at\n%s with params: %#v", m.CheckCatalogUserPermissionMock.defaultExpectation.expectationOrigins.origin, *m.CheckCatalogUserPermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckCatalogUserPermission != nil && afterCheckCatalogUserPermissionCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.CheckCatalogUserPermission at\n%s", m.funcCheckCatalogUserPermissionOrigin)
	}

	if !m.CheckCatalogUserPermissionMock.invocationsDone() && afterCheckCatalogUserPermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.CheckCatalogUserPermission at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckCatalogUserPermissionMock.expectedInvocations), m.CheckCatalogUserPermissionMock.expectedInvocationsOrigin, afterCheckCatalogUserPermissionCounter)
	}
}

type mServiceMockCheckNamespacePermission struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockCheckNamespacePermissionExpectation
	expectations       []*ServiceMockCheckNamespacePermissionExpectation

	callArgs []*ServiceMockCheckNamespacePermissionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockCheckNamespacePermissionExpectation specifies expectation struct of the Service.CheckNamespacePermission
type ServiceMockCheckNamespacePermissionExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockCheckNamespacePermissionParams
	paramPtrs          *ServiceMockCheckNamespacePermissionParamPtrs
	expectationOrigins ServiceMockCheckNamespacePermissionExpectationOrigins
	results            *ServiceMockCheckNamespacePermissionResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockCheckNamespacePermissionParams contains parameters of the Service.CheckNamespacePermission
type ServiceMockCheckNamespacePermissionParams struct {
	ctx context.Context
	np1 *resource.Namespace
}

// ServiceMockCheckNamespacePermissionParamPtrs contains pointers to parameters of the Service.CheckNamespacePermission
type ServiceMockCheckNamespacePermissionParamPtrs struct {
	ctx *context.Context
	np1 **resource.Namespace
}

// ServiceMockCheckNamespacePermissionResults contains results of the Service.CheckNamespacePermission
type ServiceMockCheckNamespacePermissionResults struct {
	err error
}

// ServiceMockCheckNamespacePermissionOrigins contains origins of expectations of the Service.CheckNamespacePermission
type ServiceMockCheckNamespacePermissionExpectationOrigins struct {
	origin    string
	originCtx string
	originNp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) Optional() *mServiceMockCheckNamespacePermission {
	mmCheckNamespacePermission.optional = true
	return mmCheckNamespacePermission
}

// Expect sets up expected params for Service.CheckNamespacePermission
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) Expect(ctx context.Context, np1 *resource.Namespace) *mServiceMockCheckNamespacePermission {
	if mmCheckNamespacePermission.mock.funcCheckNamespacePermission != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("ServiceMock.CheckNamespacePermission mock is already set by Set")
	}

	if mmCheckNamespacePermission.defaultExpectation == nil {
		mmCheckNamespacePermission.defaultExpectation = &ServiceMockCheckNamespacePermissionExpectation{}
	}

	if mmCheckNamespacePermission.defaultExpectation.paramPtrs != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("ServiceMock.CheckNamespacePermission mock is already set by ExpectParams functions")
	}

	mmCheckNamespacePermission.defaultExpectation.params = &ServiceMockCheckNamespacePermissionParams{ctx, np1}
	mmCheckNamespacePermission.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckNamespacePermission.expectations {
		if minimock.Equal(e.params, mmCheckNamespacePermission.defaultExpectation.params) {
			mmCheckNamespacePermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckNamespacePermission.defaultExpectation.params)
		}
	}

	return mmCheckNamespacePermission
}

// ExpectCtxParam1 sets up expected param ctx for Service.CheckNamespacePermission
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) ExpectCtxParam1(ctx context.Context) *mServiceMockCheckNamespacePermission {
	if mmCheckNamespacePermission.mock.funcCheckNamespacePermission != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("ServiceMock.CheckNamespacePermission mock is already set by Set")
	}

	if mmCheckNamespacePermission.defaultExpectation == nil {
		mmCheckNamespacePermission.defaultExpectation = &ServiceMockCheckNamespacePermissionExpectation{}
	}

	if mmCheckNamespacePermission.defaultExpectation.params != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("ServiceMock.CheckNamespacePermission mock is already set by Expect")
	}

	if mmCheckNamespacePermission.defaultExpectation.paramPtrs == nil {
		mmCheckNamespacePermission.defaultExpectation.paramPtrs = &ServiceMockCheckNamespacePermissionParamPtrs{}
	}
	mmCheckNamespacePermission.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckNamespacePermission.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckNamespacePermission
}

// ExpectNp1Param2 sets up expected param np1 for Service.CheckNamespacePermission
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) ExpectNp1Param2(np1 *resource.Namespace) *mServiceMockCheckNamespacePermission {
	if mmCheckNamespacePermission.mock.funcCheckNamespacePermission != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("ServiceMock.CheckNamespacePermission mock is already set by Set")
	}

	if mmCheckNamespacePermission.defaultExpectation == nil {
		mmCheckNamespacePermission.defaultExpectation = &ServiceMockCheckNamespacePermissionExpectation{}
	}

	if mmCheckNamespacePermission.defaultExpectation.params != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("ServiceMock.CheckNamespacePermission mock is already set by Expect")
	}

	if mmCheckNamespacePermission.defaultExpectation.paramPtrs == nil {
		mmCheckNamespacePermission.defaultExpectation.paramPtrs = &ServiceMockCheckNamespacePermissionParamPtrs{}
	}
	mmCheckNamespacePermission.defaultExpectation.paramPtrs.np1 = &np1
	mmCheckNamespacePermission.defaultExpectation.expectationOrigins.originNp1 = minimock.CallerInfo(1)

	return mmCheckNamespacePermission
}

// Inspect accepts an inspector function that has same arguments as the Service.CheckNamespacePermission
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) Inspect(f func(ctx context.Context, np1 *resource.Namespace)) *mServiceMockCheckNamespacePermission {
	if mmCheckNamespacePermission.mock.inspectFuncCheckNamespacePermission != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("Inspect function is already set for ServiceMock.CheckNamespacePermission")
	}

	mmCheckNamespacePermission.mock.inspectFuncCheckNamespacePermission = f

	return mmCheckNamespacePermission
}

// Return sets up results that will be returned by Service.CheckNamespacePermission
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) Return(err error) *ServiceMock {
	if mmCheckNamespacePermission.mock.funcCheckNamespacePermission != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("ServiceMock.CheckNamespacePermission mock is already set by Set")
	}

	if mmCheckNamespacePermission.defaultExpectation == nil {
		mmCheckNamespacePermission.defaultExpectation = &ServiceMockCheckNamespacePermissionExpectation{mock: mmCheckNamespacePermission.mock}
	}
	mmCheckNamespacePermission.defaultExpectation.results = &ServiceMockCheckNamespacePermissionResults{err}
	mmCheckNamespacePermission.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckNamespacePermission.mock
}

// Set uses given function f to mock the Service.CheckNamespacePermission method
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) Set(f func(ctx context.Context, np1 *resource.Namespace) (err error)) *ServiceMock {
	if mmCheckNamespacePermission.defaultExpectation != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("Default expectation is already set for the Service.CheckNamespacePermission method")
	}

	if len(mmCheckNamespacePermission.expectations) > 0 {
		mmCheckNamespacePermission.mock.t.Fatalf("Some expectations are already set for the Service.CheckNamespacePermission method")
	}

	mmCheckNamespacePermission.mock.funcCheckNamespacePermission = f
	mmCheckNamespacePermission.mock.funcCheckNamespacePermissionOrigin = minimock.CallerInfo(1)
	return mmCheckNamespacePermission.mock
}

// When sets expectation for the Service.CheckNamespacePermission which will trigger the result defined by the following
// Then helper
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) When(ctx context.Context, np1 *resource.Namespace) *ServiceMockCheckNamespacePermissionExpectation {
	if mmCheckNamespacePermission.mock.funcCheckNamespacePermission != nil {
		mmCheckNamespacePermission.mock.t.Fatalf("ServiceMock.CheckNamespacePermission mock is already set by Set")
	}

	expectation := &ServiceMockCheckNamespacePermissionExpectation{
		mock:               mmCheckNamespacePermission.mock,
		params:             &ServiceMockCheckNamespacePermissionParams{ctx, np1},
		expectationOrigins: ServiceMockCheckNamespacePermissionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckNamespacePermission.expectations = append(mmCheckNamespacePermission.expectations, expectation)
	return expectation
}

// Then sets up Service.CheckNamespacePermission return parameters for the expectation previously defined by the When method
func (e *ServiceMockCheckNamespacePermissionExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockCheckNamespacePermissionResults{err}
	return e.mock
}

// Times sets number of times Service.CheckNamespacePermission should be invoked
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) Times(n uint64) *mServiceMockCheckNamespacePermission {
	if n == 0 {
		mmCheckNamespacePermission.mock.t.Fatalf("Times of ServiceMock.CheckNamespacePermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckNamespacePermission.expectedInvocations, n)
	mmCheckNamespacePermission.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckNamespacePermission
}

func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) invocationsDone() bool {
	if len(mmCheckNamespacePermission.expectations) == 0 && mmCheckNamespacePermission.defaultExpectation == nil && mmCheckNamespacePermission.mock.funcCheckNamespacePermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckNamespacePermission.mock.afterCheckNamespacePermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckNamespacePermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckNamespacePermission implements mm_service.Service
func (mmCheckNamespacePermission *ServiceMock) CheckNamespacePermission(ctx context.Context, np1 *resource.Namespace) (err error) {
	mm_atomic.AddUint64(&mmCheckNamespacePermission.beforeCheckNamespacePermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckNamespacePermission.afterCheckNamespacePermissionCounter, 1)

	mmCheckNamespacePermission.t.Helper()

	if mmCheckNamespacePermission.inspectFuncCheckNamespacePermission != nil {
		mmCheckNamespacePermission.inspectFuncCheckNamespacePermission(ctx, np1)
	}

	mm_params := ServiceMockCheckNamespacePermissionParams{ctx, np1}

	// Record call args
	mmCheckNamespacePermission.CheckNamespacePermissionMock.mutex.Lock()
	mmCheckNamespacePermission.CheckNamespacePermissionMock.callArgs = append(mmCheckNamespacePermission.CheckNamespacePermissionMock.callArgs, &mm_params)
	mmCheckNamespacePermission.CheckNamespacePermissionMock.mutex.Unlock()

	for _, e := range mmCheckNamespacePermission.CheckNamespacePermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCheckNamespacePermission.CheckNamespacePermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckNamespacePermission.CheckNamespacePermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckNamespacePermission.CheckNamespacePermissionMock.defaultExpectation.params
		mm_want_ptrs := mmCheckNamespacePermission.CheckNamespacePermissionMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockCheckNamespacePermissionParams{ctx, np1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckNamespacePermission.t.Errorf("ServiceMock.CheckNamespacePermission got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckNamespacePermission.CheckNamespacePermissionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.np1 != nil && !minimock.Equal(*mm_want_ptrs.np1, mm_got.np1) {
				mmCheckNamespacePermission.t.Errorf("ServiceMock.CheckNamespacePermission got unexpected parameter np1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckNamespacePermission.CheckNamespacePermissionMock.defaultExpectation.expectationOrigins.originNp1, *mm_want_ptrs.np1, mm_got.np1, minimock.Diff(*mm_want_ptrs.np1, mm_got.np1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckNamespacePermission.t.Errorf("ServiceMock.CheckNamespacePermission got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckNamespacePermission.CheckNamespacePermissionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckNamespacePermission.CheckNamespacePermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckNamespacePermission.t.Fatal("No results are set for the ServiceMock.CheckNamespacePermission")
		}
		return (*mm_results).err
	}
	if mmCheckNamespacePermission.funcCheckNamespacePermission != nil {
		return mmCheckNamespacePermission.funcCheckNamespacePermission(ctx, np1)
	}
	mmCheckNamespacePermission.t.Fatalf("Unexpected call to ServiceMock.CheckNamespacePermission. %v %v", ctx, np1)
	return
}

// CheckNamespacePermissionAfterCounter returns a count of finished ServiceMock.CheckNamespacePermission invocations
func (mmCheckNamespacePermission *ServiceMock) CheckNamespacePermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckNamespacePermission.afterCheckNamespacePermissionCounter)
}

// CheckNamespacePermissionBeforeCounter returns a count of ServiceMock.CheckNamespacePermission invocations
func (mmCheckNamespacePermission *ServiceMock) CheckNamespacePermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckNamespacePermission.beforeCheckNamespacePermissionCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.CheckNamespacePermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckNamespacePermission *mServiceMockCheckNamespacePermission) Calls() []*ServiceMockCheckNamespacePermissionParams {
	mmCheckNamespacePermission.mutex.RLock()

	argCopy := make([]*ServiceMockCheckNamespacePermissionParams, len(mmCheckNamespacePermission.callArgs))
	copy(argCopy, mmCheckNamespacePermission.callArgs)

	mmCheckNamespacePermission.mutex.RUnlock()

	return argCopy
}

// MinimockCheckNamespacePermissionDone returns true if the count of the CheckNamespacePermission invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCheckNamespacePermissionDone() bool {
	if m.CheckNamespacePermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckNamespacePermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckNamespacePermissionMock.invocationsDone()
}

// MinimockCheckNamespacePermissionInspect logs each unmet expectation
func (m *ServiceMock) MinimockCheckNamespacePermissionInspect() {
	for _, e := range m.CheckNamespacePermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.CheckNamespacePermission at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckNamespacePermissionCounter := mm_atomic.LoadUint64(&m.afterCheckNamespacePermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckNamespacePermissionMock.defaultExpectation != nil && afterCheckNamespacePermissionCounter < 1 {
		if m.CheckNamespacePermissionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.CheckNamespacePermission at\n%s", m.CheckNamespacePermissionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.CheckNamespacePermission at\n%s with params: %#v", m.CheckNamespacePermissionMock.defaultExpectation.expectationOrigins.origin, *m.CheckNamespacePermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckNamespacePermission != nil && afterCheckNamespacePermissionCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.CheckNamespacePermission at\n%s", m.funcCheckNamespacePermissionOrigin)
	}

	if !m.CheckNamespacePermissionMock.invocationsDone() && afterCheckNamespacePermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.CheckNamespacePermission at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckNamespacePermissionMock.expectedInvocations), m.CheckNamespacePermissionMock.expectedInvocationsOrigin, afterCheckNamespacePermissionCounter)
	}
}

type mServiceMockCleanupFile struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockCleanupFileExpectation
	expectations       []*ServiceMockCleanupFileExpectation

	callArgs []*ServiceMockCleanupFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockCleanupFileExpectation specifies expectation struct of the Service.CleanupFile
type ServiceMockCleanupFileExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockCleanupFileParams
	paramPtrs          *ServiceMockCleanupFileParamPtrs
	expectationOrigins ServiceMockCleanupFileExpectationOrigins
	results            *ServiceMockCleanupFileResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockCleanupFileParams contains parameters of the Service.CleanupFile
type ServiceMockCleanupFileParams struct {
	ctx context.Context
	f1  types.FileUIDType
	u1  types.UserUIDType
	r1  types.RequesterUIDType
	s1  string
	b1  bool
}

// ServiceMockCleanupFileParamPtrs contains pointers to parameters of the Service.CleanupFile
type ServiceMockCleanupFileParamPtrs struct {
	ctx *context.Context
	f1  *types.FileUIDType
	u1  *types.UserUIDType
	r1  *types.RequesterUIDType
	s1  *string
	b1  *bool
}

// ServiceMockCleanupFileResults contains results of the Service.CleanupFile
type ServiceMockCleanupFileResults struct {
	err error
}

// ServiceMockCleanupFileOrigins contains origins of expectations of the Service.CleanupFile
type ServiceMockCleanupFileExpectationOrigins struct {
	origin    string
	originCtx string
	originF1  string
	originU1  string
	originR1  string
	originS1  string
	originB1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCleanupFile *mServiceMockCleanupFile) Optional() *mServiceMockCleanupFile {
	mmCleanupFile.optional = true
	return mmCleanupFile
}

// Expect sets up expected params for Service.CleanupFile
func (mmCleanupFile *mServiceMockCleanupFile) Expect(ctx context.Context, f1 types.FileUIDType, u1 types.UserUIDType, r1 types.RequesterUIDType, s1 string, b1 bool) *mServiceMockCleanupFile {
	if mmCleanupFile.mock.funcCleanupFile != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Set")
	}

	if mmCleanupFile.defaultExpectation == nil {
		mmCleanupFile.defaultExpectation = &ServiceMockCleanupFileExpectation{}
	}

	if mmCleanupFile.defaultExpectation.paramPtrs != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by ExpectParams functions")
	}

	mmCleanupFile.defaultExpectation.params = &ServiceMockCleanupFileParams{ctx, f1, u1, r1, s1, b1}
	mmCleanupFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCleanupFile.expectations {
		if minimock.Equal(e.params, mmCleanupFile.defaultExpectation.params) {
			mmCleanupFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCleanupFile.defaultExpectation.params)
		}
	}

	return mmCleanupFile
}

// ExpectCtxParam1 sets up expected param ctx for Service.CleanupFile
func (mmCleanupFile *mServiceMockCleanupFile) ExpectCtxParam1(ctx context.Context) *mServiceMockCleanupFile {
	if mmCleanupFile.mock.funcCleanupFile != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Set")
	}

	if mmCleanupFile.defaultExpectation == nil {
		mmCleanupFile.defaultExpectation = &ServiceMockCleanupFileExpectation{}
	}

	if mmCleanupFile.defaultExpectation.params != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Expect")
	}

	if mmCleanupFile.defaultExpectation.paramPtrs == nil {
		mmCleanupFile.defaultExpectation.paramPtrs = &ServiceMockCleanupFileParamPtrs{}
	}
	mmCleanupFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmCleanupFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCleanupFile
}

// ExpectF1Param2 sets up expected param f1 for Service.CleanupFile
func (mmCleanupFile *mServiceMockCleanupFile) ExpectF1Param2(f1 types.FileUIDType) *mServiceMockCleanupFile {
	if mmCleanupFile.mock.funcCleanupFile != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Set")
	}

	if mmCleanupFile.defaultExpectation == nil {
		mmCleanupFile.defaultExpectation = &ServiceMockCleanupFileExpectation{}
	}

	if mmCleanupFile.defaultExpectation.params != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Expect")
	}

	if mmCleanupFile.defaultExpectation.paramPtrs == nil {
		mmCleanupFile.defaultExpectation.paramPtrs = &ServiceMockCleanupFileParamPtrs{}
	}
	mmCleanupFile.defaultExpectation.paramPtrs.f1 = &f1
	mmCleanupFile.defaultExpectation.expectationOrigins.originF1 = minimock.CallerInfo(1)

	return mmCleanupFile
}

// ExpectU1Param3 sets up expected param u1 for Service.CleanupFile
func (mmCleanupFile *mServiceMockCleanupFile) ExpectU1Param3(u1 types.UserUIDType) *mServiceMockCleanupFile {
	if mmCleanupFile.mock.funcCleanupFile != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Set")
	}

	if mmCleanupFile.defaultExpectation == nil {
		mmCleanupFile.defaultExpectation = &ServiceMockCleanupFileExpectation{}
	}

	if mmCleanupFile.defaultExpectation.params != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Expect")
	}

	if mmCleanupFile.defaultExpectation.paramPtrs == nil {
		mmCleanupFile.defaultExpectation.paramPtrs = &ServiceMockCleanupFileParamPtrs{}
	}
	mmCleanupFile.defaultExpectation.paramPtrs.u1 = &u1
	mmCleanupFile.defaultExpectation.expectationOrigins.originU1 = minimock.CallerInfo(1)

	return mmCleanupFile
}

// ExpectR1Param4 sets up expected param r1 for Service.CleanupFile
func (mmCleanupFile *mServiceMockCleanupFile) ExpectR1Param4(r1 types.RequesterUIDType) *mServiceMockCleanupFile {
	if mmCleanupFile.mock.funcCleanupFile != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Set")
	}

	if mmCleanupFile.defaultExpectation == nil {
		mmCleanupFile.defaultExpectation = &ServiceMockCleanupFileExpectation{}
	}

	if mmCleanupFile.defaultExpectation.params != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Expect")
	}

	if mmCleanupFile.defaultExpectation.paramPtrs == nil {
		mmCleanupFile.defaultExpectation.paramPtrs = &ServiceMockCleanupFileParamPtrs{}
	}
	mmCleanupFile.defaultExpectation.paramPtrs.r1 = &r1
	mmCleanupFile.defaultExpectation.expectationOrigins.originR1 = minimock.CallerInfo(1)

	return mmCleanupFile
}

// ExpectS1Param5 sets up expected param s1 for Service.CleanupFile
func (mmCleanupFile *mServiceMockCleanupFile) ExpectS1Param5(s1 string) *mServiceMockCleanupFile {
	if mmCleanupFile.mock.funcCleanupFile != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Set")
	}

	if mmCleanupFile.defaultExpectation == nil {
		mmCleanupFile.defaultExpectation = &ServiceMockCleanupFileExpectation{}
	}

	if mmCleanupFile.defaultExpectation.params != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Expect")
	}

	if mmCleanupFile.defaultExpectation.paramPtrs == nil {
		mmCleanupFile.defaultExpectation.paramPtrs = &ServiceMockCleanupFileParamPtrs{}
	}
	mmCleanupFile.defaultExpectation.paramPtrs.s1 = &s1
	mmCleanupFile.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmCleanupFile
}

// ExpectB1Param6 sets up expected param b1 for Service.CleanupFile
func (mmCleanupFile *mServiceMockCleanupFile) ExpectB1Param6(b1 bool) *mServiceMockCleanupFile {
	if mmCleanupFile.mock.funcCleanupFile != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Set")
	}

	if mmCleanupFile.defaultExpectation == nil {
		mmCleanupFile.defaultExpectation = &ServiceMockCleanupFileExpectation{}
	}

	if mmCleanupFile.defaultExpectation.params != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Expect")
	}

	if mmCleanupFile.defaultExpectation.paramPtrs == nil {
		mmCleanupFile.defaultExpectation.paramPtrs = &ServiceMockCleanupFileParamPtrs{}
	}
	mmCleanupFile.defaultExpectation.paramPtrs.b1 = &b1
	mmCleanupFile.defaultExpectation.expectationOrigins.originB1 = minimock.CallerInfo(1)

	return mmCleanupFile
}

// Inspect accepts an inspector function that has same arguments as the Service.CleanupFile
func (mmCleanupFile *mServiceMockCleanupFile) Inspect(f func(ctx context.Context, f1 types.FileUIDType, u1 types.UserUIDType, r1 types.RequesterUIDType, s1 string, b1 bool)) *mServiceMockCleanupFile {
	if mmCleanupFile.mock.inspectFuncCleanupFile != nil {
		mmCleanupFile.mock.t.Fatalf("Inspect function is already set for ServiceMock.CleanupFile")
	}

	mmCleanupFile.mock.inspectFuncCleanupFile = f

	return mmCleanupFile
}

// Return sets up results that will be returned by Service.CleanupFile
func (mmCleanupFile *mServiceMockCleanupFile) Return(err error) *ServiceMock {
	if mmCleanupFile.mock.funcCleanupFile != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Set")
	}

	if mmCleanupFile.defaultExpectation == nil {
		mmCleanupFile.defaultExpectation = &ServiceMockCleanupFileExpectation{mock: mmCleanupFile.mock}
	}
	mmCleanupFile.defaultExpectation.results = &ServiceMockCleanupFileResults{err}
	mmCleanupFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCleanupFile.mock
}

// Set uses given function f to mock the Service.CleanupFile method
func (mmCleanupFile *mServiceMockCleanupFile) Set(f func(ctx context.Context, f1 types.FileUIDType, u1 types.UserUIDType, r1 types.RequesterUIDType, s1 string, b1 bool) (err error)) *ServiceMock {
	if mmCleanupFile.defaultExpectation != nil {
		mmCleanupFile.mock.t.Fatalf("Default expectation is already set for the Service.CleanupFile method")
	}

	if len(mmCleanupFile.expectations) > 0 {
		mmCleanupFile.mock.t.Fatalf("Some expectations are already set for the Service.CleanupFile method")
	}

	mmCleanupFile.mock.funcCleanupFile = f
	mmCleanupFile.mock.funcCleanupFileOrigin = minimock.CallerInfo(1)
	return mmCleanupFile.mock
}

// When sets expectation for the Service.CleanupFile which will trigger the result defined by the following
// Then helper
func (mmCleanupFile *mServiceMockCleanupFile) When(ctx context.Context, f1 types.FileUIDType, u1 types.UserUIDType, r1 types.RequesterUIDType, s1 string, b1 bool) *ServiceMockCleanupFileExpectation {
	if mmCleanupFile.mock.funcCleanupFile != nil {
		mmCleanupFile.mock.t.Fatalf("ServiceMock.CleanupFile mock is already set by Set")
	}

	expectation := &ServiceMockCleanupFileExpectation{
		mock:               mmCleanupFile.mock,
		params:             &ServiceMockCleanupFileParams{ctx, f1, u1, r1, s1, b1},
		expectationOrigins: ServiceMockCleanupFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCleanupFile.expectations = append(mmCleanupFile.expectations, expectation)
	return expectation
}

// Then sets up Service.CleanupFile return parameters for the expectation previously defined by the When method
func (e *ServiceMockCleanupFileExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockCleanupFileResults{err}
	return e.mock
}

// Times sets number of times Service.CleanupFile should be invoked
func (mmCleanupFile *mServiceMockCleanupFile) Times(n uint64) *mServiceMockCleanupFile {
	if n == 0 {
		mmCleanupFile.mock.t.Fatalf("Times of ServiceMock.CleanupFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCleanupFile.expectedInvocations, n)
	mmCleanupFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCleanupFile
}

func (mmCleanupFile *mServiceMockCleanupFile) invocationsDone() bool {
	if len(mmCleanupFile.expectations) == 0 && mmCleanupFile.defaultExpectation == nil && mmCleanupFile.mock.funcCleanupFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCleanupFile.mock.afterCleanupFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCleanupFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CleanupFile implements mm_service.Service
func (mmCleanupFile *ServiceMock) CleanupFile(ctx context.Context, f1 types.FileUIDType, u1 types.UserUIDType, r1 types.RequesterUIDType, s1 string, b1 bool) (err error) {
	mm_atomic.AddUint64(&mmCleanupFile.beforeCleanupFileCounter, 1)
	defer mm_atomic.AddUint64(&mmCleanupFile.afterCleanupFileCounter, 1)

	mmCleanupFile.t.Helper()

	if mmCleanupFile.inspectFuncCleanupFile != nil {
		mmCleanupFile.inspectFuncCleanupFile(ctx, f1, u1, r1, s1, b1)
	}

	mm_params := ServiceMockCleanupFileParams{ctx, f1, u1, r1, s1, b1}

	// Record call args
	mmCleanupFile.CleanupFileMock.mutex.Lock()
	mmCleanupFile.CleanupFileMock.callArgs = append(mmCleanupFile.CleanupFileMock.callArgs, &mm_params)
	mmCleanupFile.CleanupFileMock.mutex.Unlock()

	for _, e := range mmCleanupFile.CleanupFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCleanupFile.CleanupFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCleanupFile.CleanupFileMock.defaultExpectation.Counter, 1)
		mm_want := mmCleanupFile.CleanupFileMock.defaultExpectation.params
		mm_want_ptrs := mmCleanupFile.CleanupFileMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockCleanupFileParams{ctx, f1, u1, r1, s1, b1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCleanupFile.t.Errorf("ServiceMock.CleanupFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCleanupFile.CleanupFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.f1 != nil && !minimock.Equal(*mm_want_ptrs.f1, mm_got.f1) {
				mmCleanupFile.t.Errorf("ServiceMock.CleanupFile got unexpected parameter f1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCleanupFile.CleanupFileMock.defaultExpectation.expectationOrigins.originF1, *mm_want_ptrs.f1, mm_got.f1, minimock.Diff(*mm_want_ptrs.f1, mm_got.f1))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmCleanupFile.t.Errorf("ServiceMock.CleanupFile got unexpected parameter u1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCleanupFile.CleanupFileMock.defaultExpectation.expectationOrigins.originU1, *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

			if mm_want_ptrs.r1 != nil && !minimock.Equal(*mm_want_ptrs.r1, mm_got.r1) {
				mmCleanupFile.t.Errorf("ServiceMock.CleanupFile got unexpected parameter r1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCleanupFile.CleanupFileMock.defaultExpectation.expectationOrigins.originR1, *mm_want_ptrs.r1, mm_got.r1, minimock.Diff(*mm_want_ptrs.r1, mm_got.r1))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmCleanupFile.t.Errorf("ServiceMock.CleanupFile got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCleanupFile.CleanupFileMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

			if mm_want_ptrs.b1 != nil && !minimock.Equal(*mm_want_ptrs.b1, mm_got.b1) {
				mmCleanupFile.t.Errorf("ServiceMock.CleanupFile got unexpected parameter b1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCleanupFile.CleanupFileMock.defaultExpectation.expectationOrigins.originB1, *mm_want_ptrs.b1, mm_got.b1, minimock.Diff(*mm_want_ptrs.b1, mm_got.b1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCleanupFile.t.Errorf("ServiceMock.CleanupFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCleanupFile.CleanupFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCleanupFile.CleanupFileMock.defaultExpectation.results
		if mm_results == nil {
			mmCleanupFile.t.Fatal("No results are set for the ServiceMock.CleanupFile")
		}
		return (*mm_results).err
	}
	if mmCleanupFile.funcCleanupFile != nil {
		return mmCleanupFile.funcCleanupFile(ctx, f1, u1, r1, s1, b1)
	}
	mmCleanupFile.t.Fatalf("Unexpected call to ServiceMock.CleanupFile. %v %v %v %v %v %v", ctx, f1, u1, r1, s1, b1)
	return
}

// CleanupFileAfterCounter returns a count of finished ServiceMock.CleanupFile invocations
func (mmCleanupFile *ServiceMock) CleanupFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCleanupFile.afterCleanupFileCounter)
}

// CleanupFileBeforeCounter returns a count of ServiceMock.CleanupFile invocations
func (mmCleanupFile *ServiceMock) CleanupFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCleanupFile.beforeCleanupFileCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.CleanupFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCleanupFile *mServiceMockCleanupFile) Calls() []*ServiceMockCleanupFileParams {
	mmCleanupFile.mutex.RLock()

	argCopy := make([]*ServiceMockCleanupFileParams, len(mmCleanupFile.callArgs))
	copy(argCopy, mmCleanupFile.callArgs)

	mmCleanupFile.mutex.RUnlock()

	return argCopy
}

// MinimockCleanupFileDone returns true if the count of the CleanupFile invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCleanupFileDone() bool {
	if m.CleanupFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CleanupFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CleanupFileMock.invocationsDone()
}

// MinimockCleanupFileInspect logs each unmet expectation
func (m *ServiceMock) MinimockCleanupFileInspect() {
	for _, e := range m.CleanupFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.CleanupFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCleanupFileCounter := mm_atomic.LoadUint64(&m.afterCleanupFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CleanupFileMock.defaultExpectation != nil && afterCleanupFileCounter < 1 {
		if m.CleanupFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.CleanupFile at\n%s", m.CleanupFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.CleanupFile at\n%s with params: %#v", m.CleanupFileMock.defaultExpectation.expectationOrigins.origin, *m.CleanupFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCleanupFile != nil && afterCleanupFileCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.CleanupFile at\n%s", m.funcCleanupFileOrigin)
	}

	if !m.CleanupFileMock.invocationsDone() && afterCleanupFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.CleanupFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CleanupFileMock.expectedInvocations), m.CleanupFileMock.expectedInvocationsOrigin, afterCleanupFileCounter)
	}
}

type mServiceMockCleanupKnowledgeBase struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockCleanupKnowledgeBaseExpectation
	expectations       []*ServiceMockCleanupKnowledgeBaseExpectation

	callArgs []*ServiceMockCleanupKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockCleanupKnowledgeBaseExpectation specifies expectation struct of the Service.CleanupKnowledgeBase
type ServiceMockCleanupKnowledgeBaseExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockCleanupKnowledgeBaseParams
	paramPtrs          *ServiceMockCleanupKnowledgeBaseParamPtrs
	expectationOrigins ServiceMockCleanupKnowledgeBaseExpectationOrigins
	results            *ServiceMockCleanupKnowledgeBaseResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockCleanupKnowledgeBaseParams contains parameters of the Service.CleanupKnowledgeBase
type ServiceMockCleanupKnowledgeBaseParams struct {
	ctx context.Context
	k1  types.KBUIDType
}

// ServiceMockCleanupKnowledgeBaseParamPtrs contains pointers to parameters of the Service.CleanupKnowledgeBase
type ServiceMockCleanupKnowledgeBaseParamPtrs struct {
	ctx *context.Context
	k1  *types.KBUIDType
}

// ServiceMockCleanupKnowledgeBaseResults contains results of the Service.CleanupKnowledgeBase
type ServiceMockCleanupKnowledgeBaseResults struct {
	err error
}

// ServiceMockCleanupKnowledgeBaseOrigins contains origins of expectations of the Service.CleanupKnowledgeBase
type ServiceMockCleanupKnowledgeBaseExpectationOrigins struct {
	origin    string
	originCtx string
	originK1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCleanupKnowledgeBase *mServiceMockCleanupKnowledgeBase) Optional() *mServiceMockCleanupKnowledgeBase {
	mmCleanupKnowledgeBase.optional = true
	return mmCleanupKnowledgeBase
}

// Expect sets up expected params for Service.CleanupKnowledgeBase
func (mmCleanupKnowledgeBase *mServiceMockCleanupKnowledgeBase) Expect(ctx context.Context, k1 types.KBUIDType) *mServiceMockCleanupKnowledgeBase {
	if mmCleanupKnowledgeBase.mock.funcCleanupKnowledgeBase != nil {
		mmCleanupKnowledgeBase.mock.t.Fatalf("ServiceMock.CleanupKnowledgeBase mock is already set by Set")
	}

	if mmCleanupKnowledgeBase.defaultExpectation == nil {
		mmCleanupKnowledgeBase.defaultExpectation = &ServiceMockCleanupKnowledgeBaseExpectation{}
	}

	if mmCleanupKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmCleanupKnowledgeBase.mock.t.Fatalf("ServiceMock.CleanupKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmCleanupKnowledgeBase.defaultExpectation.params = &ServiceMockCleanupKnowledgeBaseParams{ctx, k1}
	mmCleanupKnowledgeBase.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCleanupKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmCleanupKnowledgeBase.defaultExpectation.params) {
			mmCleanupKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCleanupKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmCleanupKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for Service.CleanupKnowledgeBase
func (mmCleanupKnowledgeBase *mServiceMockCleanupKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mServiceMockCleanupKnowledgeBase {
	if mmCleanupKnowledgeBase.mock.funcCleanupKnowledgeBase != nil {
		mmCleanupKnowledgeBase.mock.t.Fatalf("ServiceMock.CleanupKnowledgeBase mock is already set by Set")
	}

	if mmCleanupKnowledgeBase.defaultExpectation == nil {
		mmCleanupKnowledgeBase.defaultExpectation = &ServiceMockCleanupKnowledgeBaseExpectation{}
	}

	if mmCleanupKnowledgeBase.defaultExpectation.params != nil {
		mmCleanupKnowledgeBase.mock.t.Fatalf("ServiceMock.CleanupKnowledgeBase mock is already set by Expect")
	}

	if mmCleanupKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCleanupKnowledgeBase.defaultExpectation.paramPtrs = &ServiceMockCleanupKnowledgeBaseParamPtrs{}
	}
	mmCleanupKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx
	mmCleanupKnowledgeBase.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCleanupKnowledgeBase
}

// ExpectK1Param2 sets up expected param k1 for Service.CleanupKnowledgeBase
func (mmCleanupKnowledgeBase *mServiceMockCleanupKnowledgeBase) ExpectK1Param2(k1 types.KBUIDType) *mServiceMockCleanupKnowledgeBase {
	if mmCleanupKnowledgeBase.mock.funcCleanupKnowledgeBase != nil {
		mmCleanupKnowledgeBase.mock.t.Fatalf("ServiceMock.CleanupKnowledgeBase mock is already set by Set")
	}

	if mmCleanupKnowledgeBase.defaultExpectation == nil {
		mmCleanupKnowledgeBase.defaultExpectation = &ServiceMockCleanupKnowledgeBaseExpectation{}
	}

	if mmCleanupKnowledgeBase.defaultExpectation.params != nil {
		mmCleanupKnowledgeBase.mock.t.Fatalf("ServiceMock.CleanupKnowledgeBase mock is already set by Expect")
	}

	if mmCleanupKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCleanupKnowledgeBase.defaultExpectation.paramPtrs = &ServiceMockCleanupKnowledgeBaseParamPtrs{}
	}
	mmCleanupKnowledgeBase.defaultExpectation.paramPtrs.k1 = &k1
	mmCleanupKnowledgeBase.defaultExpectation.expectationOrigins.originK1 = minimock.CallerInfo(1)

	return mmCleanupKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the Service.CleanupKnowledgeBase
func (mmCleanupKnowledgeBase *mServiceMockCleanupKnowledgeBase) Inspect(f func(ctx context.Context, k1 types.KBUIDType)) *mServiceMockCleanupKnowledgeBase {
	if mmCleanupKnowledgeBase.mock.inspectFuncCleanupKnowledgeBase != nil {
		mmCleanupKnowledgeBase.mock.t.Fatalf("Inspect function is already set for ServiceMock.CleanupKnowledgeBase")
	}

	mmCleanupKnowledgeBase.mock.inspectFuncCleanupKnowledgeBase = f

	return mmCleanupKnowledgeBase
}

// Return sets up results that will be returned by Service.CleanupKnowledgeBase
func (mmCleanupKnowledgeBase *mServiceMockCleanupKnowledgeBase) Return(err error) *ServiceMock {
	if mmCleanupKnowledgeBase.mock.funcCleanupKnowledgeBase != nil {
		mmCleanupKnowledgeBase.mock.t.Fatalf("ServiceMock.CleanupKnowledgeBase mock is already set by Set")
	}

	if mmCleanupKnowledgeBase.defaultExpectation == nil {
		mmCleanupKnowledgeBase.defaultExpectation = &ServiceMockCleanupKnowledgeBaseExpectation{mock: mmCleanupKnowledgeBase.mock}
	}
	mmCleanupKnowledgeBase.defaultExpectation.results = &ServiceMockCleanupKnowledgeBaseResults{err}
	mmCleanupKnowledgeBase.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCleanupKnowledgeBase.mock
}

// Set uses given function f to mock the Service.CleanupKnowledgeBase method
func (mmCleanupKnowledgeBase *mServiceMockCleanupKnowledgeBase) Set(f func(ctx context.Context, k1 types.KBUIDType) (err error)) *ServiceMock {
	if mmCleanupKnowledgeBase.defaultExpectation != nil {
		mmCleanupKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the Service.CleanupKnowledgeBase method")
	}

	if len(mmCleanupKnowledgeBase.expectations) > 0 {
		mmCleanupKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the Service.CleanupKnowledgeBase method")
	}

	mmCleanupKnowledgeBase.mock.funcCleanupKnowledgeBase = f
	mmCleanupKnowledgeBase.mock.funcCleanupKnowledgeBaseOrigin = minimock.CallerInfo(1)
	return mmCleanupKnowledgeBase.mock
}

// When sets expectation for the Service.CleanupKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmCleanupKnowledgeBase *mServiceMockCleanupKnowledgeBase) When(ctx context.Context, k1 types.KBUIDType) *ServiceMockCleanupKnowledgeBaseExpectation {
	if mmCleanupKnowledgeBase.mock.funcCleanupKnowledgeBase != nil {
		mmCleanupKnowledgeBase.mock.t.Fatalf("ServiceMock.CleanupKnowledgeBase mock is already set by Set")
	}

	expectation := &ServiceMockCleanupKnowledgeBaseExpectation{
		mock:               mmCleanupKnowledgeBase.mock,
		params:             &ServiceMockCleanupKnowledgeBaseParams{ctx, k1},
		expectationOrigins: ServiceMockCleanupKnowledgeBaseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCleanupKnowledgeBase.expectations = append(mmCleanupKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up Service.CleanupKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *ServiceMockCleanupKnowledgeBaseExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockCleanupKnowledgeBaseResults{err}
	return e.mock
}

// Times sets number of times Service.CleanupKnowledgeBase should be invoked
func (mmCleanupKnowledgeBase *mServiceMockCleanupKnowledgeBase) Times(n uint64) *mServiceMockCleanupKnowledgeBase {
	if n == 0 {
		mmCleanupKnowledgeBase.mock.t.Fatalf("Times of ServiceMock.CleanupKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCleanupKnowledgeBase.expectedInvocations, n)
	mmCleanupKnowledgeBase.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCleanupKnowledgeBase
}

func (mmCleanupKnowledgeBase *mServiceMockCleanupKnowledgeBase) invocationsDone() bool {
	if len(mmCleanupKnowledgeBase.expectations) == 0 && mmCleanupKnowledgeBase.defaultExpectation == nil && mmCleanupKnowledgeBase.mock.funcCleanupKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCleanupKnowledgeBase.mock.afterCleanupKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCleanupKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CleanupKnowledgeBase implements mm_service.Service
func (mmCleanupKnowledgeBase *ServiceMock) CleanupKnowledgeBase(ctx context.Context, k1 types.KBUIDType) (err error) {
	mm_atomic.AddUint64(&mmCleanupKnowledgeBase.beforeCleanupKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmCleanupKnowledgeBase.afterCleanupKnowledgeBaseCounter, 1)

	mmCleanupKnowledgeBase.t.Helper()

	if mmCleanupKnowledgeBase.inspectFuncCleanupKnowledgeBase != nil {
		mmCleanupKnowledgeBase.inspectFuncCleanupKnowledgeBase(ctx, k1)
	}

	mm_params := ServiceMockCleanupKnowledgeBaseParams{ctx, k1}

	// Record call args
	mmCleanupKnowledgeBase.CleanupKnowledgeBaseMock.mutex.Lock()
	mmCleanupKnowledgeBase.CleanupKnowledgeBaseMock.callArgs = append(mmCleanupKnowledgeBase.CleanupKnowledgeBaseMock.callArgs, &mm_params)
	mmCleanupKnowledgeBase.CleanupKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmCleanupKnowledgeBase.CleanupKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCleanupKnowledgeBase.CleanupKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCleanupKnowledgeBase.CleanupKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmCleanupKnowledgeBase.CleanupKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmCleanupKnowledgeBase.CleanupKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockCleanupKnowledgeBaseParams{ctx, k1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCleanupKnowledgeBase.t.Errorf("ServiceMock.CleanupKnowledgeBase got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCleanupKnowledgeBase.CleanupKnowledgeBaseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.k1 != nil && !minimock.Equal(*mm_want_ptrs.k1, mm_got.k1) {
				mmCleanupKnowledgeBase.t.Errorf("ServiceMock.CleanupKnowledgeBase got unexpected parameter k1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCleanupKnowledgeBase.CleanupKnowledgeBaseMock.defaultExpectation.expectationOrigins.originK1, *mm_want_ptrs.k1, mm_got.k1, minimock.Diff(*mm_want_ptrs.k1, mm_got.k1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCleanupKnowledgeBase.t.Errorf("ServiceMock.CleanupKnowledgeBase got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCleanupKnowledgeBase.CleanupKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCleanupKnowledgeBase.CleanupKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmCleanupKnowledgeBase.t.Fatal("No results are set for the ServiceMock.CleanupKnowledgeBase")
		}
		return (*mm_results).err
	}
	if mmCleanupKnowledgeBase.funcCleanupKnowledgeBase != nil {
		return mmCleanupKnowledgeBase.funcCleanupKnowledgeBase(ctx, k1)
	}
	mmCleanupKnowledgeBase.t.Fatalf("Unexpected call to ServiceMock.CleanupKnowledgeBase. %v %v", ctx, k1)
	return
}

// CleanupKnowledgeBaseAfterCounter returns a count of finished ServiceMock.CleanupKnowledgeBase invocations
func (mmCleanupKnowledgeBase *ServiceMock) CleanupKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCleanupKnowledgeBase.afterCleanupKnowledgeBaseCounter)
}

// CleanupKnowledgeBaseBeforeCounter returns a count of ServiceMock.CleanupKnowledgeBase invocations
func (mmCleanupKnowledgeBase *ServiceMock) CleanupKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCleanupKnowledgeBase.beforeCleanupKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.CleanupKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCleanupKnowledgeBase *mServiceMockCleanupKnowledgeBase) Calls() []*ServiceMockCleanupKnowledgeBaseParams {
	mmCleanupKnowledgeBase.mutex.RLock()

	argCopy := make([]*ServiceMockCleanupKnowledgeBaseParams, len(mmCleanupKnowledgeBase.callArgs))
	copy(argCopy, mmCleanupKnowledgeBase.callArgs)

	mmCleanupKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockCleanupKnowledgeBaseDone returns true if the count of the CleanupKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCleanupKnowledgeBaseDone() bool {
	if m.CleanupKnowledgeBaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CleanupKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CleanupKnowledgeBaseMock.invocationsDone()
}

// MinimockCleanupKnowledgeBaseInspect logs each unmet expectation
func (m *ServiceMock) MinimockCleanupKnowledgeBaseInspect() {
	for _, e := range m.CleanupKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.CleanupKnowledgeBase at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCleanupKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterCleanupKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CleanupKnowledgeBaseMock.defaultExpectation != nil && afterCleanupKnowledgeBaseCounter < 1 {
		if m.CleanupKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.CleanupKnowledgeBase at\n%s", m.CleanupKnowledgeBaseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.CleanupKnowledgeBase at\n%s with params: %#v", m.CleanupKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *m.CleanupKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCleanupKnowledgeBase != nil && afterCleanupKnowledgeBaseCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.CleanupKnowledgeBase at\n%s", m.funcCleanupKnowledgeBaseOrigin)
	}

	if !m.CleanupKnowledgeBaseMock.invocationsDone() && afterCleanupKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.CleanupKnowledgeBase at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CleanupKnowledgeBaseMock.expectedInvocations), m.CleanupKnowledgeBaseMock.expectedInvocationsOrigin, afterCleanupKnowledgeBaseCounter)
	}
}

type mServiceMockCreateRepositoryTag struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockCreateRepositoryTagExpectation
	expectations       []*ServiceMockCreateRepositoryTagExpectation

	callArgs []*ServiceMockCreateRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockCreateRepositoryTagExpectation specifies expectation struct of the Service.CreateRepositoryTag
type ServiceMockCreateRepositoryTagExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockCreateRepositoryTagParams
	paramPtrs          *ServiceMockCreateRepositoryTagParamPtrs
	expectationOrigins ServiceMockCreateRepositoryTagExpectationOrigins
	results            *ServiceMockCreateRepositoryTagResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockCreateRepositoryTagParams contains parameters of the Service.CreateRepositoryTag
type ServiceMockCreateRepositoryTagParams struct {
	ctx context.Context
	cp1 *artifactpb.CreateRepositoryTagRequest
}

// ServiceMockCreateRepositoryTagParamPtrs contains pointers to parameters of the Service.CreateRepositoryTag
type ServiceMockCreateRepositoryTagParamPtrs struct {
	ctx *context.Context
	cp1 **artifactpb.CreateRepositoryTagRequest
}

// ServiceMockCreateRepositoryTagResults contains results of the Service.CreateRepositoryTag
type ServiceMockCreateRepositoryTagResults struct {
	cp2 *artifactpb.CreateRepositoryTagResponse
	err error
}

// ServiceMockCreateRepositoryTagOrigins contains origins of expectations of the Service.CreateRepositoryTag
type ServiceMockCreateRepositoryTagExpectationOrigins struct {
	origin    string
	originCtx string
	originCp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) Optional() *mServiceMockCreateRepositoryTag {
	mmCreateRepositoryTag.optional = true
	return mmCreateRepositoryTag
}

// Expect sets up expected params for Service.CreateRepositoryTag
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) Expect(ctx context.Context, cp1 *artifactpb.CreateRepositoryTagRequest) *mServiceMockCreateRepositoryTag {
	if mmCreateRepositoryTag.mock.funcCreateRepositoryTag != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("ServiceMock.CreateRepositoryTag mock is already set by Set")
	}

	if mmCreateRepositoryTag.defaultExpectation == nil {
		mmCreateRepositoryTag.defaultExpectation = &ServiceMockCreateRepositoryTagExpectation{}
	}

	if mmCreateRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("ServiceMock.CreateRepositoryTag mock is already set by ExpectParams functions")
	}

	mmCreateRepositoryTag.defaultExpectation.params = &ServiceMockCreateRepositoryTagParams{ctx, cp1}
	mmCreateRepositoryTag.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateRepositoryTag.expectations {
		if minimock.Equal(e.params, mmCreateRepositoryTag.defaultExpectation.params) {
			mmCreateRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateRepositoryTag.defaultExpectation.params)
		}
	}

	return mmCreateRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for Service.CreateRepositoryTag
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) ExpectCtxParam1(ctx context.Context) *mServiceMockCreateRepositoryTag {
	if mmCreateRepositoryTag.mock.funcCreateRepositoryTag != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("ServiceMock.CreateRepositoryTag mock is already set by Set")
	}

	if mmCreateRepositoryTag.defaultExpectation == nil {
		mmCreateRepositoryTag.defaultExpectation = &ServiceMockCreateRepositoryTagExpectation{}
	}

	if mmCreateRepositoryTag.defaultExpectation.params != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("ServiceMock.CreateRepositoryTag mock is already set by Expect")
	}

	if mmCreateRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmCreateRepositoryTag.defaultExpectation.paramPtrs = &ServiceMockCreateRepositoryTagParamPtrs{}
	}
	mmCreateRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateRepositoryTag.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateRepositoryTag
}

// ExpectCp1Param2 sets up expected param cp1 for Service.CreateRepositoryTag
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) ExpectCp1Param2(cp1 *artifactpb.CreateRepositoryTagRequest) *mServiceMockCreateRepositoryTag {
	if mmCreateRepositoryTag.mock.funcCreateRepositoryTag != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("ServiceMock.CreateRepositoryTag mock is already set by Set")
	}

	if mmCreateRepositoryTag.defaultExpectation == nil {
		mmCreateRepositoryTag.defaultExpectation = &ServiceMockCreateRepositoryTagExpectation{}
	}

	if mmCreateRepositoryTag.defaultExpectation.params != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("ServiceMock.CreateRepositoryTag mock is already set by Expect")
	}

	if mmCreateRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmCreateRepositoryTag.defaultExpectation.paramPtrs = &ServiceMockCreateRepositoryTagParamPtrs{}
	}
	mmCreateRepositoryTag.defaultExpectation.paramPtrs.cp1 = &cp1
	mmCreateRepositoryTag.defaultExpectation.expectationOrigins.originCp1 = minimock.CallerInfo(1)

	return mmCreateRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the Service.CreateRepositoryTag
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) Inspect(f func(ctx context.Context, cp1 *artifactpb.CreateRepositoryTagRequest)) *mServiceMockCreateRepositoryTag {
	if mmCreateRepositoryTag.mock.inspectFuncCreateRepositoryTag != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("Inspect function is already set for ServiceMock.CreateRepositoryTag")
	}

	mmCreateRepositoryTag.mock.inspectFuncCreateRepositoryTag = f

	return mmCreateRepositoryTag
}

// Return sets up results that will be returned by Service.CreateRepositoryTag
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) Return(cp2 *artifactpb.CreateRepositoryTagResponse, err error) *ServiceMock {
	if mmCreateRepositoryTag.mock.funcCreateRepositoryTag != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("ServiceMock.CreateRepositoryTag mock is already set by Set")
	}

	if mmCreateRepositoryTag.defaultExpectation == nil {
		mmCreateRepositoryTag.defaultExpectation = &ServiceMockCreateRepositoryTagExpectation{mock: mmCreateRepositoryTag.mock}
	}
	mmCreateRepositoryTag.defaultExpectation.results = &ServiceMockCreateRepositoryTagResults{cp2, err}
	mmCreateRepositoryTag.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateRepositoryTag.mock
}

// Set uses given function f to mock the Service.CreateRepositoryTag method
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) Set(f func(ctx context.Context, cp1 *artifactpb.CreateRepositoryTagRequest) (cp2 *artifactpb.CreateRepositoryTagResponse, err error)) *ServiceMock {
	if mmCreateRepositoryTag.defaultExpectation != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("Default expectation is already set for the Service.CreateRepositoryTag method")
	}

	if len(mmCreateRepositoryTag.expectations) > 0 {
		mmCreateRepositoryTag.mock.t.Fatalf("Some expectations are already set for the Service.CreateRepositoryTag method")
	}

	mmCreateRepositoryTag.mock.funcCreateRepositoryTag = f
	mmCreateRepositoryTag.mock.funcCreateRepositoryTagOrigin = minimock.CallerInfo(1)
	return mmCreateRepositoryTag.mock
}

// When sets expectation for the Service.CreateRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) When(ctx context.Context, cp1 *artifactpb.CreateRepositoryTagRequest) *ServiceMockCreateRepositoryTagExpectation {
	if mmCreateRepositoryTag.mock.funcCreateRepositoryTag != nil {
		mmCreateRepositoryTag.mock.t.Fatalf("ServiceMock.CreateRepositoryTag mock is already set by Set")
	}

	expectation := &ServiceMockCreateRepositoryTagExpectation{
		mock:               mmCreateRepositoryTag.mock,
		params:             &ServiceMockCreateRepositoryTagParams{ctx, cp1},
		expectationOrigins: ServiceMockCreateRepositoryTagExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateRepositoryTag.expectations = append(mmCreateRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up Service.CreateRepositoryTag return parameters for the expectation previously defined by the When method
func (e *ServiceMockCreateRepositoryTagExpectation) Then(cp2 *artifactpb.CreateRepositoryTagResponse, err error) *ServiceMock {
	e.results = &ServiceMockCreateRepositoryTagResults{cp2, err}
	return e.mock
}

// Times sets number of times Service.CreateRepositoryTag should be invoked
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) Times(n uint64) *mServiceMockCreateRepositoryTag {
	if n == 0 {
		mmCreateRepositoryTag.mock.t.Fatalf("Times of ServiceMock.CreateRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateRepositoryTag.expectedInvocations, n)
	mmCreateRepositoryTag.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateRepositoryTag
}

func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) invocationsDone() bool {
	if len(mmCreateRepositoryTag.expectations) == 0 && mmCreateRepositoryTag.defaultExpectation == nil && mmCreateRepositoryTag.mock.funcCreateRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateRepositoryTag.mock.afterCreateRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateRepositoryTag implements mm_service.Service
func (mmCreateRepositoryTag *ServiceMock) CreateRepositoryTag(ctx context.Context, cp1 *artifactpb.CreateRepositoryTagRequest) (cp2 *artifactpb.CreateRepositoryTagResponse, err error) {
	mm_atomic.AddUint64(&mmCreateRepositoryTag.beforeCreateRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateRepositoryTag.afterCreateRepositoryTagCounter, 1)

	mmCreateRepositoryTag.t.Helper()

	if mmCreateRepositoryTag.inspectFuncCreateRepositoryTag != nil {
		mmCreateRepositoryTag.inspectFuncCreateRepositoryTag(ctx, cp1)
	}

	mm_params := ServiceMockCreateRepositoryTagParams{ctx, cp1}

	// Record call args
	mmCreateRepositoryTag.CreateRepositoryTagMock.mutex.Lock()
	mmCreateRepositoryTag.CreateRepositoryTagMock.callArgs = append(mmCreateRepositoryTag.CreateRepositoryTagMock.callArgs, &mm_params)
	mmCreateRepositoryTag.CreateRepositoryTagMock.mutex.Unlock()

	for _, e := range mmCreateRepositoryTag.CreateRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp2, e.results.err
		}
	}

	if mmCreateRepositoryTag.CreateRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateRepositoryTag.CreateRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateRepositoryTag.CreateRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmCreateRepositoryTag.CreateRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockCreateRepositoryTagParams{ctx, cp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateRepositoryTag.t.Errorf("ServiceMock.CreateRepositoryTag got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateRepositoryTag.CreateRepositoryTagMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cp1 != nil && !minimock.Equal(*mm_want_ptrs.cp1, mm_got.cp1) {
				mmCreateRepositoryTag.t.Errorf("ServiceMock.CreateRepositoryTag got unexpected parameter cp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateRepositoryTag.CreateRepositoryTagMock.defaultExpectation.expectationOrigins.originCp1, *mm_want_ptrs.cp1, mm_got.cp1, minimock.Diff(*mm_want_ptrs.cp1, mm_got.cp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateRepositoryTag.t.Errorf("ServiceMock.CreateRepositoryTag got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateRepositoryTag.CreateRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateRepositoryTag.CreateRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateRepositoryTag.t.Fatal("No results are set for the ServiceMock.CreateRepositoryTag")
		}
		return (*mm_results).cp2, (*mm_results).err
	}
	if mmCreateRepositoryTag.funcCreateRepositoryTag != nil {
		return mmCreateRepositoryTag.funcCreateRepositoryTag(ctx, cp1)
	}
	mmCreateRepositoryTag.t.Fatalf("Unexpected call to ServiceMock.CreateRepositoryTag. %v %v", ctx, cp1)
	return
}

// CreateRepositoryTagAfterCounter returns a count of finished ServiceMock.CreateRepositoryTag invocations
func (mmCreateRepositoryTag *ServiceMock) CreateRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateRepositoryTag.afterCreateRepositoryTagCounter)
}

// CreateRepositoryTagBeforeCounter returns a count of ServiceMock.CreateRepositoryTag invocations
func (mmCreateRepositoryTag *ServiceMock) CreateRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateRepositoryTag.beforeCreateRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.CreateRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateRepositoryTag *mServiceMockCreateRepositoryTag) Calls() []*ServiceMockCreateRepositoryTagParams {
	mmCreateRepositoryTag.mutex.RLock()

	argCopy := make([]*ServiceMockCreateRepositoryTagParams, len(mmCreateRepositoryTag.callArgs))
	copy(argCopy, mmCreateRepositoryTag.callArgs)

	mmCreateRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockCreateRepositoryTagDone returns true if the count of the CreateRepositoryTag invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCreateRepositoryTagDone() bool {
	if m.CreateRepositoryTagMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateRepositoryTagMock.invocationsDone()
}

// MinimockCreateRepositoryTagInspect logs each unmet expectation
func (m *ServiceMock) MinimockCreateRepositoryTagInspect() {
	for _, e := range m.CreateRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.CreateRepositoryTag at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterCreateRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateRepositoryTagMock.defaultExpectation != nil && afterCreateRepositoryTagCounter < 1 {
		if m.CreateRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.CreateRepositoryTag at\n%s", m.CreateRepositoryTagMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.CreateRepositoryTag at\n%s with params: %#v", m.CreateRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *m.CreateRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateRepositoryTag != nil && afterCreateRepositoryTagCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.CreateRepositoryTag at\n%s", m.funcCreateRepositoryTagOrigin)
	}

	if !m.CreateRepositoryTagMock.invocationsDone() && afterCreateRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.CreateRepositoryTag at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateRepositoryTagMock.expectedInvocations), m.CreateRepositoryTagMock.expectedInvocationsOrigin, afterCreateRepositoryTagCounter)
	}
}

type mServiceMockCreateSystemAdmin struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockCreateSystemAdminExpectation
	expectations       []*ServiceMockCreateSystemAdminExpectation

	callArgs []*ServiceMockCreateSystemAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockCreateSystemAdminExpectation specifies expectation struct of the Service.CreateSystemAdmin
type ServiceMockCreateSystemAdminExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockCreateSystemAdminParams
	paramPtrs          *ServiceMockCreateSystemAdminParamPtrs
	expectationOrigins ServiceMockCreateSystemAdminExpectationOrigins
	results            *ServiceMockCreateSystemAdminResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockCreateSystemAdminParams contains parameters of the Service.CreateSystemAdmin
type ServiceMockCreateSystemAdminParams struct {
	ctx context.Context
	cp1 *artifactpb.CreateSystemAdminRequest
}

// ServiceMockCreateSystemAdminParamPtrs contains pointers to parameters of the Service.CreateSystemAdmin
type ServiceMockCreateSystemAdminParamPtrs struct {
	ctx *context.Context
	cp1 **artifactpb.CreateSystemAdminRequest
}

// ServiceMockCreateSystemAdminResults contains results of the Service.CreateSystemAdmin
type ServiceMockCreateSystemAdminResults struct {
	cp2 *artifactpb.CreateSystemAdminResponse
	err error
}

// ServiceMockCreateSystemAdminOrigins contains origins of expectations of the Service.CreateSystemAdmin
type ServiceMockCreateSystemAdminExpectationOrigins struct {
	origin    string
	originCtx string
	originCp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateSystemAdmin *mServiceMockCreateSystemAdmin) Optional() *mServiceMockCreateSystemAdmin {
	mmCreateSystemAdmin.optional = true
	return mmCreateSystemAdmin
}

// Expect sets up expected params for Service.CreateSystemAdmin
func (mmCreateSystemAdmin *mServiceMockCreateSystemAdmin) Expect(ctx context.Context, cp1 *artifactpb.CreateSystemAdminRequest) *mServiceMockCreateSystemAdmin {
	if mmCreateSystemAdmin.mock.funcCreateSystemAdmin != nil {
		mmCreateSystemAdmin.mock.t.Fatalf("ServiceMock.CreateSystemAdmin mock is already set by Set")
	}

	if mmCreateSystemAdmin.defaultExpectation == nil {
		mmCreateSystemAdmin.defaultExpectation = &ServiceMockCreateSystemAdminExpectation{}
	}

	if mmCreateSystemAdmin.defaultExpectation.paramPtrs != nil {
		mmCreateSystemAdmin.mock.t.Fatalf("ServiceMock.CreateSystemAdmin mock is already set by ExpectParams functions")
	}

	mmCreateSystemAdmin.defaultExpectation.params = &ServiceMockCreateSystemAdminParams{ctx, cp1}
	mmCreateSystemAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateSystemAdmin.expectations {
		if minimock.Equal(e.params, mmCreateSystemAdmin.defaultExpectation.params) {
			mmCreateSystemAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateSystemAdmin.defaultExpectation.params)
		}
	}

	return mmCreateSystemAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Service.CreateSystemAdmin
func (mmCreateSystemAdmin *mServiceMockCreateSystemAdmin) ExpectCtxParam1(ctx context.Context) *mServiceMockCreateSystemAdmin {
	if mmCreateSystemAdmin.mock.funcCreateSystemAdmin != nil {
		mmCreateSystemAdmin.mock.t.Fatalf("ServiceMock.CreateSystemAdmin mock is already set by Set")
	}

	if mmCreateSystemAdmin.defaultExpectation == nil {
		mmCreateSystemAdmin.defaultExpectation = &ServiceMockCreateSystemAdminExpectation{}
	}

	if mmCreateSystemAdmin.defaultExpectation.params != nil {
		mmCreateSystemAdmin.mock.t.Fatalf("ServiceMock.CreateSystemAdmin mock is already set by Expect")
	}

	if mmCreateSystemAdmin.defaultExpectation.paramPtrs == nil {
		mmCreateSystemAdmin.defaultExpectation.paramPtrs = &ServiceMockCreateSystemAdminParamPtrs{}
	}
	mmCreateSystemAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateSystemAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateSystemAdmin
}

// ExpectCp1Param2 sets up expected param cp1 for Service.CreateSystemAdmin
func (mmCreateSystemAdmin *mServiceMockCreateSystemAdmin) ExpectCp1Param2(cp1 *artifactpb.CreateSystemAdminRequest) *mServiceMockCreateSystemAdmin {
	if mmCreateSystemAdmin.mock.funcCreateSystemAdmin != nil {
		mmCreateSystemAdmin.mock.t.Fatalf("ServiceMock.CreateSystemAdmin mock is already set by Set")
	}

	if mmCreateSystemAdmin.defaultExpectation == nil {
		mmCreateSystemAdmin.defaultExpectation = &ServiceMockCreateSystemAdminExpectation{}
	}

	if mmCreateSystemAdmin.defaultExpectation.params != nil {
		mmCreateSystemAdmin.mock.t.Fatalf("ServiceMock.CreateSystemAdmin mock is already set by Expect")
	}

	if mmCreateSystemAdmin.defaultExpectation.paramPtrs == nil {
		mmCreateSystemAdmin.defaultExpectation.paramPtrs = &ServiceMockCreateSystemAdminParamPtrs{}
	}
	mmCreateSystemAdmin.defaultExpectation.paramPtrs.cp1 = &cp1
	mmCreateSystemAdmin.defaultExpectation.expectationOrigins.originCp1 = minimock.CallerInfo(1)

	return mmCreateSystemAdmin
}

// Inspect accepts an inspector function that has same arguments as the Service.CreateSystemAdmin
func (mmCreateSystemAdmin *mServiceMockCreateSystemAdmin) Inspect(f func(ctx context.Context, cp1 *artifactpb.CreateSystemAdminRequest)) *mServiceMockCreateSystemAdmin {
	if mmCreateSystemAdmin.mock.inspectFuncCreateSystemAdmin != nil {
		mmCreateSystemAdmin.mock.t.Fatalf("Inspect function is already set for ServiceMock.CreateSystemAdmin")
	}

	mmCreateSystemAdmin.mock.inspectFuncCreateSystemAdmin = f

	return mmCreateSystemAdmin
}

// Return sets up results that will be returned by Service.CreateSystemAdmin
func (mmCreateSystemAdmin *mServiceMockCreateSystemAdmin) Return(cp2 *artifactpb.CreateSystemAdminResponse, err error) *ServiceMock {
	if mmCreateSystemAdmin.mock.funcCreateSystemAdmin != nil {
		mmCreateSystemAdmin.mock.t.Fatalf("ServiceMock.CreateSystemAdmin mock is already set by Set")
	}

	if mmCreateSystemAdmin.defaultExpectation == nil {
		mmCreateSystemAdmin.defaultExpectation = &ServiceMockCreateSystemAdminExpectation{mock: mmCreateSystemAdmin.mock}
	}
	mmCreateSystemAdmin.defaultExpectation.results = &ServiceMockCreateSystemAdminResults{cp2, err}
	mmCreateSystemAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateSystemAdmin.mock
}

// Set uses given function f to mock the Service.CreateSystemAdmin method
func (mmCreateSystemAdmin *mServiceMockCreateSystemAdmin) Set(f func(ctx context.Context, cp1 *artifactpb.CreateSystemAdminRequest) (cp2 *artifactpb.CreateSystemAdminResponse, err error)) *ServiceMock {
	if mmCreateSystemAdmin.defaultExpectation != nil {
		mmCreateSystemAdmin.mock.t.Fatalf("Default expectation is already set for the Service.CreateSystemAdmin method")
	}

	if len(mmCreateSystemAdmin.expectations) > 0 {
		mmCreateSystemAdmin.mock.t.Fatalf("Some expectations are already set for the Service.CreateSystemAdmin method")
	}

	mmCreateSystemAdmin.mock.funcCreateSystemAdmin = f
	mmCreateSystemAdmin.mock.funcCreateSystemAdminOrigin = minimock.CallerInfo(1)
	return mmCreateSystemAdmin.mock
}

// When sets expectation for the Service.CreateSystemAdmin which will trigger the result defined by the following
// Then helper
func (mmCreateSystemAdmin *mServiceMockCreateSystemAdmin) When(ctx context.Context, cp1 *artifactpb.CreateSystemAdminRequest) *ServiceMockCreateSystemAdminExpectation {
	if mmCreateSystemAdmin.mock.funcCreateSystemAdmin != nil {
		mmCreateSystemAdmin.mock.t.Fatalf("ServiceMock.CreateSystemAdmin mock is already set by Set")
	}

	expectation := &ServiceMockCreateSystemAdminExpectation{
		mock:               mmCreateSystemAdmin.mock,
		params:             &ServiceMockCreateSystemAdminParams{ctx, cp1},
		expectationOrigins: ServiceMockCreateSystemAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateSystemAdmin.expectations = append(mmCreateSystemAdmin.expectations, expectation)
	return expectation
}

// Then sets up Service.CreateSystemAdmin return parameters for the expectation previously defined by the When method
func (e *ServiceMockCreateSystemAdminExpectation) Then(cp2 *artifactpb.CreateSystemAdminResponse, err error) *ServiceMock {
	e.results = &ServiceMockCreateSystemAdminResults{cp2, err}
	return e.mock
}

// Times sets number of times Service.CreateSystemAdmin should be invoked
func (mmCreateSystemAdmin *mServiceMockCreateSystemAdmin) Times(n uint64) *mServiceMockCreateSystemAdmin {
	if n == 0 {
		mmCreateSystemAdmin.mock.t.Fatalf("Times of ServiceMock.CreateSystemAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateSystemAdmin.expectedInvocations, n)
	mmCreateSystemAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateSystemAdmin
}

func (mmCreateSystemAdmin *mServiceMockCreateSystemAdmin) invocationsDone() bool {
	if len(mmCreateSystemAdmin.expectations) == 0 && mmCreateSystemAdmin.defaultExpectation == nil && mmCreateSystemAdmin.mock.funcCreateSystemAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateSystemAdmin.mock.afterCreateSystemAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateSystemAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateSystemAdmin implements mm_service.Service
func (mmCreateSystemAdmin *ServiceMock) CreateSystemAdmin(ctx context.Context, cp1 *artifactpb.CreateSystemAdminRequest) (cp2 *artifactpb.CreateSystemAdminResponse, err error) {
	mm_atomic.AddUint64(&mmCreateSystemAdmin.beforeCreateSystemAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateSystemAdmin.afterCreateSystemAdminCounter, 1)

	mmCreateSystemAdmin.t.Helper()

	if mmCreateSystemAdmin.inspectFuncCreateSystemAdmin != nil {
		mmCreateSystemAdmin.inspectFuncCreateSystemAdmin(ctx, cp1)
	}

	mm_params := ServiceMockCreateSystemAdminParams{ctx, cp1}

	// Record call args
	mmCreateSystemAdmin.CreateSystemAdminMock.mutex.Lock()
	mmCreateSystemAdmin.CreateSystemAdminMock.callArgs = append(mmCreateSystemAdmin.CreateSystemAdminMock.callArgs, &mm_params)
	mmCreateSystemAdmin.CreateSystemAdminMock.mutex.Unlock()

	for _, e := range mmCreateSystemAdmin.CreateSystemAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp2, e.results.err
		}
	}

	if mmCreateSystemAdmin.CreateSystemAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateSystemAdmin.CreateSystemAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateSystemAdmin.CreateSystemAdminMock.defaultExpectation.params
		mm_want_ptrs := mmCreateSystemAdmin.CreateSystemAdminMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockCreateSystemAdminParams{ctx, cp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateSystemAdmin.t.Errorf("ServiceMock.CreateSystemAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateSystemAdmin.CreateSystemAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cp1 != nil && !minimock.Equal(*mm_want_ptrs.cp1, mm_got.cp1) {
				mmCreateSystemAdmin.t.Errorf("ServiceMock.CreateSystemAdmin got unexpected parameter cp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateSystemAdmin.CreateSystemAdminMock.defaultExpectation.expectationOrigins.originCp1, *mm_want_ptrs.cp1, mm_got.cp1, minimock.Diff(*mm_want_ptrs.cp1, mm_got.cp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateSystemAdmin.t.Errorf("ServiceMock.CreateSystemAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateSystemAdmin.CreateSystemAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateSystemAdmin.CreateSystemAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateSystemAdmin.t.Fatal("No results are set for the ServiceMock.CreateSystemAdmin")
		}
		return (*mm_results).cp2, (*mm_results).err
	}
	if mmCreateSystemAdmin.funcCreateSystemAdmin != nil {
		return mmCreateSystemAdmin.funcCreateSystemAdmin(ctx, cp1)
	}
	mmCreateSystemAdmin.t.Fatalf("Unexpected call to ServiceMock.CreateSystemAdmin. %v %v", ctx, cp1)
	return
}

// CreateSystemAdminAfterCounter returns a count of finished ServiceMock.CreateSystemAdmin invocations
func (mmCreateSystemAdmin *ServiceMock) CreateSystemAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateSystemAdmin.afterCreateSystemAdminCounter)
}

// CreateSystemAdminBeforeCounter returns a count of ServiceMock.CreateSystemAdmin invocations
func (mmCreateSystemAdmin *ServiceMock) CreateSystemAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateSystemAdmin.beforeCreateSystemAdminCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.CreateSystemAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateSystemAdmin *mServiceMockCreateSystemAdmin) Calls() []*ServiceMockCreateSystemAdminParams {
	mmCreateSystemAdmin.mutex.RLock()

	argCopy := make([]*ServiceMockCreateSystemAdminParams, len(mmCreateSystemAdmin.callArgs))
	copy(argCopy, mmCreateSystemAdmin.callArgs)

	mmCreateSystemAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockCreateSystemAdminDone returns true if the count of the CreateSystemAdmin invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCreateSystemAdminDone() bool {
	if m.CreateSystemAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateSystemAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateSystemAdminMock.invocationsDone()
}

// MinimockCreateSystemAdminInspect logs each unmet expectation
func (m *ServiceMock) MinimockCreateSystemAdminInspect() {
	for _, e := range m.CreateSystemAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.CreateSystemAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateSystemAdminCounter := mm_atomic.LoadUint64(&m.afterCreateSystemAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateSystemAdminMock.defaultExpectation != nil && afterCreateSystemAdminCounter < 1 {
		if m.CreateSystemAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.CreateSystemAdmin at\n%s", m.CreateSystemAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.CreateSystemAdmin at\n%s with params: %#v", m.CreateSystemAdminMock.defaultExpectation.expectationOrigins.origin, *m.CreateSystemAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateSystemAdmin != nil && afterCreateSystemAdminCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.CreateSystemAdmin at\n%s", m.funcCreateSystemAdminOrigin)
	}

	if !m.CreateSystemAdminMock.invocationsDone() && afterCreateSystemAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.CreateSystemAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateSystemAdminMock.expectedInvocations), m.CreateSystemAdminMock.expectedInvocationsOrigin, afterCreateSystemAdminCounter)
	}
}

type mServiceMockDeleteFiles struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockDeleteFilesExpectation
	expectations       []*ServiceMockDeleteFilesExpectation

	callArgs []*ServiceMockDeleteFilesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockDeleteFilesExpectation specifies expectation struct of the Service.DeleteFiles
type ServiceMockDeleteFilesExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockDeleteFilesParams
	paramPtrs          *ServiceMockDeleteFilesParamPtrs
	expectationOrigins ServiceMockDeleteFilesExpectationOrigins
	results            *ServiceMockDeleteFilesResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockDeleteFilesParams contains parameters of the Service.DeleteFiles
type ServiceMockDeleteFilesParams struct {
	ctx context.Context
	s1  string
	sa1 []string
}

// ServiceMockDeleteFilesParamPtrs contains pointers to parameters of the Service.DeleteFiles
type ServiceMockDeleteFilesParamPtrs struct {
	ctx *context.Context
	s1  *string
	sa1 *[]string
}

// ServiceMockDeleteFilesResults contains results of the Service.DeleteFiles
type ServiceMockDeleteFilesResults struct {
	err error
}

// ServiceMockDeleteFilesOrigins contains origins of expectations of the Service.DeleteFiles
type ServiceMockDeleteFilesExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
	originSa1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteFiles *mServiceMockDeleteFiles) Optional() *mServiceMockDeleteFiles {
	mmDeleteFiles.optional = true
	return mmDeleteFiles
}

// Expect sets up expected params for Service.DeleteFiles
func (mmDeleteFiles *mServiceMockDeleteFiles) Expect(ctx context.Context, s1 string, sa1 []string) *mServiceMockDeleteFiles {
	if mmDeleteFiles.mock.funcDeleteFiles != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by Set")
	}

	if mmDeleteFiles.defaultExpectation == nil {
		mmDeleteFiles.defaultExpectation = &ServiceMockDeleteFilesExpectation{}
	}

	if mmDeleteFiles.defaultExpectation.paramPtrs != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by ExpectParams functions")
	}

	mmDeleteFiles.defaultExpectation.params = &ServiceMockDeleteFilesParams{ctx, s1, sa1}
	mmDeleteFiles.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteFiles.expectations {
		if minimock.Equal(e.params, mmDeleteFiles.defaultExpectation.params) {
			mmDeleteFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteFiles.defaultExpectation.params)
		}
	}

	return mmDeleteFiles
}

// ExpectCtxParam1 sets up expected param ctx for Service.DeleteFiles
func (mmDeleteFiles *mServiceMockDeleteFiles) ExpectCtxParam1(ctx context.Context) *mServiceMockDeleteFiles {
	if mmDeleteFiles.mock.funcDeleteFiles != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by Set")
	}

	if mmDeleteFiles.defaultExpectation == nil {
		mmDeleteFiles.defaultExpectation = &ServiceMockDeleteFilesExpectation{}
	}

	if mmDeleteFiles.defaultExpectation.params != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by Expect")
	}

	if mmDeleteFiles.defaultExpectation.paramPtrs == nil {
		mmDeleteFiles.defaultExpectation.paramPtrs = &ServiceMockDeleteFilesParamPtrs{}
	}
	mmDeleteFiles.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteFiles.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteFiles
}

// ExpectS1Param2 sets up expected param s1 for Service.DeleteFiles
func (mmDeleteFiles *mServiceMockDeleteFiles) ExpectS1Param2(s1 string) *mServiceMockDeleteFiles {
	if mmDeleteFiles.mock.funcDeleteFiles != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by Set")
	}

	if mmDeleteFiles.defaultExpectation == nil {
		mmDeleteFiles.defaultExpectation = &ServiceMockDeleteFilesExpectation{}
	}

	if mmDeleteFiles.defaultExpectation.params != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by Expect")
	}

	if mmDeleteFiles.defaultExpectation.paramPtrs == nil {
		mmDeleteFiles.defaultExpectation.paramPtrs = &ServiceMockDeleteFilesParamPtrs{}
	}
	mmDeleteFiles.defaultExpectation.paramPtrs.s1 = &s1
	mmDeleteFiles.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmDeleteFiles
}

// ExpectSa1Param3 sets up expected param sa1 for Service.DeleteFiles
func (mmDeleteFiles *mServiceMockDeleteFiles) ExpectSa1Param3(sa1 []string) *mServiceMockDeleteFiles {
	if mmDeleteFiles.mock.funcDeleteFiles != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by Set")
	}

	if mmDeleteFiles.defaultExpectation == nil {
		mmDeleteFiles.defaultExpectation = &ServiceMockDeleteFilesExpectation{}
	}

	if mmDeleteFiles.defaultExpectation.params != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by Expect")
	}

	if mmDeleteFiles.defaultExpectation.paramPtrs == nil {
		mmDeleteFiles.defaultExpectation.paramPtrs = &ServiceMockDeleteFilesParamPtrs{}
	}
	mmDeleteFiles.defaultExpectation.paramPtrs.sa1 = &sa1
	mmDeleteFiles.defaultExpectation.expectationOrigins.originSa1 = minimock.CallerInfo(1)

	return mmDeleteFiles
}

// Inspect accepts an inspector function that has same arguments as the Service.DeleteFiles
func (mmDeleteFiles *mServiceMockDeleteFiles) Inspect(f func(ctx context.Context, s1 string, sa1 []string)) *mServiceMockDeleteFiles {
	if mmDeleteFiles.mock.inspectFuncDeleteFiles != nil {
		mmDeleteFiles.mock.t.Fatalf("Inspect function is already set for ServiceMock.DeleteFiles")
	}

	mmDeleteFiles.mock.inspectFuncDeleteFiles = f

	return mmDeleteFiles
}

// Return sets up results that will be returned by Service.DeleteFiles
func (mmDeleteFiles *mServiceMockDeleteFiles) Return(err error) *ServiceMock {
	if mmDeleteFiles.mock.funcDeleteFiles != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by Set")
	}

	if mmDeleteFiles.defaultExpectation == nil {
		mmDeleteFiles.defaultExpectation = &ServiceMockDeleteFilesExpectation{mock: mmDeleteFiles.mock}
	}
	mmDeleteFiles.defaultExpectation.results = &ServiceMockDeleteFilesResults{err}
	mmDeleteFiles.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteFiles.mock
}

// Set uses given function f to mock the Service.DeleteFiles method
func (mmDeleteFiles *mServiceMockDeleteFiles) Set(f func(ctx context.Context, s1 string, sa1 []string) (err error)) *ServiceMock {
	if mmDeleteFiles.defaultExpectation != nil {
		mmDeleteFiles.mock.t.Fatalf("Default expectation is already set for the Service.DeleteFiles method")
	}

	if len(mmDeleteFiles.expectations) > 0 {
		mmDeleteFiles.mock.t.Fatalf("Some expectations are already set for the Service.DeleteFiles method")
	}

	mmDeleteFiles.mock.funcDeleteFiles = f
	mmDeleteFiles.mock.funcDeleteFilesOrigin = minimock.CallerInfo(1)
	return mmDeleteFiles.mock
}

// When sets expectation for the Service.DeleteFiles which will trigger the result defined by the following
// Then helper
func (mmDeleteFiles *mServiceMockDeleteFiles) When(ctx context.Context, s1 string, sa1 []string) *ServiceMockDeleteFilesExpectation {
	if mmDeleteFiles.mock.funcDeleteFiles != nil {
		mmDeleteFiles.mock.t.Fatalf("ServiceMock.DeleteFiles mock is already set by Set")
	}

	expectation := &ServiceMockDeleteFilesExpectation{
		mock:               mmDeleteFiles.mock,
		params:             &ServiceMockDeleteFilesParams{ctx, s1, sa1},
		expectationOrigins: ServiceMockDeleteFilesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteFiles.expectations = append(mmDeleteFiles.expectations, expectation)
	return expectation
}

// Then sets up Service.DeleteFiles return parameters for the expectation previously defined by the When method
func (e *ServiceMockDeleteFilesExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockDeleteFilesResults{err}
	return e.mock
}

// Times sets number of times Service.DeleteFiles should be invoked
func (mmDeleteFiles *mServiceMockDeleteFiles) Times(n uint64) *mServiceMockDeleteFiles {
	if n == 0 {
		mmDeleteFiles.mock.t.Fatalf("Times of ServiceMock.DeleteFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteFiles.expectedInvocations, n)
	mmDeleteFiles.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteFiles
}

func (mmDeleteFiles *mServiceMockDeleteFiles) invocationsDone() bool {
	if len(mmDeleteFiles.expectations) == 0 && mmDeleteFiles.defaultExpectation == nil && mmDeleteFiles.mock.funcDeleteFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteFiles.mock.afterDeleteFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteFiles implements mm_service.Service
func (mmDeleteFiles *ServiceMock) DeleteFiles(ctx context.Context, s1 string, sa1 []string) (err error) {
	mm_atomic.AddUint64(&mmDeleteFiles.beforeDeleteFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteFiles.afterDeleteFilesCounter, 1)

	mmDeleteFiles.t.Helper()

	if mmDeleteFiles.inspectFuncDeleteFiles != nil {
		mmDeleteFiles.inspectFuncDeleteFiles(ctx, s1, sa1)
	}

	mm_params := ServiceMockDeleteFilesParams{ctx, s1, sa1}

	// Record call args
	mmDeleteFiles.DeleteFilesMock.mutex.Lock()
	mmDeleteFiles.DeleteFilesMock.callArgs = append(mmDeleteFiles.DeleteFilesMock.callArgs, &mm_params)
	mmDeleteFiles.DeleteFilesMock.mutex.Unlock()

	for _, e := range mmDeleteFiles.DeleteFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteFiles.DeleteFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteFiles.DeleteFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteFiles.DeleteFilesMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteFiles.DeleteFilesMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockDeleteFilesParams{ctx, s1, sa1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteFiles.t.Errorf("ServiceMock.DeleteFiles got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFiles.DeleteFilesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmDeleteFiles.t.Errorf("ServiceMock.DeleteFiles got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFiles.DeleteFilesMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

			if mm_want_ptrs.sa1 != nil && !minimock.Equal(*mm_want_ptrs.sa1, mm_got.sa1) {
				mmDeleteFiles.t.Errorf("ServiceMock.DeleteFiles got unexpected parameter sa1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFiles.DeleteFilesMock.defaultExpectation.expectationOrigins.originSa1, *mm_want_ptrs.sa1, mm_got.sa1, minimock.Diff(*mm_want_ptrs.sa1, mm_got.sa1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteFiles.t.Errorf("ServiceMock.DeleteFiles got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteFiles.DeleteFilesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteFiles.DeleteFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteFiles.t.Fatal("No results are set for the ServiceMock.DeleteFiles")
		}
		return (*mm_results).err
	}
	if mmDeleteFiles.funcDeleteFiles != nil {
		return mmDeleteFiles.funcDeleteFiles(ctx, s1, sa1)
	}
	mmDeleteFiles.t.Fatalf("Unexpected call to ServiceMock.DeleteFiles. %v %v %v", ctx, s1, sa1)
	return
}

// DeleteFilesAfterCounter returns a count of finished ServiceMock.DeleteFiles invocations
func (mmDeleteFiles *ServiceMock) DeleteFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFiles.afterDeleteFilesCounter)
}

// DeleteFilesBeforeCounter returns a count of ServiceMock.DeleteFiles invocations
func (mmDeleteFiles *ServiceMock) DeleteFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFiles.beforeDeleteFilesCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.DeleteFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteFiles *mServiceMockDeleteFiles) Calls() []*ServiceMockDeleteFilesParams {
	mmDeleteFiles.mutex.RLock()

	argCopy := make([]*ServiceMockDeleteFilesParams, len(mmDeleteFiles.callArgs))
	copy(argCopy, mmDeleteFiles.callArgs)

	mmDeleteFiles.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteFilesDone returns true if the count of the DeleteFiles invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockDeleteFilesDone() bool {
	if m.DeleteFilesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteFilesMock.invocationsDone()
}

// MinimockDeleteFilesInspect logs each unmet expectation
func (m *ServiceMock) MinimockDeleteFilesInspect() {
	for _, e := range m.DeleteFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.DeleteFiles at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteFilesCounter := mm_atomic.LoadUint64(&m.afterDeleteFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFilesMock.defaultExpectation != nil && afterDeleteFilesCounter < 1 {
		if m.DeleteFilesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.DeleteFiles at\n%s", m.DeleteFilesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.DeleteFiles at\n%s with params: %#v", m.DeleteFilesMock.defaultExpectation.expectationOrigins.origin, *m.DeleteFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFiles != nil && afterDeleteFilesCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.DeleteFiles at\n%s", m.funcDeleteFilesOrigin)
	}

	if !m.DeleteFilesMock.invocationsDone() && afterDeleteFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.DeleteFiles at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteFilesMock.expectedInvocations), m.DeleteFilesMock.expectedInvocationsOrigin, afterDeleteFilesCounter)
	}
}

type mServiceMockDeleteRepositoryTag struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockDeleteRepositoryTagExpectation
	expectations       []*ServiceMockDeleteRepositoryTagExpectation

	callArgs []*ServiceMockDeleteRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockDeleteRepositoryTagExpectation specifies expectation struct of the Service.DeleteRepositoryTag
type ServiceMockDeleteRepositoryTagExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockDeleteRepositoryTagParams
	paramPtrs          *ServiceMockDeleteRepositoryTagParamPtrs
	expectationOrigins ServiceMockDeleteRepositoryTagExpectationOrigins
	results            *ServiceMockDeleteRepositoryTagResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockDeleteRepositoryTagParams contains parameters of the Service.DeleteRepositoryTag
type ServiceMockDeleteRepositoryTagParams struct {
	ctx context.Context
	dp1 *artifactpb.DeleteRepositoryTagRequest
}

// ServiceMockDeleteRepositoryTagParamPtrs contains pointers to parameters of the Service.DeleteRepositoryTag
type ServiceMockDeleteRepositoryTagParamPtrs struct {
	ctx *context.Context
	dp1 **artifactpb.DeleteRepositoryTagRequest
}

// ServiceMockDeleteRepositoryTagResults contains results of the Service.DeleteRepositoryTag
type ServiceMockDeleteRepositoryTagResults struct {
	dp2 *artifactpb.DeleteRepositoryTagResponse
	err error
}

// ServiceMockDeleteRepositoryTagOrigins contains origins of expectations of the Service.DeleteRepositoryTag
type ServiceMockDeleteRepositoryTagExpectationOrigins struct {
	origin    string
	originCtx string
	originDp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) Optional() *mServiceMockDeleteRepositoryTag {
	mmDeleteRepositoryTag.optional = true
	return mmDeleteRepositoryTag
}

// Expect sets up expected params for Service.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) Expect(ctx context.Context, dp1 *artifactpb.DeleteRepositoryTagRequest) *mServiceMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("ServiceMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &ServiceMockDeleteRepositoryTagExpectation{}
	}

	if mmDeleteRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("ServiceMock.DeleteRepositoryTag mock is already set by ExpectParams functions")
	}

	mmDeleteRepositoryTag.defaultExpectation.params = &ServiceMockDeleteRepositoryTagParams{ctx, dp1}
	mmDeleteRepositoryTag.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteRepositoryTag.expectations {
		if minimock.Equal(e.params, mmDeleteRepositoryTag.defaultExpectation.params) {
			mmDeleteRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteRepositoryTag.defaultExpectation.params)
		}
	}

	return mmDeleteRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for Service.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) ExpectCtxParam1(ctx context.Context) *mServiceMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("ServiceMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &ServiceMockDeleteRepositoryTagExpectation{}
	}

	if mmDeleteRepositoryTag.defaultExpectation.params != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("ServiceMock.DeleteRepositoryTag mock is already set by Expect")
	}

	if mmDeleteRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmDeleteRepositoryTag.defaultExpectation.paramPtrs = &ServiceMockDeleteRepositoryTagParamPtrs{}
	}
	mmDeleteRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteRepositoryTag.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteRepositoryTag
}

// ExpectDp1Param2 sets up expected param dp1 for Service.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) ExpectDp1Param2(dp1 *artifactpb.DeleteRepositoryTagRequest) *mServiceMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("ServiceMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &ServiceMockDeleteRepositoryTagExpectation{}
	}

	if mmDeleteRepositoryTag.defaultExpectation.params != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("ServiceMock.DeleteRepositoryTag mock is already set by Expect")
	}

	if mmDeleteRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmDeleteRepositoryTag.defaultExpectation.paramPtrs = &ServiceMockDeleteRepositoryTagParamPtrs{}
	}
	mmDeleteRepositoryTag.defaultExpectation.paramPtrs.dp1 = &dp1
	mmDeleteRepositoryTag.defaultExpectation.expectationOrigins.originDp1 = minimock.CallerInfo(1)

	return mmDeleteRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the Service.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) Inspect(f func(ctx context.Context, dp1 *artifactpb.DeleteRepositoryTagRequest)) *mServiceMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.inspectFuncDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("Inspect function is already set for ServiceMock.DeleteRepositoryTag")
	}

	mmDeleteRepositoryTag.mock.inspectFuncDeleteRepositoryTag = f

	return mmDeleteRepositoryTag
}

// Return sets up results that will be returned by Service.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) Return(dp2 *artifactpb.DeleteRepositoryTagResponse, err error) *ServiceMock {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("ServiceMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &ServiceMockDeleteRepositoryTagExpectation{mock: mmDeleteRepositoryTag.mock}
	}
	mmDeleteRepositoryTag.defaultExpectation.results = &ServiceMockDeleteRepositoryTagResults{dp2, err}
	mmDeleteRepositoryTag.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteRepositoryTag.mock
}

// Set uses given function f to mock the Service.DeleteRepositoryTag method
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) Set(f func(ctx context.Context, dp1 *artifactpb.DeleteRepositoryTagRequest) (dp2 *artifactpb.DeleteRepositoryTagResponse, err error)) *ServiceMock {
	if mmDeleteRepositoryTag.defaultExpectation != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("Default expectation is already set for the Service.DeleteRepositoryTag method")
	}

	if len(mmDeleteRepositoryTag.expectations) > 0 {
		mmDeleteRepositoryTag.mock.t.Fatalf("Some expectations are already set for the Service.DeleteRepositoryTag method")
	}

	mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag = f
	mmDeleteRepositoryTag.mock.funcDeleteRepositoryTagOrigin = minimock.CallerInfo(1)
	return mmDeleteRepositoryTag.mock
}

// When sets expectation for the Service.DeleteRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) When(ctx context.Context, dp1 *artifactpb.DeleteRepositoryTagRequest) *ServiceMockDeleteRepositoryTagExpectation {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("ServiceMock.DeleteRepositoryTag mock is already set by Set")
	}

	expectation := &ServiceMockDeleteRepositoryTagExpectation{
		mock:               mmDeleteRepositoryTag.mock,
		params:             &ServiceMockDeleteRepositoryTagParams{ctx, dp1},
		expectationOrigins: ServiceMockDeleteRepositoryTagExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteRepositoryTag.expectations = append(mmDeleteRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up Service.DeleteRepositoryTag return parameters for the expectation previously defined by the When method
func (e *ServiceMockDeleteRepositoryTagExpectation) Then(dp2 *artifactpb.DeleteRepositoryTagResponse, err error) *ServiceMock {
	e.results = &ServiceMockDeleteRepositoryTagResults{dp2, err}
	return e.mock
}

// Times sets number of times Service.DeleteRepositoryTag should be invoked
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) Times(n uint64) *mServiceMockDeleteRepositoryTag {
	if n == 0 {
		mmDeleteRepositoryTag.mock.t.Fatalf("Times of ServiceMock.DeleteRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteRepositoryTag.expectedInvocations, n)
	mmDeleteRepositoryTag.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteRepositoryTag
}

func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) invocationsDone() bool {
	if len(mmDeleteRepositoryTag.expectations) == 0 && mmDeleteRepositoryTag.defaultExpectation == nil && mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteRepositoryTag.mock.afterDeleteRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteRepositoryTag implements mm_service.Service
func (mmDeleteRepositoryTag *ServiceMock) DeleteRepositoryTag(ctx context.Context, dp1 *artifactpb.DeleteRepositoryTagRequest) (dp2 *artifactpb.DeleteRepositoryTagResponse, err error) {
	mm_atomic.AddUint64(&mmDeleteRepositoryTag.beforeDeleteRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteRepositoryTag.afterDeleteRepositoryTagCounter, 1)

	mmDeleteRepositoryTag.t.Helper()

	if mmDeleteRepositoryTag.inspectFuncDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.inspectFuncDeleteRepositoryTag(ctx, dp1)
	}

	mm_params := ServiceMockDeleteRepositoryTagParams{ctx, dp1}

	// Record call args
	mmDeleteRepositoryTag.DeleteRepositoryTagMock.mutex.Lock()
	mmDeleteRepositoryTag.DeleteRepositoryTagMock.callArgs = append(mmDeleteRepositoryTag.DeleteRepositoryTagMock.callArgs, &mm_params)
	mmDeleteRepositoryTag.DeleteRepositoryTagMock.mutex.Unlock()

	for _, e := range mmDeleteRepositoryTag.DeleteRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp2, e.results.err
		}
	}

	if mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockDeleteRepositoryTagParams{ctx, dp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteRepositoryTag.t.Errorf("ServiceMock.DeleteRepositoryTag got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dp1 != nil && !minimock.Equal(*mm_want_ptrs.dp1, mm_got.dp1) {
				mmDeleteRepositoryTag.t.Errorf("ServiceMock.DeleteRepositoryTag got unexpected parameter dp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.expectationOrigins.originDp1, *mm_want_ptrs.dp1, mm_got.dp1, minimock.Diff(*mm_want_ptrs.dp1, mm_got.dp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteRepositoryTag.t.Errorf("ServiceMock.DeleteRepositoryTag got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteRepositoryTag.t.Fatal("No results are set for the ServiceMock.DeleteRepositoryTag")
		}
		return (*mm_results).dp2, (*mm_results).err
	}
	if mmDeleteRepositoryTag.funcDeleteRepositoryTag != nil {
		return mmDeleteRepositoryTag.funcDeleteRepositoryTag(ctx, dp1)
	}
	mmDeleteRepositoryTag.t.Fatalf("Unexpected call to ServiceMock.DeleteRepositoryTag. %v %v", ctx, dp1)
	return
}

// DeleteRepositoryTagAfterCounter returns a count of finished ServiceMock.DeleteRepositoryTag invocations
func (mmDeleteRepositoryTag *ServiceMock) DeleteRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRepositoryTag.afterDeleteRepositoryTagCounter)
}

// DeleteRepositoryTagBeforeCounter returns a count of ServiceMock.DeleteRepositoryTag invocations
func (mmDeleteRepositoryTag *ServiceMock) DeleteRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRepositoryTag.beforeDeleteRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.DeleteRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteRepositoryTag *mServiceMockDeleteRepositoryTag) Calls() []*ServiceMockDeleteRepositoryTagParams {
	mmDeleteRepositoryTag.mutex.RLock()

	argCopy := make([]*ServiceMockDeleteRepositoryTagParams, len(mmDeleteRepositoryTag.callArgs))
	copy(argCopy, mmDeleteRepositoryTag.callArgs)

	mmDeleteRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteRepositoryTagDone returns true if the count of the DeleteRepositoryTag invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockDeleteRepositoryTagDone() bool {
	if m.DeleteRepositoryTagMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteRepositoryTagMock.invocationsDone()
}

// MinimockDeleteRepositoryTagInspect logs each unmet expectation
func (m *ServiceMock) MinimockDeleteRepositoryTagInspect() {
	for _, e := range m.DeleteRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.DeleteRepositoryTag at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterDeleteRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteRepositoryTagMock.defaultExpectation != nil && afterDeleteRepositoryTagCounter < 1 {
		if m.DeleteRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.DeleteRepositoryTag at\n%s", m.DeleteRepositoryTagMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.DeleteRepositoryTag at\n%s with params: %#v", m.DeleteRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *m.DeleteRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteRepositoryTag != nil && afterDeleteRepositoryTagCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.DeleteRepositoryTag at\n%s", m.funcDeleteRepositoryTagOrigin)
	}

	if !m.DeleteRepositoryTagMock.invocationsDone() && afterDeleteRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.DeleteRepositoryTag at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteRepositoryTagMock.expectedInvocations), m.DeleteRepositoryTagMock.expectedInvocationsOrigin, afterDeleteRepositoryTagCounter)
	}
}

type mServiceMockDeleteSystemAdmin struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockDeleteSystemAdminExpectation
	expectations       []*ServiceMockDeleteSystemAdminExpectation

	callArgs []*ServiceMockDeleteSystemAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockDeleteSystemAdminExpectation specifies expectation struct of the Service.DeleteSystemAdmin
type ServiceMockDeleteSystemAdminExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockDeleteSystemAdminParams
	paramPtrs          *ServiceMockDeleteSystemAdminParamPtrs
	expectationOrigins ServiceMockDeleteSystemAdminExpectationOrigins
	results            *ServiceMockDeleteSystemAdminResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockDeleteSystemAdminParams contains parameters of the Service.DeleteSystemAdmin
type ServiceMockDeleteSystemAdminParams struct {
	ctx context.Context
	s1  string
}

// ServiceMockDeleteSystemAdminParamPtrs contains pointers to parameters of the Service.DeleteSystemAdmin
type ServiceMockDeleteSystemAdminParamPtrs struct {
	ctx *context.Context
	s1  *string
}

// ServiceMockDeleteSystemAdminResults contains results of the Service.DeleteSystemAdmin
type ServiceMockDeleteSystemAdminResults struct {
	dp1 *artifactpb.DeleteSystemAdminResponse
	err error
}

// ServiceMockDeleteSystemAdminOrigins contains origins of expectations of the Service.DeleteSystemAdmin
type ServiceMockDeleteSystemAdminExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteSystemAdmin *mServiceMockDeleteSystemAdmin) Optional() *mServiceMockDeleteSystemAdmin {
	mmDeleteSystemAdmin.optional = true
	return mmDeleteSystemAdmin
}

// Expect sets up expected params for Service.DeleteSystemAdmin
func (mmDeleteSystemAdmin *mServiceMockDeleteSystemAdmin) Expect(ctx context.Context, s1 string) *mServiceMockDeleteSystemAdmin {
	if mmDeleteSystemAdmin.mock.funcDeleteSystemAdmin != nil {
		mmDeleteSystemAdmin.mock.t.Fatalf("ServiceMock.DeleteSystemAdmin mock is already set by Set")
	}

	if mmDeleteSystemAdmin.defaultExpectation == nil {
		mmDeleteSystemAdmin.defaultExpectation = &ServiceMockDeleteSystemAdminExpectation{}
	}

	if mmDeleteSystemAdmin.defaultExpectation.paramPtrs != nil {
		mmDeleteSystemAdmin.mock.t.Fatalf("ServiceMock.DeleteSystemAdmin mock is already set by ExpectParams functions")
	}

	mmDeleteSystemAdmin.defaultExpectation.params = &ServiceMockDeleteSystemAdminParams{ctx, s1}
	mmDeleteSystemAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteSystemAdmin.expectations {
		if minimock.Equal(e.params, mmDeleteSystemAdmin.defaultExpectation.params) {
			mmDeleteSystemAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteSystemAdmin.defaultExpectation.params)
		}
	}

	return mmDeleteSystemAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Service.DeleteSystemAdmin
func (mmDeleteSystemAdmin *mServiceMockDeleteSystemAdmin) ExpectCtxParam1(ctx context.Context) *mServiceMockDeleteSystemAdmin {
	if mmDeleteSystemAdmin.mock.funcDeleteSystemAdmin != nil {
		mmDeleteSystemAdmin.mock.t.Fatalf("ServiceMock.DeleteSystemAdmin mock is already set by Set")
	}

	if mmDeleteSystemAdmin.defaultExpectation == nil {
		mmDeleteSystemAdmin.defaultExpectation = &ServiceMockDeleteSystemAdminExpectation{}
	}

	if mmDeleteSystemAdmin.defaultExpectation.params != nil {
		mmDeleteSystemAdmin.mock.t.Fatalf("ServiceMock.DeleteSystemAdmin mock is already set by Expect")
	}

	if mmDeleteSystemAdmin.defaultExpectation.paramPtrs == nil {
		mmDeleteSystemAdmin.defaultExpectation.paramPtrs = &ServiceMockDeleteSystemAdminParamPtrs{}
	}
	mmDeleteSystemAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteSystemAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteSystemAdmin
}

// ExpectS1Param2 sets up expected param s1 for Service.DeleteSystemAdmin
func (mmDeleteSystemAdmin *mServiceMockDeleteSystemAdmin) ExpectS1Param2(s1 string) *mServiceMockDeleteSystemAdmin {
	if mmDeleteSystemAdmin.mock.funcDeleteSystemAdmin != nil {
		mmDeleteSystemAdmin.mock.t.Fatalf("ServiceMock.DeleteSystemAdmin mock is already set by Set")
	}

	if mmDeleteSystemAdmin.defaultExpectation == nil {
		mmDeleteSystemAdmin.defaultExpectation = &ServiceMockDeleteSystemAdminExpectation{}
	}

	if mmDeleteSystemAdmin.defaultExpectation.params != nil {
		mmDeleteSystemAdmin.mock.t.Fatalf("ServiceMock.DeleteSystemAdmin mock is already set by Expect")
	}

	if mmDeleteSystemAdmin.defaultExpectation.paramPtrs == nil {
		mmDeleteSystemAdmin.defaultExpectation.paramPtrs = &ServiceMockDeleteSystemAdminParamPtrs{}
	}
	mmDeleteSystemAdmin.defaultExpectation.paramPtrs.s1 = &s1
	mmDeleteSystemAdmin.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmDeleteSystemAdmin
}

// Inspect accepts an inspector function that has same arguments as the Service.DeleteSystemAdmin
func (mmDeleteSystemAdmin *mServiceMockDeleteSystemAdmin) Inspect(f func(ctx context.Context, s1 string)) *mServiceMockDeleteSystemAdmin {
	if mmDeleteSystemAdmin.mock.inspectFuncDeleteSystemAdmin != nil {
		mmDeleteSystemAdmin.mock.t.Fatalf("Inspect function is already set for ServiceMock.DeleteSystemAdmin")
	}

	mmDeleteSystemAdmin.mock.inspectFuncDeleteSystemAdmin = f

	return mmDeleteSystemAdmin
}

// Return sets up results that will be returned by Service.DeleteSystemAdmin
func (mmDeleteSystemAdmin *mServiceMockDeleteSystemAdmin) Return(dp1 *artifactpb.DeleteSystemAdminResponse, err error) *ServiceMock {
	if mmDeleteSystemAdmin.mock.funcDeleteSystemAdmin != nil {
		mmDeleteSystemAdmin.mock.t.Fatalf("ServiceMock.DeleteSystemAdmin mock is already set by Set")
	}

	if mmDeleteSystemAdmin.defaultExpectation == nil {
		mmDeleteSystemAdmin.defaultExpectation = &ServiceMockDeleteSystemAdminExpectation{mock: mmDeleteSystemAdmin.mock}
	}
	mmDeleteSystemAdmin.defaultExpectation.results = &ServiceMockDeleteSystemAdminResults{dp1, err}
	mmDeleteSystemAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteSystemAdmin.mock
}

// Set uses given function f to mock the Service.DeleteSystemAdmin method
func (mmDeleteSystemAdmin *mServiceMockDeleteSystemAdmin) Set(f func(ctx context.Context, s1 string) (dp1 *artifactpb.DeleteSystemAdminResponse, err error)) *ServiceMock {
	if mmDeleteSystemAdmin.defaultExpectation != nil {
		mmDeleteSystemAdmin.mock.t.Fatalf("Default expectation is already set for the Service.DeleteSystemAdmin method")
	}

	if len(mmDeleteSystemAdmin.expectations) > 0 {
		mmDeleteSystemAdmin.mock.t.Fatalf("Some expectations are already set for the Service.DeleteSystemAdmin method")
	}

	mmDeleteSystemAdmin.mock.funcDeleteSystemAdmin = f
	mmDeleteSystemAdmin.mock.funcDeleteSystemAdminOrigin = minimock.CallerInfo(1)
	return mmDeleteSystemAdmin.mock
}

// When sets expectation for the Service.DeleteSystemAdmin which will trigger the result defined by the following
// Then helper
func (mmDeleteSystemAdmin *mServiceMockDeleteSystemAdmin) When(ctx context.Context, s1 string) *ServiceMockDeleteSystemAdminExpectation {
	if mmDeleteSystemAdmin.mock.funcDeleteSystemAdmin != nil {
		mmDeleteSystemAdmin.mock.t.Fatalf("ServiceMock.DeleteSystemAdmin mock is already set by Set")
	}

	expectation := &ServiceMockDeleteSystemAdminExpectation{
		mock:               mmDeleteSystemAdmin.mock,
		params:             &ServiceMockDeleteSystemAdminParams{ctx, s1},
		expectationOrigins: ServiceMockDeleteSystemAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteSystemAdmin.expectations = append(mmDeleteSystemAdmin.expectations, expectation)
	return expectation
}

// Then sets up Service.DeleteSystemAdmin return parameters for the expectation previously defined by the When method
func (e *ServiceMockDeleteSystemAdminExpectation) Then(dp1 *artifactpb.DeleteSystemAdminResponse, err error) *ServiceMock {
	e.results = &ServiceMockDeleteSystemAdminResults{dp1, err}
	return e.mock
}

// Times sets number of times Service.DeleteSystemAdmin should be invoked
func (mmDeleteSystemAdmin *mServiceMockDeleteSystemAdmin) Times(n uint64) *mServiceMockDeleteSystemAdmin {
	if n == 0 {
		mmDeleteSystemAdmin.mock.t.Fatalf("Times of ServiceMock.DeleteSystemAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteSystemAdmin.expectedInvocations, n)
	mmDeleteSystemAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteSystemAdmin
}

func (mmDeleteSystemAdmin *mServiceMockDeleteSystemAdmin) invocationsDone() bool {
	if len(mmDeleteSystemAdmin.expectations) == 0 && mmDeleteSystemAdmin.defaultExpectation == nil && mmDeleteSystemAdmin.mock.funcDeleteSystemAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteSystemAdmin.mock.afterDeleteSystemAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteSystemAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteSystemAdmin implements mm_service.Service
func (mmDeleteSystemAdmin *ServiceMock) DeleteSystemAdmin(ctx context.Context, s1 string) (dp1 *artifactpb.DeleteSystemAdminResponse, err error) {
	mm_atomic.AddUint64(&mmDeleteSystemAdmin.beforeDeleteSystemAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteSystemAdmin.afterDeleteSystemAdminCounter, 1)

	mmDeleteSystemAdmin.t.Helper()

	if mmDeleteSystemAdmin.inspectFuncDeleteSystemAdmin != nil {
		mmDeleteSystemAdmin.inspectFuncDeleteSystemAdmin(ctx, s1)
	}

	mm_params := ServiceMockDeleteSystemAdminParams{ctx, s1}

	// Record call args
	mmDeleteSystemAdmin.DeleteSystemAdminMock.mutex.Lock()
	mmDeleteSystemAdmin.DeleteSystemAdminMock.callArgs = append(mmDeleteSystemAdmin.DeleteSystemAdminMock.callArgs, &mm_params)
	mmDeleteSystemAdmin.DeleteSystemAdminMock.mutex.Unlock()

	for _, e := range mmDeleteSystemAdmin.DeleteSystemAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp1, e.results.err
		}
	}

	if mmDeleteSystemAdmin.DeleteSystemAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteSystemAdmin.DeleteSystemAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteSystemAdmin.DeleteSystemAdminMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteSystemAdmin.DeleteSystemAdminMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockDeleteSystemAdminParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteSystemAdmin.t.Errorf("ServiceMock.DeleteSystemAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSystemAdmin.DeleteSystemAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmDeleteSystemAdmin.t.Errorf("ServiceMock.DeleteSystemAdmin got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSystemAdmin.DeleteSystemAdminMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteSystemAdmin.t.Errorf("ServiceMock.DeleteSystemAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteSystemAdmin.DeleteSystemAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteSystemAdmin.DeleteSystemAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteSystemAdmin.t.Fatal("No results are set for the ServiceMock.DeleteSystemAdmin")
		}
		return (*mm_results).dp1, (*mm_results).err
	}
	if mmDeleteSystemAdmin.funcDeleteSystemAdmin != nil {
		return mmDeleteSystemAdmin.funcDeleteSystemAdmin(ctx, s1)
	}
	mmDeleteSystemAdmin.t.Fatalf("Unexpected call to ServiceMock.DeleteSystemAdmin. %v %v", ctx, s1)
	return
}

// DeleteSystemAdminAfterCounter returns a count of finished ServiceMock.DeleteSystemAdmin invocations
func (mmDeleteSystemAdmin *ServiceMock) DeleteSystemAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSystemAdmin.afterDeleteSystemAdminCounter)
}

// DeleteSystemAdminBeforeCounter returns a count of ServiceMock.DeleteSystemAdmin invocations
func (mmDeleteSystemAdmin *ServiceMock) DeleteSystemAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSystemAdmin.beforeDeleteSystemAdminCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.DeleteSystemAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteSystemAdmin *mServiceMockDeleteSystemAdmin) Calls() []*ServiceMockDeleteSystemAdminParams {
	mmDeleteSystemAdmin.mutex.RLock()

	argCopy := make([]*ServiceMockDeleteSystemAdminParams, len(mmDeleteSystemAdmin.callArgs))
	copy(argCopy, mmDeleteSystemAdmin.callArgs)

	mmDeleteSystemAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteSystemAdminDone returns true if the count of the DeleteSystemAdmin invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockDeleteSystemAdminDone() bool {
	if m.DeleteSystemAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteSystemAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteSystemAdminMock.invocationsDone()
}

// MinimockDeleteSystemAdminInspect logs each unmet expectation
func (m *ServiceMock) MinimockDeleteSystemAdminInspect() {
	for _, e := range m.DeleteSystemAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.DeleteSystemAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteSystemAdminCounter := mm_atomic.LoadUint64(&m.afterDeleteSystemAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSystemAdminMock.defaultExpectation != nil && afterDeleteSystemAdminCounter < 1 {
		if m.DeleteSystemAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.DeleteSystemAdmin at\n%s", m.DeleteSystemAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.DeleteSystemAdmin at\n%s with params: %#v", m.DeleteSystemAdminMock.defaultExpectation.expectationOrigins.origin, *m.DeleteSystemAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSystemAdmin != nil && afterDeleteSystemAdminCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.DeleteSystemAdmin at\n%s", m.funcDeleteSystemAdminOrigin)
	}

	if !m.DeleteSystemAdminMock.invocationsDone() && afterDeleteSystemAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.DeleteSystemAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteSystemAdminMock.expectedInvocations), m.DeleteSystemAdminMock.expectedInvocationsOrigin, afterDeleteSystemAdminCounter)
	}
}

type mServiceMockEmbedTexts struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockEmbedTextsExpectation
	expectations       []*ServiceMockEmbedTextsExpectation

	callArgs []*ServiceMockEmbedTextsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockEmbedTextsExpectation specifies expectation struct of the Service.EmbedTexts
type ServiceMockEmbedTextsExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockEmbedTextsParams
	paramPtrs          *ServiceMockEmbedTextsParamPtrs
	expectationOrigins ServiceMockEmbedTextsExpectationOrigins
	results            *ServiceMockEmbedTextsResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockEmbedTextsParams contains parameters of the Service.EmbedTexts
type ServiceMockEmbedTextsParams struct {
	ctx context.Context
	kp1 *types.KBUIDType
	sa1 []string
	s1  string
}

// ServiceMockEmbedTextsParamPtrs contains pointers to parameters of the Service.EmbedTexts
type ServiceMockEmbedTextsParamPtrs struct {
	ctx *context.Context
	kp1 **types.KBUIDType
	sa1 *[]string
	s1  *string
}

// ServiceMockEmbedTextsResults contains results of the Service.EmbedTexts
type ServiceMockEmbedTextsResults struct {
	faa1 [][]float32
	err  error
}

// ServiceMockEmbedTextsOrigins contains origins of expectations of the Service.EmbedTexts
type ServiceMockEmbedTextsExpectationOrigins struct {
	origin    string
	originCtx string
	originKp1 string
	originSa1 string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmEmbedTexts *mServiceMockEmbedTexts) Optional() *mServiceMockEmbedTexts {
	mmEmbedTexts.optional = true
	return mmEmbedTexts
}

// Expect sets up expected params for Service.EmbedTexts
func (mmEmbedTexts *mServiceMockEmbedTexts) Expect(ctx context.Context, kp1 *types.KBUIDType, sa1 []string, s1 string) *mServiceMockEmbedTexts {
	if mmEmbedTexts.mock.funcEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("ServiceMock.EmbedTexts mock is already set by Set")
	}

	if mmEmbedTexts.defaultExpectation == nil {
		mmEmbedTexts.defaultExpectation = &ServiceMockEmbedTextsExpectation{}
	}

	if mmEmbedTexts.defaultExpectation.paramPtrs != nil {
		mmEmbedTexts.mock.t.Fatalf("ServiceMock.EmbedTexts mock is already set by ExpectParams functions")
	}

	mmEmbedTexts.defaultExpectation.params = &ServiceMockEmbedTextsParams{ctx, kp1, sa1, s1}
	mmEmbedTexts.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmEmbedTexts.expectations {
		if minimock.Equal(e.params, mmEmbedTexts.defaultExpectation.params) {
			mmEmbedTexts.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEmbedTexts.defaultExpectation.params)
		}
	}

	return mmEmbedTexts
}

// ExpectCtxParam1 sets up expected param ctx for Service.EmbedTexts
func (mmEmbedTexts *mServiceMockEmbedTexts) ExpectCtxParam1(ctx context.Context) *mServiceMockEmbedTexts {
	if mmEmbedTexts.mock.funcEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("ServiceMock.EmbedTexts mock is already set by Set")
	}

	if mmEmbedTexts.defaultExpectation == nil {
		mmEmbedTexts.defaultExpectation = &ServiceMockEmbedTextsExpectation{}
	}

	if mmEmbedTexts.defaultExpectation.params != nil {
		mmEmbedTexts.mock.t.Fatalf("ServiceMock.EmbedTexts mock is already set by Expect")
	}

	if mmEmbedTexts.defaultExpectation.paramPtrs == nil {
		mmEmbedTexts.defaultExpectation.paramPtrs = &ServiceMockEmbedTextsParamPtrs{}
	}
	mmEmbedTexts.defaultExpectation.paramPtrs.ctx = &ctx
	mmEmbedTexts.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmEmbedTexts
}

// ExpectKp1Param2 sets up expected param kp1 for Service.EmbedTexts
func (mmEmbedTexts *mServiceMockEmbedTexts) ExpectKp1Param2(kp1 *types.KBUIDType) *mServiceMockEmbedTexts {
	if mmEmbedTexts.mock.funcEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("ServiceMock.EmbedTexts mock is already set by Set")
	}

	if mmEmbedTexts.defaultExpectation == nil {
		mmEmbedTexts.defaultExpectation = &ServiceMockEmbedTextsExpectation{}
	}

	if mmEmbedTexts.defaultExpectation.params != nil {
		mmEmbedTexts.mock.t.Fatalf("ServiceMock.EmbedTexts mock is already set by Expect")
	}

	if mmEmbedTexts.defaultExpectation.paramPtrs == nil {
		mmEmbedTexts.defaultExpectation.paramPtrs = &ServiceMockEmbedTextsParamPtrs{}
	}
	mmEmbedTexts.defaultExpectation.paramPtrs.kp1 = &kp1
	mmEmbedTexts.defaultExpectation.expectationOrigins.originKp1 = minimock.CallerInfo(1)

	return mmEmbedTexts
}

// ExpectSa1Param3 sets up expected param sa1 for Service.EmbedTexts
func (mmEmbedTexts *mServiceMockEmbedTexts) ExpectSa1Param3(sa1 []string) *mServiceMockEmbedTexts {
	if mmEmbedTexts.mock.funcEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("ServiceMock.EmbedTexts mock is already set by Set")
	}

	if mmEmbedTexts.defaultExpectation == nil {
		mmEmbedTexts.defaultExpectation = &ServiceMockEmbedTextsExpectation{}
	}

	if mmEmbedTexts.defaultExpectation.params != nil {
		mmEmbedTexts.mock.t.Fatalf("ServiceMock.EmbedTexts mock is already set by Expect")
	}

	if mmEmbedTexts.defaultExpectation.paramPtrs == nil {
		mmEmbedTexts.defaultExpectation.paramPtrs = &ServiceMockEmbedTextsParamPtrs{}
	}
	mmEmbedTexts.defaultExpectation.paramPtrs.sa1 = &sa1
	mmEmbedTexts.defaultExpectation.expectationOrigins.originSa1 = minimock.CallerInfo(1)

	return mmEmbedTexts
}

// ExpectS1Param4 sets up expected param s1 for Service.EmbedTexts
func (mmEmbedTexts *mServiceMockEmbedTexts) ExpectS1Param4(s1 string) *mServiceMockEmbedTexts {
	if mmEmbedTexts.mock.funcEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("ServiceMock.EmbedTexts mock is already set by Set")
	}

	if mmEmbedTexts.defaultExpectation == nil {
		mmEmbedTexts.defaultExpectation = &ServiceMockEmbedTextsExpectation{}
	}

	if mmEmbedTexts.defaultExpectation.params != nil {
		mmEmbedTexts.mock.t.Fatalf("ServiceMock.EmbedTexts mock is already set by Expect")
	}

	if mmEmbedTexts.defaultExpectation.paramPtrs == nil {
		mmEmbedTexts.defaultExpectation.paramPtrs = &ServiceMockEmbedTextsParamPtrs{}
	}
	mmEmbedTexts.defaultExpectation.paramPtrs.s1 = &s1
	mmEmbedTexts.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmEmbedTexts
}

// Inspect accepts an inspector function that has same arguments as the Service.EmbedTexts
func (mmEmbedTexts *mServiceMockEmbedTexts) Inspect(f func(ctx context.Context, kp1 *types.KBUIDType, sa1 []string, s1 string)) *mServiceMockEmbedTexts {
	if mmEmbedTexts.mock.inspectFuncEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("Inspect function is already set for ServiceMock.EmbedTexts")
	}

	mmEmbedTexts.mock.inspectFuncEmbedTexts = f

	return mmEmbedTexts
}

// Return sets up results that will be returned by Service.EmbedTexts
func (mmEmbedTexts *mServiceMockEmbedTexts) Return(faa1 [][]float32, err error) *ServiceMock {
	if mmEmbedTexts.mock.funcEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("ServiceMock.EmbedTexts mock is already set by Set")
	}

	if mmEmbedTexts.defaultExpectation == nil {
		mmEmbedTexts.defaultExpectation = &ServiceMockEmbedTextsExpectation{mock: mmEmbedTexts.mock}
	}
	mmEmbedTexts.defaultExpectation.results = &ServiceMockEmbedTextsResults{faa1, err}
	mmEmbedTexts.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmEmbedTexts.mock
}

// Set uses given function f to mock the Service.EmbedTexts method
func (mmEmbedTexts *mServiceMockEmbedTexts) Set(f func(ctx context.Context, kp1 *types.KBUIDType, sa1 []string, s1 string) (faa1 [][]float32, err error)) *ServiceMock {
	if mmEmbedTexts.defaultExpectation != nil {
		mmEmbedTexts.mock.t.Fatalf("Default expectation is already set for the Service.EmbedTexts method")
	}

	if len(mmEmbedTexts.expectations) > 0 {
		mmEmbedTexts.mock.t.Fatalf("Some expectations are already set for the Service.EmbedTexts method")
	}

	mmEmbedTexts.mock.funcEmbedTexts = f
	mmEmbedTexts.mock.funcEmbedTextsOrigin = minimock.CallerInfo(1)
	return mmEmbedTexts.mock
}

// When sets expectation for the Service.EmbedTexts which will trigger the result defined by the following
// Then helper
func (mmEmbedTexts *mServiceMockEmbedTexts) When(ctx context.Context, kp1 *types.KBUIDType, sa1 []string, s1 string) *ServiceMockEmbedTextsExpectation {
	if mmEmbedTexts.mock.funcEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("ServiceMock.EmbedTexts mock is already set by Set")
	}

	expectation := &ServiceMockEmbedTextsExpectation{
		mock:               mmEmbedTexts.mock,
		params:             &ServiceMockEmbedTextsParams{ctx, kp1, sa1, s1},
		expectationOrigins: ServiceMockEmbedTextsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmEmbedTexts.expectations = append(mmEmbedTexts.expectations, expectation)
	return expectation
}

// Then sets up Service.EmbedTexts return parameters for the expectation previously defined by the When method
func (e *ServiceMockEmbedTextsExpectation) Then(faa1 [][]float32, err error) *ServiceMock {
	e.results = &ServiceMockEmbedTextsResults{faa1, err}
	return e.mock
}

// Times sets number of times Service.EmbedTexts should be invoked
func (mmEmbedTexts *mServiceMockEmbedTexts) Times(n uint64) *mServiceMockEmbedTexts {
	if n == 0 {
		mmEmbedTexts.mock.t.Fatalf("Times of ServiceMock.EmbedTexts mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmEmbedTexts.expectedInvocations, n)
	mmEmbedTexts.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmEmbedTexts
}

func (mmEmbedTexts *mServiceMockEmbedTexts) invocationsDone() bool {
	if len(mmEmbedTexts.expectations) == 0 && mmEmbedTexts.defaultExpectation == nil && mmEmbedTexts.mock.funcEmbedTexts == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmEmbedTexts.mock.afterEmbedTextsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmEmbedTexts.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// EmbedTexts implements mm_service.Service
func (mmEmbedTexts *ServiceMock) EmbedTexts(ctx context.Context, kp1 *types.KBUIDType, sa1 []string, s1 string) (faa1 [][]float32, err error) {
	mm_atomic.AddUint64(&mmEmbedTexts.beforeEmbedTextsCounter, 1)
	defer mm_atomic.AddUint64(&mmEmbedTexts.afterEmbedTextsCounter, 1)

	mmEmbedTexts.t.Helper()

	if mmEmbedTexts.inspectFuncEmbedTexts != nil {
		mmEmbedTexts.inspectFuncEmbedTexts(ctx, kp1, sa1, s1)
	}

	mm_params := ServiceMockEmbedTextsParams{ctx, kp1, sa1, s1}

	// Record call args
	mmEmbedTexts.EmbedTextsMock.mutex.Lock()
	mmEmbedTexts.EmbedTextsMock.callArgs = append(mmEmbedTexts.EmbedTextsMock.callArgs, &mm_params)
	mmEmbedTexts.EmbedTextsMock.mutex.Unlock()

	for _, e := range mmEmbedTexts.EmbedTextsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.faa1, e.results.err
		}
	}

	if mmEmbedTexts.EmbedTextsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEmbedTexts.EmbedTextsMock.defaultExpectation.Counter, 1)
		mm_want := mmEmbedTexts.EmbedTextsMock.defaultExpectation.params
		mm_want_ptrs := mmEmbedTexts.EmbedTextsMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockEmbedTextsParams{ctx, kp1, sa1, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmEmbedTexts.t.Errorf("ServiceMock.EmbedTexts got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEmbedTexts.EmbedTextsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kp1 != nil && !minimock.Equal(*mm_want_ptrs.kp1, mm_got.kp1) {
				mmEmbedTexts.t.Errorf("ServiceMock.EmbedTexts got unexpected parameter kp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEmbedTexts.EmbedTextsMock.defaultExpectation.expectationOrigins.originKp1, *mm_want_ptrs.kp1, mm_got.kp1, minimock.Diff(*mm_want_ptrs.kp1, mm_got.kp1))
			}

			if mm_want_ptrs.sa1 != nil && !minimock.Equal(*mm_want_ptrs.sa1, mm_got.sa1) {
				mmEmbedTexts.t.Errorf("ServiceMock.EmbedTexts got unexpected parameter sa1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEmbedTexts.EmbedTextsMock.defaultExpectation.expectationOrigins.originSa1, *mm_want_ptrs.sa1, mm_got.sa1, minimock.Diff(*mm_want_ptrs.sa1, mm_got.sa1))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmEmbedTexts.t.Errorf("ServiceMock.EmbedTexts got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEmbedTexts.EmbedTextsMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEmbedTexts.t.Errorf("ServiceMock.EmbedTexts got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmEmbedTexts.EmbedTextsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEmbedTexts.EmbedTextsMock.defaultExpectation.results
		if mm_results == nil {
			mmEmbedTexts.t.Fatal("No results are set for the ServiceMock.EmbedTexts")
		}
		return (*mm_results).faa1, (*mm_results).err
	}
	if mmEmbedTexts.funcEmbedTexts != nil {
		return mmEmbedTexts.funcEmbedTexts(ctx, kp1, sa1, s1)
	}
	mmEmbedTexts.t.Fatalf("Unexpected call to ServiceMock.EmbedTexts. %v %v %v %v", ctx, kp1, sa1, s1)
	return
}

// EmbedTextsAfterCounter returns a count of finished ServiceMock.EmbedTexts invocations
func (mmEmbedTexts *ServiceMock) EmbedTextsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEmbedTexts.afterEmbedTextsCounter)
}

// EmbedTextsBeforeCounter returns a count of ServiceMock.EmbedTexts invocations
func (mmEmbedTexts *ServiceMock) EmbedTextsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEmbedTexts.beforeEmbedTextsCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.EmbedTexts.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEmbedTexts *mServiceMockEmbedTexts) Calls() []*ServiceMockEmbedTextsParams {
	mmEmbedTexts.mutex.RLock()

	argCopy := make([]*ServiceMockEmbedTextsParams, len(mmEmbedTexts.callArgs))
	copy(argCopy, mmEmbedTexts.callArgs)

	mmEmbedTexts.mutex.RUnlock()

	return argCopy
}

// MinimockEmbedTextsDone returns true if the count of the EmbedTexts invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockEmbedTextsDone() bool {
	if m.EmbedTextsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.EmbedTextsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.EmbedTextsMock.invocationsDone()
}

// MinimockEmbedTextsInspect logs each unmet expectation
func (m *ServiceMock) MinimockEmbedTextsInspect() {
	for _, e := range m.EmbedTextsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.EmbedTexts at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterEmbedTextsCounter := mm_atomic.LoadUint64(&m.afterEmbedTextsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.EmbedTextsMock.defaultExpectation != nil && afterEmbedTextsCounter < 1 {
		if m.EmbedTextsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.EmbedTexts at\n%s", m.EmbedTextsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.EmbedTexts at\n%s with params: %#v", m.EmbedTextsMock.defaultExpectation.expectationOrigins.origin, *m.EmbedTextsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEmbedTexts != nil && afterEmbedTextsCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.EmbedTexts at\n%s", m.funcEmbedTextsOrigin)
	}

	if !m.EmbedTextsMock.invocationsDone() && afterEmbedTextsCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.EmbedTexts at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.EmbedTextsMock.expectedInvocations), m.EmbedTextsMock.expectedInvocationsOrigin, afterEmbedTextsCounter)
	}
}

type mServiceMockExecuteKnowledgeBaseUpdateAdmin struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockExecuteKnowledgeBaseUpdateAdminExpectation
	expectations       []*ServiceMockExecuteKnowledgeBaseUpdateAdminExpectation

	callArgs []*ServiceMockExecuteKnowledgeBaseUpdateAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockExecuteKnowledgeBaseUpdateAdminExpectation specifies expectation struct of the Service.ExecuteKnowledgeBaseUpdateAdmin
type ServiceMockExecuteKnowledgeBaseUpdateAdminExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockExecuteKnowledgeBaseUpdateAdminParams
	paramPtrs          *ServiceMockExecuteKnowledgeBaseUpdateAdminParamPtrs
	expectationOrigins ServiceMockExecuteKnowledgeBaseUpdateAdminExpectationOrigins
	results            *ServiceMockExecuteKnowledgeBaseUpdateAdminResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockExecuteKnowledgeBaseUpdateAdminParams contains parameters of the Service.ExecuteKnowledgeBaseUpdateAdmin
type ServiceMockExecuteKnowledgeBaseUpdateAdminParams struct {
	ctx context.Context
	ep1 *artifactpb.ExecuteKnowledgeBaseUpdateAdminRequest
}

// ServiceMockExecuteKnowledgeBaseUpdateAdminParamPtrs contains pointers to parameters of the Service.ExecuteKnowledgeBaseUpdateAdmin
type ServiceMockExecuteKnowledgeBaseUpdateAdminParamPtrs struct {
	ctx *context.Context
	ep1 **artifactpb.ExecuteKnowledgeBaseUpdateAdminRequest
}

// ServiceMockExecuteKnowledgeBaseUpdateAdminResults contains results of the Service.ExecuteKnowledgeBaseUpdateAdmin
type ServiceMockExecuteKnowledgeBaseUpdateAdminResults struct {
	ep2 *artifactpb.ExecuteKnowledgeBaseUpdateAdminResponse
	err error
}

// ServiceMockExecuteKnowledgeBaseUpdateAdminOrigins contains origins of expectations of the Service.ExecuteKnowledgeBaseUpdateAdmin
type ServiceMockExecuteKnowledgeBaseUpdateAdminExpectationOrigins struct {
	origin    string
	originCtx string
	originEp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExecuteKnowledgeBaseUpdateAdmin *mServiceMockExecuteKnowledgeBaseUpdateAdmin) Optional() *mServiceMockExecuteKnowledgeBaseUpdateAdmin {
	mmExecuteKnowledgeBaseUpdateAdmin.optional = true
	return mmExecuteKnowledgeBaseUpdateAdmin
}

// Expect sets up expected params for Service.ExecuteKnowledgeBaseUpdateAdmin
func (mmExecuteKnowledgeBaseUpdateAdmin *mServiceMockExecuteKnowledgeBaseUpdateAdmin) Expect(ctx context.Context, ep1 *artifactpb.ExecuteKnowledgeBaseUpdateAdminRequest) *mServiceMockExecuteKnowledgeBaseUpdateAdmin {
	if mmExecuteKnowledgeBaseUpdateAdmin.mock.funcExecuteKnowledgeBaseUpdateAdmin != nil {
		mmExecuteKnowledgeBaseUpdateAdmin.mock.t.Fatalf("ServiceMock.ExecuteKnowledgeBaseUpdateAdmin mock is already set by Set")
	}

	if mmExecuteKnowledgeBaseUpdateAdmin.defaultExpectation == nil {
		mmExecuteKnowledgeBaseUpdateAdmin.defaultExpectation = &ServiceMockExecuteKnowledgeBaseUpdateAdminExpectation{}
	}

	if mmExecuteKnowledgeBaseUpdateAdmin.defaultExpectation.paramPtrs != nil {
		mmExecuteKnowledgeBaseUpdateAdmin.mock.t.Fatalf("ServiceMock.ExecuteKnowledgeBaseUpdateAdmin mock is already set by ExpectParams functions")
	}

	mmExecuteKnowledgeBaseUpdateAdmin.defaultExpectation.params = &ServiceMockExecuteKnowledgeBaseUpdateAdminParams{ctx, ep1}
	mmExecuteKnowledgeBaseUpdateAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmExecuteKnowledgeBaseUpdateAdmin.expectations {
		if minimock.Equal(e.params, mmExecuteKnowledgeBaseUpdateAdmin.defaultExpectation.params) {
			mmExecuteKnowledgeBaseUpdateAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExecuteKnowledgeBaseUpdateAdmin.defaultExpectation.params)
		}
	}

	return mmExecuteKnowledgeBaseUpdateAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Service.ExecuteKnowledgeBaseUpdateAdmin
func (mmExecuteKnowledgeBaseUpdateAdmin *mServiceMockExecuteKnowledgeBaseUpdateAdmin) ExpectCtxParam1(ctx context.Context) *mServiceMockExecuteKnowledgeBaseUpdateAdmin {
	if mmExecuteKnowledgeBaseUpdateAdmin.mock.funcExecuteKnowledgeBaseUpdateAdmin != nil {
		mmExecuteKnowledgeBaseUpdateAdmin.mock.t.Fatalf("ServiceMock.ExecuteKnowledgeBaseUpdateAdmin mock is already set by Set")
	}

	if mmExecuteKnowledgeBaseUpdateAdmin.defaultExpectation == nil {
		mmExecuteKnowledgeBaseUpdateAdmin.defaultExpectation = &ServiceMockExecuteKnowledgeBaseUpdateAdminExpectation{}
	}

	if mmExecuteKnowledgeBaseUpdateAdmin.defaultExpectation.params != nil {
		mmExecuteKnowledgeBaseUpdateAdmin.mock.t.Fatalf("ServiceMock.ExecuteKnowledgeBaseUpdateAdmin mock is already set by Expect")
	}

	if mmExecuteKnowledgeBaseUpdateAdmin.defaultExpectation.paramPtrs == nil {
		mmExecuteKnowledgeBaseUpdateAdmin.defaultExpectation.paramPtrs = &ServiceMockExecuteKnowledgeBaseUpdateAdminParamPtrs{}
	}
	mmExecuteKnowledgeBaseUpdateAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmExecuteKnowledgeBaseUpdateAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmExecuteKnowledgeBaseUpdateAdmin
}

// ExpectEp1Param2 sets up expected param ep1 for Service.ExecuteKnowledgeBaseUpdateAdmin
func (mmExecuteKnowledgeBaseUpdateAdmin *mServiceMockExecuteKnowledgeBaseUpdateAdmin) ExpectEp1Param2(ep1 *artifactpb.ExecuteKnowledgeBaseUpdateAdminRequest) *mServiceMockExecuteKnowledgeBaseUpdateAdmin {
	if mmExecuteKnowledgeBaseUpdateAdmin.mock.funcExecuteKnowledgeBaseUpdateAdmin != nil {
		mmExecuteKnowledgeBaseUpdateAdmin.mock.t.Fatalf("ServiceMock.ExecuteKnowledgeBaseUpdateAdmin mock is already set by Set")
	}

	if mmExecuteKnowledgeBaseUpdateAdmin.defaultExpectation == nil {
		mmExecuteKnowledgeBaseUpdateAdmin.defaultExpectation = &ServiceMockExecuteKnowledgeBaseUpdateAdminExpectation{}
	}

	if mmExecuteKnowledgeBaseUpdateAdmin.defaultExpectation.params != nil {
		mmExecuteKnowledgeBaseUpdateAdmin.mock.t.Fatalf("ServiceMock.ExecuteKnowledgeBaseUpdateAdmin mock is already set by Expect")
	}

	if mmExecuteKnowledgeBaseUpdateAdmin.defaultExpectation.paramPtrs == nil {
		mmExecuteKnowledgeBaseUpdateAdmin.defaultExpectation.paramPtrs = &ServiceMockExecuteKnowledgeBaseUpdateAdminParamPtrs{}
	}
	mmExecuteKnowledgeBaseUpdateAdmin.defaultExpectation.paramPtrs.ep1 = &ep1
	mmExecuteKnowledgeBaseUpdateAdmin.defaultExpectation.expectationOrigins.originEp1 = minimock.CallerInfo(1)

	return mmExecuteKnowledgeBaseUpdateAdmin
}

// Inspect accepts an inspector function that has same arguments as the Service.ExecuteKnowledgeBaseUpdateAdmin
func (mmExecuteKnowledgeBaseUpdateAdmin *mServiceMockExecuteKnowledgeBaseUpdateAdmin) Inspect(f func(ctx context.Context, ep1 *artifactpb.ExecuteKnowledgeBaseUpdateAdminRequest)) *mServiceMockExecuteKnowledgeBaseUpdateAdmin {
	if mmExecuteKnowledgeBaseUpdateAdmin.mock.inspectFuncExecuteKnowledgeBaseUpdateAdmin != nil {
		mmExecuteKnowledgeBaseUpdateAdmin.mock.t.Fatalf("Inspect function is already set for ServiceMock.ExecuteKnowledgeBaseUpdateAdmin")
	}

	mmExecuteKnowledgeBaseUpdateAdmin.mock.inspectFuncExecuteKnowledgeBaseUpdateAdmin = f

	return mmExecuteKnowledgeBaseUpdateAdmin
}

// Return sets up results that will be returned by Service.ExecuteKnowledgeBaseUpdateAdmin
func (mmExecuteKnowledgeBaseUpdateAdmin *mServiceMockExecuteKnowledgeBaseUpdateAdmin) Return(ep2 *artifactpb.ExecuteKnowledgeBaseUpdateAdminResponse, err error) *ServiceMock {
	if mmExecuteKnowledgeBaseUpdateAdmin.mock.funcExecuteKnowledgeBaseUpdateAdmin != nil {
		mmExecuteKnowledgeBaseUpdateAdmin.mock.t.Fatalf("ServiceMock.ExecuteKnowledgeBaseUpdateAdmin mock is already set by Set")
	}

	if mmExecuteKnowledgeBaseUpdateAdmin.defaultExpectation == nil {
		mmExecuteKnowledgeBaseUpdateAdmin.defaultExpectation = &ServiceMockExecuteKnowledgeBaseUpdateAdminExpectation{mock: mmExecuteKnowledgeBaseUpdateAdmin.mock}
	}
	mmExecuteKnowledgeBaseUpdateAdmin.defaultExpectation.results = &ServiceMockExecuteKnowledgeBaseUpdateAdminResults{ep2, err}
	mmExecuteKnowledgeBaseUpdateAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmExecuteKnowledgeBaseUpdateAdmin.mock
}

// Set uses given function f to mock the Service.ExecuteKnowledgeBaseUpdateAdmin method
func (mmExecuteKnowledgeBaseUpdateAdmin *mServiceMockExecuteKnowledgeBaseUpdateAdmin) Set(f func(ctx context.Context, ep1 *artifactpb.ExecuteKnowledgeBaseUpdateAdminRequest) (ep2 *artifactpb.ExecuteKnowledgeBaseUpdateAdminResponse, err error)) *ServiceMock {
	if mmExecuteKnowledgeBaseUpdateAdmin.defaultExpectation != nil {
		mmExecuteKnowledgeBaseUpdateAdmin.mock.t.Fatalf("Default expectation is already set for the Service.ExecuteKnowledgeBaseUpdateAdmin method")
	}

	if len(mmExecuteKnowledgeBaseUpdateAdmin.expectations) > 0 {
		mmExecuteKnowledgeBaseUpdateAdmin.mock.t.Fatalf("Some expectations are already set for the Service.ExecuteKnowledgeBaseUpdateAdmin method")
	}

	mmExecuteKnowledgeBaseUpdateAdmin.mock.funcExecuteKnowledgeBaseUpdateAdmin = f
	mmExecuteKnowledgeBaseUpdateAdmin.mock.funcExecuteKnowledgeBaseUpdateAdminOrigin = minimock.CallerInfo(1)
	return mmExecuteKnowledgeBaseUpdateAdmin.mock
}

// When sets expectation for the Service.ExecuteKnowledgeBaseUpdateAdmin which will trigger the result defined by the following
// Then helper
func (mmExecuteKnowledgeBaseUpdateAdmin *mServiceMockExecuteKnowledgeBaseUpdateAdmin) When(ctx context.Context, ep1 *artifactpb.ExecuteKnowledgeBaseUpdateAdminRequest) *ServiceMockExecuteKnowledgeBaseUpdateAdminExpectation {
	if mmExecuteKnowledgeBaseUpdateAdmin.mock.funcExecuteKnowledgeBaseUpdateAdmin != nil {
		mmExecuteKnowledgeBaseUpdateAdmin.mock.t.Fatalf("ServiceMock.ExecuteKnowledgeBaseUpdateAdmin mock is already set by Set")
	}

	expectation := &ServiceMockExecuteKnowledgeBaseUpdateAdminExpectation{
		mock:               mmExecuteKnowledgeBaseUpdateAdmin.mock,
		params:             &ServiceMockExecuteKnowledgeBaseUpdateAdminParams{ctx, ep1},
		expectationOrigins: ServiceMockExecuteKnowledgeBaseUpdateAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmExecuteKnowledgeBaseUpdateAdmin.expectations = append(mmExecuteKnowledgeBaseUpdateAdmin.expectations, expectation)
	return expectation
}

// Then sets up Service.ExecuteKnowledgeBaseUpdateAdmin return parameters for the expectation previously defined by the When method
func (e *ServiceMockExecuteKnowledgeBaseUpdateAdminExpectation) Then(ep2 *artifactpb.ExecuteKnowledgeBaseUpdateAdminResponse, err error) *ServiceMock {
	e.results = &ServiceMockExecuteKnowledgeBaseUpdateAdminResults{ep2, err}
	return e.mock
}

// Times sets number of times Service.ExecuteKnowledgeBaseUpdateAdmin should be invoked
func (mmExecuteKnowledgeBaseUpdateAdmin *mServiceMockExecuteKnowledgeBaseUpdateAdmin) Times(n uint64) *mServiceMockExecuteKnowledgeBaseUpdateAdmin {
	if n == 0 {
		mmExecuteKnowledgeBaseUpdateAdmin.mock.t.Fatalf("Times of ServiceMock.ExecuteKnowledgeBaseUpdateAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExecuteKnowledgeBaseUpdateAdmin.expectedInvocations, n)
	mmExecuteKnowledgeBaseUpdateAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmExecuteKnowledgeBaseUpdateAdmin
}

func (mmExecuteKnowledgeBaseUpdateAdmin *mServiceMockExecuteKnowledgeBaseUpdateAdmin) invocationsDone() bool {
	if len(mmExecuteKnowledgeBaseUpdateAdmin.expectations) == 0 && mmExecuteKnowledgeBaseUpdateAdmin.defaultExpectation == nil && mmExecuteKnowledgeBaseUpdateAdmin.mock.funcExecuteKnowledgeBaseUpdateAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExecuteKnowledgeBaseUpdateAdmin.mock.afterExecuteKnowledgeBaseUpdateAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExecuteKnowledgeBaseUpdateAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ExecuteKnowledgeBaseUpdateAdmin implements mm_service.Service
func (mmExecuteKnowledgeBaseUpdateAdmin *ServiceMock) ExecuteKnowledgeBaseUpdateAdmin(ctx context.Context, ep1 *artifactpb.ExecuteKnowledgeBaseUpdateAdminRequest) (ep2 *artifactpb.ExecuteKnowledgeBaseUpdateAdminResponse, err error) {
	mm_atomic.AddUint64(&mmExecuteKnowledgeBaseUpdateAdmin.beforeExecuteKnowledgeBaseUpdateAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmExecuteKnowledgeBaseUpdateAdmin.afterExecuteKnowledgeBaseUpdateAdminCounter, 1)

	mmExecuteKnowledgeBaseUpdateAdmin.t.Helper()

	if mmExecuteKnowledgeBaseUpdateAdmin.inspectFuncExecuteKnowledgeBaseUpdateAdmin != nil {
		mmExecuteKnowledgeBaseUpdateAdmin.inspectFuncExecuteKnowledgeBaseUpdateAdmin(ctx, ep1)
	}

	mm_params := ServiceMockExecuteKnowledgeBaseUpdateAdminParams{ctx, ep1}

	// Record call args
	mmExecuteKnowledgeBaseUpdateAdmin.ExecuteKnowledgeBaseUpdateAdminMock.mutex.Lock()
	mmExecuteKnowledgeBaseUpdateAdmin.ExecuteKnowledgeBaseUpdateAdminMock.callArgs = append(mmExecuteKnowledgeBaseUpdateAdmin.ExecuteKnowledgeBaseUpdateAdminMock.callArgs, &mm_params)
	mmExecuteKnowledgeBaseUpdateAdmin.ExecuteKnowledgeBaseUpdateAdminMock.mutex.Unlock()

	for _, e := range mmExecuteKnowledgeBaseUpdateAdmin.ExecuteKnowledgeBaseUpdateAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ep2, e.results.err
		}
	}

	if mmExecuteKnowledgeBaseUpdateAdmin.ExecuteKnowledgeBaseUpdateAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExecuteKnowledgeBaseUpdateAdmin.ExecuteKnowledgeBaseUpdateAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmExecuteKnowledgeBaseUpdateAdmin.ExecuteKnowledgeBaseUpdateAdminMock.defaultExpectation.params
		mm_want_ptrs := mmExecuteKnowledgeBaseUpdateAdmin.ExecuteKnowledgeBaseUpdateAdminMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockExecuteKnowledgeBaseUpdateAdminParams{ctx, ep1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmExecuteKnowledgeBaseUpdateAdmin.t.Errorf("ServiceMock.ExecuteKnowledgeBaseUpdateAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExecuteKnowledgeBaseUpdateAdmin.ExecuteKnowledgeBaseUpdateAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ep1 != nil && !minimock.Equal(*mm_want_ptrs.ep1, mm_got.ep1) {
				mmExecuteKnowledgeBaseUpdateAdmin.t.Errorf("ServiceMock.ExecuteKnowledgeBaseUpdateAdmin got unexpected parameter ep1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExecuteKnowledgeBaseUpdateAdmin.ExecuteKnowledgeBaseUpdateAdminMock.defaultExpectation.expectationOrigins.originEp1, *mm_want_ptrs.ep1, mm_got.ep1, minimock.Diff(*mm_want_ptrs.ep1, mm_got.ep1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExecuteKnowledgeBaseUpdateAdmin.t.Errorf("ServiceMock.ExecuteKnowledgeBaseUpdateAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmExecuteKnowledgeBaseUpdateAdmin.ExecuteKnowledgeBaseUpdateAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExecuteKnowledgeBaseUpdateAdmin.ExecuteKnowledgeBaseUpdateAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmExecuteKnowledgeBaseUpdateAdmin.t.Fatal("No results are set for the ServiceMock.ExecuteKnowledgeBaseUpdateAdmin")
		}
		return (*mm_results).ep2, (*mm_results).err
	}
	if mmExecuteKnowledgeBaseUpdateAdmin.funcExecuteKnowledgeBaseUpdateAdmin != nil {
		return mmExecuteKnowledgeBaseUpdateAdmin.funcExecuteKnowledgeBaseUpdateAdmin(ctx, ep1)
	}
	mmExecuteKnowledgeBaseUpdateAdmin.t.Fatalf("Unexpected call to ServiceMock.ExecuteKnowledgeBaseUpdateAdmin. %v %v", ctx, ep1)
	return
}

// ExecuteKnowledgeBaseUpdateAdminAfterCounter returns a count of finished ServiceMock.ExecuteKnowledgeBaseUpdateAdmin invocations
func (mmExecuteKnowledgeBaseUpdateAdmin *ServiceMock) ExecuteKnowledgeBaseUpdateAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExecuteKnowledgeBaseUpdateAdmin.afterExecuteKnowledgeBaseUpdateAdminCounter)
}

// ExecuteKnowledgeBaseUpdateAdminBeforeCounter returns a count of ServiceMock.ExecuteKnowledgeBaseUpdateAdmin invocations
func (mmExecuteKnowledgeBaseUpdateAdmin *ServiceMock) ExecuteKnowledgeBaseUpdateAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExecuteKnowledgeBaseUpdateAdmin.beforeExecuteKnowledgeBaseUpdateAdminCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.ExecuteKnowledgeBaseUpdateAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExecuteKnowledgeBaseUpdateAdmin *mServiceMockExecuteKnowledgeBaseUpdateAdmin) Calls() []*ServiceMockExecuteKnowledgeBaseUpdateAdminParams {
	mmExecuteKnowledgeBaseUpdateAdmin.mutex.RLock()

	argCopy := make([]*ServiceMockExecuteKnowledgeBaseUpdateAdminParams, len(mmExecuteKnowledgeBaseUpdateAdmin.callArgs))
	copy(argCopy, mmExecuteKnowledgeBaseUpdateAdmin.callArgs)

	mmExecuteKnowledgeBaseUpdateAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockExecuteKnowledgeBaseUpdateAdminDone returns true if the count of the ExecuteKnowledgeBaseUpdateAdmin invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockExecuteKnowledgeBaseUpdateAdminDone() bool {
	if m.ExecuteKnowledgeBaseUpdateAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExecuteKnowledgeBaseUpdateAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExecuteKnowledgeBaseUpdateAdminMock.invocationsDone()
}

// MinimockExecuteKnowledgeBaseUpdateAdminInspect logs each unmet expectation
func (m *ServiceMock) MinimockExecuteKnowledgeBaseUpdateAdminInspect() {
	for _, e := range m.ExecuteKnowledgeBaseUpdateAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.ExecuteKnowledgeBaseUpdateAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterExecuteKnowledgeBaseUpdateAdminCounter := mm_atomic.LoadUint64(&m.afterExecuteKnowledgeBaseUpdateAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExecuteKnowledgeBaseUpdateAdminMock.defaultExpectation != nil && afterExecuteKnowledgeBaseUpdateAdminCounter < 1 {
		if m.ExecuteKnowledgeBaseUpdateAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.ExecuteKnowledgeBaseUpdateAdmin at\n%s", m.ExecuteKnowledgeBaseUpdateAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.ExecuteKnowledgeBaseUpdateAdmin at\n%s with params: %#v", m.ExecuteKnowledgeBaseUpdateAdminMock.defaultExpectation.expectationOrigins.origin, *m.ExecuteKnowledgeBaseUpdateAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExecuteKnowledgeBaseUpdateAdmin != nil && afterExecuteKnowledgeBaseUpdateAdminCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.ExecuteKnowledgeBaseUpdateAdmin at\n%s", m.funcExecuteKnowledgeBaseUpdateAdminOrigin)
	}

	if !m.ExecuteKnowledgeBaseUpdateAdminMock.invocationsDone() && afterExecuteKnowledgeBaseUpdateAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.ExecuteKnowledgeBaseUpdateAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ExecuteKnowledgeBaseUpdateAdminMock.expectedInvocations), m.ExecuteKnowledgeBaseUpdateAdminMock.expectedInvocationsOrigin, afterExecuteKnowledgeBaseUpdateAdminCounter)
	}
}

type mServiceMockGetChunksByFile struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetChunksByFileExpectation
	expectations       []*ServiceMockGetChunksByFileExpectation

	callArgs []*ServiceMockGetChunksByFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetChunksByFileExpectation specifies expectation struct of the Service.GetChunksByFile
type ServiceMockGetChunksByFileExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetChunksByFileParams
	paramPtrs          *ServiceMockGetChunksByFileParamPtrs
	expectationOrigins ServiceMockGetChunksByFileExpectationOrigins
	results            *ServiceMockGetChunksByFileResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetChunksByFileParams contains parameters of the Service.GetChunksByFile
type ServiceMockGetChunksByFileParams struct {
	ctx context.Context
	kp1 *repository.KnowledgeBaseFileModel
}

// ServiceMockGetChunksByFileParamPtrs contains pointers to parameters of the Service.GetChunksByFile
type ServiceMockGetChunksByFileParamPtrs struct {
	ctx *context.Context
	kp1 **repository.KnowledgeBaseFileModel
}

// ServiceMockGetChunksByFileResults contains results of the Service.GetChunksByFile
type ServiceMockGetChunksByFileResults struct {
	s1  types.SourceTableType
	s2  types.SourceUIDType
	ta1 []repository.TextChunkModel
	sa1 []string
	err error
}

// ServiceMockGetChunksByFileOrigins contains origins of expectations of the Service.GetChunksByFile
type ServiceMockGetChunksByFileExpectationOrigins struct {
	origin    string
	originCtx string
	originKp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetChunksByFile *mServiceMockGetChunksByFile) Optional() *mServiceMockGetChunksByFile {
	mmGetChunksByFile.optional = true
	return mmGetChunksByFile
}

// Expect sets up expected params for Service.GetChunksByFile
func (mmGetChunksByFile *mServiceMockGetChunksByFile) Expect(ctx context.Context, kp1 *repository.KnowledgeBaseFileModel) *mServiceMockGetChunksByFile {
	if mmGetChunksByFile.mock.funcGetChunksByFile != nil {
		mmGetChunksByFile.mock.t.Fatalf("ServiceMock.GetChunksByFile mock is already set by Set")
	}

	if mmGetChunksByFile.defaultExpectation == nil {
		mmGetChunksByFile.defaultExpectation = &ServiceMockGetChunksByFileExpectation{}
	}

	if mmGetChunksByFile.defaultExpectation.paramPtrs != nil {
		mmGetChunksByFile.mock.t.Fatalf("ServiceMock.GetChunksByFile mock is already set by ExpectParams functions")
	}

	mmGetChunksByFile.defaultExpectation.params = &ServiceMockGetChunksByFileParams{ctx, kp1}
	mmGetChunksByFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetChunksByFile.expectations {
		if minimock.Equal(e.params, mmGetChunksByFile.defaultExpectation.params) {
			mmGetChunksByFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChunksByFile.defaultExpectation.params)
		}
	}

	return mmGetChunksByFile
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetChunksByFile
func (mmGetChunksByFile *mServiceMockGetChunksByFile) ExpectCtxParam1(ctx context.Context) *mServiceMockGetChunksByFile {
	if mmGetChunksByFile.mock.funcGetChunksByFile != nil {
		mmGetChunksByFile.mock.t.Fatalf("ServiceMock.GetChunksByFile mock is already set by Set")
	}

	if mmGetChunksByFile.defaultExpectation == nil {
		mmGetChunksByFile.defaultExpectation = &ServiceMockGetChunksByFileExpectation{}
	}

	if mmGetChunksByFile.defaultExpectation.params != nil {
		mmGetChunksByFile.mock.t.Fatalf("ServiceMock.GetChunksByFile mock is already set by Expect")
	}

	if mmGetChunksByFile.defaultExpectation.paramPtrs == nil {
		mmGetChunksByFile.defaultExpectation.paramPtrs = &ServiceMockGetChunksByFileParamPtrs{}
	}
	mmGetChunksByFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetChunksByFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetChunksByFile
}

// ExpectKp1Param2 sets up expected param kp1 for Service.GetChunksByFile
func (mmGetChunksByFile *mServiceMockGetChunksByFile) ExpectKp1Param2(kp1 *repository.KnowledgeBaseFileModel) *mServiceMockGetChunksByFile {
	if mmGetChunksByFile.mock.funcGetChunksByFile != nil {
		mmGetChunksByFile.mock.t.Fatalf("ServiceMock.GetChunksByFile mock is already set by Set")
	}

	if mmGetChunksByFile.defaultExpectation == nil {
		mmGetChunksByFile.defaultExpectation = &ServiceMockGetChunksByFileExpectation{}
	}

	if mmGetChunksByFile.defaultExpectation.params != nil {
		mmGetChunksByFile.mock.t.Fatalf("ServiceMock.GetChunksByFile mock is already set by Expect")
	}

	if mmGetChunksByFile.defaultExpectation.paramPtrs == nil {
		mmGetChunksByFile.defaultExpectation.paramPtrs = &ServiceMockGetChunksByFileParamPtrs{}
	}
	mmGetChunksByFile.defaultExpectation.paramPtrs.kp1 = &kp1
	mmGetChunksByFile.defaultExpectation.expectationOrigins.originKp1 = minimock.CallerInfo(1)

	return mmGetChunksByFile
}

// Inspect accepts an inspector function that has same arguments as the Service.GetChunksByFile
func (mmGetChunksByFile *mServiceMockGetChunksByFile) Inspect(f func(ctx context.Context, kp1 *repository.KnowledgeBaseFileModel)) *mServiceMockGetChunksByFile {
	if mmGetChunksByFile.mock.inspectFuncGetChunksByFile != nil {
		mmGetChunksByFile.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetChunksByFile")
	}

	mmGetChunksByFile.mock.inspectFuncGetChunksByFile = f

	return mmGetChunksByFile
}

// Return sets up results that will be returned by Service.GetChunksByFile
func (mmGetChunksByFile *mServiceMockGetChunksByFile) Return(s1 types.SourceTableType, s2 types.SourceUIDType, ta1 []repository.TextChunkModel, sa1 []string, err error) *ServiceMock {
	if mmGetChunksByFile.mock.funcGetChunksByFile != nil {
		mmGetChunksByFile.mock.t.Fatalf("ServiceMock.GetChunksByFile mock is already set by Set")
	}

	if mmGetChunksByFile.defaultExpectation == nil {
		mmGetChunksByFile.defaultExpectation = &ServiceMockGetChunksByFileExpectation{mock: mmGetChunksByFile.mock}
	}
	mmGetChunksByFile.defaultExpectation.results = &ServiceMockGetChunksByFileResults{s1, s2, ta1, sa1, err}
	mmGetChunksByFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetChunksByFile.mock
}

// Set uses given function f to mock the Service.GetChunksByFile method
func (mmGetChunksByFile *mServiceMockGetChunksByFile) Set(f func(ctx context.Context, kp1 *repository.KnowledgeBaseFileModel) (s1 types.SourceTableType, s2 types.SourceUIDType, ta1 []repository.TextChunkModel, sa1 []string, err error)) *ServiceMock {
	if mmGetChunksByFile.defaultExpectation != nil {
		mmGetChunksByFile.mock.t.Fatalf("Default expectation is already set for the Service.GetChunksByFile method")
	}

	if len(mmGetChunksByFile.expectations) > 0 {
		mmGetChunksByFile.mock.t.Fatalf("Some expectations are already set for the Service.GetChunksByFile method")
	}

	mmGetChunksByFile.mock.funcGetChunksByFile = f
	mmGetChunksByFile.mock.funcGetChunksByFileOrigin = minimock.CallerInfo(1)
	return mmGetChunksByFile.mock
}

// When sets expectation for the Service.GetChunksByFile which will trigger the result defined by the following
// Then helper
func (mmGetChunksByFile *mServiceMockGetChunksByFile) When(ctx context.Context, kp1 *repository.KnowledgeBaseFileModel) *ServiceMockGetChunksByFileExpectation {
	if mmGetChunksByFile.mock.funcGetChunksByFile != nil {
		mmGetChunksByFile.mock.t.Fatalf("ServiceMock.GetChunksByFile mock is already set by Set")
	}

	expectation := &ServiceMockGetChunksByFileExpectation{
		mock:               mmGetChunksByFile.mock,
		params:             &ServiceMockGetChunksByFileParams{ctx, kp1},
		expectationOrigins: ServiceMockGetChunksByFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetChunksByFile.expectations = append(mmGetChunksByFile.expectations, expectation)
	return expectation
}

// Then sets up Service.GetChunksByFile return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetChunksByFileExpectation) Then(s1 types.SourceTableType, s2 types.SourceUIDType, ta1 []repository.TextChunkModel, sa1 []string, err error) *ServiceMock {
	e.results = &ServiceMockGetChunksByFileResults{s1, s2, ta1, sa1, err}
	return e.mock
}

// Times sets number of times Service.GetChunksByFile should be invoked
func (mmGetChunksByFile *mServiceMockGetChunksByFile) Times(n uint64) *mServiceMockGetChunksByFile {
	if n == 0 {
		mmGetChunksByFile.mock.t.Fatalf("Times of ServiceMock.GetChunksByFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetChunksByFile.expectedInvocations, n)
	mmGetChunksByFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetChunksByFile
}

func (mmGetChunksByFile *mServiceMockGetChunksByFile) invocationsDone() bool {
	if len(mmGetChunksByFile.expectations) == 0 && mmGetChunksByFile.defaultExpectation == nil && mmGetChunksByFile.mock.funcGetChunksByFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetChunksByFile.mock.afterGetChunksByFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetChunksByFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetChunksByFile implements mm_service.Service
func (mmGetChunksByFile *ServiceMock) GetChunksByFile(ctx context.Context, kp1 *repository.KnowledgeBaseFileModel) (s1 types.SourceTableType, s2 types.SourceUIDType, ta1 []repository.TextChunkModel, sa1 []string, err error) {
	mm_atomic.AddUint64(&mmGetChunksByFile.beforeGetChunksByFileCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChunksByFile.afterGetChunksByFileCounter, 1)

	mmGetChunksByFile.t.Helper()

	if mmGetChunksByFile.inspectFuncGetChunksByFile != nil {
		mmGetChunksByFile.inspectFuncGetChunksByFile(ctx, kp1)
	}

	mm_params := ServiceMockGetChunksByFileParams{ctx, kp1}

	// Record call args
	mmGetChunksByFile.GetChunksByFileMock.mutex.Lock()
	mmGetChunksByFile.GetChunksByFileMock.callArgs = append(mmGetChunksByFile.GetChunksByFileMock.callArgs, &mm_params)
	mmGetChunksByFile.GetChunksByFileMock.mutex.Unlock()

	for _, e := range mmGetChunksByFile.GetChunksByFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.s2, e.results.ta1, e.results.sa1, e.results.err
		}
	}

	if mmGetChunksByFile.GetChunksByFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChunksByFile.GetChunksByFileMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChunksByFile.GetChunksByFileMock.defaultExpectation.params
		mm_want_ptrs := mmGetChunksByFile.GetChunksByFileMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetChunksByFileParams{ctx, kp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetChunksByFile.t.Errorf("ServiceMock.GetChunksByFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChunksByFile.GetChunksByFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kp1 != nil && !minimock.Equal(*mm_want_ptrs.kp1, mm_got.kp1) {
				mmGetChunksByFile.t.Errorf("ServiceMock.GetChunksByFile got unexpected parameter kp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChunksByFile.GetChunksByFileMock.defaultExpectation.expectationOrigins.originKp1, *mm_want_ptrs.kp1, mm_got.kp1, minimock.Diff(*mm_want_ptrs.kp1, mm_got.kp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChunksByFile.t.Errorf("ServiceMock.GetChunksByFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetChunksByFile.GetChunksByFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChunksByFile.GetChunksByFileMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChunksByFile.t.Fatal("No results are set for the ServiceMock.GetChunksByFile")
		}
		return (*mm_results).s1, (*mm_results).s2, (*mm_results).ta1, (*mm_results).sa1, (*mm_results).err
	}
	if mmGetChunksByFile.funcGetChunksByFile != nil {
		return mmGetChunksByFile.funcGetChunksByFile(ctx, kp1)
	}
	mmGetChunksByFile.t.Fatalf("Unexpected call to ServiceMock.GetChunksByFile. %v %v", ctx, kp1)
	return
}

// GetChunksByFileAfterCounter returns a count of finished ServiceMock.GetChunksByFile invocations
func (mmGetChunksByFile *ServiceMock) GetChunksByFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChunksByFile.afterGetChunksByFileCounter)
}

// GetChunksByFileBeforeCounter returns a count of ServiceMock.GetChunksByFile invocations
func (mmGetChunksByFile *ServiceMock) GetChunksByFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChunksByFile.beforeGetChunksByFileCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetChunksByFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChunksByFile *mServiceMockGetChunksByFile) Calls() []*ServiceMockGetChunksByFileParams {
	mmGetChunksByFile.mutex.RLock()

	argCopy := make([]*ServiceMockGetChunksByFileParams, len(mmGetChunksByFile.callArgs))
	copy(argCopy, mmGetChunksByFile.callArgs)

	mmGetChunksByFile.mutex.RUnlock()

	return argCopy
}

// MinimockGetChunksByFileDone returns true if the count of the GetChunksByFile invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetChunksByFileDone() bool {
	if m.GetChunksByFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetChunksByFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetChunksByFileMock.invocationsDone()
}

// MinimockGetChunksByFileInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetChunksByFileInspect() {
	for _, e := range m.GetChunksByFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetChunksByFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetChunksByFileCounter := mm_atomic.LoadUint64(&m.afterGetChunksByFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetChunksByFileMock.defaultExpectation != nil && afterGetChunksByFileCounter < 1 {
		if m.GetChunksByFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetChunksByFile at\n%s", m.GetChunksByFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetChunksByFile at\n%s with params: %#v", m.GetChunksByFileMock.defaultExpectation.expectationOrigins.origin, *m.GetChunksByFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChunksByFile != nil && afterGetChunksByFileCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetChunksByFile at\n%s", m.funcGetChunksByFileOrigin)
	}

	if !m.GetChunksByFileMock.invocationsDone() && afterGetChunksByFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetChunksByFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetChunksByFileMock.expectedInvocations), m.GetChunksByFileMock.expectedInvocationsOrigin, afterGetChunksByFileCounter)
	}
}

type mServiceMockGetConvertedFilePathsByFileUID struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetConvertedFilePathsByFileUIDExpectation
	expectations       []*ServiceMockGetConvertedFilePathsByFileUIDExpectation

	callArgs []*ServiceMockGetConvertedFilePathsByFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetConvertedFilePathsByFileUIDExpectation specifies expectation struct of the Service.GetConvertedFilePathsByFileUID
type ServiceMockGetConvertedFilePathsByFileUIDExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetConvertedFilePathsByFileUIDParams
	paramPtrs          *ServiceMockGetConvertedFilePathsByFileUIDParamPtrs
	expectationOrigins ServiceMockGetConvertedFilePathsByFileUIDExpectationOrigins
	results            *ServiceMockGetConvertedFilePathsByFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetConvertedFilePathsByFileUIDParams contains parameters of the Service.GetConvertedFilePathsByFileUID
type ServiceMockGetConvertedFilePathsByFileUIDParams struct {
	ctx context.Context
	k1  types.KBUIDType
	f1  types.FileUIDType
}

// ServiceMockGetConvertedFilePathsByFileUIDParamPtrs contains pointers to parameters of the Service.GetConvertedFilePathsByFileUID
type ServiceMockGetConvertedFilePathsByFileUIDParamPtrs struct {
	ctx *context.Context
	k1  *types.KBUIDType
	f1  *types.FileUIDType
}

// ServiceMockGetConvertedFilePathsByFileUIDResults contains results of the Service.GetConvertedFilePathsByFileUID
type ServiceMockGetConvertedFilePathsByFileUIDResults struct {
	sa1 []string
	err error
}

// ServiceMockGetConvertedFilePathsByFileUIDOrigins contains origins of expectations of the Service.GetConvertedFilePathsByFileUID
type ServiceMockGetConvertedFilePathsByFileUIDExpectationOrigins struct {
	origin    string
	originCtx string
	originK1  string
	originF1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetConvertedFilePathsByFileUID *mServiceMockGetConvertedFilePathsByFileUID) Optional() *mServiceMockGetConvertedFilePathsByFileUID {
	mmGetConvertedFilePathsByFileUID.optional = true
	return mmGetConvertedFilePathsByFileUID
}

// Expect sets up expected params for Service.GetConvertedFilePathsByFileUID
func (mmGetConvertedFilePathsByFileUID *mServiceMockGetConvertedFilePathsByFileUID) Expect(ctx context.Context, k1 types.KBUIDType, f1 types.FileUIDType) *mServiceMockGetConvertedFilePathsByFileUID {
	if mmGetConvertedFilePathsByFileUID.mock.funcGetConvertedFilePathsByFileUID != nil {
		mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetConvertedFilePathsByFileUID mock is already set by Set")
	}

	if mmGetConvertedFilePathsByFileUID.defaultExpectation == nil {
		mmGetConvertedFilePathsByFileUID.defaultExpectation = &ServiceMockGetConvertedFilePathsByFileUIDExpectation{}
	}

	if mmGetConvertedFilePathsByFileUID.defaultExpectation.paramPtrs != nil {
		mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetConvertedFilePathsByFileUID mock is already set by ExpectParams functions")
	}

	mmGetConvertedFilePathsByFileUID.defaultExpectation.params = &ServiceMockGetConvertedFilePathsByFileUIDParams{ctx, k1, f1}
	mmGetConvertedFilePathsByFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetConvertedFilePathsByFileUID.expectations {
		if minimock.Equal(e.params, mmGetConvertedFilePathsByFileUID.defaultExpectation.params) {
			mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetConvertedFilePathsByFileUID.defaultExpectation.params)
		}
	}

	return mmGetConvertedFilePathsByFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetConvertedFilePathsByFileUID
func (mmGetConvertedFilePathsByFileUID *mServiceMockGetConvertedFilePathsByFileUID) ExpectCtxParam1(ctx context.Context) *mServiceMockGetConvertedFilePathsByFileUID {
	if mmGetConvertedFilePathsByFileUID.mock.funcGetConvertedFilePathsByFileUID != nil {
		mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetConvertedFilePathsByFileUID mock is already set by Set")
	}

	if mmGetConvertedFilePathsByFileUID.defaultExpectation == nil {
		mmGetConvertedFilePathsByFileUID.defaultExpectation = &ServiceMockGetConvertedFilePathsByFileUIDExpectation{}
	}

	if mmGetConvertedFilePathsByFileUID.defaultExpectation.params != nil {
		mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetConvertedFilePathsByFileUID mock is already set by Expect")
	}

	if mmGetConvertedFilePathsByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetConvertedFilePathsByFileUID.defaultExpectation.paramPtrs = &ServiceMockGetConvertedFilePathsByFileUIDParamPtrs{}
	}
	mmGetConvertedFilePathsByFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetConvertedFilePathsByFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetConvertedFilePathsByFileUID
}

// ExpectK1Param2 sets up expected param k1 for Service.GetConvertedFilePathsByFileUID
func (mmGetConvertedFilePathsByFileUID *mServiceMockGetConvertedFilePathsByFileUID) ExpectK1Param2(k1 types.KBUIDType) *mServiceMockGetConvertedFilePathsByFileUID {
	if mmGetConvertedFilePathsByFileUID.mock.funcGetConvertedFilePathsByFileUID != nil {
		mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetConvertedFilePathsByFileUID mock is already set by Set")
	}

	if mmGetConvertedFilePathsByFileUID.defaultExpectation == nil {
		mmGetConvertedFilePathsByFileUID.defaultExpectation = &ServiceMockGetConvertedFilePathsByFileUIDExpectation{}
	}

	if mmGetConvertedFilePathsByFileUID.defaultExpectation.params != nil {
		mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetConvertedFilePathsByFileUID mock is already set by Expect")
	}

	if mmGetConvertedFilePathsByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetConvertedFilePathsByFileUID.defaultExpectation.paramPtrs = &ServiceMockGetConvertedFilePathsByFileUIDParamPtrs{}
	}
	mmGetConvertedFilePathsByFileUID.defaultExpectation.paramPtrs.k1 = &k1
	mmGetConvertedFilePathsByFileUID.defaultExpectation.expectationOrigins.originK1 = minimock.CallerInfo(1)

	return mmGetConvertedFilePathsByFileUID
}

// ExpectF1Param3 sets up expected param f1 for Service.GetConvertedFilePathsByFileUID
func (mmGetConvertedFilePathsByFileUID *mServiceMockGetConvertedFilePathsByFileUID) ExpectF1Param3(f1 types.FileUIDType) *mServiceMockGetConvertedFilePathsByFileUID {
	if mmGetConvertedFilePathsByFileUID.mock.funcGetConvertedFilePathsByFileUID != nil {
		mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetConvertedFilePathsByFileUID mock is already set by Set")
	}

	if mmGetConvertedFilePathsByFileUID.defaultExpectation == nil {
		mmGetConvertedFilePathsByFileUID.defaultExpectation = &ServiceMockGetConvertedFilePathsByFileUIDExpectation{}
	}

	if mmGetConvertedFilePathsByFileUID.defaultExpectation.params != nil {
		mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetConvertedFilePathsByFileUID mock is already set by Expect")
	}

	if mmGetConvertedFilePathsByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetConvertedFilePathsByFileUID.defaultExpectation.paramPtrs = &ServiceMockGetConvertedFilePathsByFileUIDParamPtrs{}
	}
	mmGetConvertedFilePathsByFileUID.defaultExpectation.paramPtrs.f1 = &f1
	mmGetConvertedFilePathsByFileUID.defaultExpectation.expectationOrigins.originF1 = minimock.CallerInfo(1)

	return mmGetConvertedFilePathsByFileUID
}

// Inspect accepts an inspector function that has same arguments as the Service.GetConvertedFilePathsByFileUID
func (mmGetConvertedFilePathsByFileUID *mServiceMockGetConvertedFilePathsByFileUID) Inspect(f func(ctx context.Context, k1 types.KBUIDType, f1 types.FileUIDType)) *mServiceMockGetConvertedFilePathsByFileUID {
	if mmGetConvertedFilePathsByFileUID.mock.inspectFuncGetConvertedFilePathsByFileUID != nil {
		mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetConvertedFilePathsByFileUID")
	}

	mmGetConvertedFilePathsByFileUID.mock.inspectFuncGetConvertedFilePathsByFileUID = f

	return mmGetConvertedFilePathsByFileUID
}

// Return sets up results that will be returned by Service.GetConvertedFilePathsByFileUID
func (mmGetConvertedFilePathsByFileUID *mServiceMockGetConvertedFilePathsByFileUID) Return(sa1 []string, err error) *ServiceMock {
	if mmGetConvertedFilePathsByFileUID.mock.funcGetConvertedFilePathsByFileUID != nil {
		mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetConvertedFilePathsByFileUID mock is already set by Set")
	}

	if mmGetConvertedFilePathsByFileUID.defaultExpectation == nil {
		mmGetConvertedFilePathsByFileUID.defaultExpectation = &ServiceMockGetConvertedFilePathsByFileUIDExpectation{mock: mmGetConvertedFilePathsByFileUID.mock}
	}
	mmGetConvertedFilePathsByFileUID.defaultExpectation.results = &ServiceMockGetConvertedFilePathsByFileUIDResults{sa1, err}
	mmGetConvertedFilePathsByFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetConvertedFilePathsByFileUID.mock
}

// Set uses given function f to mock the Service.GetConvertedFilePathsByFileUID method
func (mmGetConvertedFilePathsByFileUID *mServiceMockGetConvertedFilePathsByFileUID) Set(f func(ctx context.Context, k1 types.KBUIDType, f1 types.FileUIDType) (sa1 []string, err error)) *ServiceMock {
	if mmGetConvertedFilePathsByFileUID.defaultExpectation != nil {
		mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("Default expectation is already set for the Service.GetConvertedFilePathsByFileUID method")
	}

	if len(mmGetConvertedFilePathsByFileUID.expectations) > 0 {
		mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("Some expectations are already set for the Service.GetConvertedFilePathsByFileUID method")
	}

	mmGetConvertedFilePathsByFileUID.mock.funcGetConvertedFilePathsByFileUID = f
	mmGetConvertedFilePathsByFileUID.mock.funcGetConvertedFilePathsByFileUIDOrigin = minimock.CallerInfo(1)
	return mmGetConvertedFilePathsByFileUID.mock
}

// When sets expectation for the Service.GetConvertedFilePathsByFileUID which will trigger the result defined by the following
// Then helper
func (mmGetConvertedFilePathsByFileUID *mServiceMockGetConvertedFilePathsByFileUID) When(ctx context.Context, k1 types.KBUIDType, f1 types.FileUIDType) *ServiceMockGetConvertedFilePathsByFileUIDExpectation {
	if mmGetConvertedFilePathsByFileUID.mock.funcGetConvertedFilePathsByFileUID != nil {
		mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetConvertedFilePathsByFileUID mock is already set by Set")
	}

	expectation := &ServiceMockGetConvertedFilePathsByFileUIDExpectation{
		mock:               mmGetConvertedFilePathsByFileUID.mock,
		params:             &ServiceMockGetConvertedFilePathsByFileUIDParams{ctx, k1, f1},
		expectationOrigins: ServiceMockGetConvertedFilePathsByFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetConvertedFilePathsByFileUID.expectations = append(mmGetConvertedFilePathsByFileUID.expectations, expectation)
	return expectation
}

// Then sets up Service.GetConvertedFilePathsByFileUID return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetConvertedFilePathsByFileUIDExpectation) Then(sa1 []string, err error) *ServiceMock {
	e.results = &ServiceMockGetConvertedFilePathsByFileUIDResults{sa1, err}
	return e.mock
}

// Times sets number of times Service.GetConvertedFilePathsByFileUID should be invoked
func (mmGetConvertedFilePathsByFileUID *mServiceMockGetConvertedFilePathsByFileUID) Times(n uint64) *mServiceMockGetConvertedFilePathsByFileUID {
	if n == 0 {
		mmGetConvertedFilePathsByFileUID.mock.t.Fatalf("Times of ServiceMock.GetConvertedFilePathsByFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetConvertedFilePathsByFileUID.expectedInvocations, n)
	mmGetConvertedFilePathsByFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetConvertedFilePathsByFileUID
}

func (mmGetConvertedFilePathsByFileUID *mServiceMockGetConvertedFilePathsByFileUID) invocationsDone() bool {
	if len(mmGetConvertedFilePathsByFileUID.expectations) == 0 && mmGetConvertedFilePathsByFileUID.defaultExpectation == nil && mmGetConvertedFilePathsByFileUID.mock.funcGetConvertedFilePathsByFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetConvertedFilePathsByFileUID.mock.afterGetConvertedFilePathsByFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetConvertedFilePathsByFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetConvertedFilePathsByFileUID implements mm_service.Service
func (mmGetConvertedFilePathsByFileUID *ServiceMock) GetConvertedFilePathsByFileUID(ctx context.Context, k1 types.KBUIDType, f1 types.FileUIDType) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmGetConvertedFilePathsByFileUID.beforeGetConvertedFilePathsByFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetConvertedFilePathsByFileUID.afterGetConvertedFilePathsByFileUIDCounter, 1)

	mmGetConvertedFilePathsByFileUID.t.Helper()

	if mmGetConvertedFilePathsByFileUID.inspectFuncGetConvertedFilePathsByFileUID != nil {
		mmGetConvertedFilePathsByFileUID.inspectFuncGetConvertedFilePathsByFileUID(ctx, k1, f1)
	}

	mm_params := ServiceMockGetConvertedFilePathsByFileUIDParams{ctx, k1, f1}

	// Record call args
	mmGetConvertedFilePathsByFileUID.GetConvertedFilePathsByFileUIDMock.mutex.Lock()
	mmGetConvertedFilePathsByFileUID.GetConvertedFilePathsByFileUIDMock.callArgs = append(mmGetConvertedFilePathsByFileUID.GetConvertedFilePathsByFileUIDMock.callArgs, &mm_params)
	mmGetConvertedFilePathsByFileUID.GetConvertedFilePathsByFileUIDMock.mutex.Unlock()

	for _, e := range mmGetConvertedFilePathsByFileUID.GetConvertedFilePathsByFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmGetConvertedFilePathsByFileUID.GetConvertedFilePathsByFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetConvertedFilePathsByFileUID.GetConvertedFilePathsByFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetConvertedFilePathsByFileUID.GetConvertedFilePathsByFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetConvertedFilePathsByFileUID.GetConvertedFilePathsByFileUIDMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetConvertedFilePathsByFileUIDParams{ctx, k1, f1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetConvertedFilePathsByFileUID.t.Errorf("ServiceMock.GetConvertedFilePathsByFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetConvertedFilePathsByFileUID.GetConvertedFilePathsByFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.k1 != nil && !minimock.Equal(*mm_want_ptrs.k1, mm_got.k1) {
				mmGetConvertedFilePathsByFileUID.t.Errorf("ServiceMock.GetConvertedFilePathsByFileUID got unexpected parameter k1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetConvertedFilePathsByFileUID.GetConvertedFilePathsByFileUIDMock.defaultExpectation.expectationOrigins.originK1, *mm_want_ptrs.k1, mm_got.k1, minimock.Diff(*mm_want_ptrs.k1, mm_got.k1))
			}

			if mm_want_ptrs.f1 != nil && !minimock.Equal(*mm_want_ptrs.f1, mm_got.f1) {
				mmGetConvertedFilePathsByFileUID.t.Errorf("ServiceMock.GetConvertedFilePathsByFileUID got unexpected parameter f1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetConvertedFilePathsByFileUID.GetConvertedFilePathsByFileUIDMock.defaultExpectation.expectationOrigins.originF1, *mm_want_ptrs.f1, mm_got.f1, minimock.Diff(*mm_want_ptrs.f1, mm_got.f1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetConvertedFilePathsByFileUID.t.Errorf("ServiceMock.GetConvertedFilePathsByFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetConvertedFilePathsByFileUID.GetConvertedFilePathsByFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetConvertedFilePathsByFileUID.GetConvertedFilePathsByFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetConvertedFilePathsByFileUID.t.Fatal("No results are set for the ServiceMock.GetConvertedFilePathsByFileUID")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmGetConvertedFilePathsByFileUID.funcGetConvertedFilePathsByFileUID != nil {
		return mmGetConvertedFilePathsByFileUID.funcGetConvertedFilePathsByFileUID(ctx, k1, f1)
	}
	mmGetConvertedFilePathsByFileUID.t.Fatalf("Unexpected call to ServiceMock.GetConvertedFilePathsByFileUID. %v %v %v", ctx, k1, f1)
	return
}

// GetConvertedFilePathsByFileUIDAfterCounter returns a count of finished ServiceMock.GetConvertedFilePathsByFileUID invocations
func (mmGetConvertedFilePathsByFileUID *ServiceMock) GetConvertedFilePathsByFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConvertedFilePathsByFileUID.afterGetConvertedFilePathsByFileUIDCounter)
}

// GetConvertedFilePathsByFileUIDBeforeCounter returns a count of ServiceMock.GetConvertedFilePathsByFileUID invocations
func (mmGetConvertedFilePathsByFileUID *ServiceMock) GetConvertedFilePathsByFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConvertedFilePathsByFileUID.beforeGetConvertedFilePathsByFileUIDCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetConvertedFilePathsByFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetConvertedFilePathsByFileUID *mServiceMockGetConvertedFilePathsByFileUID) Calls() []*ServiceMockGetConvertedFilePathsByFileUIDParams {
	mmGetConvertedFilePathsByFileUID.mutex.RLock()

	argCopy := make([]*ServiceMockGetConvertedFilePathsByFileUIDParams, len(mmGetConvertedFilePathsByFileUID.callArgs))
	copy(argCopy, mmGetConvertedFilePathsByFileUID.callArgs)

	mmGetConvertedFilePathsByFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetConvertedFilePathsByFileUIDDone returns true if the count of the GetConvertedFilePathsByFileUID invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetConvertedFilePathsByFileUIDDone() bool {
	if m.GetConvertedFilePathsByFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetConvertedFilePathsByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetConvertedFilePathsByFileUIDMock.invocationsDone()
}

// MinimockGetConvertedFilePathsByFileUIDInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetConvertedFilePathsByFileUIDInspect() {
	for _, e := range m.GetConvertedFilePathsByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetConvertedFilePathsByFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetConvertedFilePathsByFileUIDCounter := mm_atomic.LoadUint64(&m.afterGetConvertedFilePathsByFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetConvertedFilePathsByFileUIDMock.defaultExpectation != nil && afterGetConvertedFilePathsByFileUIDCounter < 1 {
		if m.GetConvertedFilePathsByFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetConvertedFilePathsByFileUID at\n%s", m.GetConvertedFilePathsByFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetConvertedFilePathsByFileUID at\n%s with params: %#v", m.GetConvertedFilePathsByFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetConvertedFilePathsByFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetConvertedFilePathsByFileUID != nil && afterGetConvertedFilePathsByFileUIDCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetConvertedFilePathsByFileUID at\n%s", m.funcGetConvertedFilePathsByFileUIDOrigin)
	}

	if !m.GetConvertedFilePathsByFileUIDMock.invocationsDone() && afterGetConvertedFilePathsByFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetConvertedFilePathsByFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetConvertedFilePathsByFileUIDMock.expectedInvocations), m.GetConvertedFilePathsByFileUIDMock.expectedInvocationsOrigin, afterGetConvertedFilePathsByFileUIDCounter)
	}
}

type mServiceMockGetDefaultSystemAdmin struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetDefaultSystemAdminExpectation
	expectations       []*ServiceMockGetDefaultSystemAdminExpectation

	callArgs []*ServiceMockGetDefaultSystemAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetDefaultSystemAdminExpectation specifies expectation struct of the Service.GetDefaultSystemAdmin
type ServiceMockGetDefaultSystemAdminExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetDefaultSystemAdminParams
	paramPtrs          *ServiceMockGetDefaultSystemAdminParamPtrs
	expectationOrigins ServiceMockGetDefaultSystemAdminExpectationOrigins
	results            *ServiceMockGetDefaultSystemAdminResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetDefaultSystemAdminParams contains parameters of the Service.GetDefaultSystemAdmin
type ServiceMockGetDefaultSystemAdminParams struct {
	ctx context.Context
	gp1 *artifactpb.GetDefaultSystemAdminRequest
}

// ServiceMockGetDefaultSystemAdminParamPtrs contains pointers to parameters of the Service.GetDefaultSystemAdmin
type ServiceMockGetDefaultSystemAdminParamPtrs struct {
	ctx *context.Context
	gp1 **artifactpb.GetDefaultSystemAdminRequest
}

// ServiceMockGetDefaultSystemAdminResults contains results of the Service.GetDefaultSystemAdmin
type ServiceMockGetDefaultSystemAdminResults struct {
	gp2 *artifactpb.GetDefaultSystemAdminResponse
	err error
}

// ServiceMockGetDefaultSystemAdminOrigins contains origins of expectations of the Service.GetDefaultSystemAdmin
type ServiceMockGetDefaultSystemAdminExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetDefaultSystemAdmin *mServiceMockGetDefaultSystemAdmin) Optional() *mServiceMockGetDefaultSystemAdmin {
	mmGetDefaultSystemAdmin.optional = true
	return mmGetDefaultSystemAdmin
}

// Expect sets up expected params for Service.GetDefaultSystemAdmin
func (mmGetDefaultSystemAdmin *mServiceMockGetDefaultSystemAdmin) Expect(ctx context.Context, gp1 *artifactpb.GetDefaultSystemAdminRequest) *mServiceMockGetDefaultSystemAdmin {
	if mmGetDefaultSystemAdmin.mock.funcGetDefaultSystemAdmin != nil {
		mmGetDefaultSystemAdmin.mock.t.Fatalf("ServiceMock.GetDefaultSystemAdmin mock is already set by Set")
	}

	if mmGetDefaultSystemAdmin.defaultExpectation == nil {
		mmGetDefaultSystemAdmin.defaultExpectation = &ServiceMockGetDefaultSystemAdminExpectation{}
	}

	if mmGetDefaultSystemAdmin.defaultExpectation.paramPtrs != nil {
		mmGetDefaultSystemAdmin.mock.t.Fatalf("ServiceMock.GetDefaultSystemAdmin mock is already set by ExpectParams functions")
	}

	mmGetDefaultSystemAdmin.defaultExpectation.params = &ServiceMockGetDefaultSystemAdminParams{ctx, gp1}
	mmGetDefaultSystemAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetDefaultSystemAdmin.expectations {
		if minimock.Equal(e.params, mmGetDefaultSystemAdmin.defaultExpectation.params) {
			mmGetDefaultSystemAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetDefaultSystemAdmin.defaultExpectation.params)
		}
	}

	return mmGetDefaultSystemAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetDefaultSystemAdmin
func (mmGetDefaultSystemAdmin *mServiceMockGetDefaultSystemAdmin) ExpectCtxParam1(ctx context.Context) *mServiceMockGetDefaultSystemAdmin {
	if mmGetDefaultSystemAdmin.mock.funcGetDefaultSystemAdmin != nil {
		mmGetDefaultSystemAdmin.mock.t.Fatalf("ServiceMock.GetDefaultSystemAdmin mock is already set by Set")
	}

	if mmGetDefaultSystemAdmin.defaultExpectation == nil {
		mmGetDefaultSystemAdmin.defaultExpectation = &ServiceMockGetDefaultSystemAdminExpectation{}
	}

	if mmGetDefaultSystemAdmin.defaultExpectation.params != nil {
		mmGetDefaultSystemAdmin.mock.t.Fatalf("ServiceMock.GetDefaultSystemAdmin mock is already set by Expect")
	}

	if mmGetDefaultSystemAdmin.defaultExpectation.paramPtrs == nil {
		mmGetDefaultSystemAdmin.defaultExpectation.paramPtrs = &ServiceMockGetDefaultSystemAdminParamPtrs{}
	}
	mmGetDefaultSystemAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetDefaultSystemAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetDefaultSystemAdmin
}

// ExpectGp1Param2 sets up expected param gp1 for Service.GetDefaultSystemAdmin
func (mmGetDefaultSystemAdmin *mServiceMockGetDefaultSystemAdmin) ExpectGp1Param2(gp1 *artifactpb.GetDefaultSystemAdminRequest) *mServiceMockGetDefaultSystemAdmin {
	if mmGetDefaultSystemAdmin.mock.funcGetDefaultSystemAdmin != nil {
		mmGetDefaultSystemAdmin.mock.t.Fatalf("ServiceMock.GetDefaultSystemAdmin mock is already set by Set")
	}

	if mmGetDefaultSystemAdmin.defaultExpectation == nil {
		mmGetDefaultSystemAdmin.defaultExpectation = &ServiceMockGetDefaultSystemAdminExpectation{}
	}

	if mmGetDefaultSystemAdmin.defaultExpectation.params != nil {
		mmGetDefaultSystemAdmin.mock.t.Fatalf("ServiceMock.GetDefaultSystemAdmin mock is already set by Expect")
	}

	if mmGetDefaultSystemAdmin.defaultExpectation.paramPtrs == nil {
		mmGetDefaultSystemAdmin.defaultExpectation.paramPtrs = &ServiceMockGetDefaultSystemAdminParamPtrs{}
	}
	mmGetDefaultSystemAdmin.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetDefaultSystemAdmin.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetDefaultSystemAdmin
}

// Inspect accepts an inspector function that has same arguments as the Service.GetDefaultSystemAdmin
func (mmGetDefaultSystemAdmin *mServiceMockGetDefaultSystemAdmin) Inspect(f func(ctx context.Context, gp1 *artifactpb.GetDefaultSystemAdminRequest)) *mServiceMockGetDefaultSystemAdmin {
	if mmGetDefaultSystemAdmin.mock.inspectFuncGetDefaultSystemAdmin != nil {
		mmGetDefaultSystemAdmin.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetDefaultSystemAdmin")
	}

	mmGetDefaultSystemAdmin.mock.inspectFuncGetDefaultSystemAdmin = f

	return mmGetDefaultSystemAdmin
}

// Return sets up results that will be returned by Service.GetDefaultSystemAdmin
func (mmGetDefaultSystemAdmin *mServiceMockGetDefaultSystemAdmin) Return(gp2 *artifactpb.GetDefaultSystemAdminResponse, err error) *ServiceMock {
	if mmGetDefaultSystemAdmin.mock.funcGetDefaultSystemAdmin != nil {
		mmGetDefaultSystemAdmin.mock.t.Fatalf("ServiceMock.GetDefaultSystemAdmin mock is already set by Set")
	}

	if mmGetDefaultSystemAdmin.defaultExpectation == nil {
		mmGetDefaultSystemAdmin.defaultExpectation = &ServiceMockGetDefaultSystemAdminExpectation{mock: mmGetDefaultSystemAdmin.mock}
	}
	mmGetDefaultSystemAdmin.defaultExpectation.results = &ServiceMockGetDefaultSystemAdminResults{gp2, err}
	mmGetDefaultSystemAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetDefaultSystemAdmin.mock
}

// Set uses given function f to mock the Service.GetDefaultSystemAdmin method
func (mmGetDefaultSystemAdmin *mServiceMockGetDefaultSystemAdmin) Set(f func(ctx context.Context, gp1 *artifactpb.GetDefaultSystemAdminRequest) (gp2 *artifactpb.GetDefaultSystemAdminResponse, err error)) *ServiceMock {
	if mmGetDefaultSystemAdmin.defaultExpectation != nil {
		mmGetDefaultSystemAdmin.mock.t.Fatalf("Default expectation is already set for the Service.GetDefaultSystemAdmin method")
	}

	if len(mmGetDefaultSystemAdmin.expectations) > 0 {
		mmGetDefaultSystemAdmin.mock.t.Fatalf("Some expectations are already set for the Service.GetDefaultSystemAdmin method")
	}

	mmGetDefaultSystemAdmin.mock.funcGetDefaultSystemAdmin = f
	mmGetDefaultSystemAdmin.mock.funcGetDefaultSystemAdminOrigin = minimock.CallerInfo(1)
	return mmGetDefaultSystemAdmin.mock
}

// When sets expectation for the Service.GetDefaultSystemAdmin which will trigger the result defined by the following
// Then helper
func (mmGetDefaultSystemAdmin *mServiceMockGetDefaultSystemAdmin) When(ctx context.Context, gp1 *artifactpb.GetDefaultSystemAdminRequest) *ServiceMockGetDefaultSystemAdminExpectation {
	if mmGetDefaultSystemAdmin.mock.funcGetDefaultSystemAdmin != nil {
		mmGetDefaultSystemAdmin.mock.t.Fatalf("ServiceMock.GetDefaultSystemAdmin mock is already set by Set")
	}

	expectation := &ServiceMockGetDefaultSystemAdminExpectation{
		mock:               mmGetDefaultSystemAdmin.mock,
		params:             &ServiceMockGetDefaultSystemAdminParams{ctx, gp1},
		expectationOrigins: ServiceMockGetDefaultSystemAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetDefaultSystemAdmin.expectations = append(mmGetDefaultSystemAdmin.expectations, expectation)
	return expectation
}

// Then sets up Service.GetDefaultSystemAdmin return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetDefaultSystemAdminExpectation) Then(gp2 *artifactpb.GetDefaultSystemAdminResponse, err error) *ServiceMock {
	e.results = &ServiceMockGetDefaultSystemAdminResults{gp2, err}
	return e.mock
}

// Times sets number of times Service.GetDefaultSystemAdmin should be invoked
func (mmGetDefaultSystemAdmin *mServiceMockGetDefaultSystemAdmin) Times(n uint64) *mServiceMockGetDefaultSystemAdmin {
	if n == 0 {
		mmGetDefaultSystemAdmin.mock.t.Fatalf("Times of ServiceMock.GetDefaultSystemAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetDefaultSystemAdmin.expectedInvocations, n)
	mmGetDefaultSystemAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetDefaultSystemAdmin
}

func (mmGetDefaultSystemAdmin *mServiceMockGetDefaultSystemAdmin) invocationsDone() bool {
	if len(mmGetDefaultSystemAdmin.expectations) == 0 && mmGetDefaultSystemAdmin.defaultExpectation == nil && mmGetDefaultSystemAdmin.mock.funcGetDefaultSystemAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetDefaultSystemAdmin.mock.afterGetDefaultSystemAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetDefaultSystemAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetDefaultSystemAdmin implements mm_service.Service
func (mmGetDefaultSystemAdmin *ServiceMock) GetDefaultSystemAdmin(ctx context.Context, gp1 *artifactpb.GetDefaultSystemAdminRequest) (gp2 *artifactpb.GetDefaultSystemAdminResponse, err error) {
	mm_atomic.AddUint64(&mmGetDefaultSystemAdmin.beforeGetDefaultSystemAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDefaultSystemAdmin.afterGetDefaultSystemAdminCounter, 1)

	mmGetDefaultSystemAdmin.t.Helper()

	if mmGetDefaultSystemAdmin.inspectFuncGetDefaultSystemAdmin != nil {
		mmGetDefaultSystemAdmin.inspectFuncGetDefaultSystemAdmin(ctx, gp1)
	}

	mm_params := ServiceMockGetDefaultSystemAdminParams{ctx, gp1}

	// Record call args
	mmGetDefaultSystemAdmin.GetDefaultSystemAdminMock.mutex.Lock()
	mmGetDefaultSystemAdmin.GetDefaultSystemAdminMock.callArgs = append(mmGetDefaultSystemAdmin.GetDefaultSystemAdminMock.callArgs, &mm_params)
	mmGetDefaultSystemAdmin.GetDefaultSystemAdminMock.mutex.Unlock()

	for _, e := range mmGetDefaultSystemAdmin.GetDefaultSystemAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetDefaultSystemAdmin.GetDefaultSystemAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDefaultSystemAdmin.GetDefaultSystemAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmGetDefaultSystemAdmin.GetDefaultSystemAdminMock.defaultExpectation.params
		mm_want_ptrs := mmGetDefaultSystemAdmin.GetDefaultSystemAdminMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetDefaultSystemAdminParams{ctx, gp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetDefaultSystemAdmin.t.Errorf("ServiceMock.GetDefaultSystemAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetDefaultSystemAdmin.GetDefaultSystemAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetDefaultSystemAdmin.t.Errorf("ServiceMock.GetDefaultSystemAdmin got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetDefaultSystemAdmin.GetDefaultSystemAdminMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetDefaultSystemAdmin.t.Errorf("ServiceMock.GetDefaultSystemAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetDefaultSystemAdmin.GetDefaultSystemAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetDefaultSystemAdmin.GetDefaultSystemAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDefaultSystemAdmin.t.Fatal("No results are set for the ServiceMock.GetDefaultSystemAdmin")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetDefaultSystemAdmin.funcGetDefaultSystemAdmin != nil {
		return mmGetDefaultSystemAdmin.funcGetDefaultSystemAdmin(ctx, gp1)
	}
	mmGetDefaultSystemAdmin.t.Fatalf("Unexpected call to ServiceMock.GetDefaultSystemAdmin. %v %v", ctx, gp1)
	return
}

// GetDefaultSystemAdminAfterCounter returns a count of finished ServiceMock.GetDefaultSystemAdmin invocations
func (mmGetDefaultSystemAdmin *ServiceMock) GetDefaultSystemAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDefaultSystemAdmin.afterGetDefaultSystemAdminCounter)
}

// GetDefaultSystemAdminBeforeCounter returns a count of ServiceMock.GetDefaultSystemAdmin invocations
func (mmGetDefaultSystemAdmin *ServiceMock) GetDefaultSystemAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDefaultSystemAdmin.beforeGetDefaultSystemAdminCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetDefaultSystemAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetDefaultSystemAdmin *mServiceMockGetDefaultSystemAdmin) Calls() []*ServiceMockGetDefaultSystemAdminParams {
	mmGetDefaultSystemAdmin.mutex.RLock()

	argCopy := make([]*ServiceMockGetDefaultSystemAdminParams, len(mmGetDefaultSystemAdmin.callArgs))
	copy(argCopy, mmGetDefaultSystemAdmin.callArgs)

	mmGetDefaultSystemAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockGetDefaultSystemAdminDone returns true if the count of the GetDefaultSystemAdmin invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetDefaultSystemAdminDone() bool {
	if m.GetDefaultSystemAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetDefaultSystemAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetDefaultSystemAdminMock.invocationsDone()
}

// MinimockGetDefaultSystemAdminInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetDefaultSystemAdminInspect() {
	for _, e := range m.GetDefaultSystemAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetDefaultSystemAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetDefaultSystemAdminCounter := mm_atomic.LoadUint64(&m.afterGetDefaultSystemAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetDefaultSystemAdminMock.defaultExpectation != nil && afterGetDefaultSystemAdminCounter < 1 {
		if m.GetDefaultSystemAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetDefaultSystemAdmin at\n%s", m.GetDefaultSystemAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetDefaultSystemAdmin at\n%s with params: %#v", m.GetDefaultSystemAdminMock.defaultExpectation.expectationOrigins.origin, *m.GetDefaultSystemAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDefaultSystemAdmin != nil && afterGetDefaultSystemAdminCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetDefaultSystemAdmin at\n%s", m.funcGetDefaultSystemAdminOrigin)
	}

	if !m.GetDefaultSystemAdminMock.invocationsDone() && afterGetDefaultSystemAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetDefaultSystemAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetDefaultSystemAdminMock.expectedInvocations), m.GetDefaultSystemAdminMock.expectedInvocationsOrigin, afterGetDefaultSystemAdminCounter)
	}
}

type mServiceMockGetDownloadURL struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetDownloadURLExpectation
	expectations       []*ServiceMockGetDownloadURLExpectation

	callArgs []*ServiceMockGetDownloadURLParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetDownloadURLExpectation specifies expectation struct of the Service.GetDownloadURL
type ServiceMockGetDownloadURLExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetDownloadURLParams
	paramPtrs          *ServiceMockGetDownloadURLParamPtrs
	expectationOrigins ServiceMockGetDownloadURLExpectationOrigins
	results            *ServiceMockGetDownloadURLResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetDownloadURLParams contains parameters of the Service.GetDownloadURL
type ServiceMockGetDownloadURLParams struct {
	ctx context.Context
	gp1 *artifactpb.GetObjectDownloadURLRequest
	n1  types.NamespaceUIDType
	s1  string
}

// ServiceMockGetDownloadURLParamPtrs contains pointers to parameters of the Service.GetDownloadURL
type ServiceMockGetDownloadURLParamPtrs struct {
	ctx *context.Context
	gp1 **artifactpb.GetObjectDownloadURLRequest
	n1  *types.NamespaceUIDType
	s1  *string
}

// ServiceMockGetDownloadURLResults contains results of the Service.GetDownloadURL
type ServiceMockGetDownloadURLResults struct {
	gp2 *artifactpb.GetObjectDownloadURLResponse
	err error
}

// ServiceMockGetDownloadURLOrigins contains origins of expectations of the Service.GetDownloadURL
type ServiceMockGetDownloadURLExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
	originN1  string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetDownloadURL *mServiceMockGetDownloadURL) Optional() *mServiceMockGetDownloadURL {
	mmGetDownloadURL.optional = true
	return mmGetDownloadURL
}

// Expect sets up expected params for Service.GetDownloadURL
func (mmGetDownloadURL *mServiceMockGetDownloadURL) Expect(ctx context.Context, gp1 *artifactpb.GetObjectDownloadURLRequest, n1 types.NamespaceUIDType, s1 string) *mServiceMockGetDownloadURL {
	if mmGetDownloadURL.mock.funcGetDownloadURL != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Set")
	}

	if mmGetDownloadURL.defaultExpectation == nil {
		mmGetDownloadURL.defaultExpectation = &ServiceMockGetDownloadURLExpectation{}
	}

	if mmGetDownloadURL.defaultExpectation.paramPtrs != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by ExpectParams functions")
	}

	mmGetDownloadURL.defaultExpectation.params = &ServiceMockGetDownloadURLParams{ctx, gp1, n1, s1}
	mmGetDownloadURL.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetDownloadURL.expectations {
		if minimock.Equal(e.params, mmGetDownloadURL.defaultExpectation.params) {
			mmGetDownloadURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetDownloadURL.defaultExpectation.params)
		}
	}

	return mmGetDownloadURL
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetDownloadURL
func (mmGetDownloadURL *mServiceMockGetDownloadURL) ExpectCtxParam1(ctx context.Context) *mServiceMockGetDownloadURL {
	if mmGetDownloadURL.mock.funcGetDownloadURL != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Set")
	}

	if mmGetDownloadURL.defaultExpectation == nil {
		mmGetDownloadURL.defaultExpectation = &ServiceMockGetDownloadURLExpectation{}
	}

	if mmGetDownloadURL.defaultExpectation.params != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Expect")
	}

	if mmGetDownloadURL.defaultExpectation.paramPtrs == nil {
		mmGetDownloadURL.defaultExpectation.paramPtrs = &ServiceMockGetDownloadURLParamPtrs{}
	}
	mmGetDownloadURL.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetDownloadURL.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetDownloadURL
}

// ExpectGp1Param2 sets up expected param gp1 for Service.GetDownloadURL
func (mmGetDownloadURL *mServiceMockGetDownloadURL) ExpectGp1Param2(gp1 *artifactpb.GetObjectDownloadURLRequest) *mServiceMockGetDownloadURL {
	if mmGetDownloadURL.mock.funcGetDownloadURL != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Set")
	}

	if mmGetDownloadURL.defaultExpectation == nil {
		mmGetDownloadURL.defaultExpectation = &ServiceMockGetDownloadURLExpectation{}
	}

	if mmGetDownloadURL.defaultExpectation.params != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Expect")
	}

	if mmGetDownloadURL.defaultExpectation.paramPtrs == nil {
		mmGetDownloadURL.defaultExpectation.paramPtrs = &ServiceMockGetDownloadURLParamPtrs{}
	}
	mmGetDownloadURL.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetDownloadURL.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetDownloadURL
}

// ExpectN1Param3 sets up expected param n1 for Service.GetDownloadURL
func (mmGetDownloadURL *mServiceMockGetDownloadURL) ExpectN1Param3(n1 types.NamespaceUIDType) *mServiceMockGetDownloadURL {
	if mmGetDownloadURL.mock.funcGetDownloadURL != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Set")
	}

	if mmGetDownloadURL.defaultExpectation == nil {
		mmGetDownloadURL.defaultExpectation = &ServiceMockGetDownloadURLExpectation{}
	}

	if mmGetDownloadURL.defaultExpectation.params != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Expect")
	}

	if mmGetDownloadURL.defaultExpectation.paramPtrs == nil {
		mmGetDownloadURL.defaultExpectation.paramPtrs = &ServiceMockGetDownloadURLParamPtrs{}
	}
	mmGetDownloadURL.defaultExpectation.paramPtrs.n1 = &n1
	mmGetDownloadURL.defaultExpectation.expectationOrigins.originN1 = minimock.CallerInfo(1)

	return mmGetDownloadURL
}

// ExpectS1Param4 sets up expected param s1 for Service.GetDownloadURL
func (mmGetDownloadURL *mServiceMockGetDownloadURL) ExpectS1Param4(s1 string) *mServiceMockGetDownloadURL {
	if mmGetDownloadURL.mock.funcGetDownloadURL != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Set")
	}

	if mmGetDownloadURL.defaultExpectation == nil {
		mmGetDownloadURL.defaultExpectation = &ServiceMockGetDownloadURLExpectation{}
	}

	if mmGetDownloadURL.defaultExpectation.params != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Expect")
	}

	if mmGetDownloadURL.defaultExpectation.paramPtrs == nil {
		mmGetDownloadURL.defaultExpectation.paramPtrs = &ServiceMockGetDownloadURLParamPtrs{}
	}
	mmGetDownloadURL.defaultExpectation.paramPtrs.s1 = &s1
	mmGetDownloadURL.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmGetDownloadURL
}

// Inspect accepts an inspector function that has same arguments as the Service.GetDownloadURL
func (mmGetDownloadURL *mServiceMockGetDownloadURL) Inspect(f func(ctx context.Context, gp1 *artifactpb.GetObjectDownloadURLRequest, n1 types.NamespaceUIDType, s1 string)) *mServiceMockGetDownloadURL {
	if mmGetDownloadURL.mock.inspectFuncGetDownloadURL != nil {
		mmGetDownloadURL.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetDownloadURL")
	}

	mmGetDownloadURL.mock.inspectFuncGetDownloadURL = f

	return mmGetDownloadURL
}

// Return sets up results that will be returned by Service.GetDownloadURL
func (mmGetDownloadURL *mServiceMockGetDownloadURL) Return(gp2 *artifactpb.GetObjectDownloadURLResponse, err error) *ServiceMock {
	if mmGetDownloadURL.mock.funcGetDownloadURL != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Set")
	}

	if mmGetDownloadURL.defaultExpectation == nil {
		mmGetDownloadURL.defaultExpectation = &ServiceMockGetDownloadURLExpectation{mock: mmGetDownloadURL.mock}
	}
	mmGetDownloadURL.defaultExpectation.results = &ServiceMockGetDownloadURLResults{gp2, err}
	mmGetDownloadURL.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetDownloadURL.mock
}

// Set uses given function f to mock the Service.GetDownloadURL method
func (mmGetDownloadURL *mServiceMockGetDownloadURL) Set(f func(ctx context.Context, gp1 *artifactpb.GetObjectDownloadURLRequest, n1 types.NamespaceUIDType, s1 string) (gp2 *artifactpb.GetObjectDownloadURLResponse, err error)) *ServiceMock {
	if mmGetDownloadURL.defaultExpectation != nil {
		mmGetDownloadURL.mock.t.Fatalf("Default expectation is already set for the Service.GetDownloadURL method")
	}

	if len(mmGetDownloadURL.expectations) > 0 {
		mmGetDownloadURL.mock.t.Fatalf("Some expectations are already set for the Service.GetDownloadURL method")
	}

	mmGetDownloadURL.mock.funcGetDownloadURL = f
	mmGetDownloadURL.mock.funcGetDownloadURLOrigin = minimock.CallerInfo(1)
	return mmGetDownloadURL.mock
}

// When sets expectation for the Service.GetDownloadURL which will trigger the result defined by the following
// Then helper
func (mmGetDownloadURL *mServiceMockGetDownloadURL) When(ctx context.Context, gp1 *artifactpb.GetObjectDownloadURLRequest, n1 types.NamespaceUIDType, s1 string) *ServiceMockGetDownloadURLExpectation {
	if mmGetDownloadURL.mock.funcGetDownloadURL != nil {
		mmGetDownloadURL.mock.t.Fatalf("ServiceMock.GetDownloadURL mock is already set by Set")
	}

	expectation := &ServiceMockGetDownloadURLExpectation{
		mock:               mmGetDownloadURL.mock,
		params:             &ServiceMockGetDownloadURLParams{ctx, gp1, n1, s1},
		expectationOrigins: ServiceMockGetDownloadURLExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetDownloadURL.expectations = append(mmGetDownloadURL.expectations, expectation)
	return expectation
}

// Then sets up Service.GetDownloadURL return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetDownloadURLExpectation) Then(gp2 *artifactpb.GetObjectDownloadURLResponse, err error) *ServiceMock {
	e.results = &ServiceMockGetDownloadURLResults{gp2, err}
	return e.mock
}

// Times sets number of times Service.GetDownloadURL should be invoked
func (mmGetDownloadURL *mServiceMockGetDownloadURL) Times(n uint64) *mServiceMockGetDownloadURL {
	if n == 0 {
		mmGetDownloadURL.mock.t.Fatalf("Times of ServiceMock.GetDownloadURL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetDownloadURL.expectedInvocations, n)
	mmGetDownloadURL.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetDownloadURL
}

func (mmGetDownloadURL *mServiceMockGetDownloadURL) invocationsDone() bool {
	if len(mmGetDownloadURL.expectations) == 0 && mmGetDownloadURL.defaultExpectation == nil && mmGetDownloadURL.mock.funcGetDownloadURL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetDownloadURL.mock.afterGetDownloadURLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetDownloadURL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetDownloadURL implements mm_service.Service
func (mmGetDownloadURL *ServiceMock) GetDownloadURL(ctx context.Context, gp1 *artifactpb.GetObjectDownloadURLRequest, n1 types.NamespaceUIDType, s1 string) (gp2 *artifactpb.GetObjectDownloadURLResponse, err error) {
	mm_atomic.AddUint64(&mmGetDownloadURL.beforeGetDownloadURLCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDownloadURL.afterGetDownloadURLCounter, 1)

	mmGetDownloadURL.t.Helper()

	if mmGetDownloadURL.inspectFuncGetDownloadURL != nil {
		mmGetDownloadURL.inspectFuncGetDownloadURL(ctx, gp1, n1, s1)
	}

	mm_params := ServiceMockGetDownloadURLParams{ctx, gp1, n1, s1}

	// Record call args
	mmGetDownloadURL.GetDownloadURLMock.mutex.Lock()
	mmGetDownloadURL.GetDownloadURLMock.callArgs = append(mmGetDownloadURL.GetDownloadURLMock.callArgs, &mm_params)
	mmGetDownloadURL.GetDownloadURLMock.mutex.Unlock()

	for _, e := range mmGetDownloadURL.GetDownloadURLMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetDownloadURL.GetDownloadURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDownloadURL.GetDownloadURLMock.defaultExpectation.Counter, 1)
		mm_want := mmGetDownloadURL.GetDownloadURLMock.defaultExpectation.params
		mm_want_ptrs := mmGetDownloadURL.GetDownloadURLMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetDownloadURLParams{ctx, gp1, n1, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetDownloadURL.t.Errorf("ServiceMock.GetDownloadURL got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetDownloadURL.GetDownloadURLMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetDownloadURL.t.Errorf("ServiceMock.GetDownloadURL got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetDownloadURL.GetDownloadURLMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

			if mm_want_ptrs.n1 != nil && !minimock.Equal(*mm_want_ptrs.n1, mm_got.n1) {
				mmGetDownloadURL.t.Errorf("ServiceMock.GetDownloadURL got unexpected parameter n1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetDownloadURL.GetDownloadURLMock.defaultExpectation.expectationOrigins.originN1, *mm_want_ptrs.n1, mm_got.n1, minimock.Diff(*mm_want_ptrs.n1, mm_got.n1))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmGetDownloadURL.t.Errorf("ServiceMock.GetDownloadURL got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetDownloadURL.GetDownloadURLMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetDownloadURL.t.Errorf("ServiceMock.GetDownloadURL got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetDownloadURL.GetDownloadURLMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetDownloadURL.GetDownloadURLMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDownloadURL.t.Fatal("No results are set for the ServiceMock.GetDownloadURL")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetDownloadURL.funcGetDownloadURL != nil {
		return mmGetDownloadURL.funcGetDownloadURL(ctx, gp1, n1, s1)
	}
	mmGetDownloadURL.t.Fatalf("Unexpected call to ServiceMock.GetDownloadURL. %v %v %v %v", ctx, gp1, n1, s1)
	return
}

// GetDownloadURLAfterCounter returns a count of finished ServiceMock.GetDownloadURL invocations
func (mmGetDownloadURL *ServiceMock) GetDownloadURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDownloadURL.afterGetDownloadURLCounter)
}

// GetDownloadURLBeforeCounter returns a count of ServiceMock.GetDownloadURL invocations
func (mmGetDownloadURL *ServiceMock) GetDownloadURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDownloadURL.beforeGetDownloadURLCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetDownloadURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetDownloadURL *mServiceMockGetDownloadURL) Calls() []*ServiceMockGetDownloadURLParams {
	mmGetDownloadURL.mutex.RLock()

	argCopy := make([]*ServiceMockGetDownloadURLParams, len(mmGetDownloadURL.callArgs))
	copy(argCopy, mmGetDownloadURL.callArgs)

	mmGetDownloadURL.mutex.RUnlock()

	return argCopy
}

// MinimockGetDownloadURLDone returns true if the count of the GetDownloadURL invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetDownloadURLDone() bool {
	if m.GetDownloadURLMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetDownloadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetDownloadURLMock.invocationsDone()
}

// MinimockGetDownloadURLInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetDownloadURLInspect() {
	for _, e := range m.GetDownloadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetDownloadURL at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetDownloadURLCounter := mm_atomic.LoadUint64(&m.afterGetDownloadURLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetDownloadURLMock.defaultExpectation != nil && afterGetDownloadURLCounter < 1 {
		if m.GetDownloadURLMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetDownloadURL at\n%s", m.GetDownloadURLMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetDownloadURL at\n%s with params: %#v", m.GetDownloadURLMock.defaultExpectation.expectationOrigins.origin, *m.GetDownloadURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDownloadURL != nil && afterGetDownloadURLCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetDownloadURL at\n%s", m.funcGetDownloadURLOrigin)
	}

	if !m.GetDownloadURLMock.invocationsDone() && afterGetDownloadURLCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetDownloadURL at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetDownloadURLMock.expectedInvocations), m.GetDownloadURLMock.expectedInvocationsOrigin, afterGetDownloadURLCounter)
	}
}

type mServiceMockGetFilesByPaths struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetFilesByPathsExpectation
	expectations       []*ServiceMockGetFilesByPathsExpectation

	callArgs []*ServiceMockGetFilesByPathsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetFilesByPathsExpectation specifies expectation struct of the Service.GetFilesByPaths
type ServiceMockGetFilesByPathsExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetFilesByPathsParams
	paramPtrs          *ServiceMockGetFilesByPathsParamPtrs
	expectationOrigins ServiceMockGetFilesByPathsExpectationOrigins
	results            *ServiceMockGetFilesByPathsResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetFilesByPathsParams contains parameters of the Service.GetFilesByPaths
type ServiceMockGetFilesByPathsParams struct {
	ctx context.Context
	s1  string
	sa1 []string
}

// ServiceMockGetFilesByPathsParamPtrs contains pointers to parameters of the Service.GetFilesByPaths
type ServiceMockGetFilesByPathsParamPtrs struct {
	ctx *context.Context
	s1  *string
	sa1 *[]string
}

// ServiceMockGetFilesByPathsResults contains results of the Service.GetFilesByPaths
type ServiceMockGetFilesByPathsResults struct {
	fa1 []mm_service.FileContent
	err error
}

// ServiceMockGetFilesByPathsOrigins contains origins of expectations of the Service.GetFilesByPaths
type ServiceMockGetFilesByPathsExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
	originSa1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) Optional() *mServiceMockGetFilesByPaths {
	mmGetFilesByPaths.optional = true
	return mmGetFilesByPaths
}

// Expect sets up expected params for Service.GetFilesByPaths
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) Expect(ctx context.Context, s1 string, sa1 []string) *mServiceMockGetFilesByPaths {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by Set")
	}

	if mmGetFilesByPaths.defaultExpectation == nil {
		mmGetFilesByPaths.defaultExpectation = &ServiceMockGetFilesByPathsExpectation{}
	}

	if mmGetFilesByPaths.defaultExpectation.paramPtrs != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by ExpectParams functions")
	}

	mmGetFilesByPaths.defaultExpectation.params = &ServiceMockGetFilesByPathsParams{ctx, s1, sa1}
	mmGetFilesByPaths.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetFilesByPaths.expectations {
		if minimock.Equal(e.params, mmGetFilesByPaths.defaultExpectation.params) {
			mmGetFilesByPaths.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFilesByPaths.defaultExpectation.params)
		}
	}

	return mmGetFilesByPaths
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetFilesByPaths
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) ExpectCtxParam1(ctx context.Context) *mServiceMockGetFilesByPaths {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by Set")
	}

	if mmGetFilesByPaths.defaultExpectation == nil {
		mmGetFilesByPaths.defaultExpectation = &ServiceMockGetFilesByPathsExpectation{}
	}

	if mmGetFilesByPaths.defaultExpectation.params != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by Expect")
	}

	if mmGetFilesByPaths.defaultExpectation.paramPtrs == nil {
		mmGetFilesByPaths.defaultExpectation.paramPtrs = &ServiceMockGetFilesByPathsParamPtrs{}
	}
	mmGetFilesByPaths.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetFilesByPaths.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetFilesByPaths
}

// ExpectS1Param2 sets up expected param s1 for Service.GetFilesByPaths
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) ExpectS1Param2(s1 string) *mServiceMockGetFilesByPaths {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by Set")
	}

	if mmGetFilesByPaths.defaultExpectation == nil {
		mmGetFilesByPaths.defaultExpectation = &ServiceMockGetFilesByPathsExpectation{}
	}

	if mmGetFilesByPaths.defaultExpectation.params != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by Expect")
	}

	if mmGetFilesByPaths.defaultExpectation.paramPtrs == nil {
		mmGetFilesByPaths.defaultExpectation.paramPtrs = &ServiceMockGetFilesByPathsParamPtrs{}
	}
	mmGetFilesByPaths.defaultExpectation.paramPtrs.s1 = &s1
	mmGetFilesByPaths.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmGetFilesByPaths
}

// ExpectSa1Param3 sets up expected param sa1 for Service.GetFilesByPaths
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) ExpectSa1Param3(sa1 []string) *mServiceMockGetFilesByPaths {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by Set")
	}

	if mmGetFilesByPaths.defaultExpectation == nil {
		mmGetFilesByPaths.defaultExpectation = &ServiceMockGetFilesByPathsExpectation{}
	}

	if mmGetFilesByPaths.defaultExpectation.params != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by Expect")
	}

	if mmGetFilesByPaths.defaultExpectation.paramPtrs == nil {
		mmGetFilesByPaths.defaultExpectation.paramPtrs = &ServiceMockGetFilesByPathsParamPtrs{}
	}
	mmGetFilesByPaths.defaultExpectation.paramPtrs.sa1 = &sa1
	mmGetFilesByPaths.defaultExpectation.expectationOrigins.originSa1 = minimock.CallerInfo(1)

	return mmGetFilesByPaths
}

// Inspect accepts an inspector function that has same arguments as the Service.GetFilesByPaths
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) Inspect(f func(ctx context.Context, s1 string, sa1 []string)) *mServiceMockGetFilesByPaths {
	if mmGetFilesByPaths.mock.inspectFuncGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetFilesByPaths")
	}

	mmGetFilesByPaths.mock.inspectFuncGetFilesByPaths = f

	return mmGetFilesByPaths
}

// Return sets up results that will be returned by Service.GetFilesByPaths
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) Return(fa1 []mm_service.FileContent, err error) *ServiceMock {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by Set")
	}

	if mmGetFilesByPaths.defaultExpectation == nil {
		mmGetFilesByPaths.defaultExpectation = &ServiceMockGetFilesByPathsExpectation{mock: mmGetFilesByPaths.mock}
	}
	mmGetFilesByPaths.defaultExpectation.results = &ServiceMockGetFilesByPathsResults{fa1, err}
	mmGetFilesByPaths.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetFilesByPaths.mock
}

// Set uses given function f to mock the Service.GetFilesByPaths method
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) Set(f func(ctx context.Context, s1 string, sa1 []string) (fa1 []mm_service.FileContent, err error)) *ServiceMock {
	if mmGetFilesByPaths.defaultExpectation != nil {
		mmGetFilesByPaths.mock.t.Fatalf("Default expectation is already set for the Service.GetFilesByPaths method")
	}

	if len(mmGetFilesByPaths.expectations) > 0 {
		mmGetFilesByPaths.mock.t.Fatalf("Some expectations are already set for the Service.GetFilesByPaths method")
	}

	mmGetFilesByPaths.mock.funcGetFilesByPaths = f
	mmGetFilesByPaths.mock.funcGetFilesByPathsOrigin = minimock.CallerInfo(1)
	return mmGetFilesByPaths.mock
}

// When sets expectation for the Service.GetFilesByPaths which will trigger the result defined by the following
// Then helper
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) When(ctx context.Context, s1 string, sa1 []string) *ServiceMockGetFilesByPathsExpectation {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("ServiceMock.GetFilesByPaths mock is already set by Set")
	}

	expectation := &ServiceMockGetFilesByPathsExpectation{
		mock:               mmGetFilesByPaths.mock,
		params:             &ServiceMockGetFilesByPathsParams{ctx, s1, sa1},
		expectationOrigins: ServiceMockGetFilesByPathsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetFilesByPaths.expectations = append(mmGetFilesByPaths.expectations, expectation)
	return expectation
}

// Then sets up Service.GetFilesByPaths return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetFilesByPathsExpectation) Then(fa1 []mm_service.FileContent, err error) *ServiceMock {
	e.results = &ServiceMockGetFilesByPathsResults{fa1, err}
	return e.mock
}

// Times sets number of times Service.GetFilesByPaths should be invoked
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) Times(n uint64) *mServiceMockGetFilesByPaths {
	if n == 0 {
		mmGetFilesByPaths.mock.t.Fatalf("Times of ServiceMock.GetFilesByPaths mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFilesByPaths.expectedInvocations, n)
	mmGetFilesByPaths.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetFilesByPaths
}

func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) invocationsDone() bool {
	if len(mmGetFilesByPaths.expectations) == 0 && mmGetFilesByPaths.defaultExpectation == nil && mmGetFilesByPaths.mock.funcGetFilesByPaths == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFilesByPaths.mock.afterGetFilesByPathsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFilesByPaths.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFilesByPaths implements mm_service.Service
func (mmGetFilesByPaths *ServiceMock) GetFilesByPaths(ctx context.Context, s1 string, sa1 []string) (fa1 []mm_service.FileContent, err error) {
	mm_atomic.AddUint64(&mmGetFilesByPaths.beforeGetFilesByPathsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFilesByPaths.afterGetFilesByPathsCounter, 1)

	mmGetFilesByPaths.t.Helper()

	if mmGetFilesByPaths.inspectFuncGetFilesByPaths != nil {
		mmGetFilesByPaths.inspectFuncGetFilesByPaths(ctx, s1, sa1)
	}

	mm_params := ServiceMockGetFilesByPathsParams{ctx, s1, sa1}

	// Record call args
	mmGetFilesByPaths.GetFilesByPathsMock.mutex.Lock()
	mmGetFilesByPaths.GetFilesByPathsMock.callArgs = append(mmGetFilesByPaths.GetFilesByPathsMock.callArgs, &mm_params)
	mmGetFilesByPaths.GetFilesByPathsMock.mutex.Unlock()

	for _, e := range mmGetFilesByPaths.GetFilesByPathsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.fa1, e.results.err
		}
	}

	if mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.params
		mm_want_ptrs := mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetFilesByPathsParams{ctx, s1, sa1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFilesByPaths.t.Errorf("ServiceMock.GetFilesByPaths got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmGetFilesByPaths.t.Errorf("ServiceMock.GetFilesByPaths got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

			if mm_want_ptrs.sa1 != nil && !minimock.Equal(*mm_want_ptrs.sa1, mm_got.sa1) {
				mmGetFilesByPaths.t.Errorf("ServiceMock.GetFilesByPaths got unexpected parameter sa1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.expectationOrigins.originSa1, *mm_want_ptrs.sa1, mm_got.sa1, minimock.Diff(*mm_want_ptrs.sa1, mm_got.sa1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFilesByPaths.t.Errorf("ServiceMock.GetFilesByPaths got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFilesByPaths.t.Fatal("No results are set for the ServiceMock.GetFilesByPaths")
		}
		return (*mm_results).fa1, (*mm_results).err
	}
	if mmGetFilesByPaths.funcGetFilesByPaths != nil {
		return mmGetFilesByPaths.funcGetFilesByPaths(ctx, s1, sa1)
	}
	mmGetFilesByPaths.t.Fatalf("Unexpected call to ServiceMock.GetFilesByPaths. %v %v %v", ctx, s1, sa1)
	return
}

// GetFilesByPathsAfterCounter returns a count of finished ServiceMock.GetFilesByPaths invocations
func (mmGetFilesByPaths *ServiceMock) GetFilesByPathsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFilesByPaths.afterGetFilesByPathsCounter)
}

// GetFilesByPathsBeforeCounter returns a count of ServiceMock.GetFilesByPaths invocations
func (mmGetFilesByPaths *ServiceMock) GetFilesByPathsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFilesByPaths.beforeGetFilesByPathsCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetFilesByPaths.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFilesByPaths *mServiceMockGetFilesByPaths) Calls() []*ServiceMockGetFilesByPathsParams {
	mmGetFilesByPaths.mutex.RLock()

	argCopy := make([]*ServiceMockGetFilesByPathsParams, len(mmGetFilesByPaths.callArgs))
	copy(argCopy, mmGetFilesByPaths.callArgs)

	mmGetFilesByPaths.mutex.RUnlock()

	return argCopy
}

// MinimockGetFilesByPathsDone returns true if the count of the GetFilesByPaths invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetFilesByPathsDone() bool {
	if m.GetFilesByPathsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFilesByPathsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFilesByPathsMock.invocationsDone()
}

// MinimockGetFilesByPathsInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetFilesByPathsInspect() {
	for _, e := range m.GetFilesByPathsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetFilesByPaths at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetFilesByPathsCounter := mm_atomic.LoadUint64(&m.afterGetFilesByPathsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFilesByPathsMock.defaultExpectation != nil && afterGetFilesByPathsCounter < 1 {
		if m.GetFilesByPathsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetFilesByPaths at\n%s", m.GetFilesByPathsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetFilesByPaths at\n%s with params: %#v", m.GetFilesByPathsMock.defaultExpectation.expectationOrigins.origin, *m.GetFilesByPathsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFilesByPaths != nil && afterGetFilesByPathsCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetFilesByPaths at\n%s", m.funcGetFilesByPathsOrigin)
	}

	if !m.GetFilesByPathsMock.invocationsDone() && afterGetFilesByPathsCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetFilesByPaths at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetFilesByPathsMock.expectedInvocations), m.GetFilesByPathsMock.expectedInvocationsOrigin, afterGetFilesByPathsCounter)
	}
}

type mServiceMockGetKnowledgeBaseUpdateStatusAdmin struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetKnowledgeBaseUpdateStatusAdminExpectation
	expectations       []*ServiceMockGetKnowledgeBaseUpdateStatusAdminExpectation

	callArgs []*ServiceMockGetKnowledgeBaseUpdateStatusAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetKnowledgeBaseUpdateStatusAdminExpectation specifies expectation struct of the Service.GetKnowledgeBaseUpdateStatusAdmin
type ServiceMockGetKnowledgeBaseUpdateStatusAdminExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetKnowledgeBaseUpdateStatusAdminParams
	paramPtrs          *ServiceMockGetKnowledgeBaseUpdateStatusAdminParamPtrs
	expectationOrigins ServiceMockGetKnowledgeBaseUpdateStatusAdminExpectationOrigins
	results            *ServiceMockGetKnowledgeBaseUpdateStatusAdminResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetKnowledgeBaseUpdateStatusAdminParams contains parameters of the Service.GetKnowledgeBaseUpdateStatusAdmin
type ServiceMockGetKnowledgeBaseUpdateStatusAdminParams struct {
	ctx context.Context
}

// ServiceMockGetKnowledgeBaseUpdateStatusAdminParamPtrs contains pointers to parameters of the Service.GetKnowledgeBaseUpdateStatusAdmin
type ServiceMockGetKnowledgeBaseUpdateStatusAdminParamPtrs struct {
	ctx *context.Context
}

// ServiceMockGetKnowledgeBaseUpdateStatusAdminResults contains results of the Service.GetKnowledgeBaseUpdateStatusAdmin
type ServiceMockGetKnowledgeBaseUpdateStatusAdminResults struct {
	gp1 *artifactpb.GetKnowledgeBaseUpdateStatusAdminResponse
	err error
}

// ServiceMockGetKnowledgeBaseUpdateStatusAdminOrigins contains origins of expectations of the Service.GetKnowledgeBaseUpdateStatusAdmin
type ServiceMockGetKnowledgeBaseUpdateStatusAdminExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetKnowledgeBaseUpdateStatusAdmin *mServiceMockGetKnowledgeBaseUpdateStatusAdmin) Optional() *mServiceMockGetKnowledgeBaseUpdateStatusAdmin {
	mmGetKnowledgeBaseUpdateStatusAdmin.optional = true
	return mmGetKnowledgeBaseUpdateStatusAdmin
}

// Expect sets up expected params for Service.GetKnowledgeBaseUpdateStatusAdmin
func (mmGetKnowledgeBaseUpdateStatusAdmin *mServiceMockGetKnowledgeBaseUpdateStatusAdmin) Expect(ctx context.Context) *mServiceMockGetKnowledgeBaseUpdateStatusAdmin {
	if mmGetKnowledgeBaseUpdateStatusAdmin.mock.funcGetKnowledgeBaseUpdateStatusAdmin != nil {
		mmGetKnowledgeBaseUpdateStatusAdmin.mock.t.Fatalf("ServiceMock.GetKnowledgeBaseUpdateStatusAdmin mock is already set by Set")
	}

	if mmGetKnowledgeBaseUpdateStatusAdmin.defaultExpectation == nil {
		mmGetKnowledgeBaseUpdateStatusAdmin.defaultExpectation = &ServiceMockGetKnowledgeBaseUpdateStatusAdminExpectation{}
	}

	if mmGetKnowledgeBaseUpdateStatusAdmin.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBaseUpdateStatusAdmin.mock.t.Fatalf("ServiceMock.GetKnowledgeBaseUpdateStatusAdmin mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBaseUpdateStatusAdmin.defaultExpectation.params = &ServiceMockGetKnowledgeBaseUpdateStatusAdminParams{ctx}
	mmGetKnowledgeBaseUpdateStatusAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetKnowledgeBaseUpdateStatusAdmin.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBaseUpdateStatusAdmin.defaultExpectation.params) {
			mmGetKnowledgeBaseUpdateStatusAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBaseUpdateStatusAdmin.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBaseUpdateStatusAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetKnowledgeBaseUpdateStatusAdmin
func (mmGetKnowledgeBaseUpdateStatusAdmin *mServiceMockGetKnowledgeBaseUpdateStatusAdmin) ExpectCtxParam1(ctx context.Context) *mServiceMockGetKnowledgeBaseUpdateStatusAdmin {
	if mmGetKnowledgeBaseUpdateStatusAdmin.mock.funcGetKnowledgeBaseUpdateStatusAdmin != nil {
		mmGetKnowledgeBaseUpdateStatusAdmin.mock.t.Fatalf("ServiceMock.GetKnowledgeBaseUpdateStatusAdmin mock is already set by Set")
	}

	if mmGetKnowledgeBaseUpdateStatusAdmin.defaultExpectation == nil {
		mmGetKnowledgeBaseUpdateStatusAdmin.defaultExpectation = &ServiceMockGetKnowledgeBaseUpdateStatusAdminExpectation{}
	}

	if mmGetKnowledgeBaseUpdateStatusAdmin.defaultExpectation.params != nil {
		mmGetKnowledgeBaseUpdateStatusAdmin.mock.t.Fatalf("ServiceMock.GetKnowledgeBaseUpdateStatusAdmin mock is already set by Expect")
	}

	if mmGetKnowledgeBaseUpdateStatusAdmin.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseUpdateStatusAdmin.defaultExpectation.paramPtrs = &ServiceMockGetKnowledgeBaseUpdateStatusAdminParamPtrs{}
	}
	mmGetKnowledgeBaseUpdateStatusAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetKnowledgeBaseUpdateStatusAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseUpdateStatusAdmin
}

// Inspect accepts an inspector function that has same arguments as the Service.GetKnowledgeBaseUpdateStatusAdmin
func (mmGetKnowledgeBaseUpdateStatusAdmin *mServiceMockGetKnowledgeBaseUpdateStatusAdmin) Inspect(f func(ctx context.Context)) *mServiceMockGetKnowledgeBaseUpdateStatusAdmin {
	if mmGetKnowledgeBaseUpdateStatusAdmin.mock.inspectFuncGetKnowledgeBaseUpdateStatusAdmin != nil {
		mmGetKnowledgeBaseUpdateStatusAdmin.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetKnowledgeBaseUpdateStatusAdmin")
	}

	mmGetKnowledgeBaseUpdateStatusAdmin.mock.inspectFuncGetKnowledgeBaseUpdateStatusAdmin = f

	return mmGetKnowledgeBaseUpdateStatusAdmin
}

// Return sets up results that will be returned by Service.GetKnowledgeBaseUpdateStatusAdmin
func (mmGetKnowledgeBaseUpdateStatusAdmin *mServiceMockGetKnowledgeBaseUpdateStatusAdmin) Return(gp1 *artifactpb.GetKnowledgeBaseUpdateStatusAdminResponse, err error) *ServiceMock {
	if mmGetKnowledgeBaseUpdateStatusAdmin.mock.funcGetKnowledgeBaseUpdateStatusAdmin != nil {
		mmGetKnowledgeBaseUpdateStatusAdmin.mock.t.Fatalf("ServiceMock.GetKnowledgeBaseUpdateStatusAdmin mock is already set by Set")
	}

	if mmGetKnowledgeBaseUpdateStatusAdmin.defaultExpectation == nil {
		mmGetKnowledgeBaseUpdateStatusAdmin.defaultExpectation = &ServiceMockGetKnowledgeBaseUpdateStatusAdminExpectation{mock: mmGetKnowledgeBaseUpdateStatusAdmin.mock}
	}
	mmGetKnowledgeBaseUpdateStatusAdmin.defaultExpectation.results = &ServiceMockGetKnowledgeBaseUpdateStatusAdminResults{gp1, err}
	mmGetKnowledgeBaseUpdateStatusAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseUpdateStatusAdmin.mock
}

// Set uses given function f to mock the Service.GetKnowledgeBaseUpdateStatusAdmin method
func (mmGetKnowledgeBaseUpdateStatusAdmin *mServiceMockGetKnowledgeBaseUpdateStatusAdmin) Set(f func(ctx context.Context) (gp1 *artifactpb.GetKnowledgeBaseUpdateStatusAdminResponse, err error)) *ServiceMock {
	if mmGetKnowledgeBaseUpdateStatusAdmin.defaultExpectation != nil {
		mmGetKnowledgeBaseUpdateStatusAdmin.mock.t.Fatalf("Default expectation is already set for the Service.GetKnowledgeBaseUpdateStatusAdmin method")
	}

	if len(mmGetKnowledgeBaseUpdateStatusAdmin.expectations) > 0 {
		mmGetKnowledgeBaseUpdateStatusAdmin.mock.t.Fatalf("Some expectations are already set for the Service.GetKnowledgeBaseUpdateStatusAdmin method")
	}

	mmGetKnowledgeBaseUpdateStatusAdmin.mock.funcGetKnowledgeBaseUpdateStatusAdmin = f
	mmGetKnowledgeBaseUpdateStatusAdmin.mock.funcGetKnowledgeBaseUpdateStatusAdminOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseUpdateStatusAdmin.mock
}

// When sets expectation for the Service.GetKnowledgeBaseUpdateStatusAdmin which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBaseUpdateStatusAdmin *mServiceMockGetKnowledgeBaseUpdateStatusAdmin) When(ctx context.Context) *ServiceMockGetKnowledgeBaseUpdateStatusAdminExpectation {
	if mmGetKnowledgeBaseUpdateStatusAdmin.mock.funcGetKnowledgeBaseUpdateStatusAdmin != nil {
		mmGetKnowledgeBaseUpdateStatusAdmin.mock.t.Fatalf("ServiceMock.GetKnowledgeBaseUpdateStatusAdmin mock is already set by Set")
	}

	expectation := &ServiceMockGetKnowledgeBaseUpdateStatusAdminExpectation{
		mock:               mmGetKnowledgeBaseUpdateStatusAdmin.mock,
		params:             &ServiceMockGetKnowledgeBaseUpdateStatusAdminParams{ctx},
		expectationOrigins: ServiceMockGetKnowledgeBaseUpdateStatusAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetKnowledgeBaseUpdateStatusAdmin.expectations = append(mmGetKnowledgeBaseUpdateStatusAdmin.expectations, expectation)
	return expectation
}

// Then sets up Service.GetKnowledgeBaseUpdateStatusAdmin return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetKnowledgeBaseUpdateStatusAdminExpectation) Then(gp1 *artifactpb.GetKnowledgeBaseUpdateStatusAdminResponse, err error) *ServiceMock {
	e.results = &ServiceMockGetKnowledgeBaseUpdateStatusAdminResults{gp1, err}
	return e.mock
}

// Times sets number of times Service.GetKnowledgeBaseUpdateStatusAdmin should be invoked
func (mmGetKnowledgeBaseUpdateStatusAdmin *mServiceMockGetKnowledgeBaseUpdateStatusAdmin) Times(n uint64) *mServiceMockGetKnowledgeBaseUpdateStatusAdmin {
	if n == 0 {
		mmGetKnowledgeBaseUpdateStatusAdmin.mock.t.Fatalf("Times of ServiceMock.GetKnowledgeBaseUpdateStatusAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBaseUpdateStatusAdmin.expectedInvocations, n)
	mmGetKnowledgeBaseUpdateStatusAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseUpdateStatusAdmin
}

func (mmGetKnowledgeBaseUpdateStatusAdmin *mServiceMockGetKnowledgeBaseUpdateStatusAdmin) invocationsDone() bool {
	if len(mmGetKnowledgeBaseUpdateStatusAdmin.expectations) == 0 && mmGetKnowledgeBaseUpdateStatusAdmin.defaultExpectation == nil && mmGetKnowledgeBaseUpdateStatusAdmin.mock.funcGetKnowledgeBaseUpdateStatusAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseUpdateStatusAdmin.mock.afterGetKnowledgeBaseUpdateStatusAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseUpdateStatusAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBaseUpdateStatusAdmin implements mm_service.Service
func (mmGetKnowledgeBaseUpdateStatusAdmin *ServiceMock) GetKnowledgeBaseUpdateStatusAdmin(ctx context.Context) (gp1 *artifactpb.GetKnowledgeBaseUpdateStatusAdminResponse, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBaseUpdateStatusAdmin.beforeGetKnowledgeBaseUpdateStatusAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBaseUpdateStatusAdmin.afterGetKnowledgeBaseUpdateStatusAdminCounter, 1)

	mmGetKnowledgeBaseUpdateStatusAdmin.t.Helper()

	if mmGetKnowledgeBaseUpdateStatusAdmin.inspectFuncGetKnowledgeBaseUpdateStatusAdmin != nil {
		mmGetKnowledgeBaseUpdateStatusAdmin.inspectFuncGetKnowledgeBaseUpdateStatusAdmin(ctx)
	}

	mm_params := ServiceMockGetKnowledgeBaseUpdateStatusAdminParams{ctx}

	// Record call args
	mmGetKnowledgeBaseUpdateStatusAdmin.GetKnowledgeBaseUpdateStatusAdminMock.mutex.Lock()
	mmGetKnowledgeBaseUpdateStatusAdmin.GetKnowledgeBaseUpdateStatusAdminMock.callArgs = append(mmGetKnowledgeBaseUpdateStatusAdmin.GetKnowledgeBaseUpdateStatusAdminMock.callArgs, &mm_params)
	mmGetKnowledgeBaseUpdateStatusAdmin.GetKnowledgeBaseUpdateStatusAdminMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBaseUpdateStatusAdmin.GetKnowledgeBaseUpdateStatusAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGetKnowledgeBaseUpdateStatusAdmin.GetKnowledgeBaseUpdateStatusAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBaseUpdateStatusAdmin.GetKnowledgeBaseUpdateStatusAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBaseUpdateStatusAdmin.GetKnowledgeBaseUpdateStatusAdminMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBaseUpdateStatusAdmin.GetKnowledgeBaseUpdateStatusAdminMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetKnowledgeBaseUpdateStatusAdminParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBaseUpdateStatusAdmin.t.Errorf("ServiceMock.GetKnowledgeBaseUpdateStatusAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseUpdateStatusAdmin.GetKnowledgeBaseUpdateStatusAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBaseUpdateStatusAdmin.t.Errorf("ServiceMock.GetKnowledgeBaseUpdateStatusAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetKnowledgeBaseUpdateStatusAdmin.GetKnowledgeBaseUpdateStatusAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBaseUpdateStatusAdmin.GetKnowledgeBaseUpdateStatusAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBaseUpdateStatusAdmin.t.Fatal("No results are set for the ServiceMock.GetKnowledgeBaseUpdateStatusAdmin")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGetKnowledgeBaseUpdateStatusAdmin.funcGetKnowledgeBaseUpdateStatusAdmin != nil {
		return mmGetKnowledgeBaseUpdateStatusAdmin.funcGetKnowledgeBaseUpdateStatusAdmin(ctx)
	}
	mmGetKnowledgeBaseUpdateStatusAdmin.t.Fatalf("Unexpected call to ServiceMock.GetKnowledgeBaseUpdateStatusAdmin. %v", ctx)
	return
}

// GetKnowledgeBaseUpdateStatusAdminAfterCounter returns a count of finished ServiceMock.GetKnowledgeBaseUpdateStatusAdmin invocations
func (mmGetKnowledgeBaseUpdateStatusAdmin *ServiceMock) GetKnowledgeBaseUpdateStatusAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseUpdateStatusAdmin.afterGetKnowledgeBaseUpdateStatusAdminCounter)
}

// GetKnowledgeBaseUpdateStatusAdminBeforeCounter returns a count of ServiceMock.GetKnowledgeBaseUpdateStatusAdmin invocations
func (mmGetKnowledgeBaseUpdateStatusAdmin *ServiceMock) GetKnowledgeBaseUpdateStatusAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseUpdateStatusAdmin.beforeGetKnowledgeBaseUpdateStatusAdminCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetKnowledgeBaseUpdateStatusAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBaseUpdateStatusAdmin *mServiceMockGetKnowledgeBaseUpdateStatusAdmin) Calls() []*ServiceMockGetKnowledgeBaseUpdateStatusAdminParams {
	mmGetKnowledgeBaseUpdateStatusAdmin.mutex.RLock()

	argCopy := make([]*ServiceMockGetKnowledgeBaseUpdateStatusAdminParams, len(mmGetKnowledgeBaseUpdateStatusAdmin.callArgs))
	copy(argCopy, mmGetKnowledgeBaseUpdateStatusAdmin.callArgs)

	mmGetKnowledgeBaseUpdateStatusAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBaseUpdateStatusAdminDone returns true if the count of the GetKnowledgeBaseUpdateStatusAdmin invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetKnowledgeBaseUpdateStatusAdminDone() bool {
	if m.GetKnowledgeBaseUpdateStatusAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetKnowledgeBaseUpdateStatusAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBaseUpdateStatusAdminMock.invocationsDone()
}

// MinimockGetKnowledgeBaseUpdateStatusAdminInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetKnowledgeBaseUpdateStatusAdminInspect() {
	for _, e := range m.GetKnowledgeBaseUpdateStatusAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetKnowledgeBaseUpdateStatusAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetKnowledgeBaseUpdateStatusAdminCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBaseUpdateStatusAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBaseUpdateStatusAdminMock.defaultExpectation != nil && afterGetKnowledgeBaseUpdateStatusAdminCounter < 1 {
		if m.GetKnowledgeBaseUpdateStatusAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetKnowledgeBaseUpdateStatusAdmin at\n%s", m.GetKnowledgeBaseUpdateStatusAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetKnowledgeBaseUpdateStatusAdmin at\n%s with params: %#v", m.GetKnowledgeBaseUpdateStatusAdminMock.defaultExpectation.expectationOrigins.origin, *m.GetKnowledgeBaseUpdateStatusAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBaseUpdateStatusAdmin != nil && afterGetKnowledgeBaseUpdateStatusAdminCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetKnowledgeBaseUpdateStatusAdmin at\n%s", m.funcGetKnowledgeBaseUpdateStatusAdminOrigin)
	}

	if !m.GetKnowledgeBaseUpdateStatusAdminMock.invocationsDone() && afterGetKnowledgeBaseUpdateStatusAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetKnowledgeBaseUpdateStatusAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBaseUpdateStatusAdminMock.expectedInvocations), m.GetKnowledgeBaseUpdateStatusAdminMock.expectedInvocationsOrigin, afterGetKnowledgeBaseUpdateStatusAdminCounter)
	}
}

type mServiceMockGetNamespaceAndCheckPermission struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetNamespaceAndCheckPermissionExpectation
	expectations       []*ServiceMockGetNamespaceAndCheckPermissionExpectation

	callArgs []*ServiceMockGetNamespaceAndCheckPermissionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetNamespaceAndCheckPermissionExpectation specifies expectation struct of the Service.GetNamespaceAndCheckPermission
type ServiceMockGetNamespaceAndCheckPermissionExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetNamespaceAndCheckPermissionParams
	paramPtrs          *ServiceMockGetNamespaceAndCheckPermissionParamPtrs
	expectationOrigins ServiceMockGetNamespaceAndCheckPermissionExpectationOrigins
	results            *ServiceMockGetNamespaceAndCheckPermissionResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetNamespaceAndCheckPermissionParams contains parameters of the Service.GetNamespaceAndCheckPermission
type ServiceMockGetNamespaceAndCheckPermissionParams struct {
	ctx context.Context
	s1  string
}

// ServiceMockGetNamespaceAndCheckPermissionParamPtrs contains pointers to parameters of the Service.GetNamespaceAndCheckPermission
type ServiceMockGetNamespaceAndCheckPermissionParamPtrs struct {
	ctx *context.Context
	s1  *string
}

// ServiceMockGetNamespaceAndCheckPermissionResults contains results of the Service.GetNamespaceAndCheckPermission
type ServiceMockGetNamespaceAndCheckPermissionResults struct {
	np1 *resource.Namespace
	err error
}

// ServiceMockGetNamespaceAndCheckPermissionOrigins contains origins of expectations of the Service.GetNamespaceAndCheckPermission
type ServiceMockGetNamespaceAndCheckPermissionExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) Optional() *mServiceMockGetNamespaceAndCheckPermission {
	mmGetNamespaceAndCheckPermission.optional = true
	return mmGetNamespaceAndCheckPermission
}

// Expect sets up expected params for Service.GetNamespaceAndCheckPermission
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) Expect(ctx context.Context, s1 string) *mServiceMockGetNamespaceAndCheckPermission {
	if mmGetNamespaceAndCheckPermission.mock.funcGetNamespaceAndCheckPermission != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("ServiceMock.GetNamespaceAndCheckPermission mock is already set by Set")
	}

	if mmGetNamespaceAndCheckPermission.defaultExpectation == nil {
		mmGetNamespaceAndCheckPermission.defaultExpectation = &ServiceMockGetNamespaceAndCheckPermissionExpectation{}
	}

	if mmGetNamespaceAndCheckPermission.defaultExpectation.paramPtrs != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("ServiceMock.GetNamespaceAndCheckPermission mock is already set by ExpectParams functions")
	}

	mmGetNamespaceAndCheckPermission.defaultExpectation.params = &ServiceMockGetNamespaceAndCheckPermissionParams{ctx, s1}
	mmGetNamespaceAndCheckPermission.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetNamespaceAndCheckPermission.expectations {
		if minimock.Equal(e.params, mmGetNamespaceAndCheckPermission.defaultExpectation.params) {
			mmGetNamespaceAndCheckPermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetNamespaceAndCheckPermission.defaultExpectation.params)
		}
	}

	return mmGetNamespaceAndCheckPermission
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetNamespaceAndCheckPermission
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) ExpectCtxParam1(ctx context.Context) *mServiceMockGetNamespaceAndCheckPermission {
	if mmGetNamespaceAndCheckPermission.mock.funcGetNamespaceAndCheckPermission != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("ServiceMock.GetNamespaceAndCheckPermission mock is already set by Set")
	}

	if mmGetNamespaceAndCheckPermission.defaultExpectation == nil {
		mmGetNamespaceAndCheckPermission.defaultExpectation = &ServiceMockGetNamespaceAndCheckPermissionExpectation{}
	}

	if mmGetNamespaceAndCheckPermission.defaultExpectation.params != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("ServiceMock.GetNamespaceAndCheckPermission mock is already set by Expect")
	}

	if mmGetNamespaceAndCheckPermission.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceAndCheckPermission.defaultExpectation.paramPtrs = &ServiceMockGetNamespaceAndCheckPermissionParamPtrs{}
	}
	mmGetNamespaceAndCheckPermission.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetNamespaceAndCheckPermission.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetNamespaceAndCheckPermission
}

// ExpectS1Param2 sets up expected param s1 for Service.GetNamespaceAndCheckPermission
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) ExpectS1Param2(s1 string) *mServiceMockGetNamespaceAndCheckPermission {
	if mmGetNamespaceAndCheckPermission.mock.funcGetNamespaceAndCheckPermission != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("ServiceMock.GetNamespaceAndCheckPermission mock is already set by Set")
	}

	if mmGetNamespaceAndCheckPermission.defaultExpectation == nil {
		mmGetNamespaceAndCheckPermission.defaultExpectation = &ServiceMockGetNamespaceAndCheckPermissionExpectation{}
	}

	if mmGetNamespaceAndCheckPermission.defaultExpectation.params != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("ServiceMock.GetNamespaceAndCheckPermission mock is already set by Expect")
	}

	if mmGetNamespaceAndCheckPermission.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceAndCheckPermission.defaultExpectation.paramPtrs = &ServiceMockGetNamespaceAndCheckPermissionParamPtrs{}
	}
	mmGetNamespaceAndCheckPermission.defaultExpectation.paramPtrs.s1 = &s1
	mmGetNamespaceAndCheckPermission.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmGetNamespaceAndCheckPermission
}

// Inspect accepts an inspector function that has same arguments as the Service.GetNamespaceAndCheckPermission
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) Inspect(f func(ctx context.Context, s1 string)) *mServiceMockGetNamespaceAndCheckPermission {
	if mmGetNamespaceAndCheckPermission.mock.inspectFuncGetNamespaceAndCheckPermission != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetNamespaceAndCheckPermission")
	}

	mmGetNamespaceAndCheckPermission.mock.inspectFuncGetNamespaceAndCheckPermission = f

	return mmGetNamespaceAndCheckPermission
}

// Return sets up results that will be returned by Service.GetNamespaceAndCheckPermission
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) Return(np1 *resource.Namespace, err error) *ServiceMock {
	if mmGetNamespaceAndCheckPermission.mock.funcGetNamespaceAndCheckPermission != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("ServiceMock.GetNamespaceAndCheckPermission mock is already set by Set")
	}

	if mmGetNamespaceAndCheckPermission.defaultExpectation == nil {
		mmGetNamespaceAndCheckPermission.defaultExpectation = &ServiceMockGetNamespaceAndCheckPermissionExpectation{mock: mmGetNamespaceAndCheckPermission.mock}
	}
	mmGetNamespaceAndCheckPermission.defaultExpectation.results = &ServiceMockGetNamespaceAndCheckPermissionResults{np1, err}
	mmGetNamespaceAndCheckPermission.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceAndCheckPermission.mock
}

// Set uses given function f to mock the Service.GetNamespaceAndCheckPermission method
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) Set(f func(ctx context.Context, s1 string) (np1 *resource.Namespace, err error)) *ServiceMock {
	if mmGetNamespaceAndCheckPermission.defaultExpectation != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("Default expectation is already set for the Service.GetNamespaceAndCheckPermission method")
	}

	if len(mmGetNamespaceAndCheckPermission.expectations) > 0 {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("Some expectations are already set for the Service.GetNamespaceAndCheckPermission method")
	}

	mmGetNamespaceAndCheckPermission.mock.funcGetNamespaceAndCheckPermission = f
	mmGetNamespaceAndCheckPermission.mock.funcGetNamespaceAndCheckPermissionOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceAndCheckPermission.mock
}

// When sets expectation for the Service.GetNamespaceAndCheckPermission which will trigger the result defined by the following
// Then helper
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) When(ctx context.Context, s1 string) *ServiceMockGetNamespaceAndCheckPermissionExpectation {
	if mmGetNamespaceAndCheckPermission.mock.funcGetNamespaceAndCheckPermission != nil {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("ServiceMock.GetNamespaceAndCheckPermission mock is already set by Set")
	}

	expectation := &ServiceMockGetNamespaceAndCheckPermissionExpectation{
		mock:               mmGetNamespaceAndCheckPermission.mock,
		params:             &ServiceMockGetNamespaceAndCheckPermissionParams{ctx, s1},
		expectationOrigins: ServiceMockGetNamespaceAndCheckPermissionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetNamespaceAndCheckPermission.expectations = append(mmGetNamespaceAndCheckPermission.expectations, expectation)
	return expectation
}

// Then sets up Service.GetNamespaceAndCheckPermission return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetNamespaceAndCheckPermissionExpectation) Then(np1 *resource.Namespace, err error) *ServiceMock {
	e.results = &ServiceMockGetNamespaceAndCheckPermissionResults{np1, err}
	return e.mock
}

// Times sets number of times Service.GetNamespaceAndCheckPermission should be invoked
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) Times(n uint64) *mServiceMockGetNamespaceAndCheckPermission {
	if n == 0 {
		mmGetNamespaceAndCheckPermission.mock.t.Fatalf("Times of ServiceMock.GetNamespaceAndCheckPermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetNamespaceAndCheckPermission.expectedInvocations, n)
	mmGetNamespaceAndCheckPermission.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceAndCheckPermission
}

func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) invocationsDone() bool {
	if len(mmGetNamespaceAndCheckPermission.expectations) == 0 && mmGetNamespaceAndCheckPermission.defaultExpectation == nil && mmGetNamespaceAndCheckPermission.mock.funcGetNamespaceAndCheckPermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetNamespaceAndCheckPermission.mock.afterGetNamespaceAndCheckPermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetNamespaceAndCheckPermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetNamespaceAndCheckPermission implements mm_service.Service
func (mmGetNamespaceAndCheckPermission *ServiceMock) GetNamespaceAndCheckPermission(ctx context.Context, s1 string) (np1 *resource.Namespace, err error) {
	mm_atomic.AddUint64(&mmGetNamespaceAndCheckPermission.beforeGetNamespaceAndCheckPermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNamespaceAndCheckPermission.afterGetNamespaceAndCheckPermissionCounter, 1)

	mmGetNamespaceAndCheckPermission.t.Helper()

	if mmGetNamespaceAndCheckPermission.inspectFuncGetNamespaceAndCheckPermission != nil {
		mmGetNamespaceAndCheckPermission.inspectFuncGetNamespaceAndCheckPermission(ctx, s1)
	}

	mm_params := ServiceMockGetNamespaceAndCheckPermissionParams{ctx, s1}

	// Record call args
	mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.mutex.Lock()
	mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.callArgs = append(mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.callArgs, &mm_params)
	mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.mutex.Unlock()

	for _, e := range mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.np1, e.results.err
		}
	}

	if mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.defaultExpectation.params
		mm_want_ptrs := mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetNamespaceAndCheckPermissionParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetNamespaceAndCheckPermission.t.Errorf("ServiceMock.GetNamespaceAndCheckPermission got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmGetNamespaceAndCheckPermission.t.Errorf("ServiceMock.GetNamespaceAndCheckPermission got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetNamespaceAndCheckPermission.t.Errorf("ServiceMock.GetNamespaceAndCheckPermission got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetNamespaceAndCheckPermission.GetNamespaceAndCheckPermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNamespaceAndCheckPermission.t.Fatal("No results are set for the ServiceMock.GetNamespaceAndCheckPermission")
		}
		return (*mm_results).np1, (*mm_results).err
	}
	if mmGetNamespaceAndCheckPermission.funcGetNamespaceAndCheckPermission != nil {
		return mmGetNamespaceAndCheckPermission.funcGetNamespaceAndCheckPermission(ctx, s1)
	}
	mmGetNamespaceAndCheckPermission.t.Fatalf("Unexpected call to ServiceMock.GetNamespaceAndCheckPermission. %v %v", ctx, s1)
	return
}

// GetNamespaceAndCheckPermissionAfterCounter returns a count of finished ServiceMock.GetNamespaceAndCheckPermission invocations
func (mmGetNamespaceAndCheckPermission *ServiceMock) GetNamespaceAndCheckPermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceAndCheckPermission.afterGetNamespaceAndCheckPermissionCounter)
}

// GetNamespaceAndCheckPermissionBeforeCounter returns a count of ServiceMock.GetNamespaceAndCheckPermission invocations
func (mmGetNamespaceAndCheckPermission *ServiceMock) GetNamespaceAndCheckPermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceAndCheckPermission.beforeGetNamespaceAndCheckPermissionCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetNamespaceAndCheckPermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetNamespaceAndCheckPermission *mServiceMockGetNamespaceAndCheckPermission) Calls() []*ServiceMockGetNamespaceAndCheckPermissionParams {
	mmGetNamespaceAndCheckPermission.mutex.RLock()

	argCopy := make([]*ServiceMockGetNamespaceAndCheckPermissionParams, len(mmGetNamespaceAndCheckPermission.callArgs))
	copy(argCopy, mmGetNamespaceAndCheckPermission.callArgs)

	mmGetNamespaceAndCheckPermission.mutex.RUnlock()

	return argCopy
}

// MinimockGetNamespaceAndCheckPermissionDone returns true if the count of the GetNamespaceAndCheckPermission invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetNamespaceAndCheckPermissionDone() bool {
	if m.GetNamespaceAndCheckPermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetNamespaceAndCheckPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetNamespaceAndCheckPermissionMock.invocationsDone()
}

// MinimockGetNamespaceAndCheckPermissionInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetNamespaceAndCheckPermissionInspect() {
	for _, e := range m.GetNamespaceAndCheckPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetNamespaceAndCheckPermission at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetNamespaceAndCheckPermissionCounter := mm_atomic.LoadUint64(&m.afterGetNamespaceAndCheckPermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetNamespaceAndCheckPermissionMock.defaultExpectation != nil && afterGetNamespaceAndCheckPermissionCounter < 1 {
		if m.GetNamespaceAndCheckPermissionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetNamespaceAndCheckPermission at\n%s", m.GetNamespaceAndCheckPermissionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetNamespaceAndCheckPermission at\n%s with params: %#v", m.GetNamespaceAndCheckPermissionMock.defaultExpectation.expectationOrigins.origin, *m.GetNamespaceAndCheckPermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNamespaceAndCheckPermission != nil && afterGetNamespaceAndCheckPermissionCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetNamespaceAndCheckPermission at\n%s", m.funcGetNamespaceAndCheckPermissionOrigin)
	}

	if !m.GetNamespaceAndCheckPermissionMock.invocationsDone() && afterGetNamespaceAndCheckPermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetNamespaceAndCheckPermission at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetNamespaceAndCheckPermissionMock.expectedInvocations), m.GetNamespaceAndCheckPermissionMock.expectedInvocationsOrigin, afterGetNamespaceAndCheckPermissionCounter)
	}
}

type mServiceMockGetNamespaceByNsID struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetNamespaceByNsIDExpectation
	expectations       []*ServiceMockGetNamespaceByNsIDExpectation

	callArgs []*ServiceMockGetNamespaceByNsIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetNamespaceByNsIDExpectation specifies expectation struct of the Service.GetNamespaceByNsID
type ServiceMockGetNamespaceByNsIDExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetNamespaceByNsIDParams
	paramPtrs          *ServiceMockGetNamespaceByNsIDParamPtrs
	expectationOrigins ServiceMockGetNamespaceByNsIDExpectationOrigins
	results            *ServiceMockGetNamespaceByNsIDResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetNamespaceByNsIDParams contains parameters of the Service.GetNamespaceByNsID
type ServiceMockGetNamespaceByNsIDParams struct {
	ctx context.Context
	s1  string
}

// ServiceMockGetNamespaceByNsIDParamPtrs contains pointers to parameters of the Service.GetNamespaceByNsID
type ServiceMockGetNamespaceByNsIDParamPtrs struct {
	ctx *context.Context
	s1  *string
}

// ServiceMockGetNamespaceByNsIDResults contains results of the Service.GetNamespaceByNsID
type ServiceMockGetNamespaceByNsIDResults struct {
	np1 *resource.Namespace
	err error
}

// ServiceMockGetNamespaceByNsIDOrigins contains origins of expectations of the Service.GetNamespaceByNsID
type ServiceMockGetNamespaceByNsIDExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) Optional() *mServiceMockGetNamespaceByNsID {
	mmGetNamespaceByNsID.optional = true
	return mmGetNamespaceByNsID
}

// Expect sets up expected params for Service.GetNamespaceByNsID
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) Expect(ctx context.Context, s1 string) *mServiceMockGetNamespaceByNsID {
	if mmGetNamespaceByNsID.mock.funcGetNamespaceByNsID != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("ServiceMock.GetNamespaceByNsID mock is already set by Set")
	}

	if mmGetNamespaceByNsID.defaultExpectation == nil {
		mmGetNamespaceByNsID.defaultExpectation = &ServiceMockGetNamespaceByNsIDExpectation{}
	}

	if mmGetNamespaceByNsID.defaultExpectation.paramPtrs != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("ServiceMock.GetNamespaceByNsID mock is already set by ExpectParams functions")
	}

	mmGetNamespaceByNsID.defaultExpectation.params = &ServiceMockGetNamespaceByNsIDParams{ctx, s1}
	mmGetNamespaceByNsID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetNamespaceByNsID.expectations {
		if minimock.Equal(e.params, mmGetNamespaceByNsID.defaultExpectation.params) {
			mmGetNamespaceByNsID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetNamespaceByNsID.defaultExpectation.params)
		}
	}

	return mmGetNamespaceByNsID
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetNamespaceByNsID
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) ExpectCtxParam1(ctx context.Context) *mServiceMockGetNamespaceByNsID {
	if mmGetNamespaceByNsID.mock.funcGetNamespaceByNsID != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("ServiceMock.GetNamespaceByNsID mock is already set by Set")
	}

	if mmGetNamespaceByNsID.defaultExpectation == nil {
		mmGetNamespaceByNsID.defaultExpectation = &ServiceMockGetNamespaceByNsIDExpectation{}
	}

	if mmGetNamespaceByNsID.defaultExpectation.params != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("ServiceMock.GetNamespaceByNsID mock is already set by Expect")
	}

	if mmGetNamespaceByNsID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceByNsID.defaultExpectation.paramPtrs = &ServiceMockGetNamespaceByNsIDParamPtrs{}
	}
	mmGetNamespaceByNsID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetNamespaceByNsID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetNamespaceByNsID
}

// ExpectS1Param2 sets up expected param s1 for Service.GetNamespaceByNsID
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) ExpectS1Param2(s1 string) *mServiceMockGetNamespaceByNsID {
	if mmGetNamespaceByNsID.mock.funcGetNamespaceByNsID != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("ServiceMock.GetNamespaceByNsID mock is already set by Set")
	}

	if mmGetNamespaceByNsID.defaultExpectation == nil {
		mmGetNamespaceByNsID.defaultExpectation = &ServiceMockGetNamespaceByNsIDExpectation{}
	}

	if mmGetNamespaceByNsID.defaultExpectation.params != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("ServiceMock.GetNamespaceByNsID mock is already set by Expect")
	}

	if mmGetNamespaceByNsID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceByNsID.defaultExpectation.paramPtrs = &ServiceMockGetNamespaceByNsIDParamPtrs{}
	}
	mmGetNamespaceByNsID.defaultExpectation.paramPtrs.s1 = &s1
	mmGetNamespaceByNsID.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmGetNamespaceByNsID
}

// Inspect accepts an inspector function that has same arguments as the Service.GetNamespaceByNsID
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) Inspect(f func(ctx context.Context, s1 string)) *mServiceMockGetNamespaceByNsID {
	if mmGetNamespaceByNsID.mock.inspectFuncGetNamespaceByNsID != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetNamespaceByNsID")
	}

	mmGetNamespaceByNsID.mock.inspectFuncGetNamespaceByNsID = f

	return mmGetNamespaceByNsID
}

// Return sets up results that will be returned by Service.GetNamespaceByNsID
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) Return(np1 *resource.Namespace, err error) *ServiceMock {
	if mmGetNamespaceByNsID.mock.funcGetNamespaceByNsID != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("ServiceMock.GetNamespaceByNsID mock is already set by Set")
	}

	if mmGetNamespaceByNsID.defaultExpectation == nil {
		mmGetNamespaceByNsID.defaultExpectation = &ServiceMockGetNamespaceByNsIDExpectation{mock: mmGetNamespaceByNsID.mock}
	}
	mmGetNamespaceByNsID.defaultExpectation.results = &ServiceMockGetNamespaceByNsIDResults{np1, err}
	mmGetNamespaceByNsID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceByNsID.mock
}

// Set uses given function f to mock the Service.GetNamespaceByNsID method
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) Set(f func(ctx context.Context, s1 string) (np1 *resource.Namespace, err error)) *ServiceMock {
	if mmGetNamespaceByNsID.defaultExpectation != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("Default expectation is already set for the Service.GetNamespaceByNsID method")
	}

	if len(mmGetNamespaceByNsID.expectations) > 0 {
		mmGetNamespaceByNsID.mock.t.Fatalf("Some expectations are already set for the Service.GetNamespaceByNsID method")
	}

	mmGetNamespaceByNsID.mock.funcGetNamespaceByNsID = f
	mmGetNamespaceByNsID.mock.funcGetNamespaceByNsIDOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceByNsID.mock
}

// When sets expectation for the Service.GetNamespaceByNsID which will trigger the result defined by the following
// Then helper
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) When(ctx context.Context, s1 string) *ServiceMockGetNamespaceByNsIDExpectation {
	if mmGetNamespaceByNsID.mock.funcGetNamespaceByNsID != nil {
		mmGetNamespaceByNsID.mock.t.Fatalf("ServiceMock.GetNamespaceByNsID mock is already set by Set")
	}

	expectation := &ServiceMockGetNamespaceByNsIDExpectation{
		mock:               mmGetNamespaceByNsID.mock,
		params:             &ServiceMockGetNamespaceByNsIDParams{ctx, s1},
		expectationOrigins: ServiceMockGetNamespaceByNsIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetNamespaceByNsID.expectations = append(mmGetNamespaceByNsID.expectations, expectation)
	return expectation
}

// Then sets up Service.GetNamespaceByNsID return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetNamespaceByNsIDExpectation) Then(np1 *resource.Namespace, err error) *ServiceMock {
	e.results = &ServiceMockGetNamespaceByNsIDResults{np1, err}
	return e.mock
}

// Times sets number of times Service.GetNamespaceByNsID should be invoked
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) Times(n uint64) *mServiceMockGetNamespaceByNsID {
	if n == 0 {
		mmGetNamespaceByNsID.mock.t.Fatalf("Times of ServiceMock.GetNamespaceByNsID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetNamespaceByNsID.expectedInvocations, n)
	mmGetNamespaceByNsID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceByNsID
}

func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) invocationsDone() bool {
	if len(mmGetNamespaceByNsID.expectations) == 0 && mmGetNamespaceByNsID.defaultExpectation == nil && mmGetNamespaceByNsID.mock.funcGetNamespaceByNsID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetNamespaceByNsID.mock.afterGetNamespaceByNsIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetNamespaceByNsID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetNamespaceByNsID implements mm_service.Service
func (mmGetNamespaceByNsID *ServiceMock) GetNamespaceByNsID(ctx context.Context, s1 string) (np1 *resource.Namespace, err error) {
	mm_atomic.AddUint64(&mmGetNamespaceByNsID.beforeGetNamespaceByNsIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNamespaceByNsID.afterGetNamespaceByNsIDCounter, 1)

	mmGetNamespaceByNsID.t.Helper()

	if mmGetNamespaceByNsID.inspectFuncGetNamespaceByNsID != nil {
		mmGetNamespaceByNsID.inspectFuncGetNamespaceByNsID(ctx, s1)
	}

	mm_params := ServiceMockGetNamespaceByNsIDParams{ctx, s1}

	// Record call args
	mmGetNamespaceByNsID.GetNamespaceByNsIDMock.mutex.Lock()
	mmGetNamespaceByNsID.GetNamespaceByNsIDMock.callArgs = append(mmGetNamespaceByNsID.GetNamespaceByNsIDMock.callArgs, &mm_params)
	mmGetNamespaceByNsID.GetNamespaceByNsIDMock.mutex.Unlock()

	for _, e := range mmGetNamespaceByNsID.GetNamespaceByNsIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.np1, e.results.err
		}
	}

	if mmGetNamespaceByNsID.GetNamespaceByNsIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNamespaceByNsID.GetNamespaceByNsIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetNamespaceByNsID.GetNamespaceByNsIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetNamespaceByNsID.GetNamespaceByNsIDMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetNamespaceByNsIDParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetNamespaceByNsID.t.Errorf("ServiceMock.GetNamespaceByNsID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceByNsID.GetNamespaceByNsIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmGetNamespaceByNsID.t.Errorf("ServiceMock.GetNamespaceByNsID got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceByNsID.GetNamespaceByNsIDMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetNamespaceByNsID.t.Errorf("ServiceMock.GetNamespaceByNsID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetNamespaceByNsID.GetNamespaceByNsIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetNamespaceByNsID.GetNamespaceByNsIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNamespaceByNsID.t.Fatal("No results are set for the ServiceMock.GetNamespaceByNsID")
		}
		return (*mm_results).np1, (*mm_results).err
	}
	if mmGetNamespaceByNsID.funcGetNamespaceByNsID != nil {
		return mmGetNamespaceByNsID.funcGetNamespaceByNsID(ctx, s1)
	}
	mmGetNamespaceByNsID.t.Fatalf("Unexpected call to ServiceMock.GetNamespaceByNsID. %v %v", ctx, s1)
	return
}

// GetNamespaceByNsIDAfterCounter returns a count of finished ServiceMock.GetNamespaceByNsID invocations
func (mmGetNamespaceByNsID *ServiceMock) GetNamespaceByNsIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceByNsID.afterGetNamespaceByNsIDCounter)
}

// GetNamespaceByNsIDBeforeCounter returns a count of ServiceMock.GetNamespaceByNsID invocations
func (mmGetNamespaceByNsID *ServiceMock) GetNamespaceByNsIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceByNsID.beforeGetNamespaceByNsIDCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetNamespaceByNsID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetNamespaceByNsID *mServiceMockGetNamespaceByNsID) Calls() []*ServiceMockGetNamespaceByNsIDParams {
	mmGetNamespaceByNsID.mutex.RLock()

	argCopy := make([]*ServiceMockGetNamespaceByNsIDParams, len(mmGetNamespaceByNsID.callArgs))
	copy(argCopy, mmGetNamespaceByNsID.callArgs)

	mmGetNamespaceByNsID.mutex.RUnlock()

	return argCopy
}

// MinimockGetNamespaceByNsIDDone returns true if the count of the GetNamespaceByNsID invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetNamespaceByNsIDDone() bool {
	if m.GetNamespaceByNsIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetNamespaceByNsIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetNamespaceByNsIDMock.invocationsDone()
}

// MinimockGetNamespaceByNsIDInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetNamespaceByNsIDInspect() {
	for _, e := range m.GetNamespaceByNsIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetNamespaceByNsID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetNamespaceByNsIDCounter := mm_atomic.LoadUint64(&m.afterGetNamespaceByNsIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetNamespaceByNsIDMock.defaultExpectation != nil && afterGetNamespaceByNsIDCounter < 1 {
		if m.GetNamespaceByNsIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetNamespaceByNsID at\n%s", m.GetNamespaceByNsIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetNamespaceByNsID at\n%s with params: %#v", m.GetNamespaceByNsIDMock.defaultExpectation.expectationOrigins.origin, *m.GetNamespaceByNsIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNamespaceByNsID != nil && afterGetNamespaceByNsIDCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetNamespaceByNsID at\n%s", m.funcGetNamespaceByNsIDOrigin)
	}

	if !m.GetNamespaceByNsIDMock.invocationsDone() && afterGetNamespaceByNsIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetNamespaceByNsID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetNamespaceByNsIDMock.expectedInvocations), m.GetNamespaceByNsIDMock.expectedInvocationsOrigin, afterGetNamespaceByNsIDCounter)
	}
}

type mServiceMockGetRepositoryTag struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetRepositoryTagExpectation
	expectations       []*ServiceMockGetRepositoryTagExpectation

	callArgs []*ServiceMockGetRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetRepositoryTagExpectation specifies expectation struct of the Service.GetRepositoryTag
type ServiceMockGetRepositoryTagExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetRepositoryTagParams
	paramPtrs          *ServiceMockGetRepositoryTagParamPtrs
	expectationOrigins ServiceMockGetRepositoryTagExpectationOrigins
	results            *ServiceMockGetRepositoryTagResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetRepositoryTagParams contains parameters of the Service.GetRepositoryTag
type ServiceMockGetRepositoryTagParams struct {
	ctx context.Context
	gp1 *artifactpb.GetRepositoryTagRequest
}

// ServiceMockGetRepositoryTagParamPtrs contains pointers to parameters of the Service.GetRepositoryTag
type ServiceMockGetRepositoryTagParamPtrs struct {
	ctx *context.Context
	gp1 **artifactpb.GetRepositoryTagRequest
}

// ServiceMockGetRepositoryTagResults contains results of the Service.GetRepositoryTag
type ServiceMockGetRepositoryTagResults struct {
	gp2 *artifactpb.GetRepositoryTagResponse
	err error
}

// ServiceMockGetRepositoryTagOrigins contains origins of expectations of the Service.GetRepositoryTag
type ServiceMockGetRepositoryTagExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) Optional() *mServiceMockGetRepositoryTag {
	mmGetRepositoryTag.optional = true
	return mmGetRepositoryTag
}

// Expect sets up expected params for Service.GetRepositoryTag
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) Expect(ctx context.Context, gp1 *artifactpb.GetRepositoryTagRequest) *mServiceMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("ServiceMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &ServiceMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmGetRepositoryTag.mock.t.Fatalf("ServiceMock.GetRepositoryTag mock is already set by ExpectParams functions")
	}

	mmGetRepositoryTag.defaultExpectation.params = &ServiceMockGetRepositoryTagParams{ctx, gp1}
	mmGetRepositoryTag.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetRepositoryTag.expectations {
		if minimock.Equal(e.params, mmGetRepositoryTag.defaultExpectation.params) {
			mmGetRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRepositoryTag.defaultExpectation.params)
		}
	}

	return mmGetRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetRepositoryTag
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) ExpectCtxParam1(ctx context.Context) *mServiceMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("ServiceMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &ServiceMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.params != nil {
		mmGetRepositoryTag.mock.t.Fatalf("ServiceMock.GetRepositoryTag mock is already set by Expect")
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmGetRepositoryTag.defaultExpectation.paramPtrs = &ServiceMockGetRepositoryTagParamPtrs{}
	}
	mmGetRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetRepositoryTag.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetRepositoryTag
}

// ExpectGp1Param2 sets up expected param gp1 for Service.GetRepositoryTag
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) ExpectGp1Param2(gp1 *artifactpb.GetRepositoryTagRequest) *mServiceMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("ServiceMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &ServiceMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.params != nil {
		mmGetRepositoryTag.mock.t.Fatalf("ServiceMock.GetRepositoryTag mock is already set by Expect")
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmGetRepositoryTag.defaultExpectation.paramPtrs = &ServiceMockGetRepositoryTagParamPtrs{}
	}
	mmGetRepositoryTag.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetRepositoryTag.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the Service.GetRepositoryTag
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) Inspect(f func(ctx context.Context, gp1 *artifactpb.GetRepositoryTagRequest)) *mServiceMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.inspectFuncGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetRepositoryTag")
	}

	mmGetRepositoryTag.mock.inspectFuncGetRepositoryTag = f

	return mmGetRepositoryTag
}

// Return sets up results that will be returned by Service.GetRepositoryTag
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) Return(gp2 *artifactpb.GetRepositoryTagResponse, err error) *ServiceMock {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("ServiceMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &ServiceMockGetRepositoryTagExpectation{mock: mmGetRepositoryTag.mock}
	}
	mmGetRepositoryTag.defaultExpectation.results = &ServiceMockGetRepositoryTagResults{gp2, err}
	mmGetRepositoryTag.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetRepositoryTag.mock
}

// Set uses given function f to mock the Service.GetRepositoryTag method
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) Set(f func(ctx context.Context, gp1 *artifactpb.GetRepositoryTagRequest) (gp2 *artifactpb.GetRepositoryTagResponse, err error)) *ServiceMock {
	if mmGetRepositoryTag.defaultExpectation != nil {
		mmGetRepositoryTag.mock.t.Fatalf("Default expectation is already set for the Service.GetRepositoryTag method")
	}

	if len(mmGetRepositoryTag.expectations) > 0 {
		mmGetRepositoryTag.mock.t.Fatalf("Some expectations are already set for the Service.GetRepositoryTag method")
	}

	mmGetRepositoryTag.mock.funcGetRepositoryTag = f
	mmGetRepositoryTag.mock.funcGetRepositoryTagOrigin = minimock.CallerInfo(1)
	return mmGetRepositoryTag.mock
}

// When sets expectation for the Service.GetRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) When(ctx context.Context, gp1 *artifactpb.GetRepositoryTagRequest) *ServiceMockGetRepositoryTagExpectation {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("ServiceMock.GetRepositoryTag mock is already set by Set")
	}

	expectation := &ServiceMockGetRepositoryTagExpectation{
		mock:               mmGetRepositoryTag.mock,
		params:             &ServiceMockGetRepositoryTagParams{ctx, gp1},
		expectationOrigins: ServiceMockGetRepositoryTagExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetRepositoryTag.expectations = append(mmGetRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up Service.GetRepositoryTag return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetRepositoryTagExpectation) Then(gp2 *artifactpb.GetRepositoryTagResponse, err error) *ServiceMock {
	e.results = &ServiceMockGetRepositoryTagResults{gp2, err}
	return e.mock
}

// Times sets number of times Service.GetRepositoryTag should be invoked
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) Times(n uint64) *mServiceMockGetRepositoryTag {
	if n == 0 {
		mmGetRepositoryTag.mock.t.Fatalf("Times of ServiceMock.GetRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRepositoryTag.expectedInvocations, n)
	mmGetRepositoryTag.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetRepositoryTag
}

func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) invocationsDone() bool {
	if len(mmGetRepositoryTag.expectations) == 0 && mmGetRepositoryTag.defaultExpectation == nil && mmGetRepositoryTag.mock.funcGetRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRepositoryTag.mock.afterGetRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRepositoryTag implements mm_service.Service
func (mmGetRepositoryTag *ServiceMock) GetRepositoryTag(ctx context.Context, gp1 *artifactpb.GetRepositoryTagRequest) (gp2 *artifactpb.GetRepositoryTagResponse, err error) {
	mm_atomic.AddUint64(&mmGetRepositoryTag.beforeGetRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRepositoryTag.afterGetRepositoryTagCounter, 1)

	mmGetRepositoryTag.t.Helper()

	if mmGetRepositoryTag.inspectFuncGetRepositoryTag != nil {
		mmGetRepositoryTag.inspectFuncGetRepositoryTag(ctx, gp1)
	}

	mm_params := ServiceMockGetRepositoryTagParams{ctx, gp1}

	// Record call args
	mmGetRepositoryTag.GetRepositoryTagMock.mutex.Lock()
	mmGetRepositoryTag.GetRepositoryTagMock.callArgs = append(mmGetRepositoryTag.GetRepositoryTagMock.callArgs, &mm_params)
	mmGetRepositoryTag.GetRepositoryTagMock.mutex.Unlock()

	for _, e := range mmGetRepositoryTag.GetRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetRepositoryTagParams{ctx, gp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetRepositoryTag.t.Errorf("ServiceMock.GetRepositoryTag got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetRepositoryTag.t.Errorf("ServiceMock.GetRepositoryTag got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRepositoryTag.t.Errorf("ServiceMock.GetRepositoryTag got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRepositoryTag.t.Fatal("No results are set for the ServiceMock.GetRepositoryTag")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetRepositoryTag.funcGetRepositoryTag != nil {
		return mmGetRepositoryTag.funcGetRepositoryTag(ctx, gp1)
	}
	mmGetRepositoryTag.t.Fatalf("Unexpected call to ServiceMock.GetRepositoryTag. %v %v", ctx, gp1)
	return
}

// GetRepositoryTagAfterCounter returns a count of finished ServiceMock.GetRepositoryTag invocations
func (mmGetRepositoryTag *ServiceMock) GetRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRepositoryTag.afterGetRepositoryTagCounter)
}

// GetRepositoryTagBeforeCounter returns a count of ServiceMock.GetRepositoryTag invocations
func (mmGetRepositoryTag *ServiceMock) GetRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRepositoryTag.beforeGetRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRepositoryTag *mServiceMockGetRepositoryTag) Calls() []*ServiceMockGetRepositoryTagParams {
	mmGetRepositoryTag.mutex.RLock()

	argCopy := make([]*ServiceMockGetRepositoryTagParams, len(mmGetRepositoryTag.callArgs))
	copy(argCopy, mmGetRepositoryTag.callArgs)

	mmGetRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockGetRepositoryTagDone returns true if the count of the GetRepositoryTag invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetRepositoryTagDone() bool {
	if m.GetRepositoryTagMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRepositoryTagMock.invocationsDone()
}

// MinimockGetRepositoryTagInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetRepositoryTagInspect() {
	for _, e := range m.GetRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetRepositoryTag at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterGetRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRepositoryTagMock.defaultExpectation != nil && afterGetRepositoryTagCounter < 1 {
		if m.GetRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetRepositoryTag at\n%s", m.GetRepositoryTagMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetRepositoryTag at\n%s with params: %#v", m.GetRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *m.GetRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRepositoryTag != nil && afterGetRepositoryTagCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetRepositoryTag at\n%s", m.funcGetRepositoryTagOrigin)
	}

	if !m.GetRepositoryTagMock.invocationsDone() && afterGetRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetRepositoryTag at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetRepositoryTagMock.expectedInvocations), m.GetRepositoryTagMock.expectedInvocationsOrigin, afterGetRepositoryTagCounter)
	}
}

type mServiceMockGetSystemAdmin struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetSystemAdminExpectation
	expectations       []*ServiceMockGetSystemAdminExpectation

	callArgs []*ServiceMockGetSystemAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetSystemAdminExpectation specifies expectation struct of the Service.GetSystemAdmin
type ServiceMockGetSystemAdminExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetSystemAdminParams
	paramPtrs          *ServiceMockGetSystemAdminParamPtrs
	expectationOrigins ServiceMockGetSystemAdminExpectationOrigins
	results            *ServiceMockGetSystemAdminResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetSystemAdminParams contains parameters of the Service.GetSystemAdmin
type ServiceMockGetSystemAdminParams struct {
	ctx context.Context
	s1  string
}

// ServiceMockGetSystemAdminParamPtrs contains pointers to parameters of the Service.GetSystemAdmin
type ServiceMockGetSystemAdminParamPtrs struct {
	ctx *context.Context
	s1  *string
}

// ServiceMockGetSystemAdminResults contains results of the Service.GetSystemAdmin
type ServiceMockGetSystemAdminResults struct {
	gp1 *artifactpb.GetSystemAdminResponse
	err error
}

// ServiceMockGetSystemAdminOrigins contains origins of expectations of the Service.GetSystemAdmin
type ServiceMockGetSystemAdminExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetSystemAdmin *mServiceMockGetSystemAdmin) Optional() *mServiceMockGetSystemAdmin {
	mmGetSystemAdmin.optional = true
	return mmGetSystemAdmin
}

// Expect sets up expected params for Service.GetSystemAdmin
func (mmGetSystemAdmin *mServiceMockGetSystemAdmin) Expect(ctx context.Context, s1 string) *mServiceMockGetSystemAdmin {
	if mmGetSystemAdmin.mock.funcGetSystemAdmin != nil {
		mmGetSystemAdmin.mock.t.Fatalf("ServiceMock.GetSystemAdmin mock is already set by Set")
	}

	if mmGetSystemAdmin.defaultExpectation == nil {
		mmGetSystemAdmin.defaultExpectation = &ServiceMockGetSystemAdminExpectation{}
	}

	if mmGetSystemAdmin.defaultExpectation.paramPtrs != nil {
		mmGetSystemAdmin.mock.t.Fatalf("ServiceMock.GetSystemAdmin mock is already set by ExpectParams functions")
	}

	mmGetSystemAdmin.defaultExpectation.params = &ServiceMockGetSystemAdminParams{ctx, s1}
	mmGetSystemAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetSystemAdmin.expectations {
		if minimock.Equal(e.params, mmGetSystemAdmin.defaultExpectation.params) {
			mmGetSystemAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSystemAdmin.defaultExpectation.params)
		}
	}

	return mmGetSystemAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetSystemAdmin
func (mmGetSystemAdmin *mServiceMockGetSystemAdmin) ExpectCtxParam1(ctx context.Context) *mServiceMockGetSystemAdmin {
	if mmGetSystemAdmin.mock.funcGetSystemAdmin != nil {
		mmGetSystemAdmin.mock.t.Fatalf("ServiceMock.GetSystemAdmin mock is already set by Set")
	}

	if mmGetSystemAdmin.defaultExpectation == nil {
		mmGetSystemAdmin.defaultExpectation = &ServiceMockGetSystemAdminExpectation{}
	}

	if mmGetSystemAdmin.defaultExpectation.params != nil {
		mmGetSystemAdmin.mock.t.Fatalf("ServiceMock.GetSystemAdmin mock is already set by Expect")
	}

	if mmGetSystemAdmin.defaultExpectation.paramPtrs == nil {
		mmGetSystemAdmin.defaultExpectation.paramPtrs = &ServiceMockGetSystemAdminParamPtrs{}
	}
	mmGetSystemAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetSystemAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetSystemAdmin
}

// ExpectS1Param2 sets up expected param s1 for Service.GetSystemAdmin
func (mmGetSystemAdmin *mServiceMockGetSystemAdmin) ExpectS1Param2(s1 string) *mServiceMockGetSystemAdmin {
	if mmGetSystemAdmin.mock.funcGetSystemAdmin != nil {
		mmGetSystemAdmin.mock.t.Fatalf("ServiceMock.GetSystemAdmin mock is already set by Set")
	}

	if mmGetSystemAdmin.defaultExpectation == nil {
		mmGetSystemAdmin.defaultExpectation = &ServiceMockGetSystemAdminExpectation{}
	}

	if mmGetSystemAdmin.defaultExpectation.params != nil {
		mmGetSystemAdmin.mock.t.Fatalf("ServiceMock.GetSystemAdmin mock is already set by Expect")
	}

	if mmGetSystemAdmin.defaultExpectation.paramPtrs == nil {
		mmGetSystemAdmin.defaultExpectation.paramPtrs = &ServiceMockGetSystemAdminParamPtrs{}
	}
	mmGetSystemAdmin.defaultExpectation.paramPtrs.s1 = &s1
	mmGetSystemAdmin.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmGetSystemAdmin
}

// Inspect accepts an inspector function that has same arguments as the Service.GetSystemAdmin
func (mmGetSystemAdmin *mServiceMockGetSystemAdmin) Inspect(f func(ctx context.Context, s1 string)) *mServiceMockGetSystemAdmin {
	if mmGetSystemAdmin.mock.inspectFuncGetSystemAdmin != nil {
		mmGetSystemAdmin.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetSystemAdmin")
	}

	mmGetSystemAdmin.mock.inspectFuncGetSystemAdmin = f

	return mmGetSystemAdmin
}

// Return sets up results that will be returned by Service.GetSystemAdmin
func (mmGetSystemAdmin *mServiceMockGetSystemAdmin) Return(gp1 *artifactpb.GetSystemAdminResponse, err error) *ServiceMock {
	if mmGetSystemAdmin.mock.funcGetSystemAdmin != nil {
		mmGetSystemAdmin.mock.t.Fatalf("ServiceMock.GetSystemAdmin mock is already set by Set")
	}

	if mmGetSystemAdmin.defaultExpectation == nil {
		mmGetSystemAdmin.defaultExpectation = &ServiceMockGetSystemAdminExpectation{mock: mmGetSystemAdmin.mock}
	}
	mmGetSystemAdmin.defaultExpectation.results = &ServiceMockGetSystemAdminResults{gp1, err}
	mmGetSystemAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetSystemAdmin.mock
}

// Set uses given function f to mock the Service.GetSystemAdmin method
func (mmGetSystemAdmin *mServiceMockGetSystemAdmin) Set(f func(ctx context.Context, s1 string) (gp1 *artifactpb.GetSystemAdminResponse, err error)) *ServiceMock {
	if mmGetSystemAdmin.defaultExpectation != nil {
		mmGetSystemAdmin.mock.t.Fatalf("Default expectation is already set for the Service.GetSystemAdmin method")
	}

	if len(mmGetSystemAdmin.expectations) > 0 {
		mmGetSystemAdmin.mock.t.Fatalf("Some expectations are already set for the Service.GetSystemAdmin method")
	}

	mmGetSystemAdmin.mock.funcGetSystemAdmin = f
	mmGetSystemAdmin.mock.funcGetSystemAdminOrigin = minimock.CallerInfo(1)
	return mmGetSystemAdmin.mock
}

// When sets expectation for the Service.GetSystemAdmin which will trigger the result defined by the following
// Then helper
func (mmGetSystemAdmin *mServiceMockGetSystemAdmin) When(ctx context.Context, s1 string) *ServiceMockGetSystemAdminExpectation {
	if mmGetSystemAdmin.mock.funcGetSystemAdmin != nil {
		mmGetSystemAdmin.mock.t.Fatalf("ServiceMock.GetSystemAdmin mock is already set by Set")
	}

	expectation := &ServiceMockGetSystemAdminExpectation{
		mock:               mmGetSystemAdmin.mock,
		params:             &ServiceMockGetSystemAdminParams{ctx, s1},
		expectationOrigins: ServiceMockGetSystemAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetSystemAdmin.expectations = append(mmGetSystemAdmin.expectations, expectation)
	return expectation
}

// Then sets up Service.GetSystemAdmin return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetSystemAdminExpectation) Then(gp1 *artifactpb.GetSystemAdminResponse, err error) *ServiceMock {
	e.results = &ServiceMockGetSystemAdminResults{gp1, err}
	return e.mock
}

// Times sets number of times Service.GetSystemAdmin should be invoked
func (mmGetSystemAdmin *mServiceMockGetSystemAdmin) Times(n uint64) *mServiceMockGetSystemAdmin {
	if n == 0 {
		mmGetSystemAdmin.mock.t.Fatalf("Times of ServiceMock.GetSystemAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetSystemAdmin.expectedInvocations, n)
	mmGetSystemAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetSystemAdmin
}

func (mmGetSystemAdmin *mServiceMockGetSystemAdmin) invocationsDone() bool {
	if len(mmGetSystemAdmin.expectations) == 0 && mmGetSystemAdmin.defaultExpectation == nil && mmGetSystemAdmin.mock.funcGetSystemAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetSystemAdmin.mock.afterGetSystemAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetSystemAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetSystemAdmin implements mm_service.Service
func (mmGetSystemAdmin *ServiceMock) GetSystemAdmin(ctx context.Context, s1 string) (gp1 *artifactpb.GetSystemAdminResponse, err error) {
	mm_atomic.AddUint64(&mmGetSystemAdmin.beforeGetSystemAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSystemAdmin.afterGetSystemAdminCounter, 1)

	mmGetSystemAdmin.t.Helper()

	if mmGetSystemAdmin.inspectFuncGetSystemAdmin != nil {
		mmGetSystemAdmin.inspectFuncGetSystemAdmin(ctx, s1)
	}

	mm_params := ServiceMockGetSystemAdminParams{ctx, s1}

	// Record call args
	mmGetSystemAdmin.GetSystemAdminMock.mutex.Lock()
	mmGetSystemAdmin.GetSystemAdminMock.callArgs = append(mmGetSystemAdmin.GetSystemAdminMock.callArgs, &mm_params)
	mmGetSystemAdmin.GetSystemAdminMock.mutex.Unlock()

	for _, e := range mmGetSystemAdmin.GetSystemAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGetSystemAdmin.GetSystemAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSystemAdmin.GetSystemAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSystemAdmin.GetSystemAdminMock.defaultExpectation.params
		mm_want_ptrs := mmGetSystemAdmin.GetSystemAdminMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetSystemAdminParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetSystemAdmin.t.Errorf("ServiceMock.GetSystemAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetSystemAdmin.GetSystemAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmGetSystemAdmin.t.Errorf("ServiceMock.GetSystemAdmin got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetSystemAdmin.GetSystemAdminMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSystemAdmin.t.Errorf("ServiceMock.GetSystemAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetSystemAdmin.GetSystemAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSystemAdmin.GetSystemAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSystemAdmin.t.Fatal("No results are set for the ServiceMock.GetSystemAdmin")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGetSystemAdmin.funcGetSystemAdmin != nil {
		return mmGetSystemAdmin.funcGetSystemAdmin(ctx, s1)
	}
	mmGetSystemAdmin.t.Fatalf("Unexpected call to ServiceMock.GetSystemAdmin. %v %v", ctx, s1)
	return
}

// GetSystemAdminAfterCounter returns a count of finished ServiceMock.GetSystemAdmin invocations
func (mmGetSystemAdmin *ServiceMock) GetSystemAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSystemAdmin.afterGetSystemAdminCounter)
}

// GetSystemAdminBeforeCounter returns a count of ServiceMock.GetSystemAdmin invocations
func (mmGetSystemAdmin *ServiceMock) GetSystemAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSystemAdmin.beforeGetSystemAdminCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetSystemAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSystemAdmin *mServiceMockGetSystemAdmin) Calls() []*ServiceMockGetSystemAdminParams {
	mmGetSystemAdmin.mutex.RLock()

	argCopy := make([]*ServiceMockGetSystemAdminParams, len(mmGetSystemAdmin.callArgs))
	copy(argCopy, mmGetSystemAdmin.callArgs)

	mmGetSystemAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockGetSystemAdminDone returns true if the count of the GetSystemAdmin invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetSystemAdminDone() bool {
	if m.GetSystemAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetSystemAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetSystemAdminMock.invocationsDone()
}

// MinimockGetSystemAdminInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetSystemAdminInspect() {
	for _, e := range m.GetSystemAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetSystemAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetSystemAdminCounter := mm_atomic.LoadUint64(&m.afterGetSystemAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetSystemAdminMock.defaultExpectation != nil && afterGetSystemAdminCounter < 1 {
		if m.GetSystemAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetSystemAdmin at\n%s", m.GetSystemAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetSystemAdmin at\n%s with params: %#v", m.GetSystemAdminMock.defaultExpectation.expectationOrigins.origin, *m.GetSystemAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSystemAdmin != nil && afterGetSystemAdminCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetSystemAdmin at\n%s", m.funcGetSystemAdminOrigin)
	}

	if !m.GetSystemAdminMock.invocationsDone() && afterGetSystemAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetSystemAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetSystemAdminMock.expectedInvocations), m.GetSystemAdminMock.expectedInvocationsOrigin, afterGetSystemAdminCounter)
	}
}

type mServiceMockGetTextChunkFilePathsByFileUID struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetTextChunkFilePathsByFileUIDExpectation
	expectations       []*ServiceMockGetTextChunkFilePathsByFileUIDExpectation

	callArgs []*ServiceMockGetTextChunkFilePathsByFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetTextChunkFilePathsByFileUIDExpectation specifies expectation struct of the Service.GetTextChunkFilePathsByFileUID
type ServiceMockGetTextChunkFilePathsByFileUIDExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetTextChunkFilePathsByFileUIDParams
	paramPtrs          *ServiceMockGetTextChunkFilePathsByFileUIDParamPtrs
	expectationOrigins ServiceMockGetTextChunkFilePathsByFileUIDExpectationOrigins
	results            *ServiceMockGetTextChunkFilePathsByFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetTextChunkFilePathsByFileUIDParams contains parameters of the Service.GetTextChunkFilePathsByFileUID
type ServiceMockGetTextChunkFilePathsByFileUIDParams struct {
	ctx context.Context
	k1  types.KBUIDType
	f1  types.FileUIDType
}

// ServiceMockGetTextChunkFilePathsByFileUIDParamPtrs contains pointers to parameters of the Service.GetTextChunkFilePathsByFileUID
type ServiceMockGetTextChunkFilePathsByFileUIDParamPtrs struct {
	ctx *context.Context
	k1  *types.KBUIDType
	f1  *types.FileUIDType
}

// ServiceMockGetTextChunkFilePathsByFileUIDResults contains results of the Service.GetTextChunkFilePathsByFileUID
type ServiceMockGetTextChunkFilePathsByFileUIDResults struct {
	sa1 []string
	err error
}

// ServiceMockGetTextChunkFilePathsByFileUIDOrigins contains origins of expectations of the Service.GetTextChunkFilePathsByFileUID
type ServiceMockGetTextChunkFilePathsByFileUIDExpectationOrigins struct {
	origin    string
	originCtx string
	originK1  string
	originF1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetTextChunkFilePathsByFileUID *mServiceMockGetTextChunkFilePathsByFileUID) Optional() *mServiceMockGetTextChunkFilePathsByFileUID {
	mmGetTextChunkFilePathsByFileUID.optional = true
	return mmGetTextChunkFilePathsByFileUID
}

// Expect sets up expected params for Service.GetTextChunkFilePathsByFileUID
func (mmGetTextChunkFilePathsByFileUID *mServiceMockGetTextChunkFilePathsByFileUID) Expect(ctx context.Context, k1 types.KBUIDType, f1 types.FileUIDType) *mServiceMockGetTextChunkFilePathsByFileUID {
	if mmGetTextChunkFilePathsByFileUID.mock.funcGetTextChunkFilePathsByFileUID != nil {
		mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetTextChunkFilePathsByFileUID mock is already set by Set")
	}

	if mmGetTextChunkFilePathsByFileUID.defaultExpectation == nil {
		mmGetTextChunkFilePathsByFileUID.defaultExpectation = &ServiceMockGetTextChunkFilePathsByFileUIDExpectation{}
	}

	if mmGetTextChunkFilePathsByFileUID.defaultExpectation.paramPtrs != nil {
		mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetTextChunkFilePathsByFileUID mock is already set by ExpectParams functions")
	}

	mmGetTextChunkFilePathsByFileUID.defaultExpectation.params = &ServiceMockGetTextChunkFilePathsByFileUIDParams{ctx, k1, f1}
	mmGetTextChunkFilePathsByFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetTextChunkFilePathsByFileUID.expectations {
		if minimock.Equal(e.params, mmGetTextChunkFilePathsByFileUID.defaultExpectation.params) {
			mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTextChunkFilePathsByFileUID.defaultExpectation.params)
		}
	}

	return mmGetTextChunkFilePathsByFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetTextChunkFilePathsByFileUID
func (mmGetTextChunkFilePathsByFileUID *mServiceMockGetTextChunkFilePathsByFileUID) ExpectCtxParam1(ctx context.Context) *mServiceMockGetTextChunkFilePathsByFileUID {
	if mmGetTextChunkFilePathsByFileUID.mock.funcGetTextChunkFilePathsByFileUID != nil {
		mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetTextChunkFilePathsByFileUID mock is already set by Set")
	}

	if mmGetTextChunkFilePathsByFileUID.defaultExpectation == nil {
		mmGetTextChunkFilePathsByFileUID.defaultExpectation = &ServiceMockGetTextChunkFilePathsByFileUIDExpectation{}
	}

	if mmGetTextChunkFilePathsByFileUID.defaultExpectation.params != nil {
		mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetTextChunkFilePathsByFileUID mock is already set by Expect")
	}

	if mmGetTextChunkFilePathsByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetTextChunkFilePathsByFileUID.defaultExpectation.paramPtrs = &ServiceMockGetTextChunkFilePathsByFileUIDParamPtrs{}
	}
	mmGetTextChunkFilePathsByFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetTextChunkFilePathsByFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetTextChunkFilePathsByFileUID
}

// ExpectK1Param2 sets up expected param k1 for Service.GetTextChunkFilePathsByFileUID
func (mmGetTextChunkFilePathsByFileUID *mServiceMockGetTextChunkFilePathsByFileUID) ExpectK1Param2(k1 types.KBUIDType) *mServiceMockGetTextChunkFilePathsByFileUID {
	if mmGetTextChunkFilePathsByFileUID.mock.funcGetTextChunkFilePathsByFileUID != nil {
		mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetTextChunkFilePathsByFileUID mock is already set by Set")
	}

	if mmGetTextChunkFilePathsByFileUID.defaultExpectation == nil {
		mmGetTextChunkFilePathsByFileUID.defaultExpectation = &ServiceMockGetTextChunkFilePathsByFileUIDExpectation{}
	}

	if mmGetTextChunkFilePathsByFileUID.defaultExpectation.params != nil {
		mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetTextChunkFilePathsByFileUID mock is already set by Expect")
	}

	if mmGetTextChunkFilePathsByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetTextChunkFilePathsByFileUID.defaultExpectation.paramPtrs = &ServiceMockGetTextChunkFilePathsByFileUIDParamPtrs{}
	}
	mmGetTextChunkFilePathsByFileUID.defaultExpectation.paramPtrs.k1 = &k1
	mmGetTextChunkFilePathsByFileUID.defaultExpectation.expectationOrigins.originK1 = minimock.CallerInfo(1)

	return mmGetTextChunkFilePathsByFileUID
}

// ExpectF1Param3 sets up expected param f1 for Service.GetTextChunkFilePathsByFileUID
func (mmGetTextChunkFilePathsByFileUID *mServiceMockGetTextChunkFilePathsByFileUID) ExpectF1Param3(f1 types.FileUIDType) *mServiceMockGetTextChunkFilePathsByFileUID {
	if mmGetTextChunkFilePathsByFileUID.mock.funcGetTextChunkFilePathsByFileUID != nil {
		mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetTextChunkFilePathsByFileUID mock is already set by Set")
	}

	if mmGetTextChunkFilePathsByFileUID.defaultExpectation == nil {
		mmGetTextChunkFilePathsByFileUID.defaultExpectation = &ServiceMockGetTextChunkFilePathsByFileUIDExpectation{}
	}

	if mmGetTextChunkFilePathsByFileUID.defaultExpectation.params != nil {
		mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetTextChunkFilePathsByFileUID mock is already set by Expect")
	}

	if mmGetTextChunkFilePathsByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetTextChunkFilePathsByFileUID.defaultExpectation.paramPtrs = &ServiceMockGetTextChunkFilePathsByFileUIDParamPtrs{}
	}
	mmGetTextChunkFilePathsByFileUID.defaultExpectation.paramPtrs.f1 = &f1
	mmGetTextChunkFilePathsByFileUID.defaultExpectation.expectationOrigins.originF1 = minimock.CallerInfo(1)

	return mmGetTextChunkFilePathsByFileUID
}

// Inspect accepts an inspector function that has same arguments as the Service.GetTextChunkFilePathsByFileUID
func (mmGetTextChunkFilePathsByFileUID *mServiceMockGetTextChunkFilePathsByFileUID) Inspect(f func(ctx context.Context, k1 types.KBUIDType, f1 types.FileUIDType)) *mServiceMockGetTextChunkFilePathsByFileUID {
	if mmGetTextChunkFilePathsByFileUID.mock.inspectFuncGetTextChunkFilePathsByFileUID != nil {
		mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetTextChunkFilePathsByFileUID")
	}

	mmGetTextChunkFilePathsByFileUID.mock.inspectFuncGetTextChunkFilePathsByFileUID = f

	return mmGetTextChunkFilePathsByFileUID
}

// Return sets up results that will be returned by Service.GetTextChunkFilePathsByFileUID
func (mmGetTextChunkFilePathsByFileUID *mServiceMockGetTextChunkFilePathsByFileUID) Return(sa1 []string, err error) *ServiceMock {
	if mmGetTextChunkFilePathsByFileUID.mock.funcGetTextChunkFilePathsByFileUID != nil {
		mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetTextChunkFilePathsByFileUID mock is already set by Set")
	}

	if mmGetTextChunkFilePathsByFileUID.defaultExpectation == nil {
		mmGetTextChunkFilePathsByFileUID.defaultExpectation = &ServiceMockGetTextChunkFilePathsByFileUIDExpectation{mock: mmGetTextChunkFilePathsByFileUID.mock}
	}
	mmGetTextChunkFilePathsByFileUID.defaultExpectation.results = &ServiceMockGetTextChunkFilePathsByFileUIDResults{sa1, err}
	mmGetTextChunkFilePathsByFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetTextChunkFilePathsByFileUID.mock
}

// Set uses given function f to mock the Service.GetTextChunkFilePathsByFileUID method
func (mmGetTextChunkFilePathsByFileUID *mServiceMockGetTextChunkFilePathsByFileUID) Set(f func(ctx context.Context, k1 types.KBUIDType, f1 types.FileUIDType) (sa1 []string, err error)) *ServiceMock {
	if mmGetTextChunkFilePathsByFileUID.defaultExpectation != nil {
		mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("Default expectation is already set for the Service.GetTextChunkFilePathsByFileUID method")
	}

	if len(mmGetTextChunkFilePathsByFileUID.expectations) > 0 {
		mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("Some expectations are already set for the Service.GetTextChunkFilePathsByFileUID method")
	}

	mmGetTextChunkFilePathsByFileUID.mock.funcGetTextChunkFilePathsByFileUID = f
	mmGetTextChunkFilePathsByFileUID.mock.funcGetTextChunkFilePathsByFileUIDOrigin = minimock.CallerInfo(1)
	return mmGetTextChunkFilePathsByFileUID.mock
}

// When sets expectation for the Service.GetTextChunkFilePathsByFileUID which will trigger the result defined by the following
// Then helper
func (mmGetTextChunkFilePathsByFileUID *mServiceMockGetTextChunkFilePathsByFileUID) When(ctx context.Context, k1 types.KBUIDType, f1 types.FileUIDType) *ServiceMockGetTextChunkFilePathsByFileUIDExpectation {
	if mmGetTextChunkFilePathsByFileUID.mock.funcGetTextChunkFilePathsByFileUID != nil {
		mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("ServiceMock.GetTextChunkFilePathsByFileUID mock is already set by Set")
	}

	expectation := &ServiceMockGetTextChunkFilePathsByFileUIDExpectation{
		mock:               mmGetTextChunkFilePathsByFileUID.mock,
		params:             &ServiceMockGetTextChunkFilePathsByFileUIDParams{ctx, k1, f1},
		expectationOrigins: ServiceMockGetTextChunkFilePathsByFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetTextChunkFilePathsByFileUID.expectations = append(mmGetTextChunkFilePathsByFileUID.expectations, expectation)
	return expectation
}

// Then sets up Service.GetTextChunkFilePathsByFileUID return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetTextChunkFilePathsByFileUIDExpectation) Then(sa1 []string, err error) *ServiceMock {
	e.results = &ServiceMockGetTextChunkFilePathsByFileUIDResults{sa1, err}
	return e.mock
}

// Times sets number of times Service.GetTextChunkFilePathsByFileUID should be invoked
func (mmGetTextChunkFilePathsByFileUID *mServiceMockGetTextChunkFilePathsByFileUID) Times(n uint64) *mServiceMockGetTextChunkFilePathsByFileUID {
	if n == 0 {
		mmGetTextChunkFilePathsByFileUID.mock.t.Fatalf("Times of ServiceMock.GetTextChunkFilePathsByFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTextChunkFilePathsByFileUID.expectedInvocations, n)
	mmGetTextChunkFilePathsByFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetTextChunkFilePathsByFileUID
}

func (mmGetTextChunkFilePathsByFileUID *mServiceMockGetTextChunkFilePathsByFileUID) invocationsDone() bool {
	if len(mmGetTextChunkFilePathsByFileUID.expectations) == 0 && mmGetTextChunkFilePathsByFileUID.defaultExpectation == nil && mmGetTextChunkFilePathsByFileUID.mock.funcGetTextChunkFilePathsByFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTextChunkFilePathsByFileUID.mock.afterGetTextChunkFilePathsByFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTextChunkFilePathsByFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTextChunkFilePathsByFileUID implements mm_service.Service
func (mmGetTextChunkFilePathsByFileUID *ServiceMock) GetTextChunkFilePathsByFileUID(ctx context.Context, k1 types.KBUIDType, f1 types.FileUIDType) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmGetTextChunkFilePathsByFileUID.beforeGetTextChunkFilePathsByFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTextChunkFilePathsByFileUID.afterGetTextChunkFilePathsByFileUIDCounter, 1)

	mmGetTextChunkFilePathsByFileUID.t.Helper()

	if mmGetTextChunkFilePathsByFileUID.inspectFuncGetTextChunkFilePathsByFileUID != nil {
		mmGetTextChunkFilePathsByFileUID.inspectFuncGetTextChunkFilePathsByFileUID(ctx, k1, f1)
	}

	mm_params := ServiceMockGetTextChunkFilePathsByFileUIDParams{ctx, k1, f1}

	// Record call args
	mmGetTextChunkFilePathsByFileUID.GetTextChunkFilePathsByFileUIDMock.mutex.Lock()
	mmGetTextChunkFilePathsByFileUID.GetTextChunkFilePathsByFileUIDMock.callArgs = append(mmGetTextChunkFilePathsByFileUID.GetTextChunkFilePathsByFileUIDMock.callArgs, &mm_params)
	mmGetTextChunkFilePathsByFileUID.GetTextChunkFilePathsByFileUIDMock.mutex.Unlock()

	for _, e := range mmGetTextChunkFilePathsByFileUID.GetTextChunkFilePathsByFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmGetTextChunkFilePathsByFileUID.GetTextChunkFilePathsByFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTextChunkFilePathsByFileUID.GetTextChunkFilePathsByFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTextChunkFilePathsByFileUID.GetTextChunkFilePathsByFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetTextChunkFilePathsByFileUID.GetTextChunkFilePathsByFileUIDMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetTextChunkFilePathsByFileUIDParams{ctx, k1, f1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTextChunkFilePathsByFileUID.t.Errorf("ServiceMock.GetTextChunkFilePathsByFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTextChunkFilePathsByFileUID.GetTextChunkFilePathsByFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.k1 != nil && !minimock.Equal(*mm_want_ptrs.k1, mm_got.k1) {
				mmGetTextChunkFilePathsByFileUID.t.Errorf("ServiceMock.GetTextChunkFilePathsByFileUID got unexpected parameter k1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTextChunkFilePathsByFileUID.GetTextChunkFilePathsByFileUIDMock.defaultExpectation.expectationOrigins.originK1, *mm_want_ptrs.k1, mm_got.k1, minimock.Diff(*mm_want_ptrs.k1, mm_got.k1))
			}

			if mm_want_ptrs.f1 != nil && !minimock.Equal(*mm_want_ptrs.f1, mm_got.f1) {
				mmGetTextChunkFilePathsByFileUID.t.Errorf("ServiceMock.GetTextChunkFilePathsByFileUID got unexpected parameter f1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTextChunkFilePathsByFileUID.GetTextChunkFilePathsByFileUIDMock.defaultExpectation.expectationOrigins.originF1, *mm_want_ptrs.f1, mm_got.f1, minimock.Diff(*mm_want_ptrs.f1, mm_got.f1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTextChunkFilePathsByFileUID.t.Errorf("ServiceMock.GetTextChunkFilePathsByFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetTextChunkFilePathsByFileUID.GetTextChunkFilePathsByFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTextChunkFilePathsByFileUID.GetTextChunkFilePathsByFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTextChunkFilePathsByFileUID.t.Fatal("No results are set for the ServiceMock.GetTextChunkFilePathsByFileUID")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmGetTextChunkFilePathsByFileUID.funcGetTextChunkFilePathsByFileUID != nil {
		return mmGetTextChunkFilePathsByFileUID.funcGetTextChunkFilePathsByFileUID(ctx, k1, f1)
	}
	mmGetTextChunkFilePathsByFileUID.t.Fatalf("Unexpected call to ServiceMock.GetTextChunkFilePathsByFileUID. %v %v %v", ctx, k1, f1)
	return
}

// GetTextChunkFilePathsByFileUIDAfterCounter returns a count of finished ServiceMock.GetTextChunkFilePathsByFileUID invocations
func (mmGetTextChunkFilePathsByFileUID *ServiceMock) GetTextChunkFilePathsByFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTextChunkFilePathsByFileUID.afterGetTextChunkFilePathsByFileUIDCounter)
}

// GetTextChunkFilePathsByFileUIDBeforeCounter returns a count of ServiceMock.GetTextChunkFilePathsByFileUID invocations
func (mmGetTextChunkFilePathsByFileUID *ServiceMock) GetTextChunkFilePathsByFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTextChunkFilePathsByFileUID.beforeGetTextChunkFilePathsByFileUIDCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetTextChunkFilePathsByFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTextChunkFilePathsByFileUID *mServiceMockGetTextChunkFilePathsByFileUID) Calls() []*ServiceMockGetTextChunkFilePathsByFileUIDParams {
	mmGetTextChunkFilePathsByFileUID.mutex.RLock()

	argCopy := make([]*ServiceMockGetTextChunkFilePathsByFileUIDParams, len(mmGetTextChunkFilePathsByFileUID.callArgs))
	copy(argCopy, mmGetTextChunkFilePathsByFileUID.callArgs)

	mmGetTextChunkFilePathsByFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetTextChunkFilePathsByFileUIDDone returns true if the count of the GetTextChunkFilePathsByFileUID invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetTextChunkFilePathsByFileUIDDone() bool {
	if m.GetTextChunkFilePathsByFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetTextChunkFilePathsByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTextChunkFilePathsByFileUIDMock.invocationsDone()
}

// MinimockGetTextChunkFilePathsByFileUIDInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetTextChunkFilePathsByFileUIDInspect() {
	for _, e := range m.GetTextChunkFilePathsByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetTextChunkFilePathsByFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetTextChunkFilePathsByFileUIDCounter := mm_atomic.LoadUint64(&m.afterGetTextChunkFilePathsByFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTextChunkFilePathsByFileUIDMock.defaultExpectation != nil && afterGetTextChunkFilePathsByFileUIDCounter < 1 {
		if m.GetTextChunkFilePathsByFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetTextChunkFilePathsByFileUID at\n%s", m.GetTextChunkFilePathsByFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetTextChunkFilePathsByFileUID at\n%s with params: %#v", m.GetTextChunkFilePathsByFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetTextChunkFilePathsByFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTextChunkFilePathsByFileUID != nil && afterGetTextChunkFilePathsByFileUIDCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetTextChunkFilePathsByFileUID at\n%s", m.funcGetTextChunkFilePathsByFileUIDOrigin)
	}

	if !m.GetTextChunkFilePathsByFileUIDMock.invocationsDone() && afterGetTextChunkFilePathsByFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetTextChunkFilePathsByFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetTextChunkFilePathsByFileUIDMock.expectedInvocations), m.GetTextChunkFilePathsByFileUIDMock.expectedInvocationsOrigin, afterGetTextChunkFilePathsByFileUIDCounter)
	}
}

type mServiceMockGetUploadURL struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetUploadURLExpectation
	expectations       []*ServiceMockGetUploadURLExpectation

	callArgs []*ServiceMockGetUploadURLParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetUploadURLExpectation specifies expectation struct of the Service.GetUploadURL
type ServiceMockGetUploadURLExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetUploadURLParams
	paramPtrs          *ServiceMockGetUploadURLParamPtrs
	expectationOrigins ServiceMockGetUploadURLExpectationOrigins
	results            *ServiceMockGetUploadURLResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetUploadURLParams contains parameters of the Service.GetUploadURL
type ServiceMockGetUploadURLParams struct {
	ctx context.Context
	gp1 *artifactpb.GetObjectUploadURLRequest
	n1  types.NamespaceUIDType
	s1  string
	c2  types.CreatorUIDType
}

// ServiceMockGetUploadURLParamPtrs contains pointers to parameters of the Service.GetUploadURL
type ServiceMockGetUploadURLParamPtrs struct {
	ctx *context.Context
	gp1 **artifactpb.GetObjectUploadURLRequest
	n1  *types.NamespaceUIDType
	s1  *string
	c2  *types.CreatorUIDType
}

// ServiceMockGetUploadURLResults contains results of the Service.GetUploadURL
type ServiceMockGetUploadURLResults struct {
	gp2 *artifactpb.GetObjectUploadURLResponse
	err error
}

// ServiceMockGetUploadURLOrigins contains origins of expectations of the Service.GetUploadURL
type ServiceMockGetUploadURLExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
	originN1  string
	originS1  string
	originC2  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUploadURL *mServiceMockGetUploadURL) Optional() *mServiceMockGetUploadURL {
	mmGetUploadURL.optional = true
	return mmGetUploadURL
}

// Expect sets up expected params for Service.GetUploadURL
func (mmGetUploadURL *mServiceMockGetUploadURL) Expect(ctx context.Context, gp1 *artifactpb.GetObjectUploadURLRequest, n1 types.NamespaceUIDType, s1 string, c2 types.CreatorUIDType) *mServiceMockGetUploadURL {
	if mmGetUploadURL.mock.funcGetUploadURL != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Set")
	}

	if mmGetUploadURL.defaultExpectation == nil {
		mmGetUploadURL.defaultExpectation = &ServiceMockGetUploadURLExpectation{}
	}

	if mmGetUploadURL.defaultExpectation.paramPtrs != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by ExpectParams functions")
	}

	mmGetUploadURL.defaultExpectation.params = &ServiceMockGetUploadURLParams{ctx, gp1, n1, s1, c2}
	mmGetUploadURL.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUploadURL.expectations {
		if minimock.Equal(e.params, mmGetUploadURL.defaultExpectation.params) {
			mmGetUploadURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUploadURL.defaultExpectation.params)
		}
	}

	return mmGetUploadURL
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetUploadURL
func (mmGetUploadURL *mServiceMockGetUploadURL) ExpectCtxParam1(ctx context.Context) *mServiceMockGetUploadURL {
	if mmGetUploadURL.mock.funcGetUploadURL != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Set")
	}

	if mmGetUploadURL.defaultExpectation == nil {
		mmGetUploadURL.defaultExpectation = &ServiceMockGetUploadURLExpectation{}
	}

	if mmGetUploadURL.defaultExpectation.params != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Expect")
	}

	if mmGetUploadURL.defaultExpectation.paramPtrs == nil {
		mmGetUploadURL.defaultExpectation.paramPtrs = &ServiceMockGetUploadURLParamPtrs{}
	}
	mmGetUploadURL.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUploadURL.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUploadURL
}

// ExpectGp1Param2 sets up expected param gp1 for Service.GetUploadURL
func (mmGetUploadURL *mServiceMockGetUploadURL) ExpectGp1Param2(gp1 *artifactpb.GetObjectUploadURLRequest) *mServiceMockGetUploadURL {
	if mmGetUploadURL.mock.funcGetUploadURL != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Set")
	}

	if mmGetUploadURL.defaultExpectation == nil {
		mmGetUploadURL.defaultExpectation = &ServiceMockGetUploadURLExpectation{}
	}

	if mmGetUploadURL.defaultExpectation.params != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Expect")
	}

	if mmGetUploadURL.defaultExpectation.paramPtrs == nil {
		mmGetUploadURL.defaultExpectation.paramPtrs = &ServiceMockGetUploadURLParamPtrs{}
	}
	mmGetUploadURL.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetUploadURL.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetUploadURL
}

// ExpectN1Param3 sets up expected param n1 for Service.GetUploadURL
func (mmGetUploadURL *mServiceMockGetUploadURL) ExpectN1Param3(n1 types.NamespaceUIDType) *mServiceMockGetUploadURL {
	if mmGetUploadURL.mock.funcGetUploadURL != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Set")
	}

	if mmGetUploadURL.defaultExpectation == nil {
		mmGetUploadURL.defaultExpectation = &ServiceMockGetUploadURLExpectation{}
	}

	if mmGetUploadURL.defaultExpectation.params != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Expect")
	}

	if mmGetUploadURL.defaultExpectation.paramPtrs == nil {
		mmGetUploadURL.defaultExpectation.paramPtrs = &ServiceMockGetUploadURLParamPtrs{}
	}
	mmGetUploadURL.defaultExpectation.paramPtrs.n1 = &n1
	mmGetUploadURL.defaultExpectation.expectationOrigins.originN1 = minimock.CallerInfo(1)

	return mmGetUploadURL
}

// ExpectS1Param4 sets up expected param s1 for Service.GetUploadURL
func (mmGetUploadURL *mServiceMockGetUploadURL) ExpectS1Param4(s1 string) *mServiceMockGetUploadURL {
	if mmGetUploadURL.mock.funcGetUploadURL != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Set")
	}

	if mmGetUploadURL.defaultExpectation == nil {
		mmGetUploadURL.defaultExpectation = &ServiceMockGetUploadURLExpectation{}
	}

	if mmGetUploadURL.defaultExpectation.params != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Expect")
	}

	if mmGetUploadURL.defaultExpectation.paramPtrs == nil {
		mmGetUploadURL.defaultExpectation.paramPtrs = &ServiceMockGetUploadURLParamPtrs{}
	}
	mmGetUploadURL.defaultExpectation.paramPtrs.s1 = &s1
	mmGetUploadURL.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmGetUploadURL
}

// ExpectC2Param5 sets up expected param c2 for Service.GetUploadURL
func (mmGetUploadURL *mServiceMockGetUploadURL) ExpectC2Param5(c2 types.CreatorUIDType) *mServiceMockGetUploadURL {
	if mmGetUploadURL.mock.funcGetUploadURL != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Set")
	}

	if mmGetUploadURL.defaultExpectation == nil {
		mmGetUploadURL.defaultExpectation = &ServiceMockGetUploadURLExpectation{}
	}

	if mmGetUploadURL.defaultExpectation.params != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Expect")
	}

	if mmGetUploadURL.defaultExpectation.paramPtrs == nil {
		mmGetUploadURL.defaultExpectation.paramPtrs = &ServiceMockGetUploadURLParamPtrs{}
	}
	mmGetUploadURL.defaultExpectation.paramPtrs.c2 = &c2
	mmGetUploadURL.defaultExpectation.expectationOrigins.originC2 = minimock.CallerInfo(1)

	return mmGetUploadURL
}

// Inspect accepts an inspector function that has same arguments as the Service.GetUploadURL
func (mmGetUploadURL *mServiceMockGetUploadURL) Inspect(f func(ctx context.Context, gp1 *artifactpb.GetObjectUploadURLRequest, n1 types.NamespaceUIDType, s1 string, c2 types.CreatorUIDType)) *mServiceMockGetUploadURL {
	if mmGetUploadURL.mock.inspectFuncGetUploadURL != nil {
		mmGetUploadURL.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetUploadURL")
	}

	mmGetUploadURL.mock.inspectFuncGetUploadURL = f

	return mmGetUploadURL
}

// Return sets up results that will be returned by Service.GetUploadURL
func (mmGetUploadURL *mServiceMockGetUploadURL) Return(gp2 *artifactpb.GetObjectUploadURLResponse, err error) *ServiceMock {
	if mmGetUploadURL.mock.funcGetUploadURL != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Set")
	}

	if mmGetUploadURL.defaultExpectation == nil {
		mmGetUploadURL.defaultExpectation = &ServiceMockGetUploadURLExpectation{mock: mmGetUploadURL.mock}
	}
	mmGetUploadURL.defaultExpectation.results = &ServiceMockGetUploadURLResults{gp2, err}
	mmGetUploadURL.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUploadURL.mock
}

// Set uses given function f to mock the Service.GetUploadURL method
func (mmGetUploadURL *mServiceMockGetUploadURL) Set(f func(ctx context.Context, gp1 *artifactpb.GetObjectUploadURLRequest, n1 types.NamespaceUIDType, s1 string, c2 types.CreatorUIDType) (gp2 *artifactpb.GetObjectUploadURLResponse, err error)) *ServiceMock {
	if mmGetUploadURL.defaultExpectation != nil {
		mmGetUploadURL.mock.t.Fatalf("Default expectation is already set for the Service.GetUploadURL method")
	}

	if len(mmGetUploadURL.expectations) > 0 {
		mmGetUploadURL.mock.t.Fatalf("Some expectations are already set for the Service.GetUploadURL method")
	}

	mmGetUploadURL.mock.funcGetUploadURL = f
	mmGetUploadURL.mock.funcGetUploadURLOrigin = minimock.CallerInfo(1)
	return mmGetUploadURL.mock
}

// When sets expectation for the Service.GetUploadURL which will trigger the result defined by the following
// Then helper
func (mmGetUploadURL *mServiceMockGetUploadURL) When(ctx context.Context, gp1 *artifactpb.GetObjectUploadURLRequest, n1 types.NamespaceUIDType, s1 string, c2 types.CreatorUIDType) *ServiceMockGetUploadURLExpectation {
	if mmGetUploadURL.mock.funcGetUploadURL != nil {
		mmGetUploadURL.mock.t.Fatalf("ServiceMock.GetUploadURL mock is already set by Set")
	}

	expectation := &ServiceMockGetUploadURLExpectation{
		mock:               mmGetUploadURL.mock,
		params:             &ServiceMockGetUploadURLParams{ctx, gp1, n1, s1, c2},
		expectationOrigins: ServiceMockGetUploadURLExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUploadURL.expectations = append(mmGetUploadURL.expectations, expectation)
	return expectation
}

// Then sets up Service.GetUploadURL return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetUploadURLExpectation) Then(gp2 *artifactpb.GetObjectUploadURLResponse, err error) *ServiceMock {
	e.results = &ServiceMockGetUploadURLResults{gp2, err}
	return e.mock
}

// Times sets number of times Service.GetUploadURL should be invoked
func (mmGetUploadURL *mServiceMockGetUploadURL) Times(n uint64) *mServiceMockGetUploadURL {
	if n == 0 {
		mmGetUploadURL.mock.t.Fatalf("Times of ServiceMock.GetUploadURL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUploadURL.expectedInvocations, n)
	mmGetUploadURL.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUploadURL
}

func (mmGetUploadURL *mServiceMockGetUploadURL) invocationsDone() bool {
	if len(mmGetUploadURL.expectations) == 0 && mmGetUploadURL.defaultExpectation == nil && mmGetUploadURL.mock.funcGetUploadURL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUploadURL.mock.afterGetUploadURLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUploadURL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUploadURL implements mm_service.Service
func (mmGetUploadURL *ServiceMock) GetUploadURL(ctx context.Context, gp1 *artifactpb.GetObjectUploadURLRequest, n1 types.NamespaceUIDType, s1 string, c2 types.CreatorUIDType) (gp2 *artifactpb.GetObjectUploadURLResponse, err error) {
	mm_atomic.AddUint64(&mmGetUploadURL.beforeGetUploadURLCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUploadURL.afterGetUploadURLCounter, 1)

	mmGetUploadURL.t.Helper()

	if mmGetUploadURL.inspectFuncGetUploadURL != nil {
		mmGetUploadURL.inspectFuncGetUploadURL(ctx, gp1, n1, s1, c2)
	}

	mm_params := ServiceMockGetUploadURLParams{ctx, gp1, n1, s1, c2}

	// Record call args
	mmGetUploadURL.GetUploadURLMock.mutex.Lock()
	mmGetUploadURL.GetUploadURLMock.callArgs = append(mmGetUploadURL.GetUploadURLMock.callArgs, &mm_params)
	mmGetUploadURL.GetUploadURLMock.mutex.Unlock()

	for _, e := range mmGetUploadURL.GetUploadURLMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetUploadURL.GetUploadURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUploadURL.GetUploadURLMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUploadURL.GetUploadURLMock.defaultExpectation.params
		mm_want_ptrs := mmGetUploadURL.GetUploadURLMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetUploadURLParams{ctx, gp1, n1, s1, c2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUploadURL.t.Errorf("ServiceMock.GetUploadURL got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUploadURL.GetUploadURLMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetUploadURL.t.Errorf("ServiceMock.GetUploadURL got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUploadURL.GetUploadURLMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

			if mm_want_ptrs.n1 != nil && !minimock.Equal(*mm_want_ptrs.n1, mm_got.n1) {
				mmGetUploadURL.t.Errorf("ServiceMock.GetUploadURL got unexpected parameter n1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUploadURL.GetUploadURLMock.defaultExpectation.expectationOrigins.originN1, *mm_want_ptrs.n1, mm_got.n1, minimock.Diff(*mm_want_ptrs.n1, mm_got.n1))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmGetUploadURL.t.Errorf("ServiceMock.GetUploadURL got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUploadURL.GetUploadURLMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

			if mm_want_ptrs.c2 != nil && !minimock.Equal(*mm_want_ptrs.c2, mm_got.c2) {
				mmGetUploadURL.t.Errorf("ServiceMock.GetUploadURL got unexpected parameter c2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUploadURL.GetUploadURLMock.defaultExpectation.expectationOrigins.originC2, *mm_want_ptrs.c2, mm_got.c2, minimock.Diff(*mm_want_ptrs.c2, mm_got.c2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUploadURL.t.Errorf("ServiceMock.GetUploadURL got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUploadURL.GetUploadURLMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUploadURL.GetUploadURLMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUploadURL.t.Fatal("No results are set for the ServiceMock.GetUploadURL")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetUploadURL.funcGetUploadURL != nil {
		return mmGetUploadURL.funcGetUploadURL(ctx, gp1, n1, s1, c2)
	}
	mmGetUploadURL.t.Fatalf("Unexpected call to ServiceMock.GetUploadURL. %v %v %v %v %v", ctx, gp1, n1, s1, c2)
	return
}

// GetUploadURLAfterCounter returns a count of finished ServiceMock.GetUploadURL invocations
func (mmGetUploadURL *ServiceMock) GetUploadURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUploadURL.afterGetUploadURLCounter)
}

// GetUploadURLBeforeCounter returns a count of ServiceMock.GetUploadURL invocations
func (mmGetUploadURL *ServiceMock) GetUploadURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUploadURL.beforeGetUploadURLCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetUploadURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUploadURL *mServiceMockGetUploadURL) Calls() []*ServiceMockGetUploadURLParams {
	mmGetUploadURL.mutex.RLock()

	argCopy := make([]*ServiceMockGetUploadURLParams, len(mmGetUploadURL.callArgs))
	copy(argCopy, mmGetUploadURL.callArgs)

	mmGetUploadURL.mutex.RUnlock()

	return argCopy
}

// MinimockGetUploadURLDone returns true if the count of the GetUploadURL invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetUploadURLDone() bool {
	if m.GetUploadURLMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUploadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUploadURLMock.invocationsDone()
}

// MinimockGetUploadURLInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetUploadURLInspect() {
	for _, e := range m.GetUploadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetUploadURL at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUploadURLCounter := mm_atomic.LoadUint64(&m.afterGetUploadURLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUploadURLMock.defaultExpectation != nil && afterGetUploadURLCounter < 1 {
		if m.GetUploadURLMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetUploadURL at\n%s", m.GetUploadURLMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetUploadURL at\n%s with params: %#v", m.GetUploadURLMock.defaultExpectation.expectationOrigins.origin, *m.GetUploadURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUploadURL != nil && afterGetUploadURLCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetUploadURL at\n%s", m.funcGetUploadURLOrigin)
	}

	if !m.GetUploadURLMock.invocationsDone() && afterGetUploadURLCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetUploadURL at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUploadURLMock.expectedInvocations), m.GetUploadURLMock.expectedInvocationsOrigin, afterGetUploadURLCounter)
	}
}

type mServiceMockListRepositoryTags struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockListRepositoryTagsExpectation
	expectations       []*ServiceMockListRepositoryTagsExpectation

	callArgs []*ServiceMockListRepositoryTagsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockListRepositoryTagsExpectation specifies expectation struct of the Service.ListRepositoryTags
type ServiceMockListRepositoryTagsExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockListRepositoryTagsParams
	paramPtrs          *ServiceMockListRepositoryTagsParamPtrs
	expectationOrigins ServiceMockListRepositoryTagsExpectationOrigins
	results            *ServiceMockListRepositoryTagsResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockListRepositoryTagsParams contains parameters of the Service.ListRepositoryTags
type ServiceMockListRepositoryTagsParams struct {
	ctx context.Context
	lp1 *artifactpb.ListRepositoryTagsRequest
}

// ServiceMockListRepositoryTagsParamPtrs contains pointers to parameters of the Service.ListRepositoryTags
type ServiceMockListRepositoryTagsParamPtrs struct {
	ctx *context.Context
	lp1 **artifactpb.ListRepositoryTagsRequest
}

// ServiceMockListRepositoryTagsResults contains results of the Service.ListRepositoryTags
type ServiceMockListRepositoryTagsResults struct {
	lp2 *artifactpb.ListRepositoryTagsResponse
	err error
}

// ServiceMockListRepositoryTagsOrigins contains origins of expectations of the Service.ListRepositoryTags
type ServiceMockListRepositoryTagsExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListRepositoryTags *mServiceMockListRepositoryTags) Optional() *mServiceMockListRepositoryTags {
	mmListRepositoryTags.optional = true
	return mmListRepositoryTags
}

// Expect sets up expected params for Service.ListRepositoryTags
func (mmListRepositoryTags *mServiceMockListRepositoryTags) Expect(ctx context.Context, lp1 *artifactpb.ListRepositoryTagsRequest) *mServiceMockListRepositoryTags {
	if mmListRepositoryTags.mock.funcListRepositoryTags != nil {
		mmListRepositoryTags.mock.t.Fatalf("ServiceMock.ListRepositoryTags mock is already set by Set")
	}

	if mmListRepositoryTags.defaultExpectation == nil {
		mmListRepositoryTags.defaultExpectation = &ServiceMockListRepositoryTagsExpectation{}
	}

	if mmListRepositoryTags.defaultExpectation.paramPtrs != nil {
		mmListRepositoryTags.mock.t.Fatalf("ServiceMock.ListRepositoryTags mock is already set by ExpectParams functions")
	}

	mmListRepositoryTags.defaultExpectation.params = &ServiceMockListRepositoryTagsParams{ctx, lp1}
	mmListRepositoryTags.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListRepositoryTags.expectations {
		if minimock.Equal(e.params, mmListRepositoryTags.defaultExpectation.params) {
			mmListRepositoryTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListRepositoryTags.defaultExpectation.params)
		}
	}

	return mmListRepositoryTags
}

// ExpectCtxParam1 sets up expected param ctx for Service.ListRepositoryTags
func (mmListRepositoryTags *mServiceMockListRepositoryTags) ExpectCtxParam1(ctx context.Context) *mServiceMockListRepositoryTags {
	if mmListRepositoryTags.mock.funcListRepositoryTags != nil {
		mmListRepositoryTags.mock.t.Fatalf("ServiceMock.ListRepositoryTags mock is already set by Set")
	}

	if mmListRepositoryTags.defaultExpectation == nil {
		mmListRepositoryTags.defaultExpectation = &ServiceMockListRepositoryTagsExpectation{}
	}

	if mmListRepositoryTags.defaultExpectation.params != nil {
		mmListRepositoryTags.mock.t.Fatalf("ServiceMock.ListRepositoryTags mock is already set by Expect")
	}

	if mmListRepositoryTags.defaultExpectation.paramPtrs == nil {
		mmListRepositoryTags.defaultExpectation.paramPtrs = &ServiceMockListRepositoryTagsParamPtrs{}
	}
	mmListRepositoryTags.defaultExpectation.paramPtrs.ctx = &ctx
	mmListRepositoryTags.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListRepositoryTags
}

// ExpectLp1Param2 sets up expected param lp1 for Service.ListRepositoryTags
func (mmListRepositoryTags *mServiceMockListRepositoryTags) ExpectLp1Param2(lp1 *artifactpb.ListRepositoryTagsRequest) *mServiceMockListRepositoryTags {
	if mmListRepositoryTags.mock.funcListRepositoryTags != nil {
		mmListRepositoryTags.mock.t.Fatalf("ServiceMock.ListRepositoryTags mock is already set by Set")
	}

	if mmListRepositoryTags.defaultExpectation == nil {
		mmListRepositoryTags.defaultExpectation = &ServiceMockListRepositoryTagsExpectation{}
	}

	if mmListRepositoryTags.defaultExpectation.params != nil {
		mmListRepositoryTags.mock.t.Fatalf("ServiceMock.ListRepositoryTags mock is already set by Expect")
	}

	if mmListRepositoryTags.defaultExpectation.paramPtrs == nil {
		mmListRepositoryTags.defaultExpectation.paramPtrs = &ServiceMockListRepositoryTagsParamPtrs{}
	}
	mmListRepositoryTags.defaultExpectation.paramPtrs.lp1 = &lp1
	mmListRepositoryTags.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmListRepositoryTags
}

// Inspect accepts an inspector function that has same arguments as the Service.ListRepositoryTags
func (mmListRepositoryTags *mServiceMockListRepositoryTags) Inspect(f func(ctx context.Context, lp1 *artifactpb.ListRepositoryTagsRequest)) *mServiceMockListRepositoryTags {
	if mmListRepositoryTags.mock.inspectFuncListRepositoryTags != nil {
		mmListRepositoryTags.mock.t.Fatalf("Inspect function is already set for ServiceMock.ListRepositoryTags")
	}

	mmListRepositoryTags.mock.inspectFuncListRepositoryTags = f

	return mmListRepositoryTags
}

// Return sets up results that will be returned by Service.ListRepositoryTags
func (mmListRepositoryTags *mServiceMockListRepositoryTags) Return(lp2 *artifactpb.ListRepositoryTagsResponse, err error) *ServiceMock {
	if mmListRepositoryTags.mock.funcListRepositoryTags != nil {
		mmListRepositoryTags.mock.t.Fatalf("ServiceMock.ListRepositoryTags mock is already set by Set")
	}

	if mmListRepositoryTags.defaultExpectation == nil {
		mmListRepositoryTags.defaultExpectation = &ServiceMockListRepositoryTagsExpectation{mock: mmListRepositoryTags.mock}
	}
	mmListRepositoryTags.defaultExpectation.results = &ServiceMockListRepositoryTagsResults{lp2, err}
	mmListRepositoryTags.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListRepositoryTags.mock
}

// Set uses given function f to mock the Service.ListRepositoryTags method
func (mmListRepositoryTags *mServiceMockListRepositoryTags) Set(f func(ctx context.Context, lp1 *artifactpb.ListRepositoryTagsRequest) (lp2 *artifactpb.ListRepositoryTagsResponse, err error)) *ServiceMock {
	if mmListRepositoryTags.defaultExpectation != nil {
		mmListRepositoryTags.mock.t.Fatalf("Default expectation is already set for the Service.ListRepositoryTags method")
	}

	if len(mmListRepositoryTags.expectations) > 0 {
		mmListRepositoryTags.mock.t.Fatalf("Some expectations are already set for the Service.ListRepositoryTags method")
	}

	mmListRepositoryTags.mock.funcListRepositoryTags = f
	mmListRepositoryTags.mock.funcListRepositoryTagsOrigin = minimock.CallerInfo(1)
	return mmListRepositoryTags.mock
}

// When sets expectation for the Service.ListRepositoryTags which will trigger the result defined by the following
// Then helper
func (mmListRepositoryTags *mServiceMockListRepositoryTags) When(ctx context.Context, lp1 *artifactpb.ListRepositoryTagsRequest) *ServiceMockListRepositoryTagsExpectation {
	if mmListRepositoryTags.mock.funcListRepositoryTags != nil {
		mmListRepositoryTags.mock.t.Fatalf("ServiceMock.ListRepositoryTags mock is already set by Set")
	}

	expectation := &ServiceMockListRepositoryTagsExpectation{
		mock:               mmListRepositoryTags.mock,
		params:             &ServiceMockListRepositoryTagsParams{ctx, lp1},
		expectationOrigins: ServiceMockListRepositoryTagsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListRepositoryTags.expectations = append(mmListRepositoryTags.expectations, expectation)
	return expectation
}

// Then sets up Service.ListRepositoryTags return parameters for the expectation previously defined by the When method
func (e *ServiceMockListRepositoryTagsExpectation) Then(lp2 *artifactpb.ListRepositoryTagsResponse, err error) *ServiceMock {
	e.results = &ServiceMockListRepositoryTagsResults{lp2, err}
	return e.mock
}

// Times sets number of times Service.ListRepositoryTags should be invoked
func (mmListRepositoryTags *mServiceMockListRepositoryTags) Times(n uint64) *mServiceMockListRepositoryTags {
	if n == 0 {
		mmListRepositoryTags.mock.t.Fatalf("Times of ServiceMock.ListRepositoryTags mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListRepositoryTags.expectedInvocations, n)
	mmListRepositoryTags.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListRepositoryTags
}

func (mmListRepositoryTags *mServiceMockListRepositoryTags) invocationsDone() bool {
	if len(mmListRepositoryTags.expectations) == 0 && mmListRepositoryTags.defaultExpectation == nil && mmListRepositoryTags.mock.funcListRepositoryTags == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListRepositoryTags.mock.afterListRepositoryTagsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListRepositoryTags.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListRepositoryTags implements mm_service.Service
func (mmListRepositoryTags *ServiceMock) ListRepositoryTags(ctx context.Context, lp1 *artifactpb.ListRepositoryTagsRequest) (lp2 *artifactpb.ListRepositoryTagsResponse, err error) {
	mm_atomic.AddUint64(&mmListRepositoryTags.beforeListRepositoryTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmListRepositoryTags.afterListRepositoryTagsCounter, 1)

	mmListRepositoryTags.t.Helper()

	if mmListRepositoryTags.inspectFuncListRepositoryTags != nil {
		mmListRepositoryTags.inspectFuncListRepositoryTags(ctx, lp1)
	}

	mm_params := ServiceMockListRepositoryTagsParams{ctx, lp1}

	// Record call args
	mmListRepositoryTags.ListRepositoryTagsMock.mutex.Lock()
	mmListRepositoryTags.ListRepositoryTagsMock.callArgs = append(mmListRepositoryTags.ListRepositoryTagsMock.callArgs, &mm_params)
	mmListRepositoryTags.ListRepositoryTagsMock.mutex.Unlock()

	for _, e := range mmListRepositoryTags.ListRepositoryTagsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmListRepositoryTags.ListRepositoryTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListRepositoryTags.ListRepositoryTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmListRepositoryTags.ListRepositoryTagsMock.defaultExpectation.params
		mm_want_ptrs := mmListRepositoryTags.ListRepositoryTagsMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockListRepositoryTagsParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListRepositoryTags.t.Errorf("ServiceMock.ListRepositoryTags got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListRepositoryTags.ListRepositoryTagsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmListRepositoryTags.t.Errorf("ServiceMock.ListRepositoryTags got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListRepositoryTags.ListRepositoryTagsMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListRepositoryTags.t.Errorf("ServiceMock.ListRepositoryTags got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListRepositoryTags.ListRepositoryTagsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListRepositoryTags.ListRepositoryTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmListRepositoryTags.t.Fatal("No results are set for the ServiceMock.ListRepositoryTags")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmListRepositoryTags.funcListRepositoryTags != nil {
		return mmListRepositoryTags.funcListRepositoryTags(ctx, lp1)
	}
	mmListRepositoryTags.t.Fatalf("Unexpected call to ServiceMock.ListRepositoryTags. %v %v", ctx, lp1)
	return
}

// ListRepositoryTagsAfterCounter returns a count of finished ServiceMock.ListRepositoryTags invocations
func (mmListRepositoryTags *ServiceMock) ListRepositoryTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListRepositoryTags.afterListRepositoryTagsCounter)
}

// ListRepositoryTagsBeforeCounter returns a count of ServiceMock.ListRepositoryTags invocations
func (mmListRepositoryTags *ServiceMock) ListRepositoryTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListRepositoryTags.beforeListRepositoryTagsCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.ListRepositoryTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListRepositoryTags *mServiceMockListRepositoryTags) Calls() []*ServiceMockListRepositoryTagsParams {
	mmListRepositoryTags.mutex.RLock()

	argCopy := make([]*ServiceMockListRepositoryTagsParams, len(mmListRepositoryTags.callArgs))
	copy(argCopy, mmListRepositoryTags.callArgs)

	mmListRepositoryTags.mutex.RUnlock()

	return argCopy
}

// MinimockListRepositoryTagsDone returns true if the count of the ListRepositoryTags invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockListRepositoryTagsDone() bool {
	if m.ListRepositoryTagsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListRepositoryTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListRepositoryTagsMock.invocationsDone()
}

// MinimockListRepositoryTagsInspect logs each unmet expectation
func (m *ServiceMock) MinimockListRepositoryTagsInspect() {
	for _, e := range m.ListRepositoryTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.ListRepositoryTags at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListRepositoryTagsCounter := mm_atomic.LoadUint64(&m.afterListRepositoryTagsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListRepositoryTagsMock.defaultExpectation != nil && afterListRepositoryTagsCounter < 1 {
		if m.ListRepositoryTagsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.ListRepositoryTags at\n%s", m.ListRepositoryTagsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.ListRepositoryTags at\n%s with params: %#v", m.ListRepositoryTagsMock.defaultExpectation.expectationOrigins.origin, *m.ListRepositoryTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListRepositoryTags != nil && afterListRepositoryTagsCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.ListRepositoryTags at\n%s", m.funcListRepositoryTagsOrigin)
	}

	if !m.ListRepositoryTagsMock.invocationsDone() && afterListRepositoryTagsCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.ListRepositoryTags at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListRepositoryTagsMock.expectedInvocations), m.ListRepositoryTagsMock.expectedInvocationsOrigin, afterListRepositoryTagsCounter)
	}
}

type mServiceMockListSystemsAdmin struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockListSystemsAdminExpectation
	expectations       []*ServiceMockListSystemsAdminExpectation

	callArgs []*ServiceMockListSystemsAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockListSystemsAdminExpectation specifies expectation struct of the Service.ListSystemsAdmin
type ServiceMockListSystemsAdminExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockListSystemsAdminParams
	paramPtrs          *ServiceMockListSystemsAdminParamPtrs
	expectationOrigins ServiceMockListSystemsAdminExpectationOrigins
	results            *ServiceMockListSystemsAdminResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockListSystemsAdminParams contains parameters of the Service.ListSystemsAdmin
type ServiceMockListSystemsAdminParams struct {
	ctx context.Context
}

// ServiceMockListSystemsAdminParamPtrs contains pointers to parameters of the Service.ListSystemsAdmin
type ServiceMockListSystemsAdminParamPtrs struct {
	ctx *context.Context
}

// ServiceMockListSystemsAdminResults contains results of the Service.ListSystemsAdmin
type ServiceMockListSystemsAdminResults struct {
	lp1 *artifactpb.ListSystemsAdminResponse
	err error
}

// ServiceMockListSystemsAdminOrigins contains origins of expectations of the Service.ListSystemsAdmin
type ServiceMockListSystemsAdminExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListSystemsAdmin *mServiceMockListSystemsAdmin) Optional() *mServiceMockListSystemsAdmin {
	mmListSystemsAdmin.optional = true
	return mmListSystemsAdmin
}

// Expect sets up expected params for Service.ListSystemsAdmin
func (mmListSystemsAdmin *mServiceMockListSystemsAdmin) Expect(ctx context.Context) *mServiceMockListSystemsAdmin {
	if mmListSystemsAdmin.mock.funcListSystemsAdmin != nil {
		mmListSystemsAdmin.mock.t.Fatalf("ServiceMock.ListSystemsAdmin mock is already set by Set")
	}

	if mmListSystemsAdmin.defaultExpectation == nil {
		mmListSystemsAdmin.defaultExpectation = &ServiceMockListSystemsAdminExpectation{}
	}

	if mmListSystemsAdmin.defaultExpectation.paramPtrs != nil {
		mmListSystemsAdmin.mock.t.Fatalf("ServiceMock.ListSystemsAdmin mock is already set by ExpectParams functions")
	}

	mmListSystemsAdmin.defaultExpectation.params = &ServiceMockListSystemsAdminParams{ctx}
	mmListSystemsAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListSystemsAdmin.expectations {
		if minimock.Equal(e.params, mmListSystemsAdmin.defaultExpectation.params) {
			mmListSystemsAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListSystemsAdmin.defaultExpectation.params)
		}
	}

	return mmListSystemsAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Service.ListSystemsAdmin
func (mmListSystemsAdmin *mServiceMockListSystemsAdmin) ExpectCtxParam1(ctx context.Context) *mServiceMockListSystemsAdmin {
	if mmListSystemsAdmin.mock.funcListSystemsAdmin != nil {
		mmListSystemsAdmin.mock.t.Fatalf("ServiceMock.ListSystemsAdmin mock is already set by Set")
	}

	if mmListSystemsAdmin.defaultExpectation == nil {
		mmListSystemsAdmin.defaultExpectation = &ServiceMockListSystemsAdminExpectation{}
	}

	if mmListSystemsAdmin.defaultExpectation.params != nil {
		mmListSystemsAdmin.mock.t.Fatalf("ServiceMock.ListSystemsAdmin mock is already set by Expect")
	}

	if mmListSystemsAdmin.defaultExpectation.paramPtrs == nil {
		mmListSystemsAdmin.defaultExpectation.paramPtrs = &ServiceMockListSystemsAdminParamPtrs{}
	}
	mmListSystemsAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmListSystemsAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListSystemsAdmin
}

// Inspect accepts an inspector function that has same arguments as the Service.ListSystemsAdmin
func (mmListSystemsAdmin *mServiceMockListSystemsAdmin) Inspect(f func(ctx context.Context)) *mServiceMockListSystemsAdmin {
	if mmListSystemsAdmin.mock.inspectFuncListSystemsAdmin != nil {
		mmListSystemsAdmin.mock.t.Fatalf("Inspect function is already set for ServiceMock.ListSystemsAdmin")
	}

	mmListSystemsAdmin.mock.inspectFuncListSystemsAdmin = f

	return mmListSystemsAdmin
}

// Return sets up results that will be returned by Service.ListSystemsAdmin
func (mmListSystemsAdmin *mServiceMockListSystemsAdmin) Return(lp1 *artifactpb.ListSystemsAdminResponse, err error) *ServiceMock {
	if mmListSystemsAdmin.mock.funcListSystemsAdmin != nil {
		mmListSystemsAdmin.mock.t.Fatalf("ServiceMock.ListSystemsAdmin mock is already set by Set")
	}

	if mmListSystemsAdmin.defaultExpectation == nil {
		mmListSystemsAdmin.defaultExpectation = &ServiceMockListSystemsAdminExpectation{mock: mmListSystemsAdmin.mock}
	}
	mmListSystemsAdmin.defaultExpectation.results = &ServiceMockListSystemsAdminResults{lp1, err}
	mmListSystemsAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListSystemsAdmin.mock
}

// Set uses given function f to mock the Service.ListSystemsAdmin method
func (mmListSystemsAdmin *mServiceMockListSystemsAdmin) Set(f func(ctx context.Context) (lp1 *artifactpb.ListSystemsAdminResponse, err error)) *ServiceMock {
	if mmListSystemsAdmin.defaultExpectation != nil {
		mmListSystemsAdmin.mock.t.Fatalf("Default expectation is already set for the Service.ListSystemsAdmin method")
	}

	if len(mmListSystemsAdmin.expectations) > 0 {
		mmListSystemsAdmin.mock.t.Fatalf("Some expectations are already set for the Service.ListSystemsAdmin method")
	}

	mmListSystemsAdmin.mock.funcListSystemsAdmin = f
	mmListSystemsAdmin.mock.funcListSystemsAdminOrigin = minimock.CallerInfo(1)
	return mmListSystemsAdmin.mock
}

// When sets expectation for the Service.ListSystemsAdmin which will trigger the result defined by the following
// Then helper
func (mmListSystemsAdmin *mServiceMockListSystemsAdmin) When(ctx context.Context) *ServiceMockListSystemsAdminExpectation {
	if mmListSystemsAdmin.mock.funcListSystemsAdmin != nil {
		mmListSystemsAdmin.mock.t.Fatalf("ServiceMock.ListSystemsAdmin mock is already set by Set")
	}

	expectation := &ServiceMockListSystemsAdminExpectation{
		mock:               mmListSystemsAdmin.mock,
		params:             &ServiceMockListSystemsAdminParams{ctx},
		expectationOrigins: ServiceMockListSystemsAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListSystemsAdmin.expectations = append(mmListSystemsAdmin.expectations, expectation)
	return expectation
}

// Then sets up Service.ListSystemsAdmin return parameters for the expectation previously defined by the When method
func (e *ServiceMockListSystemsAdminExpectation) Then(lp1 *artifactpb.ListSystemsAdminResponse, err error) *ServiceMock {
	e.results = &ServiceMockListSystemsAdminResults{lp1, err}
	return e.mock
}

// Times sets number of times Service.ListSystemsAdmin should be invoked
func (mmListSystemsAdmin *mServiceMockListSystemsAdmin) Times(n uint64) *mServiceMockListSystemsAdmin {
	if n == 0 {
		mmListSystemsAdmin.mock.t.Fatalf("Times of ServiceMock.ListSystemsAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListSystemsAdmin.expectedInvocations, n)
	mmListSystemsAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListSystemsAdmin
}

func (mmListSystemsAdmin *mServiceMockListSystemsAdmin) invocationsDone() bool {
	if len(mmListSystemsAdmin.expectations) == 0 && mmListSystemsAdmin.defaultExpectation == nil && mmListSystemsAdmin.mock.funcListSystemsAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListSystemsAdmin.mock.afterListSystemsAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListSystemsAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListSystemsAdmin implements mm_service.Service
func (mmListSystemsAdmin *ServiceMock) ListSystemsAdmin(ctx context.Context) (lp1 *artifactpb.ListSystemsAdminResponse, err error) {
	mm_atomic.AddUint64(&mmListSystemsAdmin.beforeListSystemsAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmListSystemsAdmin.afterListSystemsAdminCounter, 1)

	mmListSystemsAdmin.t.Helper()

	if mmListSystemsAdmin.inspectFuncListSystemsAdmin != nil {
		mmListSystemsAdmin.inspectFuncListSystemsAdmin(ctx)
	}

	mm_params := ServiceMockListSystemsAdminParams{ctx}

	// Record call args
	mmListSystemsAdmin.ListSystemsAdminMock.mutex.Lock()
	mmListSystemsAdmin.ListSystemsAdminMock.callArgs = append(mmListSystemsAdmin.ListSystemsAdminMock.callArgs, &mm_params)
	mmListSystemsAdmin.ListSystemsAdminMock.mutex.Unlock()

	for _, e := range mmListSystemsAdmin.ListSystemsAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmListSystemsAdmin.ListSystemsAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListSystemsAdmin.ListSystemsAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmListSystemsAdmin.ListSystemsAdminMock.defaultExpectation.params
		mm_want_ptrs := mmListSystemsAdmin.ListSystemsAdminMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockListSystemsAdminParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListSystemsAdmin.t.Errorf("ServiceMock.ListSystemsAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListSystemsAdmin.ListSystemsAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListSystemsAdmin.t.Errorf("ServiceMock.ListSystemsAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListSystemsAdmin.ListSystemsAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListSystemsAdmin.ListSystemsAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmListSystemsAdmin.t.Fatal("No results are set for the ServiceMock.ListSystemsAdmin")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmListSystemsAdmin.funcListSystemsAdmin != nil {
		return mmListSystemsAdmin.funcListSystemsAdmin(ctx)
	}
	mmListSystemsAdmin.t.Fatalf("Unexpected call to ServiceMock.ListSystemsAdmin. %v", ctx)
	return
}

// ListSystemsAdminAfterCounter returns a count of finished ServiceMock.ListSystemsAdmin invocations
func (mmListSystemsAdmin *ServiceMock) ListSystemsAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSystemsAdmin.afterListSystemsAdminCounter)
}

// ListSystemsAdminBeforeCounter returns a count of ServiceMock.ListSystemsAdmin invocations
func (mmListSystemsAdmin *ServiceMock) ListSystemsAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSystemsAdmin.beforeListSystemsAdminCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.ListSystemsAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListSystemsAdmin *mServiceMockListSystemsAdmin) Calls() []*ServiceMockListSystemsAdminParams {
	mmListSystemsAdmin.mutex.RLock()

	argCopy := make([]*ServiceMockListSystemsAdminParams, len(mmListSystemsAdmin.callArgs))
	copy(argCopy, mmListSystemsAdmin.callArgs)

	mmListSystemsAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockListSystemsAdminDone returns true if the count of the ListSystemsAdmin invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockListSystemsAdminDone() bool {
	if m.ListSystemsAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListSystemsAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListSystemsAdminMock.invocationsDone()
}

// MinimockListSystemsAdminInspect logs each unmet expectation
func (m *ServiceMock) MinimockListSystemsAdminInspect() {
	for _, e := range m.ListSystemsAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.ListSystemsAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListSystemsAdminCounter := mm_atomic.LoadUint64(&m.afterListSystemsAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListSystemsAdminMock.defaultExpectation != nil && afterListSystemsAdminCounter < 1 {
		if m.ListSystemsAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.ListSystemsAdmin at\n%s", m.ListSystemsAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.ListSystemsAdmin at\n%s with params: %#v", m.ListSystemsAdminMock.defaultExpectation.expectationOrigins.origin, *m.ListSystemsAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListSystemsAdmin != nil && afterListSystemsAdminCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.ListSystemsAdmin at\n%s", m.funcListSystemsAdminOrigin)
	}

	if !m.ListSystemsAdminMock.invocationsDone() && afterListSystemsAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.ListSystemsAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListSystemsAdminMock.expectedInvocations), m.ListSystemsAdminMock.expectedInvocationsOrigin, afterListSystemsAdminCounter)
	}
}

type mServiceMockPipelinePublicClient struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockPipelinePublicClientExpectation
	expectations       []*ServiceMockPipelinePublicClientExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockPipelinePublicClientExpectation specifies expectation struct of the Service.PipelinePublicClient
type ServiceMockPipelinePublicClientExpectation struct {
	mock *ServiceMock

	results      *ServiceMockPipelinePublicClientResults
	returnOrigin string
	Counter      uint64
}

// ServiceMockPipelinePublicClientResults contains results of the Service.PipelinePublicClient
type ServiceMockPipelinePublicClientResults struct {
	p1 pipelinepb.PipelinePublicServiceClient
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPipelinePublicClient *mServiceMockPipelinePublicClient) Optional() *mServiceMockPipelinePublicClient {
	mmPipelinePublicClient.optional = true
	return mmPipelinePublicClient
}

// Expect sets up expected params for Service.PipelinePublicClient
func (mmPipelinePublicClient *mServiceMockPipelinePublicClient) Expect() *mServiceMockPipelinePublicClient {
	if mmPipelinePublicClient.mock.funcPipelinePublicClient != nil {
		mmPipelinePublicClient.mock.t.Fatalf("ServiceMock.PipelinePublicClient mock is already set by Set")
	}

	if mmPipelinePublicClient.defaultExpectation == nil {
		mmPipelinePublicClient.defaultExpectation = &ServiceMockPipelinePublicClientExpectation{}
	}

	return mmPipelinePublicClient
}

// Inspect accepts an inspector function that has same arguments as the Service.PipelinePublicClient
func (mmPipelinePublicClient *mServiceMockPipelinePublicClient) Inspect(f func()) *mServiceMockPipelinePublicClient {
	if mmPipelinePublicClient.mock.inspectFuncPipelinePublicClient != nil {
		mmPipelinePublicClient.mock.t.Fatalf("Inspect function is already set for ServiceMock.PipelinePublicClient")
	}

	mmPipelinePublicClient.mock.inspectFuncPipelinePublicClient = f

	return mmPipelinePublicClient
}

// Return sets up results that will be returned by Service.PipelinePublicClient
func (mmPipelinePublicClient *mServiceMockPipelinePublicClient) Return(p1 pipelinepb.PipelinePublicServiceClient) *ServiceMock {
	if mmPipelinePublicClient.mock.funcPipelinePublicClient != nil {
		mmPipelinePublicClient.mock.t.Fatalf("ServiceMock.PipelinePublicClient mock is already set by Set")
	}

	if mmPipelinePublicClient.defaultExpectation == nil {
		mmPipelinePublicClient.defaultExpectation = &ServiceMockPipelinePublicClientExpectation{mock: mmPipelinePublicClient.mock}
	}
	mmPipelinePublicClient.defaultExpectation.results = &ServiceMockPipelinePublicClientResults{p1}
	mmPipelinePublicClient.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPipelinePublicClient.mock
}

// Set uses given function f to mock the Service.PipelinePublicClient method
func (mmPipelinePublicClient *mServiceMockPipelinePublicClient) Set(f func() (p1 pipelinepb.PipelinePublicServiceClient)) *ServiceMock {
	if mmPipelinePublicClient.defaultExpectation != nil {
		mmPipelinePublicClient.mock.t.Fatalf("Default expectation is already set for the Service.PipelinePublicClient method")
	}

	if len(mmPipelinePublicClient.expectations) > 0 {
		mmPipelinePublicClient.mock.t.Fatalf("Some expectations are already set for the Service.PipelinePublicClient method")
	}

	mmPipelinePublicClient.mock.funcPipelinePublicClient = f
	mmPipelinePublicClient.mock.funcPipelinePublicClientOrigin = minimock.CallerInfo(1)
	return mmPipelinePublicClient.mock
}

// Times sets number of times Service.PipelinePublicClient should be invoked
func (mmPipelinePublicClient *mServiceMockPipelinePublicClient) Times(n uint64) *mServiceMockPipelinePublicClient {
	if n == 0 {
		mmPipelinePublicClient.mock.t.Fatalf("Times of ServiceMock.PipelinePublicClient mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPipelinePublicClient.expectedInvocations, n)
	mmPipelinePublicClient.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPipelinePublicClient
}

func (mmPipelinePublicClient *mServiceMockPipelinePublicClient) invocationsDone() bool {
	if len(mmPipelinePublicClient.expectations) == 0 && mmPipelinePublicClient.defaultExpectation == nil && mmPipelinePublicClient.mock.funcPipelinePublicClient == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPipelinePublicClient.mock.afterPipelinePublicClientCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPipelinePublicClient.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PipelinePublicClient implements mm_service.Service
func (mmPipelinePublicClient *ServiceMock) PipelinePublicClient() (p1 pipelinepb.PipelinePublicServiceClient) {
	mm_atomic.AddUint64(&mmPipelinePublicClient.beforePipelinePublicClientCounter, 1)
	defer mm_atomic.AddUint64(&mmPipelinePublicClient.afterPipelinePublicClientCounter, 1)

	mmPipelinePublicClient.t.Helper()

	if mmPipelinePublicClient.inspectFuncPipelinePublicClient != nil {
		mmPipelinePublicClient.inspectFuncPipelinePublicClient()
	}

	if mmPipelinePublicClient.PipelinePublicClientMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPipelinePublicClient.PipelinePublicClientMock.defaultExpectation.Counter, 1)

		mm_results := mmPipelinePublicClient.PipelinePublicClientMock.defaultExpectation.results
		if mm_results == nil {
			mmPipelinePublicClient.t.Fatal("No results are set for the ServiceMock.PipelinePublicClient")
		}
		return (*mm_results).p1
	}
	if mmPipelinePublicClient.funcPipelinePublicClient != nil {
		return mmPipelinePublicClient.funcPipelinePublicClient()
	}
	mmPipelinePublicClient.t.Fatalf("Unexpected call to ServiceMock.PipelinePublicClient.")
	return
}

// PipelinePublicClientAfterCounter returns a count of finished ServiceMock.PipelinePublicClient invocations
func (mmPipelinePublicClient *ServiceMock) PipelinePublicClientAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPipelinePublicClient.afterPipelinePublicClientCounter)
}

// PipelinePublicClientBeforeCounter returns a count of ServiceMock.PipelinePublicClient invocations
func (mmPipelinePublicClient *ServiceMock) PipelinePublicClientBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPipelinePublicClient.beforePipelinePublicClientCounter)
}

// MinimockPipelinePublicClientDone returns true if the count of the PipelinePublicClient invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockPipelinePublicClientDone() bool {
	if m.PipelinePublicClientMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PipelinePublicClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PipelinePublicClientMock.invocationsDone()
}

// MinimockPipelinePublicClientInspect logs each unmet expectation
func (m *ServiceMock) MinimockPipelinePublicClientInspect() {
	for _, e := range m.PipelinePublicClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServiceMock.PipelinePublicClient")
		}
	}

	afterPipelinePublicClientCounter := mm_atomic.LoadUint64(&m.afterPipelinePublicClientCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PipelinePublicClientMock.defaultExpectation != nil && afterPipelinePublicClientCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.PipelinePublicClient at\n%s", m.PipelinePublicClientMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPipelinePublicClient != nil && afterPipelinePublicClientCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.PipelinePublicClient at\n%s", m.funcPipelinePublicClientOrigin)
	}

	if !m.PipelinePublicClientMock.invocationsDone() && afterPipelinePublicClientCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.PipelinePublicClient at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PipelinePublicClientMock.expectedInvocations), m.PipelinePublicClientMock.expectedInvocationsOrigin, afterPipelinePublicClientCounter)
	}
}

type mServiceMockProcessFile struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockProcessFileExpectation
	expectations       []*ServiceMockProcessFileExpectation

	callArgs []*ServiceMockProcessFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockProcessFileExpectation specifies expectation struct of the Service.ProcessFile
type ServiceMockProcessFileExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockProcessFileParams
	paramPtrs          *ServiceMockProcessFileParamPtrs
	expectationOrigins ServiceMockProcessFileExpectationOrigins
	results            *ServiceMockProcessFileResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockProcessFileParams contains parameters of the Service.ProcessFile
type ServiceMockProcessFileParams struct {
	ctx context.Context
	k1  types.KBUIDType
	fa1 []types.FileUIDType
	u1  types.UserUIDType
	r1  types.RequesterUIDType
}

// ServiceMockProcessFileParamPtrs contains pointers to parameters of the Service.ProcessFile
type ServiceMockProcessFileParamPtrs struct {
	ctx *context.Context
	k1  *types.KBUIDType
	fa1 *[]types.FileUIDType
	u1  *types.UserUIDType
	r1  *types.RequesterUIDType
}

// ServiceMockProcessFileResults contains results of the Service.ProcessFile
type ServiceMockProcessFileResults struct {
	err error
}

// ServiceMockProcessFileOrigins contains origins of expectations of the Service.ProcessFile
type ServiceMockProcessFileExpectationOrigins struct {
	origin    string
	originCtx string
	originK1  string
	originFa1 string
	originU1  string
	originR1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmProcessFile *mServiceMockProcessFile) Optional() *mServiceMockProcessFile {
	mmProcessFile.optional = true
	return mmProcessFile
}

// Expect sets up expected params for Service.ProcessFile
func (mmProcessFile *mServiceMockProcessFile) Expect(ctx context.Context, k1 types.KBUIDType, fa1 []types.FileUIDType, u1 types.UserUIDType, r1 types.RequesterUIDType) *mServiceMockProcessFile {
	if mmProcessFile.mock.funcProcessFile != nil {
		mmProcessFile.mock.t.Fatalf("ServiceMock.ProcessFile mock is already set by Set")
	}

	if mmProcessFile.defaultExpectation == nil {
		mmProcessFile.defaultExpectation = &ServiceMockProcessFileExpectation{}
	}

	if mmProcessFile.defaultExpectation.paramPtrs != nil {
		mmProcessFile.mock.t.Fatalf("ServiceMock.ProcessFile mock is already set by ExpectParams functions")
	}

	mmProcessFile.defaultExpectation.params = &ServiceMockProcessFileParams{ctx, k1, fa1, u1, r1}
	mmProcessFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmProcessFile.expectations {
		if minimock.Equal(e.params, mmProcessFile.defaultExpectation.params) {
			mmProcessFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmProcessFile.defaultExpectation.params)
		}
	}

	return mmProcessFile
}

// ExpectCtxParam1 sets up expected param ctx for Service.ProcessFile
func (mmProcessFile *mServiceMockProcessFile) ExpectCtxParam1(ctx context.Context) *mServiceMockProcessFile {
	if mmProcessFile.mock.funcProcessFile != nil {
		mmProcessFile.mock.t.Fatalf("ServiceMock.ProcessFile mock is already set by Set")
	}

	if mmProcessFile.defaultExpectation == nil {
		mmProcessFile.defaultExpectation = &ServiceMockProcessFileExpectation{}
	}

	if mmProcessFile.defaultExpectation.params != nil {
		mmProcessFile.mock.t.Fatalf("ServiceMock.ProcessFile mock is already set by Expect")
	}

	if mmProcessFile.defaultExpectation.paramPtrs == nil {
		mmProcessFile.defaultExpectation.paramPtrs = &ServiceMockProcessFileParamPtrs{}
	}
	mmProcessFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmProcessFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmProcessFile
}

// ExpectK1Param2 sets up expected param k1 for Service.ProcessFile
func (mmProcessFile *mServiceMockProcessFile) ExpectK1Param2(k1 types.KBUIDType) *mServiceMockProcessFile {
	if mmProcessFile.mock.funcProcessFile != nil {
		mmProcessFile.mock.t.Fatalf("ServiceMock.ProcessFile mock is already set by Set")
	}

	if mmProcessFile.defaultExpectation == nil {
		mmProcessFile.defaultExpectation = &ServiceMockProcessFileExpectation{}
	}

	if mmProcessFile.defaultExpectation.params != nil {
		mmProcessFile.mock.t.Fatalf("ServiceMock.ProcessFile mock is already set by Expect")
	}

	if mmProcessFile.defaultExpectation.paramPtrs == nil {
		mmProcessFile.defaultExpectation.paramPtrs = &ServiceMockProcessFileParamPtrs{}
	}
	mmProcessFile.defaultExpectation.paramPtrs.k1 = &k1
	mmProcessFile.defaultExpectation.expectationOrigins.originK1 = minimock.CallerInfo(1)

	return mmProcessFile
}

// ExpectFa1Param3 sets up expected param fa1 for Service.ProcessFile
func (mmProcessFile *mServiceMockProcessFile) ExpectFa1Param3(fa1 []types.FileUIDType) *mServiceMockProcessFile {
	if mmProcessFile.mock.funcProcessFile != nil {
		mmProcessFile.mock.t.Fatalf("ServiceMock.ProcessFile mock is already set by Set")
	}

	if mmProcessFile.defaultExpectation == nil {
		mmProcessFile.defaultExpectation = &ServiceMockProcessFileExpectation{}
	}

	if mmProcessFile.defaultExpectation.params != nil {
		mmProcessFile.mock.t.Fatalf("ServiceMock.ProcessFile mock is already set by Expect")
	}

	if mmProcessFile.defaultExpectation.paramPtrs == nil {
		mmProcessFile.defaultExpectation.paramPtrs = &ServiceMockProcessFileParamPtrs{}
	}
	mmProcessFile.defaultExpectation.paramPtrs.fa1 = &fa1
	mmProcessFile.defaultExpectation.expectationOrigins.originFa1 = minimock.CallerInfo(1)

	return mmProcessFile
}

// ExpectU1Param4 sets up expected param u1 for Service.ProcessFile
func (mmProcessFile *mServiceMockProcessFile) ExpectU1Param4(u1 types.UserUIDType) *mServiceMockProcessFile {
	if mmProcessFile.mock.funcProcessFile != nil {
		mmProcessFile.mock.t.Fatalf("ServiceMock.ProcessFile mock is already set by Set")
	}

	if mmProcessFile.defaultExpectation == nil {
		mmProcessFile.defaultExpectation = &ServiceMockProcessFileExpectation{}
	}

	if mmProcessFile.defaultExpectation.params != nil {
		mmProcessFile.mock.t.Fatalf("ServiceMock.ProcessFile mock is already set by Expect")
	}

	if mmProcessFile.defaultExpectation.paramPtrs == nil {
		mmProcessFile.defaultExpectation.paramPtrs = &ServiceMockProcessFileParamPtrs{}
	}
	mmProcessFile.defaultExpectation.paramPtrs.u1 = &u1
	mmProcessFile.defaultExpectation.expectationOrigins.originU1 = minimock.CallerInfo(1)

	return mmProcessFile
}

// ExpectR1Param5 sets up expected param r1 for Service.ProcessFile
func (mmProcessFile *mServiceMockProcessFile) ExpectR1Param5(r1 types.RequesterUIDType) *mServiceMockProcessFile {
	if mmProcessFile.mock.funcProcessFile != nil {
		mmProcessFile.mock.t.Fatalf("ServiceMock.ProcessFile mock is already set by Set")
	}

	if mmProcessFile.defaultExpectation == nil {
		mmProcessFile.defaultExpectation = &ServiceMockProcessFileExpectation{}
	}

	if mmProcessFile.defaultExpectation.params != nil {
		mmProcessFile.mock.t.Fatalf("ServiceMock.ProcessFile mock is already set by Expect")
	}

	if mmProcessFile.defaultExpectation.paramPtrs == nil {
		mmProcessFile.defaultExpectation.paramPtrs = &ServiceMockProcessFileParamPtrs{}
	}
	mmProcessFile.defaultExpectation.paramPtrs.r1 = &r1
	mmProcessFile.defaultExpectation.expectationOrigins.originR1 = minimock.CallerInfo(1)

	return mmProcessFile
}

// Inspect accepts an inspector function that has same arguments as the Service.ProcessFile
func (mmProcessFile *mServiceMockProcessFile) Inspect(f func(ctx context.Context, k1 types.KBUIDType, fa1 []types.FileUIDType, u1 types.UserUIDType, r1 types.RequesterUIDType)) *mServiceMockProcessFile {
	if mmProcessFile.mock.inspectFuncProcessFile != nil {
		mmProcessFile.mock.t.Fatalf("Inspect function is already set for ServiceMock.ProcessFile")
	}

	mmProcessFile.mock.inspectFuncProcessFile = f

	return mmProcessFile
}

// Return sets up results that will be returned by Service.ProcessFile
func (mmProcessFile *mServiceMockProcessFile) Return(err error) *ServiceMock {
	if mmProcessFile.mock.funcProcessFile != nil {
		mmProcessFile.mock.t.Fatalf("ServiceMock.ProcessFile mock is already set by Set")
	}

	if mmProcessFile.defaultExpectation == nil {
		mmProcessFile.defaultExpectation = &ServiceMockProcessFileExpectation{mock: mmProcessFile.mock}
	}
	mmProcessFile.defaultExpectation.results = &ServiceMockProcessFileResults{err}
	mmProcessFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmProcessFile.mock
}

// Set uses given function f to mock the Service.ProcessFile method
func (mmProcessFile *mServiceMockProcessFile) Set(f func(ctx context.Context, k1 types.KBUIDType, fa1 []types.FileUIDType, u1 types.UserUIDType, r1 types.RequesterUIDType) (err error)) *ServiceMock {
	if mmProcessFile.defaultExpectation != nil {
		mmProcessFile.mock.t.Fatalf("Default expectation is already set for the Service.ProcessFile method")
	}

	if len(mmProcessFile.expectations) > 0 {
		mmProcessFile.mock.t.Fatalf("Some expectations are already set for the Service.ProcessFile method")
	}

	mmProcessFile.mock.funcProcessFile = f
	mmProcessFile.mock.funcProcessFileOrigin = minimock.CallerInfo(1)
	return mmProcessFile.mock
}

// When sets expectation for the Service.ProcessFile which will trigger the result defined by the following
// Then helper
func (mmProcessFile *mServiceMockProcessFile) When(ctx context.Context, k1 types.KBUIDType, fa1 []types.FileUIDType, u1 types.UserUIDType, r1 types.RequesterUIDType) *ServiceMockProcessFileExpectation {
	if mmProcessFile.mock.funcProcessFile != nil {
		mmProcessFile.mock.t.Fatalf("ServiceMock.ProcessFile mock is already set by Set")
	}

	expectation := &ServiceMockProcessFileExpectation{
		mock:               mmProcessFile.mock,
		params:             &ServiceMockProcessFileParams{ctx, k1, fa1, u1, r1},
		expectationOrigins: ServiceMockProcessFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmProcessFile.expectations = append(mmProcessFile.expectations, expectation)
	return expectation
}

// Then sets up Service.ProcessFile return parameters for the expectation previously defined by the When method
func (e *ServiceMockProcessFileExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockProcessFileResults{err}
	return e.mock
}

// Times sets number of times Service.ProcessFile should be invoked
func (mmProcessFile *mServiceMockProcessFile) Times(n uint64) *mServiceMockProcessFile {
	if n == 0 {
		mmProcessFile.mock.t.Fatalf("Times of ServiceMock.ProcessFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmProcessFile.expectedInvocations, n)
	mmProcessFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmProcessFile
}

func (mmProcessFile *mServiceMockProcessFile) invocationsDone() bool {
	if len(mmProcessFile.expectations) == 0 && mmProcessFile.defaultExpectation == nil && mmProcessFile.mock.funcProcessFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmProcessFile.mock.afterProcessFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmProcessFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ProcessFile implements mm_service.Service
func (mmProcessFile *ServiceMock) ProcessFile(ctx context.Context, k1 types.KBUIDType, fa1 []types.FileUIDType, u1 types.UserUIDType, r1 types.RequesterUIDType) (err error) {
	mm_atomic.AddUint64(&mmProcessFile.beforeProcessFileCounter, 1)
	defer mm_atomic.AddUint64(&mmProcessFile.afterProcessFileCounter, 1)

	mmProcessFile.t.Helper()

	if mmProcessFile.inspectFuncProcessFile != nil {
		mmProcessFile.inspectFuncProcessFile(ctx, k1, fa1, u1, r1)
	}

	mm_params := ServiceMockProcessFileParams{ctx, k1, fa1, u1, r1}

	// Record call args
	mmProcessFile.ProcessFileMock.mutex.Lock()
	mmProcessFile.ProcessFileMock.callArgs = append(mmProcessFile.ProcessFileMock.callArgs, &mm_params)
	mmProcessFile.ProcessFileMock.mutex.Unlock()

	for _, e := range mmProcessFile.ProcessFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmProcessFile.ProcessFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProcessFile.ProcessFileMock.defaultExpectation.Counter, 1)
		mm_want := mmProcessFile.ProcessFileMock.defaultExpectation.params
		mm_want_ptrs := mmProcessFile.ProcessFileMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockProcessFileParams{ctx, k1, fa1, u1, r1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmProcessFile.t.Errorf("ServiceMock.ProcessFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProcessFile.ProcessFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.k1 != nil && !minimock.Equal(*mm_want_ptrs.k1, mm_got.k1) {
				mmProcessFile.t.Errorf("ServiceMock.ProcessFile got unexpected parameter k1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProcessFile.ProcessFileMock.defaultExpectation.expectationOrigins.originK1, *mm_want_ptrs.k1, mm_got.k1, minimock.Diff(*mm_want_ptrs.k1, mm_got.k1))
			}

			if mm_want_ptrs.fa1 != nil && !minimock.Equal(*mm_want_ptrs.fa1, mm_got.fa1) {
				mmProcessFile.t.Errorf("ServiceMock.ProcessFile got unexpected parameter fa1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProcessFile.ProcessFileMock.defaultExpectation.expectationOrigins.originFa1, *mm_want_ptrs.fa1, mm_got.fa1, minimock.Diff(*mm_want_ptrs.fa1, mm_got.fa1))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmProcessFile.t.Errorf("ServiceMock.ProcessFile got unexpected parameter u1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProcessFile.ProcessFileMock.defaultExpectation.expectationOrigins.originU1, *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

			if mm_want_ptrs.r1 != nil && !minimock.Equal(*mm_want_ptrs.r1, mm_got.r1) {
				mmProcessFile.t.Errorf("ServiceMock.ProcessFile got unexpected parameter r1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProcessFile.ProcessFileMock.defaultExpectation.expectationOrigins.originR1, *mm_want_ptrs.r1, mm_got.r1, minimock.Diff(*mm_want_ptrs.r1, mm_got.r1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmProcessFile.t.Errorf("ServiceMock.ProcessFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmProcessFile.ProcessFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmProcessFile.ProcessFileMock.defaultExpectation.results
		if mm_results == nil {
			mmProcessFile.t.Fatal("No results are set for the ServiceMock.ProcessFile")
		}
		return (*mm_results).err
	}
	if mmProcessFile.funcProcessFile != nil {
		return mmProcessFile.funcProcessFile(ctx, k1, fa1, u1, r1)
	}
	mmProcessFile.t.Fatalf("Unexpected call to ServiceMock.ProcessFile. %v %v %v %v %v", ctx, k1, fa1, u1, r1)
	return
}

// ProcessFileAfterCounter returns a count of finished ServiceMock.ProcessFile invocations
func (mmProcessFile *ServiceMock) ProcessFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessFile.afterProcessFileCounter)
}

// ProcessFileBeforeCounter returns a count of ServiceMock.ProcessFile invocations
func (mmProcessFile *ServiceMock) ProcessFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessFile.beforeProcessFileCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.ProcessFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmProcessFile *mServiceMockProcessFile) Calls() []*ServiceMockProcessFileParams {
	mmProcessFile.mutex.RLock()

	argCopy := make([]*ServiceMockProcessFileParams, len(mmProcessFile.callArgs))
	copy(argCopy, mmProcessFile.callArgs)

	mmProcessFile.mutex.RUnlock()

	return argCopy
}

// MinimockProcessFileDone returns true if the count of the ProcessFile invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockProcessFileDone() bool {
	if m.ProcessFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ProcessFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ProcessFileMock.invocationsDone()
}

// MinimockProcessFileInspect logs each unmet expectation
func (m *ServiceMock) MinimockProcessFileInspect() {
	for _, e := range m.ProcessFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.ProcessFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterProcessFileCounter := mm_atomic.LoadUint64(&m.afterProcessFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ProcessFileMock.defaultExpectation != nil && afterProcessFileCounter < 1 {
		if m.ProcessFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.ProcessFile at\n%s", m.ProcessFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.ProcessFile at\n%s with params: %#v", m.ProcessFileMock.defaultExpectation.expectationOrigins.origin, *m.ProcessFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProcessFile != nil && afterProcessFileCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.ProcessFile at\n%s", m.funcProcessFileOrigin)
	}

	if !m.ProcessFileMock.invocationsDone() && afterProcessFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.ProcessFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ProcessFileMock.expectedInvocations), m.ProcessFileMock.expectedInvocationsOrigin, afterProcessFileCounter)
	}
}

type mServiceMockProcessFileDualMode struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockProcessFileDualModeExpectation
	expectations       []*ServiceMockProcessFileDualModeExpectation

	callArgs []*ServiceMockProcessFileDualModeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockProcessFileDualModeExpectation specifies expectation struct of the Service.ProcessFileDualMode
type ServiceMockProcessFileDualModeExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockProcessFileDualModeParams
	paramPtrs          *ServiceMockProcessFileDualModeParamPtrs
	expectationOrigins ServiceMockProcessFileDualModeExpectationOrigins
	results            *ServiceMockProcessFileDualModeResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockProcessFileDualModeParams contains parameters of the Service.ProcessFileDualMode
type ServiceMockProcessFileDualModeParams struct {
	ctx          context.Context
	prodKBUID    types.KBUIDType
	stagingKBUID types.KBUIDType
	fileUIDs     []types.FileUIDType
	userUID      types.RequesterUIDType
	requesterUID types.RequesterUIDType
}

// ServiceMockProcessFileDualModeParamPtrs contains pointers to parameters of the Service.ProcessFileDualMode
type ServiceMockProcessFileDualModeParamPtrs struct {
	ctx          *context.Context
	prodKBUID    *types.KBUIDType
	stagingKBUID *types.KBUIDType
	fileUIDs     *[]types.FileUIDType
	userUID      *types.RequesterUIDType
	requesterUID *types.RequesterUIDType
}

// ServiceMockProcessFileDualModeResults contains results of the Service.ProcessFileDualMode
type ServiceMockProcessFileDualModeResults struct {
	err error
}

// ServiceMockProcessFileDualModeOrigins contains origins of expectations of the Service.ProcessFileDualMode
type ServiceMockProcessFileDualModeExpectationOrigins struct {
	origin             string
	originCtx          string
	originProdKBUID    string
	originStagingKBUID string
	originFileUIDs     string
	originUserUID      string
	originRequesterUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmProcessFileDualMode *mServiceMockProcessFileDualMode) Optional() *mServiceMockProcessFileDualMode {
	mmProcessFileDualMode.optional = true
	return mmProcessFileDualMode
}

// Expect sets up expected params for Service.ProcessFileDualMode
func (mmProcessFileDualMode *mServiceMockProcessFileDualMode) Expect(ctx context.Context, prodKBUID types.KBUIDType, stagingKBUID types.KBUIDType, fileUIDs []types.FileUIDType, userUID types.RequesterUIDType, requesterUID types.RequesterUIDType) *mServiceMockProcessFileDualMode {
	if mmProcessFileDualMode.mock.funcProcessFileDualMode != nil {
		mmProcessFileDualMode.mock.t.Fatalf("ServiceMock.ProcessFileDualMode mock is already set by Set")
	}

	if mmProcessFileDualMode.defaultExpectation == nil {
		mmProcessFileDualMode.defaultExpectation = &ServiceMockProcessFileDualModeExpectation{}
	}

	if mmProcessFileDualMode.defaultExpectation.paramPtrs != nil {
		mmProcessFileDualMode.mock.t.Fatalf("ServiceMock.ProcessFileDualMode mock is already set by ExpectParams functions")
	}

	mmProcessFileDualMode.defaultExpectation.params = &ServiceMockProcessFileDualModeParams{ctx, prodKBUID, stagingKBUID, fileUIDs, userUID, requesterUID}
	mmProcessFileDualMode.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmProcessFileDualMode.expectations {
		if minimock.Equal(e.params, mmProcessFileDualMode.defaultExpectation.params) {
			mmProcessFileDualMode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmProcessFileDualMode.defaultExpectation.params)
		}
	}

	return mmProcessFileDualMode
}

// ExpectCtxParam1 sets up expected param ctx for Service.ProcessFileDualMode
func (mmProcessFileDualMode *mServiceMockProcessFileDualMode) ExpectCtxParam1(ctx context.Context) *mServiceMockProcessFileDualMode {
	if mmProcessFileDualMode.mock.funcProcessFileDualMode != nil {
		mmProcessFileDualMode.mock.t.Fatalf("ServiceMock.ProcessFileDualMode mock is already set by Set")
	}

	if mmProcessFileDualMode.defaultExpectation == nil {
		mmProcessFileDualMode.defaultExpectation = &ServiceMockProcessFileDualModeExpectation{}
	}

	if mmProcessFileDualMode.defaultExpectation.params != nil {
		mmProcessFileDualMode.mock.t.Fatalf("ServiceMock.ProcessFileDualMode mock is already set by Expect")
	}

	if mmProcessFileDualMode.defaultExpectation.paramPtrs == nil {
		mmProcessFileDualMode.defaultExpectation.paramPtrs = &ServiceMockProcessFileDualModeParamPtrs{}
	}
	mmProcessFileDualMode.defaultExpectation.paramPtrs.ctx = &ctx
	mmProcessFileDualMode.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmProcessFileDualMode
}

// ExpectProdKBUIDParam2 sets up expected param prodKBUID for Service.ProcessFileDualMode
func (mmProcessFileDualMode *mServiceMockProcessFileDualMode) ExpectProdKBUIDParam2(prodKBUID types.KBUIDType) *mServiceMockProcessFileDualMode {
	if mmProcessFileDualMode.mock.funcProcessFileDualMode != nil {
		mmProcessFileDualMode.mock.t.Fatalf("ServiceMock.ProcessFileDualMode mock is already set by Set")
	}

	if mmProcessFileDualMode.defaultExpectation == nil {
		mmProcessFileDualMode.defaultExpectation = &ServiceMockProcessFileDualModeExpectation{}
	}

	if mmProcessFileDualMode.defaultExpectation.params != nil {
		mmProcessFileDualMode.mock.t.Fatalf("ServiceMock.ProcessFileDualMode mock is already set by Expect")
	}

	if mmProcessFileDualMode.defaultExpectation.paramPtrs == nil {
		mmProcessFileDualMode.defaultExpectation.paramPtrs = &ServiceMockProcessFileDualModeParamPtrs{}
	}
	mmProcessFileDualMode.defaultExpectation.paramPtrs.prodKBUID = &prodKBUID
	mmProcessFileDualMode.defaultExpectation.expectationOrigins.originProdKBUID = minimock.CallerInfo(1)

	return mmProcessFileDualMode
}

// ExpectStagingKBUIDParam3 sets up expected param stagingKBUID for Service.ProcessFileDualMode
func (mmProcessFileDualMode *mServiceMockProcessFileDualMode) ExpectStagingKBUIDParam3(stagingKBUID types.KBUIDType) *mServiceMockProcessFileDualMode {
	if mmProcessFileDualMode.mock.funcProcessFileDualMode != nil {
		mmProcessFileDualMode.mock.t.Fatalf("ServiceMock.ProcessFileDualMode mock is already set by Set")
	}

	if mmProcessFileDualMode.defaultExpectation == nil {
		mmProcessFileDualMode.defaultExpectation = &ServiceMockProcessFileDualModeExpectation{}
	}

	if mmProcessFileDualMode.defaultExpectation.params != nil {
		mmProcessFileDualMode.mock.t.Fatalf("ServiceMock.ProcessFileDualMode mock is already set by Expect")
	}

	if mmProcessFileDualMode.defaultExpectation.paramPtrs == nil {
		mmProcessFileDualMode.defaultExpectation.paramPtrs = &ServiceMockProcessFileDualModeParamPtrs{}
	}
	mmProcessFileDualMode.defaultExpectation.paramPtrs.stagingKBUID = &stagingKBUID
	mmProcessFileDualMode.defaultExpectation.expectationOrigins.originStagingKBUID = minimock.CallerInfo(1)

	return mmProcessFileDualMode
}

// ExpectFileUIDsParam4 sets up expected param fileUIDs for Service.ProcessFileDualMode
func (mmProcessFileDualMode *mServiceMockProcessFileDualMode) ExpectFileUIDsParam4(fileUIDs []types.FileUIDType) *mServiceMockProcessFileDualMode {
	if mmProcessFileDualMode.mock.funcProcessFileDualMode != nil {
		mmProcessFileDualMode.mock.t.Fatalf("ServiceMock.ProcessFileDualMode mock is already set by Set")
	}

	if mmProcessFileDualMode.defaultExpectation == nil {
		mmProcessFileDualMode.defaultExpectation = &ServiceMockProcessFileDualModeExpectation{}
	}

	if mmProcessFileDualMode.defaultExpectation.params != nil {
		mmProcessFileDualMode.mock.t.Fatalf("ServiceMock.ProcessFileDualMode mock is already set by Expect")
	}

	if mmProcessFileDualMode.defaultExpectation.paramPtrs == nil {
		mmProcessFileDualMode.defaultExpectation.paramPtrs = &ServiceMockProcessFileDualModeParamPtrs{}
	}
	mmProcessFileDualMode.defaultExpectation.paramPtrs.fileUIDs = &fileUIDs
	mmProcessFileDualMode.defaultExpectation.expectationOrigins.originFileUIDs = minimock.CallerInfo(1)

	return mmProcessFileDualMode
}

// ExpectUserUIDParam5 sets up expected param userUID for Service.ProcessFileDualMode
func (mmProcessFileDualMode *mServiceMockProcessFileDualMode) ExpectUserUIDParam5(userUID types.RequesterUIDType) *mServiceMockProcessFileDualMode {
	if mmProcessFileDualMode.mock.funcProcessFileDualMode != nil {
		mmProcessFileDualMode.mock.t.Fatalf("ServiceMock.ProcessFileDualMode mock is already set by Set")
	}

	if mmProcessFileDualMode.defaultExpectation == nil {
		mmProcessFileDualMode.defaultExpectation = &ServiceMockProcessFileDualModeExpectation{}
	}

	if mmProcessFileDualMode.defaultExpectation.params != nil {
		mmProcessFileDualMode.mock.t.Fatalf("ServiceMock.ProcessFileDualMode mock is already set by Expect")
	}

	if mmProcessFileDualMode.defaultExpectation.paramPtrs == nil {
		mmProcessFileDualMode.defaultExpectation.paramPtrs = &ServiceMockProcessFileDualModeParamPtrs{}
	}
	mmProcessFileDualMode.defaultExpectation.paramPtrs.userUID = &userUID
	mmProcessFileDualMode.defaultExpectation.expectationOrigins.originUserUID = minimock.CallerInfo(1)

	return mmProcessFileDualMode
}

// ExpectRequesterUIDParam6 sets up expected param requesterUID for Service.ProcessFileDualMode
func (mmProcessFileDualMode *mServiceMockProcessFileDualMode) ExpectRequesterUIDParam6(requesterUID types.RequesterUIDType) *mServiceMockProcessFileDualMode {
	if mmProcessFileDualMode.mock.funcProcessFileDualMode != nil {
		mmProcessFileDualMode.mock.t.Fatalf("ServiceMock.ProcessFileDualMode mock is already set by Set")
	}

	if mmProcessFileDualMode.defaultExpectation == nil {
		mmProcessFileDualMode.defaultExpectation = &ServiceMockProcessFileDualModeExpectation{}
	}

	if mmProcessFileDualMode.defaultExpectation.params != nil {
		mmProcessFileDualMode.mock.t.Fatalf("ServiceMock.ProcessFileDualMode mock is already set by Expect")
	}

	if mmProcessFileDualMode.defaultExpectation.paramPtrs == nil {
		mmProcessFileDualMode.defaultExpectation.paramPtrs = &ServiceMockProcessFileDualModeParamPtrs{}
	}
	mmProcessFileDualMode.defaultExpectation.paramPtrs.requesterUID = &requesterUID
	mmProcessFileDualMode.defaultExpectation.expectationOrigins.originRequesterUID = minimock.CallerInfo(1)

	return mmProcessFileDualMode
}

// Inspect accepts an inspector function that has same arguments as the Service.ProcessFileDualMode
func (mmProcessFileDualMode *mServiceMockProcessFileDualMode) Inspect(f func(ctx context.Context, prodKBUID types.KBUIDType, stagingKBUID types.KBUIDType, fileUIDs []types.FileUIDType, userUID types.RequesterUIDType, requesterUID types.RequesterUIDType)) *mServiceMockProcessFileDualMode {
	if mmProcessFileDualMode.mock.inspectFuncProcessFileDualMode != nil {
		mmProcessFileDualMode.mock.t.Fatalf("Inspect function is already set for ServiceMock.ProcessFileDualMode")
	}

	mmProcessFileDualMode.mock.inspectFuncProcessFileDualMode = f

	return mmProcessFileDualMode
}

// Return sets up results that will be returned by Service.ProcessFileDualMode
func (mmProcessFileDualMode *mServiceMockProcessFileDualMode) Return(err error) *ServiceMock {
	if mmProcessFileDualMode.mock.funcProcessFileDualMode != nil {
		mmProcessFileDualMode.mock.t.Fatalf("ServiceMock.ProcessFileDualMode mock is already set by Set")
	}

	if mmProcessFileDualMode.defaultExpectation == nil {
		mmProcessFileDualMode.defaultExpectation = &ServiceMockProcessFileDualModeExpectation{mock: mmProcessFileDualMode.mock}
	}
	mmProcessFileDualMode.defaultExpectation.results = &ServiceMockProcessFileDualModeResults{err}
	mmProcessFileDualMode.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmProcessFileDualMode.mock
}

// Set uses given function f to mock the Service.ProcessFileDualMode method
func (mmProcessFileDualMode *mServiceMockProcessFileDualMode) Set(f func(ctx context.Context, prodKBUID types.KBUIDType, stagingKBUID types.KBUIDType, fileUIDs []types.FileUIDType, userUID types.RequesterUIDType, requesterUID types.RequesterUIDType) (err error)) *ServiceMock {
	if mmProcessFileDualMode.defaultExpectation != nil {
		mmProcessFileDualMode.mock.t.Fatalf("Default expectation is already set for the Service.ProcessFileDualMode method")
	}

	if len(mmProcessFileDualMode.expectations) > 0 {
		mmProcessFileDualMode.mock.t.Fatalf("Some expectations are already set for the Service.ProcessFileDualMode method")
	}

	mmProcessFileDualMode.mock.funcProcessFileDualMode = f
	mmProcessFileDualMode.mock.funcProcessFileDualModeOrigin = minimock.CallerInfo(1)
	return mmProcessFileDualMode.mock
}

// When sets expectation for the Service.ProcessFileDualMode which will trigger the result defined by the following
// Then helper
func (mmProcessFileDualMode *mServiceMockProcessFileDualMode) When(ctx context.Context, prodKBUID types.KBUIDType, stagingKBUID types.KBUIDType, fileUIDs []types.FileUIDType, userUID types.RequesterUIDType, requesterUID types.RequesterUIDType) *ServiceMockProcessFileDualModeExpectation {
	if mmProcessFileDualMode.mock.funcProcessFileDualMode != nil {
		mmProcessFileDualMode.mock.t.Fatalf("ServiceMock.ProcessFileDualMode mock is already set by Set")
	}

	expectation := &ServiceMockProcessFileDualModeExpectation{
		mock:               mmProcessFileDualMode.mock,
		params:             &ServiceMockProcessFileDualModeParams{ctx, prodKBUID, stagingKBUID, fileUIDs, userUID, requesterUID},
		expectationOrigins: ServiceMockProcessFileDualModeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmProcessFileDualMode.expectations = append(mmProcessFileDualMode.expectations, expectation)
	return expectation
}

// Then sets up Service.ProcessFileDualMode return parameters for the expectation previously defined by the When method
func (e *ServiceMockProcessFileDualModeExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockProcessFileDualModeResults{err}
	return e.mock
}

// Times sets number of times Service.ProcessFileDualMode should be invoked
func (mmProcessFileDualMode *mServiceMockProcessFileDualMode) Times(n uint64) *mServiceMockProcessFileDualMode {
	if n == 0 {
		mmProcessFileDualMode.mock.t.Fatalf("Times of ServiceMock.ProcessFileDualMode mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmProcessFileDualMode.expectedInvocations, n)
	mmProcessFileDualMode.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmProcessFileDualMode
}

func (mmProcessFileDualMode *mServiceMockProcessFileDualMode) invocationsDone() bool {
	if len(mmProcessFileDualMode.expectations) == 0 && mmProcessFileDualMode.defaultExpectation == nil && mmProcessFileDualMode.mock.funcProcessFileDualMode == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmProcessFileDualMode.mock.afterProcessFileDualModeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmProcessFileDualMode.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ProcessFileDualMode implements mm_service.Service
func (mmProcessFileDualMode *ServiceMock) ProcessFileDualMode(ctx context.Context, prodKBUID types.KBUIDType, stagingKBUID types.KBUIDType, fileUIDs []types.FileUIDType, userUID types.RequesterUIDType, requesterUID types.RequesterUIDType) (err error) {
	mm_atomic.AddUint64(&mmProcessFileDualMode.beforeProcessFileDualModeCounter, 1)
	defer mm_atomic.AddUint64(&mmProcessFileDualMode.afterProcessFileDualModeCounter, 1)

	mmProcessFileDualMode.t.Helper()

	if mmProcessFileDualMode.inspectFuncProcessFileDualMode != nil {
		mmProcessFileDualMode.inspectFuncProcessFileDualMode(ctx, prodKBUID, stagingKBUID, fileUIDs, userUID, requesterUID)
	}

	mm_params := ServiceMockProcessFileDualModeParams{ctx, prodKBUID, stagingKBUID, fileUIDs, userUID, requesterUID}

	// Record call args
	mmProcessFileDualMode.ProcessFileDualModeMock.mutex.Lock()
	mmProcessFileDualMode.ProcessFileDualModeMock.callArgs = append(mmProcessFileDualMode.ProcessFileDualModeMock.callArgs, &mm_params)
	mmProcessFileDualMode.ProcessFileDualModeMock.mutex.Unlock()

	for _, e := range mmProcessFileDualMode.ProcessFileDualModeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmProcessFileDualMode.ProcessFileDualModeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProcessFileDualMode.ProcessFileDualModeMock.defaultExpectation.Counter, 1)
		mm_want := mmProcessFileDualMode.ProcessFileDualModeMock.defaultExpectation.params
		mm_want_ptrs := mmProcessFileDualMode.ProcessFileDualModeMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockProcessFileDualModeParams{ctx, prodKBUID, stagingKBUID, fileUIDs, userUID, requesterUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmProcessFileDualMode.t.Errorf("ServiceMock.ProcessFileDualMode got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProcessFileDualMode.ProcessFileDualModeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.prodKBUID != nil && !minimock.Equal(*mm_want_ptrs.prodKBUID, mm_got.prodKBUID) {
				mmProcessFileDualMode.t.Errorf("ServiceMock.ProcessFileDualMode got unexpected parameter prodKBUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProcessFileDualMode.ProcessFileDualModeMock.defaultExpectation.expectationOrigins.originProdKBUID, *mm_want_ptrs.prodKBUID, mm_got.prodKBUID, minimock.Diff(*mm_want_ptrs.prodKBUID, mm_got.prodKBUID))
			}

			if mm_want_ptrs.stagingKBUID != nil && !minimock.Equal(*mm_want_ptrs.stagingKBUID, mm_got.stagingKBUID) {
				mmProcessFileDualMode.t.Errorf("ServiceMock.ProcessFileDualMode got unexpected parameter stagingKBUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProcessFileDualMode.ProcessFileDualModeMock.defaultExpectation.expectationOrigins.originStagingKBUID, *mm_want_ptrs.stagingKBUID, mm_got.stagingKBUID, minimock.Diff(*mm_want_ptrs.stagingKBUID, mm_got.stagingKBUID))
			}

			if mm_want_ptrs.fileUIDs != nil && !minimock.Equal(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs) {
				mmProcessFileDualMode.t.Errorf("ServiceMock.ProcessFileDualMode got unexpected parameter fileUIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProcessFileDualMode.ProcessFileDualModeMock.defaultExpectation.expectationOrigins.originFileUIDs, *mm_want_ptrs.fileUIDs, mm_got.fileUIDs, minimock.Diff(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs))
			}

			if mm_want_ptrs.userUID != nil && !minimock.Equal(*mm_want_ptrs.userUID, mm_got.userUID) {
				mmProcessFileDualMode.t.Errorf("ServiceMock.ProcessFileDualMode got unexpected parameter userUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProcessFileDualMode.ProcessFileDualModeMock.defaultExpectation.expectationOrigins.originUserUID, *mm_want_ptrs.userUID, mm_got.userUID, minimock.Diff(*mm_want_ptrs.userUID, mm_got.userUID))
			}

			if mm_want_ptrs.requesterUID != nil && !minimock.Equal(*mm_want_ptrs.requesterUID, mm_got.requesterUID) {
				mmProcessFileDualMode.t.Errorf("ServiceMock.ProcessFileDualMode got unexpected parameter requesterUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProcessFileDualMode.ProcessFileDualModeMock.defaultExpectation.expectationOrigins.originRequesterUID, *mm_want_ptrs.requesterUID, mm_got.requesterUID, minimock.Diff(*mm_want_ptrs.requesterUID, mm_got.requesterUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmProcessFileDualMode.t.Errorf("ServiceMock.ProcessFileDualMode got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmProcessFileDualMode.ProcessFileDualModeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmProcessFileDualMode.ProcessFileDualModeMock.defaultExpectation.results
		if mm_results == nil {
			mmProcessFileDualMode.t.Fatal("No results are set for the ServiceMock.ProcessFileDualMode")
		}
		return (*mm_results).err
	}
	if mmProcessFileDualMode.funcProcessFileDualMode != nil {
		return mmProcessFileDualMode.funcProcessFileDualMode(ctx, prodKBUID, stagingKBUID, fileUIDs, userUID, requesterUID)
	}
	mmProcessFileDualMode.t.Fatalf("Unexpected call to ServiceMock.ProcessFileDualMode. %v %v %v %v %v %v", ctx, prodKBUID, stagingKBUID, fileUIDs, userUID, requesterUID)
	return
}

// ProcessFileDualModeAfterCounter returns a count of finished ServiceMock.ProcessFileDualMode invocations
func (mmProcessFileDualMode *ServiceMock) ProcessFileDualModeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessFileDualMode.afterProcessFileDualModeCounter)
}

// ProcessFileDualModeBeforeCounter returns a count of ServiceMock.ProcessFileDualMode invocations
func (mmProcessFileDualMode *ServiceMock) ProcessFileDualModeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessFileDualMode.beforeProcessFileDualModeCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.ProcessFileDualMode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmProcessFileDualMode *mServiceMockProcessFileDualMode) Calls() []*ServiceMockProcessFileDualModeParams {
	mmProcessFileDualMode.mutex.RLock()

	argCopy := make([]*ServiceMockProcessFileDualModeParams, len(mmProcessFileDualMode.callArgs))
	copy(argCopy, mmProcessFileDualMode.callArgs)

	mmProcessFileDualMode.mutex.RUnlock()

	return argCopy
}

// MinimockProcessFileDualModeDone returns true if the count of the ProcessFileDualMode invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockProcessFileDualModeDone() bool {
	if m.ProcessFileDualModeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ProcessFileDualModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ProcessFileDualModeMock.invocationsDone()
}

// MinimockProcessFileDualModeInspect logs each unmet expectation
func (m *ServiceMock) MinimockProcessFileDualModeInspect() {
	for _, e := range m.ProcessFileDualModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.ProcessFileDualMode at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterProcessFileDualModeCounter := mm_atomic.LoadUint64(&m.afterProcessFileDualModeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ProcessFileDualModeMock.defaultExpectation != nil && afterProcessFileDualModeCounter < 1 {
		if m.ProcessFileDualModeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.ProcessFileDualMode at\n%s", m.ProcessFileDualModeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.ProcessFileDualMode at\n%s with params: %#v", m.ProcessFileDualModeMock.defaultExpectation.expectationOrigins.origin, *m.ProcessFileDualModeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProcessFileDualMode != nil && afterProcessFileDualModeCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.ProcessFileDualMode at\n%s", m.funcProcessFileDualModeOrigin)
	}

	if !m.ProcessFileDualModeMock.invocationsDone() && afterProcessFileDualModeCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.ProcessFileDualMode at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ProcessFileDualModeMock.expectedInvocations), m.ProcessFileDualModeMock.expectedInvocationsOrigin, afterProcessFileDualModeCounter)
	}
}

type mServiceMockPurgeRollbackAdmin struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockPurgeRollbackAdminExpectation
	expectations       []*ServiceMockPurgeRollbackAdminExpectation

	callArgs []*ServiceMockPurgeRollbackAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockPurgeRollbackAdminExpectation specifies expectation struct of the Service.PurgeRollbackAdmin
type ServiceMockPurgeRollbackAdminExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockPurgeRollbackAdminParams
	paramPtrs          *ServiceMockPurgeRollbackAdminParamPtrs
	expectationOrigins ServiceMockPurgeRollbackAdminExpectationOrigins
	results            *ServiceMockPurgeRollbackAdminResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockPurgeRollbackAdminParams contains parameters of the Service.PurgeRollbackAdmin
type ServiceMockPurgeRollbackAdminParams struct {
	ctx context.Context
	o1  types.OwnerUIDType
	s1  string
}

// ServiceMockPurgeRollbackAdminParamPtrs contains pointers to parameters of the Service.PurgeRollbackAdmin
type ServiceMockPurgeRollbackAdminParamPtrs struct {
	ctx *context.Context
	o1  *types.OwnerUIDType
	s1  *string
}

// ServiceMockPurgeRollbackAdminResults contains results of the Service.PurgeRollbackAdmin
type ServiceMockPurgeRollbackAdminResults struct {
	pp1 *artifactpb.PurgeRollbackAdminResponse
	err error
}

// ServiceMockPurgeRollbackAdminOrigins contains origins of expectations of the Service.PurgeRollbackAdmin
type ServiceMockPurgeRollbackAdminExpectationOrigins struct {
	origin    string
	originCtx string
	originO1  string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPurgeRollbackAdmin *mServiceMockPurgeRollbackAdmin) Optional() *mServiceMockPurgeRollbackAdmin {
	mmPurgeRollbackAdmin.optional = true
	return mmPurgeRollbackAdmin
}

// Expect sets up expected params for Service.PurgeRollbackAdmin
func (mmPurgeRollbackAdmin *mServiceMockPurgeRollbackAdmin) Expect(ctx context.Context, o1 types.OwnerUIDType, s1 string) *mServiceMockPurgeRollbackAdmin {
	if mmPurgeRollbackAdmin.mock.funcPurgeRollbackAdmin != nil {
		mmPurgeRollbackAdmin.mock.t.Fatalf("ServiceMock.PurgeRollbackAdmin mock is already set by Set")
	}

	if mmPurgeRollbackAdmin.defaultExpectation == nil {
		mmPurgeRollbackAdmin.defaultExpectation = &ServiceMockPurgeRollbackAdminExpectation{}
	}

	if mmPurgeRollbackAdmin.defaultExpectation.paramPtrs != nil {
		mmPurgeRollbackAdmin.mock.t.Fatalf("ServiceMock.PurgeRollbackAdmin mock is already set by ExpectParams functions")
	}

	mmPurgeRollbackAdmin.defaultExpectation.params = &ServiceMockPurgeRollbackAdminParams{ctx, o1, s1}
	mmPurgeRollbackAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPurgeRollbackAdmin.expectations {
		if minimock.Equal(e.params, mmPurgeRollbackAdmin.defaultExpectation.params) {
			mmPurgeRollbackAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPurgeRollbackAdmin.defaultExpectation.params)
		}
	}

	return mmPurgeRollbackAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Service.PurgeRollbackAdmin
func (mmPurgeRollbackAdmin *mServiceMockPurgeRollbackAdmin) ExpectCtxParam1(ctx context.Context) *mServiceMockPurgeRollbackAdmin {
	if mmPurgeRollbackAdmin.mock.funcPurgeRollbackAdmin != nil {
		mmPurgeRollbackAdmin.mock.t.Fatalf("ServiceMock.PurgeRollbackAdmin mock is already set by Set")
	}

	if mmPurgeRollbackAdmin.defaultExpectation == nil {
		mmPurgeRollbackAdmin.defaultExpectation = &ServiceMockPurgeRollbackAdminExpectation{}
	}

	if mmPurgeRollbackAdmin.defaultExpectation.params != nil {
		mmPurgeRollbackAdmin.mock.t.Fatalf("ServiceMock.PurgeRollbackAdmin mock is already set by Expect")
	}

	if mmPurgeRollbackAdmin.defaultExpectation.paramPtrs == nil {
		mmPurgeRollbackAdmin.defaultExpectation.paramPtrs = &ServiceMockPurgeRollbackAdminParamPtrs{}
	}
	mmPurgeRollbackAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmPurgeRollbackAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPurgeRollbackAdmin
}

// ExpectO1Param2 sets up expected param o1 for Service.PurgeRollbackAdmin
func (mmPurgeRollbackAdmin *mServiceMockPurgeRollbackAdmin) ExpectO1Param2(o1 types.OwnerUIDType) *mServiceMockPurgeRollbackAdmin {
	if mmPurgeRollbackAdmin.mock.funcPurgeRollbackAdmin != nil {
		mmPurgeRollbackAdmin.mock.t.Fatalf("ServiceMock.PurgeRollbackAdmin mock is already set by Set")
	}

	if mmPurgeRollbackAdmin.defaultExpectation == nil {
		mmPurgeRollbackAdmin.defaultExpectation = &ServiceMockPurgeRollbackAdminExpectation{}
	}

	if mmPurgeRollbackAdmin.defaultExpectation.params != nil {
		mmPurgeRollbackAdmin.mock.t.Fatalf("ServiceMock.PurgeRollbackAdmin mock is already set by Expect")
	}

	if mmPurgeRollbackAdmin.defaultExpectation.paramPtrs == nil {
		mmPurgeRollbackAdmin.defaultExpectation.paramPtrs = &ServiceMockPurgeRollbackAdminParamPtrs{}
	}
	mmPurgeRollbackAdmin.defaultExpectation.paramPtrs.o1 = &o1
	mmPurgeRollbackAdmin.defaultExpectation.expectationOrigins.originO1 = minimock.CallerInfo(1)

	return mmPurgeRollbackAdmin
}

// ExpectS1Param3 sets up expected param s1 for Service.PurgeRollbackAdmin
func (mmPurgeRollbackAdmin *mServiceMockPurgeRollbackAdmin) ExpectS1Param3(s1 string) *mServiceMockPurgeRollbackAdmin {
	if mmPurgeRollbackAdmin.mock.funcPurgeRollbackAdmin != nil {
		mmPurgeRollbackAdmin.mock.t.Fatalf("ServiceMock.PurgeRollbackAdmin mock is already set by Set")
	}

	if mmPurgeRollbackAdmin.defaultExpectation == nil {
		mmPurgeRollbackAdmin.defaultExpectation = &ServiceMockPurgeRollbackAdminExpectation{}
	}

	if mmPurgeRollbackAdmin.defaultExpectation.params != nil {
		mmPurgeRollbackAdmin.mock.t.Fatalf("ServiceMock.PurgeRollbackAdmin mock is already set by Expect")
	}

	if mmPurgeRollbackAdmin.defaultExpectation.paramPtrs == nil {
		mmPurgeRollbackAdmin.defaultExpectation.paramPtrs = &ServiceMockPurgeRollbackAdminParamPtrs{}
	}
	mmPurgeRollbackAdmin.defaultExpectation.paramPtrs.s1 = &s1
	mmPurgeRollbackAdmin.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmPurgeRollbackAdmin
}

// Inspect accepts an inspector function that has same arguments as the Service.PurgeRollbackAdmin
func (mmPurgeRollbackAdmin *mServiceMockPurgeRollbackAdmin) Inspect(f func(ctx context.Context, o1 types.OwnerUIDType, s1 string)) *mServiceMockPurgeRollbackAdmin {
	if mmPurgeRollbackAdmin.mock.inspectFuncPurgeRollbackAdmin != nil {
		mmPurgeRollbackAdmin.mock.t.Fatalf("Inspect function is already set for ServiceMock.PurgeRollbackAdmin")
	}

	mmPurgeRollbackAdmin.mock.inspectFuncPurgeRollbackAdmin = f

	return mmPurgeRollbackAdmin
}

// Return sets up results that will be returned by Service.PurgeRollbackAdmin
func (mmPurgeRollbackAdmin *mServiceMockPurgeRollbackAdmin) Return(pp1 *artifactpb.PurgeRollbackAdminResponse, err error) *ServiceMock {
	if mmPurgeRollbackAdmin.mock.funcPurgeRollbackAdmin != nil {
		mmPurgeRollbackAdmin.mock.t.Fatalf("ServiceMock.PurgeRollbackAdmin mock is already set by Set")
	}

	if mmPurgeRollbackAdmin.defaultExpectation == nil {
		mmPurgeRollbackAdmin.defaultExpectation = &ServiceMockPurgeRollbackAdminExpectation{mock: mmPurgeRollbackAdmin.mock}
	}
	mmPurgeRollbackAdmin.defaultExpectation.results = &ServiceMockPurgeRollbackAdminResults{pp1, err}
	mmPurgeRollbackAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPurgeRollbackAdmin.mock
}

// Set uses given function f to mock the Service.PurgeRollbackAdmin method
func (mmPurgeRollbackAdmin *mServiceMockPurgeRollbackAdmin) Set(f func(ctx context.Context, o1 types.OwnerUIDType, s1 string) (pp1 *artifactpb.PurgeRollbackAdminResponse, err error)) *ServiceMock {
	if mmPurgeRollbackAdmin.defaultExpectation != nil {
		mmPurgeRollbackAdmin.mock.t.Fatalf("Default expectation is already set for the Service.PurgeRollbackAdmin method")
	}

	if len(mmPurgeRollbackAdmin.expectations) > 0 {
		mmPurgeRollbackAdmin.mock.t.Fatalf("Some expectations are already set for the Service.PurgeRollbackAdmin method")
	}

	mmPurgeRollbackAdmin.mock.funcPurgeRollbackAdmin = f
	mmPurgeRollbackAdmin.mock.funcPurgeRollbackAdminOrigin = minimock.CallerInfo(1)
	return mmPurgeRollbackAdmin.mock
}

// When sets expectation for the Service.PurgeRollbackAdmin which will trigger the result defined by the following
// Then helper
func (mmPurgeRollbackAdmin *mServiceMockPurgeRollbackAdmin) When(ctx context.Context, o1 types.OwnerUIDType, s1 string) *ServiceMockPurgeRollbackAdminExpectation {
	if mmPurgeRollbackAdmin.mock.funcPurgeRollbackAdmin != nil {
		mmPurgeRollbackAdmin.mock.t.Fatalf("ServiceMock.PurgeRollbackAdmin mock is already set by Set")
	}

	expectation := &ServiceMockPurgeRollbackAdminExpectation{
		mock:               mmPurgeRollbackAdmin.mock,
		params:             &ServiceMockPurgeRollbackAdminParams{ctx, o1, s1},
		expectationOrigins: ServiceMockPurgeRollbackAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPurgeRollbackAdmin.expectations = append(mmPurgeRollbackAdmin.expectations, expectation)
	return expectation
}

// Then sets up Service.PurgeRollbackAdmin return parameters for the expectation previously defined by the When method
func (e *ServiceMockPurgeRollbackAdminExpectation) Then(pp1 *artifactpb.PurgeRollbackAdminResponse, err error) *ServiceMock {
	e.results = &ServiceMockPurgeRollbackAdminResults{pp1, err}
	return e.mock
}

// Times sets number of times Service.PurgeRollbackAdmin should be invoked
func (mmPurgeRollbackAdmin *mServiceMockPurgeRollbackAdmin) Times(n uint64) *mServiceMockPurgeRollbackAdmin {
	if n == 0 {
		mmPurgeRollbackAdmin.mock.t.Fatalf("Times of ServiceMock.PurgeRollbackAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPurgeRollbackAdmin.expectedInvocations, n)
	mmPurgeRollbackAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPurgeRollbackAdmin
}

func (mmPurgeRollbackAdmin *mServiceMockPurgeRollbackAdmin) invocationsDone() bool {
	if len(mmPurgeRollbackAdmin.expectations) == 0 && mmPurgeRollbackAdmin.defaultExpectation == nil && mmPurgeRollbackAdmin.mock.funcPurgeRollbackAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPurgeRollbackAdmin.mock.afterPurgeRollbackAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPurgeRollbackAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PurgeRollbackAdmin implements mm_service.Service
func (mmPurgeRollbackAdmin *ServiceMock) PurgeRollbackAdmin(ctx context.Context, o1 types.OwnerUIDType, s1 string) (pp1 *artifactpb.PurgeRollbackAdminResponse, err error) {
	mm_atomic.AddUint64(&mmPurgeRollbackAdmin.beforePurgeRollbackAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmPurgeRollbackAdmin.afterPurgeRollbackAdminCounter, 1)

	mmPurgeRollbackAdmin.t.Helper()

	if mmPurgeRollbackAdmin.inspectFuncPurgeRollbackAdmin != nil {
		mmPurgeRollbackAdmin.inspectFuncPurgeRollbackAdmin(ctx, o1, s1)
	}

	mm_params := ServiceMockPurgeRollbackAdminParams{ctx, o1, s1}

	// Record call args
	mmPurgeRollbackAdmin.PurgeRollbackAdminMock.mutex.Lock()
	mmPurgeRollbackAdmin.PurgeRollbackAdminMock.callArgs = append(mmPurgeRollbackAdmin.PurgeRollbackAdminMock.callArgs, &mm_params)
	mmPurgeRollbackAdmin.PurgeRollbackAdminMock.mutex.Unlock()

	for _, e := range mmPurgeRollbackAdmin.PurgeRollbackAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmPurgeRollbackAdmin.PurgeRollbackAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPurgeRollbackAdmin.PurgeRollbackAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmPurgeRollbackAdmin.PurgeRollbackAdminMock.defaultExpectation.params
		mm_want_ptrs := mmPurgeRollbackAdmin.PurgeRollbackAdminMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockPurgeRollbackAdminParams{ctx, o1, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPurgeRollbackAdmin.t.Errorf("ServiceMock.PurgeRollbackAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPurgeRollbackAdmin.PurgeRollbackAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.o1 != nil && !minimock.Equal(*mm_want_ptrs.o1, mm_got.o1) {
				mmPurgeRollbackAdmin.t.Errorf("ServiceMock.PurgeRollbackAdmin got unexpected parameter o1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPurgeRollbackAdmin.PurgeRollbackAdminMock.defaultExpectation.expectationOrigins.originO1, *mm_want_ptrs.o1, mm_got.o1, minimock.Diff(*mm_want_ptrs.o1, mm_got.o1))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmPurgeRollbackAdmin.t.Errorf("ServiceMock.PurgeRollbackAdmin got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPurgeRollbackAdmin.PurgeRollbackAdminMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPurgeRollbackAdmin.t.Errorf("ServiceMock.PurgeRollbackAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPurgeRollbackAdmin.PurgeRollbackAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPurgeRollbackAdmin.PurgeRollbackAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmPurgeRollbackAdmin.t.Fatal("No results are set for the ServiceMock.PurgeRollbackAdmin")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmPurgeRollbackAdmin.funcPurgeRollbackAdmin != nil {
		return mmPurgeRollbackAdmin.funcPurgeRollbackAdmin(ctx, o1, s1)
	}
	mmPurgeRollbackAdmin.t.Fatalf("Unexpected call to ServiceMock.PurgeRollbackAdmin. %v %v %v", ctx, o1, s1)
	return
}

// PurgeRollbackAdminAfterCounter returns a count of finished ServiceMock.PurgeRollbackAdmin invocations
func (mmPurgeRollbackAdmin *ServiceMock) PurgeRollbackAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPurgeRollbackAdmin.afterPurgeRollbackAdminCounter)
}

// PurgeRollbackAdminBeforeCounter returns a count of ServiceMock.PurgeRollbackAdmin invocations
func (mmPurgeRollbackAdmin *ServiceMock) PurgeRollbackAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPurgeRollbackAdmin.beforePurgeRollbackAdminCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.PurgeRollbackAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPurgeRollbackAdmin *mServiceMockPurgeRollbackAdmin) Calls() []*ServiceMockPurgeRollbackAdminParams {
	mmPurgeRollbackAdmin.mutex.RLock()

	argCopy := make([]*ServiceMockPurgeRollbackAdminParams, len(mmPurgeRollbackAdmin.callArgs))
	copy(argCopy, mmPurgeRollbackAdmin.callArgs)

	mmPurgeRollbackAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockPurgeRollbackAdminDone returns true if the count of the PurgeRollbackAdmin invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockPurgeRollbackAdminDone() bool {
	if m.PurgeRollbackAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PurgeRollbackAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PurgeRollbackAdminMock.invocationsDone()
}

// MinimockPurgeRollbackAdminInspect logs each unmet expectation
func (m *ServiceMock) MinimockPurgeRollbackAdminInspect() {
	for _, e := range m.PurgeRollbackAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.PurgeRollbackAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPurgeRollbackAdminCounter := mm_atomic.LoadUint64(&m.afterPurgeRollbackAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PurgeRollbackAdminMock.defaultExpectation != nil && afterPurgeRollbackAdminCounter < 1 {
		if m.PurgeRollbackAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.PurgeRollbackAdmin at\n%s", m.PurgeRollbackAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.PurgeRollbackAdmin at\n%s with params: %#v", m.PurgeRollbackAdminMock.defaultExpectation.expectationOrigins.origin, *m.PurgeRollbackAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPurgeRollbackAdmin != nil && afterPurgeRollbackAdminCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.PurgeRollbackAdmin at\n%s", m.funcPurgeRollbackAdminOrigin)
	}

	if !m.PurgeRollbackAdminMock.invocationsDone() && afterPurgeRollbackAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.PurgeRollbackAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PurgeRollbackAdminMock.expectedInvocations), m.PurgeRollbackAdminMock.expectedInvocationsOrigin, afterPurgeRollbackAdminCounter)
	}
}

type mServiceMockRedisClient struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockRedisClientExpectation
	expectations       []*ServiceMockRedisClientExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockRedisClientExpectation specifies expectation struct of the Service.RedisClient
type ServiceMockRedisClientExpectation struct {
	mock *ServiceMock

	results      *ServiceMockRedisClientResults
	returnOrigin string
	Counter      uint64
}

// ServiceMockRedisClientResults contains results of the Service.RedisClient
type ServiceMockRedisClientResults struct {
	cp1 *redis.Client
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRedisClient *mServiceMockRedisClient) Optional() *mServiceMockRedisClient {
	mmRedisClient.optional = true
	return mmRedisClient
}

// Expect sets up expected params for Service.RedisClient
func (mmRedisClient *mServiceMockRedisClient) Expect() *mServiceMockRedisClient {
	if mmRedisClient.mock.funcRedisClient != nil {
		mmRedisClient.mock.t.Fatalf("ServiceMock.RedisClient mock is already set by Set")
	}

	if mmRedisClient.defaultExpectation == nil {
		mmRedisClient.defaultExpectation = &ServiceMockRedisClientExpectation{}
	}

	return mmRedisClient
}

// Inspect accepts an inspector function that has same arguments as the Service.RedisClient
func (mmRedisClient *mServiceMockRedisClient) Inspect(f func()) *mServiceMockRedisClient {
	if mmRedisClient.mock.inspectFuncRedisClient != nil {
		mmRedisClient.mock.t.Fatalf("Inspect function is already set for ServiceMock.RedisClient")
	}

	mmRedisClient.mock.inspectFuncRedisClient = f

	return mmRedisClient
}

// Return sets up results that will be returned by Service.RedisClient
func (mmRedisClient *mServiceMockRedisClient) Return(cp1 *redis.Client) *ServiceMock {
	if mmRedisClient.mock.funcRedisClient != nil {
		mmRedisClient.mock.t.Fatalf("ServiceMock.RedisClient mock is already set by Set")
	}

	if mmRedisClient.defaultExpectation == nil {
		mmRedisClient.defaultExpectation = &ServiceMockRedisClientExpectation{mock: mmRedisClient.mock}
	}
	mmRedisClient.defaultExpectation.results = &ServiceMockRedisClientResults{cp1}
	mmRedisClient.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRedisClient.mock
}

// Set uses given function f to mock the Service.RedisClient method
func (mmRedisClient *mServiceMockRedisClient) Set(f func() (cp1 *redis.Client)) *ServiceMock {
	if mmRedisClient.defaultExpectation != nil {
		mmRedisClient.mock.t.Fatalf("Default expectation is already set for the Service.RedisClient method")
	}

	if len(mmRedisClient.expectations) > 0 {
		mmRedisClient.mock.t.Fatalf("Some expectations are already set for the Service.RedisClient method")
	}

	mmRedisClient.mock.funcRedisClient = f
	mmRedisClient.mock.funcRedisClientOrigin = minimock.CallerInfo(1)
	return mmRedisClient.mock
}

// Times sets number of times Service.RedisClient should be invoked
func (mmRedisClient *mServiceMockRedisClient) Times(n uint64) *mServiceMockRedisClient {
	if n == 0 {
		mmRedisClient.mock.t.Fatalf("Times of ServiceMock.RedisClient mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRedisClient.expectedInvocations, n)
	mmRedisClient.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRedisClient
}

func (mmRedisClient *mServiceMockRedisClient) invocationsDone() bool {
	if len(mmRedisClient.expectations) == 0 && mmRedisClient.defaultExpectation == nil && mmRedisClient.mock.funcRedisClient == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRedisClient.mock.afterRedisClientCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRedisClient.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RedisClient implements mm_service.Service
func (mmRedisClient *ServiceMock) RedisClient() (cp1 *redis.Client) {
	mm_atomic.AddUint64(&mmRedisClient.beforeRedisClientCounter, 1)
	defer mm_atomic.AddUint64(&mmRedisClient.afterRedisClientCounter, 1)

	mmRedisClient.t.Helper()

	if mmRedisClient.inspectFuncRedisClient != nil {
		mmRedisClient.inspectFuncRedisClient()
	}

	if mmRedisClient.RedisClientMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRedisClient.RedisClientMock.defaultExpectation.Counter, 1)

		mm_results := mmRedisClient.RedisClientMock.defaultExpectation.results
		if mm_results == nil {
			mmRedisClient.t.Fatal("No results are set for the ServiceMock.RedisClient")
		}
		return (*mm_results).cp1
	}
	if mmRedisClient.funcRedisClient != nil {
		return mmRedisClient.funcRedisClient()
	}
	mmRedisClient.t.Fatalf("Unexpected call to ServiceMock.RedisClient.")
	return
}

// RedisClientAfterCounter returns a count of finished ServiceMock.RedisClient invocations
func (mmRedisClient *ServiceMock) RedisClientAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRedisClient.afterRedisClientCounter)
}

// RedisClientBeforeCounter returns a count of ServiceMock.RedisClient invocations
func (mmRedisClient *ServiceMock) RedisClientBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRedisClient.beforeRedisClientCounter)
}

// MinimockRedisClientDone returns true if the count of the RedisClient invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockRedisClientDone() bool {
	if m.RedisClientMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RedisClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RedisClientMock.invocationsDone()
}

// MinimockRedisClientInspect logs each unmet expectation
func (m *ServiceMock) MinimockRedisClientInspect() {
	for _, e := range m.RedisClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServiceMock.RedisClient")
		}
	}

	afterRedisClientCounter := mm_atomic.LoadUint64(&m.afterRedisClientCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RedisClientMock.defaultExpectation != nil && afterRedisClientCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.RedisClient at\n%s", m.RedisClientMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRedisClient != nil && afterRedisClientCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.RedisClient at\n%s", m.funcRedisClientOrigin)
	}

	if !m.RedisClientMock.invocationsDone() && afterRedisClientCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.RedisClient at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RedisClientMock.expectedInvocations), m.RedisClientMock.expectedInvocationsOrigin, afterRedisClientCounter)
	}
}

type mServiceMockRenameSystemAdmin struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockRenameSystemAdminExpectation
	expectations       []*ServiceMockRenameSystemAdminExpectation

	callArgs []*ServiceMockRenameSystemAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockRenameSystemAdminExpectation specifies expectation struct of the Service.RenameSystemAdmin
type ServiceMockRenameSystemAdminExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockRenameSystemAdminParams
	paramPtrs          *ServiceMockRenameSystemAdminParamPtrs
	expectationOrigins ServiceMockRenameSystemAdminExpectationOrigins
	results            *ServiceMockRenameSystemAdminResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockRenameSystemAdminParams contains parameters of the Service.RenameSystemAdmin
type ServiceMockRenameSystemAdminParams struct {
	ctx context.Context
	rp1 *artifactpb.RenameSystemAdminRequest
}

// ServiceMockRenameSystemAdminParamPtrs contains pointers to parameters of the Service.RenameSystemAdmin
type ServiceMockRenameSystemAdminParamPtrs struct {
	ctx *context.Context
	rp1 **artifactpb.RenameSystemAdminRequest
}

// ServiceMockRenameSystemAdminResults contains results of the Service.RenameSystemAdmin
type ServiceMockRenameSystemAdminResults struct {
	rp2 *artifactpb.RenameSystemAdminResponse
	err error
}

// ServiceMockRenameSystemAdminOrigins contains origins of expectations of the Service.RenameSystemAdmin
type ServiceMockRenameSystemAdminExpectationOrigins struct {
	origin    string
	originCtx string
	originRp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRenameSystemAdmin *mServiceMockRenameSystemAdmin) Optional() *mServiceMockRenameSystemAdmin {
	mmRenameSystemAdmin.optional = true
	return mmRenameSystemAdmin
}

// Expect sets up expected params for Service.RenameSystemAdmin
func (mmRenameSystemAdmin *mServiceMockRenameSystemAdmin) Expect(ctx context.Context, rp1 *artifactpb.RenameSystemAdminRequest) *mServiceMockRenameSystemAdmin {
	if mmRenameSystemAdmin.mock.funcRenameSystemAdmin != nil {
		mmRenameSystemAdmin.mock.t.Fatalf("ServiceMock.RenameSystemAdmin mock is already set by Set")
	}

	if mmRenameSystemAdmin.defaultExpectation == nil {
		mmRenameSystemAdmin.defaultExpectation = &ServiceMockRenameSystemAdminExpectation{}
	}

	if mmRenameSystemAdmin.defaultExpectation.paramPtrs != nil {
		mmRenameSystemAdmin.mock.t.Fatalf("ServiceMock.RenameSystemAdmin mock is already set by ExpectParams functions")
	}

	mmRenameSystemAdmin.defaultExpectation.params = &ServiceMockRenameSystemAdminParams{ctx, rp1}
	mmRenameSystemAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRenameSystemAdmin.expectations {
		if minimock.Equal(e.params, mmRenameSystemAdmin.defaultExpectation.params) {
			mmRenameSystemAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRenameSystemAdmin.defaultExpectation.params)
		}
	}

	return mmRenameSystemAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Service.RenameSystemAdmin
func (mmRenameSystemAdmin *mServiceMockRenameSystemAdmin) ExpectCtxParam1(ctx context.Context) *mServiceMockRenameSystemAdmin {
	if mmRenameSystemAdmin.mock.funcRenameSystemAdmin != nil {
		mmRenameSystemAdmin.mock.t.Fatalf("ServiceMock.RenameSystemAdmin mock is already set by Set")
	}

	if mmRenameSystemAdmin.defaultExpectation == nil {
		mmRenameSystemAdmin.defaultExpectation = &ServiceMockRenameSystemAdminExpectation{}
	}

	if mmRenameSystemAdmin.defaultExpectation.params != nil {
		mmRenameSystemAdmin.mock.t.Fatalf("ServiceMock.RenameSystemAdmin mock is already set by Expect")
	}

	if mmRenameSystemAdmin.defaultExpectation.paramPtrs == nil {
		mmRenameSystemAdmin.defaultExpectation.paramPtrs = &ServiceMockRenameSystemAdminParamPtrs{}
	}
	mmRenameSystemAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmRenameSystemAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRenameSystemAdmin
}

// ExpectRp1Param2 sets up expected param rp1 for Service.RenameSystemAdmin
func (mmRenameSystemAdmin *mServiceMockRenameSystemAdmin) ExpectRp1Param2(rp1 *artifactpb.RenameSystemAdminRequest) *mServiceMockRenameSystemAdmin {
	if mmRenameSystemAdmin.mock.funcRenameSystemAdmin != nil {
		mmRenameSystemAdmin.mock.t.Fatalf("ServiceMock.RenameSystemAdmin mock is already set by Set")
	}

	if mmRenameSystemAdmin.defaultExpectation == nil {
		mmRenameSystemAdmin.defaultExpectation = &ServiceMockRenameSystemAdminExpectation{}
	}

	if mmRenameSystemAdmin.defaultExpectation.params != nil {
		mmRenameSystemAdmin.mock.t.Fatalf("ServiceMock.RenameSystemAdmin mock is already set by Expect")
	}

	if mmRenameSystemAdmin.defaultExpectation.paramPtrs == nil {
		mmRenameSystemAdmin.defaultExpectation.paramPtrs = &ServiceMockRenameSystemAdminParamPtrs{}
	}
	mmRenameSystemAdmin.defaultExpectation.paramPtrs.rp1 = &rp1
	mmRenameSystemAdmin.defaultExpectation.expectationOrigins.originRp1 = minimock.CallerInfo(1)

	return mmRenameSystemAdmin
}

// Inspect accepts an inspector function that has same arguments as the Service.RenameSystemAdmin
func (mmRenameSystemAdmin *mServiceMockRenameSystemAdmin) Inspect(f func(ctx context.Context, rp1 *artifactpb.RenameSystemAdminRequest)) *mServiceMockRenameSystemAdmin {
	if mmRenameSystemAdmin.mock.inspectFuncRenameSystemAdmin != nil {
		mmRenameSystemAdmin.mock.t.Fatalf("Inspect function is already set for ServiceMock.RenameSystemAdmin")
	}

	mmRenameSystemAdmin.mock.inspectFuncRenameSystemAdmin = f

	return mmRenameSystemAdmin
}

// Return sets up results that will be returned by Service.RenameSystemAdmin
func (mmRenameSystemAdmin *mServiceMockRenameSystemAdmin) Return(rp2 *artifactpb.RenameSystemAdminResponse, err error) *ServiceMock {
	if mmRenameSystemAdmin.mock.funcRenameSystemAdmin != nil {
		mmRenameSystemAdmin.mock.t.Fatalf("ServiceMock.RenameSystemAdmin mock is already set by Set")
	}

	if mmRenameSystemAdmin.defaultExpectation == nil {
		mmRenameSystemAdmin.defaultExpectation = &ServiceMockRenameSystemAdminExpectation{mock: mmRenameSystemAdmin.mock}
	}
	mmRenameSystemAdmin.defaultExpectation.results = &ServiceMockRenameSystemAdminResults{rp2, err}
	mmRenameSystemAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRenameSystemAdmin.mock
}

// Set uses given function f to mock the Service.RenameSystemAdmin method
func (mmRenameSystemAdmin *mServiceMockRenameSystemAdmin) Set(f func(ctx context.Context, rp1 *artifactpb.RenameSystemAdminRequest) (rp2 *artifactpb.RenameSystemAdminResponse, err error)) *ServiceMock {
	if mmRenameSystemAdmin.defaultExpectation != nil {
		mmRenameSystemAdmin.mock.t.Fatalf("Default expectation is already set for the Service.RenameSystemAdmin method")
	}

	if len(mmRenameSystemAdmin.expectations) > 0 {
		mmRenameSystemAdmin.mock.t.Fatalf("Some expectations are already set for the Service.RenameSystemAdmin method")
	}

	mmRenameSystemAdmin.mock.funcRenameSystemAdmin = f
	mmRenameSystemAdmin.mock.funcRenameSystemAdminOrigin = minimock.CallerInfo(1)
	return mmRenameSystemAdmin.mock
}

// When sets expectation for the Service.RenameSystemAdmin which will trigger the result defined by the following
// Then helper
func (mmRenameSystemAdmin *mServiceMockRenameSystemAdmin) When(ctx context.Context, rp1 *artifactpb.RenameSystemAdminRequest) *ServiceMockRenameSystemAdminExpectation {
	if mmRenameSystemAdmin.mock.funcRenameSystemAdmin != nil {
		mmRenameSystemAdmin.mock.t.Fatalf("ServiceMock.RenameSystemAdmin mock is already set by Set")
	}

	expectation := &ServiceMockRenameSystemAdminExpectation{
		mock:               mmRenameSystemAdmin.mock,
		params:             &ServiceMockRenameSystemAdminParams{ctx, rp1},
		expectationOrigins: ServiceMockRenameSystemAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRenameSystemAdmin.expectations = append(mmRenameSystemAdmin.expectations, expectation)
	return expectation
}

// Then sets up Service.RenameSystemAdmin return parameters for the expectation previously defined by the When method
func (e *ServiceMockRenameSystemAdminExpectation) Then(rp2 *artifactpb.RenameSystemAdminResponse, err error) *ServiceMock {
	e.results = &ServiceMockRenameSystemAdminResults{rp2, err}
	return e.mock
}

// Times sets number of times Service.RenameSystemAdmin should be invoked
func (mmRenameSystemAdmin *mServiceMockRenameSystemAdmin) Times(n uint64) *mServiceMockRenameSystemAdmin {
	if n == 0 {
		mmRenameSystemAdmin.mock.t.Fatalf("Times of ServiceMock.RenameSystemAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRenameSystemAdmin.expectedInvocations, n)
	mmRenameSystemAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRenameSystemAdmin
}

func (mmRenameSystemAdmin *mServiceMockRenameSystemAdmin) invocationsDone() bool {
	if len(mmRenameSystemAdmin.expectations) == 0 && mmRenameSystemAdmin.defaultExpectation == nil && mmRenameSystemAdmin.mock.funcRenameSystemAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRenameSystemAdmin.mock.afterRenameSystemAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRenameSystemAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RenameSystemAdmin implements mm_service.Service
func (mmRenameSystemAdmin *ServiceMock) RenameSystemAdmin(ctx context.Context, rp1 *artifactpb.RenameSystemAdminRequest) (rp2 *artifactpb.RenameSystemAdminResponse, err error) {
	mm_atomic.AddUint64(&mmRenameSystemAdmin.beforeRenameSystemAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmRenameSystemAdmin.afterRenameSystemAdminCounter, 1)

	mmRenameSystemAdmin.t.Helper()

	if mmRenameSystemAdmin.inspectFuncRenameSystemAdmin != nil {
		mmRenameSystemAdmin.inspectFuncRenameSystemAdmin(ctx, rp1)
	}

	mm_params := ServiceMockRenameSystemAdminParams{ctx, rp1}

	// Record call args
	mmRenameSystemAdmin.RenameSystemAdminMock.mutex.Lock()
	mmRenameSystemAdmin.RenameSystemAdminMock.callArgs = append(mmRenameSystemAdmin.RenameSystemAdminMock.callArgs, &mm_params)
	mmRenameSystemAdmin.RenameSystemAdminMock.mutex.Unlock()

	for _, e := range mmRenameSystemAdmin.RenameSystemAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp2, e.results.err
		}
	}

	if mmRenameSystemAdmin.RenameSystemAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRenameSystemAdmin.RenameSystemAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmRenameSystemAdmin.RenameSystemAdminMock.defaultExpectation.params
		mm_want_ptrs := mmRenameSystemAdmin.RenameSystemAdminMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockRenameSystemAdminParams{ctx, rp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRenameSystemAdmin.t.Errorf("ServiceMock.RenameSystemAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRenameSystemAdmin.RenameSystemAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.rp1 != nil && !minimock.Equal(*mm_want_ptrs.rp1, mm_got.rp1) {
				mmRenameSystemAdmin.t.Errorf("ServiceMock.RenameSystemAdmin got unexpected parameter rp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRenameSystemAdmin.RenameSystemAdminMock.defaultExpectation.expectationOrigins.originRp1, *mm_want_ptrs.rp1, mm_got.rp1, minimock.Diff(*mm_want_ptrs.rp1, mm_got.rp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRenameSystemAdmin.t.Errorf("ServiceMock.RenameSystemAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRenameSystemAdmin.RenameSystemAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRenameSystemAdmin.RenameSystemAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmRenameSystemAdmin.t.Fatal("No results are set for the ServiceMock.RenameSystemAdmin")
		}
		return (*mm_results).rp2, (*mm_results).err
	}
	if mmRenameSystemAdmin.funcRenameSystemAdmin != nil {
		return mmRenameSystemAdmin.funcRenameSystemAdmin(ctx, rp1)
	}
	mmRenameSystemAdmin.t.Fatalf("Unexpected call to ServiceMock.RenameSystemAdmin. %v %v", ctx, rp1)
	return
}

// RenameSystemAdminAfterCounter returns a count of finished ServiceMock.RenameSystemAdmin invocations
func (mmRenameSystemAdmin *ServiceMock) RenameSystemAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRenameSystemAdmin.afterRenameSystemAdminCounter)
}

// RenameSystemAdminBeforeCounter returns a count of ServiceMock.RenameSystemAdmin invocations
func (mmRenameSystemAdmin *ServiceMock) RenameSystemAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRenameSystemAdmin.beforeRenameSystemAdminCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.RenameSystemAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRenameSystemAdmin *mServiceMockRenameSystemAdmin) Calls() []*ServiceMockRenameSystemAdminParams {
	mmRenameSystemAdmin.mutex.RLock()

	argCopy := make([]*ServiceMockRenameSystemAdminParams, len(mmRenameSystemAdmin.callArgs))
	copy(argCopy, mmRenameSystemAdmin.callArgs)

	mmRenameSystemAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockRenameSystemAdminDone returns true if the count of the RenameSystemAdmin invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockRenameSystemAdminDone() bool {
	if m.RenameSystemAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RenameSystemAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RenameSystemAdminMock.invocationsDone()
}

// MinimockRenameSystemAdminInspect logs each unmet expectation
func (m *ServiceMock) MinimockRenameSystemAdminInspect() {
	for _, e := range m.RenameSystemAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.RenameSystemAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRenameSystemAdminCounter := mm_atomic.LoadUint64(&m.afterRenameSystemAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RenameSystemAdminMock.defaultExpectation != nil && afterRenameSystemAdminCounter < 1 {
		if m.RenameSystemAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.RenameSystemAdmin at\n%s", m.RenameSystemAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.RenameSystemAdmin at\n%s with params: %#v", m.RenameSystemAdminMock.defaultExpectation.expectationOrigins.origin, *m.RenameSystemAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRenameSystemAdmin != nil && afterRenameSystemAdminCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.RenameSystemAdmin at\n%s", m.funcRenameSystemAdminOrigin)
	}

	if !m.RenameSystemAdminMock.invocationsDone() && afterRenameSystemAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.RenameSystemAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RenameSystemAdminMock.expectedInvocations), m.RenameSystemAdminMock.expectedInvocationsOrigin, afterRenameSystemAdminCounter)
	}
}

type mServiceMockRepository struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockRepositoryExpectation
	expectations       []*ServiceMockRepositoryExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockRepositoryExpectation specifies expectation struct of the Service.Repository
type ServiceMockRepositoryExpectation struct {
	mock *ServiceMock

	results      *ServiceMockRepositoryResults
	returnOrigin string
	Counter      uint64
}

// ServiceMockRepositoryResults contains results of the Service.Repository
type ServiceMockRepositoryResults struct {
	r1 repository.Repository
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRepository *mServiceMockRepository) Optional() *mServiceMockRepository {
	mmRepository.optional = true
	return mmRepository
}

// Expect sets up expected params for Service.Repository
func (mmRepository *mServiceMockRepository) Expect() *mServiceMockRepository {
	if mmRepository.mock.funcRepository != nil {
		mmRepository.mock.t.Fatalf("ServiceMock.Repository mock is already set by Set")
	}

	if mmRepository.defaultExpectation == nil {
		mmRepository.defaultExpectation = &ServiceMockRepositoryExpectation{}
	}

	return mmRepository
}

// Inspect accepts an inspector function that has same arguments as the Service.Repository
func (mmRepository *mServiceMockRepository) Inspect(f func()) *mServiceMockRepository {
	if mmRepository.mock.inspectFuncRepository != nil {
		mmRepository.mock.t.Fatalf("Inspect function is already set for ServiceMock.Repository")
	}

	mmRepository.mock.inspectFuncRepository = f

	return mmRepository
}

// Return sets up results that will be returned by Service.Repository
func (mmRepository *mServiceMockRepository) Return(r1 repository.Repository) *ServiceMock {
	if mmRepository.mock.funcRepository != nil {
		mmRepository.mock.t.Fatalf("ServiceMock.Repository mock is already set by Set")
	}

	if mmRepository.defaultExpectation == nil {
		mmRepository.defaultExpectation = &ServiceMockRepositoryExpectation{mock: mmRepository.mock}
	}
	mmRepository.defaultExpectation.results = &ServiceMockRepositoryResults{r1}
	mmRepository.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRepository.mock
}

// Set uses given function f to mock the Service.Repository method
func (mmRepository *mServiceMockRepository) Set(f func() (r1 repository.Repository)) *ServiceMock {
	if mmRepository.defaultExpectation != nil {
		mmRepository.mock.t.Fatalf("Default expectation is already set for the Service.Repository method")
	}

	if len(mmRepository.expectations) > 0 {
		mmRepository.mock.t.Fatalf("Some expectations are already set for the Service.Repository method")
	}

	mmRepository.mock.funcRepository = f
	mmRepository.mock.funcRepositoryOrigin = minimock.CallerInfo(1)
	return mmRepository.mock
}

// Times sets number of times Service.Repository should be invoked
func (mmRepository *mServiceMockRepository) Times(n uint64) *mServiceMockRepository {
	if n == 0 {
		mmRepository.mock.t.Fatalf("Times of ServiceMock.Repository mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRepository.expectedInvocations, n)
	mmRepository.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRepository
}

func (mmRepository *mServiceMockRepository) invocationsDone() bool {
	if len(mmRepository.expectations) == 0 && mmRepository.defaultExpectation == nil && mmRepository.mock.funcRepository == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRepository.mock.afterRepositoryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRepository.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Repository implements mm_service.Service
func (mmRepository *ServiceMock) Repository() (r1 repository.Repository) {
	mm_atomic.AddUint64(&mmRepository.beforeRepositoryCounter, 1)
	defer mm_atomic.AddUint64(&mmRepository.afterRepositoryCounter, 1)

	mmRepository.t.Helper()

	if mmRepository.inspectFuncRepository != nil {
		mmRepository.inspectFuncRepository()
	}

	if mmRepository.RepositoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRepository.RepositoryMock.defaultExpectation.Counter, 1)

		mm_results := mmRepository.RepositoryMock.defaultExpectation.results
		if mm_results == nil {
			mmRepository.t.Fatal("No results are set for the ServiceMock.Repository")
		}
		return (*mm_results).r1
	}
	if mmRepository.funcRepository != nil {
		return mmRepository.funcRepository()
	}
	mmRepository.t.Fatalf("Unexpected call to ServiceMock.Repository.")
	return
}

// RepositoryAfterCounter returns a count of finished ServiceMock.Repository invocations
func (mmRepository *ServiceMock) RepositoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRepository.afterRepositoryCounter)
}

// RepositoryBeforeCounter returns a count of ServiceMock.Repository invocations
func (mmRepository *ServiceMock) RepositoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRepository.beforeRepositoryCounter)
}

// MinimockRepositoryDone returns true if the count of the Repository invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockRepositoryDone() bool {
	if m.RepositoryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RepositoryMock.invocationsDone()
}

// MinimockRepositoryInspect logs each unmet expectation
func (m *ServiceMock) MinimockRepositoryInspect() {
	for _, e := range m.RepositoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServiceMock.Repository")
		}
	}

	afterRepositoryCounter := mm_atomic.LoadUint64(&m.afterRepositoryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RepositoryMock.defaultExpectation != nil && afterRepositoryCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.Repository at\n%s", m.RepositoryMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRepository != nil && afterRepositoryCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.Repository at\n%s", m.funcRepositoryOrigin)
	}

	if !m.RepositoryMock.invocationsDone() && afterRepositoryCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.Repository at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RepositoryMock.expectedInvocations), m.RepositoryMock.expectedInvocationsOrigin, afterRepositoryCounter)
	}
}

type mServiceMockRollbackAdmin struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockRollbackAdminExpectation
	expectations       []*ServiceMockRollbackAdminExpectation

	callArgs []*ServiceMockRollbackAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockRollbackAdminExpectation specifies expectation struct of the Service.RollbackAdmin
type ServiceMockRollbackAdminExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockRollbackAdminParams
	paramPtrs          *ServiceMockRollbackAdminParamPtrs
	expectationOrigins ServiceMockRollbackAdminExpectationOrigins
	results            *ServiceMockRollbackAdminResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockRollbackAdminParams contains parameters of the Service.RollbackAdmin
type ServiceMockRollbackAdminParams struct {
	ctx context.Context
	o1  types.OwnerUIDType
	s1  string
}

// ServiceMockRollbackAdminParamPtrs contains pointers to parameters of the Service.RollbackAdmin
type ServiceMockRollbackAdminParamPtrs struct {
	ctx *context.Context
	o1  *types.OwnerUIDType
	s1  *string
}

// ServiceMockRollbackAdminResults contains results of the Service.RollbackAdmin
type ServiceMockRollbackAdminResults struct {
	rp1 *artifactpb.RollbackAdminResponse
	err error
}

// ServiceMockRollbackAdminOrigins contains origins of expectations of the Service.RollbackAdmin
type ServiceMockRollbackAdminExpectationOrigins struct {
	origin    string
	originCtx string
	originO1  string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRollbackAdmin *mServiceMockRollbackAdmin) Optional() *mServiceMockRollbackAdmin {
	mmRollbackAdmin.optional = true
	return mmRollbackAdmin
}

// Expect sets up expected params for Service.RollbackAdmin
func (mmRollbackAdmin *mServiceMockRollbackAdmin) Expect(ctx context.Context, o1 types.OwnerUIDType, s1 string) *mServiceMockRollbackAdmin {
	if mmRollbackAdmin.mock.funcRollbackAdmin != nil {
		mmRollbackAdmin.mock.t.Fatalf("ServiceMock.RollbackAdmin mock is already set by Set")
	}

	if mmRollbackAdmin.defaultExpectation == nil {
		mmRollbackAdmin.defaultExpectation = &ServiceMockRollbackAdminExpectation{}
	}

	if mmRollbackAdmin.defaultExpectation.paramPtrs != nil {
		mmRollbackAdmin.mock.t.Fatalf("ServiceMock.RollbackAdmin mock is already set by ExpectParams functions")
	}

	mmRollbackAdmin.defaultExpectation.params = &ServiceMockRollbackAdminParams{ctx, o1, s1}
	mmRollbackAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRollbackAdmin.expectations {
		if minimock.Equal(e.params, mmRollbackAdmin.defaultExpectation.params) {
			mmRollbackAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRollbackAdmin.defaultExpectation.params)
		}
	}

	return mmRollbackAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Service.RollbackAdmin
func (mmRollbackAdmin *mServiceMockRollbackAdmin) ExpectCtxParam1(ctx context.Context) *mServiceMockRollbackAdmin {
	if mmRollbackAdmin.mock.funcRollbackAdmin != nil {
		mmRollbackAdmin.mock.t.Fatalf("ServiceMock.RollbackAdmin mock is already set by Set")
	}

	if mmRollbackAdmin.defaultExpectation == nil {
		mmRollbackAdmin.defaultExpectation = &ServiceMockRollbackAdminExpectation{}
	}

	if mmRollbackAdmin.defaultExpectation.params != nil {
		mmRollbackAdmin.mock.t.Fatalf("ServiceMock.RollbackAdmin mock is already set by Expect")
	}

	if mmRollbackAdmin.defaultExpectation.paramPtrs == nil {
		mmRollbackAdmin.defaultExpectation.paramPtrs = &ServiceMockRollbackAdminParamPtrs{}
	}
	mmRollbackAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmRollbackAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRollbackAdmin
}

// ExpectO1Param2 sets up expected param o1 for Service.RollbackAdmin
func (mmRollbackAdmin *mServiceMockRollbackAdmin) ExpectO1Param2(o1 types.OwnerUIDType) *mServiceMockRollbackAdmin {
	if mmRollbackAdmin.mock.funcRollbackAdmin != nil {
		mmRollbackAdmin.mock.t.Fatalf("ServiceMock.RollbackAdmin mock is already set by Set")
	}

	if mmRollbackAdmin.defaultExpectation == nil {
		mmRollbackAdmin.defaultExpectation = &ServiceMockRollbackAdminExpectation{}
	}

	if mmRollbackAdmin.defaultExpectation.params != nil {
		mmRollbackAdmin.mock.t.Fatalf("ServiceMock.RollbackAdmin mock is already set by Expect")
	}

	if mmRollbackAdmin.defaultExpectation.paramPtrs == nil {
		mmRollbackAdmin.defaultExpectation.paramPtrs = &ServiceMockRollbackAdminParamPtrs{}
	}
	mmRollbackAdmin.defaultExpectation.paramPtrs.o1 = &o1
	mmRollbackAdmin.defaultExpectation.expectationOrigins.originO1 = minimock.CallerInfo(1)

	return mmRollbackAdmin
}

// ExpectS1Param3 sets up expected param s1 for Service.RollbackAdmin
func (mmRollbackAdmin *mServiceMockRollbackAdmin) ExpectS1Param3(s1 string) *mServiceMockRollbackAdmin {
	if mmRollbackAdmin.mock.funcRollbackAdmin != nil {
		mmRollbackAdmin.mock.t.Fatalf("ServiceMock.RollbackAdmin mock is already set by Set")
	}

	if mmRollbackAdmin.defaultExpectation == nil {
		mmRollbackAdmin.defaultExpectation = &ServiceMockRollbackAdminExpectation{}
	}

	if mmRollbackAdmin.defaultExpectation.params != nil {
		mmRollbackAdmin.mock.t.Fatalf("ServiceMock.RollbackAdmin mock is already set by Expect")
	}

	if mmRollbackAdmin.defaultExpectation.paramPtrs == nil {
		mmRollbackAdmin.defaultExpectation.paramPtrs = &ServiceMockRollbackAdminParamPtrs{}
	}
	mmRollbackAdmin.defaultExpectation.paramPtrs.s1 = &s1
	mmRollbackAdmin.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmRollbackAdmin
}

// Inspect accepts an inspector function that has same arguments as the Service.RollbackAdmin
func (mmRollbackAdmin *mServiceMockRollbackAdmin) Inspect(f func(ctx context.Context, o1 types.OwnerUIDType, s1 string)) *mServiceMockRollbackAdmin {
	if mmRollbackAdmin.mock.inspectFuncRollbackAdmin != nil {
		mmRollbackAdmin.mock.t.Fatalf("Inspect function is already set for ServiceMock.RollbackAdmin")
	}

	mmRollbackAdmin.mock.inspectFuncRollbackAdmin = f

	return mmRollbackAdmin
}

// Return sets up results that will be returned by Service.RollbackAdmin
func (mmRollbackAdmin *mServiceMockRollbackAdmin) Return(rp1 *artifactpb.RollbackAdminResponse, err error) *ServiceMock {
	if mmRollbackAdmin.mock.funcRollbackAdmin != nil {
		mmRollbackAdmin.mock.t.Fatalf("ServiceMock.RollbackAdmin mock is already set by Set")
	}

	if mmRollbackAdmin.defaultExpectation == nil {
		mmRollbackAdmin.defaultExpectation = &ServiceMockRollbackAdminExpectation{mock: mmRollbackAdmin.mock}
	}
	mmRollbackAdmin.defaultExpectation.results = &ServiceMockRollbackAdminResults{rp1, err}
	mmRollbackAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRollbackAdmin.mock
}

// Set uses given function f to mock the Service.RollbackAdmin method
func (mmRollbackAdmin *mServiceMockRollbackAdmin) Set(f func(ctx context.Context, o1 types.OwnerUIDType, s1 string) (rp1 *artifactpb.RollbackAdminResponse, err error)) *ServiceMock {
	if mmRollbackAdmin.defaultExpectation != nil {
		mmRollbackAdmin.mock.t.Fatalf("Default expectation is already set for the Service.RollbackAdmin method")
	}

	if len(mmRollbackAdmin.expectations) > 0 {
		mmRollbackAdmin.mock.t.Fatalf("Some expectations are already set for the Service.RollbackAdmin method")
	}

	mmRollbackAdmin.mock.funcRollbackAdmin = f
	mmRollbackAdmin.mock.funcRollbackAdminOrigin = minimock.CallerInfo(1)
	return mmRollbackAdmin.mock
}

// When sets expectation for the Service.RollbackAdmin which will trigger the result defined by the following
// Then helper
func (mmRollbackAdmin *mServiceMockRollbackAdmin) When(ctx context.Context, o1 types.OwnerUIDType, s1 string) *ServiceMockRollbackAdminExpectation {
	if mmRollbackAdmin.mock.funcRollbackAdmin != nil {
		mmRollbackAdmin.mock.t.Fatalf("ServiceMock.RollbackAdmin mock is already set by Set")
	}

	expectation := &ServiceMockRollbackAdminExpectation{
		mock:               mmRollbackAdmin.mock,
		params:             &ServiceMockRollbackAdminParams{ctx, o1, s1},
		expectationOrigins: ServiceMockRollbackAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRollbackAdmin.expectations = append(mmRollbackAdmin.expectations, expectation)
	return expectation
}

// Then sets up Service.RollbackAdmin return parameters for the expectation previously defined by the When method
func (e *ServiceMockRollbackAdminExpectation) Then(rp1 *artifactpb.RollbackAdminResponse, err error) *ServiceMock {
	e.results = &ServiceMockRollbackAdminResults{rp1, err}
	return e.mock
}

// Times sets number of times Service.RollbackAdmin should be invoked
func (mmRollbackAdmin *mServiceMockRollbackAdmin) Times(n uint64) *mServiceMockRollbackAdmin {
	if n == 0 {
		mmRollbackAdmin.mock.t.Fatalf("Times of ServiceMock.RollbackAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRollbackAdmin.expectedInvocations, n)
	mmRollbackAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRollbackAdmin
}

func (mmRollbackAdmin *mServiceMockRollbackAdmin) invocationsDone() bool {
	if len(mmRollbackAdmin.expectations) == 0 && mmRollbackAdmin.defaultExpectation == nil && mmRollbackAdmin.mock.funcRollbackAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRollbackAdmin.mock.afterRollbackAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRollbackAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RollbackAdmin implements mm_service.Service
func (mmRollbackAdmin *ServiceMock) RollbackAdmin(ctx context.Context, o1 types.OwnerUIDType, s1 string) (rp1 *artifactpb.RollbackAdminResponse, err error) {
	mm_atomic.AddUint64(&mmRollbackAdmin.beforeRollbackAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmRollbackAdmin.afterRollbackAdminCounter, 1)

	mmRollbackAdmin.t.Helper()

	if mmRollbackAdmin.inspectFuncRollbackAdmin != nil {
		mmRollbackAdmin.inspectFuncRollbackAdmin(ctx, o1, s1)
	}

	mm_params := ServiceMockRollbackAdminParams{ctx, o1, s1}

	// Record call args
	mmRollbackAdmin.RollbackAdminMock.mutex.Lock()
	mmRollbackAdmin.RollbackAdminMock.callArgs = append(mmRollbackAdmin.RollbackAdminMock.callArgs, &mm_params)
	mmRollbackAdmin.RollbackAdminMock.mutex.Unlock()

	for _, e := range mmRollbackAdmin.RollbackAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmRollbackAdmin.RollbackAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRollbackAdmin.RollbackAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmRollbackAdmin.RollbackAdminMock.defaultExpectation.params
		mm_want_ptrs := mmRollbackAdmin.RollbackAdminMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockRollbackAdminParams{ctx, o1, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRollbackAdmin.t.Errorf("ServiceMock.RollbackAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRollbackAdmin.RollbackAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.o1 != nil && !minimock.Equal(*mm_want_ptrs.o1, mm_got.o1) {
				mmRollbackAdmin.t.Errorf("ServiceMock.RollbackAdmin got unexpected parameter o1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRollbackAdmin.RollbackAdminMock.defaultExpectation.expectationOrigins.originO1, *mm_want_ptrs.o1, mm_got.o1, minimock.Diff(*mm_want_ptrs.o1, mm_got.o1))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmRollbackAdmin.t.Errorf("ServiceMock.RollbackAdmin got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRollbackAdmin.RollbackAdminMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRollbackAdmin.t.Errorf("ServiceMock.RollbackAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRollbackAdmin.RollbackAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRollbackAdmin.RollbackAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmRollbackAdmin.t.Fatal("No results are set for the ServiceMock.RollbackAdmin")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmRollbackAdmin.funcRollbackAdmin != nil {
		return mmRollbackAdmin.funcRollbackAdmin(ctx, o1, s1)
	}
	mmRollbackAdmin.t.Fatalf("Unexpected call to ServiceMock.RollbackAdmin. %v %v %v", ctx, o1, s1)
	return
}

// RollbackAdminAfterCounter returns a count of finished ServiceMock.RollbackAdmin invocations
func (mmRollbackAdmin *ServiceMock) RollbackAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRollbackAdmin.afterRollbackAdminCounter)
}

// RollbackAdminBeforeCounter returns a count of ServiceMock.RollbackAdmin invocations
func (mmRollbackAdmin *ServiceMock) RollbackAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRollbackAdmin.beforeRollbackAdminCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.RollbackAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRollbackAdmin *mServiceMockRollbackAdmin) Calls() []*ServiceMockRollbackAdminParams {
	mmRollbackAdmin.mutex.RLock()

	argCopy := make([]*ServiceMockRollbackAdminParams, len(mmRollbackAdmin.callArgs))
	copy(argCopy, mmRollbackAdmin.callArgs)

	mmRollbackAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockRollbackAdminDone returns true if the count of the RollbackAdmin invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockRollbackAdminDone() bool {
	if m.RollbackAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RollbackAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RollbackAdminMock.invocationsDone()
}

// MinimockRollbackAdminInspect logs each unmet expectation
func (m *ServiceMock) MinimockRollbackAdminInspect() {
	for _, e := range m.RollbackAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.RollbackAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRollbackAdminCounter := mm_atomic.LoadUint64(&m.afterRollbackAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RollbackAdminMock.defaultExpectation != nil && afterRollbackAdminCounter < 1 {
		if m.RollbackAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.RollbackAdmin at\n%s", m.RollbackAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.RollbackAdmin at\n%s with params: %#v", m.RollbackAdminMock.defaultExpectation.expectationOrigins.origin, *m.RollbackAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRollbackAdmin != nil && afterRollbackAdminCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.RollbackAdmin at\n%s", m.funcRollbackAdminOrigin)
	}

	if !m.RollbackAdminMock.invocationsDone() && afterRollbackAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.RollbackAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RollbackAdminMock.expectedInvocations), m.RollbackAdminMock.expectedInvocationsOrigin, afterRollbackAdminCounter)
	}
}

type mServiceMockSetDefaultSystemAdmin struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockSetDefaultSystemAdminExpectation
	expectations       []*ServiceMockSetDefaultSystemAdminExpectation

	callArgs []*ServiceMockSetDefaultSystemAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockSetDefaultSystemAdminExpectation specifies expectation struct of the Service.SetDefaultSystemAdmin
type ServiceMockSetDefaultSystemAdminExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockSetDefaultSystemAdminParams
	paramPtrs          *ServiceMockSetDefaultSystemAdminParamPtrs
	expectationOrigins ServiceMockSetDefaultSystemAdminExpectationOrigins
	results            *ServiceMockSetDefaultSystemAdminResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockSetDefaultSystemAdminParams contains parameters of the Service.SetDefaultSystemAdmin
type ServiceMockSetDefaultSystemAdminParams struct {
	ctx context.Context
	sp1 *artifactpb.SetDefaultSystemAdminRequest
}

// ServiceMockSetDefaultSystemAdminParamPtrs contains pointers to parameters of the Service.SetDefaultSystemAdmin
type ServiceMockSetDefaultSystemAdminParamPtrs struct {
	ctx *context.Context
	sp1 **artifactpb.SetDefaultSystemAdminRequest
}

// ServiceMockSetDefaultSystemAdminResults contains results of the Service.SetDefaultSystemAdmin
type ServiceMockSetDefaultSystemAdminResults struct {
	sp2 *artifactpb.SetDefaultSystemAdminResponse
	err error
}

// ServiceMockSetDefaultSystemAdminOrigins contains origins of expectations of the Service.SetDefaultSystemAdmin
type ServiceMockSetDefaultSystemAdminExpectationOrigins struct {
	origin    string
	originCtx string
	originSp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetDefaultSystemAdmin *mServiceMockSetDefaultSystemAdmin) Optional() *mServiceMockSetDefaultSystemAdmin {
	mmSetDefaultSystemAdmin.optional = true
	return mmSetDefaultSystemAdmin
}

// Expect sets up expected params for Service.SetDefaultSystemAdmin
func (mmSetDefaultSystemAdmin *mServiceMockSetDefaultSystemAdmin) Expect(ctx context.Context, sp1 *artifactpb.SetDefaultSystemAdminRequest) *mServiceMockSetDefaultSystemAdmin {
	if mmSetDefaultSystemAdmin.mock.funcSetDefaultSystemAdmin != nil {
		mmSetDefaultSystemAdmin.mock.t.Fatalf("ServiceMock.SetDefaultSystemAdmin mock is already set by Set")
	}

	if mmSetDefaultSystemAdmin.defaultExpectation == nil {
		mmSetDefaultSystemAdmin.defaultExpectation = &ServiceMockSetDefaultSystemAdminExpectation{}
	}

	if mmSetDefaultSystemAdmin.defaultExpectation.paramPtrs != nil {
		mmSetDefaultSystemAdmin.mock.t.Fatalf("ServiceMock.SetDefaultSystemAdmin mock is already set by ExpectParams functions")
	}

	mmSetDefaultSystemAdmin.defaultExpectation.params = &ServiceMockSetDefaultSystemAdminParams{ctx, sp1}
	mmSetDefaultSystemAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetDefaultSystemAdmin.expectations {
		if minimock.Equal(e.params, mmSetDefaultSystemAdmin.defaultExpectation.params) {
			mmSetDefaultSystemAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetDefaultSystemAdmin.defaultExpectation.params)
		}
	}

	return mmSetDefaultSystemAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Service.SetDefaultSystemAdmin
func (mmSetDefaultSystemAdmin *mServiceMockSetDefaultSystemAdmin) ExpectCtxParam1(ctx context.Context) *mServiceMockSetDefaultSystemAdmin {
	if mmSetDefaultSystemAdmin.mock.funcSetDefaultSystemAdmin != nil {
		mmSetDefaultSystemAdmin.mock.t.Fatalf("ServiceMock.SetDefaultSystemAdmin mock is already set by Set")
	}

	if mmSetDefaultSystemAdmin.defaultExpectation == nil {
		mmSetDefaultSystemAdmin.defaultExpectation = &ServiceMockSetDefaultSystemAdminExpectation{}
	}

	if mmSetDefaultSystemAdmin.defaultExpectation.params != nil {
		mmSetDefaultSystemAdmin.mock.t.Fatalf("ServiceMock.SetDefaultSystemAdmin mock is already set by Expect")
	}

	if mmSetDefaultSystemAdmin.defaultExpectation.paramPtrs == nil {
		mmSetDefaultSystemAdmin.defaultExpectation.paramPtrs = &ServiceMockSetDefaultSystemAdminParamPtrs{}
	}
	mmSetDefaultSystemAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetDefaultSystemAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetDefaultSystemAdmin
}

// ExpectSp1Param2 sets up expected param sp1 for Service.SetDefaultSystemAdmin
func (mmSetDefaultSystemAdmin *mServiceMockSetDefaultSystemAdmin) ExpectSp1Param2(sp1 *artifactpb.SetDefaultSystemAdminRequest) *mServiceMockSetDefaultSystemAdmin {
	if mmSetDefaultSystemAdmin.mock.funcSetDefaultSystemAdmin != nil {
		mmSetDefaultSystemAdmin.mock.t.Fatalf("ServiceMock.SetDefaultSystemAdmin mock is already set by Set")
	}

	if mmSetDefaultSystemAdmin.defaultExpectation == nil {
		mmSetDefaultSystemAdmin.defaultExpectation = &ServiceMockSetDefaultSystemAdminExpectation{}
	}

	if mmSetDefaultSystemAdmin.defaultExpectation.params != nil {
		mmSetDefaultSystemAdmin.mock.t.Fatalf("ServiceMock.SetDefaultSystemAdmin mock is already set by Expect")
	}

	if mmSetDefaultSystemAdmin.defaultExpectation.paramPtrs == nil {
		mmSetDefaultSystemAdmin.defaultExpectation.paramPtrs = &ServiceMockSetDefaultSystemAdminParamPtrs{}
	}
	mmSetDefaultSystemAdmin.defaultExpectation.paramPtrs.sp1 = &sp1
	mmSetDefaultSystemAdmin.defaultExpectation.expectationOrigins.originSp1 = minimock.CallerInfo(1)

	return mmSetDefaultSystemAdmin
}

// Inspect accepts an inspector function that has same arguments as the Service.SetDefaultSystemAdmin
func (mmSetDefaultSystemAdmin *mServiceMockSetDefaultSystemAdmin) Inspect(f func(ctx context.Context, sp1 *artifactpb.SetDefaultSystemAdminRequest)) *mServiceMockSetDefaultSystemAdmin {
	if mmSetDefaultSystemAdmin.mock.inspectFuncSetDefaultSystemAdmin != nil {
		mmSetDefaultSystemAdmin.mock.t.Fatalf("Inspect function is already set for ServiceMock.SetDefaultSystemAdmin")
	}

	mmSetDefaultSystemAdmin.mock.inspectFuncSetDefaultSystemAdmin = f

	return mmSetDefaultSystemAdmin
}

// Return sets up results that will be returned by Service.SetDefaultSystemAdmin
func (mmSetDefaultSystemAdmin *mServiceMockSetDefaultSystemAdmin) Return(sp2 *artifactpb.SetDefaultSystemAdminResponse, err error) *ServiceMock {
	if mmSetDefaultSystemAdmin.mock.funcSetDefaultSystemAdmin != nil {
		mmSetDefaultSystemAdmin.mock.t.Fatalf("ServiceMock.SetDefaultSystemAdmin mock is already set by Set")
	}

	if mmSetDefaultSystemAdmin.defaultExpectation == nil {
		mmSetDefaultSystemAdmin.defaultExpectation = &ServiceMockSetDefaultSystemAdminExpectation{mock: mmSetDefaultSystemAdmin.mock}
	}
	mmSetDefaultSystemAdmin.defaultExpectation.results = &ServiceMockSetDefaultSystemAdminResults{sp2, err}
	mmSetDefaultSystemAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetDefaultSystemAdmin.mock
}

// Set uses given function f to mock the Service.SetDefaultSystemAdmin method
func (mmSetDefaultSystemAdmin *mServiceMockSetDefaultSystemAdmin) Set(f func(ctx context.Context, sp1 *artifactpb.SetDefaultSystemAdminRequest) (sp2 *artifactpb.SetDefaultSystemAdminResponse, err error)) *ServiceMock {
	if mmSetDefaultSystemAdmin.defaultExpectation != nil {
		mmSetDefaultSystemAdmin.mock.t.Fatalf("Default expectation is already set for the Service.SetDefaultSystemAdmin method")
	}

	if len(mmSetDefaultSystemAdmin.expectations) > 0 {
		mmSetDefaultSystemAdmin.mock.t.Fatalf("Some expectations are already set for the Service.SetDefaultSystemAdmin method")
	}

	mmSetDefaultSystemAdmin.mock.funcSetDefaultSystemAdmin = f
	mmSetDefaultSystemAdmin.mock.funcSetDefaultSystemAdminOrigin = minimock.CallerInfo(1)
	return mmSetDefaultSystemAdmin.mock
}

// When sets expectation for the Service.SetDefaultSystemAdmin which will trigger the result defined by the following
// Then helper
func (mmSetDefaultSystemAdmin *mServiceMockSetDefaultSystemAdmin) When(ctx context.Context, sp1 *artifactpb.SetDefaultSystemAdminRequest) *ServiceMockSetDefaultSystemAdminExpectation {
	if mmSetDefaultSystemAdmin.mock.funcSetDefaultSystemAdmin != nil {
		mmSetDefaultSystemAdmin.mock.t.Fatalf("ServiceMock.SetDefaultSystemAdmin mock is already set by Set")
	}

	expectation := &ServiceMockSetDefaultSystemAdminExpectation{
		mock:               mmSetDefaultSystemAdmin.mock,
		params:             &ServiceMockSetDefaultSystemAdminParams{ctx, sp1},
		expectationOrigins: ServiceMockSetDefaultSystemAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetDefaultSystemAdmin.expectations = append(mmSetDefaultSystemAdmin.expectations, expectation)
	return expectation
}

// Then sets up Service.SetDefaultSystemAdmin return parameters for the expectation previously defined by the When method
func (e *ServiceMockSetDefaultSystemAdminExpectation) Then(sp2 *artifactpb.SetDefaultSystemAdminResponse, err error) *ServiceMock {
	e.results = &ServiceMockSetDefaultSystemAdminResults{sp2, err}
	return e.mock
}

// Times sets number of times Service.SetDefaultSystemAdmin should be invoked
func (mmSetDefaultSystemAdmin *mServiceMockSetDefaultSystemAdmin) Times(n uint64) *mServiceMockSetDefaultSystemAdmin {
	if n == 0 {
		mmSetDefaultSystemAdmin.mock.t.Fatalf("Times of ServiceMock.SetDefaultSystemAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetDefaultSystemAdmin.expectedInvocations, n)
	mmSetDefaultSystemAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetDefaultSystemAdmin
}

func (mmSetDefaultSystemAdmin *mServiceMockSetDefaultSystemAdmin) invocationsDone() bool {
	if len(mmSetDefaultSystemAdmin.expectations) == 0 && mmSetDefaultSystemAdmin.defaultExpectation == nil && mmSetDefaultSystemAdmin.mock.funcSetDefaultSystemAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetDefaultSystemAdmin.mock.afterSetDefaultSystemAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetDefaultSystemAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetDefaultSystemAdmin implements mm_service.Service
func (mmSetDefaultSystemAdmin *ServiceMock) SetDefaultSystemAdmin(ctx context.Context, sp1 *artifactpb.SetDefaultSystemAdminRequest) (sp2 *artifactpb.SetDefaultSystemAdminResponse, err error) {
	mm_atomic.AddUint64(&mmSetDefaultSystemAdmin.beforeSetDefaultSystemAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmSetDefaultSystemAdmin.afterSetDefaultSystemAdminCounter, 1)

	mmSetDefaultSystemAdmin.t.Helper()

	if mmSetDefaultSystemAdmin.inspectFuncSetDefaultSystemAdmin != nil {
		mmSetDefaultSystemAdmin.inspectFuncSetDefaultSystemAdmin(ctx, sp1)
	}

	mm_params := ServiceMockSetDefaultSystemAdminParams{ctx, sp1}

	// Record call args
	mmSetDefaultSystemAdmin.SetDefaultSystemAdminMock.mutex.Lock()
	mmSetDefaultSystemAdmin.SetDefaultSystemAdminMock.callArgs = append(mmSetDefaultSystemAdmin.SetDefaultSystemAdminMock.callArgs, &mm_params)
	mmSetDefaultSystemAdmin.SetDefaultSystemAdminMock.mutex.Unlock()

	for _, e := range mmSetDefaultSystemAdmin.SetDefaultSystemAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp2, e.results.err
		}
	}

	if mmSetDefaultSystemAdmin.SetDefaultSystemAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetDefaultSystemAdmin.SetDefaultSystemAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmSetDefaultSystemAdmin.SetDefaultSystemAdminMock.defaultExpectation.params
		mm_want_ptrs := mmSetDefaultSystemAdmin.SetDefaultSystemAdminMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockSetDefaultSystemAdminParams{ctx, sp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetDefaultSystemAdmin.t.Errorf("ServiceMock.SetDefaultSystemAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetDefaultSystemAdmin.SetDefaultSystemAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sp1 != nil && !minimock.Equal(*mm_want_ptrs.sp1, mm_got.sp1) {
				mmSetDefaultSystemAdmin.t.Errorf("ServiceMock.SetDefaultSystemAdmin got unexpected parameter sp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetDefaultSystemAdmin.SetDefaultSystemAdminMock.defaultExpectation.expectationOrigins.originSp1, *mm_want_ptrs.sp1, mm_got.sp1, minimock.Diff(*mm_want_ptrs.sp1, mm_got.sp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetDefaultSystemAdmin.t.Errorf("ServiceMock.SetDefaultSystemAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetDefaultSystemAdmin.SetDefaultSystemAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetDefaultSystemAdmin.SetDefaultSystemAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmSetDefaultSystemAdmin.t.Fatal("No results are set for the ServiceMock.SetDefaultSystemAdmin")
		}
		return (*mm_results).sp2, (*mm_results).err
	}
	if mmSetDefaultSystemAdmin.funcSetDefaultSystemAdmin != nil {
		return mmSetDefaultSystemAdmin.funcSetDefaultSystemAdmin(ctx, sp1)
	}
	mmSetDefaultSystemAdmin.t.Fatalf("Unexpected call to ServiceMock.SetDefaultSystemAdmin. %v %v", ctx, sp1)
	return
}

// SetDefaultSystemAdminAfterCounter returns a count of finished ServiceMock.SetDefaultSystemAdmin invocations
func (mmSetDefaultSystemAdmin *ServiceMock) SetDefaultSystemAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDefaultSystemAdmin.afterSetDefaultSystemAdminCounter)
}

// SetDefaultSystemAdminBeforeCounter returns a count of ServiceMock.SetDefaultSystemAdmin invocations
func (mmSetDefaultSystemAdmin *ServiceMock) SetDefaultSystemAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDefaultSystemAdmin.beforeSetDefaultSystemAdminCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.SetDefaultSystemAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetDefaultSystemAdmin *mServiceMockSetDefaultSystemAdmin) Calls() []*ServiceMockSetDefaultSystemAdminParams {
	mmSetDefaultSystemAdmin.mutex.RLock()

	argCopy := make([]*ServiceMockSetDefaultSystemAdminParams, len(mmSetDefaultSystemAdmin.callArgs))
	copy(argCopy, mmSetDefaultSystemAdmin.callArgs)

	mmSetDefaultSystemAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockSetDefaultSystemAdminDone returns true if the count of the SetDefaultSystemAdmin invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockSetDefaultSystemAdminDone() bool {
	if m.SetDefaultSystemAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetDefaultSystemAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetDefaultSystemAdminMock.invocationsDone()
}

// MinimockSetDefaultSystemAdminInspect logs each unmet expectation
func (m *ServiceMock) MinimockSetDefaultSystemAdminInspect() {
	for _, e := range m.SetDefaultSystemAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.SetDefaultSystemAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetDefaultSystemAdminCounter := mm_atomic.LoadUint64(&m.afterSetDefaultSystemAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetDefaultSystemAdminMock.defaultExpectation != nil && afterSetDefaultSystemAdminCounter < 1 {
		if m.SetDefaultSystemAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.SetDefaultSystemAdmin at\n%s", m.SetDefaultSystemAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.SetDefaultSystemAdmin at\n%s with params: %#v", m.SetDefaultSystemAdminMock.defaultExpectation.expectationOrigins.origin, *m.SetDefaultSystemAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDefaultSystemAdmin != nil && afterSetDefaultSystemAdminCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.SetDefaultSystemAdmin at\n%s", m.funcSetDefaultSystemAdminOrigin)
	}

	if !m.SetDefaultSystemAdminMock.invocationsDone() && afterSetDefaultSystemAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.SetDefaultSystemAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetDefaultSystemAdminMock.expectedInvocations), m.SetDefaultSystemAdminMock.expectedInvocationsOrigin, afterSetDefaultSystemAdminCounter)
	}
}

type mServiceMockSetRollbackRetentionAdmin struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockSetRollbackRetentionAdminExpectation
	expectations       []*ServiceMockSetRollbackRetentionAdminExpectation

	callArgs []*ServiceMockSetRollbackRetentionAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockSetRollbackRetentionAdminExpectation specifies expectation struct of the Service.SetRollbackRetentionAdmin
type ServiceMockSetRollbackRetentionAdminExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockSetRollbackRetentionAdminParams
	paramPtrs          *ServiceMockSetRollbackRetentionAdminParamPtrs
	expectationOrigins ServiceMockSetRollbackRetentionAdminExpectationOrigins
	results            *ServiceMockSetRollbackRetentionAdminResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockSetRollbackRetentionAdminParams contains parameters of the Service.SetRollbackRetentionAdmin
type ServiceMockSetRollbackRetentionAdminParams struct {
	ctx context.Context
	o1  types.OwnerUIDType
	s1  string
	i1  int32
	s2  artifactpb.SetRollbackRetentionAdminRequest_TimeUnit
}

// ServiceMockSetRollbackRetentionAdminParamPtrs contains pointers to parameters of the Service.SetRollbackRetentionAdmin
type ServiceMockSetRollbackRetentionAdminParamPtrs struct {
	ctx *context.Context
	o1  *types.OwnerUIDType
	s1  *string
	i1  *int32
	s2  *artifactpb.SetRollbackRetentionAdminRequest_TimeUnit
}

// ServiceMockSetRollbackRetentionAdminResults contains results of the Service.SetRollbackRetentionAdmin
type ServiceMockSetRollbackRetentionAdminResults struct {
	sp1 *artifactpb.SetRollbackRetentionAdminResponse
	err error
}

// ServiceMockSetRollbackRetentionAdminOrigins contains origins of expectations of the Service.SetRollbackRetentionAdmin
type ServiceMockSetRollbackRetentionAdminExpectationOrigins struct {
	origin    string
	originCtx string
	originO1  string
	originS1  string
	originI1  string
	originS2  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetRollbackRetentionAdmin *mServiceMockSetRollbackRetentionAdmin) Optional() *mServiceMockSetRollbackRetentionAdmin {
	mmSetRollbackRetentionAdmin.optional = true
	return mmSetRollbackRetentionAdmin
}

// Expect sets up expected params for Service.SetRollbackRetentionAdmin
func (mmSetRollbackRetentionAdmin *mServiceMockSetRollbackRetentionAdmin) Expect(ctx context.Context, o1 types.OwnerUIDType, s1 string, i1 int32, s2 artifactpb.SetRollbackRetentionAdminRequest_TimeUnit) *mServiceMockSetRollbackRetentionAdmin {
	if mmSetRollbackRetentionAdmin.mock.funcSetRollbackRetentionAdmin != nil {
		mmSetRollbackRetentionAdmin.mock.t.Fatalf("ServiceMock.SetRollbackRetentionAdmin mock is already set by Set")
	}

	if mmSetRollbackRetentionAdmin.defaultExpectation == nil {
		mmSetRollbackRetentionAdmin.defaultExpectation = &ServiceMockSetRollbackRetentionAdminExpectation{}
	}

	if mmSetRollbackRetentionAdmin.defaultExpectation.paramPtrs != nil {
		mmSetRollbackRetentionAdmin.mock.t.Fatalf("ServiceMock.SetRollbackRetentionAdmin mock is already set by ExpectParams functions")
	}

	mmSetRollbackRetentionAdmin.defaultExpectation.params = &ServiceMockSetRollbackRetentionAdminParams{ctx, o1, s1, i1, s2}
	mmSetRollbackRetentionAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetRollbackRetentionAdmin.expectations {
		if minimock.Equal(e.params, mmSetRollbackRetentionAdmin.defaultExpectation.params) {
			mmSetRollbackRetentionAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetRollbackRetentionAdmin.defaultExpectation.params)
		}
	}

	return mmSetRollbackRetentionAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Service.SetRollbackRetentionAdmin
func (mmSetRollbackRetentionAdmin *mServiceMockSetRollbackRetentionAdmin) ExpectCtxParam1(ctx context.Context) *mServiceMockSetRollbackRetentionAdmin {
	if mmSetRollbackRetentionAdmin.mock.funcSetRollbackRetentionAdmin != nil {
		mmSetRollbackRetentionAdmin.mock.t.Fatalf("ServiceMock.SetRollbackRetentionAdmin mock is already set by Set")
	}

	if mmSetRollbackRetentionAdmin.defaultExpectation == nil {
		mmSetRollbackRetentionAdmin.defaultExpectation = &ServiceMockSetRollbackRetentionAdminExpectation{}
	}

	if mmSetRollbackRetentionAdmin.defaultExpectation.params != nil {
		mmSetRollbackRetentionAdmin.mock.t.Fatalf("ServiceMock.SetRollbackRetentionAdmin mock is already set by Expect")
	}

	if mmSetRollbackRetentionAdmin.defaultExpectation.paramPtrs == nil {
		mmSetRollbackRetentionAdmin.defaultExpectation.paramPtrs = &ServiceMockSetRollbackRetentionAdminParamPtrs{}
	}
	mmSetRollbackRetentionAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetRollbackRetentionAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetRollbackRetentionAdmin
}

// ExpectO1Param2 sets up expected param o1 for Service.SetRollbackRetentionAdmin
func (mmSetRollbackRetentionAdmin *mServiceMockSetRollbackRetentionAdmin) ExpectO1Param2(o1 types.OwnerUIDType) *mServiceMockSetRollbackRetentionAdmin {
	if mmSetRollbackRetentionAdmin.mock.funcSetRollbackRetentionAdmin != nil {
		mmSetRollbackRetentionAdmin.mock.t.Fatalf("ServiceMock.SetRollbackRetentionAdmin mock is already set by Set")
	}

	if mmSetRollbackRetentionAdmin.defaultExpectation == nil {
		mmSetRollbackRetentionAdmin.defaultExpectation = &ServiceMockSetRollbackRetentionAdminExpectation{}
	}

	if mmSetRollbackRetentionAdmin.defaultExpectation.params != nil {
		mmSetRollbackRetentionAdmin.mock.t.Fatalf("ServiceMock.SetRollbackRetentionAdmin mock is already set by Expect")
	}

	if mmSetRollbackRetentionAdmin.defaultExpectation.paramPtrs == nil {
		mmSetRollbackRetentionAdmin.defaultExpectation.paramPtrs = &ServiceMockSetRollbackRetentionAdminParamPtrs{}
	}
	mmSetRollbackRetentionAdmin.defaultExpectation.paramPtrs.o1 = &o1
	mmSetRollbackRetentionAdmin.defaultExpectation.expectationOrigins.originO1 = minimock.CallerInfo(1)

	return mmSetRollbackRetentionAdmin
}

// ExpectS1Param3 sets up expected param s1 for Service.SetRollbackRetentionAdmin
func (mmSetRollbackRetentionAdmin *mServiceMockSetRollbackRetentionAdmin) ExpectS1Param3(s1 string) *mServiceMockSetRollbackRetentionAdmin {
	if mmSetRollbackRetentionAdmin.mock.funcSetRollbackRetentionAdmin != nil {
		mmSetRollbackRetentionAdmin.mock.t.Fatalf("ServiceMock.SetRollbackRetentionAdmin mock is already set by Set")
	}

	if mmSetRollbackRetentionAdmin.defaultExpectation == nil {
		mmSetRollbackRetentionAdmin.defaultExpectation = &ServiceMockSetRollbackRetentionAdminExpectation{}
	}

	if mmSetRollbackRetentionAdmin.defaultExpectation.params != nil {
		mmSetRollbackRetentionAdmin.mock.t.Fatalf("ServiceMock.SetRollbackRetentionAdmin mock is already set by Expect")
	}

	if mmSetRollbackRetentionAdmin.defaultExpectation.paramPtrs == nil {
		mmSetRollbackRetentionAdmin.defaultExpectation.paramPtrs = &ServiceMockSetRollbackRetentionAdminParamPtrs{}
	}
	mmSetRollbackRetentionAdmin.defaultExpectation.paramPtrs.s1 = &s1
	mmSetRollbackRetentionAdmin.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmSetRollbackRetentionAdmin
}

// ExpectI1Param4 sets up expected param i1 for Service.SetRollbackRetentionAdmin
func (mmSetRollbackRetentionAdmin *mServiceMockSetRollbackRetentionAdmin) ExpectI1Param4(i1 int32) *mServiceMockSetRollbackRetentionAdmin {
	if mmSetRollbackRetentionAdmin.mock.funcSetRollbackRetentionAdmin != nil {
		mmSetRollbackRetentionAdmin.mock.t.Fatalf("ServiceMock.SetRollbackRetentionAdmin mock is already set by Set")
	}

	if mmSetRollbackRetentionAdmin.defaultExpectation == nil {
		mmSetRollbackRetentionAdmin.defaultExpectation = &ServiceMockSetRollbackRetentionAdminExpectation{}
	}

	if mmSetRollbackRetentionAdmin.defaultExpectation.params != nil {
		mmSetRollbackRetentionAdmin.mock.t.Fatalf("ServiceMock.SetRollbackRetentionAdmin mock is already set by Expect")
	}

	if mmSetRollbackRetentionAdmin.defaultExpectation.paramPtrs == nil {
		mmSetRollbackRetentionAdmin.defaultExpectation.paramPtrs = &ServiceMockSetRollbackRetentionAdminParamPtrs{}
	}
	mmSetRollbackRetentionAdmin.defaultExpectation.paramPtrs.i1 = &i1
	mmSetRollbackRetentionAdmin.defaultExpectation.expectationOrigins.originI1 = minimock.CallerInfo(1)

	return mmSetRollbackRetentionAdmin
}

// ExpectS2Param5 sets up expected param s2 for Service.SetRollbackRetentionAdmin
func (mmSetRollbackRetentionAdmin *mServiceMockSetRollbackRetentionAdmin) ExpectS2Param5(s2 artifactpb.SetRollbackRetentionAdminRequest_TimeUnit) *mServiceMockSetRollbackRetentionAdmin {
	if mmSetRollbackRetentionAdmin.mock.funcSetRollbackRetentionAdmin != nil {
		mmSetRollbackRetentionAdmin.mock.t.Fatalf("ServiceMock.SetRollbackRetentionAdmin mock is already set by Set")
	}

	if mmSetRollbackRetentionAdmin.defaultExpectation == nil {
		mmSetRollbackRetentionAdmin.defaultExpectation = &ServiceMockSetRollbackRetentionAdminExpectation{}
	}

	if mmSetRollbackRetentionAdmin.defaultExpectation.params != nil {
		mmSetRollbackRetentionAdmin.mock.t.Fatalf("ServiceMock.SetRollbackRetentionAdmin mock is already set by Expect")
	}

	if mmSetRollbackRetentionAdmin.defaultExpectation.paramPtrs == nil {
		mmSetRollbackRetentionAdmin.defaultExpectation.paramPtrs = &ServiceMockSetRollbackRetentionAdminParamPtrs{}
	}
	mmSetRollbackRetentionAdmin.defaultExpectation.paramPtrs.s2 = &s2
	mmSetRollbackRetentionAdmin.defaultExpectation.expectationOrigins.originS2 = minimock.CallerInfo(1)

	return mmSetRollbackRetentionAdmin
}

// Inspect accepts an inspector function that has same arguments as the Service.SetRollbackRetentionAdmin
func (mmSetRollbackRetentionAdmin *mServiceMockSetRollbackRetentionAdmin) Inspect(f func(ctx context.Context, o1 types.OwnerUIDType, s1 string, i1 int32, s2 artifactpb.SetRollbackRetentionAdminRequest_TimeUnit)) *mServiceMockSetRollbackRetentionAdmin {
	if mmSetRollbackRetentionAdmin.mock.inspectFuncSetRollbackRetentionAdmin != nil {
		mmSetRollbackRetentionAdmin.mock.t.Fatalf("Inspect function is already set for ServiceMock.SetRollbackRetentionAdmin")
	}

	mmSetRollbackRetentionAdmin.mock.inspectFuncSetRollbackRetentionAdmin = f

	return mmSetRollbackRetentionAdmin
}

// Return sets up results that will be returned by Service.SetRollbackRetentionAdmin
func (mmSetRollbackRetentionAdmin *mServiceMockSetRollbackRetentionAdmin) Return(sp1 *artifactpb.SetRollbackRetentionAdminResponse, err error) *ServiceMock {
	if mmSetRollbackRetentionAdmin.mock.funcSetRollbackRetentionAdmin != nil {
		mmSetRollbackRetentionAdmin.mock.t.Fatalf("ServiceMock.SetRollbackRetentionAdmin mock is already set by Set")
	}

	if mmSetRollbackRetentionAdmin.defaultExpectation == nil {
		mmSetRollbackRetentionAdmin.defaultExpectation = &ServiceMockSetRollbackRetentionAdminExpectation{mock: mmSetRollbackRetentionAdmin.mock}
	}
	mmSetRollbackRetentionAdmin.defaultExpectation.results = &ServiceMockSetRollbackRetentionAdminResults{sp1, err}
	mmSetRollbackRetentionAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetRollbackRetentionAdmin.mock
}

// Set uses given function f to mock the Service.SetRollbackRetentionAdmin method
func (mmSetRollbackRetentionAdmin *mServiceMockSetRollbackRetentionAdmin) Set(f func(ctx context.Context, o1 types.OwnerUIDType, s1 string, i1 int32, s2 artifactpb.SetRollbackRetentionAdminRequest_TimeUnit) (sp1 *artifactpb.SetRollbackRetentionAdminResponse, err error)) *ServiceMock {
	if mmSetRollbackRetentionAdmin.defaultExpectation != nil {
		mmSetRollbackRetentionAdmin.mock.t.Fatalf("Default expectation is already set for the Service.SetRollbackRetentionAdmin method")
	}

	if len(mmSetRollbackRetentionAdmin.expectations) > 0 {
		mmSetRollbackRetentionAdmin.mock.t.Fatalf("Some expectations are already set for the Service.SetRollbackRetentionAdmin method")
	}

	mmSetRollbackRetentionAdmin.mock.funcSetRollbackRetentionAdmin = f
	mmSetRollbackRetentionAdmin.mock.funcSetRollbackRetentionAdminOrigin = minimock.CallerInfo(1)
	return mmSetRollbackRetentionAdmin.mock
}

// When sets expectation for the Service.SetRollbackRetentionAdmin which will trigger the result defined by the following
// Then helper
func (mmSetRollbackRetentionAdmin *mServiceMockSetRollbackRetentionAdmin) When(ctx context.Context, o1 types.OwnerUIDType, s1 string, i1 int32, s2 artifactpb.SetRollbackRetentionAdminRequest_TimeUnit) *ServiceMockSetRollbackRetentionAdminExpectation {
	if mmSetRollbackRetentionAdmin.mock.funcSetRollbackRetentionAdmin != nil {
		mmSetRollbackRetentionAdmin.mock.t.Fatalf("ServiceMock.SetRollbackRetentionAdmin mock is already set by Set")
	}

	expectation := &ServiceMockSetRollbackRetentionAdminExpectation{
		mock:               mmSetRollbackRetentionAdmin.mock,
		params:             &ServiceMockSetRollbackRetentionAdminParams{ctx, o1, s1, i1, s2},
		expectationOrigins: ServiceMockSetRollbackRetentionAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetRollbackRetentionAdmin.expectations = append(mmSetRollbackRetentionAdmin.expectations, expectation)
	return expectation
}

// Then sets up Service.SetRollbackRetentionAdmin return parameters for the expectation previously defined by the When method
func (e *ServiceMockSetRollbackRetentionAdminExpectation) Then(sp1 *artifactpb.SetRollbackRetentionAdminResponse, err error) *ServiceMock {
	e.results = &ServiceMockSetRollbackRetentionAdminResults{sp1, err}
	return e.mock
}

// Times sets number of times Service.SetRollbackRetentionAdmin should be invoked
func (mmSetRollbackRetentionAdmin *mServiceMockSetRollbackRetentionAdmin) Times(n uint64) *mServiceMockSetRollbackRetentionAdmin {
	if n == 0 {
		mmSetRollbackRetentionAdmin.mock.t.Fatalf("Times of ServiceMock.SetRollbackRetentionAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetRollbackRetentionAdmin.expectedInvocations, n)
	mmSetRollbackRetentionAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetRollbackRetentionAdmin
}

func (mmSetRollbackRetentionAdmin *mServiceMockSetRollbackRetentionAdmin) invocationsDone() bool {
	if len(mmSetRollbackRetentionAdmin.expectations) == 0 && mmSetRollbackRetentionAdmin.defaultExpectation == nil && mmSetRollbackRetentionAdmin.mock.funcSetRollbackRetentionAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetRollbackRetentionAdmin.mock.afterSetRollbackRetentionAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetRollbackRetentionAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetRollbackRetentionAdmin implements mm_service.Service
func (mmSetRollbackRetentionAdmin *ServiceMock) SetRollbackRetentionAdmin(ctx context.Context, o1 types.OwnerUIDType, s1 string, i1 int32, s2 artifactpb.SetRollbackRetentionAdminRequest_TimeUnit) (sp1 *artifactpb.SetRollbackRetentionAdminResponse, err error) {
	mm_atomic.AddUint64(&mmSetRollbackRetentionAdmin.beforeSetRollbackRetentionAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmSetRollbackRetentionAdmin.afterSetRollbackRetentionAdminCounter, 1)

	mmSetRollbackRetentionAdmin.t.Helper()

	if mmSetRollbackRetentionAdmin.inspectFuncSetRollbackRetentionAdmin != nil {
		mmSetRollbackRetentionAdmin.inspectFuncSetRollbackRetentionAdmin(ctx, o1, s1, i1, s2)
	}

	mm_params := ServiceMockSetRollbackRetentionAdminParams{ctx, o1, s1, i1, s2}

	// Record call args
	mmSetRollbackRetentionAdmin.SetRollbackRetentionAdminMock.mutex.Lock()
	mmSetRollbackRetentionAdmin.SetRollbackRetentionAdminMock.callArgs = append(mmSetRollbackRetentionAdmin.SetRollbackRetentionAdminMock.callArgs, &mm_params)
	mmSetRollbackRetentionAdmin.SetRollbackRetentionAdminMock.mutex.Unlock()

	for _, e := range mmSetRollbackRetentionAdmin.SetRollbackRetentionAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmSetRollbackRetentionAdmin.SetRollbackRetentionAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetRollbackRetentionAdmin.SetRollbackRetentionAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmSetRollbackRetentionAdmin.SetRollbackRetentionAdminMock.defaultExpectation.params
		mm_want_ptrs := mmSetRollbackRetentionAdmin.SetRollbackRetentionAdminMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockSetRollbackRetentionAdminParams{ctx, o1, s1, i1, s2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetRollbackRetentionAdmin.t.Errorf("ServiceMock.SetRollbackRetentionAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetRollbackRetentionAdmin.SetRollbackRetentionAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.o1 != nil && !minimock.Equal(*mm_want_ptrs.o1, mm_got.o1) {
				mmSetRollbackRetentionAdmin.t.Errorf("ServiceMock.SetRollbackRetentionAdmin got unexpected parameter o1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetRollbackRetentionAdmin.SetRollbackRetentionAdminMock.defaultExpectation.expectationOrigins.originO1, *mm_want_ptrs.o1, mm_got.o1, minimock.Diff(*mm_want_ptrs.o1, mm_got.o1))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmSetRollbackRetentionAdmin.t.Errorf("ServiceMock.SetRollbackRetentionAdmin got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetRollbackRetentionAdmin.SetRollbackRetentionAdminMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

			if mm_want_ptrs.i1 != nil && !minimock.Equal(*mm_want_ptrs.i1, mm_got.i1) {
				mmSetRollbackRetentionAdmin.t.Errorf("ServiceMock.SetRollbackRetentionAdmin got unexpected parameter i1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetRollbackRetentionAdmin.SetRollbackRetentionAdminMock.defaultExpectation.expectationOrigins.originI1, *mm_want_ptrs.i1, mm_got.i1, minimock.Diff(*mm_want_ptrs.i1, mm_got.i1))
			}

			if mm_want_ptrs.s2 != nil && !minimock.Equal(*mm_want_ptrs.s2, mm_got.s2) {
				mmSetRollbackRetentionAdmin.t.Errorf("ServiceMock.SetRollbackRetentionAdmin got unexpected parameter s2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetRollbackRetentionAdmin.SetRollbackRetentionAdminMock.defaultExpectation.expectationOrigins.originS2, *mm_want_ptrs.s2, mm_got.s2, minimock.Diff(*mm_want_ptrs.s2, mm_got.s2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetRollbackRetentionAdmin.t.Errorf("ServiceMock.SetRollbackRetentionAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetRollbackRetentionAdmin.SetRollbackRetentionAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetRollbackRetentionAdmin.SetRollbackRetentionAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmSetRollbackRetentionAdmin.t.Fatal("No results are set for the ServiceMock.SetRollbackRetentionAdmin")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmSetRollbackRetentionAdmin.funcSetRollbackRetentionAdmin != nil {
		return mmSetRollbackRetentionAdmin.funcSetRollbackRetentionAdmin(ctx, o1, s1, i1, s2)
	}
	mmSetRollbackRetentionAdmin.t.Fatalf("Unexpected call to ServiceMock.SetRollbackRetentionAdmin. %v %v %v %v %v", ctx, o1, s1, i1, s2)
	return
}

// SetRollbackRetentionAdminAfterCounter returns a count of finished ServiceMock.SetRollbackRetentionAdmin invocations
func (mmSetRollbackRetentionAdmin *ServiceMock) SetRollbackRetentionAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetRollbackRetentionAdmin.afterSetRollbackRetentionAdminCounter)
}

// SetRollbackRetentionAdminBeforeCounter returns a count of ServiceMock.SetRollbackRetentionAdmin invocations
func (mmSetRollbackRetentionAdmin *ServiceMock) SetRollbackRetentionAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetRollbackRetentionAdmin.beforeSetRollbackRetentionAdminCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.SetRollbackRetentionAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetRollbackRetentionAdmin *mServiceMockSetRollbackRetentionAdmin) Calls() []*ServiceMockSetRollbackRetentionAdminParams {
	mmSetRollbackRetentionAdmin.mutex.RLock()

	argCopy := make([]*ServiceMockSetRollbackRetentionAdminParams, len(mmSetRollbackRetentionAdmin.callArgs))
	copy(argCopy, mmSetRollbackRetentionAdmin.callArgs)

	mmSetRollbackRetentionAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockSetRollbackRetentionAdminDone returns true if the count of the SetRollbackRetentionAdmin invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockSetRollbackRetentionAdminDone() bool {
	if m.SetRollbackRetentionAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetRollbackRetentionAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetRollbackRetentionAdminMock.invocationsDone()
}

// MinimockSetRollbackRetentionAdminInspect logs each unmet expectation
func (m *ServiceMock) MinimockSetRollbackRetentionAdminInspect() {
	for _, e := range m.SetRollbackRetentionAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.SetRollbackRetentionAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetRollbackRetentionAdminCounter := mm_atomic.LoadUint64(&m.afterSetRollbackRetentionAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetRollbackRetentionAdminMock.defaultExpectation != nil && afterSetRollbackRetentionAdminCounter < 1 {
		if m.SetRollbackRetentionAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.SetRollbackRetentionAdmin at\n%s", m.SetRollbackRetentionAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.SetRollbackRetentionAdmin at\n%s with params: %#v", m.SetRollbackRetentionAdminMock.defaultExpectation.expectationOrigins.origin, *m.SetRollbackRetentionAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetRollbackRetentionAdmin != nil && afterSetRollbackRetentionAdminCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.SetRollbackRetentionAdmin at\n%s", m.funcSetRollbackRetentionAdminOrigin)
	}

	if !m.SetRollbackRetentionAdminMock.invocationsDone() && afterSetRollbackRetentionAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.SetRollbackRetentionAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetRollbackRetentionAdminMock.expectedInvocations), m.SetRollbackRetentionAdminMock.expectedInvocationsOrigin, afterSetRollbackRetentionAdminCounter)
	}
}

type mServiceMockSimilarityChunksSearch struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockSimilarityChunksSearchExpectation
	expectations       []*ServiceMockSimilarityChunksSearchExpectation

	callArgs []*ServiceMockSimilarityChunksSearchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockSimilarityChunksSearchExpectation specifies expectation struct of the Service.SimilarityChunksSearch
type ServiceMockSimilarityChunksSearchExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockSimilarityChunksSearchParams
	paramPtrs          *ServiceMockSimilarityChunksSearchParamPtrs
	expectationOrigins ServiceMockSimilarityChunksSearchExpectationOrigins
	results            *ServiceMockSimilarityChunksSearchResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockSimilarityChunksSearchParams contains parameters of the Service.SimilarityChunksSearch
type ServiceMockSimilarityChunksSearchParams struct {
	ctx  context.Context
	o1   types.OwnerUIDType
	sp1  *artifactpb.SimilarityChunksSearchRequest
	faa1 [][]float32
}

// ServiceMockSimilarityChunksSearchParamPtrs contains pointers to parameters of the Service.SimilarityChunksSearch
type ServiceMockSimilarityChunksSearchParamPtrs struct {
	ctx  *context.Context
	o1   *types.OwnerUIDType
	sp1  **artifactpb.SimilarityChunksSearchRequest
	faa1 *[][]float32
}

// ServiceMockSimilarityChunksSearchResults contains results of the Service.SimilarityChunksSearch
type ServiceMockSimilarityChunksSearchResults struct {
	sa1 []mm_service.SimChunk
	err error
}

// ServiceMockSimilarityChunksSearchOrigins contains origins of expectations of the Service.SimilarityChunksSearch
type ServiceMockSimilarityChunksSearchExpectationOrigins struct {
	origin     string
	originCtx  string
	originO1   string
	originSp1  string
	originFaa1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) Optional() *mServiceMockSimilarityChunksSearch {
	mmSimilarityChunksSearch.optional = true
	return mmSimilarityChunksSearch
}

// Expect sets up expected params for Service.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) Expect(ctx context.Context, o1 types.OwnerUIDType, sp1 *artifactpb.SimilarityChunksSearchRequest, faa1 [][]float32) *mServiceMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ServiceMockSimilarityChunksSearchExpectation{}
	}

	if mmSimilarityChunksSearch.defaultExpectation.paramPtrs != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by ExpectParams functions")
	}

	mmSimilarityChunksSearch.defaultExpectation.params = &ServiceMockSimilarityChunksSearchParams{ctx, o1, sp1, faa1}
	mmSimilarityChunksSearch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSimilarityChunksSearch.expectations {
		if minimock.Equal(e.params, mmSimilarityChunksSearch.defaultExpectation.params) {
			mmSimilarityChunksSearch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSimilarityChunksSearch.defaultExpectation.params)
		}
	}

	return mmSimilarityChunksSearch
}

// ExpectCtxParam1 sets up expected param ctx for Service.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) ExpectCtxParam1(ctx context.Context) *mServiceMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ServiceMockSimilarityChunksSearchExpectation{}
	}

	if mmSimilarityChunksSearch.defaultExpectation.params != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Expect")
	}

	if mmSimilarityChunksSearch.defaultExpectation.paramPtrs == nil {
		mmSimilarityChunksSearch.defaultExpectation.paramPtrs = &ServiceMockSimilarityChunksSearchParamPtrs{}
	}
	mmSimilarityChunksSearch.defaultExpectation.paramPtrs.ctx = &ctx
	mmSimilarityChunksSearch.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSimilarityChunksSearch
}

// ExpectO1Param2 sets up expected param o1 for Service.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) ExpectO1Param2(o1 types.OwnerUIDType) *mServiceMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ServiceMockSimilarityChunksSearchExpectation{}
	}

	if mmSimilarityChunksSearch.defaultExpectation.params != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Expect")
	}

	if mmSimilarityChunksSearch.defaultExpectation.paramPtrs == nil {
		mmSimilarityChunksSearch.defaultExpectation.paramPtrs = &ServiceMockSimilarityChunksSearchParamPtrs{}
	}
	mmSimilarityChunksSearch.defaultExpectation.paramPtrs.o1 = &o1
	mmSimilarityChunksSearch.defaultExpectation.expectationOrigins.originO1 = minimock.CallerInfo(1)

	return mmSimilarityChunksSearch
}

// ExpectSp1Param3 sets up expected param sp1 for Service.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) ExpectSp1Param3(sp1 *artifactpb.SimilarityChunksSearchRequest) *mServiceMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ServiceMockSimilarityChunksSearchExpectation{}
	}

	if mmSimilarityChunksSearch.defaultExpectation.params != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Expect")
	}

	if mmSimilarityChunksSearch.defaultExpectation.paramPtrs == nil {
		mmSimilarityChunksSearch.defaultExpectation.paramPtrs = &ServiceMockSimilarityChunksSearchParamPtrs{}
	}
	mmSimilarityChunksSearch.defaultExpectation.paramPtrs.sp1 = &sp1
	mmSimilarityChunksSearch.defaultExpectation.expectationOrigins.originSp1 = minimock.CallerInfo(1)

	return mmSimilarityChunksSearch
}

// ExpectFaa1Param4 sets up expected param faa1 for Service.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) ExpectFaa1Param4(faa1 [][]float32) *mServiceMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ServiceMockSimilarityChunksSearchExpectation{}
	}

	if mmSimilarityChunksSearch.defaultExpectation.params != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Expect")
	}

	if mmSimilarityChunksSearch.defaultExpectation.paramPtrs == nil {
		mmSimilarityChunksSearch.defaultExpectation.paramPtrs = &ServiceMockSimilarityChunksSearchParamPtrs{}
	}
	mmSimilarityChunksSearch.defaultExpectation.paramPtrs.faa1 = &faa1
	mmSimilarityChunksSearch.defaultExpectation.expectationOrigins.originFaa1 = minimock.CallerInfo(1)

	return mmSimilarityChunksSearch
}

// Inspect accepts an inspector function that has same arguments as the Service.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) Inspect(f func(ctx context.Context, o1 types.OwnerUIDType, sp1 *artifactpb.SimilarityChunksSearchRequest, faa1 [][]float32)) *mServiceMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.inspectFuncSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("Inspect function is already set for ServiceMock.SimilarityChunksSearch")
	}

	mmSimilarityChunksSearch.mock.inspectFuncSimilarityChunksSearch = f

	return mmSimilarityChunksSearch
}

// Return sets up results that will be returned by Service.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) Return(sa1 []mm_service.SimChunk, err error) *ServiceMock {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ServiceMockSimilarityChunksSearchExpectation{mock: mmSimilarityChunksSearch.mock}
	}
	mmSimilarityChunksSearch.defaultExpectation.results = &ServiceMockSimilarityChunksSearchResults{sa1, err}
	mmSimilarityChunksSearch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSimilarityChunksSearch.mock
}

// Set uses given function f to mock the Service.SimilarityChunksSearch method
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) Set(f func(ctx context.Context, o1 types.OwnerUIDType, sp1 *artifactpb.SimilarityChunksSearchRequest, faa1 [][]float32) (sa1 []mm_service.SimChunk, err error)) *ServiceMock {
	if mmSimilarityChunksSearch.defaultExpectation != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("Default expectation is already set for the Service.SimilarityChunksSearch method")
	}

	if len(mmSimilarityChunksSearch.expectations) > 0 {
		mmSimilarityChunksSearch.mock.t.Fatalf("Some expectations are already set for the Service.SimilarityChunksSearch method")
	}

	mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch = f
	mmSimilarityChunksSearch.mock.funcSimilarityChunksSearchOrigin = minimock.CallerInfo(1)
	return mmSimilarityChunksSearch.mock
}

// When sets expectation for the Service.SimilarityChunksSearch which will trigger the result defined by the following
// Then helper
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) When(ctx context.Context, o1 types.OwnerUIDType, sp1 *artifactpb.SimilarityChunksSearchRequest, faa1 [][]float32) *ServiceMockSimilarityChunksSearchExpectation {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ServiceMock.SimilarityChunksSearch mock is already set by Set")
	}

	expectation := &ServiceMockSimilarityChunksSearchExpectation{
		mock:               mmSimilarityChunksSearch.mock,
		params:             &ServiceMockSimilarityChunksSearchParams{ctx, o1, sp1, faa1},
		expectationOrigins: ServiceMockSimilarityChunksSearchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSimilarityChunksSearch.expectations = append(mmSimilarityChunksSearch.expectations, expectation)
	return expectation
}

// Then sets up Service.SimilarityChunksSearch return parameters for the expectation previously defined by the When method
func (e *ServiceMockSimilarityChunksSearchExpectation) Then(sa1 []mm_service.SimChunk, err error) *ServiceMock {
	e.results = &ServiceMockSimilarityChunksSearchResults{sa1, err}
	return e.mock
}

// Times sets number of times Service.SimilarityChunksSearch should be invoked
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) Times(n uint64) *mServiceMockSimilarityChunksSearch {
	if n == 0 {
		mmSimilarityChunksSearch.mock.t.Fatalf("Times of ServiceMock.SimilarityChunksSearch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSimilarityChunksSearch.expectedInvocations, n)
	mmSimilarityChunksSearch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSimilarityChunksSearch
}

func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) invocationsDone() bool {
	if len(mmSimilarityChunksSearch.expectations) == 0 && mmSimilarityChunksSearch.defaultExpectation == nil && mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSimilarityChunksSearch.mock.afterSimilarityChunksSearchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSimilarityChunksSearch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SimilarityChunksSearch implements mm_service.Service
func (mmSimilarityChunksSearch *ServiceMock) SimilarityChunksSearch(ctx context.Context, o1 types.OwnerUIDType, sp1 *artifactpb.SimilarityChunksSearchRequest, faa1 [][]float32) (sa1 []mm_service.SimChunk, err error) {
	mm_atomic.AddUint64(&mmSimilarityChunksSearch.beforeSimilarityChunksSearchCounter, 1)
	defer mm_atomic.AddUint64(&mmSimilarityChunksSearch.afterSimilarityChunksSearchCounter, 1)

	mmSimilarityChunksSearch.t.Helper()

	if mmSimilarityChunksSearch.inspectFuncSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.inspectFuncSimilarityChunksSearch(ctx, o1, sp1, faa1)
	}

	mm_params := ServiceMockSimilarityChunksSearchParams{ctx, o1, sp1, faa1}

	// Record call args
	mmSimilarityChunksSearch.SimilarityChunksSearchMock.mutex.Lock()
	mmSimilarityChunksSearch.SimilarityChunksSearchMock.callArgs = append(mmSimilarityChunksSearch.SimilarityChunksSearchMock.callArgs, &mm_params)
	mmSimilarityChunksSearch.SimilarityChunksSearchMock.mutex.Unlock()

	for _, e := range mmSimilarityChunksSearch.SimilarityChunksSearchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.Counter, 1)
		mm_want := mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.params
		mm_want_ptrs := mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockSimilarityChunksSearchParams{ctx, o1, sp1, faa1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSimilarityChunksSearch.t.Errorf("ServiceMock.SimilarityChunksSearch got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.o1 != nil && !minimock.Equal(*mm_want_ptrs.o1, mm_got.o1) {
				mmSimilarityChunksSearch.t.Errorf("ServiceMock.SimilarityChunksSearch got unexpected parameter o1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.expectationOrigins.originO1, *mm_want_ptrs.o1, mm_got.o1, minimock.Diff(*mm_want_ptrs.o1, mm_got.o1))
			}

			if mm_want_ptrs.sp1 != nil && !minimock.Equal(*mm_want_ptrs.sp1, mm_got.sp1) {
				mmSimilarityChunksSearch.t.Errorf("ServiceMock.SimilarityChunksSearch got unexpected parameter sp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.expectationOrigins.originSp1, *mm_want_ptrs.sp1, mm_got.sp1, minimock.Diff(*mm_want_ptrs.sp1, mm_got.sp1))
			}

			if mm_want_ptrs.faa1 != nil && !minimock.Equal(*mm_want_ptrs.faa1, mm_got.faa1) {
				mmSimilarityChunksSearch.t.Errorf("ServiceMock.SimilarityChunksSearch got unexpected parameter faa1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.expectationOrigins.originFaa1, *mm_want_ptrs.faa1, mm_got.faa1, minimock.Diff(*mm_want_ptrs.faa1, mm_got.faa1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSimilarityChunksSearch.t.Errorf("ServiceMock.SimilarityChunksSearch got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.results
		if mm_results == nil {
			mmSimilarityChunksSearch.t.Fatal("No results are set for the ServiceMock.SimilarityChunksSearch")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmSimilarityChunksSearch.funcSimilarityChunksSearch != nil {
		return mmSimilarityChunksSearch.funcSimilarityChunksSearch(ctx, o1, sp1, faa1)
	}
	mmSimilarityChunksSearch.t.Fatalf("Unexpected call to ServiceMock.SimilarityChunksSearch. %v %v %v %v", ctx, o1, sp1, faa1)
	return
}

// SimilarityChunksSearchAfterCounter returns a count of finished ServiceMock.SimilarityChunksSearch invocations
func (mmSimilarityChunksSearch *ServiceMock) SimilarityChunksSearchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSimilarityChunksSearch.afterSimilarityChunksSearchCounter)
}

// SimilarityChunksSearchBeforeCounter returns a count of ServiceMock.SimilarityChunksSearch invocations
func (mmSimilarityChunksSearch *ServiceMock) SimilarityChunksSearchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSimilarityChunksSearch.beforeSimilarityChunksSearchCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.SimilarityChunksSearch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSimilarityChunksSearch *mServiceMockSimilarityChunksSearch) Calls() []*ServiceMockSimilarityChunksSearchParams {
	mmSimilarityChunksSearch.mutex.RLock()

	argCopy := make([]*ServiceMockSimilarityChunksSearchParams, len(mmSimilarityChunksSearch.callArgs))
	copy(argCopy, mmSimilarityChunksSearch.callArgs)

	mmSimilarityChunksSearch.mutex.RUnlock()

	return argCopy
}

// MinimockSimilarityChunksSearchDone returns true if the count of the SimilarityChunksSearch invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockSimilarityChunksSearchDone() bool {
	if m.SimilarityChunksSearchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SimilarityChunksSearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SimilarityChunksSearchMock.invocationsDone()
}

// MinimockSimilarityChunksSearchInspect logs each unmet expectation
func (m *ServiceMock) MinimockSimilarityChunksSearchInspect() {
	for _, e := range m.SimilarityChunksSearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.SimilarityChunksSearch at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSimilarityChunksSearchCounter := mm_atomic.LoadUint64(&m.afterSimilarityChunksSearchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SimilarityChunksSearchMock.defaultExpectation != nil && afterSimilarityChunksSearchCounter < 1 {
		if m.SimilarityChunksSearchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.SimilarityChunksSearch at\n%s", m.SimilarityChunksSearchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.SimilarityChunksSearch at\n%s with params: %#v", m.SimilarityChunksSearchMock.defaultExpectation.expectationOrigins.origin, *m.SimilarityChunksSearchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSimilarityChunksSearch != nil && afterSimilarityChunksSearchCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.SimilarityChunksSearch at\n%s", m.funcSimilarityChunksSearchOrigin)
	}

	if !m.SimilarityChunksSearchMock.invocationsDone() && afterSimilarityChunksSearchCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.SimilarityChunksSearch at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SimilarityChunksSearchMock.expectedInvocations), m.SimilarityChunksSearchMock.expectedInvocationsOrigin, afterSimilarityChunksSearchCounter)
	}
}

type mServiceMockUpdateSystemAdmin struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockUpdateSystemAdminExpectation
	expectations       []*ServiceMockUpdateSystemAdminExpectation

	callArgs []*ServiceMockUpdateSystemAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockUpdateSystemAdminExpectation specifies expectation struct of the Service.UpdateSystemAdmin
type ServiceMockUpdateSystemAdminExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockUpdateSystemAdminParams
	paramPtrs          *ServiceMockUpdateSystemAdminParamPtrs
	expectationOrigins ServiceMockUpdateSystemAdminExpectationOrigins
	results            *ServiceMockUpdateSystemAdminResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockUpdateSystemAdminParams contains parameters of the Service.UpdateSystemAdmin
type ServiceMockUpdateSystemAdminParams struct {
	ctx context.Context
	up1 *artifactpb.UpdateSystemAdminRequest
}

// ServiceMockUpdateSystemAdminParamPtrs contains pointers to parameters of the Service.UpdateSystemAdmin
type ServiceMockUpdateSystemAdminParamPtrs struct {
	ctx *context.Context
	up1 **artifactpb.UpdateSystemAdminRequest
}

// ServiceMockUpdateSystemAdminResults contains results of the Service.UpdateSystemAdmin
type ServiceMockUpdateSystemAdminResults struct {
	up2 *artifactpb.UpdateSystemAdminResponse
	err error
}

// ServiceMockUpdateSystemAdminOrigins contains origins of expectations of the Service.UpdateSystemAdmin
type ServiceMockUpdateSystemAdminExpectationOrigins struct {
	origin    string
	originCtx string
	originUp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateSystemAdmin *mServiceMockUpdateSystemAdmin) Optional() *mServiceMockUpdateSystemAdmin {
	mmUpdateSystemAdmin.optional = true
	return mmUpdateSystemAdmin
}

// Expect sets up expected params for Service.UpdateSystemAdmin
func (mmUpdateSystemAdmin *mServiceMockUpdateSystemAdmin) Expect(ctx context.Context, up1 *artifactpb.UpdateSystemAdminRequest) *mServiceMockUpdateSystemAdmin {
	if mmUpdateSystemAdmin.mock.funcUpdateSystemAdmin != nil {
		mmUpdateSystemAdmin.mock.t.Fatalf("ServiceMock.UpdateSystemAdmin mock is already set by Set")
	}

	if mmUpdateSystemAdmin.defaultExpectation == nil {
		mmUpdateSystemAdmin.defaultExpectation = &ServiceMockUpdateSystemAdminExpectation{}
	}

	if mmUpdateSystemAdmin.defaultExpectation.paramPtrs != nil {
		mmUpdateSystemAdmin.mock.t.Fatalf("ServiceMock.UpdateSystemAdmin mock is already set by ExpectParams functions")
	}

	mmUpdateSystemAdmin.defaultExpectation.params = &ServiceMockUpdateSystemAdminParams{ctx, up1}
	mmUpdateSystemAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateSystemAdmin.expectations {
		if minimock.Equal(e.params, mmUpdateSystemAdmin.defaultExpectation.params) {
			mmUpdateSystemAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateSystemAdmin.defaultExpectation.params)
		}
	}

	return mmUpdateSystemAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Service.UpdateSystemAdmin
func (mmUpdateSystemAdmin *mServiceMockUpdateSystemAdmin) ExpectCtxParam1(ctx context.Context) *mServiceMockUpdateSystemAdmin {
	if mmUpdateSystemAdmin.mock.funcUpdateSystemAdmin != nil {
		mmUpdateSystemAdmin.mock.t.Fatalf("ServiceMock.UpdateSystemAdmin mock is already set by Set")
	}

	if mmUpdateSystemAdmin.defaultExpectation == nil {
		mmUpdateSystemAdmin.defaultExpectation = &ServiceMockUpdateSystemAdminExpectation{}
	}

	if mmUpdateSystemAdmin.defaultExpectation.params != nil {
		mmUpdateSystemAdmin.mock.t.Fatalf("ServiceMock.UpdateSystemAdmin mock is already set by Expect")
	}

	if mmUpdateSystemAdmin.defaultExpectation.paramPtrs == nil {
		mmUpdateSystemAdmin.defaultExpectation.paramPtrs = &ServiceMockUpdateSystemAdminParamPtrs{}
	}
	mmUpdateSystemAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateSystemAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateSystemAdmin
}

// ExpectUp1Param2 sets up expected param up1 for Service.UpdateSystemAdmin
func (mmUpdateSystemAdmin *mServiceMockUpdateSystemAdmin) ExpectUp1Param2(up1 *artifactpb.UpdateSystemAdminRequest) *mServiceMockUpdateSystemAdmin {
	if mmUpdateSystemAdmin.mock.funcUpdateSystemAdmin != nil {
		mmUpdateSystemAdmin.mock.t.Fatalf("ServiceMock.UpdateSystemAdmin mock is already set by Set")
	}

	if mmUpdateSystemAdmin.defaultExpectation == nil {
		mmUpdateSystemAdmin.defaultExpectation = &ServiceMockUpdateSystemAdminExpectation{}
	}

	if mmUpdateSystemAdmin.defaultExpectation.params != nil {
		mmUpdateSystemAdmin.mock.t.Fatalf("ServiceMock.UpdateSystemAdmin mock is already set by Expect")
	}

	if mmUpdateSystemAdmin.defaultExpectation.paramPtrs == nil {
		mmUpdateSystemAdmin.defaultExpectation.paramPtrs = &ServiceMockUpdateSystemAdminParamPtrs{}
	}
	mmUpdateSystemAdmin.defaultExpectation.paramPtrs.up1 = &up1
	mmUpdateSystemAdmin.defaultExpectation.expectationOrigins.originUp1 = minimock.CallerInfo(1)

	return mmUpdateSystemAdmin
}

// Inspect accepts an inspector function that has same arguments as the Service.UpdateSystemAdmin
func (mmUpdateSystemAdmin *mServiceMockUpdateSystemAdmin) Inspect(f func(ctx context.Context, up1 *artifactpb.UpdateSystemAdminRequest)) *mServiceMockUpdateSystemAdmin {
	if mmUpdateSystemAdmin.mock.inspectFuncUpdateSystemAdmin != nil {
		mmUpdateSystemAdmin.mock.t.Fatalf("Inspect function is already set for ServiceMock.UpdateSystemAdmin")
	}

	mmUpdateSystemAdmin.mock.inspectFuncUpdateSystemAdmin = f

	return mmUpdateSystemAdmin
}

// Return sets up results that will be returned by Service.UpdateSystemAdmin
func (mmUpdateSystemAdmin *mServiceMockUpdateSystemAdmin) Return(up2 *artifactpb.UpdateSystemAdminResponse, err error) *ServiceMock {
	if mmUpdateSystemAdmin.mock.funcUpdateSystemAdmin != nil {
		mmUpdateSystemAdmin.mock.t.Fatalf("ServiceMock.UpdateSystemAdmin mock is already set by Set")
	}

	if mmUpdateSystemAdmin.defaultExpectation == nil {
		mmUpdateSystemAdmin.defaultExpectation = &ServiceMockUpdateSystemAdminExpectation{mock: mmUpdateSystemAdmin.mock}
	}
	mmUpdateSystemAdmin.defaultExpectation.results = &ServiceMockUpdateSystemAdminResults{up2, err}
	mmUpdateSystemAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateSystemAdmin.mock
}

// Set uses given function f to mock the Service.UpdateSystemAdmin method
func (mmUpdateSystemAdmin *mServiceMockUpdateSystemAdmin) Set(f func(ctx context.Context, up1 *artifactpb.UpdateSystemAdminRequest) (up2 *artifactpb.UpdateSystemAdminResponse, err error)) *ServiceMock {
	if mmUpdateSystemAdmin.defaultExpectation != nil {
		mmUpdateSystemAdmin.mock.t.Fatalf("Default expectation is already set for the Service.UpdateSystemAdmin method")
	}

	if len(mmUpdateSystemAdmin.expectations) > 0 {
		mmUpdateSystemAdmin.mock.t.Fatalf("Some expectations are already set for the Service.UpdateSystemAdmin method")
	}

	mmUpdateSystemAdmin.mock.funcUpdateSystemAdmin = f
	mmUpdateSystemAdmin.mock.funcUpdateSystemAdminOrigin = minimock.CallerInfo(1)
	return mmUpdateSystemAdmin.mock
}

// When sets expectation for the Service.UpdateSystemAdmin which will trigger the result defined by the following
// Then helper
func (mmUpdateSystemAdmin *mServiceMockUpdateSystemAdmin) When(ctx context.Context, up1 *artifactpb.UpdateSystemAdminRequest) *ServiceMockUpdateSystemAdminExpectation {
	if mmUpdateSystemAdmin.mock.funcUpdateSystemAdmin != nil {
		mmUpdateSystemAdmin.mock.t.Fatalf("ServiceMock.UpdateSystemAdmin mock is already set by Set")
	}

	expectation := &ServiceMockUpdateSystemAdminExpectation{
		mock:               mmUpdateSystemAdmin.mock,
		params:             &ServiceMockUpdateSystemAdminParams{ctx, up1},
		expectationOrigins: ServiceMockUpdateSystemAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateSystemAdmin.expectations = append(mmUpdateSystemAdmin.expectations, expectation)
	return expectation
}

// Then sets up Service.UpdateSystemAdmin return parameters for the expectation previously defined by the When method
func (e *ServiceMockUpdateSystemAdminExpectation) Then(up2 *artifactpb.UpdateSystemAdminResponse, err error) *ServiceMock {
	e.results = &ServiceMockUpdateSystemAdminResults{up2, err}
	return e.mock
}

// Times sets number of times Service.UpdateSystemAdmin should be invoked
func (mmUpdateSystemAdmin *mServiceMockUpdateSystemAdmin) Times(n uint64) *mServiceMockUpdateSystemAdmin {
	if n == 0 {
		mmUpdateSystemAdmin.mock.t.Fatalf("Times of ServiceMock.UpdateSystemAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateSystemAdmin.expectedInvocations, n)
	mmUpdateSystemAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateSystemAdmin
}

func (mmUpdateSystemAdmin *mServiceMockUpdateSystemAdmin) invocationsDone() bool {
	if len(mmUpdateSystemAdmin.expectations) == 0 && mmUpdateSystemAdmin.defaultExpectation == nil && mmUpdateSystemAdmin.mock.funcUpdateSystemAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateSystemAdmin.mock.afterUpdateSystemAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateSystemAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateSystemAdmin implements mm_service.Service
func (mmUpdateSystemAdmin *ServiceMock) UpdateSystemAdmin(ctx context.Context, up1 *artifactpb.UpdateSystemAdminRequest) (up2 *artifactpb.UpdateSystemAdminResponse, err error) {
	mm_atomic.AddUint64(&mmUpdateSystemAdmin.beforeUpdateSystemAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateSystemAdmin.afterUpdateSystemAdminCounter, 1)

	mmUpdateSystemAdmin.t.Helper()

	if mmUpdateSystemAdmin.inspectFuncUpdateSystemAdmin != nil {
		mmUpdateSystemAdmin.inspectFuncUpdateSystemAdmin(ctx, up1)
	}

	mm_params := ServiceMockUpdateSystemAdminParams{ctx, up1}

	// Record call args
	mmUpdateSystemAdmin.UpdateSystemAdminMock.mutex.Lock()
	mmUpdateSystemAdmin.UpdateSystemAdminMock.callArgs = append(mmUpdateSystemAdmin.UpdateSystemAdminMock.callArgs, &mm_params)
	mmUpdateSystemAdmin.UpdateSystemAdminMock.mutex.Unlock()

	for _, e := range mmUpdateSystemAdmin.UpdateSystemAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up2, e.results.err
		}
	}

	if mmUpdateSystemAdmin.UpdateSystemAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateSystemAdmin.UpdateSystemAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateSystemAdmin.UpdateSystemAdminMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateSystemAdmin.UpdateSystemAdminMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockUpdateSystemAdminParams{ctx, up1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateSystemAdmin.t.Errorf("ServiceMock.UpdateSystemAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateSystemAdmin.UpdateSystemAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.up1 != nil && !minimock.Equal(*mm_want_ptrs.up1, mm_got.up1) {
				mmUpdateSystemAdmin.t.Errorf("ServiceMock.UpdateSystemAdmin got unexpected parameter up1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateSystemAdmin.UpdateSystemAdminMock.defaultExpectation.expectationOrigins.originUp1, *mm_want_ptrs.up1, mm_got.up1, minimock.Diff(*mm_want_ptrs.up1, mm_got.up1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateSystemAdmin.t.Errorf("ServiceMock.UpdateSystemAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateSystemAdmin.UpdateSystemAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateSystemAdmin.UpdateSystemAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateSystemAdmin.t.Fatal("No results are set for the ServiceMock.UpdateSystemAdmin")
		}
		return (*mm_results).up2, (*mm_results).err
	}
	if mmUpdateSystemAdmin.funcUpdateSystemAdmin != nil {
		return mmUpdateSystemAdmin.funcUpdateSystemAdmin(ctx, up1)
	}
	mmUpdateSystemAdmin.t.Fatalf("Unexpected call to ServiceMock.UpdateSystemAdmin. %v %v", ctx, up1)
	return
}

// UpdateSystemAdminAfterCounter returns a count of finished ServiceMock.UpdateSystemAdmin invocations
func (mmUpdateSystemAdmin *ServiceMock) UpdateSystemAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateSystemAdmin.afterUpdateSystemAdminCounter)
}

// UpdateSystemAdminBeforeCounter returns a count of ServiceMock.UpdateSystemAdmin invocations
func (mmUpdateSystemAdmin *ServiceMock) UpdateSystemAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateSystemAdmin.beforeUpdateSystemAdminCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.UpdateSystemAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateSystemAdmin *mServiceMockUpdateSystemAdmin) Calls() []*ServiceMockUpdateSystemAdminParams {
	mmUpdateSystemAdmin.mutex.RLock()

	argCopy := make([]*ServiceMockUpdateSystemAdminParams, len(mmUpdateSystemAdmin.callArgs))
	copy(argCopy, mmUpdateSystemAdmin.callArgs)

	mmUpdateSystemAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateSystemAdminDone returns true if the count of the UpdateSystemAdmin invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockUpdateSystemAdminDone() bool {
	if m.UpdateSystemAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateSystemAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateSystemAdminMock.invocationsDone()
}

// MinimockUpdateSystemAdminInspect logs each unmet expectation
func (m *ServiceMock) MinimockUpdateSystemAdminInspect() {
	for _, e := range m.UpdateSystemAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.UpdateSystemAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateSystemAdminCounter := mm_atomic.LoadUint64(&m.afterUpdateSystemAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateSystemAdminMock.defaultExpectation != nil && afterUpdateSystemAdminCounter < 1 {
		if m.UpdateSystemAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.UpdateSystemAdmin at\n%s", m.UpdateSystemAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.UpdateSystemAdmin at\n%s with params: %#v", m.UpdateSystemAdminMock.defaultExpectation.expectationOrigins.origin, *m.UpdateSystemAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateSystemAdmin != nil && afterUpdateSystemAdminCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.UpdateSystemAdmin at\n%s", m.funcUpdateSystemAdminOrigin)
	}

	if !m.UpdateSystemAdminMock.invocationsDone() && afterUpdateSystemAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.UpdateSystemAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateSystemAdminMock.expectedInvocations), m.UpdateSystemAdminMock.expectedInvocationsOrigin, afterUpdateSystemAdminCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockACLClientInspect()

			m.MinimockAbortKnowledgeBaseUpdateAdminInspect()

			m.MinimockCheckCatalogUserPermissionInspect()

			m.MinimockCheckNamespacePermissionInspect()

			m.MinimockCleanupFileInspect()

			m.MinimockCleanupKnowledgeBaseInspect()

			m.MinimockCreateRepositoryTagInspect()

			m.MinimockCreateSystemAdminInspect()

			m.MinimockDeleteFilesInspect()

			m.MinimockDeleteRepositoryTagInspect()

			m.MinimockDeleteSystemAdminInspect()

			m.MinimockEmbedTextsInspect()

			m.MinimockExecuteKnowledgeBaseUpdateAdminInspect()

			m.MinimockGetChunksByFileInspect()

			m.MinimockGetConvertedFilePathsByFileUIDInspect()

			m.MinimockGetDefaultSystemAdminInspect()

			m.MinimockGetDownloadURLInspect()

			m.MinimockGetFilesByPathsInspect()

			m.MinimockGetKnowledgeBaseUpdateStatusAdminInspect()

			m.MinimockGetNamespaceAndCheckPermissionInspect()

			m.MinimockGetNamespaceByNsIDInspect()

			m.MinimockGetRepositoryTagInspect()

			m.MinimockGetSystemAdminInspect()

			m.MinimockGetTextChunkFilePathsByFileUIDInspect()

			m.MinimockGetUploadURLInspect()

			m.MinimockListRepositoryTagsInspect()

			m.MinimockListSystemsAdminInspect()

			m.MinimockPipelinePublicClientInspect()

			m.MinimockProcessFileInspect()

			m.MinimockProcessFileDualModeInspect()

			m.MinimockPurgeRollbackAdminInspect()

			m.MinimockRedisClientInspect()

			m.MinimockRenameSystemAdminInspect()

			m.MinimockRepositoryInspect()

			m.MinimockRollbackAdminInspect()

			m.MinimockSetDefaultSystemAdminInspect()

			m.MinimockSetRollbackRetentionAdminInspect()

			m.MinimockSimilarityChunksSearchInspect()

			m.MinimockUpdateSystemAdminInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockACLClientDone() &&
		m.MinimockAbortKnowledgeBaseUpdateAdminDone() &&
		m.MinimockCheckCatalogUserPermissionDone() &&
		m.MinimockCheckNamespacePermissionDone() &&
		m.MinimockCleanupFileDone() &&
		m.MinimockCleanupKnowledgeBaseDone() &&
		m.MinimockCreateRepositoryTagDone() &&
		m.MinimockCreateSystemAdminDone() &&
		m.MinimockDeleteFilesDone() &&
		m.MinimockDeleteRepositoryTagDone() &&
		m.MinimockDeleteSystemAdminDone() &&
		m.MinimockEmbedTextsDone() &&
		m.MinimockExecuteKnowledgeBaseUpdateAdminDone() &&
		m.MinimockGetChunksByFileDone() &&
		m.MinimockGetConvertedFilePathsByFileUIDDone() &&
		m.MinimockGetDefaultSystemAdminDone() &&
		m.MinimockGetDownloadURLDone() &&
		m.MinimockGetFilesByPathsDone() &&
		m.MinimockGetKnowledgeBaseUpdateStatusAdminDone() &&
		m.MinimockGetNamespaceAndCheckPermissionDone() &&
		m.MinimockGetNamespaceByNsIDDone() &&
		m.MinimockGetRepositoryTagDone() &&
		m.MinimockGetSystemAdminDone() &&
		m.MinimockGetTextChunkFilePathsByFileUIDDone() &&
		m.MinimockGetUploadURLDone() &&
		m.MinimockListRepositoryTagsDone() &&
		m.MinimockListSystemsAdminDone() &&
		m.MinimockPipelinePublicClientDone() &&
		m.MinimockProcessFileDone() &&
		m.MinimockProcessFileDualModeDone() &&
		m.MinimockPurgeRollbackAdminDone() &&
		m.MinimockRedisClientDone() &&
		m.MinimockRenameSystemAdminDone() &&
		m.MinimockRepositoryDone() &&
		m.MinimockRollbackAdminDone() &&
		m.MinimockSetDefaultSystemAdminDone() &&
		m.MinimockSetRollbackRetentionAdminDone() &&
		m.MinimockSimilarityChunksSearchDone() &&
		m.MinimockUpdateSystemAdminDone()
}
