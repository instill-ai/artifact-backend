// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gofrs/uuid"
	"github.com/gojuno/minimock/v3"
	mm_service "github.com/instill-ai/artifact-backend/pkg/service"
)

// VectorDatabaseMock implements mm_service.VectorDatabase
type VectorDatabaseMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCheckFileUIDMetadata          func(ctx context.Context, collectionID string) (b1 bool, err error)
	funcCheckFileUIDMetadataOrigin    string
	inspectFuncCheckFileUIDMetadata   func(ctx context.Context, collectionID string)
	afterCheckFileUIDMetadataCounter  uint64
	beforeCheckFileUIDMetadataCounter uint64
	CheckFileUIDMetadataMock          mVectorDatabaseMockCheckFileUIDMetadata

	funcCreateCollection          func(ctx context.Context, id string) (err error)
	funcCreateCollectionOrigin    string
	inspectFuncCreateCollection   func(ctx context.Context, id string)
	afterCreateCollectionCounter  uint64
	beforeCreateCollectionCounter uint64
	CreateCollectionMock          mVectorDatabaseMockCreateCollection

	funcDeleteEmbeddingsWithFileUID          func(ctx context.Context, collID string, fileUID uuid.UUID) (err error)
	funcDeleteEmbeddingsWithFileUIDOrigin    string
	inspectFuncDeleteEmbeddingsWithFileUID   func(ctx context.Context, collID string, fileUID uuid.UUID)
	afterDeleteEmbeddingsWithFileUIDCounter  uint64
	beforeDeleteEmbeddingsWithFileUIDCounter uint64
	DeleteEmbeddingsWithFileUIDMock          mVectorDatabaseMockDeleteEmbeddingsWithFileUID

	funcDropCollection          func(ctx context.Context, id string) (err error)
	funcDropCollectionOrigin    string
	inspectFuncDropCollection   func(ctx context.Context, id string)
	afterDropCollectionCounter  uint64
	beforeDropCollectionCounter uint64
	DropCollectionMock          mVectorDatabaseMockDropCollection

	funcFlushCollection          func(ctx context.Context, collectionID string) (err error)
	funcFlushCollectionOrigin    string
	inspectFuncFlushCollection   func(ctx context.Context, collectionID string)
	afterFlushCollectionCounter  uint64
	beforeFlushCollectionCounter uint64
	FlushCollectionMock          mVectorDatabaseMockFlushCollection

	funcInsertVectorsInCollection          func(ctx context.Context, collID string, embeddings []mm_service.Embedding) (err error)
	funcInsertVectorsInCollectionOrigin    string
	inspectFuncInsertVectorsInCollection   func(ctx context.Context, collID string, embeddings []mm_service.Embedding)
	afterInsertVectorsInCollectionCounter  uint64
	beforeInsertVectorsInCollectionCounter uint64
	InsertVectorsInCollectionMock          mVectorDatabaseMockInsertVectorsInCollection

	funcSimilarVectorsInCollection          func(ctx context.Context, s1 mm_service.SimilarVectorSearchParam) (saa1 [][]mm_service.SimilarEmbedding, err error)
	funcSimilarVectorsInCollectionOrigin    string
	inspectFuncSimilarVectorsInCollection   func(ctx context.Context, s1 mm_service.SimilarVectorSearchParam)
	afterSimilarVectorsInCollectionCounter  uint64
	beforeSimilarVectorsInCollectionCounter uint64
	SimilarVectorsInCollectionMock          mVectorDatabaseMockSimilarVectorsInCollection
}

// NewVectorDatabaseMock returns a mock for mm_service.VectorDatabase
func NewVectorDatabaseMock(t minimock.Tester) *VectorDatabaseMock {
	m := &VectorDatabaseMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckFileUIDMetadataMock = mVectorDatabaseMockCheckFileUIDMetadata{mock: m}
	m.CheckFileUIDMetadataMock.callArgs = []*VectorDatabaseMockCheckFileUIDMetadataParams{}

	m.CreateCollectionMock = mVectorDatabaseMockCreateCollection{mock: m}
	m.CreateCollectionMock.callArgs = []*VectorDatabaseMockCreateCollectionParams{}

	m.DeleteEmbeddingsWithFileUIDMock = mVectorDatabaseMockDeleteEmbeddingsWithFileUID{mock: m}
	m.DeleteEmbeddingsWithFileUIDMock.callArgs = []*VectorDatabaseMockDeleteEmbeddingsWithFileUIDParams{}

	m.DropCollectionMock = mVectorDatabaseMockDropCollection{mock: m}
	m.DropCollectionMock.callArgs = []*VectorDatabaseMockDropCollectionParams{}

	m.FlushCollectionMock = mVectorDatabaseMockFlushCollection{mock: m}
	m.FlushCollectionMock.callArgs = []*VectorDatabaseMockFlushCollectionParams{}

	m.InsertVectorsInCollectionMock = mVectorDatabaseMockInsertVectorsInCollection{mock: m}
	m.InsertVectorsInCollectionMock.callArgs = []*VectorDatabaseMockInsertVectorsInCollectionParams{}

	m.SimilarVectorsInCollectionMock = mVectorDatabaseMockSimilarVectorsInCollection{mock: m}
	m.SimilarVectorsInCollectionMock.callArgs = []*VectorDatabaseMockSimilarVectorsInCollectionParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mVectorDatabaseMockCheckFileUIDMetadata struct {
	optional           bool
	mock               *VectorDatabaseMock
	defaultExpectation *VectorDatabaseMockCheckFileUIDMetadataExpectation
	expectations       []*VectorDatabaseMockCheckFileUIDMetadataExpectation

	callArgs []*VectorDatabaseMockCheckFileUIDMetadataParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// VectorDatabaseMockCheckFileUIDMetadataExpectation specifies expectation struct of the VectorDatabase.CheckFileUIDMetadata
type VectorDatabaseMockCheckFileUIDMetadataExpectation struct {
	mock               *VectorDatabaseMock
	params             *VectorDatabaseMockCheckFileUIDMetadataParams
	paramPtrs          *VectorDatabaseMockCheckFileUIDMetadataParamPtrs
	expectationOrigins VectorDatabaseMockCheckFileUIDMetadataExpectationOrigins
	results            *VectorDatabaseMockCheckFileUIDMetadataResults
	returnOrigin       string
	Counter            uint64
}

// VectorDatabaseMockCheckFileUIDMetadataParams contains parameters of the VectorDatabase.CheckFileUIDMetadata
type VectorDatabaseMockCheckFileUIDMetadataParams struct {
	ctx          context.Context
	collectionID string
}

// VectorDatabaseMockCheckFileUIDMetadataParamPtrs contains pointers to parameters of the VectorDatabase.CheckFileUIDMetadata
type VectorDatabaseMockCheckFileUIDMetadataParamPtrs struct {
	ctx          *context.Context
	collectionID *string
}

// VectorDatabaseMockCheckFileUIDMetadataResults contains results of the VectorDatabase.CheckFileUIDMetadata
type VectorDatabaseMockCheckFileUIDMetadataResults struct {
	b1  bool
	err error
}

// VectorDatabaseMockCheckFileUIDMetadataOrigins contains origins of expectations of the VectorDatabase.CheckFileUIDMetadata
type VectorDatabaseMockCheckFileUIDMetadataExpectationOrigins struct {
	origin             string
	originCtx          string
	originCollectionID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckFileUIDMetadata *mVectorDatabaseMockCheckFileUIDMetadata) Optional() *mVectorDatabaseMockCheckFileUIDMetadata {
	mmCheckFileUIDMetadata.optional = true
	return mmCheckFileUIDMetadata
}

// Expect sets up expected params for VectorDatabase.CheckFileUIDMetadata
func (mmCheckFileUIDMetadata *mVectorDatabaseMockCheckFileUIDMetadata) Expect(ctx context.Context, collectionID string) *mVectorDatabaseMockCheckFileUIDMetadata {
	if mmCheckFileUIDMetadata.mock.funcCheckFileUIDMetadata != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("VectorDatabaseMock.CheckFileUIDMetadata mock is already set by Set")
	}

	if mmCheckFileUIDMetadata.defaultExpectation == nil {
		mmCheckFileUIDMetadata.defaultExpectation = &VectorDatabaseMockCheckFileUIDMetadataExpectation{}
	}

	if mmCheckFileUIDMetadata.defaultExpectation.paramPtrs != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("VectorDatabaseMock.CheckFileUIDMetadata mock is already set by ExpectParams functions")
	}

	mmCheckFileUIDMetadata.defaultExpectation.params = &VectorDatabaseMockCheckFileUIDMetadataParams{ctx, collectionID}
	mmCheckFileUIDMetadata.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckFileUIDMetadata.expectations {
		if minimock.Equal(e.params, mmCheckFileUIDMetadata.defaultExpectation.params) {
			mmCheckFileUIDMetadata.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckFileUIDMetadata.defaultExpectation.params)
		}
	}

	return mmCheckFileUIDMetadata
}

// ExpectCtxParam1 sets up expected param ctx for VectorDatabase.CheckFileUIDMetadata
func (mmCheckFileUIDMetadata *mVectorDatabaseMockCheckFileUIDMetadata) ExpectCtxParam1(ctx context.Context) *mVectorDatabaseMockCheckFileUIDMetadata {
	if mmCheckFileUIDMetadata.mock.funcCheckFileUIDMetadata != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("VectorDatabaseMock.CheckFileUIDMetadata mock is already set by Set")
	}

	if mmCheckFileUIDMetadata.defaultExpectation == nil {
		mmCheckFileUIDMetadata.defaultExpectation = &VectorDatabaseMockCheckFileUIDMetadataExpectation{}
	}

	if mmCheckFileUIDMetadata.defaultExpectation.params != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("VectorDatabaseMock.CheckFileUIDMetadata mock is already set by Expect")
	}

	if mmCheckFileUIDMetadata.defaultExpectation.paramPtrs == nil {
		mmCheckFileUIDMetadata.defaultExpectation.paramPtrs = &VectorDatabaseMockCheckFileUIDMetadataParamPtrs{}
	}
	mmCheckFileUIDMetadata.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckFileUIDMetadata.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckFileUIDMetadata
}

// ExpectCollectionIDParam2 sets up expected param collectionID for VectorDatabase.CheckFileUIDMetadata
func (mmCheckFileUIDMetadata *mVectorDatabaseMockCheckFileUIDMetadata) ExpectCollectionIDParam2(collectionID string) *mVectorDatabaseMockCheckFileUIDMetadata {
	if mmCheckFileUIDMetadata.mock.funcCheckFileUIDMetadata != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("VectorDatabaseMock.CheckFileUIDMetadata mock is already set by Set")
	}

	if mmCheckFileUIDMetadata.defaultExpectation == nil {
		mmCheckFileUIDMetadata.defaultExpectation = &VectorDatabaseMockCheckFileUIDMetadataExpectation{}
	}

	if mmCheckFileUIDMetadata.defaultExpectation.params != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("VectorDatabaseMock.CheckFileUIDMetadata mock is already set by Expect")
	}

	if mmCheckFileUIDMetadata.defaultExpectation.paramPtrs == nil {
		mmCheckFileUIDMetadata.defaultExpectation.paramPtrs = &VectorDatabaseMockCheckFileUIDMetadataParamPtrs{}
	}
	mmCheckFileUIDMetadata.defaultExpectation.paramPtrs.collectionID = &collectionID
	mmCheckFileUIDMetadata.defaultExpectation.expectationOrigins.originCollectionID = minimock.CallerInfo(1)

	return mmCheckFileUIDMetadata
}

// Inspect accepts an inspector function that has same arguments as the VectorDatabase.CheckFileUIDMetadata
func (mmCheckFileUIDMetadata *mVectorDatabaseMockCheckFileUIDMetadata) Inspect(f func(ctx context.Context, collectionID string)) *mVectorDatabaseMockCheckFileUIDMetadata {
	if mmCheckFileUIDMetadata.mock.inspectFuncCheckFileUIDMetadata != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("Inspect function is already set for VectorDatabaseMock.CheckFileUIDMetadata")
	}

	mmCheckFileUIDMetadata.mock.inspectFuncCheckFileUIDMetadata = f

	return mmCheckFileUIDMetadata
}

// Return sets up results that will be returned by VectorDatabase.CheckFileUIDMetadata
func (mmCheckFileUIDMetadata *mVectorDatabaseMockCheckFileUIDMetadata) Return(b1 bool, err error) *VectorDatabaseMock {
	if mmCheckFileUIDMetadata.mock.funcCheckFileUIDMetadata != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("VectorDatabaseMock.CheckFileUIDMetadata mock is already set by Set")
	}

	if mmCheckFileUIDMetadata.defaultExpectation == nil {
		mmCheckFileUIDMetadata.defaultExpectation = &VectorDatabaseMockCheckFileUIDMetadataExpectation{mock: mmCheckFileUIDMetadata.mock}
	}
	mmCheckFileUIDMetadata.defaultExpectation.results = &VectorDatabaseMockCheckFileUIDMetadataResults{b1, err}
	mmCheckFileUIDMetadata.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckFileUIDMetadata.mock
}

// Set uses given function f to mock the VectorDatabase.CheckFileUIDMetadata method
func (mmCheckFileUIDMetadata *mVectorDatabaseMockCheckFileUIDMetadata) Set(f func(ctx context.Context, collectionID string) (b1 bool, err error)) *VectorDatabaseMock {
	if mmCheckFileUIDMetadata.defaultExpectation != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("Default expectation is already set for the VectorDatabase.CheckFileUIDMetadata method")
	}

	if len(mmCheckFileUIDMetadata.expectations) > 0 {
		mmCheckFileUIDMetadata.mock.t.Fatalf("Some expectations are already set for the VectorDatabase.CheckFileUIDMetadata method")
	}

	mmCheckFileUIDMetadata.mock.funcCheckFileUIDMetadata = f
	mmCheckFileUIDMetadata.mock.funcCheckFileUIDMetadataOrigin = minimock.CallerInfo(1)
	return mmCheckFileUIDMetadata.mock
}

// When sets expectation for the VectorDatabase.CheckFileUIDMetadata which will trigger the result defined by the following
// Then helper
func (mmCheckFileUIDMetadata *mVectorDatabaseMockCheckFileUIDMetadata) When(ctx context.Context, collectionID string) *VectorDatabaseMockCheckFileUIDMetadataExpectation {
	if mmCheckFileUIDMetadata.mock.funcCheckFileUIDMetadata != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("VectorDatabaseMock.CheckFileUIDMetadata mock is already set by Set")
	}

	expectation := &VectorDatabaseMockCheckFileUIDMetadataExpectation{
		mock:               mmCheckFileUIDMetadata.mock,
		params:             &VectorDatabaseMockCheckFileUIDMetadataParams{ctx, collectionID},
		expectationOrigins: VectorDatabaseMockCheckFileUIDMetadataExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckFileUIDMetadata.expectations = append(mmCheckFileUIDMetadata.expectations, expectation)
	return expectation
}

// Then sets up VectorDatabase.CheckFileUIDMetadata return parameters for the expectation previously defined by the When method
func (e *VectorDatabaseMockCheckFileUIDMetadataExpectation) Then(b1 bool, err error) *VectorDatabaseMock {
	e.results = &VectorDatabaseMockCheckFileUIDMetadataResults{b1, err}
	return e.mock
}

// Times sets number of times VectorDatabase.CheckFileUIDMetadata should be invoked
func (mmCheckFileUIDMetadata *mVectorDatabaseMockCheckFileUIDMetadata) Times(n uint64) *mVectorDatabaseMockCheckFileUIDMetadata {
	if n == 0 {
		mmCheckFileUIDMetadata.mock.t.Fatalf("Times of VectorDatabaseMock.CheckFileUIDMetadata mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckFileUIDMetadata.expectedInvocations, n)
	mmCheckFileUIDMetadata.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckFileUIDMetadata
}

func (mmCheckFileUIDMetadata *mVectorDatabaseMockCheckFileUIDMetadata) invocationsDone() bool {
	if len(mmCheckFileUIDMetadata.expectations) == 0 && mmCheckFileUIDMetadata.defaultExpectation == nil && mmCheckFileUIDMetadata.mock.funcCheckFileUIDMetadata == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckFileUIDMetadata.mock.afterCheckFileUIDMetadataCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckFileUIDMetadata.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckFileUIDMetadata implements mm_service.VectorDatabase
func (mmCheckFileUIDMetadata *VectorDatabaseMock) CheckFileUIDMetadata(ctx context.Context, collectionID string) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmCheckFileUIDMetadata.beforeCheckFileUIDMetadataCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckFileUIDMetadata.afterCheckFileUIDMetadataCounter, 1)

	mmCheckFileUIDMetadata.t.Helper()

	if mmCheckFileUIDMetadata.inspectFuncCheckFileUIDMetadata != nil {
		mmCheckFileUIDMetadata.inspectFuncCheckFileUIDMetadata(ctx, collectionID)
	}

	mm_params := VectorDatabaseMockCheckFileUIDMetadataParams{ctx, collectionID}

	// Record call args
	mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.mutex.Lock()
	mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.callArgs = append(mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.callArgs, &mm_params)
	mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.mutex.Unlock()

	for _, e := range mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.defaultExpectation.params
		mm_want_ptrs := mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.defaultExpectation.paramPtrs

		mm_got := VectorDatabaseMockCheckFileUIDMetadataParams{ctx, collectionID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckFileUIDMetadata.t.Errorf("VectorDatabaseMock.CheckFileUIDMetadata got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.collectionID != nil && !minimock.Equal(*mm_want_ptrs.collectionID, mm_got.collectionID) {
				mmCheckFileUIDMetadata.t.Errorf("VectorDatabaseMock.CheckFileUIDMetadata got unexpected parameter collectionID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.defaultExpectation.expectationOrigins.originCollectionID, *mm_want_ptrs.collectionID, mm_got.collectionID, minimock.Diff(*mm_want_ptrs.collectionID, mm_got.collectionID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckFileUIDMetadata.t.Errorf("VectorDatabaseMock.CheckFileUIDMetadata got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckFileUIDMetadata.t.Fatal("No results are set for the VectorDatabaseMock.CheckFileUIDMetadata")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmCheckFileUIDMetadata.funcCheckFileUIDMetadata != nil {
		return mmCheckFileUIDMetadata.funcCheckFileUIDMetadata(ctx, collectionID)
	}
	mmCheckFileUIDMetadata.t.Fatalf("Unexpected call to VectorDatabaseMock.CheckFileUIDMetadata. %v %v", ctx, collectionID)
	return
}

// CheckFileUIDMetadataAfterCounter returns a count of finished VectorDatabaseMock.CheckFileUIDMetadata invocations
func (mmCheckFileUIDMetadata *VectorDatabaseMock) CheckFileUIDMetadataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckFileUIDMetadata.afterCheckFileUIDMetadataCounter)
}

// CheckFileUIDMetadataBeforeCounter returns a count of VectorDatabaseMock.CheckFileUIDMetadata invocations
func (mmCheckFileUIDMetadata *VectorDatabaseMock) CheckFileUIDMetadataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckFileUIDMetadata.beforeCheckFileUIDMetadataCounter)
}

// Calls returns a list of arguments used in each call to VectorDatabaseMock.CheckFileUIDMetadata.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckFileUIDMetadata *mVectorDatabaseMockCheckFileUIDMetadata) Calls() []*VectorDatabaseMockCheckFileUIDMetadataParams {
	mmCheckFileUIDMetadata.mutex.RLock()

	argCopy := make([]*VectorDatabaseMockCheckFileUIDMetadataParams, len(mmCheckFileUIDMetadata.callArgs))
	copy(argCopy, mmCheckFileUIDMetadata.callArgs)

	mmCheckFileUIDMetadata.mutex.RUnlock()

	return argCopy
}

// MinimockCheckFileUIDMetadataDone returns true if the count of the CheckFileUIDMetadata invocations corresponds
// the number of defined expectations
func (m *VectorDatabaseMock) MinimockCheckFileUIDMetadataDone() bool {
	if m.CheckFileUIDMetadataMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckFileUIDMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckFileUIDMetadataMock.invocationsDone()
}

// MinimockCheckFileUIDMetadataInspect logs each unmet expectation
func (m *VectorDatabaseMock) MinimockCheckFileUIDMetadataInspect() {
	for _, e := range m.CheckFileUIDMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to VectorDatabaseMock.CheckFileUIDMetadata at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckFileUIDMetadataCounter := mm_atomic.LoadUint64(&m.afterCheckFileUIDMetadataCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckFileUIDMetadataMock.defaultExpectation != nil && afterCheckFileUIDMetadataCounter < 1 {
		if m.CheckFileUIDMetadataMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to VectorDatabaseMock.CheckFileUIDMetadata at\n%s", m.CheckFileUIDMetadataMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to VectorDatabaseMock.CheckFileUIDMetadata at\n%s with params: %#v", m.CheckFileUIDMetadataMock.defaultExpectation.expectationOrigins.origin, *m.CheckFileUIDMetadataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckFileUIDMetadata != nil && afterCheckFileUIDMetadataCounter < 1 {
		m.t.Errorf("Expected call to VectorDatabaseMock.CheckFileUIDMetadata at\n%s", m.funcCheckFileUIDMetadataOrigin)
	}

	if !m.CheckFileUIDMetadataMock.invocationsDone() && afterCheckFileUIDMetadataCounter > 0 {
		m.t.Errorf("Expected %d calls to VectorDatabaseMock.CheckFileUIDMetadata at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckFileUIDMetadataMock.expectedInvocations), m.CheckFileUIDMetadataMock.expectedInvocationsOrigin, afterCheckFileUIDMetadataCounter)
	}
}

type mVectorDatabaseMockCreateCollection struct {
	optional           bool
	mock               *VectorDatabaseMock
	defaultExpectation *VectorDatabaseMockCreateCollectionExpectation
	expectations       []*VectorDatabaseMockCreateCollectionExpectation

	callArgs []*VectorDatabaseMockCreateCollectionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// VectorDatabaseMockCreateCollectionExpectation specifies expectation struct of the VectorDatabase.CreateCollection
type VectorDatabaseMockCreateCollectionExpectation struct {
	mock               *VectorDatabaseMock
	params             *VectorDatabaseMockCreateCollectionParams
	paramPtrs          *VectorDatabaseMockCreateCollectionParamPtrs
	expectationOrigins VectorDatabaseMockCreateCollectionExpectationOrigins
	results            *VectorDatabaseMockCreateCollectionResults
	returnOrigin       string
	Counter            uint64
}

// VectorDatabaseMockCreateCollectionParams contains parameters of the VectorDatabase.CreateCollection
type VectorDatabaseMockCreateCollectionParams struct {
	ctx context.Context
	id  string
}

// VectorDatabaseMockCreateCollectionParamPtrs contains pointers to parameters of the VectorDatabase.CreateCollection
type VectorDatabaseMockCreateCollectionParamPtrs struct {
	ctx *context.Context
	id  *string
}

// VectorDatabaseMockCreateCollectionResults contains results of the VectorDatabase.CreateCollection
type VectorDatabaseMockCreateCollectionResults struct {
	err error
}

// VectorDatabaseMockCreateCollectionOrigins contains origins of expectations of the VectorDatabase.CreateCollection
type VectorDatabaseMockCreateCollectionExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateCollection *mVectorDatabaseMockCreateCollection) Optional() *mVectorDatabaseMockCreateCollection {
	mmCreateCollection.optional = true
	return mmCreateCollection
}

// Expect sets up expected params for VectorDatabase.CreateCollection
func (mmCreateCollection *mVectorDatabaseMockCreateCollection) Expect(ctx context.Context, id string) *mVectorDatabaseMockCreateCollection {
	if mmCreateCollection.mock.funcCreateCollection != nil {
		mmCreateCollection.mock.t.Fatalf("VectorDatabaseMock.CreateCollection mock is already set by Set")
	}

	if mmCreateCollection.defaultExpectation == nil {
		mmCreateCollection.defaultExpectation = &VectorDatabaseMockCreateCollectionExpectation{}
	}

	if mmCreateCollection.defaultExpectation.paramPtrs != nil {
		mmCreateCollection.mock.t.Fatalf("VectorDatabaseMock.CreateCollection mock is already set by ExpectParams functions")
	}

	mmCreateCollection.defaultExpectation.params = &VectorDatabaseMockCreateCollectionParams{ctx, id}
	mmCreateCollection.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateCollection.expectations {
		if minimock.Equal(e.params, mmCreateCollection.defaultExpectation.params) {
			mmCreateCollection.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateCollection.defaultExpectation.params)
		}
	}

	return mmCreateCollection
}

// ExpectCtxParam1 sets up expected param ctx for VectorDatabase.CreateCollection
func (mmCreateCollection *mVectorDatabaseMockCreateCollection) ExpectCtxParam1(ctx context.Context) *mVectorDatabaseMockCreateCollection {
	if mmCreateCollection.mock.funcCreateCollection != nil {
		mmCreateCollection.mock.t.Fatalf("VectorDatabaseMock.CreateCollection mock is already set by Set")
	}

	if mmCreateCollection.defaultExpectation == nil {
		mmCreateCollection.defaultExpectation = &VectorDatabaseMockCreateCollectionExpectation{}
	}

	if mmCreateCollection.defaultExpectation.params != nil {
		mmCreateCollection.mock.t.Fatalf("VectorDatabaseMock.CreateCollection mock is already set by Expect")
	}

	if mmCreateCollection.defaultExpectation.paramPtrs == nil {
		mmCreateCollection.defaultExpectation.paramPtrs = &VectorDatabaseMockCreateCollectionParamPtrs{}
	}
	mmCreateCollection.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateCollection.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateCollection
}

// ExpectIdParam2 sets up expected param id for VectorDatabase.CreateCollection
func (mmCreateCollection *mVectorDatabaseMockCreateCollection) ExpectIdParam2(id string) *mVectorDatabaseMockCreateCollection {
	if mmCreateCollection.mock.funcCreateCollection != nil {
		mmCreateCollection.mock.t.Fatalf("VectorDatabaseMock.CreateCollection mock is already set by Set")
	}

	if mmCreateCollection.defaultExpectation == nil {
		mmCreateCollection.defaultExpectation = &VectorDatabaseMockCreateCollectionExpectation{}
	}

	if mmCreateCollection.defaultExpectation.params != nil {
		mmCreateCollection.mock.t.Fatalf("VectorDatabaseMock.CreateCollection mock is already set by Expect")
	}

	if mmCreateCollection.defaultExpectation.paramPtrs == nil {
		mmCreateCollection.defaultExpectation.paramPtrs = &VectorDatabaseMockCreateCollectionParamPtrs{}
	}
	mmCreateCollection.defaultExpectation.paramPtrs.id = &id
	mmCreateCollection.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmCreateCollection
}

// Inspect accepts an inspector function that has same arguments as the VectorDatabase.CreateCollection
func (mmCreateCollection *mVectorDatabaseMockCreateCollection) Inspect(f func(ctx context.Context, id string)) *mVectorDatabaseMockCreateCollection {
	if mmCreateCollection.mock.inspectFuncCreateCollection != nil {
		mmCreateCollection.mock.t.Fatalf("Inspect function is already set for VectorDatabaseMock.CreateCollection")
	}

	mmCreateCollection.mock.inspectFuncCreateCollection = f

	return mmCreateCollection
}

// Return sets up results that will be returned by VectorDatabase.CreateCollection
func (mmCreateCollection *mVectorDatabaseMockCreateCollection) Return(err error) *VectorDatabaseMock {
	if mmCreateCollection.mock.funcCreateCollection != nil {
		mmCreateCollection.mock.t.Fatalf("VectorDatabaseMock.CreateCollection mock is already set by Set")
	}

	if mmCreateCollection.defaultExpectation == nil {
		mmCreateCollection.defaultExpectation = &VectorDatabaseMockCreateCollectionExpectation{mock: mmCreateCollection.mock}
	}
	mmCreateCollection.defaultExpectation.results = &VectorDatabaseMockCreateCollectionResults{err}
	mmCreateCollection.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateCollection.mock
}

// Set uses given function f to mock the VectorDatabase.CreateCollection method
func (mmCreateCollection *mVectorDatabaseMockCreateCollection) Set(f func(ctx context.Context, id string) (err error)) *VectorDatabaseMock {
	if mmCreateCollection.defaultExpectation != nil {
		mmCreateCollection.mock.t.Fatalf("Default expectation is already set for the VectorDatabase.CreateCollection method")
	}

	if len(mmCreateCollection.expectations) > 0 {
		mmCreateCollection.mock.t.Fatalf("Some expectations are already set for the VectorDatabase.CreateCollection method")
	}

	mmCreateCollection.mock.funcCreateCollection = f
	mmCreateCollection.mock.funcCreateCollectionOrigin = minimock.CallerInfo(1)
	return mmCreateCollection.mock
}

// When sets expectation for the VectorDatabase.CreateCollection which will trigger the result defined by the following
// Then helper
func (mmCreateCollection *mVectorDatabaseMockCreateCollection) When(ctx context.Context, id string) *VectorDatabaseMockCreateCollectionExpectation {
	if mmCreateCollection.mock.funcCreateCollection != nil {
		mmCreateCollection.mock.t.Fatalf("VectorDatabaseMock.CreateCollection mock is already set by Set")
	}

	expectation := &VectorDatabaseMockCreateCollectionExpectation{
		mock:               mmCreateCollection.mock,
		params:             &VectorDatabaseMockCreateCollectionParams{ctx, id},
		expectationOrigins: VectorDatabaseMockCreateCollectionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateCollection.expectations = append(mmCreateCollection.expectations, expectation)
	return expectation
}

// Then sets up VectorDatabase.CreateCollection return parameters for the expectation previously defined by the When method
func (e *VectorDatabaseMockCreateCollectionExpectation) Then(err error) *VectorDatabaseMock {
	e.results = &VectorDatabaseMockCreateCollectionResults{err}
	return e.mock
}

// Times sets number of times VectorDatabase.CreateCollection should be invoked
func (mmCreateCollection *mVectorDatabaseMockCreateCollection) Times(n uint64) *mVectorDatabaseMockCreateCollection {
	if n == 0 {
		mmCreateCollection.mock.t.Fatalf("Times of VectorDatabaseMock.CreateCollection mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateCollection.expectedInvocations, n)
	mmCreateCollection.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateCollection
}

func (mmCreateCollection *mVectorDatabaseMockCreateCollection) invocationsDone() bool {
	if len(mmCreateCollection.expectations) == 0 && mmCreateCollection.defaultExpectation == nil && mmCreateCollection.mock.funcCreateCollection == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateCollection.mock.afterCreateCollectionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateCollection.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateCollection implements mm_service.VectorDatabase
func (mmCreateCollection *VectorDatabaseMock) CreateCollection(ctx context.Context, id string) (err error) {
	mm_atomic.AddUint64(&mmCreateCollection.beforeCreateCollectionCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateCollection.afterCreateCollectionCounter, 1)

	mmCreateCollection.t.Helper()

	if mmCreateCollection.inspectFuncCreateCollection != nil {
		mmCreateCollection.inspectFuncCreateCollection(ctx, id)
	}

	mm_params := VectorDatabaseMockCreateCollectionParams{ctx, id}

	// Record call args
	mmCreateCollection.CreateCollectionMock.mutex.Lock()
	mmCreateCollection.CreateCollectionMock.callArgs = append(mmCreateCollection.CreateCollectionMock.callArgs, &mm_params)
	mmCreateCollection.CreateCollectionMock.mutex.Unlock()

	for _, e := range mmCreateCollection.CreateCollectionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateCollection.CreateCollectionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateCollection.CreateCollectionMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateCollection.CreateCollectionMock.defaultExpectation.params
		mm_want_ptrs := mmCreateCollection.CreateCollectionMock.defaultExpectation.paramPtrs

		mm_got := VectorDatabaseMockCreateCollectionParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateCollection.t.Errorf("VectorDatabaseMock.CreateCollection got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCollection.CreateCollectionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmCreateCollection.t.Errorf("VectorDatabaseMock.CreateCollection got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCollection.CreateCollectionMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateCollection.t.Errorf("VectorDatabaseMock.CreateCollection got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateCollection.CreateCollectionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateCollection.CreateCollectionMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateCollection.t.Fatal("No results are set for the VectorDatabaseMock.CreateCollection")
		}
		return (*mm_results).err
	}
	if mmCreateCollection.funcCreateCollection != nil {
		return mmCreateCollection.funcCreateCollection(ctx, id)
	}
	mmCreateCollection.t.Fatalf("Unexpected call to VectorDatabaseMock.CreateCollection. %v %v", ctx, id)
	return
}

// CreateCollectionAfterCounter returns a count of finished VectorDatabaseMock.CreateCollection invocations
func (mmCreateCollection *VectorDatabaseMock) CreateCollectionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCollection.afterCreateCollectionCounter)
}

// CreateCollectionBeforeCounter returns a count of VectorDatabaseMock.CreateCollection invocations
func (mmCreateCollection *VectorDatabaseMock) CreateCollectionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCollection.beforeCreateCollectionCounter)
}

// Calls returns a list of arguments used in each call to VectorDatabaseMock.CreateCollection.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateCollection *mVectorDatabaseMockCreateCollection) Calls() []*VectorDatabaseMockCreateCollectionParams {
	mmCreateCollection.mutex.RLock()

	argCopy := make([]*VectorDatabaseMockCreateCollectionParams, len(mmCreateCollection.callArgs))
	copy(argCopy, mmCreateCollection.callArgs)

	mmCreateCollection.mutex.RUnlock()

	return argCopy
}

// MinimockCreateCollectionDone returns true if the count of the CreateCollection invocations corresponds
// the number of defined expectations
func (m *VectorDatabaseMock) MinimockCreateCollectionDone() bool {
	if m.CreateCollectionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateCollectionMock.invocationsDone()
}

// MinimockCreateCollectionInspect logs each unmet expectation
func (m *VectorDatabaseMock) MinimockCreateCollectionInspect() {
	for _, e := range m.CreateCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to VectorDatabaseMock.CreateCollection at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCollectionCounter := mm_atomic.LoadUint64(&m.afterCreateCollectionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateCollectionMock.defaultExpectation != nil && afterCreateCollectionCounter < 1 {
		if m.CreateCollectionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to VectorDatabaseMock.CreateCollection at\n%s", m.CreateCollectionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to VectorDatabaseMock.CreateCollection at\n%s with params: %#v", m.CreateCollectionMock.defaultExpectation.expectationOrigins.origin, *m.CreateCollectionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateCollection != nil && afterCreateCollectionCounter < 1 {
		m.t.Errorf("Expected call to VectorDatabaseMock.CreateCollection at\n%s", m.funcCreateCollectionOrigin)
	}

	if !m.CreateCollectionMock.invocationsDone() && afterCreateCollectionCounter > 0 {
		m.t.Errorf("Expected %d calls to VectorDatabaseMock.CreateCollection at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateCollectionMock.expectedInvocations), m.CreateCollectionMock.expectedInvocationsOrigin, afterCreateCollectionCounter)
	}
}

type mVectorDatabaseMockDeleteEmbeddingsWithFileUID struct {
	optional           bool
	mock               *VectorDatabaseMock
	defaultExpectation *VectorDatabaseMockDeleteEmbeddingsWithFileUIDExpectation
	expectations       []*VectorDatabaseMockDeleteEmbeddingsWithFileUIDExpectation

	callArgs []*VectorDatabaseMockDeleteEmbeddingsWithFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// VectorDatabaseMockDeleteEmbeddingsWithFileUIDExpectation specifies expectation struct of the VectorDatabase.DeleteEmbeddingsWithFileUID
type VectorDatabaseMockDeleteEmbeddingsWithFileUIDExpectation struct {
	mock               *VectorDatabaseMock
	params             *VectorDatabaseMockDeleteEmbeddingsWithFileUIDParams
	paramPtrs          *VectorDatabaseMockDeleteEmbeddingsWithFileUIDParamPtrs
	expectationOrigins VectorDatabaseMockDeleteEmbeddingsWithFileUIDExpectationOrigins
	results            *VectorDatabaseMockDeleteEmbeddingsWithFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// VectorDatabaseMockDeleteEmbeddingsWithFileUIDParams contains parameters of the VectorDatabase.DeleteEmbeddingsWithFileUID
type VectorDatabaseMockDeleteEmbeddingsWithFileUIDParams struct {
	ctx     context.Context
	collID  string
	fileUID uuid.UUID
}

// VectorDatabaseMockDeleteEmbeddingsWithFileUIDParamPtrs contains pointers to parameters of the VectorDatabase.DeleteEmbeddingsWithFileUID
type VectorDatabaseMockDeleteEmbeddingsWithFileUIDParamPtrs struct {
	ctx     *context.Context
	collID  *string
	fileUID *uuid.UUID
}

// VectorDatabaseMockDeleteEmbeddingsWithFileUIDResults contains results of the VectorDatabase.DeleteEmbeddingsWithFileUID
type VectorDatabaseMockDeleteEmbeddingsWithFileUIDResults struct {
	err error
}

// VectorDatabaseMockDeleteEmbeddingsWithFileUIDOrigins contains origins of expectations of the VectorDatabase.DeleteEmbeddingsWithFileUID
type VectorDatabaseMockDeleteEmbeddingsWithFileUIDExpectationOrigins struct {
	origin        string
	originCtx     string
	originCollID  string
	originFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteEmbeddingsWithFileUID *mVectorDatabaseMockDeleteEmbeddingsWithFileUID) Optional() *mVectorDatabaseMockDeleteEmbeddingsWithFileUID {
	mmDeleteEmbeddingsWithFileUID.optional = true
	return mmDeleteEmbeddingsWithFileUID
}

// Expect sets up expected params for VectorDatabase.DeleteEmbeddingsWithFileUID
func (mmDeleteEmbeddingsWithFileUID *mVectorDatabaseMockDeleteEmbeddingsWithFileUID) Expect(ctx context.Context, collID string, fileUID uuid.UUID) *mVectorDatabaseMockDeleteEmbeddingsWithFileUID {
	if mmDeleteEmbeddingsWithFileUID.mock.funcDeleteEmbeddingsWithFileUID != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("VectorDatabaseMock.DeleteEmbeddingsWithFileUID mock is already set by Set")
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation == nil {
		mmDeleteEmbeddingsWithFileUID.defaultExpectation = &VectorDatabaseMockDeleteEmbeddingsWithFileUIDExpectation{}
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("VectorDatabaseMock.DeleteEmbeddingsWithFileUID mock is already set by ExpectParams functions")
	}

	mmDeleteEmbeddingsWithFileUID.defaultExpectation.params = &VectorDatabaseMockDeleteEmbeddingsWithFileUIDParams{ctx, collID, fileUID}
	mmDeleteEmbeddingsWithFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteEmbeddingsWithFileUID.expectations {
		if minimock.Equal(e.params, mmDeleteEmbeddingsWithFileUID.defaultExpectation.params) {
			mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteEmbeddingsWithFileUID.defaultExpectation.params)
		}
	}

	return mmDeleteEmbeddingsWithFileUID
}

// ExpectCtxParam1 sets up expected param ctx for VectorDatabase.DeleteEmbeddingsWithFileUID
func (mmDeleteEmbeddingsWithFileUID *mVectorDatabaseMockDeleteEmbeddingsWithFileUID) ExpectCtxParam1(ctx context.Context) *mVectorDatabaseMockDeleteEmbeddingsWithFileUID {
	if mmDeleteEmbeddingsWithFileUID.mock.funcDeleteEmbeddingsWithFileUID != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("VectorDatabaseMock.DeleteEmbeddingsWithFileUID mock is already set by Set")
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation == nil {
		mmDeleteEmbeddingsWithFileUID.defaultExpectation = &VectorDatabaseMockDeleteEmbeddingsWithFileUIDExpectation{}
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation.params != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("VectorDatabaseMock.DeleteEmbeddingsWithFileUID mock is already set by Expect")
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs == nil {
		mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs = &VectorDatabaseMockDeleteEmbeddingsWithFileUIDParamPtrs{}
	}
	mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteEmbeddingsWithFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteEmbeddingsWithFileUID
}

// ExpectCollIDParam2 sets up expected param collID for VectorDatabase.DeleteEmbeddingsWithFileUID
func (mmDeleteEmbeddingsWithFileUID *mVectorDatabaseMockDeleteEmbeddingsWithFileUID) ExpectCollIDParam2(collID string) *mVectorDatabaseMockDeleteEmbeddingsWithFileUID {
	if mmDeleteEmbeddingsWithFileUID.mock.funcDeleteEmbeddingsWithFileUID != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("VectorDatabaseMock.DeleteEmbeddingsWithFileUID mock is already set by Set")
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation == nil {
		mmDeleteEmbeddingsWithFileUID.defaultExpectation = &VectorDatabaseMockDeleteEmbeddingsWithFileUIDExpectation{}
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation.params != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("VectorDatabaseMock.DeleteEmbeddingsWithFileUID mock is already set by Expect")
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs == nil {
		mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs = &VectorDatabaseMockDeleteEmbeddingsWithFileUIDParamPtrs{}
	}
	mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs.collID = &collID
	mmDeleteEmbeddingsWithFileUID.defaultExpectation.expectationOrigins.originCollID = minimock.CallerInfo(1)

	return mmDeleteEmbeddingsWithFileUID
}

// ExpectFileUIDParam3 sets up expected param fileUID for VectorDatabase.DeleteEmbeddingsWithFileUID
func (mmDeleteEmbeddingsWithFileUID *mVectorDatabaseMockDeleteEmbeddingsWithFileUID) ExpectFileUIDParam3(fileUID uuid.UUID) *mVectorDatabaseMockDeleteEmbeddingsWithFileUID {
	if mmDeleteEmbeddingsWithFileUID.mock.funcDeleteEmbeddingsWithFileUID != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("VectorDatabaseMock.DeleteEmbeddingsWithFileUID mock is already set by Set")
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation == nil {
		mmDeleteEmbeddingsWithFileUID.defaultExpectation = &VectorDatabaseMockDeleteEmbeddingsWithFileUIDExpectation{}
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation.params != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("VectorDatabaseMock.DeleteEmbeddingsWithFileUID mock is already set by Expect")
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs == nil {
		mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs = &VectorDatabaseMockDeleteEmbeddingsWithFileUIDParamPtrs{}
	}
	mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmDeleteEmbeddingsWithFileUID.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmDeleteEmbeddingsWithFileUID
}

// Inspect accepts an inspector function that has same arguments as the VectorDatabase.DeleteEmbeddingsWithFileUID
func (mmDeleteEmbeddingsWithFileUID *mVectorDatabaseMockDeleteEmbeddingsWithFileUID) Inspect(f func(ctx context.Context, collID string, fileUID uuid.UUID)) *mVectorDatabaseMockDeleteEmbeddingsWithFileUID {
	if mmDeleteEmbeddingsWithFileUID.mock.inspectFuncDeleteEmbeddingsWithFileUID != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("Inspect function is already set for VectorDatabaseMock.DeleteEmbeddingsWithFileUID")
	}

	mmDeleteEmbeddingsWithFileUID.mock.inspectFuncDeleteEmbeddingsWithFileUID = f

	return mmDeleteEmbeddingsWithFileUID
}

// Return sets up results that will be returned by VectorDatabase.DeleteEmbeddingsWithFileUID
func (mmDeleteEmbeddingsWithFileUID *mVectorDatabaseMockDeleteEmbeddingsWithFileUID) Return(err error) *VectorDatabaseMock {
	if mmDeleteEmbeddingsWithFileUID.mock.funcDeleteEmbeddingsWithFileUID != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("VectorDatabaseMock.DeleteEmbeddingsWithFileUID mock is already set by Set")
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation == nil {
		mmDeleteEmbeddingsWithFileUID.defaultExpectation = &VectorDatabaseMockDeleteEmbeddingsWithFileUIDExpectation{mock: mmDeleteEmbeddingsWithFileUID.mock}
	}
	mmDeleteEmbeddingsWithFileUID.defaultExpectation.results = &VectorDatabaseMockDeleteEmbeddingsWithFileUIDResults{err}
	mmDeleteEmbeddingsWithFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteEmbeddingsWithFileUID.mock
}

// Set uses given function f to mock the VectorDatabase.DeleteEmbeddingsWithFileUID method
func (mmDeleteEmbeddingsWithFileUID *mVectorDatabaseMockDeleteEmbeddingsWithFileUID) Set(f func(ctx context.Context, collID string, fileUID uuid.UUID) (err error)) *VectorDatabaseMock {
	if mmDeleteEmbeddingsWithFileUID.defaultExpectation != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("Default expectation is already set for the VectorDatabase.DeleteEmbeddingsWithFileUID method")
	}

	if len(mmDeleteEmbeddingsWithFileUID.expectations) > 0 {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("Some expectations are already set for the VectorDatabase.DeleteEmbeddingsWithFileUID method")
	}

	mmDeleteEmbeddingsWithFileUID.mock.funcDeleteEmbeddingsWithFileUID = f
	mmDeleteEmbeddingsWithFileUID.mock.funcDeleteEmbeddingsWithFileUIDOrigin = minimock.CallerInfo(1)
	return mmDeleteEmbeddingsWithFileUID.mock
}

// When sets expectation for the VectorDatabase.DeleteEmbeddingsWithFileUID which will trigger the result defined by the following
// Then helper
func (mmDeleteEmbeddingsWithFileUID *mVectorDatabaseMockDeleteEmbeddingsWithFileUID) When(ctx context.Context, collID string, fileUID uuid.UUID) *VectorDatabaseMockDeleteEmbeddingsWithFileUIDExpectation {
	if mmDeleteEmbeddingsWithFileUID.mock.funcDeleteEmbeddingsWithFileUID != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("VectorDatabaseMock.DeleteEmbeddingsWithFileUID mock is already set by Set")
	}

	expectation := &VectorDatabaseMockDeleteEmbeddingsWithFileUIDExpectation{
		mock:               mmDeleteEmbeddingsWithFileUID.mock,
		params:             &VectorDatabaseMockDeleteEmbeddingsWithFileUIDParams{ctx, collID, fileUID},
		expectationOrigins: VectorDatabaseMockDeleteEmbeddingsWithFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteEmbeddingsWithFileUID.expectations = append(mmDeleteEmbeddingsWithFileUID.expectations, expectation)
	return expectation
}

// Then sets up VectorDatabase.DeleteEmbeddingsWithFileUID return parameters for the expectation previously defined by the When method
func (e *VectorDatabaseMockDeleteEmbeddingsWithFileUIDExpectation) Then(err error) *VectorDatabaseMock {
	e.results = &VectorDatabaseMockDeleteEmbeddingsWithFileUIDResults{err}
	return e.mock
}

// Times sets number of times VectorDatabase.DeleteEmbeddingsWithFileUID should be invoked
func (mmDeleteEmbeddingsWithFileUID *mVectorDatabaseMockDeleteEmbeddingsWithFileUID) Times(n uint64) *mVectorDatabaseMockDeleteEmbeddingsWithFileUID {
	if n == 0 {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("Times of VectorDatabaseMock.DeleteEmbeddingsWithFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteEmbeddingsWithFileUID.expectedInvocations, n)
	mmDeleteEmbeddingsWithFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteEmbeddingsWithFileUID
}

func (mmDeleteEmbeddingsWithFileUID *mVectorDatabaseMockDeleteEmbeddingsWithFileUID) invocationsDone() bool {
	if len(mmDeleteEmbeddingsWithFileUID.expectations) == 0 && mmDeleteEmbeddingsWithFileUID.defaultExpectation == nil && mmDeleteEmbeddingsWithFileUID.mock.funcDeleteEmbeddingsWithFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteEmbeddingsWithFileUID.mock.afterDeleteEmbeddingsWithFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteEmbeddingsWithFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteEmbeddingsWithFileUID implements mm_service.VectorDatabase
func (mmDeleteEmbeddingsWithFileUID *VectorDatabaseMock) DeleteEmbeddingsWithFileUID(ctx context.Context, collID string, fileUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteEmbeddingsWithFileUID.beforeDeleteEmbeddingsWithFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteEmbeddingsWithFileUID.afterDeleteEmbeddingsWithFileUIDCounter, 1)

	mmDeleteEmbeddingsWithFileUID.t.Helper()

	if mmDeleteEmbeddingsWithFileUID.inspectFuncDeleteEmbeddingsWithFileUID != nil {
		mmDeleteEmbeddingsWithFileUID.inspectFuncDeleteEmbeddingsWithFileUID(ctx, collID, fileUID)
	}

	mm_params := VectorDatabaseMockDeleteEmbeddingsWithFileUIDParams{ctx, collID, fileUID}

	// Record call args
	mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.mutex.Lock()
	mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.callArgs = append(mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.callArgs, &mm_params)
	mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.mutex.Unlock()

	for _, e := range mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.paramPtrs

		mm_got := VectorDatabaseMockDeleteEmbeddingsWithFileUIDParams{ctx, collID, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteEmbeddingsWithFileUID.t.Errorf("VectorDatabaseMock.DeleteEmbeddingsWithFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.collID != nil && !minimock.Equal(*mm_want_ptrs.collID, mm_got.collID) {
				mmDeleteEmbeddingsWithFileUID.t.Errorf("VectorDatabaseMock.DeleteEmbeddingsWithFileUID got unexpected parameter collID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.expectationOrigins.originCollID, *mm_want_ptrs.collID, mm_got.collID, minimock.Diff(*mm_want_ptrs.collID, mm_got.collID))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmDeleteEmbeddingsWithFileUID.t.Errorf("VectorDatabaseMock.DeleteEmbeddingsWithFileUID got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteEmbeddingsWithFileUID.t.Errorf("VectorDatabaseMock.DeleteEmbeddingsWithFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteEmbeddingsWithFileUID.t.Fatal("No results are set for the VectorDatabaseMock.DeleteEmbeddingsWithFileUID")
		}
		return (*mm_results).err
	}
	if mmDeleteEmbeddingsWithFileUID.funcDeleteEmbeddingsWithFileUID != nil {
		return mmDeleteEmbeddingsWithFileUID.funcDeleteEmbeddingsWithFileUID(ctx, collID, fileUID)
	}
	mmDeleteEmbeddingsWithFileUID.t.Fatalf("Unexpected call to VectorDatabaseMock.DeleteEmbeddingsWithFileUID. %v %v %v", ctx, collID, fileUID)
	return
}

// DeleteEmbeddingsWithFileUIDAfterCounter returns a count of finished VectorDatabaseMock.DeleteEmbeddingsWithFileUID invocations
func (mmDeleteEmbeddingsWithFileUID *VectorDatabaseMock) DeleteEmbeddingsWithFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEmbeddingsWithFileUID.afterDeleteEmbeddingsWithFileUIDCounter)
}

// DeleteEmbeddingsWithFileUIDBeforeCounter returns a count of VectorDatabaseMock.DeleteEmbeddingsWithFileUID invocations
func (mmDeleteEmbeddingsWithFileUID *VectorDatabaseMock) DeleteEmbeddingsWithFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEmbeddingsWithFileUID.beforeDeleteEmbeddingsWithFileUIDCounter)
}

// Calls returns a list of arguments used in each call to VectorDatabaseMock.DeleteEmbeddingsWithFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteEmbeddingsWithFileUID *mVectorDatabaseMockDeleteEmbeddingsWithFileUID) Calls() []*VectorDatabaseMockDeleteEmbeddingsWithFileUIDParams {
	mmDeleteEmbeddingsWithFileUID.mutex.RLock()

	argCopy := make([]*VectorDatabaseMockDeleteEmbeddingsWithFileUIDParams, len(mmDeleteEmbeddingsWithFileUID.callArgs))
	copy(argCopy, mmDeleteEmbeddingsWithFileUID.callArgs)

	mmDeleteEmbeddingsWithFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteEmbeddingsWithFileUIDDone returns true if the count of the DeleteEmbeddingsWithFileUID invocations corresponds
// the number of defined expectations
func (m *VectorDatabaseMock) MinimockDeleteEmbeddingsWithFileUIDDone() bool {
	if m.DeleteEmbeddingsWithFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteEmbeddingsWithFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteEmbeddingsWithFileUIDMock.invocationsDone()
}

// MinimockDeleteEmbeddingsWithFileUIDInspect logs each unmet expectation
func (m *VectorDatabaseMock) MinimockDeleteEmbeddingsWithFileUIDInspect() {
	for _, e := range m.DeleteEmbeddingsWithFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to VectorDatabaseMock.DeleteEmbeddingsWithFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteEmbeddingsWithFileUIDCounter := mm_atomic.LoadUint64(&m.afterDeleteEmbeddingsWithFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteEmbeddingsWithFileUIDMock.defaultExpectation != nil && afterDeleteEmbeddingsWithFileUIDCounter < 1 {
		if m.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to VectorDatabaseMock.DeleteEmbeddingsWithFileUID at\n%s", m.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to VectorDatabaseMock.DeleteEmbeddingsWithFileUID at\n%s with params: %#v", m.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteEmbeddingsWithFileUID != nil && afterDeleteEmbeddingsWithFileUIDCounter < 1 {
		m.t.Errorf("Expected call to VectorDatabaseMock.DeleteEmbeddingsWithFileUID at\n%s", m.funcDeleteEmbeddingsWithFileUIDOrigin)
	}

	if !m.DeleteEmbeddingsWithFileUIDMock.invocationsDone() && afterDeleteEmbeddingsWithFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to VectorDatabaseMock.DeleteEmbeddingsWithFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteEmbeddingsWithFileUIDMock.expectedInvocations), m.DeleteEmbeddingsWithFileUIDMock.expectedInvocationsOrigin, afterDeleteEmbeddingsWithFileUIDCounter)
	}
}

type mVectorDatabaseMockDropCollection struct {
	optional           bool
	mock               *VectorDatabaseMock
	defaultExpectation *VectorDatabaseMockDropCollectionExpectation
	expectations       []*VectorDatabaseMockDropCollectionExpectation

	callArgs []*VectorDatabaseMockDropCollectionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// VectorDatabaseMockDropCollectionExpectation specifies expectation struct of the VectorDatabase.DropCollection
type VectorDatabaseMockDropCollectionExpectation struct {
	mock               *VectorDatabaseMock
	params             *VectorDatabaseMockDropCollectionParams
	paramPtrs          *VectorDatabaseMockDropCollectionParamPtrs
	expectationOrigins VectorDatabaseMockDropCollectionExpectationOrigins
	results            *VectorDatabaseMockDropCollectionResults
	returnOrigin       string
	Counter            uint64
}

// VectorDatabaseMockDropCollectionParams contains parameters of the VectorDatabase.DropCollection
type VectorDatabaseMockDropCollectionParams struct {
	ctx context.Context
	id  string
}

// VectorDatabaseMockDropCollectionParamPtrs contains pointers to parameters of the VectorDatabase.DropCollection
type VectorDatabaseMockDropCollectionParamPtrs struct {
	ctx *context.Context
	id  *string
}

// VectorDatabaseMockDropCollectionResults contains results of the VectorDatabase.DropCollection
type VectorDatabaseMockDropCollectionResults struct {
	err error
}

// VectorDatabaseMockDropCollectionOrigins contains origins of expectations of the VectorDatabase.DropCollection
type VectorDatabaseMockDropCollectionExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDropCollection *mVectorDatabaseMockDropCollection) Optional() *mVectorDatabaseMockDropCollection {
	mmDropCollection.optional = true
	return mmDropCollection
}

// Expect sets up expected params for VectorDatabase.DropCollection
func (mmDropCollection *mVectorDatabaseMockDropCollection) Expect(ctx context.Context, id string) *mVectorDatabaseMockDropCollection {
	if mmDropCollection.mock.funcDropCollection != nil {
		mmDropCollection.mock.t.Fatalf("VectorDatabaseMock.DropCollection mock is already set by Set")
	}

	if mmDropCollection.defaultExpectation == nil {
		mmDropCollection.defaultExpectation = &VectorDatabaseMockDropCollectionExpectation{}
	}

	if mmDropCollection.defaultExpectation.paramPtrs != nil {
		mmDropCollection.mock.t.Fatalf("VectorDatabaseMock.DropCollection mock is already set by ExpectParams functions")
	}

	mmDropCollection.defaultExpectation.params = &VectorDatabaseMockDropCollectionParams{ctx, id}
	mmDropCollection.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDropCollection.expectations {
		if minimock.Equal(e.params, mmDropCollection.defaultExpectation.params) {
			mmDropCollection.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDropCollection.defaultExpectation.params)
		}
	}

	return mmDropCollection
}

// ExpectCtxParam1 sets up expected param ctx for VectorDatabase.DropCollection
func (mmDropCollection *mVectorDatabaseMockDropCollection) ExpectCtxParam1(ctx context.Context) *mVectorDatabaseMockDropCollection {
	if mmDropCollection.mock.funcDropCollection != nil {
		mmDropCollection.mock.t.Fatalf("VectorDatabaseMock.DropCollection mock is already set by Set")
	}

	if mmDropCollection.defaultExpectation == nil {
		mmDropCollection.defaultExpectation = &VectorDatabaseMockDropCollectionExpectation{}
	}

	if mmDropCollection.defaultExpectation.params != nil {
		mmDropCollection.mock.t.Fatalf("VectorDatabaseMock.DropCollection mock is already set by Expect")
	}

	if mmDropCollection.defaultExpectation.paramPtrs == nil {
		mmDropCollection.defaultExpectation.paramPtrs = &VectorDatabaseMockDropCollectionParamPtrs{}
	}
	mmDropCollection.defaultExpectation.paramPtrs.ctx = &ctx
	mmDropCollection.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDropCollection
}

// ExpectIdParam2 sets up expected param id for VectorDatabase.DropCollection
func (mmDropCollection *mVectorDatabaseMockDropCollection) ExpectIdParam2(id string) *mVectorDatabaseMockDropCollection {
	if mmDropCollection.mock.funcDropCollection != nil {
		mmDropCollection.mock.t.Fatalf("VectorDatabaseMock.DropCollection mock is already set by Set")
	}

	if mmDropCollection.defaultExpectation == nil {
		mmDropCollection.defaultExpectation = &VectorDatabaseMockDropCollectionExpectation{}
	}

	if mmDropCollection.defaultExpectation.params != nil {
		mmDropCollection.mock.t.Fatalf("VectorDatabaseMock.DropCollection mock is already set by Expect")
	}

	if mmDropCollection.defaultExpectation.paramPtrs == nil {
		mmDropCollection.defaultExpectation.paramPtrs = &VectorDatabaseMockDropCollectionParamPtrs{}
	}
	mmDropCollection.defaultExpectation.paramPtrs.id = &id
	mmDropCollection.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDropCollection
}

// Inspect accepts an inspector function that has same arguments as the VectorDatabase.DropCollection
func (mmDropCollection *mVectorDatabaseMockDropCollection) Inspect(f func(ctx context.Context, id string)) *mVectorDatabaseMockDropCollection {
	if mmDropCollection.mock.inspectFuncDropCollection != nil {
		mmDropCollection.mock.t.Fatalf("Inspect function is already set for VectorDatabaseMock.DropCollection")
	}

	mmDropCollection.mock.inspectFuncDropCollection = f

	return mmDropCollection
}

// Return sets up results that will be returned by VectorDatabase.DropCollection
func (mmDropCollection *mVectorDatabaseMockDropCollection) Return(err error) *VectorDatabaseMock {
	if mmDropCollection.mock.funcDropCollection != nil {
		mmDropCollection.mock.t.Fatalf("VectorDatabaseMock.DropCollection mock is already set by Set")
	}

	if mmDropCollection.defaultExpectation == nil {
		mmDropCollection.defaultExpectation = &VectorDatabaseMockDropCollectionExpectation{mock: mmDropCollection.mock}
	}
	mmDropCollection.defaultExpectation.results = &VectorDatabaseMockDropCollectionResults{err}
	mmDropCollection.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDropCollection.mock
}

// Set uses given function f to mock the VectorDatabase.DropCollection method
func (mmDropCollection *mVectorDatabaseMockDropCollection) Set(f func(ctx context.Context, id string) (err error)) *VectorDatabaseMock {
	if mmDropCollection.defaultExpectation != nil {
		mmDropCollection.mock.t.Fatalf("Default expectation is already set for the VectorDatabase.DropCollection method")
	}

	if len(mmDropCollection.expectations) > 0 {
		mmDropCollection.mock.t.Fatalf("Some expectations are already set for the VectorDatabase.DropCollection method")
	}

	mmDropCollection.mock.funcDropCollection = f
	mmDropCollection.mock.funcDropCollectionOrigin = minimock.CallerInfo(1)
	return mmDropCollection.mock
}

// When sets expectation for the VectorDatabase.DropCollection which will trigger the result defined by the following
// Then helper
func (mmDropCollection *mVectorDatabaseMockDropCollection) When(ctx context.Context, id string) *VectorDatabaseMockDropCollectionExpectation {
	if mmDropCollection.mock.funcDropCollection != nil {
		mmDropCollection.mock.t.Fatalf("VectorDatabaseMock.DropCollection mock is already set by Set")
	}

	expectation := &VectorDatabaseMockDropCollectionExpectation{
		mock:               mmDropCollection.mock,
		params:             &VectorDatabaseMockDropCollectionParams{ctx, id},
		expectationOrigins: VectorDatabaseMockDropCollectionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDropCollection.expectations = append(mmDropCollection.expectations, expectation)
	return expectation
}

// Then sets up VectorDatabase.DropCollection return parameters for the expectation previously defined by the When method
func (e *VectorDatabaseMockDropCollectionExpectation) Then(err error) *VectorDatabaseMock {
	e.results = &VectorDatabaseMockDropCollectionResults{err}
	return e.mock
}

// Times sets number of times VectorDatabase.DropCollection should be invoked
func (mmDropCollection *mVectorDatabaseMockDropCollection) Times(n uint64) *mVectorDatabaseMockDropCollection {
	if n == 0 {
		mmDropCollection.mock.t.Fatalf("Times of VectorDatabaseMock.DropCollection mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDropCollection.expectedInvocations, n)
	mmDropCollection.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDropCollection
}

func (mmDropCollection *mVectorDatabaseMockDropCollection) invocationsDone() bool {
	if len(mmDropCollection.expectations) == 0 && mmDropCollection.defaultExpectation == nil && mmDropCollection.mock.funcDropCollection == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDropCollection.mock.afterDropCollectionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDropCollection.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DropCollection implements mm_service.VectorDatabase
func (mmDropCollection *VectorDatabaseMock) DropCollection(ctx context.Context, id string) (err error) {
	mm_atomic.AddUint64(&mmDropCollection.beforeDropCollectionCounter, 1)
	defer mm_atomic.AddUint64(&mmDropCollection.afterDropCollectionCounter, 1)

	mmDropCollection.t.Helper()

	if mmDropCollection.inspectFuncDropCollection != nil {
		mmDropCollection.inspectFuncDropCollection(ctx, id)
	}

	mm_params := VectorDatabaseMockDropCollectionParams{ctx, id}

	// Record call args
	mmDropCollection.DropCollectionMock.mutex.Lock()
	mmDropCollection.DropCollectionMock.callArgs = append(mmDropCollection.DropCollectionMock.callArgs, &mm_params)
	mmDropCollection.DropCollectionMock.mutex.Unlock()

	for _, e := range mmDropCollection.DropCollectionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDropCollection.DropCollectionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDropCollection.DropCollectionMock.defaultExpectation.Counter, 1)
		mm_want := mmDropCollection.DropCollectionMock.defaultExpectation.params
		mm_want_ptrs := mmDropCollection.DropCollectionMock.defaultExpectation.paramPtrs

		mm_got := VectorDatabaseMockDropCollectionParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDropCollection.t.Errorf("VectorDatabaseMock.DropCollection got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDropCollection.DropCollectionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDropCollection.t.Errorf("VectorDatabaseMock.DropCollection got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDropCollection.DropCollectionMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDropCollection.t.Errorf("VectorDatabaseMock.DropCollection got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDropCollection.DropCollectionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDropCollection.DropCollectionMock.defaultExpectation.results
		if mm_results == nil {
			mmDropCollection.t.Fatal("No results are set for the VectorDatabaseMock.DropCollection")
		}
		return (*mm_results).err
	}
	if mmDropCollection.funcDropCollection != nil {
		return mmDropCollection.funcDropCollection(ctx, id)
	}
	mmDropCollection.t.Fatalf("Unexpected call to VectorDatabaseMock.DropCollection. %v %v", ctx, id)
	return
}

// DropCollectionAfterCounter returns a count of finished VectorDatabaseMock.DropCollection invocations
func (mmDropCollection *VectorDatabaseMock) DropCollectionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDropCollection.afterDropCollectionCounter)
}

// DropCollectionBeforeCounter returns a count of VectorDatabaseMock.DropCollection invocations
func (mmDropCollection *VectorDatabaseMock) DropCollectionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDropCollection.beforeDropCollectionCounter)
}

// Calls returns a list of arguments used in each call to VectorDatabaseMock.DropCollection.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDropCollection *mVectorDatabaseMockDropCollection) Calls() []*VectorDatabaseMockDropCollectionParams {
	mmDropCollection.mutex.RLock()

	argCopy := make([]*VectorDatabaseMockDropCollectionParams, len(mmDropCollection.callArgs))
	copy(argCopy, mmDropCollection.callArgs)

	mmDropCollection.mutex.RUnlock()

	return argCopy
}

// MinimockDropCollectionDone returns true if the count of the DropCollection invocations corresponds
// the number of defined expectations
func (m *VectorDatabaseMock) MinimockDropCollectionDone() bool {
	if m.DropCollectionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DropCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DropCollectionMock.invocationsDone()
}

// MinimockDropCollectionInspect logs each unmet expectation
func (m *VectorDatabaseMock) MinimockDropCollectionInspect() {
	for _, e := range m.DropCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to VectorDatabaseMock.DropCollection at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDropCollectionCounter := mm_atomic.LoadUint64(&m.afterDropCollectionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DropCollectionMock.defaultExpectation != nil && afterDropCollectionCounter < 1 {
		if m.DropCollectionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to VectorDatabaseMock.DropCollection at\n%s", m.DropCollectionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to VectorDatabaseMock.DropCollection at\n%s with params: %#v", m.DropCollectionMock.defaultExpectation.expectationOrigins.origin, *m.DropCollectionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDropCollection != nil && afterDropCollectionCounter < 1 {
		m.t.Errorf("Expected call to VectorDatabaseMock.DropCollection at\n%s", m.funcDropCollectionOrigin)
	}

	if !m.DropCollectionMock.invocationsDone() && afterDropCollectionCounter > 0 {
		m.t.Errorf("Expected %d calls to VectorDatabaseMock.DropCollection at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DropCollectionMock.expectedInvocations), m.DropCollectionMock.expectedInvocationsOrigin, afterDropCollectionCounter)
	}
}

type mVectorDatabaseMockFlushCollection struct {
	optional           bool
	mock               *VectorDatabaseMock
	defaultExpectation *VectorDatabaseMockFlushCollectionExpectation
	expectations       []*VectorDatabaseMockFlushCollectionExpectation

	callArgs []*VectorDatabaseMockFlushCollectionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// VectorDatabaseMockFlushCollectionExpectation specifies expectation struct of the VectorDatabase.FlushCollection
type VectorDatabaseMockFlushCollectionExpectation struct {
	mock               *VectorDatabaseMock
	params             *VectorDatabaseMockFlushCollectionParams
	paramPtrs          *VectorDatabaseMockFlushCollectionParamPtrs
	expectationOrigins VectorDatabaseMockFlushCollectionExpectationOrigins
	results            *VectorDatabaseMockFlushCollectionResults
	returnOrigin       string
	Counter            uint64
}

// VectorDatabaseMockFlushCollectionParams contains parameters of the VectorDatabase.FlushCollection
type VectorDatabaseMockFlushCollectionParams struct {
	ctx          context.Context
	collectionID string
}

// VectorDatabaseMockFlushCollectionParamPtrs contains pointers to parameters of the VectorDatabase.FlushCollection
type VectorDatabaseMockFlushCollectionParamPtrs struct {
	ctx          *context.Context
	collectionID *string
}

// VectorDatabaseMockFlushCollectionResults contains results of the VectorDatabase.FlushCollection
type VectorDatabaseMockFlushCollectionResults struct {
	err error
}

// VectorDatabaseMockFlushCollectionOrigins contains origins of expectations of the VectorDatabase.FlushCollection
type VectorDatabaseMockFlushCollectionExpectationOrigins struct {
	origin             string
	originCtx          string
	originCollectionID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFlushCollection *mVectorDatabaseMockFlushCollection) Optional() *mVectorDatabaseMockFlushCollection {
	mmFlushCollection.optional = true
	return mmFlushCollection
}

// Expect sets up expected params for VectorDatabase.FlushCollection
func (mmFlushCollection *mVectorDatabaseMockFlushCollection) Expect(ctx context.Context, collectionID string) *mVectorDatabaseMockFlushCollection {
	if mmFlushCollection.mock.funcFlushCollection != nil {
		mmFlushCollection.mock.t.Fatalf("VectorDatabaseMock.FlushCollection mock is already set by Set")
	}

	if mmFlushCollection.defaultExpectation == nil {
		mmFlushCollection.defaultExpectation = &VectorDatabaseMockFlushCollectionExpectation{}
	}

	if mmFlushCollection.defaultExpectation.paramPtrs != nil {
		mmFlushCollection.mock.t.Fatalf("VectorDatabaseMock.FlushCollection mock is already set by ExpectParams functions")
	}

	mmFlushCollection.defaultExpectation.params = &VectorDatabaseMockFlushCollectionParams{ctx, collectionID}
	mmFlushCollection.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFlushCollection.expectations {
		if minimock.Equal(e.params, mmFlushCollection.defaultExpectation.params) {
			mmFlushCollection.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFlushCollection.defaultExpectation.params)
		}
	}

	return mmFlushCollection
}

// ExpectCtxParam1 sets up expected param ctx for VectorDatabase.FlushCollection
func (mmFlushCollection *mVectorDatabaseMockFlushCollection) ExpectCtxParam1(ctx context.Context) *mVectorDatabaseMockFlushCollection {
	if mmFlushCollection.mock.funcFlushCollection != nil {
		mmFlushCollection.mock.t.Fatalf("VectorDatabaseMock.FlushCollection mock is already set by Set")
	}

	if mmFlushCollection.defaultExpectation == nil {
		mmFlushCollection.defaultExpectation = &VectorDatabaseMockFlushCollectionExpectation{}
	}

	if mmFlushCollection.defaultExpectation.params != nil {
		mmFlushCollection.mock.t.Fatalf("VectorDatabaseMock.FlushCollection mock is already set by Expect")
	}

	if mmFlushCollection.defaultExpectation.paramPtrs == nil {
		mmFlushCollection.defaultExpectation.paramPtrs = &VectorDatabaseMockFlushCollectionParamPtrs{}
	}
	mmFlushCollection.defaultExpectation.paramPtrs.ctx = &ctx
	mmFlushCollection.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFlushCollection
}

// ExpectCollectionIDParam2 sets up expected param collectionID for VectorDatabase.FlushCollection
func (mmFlushCollection *mVectorDatabaseMockFlushCollection) ExpectCollectionIDParam2(collectionID string) *mVectorDatabaseMockFlushCollection {
	if mmFlushCollection.mock.funcFlushCollection != nil {
		mmFlushCollection.mock.t.Fatalf("VectorDatabaseMock.FlushCollection mock is already set by Set")
	}

	if mmFlushCollection.defaultExpectation == nil {
		mmFlushCollection.defaultExpectation = &VectorDatabaseMockFlushCollectionExpectation{}
	}

	if mmFlushCollection.defaultExpectation.params != nil {
		mmFlushCollection.mock.t.Fatalf("VectorDatabaseMock.FlushCollection mock is already set by Expect")
	}

	if mmFlushCollection.defaultExpectation.paramPtrs == nil {
		mmFlushCollection.defaultExpectation.paramPtrs = &VectorDatabaseMockFlushCollectionParamPtrs{}
	}
	mmFlushCollection.defaultExpectation.paramPtrs.collectionID = &collectionID
	mmFlushCollection.defaultExpectation.expectationOrigins.originCollectionID = minimock.CallerInfo(1)

	return mmFlushCollection
}

// Inspect accepts an inspector function that has same arguments as the VectorDatabase.FlushCollection
func (mmFlushCollection *mVectorDatabaseMockFlushCollection) Inspect(f func(ctx context.Context, collectionID string)) *mVectorDatabaseMockFlushCollection {
	if mmFlushCollection.mock.inspectFuncFlushCollection != nil {
		mmFlushCollection.mock.t.Fatalf("Inspect function is already set for VectorDatabaseMock.FlushCollection")
	}

	mmFlushCollection.mock.inspectFuncFlushCollection = f

	return mmFlushCollection
}

// Return sets up results that will be returned by VectorDatabase.FlushCollection
func (mmFlushCollection *mVectorDatabaseMockFlushCollection) Return(err error) *VectorDatabaseMock {
	if mmFlushCollection.mock.funcFlushCollection != nil {
		mmFlushCollection.mock.t.Fatalf("VectorDatabaseMock.FlushCollection mock is already set by Set")
	}

	if mmFlushCollection.defaultExpectation == nil {
		mmFlushCollection.defaultExpectation = &VectorDatabaseMockFlushCollectionExpectation{mock: mmFlushCollection.mock}
	}
	mmFlushCollection.defaultExpectation.results = &VectorDatabaseMockFlushCollectionResults{err}
	mmFlushCollection.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFlushCollection.mock
}

// Set uses given function f to mock the VectorDatabase.FlushCollection method
func (mmFlushCollection *mVectorDatabaseMockFlushCollection) Set(f func(ctx context.Context, collectionID string) (err error)) *VectorDatabaseMock {
	if mmFlushCollection.defaultExpectation != nil {
		mmFlushCollection.mock.t.Fatalf("Default expectation is already set for the VectorDatabase.FlushCollection method")
	}

	if len(mmFlushCollection.expectations) > 0 {
		mmFlushCollection.mock.t.Fatalf("Some expectations are already set for the VectorDatabase.FlushCollection method")
	}

	mmFlushCollection.mock.funcFlushCollection = f
	mmFlushCollection.mock.funcFlushCollectionOrigin = minimock.CallerInfo(1)
	return mmFlushCollection.mock
}

// When sets expectation for the VectorDatabase.FlushCollection which will trigger the result defined by the following
// Then helper
func (mmFlushCollection *mVectorDatabaseMockFlushCollection) When(ctx context.Context, collectionID string) *VectorDatabaseMockFlushCollectionExpectation {
	if mmFlushCollection.mock.funcFlushCollection != nil {
		mmFlushCollection.mock.t.Fatalf("VectorDatabaseMock.FlushCollection mock is already set by Set")
	}

	expectation := &VectorDatabaseMockFlushCollectionExpectation{
		mock:               mmFlushCollection.mock,
		params:             &VectorDatabaseMockFlushCollectionParams{ctx, collectionID},
		expectationOrigins: VectorDatabaseMockFlushCollectionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFlushCollection.expectations = append(mmFlushCollection.expectations, expectation)
	return expectation
}

// Then sets up VectorDatabase.FlushCollection return parameters for the expectation previously defined by the When method
func (e *VectorDatabaseMockFlushCollectionExpectation) Then(err error) *VectorDatabaseMock {
	e.results = &VectorDatabaseMockFlushCollectionResults{err}
	return e.mock
}

// Times sets number of times VectorDatabase.FlushCollection should be invoked
func (mmFlushCollection *mVectorDatabaseMockFlushCollection) Times(n uint64) *mVectorDatabaseMockFlushCollection {
	if n == 0 {
		mmFlushCollection.mock.t.Fatalf("Times of VectorDatabaseMock.FlushCollection mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFlushCollection.expectedInvocations, n)
	mmFlushCollection.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFlushCollection
}

func (mmFlushCollection *mVectorDatabaseMockFlushCollection) invocationsDone() bool {
	if len(mmFlushCollection.expectations) == 0 && mmFlushCollection.defaultExpectation == nil && mmFlushCollection.mock.funcFlushCollection == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFlushCollection.mock.afterFlushCollectionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFlushCollection.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FlushCollection implements mm_service.VectorDatabase
func (mmFlushCollection *VectorDatabaseMock) FlushCollection(ctx context.Context, collectionID string) (err error) {
	mm_atomic.AddUint64(&mmFlushCollection.beforeFlushCollectionCounter, 1)
	defer mm_atomic.AddUint64(&mmFlushCollection.afterFlushCollectionCounter, 1)

	mmFlushCollection.t.Helper()

	if mmFlushCollection.inspectFuncFlushCollection != nil {
		mmFlushCollection.inspectFuncFlushCollection(ctx, collectionID)
	}

	mm_params := VectorDatabaseMockFlushCollectionParams{ctx, collectionID}

	// Record call args
	mmFlushCollection.FlushCollectionMock.mutex.Lock()
	mmFlushCollection.FlushCollectionMock.callArgs = append(mmFlushCollection.FlushCollectionMock.callArgs, &mm_params)
	mmFlushCollection.FlushCollectionMock.mutex.Unlock()

	for _, e := range mmFlushCollection.FlushCollectionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmFlushCollection.FlushCollectionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFlushCollection.FlushCollectionMock.defaultExpectation.Counter, 1)
		mm_want := mmFlushCollection.FlushCollectionMock.defaultExpectation.params
		mm_want_ptrs := mmFlushCollection.FlushCollectionMock.defaultExpectation.paramPtrs

		mm_got := VectorDatabaseMockFlushCollectionParams{ctx, collectionID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFlushCollection.t.Errorf("VectorDatabaseMock.FlushCollection got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFlushCollection.FlushCollectionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.collectionID != nil && !minimock.Equal(*mm_want_ptrs.collectionID, mm_got.collectionID) {
				mmFlushCollection.t.Errorf("VectorDatabaseMock.FlushCollection got unexpected parameter collectionID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFlushCollection.FlushCollectionMock.defaultExpectation.expectationOrigins.originCollectionID, *mm_want_ptrs.collectionID, mm_got.collectionID, minimock.Diff(*mm_want_ptrs.collectionID, mm_got.collectionID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFlushCollection.t.Errorf("VectorDatabaseMock.FlushCollection got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFlushCollection.FlushCollectionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFlushCollection.FlushCollectionMock.defaultExpectation.results
		if mm_results == nil {
			mmFlushCollection.t.Fatal("No results are set for the VectorDatabaseMock.FlushCollection")
		}
		return (*mm_results).err
	}
	if mmFlushCollection.funcFlushCollection != nil {
		return mmFlushCollection.funcFlushCollection(ctx, collectionID)
	}
	mmFlushCollection.t.Fatalf("Unexpected call to VectorDatabaseMock.FlushCollection. %v %v", ctx, collectionID)
	return
}

// FlushCollectionAfterCounter returns a count of finished VectorDatabaseMock.FlushCollection invocations
func (mmFlushCollection *VectorDatabaseMock) FlushCollectionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFlushCollection.afterFlushCollectionCounter)
}

// FlushCollectionBeforeCounter returns a count of VectorDatabaseMock.FlushCollection invocations
func (mmFlushCollection *VectorDatabaseMock) FlushCollectionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFlushCollection.beforeFlushCollectionCounter)
}

// Calls returns a list of arguments used in each call to VectorDatabaseMock.FlushCollection.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFlushCollection *mVectorDatabaseMockFlushCollection) Calls() []*VectorDatabaseMockFlushCollectionParams {
	mmFlushCollection.mutex.RLock()

	argCopy := make([]*VectorDatabaseMockFlushCollectionParams, len(mmFlushCollection.callArgs))
	copy(argCopy, mmFlushCollection.callArgs)

	mmFlushCollection.mutex.RUnlock()

	return argCopy
}

// MinimockFlushCollectionDone returns true if the count of the FlushCollection invocations corresponds
// the number of defined expectations
func (m *VectorDatabaseMock) MinimockFlushCollectionDone() bool {
	if m.FlushCollectionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FlushCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FlushCollectionMock.invocationsDone()
}

// MinimockFlushCollectionInspect logs each unmet expectation
func (m *VectorDatabaseMock) MinimockFlushCollectionInspect() {
	for _, e := range m.FlushCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to VectorDatabaseMock.FlushCollection at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFlushCollectionCounter := mm_atomic.LoadUint64(&m.afterFlushCollectionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FlushCollectionMock.defaultExpectation != nil && afterFlushCollectionCounter < 1 {
		if m.FlushCollectionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to VectorDatabaseMock.FlushCollection at\n%s", m.FlushCollectionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to VectorDatabaseMock.FlushCollection at\n%s with params: %#v", m.FlushCollectionMock.defaultExpectation.expectationOrigins.origin, *m.FlushCollectionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFlushCollection != nil && afterFlushCollectionCounter < 1 {
		m.t.Errorf("Expected call to VectorDatabaseMock.FlushCollection at\n%s", m.funcFlushCollectionOrigin)
	}

	if !m.FlushCollectionMock.invocationsDone() && afterFlushCollectionCounter > 0 {
		m.t.Errorf("Expected %d calls to VectorDatabaseMock.FlushCollection at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FlushCollectionMock.expectedInvocations), m.FlushCollectionMock.expectedInvocationsOrigin, afterFlushCollectionCounter)
	}
}

type mVectorDatabaseMockInsertVectorsInCollection struct {
	optional           bool
	mock               *VectorDatabaseMock
	defaultExpectation *VectorDatabaseMockInsertVectorsInCollectionExpectation
	expectations       []*VectorDatabaseMockInsertVectorsInCollectionExpectation

	callArgs []*VectorDatabaseMockInsertVectorsInCollectionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// VectorDatabaseMockInsertVectorsInCollectionExpectation specifies expectation struct of the VectorDatabase.InsertVectorsInCollection
type VectorDatabaseMockInsertVectorsInCollectionExpectation struct {
	mock               *VectorDatabaseMock
	params             *VectorDatabaseMockInsertVectorsInCollectionParams
	paramPtrs          *VectorDatabaseMockInsertVectorsInCollectionParamPtrs
	expectationOrigins VectorDatabaseMockInsertVectorsInCollectionExpectationOrigins
	results            *VectorDatabaseMockInsertVectorsInCollectionResults
	returnOrigin       string
	Counter            uint64
}

// VectorDatabaseMockInsertVectorsInCollectionParams contains parameters of the VectorDatabase.InsertVectorsInCollection
type VectorDatabaseMockInsertVectorsInCollectionParams struct {
	ctx        context.Context
	collID     string
	embeddings []mm_service.Embedding
}

// VectorDatabaseMockInsertVectorsInCollectionParamPtrs contains pointers to parameters of the VectorDatabase.InsertVectorsInCollection
type VectorDatabaseMockInsertVectorsInCollectionParamPtrs struct {
	ctx        *context.Context
	collID     *string
	embeddings *[]mm_service.Embedding
}

// VectorDatabaseMockInsertVectorsInCollectionResults contains results of the VectorDatabase.InsertVectorsInCollection
type VectorDatabaseMockInsertVectorsInCollectionResults struct {
	err error
}

// VectorDatabaseMockInsertVectorsInCollectionOrigins contains origins of expectations of the VectorDatabase.InsertVectorsInCollection
type VectorDatabaseMockInsertVectorsInCollectionExpectationOrigins struct {
	origin           string
	originCtx        string
	originCollID     string
	originEmbeddings string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInsertVectorsInCollection *mVectorDatabaseMockInsertVectorsInCollection) Optional() *mVectorDatabaseMockInsertVectorsInCollection {
	mmInsertVectorsInCollection.optional = true
	return mmInsertVectorsInCollection
}

// Expect sets up expected params for VectorDatabase.InsertVectorsInCollection
func (mmInsertVectorsInCollection *mVectorDatabaseMockInsertVectorsInCollection) Expect(ctx context.Context, collID string, embeddings []mm_service.Embedding) *mVectorDatabaseMockInsertVectorsInCollection {
	if mmInsertVectorsInCollection.mock.funcInsertVectorsInCollection != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("VectorDatabaseMock.InsertVectorsInCollection mock is already set by Set")
	}

	if mmInsertVectorsInCollection.defaultExpectation == nil {
		mmInsertVectorsInCollection.defaultExpectation = &VectorDatabaseMockInsertVectorsInCollectionExpectation{}
	}

	if mmInsertVectorsInCollection.defaultExpectation.paramPtrs != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("VectorDatabaseMock.InsertVectorsInCollection mock is already set by ExpectParams functions")
	}

	mmInsertVectorsInCollection.defaultExpectation.params = &VectorDatabaseMockInsertVectorsInCollectionParams{ctx, collID, embeddings}
	mmInsertVectorsInCollection.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmInsertVectorsInCollection.expectations {
		if minimock.Equal(e.params, mmInsertVectorsInCollection.defaultExpectation.params) {
			mmInsertVectorsInCollection.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInsertVectorsInCollection.defaultExpectation.params)
		}
	}

	return mmInsertVectorsInCollection
}

// ExpectCtxParam1 sets up expected param ctx for VectorDatabase.InsertVectorsInCollection
func (mmInsertVectorsInCollection *mVectorDatabaseMockInsertVectorsInCollection) ExpectCtxParam1(ctx context.Context) *mVectorDatabaseMockInsertVectorsInCollection {
	if mmInsertVectorsInCollection.mock.funcInsertVectorsInCollection != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("VectorDatabaseMock.InsertVectorsInCollection mock is already set by Set")
	}

	if mmInsertVectorsInCollection.defaultExpectation == nil {
		mmInsertVectorsInCollection.defaultExpectation = &VectorDatabaseMockInsertVectorsInCollectionExpectation{}
	}

	if mmInsertVectorsInCollection.defaultExpectation.params != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("VectorDatabaseMock.InsertVectorsInCollection mock is already set by Expect")
	}

	if mmInsertVectorsInCollection.defaultExpectation.paramPtrs == nil {
		mmInsertVectorsInCollection.defaultExpectation.paramPtrs = &VectorDatabaseMockInsertVectorsInCollectionParamPtrs{}
	}
	mmInsertVectorsInCollection.defaultExpectation.paramPtrs.ctx = &ctx
	mmInsertVectorsInCollection.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmInsertVectorsInCollection
}

// ExpectCollIDParam2 sets up expected param collID for VectorDatabase.InsertVectorsInCollection
func (mmInsertVectorsInCollection *mVectorDatabaseMockInsertVectorsInCollection) ExpectCollIDParam2(collID string) *mVectorDatabaseMockInsertVectorsInCollection {
	if mmInsertVectorsInCollection.mock.funcInsertVectorsInCollection != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("VectorDatabaseMock.InsertVectorsInCollection mock is already set by Set")
	}

	if mmInsertVectorsInCollection.defaultExpectation == nil {
		mmInsertVectorsInCollection.defaultExpectation = &VectorDatabaseMockInsertVectorsInCollectionExpectation{}
	}

	if mmInsertVectorsInCollection.defaultExpectation.params != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("VectorDatabaseMock.InsertVectorsInCollection mock is already set by Expect")
	}

	if mmInsertVectorsInCollection.defaultExpectation.paramPtrs == nil {
		mmInsertVectorsInCollection.defaultExpectation.paramPtrs = &VectorDatabaseMockInsertVectorsInCollectionParamPtrs{}
	}
	mmInsertVectorsInCollection.defaultExpectation.paramPtrs.collID = &collID
	mmInsertVectorsInCollection.defaultExpectation.expectationOrigins.originCollID = minimock.CallerInfo(1)

	return mmInsertVectorsInCollection
}

// ExpectEmbeddingsParam3 sets up expected param embeddings for VectorDatabase.InsertVectorsInCollection
func (mmInsertVectorsInCollection *mVectorDatabaseMockInsertVectorsInCollection) ExpectEmbeddingsParam3(embeddings []mm_service.Embedding) *mVectorDatabaseMockInsertVectorsInCollection {
	if mmInsertVectorsInCollection.mock.funcInsertVectorsInCollection != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("VectorDatabaseMock.InsertVectorsInCollection mock is already set by Set")
	}

	if mmInsertVectorsInCollection.defaultExpectation == nil {
		mmInsertVectorsInCollection.defaultExpectation = &VectorDatabaseMockInsertVectorsInCollectionExpectation{}
	}

	if mmInsertVectorsInCollection.defaultExpectation.params != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("VectorDatabaseMock.InsertVectorsInCollection mock is already set by Expect")
	}

	if mmInsertVectorsInCollection.defaultExpectation.paramPtrs == nil {
		mmInsertVectorsInCollection.defaultExpectation.paramPtrs = &VectorDatabaseMockInsertVectorsInCollectionParamPtrs{}
	}
	mmInsertVectorsInCollection.defaultExpectation.paramPtrs.embeddings = &embeddings
	mmInsertVectorsInCollection.defaultExpectation.expectationOrigins.originEmbeddings = minimock.CallerInfo(1)

	return mmInsertVectorsInCollection
}

// Inspect accepts an inspector function that has same arguments as the VectorDatabase.InsertVectorsInCollection
func (mmInsertVectorsInCollection *mVectorDatabaseMockInsertVectorsInCollection) Inspect(f func(ctx context.Context, collID string, embeddings []mm_service.Embedding)) *mVectorDatabaseMockInsertVectorsInCollection {
	if mmInsertVectorsInCollection.mock.inspectFuncInsertVectorsInCollection != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("Inspect function is already set for VectorDatabaseMock.InsertVectorsInCollection")
	}

	mmInsertVectorsInCollection.mock.inspectFuncInsertVectorsInCollection = f

	return mmInsertVectorsInCollection
}

// Return sets up results that will be returned by VectorDatabase.InsertVectorsInCollection
func (mmInsertVectorsInCollection *mVectorDatabaseMockInsertVectorsInCollection) Return(err error) *VectorDatabaseMock {
	if mmInsertVectorsInCollection.mock.funcInsertVectorsInCollection != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("VectorDatabaseMock.InsertVectorsInCollection mock is already set by Set")
	}

	if mmInsertVectorsInCollection.defaultExpectation == nil {
		mmInsertVectorsInCollection.defaultExpectation = &VectorDatabaseMockInsertVectorsInCollectionExpectation{mock: mmInsertVectorsInCollection.mock}
	}
	mmInsertVectorsInCollection.defaultExpectation.results = &VectorDatabaseMockInsertVectorsInCollectionResults{err}
	mmInsertVectorsInCollection.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInsertVectorsInCollection.mock
}

// Set uses given function f to mock the VectorDatabase.InsertVectorsInCollection method
func (mmInsertVectorsInCollection *mVectorDatabaseMockInsertVectorsInCollection) Set(f func(ctx context.Context, collID string, embeddings []mm_service.Embedding) (err error)) *VectorDatabaseMock {
	if mmInsertVectorsInCollection.defaultExpectation != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("Default expectation is already set for the VectorDatabase.InsertVectorsInCollection method")
	}

	if len(mmInsertVectorsInCollection.expectations) > 0 {
		mmInsertVectorsInCollection.mock.t.Fatalf("Some expectations are already set for the VectorDatabase.InsertVectorsInCollection method")
	}

	mmInsertVectorsInCollection.mock.funcInsertVectorsInCollection = f
	mmInsertVectorsInCollection.mock.funcInsertVectorsInCollectionOrigin = minimock.CallerInfo(1)
	return mmInsertVectorsInCollection.mock
}

// When sets expectation for the VectorDatabase.InsertVectorsInCollection which will trigger the result defined by the following
// Then helper
func (mmInsertVectorsInCollection *mVectorDatabaseMockInsertVectorsInCollection) When(ctx context.Context, collID string, embeddings []mm_service.Embedding) *VectorDatabaseMockInsertVectorsInCollectionExpectation {
	if mmInsertVectorsInCollection.mock.funcInsertVectorsInCollection != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("VectorDatabaseMock.InsertVectorsInCollection mock is already set by Set")
	}

	expectation := &VectorDatabaseMockInsertVectorsInCollectionExpectation{
		mock:               mmInsertVectorsInCollection.mock,
		params:             &VectorDatabaseMockInsertVectorsInCollectionParams{ctx, collID, embeddings},
		expectationOrigins: VectorDatabaseMockInsertVectorsInCollectionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmInsertVectorsInCollection.expectations = append(mmInsertVectorsInCollection.expectations, expectation)
	return expectation
}

// Then sets up VectorDatabase.InsertVectorsInCollection return parameters for the expectation previously defined by the When method
func (e *VectorDatabaseMockInsertVectorsInCollectionExpectation) Then(err error) *VectorDatabaseMock {
	e.results = &VectorDatabaseMockInsertVectorsInCollectionResults{err}
	return e.mock
}

// Times sets number of times VectorDatabase.InsertVectorsInCollection should be invoked
func (mmInsertVectorsInCollection *mVectorDatabaseMockInsertVectorsInCollection) Times(n uint64) *mVectorDatabaseMockInsertVectorsInCollection {
	if n == 0 {
		mmInsertVectorsInCollection.mock.t.Fatalf("Times of VectorDatabaseMock.InsertVectorsInCollection mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInsertVectorsInCollection.expectedInvocations, n)
	mmInsertVectorsInCollection.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInsertVectorsInCollection
}

func (mmInsertVectorsInCollection *mVectorDatabaseMockInsertVectorsInCollection) invocationsDone() bool {
	if len(mmInsertVectorsInCollection.expectations) == 0 && mmInsertVectorsInCollection.defaultExpectation == nil && mmInsertVectorsInCollection.mock.funcInsertVectorsInCollection == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInsertVectorsInCollection.mock.afterInsertVectorsInCollectionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInsertVectorsInCollection.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// InsertVectorsInCollection implements mm_service.VectorDatabase
func (mmInsertVectorsInCollection *VectorDatabaseMock) InsertVectorsInCollection(ctx context.Context, collID string, embeddings []mm_service.Embedding) (err error) {
	mm_atomic.AddUint64(&mmInsertVectorsInCollection.beforeInsertVectorsInCollectionCounter, 1)
	defer mm_atomic.AddUint64(&mmInsertVectorsInCollection.afterInsertVectorsInCollectionCounter, 1)

	mmInsertVectorsInCollection.t.Helper()

	if mmInsertVectorsInCollection.inspectFuncInsertVectorsInCollection != nil {
		mmInsertVectorsInCollection.inspectFuncInsertVectorsInCollection(ctx, collID, embeddings)
	}

	mm_params := VectorDatabaseMockInsertVectorsInCollectionParams{ctx, collID, embeddings}

	// Record call args
	mmInsertVectorsInCollection.InsertVectorsInCollectionMock.mutex.Lock()
	mmInsertVectorsInCollection.InsertVectorsInCollectionMock.callArgs = append(mmInsertVectorsInCollection.InsertVectorsInCollectionMock.callArgs, &mm_params)
	mmInsertVectorsInCollection.InsertVectorsInCollectionMock.mutex.Unlock()

	for _, e := range mmInsertVectorsInCollection.InsertVectorsInCollectionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmInsertVectorsInCollection.InsertVectorsInCollectionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInsertVectorsInCollection.InsertVectorsInCollectionMock.defaultExpectation.Counter, 1)
		mm_want := mmInsertVectorsInCollection.InsertVectorsInCollectionMock.defaultExpectation.params
		mm_want_ptrs := mmInsertVectorsInCollection.InsertVectorsInCollectionMock.defaultExpectation.paramPtrs

		mm_got := VectorDatabaseMockInsertVectorsInCollectionParams{ctx, collID, embeddings}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmInsertVectorsInCollection.t.Errorf("VectorDatabaseMock.InsertVectorsInCollection got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInsertVectorsInCollection.InsertVectorsInCollectionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.collID != nil && !minimock.Equal(*mm_want_ptrs.collID, mm_got.collID) {
				mmInsertVectorsInCollection.t.Errorf("VectorDatabaseMock.InsertVectorsInCollection got unexpected parameter collID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInsertVectorsInCollection.InsertVectorsInCollectionMock.defaultExpectation.expectationOrigins.originCollID, *mm_want_ptrs.collID, mm_got.collID, minimock.Diff(*mm_want_ptrs.collID, mm_got.collID))
			}

			if mm_want_ptrs.embeddings != nil && !minimock.Equal(*mm_want_ptrs.embeddings, mm_got.embeddings) {
				mmInsertVectorsInCollection.t.Errorf("VectorDatabaseMock.InsertVectorsInCollection got unexpected parameter embeddings, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInsertVectorsInCollection.InsertVectorsInCollectionMock.defaultExpectation.expectationOrigins.originEmbeddings, *mm_want_ptrs.embeddings, mm_got.embeddings, minimock.Diff(*mm_want_ptrs.embeddings, mm_got.embeddings))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInsertVectorsInCollection.t.Errorf("VectorDatabaseMock.InsertVectorsInCollection got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmInsertVectorsInCollection.InsertVectorsInCollectionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInsertVectorsInCollection.InsertVectorsInCollectionMock.defaultExpectation.results
		if mm_results == nil {
			mmInsertVectorsInCollection.t.Fatal("No results are set for the VectorDatabaseMock.InsertVectorsInCollection")
		}
		return (*mm_results).err
	}
	if mmInsertVectorsInCollection.funcInsertVectorsInCollection != nil {
		return mmInsertVectorsInCollection.funcInsertVectorsInCollection(ctx, collID, embeddings)
	}
	mmInsertVectorsInCollection.t.Fatalf("Unexpected call to VectorDatabaseMock.InsertVectorsInCollection. %v %v %v", ctx, collID, embeddings)
	return
}

// InsertVectorsInCollectionAfterCounter returns a count of finished VectorDatabaseMock.InsertVectorsInCollection invocations
func (mmInsertVectorsInCollection *VectorDatabaseMock) InsertVectorsInCollectionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertVectorsInCollection.afterInsertVectorsInCollectionCounter)
}

// InsertVectorsInCollectionBeforeCounter returns a count of VectorDatabaseMock.InsertVectorsInCollection invocations
func (mmInsertVectorsInCollection *VectorDatabaseMock) InsertVectorsInCollectionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertVectorsInCollection.beforeInsertVectorsInCollectionCounter)
}

// Calls returns a list of arguments used in each call to VectorDatabaseMock.InsertVectorsInCollection.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInsertVectorsInCollection *mVectorDatabaseMockInsertVectorsInCollection) Calls() []*VectorDatabaseMockInsertVectorsInCollectionParams {
	mmInsertVectorsInCollection.mutex.RLock()

	argCopy := make([]*VectorDatabaseMockInsertVectorsInCollectionParams, len(mmInsertVectorsInCollection.callArgs))
	copy(argCopy, mmInsertVectorsInCollection.callArgs)

	mmInsertVectorsInCollection.mutex.RUnlock()

	return argCopy
}

// MinimockInsertVectorsInCollectionDone returns true if the count of the InsertVectorsInCollection invocations corresponds
// the number of defined expectations
func (m *VectorDatabaseMock) MinimockInsertVectorsInCollectionDone() bool {
	if m.InsertVectorsInCollectionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InsertVectorsInCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InsertVectorsInCollectionMock.invocationsDone()
}

// MinimockInsertVectorsInCollectionInspect logs each unmet expectation
func (m *VectorDatabaseMock) MinimockInsertVectorsInCollectionInspect() {
	for _, e := range m.InsertVectorsInCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to VectorDatabaseMock.InsertVectorsInCollection at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterInsertVectorsInCollectionCounter := mm_atomic.LoadUint64(&m.afterInsertVectorsInCollectionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InsertVectorsInCollectionMock.defaultExpectation != nil && afterInsertVectorsInCollectionCounter < 1 {
		if m.InsertVectorsInCollectionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to VectorDatabaseMock.InsertVectorsInCollection at\n%s", m.InsertVectorsInCollectionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to VectorDatabaseMock.InsertVectorsInCollection at\n%s with params: %#v", m.InsertVectorsInCollectionMock.defaultExpectation.expectationOrigins.origin, *m.InsertVectorsInCollectionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertVectorsInCollection != nil && afterInsertVectorsInCollectionCounter < 1 {
		m.t.Errorf("Expected call to VectorDatabaseMock.InsertVectorsInCollection at\n%s", m.funcInsertVectorsInCollectionOrigin)
	}

	if !m.InsertVectorsInCollectionMock.invocationsDone() && afterInsertVectorsInCollectionCounter > 0 {
		m.t.Errorf("Expected %d calls to VectorDatabaseMock.InsertVectorsInCollection at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InsertVectorsInCollectionMock.expectedInvocations), m.InsertVectorsInCollectionMock.expectedInvocationsOrigin, afterInsertVectorsInCollectionCounter)
	}
}

type mVectorDatabaseMockSimilarVectorsInCollection struct {
	optional           bool
	mock               *VectorDatabaseMock
	defaultExpectation *VectorDatabaseMockSimilarVectorsInCollectionExpectation
	expectations       []*VectorDatabaseMockSimilarVectorsInCollectionExpectation

	callArgs []*VectorDatabaseMockSimilarVectorsInCollectionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// VectorDatabaseMockSimilarVectorsInCollectionExpectation specifies expectation struct of the VectorDatabase.SimilarVectorsInCollection
type VectorDatabaseMockSimilarVectorsInCollectionExpectation struct {
	mock               *VectorDatabaseMock
	params             *VectorDatabaseMockSimilarVectorsInCollectionParams
	paramPtrs          *VectorDatabaseMockSimilarVectorsInCollectionParamPtrs
	expectationOrigins VectorDatabaseMockSimilarVectorsInCollectionExpectationOrigins
	results            *VectorDatabaseMockSimilarVectorsInCollectionResults
	returnOrigin       string
	Counter            uint64
}

// VectorDatabaseMockSimilarVectorsInCollectionParams contains parameters of the VectorDatabase.SimilarVectorsInCollection
type VectorDatabaseMockSimilarVectorsInCollectionParams struct {
	ctx context.Context
	s1  mm_service.SimilarVectorSearchParam
}

// VectorDatabaseMockSimilarVectorsInCollectionParamPtrs contains pointers to parameters of the VectorDatabase.SimilarVectorsInCollection
type VectorDatabaseMockSimilarVectorsInCollectionParamPtrs struct {
	ctx *context.Context
	s1  *mm_service.SimilarVectorSearchParam
}

// VectorDatabaseMockSimilarVectorsInCollectionResults contains results of the VectorDatabase.SimilarVectorsInCollection
type VectorDatabaseMockSimilarVectorsInCollectionResults struct {
	saa1 [][]mm_service.SimilarEmbedding
	err  error
}

// VectorDatabaseMockSimilarVectorsInCollectionOrigins contains origins of expectations of the VectorDatabase.SimilarVectorsInCollection
type VectorDatabaseMockSimilarVectorsInCollectionExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSimilarVectorsInCollection *mVectorDatabaseMockSimilarVectorsInCollection) Optional() *mVectorDatabaseMockSimilarVectorsInCollection {
	mmSimilarVectorsInCollection.optional = true
	return mmSimilarVectorsInCollection
}

// Expect sets up expected params for VectorDatabase.SimilarVectorsInCollection
func (mmSimilarVectorsInCollection *mVectorDatabaseMockSimilarVectorsInCollection) Expect(ctx context.Context, s1 mm_service.SimilarVectorSearchParam) *mVectorDatabaseMockSimilarVectorsInCollection {
	if mmSimilarVectorsInCollection.mock.funcSimilarVectorsInCollection != nil {
		mmSimilarVectorsInCollection.mock.t.Fatalf("VectorDatabaseMock.SimilarVectorsInCollection mock is already set by Set")
	}

	if mmSimilarVectorsInCollection.defaultExpectation == nil {
		mmSimilarVectorsInCollection.defaultExpectation = &VectorDatabaseMockSimilarVectorsInCollectionExpectation{}
	}

	if mmSimilarVectorsInCollection.defaultExpectation.paramPtrs != nil {
		mmSimilarVectorsInCollection.mock.t.Fatalf("VectorDatabaseMock.SimilarVectorsInCollection mock is already set by ExpectParams functions")
	}

	mmSimilarVectorsInCollection.defaultExpectation.params = &VectorDatabaseMockSimilarVectorsInCollectionParams{ctx, s1}
	mmSimilarVectorsInCollection.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSimilarVectorsInCollection.expectations {
		if minimock.Equal(e.params, mmSimilarVectorsInCollection.defaultExpectation.params) {
			mmSimilarVectorsInCollection.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSimilarVectorsInCollection.defaultExpectation.params)
		}
	}

	return mmSimilarVectorsInCollection
}

// ExpectCtxParam1 sets up expected param ctx for VectorDatabase.SimilarVectorsInCollection
func (mmSimilarVectorsInCollection *mVectorDatabaseMockSimilarVectorsInCollection) ExpectCtxParam1(ctx context.Context) *mVectorDatabaseMockSimilarVectorsInCollection {
	if mmSimilarVectorsInCollection.mock.funcSimilarVectorsInCollection != nil {
		mmSimilarVectorsInCollection.mock.t.Fatalf("VectorDatabaseMock.SimilarVectorsInCollection mock is already set by Set")
	}

	if mmSimilarVectorsInCollection.defaultExpectation == nil {
		mmSimilarVectorsInCollection.defaultExpectation = &VectorDatabaseMockSimilarVectorsInCollectionExpectation{}
	}

	if mmSimilarVectorsInCollection.defaultExpectation.params != nil {
		mmSimilarVectorsInCollection.mock.t.Fatalf("VectorDatabaseMock.SimilarVectorsInCollection mock is already set by Expect")
	}

	if mmSimilarVectorsInCollection.defaultExpectation.paramPtrs == nil {
		mmSimilarVectorsInCollection.defaultExpectation.paramPtrs = &VectorDatabaseMockSimilarVectorsInCollectionParamPtrs{}
	}
	mmSimilarVectorsInCollection.defaultExpectation.paramPtrs.ctx = &ctx
	mmSimilarVectorsInCollection.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSimilarVectorsInCollection
}

// ExpectS1Param2 sets up expected param s1 for VectorDatabase.SimilarVectorsInCollection
func (mmSimilarVectorsInCollection *mVectorDatabaseMockSimilarVectorsInCollection) ExpectS1Param2(s1 mm_service.SimilarVectorSearchParam) *mVectorDatabaseMockSimilarVectorsInCollection {
	if mmSimilarVectorsInCollection.mock.funcSimilarVectorsInCollection != nil {
		mmSimilarVectorsInCollection.mock.t.Fatalf("VectorDatabaseMock.SimilarVectorsInCollection mock is already set by Set")
	}

	if mmSimilarVectorsInCollection.defaultExpectation == nil {
		mmSimilarVectorsInCollection.defaultExpectation = &VectorDatabaseMockSimilarVectorsInCollectionExpectation{}
	}

	if mmSimilarVectorsInCollection.defaultExpectation.params != nil {
		mmSimilarVectorsInCollection.mock.t.Fatalf("VectorDatabaseMock.SimilarVectorsInCollection mock is already set by Expect")
	}

	if mmSimilarVectorsInCollection.defaultExpectation.paramPtrs == nil {
		mmSimilarVectorsInCollection.defaultExpectation.paramPtrs = &VectorDatabaseMockSimilarVectorsInCollectionParamPtrs{}
	}
	mmSimilarVectorsInCollection.defaultExpectation.paramPtrs.s1 = &s1
	mmSimilarVectorsInCollection.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmSimilarVectorsInCollection
}

// Inspect accepts an inspector function that has same arguments as the VectorDatabase.SimilarVectorsInCollection
func (mmSimilarVectorsInCollection *mVectorDatabaseMockSimilarVectorsInCollection) Inspect(f func(ctx context.Context, s1 mm_service.SimilarVectorSearchParam)) *mVectorDatabaseMockSimilarVectorsInCollection {
	if mmSimilarVectorsInCollection.mock.inspectFuncSimilarVectorsInCollection != nil {
		mmSimilarVectorsInCollection.mock.t.Fatalf("Inspect function is already set for VectorDatabaseMock.SimilarVectorsInCollection")
	}

	mmSimilarVectorsInCollection.mock.inspectFuncSimilarVectorsInCollection = f

	return mmSimilarVectorsInCollection
}

// Return sets up results that will be returned by VectorDatabase.SimilarVectorsInCollection
func (mmSimilarVectorsInCollection *mVectorDatabaseMockSimilarVectorsInCollection) Return(saa1 [][]mm_service.SimilarEmbedding, err error) *VectorDatabaseMock {
	if mmSimilarVectorsInCollection.mock.funcSimilarVectorsInCollection != nil {
		mmSimilarVectorsInCollection.mock.t.Fatalf("VectorDatabaseMock.SimilarVectorsInCollection mock is already set by Set")
	}

	if mmSimilarVectorsInCollection.defaultExpectation == nil {
		mmSimilarVectorsInCollection.defaultExpectation = &VectorDatabaseMockSimilarVectorsInCollectionExpectation{mock: mmSimilarVectorsInCollection.mock}
	}
	mmSimilarVectorsInCollection.defaultExpectation.results = &VectorDatabaseMockSimilarVectorsInCollectionResults{saa1, err}
	mmSimilarVectorsInCollection.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSimilarVectorsInCollection.mock
}

// Set uses given function f to mock the VectorDatabase.SimilarVectorsInCollection method
func (mmSimilarVectorsInCollection *mVectorDatabaseMockSimilarVectorsInCollection) Set(f func(ctx context.Context, s1 mm_service.SimilarVectorSearchParam) (saa1 [][]mm_service.SimilarEmbedding, err error)) *VectorDatabaseMock {
	if mmSimilarVectorsInCollection.defaultExpectation != nil {
		mmSimilarVectorsInCollection.mock.t.Fatalf("Default expectation is already set for the VectorDatabase.SimilarVectorsInCollection method")
	}

	if len(mmSimilarVectorsInCollection.expectations) > 0 {
		mmSimilarVectorsInCollection.mock.t.Fatalf("Some expectations are already set for the VectorDatabase.SimilarVectorsInCollection method")
	}

	mmSimilarVectorsInCollection.mock.funcSimilarVectorsInCollection = f
	mmSimilarVectorsInCollection.mock.funcSimilarVectorsInCollectionOrigin = minimock.CallerInfo(1)
	return mmSimilarVectorsInCollection.mock
}

// When sets expectation for the VectorDatabase.SimilarVectorsInCollection which will trigger the result defined by the following
// Then helper
func (mmSimilarVectorsInCollection *mVectorDatabaseMockSimilarVectorsInCollection) When(ctx context.Context, s1 mm_service.SimilarVectorSearchParam) *VectorDatabaseMockSimilarVectorsInCollectionExpectation {
	if mmSimilarVectorsInCollection.mock.funcSimilarVectorsInCollection != nil {
		mmSimilarVectorsInCollection.mock.t.Fatalf("VectorDatabaseMock.SimilarVectorsInCollection mock is already set by Set")
	}

	expectation := &VectorDatabaseMockSimilarVectorsInCollectionExpectation{
		mock:               mmSimilarVectorsInCollection.mock,
		params:             &VectorDatabaseMockSimilarVectorsInCollectionParams{ctx, s1},
		expectationOrigins: VectorDatabaseMockSimilarVectorsInCollectionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSimilarVectorsInCollection.expectations = append(mmSimilarVectorsInCollection.expectations, expectation)
	return expectation
}

// Then sets up VectorDatabase.SimilarVectorsInCollection return parameters for the expectation previously defined by the When method
func (e *VectorDatabaseMockSimilarVectorsInCollectionExpectation) Then(saa1 [][]mm_service.SimilarEmbedding, err error) *VectorDatabaseMock {
	e.results = &VectorDatabaseMockSimilarVectorsInCollectionResults{saa1, err}
	return e.mock
}

// Times sets number of times VectorDatabase.SimilarVectorsInCollection should be invoked
func (mmSimilarVectorsInCollection *mVectorDatabaseMockSimilarVectorsInCollection) Times(n uint64) *mVectorDatabaseMockSimilarVectorsInCollection {
	if n == 0 {
		mmSimilarVectorsInCollection.mock.t.Fatalf("Times of VectorDatabaseMock.SimilarVectorsInCollection mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSimilarVectorsInCollection.expectedInvocations, n)
	mmSimilarVectorsInCollection.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSimilarVectorsInCollection
}

func (mmSimilarVectorsInCollection *mVectorDatabaseMockSimilarVectorsInCollection) invocationsDone() bool {
	if len(mmSimilarVectorsInCollection.expectations) == 0 && mmSimilarVectorsInCollection.defaultExpectation == nil && mmSimilarVectorsInCollection.mock.funcSimilarVectorsInCollection == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSimilarVectorsInCollection.mock.afterSimilarVectorsInCollectionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSimilarVectorsInCollection.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SimilarVectorsInCollection implements mm_service.VectorDatabase
func (mmSimilarVectorsInCollection *VectorDatabaseMock) SimilarVectorsInCollection(ctx context.Context, s1 mm_service.SimilarVectorSearchParam) (saa1 [][]mm_service.SimilarEmbedding, err error) {
	mm_atomic.AddUint64(&mmSimilarVectorsInCollection.beforeSimilarVectorsInCollectionCounter, 1)
	defer mm_atomic.AddUint64(&mmSimilarVectorsInCollection.afterSimilarVectorsInCollectionCounter, 1)

	mmSimilarVectorsInCollection.t.Helper()

	if mmSimilarVectorsInCollection.inspectFuncSimilarVectorsInCollection != nil {
		mmSimilarVectorsInCollection.inspectFuncSimilarVectorsInCollection(ctx, s1)
	}

	mm_params := VectorDatabaseMockSimilarVectorsInCollectionParams{ctx, s1}

	// Record call args
	mmSimilarVectorsInCollection.SimilarVectorsInCollectionMock.mutex.Lock()
	mmSimilarVectorsInCollection.SimilarVectorsInCollectionMock.callArgs = append(mmSimilarVectorsInCollection.SimilarVectorsInCollectionMock.callArgs, &mm_params)
	mmSimilarVectorsInCollection.SimilarVectorsInCollectionMock.mutex.Unlock()

	for _, e := range mmSimilarVectorsInCollection.SimilarVectorsInCollectionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.saa1, e.results.err
		}
	}

	if mmSimilarVectorsInCollection.SimilarVectorsInCollectionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSimilarVectorsInCollection.SimilarVectorsInCollectionMock.defaultExpectation.Counter, 1)
		mm_want := mmSimilarVectorsInCollection.SimilarVectorsInCollectionMock.defaultExpectation.params
		mm_want_ptrs := mmSimilarVectorsInCollection.SimilarVectorsInCollectionMock.defaultExpectation.paramPtrs

		mm_got := VectorDatabaseMockSimilarVectorsInCollectionParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSimilarVectorsInCollection.t.Errorf("VectorDatabaseMock.SimilarVectorsInCollection got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSimilarVectorsInCollection.SimilarVectorsInCollectionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmSimilarVectorsInCollection.t.Errorf("VectorDatabaseMock.SimilarVectorsInCollection got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSimilarVectorsInCollection.SimilarVectorsInCollectionMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSimilarVectorsInCollection.t.Errorf("VectorDatabaseMock.SimilarVectorsInCollection got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSimilarVectorsInCollection.SimilarVectorsInCollectionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSimilarVectorsInCollection.SimilarVectorsInCollectionMock.defaultExpectation.results
		if mm_results == nil {
			mmSimilarVectorsInCollection.t.Fatal("No results are set for the VectorDatabaseMock.SimilarVectorsInCollection")
		}
		return (*mm_results).saa1, (*mm_results).err
	}
	if mmSimilarVectorsInCollection.funcSimilarVectorsInCollection != nil {
		return mmSimilarVectorsInCollection.funcSimilarVectorsInCollection(ctx, s1)
	}
	mmSimilarVectorsInCollection.t.Fatalf("Unexpected call to VectorDatabaseMock.SimilarVectorsInCollection. %v %v", ctx, s1)
	return
}

// SimilarVectorsInCollectionAfterCounter returns a count of finished VectorDatabaseMock.SimilarVectorsInCollection invocations
func (mmSimilarVectorsInCollection *VectorDatabaseMock) SimilarVectorsInCollectionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSimilarVectorsInCollection.afterSimilarVectorsInCollectionCounter)
}

// SimilarVectorsInCollectionBeforeCounter returns a count of VectorDatabaseMock.SimilarVectorsInCollection invocations
func (mmSimilarVectorsInCollection *VectorDatabaseMock) SimilarVectorsInCollectionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSimilarVectorsInCollection.beforeSimilarVectorsInCollectionCounter)
}

// Calls returns a list of arguments used in each call to VectorDatabaseMock.SimilarVectorsInCollection.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSimilarVectorsInCollection *mVectorDatabaseMockSimilarVectorsInCollection) Calls() []*VectorDatabaseMockSimilarVectorsInCollectionParams {
	mmSimilarVectorsInCollection.mutex.RLock()

	argCopy := make([]*VectorDatabaseMockSimilarVectorsInCollectionParams, len(mmSimilarVectorsInCollection.callArgs))
	copy(argCopy, mmSimilarVectorsInCollection.callArgs)

	mmSimilarVectorsInCollection.mutex.RUnlock()

	return argCopy
}

// MinimockSimilarVectorsInCollectionDone returns true if the count of the SimilarVectorsInCollection invocations corresponds
// the number of defined expectations
func (m *VectorDatabaseMock) MinimockSimilarVectorsInCollectionDone() bool {
	if m.SimilarVectorsInCollectionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SimilarVectorsInCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SimilarVectorsInCollectionMock.invocationsDone()
}

// MinimockSimilarVectorsInCollectionInspect logs each unmet expectation
func (m *VectorDatabaseMock) MinimockSimilarVectorsInCollectionInspect() {
	for _, e := range m.SimilarVectorsInCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to VectorDatabaseMock.SimilarVectorsInCollection at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSimilarVectorsInCollectionCounter := mm_atomic.LoadUint64(&m.afterSimilarVectorsInCollectionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SimilarVectorsInCollectionMock.defaultExpectation != nil && afterSimilarVectorsInCollectionCounter < 1 {
		if m.SimilarVectorsInCollectionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to VectorDatabaseMock.SimilarVectorsInCollection at\n%s", m.SimilarVectorsInCollectionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to VectorDatabaseMock.SimilarVectorsInCollection at\n%s with params: %#v", m.SimilarVectorsInCollectionMock.defaultExpectation.expectationOrigins.origin, *m.SimilarVectorsInCollectionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSimilarVectorsInCollection != nil && afterSimilarVectorsInCollectionCounter < 1 {
		m.t.Errorf("Expected call to VectorDatabaseMock.SimilarVectorsInCollection at\n%s", m.funcSimilarVectorsInCollectionOrigin)
	}

	if !m.SimilarVectorsInCollectionMock.invocationsDone() && afterSimilarVectorsInCollectionCounter > 0 {
		m.t.Errorf("Expected %d calls to VectorDatabaseMock.SimilarVectorsInCollection at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SimilarVectorsInCollectionMock.expectedInvocations), m.SimilarVectorsInCollectionMock.expectedInvocationsOrigin, afterSimilarVectorsInCollectionCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *VectorDatabaseMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCheckFileUIDMetadataInspect()

			m.MinimockCreateCollectionInspect()

			m.MinimockDeleteEmbeddingsWithFileUIDInspect()

			m.MinimockDropCollectionInspect()

			m.MinimockFlushCollectionInspect()

			m.MinimockInsertVectorsInCollectionInspect()

			m.MinimockSimilarVectorsInCollectionInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *VectorDatabaseMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *VectorDatabaseMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckFileUIDMetadataDone() &&
		m.MinimockCreateCollectionDone() &&
		m.MinimockDeleteEmbeddingsWithFileUIDDone() &&
		m.MinimockDropCollectionDone() &&
		m.MinimockFlushCollectionDone() &&
		m.MinimockInsertVectorsInCollectionDone() &&
		m.MinimockSimilarVectorsInCollectionDone()
}
