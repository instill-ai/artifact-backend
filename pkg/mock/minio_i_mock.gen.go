// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mock

import (
	"context"
	"net/url"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gofrs/uuid"
	"github.com/gojuno/minimock/v3"
	"github.com/minio/minio-go/v7"
)

// MinioIMock implements mm_minio.MinioI
type MinioIMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDeleteFile          func(ctx context.Context, bucket string, filePath string) (err error)
	funcDeleteFileOrigin    string
	inspectFuncDeleteFile   func(ctx context.Context, bucket string, filePath string)
	afterDeleteFileCounter  uint64
	beforeDeleteFileCounter uint64
	DeleteFileMock          mMinioIMockDeleteFile

	funcGetFile          func(ctx context.Context, bucket string, filePath string) (ba1 []byte, err error)
	funcGetFileOrigin    string
	inspectFuncGetFile   func(ctx context.Context, bucket string, filePath string)
	afterGetFileCounter  uint64
	beforeGetFileCounter uint64
	GetFileMock          mMinioIMockGetFile

	funcGetFileMetadata          func(ctx context.Context, bucket string, filePath string) (op1 *minio.ObjectInfo, err error)
	funcGetFileMetadataOrigin    string
	inspectFuncGetFileMetadata   func(ctx context.Context, bucket string, filePath string)
	afterGetFileMetadataCounter  uint64
	beforeGetFileMetadataCounter uint64
	GetFileMetadataMock          mMinioIMockGetFileMetadata

	funcGetPresignedURLForDownload          func(ctx context.Context, namespaceUUID uuid.UUID, objectUUID uuid.UUID, filename string, contentType string, urlExpiration time.Duration) (up1 *url.URL, err error)
	funcGetPresignedURLForDownloadOrigin    string
	inspectFuncGetPresignedURLForDownload   func(ctx context.Context, namespaceUUID uuid.UUID, objectUUID uuid.UUID, filename string, contentType string, urlExpiration time.Duration)
	afterGetPresignedURLForDownloadCounter  uint64
	beforeGetPresignedURLForDownloadCounter uint64
	GetPresignedURLForDownloadMock          mMinioIMockGetPresignedURLForDownload

	funcGetPresignedURLForUpload          func(ctx context.Context, namespaceUUID uuid.UUID, objectUUID uuid.UUID, filename string, urlExpiration time.Duration) (up1 *url.URL, err error)
	funcGetPresignedURLForUploadOrigin    string
	inspectFuncGetPresignedURLForUpload   func(ctx context.Context, namespaceUUID uuid.UUID, objectUUID uuid.UUID, filename string, urlExpiration time.Duration)
	afterGetPresignedURLForUploadCounter  uint64
	beforeGetPresignedURLForUploadCounter uint64
	GetPresignedURLForUploadMock          mMinioIMockGetPresignedURLForUpload

	funcListConvertedFilesByFileUID          func(ctx context.Context, kbUID uuid.UUID, fileUID uuid.UUID) (sa1 []string, err error)
	funcListConvertedFilesByFileUIDOrigin    string
	inspectFuncListConvertedFilesByFileUID   func(ctx context.Context, kbUID uuid.UUID, fileUID uuid.UUID)
	afterListConvertedFilesByFileUIDCounter  uint64
	beforeListConvertedFilesByFileUIDCounter uint64
	ListConvertedFilesByFileUIDMock          mMinioIMockListConvertedFilesByFileUID

	funcListFilePathsWithPrefix          func(ctx context.Context, bucket string, prefix string) (sa1 []string, err error)
	funcListFilePathsWithPrefixOrigin    string
	inspectFuncListFilePathsWithPrefix   func(ctx context.Context, bucket string, prefix string)
	afterListFilePathsWithPrefixCounter  uint64
	beforeListFilePathsWithPrefixCounter uint64
	ListFilePathsWithPrefixMock          mMinioIMockListFilePathsWithPrefix

	funcListKnowledgeBaseFiles          func(ctx context.Context, kbUID uuid.UUID) (sa1 []string, err error)
	funcListKnowledgeBaseFilesOrigin    string
	inspectFuncListKnowledgeBaseFiles   func(ctx context.Context, kbUID uuid.UUID)
	afterListKnowledgeBaseFilesCounter  uint64
	beforeListKnowledgeBaseFilesCounter uint64
	ListKnowledgeBaseFilesMock          mMinioIMockListKnowledgeBaseFiles

	funcListTextChunksByFileUID          func(ctx context.Context, kbUID uuid.UUID, fileUID uuid.UUID) (sa1 []string, err error)
	funcListTextChunksByFileUIDOrigin    string
	inspectFuncListTextChunksByFileUID   func(ctx context.Context, kbUID uuid.UUID, fileUID uuid.UUID)
	afterListTextChunksByFileUIDCounter  uint64
	beforeListTextChunksByFileUIDCounter uint64
	ListTextChunksByFileUIDMock          mMinioIMockListTextChunksByFileUID

	funcSaveConvertedFile          func(ctx context.Context, kbUID uuid.UUID, fileUID uuid.UUID, convertedFileUID uuid.UUID, fileExt string, content []byte) (path string, err error)
	funcSaveConvertedFileOrigin    string
	inspectFuncSaveConvertedFile   func(ctx context.Context, kbUID uuid.UUID, fileUID uuid.UUID, convertedFileUID uuid.UUID, fileExt string, content []byte)
	afterSaveConvertedFileCounter  uint64
	beforeSaveConvertedFileCounter uint64
	SaveConvertedFileMock          mMinioIMockSaveConvertedFile

	funcUploadBase64File          func(ctx context.Context, bucket string, filePath string, base64Content string, fileMimeType string) (err error)
	funcUploadBase64FileOrigin    string
	inspectFuncUploadBase64File   func(ctx context.Context, bucket string, filePath string, base64Content string, fileMimeType string)
	afterUploadBase64FileCounter  uint64
	beforeUploadBase64FileCounter uint64
	UploadBase64FileMock          mMinioIMockUploadBase64File
}

// NewMinioIMock returns a mock for mm_minio.MinioI
func NewMinioIMock(t minimock.Tester) *MinioIMock {
	m := &MinioIMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeleteFileMock = mMinioIMockDeleteFile{mock: m}
	m.DeleteFileMock.callArgs = []*MinioIMockDeleteFileParams{}

	m.GetFileMock = mMinioIMockGetFile{mock: m}
	m.GetFileMock.callArgs = []*MinioIMockGetFileParams{}

	m.GetFileMetadataMock = mMinioIMockGetFileMetadata{mock: m}
	m.GetFileMetadataMock.callArgs = []*MinioIMockGetFileMetadataParams{}

	m.GetPresignedURLForDownloadMock = mMinioIMockGetPresignedURLForDownload{mock: m}
	m.GetPresignedURLForDownloadMock.callArgs = []*MinioIMockGetPresignedURLForDownloadParams{}

	m.GetPresignedURLForUploadMock = mMinioIMockGetPresignedURLForUpload{mock: m}
	m.GetPresignedURLForUploadMock.callArgs = []*MinioIMockGetPresignedURLForUploadParams{}

	m.ListConvertedFilesByFileUIDMock = mMinioIMockListConvertedFilesByFileUID{mock: m}
	m.ListConvertedFilesByFileUIDMock.callArgs = []*MinioIMockListConvertedFilesByFileUIDParams{}

	m.ListFilePathsWithPrefixMock = mMinioIMockListFilePathsWithPrefix{mock: m}
	m.ListFilePathsWithPrefixMock.callArgs = []*MinioIMockListFilePathsWithPrefixParams{}

	m.ListKnowledgeBaseFilesMock = mMinioIMockListKnowledgeBaseFiles{mock: m}
	m.ListKnowledgeBaseFilesMock.callArgs = []*MinioIMockListKnowledgeBaseFilesParams{}

	m.ListTextChunksByFileUIDMock = mMinioIMockListTextChunksByFileUID{mock: m}
	m.ListTextChunksByFileUIDMock.callArgs = []*MinioIMockListTextChunksByFileUIDParams{}

	m.SaveConvertedFileMock = mMinioIMockSaveConvertedFile{mock: m}
	m.SaveConvertedFileMock.callArgs = []*MinioIMockSaveConvertedFileParams{}

	m.UploadBase64FileMock = mMinioIMockUploadBase64File{mock: m}
	m.UploadBase64FileMock.callArgs = []*MinioIMockUploadBase64FileParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mMinioIMockDeleteFile struct {
	optional           bool
	mock               *MinioIMock
	defaultExpectation *MinioIMockDeleteFileExpectation
	expectations       []*MinioIMockDeleteFileExpectation

	callArgs []*MinioIMockDeleteFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MinioIMockDeleteFileExpectation specifies expectation struct of the MinioI.DeleteFile
type MinioIMockDeleteFileExpectation struct {
	mock               *MinioIMock
	params             *MinioIMockDeleteFileParams
	paramPtrs          *MinioIMockDeleteFileParamPtrs
	expectationOrigins MinioIMockDeleteFileExpectationOrigins
	results            *MinioIMockDeleteFileResults
	returnOrigin       string
	Counter            uint64
}

// MinioIMockDeleteFileParams contains parameters of the MinioI.DeleteFile
type MinioIMockDeleteFileParams struct {
	ctx      context.Context
	bucket   string
	filePath string
}

// MinioIMockDeleteFileParamPtrs contains pointers to parameters of the MinioI.DeleteFile
type MinioIMockDeleteFileParamPtrs struct {
	ctx      *context.Context
	bucket   *string
	filePath *string
}

// MinioIMockDeleteFileResults contains results of the MinioI.DeleteFile
type MinioIMockDeleteFileResults struct {
	err error
}

// MinioIMockDeleteFileOrigins contains origins of expectations of the MinioI.DeleteFile
type MinioIMockDeleteFileExpectationOrigins struct {
	origin         string
	originCtx      string
	originBucket   string
	originFilePath string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteFile *mMinioIMockDeleteFile) Optional() *mMinioIMockDeleteFile {
	mmDeleteFile.optional = true
	return mmDeleteFile
}

// Expect sets up expected params for MinioI.DeleteFile
func (mmDeleteFile *mMinioIMockDeleteFile) Expect(ctx context.Context, bucket string, filePath string) *mMinioIMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("MinioIMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &MinioIMockDeleteFileExpectation{}
	}

	if mmDeleteFile.defaultExpectation.paramPtrs != nil {
		mmDeleteFile.mock.t.Fatalf("MinioIMock.DeleteFile mock is already set by ExpectParams functions")
	}

	mmDeleteFile.defaultExpectation.params = &MinioIMockDeleteFileParams{ctx, bucket, filePath}
	mmDeleteFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteFile.expectations {
		if minimock.Equal(e.params, mmDeleteFile.defaultExpectation.params) {
			mmDeleteFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteFile.defaultExpectation.params)
		}
	}

	return mmDeleteFile
}

// ExpectCtxParam1 sets up expected param ctx for MinioI.DeleteFile
func (mmDeleteFile *mMinioIMockDeleteFile) ExpectCtxParam1(ctx context.Context) *mMinioIMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("MinioIMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &MinioIMockDeleteFileExpectation{}
	}

	if mmDeleteFile.defaultExpectation.params != nil {
		mmDeleteFile.mock.t.Fatalf("MinioIMock.DeleteFile mock is already set by Expect")
	}

	if mmDeleteFile.defaultExpectation.paramPtrs == nil {
		mmDeleteFile.defaultExpectation.paramPtrs = &MinioIMockDeleteFileParamPtrs{}
	}
	mmDeleteFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteFile
}

// ExpectBucketParam2 sets up expected param bucket for MinioI.DeleteFile
func (mmDeleteFile *mMinioIMockDeleteFile) ExpectBucketParam2(bucket string) *mMinioIMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("MinioIMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &MinioIMockDeleteFileExpectation{}
	}

	if mmDeleteFile.defaultExpectation.params != nil {
		mmDeleteFile.mock.t.Fatalf("MinioIMock.DeleteFile mock is already set by Expect")
	}

	if mmDeleteFile.defaultExpectation.paramPtrs == nil {
		mmDeleteFile.defaultExpectation.paramPtrs = &MinioIMockDeleteFileParamPtrs{}
	}
	mmDeleteFile.defaultExpectation.paramPtrs.bucket = &bucket
	mmDeleteFile.defaultExpectation.expectationOrigins.originBucket = minimock.CallerInfo(1)

	return mmDeleteFile
}

// ExpectFilePathParam3 sets up expected param filePath for MinioI.DeleteFile
func (mmDeleteFile *mMinioIMockDeleteFile) ExpectFilePathParam3(filePath string) *mMinioIMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("MinioIMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &MinioIMockDeleteFileExpectation{}
	}

	if mmDeleteFile.defaultExpectation.params != nil {
		mmDeleteFile.mock.t.Fatalf("MinioIMock.DeleteFile mock is already set by Expect")
	}

	if mmDeleteFile.defaultExpectation.paramPtrs == nil {
		mmDeleteFile.defaultExpectation.paramPtrs = &MinioIMockDeleteFileParamPtrs{}
	}
	mmDeleteFile.defaultExpectation.paramPtrs.filePath = &filePath
	mmDeleteFile.defaultExpectation.expectationOrigins.originFilePath = minimock.CallerInfo(1)

	return mmDeleteFile
}

// Inspect accepts an inspector function that has same arguments as the MinioI.DeleteFile
func (mmDeleteFile *mMinioIMockDeleteFile) Inspect(f func(ctx context.Context, bucket string, filePath string)) *mMinioIMockDeleteFile {
	if mmDeleteFile.mock.inspectFuncDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("Inspect function is already set for MinioIMock.DeleteFile")
	}

	mmDeleteFile.mock.inspectFuncDeleteFile = f

	return mmDeleteFile
}

// Return sets up results that will be returned by MinioI.DeleteFile
func (mmDeleteFile *mMinioIMockDeleteFile) Return(err error) *MinioIMock {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("MinioIMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &MinioIMockDeleteFileExpectation{mock: mmDeleteFile.mock}
	}
	mmDeleteFile.defaultExpectation.results = &MinioIMockDeleteFileResults{err}
	mmDeleteFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteFile.mock
}

// Set uses given function f to mock the MinioI.DeleteFile method
func (mmDeleteFile *mMinioIMockDeleteFile) Set(f func(ctx context.Context, bucket string, filePath string) (err error)) *MinioIMock {
	if mmDeleteFile.defaultExpectation != nil {
		mmDeleteFile.mock.t.Fatalf("Default expectation is already set for the MinioI.DeleteFile method")
	}

	if len(mmDeleteFile.expectations) > 0 {
		mmDeleteFile.mock.t.Fatalf("Some expectations are already set for the MinioI.DeleteFile method")
	}

	mmDeleteFile.mock.funcDeleteFile = f
	mmDeleteFile.mock.funcDeleteFileOrigin = minimock.CallerInfo(1)
	return mmDeleteFile.mock
}

// When sets expectation for the MinioI.DeleteFile which will trigger the result defined by the following
// Then helper
func (mmDeleteFile *mMinioIMockDeleteFile) When(ctx context.Context, bucket string, filePath string) *MinioIMockDeleteFileExpectation {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("MinioIMock.DeleteFile mock is already set by Set")
	}

	expectation := &MinioIMockDeleteFileExpectation{
		mock:               mmDeleteFile.mock,
		params:             &MinioIMockDeleteFileParams{ctx, bucket, filePath},
		expectationOrigins: MinioIMockDeleteFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteFile.expectations = append(mmDeleteFile.expectations, expectation)
	return expectation
}

// Then sets up MinioI.DeleteFile return parameters for the expectation previously defined by the When method
func (e *MinioIMockDeleteFileExpectation) Then(err error) *MinioIMock {
	e.results = &MinioIMockDeleteFileResults{err}
	return e.mock
}

// Times sets number of times MinioI.DeleteFile should be invoked
func (mmDeleteFile *mMinioIMockDeleteFile) Times(n uint64) *mMinioIMockDeleteFile {
	if n == 0 {
		mmDeleteFile.mock.t.Fatalf("Times of MinioIMock.DeleteFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteFile.expectedInvocations, n)
	mmDeleteFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteFile
}

func (mmDeleteFile *mMinioIMockDeleteFile) invocationsDone() bool {
	if len(mmDeleteFile.expectations) == 0 && mmDeleteFile.defaultExpectation == nil && mmDeleteFile.mock.funcDeleteFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteFile.mock.afterDeleteFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteFile implements mm_minio.MinioI
func (mmDeleteFile *MinioIMock) DeleteFile(ctx context.Context, bucket string, filePath string) (err error) {
	mm_atomic.AddUint64(&mmDeleteFile.beforeDeleteFileCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteFile.afterDeleteFileCounter, 1)

	mmDeleteFile.t.Helper()

	if mmDeleteFile.inspectFuncDeleteFile != nil {
		mmDeleteFile.inspectFuncDeleteFile(ctx, bucket, filePath)
	}

	mm_params := MinioIMockDeleteFileParams{ctx, bucket, filePath}

	// Record call args
	mmDeleteFile.DeleteFileMock.mutex.Lock()
	mmDeleteFile.DeleteFileMock.callArgs = append(mmDeleteFile.DeleteFileMock.callArgs, &mm_params)
	mmDeleteFile.DeleteFileMock.mutex.Unlock()

	for _, e := range mmDeleteFile.DeleteFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteFile.DeleteFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteFile.DeleteFileMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteFile.DeleteFileMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteFile.DeleteFileMock.defaultExpectation.paramPtrs

		mm_got := MinioIMockDeleteFileParams{ctx, bucket, filePath}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteFile.t.Errorf("MinioIMock.DeleteFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFile.DeleteFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.bucket != nil && !minimock.Equal(*mm_want_ptrs.bucket, mm_got.bucket) {
				mmDeleteFile.t.Errorf("MinioIMock.DeleteFile got unexpected parameter bucket, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFile.DeleteFileMock.defaultExpectation.expectationOrigins.originBucket, *mm_want_ptrs.bucket, mm_got.bucket, minimock.Diff(*mm_want_ptrs.bucket, mm_got.bucket))
			}

			if mm_want_ptrs.filePath != nil && !minimock.Equal(*mm_want_ptrs.filePath, mm_got.filePath) {
				mmDeleteFile.t.Errorf("MinioIMock.DeleteFile got unexpected parameter filePath, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFile.DeleteFileMock.defaultExpectation.expectationOrigins.originFilePath, *mm_want_ptrs.filePath, mm_got.filePath, minimock.Diff(*mm_want_ptrs.filePath, mm_got.filePath))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteFile.t.Errorf("MinioIMock.DeleteFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteFile.DeleteFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteFile.DeleteFileMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteFile.t.Fatal("No results are set for the MinioIMock.DeleteFile")
		}
		return (*mm_results).err
	}
	if mmDeleteFile.funcDeleteFile != nil {
		return mmDeleteFile.funcDeleteFile(ctx, bucket, filePath)
	}
	mmDeleteFile.t.Fatalf("Unexpected call to MinioIMock.DeleteFile. %v %v %v", ctx, bucket, filePath)
	return
}

// DeleteFileAfterCounter returns a count of finished MinioIMock.DeleteFile invocations
func (mmDeleteFile *MinioIMock) DeleteFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFile.afterDeleteFileCounter)
}

// DeleteFileBeforeCounter returns a count of MinioIMock.DeleteFile invocations
func (mmDeleteFile *MinioIMock) DeleteFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFile.beforeDeleteFileCounter)
}

// Calls returns a list of arguments used in each call to MinioIMock.DeleteFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteFile *mMinioIMockDeleteFile) Calls() []*MinioIMockDeleteFileParams {
	mmDeleteFile.mutex.RLock()

	argCopy := make([]*MinioIMockDeleteFileParams, len(mmDeleteFile.callArgs))
	copy(argCopy, mmDeleteFile.callArgs)

	mmDeleteFile.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteFileDone returns true if the count of the DeleteFile invocations corresponds
// the number of defined expectations
func (m *MinioIMock) MinimockDeleteFileDone() bool {
	if m.DeleteFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteFileMock.invocationsDone()
}

// MinimockDeleteFileInspect logs each unmet expectation
func (m *MinioIMock) MinimockDeleteFileInspect() {
	for _, e := range m.DeleteFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinioIMock.DeleteFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteFileCounter := mm_atomic.LoadUint64(&m.afterDeleteFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFileMock.defaultExpectation != nil && afterDeleteFileCounter < 1 {
		if m.DeleteFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MinioIMock.DeleteFile at\n%s", m.DeleteFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MinioIMock.DeleteFile at\n%s with params: %#v", m.DeleteFileMock.defaultExpectation.expectationOrigins.origin, *m.DeleteFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFile != nil && afterDeleteFileCounter < 1 {
		m.t.Errorf("Expected call to MinioIMock.DeleteFile at\n%s", m.funcDeleteFileOrigin)
	}

	if !m.DeleteFileMock.invocationsDone() && afterDeleteFileCounter > 0 {
		m.t.Errorf("Expected %d calls to MinioIMock.DeleteFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteFileMock.expectedInvocations), m.DeleteFileMock.expectedInvocationsOrigin, afterDeleteFileCounter)
	}
}

type mMinioIMockGetFile struct {
	optional           bool
	mock               *MinioIMock
	defaultExpectation *MinioIMockGetFileExpectation
	expectations       []*MinioIMockGetFileExpectation

	callArgs []*MinioIMockGetFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MinioIMockGetFileExpectation specifies expectation struct of the MinioI.GetFile
type MinioIMockGetFileExpectation struct {
	mock               *MinioIMock
	params             *MinioIMockGetFileParams
	paramPtrs          *MinioIMockGetFileParamPtrs
	expectationOrigins MinioIMockGetFileExpectationOrigins
	results            *MinioIMockGetFileResults
	returnOrigin       string
	Counter            uint64
}

// MinioIMockGetFileParams contains parameters of the MinioI.GetFile
type MinioIMockGetFileParams struct {
	ctx      context.Context
	bucket   string
	filePath string
}

// MinioIMockGetFileParamPtrs contains pointers to parameters of the MinioI.GetFile
type MinioIMockGetFileParamPtrs struct {
	ctx      *context.Context
	bucket   *string
	filePath *string
}

// MinioIMockGetFileResults contains results of the MinioI.GetFile
type MinioIMockGetFileResults struct {
	ba1 []byte
	err error
}

// MinioIMockGetFileOrigins contains origins of expectations of the MinioI.GetFile
type MinioIMockGetFileExpectationOrigins struct {
	origin         string
	originCtx      string
	originBucket   string
	originFilePath string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFile *mMinioIMockGetFile) Optional() *mMinioIMockGetFile {
	mmGetFile.optional = true
	return mmGetFile
}

// Expect sets up expected params for MinioI.GetFile
func (mmGetFile *mMinioIMockGetFile) Expect(ctx context.Context, bucket string, filePath string) *mMinioIMockGetFile {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("MinioIMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &MinioIMockGetFileExpectation{}
	}

	if mmGetFile.defaultExpectation.paramPtrs != nil {
		mmGetFile.mock.t.Fatalf("MinioIMock.GetFile mock is already set by ExpectParams functions")
	}

	mmGetFile.defaultExpectation.params = &MinioIMockGetFileParams{ctx, bucket, filePath}
	mmGetFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetFile.expectations {
		if minimock.Equal(e.params, mmGetFile.defaultExpectation.params) {
			mmGetFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFile.defaultExpectation.params)
		}
	}

	return mmGetFile
}

// ExpectCtxParam1 sets up expected param ctx for MinioI.GetFile
func (mmGetFile *mMinioIMockGetFile) ExpectCtxParam1(ctx context.Context) *mMinioIMockGetFile {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("MinioIMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &MinioIMockGetFileExpectation{}
	}

	if mmGetFile.defaultExpectation.params != nil {
		mmGetFile.mock.t.Fatalf("MinioIMock.GetFile mock is already set by Expect")
	}

	if mmGetFile.defaultExpectation.paramPtrs == nil {
		mmGetFile.defaultExpectation.paramPtrs = &MinioIMockGetFileParamPtrs{}
	}
	mmGetFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetFile
}

// ExpectBucketParam2 sets up expected param bucket for MinioI.GetFile
func (mmGetFile *mMinioIMockGetFile) ExpectBucketParam2(bucket string) *mMinioIMockGetFile {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("MinioIMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &MinioIMockGetFileExpectation{}
	}

	if mmGetFile.defaultExpectation.params != nil {
		mmGetFile.mock.t.Fatalf("MinioIMock.GetFile mock is already set by Expect")
	}

	if mmGetFile.defaultExpectation.paramPtrs == nil {
		mmGetFile.defaultExpectation.paramPtrs = &MinioIMockGetFileParamPtrs{}
	}
	mmGetFile.defaultExpectation.paramPtrs.bucket = &bucket
	mmGetFile.defaultExpectation.expectationOrigins.originBucket = minimock.CallerInfo(1)

	return mmGetFile
}

// ExpectFilePathParam3 sets up expected param filePath for MinioI.GetFile
func (mmGetFile *mMinioIMockGetFile) ExpectFilePathParam3(filePath string) *mMinioIMockGetFile {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("MinioIMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &MinioIMockGetFileExpectation{}
	}

	if mmGetFile.defaultExpectation.params != nil {
		mmGetFile.mock.t.Fatalf("MinioIMock.GetFile mock is already set by Expect")
	}

	if mmGetFile.defaultExpectation.paramPtrs == nil {
		mmGetFile.defaultExpectation.paramPtrs = &MinioIMockGetFileParamPtrs{}
	}
	mmGetFile.defaultExpectation.paramPtrs.filePath = &filePath
	mmGetFile.defaultExpectation.expectationOrigins.originFilePath = minimock.CallerInfo(1)

	return mmGetFile
}

// Inspect accepts an inspector function that has same arguments as the MinioI.GetFile
func (mmGetFile *mMinioIMockGetFile) Inspect(f func(ctx context.Context, bucket string, filePath string)) *mMinioIMockGetFile {
	if mmGetFile.mock.inspectFuncGetFile != nil {
		mmGetFile.mock.t.Fatalf("Inspect function is already set for MinioIMock.GetFile")
	}

	mmGetFile.mock.inspectFuncGetFile = f

	return mmGetFile
}

// Return sets up results that will be returned by MinioI.GetFile
func (mmGetFile *mMinioIMockGetFile) Return(ba1 []byte, err error) *MinioIMock {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("MinioIMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &MinioIMockGetFileExpectation{mock: mmGetFile.mock}
	}
	mmGetFile.defaultExpectation.results = &MinioIMockGetFileResults{ba1, err}
	mmGetFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetFile.mock
}

// Set uses given function f to mock the MinioI.GetFile method
func (mmGetFile *mMinioIMockGetFile) Set(f func(ctx context.Context, bucket string, filePath string) (ba1 []byte, err error)) *MinioIMock {
	if mmGetFile.defaultExpectation != nil {
		mmGetFile.mock.t.Fatalf("Default expectation is already set for the MinioI.GetFile method")
	}

	if len(mmGetFile.expectations) > 0 {
		mmGetFile.mock.t.Fatalf("Some expectations are already set for the MinioI.GetFile method")
	}

	mmGetFile.mock.funcGetFile = f
	mmGetFile.mock.funcGetFileOrigin = minimock.CallerInfo(1)
	return mmGetFile.mock
}

// When sets expectation for the MinioI.GetFile which will trigger the result defined by the following
// Then helper
func (mmGetFile *mMinioIMockGetFile) When(ctx context.Context, bucket string, filePath string) *MinioIMockGetFileExpectation {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("MinioIMock.GetFile mock is already set by Set")
	}

	expectation := &MinioIMockGetFileExpectation{
		mock:               mmGetFile.mock,
		params:             &MinioIMockGetFileParams{ctx, bucket, filePath},
		expectationOrigins: MinioIMockGetFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetFile.expectations = append(mmGetFile.expectations, expectation)
	return expectation
}

// Then sets up MinioI.GetFile return parameters for the expectation previously defined by the When method
func (e *MinioIMockGetFileExpectation) Then(ba1 []byte, err error) *MinioIMock {
	e.results = &MinioIMockGetFileResults{ba1, err}
	return e.mock
}

// Times sets number of times MinioI.GetFile should be invoked
func (mmGetFile *mMinioIMockGetFile) Times(n uint64) *mMinioIMockGetFile {
	if n == 0 {
		mmGetFile.mock.t.Fatalf("Times of MinioIMock.GetFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFile.expectedInvocations, n)
	mmGetFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetFile
}

func (mmGetFile *mMinioIMockGetFile) invocationsDone() bool {
	if len(mmGetFile.expectations) == 0 && mmGetFile.defaultExpectation == nil && mmGetFile.mock.funcGetFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFile.mock.afterGetFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFile implements mm_minio.MinioI
func (mmGetFile *MinioIMock) GetFile(ctx context.Context, bucket string, filePath string) (ba1 []byte, err error) {
	mm_atomic.AddUint64(&mmGetFile.beforeGetFileCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFile.afterGetFileCounter, 1)

	mmGetFile.t.Helper()

	if mmGetFile.inspectFuncGetFile != nil {
		mmGetFile.inspectFuncGetFile(ctx, bucket, filePath)
	}

	mm_params := MinioIMockGetFileParams{ctx, bucket, filePath}

	// Record call args
	mmGetFile.GetFileMock.mutex.Lock()
	mmGetFile.GetFileMock.callArgs = append(mmGetFile.GetFileMock.callArgs, &mm_params)
	mmGetFile.GetFileMock.mutex.Unlock()

	for _, e := range mmGetFile.GetFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ba1, e.results.err
		}
	}

	if mmGetFile.GetFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFile.GetFileMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFile.GetFileMock.defaultExpectation.params
		mm_want_ptrs := mmGetFile.GetFileMock.defaultExpectation.paramPtrs

		mm_got := MinioIMockGetFileParams{ctx, bucket, filePath}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFile.t.Errorf("MinioIMock.GetFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFile.GetFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.bucket != nil && !minimock.Equal(*mm_want_ptrs.bucket, mm_got.bucket) {
				mmGetFile.t.Errorf("MinioIMock.GetFile got unexpected parameter bucket, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFile.GetFileMock.defaultExpectation.expectationOrigins.originBucket, *mm_want_ptrs.bucket, mm_got.bucket, minimock.Diff(*mm_want_ptrs.bucket, mm_got.bucket))
			}

			if mm_want_ptrs.filePath != nil && !minimock.Equal(*mm_want_ptrs.filePath, mm_got.filePath) {
				mmGetFile.t.Errorf("MinioIMock.GetFile got unexpected parameter filePath, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFile.GetFileMock.defaultExpectation.expectationOrigins.originFilePath, *mm_want_ptrs.filePath, mm_got.filePath, minimock.Diff(*mm_want_ptrs.filePath, mm_got.filePath))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFile.t.Errorf("MinioIMock.GetFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetFile.GetFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFile.GetFileMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFile.t.Fatal("No results are set for the MinioIMock.GetFile")
		}
		return (*mm_results).ba1, (*mm_results).err
	}
	if mmGetFile.funcGetFile != nil {
		return mmGetFile.funcGetFile(ctx, bucket, filePath)
	}
	mmGetFile.t.Fatalf("Unexpected call to MinioIMock.GetFile. %v %v %v", ctx, bucket, filePath)
	return
}

// GetFileAfterCounter returns a count of finished MinioIMock.GetFile invocations
func (mmGetFile *MinioIMock) GetFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFile.afterGetFileCounter)
}

// GetFileBeforeCounter returns a count of MinioIMock.GetFile invocations
func (mmGetFile *MinioIMock) GetFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFile.beforeGetFileCounter)
}

// Calls returns a list of arguments used in each call to MinioIMock.GetFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFile *mMinioIMockGetFile) Calls() []*MinioIMockGetFileParams {
	mmGetFile.mutex.RLock()

	argCopy := make([]*MinioIMockGetFileParams, len(mmGetFile.callArgs))
	copy(argCopy, mmGetFile.callArgs)

	mmGetFile.mutex.RUnlock()

	return argCopy
}

// MinimockGetFileDone returns true if the count of the GetFile invocations corresponds
// the number of defined expectations
func (m *MinioIMock) MinimockGetFileDone() bool {
	if m.GetFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFileMock.invocationsDone()
}

// MinimockGetFileInspect logs each unmet expectation
func (m *MinioIMock) MinimockGetFileInspect() {
	for _, e := range m.GetFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinioIMock.GetFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetFileCounter := mm_atomic.LoadUint64(&m.afterGetFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFileMock.defaultExpectation != nil && afterGetFileCounter < 1 {
		if m.GetFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MinioIMock.GetFile at\n%s", m.GetFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MinioIMock.GetFile at\n%s with params: %#v", m.GetFileMock.defaultExpectation.expectationOrigins.origin, *m.GetFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFile != nil && afterGetFileCounter < 1 {
		m.t.Errorf("Expected call to MinioIMock.GetFile at\n%s", m.funcGetFileOrigin)
	}

	if !m.GetFileMock.invocationsDone() && afterGetFileCounter > 0 {
		m.t.Errorf("Expected %d calls to MinioIMock.GetFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetFileMock.expectedInvocations), m.GetFileMock.expectedInvocationsOrigin, afterGetFileCounter)
	}
}

type mMinioIMockGetFileMetadata struct {
	optional           bool
	mock               *MinioIMock
	defaultExpectation *MinioIMockGetFileMetadataExpectation
	expectations       []*MinioIMockGetFileMetadataExpectation

	callArgs []*MinioIMockGetFileMetadataParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MinioIMockGetFileMetadataExpectation specifies expectation struct of the MinioI.GetFileMetadata
type MinioIMockGetFileMetadataExpectation struct {
	mock               *MinioIMock
	params             *MinioIMockGetFileMetadataParams
	paramPtrs          *MinioIMockGetFileMetadataParamPtrs
	expectationOrigins MinioIMockGetFileMetadataExpectationOrigins
	results            *MinioIMockGetFileMetadataResults
	returnOrigin       string
	Counter            uint64
}

// MinioIMockGetFileMetadataParams contains parameters of the MinioI.GetFileMetadata
type MinioIMockGetFileMetadataParams struct {
	ctx      context.Context
	bucket   string
	filePath string
}

// MinioIMockGetFileMetadataParamPtrs contains pointers to parameters of the MinioI.GetFileMetadata
type MinioIMockGetFileMetadataParamPtrs struct {
	ctx      *context.Context
	bucket   *string
	filePath *string
}

// MinioIMockGetFileMetadataResults contains results of the MinioI.GetFileMetadata
type MinioIMockGetFileMetadataResults struct {
	op1 *minio.ObjectInfo
	err error
}

// MinioIMockGetFileMetadataOrigins contains origins of expectations of the MinioI.GetFileMetadata
type MinioIMockGetFileMetadataExpectationOrigins struct {
	origin         string
	originCtx      string
	originBucket   string
	originFilePath string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFileMetadata *mMinioIMockGetFileMetadata) Optional() *mMinioIMockGetFileMetadata {
	mmGetFileMetadata.optional = true
	return mmGetFileMetadata
}

// Expect sets up expected params for MinioI.GetFileMetadata
func (mmGetFileMetadata *mMinioIMockGetFileMetadata) Expect(ctx context.Context, bucket string, filePath string) *mMinioIMockGetFileMetadata {
	if mmGetFileMetadata.mock.funcGetFileMetadata != nil {
		mmGetFileMetadata.mock.t.Fatalf("MinioIMock.GetFileMetadata mock is already set by Set")
	}

	if mmGetFileMetadata.defaultExpectation == nil {
		mmGetFileMetadata.defaultExpectation = &MinioIMockGetFileMetadataExpectation{}
	}

	if mmGetFileMetadata.defaultExpectation.paramPtrs != nil {
		mmGetFileMetadata.mock.t.Fatalf("MinioIMock.GetFileMetadata mock is already set by ExpectParams functions")
	}

	mmGetFileMetadata.defaultExpectation.params = &MinioIMockGetFileMetadataParams{ctx, bucket, filePath}
	mmGetFileMetadata.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetFileMetadata.expectations {
		if minimock.Equal(e.params, mmGetFileMetadata.defaultExpectation.params) {
			mmGetFileMetadata.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFileMetadata.defaultExpectation.params)
		}
	}

	return mmGetFileMetadata
}

// ExpectCtxParam1 sets up expected param ctx for MinioI.GetFileMetadata
func (mmGetFileMetadata *mMinioIMockGetFileMetadata) ExpectCtxParam1(ctx context.Context) *mMinioIMockGetFileMetadata {
	if mmGetFileMetadata.mock.funcGetFileMetadata != nil {
		mmGetFileMetadata.mock.t.Fatalf("MinioIMock.GetFileMetadata mock is already set by Set")
	}

	if mmGetFileMetadata.defaultExpectation == nil {
		mmGetFileMetadata.defaultExpectation = &MinioIMockGetFileMetadataExpectation{}
	}

	if mmGetFileMetadata.defaultExpectation.params != nil {
		mmGetFileMetadata.mock.t.Fatalf("MinioIMock.GetFileMetadata mock is already set by Expect")
	}

	if mmGetFileMetadata.defaultExpectation.paramPtrs == nil {
		mmGetFileMetadata.defaultExpectation.paramPtrs = &MinioIMockGetFileMetadataParamPtrs{}
	}
	mmGetFileMetadata.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetFileMetadata.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetFileMetadata
}

// ExpectBucketParam2 sets up expected param bucket for MinioI.GetFileMetadata
func (mmGetFileMetadata *mMinioIMockGetFileMetadata) ExpectBucketParam2(bucket string) *mMinioIMockGetFileMetadata {
	if mmGetFileMetadata.mock.funcGetFileMetadata != nil {
		mmGetFileMetadata.mock.t.Fatalf("MinioIMock.GetFileMetadata mock is already set by Set")
	}

	if mmGetFileMetadata.defaultExpectation == nil {
		mmGetFileMetadata.defaultExpectation = &MinioIMockGetFileMetadataExpectation{}
	}

	if mmGetFileMetadata.defaultExpectation.params != nil {
		mmGetFileMetadata.mock.t.Fatalf("MinioIMock.GetFileMetadata mock is already set by Expect")
	}

	if mmGetFileMetadata.defaultExpectation.paramPtrs == nil {
		mmGetFileMetadata.defaultExpectation.paramPtrs = &MinioIMockGetFileMetadataParamPtrs{}
	}
	mmGetFileMetadata.defaultExpectation.paramPtrs.bucket = &bucket
	mmGetFileMetadata.defaultExpectation.expectationOrigins.originBucket = minimock.CallerInfo(1)

	return mmGetFileMetadata
}

// ExpectFilePathParam3 sets up expected param filePath for MinioI.GetFileMetadata
func (mmGetFileMetadata *mMinioIMockGetFileMetadata) ExpectFilePathParam3(filePath string) *mMinioIMockGetFileMetadata {
	if mmGetFileMetadata.mock.funcGetFileMetadata != nil {
		mmGetFileMetadata.mock.t.Fatalf("MinioIMock.GetFileMetadata mock is already set by Set")
	}

	if mmGetFileMetadata.defaultExpectation == nil {
		mmGetFileMetadata.defaultExpectation = &MinioIMockGetFileMetadataExpectation{}
	}

	if mmGetFileMetadata.defaultExpectation.params != nil {
		mmGetFileMetadata.mock.t.Fatalf("MinioIMock.GetFileMetadata mock is already set by Expect")
	}

	if mmGetFileMetadata.defaultExpectation.paramPtrs == nil {
		mmGetFileMetadata.defaultExpectation.paramPtrs = &MinioIMockGetFileMetadataParamPtrs{}
	}
	mmGetFileMetadata.defaultExpectation.paramPtrs.filePath = &filePath
	mmGetFileMetadata.defaultExpectation.expectationOrigins.originFilePath = minimock.CallerInfo(1)

	return mmGetFileMetadata
}

// Inspect accepts an inspector function that has same arguments as the MinioI.GetFileMetadata
func (mmGetFileMetadata *mMinioIMockGetFileMetadata) Inspect(f func(ctx context.Context, bucket string, filePath string)) *mMinioIMockGetFileMetadata {
	if mmGetFileMetadata.mock.inspectFuncGetFileMetadata != nil {
		mmGetFileMetadata.mock.t.Fatalf("Inspect function is already set for MinioIMock.GetFileMetadata")
	}

	mmGetFileMetadata.mock.inspectFuncGetFileMetadata = f

	return mmGetFileMetadata
}

// Return sets up results that will be returned by MinioI.GetFileMetadata
func (mmGetFileMetadata *mMinioIMockGetFileMetadata) Return(op1 *minio.ObjectInfo, err error) *MinioIMock {
	if mmGetFileMetadata.mock.funcGetFileMetadata != nil {
		mmGetFileMetadata.mock.t.Fatalf("MinioIMock.GetFileMetadata mock is already set by Set")
	}

	if mmGetFileMetadata.defaultExpectation == nil {
		mmGetFileMetadata.defaultExpectation = &MinioIMockGetFileMetadataExpectation{mock: mmGetFileMetadata.mock}
	}
	mmGetFileMetadata.defaultExpectation.results = &MinioIMockGetFileMetadataResults{op1, err}
	mmGetFileMetadata.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetFileMetadata.mock
}

// Set uses given function f to mock the MinioI.GetFileMetadata method
func (mmGetFileMetadata *mMinioIMockGetFileMetadata) Set(f func(ctx context.Context, bucket string, filePath string) (op1 *minio.ObjectInfo, err error)) *MinioIMock {
	if mmGetFileMetadata.defaultExpectation != nil {
		mmGetFileMetadata.mock.t.Fatalf("Default expectation is already set for the MinioI.GetFileMetadata method")
	}

	if len(mmGetFileMetadata.expectations) > 0 {
		mmGetFileMetadata.mock.t.Fatalf("Some expectations are already set for the MinioI.GetFileMetadata method")
	}

	mmGetFileMetadata.mock.funcGetFileMetadata = f
	mmGetFileMetadata.mock.funcGetFileMetadataOrigin = minimock.CallerInfo(1)
	return mmGetFileMetadata.mock
}

// When sets expectation for the MinioI.GetFileMetadata which will trigger the result defined by the following
// Then helper
func (mmGetFileMetadata *mMinioIMockGetFileMetadata) When(ctx context.Context, bucket string, filePath string) *MinioIMockGetFileMetadataExpectation {
	if mmGetFileMetadata.mock.funcGetFileMetadata != nil {
		mmGetFileMetadata.mock.t.Fatalf("MinioIMock.GetFileMetadata mock is already set by Set")
	}

	expectation := &MinioIMockGetFileMetadataExpectation{
		mock:               mmGetFileMetadata.mock,
		params:             &MinioIMockGetFileMetadataParams{ctx, bucket, filePath},
		expectationOrigins: MinioIMockGetFileMetadataExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetFileMetadata.expectations = append(mmGetFileMetadata.expectations, expectation)
	return expectation
}

// Then sets up MinioI.GetFileMetadata return parameters for the expectation previously defined by the When method
func (e *MinioIMockGetFileMetadataExpectation) Then(op1 *minio.ObjectInfo, err error) *MinioIMock {
	e.results = &MinioIMockGetFileMetadataResults{op1, err}
	return e.mock
}

// Times sets number of times MinioI.GetFileMetadata should be invoked
func (mmGetFileMetadata *mMinioIMockGetFileMetadata) Times(n uint64) *mMinioIMockGetFileMetadata {
	if n == 0 {
		mmGetFileMetadata.mock.t.Fatalf("Times of MinioIMock.GetFileMetadata mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFileMetadata.expectedInvocations, n)
	mmGetFileMetadata.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetFileMetadata
}

func (mmGetFileMetadata *mMinioIMockGetFileMetadata) invocationsDone() bool {
	if len(mmGetFileMetadata.expectations) == 0 && mmGetFileMetadata.defaultExpectation == nil && mmGetFileMetadata.mock.funcGetFileMetadata == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFileMetadata.mock.afterGetFileMetadataCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFileMetadata.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFileMetadata implements mm_minio.MinioI
func (mmGetFileMetadata *MinioIMock) GetFileMetadata(ctx context.Context, bucket string, filePath string) (op1 *minio.ObjectInfo, err error) {
	mm_atomic.AddUint64(&mmGetFileMetadata.beforeGetFileMetadataCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFileMetadata.afterGetFileMetadataCounter, 1)

	mmGetFileMetadata.t.Helper()

	if mmGetFileMetadata.inspectFuncGetFileMetadata != nil {
		mmGetFileMetadata.inspectFuncGetFileMetadata(ctx, bucket, filePath)
	}

	mm_params := MinioIMockGetFileMetadataParams{ctx, bucket, filePath}

	// Record call args
	mmGetFileMetadata.GetFileMetadataMock.mutex.Lock()
	mmGetFileMetadata.GetFileMetadataMock.callArgs = append(mmGetFileMetadata.GetFileMetadataMock.callArgs, &mm_params)
	mmGetFileMetadata.GetFileMetadataMock.mutex.Unlock()

	for _, e := range mmGetFileMetadata.GetFileMetadataMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetFileMetadata.GetFileMetadataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFileMetadata.GetFileMetadataMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFileMetadata.GetFileMetadataMock.defaultExpectation.params
		mm_want_ptrs := mmGetFileMetadata.GetFileMetadataMock.defaultExpectation.paramPtrs

		mm_got := MinioIMockGetFileMetadataParams{ctx, bucket, filePath}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFileMetadata.t.Errorf("MinioIMock.GetFileMetadata got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFileMetadata.GetFileMetadataMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.bucket != nil && !minimock.Equal(*mm_want_ptrs.bucket, mm_got.bucket) {
				mmGetFileMetadata.t.Errorf("MinioIMock.GetFileMetadata got unexpected parameter bucket, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFileMetadata.GetFileMetadataMock.defaultExpectation.expectationOrigins.originBucket, *mm_want_ptrs.bucket, mm_got.bucket, minimock.Diff(*mm_want_ptrs.bucket, mm_got.bucket))
			}

			if mm_want_ptrs.filePath != nil && !minimock.Equal(*mm_want_ptrs.filePath, mm_got.filePath) {
				mmGetFileMetadata.t.Errorf("MinioIMock.GetFileMetadata got unexpected parameter filePath, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFileMetadata.GetFileMetadataMock.defaultExpectation.expectationOrigins.originFilePath, *mm_want_ptrs.filePath, mm_got.filePath, minimock.Diff(*mm_want_ptrs.filePath, mm_got.filePath))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFileMetadata.t.Errorf("MinioIMock.GetFileMetadata got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetFileMetadata.GetFileMetadataMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFileMetadata.GetFileMetadataMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFileMetadata.t.Fatal("No results are set for the MinioIMock.GetFileMetadata")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetFileMetadata.funcGetFileMetadata != nil {
		return mmGetFileMetadata.funcGetFileMetadata(ctx, bucket, filePath)
	}
	mmGetFileMetadata.t.Fatalf("Unexpected call to MinioIMock.GetFileMetadata. %v %v %v", ctx, bucket, filePath)
	return
}

// GetFileMetadataAfterCounter returns a count of finished MinioIMock.GetFileMetadata invocations
func (mmGetFileMetadata *MinioIMock) GetFileMetadataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFileMetadata.afterGetFileMetadataCounter)
}

// GetFileMetadataBeforeCounter returns a count of MinioIMock.GetFileMetadata invocations
func (mmGetFileMetadata *MinioIMock) GetFileMetadataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFileMetadata.beforeGetFileMetadataCounter)
}

// Calls returns a list of arguments used in each call to MinioIMock.GetFileMetadata.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFileMetadata *mMinioIMockGetFileMetadata) Calls() []*MinioIMockGetFileMetadataParams {
	mmGetFileMetadata.mutex.RLock()

	argCopy := make([]*MinioIMockGetFileMetadataParams, len(mmGetFileMetadata.callArgs))
	copy(argCopy, mmGetFileMetadata.callArgs)

	mmGetFileMetadata.mutex.RUnlock()

	return argCopy
}

// MinimockGetFileMetadataDone returns true if the count of the GetFileMetadata invocations corresponds
// the number of defined expectations
func (m *MinioIMock) MinimockGetFileMetadataDone() bool {
	if m.GetFileMetadataMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFileMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFileMetadataMock.invocationsDone()
}

// MinimockGetFileMetadataInspect logs each unmet expectation
func (m *MinioIMock) MinimockGetFileMetadataInspect() {
	for _, e := range m.GetFileMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinioIMock.GetFileMetadata at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetFileMetadataCounter := mm_atomic.LoadUint64(&m.afterGetFileMetadataCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFileMetadataMock.defaultExpectation != nil && afterGetFileMetadataCounter < 1 {
		if m.GetFileMetadataMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MinioIMock.GetFileMetadata at\n%s", m.GetFileMetadataMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MinioIMock.GetFileMetadata at\n%s with params: %#v", m.GetFileMetadataMock.defaultExpectation.expectationOrigins.origin, *m.GetFileMetadataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFileMetadata != nil && afterGetFileMetadataCounter < 1 {
		m.t.Errorf("Expected call to MinioIMock.GetFileMetadata at\n%s", m.funcGetFileMetadataOrigin)
	}

	if !m.GetFileMetadataMock.invocationsDone() && afterGetFileMetadataCounter > 0 {
		m.t.Errorf("Expected %d calls to MinioIMock.GetFileMetadata at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetFileMetadataMock.expectedInvocations), m.GetFileMetadataMock.expectedInvocationsOrigin, afterGetFileMetadataCounter)
	}
}

type mMinioIMockGetPresignedURLForDownload struct {
	optional           bool
	mock               *MinioIMock
	defaultExpectation *MinioIMockGetPresignedURLForDownloadExpectation
	expectations       []*MinioIMockGetPresignedURLForDownloadExpectation

	callArgs []*MinioIMockGetPresignedURLForDownloadParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MinioIMockGetPresignedURLForDownloadExpectation specifies expectation struct of the MinioI.GetPresignedURLForDownload
type MinioIMockGetPresignedURLForDownloadExpectation struct {
	mock               *MinioIMock
	params             *MinioIMockGetPresignedURLForDownloadParams
	paramPtrs          *MinioIMockGetPresignedURLForDownloadParamPtrs
	expectationOrigins MinioIMockGetPresignedURLForDownloadExpectationOrigins
	results            *MinioIMockGetPresignedURLForDownloadResults
	returnOrigin       string
	Counter            uint64
}

// MinioIMockGetPresignedURLForDownloadParams contains parameters of the MinioI.GetPresignedURLForDownload
type MinioIMockGetPresignedURLForDownloadParams struct {
	ctx           context.Context
	namespaceUUID uuid.UUID
	objectUUID    uuid.UUID
	filename      string
	contentType   string
	urlExpiration time.Duration
}

// MinioIMockGetPresignedURLForDownloadParamPtrs contains pointers to parameters of the MinioI.GetPresignedURLForDownload
type MinioIMockGetPresignedURLForDownloadParamPtrs struct {
	ctx           *context.Context
	namespaceUUID *uuid.UUID
	objectUUID    *uuid.UUID
	filename      *string
	contentType   *string
	urlExpiration *time.Duration
}

// MinioIMockGetPresignedURLForDownloadResults contains results of the MinioI.GetPresignedURLForDownload
type MinioIMockGetPresignedURLForDownloadResults struct {
	up1 *url.URL
	err error
}

// MinioIMockGetPresignedURLForDownloadOrigins contains origins of expectations of the MinioI.GetPresignedURLForDownload
type MinioIMockGetPresignedURLForDownloadExpectationOrigins struct {
	origin              string
	originCtx           string
	originNamespaceUUID string
	originObjectUUID    string
	originFilename      string
	originContentType   string
	originUrlExpiration string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPresignedURLForDownload *mMinioIMockGetPresignedURLForDownload) Optional() *mMinioIMockGetPresignedURLForDownload {
	mmGetPresignedURLForDownload.optional = true
	return mmGetPresignedURLForDownload
}

// Expect sets up expected params for MinioI.GetPresignedURLForDownload
func (mmGetPresignedURLForDownload *mMinioIMockGetPresignedURLForDownload) Expect(ctx context.Context, namespaceUUID uuid.UUID, objectUUID uuid.UUID, filename string, contentType string, urlExpiration time.Duration) *mMinioIMockGetPresignedURLForDownload {
	if mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("MinioIMock.GetPresignedURLForDownload mock is already set by Set")
	}

	if mmGetPresignedURLForDownload.defaultExpectation == nil {
		mmGetPresignedURLForDownload.defaultExpectation = &MinioIMockGetPresignedURLForDownloadExpectation{}
	}

	if mmGetPresignedURLForDownload.defaultExpectation.paramPtrs != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("MinioIMock.GetPresignedURLForDownload mock is already set by ExpectParams functions")
	}

	mmGetPresignedURLForDownload.defaultExpectation.params = &MinioIMockGetPresignedURLForDownloadParams{ctx, namespaceUUID, objectUUID, filename, contentType, urlExpiration}
	mmGetPresignedURLForDownload.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPresignedURLForDownload.expectations {
		if minimock.Equal(e.params, mmGetPresignedURLForDownload.defaultExpectation.params) {
			mmGetPresignedURLForDownload.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPresignedURLForDownload.defaultExpectation.params)
		}
	}

	return mmGetPresignedURLForDownload
}

// ExpectCtxParam1 sets up expected param ctx for MinioI.GetPresignedURLForDownload
func (mmGetPresignedURLForDownload *mMinioIMockGetPresignedURLForDownload) ExpectCtxParam1(ctx context.Context) *mMinioIMockGetPresignedURLForDownload {
	if mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("MinioIMock.GetPresignedURLForDownload mock is already set by Set")
	}

	if mmGetPresignedURLForDownload.defaultExpectation == nil {
		mmGetPresignedURLForDownload.defaultExpectation = &MinioIMockGetPresignedURLForDownloadExpectation{}
	}

	if mmGetPresignedURLForDownload.defaultExpectation.params != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("MinioIMock.GetPresignedURLForDownload mock is already set by Expect")
	}

	if mmGetPresignedURLForDownload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForDownload.defaultExpectation.paramPtrs = &MinioIMockGetPresignedURLForDownloadParamPtrs{}
	}
	mmGetPresignedURLForDownload.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPresignedURLForDownload.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPresignedURLForDownload
}

// ExpectNamespaceUUIDParam2 sets up expected param namespaceUUID for MinioI.GetPresignedURLForDownload
func (mmGetPresignedURLForDownload *mMinioIMockGetPresignedURLForDownload) ExpectNamespaceUUIDParam2(namespaceUUID uuid.UUID) *mMinioIMockGetPresignedURLForDownload {
	if mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("MinioIMock.GetPresignedURLForDownload mock is already set by Set")
	}

	if mmGetPresignedURLForDownload.defaultExpectation == nil {
		mmGetPresignedURLForDownload.defaultExpectation = &MinioIMockGetPresignedURLForDownloadExpectation{}
	}

	if mmGetPresignedURLForDownload.defaultExpectation.params != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("MinioIMock.GetPresignedURLForDownload mock is already set by Expect")
	}

	if mmGetPresignedURLForDownload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForDownload.defaultExpectation.paramPtrs = &MinioIMockGetPresignedURLForDownloadParamPtrs{}
	}
	mmGetPresignedURLForDownload.defaultExpectation.paramPtrs.namespaceUUID = &namespaceUUID
	mmGetPresignedURLForDownload.defaultExpectation.expectationOrigins.originNamespaceUUID = minimock.CallerInfo(1)

	return mmGetPresignedURLForDownload
}

// ExpectObjectUUIDParam3 sets up expected param objectUUID for MinioI.GetPresignedURLForDownload
func (mmGetPresignedURLForDownload *mMinioIMockGetPresignedURLForDownload) ExpectObjectUUIDParam3(objectUUID uuid.UUID) *mMinioIMockGetPresignedURLForDownload {
	if mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("MinioIMock.GetPresignedURLForDownload mock is already set by Set")
	}

	if mmGetPresignedURLForDownload.defaultExpectation == nil {
		mmGetPresignedURLForDownload.defaultExpectation = &MinioIMockGetPresignedURLForDownloadExpectation{}
	}

	if mmGetPresignedURLForDownload.defaultExpectation.params != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("MinioIMock.GetPresignedURLForDownload mock is already set by Expect")
	}

	if mmGetPresignedURLForDownload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForDownload.defaultExpectation.paramPtrs = &MinioIMockGetPresignedURLForDownloadParamPtrs{}
	}
	mmGetPresignedURLForDownload.defaultExpectation.paramPtrs.objectUUID = &objectUUID
	mmGetPresignedURLForDownload.defaultExpectation.expectationOrigins.originObjectUUID = minimock.CallerInfo(1)

	return mmGetPresignedURLForDownload
}

// ExpectFilenameParam4 sets up expected param filename for MinioI.GetPresignedURLForDownload
func (mmGetPresignedURLForDownload *mMinioIMockGetPresignedURLForDownload) ExpectFilenameParam4(filename string) *mMinioIMockGetPresignedURLForDownload {
	if mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("MinioIMock.GetPresignedURLForDownload mock is already set by Set")
	}

	if mmGetPresignedURLForDownload.defaultExpectation == nil {
		mmGetPresignedURLForDownload.defaultExpectation = &MinioIMockGetPresignedURLForDownloadExpectation{}
	}

	if mmGetPresignedURLForDownload.defaultExpectation.params != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("MinioIMock.GetPresignedURLForDownload mock is already set by Expect")
	}

	if mmGetPresignedURLForDownload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForDownload.defaultExpectation.paramPtrs = &MinioIMockGetPresignedURLForDownloadParamPtrs{}
	}
	mmGetPresignedURLForDownload.defaultExpectation.paramPtrs.filename = &filename
	mmGetPresignedURLForDownload.defaultExpectation.expectationOrigins.originFilename = minimock.CallerInfo(1)

	return mmGetPresignedURLForDownload
}

// ExpectContentTypeParam5 sets up expected param contentType for MinioI.GetPresignedURLForDownload
func (mmGetPresignedURLForDownload *mMinioIMockGetPresignedURLForDownload) ExpectContentTypeParam5(contentType string) *mMinioIMockGetPresignedURLForDownload {
	if mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("MinioIMock.GetPresignedURLForDownload mock is already set by Set")
	}

	if mmGetPresignedURLForDownload.defaultExpectation == nil {
		mmGetPresignedURLForDownload.defaultExpectation = &MinioIMockGetPresignedURLForDownloadExpectation{}
	}

	if mmGetPresignedURLForDownload.defaultExpectation.params != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("MinioIMock.GetPresignedURLForDownload mock is already set by Expect")
	}

	if mmGetPresignedURLForDownload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForDownload.defaultExpectation.paramPtrs = &MinioIMockGetPresignedURLForDownloadParamPtrs{}
	}
	mmGetPresignedURLForDownload.defaultExpectation.paramPtrs.contentType = &contentType
	mmGetPresignedURLForDownload.defaultExpectation.expectationOrigins.originContentType = minimock.CallerInfo(1)

	return mmGetPresignedURLForDownload
}

// ExpectUrlExpirationParam6 sets up expected param urlExpiration for MinioI.GetPresignedURLForDownload
func (mmGetPresignedURLForDownload *mMinioIMockGetPresignedURLForDownload) ExpectUrlExpirationParam6(urlExpiration time.Duration) *mMinioIMockGetPresignedURLForDownload {
	if mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("MinioIMock.GetPresignedURLForDownload mock is already set by Set")
	}

	if mmGetPresignedURLForDownload.defaultExpectation == nil {
		mmGetPresignedURLForDownload.defaultExpectation = &MinioIMockGetPresignedURLForDownloadExpectation{}
	}

	if mmGetPresignedURLForDownload.defaultExpectation.params != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("MinioIMock.GetPresignedURLForDownload mock is already set by Expect")
	}

	if mmGetPresignedURLForDownload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForDownload.defaultExpectation.paramPtrs = &MinioIMockGetPresignedURLForDownloadParamPtrs{}
	}
	mmGetPresignedURLForDownload.defaultExpectation.paramPtrs.urlExpiration = &urlExpiration
	mmGetPresignedURLForDownload.defaultExpectation.expectationOrigins.originUrlExpiration = minimock.CallerInfo(1)

	return mmGetPresignedURLForDownload
}

// Inspect accepts an inspector function that has same arguments as the MinioI.GetPresignedURLForDownload
func (mmGetPresignedURLForDownload *mMinioIMockGetPresignedURLForDownload) Inspect(f func(ctx context.Context, namespaceUUID uuid.UUID, objectUUID uuid.UUID, filename string, contentType string, urlExpiration time.Duration)) *mMinioIMockGetPresignedURLForDownload {
	if mmGetPresignedURLForDownload.mock.inspectFuncGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("Inspect function is already set for MinioIMock.GetPresignedURLForDownload")
	}

	mmGetPresignedURLForDownload.mock.inspectFuncGetPresignedURLForDownload = f

	return mmGetPresignedURLForDownload
}

// Return sets up results that will be returned by MinioI.GetPresignedURLForDownload
func (mmGetPresignedURLForDownload *mMinioIMockGetPresignedURLForDownload) Return(up1 *url.URL, err error) *MinioIMock {
	if mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("MinioIMock.GetPresignedURLForDownload mock is already set by Set")
	}

	if mmGetPresignedURLForDownload.defaultExpectation == nil {
		mmGetPresignedURLForDownload.defaultExpectation = &MinioIMockGetPresignedURLForDownloadExpectation{mock: mmGetPresignedURLForDownload.mock}
	}
	mmGetPresignedURLForDownload.defaultExpectation.results = &MinioIMockGetPresignedURLForDownloadResults{up1, err}
	mmGetPresignedURLForDownload.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPresignedURLForDownload.mock
}

// Set uses given function f to mock the MinioI.GetPresignedURLForDownload method
func (mmGetPresignedURLForDownload *mMinioIMockGetPresignedURLForDownload) Set(f func(ctx context.Context, namespaceUUID uuid.UUID, objectUUID uuid.UUID, filename string, contentType string, urlExpiration time.Duration) (up1 *url.URL, err error)) *MinioIMock {
	if mmGetPresignedURLForDownload.defaultExpectation != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("Default expectation is already set for the MinioI.GetPresignedURLForDownload method")
	}

	if len(mmGetPresignedURLForDownload.expectations) > 0 {
		mmGetPresignedURLForDownload.mock.t.Fatalf("Some expectations are already set for the MinioI.GetPresignedURLForDownload method")
	}

	mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload = f
	mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownloadOrigin = minimock.CallerInfo(1)
	return mmGetPresignedURLForDownload.mock
}

// When sets expectation for the MinioI.GetPresignedURLForDownload which will trigger the result defined by the following
// Then helper
func (mmGetPresignedURLForDownload *mMinioIMockGetPresignedURLForDownload) When(ctx context.Context, namespaceUUID uuid.UUID, objectUUID uuid.UUID, filename string, contentType string, urlExpiration time.Duration) *MinioIMockGetPresignedURLForDownloadExpectation {
	if mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("MinioIMock.GetPresignedURLForDownload mock is already set by Set")
	}

	expectation := &MinioIMockGetPresignedURLForDownloadExpectation{
		mock:               mmGetPresignedURLForDownload.mock,
		params:             &MinioIMockGetPresignedURLForDownloadParams{ctx, namespaceUUID, objectUUID, filename, contentType, urlExpiration},
		expectationOrigins: MinioIMockGetPresignedURLForDownloadExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPresignedURLForDownload.expectations = append(mmGetPresignedURLForDownload.expectations, expectation)
	return expectation
}

// Then sets up MinioI.GetPresignedURLForDownload return parameters for the expectation previously defined by the When method
func (e *MinioIMockGetPresignedURLForDownloadExpectation) Then(up1 *url.URL, err error) *MinioIMock {
	e.results = &MinioIMockGetPresignedURLForDownloadResults{up1, err}
	return e.mock
}

// Times sets number of times MinioI.GetPresignedURLForDownload should be invoked
func (mmGetPresignedURLForDownload *mMinioIMockGetPresignedURLForDownload) Times(n uint64) *mMinioIMockGetPresignedURLForDownload {
	if n == 0 {
		mmGetPresignedURLForDownload.mock.t.Fatalf("Times of MinioIMock.GetPresignedURLForDownload mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPresignedURLForDownload.expectedInvocations, n)
	mmGetPresignedURLForDownload.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPresignedURLForDownload
}

func (mmGetPresignedURLForDownload *mMinioIMockGetPresignedURLForDownload) invocationsDone() bool {
	if len(mmGetPresignedURLForDownload.expectations) == 0 && mmGetPresignedURLForDownload.defaultExpectation == nil && mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPresignedURLForDownload.mock.afterGetPresignedURLForDownloadCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPresignedURLForDownload.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPresignedURLForDownload implements mm_minio.MinioI
func (mmGetPresignedURLForDownload *MinioIMock) GetPresignedURLForDownload(ctx context.Context, namespaceUUID uuid.UUID, objectUUID uuid.UUID, filename string, contentType string, urlExpiration time.Duration) (up1 *url.URL, err error) {
	mm_atomic.AddUint64(&mmGetPresignedURLForDownload.beforeGetPresignedURLForDownloadCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPresignedURLForDownload.afterGetPresignedURLForDownloadCounter, 1)

	mmGetPresignedURLForDownload.t.Helper()

	if mmGetPresignedURLForDownload.inspectFuncGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.inspectFuncGetPresignedURLForDownload(ctx, namespaceUUID, objectUUID, filename, contentType, urlExpiration)
	}

	mm_params := MinioIMockGetPresignedURLForDownloadParams{ctx, namespaceUUID, objectUUID, filename, contentType, urlExpiration}

	// Record call args
	mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.mutex.Lock()
	mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.callArgs = append(mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.callArgs, &mm_params)
	mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.mutex.Unlock()

	for _, e := range mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.params
		mm_want_ptrs := mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.paramPtrs

		mm_got := MinioIMockGetPresignedURLForDownloadParams{ctx, namespaceUUID, objectUUID, filename, contentType, urlExpiration}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPresignedURLForDownload.t.Errorf("MinioIMock.GetPresignedURLForDownload got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.namespaceUUID != nil && !minimock.Equal(*mm_want_ptrs.namespaceUUID, mm_got.namespaceUUID) {
				mmGetPresignedURLForDownload.t.Errorf("MinioIMock.GetPresignedURLForDownload got unexpected parameter namespaceUUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.expectationOrigins.originNamespaceUUID, *mm_want_ptrs.namespaceUUID, mm_got.namespaceUUID, minimock.Diff(*mm_want_ptrs.namespaceUUID, mm_got.namespaceUUID))
			}

			if mm_want_ptrs.objectUUID != nil && !minimock.Equal(*mm_want_ptrs.objectUUID, mm_got.objectUUID) {
				mmGetPresignedURLForDownload.t.Errorf("MinioIMock.GetPresignedURLForDownload got unexpected parameter objectUUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.expectationOrigins.originObjectUUID, *mm_want_ptrs.objectUUID, mm_got.objectUUID, minimock.Diff(*mm_want_ptrs.objectUUID, mm_got.objectUUID))
			}

			if mm_want_ptrs.filename != nil && !minimock.Equal(*mm_want_ptrs.filename, mm_got.filename) {
				mmGetPresignedURLForDownload.t.Errorf("MinioIMock.GetPresignedURLForDownload got unexpected parameter filename, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.expectationOrigins.originFilename, *mm_want_ptrs.filename, mm_got.filename, minimock.Diff(*mm_want_ptrs.filename, mm_got.filename))
			}

			if mm_want_ptrs.contentType != nil && !minimock.Equal(*mm_want_ptrs.contentType, mm_got.contentType) {
				mmGetPresignedURLForDownload.t.Errorf("MinioIMock.GetPresignedURLForDownload got unexpected parameter contentType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.expectationOrigins.originContentType, *mm_want_ptrs.contentType, mm_got.contentType, minimock.Diff(*mm_want_ptrs.contentType, mm_got.contentType))
			}

			if mm_want_ptrs.urlExpiration != nil && !minimock.Equal(*mm_want_ptrs.urlExpiration, mm_got.urlExpiration) {
				mmGetPresignedURLForDownload.t.Errorf("MinioIMock.GetPresignedURLForDownload got unexpected parameter urlExpiration, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.expectationOrigins.originUrlExpiration, *mm_want_ptrs.urlExpiration, mm_got.urlExpiration, minimock.Diff(*mm_want_ptrs.urlExpiration, mm_got.urlExpiration))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPresignedURLForDownload.t.Errorf("MinioIMock.GetPresignedURLForDownload got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPresignedURLForDownload.t.Fatal("No results are set for the MinioIMock.GetPresignedURLForDownload")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetPresignedURLForDownload.funcGetPresignedURLForDownload != nil {
		return mmGetPresignedURLForDownload.funcGetPresignedURLForDownload(ctx, namespaceUUID, objectUUID, filename, contentType, urlExpiration)
	}
	mmGetPresignedURLForDownload.t.Fatalf("Unexpected call to MinioIMock.GetPresignedURLForDownload. %v %v %v %v %v %v", ctx, namespaceUUID, objectUUID, filename, contentType, urlExpiration)
	return
}

// GetPresignedURLForDownloadAfterCounter returns a count of finished MinioIMock.GetPresignedURLForDownload invocations
func (mmGetPresignedURLForDownload *MinioIMock) GetPresignedURLForDownloadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPresignedURLForDownload.afterGetPresignedURLForDownloadCounter)
}

// GetPresignedURLForDownloadBeforeCounter returns a count of MinioIMock.GetPresignedURLForDownload invocations
func (mmGetPresignedURLForDownload *MinioIMock) GetPresignedURLForDownloadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPresignedURLForDownload.beforeGetPresignedURLForDownloadCounter)
}

// Calls returns a list of arguments used in each call to MinioIMock.GetPresignedURLForDownload.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPresignedURLForDownload *mMinioIMockGetPresignedURLForDownload) Calls() []*MinioIMockGetPresignedURLForDownloadParams {
	mmGetPresignedURLForDownload.mutex.RLock()

	argCopy := make([]*MinioIMockGetPresignedURLForDownloadParams, len(mmGetPresignedURLForDownload.callArgs))
	copy(argCopy, mmGetPresignedURLForDownload.callArgs)

	mmGetPresignedURLForDownload.mutex.RUnlock()

	return argCopy
}

// MinimockGetPresignedURLForDownloadDone returns true if the count of the GetPresignedURLForDownload invocations corresponds
// the number of defined expectations
func (m *MinioIMock) MinimockGetPresignedURLForDownloadDone() bool {
	if m.GetPresignedURLForDownloadMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPresignedURLForDownloadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPresignedURLForDownloadMock.invocationsDone()
}

// MinimockGetPresignedURLForDownloadInspect logs each unmet expectation
func (m *MinioIMock) MinimockGetPresignedURLForDownloadInspect() {
	for _, e := range m.GetPresignedURLForDownloadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinioIMock.GetPresignedURLForDownload at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPresignedURLForDownloadCounter := mm_atomic.LoadUint64(&m.afterGetPresignedURLForDownloadCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPresignedURLForDownloadMock.defaultExpectation != nil && afterGetPresignedURLForDownloadCounter < 1 {
		if m.GetPresignedURLForDownloadMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MinioIMock.GetPresignedURLForDownload at\n%s", m.GetPresignedURLForDownloadMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MinioIMock.GetPresignedURLForDownload at\n%s with params: %#v", m.GetPresignedURLForDownloadMock.defaultExpectation.expectationOrigins.origin, *m.GetPresignedURLForDownloadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPresignedURLForDownload != nil && afterGetPresignedURLForDownloadCounter < 1 {
		m.t.Errorf("Expected call to MinioIMock.GetPresignedURLForDownload at\n%s", m.funcGetPresignedURLForDownloadOrigin)
	}

	if !m.GetPresignedURLForDownloadMock.invocationsDone() && afterGetPresignedURLForDownloadCounter > 0 {
		m.t.Errorf("Expected %d calls to MinioIMock.GetPresignedURLForDownload at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPresignedURLForDownloadMock.expectedInvocations), m.GetPresignedURLForDownloadMock.expectedInvocationsOrigin, afterGetPresignedURLForDownloadCounter)
	}
}

type mMinioIMockGetPresignedURLForUpload struct {
	optional           bool
	mock               *MinioIMock
	defaultExpectation *MinioIMockGetPresignedURLForUploadExpectation
	expectations       []*MinioIMockGetPresignedURLForUploadExpectation

	callArgs []*MinioIMockGetPresignedURLForUploadParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MinioIMockGetPresignedURLForUploadExpectation specifies expectation struct of the MinioI.GetPresignedURLForUpload
type MinioIMockGetPresignedURLForUploadExpectation struct {
	mock               *MinioIMock
	params             *MinioIMockGetPresignedURLForUploadParams
	paramPtrs          *MinioIMockGetPresignedURLForUploadParamPtrs
	expectationOrigins MinioIMockGetPresignedURLForUploadExpectationOrigins
	results            *MinioIMockGetPresignedURLForUploadResults
	returnOrigin       string
	Counter            uint64
}

// MinioIMockGetPresignedURLForUploadParams contains parameters of the MinioI.GetPresignedURLForUpload
type MinioIMockGetPresignedURLForUploadParams struct {
	ctx           context.Context
	namespaceUUID uuid.UUID
	objectUUID    uuid.UUID
	filename      string
	urlExpiration time.Duration
}

// MinioIMockGetPresignedURLForUploadParamPtrs contains pointers to parameters of the MinioI.GetPresignedURLForUpload
type MinioIMockGetPresignedURLForUploadParamPtrs struct {
	ctx           *context.Context
	namespaceUUID *uuid.UUID
	objectUUID    *uuid.UUID
	filename      *string
	urlExpiration *time.Duration
}

// MinioIMockGetPresignedURLForUploadResults contains results of the MinioI.GetPresignedURLForUpload
type MinioIMockGetPresignedURLForUploadResults struct {
	up1 *url.URL
	err error
}

// MinioIMockGetPresignedURLForUploadOrigins contains origins of expectations of the MinioI.GetPresignedURLForUpload
type MinioIMockGetPresignedURLForUploadExpectationOrigins struct {
	origin              string
	originCtx           string
	originNamespaceUUID string
	originObjectUUID    string
	originFilename      string
	originUrlExpiration string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPresignedURLForUpload *mMinioIMockGetPresignedURLForUpload) Optional() *mMinioIMockGetPresignedURLForUpload {
	mmGetPresignedURLForUpload.optional = true
	return mmGetPresignedURLForUpload
}

// Expect sets up expected params for MinioI.GetPresignedURLForUpload
func (mmGetPresignedURLForUpload *mMinioIMockGetPresignedURLForUpload) Expect(ctx context.Context, namespaceUUID uuid.UUID, objectUUID uuid.UUID, filename string, urlExpiration time.Duration) *mMinioIMockGetPresignedURLForUpload {
	if mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("MinioIMock.GetPresignedURLForUpload mock is already set by Set")
	}

	if mmGetPresignedURLForUpload.defaultExpectation == nil {
		mmGetPresignedURLForUpload.defaultExpectation = &MinioIMockGetPresignedURLForUploadExpectation{}
	}

	if mmGetPresignedURLForUpload.defaultExpectation.paramPtrs != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("MinioIMock.GetPresignedURLForUpload mock is already set by ExpectParams functions")
	}

	mmGetPresignedURLForUpload.defaultExpectation.params = &MinioIMockGetPresignedURLForUploadParams{ctx, namespaceUUID, objectUUID, filename, urlExpiration}
	mmGetPresignedURLForUpload.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPresignedURLForUpload.expectations {
		if minimock.Equal(e.params, mmGetPresignedURLForUpload.defaultExpectation.params) {
			mmGetPresignedURLForUpload.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPresignedURLForUpload.defaultExpectation.params)
		}
	}

	return mmGetPresignedURLForUpload
}

// ExpectCtxParam1 sets up expected param ctx for MinioI.GetPresignedURLForUpload
func (mmGetPresignedURLForUpload *mMinioIMockGetPresignedURLForUpload) ExpectCtxParam1(ctx context.Context) *mMinioIMockGetPresignedURLForUpload {
	if mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("MinioIMock.GetPresignedURLForUpload mock is already set by Set")
	}

	if mmGetPresignedURLForUpload.defaultExpectation == nil {
		mmGetPresignedURLForUpload.defaultExpectation = &MinioIMockGetPresignedURLForUploadExpectation{}
	}

	if mmGetPresignedURLForUpload.defaultExpectation.params != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("MinioIMock.GetPresignedURLForUpload mock is already set by Expect")
	}

	if mmGetPresignedURLForUpload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForUpload.defaultExpectation.paramPtrs = &MinioIMockGetPresignedURLForUploadParamPtrs{}
	}
	mmGetPresignedURLForUpload.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPresignedURLForUpload.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPresignedURLForUpload
}

// ExpectNamespaceUUIDParam2 sets up expected param namespaceUUID for MinioI.GetPresignedURLForUpload
func (mmGetPresignedURLForUpload *mMinioIMockGetPresignedURLForUpload) ExpectNamespaceUUIDParam2(namespaceUUID uuid.UUID) *mMinioIMockGetPresignedURLForUpload {
	if mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("MinioIMock.GetPresignedURLForUpload mock is already set by Set")
	}

	if mmGetPresignedURLForUpload.defaultExpectation == nil {
		mmGetPresignedURLForUpload.defaultExpectation = &MinioIMockGetPresignedURLForUploadExpectation{}
	}

	if mmGetPresignedURLForUpload.defaultExpectation.params != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("MinioIMock.GetPresignedURLForUpload mock is already set by Expect")
	}

	if mmGetPresignedURLForUpload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForUpload.defaultExpectation.paramPtrs = &MinioIMockGetPresignedURLForUploadParamPtrs{}
	}
	mmGetPresignedURLForUpload.defaultExpectation.paramPtrs.namespaceUUID = &namespaceUUID
	mmGetPresignedURLForUpload.defaultExpectation.expectationOrigins.originNamespaceUUID = minimock.CallerInfo(1)

	return mmGetPresignedURLForUpload
}

// ExpectObjectUUIDParam3 sets up expected param objectUUID for MinioI.GetPresignedURLForUpload
func (mmGetPresignedURLForUpload *mMinioIMockGetPresignedURLForUpload) ExpectObjectUUIDParam3(objectUUID uuid.UUID) *mMinioIMockGetPresignedURLForUpload {
	if mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("MinioIMock.GetPresignedURLForUpload mock is already set by Set")
	}

	if mmGetPresignedURLForUpload.defaultExpectation == nil {
		mmGetPresignedURLForUpload.defaultExpectation = &MinioIMockGetPresignedURLForUploadExpectation{}
	}

	if mmGetPresignedURLForUpload.defaultExpectation.params != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("MinioIMock.GetPresignedURLForUpload mock is already set by Expect")
	}

	if mmGetPresignedURLForUpload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForUpload.defaultExpectation.paramPtrs = &MinioIMockGetPresignedURLForUploadParamPtrs{}
	}
	mmGetPresignedURLForUpload.defaultExpectation.paramPtrs.objectUUID = &objectUUID
	mmGetPresignedURLForUpload.defaultExpectation.expectationOrigins.originObjectUUID = minimock.CallerInfo(1)

	return mmGetPresignedURLForUpload
}

// ExpectFilenameParam4 sets up expected param filename for MinioI.GetPresignedURLForUpload
func (mmGetPresignedURLForUpload *mMinioIMockGetPresignedURLForUpload) ExpectFilenameParam4(filename string) *mMinioIMockGetPresignedURLForUpload {
	if mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("MinioIMock.GetPresignedURLForUpload mock is already set by Set")
	}

	if mmGetPresignedURLForUpload.defaultExpectation == nil {
		mmGetPresignedURLForUpload.defaultExpectation = &MinioIMockGetPresignedURLForUploadExpectation{}
	}

	if mmGetPresignedURLForUpload.defaultExpectation.params != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("MinioIMock.GetPresignedURLForUpload mock is already set by Expect")
	}

	if mmGetPresignedURLForUpload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForUpload.defaultExpectation.paramPtrs = &MinioIMockGetPresignedURLForUploadParamPtrs{}
	}
	mmGetPresignedURLForUpload.defaultExpectation.paramPtrs.filename = &filename
	mmGetPresignedURLForUpload.defaultExpectation.expectationOrigins.originFilename = minimock.CallerInfo(1)

	return mmGetPresignedURLForUpload
}

// ExpectUrlExpirationParam5 sets up expected param urlExpiration for MinioI.GetPresignedURLForUpload
func (mmGetPresignedURLForUpload *mMinioIMockGetPresignedURLForUpload) ExpectUrlExpirationParam5(urlExpiration time.Duration) *mMinioIMockGetPresignedURLForUpload {
	if mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("MinioIMock.GetPresignedURLForUpload mock is already set by Set")
	}

	if mmGetPresignedURLForUpload.defaultExpectation == nil {
		mmGetPresignedURLForUpload.defaultExpectation = &MinioIMockGetPresignedURLForUploadExpectation{}
	}

	if mmGetPresignedURLForUpload.defaultExpectation.params != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("MinioIMock.GetPresignedURLForUpload mock is already set by Expect")
	}

	if mmGetPresignedURLForUpload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForUpload.defaultExpectation.paramPtrs = &MinioIMockGetPresignedURLForUploadParamPtrs{}
	}
	mmGetPresignedURLForUpload.defaultExpectation.paramPtrs.urlExpiration = &urlExpiration
	mmGetPresignedURLForUpload.defaultExpectation.expectationOrigins.originUrlExpiration = minimock.CallerInfo(1)

	return mmGetPresignedURLForUpload
}

// Inspect accepts an inspector function that has same arguments as the MinioI.GetPresignedURLForUpload
func (mmGetPresignedURLForUpload *mMinioIMockGetPresignedURLForUpload) Inspect(f func(ctx context.Context, namespaceUUID uuid.UUID, objectUUID uuid.UUID, filename string, urlExpiration time.Duration)) *mMinioIMockGetPresignedURLForUpload {
	if mmGetPresignedURLForUpload.mock.inspectFuncGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("Inspect function is already set for MinioIMock.GetPresignedURLForUpload")
	}

	mmGetPresignedURLForUpload.mock.inspectFuncGetPresignedURLForUpload = f

	return mmGetPresignedURLForUpload
}

// Return sets up results that will be returned by MinioI.GetPresignedURLForUpload
func (mmGetPresignedURLForUpload *mMinioIMockGetPresignedURLForUpload) Return(up1 *url.URL, err error) *MinioIMock {
	if mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("MinioIMock.GetPresignedURLForUpload mock is already set by Set")
	}

	if mmGetPresignedURLForUpload.defaultExpectation == nil {
		mmGetPresignedURLForUpload.defaultExpectation = &MinioIMockGetPresignedURLForUploadExpectation{mock: mmGetPresignedURLForUpload.mock}
	}
	mmGetPresignedURLForUpload.defaultExpectation.results = &MinioIMockGetPresignedURLForUploadResults{up1, err}
	mmGetPresignedURLForUpload.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPresignedURLForUpload.mock
}

// Set uses given function f to mock the MinioI.GetPresignedURLForUpload method
func (mmGetPresignedURLForUpload *mMinioIMockGetPresignedURLForUpload) Set(f func(ctx context.Context, namespaceUUID uuid.UUID, objectUUID uuid.UUID, filename string, urlExpiration time.Duration) (up1 *url.URL, err error)) *MinioIMock {
	if mmGetPresignedURLForUpload.defaultExpectation != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("Default expectation is already set for the MinioI.GetPresignedURLForUpload method")
	}

	if len(mmGetPresignedURLForUpload.expectations) > 0 {
		mmGetPresignedURLForUpload.mock.t.Fatalf("Some expectations are already set for the MinioI.GetPresignedURLForUpload method")
	}

	mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload = f
	mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUploadOrigin = minimock.CallerInfo(1)
	return mmGetPresignedURLForUpload.mock
}

// When sets expectation for the MinioI.GetPresignedURLForUpload which will trigger the result defined by the following
// Then helper
func (mmGetPresignedURLForUpload *mMinioIMockGetPresignedURLForUpload) When(ctx context.Context, namespaceUUID uuid.UUID, objectUUID uuid.UUID, filename string, urlExpiration time.Duration) *MinioIMockGetPresignedURLForUploadExpectation {
	if mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("MinioIMock.GetPresignedURLForUpload mock is already set by Set")
	}

	expectation := &MinioIMockGetPresignedURLForUploadExpectation{
		mock:               mmGetPresignedURLForUpload.mock,
		params:             &MinioIMockGetPresignedURLForUploadParams{ctx, namespaceUUID, objectUUID, filename, urlExpiration},
		expectationOrigins: MinioIMockGetPresignedURLForUploadExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPresignedURLForUpload.expectations = append(mmGetPresignedURLForUpload.expectations, expectation)
	return expectation
}

// Then sets up MinioI.GetPresignedURLForUpload return parameters for the expectation previously defined by the When method
func (e *MinioIMockGetPresignedURLForUploadExpectation) Then(up1 *url.URL, err error) *MinioIMock {
	e.results = &MinioIMockGetPresignedURLForUploadResults{up1, err}
	return e.mock
}

// Times sets number of times MinioI.GetPresignedURLForUpload should be invoked
func (mmGetPresignedURLForUpload *mMinioIMockGetPresignedURLForUpload) Times(n uint64) *mMinioIMockGetPresignedURLForUpload {
	if n == 0 {
		mmGetPresignedURLForUpload.mock.t.Fatalf("Times of MinioIMock.GetPresignedURLForUpload mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPresignedURLForUpload.expectedInvocations, n)
	mmGetPresignedURLForUpload.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPresignedURLForUpload
}

func (mmGetPresignedURLForUpload *mMinioIMockGetPresignedURLForUpload) invocationsDone() bool {
	if len(mmGetPresignedURLForUpload.expectations) == 0 && mmGetPresignedURLForUpload.defaultExpectation == nil && mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPresignedURLForUpload.mock.afterGetPresignedURLForUploadCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPresignedURLForUpload.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPresignedURLForUpload implements mm_minio.MinioI
func (mmGetPresignedURLForUpload *MinioIMock) GetPresignedURLForUpload(ctx context.Context, namespaceUUID uuid.UUID, objectUUID uuid.UUID, filename string, urlExpiration time.Duration) (up1 *url.URL, err error) {
	mm_atomic.AddUint64(&mmGetPresignedURLForUpload.beforeGetPresignedURLForUploadCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPresignedURLForUpload.afterGetPresignedURLForUploadCounter, 1)

	mmGetPresignedURLForUpload.t.Helper()

	if mmGetPresignedURLForUpload.inspectFuncGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.inspectFuncGetPresignedURLForUpload(ctx, namespaceUUID, objectUUID, filename, urlExpiration)
	}

	mm_params := MinioIMockGetPresignedURLForUploadParams{ctx, namespaceUUID, objectUUID, filename, urlExpiration}

	// Record call args
	mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.mutex.Lock()
	mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.callArgs = append(mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.callArgs, &mm_params)
	mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.mutex.Unlock()

	for _, e := range mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.params
		mm_want_ptrs := mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.paramPtrs

		mm_got := MinioIMockGetPresignedURLForUploadParams{ctx, namespaceUUID, objectUUID, filename, urlExpiration}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPresignedURLForUpload.t.Errorf("MinioIMock.GetPresignedURLForUpload got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.namespaceUUID != nil && !minimock.Equal(*mm_want_ptrs.namespaceUUID, mm_got.namespaceUUID) {
				mmGetPresignedURLForUpload.t.Errorf("MinioIMock.GetPresignedURLForUpload got unexpected parameter namespaceUUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.expectationOrigins.originNamespaceUUID, *mm_want_ptrs.namespaceUUID, mm_got.namespaceUUID, minimock.Diff(*mm_want_ptrs.namespaceUUID, mm_got.namespaceUUID))
			}

			if mm_want_ptrs.objectUUID != nil && !minimock.Equal(*mm_want_ptrs.objectUUID, mm_got.objectUUID) {
				mmGetPresignedURLForUpload.t.Errorf("MinioIMock.GetPresignedURLForUpload got unexpected parameter objectUUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.expectationOrigins.originObjectUUID, *mm_want_ptrs.objectUUID, mm_got.objectUUID, minimock.Diff(*mm_want_ptrs.objectUUID, mm_got.objectUUID))
			}

			if mm_want_ptrs.filename != nil && !minimock.Equal(*mm_want_ptrs.filename, mm_got.filename) {
				mmGetPresignedURLForUpload.t.Errorf("MinioIMock.GetPresignedURLForUpload got unexpected parameter filename, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.expectationOrigins.originFilename, *mm_want_ptrs.filename, mm_got.filename, minimock.Diff(*mm_want_ptrs.filename, mm_got.filename))
			}

			if mm_want_ptrs.urlExpiration != nil && !minimock.Equal(*mm_want_ptrs.urlExpiration, mm_got.urlExpiration) {
				mmGetPresignedURLForUpload.t.Errorf("MinioIMock.GetPresignedURLForUpload got unexpected parameter urlExpiration, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.expectationOrigins.originUrlExpiration, *mm_want_ptrs.urlExpiration, mm_got.urlExpiration, minimock.Diff(*mm_want_ptrs.urlExpiration, mm_got.urlExpiration))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPresignedURLForUpload.t.Errorf("MinioIMock.GetPresignedURLForUpload got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPresignedURLForUpload.t.Fatal("No results are set for the MinioIMock.GetPresignedURLForUpload")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetPresignedURLForUpload.funcGetPresignedURLForUpload != nil {
		return mmGetPresignedURLForUpload.funcGetPresignedURLForUpload(ctx, namespaceUUID, objectUUID, filename, urlExpiration)
	}
	mmGetPresignedURLForUpload.t.Fatalf("Unexpected call to MinioIMock.GetPresignedURLForUpload. %v %v %v %v %v", ctx, namespaceUUID, objectUUID, filename, urlExpiration)
	return
}

// GetPresignedURLForUploadAfterCounter returns a count of finished MinioIMock.GetPresignedURLForUpload invocations
func (mmGetPresignedURLForUpload *MinioIMock) GetPresignedURLForUploadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPresignedURLForUpload.afterGetPresignedURLForUploadCounter)
}

// GetPresignedURLForUploadBeforeCounter returns a count of MinioIMock.GetPresignedURLForUpload invocations
func (mmGetPresignedURLForUpload *MinioIMock) GetPresignedURLForUploadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPresignedURLForUpload.beforeGetPresignedURLForUploadCounter)
}

// Calls returns a list of arguments used in each call to MinioIMock.GetPresignedURLForUpload.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPresignedURLForUpload *mMinioIMockGetPresignedURLForUpload) Calls() []*MinioIMockGetPresignedURLForUploadParams {
	mmGetPresignedURLForUpload.mutex.RLock()

	argCopy := make([]*MinioIMockGetPresignedURLForUploadParams, len(mmGetPresignedURLForUpload.callArgs))
	copy(argCopy, mmGetPresignedURLForUpload.callArgs)

	mmGetPresignedURLForUpload.mutex.RUnlock()

	return argCopy
}

// MinimockGetPresignedURLForUploadDone returns true if the count of the GetPresignedURLForUpload invocations corresponds
// the number of defined expectations
func (m *MinioIMock) MinimockGetPresignedURLForUploadDone() bool {
	if m.GetPresignedURLForUploadMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPresignedURLForUploadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPresignedURLForUploadMock.invocationsDone()
}

// MinimockGetPresignedURLForUploadInspect logs each unmet expectation
func (m *MinioIMock) MinimockGetPresignedURLForUploadInspect() {
	for _, e := range m.GetPresignedURLForUploadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinioIMock.GetPresignedURLForUpload at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPresignedURLForUploadCounter := mm_atomic.LoadUint64(&m.afterGetPresignedURLForUploadCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPresignedURLForUploadMock.defaultExpectation != nil && afterGetPresignedURLForUploadCounter < 1 {
		if m.GetPresignedURLForUploadMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MinioIMock.GetPresignedURLForUpload at\n%s", m.GetPresignedURLForUploadMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MinioIMock.GetPresignedURLForUpload at\n%s with params: %#v", m.GetPresignedURLForUploadMock.defaultExpectation.expectationOrigins.origin, *m.GetPresignedURLForUploadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPresignedURLForUpload != nil && afterGetPresignedURLForUploadCounter < 1 {
		m.t.Errorf("Expected call to MinioIMock.GetPresignedURLForUpload at\n%s", m.funcGetPresignedURLForUploadOrigin)
	}

	if !m.GetPresignedURLForUploadMock.invocationsDone() && afterGetPresignedURLForUploadCounter > 0 {
		m.t.Errorf("Expected %d calls to MinioIMock.GetPresignedURLForUpload at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPresignedURLForUploadMock.expectedInvocations), m.GetPresignedURLForUploadMock.expectedInvocationsOrigin, afterGetPresignedURLForUploadCounter)
	}
}

type mMinioIMockListConvertedFilesByFileUID struct {
	optional           bool
	mock               *MinioIMock
	defaultExpectation *MinioIMockListConvertedFilesByFileUIDExpectation
	expectations       []*MinioIMockListConvertedFilesByFileUIDExpectation

	callArgs []*MinioIMockListConvertedFilesByFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MinioIMockListConvertedFilesByFileUIDExpectation specifies expectation struct of the MinioI.ListConvertedFilesByFileUID
type MinioIMockListConvertedFilesByFileUIDExpectation struct {
	mock               *MinioIMock
	params             *MinioIMockListConvertedFilesByFileUIDParams
	paramPtrs          *MinioIMockListConvertedFilesByFileUIDParamPtrs
	expectationOrigins MinioIMockListConvertedFilesByFileUIDExpectationOrigins
	results            *MinioIMockListConvertedFilesByFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// MinioIMockListConvertedFilesByFileUIDParams contains parameters of the MinioI.ListConvertedFilesByFileUID
type MinioIMockListConvertedFilesByFileUIDParams struct {
	ctx     context.Context
	kbUID   uuid.UUID
	fileUID uuid.UUID
}

// MinioIMockListConvertedFilesByFileUIDParamPtrs contains pointers to parameters of the MinioI.ListConvertedFilesByFileUID
type MinioIMockListConvertedFilesByFileUIDParamPtrs struct {
	ctx     *context.Context
	kbUID   *uuid.UUID
	fileUID *uuid.UUID
}

// MinioIMockListConvertedFilesByFileUIDResults contains results of the MinioI.ListConvertedFilesByFileUID
type MinioIMockListConvertedFilesByFileUIDResults struct {
	sa1 []string
	err error
}

// MinioIMockListConvertedFilesByFileUIDOrigins contains origins of expectations of the MinioI.ListConvertedFilesByFileUID
type MinioIMockListConvertedFilesByFileUIDExpectationOrigins struct {
	origin        string
	originCtx     string
	originKbUID   string
	originFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListConvertedFilesByFileUID *mMinioIMockListConvertedFilesByFileUID) Optional() *mMinioIMockListConvertedFilesByFileUID {
	mmListConvertedFilesByFileUID.optional = true
	return mmListConvertedFilesByFileUID
}

// Expect sets up expected params for MinioI.ListConvertedFilesByFileUID
func (mmListConvertedFilesByFileUID *mMinioIMockListConvertedFilesByFileUID) Expect(ctx context.Context, kbUID uuid.UUID, fileUID uuid.UUID) *mMinioIMockListConvertedFilesByFileUID {
	if mmListConvertedFilesByFileUID.mock.funcListConvertedFilesByFileUID != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("MinioIMock.ListConvertedFilesByFileUID mock is already set by Set")
	}

	if mmListConvertedFilesByFileUID.defaultExpectation == nil {
		mmListConvertedFilesByFileUID.defaultExpectation = &MinioIMockListConvertedFilesByFileUIDExpectation{}
	}

	if mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("MinioIMock.ListConvertedFilesByFileUID mock is already set by ExpectParams functions")
	}

	mmListConvertedFilesByFileUID.defaultExpectation.params = &MinioIMockListConvertedFilesByFileUIDParams{ctx, kbUID, fileUID}
	mmListConvertedFilesByFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListConvertedFilesByFileUID.expectations {
		if minimock.Equal(e.params, mmListConvertedFilesByFileUID.defaultExpectation.params) {
			mmListConvertedFilesByFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListConvertedFilesByFileUID.defaultExpectation.params)
		}
	}

	return mmListConvertedFilesByFileUID
}

// ExpectCtxParam1 sets up expected param ctx for MinioI.ListConvertedFilesByFileUID
func (mmListConvertedFilesByFileUID *mMinioIMockListConvertedFilesByFileUID) ExpectCtxParam1(ctx context.Context) *mMinioIMockListConvertedFilesByFileUID {
	if mmListConvertedFilesByFileUID.mock.funcListConvertedFilesByFileUID != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("MinioIMock.ListConvertedFilesByFileUID mock is already set by Set")
	}

	if mmListConvertedFilesByFileUID.defaultExpectation == nil {
		mmListConvertedFilesByFileUID.defaultExpectation = &MinioIMockListConvertedFilesByFileUIDExpectation{}
	}

	if mmListConvertedFilesByFileUID.defaultExpectation.params != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("MinioIMock.ListConvertedFilesByFileUID mock is already set by Expect")
	}

	if mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs == nil {
		mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs = &MinioIMockListConvertedFilesByFileUIDParamPtrs{}
	}
	mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmListConvertedFilesByFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListConvertedFilesByFileUID
}

// ExpectKbUIDParam2 sets up expected param kbUID for MinioI.ListConvertedFilesByFileUID
func (mmListConvertedFilesByFileUID *mMinioIMockListConvertedFilesByFileUID) ExpectKbUIDParam2(kbUID uuid.UUID) *mMinioIMockListConvertedFilesByFileUID {
	if mmListConvertedFilesByFileUID.mock.funcListConvertedFilesByFileUID != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("MinioIMock.ListConvertedFilesByFileUID mock is already set by Set")
	}

	if mmListConvertedFilesByFileUID.defaultExpectation == nil {
		mmListConvertedFilesByFileUID.defaultExpectation = &MinioIMockListConvertedFilesByFileUIDExpectation{}
	}

	if mmListConvertedFilesByFileUID.defaultExpectation.params != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("MinioIMock.ListConvertedFilesByFileUID mock is already set by Expect")
	}

	if mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs == nil {
		mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs = &MinioIMockListConvertedFilesByFileUIDParamPtrs{}
	}
	mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmListConvertedFilesByFileUID.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmListConvertedFilesByFileUID
}

// ExpectFileUIDParam3 sets up expected param fileUID for MinioI.ListConvertedFilesByFileUID
func (mmListConvertedFilesByFileUID *mMinioIMockListConvertedFilesByFileUID) ExpectFileUIDParam3(fileUID uuid.UUID) *mMinioIMockListConvertedFilesByFileUID {
	if mmListConvertedFilesByFileUID.mock.funcListConvertedFilesByFileUID != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("MinioIMock.ListConvertedFilesByFileUID mock is already set by Set")
	}

	if mmListConvertedFilesByFileUID.defaultExpectation == nil {
		mmListConvertedFilesByFileUID.defaultExpectation = &MinioIMockListConvertedFilesByFileUIDExpectation{}
	}

	if mmListConvertedFilesByFileUID.defaultExpectation.params != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("MinioIMock.ListConvertedFilesByFileUID mock is already set by Expect")
	}

	if mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs == nil {
		mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs = &MinioIMockListConvertedFilesByFileUIDParamPtrs{}
	}
	mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmListConvertedFilesByFileUID.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmListConvertedFilesByFileUID
}

// Inspect accepts an inspector function that has same arguments as the MinioI.ListConvertedFilesByFileUID
func (mmListConvertedFilesByFileUID *mMinioIMockListConvertedFilesByFileUID) Inspect(f func(ctx context.Context, kbUID uuid.UUID, fileUID uuid.UUID)) *mMinioIMockListConvertedFilesByFileUID {
	if mmListConvertedFilesByFileUID.mock.inspectFuncListConvertedFilesByFileUID != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("Inspect function is already set for MinioIMock.ListConvertedFilesByFileUID")
	}

	mmListConvertedFilesByFileUID.mock.inspectFuncListConvertedFilesByFileUID = f

	return mmListConvertedFilesByFileUID
}

// Return sets up results that will be returned by MinioI.ListConvertedFilesByFileUID
func (mmListConvertedFilesByFileUID *mMinioIMockListConvertedFilesByFileUID) Return(sa1 []string, err error) *MinioIMock {
	if mmListConvertedFilesByFileUID.mock.funcListConvertedFilesByFileUID != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("MinioIMock.ListConvertedFilesByFileUID mock is already set by Set")
	}

	if mmListConvertedFilesByFileUID.defaultExpectation == nil {
		mmListConvertedFilesByFileUID.defaultExpectation = &MinioIMockListConvertedFilesByFileUIDExpectation{mock: mmListConvertedFilesByFileUID.mock}
	}
	mmListConvertedFilesByFileUID.defaultExpectation.results = &MinioIMockListConvertedFilesByFileUIDResults{sa1, err}
	mmListConvertedFilesByFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListConvertedFilesByFileUID.mock
}

// Set uses given function f to mock the MinioI.ListConvertedFilesByFileUID method
func (mmListConvertedFilesByFileUID *mMinioIMockListConvertedFilesByFileUID) Set(f func(ctx context.Context, kbUID uuid.UUID, fileUID uuid.UUID) (sa1 []string, err error)) *MinioIMock {
	if mmListConvertedFilesByFileUID.defaultExpectation != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("Default expectation is already set for the MinioI.ListConvertedFilesByFileUID method")
	}

	if len(mmListConvertedFilesByFileUID.expectations) > 0 {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("Some expectations are already set for the MinioI.ListConvertedFilesByFileUID method")
	}

	mmListConvertedFilesByFileUID.mock.funcListConvertedFilesByFileUID = f
	mmListConvertedFilesByFileUID.mock.funcListConvertedFilesByFileUIDOrigin = minimock.CallerInfo(1)
	return mmListConvertedFilesByFileUID.mock
}

// When sets expectation for the MinioI.ListConvertedFilesByFileUID which will trigger the result defined by the following
// Then helper
func (mmListConvertedFilesByFileUID *mMinioIMockListConvertedFilesByFileUID) When(ctx context.Context, kbUID uuid.UUID, fileUID uuid.UUID) *MinioIMockListConvertedFilesByFileUIDExpectation {
	if mmListConvertedFilesByFileUID.mock.funcListConvertedFilesByFileUID != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("MinioIMock.ListConvertedFilesByFileUID mock is already set by Set")
	}

	expectation := &MinioIMockListConvertedFilesByFileUIDExpectation{
		mock:               mmListConvertedFilesByFileUID.mock,
		params:             &MinioIMockListConvertedFilesByFileUIDParams{ctx, kbUID, fileUID},
		expectationOrigins: MinioIMockListConvertedFilesByFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListConvertedFilesByFileUID.expectations = append(mmListConvertedFilesByFileUID.expectations, expectation)
	return expectation
}

// Then sets up MinioI.ListConvertedFilesByFileUID return parameters for the expectation previously defined by the When method
func (e *MinioIMockListConvertedFilesByFileUIDExpectation) Then(sa1 []string, err error) *MinioIMock {
	e.results = &MinioIMockListConvertedFilesByFileUIDResults{sa1, err}
	return e.mock
}

// Times sets number of times MinioI.ListConvertedFilesByFileUID should be invoked
func (mmListConvertedFilesByFileUID *mMinioIMockListConvertedFilesByFileUID) Times(n uint64) *mMinioIMockListConvertedFilesByFileUID {
	if n == 0 {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("Times of MinioIMock.ListConvertedFilesByFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListConvertedFilesByFileUID.expectedInvocations, n)
	mmListConvertedFilesByFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListConvertedFilesByFileUID
}

func (mmListConvertedFilesByFileUID *mMinioIMockListConvertedFilesByFileUID) invocationsDone() bool {
	if len(mmListConvertedFilesByFileUID.expectations) == 0 && mmListConvertedFilesByFileUID.defaultExpectation == nil && mmListConvertedFilesByFileUID.mock.funcListConvertedFilesByFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListConvertedFilesByFileUID.mock.afterListConvertedFilesByFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListConvertedFilesByFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListConvertedFilesByFileUID implements mm_minio.MinioI
func (mmListConvertedFilesByFileUID *MinioIMock) ListConvertedFilesByFileUID(ctx context.Context, kbUID uuid.UUID, fileUID uuid.UUID) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmListConvertedFilesByFileUID.beforeListConvertedFilesByFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmListConvertedFilesByFileUID.afterListConvertedFilesByFileUIDCounter, 1)

	mmListConvertedFilesByFileUID.t.Helper()

	if mmListConvertedFilesByFileUID.inspectFuncListConvertedFilesByFileUID != nil {
		mmListConvertedFilesByFileUID.inspectFuncListConvertedFilesByFileUID(ctx, kbUID, fileUID)
	}

	mm_params := MinioIMockListConvertedFilesByFileUIDParams{ctx, kbUID, fileUID}

	// Record call args
	mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.mutex.Lock()
	mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.callArgs = append(mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.callArgs, &mm_params)
	mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.mutex.Unlock()

	for _, e := range mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.defaultExpectation.paramPtrs

		mm_got := MinioIMockListConvertedFilesByFileUIDParams{ctx, kbUID, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListConvertedFilesByFileUID.t.Errorf("MinioIMock.ListConvertedFilesByFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmListConvertedFilesByFileUID.t.Errorf("MinioIMock.ListConvertedFilesByFileUID got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmListConvertedFilesByFileUID.t.Errorf("MinioIMock.ListConvertedFilesByFileUID got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListConvertedFilesByFileUID.t.Errorf("MinioIMock.ListConvertedFilesByFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmListConvertedFilesByFileUID.t.Fatal("No results are set for the MinioIMock.ListConvertedFilesByFileUID")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmListConvertedFilesByFileUID.funcListConvertedFilesByFileUID != nil {
		return mmListConvertedFilesByFileUID.funcListConvertedFilesByFileUID(ctx, kbUID, fileUID)
	}
	mmListConvertedFilesByFileUID.t.Fatalf("Unexpected call to MinioIMock.ListConvertedFilesByFileUID. %v %v %v", ctx, kbUID, fileUID)
	return
}

// ListConvertedFilesByFileUIDAfterCounter returns a count of finished MinioIMock.ListConvertedFilesByFileUID invocations
func (mmListConvertedFilesByFileUID *MinioIMock) ListConvertedFilesByFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListConvertedFilesByFileUID.afterListConvertedFilesByFileUIDCounter)
}

// ListConvertedFilesByFileUIDBeforeCounter returns a count of MinioIMock.ListConvertedFilesByFileUID invocations
func (mmListConvertedFilesByFileUID *MinioIMock) ListConvertedFilesByFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListConvertedFilesByFileUID.beforeListConvertedFilesByFileUIDCounter)
}

// Calls returns a list of arguments used in each call to MinioIMock.ListConvertedFilesByFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListConvertedFilesByFileUID *mMinioIMockListConvertedFilesByFileUID) Calls() []*MinioIMockListConvertedFilesByFileUIDParams {
	mmListConvertedFilesByFileUID.mutex.RLock()

	argCopy := make([]*MinioIMockListConvertedFilesByFileUIDParams, len(mmListConvertedFilesByFileUID.callArgs))
	copy(argCopy, mmListConvertedFilesByFileUID.callArgs)

	mmListConvertedFilesByFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockListConvertedFilesByFileUIDDone returns true if the count of the ListConvertedFilesByFileUID invocations corresponds
// the number of defined expectations
func (m *MinioIMock) MinimockListConvertedFilesByFileUIDDone() bool {
	if m.ListConvertedFilesByFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListConvertedFilesByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListConvertedFilesByFileUIDMock.invocationsDone()
}

// MinimockListConvertedFilesByFileUIDInspect logs each unmet expectation
func (m *MinioIMock) MinimockListConvertedFilesByFileUIDInspect() {
	for _, e := range m.ListConvertedFilesByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinioIMock.ListConvertedFilesByFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListConvertedFilesByFileUIDCounter := mm_atomic.LoadUint64(&m.afterListConvertedFilesByFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListConvertedFilesByFileUIDMock.defaultExpectation != nil && afterListConvertedFilesByFileUIDCounter < 1 {
		if m.ListConvertedFilesByFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MinioIMock.ListConvertedFilesByFileUID at\n%s", m.ListConvertedFilesByFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MinioIMock.ListConvertedFilesByFileUID at\n%s with params: %#v", m.ListConvertedFilesByFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.ListConvertedFilesByFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListConvertedFilesByFileUID != nil && afterListConvertedFilesByFileUIDCounter < 1 {
		m.t.Errorf("Expected call to MinioIMock.ListConvertedFilesByFileUID at\n%s", m.funcListConvertedFilesByFileUIDOrigin)
	}

	if !m.ListConvertedFilesByFileUIDMock.invocationsDone() && afterListConvertedFilesByFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to MinioIMock.ListConvertedFilesByFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListConvertedFilesByFileUIDMock.expectedInvocations), m.ListConvertedFilesByFileUIDMock.expectedInvocationsOrigin, afterListConvertedFilesByFileUIDCounter)
	}
}

type mMinioIMockListFilePathsWithPrefix struct {
	optional           bool
	mock               *MinioIMock
	defaultExpectation *MinioIMockListFilePathsWithPrefixExpectation
	expectations       []*MinioIMockListFilePathsWithPrefixExpectation

	callArgs []*MinioIMockListFilePathsWithPrefixParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MinioIMockListFilePathsWithPrefixExpectation specifies expectation struct of the MinioI.ListFilePathsWithPrefix
type MinioIMockListFilePathsWithPrefixExpectation struct {
	mock               *MinioIMock
	params             *MinioIMockListFilePathsWithPrefixParams
	paramPtrs          *MinioIMockListFilePathsWithPrefixParamPtrs
	expectationOrigins MinioIMockListFilePathsWithPrefixExpectationOrigins
	results            *MinioIMockListFilePathsWithPrefixResults
	returnOrigin       string
	Counter            uint64
}

// MinioIMockListFilePathsWithPrefixParams contains parameters of the MinioI.ListFilePathsWithPrefix
type MinioIMockListFilePathsWithPrefixParams struct {
	ctx    context.Context
	bucket string
	prefix string
}

// MinioIMockListFilePathsWithPrefixParamPtrs contains pointers to parameters of the MinioI.ListFilePathsWithPrefix
type MinioIMockListFilePathsWithPrefixParamPtrs struct {
	ctx    *context.Context
	bucket *string
	prefix *string
}

// MinioIMockListFilePathsWithPrefixResults contains results of the MinioI.ListFilePathsWithPrefix
type MinioIMockListFilePathsWithPrefixResults struct {
	sa1 []string
	err error
}

// MinioIMockListFilePathsWithPrefixOrigins contains origins of expectations of the MinioI.ListFilePathsWithPrefix
type MinioIMockListFilePathsWithPrefixExpectationOrigins struct {
	origin       string
	originCtx    string
	originBucket string
	originPrefix string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListFilePathsWithPrefix *mMinioIMockListFilePathsWithPrefix) Optional() *mMinioIMockListFilePathsWithPrefix {
	mmListFilePathsWithPrefix.optional = true
	return mmListFilePathsWithPrefix
}

// Expect sets up expected params for MinioI.ListFilePathsWithPrefix
func (mmListFilePathsWithPrefix *mMinioIMockListFilePathsWithPrefix) Expect(ctx context.Context, bucket string, prefix string) *mMinioIMockListFilePathsWithPrefix {
	if mmListFilePathsWithPrefix.mock.funcListFilePathsWithPrefix != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("MinioIMock.ListFilePathsWithPrefix mock is already set by Set")
	}

	if mmListFilePathsWithPrefix.defaultExpectation == nil {
		mmListFilePathsWithPrefix.defaultExpectation = &MinioIMockListFilePathsWithPrefixExpectation{}
	}

	if mmListFilePathsWithPrefix.defaultExpectation.paramPtrs != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("MinioIMock.ListFilePathsWithPrefix mock is already set by ExpectParams functions")
	}

	mmListFilePathsWithPrefix.defaultExpectation.params = &MinioIMockListFilePathsWithPrefixParams{ctx, bucket, prefix}
	mmListFilePathsWithPrefix.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListFilePathsWithPrefix.expectations {
		if minimock.Equal(e.params, mmListFilePathsWithPrefix.defaultExpectation.params) {
			mmListFilePathsWithPrefix.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListFilePathsWithPrefix.defaultExpectation.params)
		}
	}

	return mmListFilePathsWithPrefix
}

// ExpectCtxParam1 sets up expected param ctx for MinioI.ListFilePathsWithPrefix
func (mmListFilePathsWithPrefix *mMinioIMockListFilePathsWithPrefix) ExpectCtxParam1(ctx context.Context) *mMinioIMockListFilePathsWithPrefix {
	if mmListFilePathsWithPrefix.mock.funcListFilePathsWithPrefix != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("MinioIMock.ListFilePathsWithPrefix mock is already set by Set")
	}

	if mmListFilePathsWithPrefix.defaultExpectation == nil {
		mmListFilePathsWithPrefix.defaultExpectation = &MinioIMockListFilePathsWithPrefixExpectation{}
	}

	if mmListFilePathsWithPrefix.defaultExpectation.params != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("MinioIMock.ListFilePathsWithPrefix mock is already set by Expect")
	}

	if mmListFilePathsWithPrefix.defaultExpectation.paramPtrs == nil {
		mmListFilePathsWithPrefix.defaultExpectation.paramPtrs = &MinioIMockListFilePathsWithPrefixParamPtrs{}
	}
	mmListFilePathsWithPrefix.defaultExpectation.paramPtrs.ctx = &ctx
	mmListFilePathsWithPrefix.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListFilePathsWithPrefix
}

// ExpectBucketParam2 sets up expected param bucket for MinioI.ListFilePathsWithPrefix
func (mmListFilePathsWithPrefix *mMinioIMockListFilePathsWithPrefix) ExpectBucketParam2(bucket string) *mMinioIMockListFilePathsWithPrefix {
	if mmListFilePathsWithPrefix.mock.funcListFilePathsWithPrefix != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("MinioIMock.ListFilePathsWithPrefix mock is already set by Set")
	}

	if mmListFilePathsWithPrefix.defaultExpectation == nil {
		mmListFilePathsWithPrefix.defaultExpectation = &MinioIMockListFilePathsWithPrefixExpectation{}
	}

	if mmListFilePathsWithPrefix.defaultExpectation.params != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("MinioIMock.ListFilePathsWithPrefix mock is already set by Expect")
	}

	if mmListFilePathsWithPrefix.defaultExpectation.paramPtrs == nil {
		mmListFilePathsWithPrefix.defaultExpectation.paramPtrs = &MinioIMockListFilePathsWithPrefixParamPtrs{}
	}
	mmListFilePathsWithPrefix.defaultExpectation.paramPtrs.bucket = &bucket
	mmListFilePathsWithPrefix.defaultExpectation.expectationOrigins.originBucket = minimock.CallerInfo(1)

	return mmListFilePathsWithPrefix
}

// ExpectPrefixParam3 sets up expected param prefix for MinioI.ListFilePathsWithPrefix
func (mmListFilePathsWithPrefix *mMinioIMockListFilePathsWithPrefix) ExpectPrefixParam3(prefix string) *mMinioIMockListFilePathsWithPrefix {
	if mmListFilePathsWithPrefix.mock.funcListFilePathsWithPrefix != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("MinioIMock.ListFilePathsWithPrefix mock is already set by Set")
	}

	if mmListFilePathsWithPrefix.defaultExpectation == nil {
		mmListFilePathsWithPrefix.defaultExpectation = &MinioIMockListFilePathsWithPrefixExpectation{}
	}

	if mmListFilePathsWithPrefix.defaultExpectation.params != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("MinioIMock.ListFilePathsWithPrefix mock is already set by Expect")
	}

	if mmListFilePathsWithPrefix.defaultExpectation.paramPtrs == nil {
		mmListFilePathsWithPrefix.defaultExpectation.paramPtrs = &MinioIMockListFilePathsWithPrefixParamPtrs{}
	}
	mmListFilePathsWithPrefix.defaultExpectation.paramPtrs.prefix = &prefix
	mmListFilePathsWithPrefix.defaultExpectation.expectationOrigins.originPrefix = minimock.CallerInfo(1)

	return mmListFilePathsWithPrefix
}

// Inspect accepts an inspector function that has same arguments as the MinioI.ListFilePathsWithPrefix
func (mmListFilePathsWithPrefix *mMinioIMockListFilePathsWithPrefix) Inspect(f func(ctx context.Context, bucket string, prefix string)) *mMinioIMockListFilePathsWithPrefix {
	if mmListFilePathsWithPrefix.mock.inspectFuncListFilePathsWithPrefix != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("Inspect function is already set for MinioIMock.ListFilePathsWithPrefix")
	}

	mmListFilePathsWithPrefix.mock.inspectFuncListFilePathsWithPrefix = f

	return mmListFilePathsWithPrefix
}

// Return sets up results that will be returned by MinioI.ListFilePathsWithPrefix
func (mmListFilePathsWithPrefix *mMinioIMockListFilePathsWithPrefix) Return(sa1 []string, err error) *MinioIMock {
	if mmListFilePathsWithPrefix.mock.funcListFilePathsWithPrefix != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("MinioIMock.ListFilePathsWithPrefix mock is already set by Set")
	}

	if mmListFilePathsWithPrefix.defaultExpectation == nil {
		mmListFilePathsWithPrefix.defaultExpectation = &MinioIMockListFilePathsWithPrefixExpectation{mock: mmListFilePathsWithPrefix.mock}
	}
	mmListFilePathsWithPrefix.defaultExpectation.results = &MinioIMockListFilePathsWithPrefixResults{sa1, err}
	mmListFilePathsWithPrefix.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListFilePathsWithPrefix.mock
}

// Set uses given function f to mock the MinioI.ListFilePathsWithPrefix method
func (mmListFilePathsWithPrefix *mMinioIMockListFilePathsWithPrefix) Set(f func(ctx context.Context, bucket string, prefix string) (sa1 []string, err error)) *MinioIMock {
	if mmListFilePathsWithPrefix.defaultExpectation != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("Default expectation is already set for the MinioI.ListFilePathsWithPrefix method")
	}

	if len(mmListFilePathsWithPrefix.expectations) > 0 {
		mmListFilePathsWithPrefix.mock.t.Fatalf("Some expectations are already set for the MinioI.ListFilePathsWithPrefix method")
	}

	mmListFilePathsWithPrefix.mock.funcListFilePathsWithPrefix = f
	mmListFilePathsWithPrefix.mock.funcListFilePathsWithPrefixOrigin = minimock.CallerInfo(1)
	return mmListFilePathsWithPrefix.mock
}

// When sets expectation for the MinioI.ListFilePathsWithPrefix which will trigger the result defined by the following
// Then helper
func (mmListFilePathsWithPrefix *mMinioIMockListFilePathsWithPrefix) When(ctx context.Context, bucket string, prefix string) *MinioIMockListFilePathsWithPrefixExpectation {
	if mmListFilePathsWithPrefix.mock.funcListFilePathsWithPrefix != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("MinioIMock.ListFilePathsWithPrefix mock is already set by Set")
	}

	expectation := &MinioIMockListFilePathsWithPrefixExpectation{
		mock:               mmListFilePathsWithPrefix.mock,
		params:             &MinioIMockListFilePathsWithPrefixParams{ctx, bucket, prefix},
		expectationOrigins: MinioIMockListFilePathsWithPrefixExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListFilePathsWithPrefix.expectations = append(mmListFilePathsWithPrefix.expectations, expectation)
	return expectation
}

// Then sets up MinioI.ListFilePathsWithPrefix return parameters for the expectation previously defined by the When method
func (e *MinioIMockListFilePathsWithPrefixExpectation) Then(sa1 []string, err error) *MinioIMock {
	e.results = &MinioIMockListFilePathsWithPrefixResults{sa1, err}
	return e.mock
}

// Times sets number of times MinioI.ListFilePathsWithPrefix should be invoked
func (mmListFilePathsWithPrefix *mMinioIMockListFilePathsWithPrefix) Times(n uint64) *mMinioIMockListFilePathsWithPrefix {
	if n == 0 {
		mmListFilePathsWithPrefix.mock.t.Fatalf("Times of MinioIMock.ListFilePathsWithPrefix mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListFilePathsWithPrefix.expectedInvocations, n)
	mmListFilePathsWithPrefix.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListFilePathsWithPrefix
}

func (mmListFilePathsWithPrefix *mMinioIMockListFilePathsWithPrefix) invocationsDone() bool {
	if len(mmListFilePathsWithPrefix.expectations) == 0 && mmListFilePathsWithPrefix.defaultExpectation == nil && mmListFilePathsWithPrefix.mock.funcListFilePathsWithPrefix == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListFilePathsWithPrefix.mock.afterListFilePathsWithPrefixCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListFilePathsWithPrefix.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListFilePathsWithPrefix implements mm_minio.MinioI
func (mmListFilePathsWithPrefix *MinioIMock) ListFilePathsWithPrefix(ctx context.Context, bucket string, prefix string) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmListFilePathsWithPrefix.beforeListFilePathsWithPrefixCounter, 1)
	defer mm_atomic.AddUint64(&mmListFilePathsWithPrefix.afterListFilePathsWithPrefixCounter, 1)

	mmListFilePathsWithPrefix.t.Helper()

	if mmListFilePathsWithPrefix.inspectFuncListFilePathsWithPrefix != nil {
		mmListFilePathsWithPrefix.inspectFuncListFilePathsWithPrefix(ctx, bucket, prefix)
	}

	mm_params := MinioIMockListFilePathsWithPrefixParams{ctx, bucket, prefix}

	// Record call args
	mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.mutex.Lock()
	mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.callArgs = append(mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.callArgs, &mm_params)
	mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.mutex.Unlock()

	for _, e := range mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.defaultExpectation.Counter, 1)
		mm_want := mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.defaultExpectation.params
		mm_want_ptrs := mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.defaultExpectation.paramPtrs

		mm_got := MinioIMockListFilePathsWithPrefixParams{ctx, bucket, prefix}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListFilePathsWithPrefix.t.Errorf("MinioIMock.ListFilePathsWithPrefix got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.bucket != nil && !minimock.Equal(*mm_want_ptrs.bucket, mm_got.bucket) {
				mmListFilePathsWithPrefix.t.Errorf("MinioIMock.ListFilePathsWithPrefix got unexpected parameter bucket, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.defaultExpectation.expectationOrigins.originBucket, *mm_want_ptrs.bucket, mm_got.bucket, minimock.Diff(*mm_want_ptrs.bucket, mm_got.bucket))
			}

			if mm_want_ptrs.prefix != nil && !minimock.Equal(*mm_want_ptrs.prefix, mm_got.prefix) {
				mmListFilePathsWithPrefix.t.Errorf("MinioIMock.ListFilePathsWithPrefix got unexpected parameter prefix, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.defaultExpectation.expectationOrigins.originPrefix, *mm_want_ptrs.prefix, mm_got.prefix, minimock.Diff(*mm_want_ptrs.prefix, mm_got.prefix))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListFilePathsWithPrefix.t.Errorf("MinioIMock.ListFilePathsWithPrefix got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.defaultExpectation.results
		if mm_results == nil {
			mmListFilePathsWithPrefix.t.Fatal("No results are set for the MinioIMock.ListFilePathsWithPrefix")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmListFilePathsWithPrefix.funcListFilePathsWithPrefix != nil {
		return mmListFilePathsWithPrefix.funcListFilePathsWithPrefix(ctx, bucket, prefix)
	}
	mmListFilePathsWithPrefix.t.Fatalf("Unexpected call to MinioIMock.ListFilePathsWithPrefix. %v %v %v", ctx, bucket, prefix)
	return
}

// ListFilePathsWithPrefixAfterCounter returns a count of finished MinioIMock.ListFilePathsWithPrefix invocations
func (mmListFilePathsWithPrefix *MinioIMock) ListFilePathsWithPrefixAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListFilePathsWithPrefix.afterListFilePathsWithPrefixCounter)
}

// ListFilePathsWithPrefixBeforeCounter returns a count of MinioIMock.ListFilePathsWithPrefix invocations
func (mmListFilePathsWithPrefix *MinioIMock) ListFilePathsWithPrefixBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListFilePathsWithPrefix.beforeListFilePathsWithPrefixCounter)
}

// Calls returns a list of arguments used in each call to MinioIMock.ListFilePathsWithPrefix.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListFilePathsWithPrefix *mMinioIMockListFilePathsWithPrefix) Calls() []*MinioIMockListFilePathsWithPrefixParams {
	mmListFilePathsWithPrefix.mutex.RLock()

	argCopy := make([]*MinioIMockListFilePathsWithPrefixParams, len(mmListFilePathsWithPrefix.callArgs))
	copy(argCopy, mmListFilePathsWithPrefix.callArgs)

	mmListFilePathsWithPrefix.mutex.RUnlock()

	return argCopy
}

// MinimockListFilePathsWithPrefixDone returns true if the count of the ListFilePathsWithPrefix invocations corresponds
// the number of defined expectations
func (m *MinioIMock) MinimockListFilePathsWithPrefixDone() bool {
	if m.ListFilePathsWithPrefixMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListFilePathsWithPrefixMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListFilePathsWithPrefixMock.invocationsDone()
}

// MinimockListFilePathsWithPrefixInspect logs each unmet expectation
func (m *MinioIMock) MinimockListFilePathsWithPrefixInspect() {
	for _, e := range m.ListFilePathsWithPrefixMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinioIMock.ListFilePathsWithPrefix at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListFilePathsWithPrefixCounter := mm_atomic.LoadUint64(&m.afterListFilePathsWithPrefixCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListFilePathsWithPrefixMock.defaultExpectation != nil && afterListFilePathsWithPrefixCounter < 1 {
		if m.ListFilePathsWithPrefixMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MinioIMock.ListFilePathsWithPrefix at\n%s", m.ListFilePathsWithPrefixMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MinioIMock.ListFilePathsWithPrefix at\n%s with params: %#v", m.ListFilePathsWithPrefixMock.defaultExpectation.expectationOrigins.origin, *m.ListFilePathsWithPrefixMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListFilePathsWithPrefix != nil && afterListFilePathsWithPrefixCounter < 1 {
		m.t.Errorf("Expected call to MinioIMock.ListFilePathsWithPrefix at\n%s", m.funcListFilePathsWithPrefixOrigin)
	}

	if !m.ListFilePathsWithPrefixMock.invocationsDone() && afterListFilePathsWithPrefixCounter > 0 {
		m.t.Errorf("Expected %d calls to MinioIMock.ListFilePathsWithPrefix at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListFilePathsWithPrefixMock.expectedInvocations), m.ListFilePathsWithPrefixMock.expectedInvocationsOrigin, afterListFilePathsWithPrefixCounter)
	}
}

type mMinioIMockListKnowledgeBaseFiles struct {
	optional           bool
	mock               *MinioIMock
	defaultExpectation *MinioIMockListKnowledgeBaseFilesExpectation
	expectations       []*MinioIMockListKnowledgeBaseFilesExpectation

	callArgs []*MinioIMockListKnowledgeBaseFilesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MinioIMockListKnowledgeBaseFilesExpectation specifies expectation struct of the MinioI.ListKnowledgeBaseFiles
type MinioIMockListKnowledgeBaseFilesExpectation struct {
	mock               *MinioIMock
	params             *MinioIMockListKnowledgeBaseFilesParams
	paramPtrs          *MinioIMockListKnowledgeBaseFilesParamPtrs
	expectationOrigins MinioIMockListKnowledgeBaseFilesExpectationOrigins
	results            *MinioIMockListKnowledgeBaseFilesResults
	returnOrigin       string
	Counter            uint64
}

// MinioIMockListKnowledgeBaseFilesParams contains parameters of the MinioI.ListKnowledgeBaseFiles
type MinioIMockListKnowledgeBaseFilesParams struct {
	ctx   context.Context
	kbUID uuid.UUID
}

// MinioIMockListKnowledgeBaseFilesParamPtrs contains pointers to parameters of the MinioI.ListKnowledgeBaseFiles
type MinioIMockListKnowledgeBaseFilesParamPtrs struct {
	ctx   *context.Context
	kbUID *uuid.UUID
}

// MinioIMockListKnowledgeBaseFilesResults contains results of the MinioI.ListKnowledgeBaseFiles
type MinioIMockListKnowledgeBaseFilesResults struct {
	sa1 []string
	err error
}

// MinioIMockListKnowledgeBaseFilesOrigins contains origins of expectations of the MinioI.ListKnowledgeBaseFiles
type MinioIMockListKnowledgeBaseFilesExpectationOrigins struct {
	origin      string
	originCtx   string
	originKbUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListKnowledgeBaseFiles *mMinioIMockListKnowledgeBaseFiles) Optional() *mMinioIMockListKnowledgeBaseFiles {
	mmListKnowledgeBaseFiles.optional = true
	return mmListKnowledgeBaseFiles
}

// Expect sets up expected params for MinioI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mMinioIMockListKnowledgeBaseFiles) Expect(ctx context.Context, kbUID uuid.UUID) *mMinioIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("MinioIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &MinioIMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("MinioIMock.ListKnowledgeBaseFiles mock is already set by ExpectParams functions")
	}

	mmListKnowledgeBaseFiles.defaultExpectation.params = &MinioIMockListKnowledgeBaseFilesParams{ctx, kbUID}
	mmListKnowledgeBaseFiles.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListKnowledgeBaseFiles.expectations {
		if minimock.Equal(e.params, mmListKnowledgeBaseFiles.defaultExpectation.params) {
			mmListKnowledgeBaseFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListKnowledgeBaseFiles.defaultExpectation.params)
		}
	}

	return mmListKnowledgeBaseFiles
}

// ExpectCtxParam1 sets up expected param ctx for MinioI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mMinioIMockListKnowledgeBaseFiles) ExpectCtxParam1(ctx context.Context) *mMinioIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("MinioIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &MinioIMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("MinioIMock.ListKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs = &MinioIMockListKnowledgeBaseFilesParamPtrs{}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs.ctx = &ctx
	mmListKnowledgeBaseFiles.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListKnowledgeBaseFiles
}

// ExpectKbUIDParam2 sets up expected param kbUID for MinioI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mMinioIMockListKnowledgeBaseFiles) ExpectKbUIDParam2(kbUID uuid.UUID) *mMinioIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("MinioIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &MinioIMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("MinioIMock.ListKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs = &MinioIMockListKnowledgeBaseFilesParamPtrs{}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmListKnowledgeBaseFiles.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmListKnowledgeBaseFiles
}

// Inspect accepts an inspector function that has same arguments as the MinioI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mMinioIMockListKnowledgeBaseFiles) Inspect(f func(ctx context.Context, kbUID uuid.UUID)) *mMinioIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.inspectFuncListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("Inspect function is already set for MinioIMock.ListKnowledgeBaseFiles")
	}

	mmListKnowledgeBaseFiles.mock.inspectFuncListKnowledgeBaseFiles = f

	return mmListKnowledgeBaseFiles
}

// Return sets up results that will be returned by MinioI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mMinioIMockListKnowledgeBaseFiles) Return(sa1 []string, err error) *MinioIMock {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("MinioIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &MinioIMockListKnowledgeBaseFilesExpectation{mock: mmListKnowledgeBaseFiles.mock}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.results = &MinioIMockListKnowledgeBaseFilesResults{sa1, err}
	mmListKnowledgeBaseFiles.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBaseFiles.mock
}

// Set uses given function f to mock the MinioI.ListKnowledgeBaseFiles method
func (mmListKnowledgeBaseFiles *mMinioIMockListKnowledgeBaseFiles) Set(f func(ctx context.Context, kbUID uuid.UUID) (sa1 []string, err error)) *MinioIMock {
	if mmListKnowledgeBaseFiles.defaultExpectation != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("Default expectation is already set for the MinioI.ListKnowledgeBaseFiles method")
	}

	if len(mmListKnowledgeBaseFiles.expectations) > 0 {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("Some expectations are already set for the MinioI.ListKnowledgeBaseFiles method")
	}

	mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles = f
	mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFilesOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBaseFiles.mock
}

// When sets expectation for the MinioI.ListKnowledgeBaseFiles which will trigger the result defined by the following
// Then helper
func (mmListKnowledgeBaseFiles *mMinioIMockListKnowledgeBaseFiles) When(ctx context.Context, kbUID uuid.UUID) *MinioIMockListKnowledgeBaseFilesExpectation {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("MinioIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	expectation := &MinioIMockListKnowledgeBaseFilesExpectation{
		mock:               mmListKnowledgeBaseFiles.mock,
		params:             &MinioIMockListKnowledgeBaseFilesParams{ctx, kbUID},
		expectationOrigins: MinioIMockListKnowledgeBaseFilesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListKnowledgeBaseFiles.expectations = append(mmListKnowledgeBaseFiles.expectations, expectation)
	return expectation
}

// Then sets up MinioI.ListKnowledgeBaseFiles return parameters for the expectation previously defined by the When method
func (e *MinioIMockListKnowledgeBaseFilesExpectation) Then(sa1 []string, err error) *MinioIMock {
	e.results = &MinioIMockListKnowledgeBaseFilesResults{sa1, err}
	return e.mock
}

// Times sets number of times MinioI.ListKnowledgeBaseFiles should be invoked
func (mmListKnowledgeBaseFiles *mMinioIMockListKnowledgeBaseFiles) Times(n uint64) *mMinioIMockListKnowledgeBaseFiles {
	if n == 0 {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("Times of MinioIMock.ListKnowledgeBaseFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListKnowledgeBaseFiles.expectedInvocations, n)
	mmListKnowledgeBaseFiles.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBaseFiles
}

func (mmListKnowledgeBaseFiles *mMinioIMockListKnowledgeBaseFiles) invocationsDone() bool {
	if len(mmListKnowledgeBaseFiles.expectations) == 0 && mmListKnowledgeBaseFiles.defaultExpectation == nil && mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBaseFiles.mock.afterListKnowledgeBaseFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBaseFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListKnowledgeBaseFiles implements mm_minio.MinioI
func (mmListKnowledgeBaseFiles *MinioIMock) ListKnowledgeBaseFiles(ctx context.Context, kbUID uuid.UUID) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmListKnowledgeBaseFiles.beforeListKnowledgeBaseFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmListKnowledgeBaseFiles.afterListKnowledgeBaseFilesCounter, 1)

	mmListKnowledgeBaseFiles.t.Helper()

	if mmListKnowledgeBaseFiles.inspectFuncListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.inspectFuncListKnowledgeBaseFiles(ctx, kbUID)
	}

	mm_params := MinioIMockListKnowledgeBaseFilesParams{ctx, kbUID}

	// Record call args
	mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.mutex.Lock()
	mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.callArgs = append(mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.callArgs, &mm_params)
	mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.mutex.Unlock()

	for _, e := range mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.params
		mm_want_ptrs := mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.paramPtrs

		mm_got := MinioIMockListKnowledgeBaseFilesParams{ctx, kbUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListKnowledgeBaseFiles.t.Errorf("MinioIMock.ListKnowledgeBaseFiles got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmListKnowledgeBaseFiles.t.Errorf("MinioIMock.ListKnowledgeBaseFiles got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListKnowledgeBaseFiles.t.Errorf("MinioIMock.ListKnowledgeBaseFiles got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmListKnowledgeBaseFiles.t.Fatal("No results are set for the MinioIMock.ListKnowledgeBaseFiles")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmListKnowledgeBaseFiles.funcListKnowledgeBaseFiles != nil {
		return mmListKnowledgeBaseFiles.funcListKnowledgeBaseFiles(ctx, kbUID)
	}
	mmListKnowledgeBaseFiles.t.Fatalf("Unexpected call to MinioIMock.ListKnowledgeBaseFiles. %v %v", ctx, kbUID)
	return
}

// ListKnowledgeBaseFilesAfterCounter returns a count of finished MinioIMock.ListKnowledgeBaseFiles invocations
func (mmListKnowledgeBaseFiles *MinioIMock) ListKnowledgeBaseFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBaseFiles.afterListKnowledgeBaseFilesCounter)
}

// ListKnowledgeBaseFilesBeforeCounter returns a count of MinioIMock.ListKnowledgeBaseFiles invocations
func (mmListKnowledgeBaseFiles *MinioIMock) ListKnowledgeBaseFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBaseFiles.beforeListKnowledgeBaseFilesCounter)
}

// Calls returns a list of arguments used in each call to MinioIMock.ListKnowledgeBaseFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListKnowledgeBaseFiles *mMinioIMockListKnowledgeBaseFiles) Calls() []*MinioIMockListKnowledgeBaseFilesParams {
	mmListKnowledgeBaseFiles.mutex.RLock()

	argCopy := make([]*MinioIMockListKnowledgeBaseFilesParams, len(mmListKnowledgeBaseFiles.callArgs))
	copy(argCopy, mmListKnowledgeBaseFiles.callArgs)

	mmListKnowledgeBaseFiles.mutex.RUnlock()

	return argCopy
}

// MinimockListKnowledgeBaseFilesDone returns true if the count of the ListKnowledgeBaseFiles invocations corresponds
// the number of defined expectations
func (m *MinioIMock) MinimockListKnowledgeBaseFilesDone() bool {
	if m.ListKnowledgeBaseFilesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListKnowledgeBaseFilesMock.invocationsDone()
}

// MinimockListKnowledgeBaseFilesInspect logs each unmet expectation
func (m *MinioIMock) MinimockListKnowledgeBaseFilesInspect() {
	for _, e := range m.ListKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinioIMock.ListKnowledgeBaseFiles at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListKnowledgeBaseFilesCounter := mm_atomic.LoadUint64(&m.afterListKnowledgeBaseFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListKnowledgeBaseFilesMock.defaultExpectation != nil && afterListKnowledgeBaseFilesCounter < 1 {
		if m.ListKnowledgeBaseFilesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MinioIMock.ListKnowledgeBaseFiles at\n%s", m.ListKnowledgeBaseFilesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MinioIMock.ListKnowledgeBaseFiles at\n%s with params: %#v", m.ListKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.origin, *m.ListKnowledgeBaseFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListKnowledgeBaseFiles != nil && afterListKnowledgeBaseFilesCounter < 1 {
		m.t.Errorf("Expected call to MinioIMock.ListKnowledgeBaseFiles at\n%s", m.funcListKnowledgeBaseFilesOrigin)
	}

	if !m.ListKnowledgeBaseFilesMock.invocationsDone() && afterListKnowledgeBaseFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to MinioIMock.ListKnowledgeBaseFiles at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListKnowledgeBaseFilesMock.expectedInvocations), m.ListKnowledgeBaseFilesMock.expectedInvocationsOrigin, afterListKnowledgeBaseFilesCounter)
	}
}

type mMinioIMockListTextChunksByFileUID struct {
	optional           bool
	mock               *MinioIMock
	defaultExpectation *MinioIMockListTextChunksByFileUIDExpectation
	expectations       []*MinioIMockListTextChunksByFileUIDExpectation

	callArgs []*MinioIMockListTextChunksByFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MinioIMockListTextChunksByFileUIDExpectation specifies expectation struct of the MinioI.ListTextChunksByFileUID
type MinioIMockListTextChunksByFileUIDExpectation struct {
	mock               *MinioIMock
	params             *MinioIMockListTextChunksByFileUIDParams
	paramPtrs          *MinioIMockListTextChunksByFileUIDParamPtrs
	expectationOrigins MinioIMockListTextChunksByFileUIDExpectationOrigins
	results            *MinioIMockListTextChunksByFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// MinioIMockListTextChunksByFileUIDParams contains parameters of the MinioI.ListTextChunksByFileUID
type MinioIMockListTextChunksByFileUIDParams struct {
	ctx     context.Context
	kbUID   uuid.UUID
	fileUID uuid.UUID
}

// MinioIMockListTextChunksByFileUIDParamPtrs contains pointers to parameters of the MinioI.ListTextChunksByFileUID
type MinioIMockListTextChunksByFileUIDParamPtrs struct {
	ctx     *context.Context
	kbUID   *uuid.UUID
	fileUID *uuid.UUID
}

// MinioIMockListTextChunksByFileUIDResults contains results of the MinioI.ListTextChunksByFileUID
type MinioIMockListTextChunksByFileUIDResults struct {
	sa1 []string
	err error
}

// MinioIMockListTextChunksByFileUIDOrigins contains origins of expectations of the MinioI.ListTextChunksByFileUID
type MinioIMockListTextChunksByFileUIDExpectationOrigins struct {
	origin        string
	originCtx     string
	originKbUID   string
	originFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListTextChunksByFileUID *mMinioIMockListTextChunksByFileUID) Optional() *mMinioIMockListTextChunksByFileUID {
	mmListTextChunksByFileUID.optional = true
	return mmListTextChunksByFileUID
}

// Expect sets up expected params for MinioI.ListTextChunksByFileUID
func (mmListTextChunksByFileUID *mMinioIMockListTextChunksByFileUID) Expect(ctx context.Context, kbUID uuid.UUID, fileUID uuid.UUID) *mMinioIMockListTextChunksByFileUID {
	if mmListTextChunksByFileUID.mock.funcListTextChunksByFileUID != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("MinioIMock.ListTextChunksByFileUID mock is already set by Set")
	}

	if mmListTextChunksByFileUID.defaultExpectation == nil {
		mmListTextChunksByFileUID.defaultExpectation = &MinioIMockListTextChunksByFileUIDExpectation{}
	}

	if mmListTextChunksByFileUID.defaultExpectation.paramPtrs != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("MinioIMock.ListTextChunksByFileUID mock is already set by ExpectParams functions")
	}

	mmListTextChunksByFileUID.defaultExpectation.params = &MinioIMockListTextChunksByFileUIDParams{ctx, kbUID, fileUID}
	mmListTextChunksByFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListTextChunksByFileUID.expectations {
		if minimock.Equal(e.params, mmListTextChunksByFileUID.defaultExpectation.params) {
			mmListTextChunksByFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListTextChunksByFileUID.defaultExpectation.params)
		}
	}

	return mmListTextChunksByFileUID
}

// ExpectCtxParam1 sets up expected param ctx for MinioI.ListTextChunksByFileUID
func (mmListTextChunksByFileUID *mMinioIMockListTextChunksByFileUID) ExpectCtxParam1(ctx context.Context) *mMinioIMockListTextChunksByFileUID {
	if mmListTextChunksByFileUID.mock.funcListTextChunksByFileUID != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("MinioIMock.ListTextChunksByFileUID mock is already set by Set")
	}

	if mmListTextChunksByFileUID.defaultExpectation == nil {
		mmListTextChunksByFileUID.defaultExpectation = &MinioIMockListTextChunksByFileUIDExpectation{}
	}

	if mmListTextChunksByFileUID.defaultExpectation.params != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("MinioIMock.ListTextChunksByFileUID mock is already set by Expect")
	}

	if mmListTextChunksByFileUID.defaultExpectation.paramPtrs == nil {
		mmListTextChunksByFileUID.defaultExpectation.paramPtrs = &MinioIMockListTextChunksByFileUIDParamPtrs{}
	}
	mmListTextChunksByFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmListTextChunksByFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListTextChunksByFileUID
}

// ExpectKbUIDParam2 sets up expected param kbUID for MinioI.ListTextChunksByFileUID
func (mmListTextChunksByFileUID *mMinioIMockListTextChunksByFileUID) ExpectKbUIDParam2(kbUID uuid.UUID) *mMinioIMockListTextChunksByFileUID {
	if mmListTextChunksByFileUID.mock.funcListTextChunksByFileUID != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("MinioIMock.ListTextChunksByFileUID mock is already set by Set")
	}

	if mmListTextChunksByFileUID.defaultExpectation == nil {
		mmListTextChunksByFileUID.defaultExpectation = &MinioIMockListTextChunksByFileUIDExpectation{}
	}

	if mmListTextChunksByFileUID.defaultExpectation.params != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("MinioIMock.ListTextChunksByFileUID mock is already set by Expect")
	}

	if mmListTextChunksByFileUID.defaultExpectation.paramPtrs == nil {
		mmListTextChunksByFileUID.defaultExpectation.paramPtrs = &MinioIMockListTextChunksByFileUIDParamPtrs{}
	}
	mmListTextChunksByFileUID.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmListTextChunksByFileUID.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmListTextChunksByFileUID
}

// ExpectFileUIDParam3 sets up expected param fileUID for MinioI.ListTextChunksByFileUID
func (mmListTextChunksByFileUID *mMinioIMockListTextChunksByFileUID) ExpectFileUIDParam3(fileUID uuid.UUID) *mMinioIMockListTextChunksByFileUID {
	if mmListTextChunksByFileUID.mock.funcListTextChunksByFileUID != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("MinioIMock.ListTextChunksByFileUID mock is already set by Set")
	}

	if mmListTextChunksByFileUID.defaultExpectation == nil {
		mmListTextChunksByFileUID.defaultExpectation = &MinioIMockListTextChunksByFileUIDExpectation{}
	}

	if mmListTextChunksByFileUID.defaultExpectation.params != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("MinioIMock.ListTextChunksByFileUID mock is already set by Expect")
	}

	if mmListTextChunksByFileUID.defaultExpectation.paramPtrs == nil {
		mmListTextChunksByFileUID.defaultExpectation.paramPtrs = &MinioIMockListTextChunksByFileUIDParamPtrs{}
	}
	mmListTextChunksByFileUID.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmListTextChunksByFileUID.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmListTextChunksByFileUID
}

// Inspect accepts an inspector function that has same arguments as the MinioI.ListTextChunksByFileUID
func (mmListTextChunksByFileUID *mMinioIMockListTextChunksByFileUID) Inspect(f func(ctx context.Context, kbUID uuid.UUID, fileUID uuid.UUID)) *mMinioIMockListTextChunksByFileUID {
	if mmListTextChunksByFileUID.mock.inspectFuncListTextChunksByFileUID != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("Inspect function is already set for MinioIMock.ListTextChunksByFileUID")
	}

	mmListTextChunksByFileUID.mock.inspectFuncListTextChunksByFileUID = f

	return mmListTextChunksByFileUID
}

// Return sets up results that will be returned by MinioI.ListTextChunksByFileUID
func (mmListTextChunksByFileUID *mMinioIMockListTextChunksByFileUID) Return(sa1 []string, err error) *MinioIMock {
	if mmListTextChunksByFileUID.mock.funcListTextChunksByFileUID != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("MinioIMock.ListTextChunksByFileUID mock is already set by Set")
	}

	if mmListTextChunksByFileUID.defaultExpectation == nil {
		mmListTextChunksByFileUID.defaultExpectation = &MinioIMockListTextChunksByFileUIDExpectation{mock: mmListTextChunksByFileUID.mock}
	}
	mmListTextChunksByFileUID.defaultExpectation.results = &MinioIMockListTextChunksByFileUIDResults{sa1, err}
	mmListTextChunksByFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListTextChunksByFileUID.mock
}

// Set uses given function f to mock the MinioI.ListTextChunksByFileUID method
func (mmListTextChunksByFileUID *mMinioIMockListTextChunksByFileUID) Set(f func(ctx context.Context, kbUID uuid.UUID, fileUID uuid.UUID) (sa1 []string, err error)) *MinioIMock {
	if mmListTextChunksByFileUID.defaultExpectation != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("Default expectation is already set for the MinioI.ListTextChunksByFileUID method")
	}

	if len(mmListTextChunksByFileUID.expectations) > 0 {
		mmListTextChunksByFileUID.mock.t.Fatalf("Some expectations are already set for the MinioI.ListTextChunksByFileUID method")
	}

	mmListTextChunksByFileUID.mock.funcListTextChunksByFileUID = f
	mmListTextChunksByFileUID.mock.funcListTextChunksByFileUIDOrigin = minimock.CallerInfo(1)
	return mmListTextChunksByFileUID.mock
}

// When sets expectation for the MinioI.ListTextChunksByFileUID which will trigger the result defined by the following
// Then helper
func (mmListTextChunksByFileUID *mMinioIMockListTextChunksByFileUID) When(ctx context.Context, kbUID uuid.UUID, fileUID uuid.UUID) *MinioIMockListTextChunksByFileUIDExpectation {
	if mmListTextChunksByFileUID.mock.funcListTextChunksByFileUID != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("MinioIMock.ListTextChunksByFileUID mock is already set by Set")
	}

	expectation := &MinioIMockListTextChunksByFileUIDExpectation{
		mock:               mmListTextChunksByFileUID.mock,
		params:             &MinioIMockListTextChunksByFileUIDParams{ctx, kbUID, fileUID},
		expectationOrigins: MinioIMockListTextChunksByFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListTextChunksByFileUID.expectations = append(mmListTextChunksByFileUID.expectations, expectation)
	return expectation
}

// Then sets up MinioI.ListTextChunksByFileUID return parameters for the expectation previously defined by the When method
func (e *MinioIMockListTextChunksByFileUIDExpectation) Then(sa1 []string, err error) *MinioIMock {
	e.results = &MinioIMockListTextChunksByFileUIDResults{sa1, err}
	return e.mock
}

// Times sets number of times MinioI.ListTextChunksByFileUID should be invoked
func (mmListTextChunksByFileUID *mMinioIMockListTextChunksByFileUID) Times(n uint64) *mMinioIMockListTextChunksByFileUID {
	if n == 0 {
		mmListTextChunksByFileUID.mock.t.Fatalf("Times of MinioIMock.ListTextChunksByFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListTextChunksByFileUID.expectedInvocations, n)
	mmListTextChunksByFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListTextChunksByFileUID
}

func (mmListTextChunksByFileUID *mMinioIMockListTextChunksByFileUID) invocationsDone() bool {
	if len(mmListTextChunksByFileUID.expectations) == 0 && mmListTextChunksByFileUID.defaultExpectation == nil && mmListTextChunksByFileUID.mock.funcListTextChunksByFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListTextChunksByFileUID.mock.afterListTextChunksByFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListTextChunksByFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListTextChunksByFileUID implements mm_minio.MinioI
func (mmListTextChunksByFileUID *MinioIMock) ListTextChunksByFileUID(ctx context.Context, kbUID uuid.UUID, fileUID uuid.UUID) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmListTextChunksByFileUID.beforeListTextChunksByFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmListTextChunksByFileUID.afterListTextChunksByFileUIDCounter, 1)

	mmListTextChunksByFileUID.t.Helper()

	if mmListTextChunksByFileUID.inspectFuncListTextChunksByFileUID != nil {
		mmListTextChunksByFileUID.inspectFuncListTextChunksByFileUID(ctx, kbUID, fileUID)
	}

	mm_params := MinioIMockListTextChunksByFileUIDParams{ctx, kbUID, fileUID}

	// Record call args
	mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.mutex.Lock()
	mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.callArgs = append(mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.callArgs, &mm_params)
	mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.mutex.Unlock()

	for _, e := range mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.defaultExpectation.paramPtrs

		mm_got := MinioIMockListTextChunksByFileUIDParams{ctx, kbUID, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListTextChunksByFileUID.t.Errorf("MinioIMock.ListTextChunksByFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmListTextChunksByFileUID.t.Errorf("MinioIMock.ListTextChunksByFileUID got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmListTextChunksByFileUID.t.Errorf("MinioIMock.ListTextChunksByFileUID got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListTextChunksByFileUID.t.Errorf("MinioIMock.ListTextChunksByFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmListTextChunksByFileUID.t.Fatal("No results are set for the MinioIMock.ListTextChunksByFileUID")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmListTextChunksByFileUID.funcListTextChunksByFileUID != nil {
		return mmListTextChunksByFileUID.funcListTextChunksByFileUID(ctx, kbUID, fileUID)
	}
	mmListTextChunksByFileUID.t.Fatalf("Unexpected call to MinioIMock.ListTextChunksByFileUID. %v %v %v", ctx, kbUID, fileUID)
	return
}

// ListTextChunksByFileUIDAfterCounter returns a count of finished MinioIMock.ListTextChunksByFileUID invocations
func (mmListTextChunksByFileUID *MinioIMock) ListTextChunksByFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTextChunksByFileUID.afterListTextChunksByFileUIDCounter)
}

// ListTextChunksByFileUIDBeforeCounter returns a count of MinioIMock.ListTextChunksByFileUID invocations
func (mmListTextChunksByFileUID *MinioIMock) ListTextChunksByFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTextChunksByFileUID.beforeListTextChunksByFileUIDCounter)
}

// Calls returns a list of arguments used in each call to MinioIMock.ListTextChunksByFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListTextChunksByFileUID *mMinioIMockListTextChunksByFileUID) Calls() []*MinioIMockListTextChunksByFileUIDParams {
	mmListTextChunksByFileUID.mutex.RLock()

	argCopy := make([]*MinioIMockListTextChunksByFileUIDParams, len(mmListTextChunksByFileUID.callArgs))
	copy(argCopy, mmListTextChunksByFileUID.callArgs)

	mmListTextChunksByFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockListTextChunksByFileUIDDone returns true if the count of the ListTextChunksByFileUID invocations corresponds
// the number of defined expectations
func (m *MinioIMock) MinimockListTextChunksByFileUIDDone() bool {
	if m.ListTextChunksByFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListTextChunksByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListTextChunksByFileUIDMock.invocationsDone()
}

// MinimockListTextChunksByFileUIDInspect logs each unmet expectation
func (m *MinioIMock) MinimockListTextChunksByFileUIDInspect() {
	for _, e := range m.ListTextChunksByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinioIMock.ListTextChunksByFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListTextChunksByFileUIDCounter := mm_atomic.LoadUint64(&m.afterListTextChunksByFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListTextChunksByFileUIDMock.defaultExpectation != nil && afterListTextChunksByFileUIDCounter < 1 {
		if m.ListTextChunksByFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MinioIMock.ListTextChunksByFileUID at\n%s", m.ListTextChunksByFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MinioIMock.ListTextChunksByFileUID at\n%s with params: %#v", m.ListTextChunksByFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.ListTextChunksByFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListTextChunksByFileUID != nil && afterListTextChunksByFileUIDCounter < 1 {
		m.t.Errorf("Expected call to MinioIMock.ListTextChunksByFileUID at\n%s", m.funcListTextChunksByFileUIDOrigin)
	}

	if !m.ListTextChunksByFileUIDMock.invocationsDone() && afterListTextChunksByFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to MinioIMock.ListTextChunksByFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListTextChunksByFileUIDMock.expectedInvocations), m.ListTextChunksByFileUIDMock.expectedInvocationsOrigin, afterListTextChunksByFileUIDCounter)
	}
}

type mMinioIMockSaveConvertedFile struct {
	optional           bool
	mock               *MinioIMock
	defaultExpectation *MinioIMockSaveConvertedFileExpectation
	expectations       []*MinioIMockSaveConvertedFileExpectation

	callArgs []*MinioIMockSaveConvertedFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MinioIMockSaveConvertedFileExpectation specifies expectation struct of the MinioI.SaveConvertedFile
type MinioIMockSaveConvertedFileExpectation struct {
	mock               *MinioIMock
	params             *MinioIMockSaveConvertedFileParams
	paramPtrs          *MinioIMockSaveConvertedFileParamPtrs
	expectationOrigins MinioIMockSaveConvertedFileExpectationOrigins
	results            *MinioIMockSaveConvertedFileResults
	returnOrigin       string
	Counter            uint64
}

// MinioIMockSaveConvertedFileParams contains parameters of the MinioI.SaveConvertedFile
type MinioIMockSaveConvertedFileParams struct {
	ctx              context.Context
	kbUID            uuid.UUID
	fileUID          uuid.UUID
	convertedFileUID uuid.UUID
	fileExt          string
	content          []byte
}

// MinioIMockSaveConvertedFileParamPtrs contains pointers to parameters of the MinioI.SaveConvertedFile
type MinioIMockSaveConvertedFileParamPtrs struct {
	ctx              *context.Context
	kbUID            *uuid.UUID
	fileUID          *uuid.UUID
	convertedFileUID *uuid.UUID
	fileExt          *string
	content          *[]byte
}

// MinioIMockSaveConvertedFileResults contains results of the MinioI.SaveConvertedFile
type MinioIMockSaveConvertedFileResults struct {
	path string
	err  error
}

// MinioIMockSaveConvertedFileOrigins contains origins of expectations of the MinioI.SaveConvertedFile
type MinioIMockSaveConvertedFileExpectationOrigins struct {
	origin                 string
	originCtx              string
	originKbUID            string
	originFileUID          string
	originConvertedFileUID string
	originFileExt          string
	originContent          string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSaveConvertedFile *mMinioIMockSaveConvertedFile) Optional() *mMinioIMockSaveConvertedFile {
	mmSaveConvertedFile.optional = true
	return mmSaveConvertedFile
}

// Expect sets up expected params for MinioI.SaveConvertedFile
func (mmSaveConvertedFile *mMinioIMockSaveConvertedFile) Expect(ctx context.Context, kbUID uuid.UUID, fileUID uuid.UUID, convertedFileUID uuid.UUID, fileExt string, content []byte) *mMinioIMockSaveConvertedFile {
	if mmSaveConvertedFile.mock.funcSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("MinioIMock.SaveConvertedFile mock is already set by Set")
	}

	if mmSaveConvertedFile.defaultExpectation == nil {
		mmSaveConvertedFile.defaultExpectation = &MinioIMockSaveConvertedFileExpectation{}
	}

	if mmSaveConvertedFile.defaultExpectation.paramPtrs != nil {
		mmSaveConvertedFile.mock.t.Fatalf("MinioIMock.SaveConvertedFile mock is already set by ExpectParams functions")
	}

	mmSaveConvertedFile.defaultExpectation.params = &MinioIMockSaveConvertedFileParams{ctx, kbUID, fileUID, convertedFileUID, fileExt, content}
	mmSaveConvertedFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSaveConvertedFile.expectations {
		if minimock.Equal(e.params, mmSaveConvertedFile.defaultExpectation.params) {
			mmSaveConvertedFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveConvertedFile.defaultExpectation.params)
		}
	}

	return mmSaveConvertedFile
}

// ExpectCtxParam1 sets up expected param ctx for MinioI.SaveConvertedFile
func (mmSaveConvertedFile *mMinioIMockSaveConvertedFile) ExpectCtxParam1(ctx context.Context) *mMinioIMockSaveConvertedFile {
	if mmSaveConvertedFile.mock.funcSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("MinioIMock.SaveConvertedFile mock is already set by Set")
	}

	if mmSaveConvertedFile.defaultExpectation == nil {
		mmSaveConvertedFile.defaultExpectation = &MinioIMockSaveConvertedFileExpectation{}
	}

	if mmSaveConvertedFile.defaultExpectation.params != nil {
		mmSaveConvertedFile.mock.t.Fatalf("MinioIMock.SaveConvertedFile mock is already set by Expect")
	}

	if mmSaveConvertedFile.defaultExpectation.paramPtrs == nil {
		mmSaveConvertedFile.defaultExpectation.paramPtrs = &MinioIMockSaveConvertedFileParamPtrs{}
	}
	mmSaveConvertedFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmSaveConvertedFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSaveConvertedFile
}

// ExpectKbUIDParam2 sets up expected param kbUID for MinioI.SaveConvertedFile
func (mmSaveConvertedFile *mMinioIMockSaveConvertedFile) ExpectKbUIDParam2(kbUID uuid.UUID) *mMinioIMockSaveConvertedFile {
	if mmSaveConvertedFile.mock.funcSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("MinioIMock.SaveConvertedFile mock is already set by Set")
	}

	if mmSaveConvertedFile.defaultExpectation == nil {
		mmSaveConvertedFile.defaultExpectation = &MinioIMockSaveConvertedFileExpectation{}
	}

	if mmSaveConvertedFile.defaultExpectation.params != nil {
		mmSaveConvertedFile.mock.t.Fatalf("MinioIMock.SaveConvertedFile mock is already set by Expect")
	}

	if mmSaveConvertedFile.defaultExpectation.paramPtrs == nil {
		mmSaveConvertedFile.defaultExpectation.paramPtrs = &MinioIMockSaveConvertedFileParamPtrs{}
	}
	mmSaveConvertedFile.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmSaveConvertedFile.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmSaveConvertedFile
}

// ExpectFileUIDParam3 sets up expected param fileUID for MinioI.SaveConvertedFile
func (mmSaveConvertedFile *mMinioIMockSaveConvertedFile) ExpectFileUIDParam3(fileUID uuid.UUID) *mMinioIMockSaveConvertedFile {
	if mmSaveConvertedFile.mock.funcSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("MinioIMock.SaveConvertedFile mock is already set by Set")
	}

	if mmSaveConvertedFile.defaultExpectation == nil {
		mmSaveConvertedFile.defaultExpectation = &MinioIMockSaveConvertedFileExpectation{}
	}

	if mmSaveConvertedFile.defaultExpectation.params != nil {
		mmSaveConvertedFile.mock.t.Fatalf("MinioIMock.SaveConvertedFile mock is already set by Expect")
	}

	if mmSaveConvertedFile.defaultExpectation.paramPtrs == nil {
		mmSaveConvertedFile.defaultExpectation.paramPtrs = &MinioIMockSaveConvertedFileParamPtrs{}
	}
	mmSaveConvertedFile.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmSaveConvertedFile.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmSaveConvertedFile
}

// ExpectConvertedFileUIDParam4 sets up expected param convertedFileUID for MinioI.SaveConvertedFile
func (mmSaveConvertedFile *mMinioIMockSaveConvertedFile) ExpectConvertedFileUIDParam4(convertedFileUID uuid.UUID) *mMinioIMockSaveConvertedFile {
	if mmSaveConvertedFile.mock.funcSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("MinioIMock.SaveConvertedFile mock is already set by Set")
	}

	if mmSaveConvertedFile.defaultExpectation == nil {
		mmSaveConvertedFile.defaultExpectation = &MinioIMockSaveConvertedFileExpectation{}
	}

	if mmSaveConvertedFile.defaultExpectation.params != nil {
		mmSaveConvertedFile.mock.t.Fatalf("MinioIMock.SaveConvertedFile mock is already set by Expect")
	}

	if mmSaveConvertedFile.defaultExpectation.paramPtrs == nil {
		mmSaveConvertedFile.defaultExpectation.paramPtrs = &MinioIMockSaveConvertedFileParamPtrs{}
	}
	mmSaveConvertedFile.defaultExpectation.paramPtrs.convertedFileUID = &convertedFileUID
	mmSaveConvertedFile.defaultExpectation.expectationOrigins.originConvertedFileUID = minimock.CallerInfo(1)

	return mmSaveConvertedFile
}

// ExpectFileExtParam5 sets up expected param fileExt for MinioI.SaveConvertedFile
func (mmSaveConvertedFile *mMinioIMockSaveConvertedFile) ExpectFileExtParam5(fileExt string) *mMinioIMockSaveConvertedFile {
	if mmSaveConvertedFile.mock.funcSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("MinioIMock.SaveConvertedFile mock is already set by Set")
	}

	if mmSaveConvertedFile.defaultExpectation == nil {
		mmSaveConvertedFile.defaultExpectation = &MinioIMockSaveConvertedFileExpectation{}
	}

	if mmSaveConvertedFile.defaultExpectation.params != nil {
		mmSaveConvertedFile.mock.t.Fatalf("MinioIMock.SaveConvertedFile mock is already set by Expect")
	}

	if mmSaveConvertedFile.defaultExpectation.paramPtrs == nil {
		mmSaveConvertedFile.defaultExpectation.paramPtrs = &MinioIMockSaveConvertedFileParamPtrs{}
	}
	mmSaveConvertedFile.defaultExpectation.paramPtrs.fileExt = &fileExt
	mmSaveConvertedFile.defaultExpectation.expectationOrigins.originFileExt = minimock.CallerInfo(1)

	return mmSaveConvertedFile
}

// ExpectContentParam6 sets up expected param content for MinioI.SaveConvertedFile
func (mmSaveConvertedFile *mMinioIMockSaveConvertedFile) ExpectContentParam6(content []byte) *mMinioIMockSaveConvertedFile {
	if mmSaveConvertedFile.mock.funcSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("MinioIMock.SaveConvertedFile mock is already set by Set")
	}

	if mmSaveConvertedFile.defaultExpectation == nil {
		mmSaveConvertedFile.defaultExpectation = &MinioIMockSaveConvertedFileExpectation{}
	}

	if mmSaveConvertedFile.defaultExpectation.params != nil {
		mmSaveConvertedFile.mock.t.Fatalf("MinioIMock.SaveConvertedFile mock is already set by Expect")
	}

	if mmSaveConvertedFile.defaultExpectation.paramPtrs == nil {
		mmSaveConvertedFile.defaultExpectation.paramPtrs = &MinioIMockSaveConvertedFileParamPtrs{}
	}
	mmSaveConvertedFile.defaultExpectation.paramPtrs.content = &content
	mmSaveConvertedFile.defaultExpectation.expectationOrigins.originContent = minimock.CallerInfo(1)

	return mmSaveConvertedFile
}

// Inspect accepts an inspector function that has same arguments as the MinioI.SaveConvertedFile
func (mmSaveConvertedFile *mMinioIMockSaveConvertedFile) Inspect(f func(ctx context.Context, kbUID uuid.UUID, fileUID uuid.UUID, convertedFileUID uuid.UUID, fileExt string, content []byte)) *mMinioIMockSaveConvertedFile {
	if mmSaveConvertedFile.mock.inspectFuncSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("Inspect function is already set for MinioIMock.SaveConvertedFile")
	}

	mmSaveConvertedFile.mock.inspectFuncSaveConvertedFile = f

	return mmSaveConvertedFile
}

// Return sets up results that will be returned by MinioI.SaveConvertedFile
func (mmSaveConvertedFile *mMinioIMockSaveConvertedFile) Return(path string, err error) *MinioIMock {
	if mmSaveConvertedFile.mock.funcSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("MinioIMock.SaveConvertedFile mock is already set by Set")
	}

	if mmSaveConvertedFile.defaultExpectation == nil {
		mmSaveConvertedFile.defaultExpectation = &MinioIMockSaveConvertedFileExpectation{mock: mmSaveConvertedFile.mock}
	}
	mmSaveConvertedFile.defaultExpectation.results = &MinioIMockSaveConvertedFileResults{path, err}
	mmSaveConvertedFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSaveConvertedFile.mock
}

// Set uses given function f to mock the MinioI.SaveConvertedFile method
func (mmSaveConvertedFile *mMinioIMockSaveConvertedFile) Set(f func(ctx context.Context, kbUID uuid.UUID, fileUID uuid.UUID, convertedFileUID uuid.UUID, fileExt string, content []byte) (path string, err error)) *MinioIMock {
	if mmSaveConvertedFile.defaultExpectation != nil {
		mmSaveConvertedFile.mock.t.Fatalf("Default expectation is already set for the MinioI.SaveConvertedFile method")
	}

	if len(mmSaveConvertedFile.expectations) > 0 {
		mmSaveConvertedFile.mock.t.Fatalf("Some expectations are already set for the MinioI.SaveConvertedFile method")
	}

	mmSaveConvertedFile.mock.funcSaveConvertedFile = f
	mmSaveConvertedFile.mock.funcSaveConvertedFileOrigin = minimock.CallerInfo(1)
	return mmSaveConvertedFile.mock
}

// When sets expectation for the MinioI.SaveConvertedFile which will trigger the result defined by the following
// Then helper
func (mmSaveConvertedFile *mMinioIMockSaveConvertedFile) When(ctx context.Context, kbUID uuid.UUID, fileUID uuid.UUID, convertedFileUID uuid.UUID, fileExt string, content []byte) *MinioIMockSaveConvertedFileExpectation {
	if mmSaveConvertedFile.mock.funcSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("MinioIMock.SaveConvertedFile mock is already set by Set")
	}

	expectation := &MinioIMockSaveConvertedFileExpectation{
		mock:               mmSaveConvertedFile.mock,
		params:             &MinioIMockSaveConvertedFileParams{ctx, kbUID, fileUID, convertedFileUID, fileExt, content},
		expectationOrigins: MinioIMockSaveConvertedFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSaveConvertedFile.expectations = append(mmSaveConvertedFile.expectations, expectation)
	return expectation
}

// Then sets up MinioI.SaveConvertedFile return parameters for the expectation previously defined by the When method
func (e *MinioIMockSaveConvertedFileExpectation) Then(path string, err error) *MinioIMock {
	e.results = &MinioIMockSaveConvertedFileResults{path, err}
	return e.mock
}

// Times sets number of times MinioI.SaveConvertedFile should be invoked
func (mmSaveConvertedFile *mMinioIMockSaveConvertedFile) Times(n uint64) *mMinioIMockSaveConvertedFile {
	if n == 0 {
		mmSaveConvertedFile.mock.t.Fatalf("Times of MinioIMock.SaveConvertedFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSaveConvertedFile.expectedInvocations, n)
	mmSaveConvertedFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSaveConvertedFile
}

func (mmSaveConvertedFile *mMinioIMockSaveConvertedFile) invocationsDone() bool {
	if len(mmSaveConvertedFile.expectations) == 0 && mmSaveConvertedFile.defaultExpectation == nil && mmSaveConvertedFile.mock.funcSaveConvertedFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSaveConvertedFile.mock.afterSaveConvertedFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSaveConvertedFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SaveConvertedFile implements mm_minio.MinioI
func (mmSaveConvertedFile *MinioIMock) SaveConvertedFile(ctx context.Context, kbUID uuid.UUID, fileUID uuid.UUID, convertedFileUID uuid.UUID, fileExt string, content []byte) (path string, err error) {
	mm_atomic.AddUint64(&mmSaveConvertedFile.beforeSaveConvertedFileCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveConvertedFile.afterSaveConvertedFileCounter, 1)

	mmSaveConvertedFile.t.Helper()

	if mmSaveConvertedFile.inspectFuncSaveConvertedFile != nil {
		mmSaveConvertedFile.inspectFuncSaveConvertedFile(ctx, kbUID, fileUID, convertedFileUID, fileExt, content)
	}

	mm_params := MinioIMockSaveConvertedFileParams{ctx, kbUID, fileUID, convertedFileUID, fileExt, content}

	// Record call args
	mmSaveConvertedFile.SaveConvertedFileMock.mutex.Lock()
	mmSaveConvertedFile.SaveConvertedFileMock.callArgs = append(mmSaveConvertedFile.SaveConvertedFileMock.callArgs, &mm_params)
	mmSaveConvertedFile.SaveConvertedFileMock.mutex.Unlock()

	for _, e := range mmSaveConvertedFile.SaveConvertedFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.path, e.results.err
		}
	}

	if mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.params
		mm_want_ptrs := mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.paramPtrs

		mm_got := MinioIMockSaveConvertedFileParams{ctx, kbUID, fileUID, convertedFileUID, fileExt, content}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSaveConvertedFile.t.Errorf("MinioIMock.SaveConvertedFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmSaveConvertedFile.t.Errorf("MinioIMock.SaveConvertedFile got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmSaveConvertedFile.t.Errorf("MinioIMock.SaveConvertedFile got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

			if mm_want_ptrs.convertedFileUID != nil && !minimock.Equal(*mm_want_ptrs.convertedFileUID, mm_got.convertedFileUID) {
				mmSaveConvertedFile.t.Errorf("MinioIMock.SaveConvertedFile got unexpected parameter convertedFileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.expectationOrigins.originConvertedFileUID, *mm_want_ptrs.convertedFileUID, mm_got.convertedFileUID, minimock.Diff(*mm_want_ptrs.convertedFileUID, mm_got.convertedFileUID))
			}

			if mm_want_ptrs.fileExt != nil && !minimock.Equal(*mm_want_ptrs.fileExt, mm_got.fileExt) {
				mmSaveConvertedFile.t.Errorf("MinioIMock.SaveConvertedFile got unexpected parameter fileExt, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.expectationOrigins.originFileExt, *mm_want_ptrs.fileExt, mm_got.fileExt, minimock.Diff(*mm_want_ptrs.fileExt, mm_got.fileExt))
			}

			if mm_want_ptrs.content != nil && !minimock.Equal(*mm_want_ptrs.content, mm_got.content) {
				mmSaveConvertedFile.t.Errorf("MinioIMock.SaveConvertedFile got unexpected parameter content, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.expectationOrigins.originContent, *mm_want_ptrs.content, mm_got.content, minimock.Diff(*mm_want_ptrs.content, mm_got.content))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveConvertedFile.t.Errorf("MinioIMock.SaveConvertedFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveConvertedFile.t.Fatal("No results are set for the MinioIMock.SaveConvertedFile")
		}
		return (*mm_results).path, (*mm_results).err
	}
	if mmSaveConvertedFile.funcSaveConvertedFile != nil {
		return mmSaveConvertedFile.funcSaveConvertedFile(ctx, kbUID, fileUID, convertedFileUID, fileExt, content)
	}
	mmSaveConvertedFile.t.Fatalf("Unexpected call to MinioIMock.SaveConvertedFile. %v %v %v %v %v %v", ctx, kbUID, fileUID, convertedFileUID, fileExt, content)
	return
}

// SaveConvertedFileAfterCounter returns a count of finished MinioIMock.SaveConvertedFile invocations
func (mmSaveConvertedFile *MinioIMock) SaveConvertedFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveConvertedFile.afterSaveConvertedFileCounter)
}

// SaveConvertedFileBeforeCounter returns a count of MinioIMock.SaveConvertedFile invocations
func (mmSaveConvertedFile *MinioIMock) SaveConvertedFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveConvertedFile.beforeSaveConvertedFileCounter)
}

// Calls returns a list of arguments used in each call to MinioIMock.SaveConvertedFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveConvertedFile *mMinioIMockSaveConvertedFile) Calls() []*MinioIMockSaveConvertedFileParams {
	mmSaveConvertedFile.mutex.RLock()

	argCopy := make([]*MinioIMockSaveConvertedFileParams, len(mmSaveConvertedFile.callArgs))
	copy(argCopy, mmSaveConvertedFile.callArgs)

	mmSaveConvertedFile.mutex.RUnlock()

	return argCopy
}

// MinimockSaveConvertedFileDone returns true if the count of the SaveConvertedFile invocations corresponds
// the number of defined expectations
func (m *MinioIMock) MinimockSaveConvertedFileDone() bool {
	if m.SaveConvertedFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SaveConvertedFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SaveConvertedFileMock.invocationsDone()
}

// MinimockSaveConvertedFileInspect logs each unmet expectation
func (m *MinioIMock) MinimockSaveConvertedFileInspect() {
	for _, e := range m.SaveConvertedFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinioIMock.SaveConvertedFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSaveConvertedFileCounter := mm_atomic.LoadUint64(&m.afterSaveConvertedFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SaveConvertedFileMock.defaultExpectation != nil && afterSaveConvertedFileCounter < 1 {
		if m.SaveConvertedFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MinioIMock.SaveConvertedFile at\n%s", m.SaveConvertedFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MinioIMock.SaveConvertedFile at\n%s with params: %#v", m.SaveConvertedFileMock.defaultExpectation.expectationOrigins.origin, *m.SaveConvertedFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveConvertedFile != nil && afterSaveConvertedFileCounter < 1 {
		m.t.Errorf("Expected call to MinioIMock.SaveConvertedFile at\n%s", m.funcSaveConvertedFileOrigin)
	}

	if !m.SaveConvertedFileMock.invocationsDone() && afterSaveConvertedFileCounter > 0 {
		m.t.Errorf("Expected %d calls to MinioIMock.SaveConvertedFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SaveConvertedFileMock.expectedInvocations), m.SaveConvertedFileMock.expectedInvocationsOrigin, afterSaveConvertedFileCounter)
	}
}

type mMinioIMockUploadBase64File struct {
	optional           bool
	mock               *MinioIMock
	defaultExpectation *MinioIMockUploadBase64FileExpectation
	expectations       []*MinioIMockUploadBase64FileExpectation

	callArgs []*MinioIMockUploadBase64FileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MinioIMockUploadBase64FileExpectation specifies expectation struct of the MinioI.UploadBase64File
type MinioIMockUploadBase64FileExpectation struct {
	mock               *MinioIMock
	params             *MinioIMockUploadBase64FileParams
	paramPtrs          *MinioIMockUploadBase64FileParamPtrs
	expectationOrigins MinioIMockUploadBase64FileExpectationOrigins
	results            *MinioIMockUploadBase64FileResults
	returnOrigin       string
	Counter            uint64
}

// MinioIMockUploadBase64FileParams contains parameters of the MinioI.UploadBase64File
type MinioIMockUploadBase64FileParams struct {
	ctx           context.Context
	bucket        string
	filePath      string
	base64Content string
	fileMimeType  string
}

// MinioIMockUploadBase64FileParamPtrs contains pointers to parameters of the MinioI.UploadBase64File
type MinioIMockUploadBase64FileParamPtrs struct {
	ctx           *context.Context
	bucket        *string
	filePath      *string
	base64Content *string
	fileMimeType  *string
}

// MinioIMockUploadBase64FileResults contains results of the MinioI.UploadBase64File
type MinioIMockUploadBase64FileResults struct {
	err error
}

// MinioIMockUploadBase64FileOrigins contains origins of expectations of the MinioI.UploadBase64File
type MinioIMockUploadBase64FileExpectationOrigins struct {
	origin              string
	originCtx           string
	originBucket        string
	originFilePath      string
	originBase64Content string
	originFileMimeType  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUploadBase64File *mMinioIMockUploadBase64File) Optional() *mMinioIMockUploadBase64File {
	mmUploadBase64File.optional = true
	return mmUploadBase64File
}

// Expect sets up expected params for MinioI.UploadBase64File
func (mmUploadBase64File *mMinioIMockUploadBase64File) Expect(ctx context.Context, bucket string, filePath string, base64Content string, fileMimeType string) *mMinioIMockUploadBase64File {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("MinioIMock.UploadBase64File mock is already set by Set")
	}

	if mmUploadBase64File.defaultExpectation == nil {
		mmUploadBase64File.defaultExpectation = &MinioIMockUploadBase64FileExpectation{}
	}

	if mmUploadBase64File.defaultExpectation.paramPtrs != nil {
		mmUploadBase64File.mock.t.Fatalf("MinioIMock.UploadBase64File mock is already set by ExpectParams functions")
	}

	mmUploadBase64File.defaultExpectation.params = &MinioIMockUploadBase64FileParams{ctx, bucket, filePath, base64Content, fileMimeType}
	mmUploadBase64File.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUploadBase64File.expectations {
		if minimock.Equal(e.params, mmUploadBase64File.defaultExpectation.params) {
			mmUploadBase64File.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUploadBase64File.defaultExpectation.params)
		}
	}

	return mmUploadBase64File
}

// ExpectCtxParam1 sets up expected param ctx for MinioI.UploadBase64File
func (mmUploadBase64File *mMinioIMockUploadBase64File) ExpectCtxParam1(ctx context.Context) *mMinioIMockUploadBase64File {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("MinioIMock.UploadBase64File mock is already set by Set")
	}

	if mmUploadBase64File.defaultExpectation == nil {
		mmUploadBase64File.defaultExpectation = &MinioIMockUploadBase64FileExpectation{}
	}

	if mmUploadBase64File.defaultExpectation.params != nil {
		mmUploadBase64File.mock.t.Fatalf("MinioIMock.UploadBase64File mock is already set by Expect")
	}

	if mmUploadBase64File.defaultExpectation.paramPtrs == nil {
		mmUploadBase64File.defaultExpectation.paramPtrs = &MinioIMockUploadBase64FileParamPtrs{}
	}
	mmUploadBase64File.defaultExpectation.paramPtrs.ctx = &ctx
	mmUploadBase64File.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUploadBase64File
}

// ExpectBucketParam2 sets up expected param bucket for MinioI.UploadBase64File
func (mmUploadBase64File *mMinioIMockUploadBase64File) ExpectBucketParam2(bucket string) *mMinioIMockUploadBase64File {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("MinioIMock.UploadBase64File mock is already set by Set")
	}

	if mmUploadBase64File.defaultExpectation == nil {
		mmUploadBase64File.defaultExpectation = &MinioIMockUploadBase64FileExpectation{}
	}

	if mmUploadBase64File.defaultExpectation.params != nil {
		mmUploadBase64File.mock.t.Fatalf("MinioIMock.UploadBase64File mock is already set by Expect")
	}

	if mmUploadBase64File.defaultExpectation.paramPtrs == nil {
		mmUploadBase64File.defaultExpectation.paramPtrs = &MinioIMockUploadBase64FileParamPtrs{}
	}
	mmUploadBase64File.defaultExpectation.paramPtrs.bucket = &bucket
	mmUploadBase64File.defaultExpectation.expectationOrigins.originBucket = minimock.CallerInfo(1)

	return mmUploadBase64File
}

// ExpectFilePathParam3 sets up expected param filePath for MinioI.UploadBase64File
func (mmUploadBase64File *mMinioIMockUploadBase64File) ExpectFilePathParam3(filePath string) *mMinioIMockUploadBase64File {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("MinioIMock.UploadBase64File mock is already set by Set")
	}

	if mmUploadBase64File.defaultExpectation == nil {
		mmUploadBase64File.defaultExpectation = &MinioIMockUploadBase64FileExpectation{}
	}

	if mmUploadBase64File.defaultExpectation.params != nil {
		mmUploadBase64File.mock.t.Fatalf("MinioIMock.UploadBase64File mock is already set by Expect")
	}

	if mmUploadBase64File.defaultExpectation.paramPtrs == nil {
		mmUploadBase64File.defaultExpectation.paramPtrs = &MinioIMockUploadBase64FileParamPtrs{}
	}
	mmUploadBase64File.defaultExpectation.paramPtrs.filePath = &filePath
	mmUploadBase64File.defaultExpectation.expectationOrigins.originFilePath = minimock.CallerInfo(1)

	return mmUploadBase64File
}

// ExpectBase64ContentParam4 sets up expected param base64Content for MinioI.UploadBase64File
func (mmUploadBase64File *mMinioIMockUploadBase64File) ExpectBase64ContentParam4(base64Content string) *mMinioIMockUploadBase64File {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("MinioIMock.UploadBase64File mock is already set by Set")
	}

	if mmUploadBase64File.defaultExpectation == nil {
		mmUploadBase64File.defaultExpectation = &MinioIMockUploadBase64FileExpectation{}
	}

	if mmUploadBase64File.defaultExpectation.params != nil {
		mmUploadBase64File.mock.t.Fatalf("MinioIMock.UploadBase64File mock is already set by Expect")
	}

	if mmUploadBase64File.defaultExpectation.paramPtrs == nil {
		mmUploadBase64File.defaultExpectation.paramPtrs = &MinioIMockUploadBase64FileParamPtrs{}
	}
	mmUploadBase64File.defaultExpectation.paramPtrs.base64Content = &base64Content
	mmUploadBase64File.defaultExpectation.expectationOrigins.originBase64Content = minimock.CallerInfo(1)

	return mmUploadBase64File
}

// ExpectFileMimeTypeParam5 sets up expected param fileMimeType for MinioI.UploadBase64File
func (mmUploadBase64File *mMinioIMockUploadBase64File) ExpectFileMimeTypeParam5(fileMimeType string) *mMinioIMockUploadBase64File {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("MinioIMock.UploadBase64File mock is already set by Set")
	}

	if mmUploadBase64File.defaultExpectation == nil {
		mmUploadBase64File.defaultExpectation = &MinioIMockUploadBase64FileExpectation{}
	}

	if mmUploadBase64File.defaultExpectation.params != nil {
		mmUploadBase64File.mock.t.Fatalf("MinioIMock.UploadBase64File mock is already set by Expect")
	}

	if mmUploadBase64File.defaultExpectation.paramPtrs == nil {
		mmUploadBase64File.defaultExpectation.paramPtrs = &MinioIMockUploadBase64FileParamPtrs{}
	}
	mmUploadBase64File.defaultExpectation.paramPtrs.fileMimeType = &fileMimeType
	mmUploadBase64File.defaultExpectation.expectationOrigins.originFileMimeType = minimock.CallerInfo(1)

	return mmUploadBase64File
}

// Inspect accepts an inspector function that has same arguments as the MinioI.UploadBase64File
func (mmUploadBase64File *mMinioIMockUploadBase64File) Inspect(f func(ctx context.Context, bucket string, filePath string, base64Content string, fileMimeType string)) *mMinioIMockUploadBase64File {
	if mmUploadBase64File.mock.inspectFuncUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("Inspect function is already set for MinioIMock.UploadBase64File")
	}

	mmUploadBase64File.mock.inspectFuncUploadBase64File = f

	return mmUploadBase64File
}

// Return sets up results that will be returned by MinioI.UploadBase64File
func (mmUploadBase64File *mMinioIMockUploadBase64File) Return(err error) *MinioIMock {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("MinioIMock.UploadBase64File mock is already set by Set")
	}

	if mmUploadBase64File.defaultExpectation == nil {
		mmUploadBase64File.defaultExpectation = &MinioIMockUploadBase64FileExpectation{mock: mmUploadBase64File.mock}
	}
	mmUploadBase64File.defaultExpectation.results = &MinioIMockUploadBase64FileResults{err}
	mmUploadBase64File.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUploadBase64File.mock
}

// Set uses given function f to mock the MinioI.UploadBase64File method
func (mmUploadBase64File *mMinioIMockUploadBase64File) Set(f func(ctx context.Context, bucket string, filePath string, base64Content string, fileMimeType string) (err error)) *MinioIMock {
	if mmUploadBase64File.defaultExpectation != nil {
		mmUploadBase64File.mock.t.Fatalf("Default expectation is already set for the MinioI.UploadBase64File method")
	}

	if len(mmUploadBase64File.expectations) > 0 {
		mmUploadBase64File.mock.t.Fatalf("Some expectations are already set for the MinioI.UploadBase64File method")
	}

	mmUploadBase64File.mock.funcUploadBase64File = f
	mmUploadBase64File.mock.funcUploadBase64FileOrigin = minimock.CallerInfo(1)
	return mmUploadBase64File.mock
}

// When sets expectation for the MinioI.UploadBase64File which will trigger the result defined by the following
// Then helper
func (mmUploadBase64File *mMinioIMockUploadBase64File) When(ctx context.Context, bucket string, filePath string, base64Content string, fileMimeType string) *MinioIMockUploadBase64FileExpectation {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("MinioIMock.UploadBase64File mock is already set by Set")
	}

	expectation := &MinioIMockUploadBase64FileExpectation{
		mock:               mmUploadBase64File.mock,
		params:             &MinioIMockUploadBase64FileParams{ctx, bucket, filePath, base64Content, fileMimeType},
		expectationOrigins: MinioIMockUploadBase64FileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUploadBase64File.expectations = append(mmUploadBase64File.expectations, expectation)
	return expectation
}

// Then sets up MinioI.UploadBase64File return parameters for the expectation previously defined by the When method
func (e *MinioIMockUploadBase64FileExpectation) Then(err error) *MinioIMock {
	e.results = &MinioIMockUploadBase64FileResults{err}
	return e.mock
}

// Times sets number of times MinioI.UploadBase64File should be invoked
func (mmUploadBase64File *mMinioIMockUploadBase64File) Times(n uint64) *mMinioIMockUploadBase64File {
	if n == 0 {
		mmUploadBase64File.mock.t.Fatalf("Times of MinioIMock.UploadBase64File mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUploadBase64File.expectedInvocations, n)
	mmUploadBase64File.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUploadBase64File
}

func (mmUploadBase64File *mMinioIMockUploadBase64File) invocationsDone() bool {
	if len(mmUploadBase64File.expectations) == 0 && mmUploadBase64File.defaultExpectation == nil && mmUploadBase64File.mock.funcUploadBase64File == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUploadBase64File.mock.afterUploadBase64FileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUploadBase64File.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UploadBase64File implements mm_minio.MinioI
func (mmUploadBase64File *MinioIMock) UploadBase64File(ctx context.Context, bucket string, filePath string, base64Content string, fileMimeType string) (err error) {
	mm_atomic.AddUint64(&mmUploadBase64File.beforeUploadBase64FileCounter, 1)
	defer mm_atomic.AddUint64(&mmUploadBase64File.afterUploadBase64FileCounter, 1)

	mmUploadBase64File.t.Helper()

	if mmUploadBase64File.inspectFuncUploadBase64File != nil {
		mmUploadBase64File.inspectFuncUploadBase64File(ctx, bucket, filePath, base64Content, fileMimeType)
	}

	mm_params := MinioIMockUploadBase64FileParams{ctx, bucket, filePath, base64Content, fileMimeType}

	// Record call args
	mmUploadBase64File.UploadBase64FileMock.mutex.Lock()
	mmUploadBase64File.UploadBase64FileMock.callArgs = append(mmUploadBase64File.UploadBase64FileMock.callArgs, &mm_params)
	mmUploadBase64File.UploadBase64FileMock.mutex.Unlock()

	for _, e := range mmUploadBase64File.UploadBase64FileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUploadBase64File.UploadBase64FileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUploadBase64File.UploadBase64FileMock.defaultExpectation.Counter, 1)
		mm_want := mmUploadBase64File.UploadBase64FileMock.defaultExpectation.params
		mm_want_ptrs := mmUploadBase64File.UploadBase64FileMock.defaultExpectation.paramPtrs

		mm_got := MinioIMockUploadBase64FileParams{ctx, bucket, filePath, base64Content, fileMimeType}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUploadBase64File.t.Errorf("MinioIMock.UploadBase64File got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadBase64File.UploadBase64FileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.bucket != nil && !minimock.Equal(*mm_want_ptrs.bucket, mm_got.bucket) {
				mmUploadBase64File.t.Errorf("MinioIMock.UploadBase64File got unexpected parameter bucket, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadBase64File.UploadBase64FileMock.defaultExpectation.expectationOrigins.originBucket, *mm_want_ptrs.bucket, mm_got.bucket, minimock.Diff(*mm_want_ptrs.bucket, mm_got.bucket))
			}

			if mm_want_ptrs.filePath != nil && !minimock.Equal(*mm_want_ptrs.filePath, mm_got.filePath) {
				mmUploadBase64File.t.Errorf("MinioIMock.UploadBase64File got unexpected parameter filePath, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadBase64File.UploadBase64FileMock.defaultExpectation.expectationOrigins.originFilePath, *mm_want_ptrs.filePath, mm_got.filePath, minimock.Diff(*mm_want_ptrs.filePath, mm_got.filePath))
			}

			if mm_want_ptrs.base64Content != nil && !minimock.Equal(*mm_want_ptrs.base64Content, mm_got.base64Content) {
				mmUploadBase64File.t.Errorf("MinioIMock.UploadBase64File got unexpected parameter base64Content, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadBase64File.UploadBase64FileMock.defaultExpectation.expectationOrigins.originBase64Content, *mm_want_ptrs.base64Content, mm_got.base64Content, minimock.Diff(*mm_want_ptrs.base64Content, mm_got.base64Content))
			}

			if mm_want_ptrs.fileMimeType != nil && !minimock.Equal(*mm_want_ptrs.fileMimeType, mm_got.fileMimeType) {
				mmUploadBase64File.t.Errorf("MinioIMock.UploadBase64File got unexpected parameter fileMimeType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadBase64File.UploadBase64FileMock.defaultExpectation.expectationOrigins.originFileMimeType, *mm_want_ptrs.fileMimeType, mm_got.fileMimeType, minimock.Diff(*mm_want_ptrs.fileMimeType, mm_got.fileMimeType))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUploadBase64File.t.Errorf("MinioIMock.UploadBase64File got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUploadBase64File.UploadBase64FileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUploadBase64File.UploadBase64FileMock.defaultExpectation.results
		if mm_results == nil {
			mmUploadBase64File.t.Fatal("No results are set for the MinioIMock.UploadBase64File")
		}
		return (*mm_results).err
	}
	if mmUploadBase64File.funcUploadBase64File != nil {
		return mmUploadBase64File.funcUploadBase64File(ctx, bucket, filePath, base64Content, fileMimeType)
	}
	mmUploadBase64File.t.Fatalf("Unexpected call to MinioIMock.UploadBase64File. %v %v %v %v %v", ctx, bucket, filePath, base64Content, fileMimeType)
	return
}

// UploadBase64FileAfterCounter returns a count of finished MinioIMock.UploadBase64File invocations
func (mmUploadBase64File *MinioIMock) UploadBase64FileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadBase64File.afterUploadBase64FileCounter)
}

// UploadBase64FileBeforeCounter returns a count of MinioIMock.UploadBase64File invocations
func (mmUploadBase64File *MinioIMock) UploadBase64FileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadBase64File.beforeUploadBase64FileCounter)
}

// Calls returns a list of arguments used in each call to MinioIMock.UploadBase64File.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUploadBase64File *mMinioIMockUploadBase64File) Calls() []*MinioIMockUploadBase64FileParams {
	mmUploadBase64File.mutex.RLock()

	argCopy := make([]*MinioIMockUploadBase64FileParams, len(mmUploadBase64File.callArgs))
	copy(argCopy, mmUploadBase64File.callArgs)

	mmUploadBase64File.mutex.RUnlock()

	return argCopy
}

// MinimockUploadBase64FileDone returns true if the count of the UploadBase64File invocations corresponds
// the number of defined expectations
func (m *MinioIMock) MinimockUploadBase64FileDone() bool {
	if m.UploadBase64FileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UploadBase64FileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UploadBase64FileMock.invocationsDone()
}

// MinimockUploadBase64FileInspect logs each unmet expectation
func (m *MinioIMock) MinimockUploadBase64FileInspect() {
	for _, e := range m.UploadBase64FileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinioIMock.UploadBase64File at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUploadBase64FileCounter := mm_atomic.LoadUint64(&m.afterUploadBase64FileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UploadBase64FileMock.defaultExpectation != nil && afterUploadBase64FileCounter < 1 {
		if m.UploadBase64FileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MinioIMock.UploadBase64File at\n%s", m.UploadBase64FileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MinioIMock.UploadBase64File at\n%s with params: %#v", m.UploadBase64FileMock.defaultExpectation.expectationOrigins.origin, *m.UploadBase64FileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUploadBase64File != nil && afterUploadBase64FileCounter < 1 {
		m.t.Errorf("Expected call to MinioIMock.UploadBase64File at\n%s", m.funcUploadBase64FileOrigin)
	}

	if !m.UploadBase64FileMock.invocationsDone() && afterUploadBase64FileCounter > 0 {
		m.t.Errorf("Expected %d calls to MinioIMock.UploadBase64File at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UploadBase64FileMock.expectedInvocations), m.UploadBase64FileMock.expectedInvocationsOrigin, afterUploadBase64FileCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MinioIMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDeleteFileInspect()

			m.MinimockGetFileInspect()

			m.MinimockGetFileMetadataInspect()

			m.MinimockGetPresignedURLForDownloadInspect()

			m.MinimockGetPresignedURLForUploadInspect()

			m.MinimockListConvertedFilesByFileUIDInspect()

			m.MinimockListFilePathsWithPrefixInspect()

			m.MinimockListKnowledgeBaseFilesInspect()

			m.MinimockListTextChunksByFileUIDInspect()

			m.MinimockSaveConvertedFileInspect()

			m.MinimockUploadBase64FileInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MinioIMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MinioIMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeleteFileDone() &&
		m.MinimockGetFileDone() &&
		m.MinimockGetFileMetadataDone() &&
		m.MinimockGetPresignedURLForDownloadDone() &&
		m.MinimockGetPresignedURLForUploadDone() &&
		m.MinimockListConvertedFilesByFileUIDDone() &&
		m.MinimockListFilePathsWithPrefixDone() &&
		m.MinimockListKnowledgeBaseFilesDone() &&
		m.MinimockListTextChunksByFileUIDDone() &&
		m.MinimockSaveConvertedFileDone() &&
		m.MinimockUploadBase64FileDone()
}
