// Code generated by http://github.com/gojuno/minimock (v3.3.9). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RegistryClientMock implements service.RegistryClient
type RegistryClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDeleteTag          func(ctx context.Context, repository string, digest string) (err error)
	inspectFuncDeleteTag   func(ctx context.Context, repository string, digest string)
	afterDeleteTagCounter  uint64
	beforeDeleteTagCounter uint64
	DeleteTagMock          mRegistryClientMockDeleteTag

	funcGetTagDigest          func(ctx context.Context, repository string, tag string) (digest string, err error)
	inspectFuncGetTagDigest   func(ctx context.Context, repository string, tag string)
	afterGetTagDigestCounter  uint64
	beforeGetTagDigestCounter uint64
	GetTagDigestMock          mRegistryClientMockGetTagDigest

	funcListTags          func(ctx context.Context, repository string) (tags []string, err error)
	inspectFuncListTags   func(ctx context.Context, repository string)
	afterListTagsCounter  uint64
	beforeListTagsCounter uint64
	ListTagsMock          mRegistryClientMockListTags
}

// NewRegistryClientMock returns a mock for service.RegistryClient
func NewRegistryClientMock(t minimock.Tester) *RegistryClientMock {
	m := &RegistryClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeleteTagMock = mRegistryClientMockDeleteTag{mock: m}
	m.DeleteTagMock.callArgs = []*RegistryClientMockDeleteTagParams{}

	m.GetTagDigestMock = mRegistryClientMockGetTagDigest{mock: m}
	m.GetTagDigestMock.callArgs = []*RegistryClientMockGetTagDigestParams{}

	m.ListTagsMock = mRegistryClientMockListTags{mock: m}
	m.ListTagsMock.callArgs = []*RegistryClientMockListTagsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRegistryClientMockDeleteTag struct {
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockDeleteTagExpectation
	expectations       []*RegistryClientMockDeleteTagExpectation

	callArgs []*RegistryClientMockDeleteTagParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RegistryClientMockDeleteTagExpectation specifies expectation struct of the RegistryClient.DeleteTag
type RegistryClientMockDeleteTagExpectation struct {
	mock      *RegistryClientMock
	params    *RegistryClientMockDeleteTagParams
	paramPtrs *RegistryClientMockDeleteTagParamPtrs
	results   *RegistryClientMockDeleteTagResults
	Counter   uint64
}

// RegistryClientMockDeleteTagParams contains parameters of the RegistryClient.DeleteTag
type RegistryClientMockDeleteTagParams struct {
	ctx        context.Context
	repository string
	digest     string
}

// RegistryClientMockDeleteTagParamPtrs contains pointers to parameters of the RegistryClient.DeleteTag
type RegistryClientMockDeleteTagParamPtrs struct {
	ctx        *context.Context
	repository *string
	digest     *string
}

// RegistryClientMockDeleteTagResults contains results of the RegistryClient.DeleteTag
type RegistryClientMockDeleteTagResults struct {
	err error
}

// Expect sets up expected params for RegistryClient.DeleteTag
func (mmDeleteTag *mRegistryClientMockDeleteTag) Expect(ctx context.Context, repository string, digest string) *mRegistryClientMockDeleteTag {
	if mmDeleteTag.mock.funcDeleteTag != nil {
		mmDeleteTag.mock.t.Fatalf("RegistryClientMock.DeleteTag mock is already set by Set")
	}

	if mmDeleteTag.defaultExpectation == nil {
		mmDeleteTag.defaultExpectation = &RegistryClientMockDeleteTagExpectation{}
	}

	if mmDeleteTag.defaultExpectation.paramPtrs != nil {
		mmDeleteTag.mock.t.Fatalf("RegistryClientMock.DeleteTag mock is already set by ExpectParams functions")
	}

	mmDeleteTag.defaultExpectation.params = &RegistryClientMockDeleteTagParams{ctx, repository, digest}
	for _, e := range mmDeleteTag.expectations {
		if minimock.Equal(e.params, mmDeleteTag.defaultExpectation.params) {
			mmDeleteTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteTag.defaultExpectation.params)
		}
	}

	return mmDeleteTag
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.DeleteTag
func (mmDeleteTag *mRegistryClientMockDeleteTag) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockDeleteTag {
	if mmDeleteTag.mock.funcDeleteTag != nil {
		mmDeleteTag.mock.t.Fatalf("RegistryClientMock.DeleteTag mock is already set by Set")
	}

	if mmDeleteTag.defaultExpectation == nil {
		mmDeleteTag.defaultExpectation = &RegistryClientMockDeleteTagExpectation{}
	}

	if mmDeleteTag.defaultExpectation.params != nil {
		mmDeleteTag.mock.t.Fatalf("RegistryClientMock.DeleteTag mock is already set by Expect")
	}

	if mmDeleteTag.defaultExpectation.paramPtrs == nil {
		mmDeleteTag.defaultExpectation.paramPtrs = &RegistryClientMockDeleteTagParamPtrs{}
	}
	mmDeleteTag.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteTag
}

// ExpectRepositoryParam2 sets up expected param repository for RegistryClient.DeleteTag
func (mmDeleteTag *mRegistryClientMockDeleteTag) ExpectRepositoryParam2(repository string) *mRegistryClientMockDeleteTag {
	if mmDeleteTag.mock.funcDeleteTag != nil {
		mmDeleteTag.mock.t.Fatalf("RegistryClientMock.DeleteTag mock is already set by Set")
	}

	if mmDeleteTag.defaultExpectation == nil {
		mmDeleteTag.defaultExpectation = &RegistryClientMockDeleteTagExpectation{}
	}

	if mmDeleteTag.defaultExpectation.params != nil {
		mmDeleteTag.mock.t.Fatalf("RegistryClientMock.DeleteTag mock is already set by Expect")
	}

	if mmDeleteTag.defaultExpectation.paramPtrs == nil {
		mmDeleteTag.defaultExpectation.paramPtrs = &RegistryClientMockDeleteTagParamPtrs{}
	}
	mmDeleteTag.defaultExpectation.paramPtrs.repository = &repository

	return mmDeleteTag
}

// ExpectDigestParam3 sets up expected param digest for RegistryClient.DeleteTag
func (mmDeleteTag *mRegistryClientMockDeleteTag) ExpectDigestParam3(digest string) *mRegistryClientMockDeleteTag {
	if mmDeleteTag.mock.funcDeleteTag != nil {
		mmDeleteTag.mock.t.Fatalf("RegistryClientMock.DeleteTag mock is already set by Set")
	}

	if mmDeleteTag.defaultExpectation == nil {
		mmDeleteTag.defaultExpectation = &RegistryClientMockDeleteTagExpectation{}
	}

	if mmDeleteTag.defaultExpectation.params != nil {
		mmDeleteTag.mock.t.Fatalf("RegistryClientMock.DeleteTag mock is already set by Expect")
	}

	if mmDeleteTag.defaultExpectation.paramPtrs == nil {
		mmDeleteTag.defaultExpectation.paramPtrs = &RegistryClientMockDeleteTagParamPtrs{}
	}
	mmDeleteTag.defaultExpectation.paramPtrs.digest = &digest

	return mmDeleteTag
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.DeleteTag
func (mmDeleteTag *mRegistryClientMockDeleteTag) Inspect(f func(ctx context.Context, repository string, digest string)) *mRegistryClientMockDeleteTag {
	if mmDeleteTag.mock.inspectFuncDeleteTag != nil {
		mmDeleteTag.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.DeleteTag")
	}

	mmDeleteTag.mock.inspectFuncDeleteTag = f

	return mmDeleteTag
}

// Return sets up results that will be returned by RegistryClient.DeleteTag
func (mmDeleteTag *mRegistryClientMockDeleteTag) Return(err error) *RegistryClientMock {
	if mmDeleteTag.mock.funcDeleteTag != nil {
		mmDeleteTag.mock.t.Fatalf("RegistryClientMock.DeleteTag mock is already set by Set")
	}

	if mmDeleteTag.defaultExpectation == nil {
		mmDeleteTag.defaultExpectation = &RegistryClientMockDeleteTagExpectation{mock: mmDeleteTag.mock}
	}
	mmDeleteTag.defaultExpectation.results = &RegistryClientMockDeleteTagResults{err}
	return mmDeleteTag.mock
}

// Set uses given function f to mock the RegistryClient.DeleteTag method
func (mmDeleteTag *mRegistryClientMockDeleteTag) Set(f func(ctx context.Context, repository string, digest string) (err error)) *RegistryClientMock {
	if mmDeleteTag.defaultExpectation != nil {
		mmDeleteTag.mock.t.Fatalf("Default expectation is already set for the RegistryClient.DeleteTag method")
	}

	if len(mmDeleteTag.expectations) > 0 {
		mmDeleteTag.mock.t.Fatalf("Some expectations are already set for the RegistryClient.DeleteTag method")
	}

	mmDeleteTag.mock.funcDeleteTag = f
	return mmDeleteTag.mock
}

// When sets expectation for the RegistryClient.DeleteTag which will trigger the result defined by the following
// Then helper
func (mmDeleteTag *mRegistryClientMockDeleteTag) When(ctx context.Context, repository string, digest string) *RegistryClientMockDeleteTagExpectation {
	if mmDeleteTag.mock.funcDeleteTag != nil {
		mmDeleteTag.mock.t.Fatalf("RegistryClientMock.DeleteTag mock is already set by Set")
	}

	expectation := &RegistryClientMockDeleteTagExpectation{
		mock:   mmDeleteTag.mock,
		params: &RegistryClientMockDeleteTagParams{ctx, repository, digest},
	}
	mmDeleteTag.expectations = append(mmDeleteTag.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.DeleteTag return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockDeleteTagExpectation) Then(err error) *RegistryClientMock {
	e.results = &RegistryClientMockDeleteTagResults{err}
	return e.mock
}

// Times sets number of times RegistryClient.DeleteTag should be invoked
func (mmDeleteTag *mRegistryClientMockDeleteTag) Times(n uint64) *mRegistryClientMockDeleteTag {
	if n == 0 {
		mmDeleteTag.mock.t.Fatalf("Times of RegistryClientMock.DeleteTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteTag.expectedInvocations, n)
	return mmDeleteTag
}

func (mmDeleteTag *mRegistryClientMockDeleteTag) invocationsDone() bool {
	if len(mmDeleteTag.expectations) == 0 && mmDeleteTag.defaultExpectation == nil && mmDeleteTag.mock.funcDeleteTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteTag.mock.afterDeleteTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteTag implements service.RegistryClient
func (mmDeleteTag *RegistryClientMock) DeleteTag(ctx context.Context, repository string, digest string) (err error) {
	mm_atomic.AddUint64(&mmDeleteTag.beforeDeleteTagCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteTag.afterDeleteTagCounter, 1)

	if mmDeleteTag.inspectFuncDeleteTag != nil {
		mmDeleteTag.inspectFuncDeleteTag(ctx, repository, digest)
	}

	mm_params := RegistryClientMockDeleteTagParams{ctx, repository, digest}

	// Record call args
	mmDeleteTag.DeleteTagMock.mutex.Lock()
	mmDeleteTag.DeleteTagMock.callArgs = append(mmDeleteTag.DeleteTagMock.callArgs, &mm_params)
	mmDeleteTag.DeleteTagMock.mutex.Unlock()

	for _, e := range mmDeleteTag.DeleteTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteTag.DeleteTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteTag.DeleteTagMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteTag.DeleteTagMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteTag.DeleteTagMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockDeleteTagParams{ctx, repository, digest}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteTag.t.Errorf("RegistryClientMock.DeleteTag got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.repository != nil && !minimock.Equal(*mm_want_ptrs.repository, mm_got.repository) {
				mmDeleteTag.t.Errorf("RegistryClientMock.DeleteTag got unexpected parameter repository, want: %#v, got: %#v%s\n", *mm_want_ptrs.repository, mm_got.repository, minimock.Diff(*mm_want_ptrs.repository, mm_got.repository))
			}

			if mm_want_ptrs.digest != nil && !minimock.Equal(*mm_want_ptrs.digest, mm_got.digest) {
				mmDeleteTag.t.Errorf("RegistryClientMock.DeleteTag got unexpected parameter digest, want: %#v, got: %#v%s\n", *mm_want_ptrs.digest, mm_got.digest, minimock.Diff(*mm_want_ptrs.digest, mm_got.digest))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteTag.t.Errorf("RegistryClientMock.DeleteTag got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteTag.DeleteTagMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteTag.t.Fatal("No results are set for the RegistryClientMock.DeleteTag")
		}
		return (*mm_results).err
	}
	if mmDeleteTag.funcDeleteTag != nil {
		return mmDeleteTag.funcDeleteTag(ctx, repository, digest)
	}
	mmDeleteTag.t.Fatalf("Unexpected call to RegistryClientMock.DeleteTag. %v %v %v", ctx, repository, digest)
	return
}

// DeleteTagAfterCounter returns a count of finished RegistryClientMock.DeleteTag invocations
func (mmDeleteTag *RegistryClientMock) DeleteTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteTag.afterDeleteTagCounter)
}

// DeleteTagBeforeCounter returns a count of RegistryClientMock.DeleteTag invocations
func (mmDeleteTag *RegistryClientMock) DeleteTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteTag.beforeDeleteTagCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.DeleteTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteTag *mRegistryClientMockDeleteTag) Calls() []*RegistryClientMockDeleteTagParams {
	mmDeleteTag.mutex.RLock()

	argCopy := make([]*RegistryClientMockDeleteTagParams, len(mmDeleteTag.callArgs))
	copy(argCopy, mmDeleteTag.callArgs)

	mmDeleteTag.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteTagDone returns true if the count of the DeleteTag invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockDeleteTagDone() bool {
	for _, e := range m.DeleteTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteTagMock.invocationsDone()
}

// MinimockDeleteTagInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockDeleteTagInspect() {
	for _, e := range m.DeleteTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.DeleteTag with params: %#v", *e.params)
		}
	}

	afterDeleteTagCounter := mm_atomic.LoadUint64(&m.afterDeleteTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteTagMock.defaultExpectation != nil && afterDeleteTagCounter < 1 {
		if m.DeleteTagMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RegistryClientMock.DeleteTag")
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.DeleteTag with params: %#v", *m.DeleteTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteTag != nil && afterDeleteTagCounter < 1 {
		m.t.Error("Expected call to RegistryClientMock.DeleteTag")
	}

	if !m.DeleteTagMock.invocationsDone() && afterDeleteTagCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.DeleteTag but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteTagMock.expectedInvocations), afterDeleteTagCounter)
	}
}

type mRegistryClientMockGetTagDigest struct {
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockGetTagDigestExpectation
	expectations       []*RegistryClientMockGetTagDigestExpectation

	callArgs []*RegistryClientMockGetTagDigestParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RegistryClientMockGetTagDigestExpectation specifies expectation struct of the RegistryClient.GetTagDigest
type RegistryClientMockGetTagDigestExpectation struct {
	mock      *RegistryClientMock
	params    *RegistryClientMockGetTagDigestParams
	paramPtrs *RegistryClientMockGetTagDigestParamPtrs
	results   *RegistryClientMockGetTagDigestResults
	Counter   uint64
}

// RegistryClientMockGetTagDigestParams contains parameters of the RegistryClient.GetTagDigest
type RegistryClientMockGetTagDigestParams struct {
	ctx        context.Context
	repository string
	tag        string
}

// RegistryClientMockGetTagDigestParamPtrs contains pointers to parameters of the RegistryClient.GetTagDigest
type RegistryClientMockGetTagDigestParamPtrs struct {
	ctx        *context.Context
	repository *string
	tag        *string
}

// RegistryClientMockGetTagDigestResults contains results of the RegistryClient.GetTagDigest
type RegistryClientMockGetTagDigestResults struct {
	digest string
	err    error
}

// Expect sets up expected params for RegistryClient.GetTagDigest
func (mmGetTagDigest *mRegistryClientMockGetTagDigest) Expect(ctx context.Context, repository string, tag string) *mRegistryClientMockGetTagDigest {
	if mmGetTagDigest.mock.funcGetTagDigest != nil {
		mmGetTagDigest.mock.t.Fatalf("RegistryClientMock.GetTagDigest mock is already set by Set")
	}

	if mmGetTagDigest.defaultExpectation == nil {
		mmGetTagDigest.defaultExpectation = &RegistryClientMockGetTagDigestExpectation{}
	}

	if mmGetTagDigest.defaultExpectation.paramPtrs != nil {
		mmGetTagDigest.mock.t.Fatalf("RegistryClientMock.GetTagDigest mock is already set by ExpectParams functions")
	}

	mmGetTagDigest.defaultExpectation.params = &RegistryClientMockGetTagDigestParams{ctx, repository, tag}
	for _, e := range mmGetTagDigest.expectations {
		if minimock.Equal(e.params, mmGetTagDigest.defaultExpectation.params) {
			mmGetTagDigest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTagDigest.defaultExpectation.params)
		}
	}

	return mmGetTagDigest
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.GetTagDigest
func (mmGetTagDigest *mRegistryClientMockGetTagDigest) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockGetTagDigest {
	if mmGetTagDigest.mock.funcGetTagDigest != nil {
		mmGetTagDigest.mock.t.Fatalf("RegistryClientMock.GetTagDigest mock is already set by Set")
	}

	if mmGetTagDigest.defaultExpectation == nil {
		mmGetTagDigest.defaultExpectation = &RegistryClientMockGetTagDigestExpectation{}
	}

	if mmGetTagDigest.defaultExpectation.params != nil {
		mmGetTagDigest.mock.t.Fatalf("RegistryClientMock.GetTagDigest mock is already set by Expect")
	}

	if mmGetTagDigest.defaultExpectation.paramPtrs == nil {
		mmGetTagDigest.defaultExpectation.paramPtrs = &RegistryClientMockGetTagDigestParamPtrs{}
	}
	mmGetTagDigest.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetTagDigest
}

// ExpectRepositoryParam2 sets up expected param repository for RegistryClient.GetTagDigest
func (mmGetTagDigest *mRegistryClientMockGetTagDigest) ExpectRepositoryParam2(repository string) *mRegistryClientMockGetTagDigest {
	if mmGetTagDigest.mock.funcGetTagDigest != nil {
		mmGetTagDigest.mock.t.Fatalf("RegistryClientMock.GetTagDigest mock is already set by Set")
	}

	if mmGetTagDigest.defaultExpectation == nil {
		mmGetTagDigest.defaultExpectation = &RegistryClientMockGetTagDigestExpectation{}
	}

	if mmGetTagDigest.defaultExpectation.params != nil {
		mmGetTagDigest.mock.t.Fatalf("RegistryClientMock.GetTagDigest mock is already set by Expect")
	}

	if mmGetTagDigest.defaultExpectation.paramPtrs == nil {
		mmGetTagDigest.defaultExpectation.paramPtrs = &RegistryClientMockGetTagDigestParamPtrs{}
	}
	mmGetTagDigest.defaultExpectation.paramPtrs.repository = &repository

	return mmGetTagDigest
}

// ExpectTagParam3 sets up expected param tag for RegistryClient.GetTagDigest
func (mmGetTagDigest *mRegistryClientMockGetTagDigest) ExpectTagParam3(tag string) *mRegistryClientMockGetTagDigest {
	if mmGetTagDigest.mock.funcGetTagDigest != nil {
		mmGetTagDigest.mock.t.Fatalf("RegistryClientMock.GetTagDigest mock is already set by Set")
	}

	if mmGetTagDigest.defaultExpectation == nil {
		mmGetTagDigest.defaultExpectation = &RegistryClientMockGetTagDigestExpectation{}
	}

	if mmGetTagDigest.defaultExpectation.params != nil {
		mmGetTagDigest.mock.t.Fatalf("RegistryClientMock.GetTagDigest mock is already set by Expect")
	}

	if mmGetTagDigest.defaultExpectation.paramPtrs == nil {
		mmGetTagDigest.defaultExpectation.paramPtrs = &RegistryClientMockGetTagDigestParamPtrs{}
	}
	mmGetTagDigest.defaultExpectation.paramPtrs.tag = &tag

	return mmGetTagDigest
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.GetTagDigest
func (mmGetTagDigest *mRegistryClientMockGetTagDigest) Inspect(f func(ctx context.Context, repository string, tag string)) *mRegistryClientMockGetTagDigest {
	if mmGetTagDigest.mock.inspectFuncGetTagDigest != nil {
		mmGetTagDigest.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.GetTagDigest")
	}

	mmGetTagDigest.mock.inspectFuncGetTagDigest = f

	return mmGetTagDigest
}

// Return sets up results that will be returned by RegistryClient.GetTagDigest
func (mmGetTagDigest *mRegistryClientMockGetTagDigest) Return(digest string, err error) *RegistryClientMock {
	if mmGetTagDigest.mock.funcGetTagDigest != nil {
		mmGetTagDigest.mock.t.Fatalf("RegistryClientMock.GetTagDigest mock is already set by Set")
	}

	if mmGetTagDigest.defaultExpectation == nil {
		mmGetTagDigest.defaultExpectation = &RegistryClientMockGetTagDigestExpectation{mock: mmGetTagDigest.mock}
	}
	mmGetTagDigest.defaultExpectation.results = &RegistryClientMockGetTagDigestResults{digest, err}
	return mmGetTagDigest.mock
}

// Set uses given function f to mock the RegistryClient.GetTagDigest method
func (mmGetTagDigest *mRegistryClientMockGetTagDigest) Set(f func(ctx context.Context, repository string, tag string) (digest string, err error)) *RegistryClientMock {
	if mmGetTagDigest.defaultExpectation != nil {
		mmGetTagDigest.mock.t.Fatalf("Default expectation is already set for the RegistryClient.GetTagDigest method")
	}

	if len(mmGetTagDigest.expectations) > 0 {
		mmGetTagDigest.mock.t.Fatalf("Some expectations are already set for the RegistryClient.GetTagDigest method")
	}

	mmGetTagDigest.mock.funcGetTagDigest = f
	return mmGetTagDigest.mock
}

// When sets expectation for the RegistryClient.GetTagDigest which will trigger the result defined by the following
// Then helper
func (mmGetTagDigest *mRegistryClientMockGetTagDigest) When(ctx context.Context, repository string, tag string) *RegistryClientMockGetTagDigestExpectation {
	if mmGetTagDigest.mock.funcGetTagDigest != nil {
		mmGetTagDigest.mock.t.Fatalf("RegistryClientMock.GetTagDigest mock is already set by Set")
	}

	expectation := &RegistryClientMockGetTagDigestExpectation{
		mock:   mmGetTagDigest.mock,
		params: &RegistryClientMockGetTagDigestParams{ctx, repository, tag},
	}
	mmGetTagDigest.expectations = append(mmGetTagDigest.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.GetTagDigest return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockGetTagDigestExpectation) Then(digest string, err error) *RegistryClientMock {
	e.results = &RegistryClientMockGetTagDigestResults{digest, err}
	return e.mock
}

// Times sets number of times RegistryClient.GetTagDigest should be invoked
func (mmGetTagDigest *mRegistryClientMockGetTagDigest) Times(n uint64) *mRegistryClientMockGetTagDigest {
	if n == 0 {
		mmGetTagDigest.mock.t.Fatalf("Times of RegistryClientMock.GetTagDigest mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTagDigest.expectedInvocations, n)
	return mmGetTagDigest
}

func (mmGetTagDigest *mRegistryClientMockGetTagDigest) invocationsDone() bool {
	if len(mmGetTagDigest.expectations) == 0 && mmGetTagDigest.defaultExpectation == nil && mmGetTagDigest.mock.funcGetTagDigest == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTagDigest.mock.afterGetTagDigestCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTagDigest.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTagDigest implements service.RegistryClient
func (mmGetTagDigest *RegistryClientMock) GetTagDigest(ctx context.Context, repository string, tag string) (digest string, err error) {
	mm_atomic.AddUint64(&mmGetTagDigest.beforeGetTagDigestCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTagDigest.afterGetTagDigestCounter, 1)

	if mmGetTagDigest.inspectFuncGetTagDigest != nil {
		mmGetTagDigest.inspectFuncGetTagDigest(ctx, repository, tag)
	}

	mm_params := RegistryClientMockGetTagDigestParams{ctx, repository, tag}

	// Record call args
	mmGetTagDigest.GetTagDigestMock.mutex.Lock()
	mmGetTagDigest.GetTagDigestMock.callArgs = append(mmGetTagDigest.GetTagDigestMock.callArgs, &mm_params)
	mmGetTagDigest.GetTagDigestMock.mutex.Unlock()

	for _, e := range mmGetTagDigest.GetTagDigestMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.digest, e.results.err
		}
	}

	if mmGetTagDigest.GetTagDigestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTagDigest.GetTagDigestMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTagDigest.GetTagDigestMock.defaultExpectation.params
		mm_want_ptrs := mmGetTagDigest.GetTagDigestMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockGetTagDigestParams{ctx, repository, tag}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTagDigest.t.Errorf("RegistryClientMock.GetTagDigest got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.repository != nil && !minimock.Equal(*mm_want_ptrs.repository, mm_got.repository) {
				mmGetTagDigest.t.Errorf("RegistryClientMock.GetTagDigest got unexpected parameter repository, want: %#v, got: %#v%s\n", *mm_want_ptrs.repository, mm_got.repository, minimock.Diff(*mm_want_ptrs.repository, mm_got.repository))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmGetTagDigest.t.Errorf("RegistryClientMock.GetTagDigest got unexpected parameter tag, want: %#v, got: %#v%s\n", *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTagDigest.t.Errorf("RegistryClientMock.GetTagDigest got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTagDigest.GetTagDigestMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTagDigest.t.Fatal("No results are set for the RegistryClientMock.GetTagDigest")
		}
		return (*mm_results).digest, (*mm_results).err
	}
	if mmGetTagDigest.funcGetTagDigest != nil {
		return mmGetTagDigest.funcGetTagDigest(ctx, repository, tag)
	}
	mmGetTagDigest.t.Fatalf("Unexpected call to RegistryClientMock.GetTagDigest. %v %v %v", ctx, repository, tag)
	return
}

// GetTagDigestAfterCounter returns a count of finished RegistryClientMock.GetTagDigest invocations
func (mmGetTagDigest *RegistryClientMock) GetTagDigestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTagDigest.afterGetTagDigestCounter)
}

// GetTagDigestBeforeCounter returns a count of RegistryClientMock.GetTagDigest invocations
func (mmGetTagDigest *RegistryClientMock) GetTagDigestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTagDigest.beforeGetTagDigestCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.GetTagDigest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTagDigest *mRegistryClientMockGetTagDigest) Calls() []*RegistryClientMockGetTagDigestParams {
	mmGetTagDigest.mutex.RLock()

	argCopy := make([]*RegistryClientMockGetTagDigestParams, len(mmGetTagDigest.callArgs))
	copy(argCopy, mmGetTagDigest.callArgs)

	mmGetTagDigest.mutex.RUnlock()

	return argCopy
}

// MinimockGetTagDigestDone returns true if the count of the GetTagDigest invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockGetTagDigestDone() bool {
	for _, e := range m.GetTagDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTagDigestMock.invocationsDone()
}

// MinimockGetTagDigestInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockGetTagDigestInspect() {
	for _, e := range m.GetTagDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.GetTagDigest with params: %#v", *e.params)
		}
	}

	afterGetTagDigestCounter := mm_atomic.LoadUint64(&m.afterGetTagDigestCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTagDigestMock.defaultExpectation != nil && afterGetTagDigestCounter < 1 {
		if m.GetTagDigestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RegistryClientMock.GetTagDigest")
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.GetTagDigest with params: %#v", *m.GetTagDigestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTagDigest != nil && afterGetTagDigestCounter < 1 {
		m.t.Error("Expected call to RegistryClientMock.GetTagDigest")
	}

	if !m.GetTagDigestMock.invocationsDone() && afterGetTagDigestCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.GetTagDigest but found %d calls",
			mm_atomic.LoadUint64(&m.GetTagDigestMock.expectedInvocations), afterGetTagDigestCounter)
	}
}

type mRegistryClientMockListTags struct {
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockListTagsExpectation
	expectations       []*RegistryClientMockListTagsExpectation

	callArgs []*RegistryClientMockListTagsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RegistryClientMockListTagsExpectation specifies expectation struct of the RegistryClient.ListTags
type RegistryClientMockListTagsExpectation struct {
	mock      *RegistryClientMock
	params    *RegistryClientMockListTagsParams
	paramPtrs *RegistryClientMockListTagsParamPtrs
	results   *RegistryClientMockListTagsResults
	Counter   uint64
}

// RegistryClientMockListTagsParams contains parameters of the RegistryClient.ListTags
type RegistryClientMockListTagsParams struct {
	ctx        context.Context
	repository string
}

// RegistryClientMockListTagsParamPtrs contains pointers to parameters of the RegistryClient.ListTags
type RegistryClientMockListTagsParamPtrs struct {
	ctx        *context.Context
	repository *string
}

// RegistryClientMockListTagsResults contains results of the RegistryClient.ListTags
type RegistryClientMockListTagsResults struct {
	tags []string
	err  error
}

// Expect sets up expected params for RegistryClient.ListTags
func (mmListTags *mRegistryClientMockListTags) Expect(ctx context.Context, repository string) *mRegistryClientMockListTags {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &RegistryClientMockListTagsExpectation{}
	}

	if mmListTags.defaultExpectation.paramPtrs != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by ExpectParams functions")
	}

	mmListTags.defaultExpectation.params = &RegistryClientMockListTagsParams{ctx, repository}
	for _, e := range mmListTags.expectations {
		if minimock.Equal(e.params, mmListTags.defaultExpectation.params) {
			mmListTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListTags.defaultExpectation.params)
		}
	}

	return mmListTags
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.ListTags
func (mmListTags *mRegistryClientMockListTags) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockListTags {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &RegistryClientMockListTagsExpectation{}
	}

	if mmListTags.defaultExpectation.params != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Expect")
	}

	if mmListTags.defaultExpectation.paramPtrs == nil {
		mmListTags.defaultExpectation.paramPtrs = &RegistryClientMockListTagsParamPtrs{}
	}
	mmListTags.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListTags
}

// ExpectRepositoryParam2 sets up expected param repository for RegistryClient.ListTags
func (mmListTags *mRegistryClientMockListTags) ExpectRepositoryParam2(repository string) *mRegistryClientMockListTags {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &RegistryClientMockListTagsExpectation{}
	}

	if mmListTags.defaultExpectation.params != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Expect")
	}

	if mmListTags.defaultExpectation.paramPtrs == nil {
		mmListTags.defaultExpectation.paramPtrs = &RegistryClientMockListTagsParamPtrs{}
	}
	mmListTags.defaultExpectation.paramPtrs.repository = &repository

	return mmListTags
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.ListTags
func (mmListTags *mRegistryClientMockListTags) Inspect(f func(ctx context.Context, repository string)) *mRegistryClientMockListTags {
	if mmListTags.mock.inspectFuncListTags != nil {
		mmListTags.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.ListTags")
	}

	mmListTags.mock.inspectFuncListTags = f

	return mmListTags
}

// Return sets up results that will be returned by RegistryClient.ListTags
func (mmListTags *mRegistryClientMockListTags) Return(tags []string, err error) *RegistryClientMock {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &RegistryClientMockListTagsExpectation{mock: mmListTags.mock}
	}
	mmListTags.defaultExpectation.results = &RegistryClientMockListTagsResults{tags, err}
	return mmListTags.mock
}

// Set uses given function f to mock the RegistryClient.ListTags method
func (mmListTags *mRegistryClientMockListTags) Set(f func(ctx context.Context, repository string) (tags []string, err error)) *RegistryClientMock {
	if mmListTags.defaultExpectation != nil {
		mmListTags.mock.t.Fatalf("Default expectation is already set for the RegistryClient.ListTags method")
	}

	if len(mmListTags.expectations) > 0 {
		mmListTags.mock.t.Fatalf("Some expectations are already set for the RegistryClient.ListTags method")
	}

	mmListTags.mock.funcListTags = f
	return mmListTags.mock
}

// When sets expectation for the RegistryClient.ListTags which will trigger the result defined by the following
// Then helper
func (mmListTags *mRegistryClientMockListTags) When(ctx context.Context, repository string) *RegistryClientMockListTagsExpectation {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Set")
	}

	expectation := &RegistryClientMockListTagsExpectation{
		mock:   mmListTags.mock,
		params: &RegistryClientMockListTagsParams{ctx, repository},
	}
	mmListTags.expectations = append(mmListTags.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.ListTags return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockListTagsExpectation) Then(tags []string, err error) *RegistryClientMock {
	e.results = &RegistryClientMockListTagsResults{tags, err}
	return e.mock
}

// Times sets number of times RegistryClient.ListTags should be invoked
func (mmListTags *mRegistryClientMockListTags) Times(n uint64) *mRegistryClientMockListTags {
	if n == 0 {
		mmListTags.mock.t.Fatalf("Times of RegistryClientMock.ListTags mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListTags.expectedInvocations, n)
	return mmListTags
}

func (mmListTags *mRegistryClientMockListTags) invocationsDone() bool {
	if len(mmListTags.expectations) == 0 && mmListTags.defaultExpectation == nil && mmListTags.mock.funcListTags == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListTags.mock.afterListTagsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListTags.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListTags implements service.RegistryClient
func (mmListTags *RegistryClientMock) ListTags(ctx context.Context, repository string) (tags []string, err error) {
	mm_atomic.AddUint64(&mmListTags.beforeListTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmListTags.afterListTagsCounter, 1)

	if mmListTags.inspectFuncListTags != nil {
		mmListTags.inspectFuncListTags(ctx, repository)
	}

	mm_params := RegistryClientMockListTagsParams{ctx, repository}

	// Record call args
	mmListTags.ListTagsMock.mutex.Lock()
	mmListTags.ListTagsMock.callArgs = append(mmListTags.ListTagsMock.callArgs, &mm_params)
	mmListTags.ListTagsMock.mutex.Unlock()

	for _, e := range mmListTags.ListTagsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tags, e.results.err
		}
	}

	if mmListTags.ListTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListTags.ListTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmListTags.ListTagsMock.defaultExpectation.params
		mm_want_ptrs := mmListTags.ListTagsMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockListTagsParams{ctx, repository}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListTags.t.Errorf("RegistryClientMock.ListTags got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.repository != nil && !minimock.Equal(*mm_want_ptrs.repository, mm_got.repository) {
				mmListTags.t.Errorf("RegistryClientMock.ListTags got unexpected parameter repository, want: %#v, got: %#v%s\n", *mm_want_ptrs.repository, mm_got.repository, minimock.Diff(*mm_want_ptrs.repository, mm_got.repository))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListTags.t.Errorf("RegistryClientMock.ListTags got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListTags.ListTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmListTags.t.Fatal("No results are set for the RegistryClientMock.ListTags")
		}
		return (*mm_results).tags, (*mm_results).err
	}
	if mmListTags.funcListTags != nil {
		return mmListTags.funcListTags(ctx, repository)
	}
	mmListTags.t.Fatalf("Unexpected call to RegistryClientMock.ListTags. %v %v", ctx, repository)
	return
}

// ListTagsAfterCounter returns a count of finished RegistryClientMock.ListTags invocations
func (mmListTags *RegistryClientMock) ListTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTags.afterListTagsCounter)
}

// ListTagsBeforeCounter returns a count of RegistryClientMock.ListTags invocations
func (mmListTags *RegistryClientMock) ListTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTags.beforeListTagsCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.ListTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListTags *mRegistryClientMockListTags) Calls() []*RegistryClientMockListTagsParams {
	mmListTags.mutex.RLock()

	argCopy := make([]*RegistryClientMockListTagsParams, len(mmListTags.callArgs))
	copy(argCopy, mmListTags.callArgs)

	mmListTags.mutex.RUnlock()

	return argCopy
}

// MinimockListTagsDone returns true if the count of the ListTags invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockListTagsDone() bool {
	for _, e := range m.ListTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListTagsMock.invocationsDone()
}

// MinimockListTagsInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockListTagsInspect() {
	for _, e := range m.ListTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.ListTags with params: %#v", *e.params)
		}
	}

	afterListTagsCounter := mm_atomic.LoadUint64(&m.afterListTagsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListTagsMock.defaultExpectation != nil && afterListTagsCounter < 1 {
		if m.ListTagsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RegistryClientMock.ListTags")
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.ListTags with params: %#v", *m.ListTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListTags != nil && afterListTagsCounter < 1 {
		m.t.Error("Expected call to RegistryClientMock.ListTags")
	}

	if !m.ListTagsMock.invocationsDone() && afterListTagsCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.ListTags but found %d calls",
			mm_atomic.LoadUint64(&m.ListTagsMock.expectedInvocations), afterListTagsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RegistryClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDeleteTagInspect()

			m.MinimockGetTagDigestInspect()

			m.MinimockListTagsInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RegistryClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RegistryClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeleteTagDone() &&
		m.MinimockGetTagDigestDone() &&
		m.MinimockListTagsDone()
}
