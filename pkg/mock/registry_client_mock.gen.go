// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RegistryClientMock implements mm_service.RegistryClient
type RegistryClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDeleteTag          func(ctx context.Context, repository string, digest string) (err error)
	funcDeleteTagOrigin    string
	inspectFuncDeleteTag   func(ctx context.Context, repository string, digest string)
	afterDeleteTagCounter  uint64
	beforeDeleteTagCounter uint64
	DeleteTagMock          mRegistryClientMockDeleteTag

	funcGetTagDigest          func(ctx context.Context, repository string, tag string) (digest string, err error)
	funcGetTagDigestOrigin    string
	inspectFuncGetTagDigest   func(ctx context.Context, repository string, tag string)
	afterGetTagDigestCounter  uint64
	beforeGetTagDigestCounter uint64
	GetTagDigestMock          mRegistryClientMockGetTagDigest

	funcListTags          func(ctx context.Context, repository string) (tags []string, err error)
	funcListTagsOrigin    string
	inspectFuncListTags   func(ctx context.Context, repository string)
	afterListTagsCounter  uint64
	beforeListTagsCounter uint64
	ListTagsMock          mRegistryClientMockListTags
}

// NewRegistryClientMock returns a mock for mm_service.RegistryClient
func NewRegistryClientMock(t minimock.Tester) *RegistryClientMock {
	m := &RegistryClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeleteTagMock = mRegistryClientMockDeleteTag{mock: m}
	m.DeleteTagMock.callArgs = []*RegistryClientMockDeleteTagParams{}

	m.GetTagDigestMock = mRegistryClientMockGetTagDigest{mock: m}
	m.GetTagDigestMock.callArgs = []*RegistryClientMockGetTagDigestParams{}

	m.ListTagsMock = mRegistryClientMockListTags{mock: m}
	m.ListTagsMock.callArgs = []*RegistryClientMockListTagsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRegistryClientMockDeleteTag struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockDeleteTagExpectation
	expectations       []*RegistryClientMockDeleteTagExpectation

	callArgs []*RegistryClientMockDeleteTagParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockDeleteTagExpectation specifies expectation struct of the RegistryClient.DeleteTag
type RegistryClientMockDeleteTagExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockDeleteTagParams
	paramPtrs          *RegistryClientMockDeleteTagParamPtrs
	expectationOrigins RegistryClientMockDeleteTagExpectationOrigins
	results            *RegistryClientMockDeleteTagResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockDeleteTagParams contains parameters of the RegistryClient.DeleteTag
type RegistryClientMockDeleteTagParams struct {
	ctx        context.Context
	repository string
	digest     string
}

// RegistryClientMockDeleteTagParamPtrs contains pointers to parameters of the RegistryClient.DeleteTag
type RegistryClientMockDeleteTagParamPtrs struct {
	ctx        *context.Context
	repository *string
	digest     *string
}

// RegistryClientMockDeleteTagResults contains results of the RegistryClient.DeleteTag
type RegistryClientMockDeleteTagResults struct {
	err error
}

// RegistryClientMockDeleteTagOrigins contains origins of expectations of the RegistryClient.DeleteTag
type RegistryClientMockDeleteTagExpectationOrigins struct {
	origin           string
	originCtx        string
	originRepository string
	originDigest     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteTag *mRegistryClientMockDeleteTag) Optional() *mRegistryClientMockDeleteTag {
	mmDeleteTag.optional = true
	return mmDeleteTag
}

// Expect sets up expected params for RegistryClient.DeleteTag
func (mmDeleteTag *mRegistryClientMockDeleteTag) Expect(ctx context.Context, repository string, digest string) *mRegistryClientMockDeleteTag {
	if mmDeleteTag.mock.funcDeleteTag != nil {
		mmDeleteTag.mock.t.Fatalf("RegistryClientMock.DeleteTag mock is already set by Set")
	}

	if mmDeleteTag.defaultExpectation == nil {
		mmDeleteTag.defaultExpectation = &RegistryClientMockDeleteTagExpectation{}
	}

	if mmDeleteTag.defaultExpectation.paramPtrs != nil {
		mmDeleteTag.mock.t.Fatalf("RegistryClientMock.DeleteTag mock is already set by ExpectParams functions")
	}

	mmDeleteTag.defaultExpectation.params = &RegistryClientMockDeleteTagParams{ctx, repository, digest}
	mmDeleteTag.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteTag.expectations {
		if minimock.Equal(e.params, mmDeleteTag.defaultExpectation.params) {
			mmDeleteTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteTag.defaultExpectation.params)
		}
	}

	return mmDeleteTag
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.DeleteTag
func (mmDeleteTag *mRegistryClientMockDeleteTag) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockDeleteTag {
	if mmDeleteTag.mock.funcDeleteTag != nil {
		mmDeleteTag.mock.t.Fatalf("RegistryClientMock.DeleteTag mock is already set by Set")
	}

	if mmDeleteTag.defaultExpectation == nil {
		mmDeleteTag.defaultExpectation = &RegistryClientMockDeleteTagExpectation{}
	}

	if mmDeleteTag.defaultExpectation.params != nil {
		mmDeleteTag.mock.t.Fatalf("RegistryClientMock.DeleteTag mock is already set by Expect")
	}

	if mmDeleteTag.defaultExpectation.paramPtrs == nil {
		mmDeleteTag.defaultExpectation.paramPtrs = &RegistryClientMockDeleteTagParamPtrs{}
	}
	mmDeleteTag.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteTag.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteTag
}

// ExpectRepositoryParam2 sets up expected param repository for RegistryClient.DeleteTag
func (mmDeleteTag *mRegistryClientMockDeleteTag) ExpectRepositoryParam2(repository string) *mRegistryClientMockDeleteTag {
	if mmDeleteTag.mock.funcDeleteTag != nil {
		mmDeleteTag.mock.t.Fatalf("RegistryClientMock.DeleteTag mock is already set by Set")
	}

	if mmDeleteTag.defaultExpectation == nil {
		mmDeleteTag.defaultExpectation = &RegistryClientMockDeleteTagExpectation{}
	}

	if mmDeleteTag.defaultExpectation.params != nil {
		mmDeleteTag.mock.t.Fatalf("RegistryClientMock.DeleteTag mock is already set by Expect")
	}

	if mmDeleteTag.defaultExpectation.paramPtrs == nil {
		mmDeleteTag.defaultExpectation.paramPtrs = &RegistryClientMockDeleteTagParamPtrs{}
	}
	mmDeleteTag.defaultExpectation.paramPtrs.repository = &repository
	mmDeleteTag.defaultExpectation.expectationOrigins.originRepository = minimock.CallerInfo(1)

	return mmDeleteTag
}

// ExpectDigestParam3 sets up expected param digest for RegistryClient.DeleteTag
func (mmDeleteTag *mRegistryClientMockDeleteTag) ExpectDigestParam3(digest string) *mRegistryClientMockDeleteTag {
	if mmDeleteTag.mock.funcDeleteTag != nil {
		mmDeleteTag.mock.t.Fatalf("RegistryClientMock.DeleteTag mock is already set by Set")
	}

	if mmDeleteTag.defaultExpectation == nil {
		mmDeleteTag.defaultExpectation = &RegistryClientMockDeleteTagExpectation{}
	}

	if mmDeleteTag.defaultExpectation.params != nil {
		mmDeleteTag.mock.t.Fatalf("RegistryClientMock.DeleteTag mock is already set by Expect")
	}

	if mmDeleteTag.defaultExpectation.paramPtrs == nil {
		mmDeleteTag.defaultExpectation.paramPtrs = &RegistryClientMockDeleteTagParamPtrs{}
	}
	mmDeleteTag.defaultExpectation.paramPtrs.digest = &digest
	mmDeleteTag.defaultExpectation.expectationOrigins.originDigest = minimock.CallerInfo(1)

	return mmDeleteTag
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.DeleteTag
func (mmDeleteTag *mRegistryClientMockDeleteTag) Inspect(f func(ctx context.Context, repository string, digest string)) *mRegistryClientMockDeleteTag {
	if mmDeleteTag.mock.inspectFuncDeleteTag != nil {
		mmDeleteTag.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.DeleteTag")
	}

	mmDeleteTag.mock.inspectFuncDeleteTag = f

	return mmDeleteTag
}

// Return sets up results that will be returned by RegistryClient.DeleteTag
func (mmDeleteTag *mRegistryClientMockDeleteTag) Return(err error) *RegistryClientMock {
	if mmDeleteTag.mock.funcDeleteTag != nil {
		mmDeleteTag.mock.t.Fatalf("RegistryClientMock.DeleteTag mock is already set by Set")
	}

	if mmDeleteTag.defaultExpectation == nil {
		mmDeleteTag.defaultExpectation = &RegistryClientMockDeleteTagExpectation{mock: mmDeleteTag.mock}
	}
	mmDeleteTag.defaultExpectation.results = &RegistryClientMockDeleteTagResults{err}
	mmDeleteTag.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteTag.mock
}

// Set uses given function f to mock the RegistryClient.DeleteTag method
func (mmDeleteTag *mRegistryClientMockDeleteTag) Set(f func(ctx context.Context, repository string, digest string) (err error)) *RegistryClientMock {
	if mmDeleteTag.defaultExpectation != nil {
		mmDeleteTag.mock.t.Fatalf("Default expectation is already set for the RegistryClient.DeleteTag method")
	}

	if len(mmDeleteTag.expectations) > 0 {
		mmDeleteTag.mock.t.Fatalf("Some expectations are already set for the RegistryClient.DeleteTag method")
	}

	mmDeleteTag.mock.funcDeleteTag = f
	mmDeleteTag.mock.funcDeleteTagOrigin = minimock.CallerInfo(1)
	return mmDeleteTag.mock
}

// When sets expectation for the RegistryClient.DeleteTag which will trigger the result defined by the following
// Then helper
func (mmDeleteTag *mRegistryClientMockDeleteTag) When(ctx context.Context, repository string, digest string) *RegistryClientMockDeleteTagExpectation {
	if mmDeleteTag.mock.funcDeleteTag != nil {
		mmDeleteTag.mock.t.Fatalf("RegistryClientMock.DeleteTag mock is already set by Set")
	}

	expectation := &RegistryClientMockDeleteTagExpectation{
		mock:               mmDeleteTag.mock,
		params:             &RegistryClientMockDeleteTagParams{ctx, repository, digest},
		expectationOrigins: RegistryClientMockDeleteTagExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteTag.expectations = append(mmDeleteTag.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.DeleteTag return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockDeleteTagExpectation) Then(err error) *RegistryClientMock {
	e.results = &RegistryClientMockDeleteTagResults{err}
	return e.mock
}

// Times sets number of times RegistryClient.DeleteTag should be invoked
func (mmDeleteTag *mRegistryClientMockDeleteTag) Times(n uint64) *mRegistryClientMockDeleteTag {
	if n == 0 {
		mmDeleteTag.mock.t.Fatalf("Times of RegistryClientMock.DeleteTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteTag.expectedInvocations, n)
	mmDeleteTag.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteTag
}

func (mmDeleteTag *mRegistryClientMockDeleteTag) invocationsDone() bool {
	if len(mmDeleteTag.expectations) == 0 && mmDeleteTag.defaultExpectation == nil && mmDeleteTag.mock.funcDeleteTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteTag.mock.afterDeleteTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteTag implements mm_service.RegistryClient
func (mmDeleteTag *RegistryClientMock) DeleteTag(ctx context.Context, repository string, digest string) (err error) {
	mm_atomic.AddUint64(&mmDeleteTag.beforeDeleteTagCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteTag.afterDeleteTagCounter, 1)

	mmDeleteTag.t.Helper()

	if mmDeleteTag.inspectFuncDeleteTag != nil {
		mmDeleteTag.inspectFuncDeleteTag(ctx, repository, digest)
	}

	mm_params := RegistryClientMockDeleteTagParams{ctx, repository, digest}

	// Record call args
	mmDeleteTag.DeleteTagMock.mutex.Lock()
	mmDeleteTag.DeleteTagMock.callArgs = append(mmDeleteTag.DeleteTagMock.callArgs, &mm_params)
	mmDeleteTag.DeleteTagMock.mutex.Unlock()

	for _, e := range mmDeleteTag.DeleteTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteTag.DeleteTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteTag.DeleteTagMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteTag.DeleteTagMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteTag.DeleteTagMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockDeleteTagParams{ctx, repository, digest}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteTag.t.Errorf("RegistryClientMock.DeleteTag got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteTag.DeleteTagMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.repository != nil && !minimock.Equal(*mm_want_ptrs.repository, mm_got.repository) {
				mmDeleteTag.t.Errorf("RegistryClientMock.DeleteTag got unexpected parameter repository, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteTag.DeleteTagMock.defaultExpectation.expectationOrigins.originRepository, *mm_want_ptrs.repository, mm_got.repository, minimock.Diff(*mm_want_ptrs.repository, mm_got.repository))
			}

			if mm_want_ptrs.digest != nil && !minimock.Equal(*mm_want_ptrs.digest, mm_got.digest) {
				mmDeleteTag.t.Errorf("RegistryClientMock.DeleteTag got unexpected parameter digest, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteTag.DeleteTagMock.defaultExpectation.expectationOrigins.originDigest, *mm_want_ptrs.digest, mm_got.digest, minimock.Diff(*mm_want_ptrs.digest, mm_got.digest))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteTag.t.Errorf("RegistryClientMock.DeleteTag got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteTag.DeleteTagMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteTag.DeleteTagMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteTag.t.Fatal("No results are set for the RegistryClientMock.DeleteTag")
		}
		return (*mm_results).err
	}
	if mmDeleteTag.funcDeleteTag != nil {
		return mmDeleteTag.funcDeleteTag(ctx, repository, digest)
	}
	mmDeleteTag.t.Fatalf("Unexpected call to RegistryClientMock.DeleteTag. %v %v %v", ctx, repository, digest)
	return
}

// DeleteTagAfterCounter returns a count of finished RegistryClientMock.DeleteTag invocations
func (mmDeleteTag *RegistryClientMock) DeleteTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteTag.afterDeleteTagCounter)
}

// DeleteTagBeforeCounter returns a count of RegistryClientMock.DeleteTag invocations
func (mmDeleteTag *RegistryClientMock) DeleteTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteTag.beforeDeleteTagCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.DeleteTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteTag *mRegistryClientMockDeleteTag) Calls() []*RegistryClientMockDeleteTagParams {
	mmDeleteTag.mutex.RLock()

	argCopy := make([]*RegistryClientMockDeleteTagParams, len(mmDeleteTag.callArgs))
	copy(argCopy, mmDeleteTag.callArgs)

	mmDeleteTag.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteTagDone returns true if the count of the DeleteTag invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockDeleteTagDone() bool {
	if m.DeleteTagMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteTagMock.invocationsDone()
}

// MinimockDeleteTagInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockDeleteTagInspect() {
	for _, e := range m.DeleteTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.DeleteTag at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteTagCounter := mm_atomic.LoadUint64(&m.afterDeleteTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteTagMock.defaultExpectation != nil && afterDeleteTagCounter < 1 {
		if m.DeleteTagMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.DeleteTag at\n%s", m.DeleteTagMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.DeleteTag at\n%s with params: %#v", m.DeleteTagMock.defaultExpectation.expectationOrigins.origin, *m.DeleteTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteTag != nil && afterDeleteTagCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.DeleteTag at\n%s", m.funcDeleteTagOrigin)
	}

	if !m.DeleteTagMock.invocationsDone() && afterDeleteTagCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.DeleteTag at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteTagMock.expectedInvocations), m.DeleteTagMock.expectedInvocationsOrigin, afterDeleteTagCounter)
	}
}

type mRegistryClientMockGetTagDigest struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockGetTagDigestExpectation
	expectations       []*RegistryClientMockGetTagDigestExpectation

	callArgs []*RegistryClientMockGetTagDigestParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockGetTagDigestExpectation specifies expectation struct of the RegistryClient.GetTagDigest
type RegistryClientMockGetTagDigestExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockGetTagDigestParams
	paramPtrs          *RegistryClientMockGetTagDigestParamPtrs
	expectationOrigins RegistryClientMockGetTagDigestExpectationOrigins
	results            *RegistryClientMockGetTagDigestResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockGetTagDigestParams contains parameters of the RegistryClient.GetTagDigest
type RegistryClientMockGetTagDigestParams struct {
	ctx        context.Context
	repository string
	tag        string
}

// RegistryClientMockGetTagDigestParamPtrs contains pointers to parameters of the RegistryClient.GetTagDigest
type RegistryClientMockGetTagDigestParamPtrs struct {
	ctx        *context.Context
	repository *string
	tag        *string
}

// RegistryClientMockGetTagDigestResults contains results of the RegistryClient.GetTagDigest
type RegistryClientMockGetTagDigestResults struct {
	digest string
	err    error
}

// RegistryClientMockGetTagDigestOrigins contains origins of expectations of the RegistryClient.GetTagDigest
type RegistryClientMockGetTagDigestExpectationOrigins struct {
	origin           string
	originCtx        string
	originRepository string
	originTag        string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetTagDigest *mRegistryClientMockGetTagDigest) Optional() *mRegistryClientMockGetTagDigest {
	mmGetTagDigest.optional = true
	return mmGetTagDigest
}

// Expect sets up expected params for RegistryClient.GetTagDigest
func (mmGetTagDigest *mRegistryClientMockGetTagDigest) Expect(ctx context.Context, repository string, tag string) *mRegistryClientMockGetTagDigest {
	if mmGetTagDigest.mock.funcGetTagDigest != nil {
		mmGetTagDigest.mock.t.Fatalf("RegistryClientMock.GetTagDigest mock is already set by Set")
	}

	if mmGetTagDigest.defaultExpectation == nil {
		mmGetTagDigest.defaultExpectation = &RegistryClientMockGetTagDigestExpectation{}
	}

	if mmGetTagDigest.defaultExpectation.paramPtrs != nil {
		mmGetTagDigest.mock.t.Fatalf("RegistryClientMock.GetTagDigest mock is already set by ExpectParams functions")
	}

	mmGetTagDigest.defaultExpectation.params = &RegistryClientMockGetTagDigestParams{ctx, repository, tag}
	mmGetTagDigest.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetTagDigest.expectations {
		if minimock.Equal(e.params, mmGetTagDigest.defaultExpectation.params) {
			mmGetTagDigest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTagDigest.defaultExpectation.params)
		}
	}

	return mmGetTagDigest
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.GetTagDigest
func (mmGetTagDigest *mRegistryClientMockGetTagDigest) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockGetTagDigest {
	if mmGetTagDigest.mock.funcGetTagDigest != nil {
		mmGetTagDigest.mock.t.Fatalf("RegistryClientMock.GetTagDigest mock is already set by Set")
	}

	if mmGetTagDigest.defaultExpectation == nil {
		mmGetTagDigest.defaultExpectation = &RegistryClientMockGetTagDigestExpectation{}
	}

	if mmGetTagDigest.defaultExpectation.params != nil {
		mmGetTagDigest.mock.t.Fatalf("RegistryClientMock.GetTagDigest mock is already set by Expect")
	}

	if mmGetTagDigest.defaultExpectation.paramPtrs == nil {
		mmGetTagDigest.defaultExpectation.paramPtrs = &RegistryClientMockGetTagDigestParamPtrs{}
	}
	mmGetTagDigest.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetTagDigest.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetTagDigest
}

// ExpectRepositoryParam2 sets up expected param repository for RegistryClient.GetTagDigest
func (mmGetTagDigest *mRegistryClientMockGetTagDigest) ExpectRepositoryParam2(repository string) *mRegistryClientMockGetTagDigest {
	if mmGetTagDigest.mock.funcGetTagDigest != nil {
		mmGetTagDigest.mock.t.Fatalf("RegistryClientMock.GetTagDigest mock is already set by Set")
	}

	if mmGetTagDigest.defaultExpectation == nil {
		mmGetTagDigest.defaultExpectation = &RegistryClientMockGetTagDigestExpectation{}
	}

	if mmGetTagDigest.defaultExpectation.params != nil {
		mmGetTagDigest.mock.t.Fatalf("RegistryClientMock.GetTagDigest mock is already set by Expect")
	}

	if mmGetTagDigest.defaultExpectation.paramPtrs == nil {
		mmGetTagDigest.defaultExpectation.paramPtrs = &RegistryClientMockGetTagDigestParamPtrs{}
	}
	mmGetTagDigest.defaultExpectation.paramPtrs.repository = &repository
	mmGetTagDigest.defaultExpectation.expectationOrigins.originRepository = minimock.CallerInfo(1)

	return mmGetTagDigest
}

// ExpectTagParam3 sets up expected param tag for RegistryClient.GetTagDigest
func (mmGetTagDigest *mRegistryClientMockGetTagDigest) ExpectTagParam3(tag string) *mRegistryClientMockGetTagDigest {
	if mmGetTagDigest.mock.funcGetTagDigest != nil {
		mmGetTagDigest.mock.t.Fatalf("RegistryClientMock.GetTagDigest mock is already set by Set")
	}

	if mmGetTagDigest.defaultExpectation == nil {
		mmGetTagDigest.defaultExpectation = &RegistryClientMockGetTagDigestExpectation{}
	}

	if mmGetTagDigest.defaultExpectation.params != nil {
		mmGetTagDigest.mock.t.Fatalf("RegistryClientMock.GetTagDigest mock is already set by Expect")
	}

	if mmGetTagDigest.defaultExpectation.paramPtrs == nil {
		mmGetTagDigest.defaultExpectation.paramPtrs = &RegistryClientMockGetTagDigestParamPtrs{}
	}
	mmGetTagDigest.defaultExpectation.paramPtrs.tag = &tag
	mmGetTagDigest.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmGetTagDigest
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.GetTagDigest
func (mmGetTagDigest *mRegistryClientMockGetTagDigest) Inspect(f func(ctx context.Context, repository string, tag string)) *mRegistryClientMockGetTagDigest {
	if mmGetTagDigest.mock.inspectFuncGetTagDigest != nil {
		mmGetTagDigest.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.GetTagDigest")
	}

	mmGetTagDigest.mock.inspectFuncGetTagDigest = f

	return mmGetTagDigest
}

// Return sets up results that will be returned by RegistryClient.GetTagDigest
func (mmGetTagDigest *mRegistryClientMockGetTagDigest) Return(digest string, err error) *RegistryClientMock {
	if mmGetTagDigest.mock.funcGetTagDigest != nil {
		mmGetTagDigest.mock.t.Fatalf("RegistryClientMock.GetTagDigest mock is already set by Set")
	}

	if mmGetTagDigest.defaultExpectation == nil {
		mmGetTagDigest.defaultExpectation = &RegistryClientMockGetTagDigestExpectation{mock: mmGetTagDigest.mock}
	}
	mmGetTagDigest.defaultExpectation.results = &RegistryClientMockGetTagDigestResults{digest, err}
	mmGetTagDigest.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetTagDigest.mock
}

// Set uses given function f to mock the RegistryClient.GetTagDigest method
func (mmGetTagDigest *mRegistryClientMockGetTagDigest) Set(f func(ctx context.Context, repository string, tag string) (digest string, err error)) *RegistryClientMock {
	if mmGetTagDigest.defaultExpectation != nil {
		mmGetTagDigest.mock.t.Fatalf("Default expectation is already set for the RegistryClient.GetTagDigest method")
	}

	if len(mmGetTagDigest.expectations) > 0 {
		mmGetTagDigest.mock.t.Fatalf("Some expectations are already set for the RegistryClient.GetTagDigest method")
	}

	mmGetTagDigest.mock.funcGetTagDigest = f
	mmGetTagDigest.mock.funcGetTagDigestOrigin = minimock.CallerInfo(1)
	return mmGetTagDigest.mock
}

// When sets expectation for the RegistryClient.GetTagDigest which will trigger the result defined by the following
// Then helper
func (mmGetTagDigest *mRegistryClientMockGetTagDigest) When(ctx context.Context, repository string, tag string) *RegistryClientMockGetTagDigestExpectation {
	if mmGetTagDigest.mock.funcGetTagDigest != nil {
		mmGetTagDigest.mock.t.Fatalf("RegistryClientMock.GetTagDigest mock is already set by Set")
	}

	expectation := &RegistryClientMockGetTagDigestExpectation{
		mock:               mmGetTagDigest.mock,
		params:             &RegistryClientMockGetTagDigestParams{ctx, repository, tag},
		expectationOrigins: RegistryClientMockGetTagDigestExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetTagDigest.expectations = append(mmGetTagDigest.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.GetTagDigest return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockGetTagDigestExpectation) Then(digest string, err error) *RegistryClientMock {
	e.results = &RegistryClientMockGetTagDigestResults{digest, err}
	return e.mock
}

// Times sets number of times RegistryClient.GetTagDigest should be invoked
func (mmGetTagDigest *mRegistryClientMockGetTagDigest) Times(n uint64) *mRegistryClientMockGetTagDigest {
	if n == 0 {
		mmGetTagDigest.mock.t.Fatalf("Times of RegistryClientMock.GetTagDigest mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTagDigest.expectedInvocations, n)
	mmGetTagDigest.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetTagDigest
}

func (mmGetTagDigest *mRegistryClientMockGetTagDigest) invocationsDone() bool {
	if len(mmGetTagDigest.expectations) == 0 && mmGetTagDigest.defaultExpectation == nil && mmGetTagDigest.mock.funcGetTagDigest == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTagDigest.mock.afterGetTagDigestCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTagDigest.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTagDigest implements mm_service.RegistryClient
func (mmGetTagDigest *RegistryClientMock) GetTagDigest(ctx context.Context, repository string, tag string) (digest string, err error) {
	mm_atomic.AddUint64(&mmGetTagDigest.beforeGetTagDigestCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTagDigest.afterGetTagDigestCounter, 1)

	mmGetTagDigest.t.Helper()

	if mmGetTagDigest.inspectFuncGetTagDigest != nil {
		mmGetTagDigest.inspectFuncGetTagDigest(ctx, repository, tag)
	}

	mm_params := RegistryClientMockGetTagDigestParams{ctx, repository, tag}

	// Record call args
	mmGetTagDigest.GetTagDigestMock.mutex.Lock()
	mmGetTagDigest.GetTagDigestMock.callArgs = append(mmGetTagDigest.GetTagDigestMock.callArgs, &mm_params)
	mmGetTagDigest.GetTagDigestMock.mutex.Unlock()

	for _, e := range mmGetTagDigest.GetTagDigestMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.digest, e.results.err
		}
	}

	if mmGetTagDigest.GetTagDigestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTagDigest.GetTagDigestMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTagDigest.GetTagDigestMock.defaultExpectation.params
		mm_want_ptrs := mmGetTagDigest.GetTagDigestMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockGetTagDigestParams{ctx, repository, tag}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTagDigest.t.Errorf("RegistryClientMock.GetTagDigest got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTagDigest.GetTagDigestMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.repository != nil && !minimock.Equal(*mm_want_ptrs.repository, mm_got.repository) {
				mmGetTagDigest.t.Errorf("RegistryClientMock.GetTagDigest got unexpected parameter repository, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTagDigest.GetTagDigestMock.defaultExpectation.expectationOrigins.originRepository, *mm_want_ptrs.repository, mm_got.repository, minimock.Diff(*mm_want_ptrs.repository, mm_got.repository))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmGetTagDigest.t.Errorf("RegistryClientMock.GetTagDigest got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTagDigest.GetTagDigestMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTagDigest.t.Errorf("RegistryClientMock.GetTagDigest got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetTagDigest.GetTagDigestMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTagDigest.GetTagDigestMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTagDigest.t.Fatal("No results are set for the RegistryClientMock.GetTagDigest")
		}
		return (*mm_results).digest, (*mm_results).err
	}
	if mmGetTagDigest.funcGetTagDigest != nil {
		return mmGetTagDigest.funcGetTagDigest(ctx, repository, tag)
	}
	mmGetTagDigest.t.Fatalf("Unexpected call to RegistryClientMock.GetTagDigest. %v %v %v", ctx, repository, tag)
	return
}

// GetTagDigestAfterCounter returns a count of finished RegistryClientMock.GetTagDigest invocations
func (mmGetTagDigest *RegistryClientMock) GetTagDigestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTagDigest.afterGetTagDigestCounter)
}

// GetTagDigestBeforeCounter returns a count of RegistryClientMock.GetTagDigest invocations
func (mmGetTagDigest *RegistryClientMock) GetTagDigestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTagDigest.beforeGetTagDigestCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.GetTagDigest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTagDigest *mRegistryClientMockGetTagDigest) Calls() []*RegistryClientMockGetTagDigestParams {
	mmGetTagDigest.mutex.RLock()

	argCopy := make([]*RegistryClientMockGetTagDigestParams, len(mmGetTagDigest.callArgs))
	copy(argCopy, mmGetTagDigest.callArgs)

	mmGetTagDigest.mutex.RUnlock()

	return argCopy
}

// MinimockGetTagDigestDone returns true if the count of the GetTagDigest invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockGetTagDigestDone() bool {
	if m.GetTagDigestMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetTagDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTagDigestMock.invocationsDone()
}

// MinimockGetTagDigestInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockGetTagDigestInspect() {
	for _, e := range m.GetTagDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.GetTagDigest at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetTagDigestCounter := mm_atomic.LoadUint64(&m.afterGetTagDigestCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTagDigestMock.defaultExpectation != nil && afterGetTagDigestCounter < 1 {
		if m.GetTagDigestMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.GetTagDigest at\n%s", m.GetTagDigestMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.GetTagDigest at\n%s with params: %#v", m.GetTagDigestMock.defaultExpectation.expectationOrigins.origin, *m.GetTagDigestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTagDigest != nil && afterGetTagDigestCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.GetTagDigest at\n%s", m.funcGetTagDigestOrigin)
	}

	if !m.GetTagDigestMock.invocationsDone() && afterGetTagDigestCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.GetTagDigest at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetTagDigestMock.expectedInvocations), m.GetTagDigestMock.expectedInvocationsOrigin, afterGetTagDigestCounter)
	}
}

type mRegistryClientMockListTags struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockListTagsExpectation
	expectations       []*RegistryClientMockListTagsExpectation

	callArgs []*RegistryClientMockListTagsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockListTagsExpectation specifies expectation struct of the RegistryClient.ListTags
type RegistryClientMockListTagsExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockListTagsParams
	paramPtrs          *RegistryClientMockListTagsParamPtrs
	expectationOrigins RegistryClientMockListTagsExpectationOrigins
	results            *RegistryClientMockListTagsResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockListTagsParams contains parameters of the RegistryClient.ListTags
type RegistryClientMockListTagsParams struct {
	ctx        context.Context
	repository string
}

// RegistryClientMockListTagsParamPtrs contains pointers to parameters of the RegistryClient.ListTags
type RegistryClientMockListTagsParamPtrs struct {
	ctx        *context.Context
	repository *string
}

// RegistryClientMockListTagsResults contains results of the RegistryClient.ListTags
type RegistryClientMockListTagsResults struct {
	tags []string
	err  error
}

// RegistryClientMockListTagsOrigins contains origins of expectations of the RegistryClient.ListTags
type RegistryClientMockListTagsExpectationOrigins struct {
	origin           string
	originCtx        string
	originRepository string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListTags *mRegistryClientMockListTags) Optional() *mRegistryClientMockListTags {
	mmListTags.optional = true
	return mmListTags
}

// Expect sets up expected params for RegistryClient.ListTags
func (mmListTags *mRegistryClientMockListTags) Expect(ctx context.Context, repository string) *mRegistryClientMockListTags {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &RegistryClientMockListTagsExpectation{}
	}

	if mmListTags.defaultExpectation.paramPtrs != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by ExpectParams functions")
	}

	mmListTags.defaultExpectation.params = &RegistryClientMockListTagsParams{ctx, repository}
	mmListTags.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListTags.expectations {
		if minimock.Equal(e.params, mmListTags.defaultExpectation.params) {
			mmListTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListTags.defaultExpectation.params)
		}
	}

	return mmListTags
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.ListTags
func (mmListTags *mRegistryClientMockListTags) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockListTags {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &RegistryClientMockListTagsExpectation{}
	}

	if mmListTags.defaultExpectation.params != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Expect")
	}

	if mmListTags.defaultExpectation.paramPtrs == nil {
		mmListTags.defaultExpectation.paramPtrs = &RegistryClientMockListTagsParamPtrs{}
	}
	mmListTags.defaultExpectation.paramPtrs.ctx = &ctx
	mmListTags.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListTags
}

// ExpectRepositoryParam2 sets up expected param repository for RegistryClient.ListTags
func (mmListTags *mRegistryClientMockListTags) ExpectRepositoryParam2(repository string) *mRegistryClientMockListTags {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &RegistryClientMockListTagsExpectation{}
	}

	if mmListTags.defaultExpectation.params != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Expect")
	}

	if mmListTags.defaultExpectation.paramPtrs == nil {
		mmListTags.defaultExpectation.paramPtrs = &RegistryClientMockListTagsParamPtrs{}
	}
	mmListTags.defaultExpectation.paramPtrs.repository = &repository
	mmListTags.defaultExpectation.expectationOrigins.originRepository = minimock.CallerInfo(1)

	return mmListTags
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.ListTags
func (mmListTags *mRegistryClientMockListTags) Inspect(f func(ctx context.Context, repository string)) *mRegistryClientMockListTags {
	if mmListTags.mock.inspectFuncListTags != nil {
		mmListTags.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.ListTags")
	}

	mmListTags.mock.inspectFuncListTags = f

	return mmListTags
}

// Return sets up results that will be returned by RegistryClient.ListTags
func (mmListTags *mRegistryClientMockListTags) Return(tags []string, err error) *RegistryClientMock {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &RegistryClientMockListTagsExpectation{mock: mmListTags.mock}
	}
	mmListTags.defaultExpectation.results = &RegistryClientMockListTagsResults{tags, err}
	mmListTags.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListTags.mock
}

// Set uses given function f to mock the RegistryClient.ListTags method
func (mmListTags *mRegistryClientMockListTags) Set(f func(ctx context.Context, repository string) (tags []string, err error)) *RegistryClientMock {
	if mmListTags.defaultExpectation != nil {
		mmListTags.mock.t.Fatalf("Default expectation is already set for the RegistryClient.ListTags method")
	}

	if len(mmListTags.expectations) > 0 {
		mmListTags.mock.t.Fatalf("Some expectations are already set for the RegistryClient.ListTags method")
	}

	mmListTags.mock.funcListTags = f
	mmListTags.mock.funcListTagsOrigin = minimock.CallerInfo(1)
	return mmListTags.mock
}

// When sets expectation for the RegistryClient.ListTags which will trigger the result defined by the following
// Then helper
func (mmListTags *mRegistryClientMockListTags) When(ctx context.Context, repository string) *RegistryClientMockListTagsExpectation {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Set")
	}

	expectation := &RegistryClientMockListTagsExpectation{
		mock:               mmListTags.mock,
		params:             &RegistryClientMockListTagsParams{ctx, repository},
		expectationOrigins: RegistryClientMockListTagsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListTags.expectations = append(mmListTags.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.ListTags return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockListTagsExpectation) Then(tags []string, err error) *RegistryClientMock {
	e.results = &RegistryClientMockListTagsResults{tags, err}
	return e.mock
}

// Times sets number of times RegistryClient.ListTags should be invoked
func (mmListTags *mRegistryClientMockListTags) Times(n uint64) *mRegistryClientMockListTags {
	if n == 0 {
		mmListTags.mock.t.Fatalf("Times of RegistryClientMock.ListTags mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListTags.expectedInvocations, n)
	mmListTags.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListTags
}

func (mmListTags *mRegistryClientMockListTags) invocationsDone() bool {
	if len(mmListTags.expectations) == 0 && mmListTags.defaultExpectation == nil && mmListTags.mock.funcListTags == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListTags.mock.afterListTagsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListTags.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListTags implements mm_service.RegistryClient
func (mmListTags *RegistryClientMock) ListTags(ctx context.Context, repository string) (tags []string, err error) {
	mm_atomic.AddUint64(&mmListTags.beforeListTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmListTags.afterListTagsCounter, 1)

	mmListTags.t.Helper()

	if mmListTags.inspectFuncListTags != nil {
		mmListTags.inspectFuncListTags(ctx, repository)
	}

	mm_params := RegistryClientMockListTagsParams{ctx, repository}

	// Record call args
	mmListTags.ListTagsMock.mutex.Lock()
	mmListTags.ListTagsMock.callArgs = append(mmListTags.ListTagsMock.callArgs, &mm_params)
	mmListTags.ListTagsMock.mutex.Unlock()

	for _, e := range mmListTags.ListTagsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tags, e.results.err
		}
	}

	if mmListTags.ListTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListTags.ListTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmListTags.ListTagsMock.defaultExpectation.params
		mm_want_ptrs := mmListTags.ListTagsMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockListTagsParams{ctx, repository}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListTags.t.Errorf("RegistryClientMock.ListTags got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTags.ListTagsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.repository != nil && !minimock.Equal(*mm_want_ptrs.repository, mm_got.repository) {
				mmListTags.t.Errorf("RegistryClientMock.ListTags got unexpected parameter repository, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTags.ListTagsMock.defaultExpectation.expectationOrigins.originRepository, *mm_want_ptrs.repository, mm_got.repository, minimock.Diff(*mm_want_ptrs.repository, mm_got.repository))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListTags.t.Errorf("RegistryClientMock.ListTags got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListTags.ListTagsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListTags.ListTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmListTags.t.Fatal("No results are set for the RegistryClientMock.ListTags")
		}
		return (*mm_results).tags, (*mm_results).err
	}
	if mmListTags.funcListTags != nil {
		return mmListTags.funcListTags(ctx, repository)
	}
	mmListTags.t.Fatalf("Unexpected call to RegistryClientMock.ListTags. %v %v", ctx, repository)
	return
}

// ListTagsAfterCounter returns a count of finished RegistryClientMock.ListTags invocations
func (mmListTags *RegistryClientMock) ListTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTags.afterListTagsCounter)
}

// ListTagsBeforeCounter returns a count of RegistryClientMock.ListTags invocations
func (mmListTags *RegistryClientMock) ListTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTags.beforeListTagsCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.ListTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListTags *mRegistryClientMockListTags) Calls() []*RegistryClientMockListTagsParams {
	mmListTags.mutex.RLock()

	argCopy := make([]*RegistryClientMockListTagsParams, len(mmListTags.callArgs))
	copy(argCopy, mmListTags.callArgs)

	mmListTags.mutex.RUnlock()

	return argCopy
}

// MinimockListTagsDone returns true if the count of the ListTags invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockListTagsDone() bool {
	if m.ListTagsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListTagsMock.invocationsDone()
}

// MinimockListTagsInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockListTagsInspect() {
	for _, e := range m.ListTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.ListTags at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListTagsCounter := mm_atomic.LoadUint64(&m.afterListTagsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListTagsMock.defaultExpectation != nil && afterListTagsCounter < 1 {
		if m.ListTagsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.ListTags at\n%s", m.ListTagsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.ListTags at\n%s with params: %#v", m.ListTagsMock.defaultExpectation.expectationOrigins.origin, *m.ListTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListTags != nil && afterListTagsCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.ListTags at\n%s", m.funcListTagsOrigin)
	}

	if !m.ListTagsMock.invocationsDone() && afterListTagsCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.ListTags at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListTagsMock.expectedInvocations), m.ListTagsMock.expectedInvocationsOrigin, afterListTagsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RegistryClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDeleteTagInspect()

			m.MinimockGetTagDigestInspect()

			m.MinimockListTagsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RegistryClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RegistryClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeleteTagDone() &&
		m.MinimockGetTagDigestDone() &&
		m.MinimockListTagsDone()
}
