// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_repository "github.com/instill-ai/artifact-backend/pkg/repository"
	"github.com/instill-ai/artifact-backend/pkg/repository/object"
	"github.com/instill-ai/artifact-backend/pkg/types"
	"github.com/instill-ai/artifact-backend/pkg/utils"
	artifactpb "github.com/instill-ai/protogen-go/artifact/artifact/v1alpha"
	"gorm.io/gorm"
)

// RepositoryMock implements mm_repository.Repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCheckFileUIDMetadata          func(ctx context.Context, collectionID string) (b1 bool, err error)
	funcCheckFileUIDMetadataOrigin    string
	inspectFuncCheckFileUIDMetadata   func(ctx context.Context, collectionID string)
	afterCheckFileUIDMetadataCounter  uint64
	beforeCheckFileUIDMetadataCounter uint64
	CheckFileUIDMetadataMock          mRepositoryMockCheckFileUIDMetadata

	funcCheckGCSFileExists          func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, view string) (b1 bool, err error)
	funcCheckGCSFileExistsOrigin    string
	inspectFuncCheckGCSFileExists   func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, view string)
	afterCheckGCSFileExistsCounter  uint64
	beforeCheckGCSFileExistsCounter uint64
	CheckGCSFileExistsMock          mRepositoryMockCheckGCSFileExists

	funcCollectionExists          func(ctx context.Context, collectionID string) (b1 bool, err error)
	funcCollectionExistsOrigin    string
	inspectFuncCollectionExists   func(ctx context.Context, collectionID string)
	afterCollectionExistsCounter  uint64
	beforeCollectionExistsCounter uint64
	CollectionExistsMock          mRepositoryMockCollectionExists

	funcCreateCollection          func(ctx context.Context, id string, dimensionality uint32) (err error)
	funcCreateCollectionOrigin    string
	inspectFuncCreateCollection   func(ctx context.Context, id string, dimensionality uint32)
	afterCreateCollectionCounter  uint64
	beforeCreateCollectionCounter uint64
	CreateCollectionMock          mRepositoryMockCreateCollection

	funcCreateConvertedFileWithDestination          func(ctx context.Context, cf mm_repository.ConvertedFileModel) (cp1 *mm_repository.ConvertedFileModel, err error)
	funcCreateConvertedFileWithDestinationOrigin    string
	inspectFuncCreateConvertedFileWithDestination   func(ctx context.Context, cf mm_repository.ConvertedFileModel)
	afterCreateConvertedFileWithDestinationCounter  uint64
	beforeCreateConvertedFileWithDestinationCounter uint64
	CreateConvertedFileWithDestinationMock          mRepositoryMockCreateConvertedFileWithDestination

	funcCreateEmbeddings          func(ctx context.Context, embeddings []mm_repository.EmbeddingModel, externalServiceCall func([]mm_repository.EmbeddingModel) error) (ea1 []mm_repository.EmbeddingModel, err error)
	funcCreateEmbeddingsOrigin    string
	inspectFuncCreateEmbeddings   func(ctx context.Context, embeddings []mm_repository.EmbeddingModel, externalServiceCall func([]mm_repository.EmbeddingModel) error)
	afterCreateEmbeddingsCounter  uint64
	beforeCreateEmbeddingsCounter uint64
	CreateEmbeddingsMock          mRepositoryMockCreateEmbeddings

	funcCreateKnowledgeBase          func(ctx context.Context, kb mm_repository.KnowledgeBaseModel, externalService func(kbUID types.KBUIDType, collectionUID types.KBUIDType) error) (kp1 *mm_repository.KnowledgeBaseModel, err error)
	funcCreateKnowledgeBaseOrigin    string
	inspectFuncCreateKnowledgeBase   func(ctx context.Context, kb mm_repository.KnowledgeBaseModel, externalService func(kbUID types.KBUIDType, collectionUID types.KBUIDType) error)
	afterCreateKnowledgeBaseCounter  uint64
	beforeCreateKnowledgeBaseCounter uint64
	CreateKnowledgeBaseMock          mRepositoryMockCreateKnowledgeBase

	funcCreateKnowledgeBaseFile          func(ctx context.Context, kb mm_repository.KnowledgeBaseFileModel, externalServiceCall func(fileUID string) error) (kp1 *mm_repository.KnowledgeBaseFileModel, err error)
	funcCreateKnowledgeBaseFileOrigin    string
	inspectFuncCreateKnowledgeBaseFile   func(ctx context.Context, kb mm_repository.KnowledgeBaseFileModel, externalServiceCall func(fileUID string) error)
	afterCreateKnowledgeBaseFileCounter  uint64
	beforeCreateKnowledgeBaseFileCounter uint64
	CreateKnowledgeBaseFileMock          mRepositoryMockCreateKnowledgeBaseFile

	funcCreateObject          func(ctx context.Context, obj mm_repository.ObjectModel) (op1 *mm_repository.ObjectModel, err error)
	funcCreateObjectOrigin    string
	inspectFuncCreateObject   func(ctx context.Context, obj mm_repository.ObjectModel)
	afterCreateObjectCounter  uint64
	beforeCreateObjectCounter uint64
	CreateObjectMock          mRepositoryMockCreateObject

	funcCreateStagingKnowledgeBase          func(ctx context.Context, original *mm_repository.KnowledgeBaseModel, newSystemUID *types.SystemUIDType, externalService func(kbUID types.KBUIDType, collectionUID types.KBUIDType) error) (kp1 *mm_repository.KnowledgeBaseModel, err error)
	funcCreateStagingKnowledgeBaseOrigin    string
	inspectFuncCreateStagingKnowledgeBase   func(ctx context.Context, original *mm_repository.KnowledgeBaseModel, newSystemUID *types.SystemUIDType, externalService func(kbUID types.KBUIDType, collectionUID types.KBUIDType) error)
	afterCreateStagingKnowledgeBaseCounter  uint64
	beforeCreateStagingKnowledgeBaseCounter uint64
	CreateStagingKnowledgeBaseMock          mRepositoryMockCreateStagingKnowledgeBase

	funcCreateSystem          func(ctx context.Context, id string, config map[string]any, description string) (err error)
	funcCreateSystemOrigin    string
	inspectFuncCreateSystem   func(ctx context.Context, id string, config map[string]any, description string)
	afterCreateSystemCounter  uint64
	beforeCreateSystemCounter uint64
	CreateSystemMock          mRepositoryMockCreateSystem

	funcCreateTextChunks          func(ctx context.Context, textChunks []*mm_repository.TextChunkModel) (err error)
	funcCreateTextChunksOrigin    string
	inspectFuncCreateTextChunks   func(ctx context.Context, textChunks []*mm_repository.TextChunkModel)
	afterCreateTextChunksCounter  uint64
	beforeCreateTextChunksCounter uint64
	CreateTextChunksMock          mRepositoryMockCreateTextChunks

	funcDeleteAllConvertedFilesInKb          func(ctx context.Context, kbUID types.KBUIDType) (err error)
	funcDeleteAllConvertedFilesInKbOrigin    string
	inspectFuncDeleteAllConvertedFilesInKb   func(ctx context.Context, kbUID types.KBUIDType)
	afterDeleteAllConvertedFilesInKbCounter  uint64
	beforeDeleteAllConvertedFilesInKbCounter uint64
	DeleteAllConvertedFilesInKbMock          mRepositoryMockDeleteAllConvertedFilesInKb

	funcDeleteAllKnowledgeBaseFiles          func(ctx context.Context, kbUID string) (err error)
	funcDeleteAllKnowledgeBaseFilesOrigin    string
	inspectFuncDeleteAllKnowledgeBaseFiles   func(ctx context.Context, kbUID string)
	afterDeleteAllKnowledgeBaseFilesCounter  uint64
	beforeDeleteAllKnowledgeBaseFilesCounter uint64
	DeleteAllKnowledgeBaseFilesMock          mRepositoryMockDeleteAllKnowledgeBaseFiles

	funcDeleteAndCreateEmbeddings          func(ctx context.Context, fileUID types.FileUIDType, embeddings []mm_repository.EmbeddingModel, externalServiceCall func([]mm_repository.EmbeddingModel) error) (ea1 []mm_repository.EmbeddingModel, err error)
	funcDeleteAndCreateEmbeddingsOrigin    string
	inspectFuncDeleteAndCreateEmbeddings   func(ctx context.Context, fileUID types.FileUIDType, embeddings []mm_repository.EmbeddingModel, externalServiceCall func([]mm_repository.EmbeddingModel) error)
	afterDeleteAndCreateEmbeddingsCounter  uint64
	beforeDeleteAndCreateEmbeddingsCounter uint64
	DeleteAndCreateEmbeddingsMock          mRepositoryMockDeleteAndCreateEmbeddings

	funcDeleteAndCreateTextChunks          func(ctx context.Context, fileUID types.FileUIDType, textChunks []*mm_repository.TextChunkModel, externalServiceCall func(chunkUIDs []string) (destinations map[string]string, _ error)) (tpa1 []*mm_repository.TextChunkModel, err error)
	funcDeleteAndCreateTextChunksOrigin    string
	inspectFuncDeleteAndCreateTextChunks   func(ctx context.Context, fileUID types.FileUIDType, textChunks []*mm_repository.TextChunkModel, externalServiceCall func(chunkUIDs []string) (destinations map[string]string, _ error))
	afterDeleteAndCreateTextChunksCounter  uint64
	beforeDeleteAndCreateTextChunksCounter uint64
	DeleteAndCreateTextChunksMock          mRepositoryMockDeleteAndCreateTextChunks

	funcDeleteCacheMetadata          func(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType) (err error)
	funcDeleteCacheMetadataOrigin    string
	inspectFuncDeleteCacheMetadata   func(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType)
	afterDeleteCacheMetadataCounter  uint64
	beforeDeleteCacheMetadataCounter uint64
	DeleteCacheMetadataMock          mRepositoryMockDeleteCacheMetadata

	funcDeleteConvertedFile          func(ctx context.Context, uid types.ConvertedFileUIDType) (err error)
	funcDeleteConvertedFileOrigin    string
	inspectFuncDeleteConvertedFile   func(ctx context.Context, uid types.ConvertedFileUIDType)
	afterDeleteConvertedFileCounter  uint64
	beforeDeleteConvertedFileCounter uint64
	DeleteConvertedFileMock          mRepositoryMockDeleteConvertedFile

	funcDeleteEmbeddingsByKBFileUID          func(ctx context.Context, kbFileUID types.FileUIDType) (err error)
	funcDeleteEmbeddingsByKBFileUIDOrigin    string
	inspectFuncDeleteEmbeddingsByKBFileUID   func(ctx context.Context, kbFileUID types.FileUIDType)
	afterDeleteEmbeddingsByKBFileUIDCounter  uint64
	beforeDeleteEmbeddingsByKBFileUIDCounter uint64
	DeleteEmbeddingsByKBFileUIDMock          mRepositoryMockDeleteEmbeddingsByKBFileUID

	funcDeleteEmbeddingsWithFileUID          func(ctx context.Context, collID string, fileUID types.FileUIDType) (err error)
	funcDeleteEmbeddingsWithFileUIDOrigin    string
	inspectFuncDeleteEmbeddingsWithFileUID   func(ctx context.Context, collID string, fileUID types.FileUIDType)
	afterDeleteEmbeddingsWithFileUIDCounter  uint64
	beforeDeleteEmbeddingsWithFileUIDCounter uint64
	DeleteEmbeddingsWithFileUIDMock          mRepositoryMockDeleteEmbeddingsWithFileUID

	funcDeleteGCSFileCache          func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, view string) (err error)
	funcDeleteGCSFileCacheOrigin    string
	inspectFuncDeleteGCSFileCache   func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, view string)
	afterDeleteGCSFileCacheCounter  uint64
	beforeDeleteGCSFileCacheCounter uint64
	DeleteGCSFileCacheMock          mRepositoryMockDeleteGCSFileCache

	funcDeleteKnowledgeBase          func(ctx context.Context, ownerUID string, kbID string) (kp1 *mm_repository.KnowledgeBaseModel, err error)
	funcDeleteKnowledgeBaseOrigin    string
	inspectFuncDeleteKnowledgeBase   func(ctx context.Context, ownerUID string, kbID string)
	afterDeleteKnowledgeBaseCounter  uint64
	beforeDeleteKnowledgeBaseCounter uint64
	DeleteKnowledgeBaseMock          mRepositoryMockDeleteKnowledgeBase

	funcDeleteKnowledgeBaseFile          func(ctx context.Context, fileUID string) (err error)
	funcDeleteKnowledgeBaseFileOrigin    string
	inspectFuncDeleteKnowledgeBaseFile   func(ctx context.Context, fileUID string)
	afterDeleteKnowledgeBaseFileCounter  uint64
	beforeDeleteKnowledgeBaseFileCounter uint64
	DeleteKnowledgeBaseFileMock          mRepositoryMockDeleteKnowledgeBaseFile

	funcDeleteKnowledgeBaseFileAndDecreaseUsage          func(ctx context.Context, fileUID types.FileUIDType) (err error)
	funcDeleteKnowledgeBaseFileAndDecreaseUsageOrigin    string
	inspectFuncDeleteKnowledgeBaseFileAndDecreaseUsage   func(ctx context.Context, fileUID types.FileUIDType)
	afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter  uint64
	beforeDeleteKnowledgeBaseFileAndDecreaseUsageCounter uint64
	DeleteKnowledgeBaseFileAndDecreaseUsageMock          mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage

	funcDeleteKnowledgeBaseTx          func(ctx context.Context, tx *gorm.DB, owner string, kbID string) (err error)
	funcDeleteKnowledgeBaseTxOrigin    string
	inspectFuncDeleteKnowledgeBaseTx   func(ctx context.Context, tx *gorm.DB, owner string, kbID string)
	afterDeleteKnowledgeBaseTxCounter  uint64
	beforeDeleteKnowledgeBaseTxCounter uint64
	DeleteKnowledgeBaseTxMock          mRepositoryMockDeleteKnowledgeBaseTx

	funcDeleteObject          func(ctx context.Context, uid types.ObjectUIDType) (err error)
	funcDeleteObjectOrigin    string
	inspectFuncDeleteObject   func(ctx context.Context, uid types.ObjectUIDType)
	afterDeleteObjectCounter  uint64
	beforeDeleteObjectCounter uint64
	DeleteObjectMock          mRepositoryMockDeleteObject

	funcDeleteObjectByDestination          func(ctx context.Context, destination string) (err error)
	funcDeleteObjectByDestinationOrigin    string
	inspectFuncDeleteObjectByDestination   func(ctx context.Context, destination string)
	afterDeleteObjectByDestinationCounter  uint64
	beforeDeleteObjectByDestinationCounter uint64
	DeleteObjectByDestinationMock          mRepositoryMockDeleteObjectByDestination

	funcDeleteRepositoryTag          func(ctx context.Context, s1 string) (err error)
	funcDeleteRepositoryTagOrigin    string
	inspectFuncDeleteRepositoryTag   func(ctx context.Context, s1 string)
	afterDeleteRepositoryTagCounter  uint64
	beforeDeleteRepositoryTagCounter uint64
	DeleteRepositoryTagMock          mRepositoryMockDeleteRepositoryTag

	funcDeleteSystem          func(ctx context.Context, id string) (err error)
	funcDeleteSystemOrigin    string
	inspectFuncDeleteSystem   func(ctx context.Context, id string)
	afterDeleteSystemCounter  uint64
	beforeDeleteSystemCounter uint64
	DeleteSystemMock          mRepositoryMockDeleteSystem

	funcDropCollection          func(ctx context.Context, id string) (err error)
	funcDropCollectionOrigin    string
	inspectFuncDropCollection   func(ctx context.Context, id string)
	afterDropCollectionCounter  uint64
	beforeDropCollectionCounter uint64
	DropCollectionMock          mRepositoryMockDropCollection

	funcFlushCollection          func(ctx context.Context, collectionID string) (err error)
	funcFlushCollectionOrigin    string
	inspectFuncFlushCollection   func(ctx context.Context, collectionID string)
	afterFlushCollectionCounter  uint64
	beforeFlushCollectionCounter uint64
	FlushCollectionMock          mRepositoryMockFlushCollection

	funcGetActiveCollectionUID          func(ctx context.Context, kbUID types.KBUIDType) (kp1 *types.KBUIDType, err error)
	funcGetActiveCollectionUIDOrigin    string
	inspectFuncGetActiveCollectionUID   func(ctx context.Context, kbUID types.KBUIDType)
	afterGetActiveCollectionUIDCounter  uint64
	beforeGetActiveCollectionUIDCounter uint64
	GetActiveCollectionUIDMock          mRepositoryMockGetActiveCollectionUID

	funcGetAllConvertedFilesByFileUID          func(ctx context.Context, fileUID types.FileUIDType) (ca1 []mm_repository.ConvertedFileModel, err error)
	funcGetAllConvertedFilesByFileUIDOrigin    string
	inspectFuncGetAllConvertedFilesByFileUID   func(ctx context.Context, fileUID types.FileUIDType)
	afterGetAllConvertedFilesByFileUIDCounter  uint64
	beforeGetAllConvertedFilesByFileUIDCounter uint64
	GetAllConvertedFilesByFileUIDMock          mRepositoryMockGetAllConvertedFilesByFileUID

	funcGetCacheMetadata          func(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType) (cp1 *mm_repository.CacheMetadata, err error)
	funcGetCacheMetadataOrigin    string
	inspectFuncGetCacheMetadata   func(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType)
	afterGetCacheMetadataCounter  uint64
	beforeGetCacheMetadataCounter uint64
	GetCacheMetadataMock          mRepositoryMockGetCacheMetadata

	funcGetChunkCountByKBUID          func(ctx context.Context, kbUID types.KBUIDType) (i1 int64, err error)
	funcGetChunkCountByKBUIDOrigin    string
	inspectFuncGetChunkCountByKBUID   func(ctx context.Context, kbUID types.KBUIDType)
	afterGetChunkCountByKBUIDCounter  uint64
	beforeGetChunkCountByKBUIDCounter uint64
	GetChunkCountByKBUIDMock          mRepositoryMockGetChunkCountByKBUID

	funcGetConfigByID          func(ctx context.Context, id string) (sp1 *mm_repository.SystemConfigJSON, err error)
	funcGetConfigByIDOrigin    string
	inspectFuncGetConfigByID   func(ctx context.Context, id string)
	afterGetConfigByIDCounter  uint64
	beforeGetConfigByIDCounter uint64
	GetConfigByIDMock          mRepositoryMockGetConfigByID

	funcGetContentByFileUIDs func(ctx context.Context, files []mm_repository.KnowledgeBaseFileModel) (m1 map[types.FileUIDType]struct {
		SourceTable string
		SourceUID   types.SourceUIDType
	}, err error)
	funcGetContentByFileUIDsOrigin    string
	inspectFuncGetContentByFileUIDs   func(ctx context.Context, files []mm_repository.KnowledgeBaseFileModel)
	afterGetContentByFileUIDsCounter  uint64
	beforeGetContentByFileUIDsCounter uint64
	GetContentByFileUIDsMock          mRepositoryMockGetContentByFileUIDs

	funcGetConvertedFileByFileUID          func(ctx context.Context, fileUID types.FileUIDType) (cp1 *mm_repository.ConvertedFileModel, err error)
	funcGetConvertedFileByFileUIDOrigin    string
	inspectFuncGetConvertedFileByFileUID   func(ctx context.Context, fileUID types.FileUIDType)
	afterGetConvertedFileByFileUIDCounter  uint64
	beforeGetConvertedFileByFileUIDCounter uint64
	GetConvertedFileByFileUIDMock          mRepositoryMockGetConvertedFileByFileUID

	funcGetConvertedFileByFileUIDAndType          func(ctx context.Context, fileUID types.FileUIDType, convertedType artifactpb.ConvertedFileType) (cp1 *mm_repository.ConvertedFileModel, err error)
	funcGetConvertedFileByFileUIDAndTypeOrigin    string
	inspectFuncGetConvertedFileByFileUIDAndType   func(ctx context.Context, fileUID types.FileUIDType, convertedType artifactpb.ConvertedFileType)
	afterGetConvertedFileByFileUIDAndTypeCounter  uint64
	beforeGetConvertedFileByFileUIDAndTypeCounter uint64
	GetConvertedFileByFileUIDAndTypeMock          mRepositoryMockGetConvertedFileByFileUIDAndType

	funcGetConvertedFileCountByKBUID          func(ctx context.Context, kbUID types.KBUIDType) (i1 int64, err error)
	funcGetConvertedFileCountByKBUIDOrigin    string
	inspectFuncGetConvertedFileCountByKBUID   func(ctx context.Context, kbUID types.KBUIDType)
	afterGetConvertedFileCountByKBUIDCounter  uint64
	beforeGetConvertedFileCountByKBUIDCounter uint64
	GetConvertedFileCountByKBUIDMock          mRepositoryMockGetConvertedFileCountByKBUID

	funcGetDB          func() (dp1 *gorm.DB)
	funcGetDBOrigin    string
	inspectFuncGetDB   func()
	afterGetDBCounter  uint64
	beforeGetDBCounter uint64
	GetDBMock          mRepositoryMockGetDB

	funcGetDefaultSystem          func(ctx context.Context) (sp1 *mm_repository.SystemModel, err error)
	funcGetDefaultSystemOrigin    string
	inspectFuncGetDefaultSystem   func(ctx context.Context)
	afterGetDefaultSystemCounter  uint64
	beforeGetDefaultSystemCounter uint64
	GetDefaultSystemMock          mRepositoryMockGetDefaultSystem

	funcGetDualProcessingTarget          func(ctx context.Context, productionKB *mm_repository.KnowledgeBaseModel) (dp1 *mm_repository.DualProcessingTarget, err error)
	funcGetDualProcessingTargetOrigin    string
	inspectFuncGetDualProcessingTarget   func(ctx context.Context, productionKB *mm_repository.KnowledgeBaseModel)
	afterGetDualProcessingTargetCounter  uint64
	beforeGetDualProcessingTargetCounter uint64
	GetDualProcessingTargetMock          mRepositoryMockGetDualProcessingTarget

	funcGetEmbeddingCountByKBUID          func(ctx context.Context, kbUID types.KBUIDType) (i1 int64, err error)
	funcGetEmbeddingCountByKBUIDOrigin    string
	inspectFuncGetEmbeddingCountByKBUID   func(ctx context.Context, kbUID types.KBUIDType)
	afterGetEmbeddingCountByKBUIDCounter  uint64
	beforeGetEmbeddingCountByKBUIDCounter uint64
	GetEmbeddingCountByKBUIDMock          mRepositoryMockGetEmbeddingCountByKBUID

	funcGetFileByIDOrAlias          func(ctx context.Context, kbUID types.KBUIDType, id string) (kp1 *mm_repository.KnowledgeBaseFileModel, err error)
	funcGetFileByIDOrAliasOrigin    string
	inspectFuncGetFileByIDOrAlias   func(ctx context.Context, kbUID types.KBUIDType, id string)
	afterGetFileByIDOrAliasCounter  uint64
	beforeGetFileByIDOrAliasCounter uint64
	GetFileByIDOrAliasMock          mRepositoryMockGetFileByIDOrAlias

	funcGetFileCountByKnowledgeBaseUID          func(ctx context.Context, kbUID types.KBUIDType, processStatus string) (i1 int64, err error)
	funcGetFileCountByKnowledgeBaseUIDOrigin    string
	inspectFuncGetFileCountByKnowledgeBaseUID   func(ctx context.Context, kbUID types.KBUIDType, processStatus string)
	afterGetFileCountByKnowledgeBaseUIDCounter  uint64
	beforeGetFileCountByKnowledgeBaseUIDCounter uint64
	GetFileCountByKnowledgeBaseUIDMock          mRepositoryMockGetFileCountByKnowledgeBaseUID

	funcGetFileCountByKnowledgeBaseUIDIncludingDeleted          func(ctx context.Context, kbUID types.KBUIDType, processStatus string) (i1 int64, err error)
	funcGetFileCountByKnowledgeBaseUIDIncludingDeletedOrigin    string
	inspectFuncGetFileCountByKnowledgeBaseUIDIncludingDeleted   func(ctx context.Context, kbUID types.KBUIDType, processStatus string)
	afterGetFileCountByKnowledgeBaseUIDIncludingDeletedCounter  uint64
	beforeGetFileCountByKnowledgeBaseUIDIncludingDeletedCounter uint64
	GetFileCountByKnowledgeBaseUIDIncludingDeletedMock          mRepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeleted

	funcGetFilesTotalTokens func(ctx context.Context, sources map[types.FileUIDType]struct {
		SourceTable types.SourceTableType
		SourceUID   types.SourceUIDType
	}) (m1 map[types.FileUIDType]int, err error)
	funcGetFilesTotalTokensOrigin  string
	inspectFuncGetFilesTotalTokens func(ctx context.Context, sources map[types.FileUIDType]struct {
		SourceTable types.SourceTableType
		SourceUID   types.SourceUIDType
	})
	afterGetFilesTotalTokensCounter  uint64
	beforeGetFilesTotalTokensCounter uint64
	GetFilesTotalTokensMock          mRepositoryMockGetFilesTotalTokens

	funcGetGCSFileInfo          func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, view string) (gp1 *mm_repository.GCSFileInfo, err error)
	funcGetGCSFileInfoOrigin    string
	inspectFuncGetGCSFileInfo   func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, view string)
	afterGetGCSFileInfoCounter  uint64
	beforeGetGCSFileInfoCounter uint64
	GetGCSFileInfoMock          mRepositoryMockGetGCSFileInfo

	funcGetGCSStorage          func() (s1 object.Storage)
	funcGetGCSStorageOrigin    string
	inspectFuncGetGCSStorage   func()
	afterGetGCSStorageCounter  uint64
	beforeGetGCSStorageCounter uint64
	GetGCSStorageMock          mRepositoryMockGetGCSStorage

	funcGetKnowledgeBaseByID          func(ctx context.Context, kbID string) (kp1 *mm_repository.KnowledgeBaseModel, err error)
	funcGetKnowledgeBaseByIDOrigin    string
	inspectFuncGetKnowledgeBaseByID   func(ctx context.Context, kbID string)
	afterGetKnowledgeBaseByIDCounter  uint64
	beforeGetKnowledgeBaseByIDCounter uint64
	GetKnowledgeBaseByIDMock          mRepositoryMockGetKnowledgeBaseByID

	funcGetKnowledgeBaseByIDOrAlias          func(ctx context.Context, ownerUID types.OwnerUIDType, id string) (kp1 *mm_repository.KnowledgeBaseModel, err error)
	funcGetKnowledgeBaseByIDOrAliasOrigin    string
	inspectFuncGetKnowledgeBaseByIDOrAlias   func(ctx context.Context, ownerUID types.OwnerUIDType, id string)
	afterGetKnowledgeBaseByIDOrAliasCounter  uint64
	beforeGetKnowledgeBaseByIDOrAliasCounter uint64
	GetKnowledgeBaseByIDOrAliasMock          mRepositoryMockGetKnowledgeBaseByIDOrAlias

	funcGetKnowledgeBaseByOwnerAndKbID          func(ctx context.Context, ownerUID types.OwnerUIDType, kbID string) (kp1 *mm_repository.KnowledgeBaseModel, err error)
	funcGetKnowledgeBaseByOwnerAndKbIDOrigin    string
	inspectFuncGetKnowledgeBaseByOwnerAndKbID   func(ctx context.Context, ownerUID types.OwnerUIDType, kbID string)
	afterGetKnowledgeBaseByOwnerAndKbIDCounter  uint64
	beforeGetKnowledgeBaseByOwnerAndKbIDCounter uint64
	GetKnowledgeBaseByOwnerAndKbIDMock          mRepositoryMockGetKnowledgeBaseByOwnerAndKbID

	funcGetKnowledgeBaseByUID          func(ctx context.Context, k1 types.KBUIDType) (kp1 *mm_repository.KnowledgeBaseModel, err error)
	funcGetKnowledgeBaseByUIDOrigin    string
	inspectFuncGetKnowledgeBaseByUID   func(ctx context.Context, k1 types.KBUIDType)
	afterGetKnowledgeBaseByUIDCounter  uint64
	beforeGetKnowledgeBaseByUIDCounter uint64
	GetKnowledgeBaseByUIDMock          mRepositoryMockGetKnowledgeBaseByUID

	funcGetKnowledgeBaseByUIDIncludingDeleted          func(ctx context.Context, kbUID types.KBUIDType) (kp1 *mm_repository.KnowledgeBaseModel, err error)
	funcGetKnowledgeBaseByUIDIncludingDeletedOrigin    string
	inspectFuncGetKnowledgeBaseByUIDIncludingDeleted   func(ctx context.Context, kbUID types.KBUIDType)
	afterGetKnowledgeBaseByUIDIncludingDeletedCounter  uint64
	beforeGetKnowledgeBaseByUIDIncludingDeletedCounter uint64
	GetKnowledgeBaseByUIDIncludingDeletedMock          mRepositoryMockGetKnowledgeBaseByUIDIncludingDeleted

	funcGetKnowledgeBaseByUIDWithConfig          func(ctx context.Context, kbUID types.KBUIDType) (kp1 *mm_repository.KnowledgeBaseWithConfig, err error)
	funcGetKnowledgeBaseByUIDWithConfigOrigin    string
	inspectFuncGetKnowledgeBaseByUIDWithConfig   func(ctx context.Context, kbUID types.KBUIDType)
	afterGetKnowledgeBaseByUIDWithConfigCounter  uint64
	beforeGetKnowledgeBaseByUIDWithConfigCounter uint64
	GetKnowledgeBaseByUIDWithConfigMock          mRepositoryMockGetKnowledgeBaseByUIDWithConfig

	funcGetKnowledgeBaseCountByOwner          func(ctx context.Context, ownerUID string, kbType artifactpb.KnowledgeBaseType) (i1 int64, err error)
	funcGetKnowledgeBaseCountByOwnerOrigin    string
	inspectFuncGetKnowledgeBaseCountByOwner   func(ctx context.Context, ownerUID string, kbType artifactpb.KnowledgeBaseType)
	afterGetKnowledgeBaseCountByOwnerCounter  uint64
	beforeGetKnowledgeBaseCountByOwnerCounter uint64
	GetKnowledgeBaseCountByOwnerMock          mRepositoryMockGetKnowledgeBaseCountByOwner

	funcGetKnowledgeBaseFilesByFileIDs          func(ctx context.Context, fileIDs []string, columns ...string) (ka1 []mm_repository.KnowledgeBaseFileModel, err error)
	funcGetKnowledgeBaseFilesByFileIDsOrigin    string
	inspectFuncGetKnowledgeBaseFilesByFileIDs   func(ctx context.Context, fileIDs []string, columns ...string)
	afterGetKnowledgeBaseFilesByFileIDsCounter  uint64
	beforeGetKnowledgeBaseFilesByFileIDsCounter uint64
	GetKnowledgeBaseFilesByFileIDsMock          mRepositoryMockGetKnowledgeBaseFilesByFileIDs

	funcGetKnowledgeBaseFilesByFileUIDs          func(ctx context.Context, fileUIDs []types.FileUIDType, columns ...string) (ka1 []mm_repository.KnowledgeBaseFileModel, err error)
	funcGetKnowledgeBaseFilesByFileUIDsOrigin    string
	inspectFuncGetKnowledgeBaseFilesByFileUIDs   func(ctx context.Context, fileUIDs []types.FileUIDType, columns ...string)
	afterGetKnowledgeBaseFilesByFileUIDsCounter  uint64
	beforeGetKnowledgeBaseFilesByFileUIDsCounter uint64
	GetKnowledgeBaseFilesByFileUIDsMock          mRepositoryMockGetKnowledgeBaseFilesByFileUIDs

	funcGetKnowledgeBaseFilesByFileUIDsIncludingDeleted          func(ctx context.Context, fileUIDs []types.FileUIDType, columns ...string) (ka1 []mm_repository.KnowledgeBaseFileModel, err error)
	funcGetKnowledgeBaseFilesByFileUIDsIncludingDeletedOrigin    string
	inspectFuncGetKnowledgeBaseFilesByFileUIDsIncludingDeleted   func(ctx context.Context, fileUIDs []types.FileUIDType, columns ...string)
	afterGetKnowledgeBaseFilesByFileUIDsIncludingDeletedCounter  uint64
	beforeGetKnowledgeBaseFilesByFileUIDsIncludingDeletedCounter uint64
	GetKnowledgeBaseFilesByFileUIDsIncludingDeletedMock          mRepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeleted

	funcGetKnowledgeBaseFilesByName          func(ctx context.Context, kbUID types.KBUIDType, filename string) (ka1 []mm_repository.KnowledgeBaseFileModel, err error)
	funcGetKnowledgeBaseFilesByNameOrigin    string
	inspectFuncGetKnowledgeBaseFilesByName   func(ctx context.Context, kbUID types.KBUIDType, filename string)
	afterGetKnowledgeBaseFilesByNameCounter  uint64
	beforeGetKnowledgeBaseFilesByNameCounter uint64
	GetKnowledgeBaseFilesByNameMock          mRepositoryMockGetKnowledgeBaseFilesByName

	funcGetKnowledgeBasesByUIDs          func(ctx context.Context, kbUIDs []types.KBUIDType) (ka1 []mm_repository.KnowledgeBaseModel, err error)
	funcGetKnowledgeBasesByUIDsOrigin    string
	inspectFuncGetKnowledgeBasesByUIDs   func(ctx context.Context, kbUIDs []types.KBUIDType)
	afterGetKnowledgeBasesByUIDsCounter  uint64
	beforeGetKnowledgeBasesByUIDsCounter uint64
	GetKnowledgeBasesByUIDsMock          mRepositoryMockGetKnowledgeBasesByUIDs

	funcGetKnowledgeBasesByUIDsWithConfig          func(ctx context.Context, kbUIDs []types.KBUIDType) (ka1 []mm_repository.KnowledgeBaseWithConfig, err error)
	funcGetKnowledgeBasesByUIDsWithConfigOrigin    string
	inspectFuncGetKnowledgeBasesByUIDsWithConfig   func(ctx context.Context, kbUIDs []types.KBUIDType)
	afterGetKnowledgeBasesByUIDsWithConfigCounter  uint64
	beforeGetKnowledgeBasesByUIDsWithConfigCounter uint64
	GetKnowledgeBasesByUIDsWithConfigMock          mRepositoryMockGetKnowledgeBasesByUIDsWithConfig

	funcGetKnowledgebaseFileByKBUIDAndFileID          func(ctx context.Context, kbUID types.KBUIDType, fileID string) (kp1 *mm_repository.KnowledgeBaseFileModel, err error)
	funcGetKnowledgebaseFileByKBUIDAndFileIDOrigin    string
	inspectFuncGetKnowledgebaseFileByKBUIDAndFileID   func(ctx context.Context, kbUID types.KBUIDType, fileID string)
	afterGetKnowledgebaseFileByKBUIDAndFileIDCounter  uint64
	beforeGetKnowledgebaseFileByKBUIDAndFileIDCounter uint64
	GetKnowledgebaseFileByKBUIDAndFileIDMock          mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID

	funcGetMinIOStorage          func() (s1 object.Storage)
	funcGetMinIOStorageOrigin    string
	inspectFuncGetMinIOStorage   func()
	afterGetMinIOStorageCounter  uint64
	beforeGetMinIOStorageCounter uint64
	GetMinIOStorageMock          mRepositoryMockGetMinIOStorage

	funcGetNotStartedFileCount          func(ctx context.Context, kbUID types.KBUIDType) (i1 int64, err error)
	funcGetNotStartedFileCountOrigin    string
	inspectFuncGetNotStartedFileCount   func(ctx context.Context, kbUID types.KBUIDType)
	afterGetNotStartedFileCountCounter  uint64
	beforeGetNotStartedFileCountCounter uint64
	GetNotStartedFileCountMock          mRepositoryMockGetNotStartedFileCount

	funcGetNotStartedFileCountExcluding          func(ctx context.Context, kbUID types.KBUIDType, excludeUIDs []types.FileUIDType) (i1 int64, err error)
	funcGetNotStartedFileCountExcludingOrigin    string
	inspectFuncGetNotStartedFileCountExcluding   func(ctx context.Context, kbUID types.KBUIDType, excludeUIDs []types.FileUIDType)
	afterGetNotStartedFileCountExcludingCounter  uint64
	beforeGetNotStartedFileCountExcludingCounter uint64
	GetNotStartedFileCountExcludingMock          mRepositoryMockGetNotStartedFileCountExcluding

	funcGetObjectByUID          func(ctx context.Context, uid types.ObjectUIDType) (op1 *mm_repository.ObjectModel, err error)
	funcGetObjectByUIDOrigin    string
	inspectFuncGetObjectByUID   func(ctx context.Context, uid types.ObjectUIDType)
	afterGetObjectByUIDCounter  uint64
	beforeGetObjectByUIDCounter uint64
	GetObjectByUIDMock          mRepositoryMockGetObjectByUID

	funcGetRepositoryTag          func(ctx context.Context, r1 utils.RepositoryTagName) (tp1 *types.Tag, err error)
	funcGetRepositoryTagOrigin    string
	inspectFuncGetRepositoryTag   func(ctx context.Context, r1 utils.RepositoryTagName)
	afterGetRepositoryTagCounter  uint64
	beforeGetRepositoryTagCounter uint64
	GetRepositoryTagMock          mRepositoryMockGetRepositoryTag

	funcGetRollbackKBForProduction          func(ctx context.Context, ownerUID types.OwnerUIDType, productionKBID string) (kp1 *mm_repository.KnowledgeBaseModel, err error)
	funcGetRollbackKBForProductionOrigin    string
	inspectFuncGetRollbackKBForProduction   func(ctx context.Context, ownerUID types.OwnerUIDType, productionKBID string)
	afterGetRollbackKBForProductionCounter  uint64
	beforeGetRollbackKBForProductionCounter uint64
	GetRollbackKBForProductionMock          mRepositoryMockGetRollbackKBForProduction

	funcGetSourceByFileUID          func(ctx context.Context, fileUID types.FileUIDType) (sp1 *mm_repository.SourceMeta, err error)
	funcGetSourceByFileUIDOrigin    string
	inspectFuncGetSourceByFileUID   func(ctx context.Context, fileUID types.FileUIDType)
	afterGetSourceByFileUIDCounter  uint64
	beforeGetSourceByFileUIDCounter uint64
	GetSourceByFileUIDMock          mRepositoryMockGetSourceByFileUID

	funcGetStagingKBForProduction          func(ctx context.Context, ownerUID types.OwnerUIDType, productionKBID string) (kp1 *mm_repository.KnowledgeBaseModel, err error)
	funcGetStagingKBForProductionOrigin    string
	inspectFuncGetStagingKBForProduction   func(ctx context.Context, ownerUID types.OwnerUIDType, productionKBID string)
	afterGetStagingKBForProductionCounter  uint64
	beforeGetStagingKBForProductionCounter uint64
	GetStagingKBForProductionMock          mRepositoryMockGetStagingKBForProduction

	funcGetSystem          func(ctx context.Context, id string) (sp1 *mm_repository.SystemModel, err error)
	funcGetSystemOrigin    string
	inspectFuncGetSystem   func(ctx context.Context, id string)
	afterGetSystemCounter  uint64
	beforeGetSystemCounter uint64
	GetSystemMock          mRepositoryMockGetSystem

	funcGetSystemByUID          func(ctx context.Context, uid types.SystemUIDType) (sp1 *mm_repository.SystemModel, err error)
	funcGetSystemByUIDOrigin    string
	inspectFuncGetSystemByUID   func(ctx context.Context, uid types.SystemUIDType)
	afterGetSystemByUIDCounter  uint64
	beforeGetSystemByUIDCounter uint64
	GetSystemByUIDMock          mRepositoryMockGetSystemByUID

	funcGetTextChunksBySource          func(ctx context.Context, sourceTable string, sourceUID types.SourceUIDType) (ta1 []mm_repository.TextChunkModel, err error)
	funcGetTextChunksBySourceOrigin    string
	inspectFuncGetTextChunksBySource   func(ctx context.Context, sourceTable string, sourceUID types.SourceUIDType)
	afterGetTextChunksBySourceCounter  uint64
	beforeGetTextChunksBySourceCounter uint64
	GetTextChunksBySourceMock          mRepositoryMockGetTextChunksBySource

	funcGetTextChunksByUIDs          func(ctx context.Context, chunkUIDs []types.TextChunkUIDType) (ta1 []mm_repository.TextChunkModel, err error)
	funcGetTextChunksByUIDsOrigin    string
	inspectFuncGetTextChunksByUIDs   func(ctx context.Context, chunkUIDs []types.TextChunkUIDType)
	afterGetTextChunksByUIDsCounter  uint64
	beforeGetTextChunksByUIDsCounter uint64
	GetTextChunksByUIDsMock          mRepositoryMockGetTextChunksByUIDs

	funcGetTotalTextChunksBySources func(ctx context.Context, sources map[types.FileUIDType]struct {
		SourceTable types.SourceTableType
		SourceUID   types.SourceUIDType
	}) (m1 map[types.FileUIDType]int, err error)
	funcGetTotalTextChunksBySourcesOrigin  string
	inspectFuncGetTotalTextChunksBySources func(ctx context.Context, sources map[types.FileUIDType]struct {
		SourceTable types.SourceTableType
		SourceUID   types.SourceUIDType
	})
	afterGetTotalTextChunksBySourcesCounter  uint64
	beforeGetTotalTextChunksBySourcesCounter uint64
	GetTotalTextChunksBySourcesMock          mRepositoryMockGetTotalTextChunksBySources

	funcGetTotalTokensByListKBUIDs          func(ctx context.Context, kbUIDs []types.KBUIDType) (m1 map[types.KBUIDType]int, err error)
	funcGetTotalTokensByListKBUIDsOrigin    string
	inspectFuncGetTotalTokensByListKBUIDs   func(ctx context.Context, kbUIDs []types.KBUIDType)
	afterGetTotalTokensByListKBUIDsCounter  uint64
	beforeGetTotalTokensByListKBUIDsCounter uint64
	GetTotalTokensByListKBUIDsMock          mRepositoryMockGetTotalTokensByListKBUIDs

	funcHardDeleteConvertedFileByFileUID          func(ctx context.Context, fileUID types.FileUIDType) (err error)
	funcHardDeleteConvertedFileByFileUIDOrigin    string
	inspectFuncHardDeleteConvertedFileByFileUID   func(ctx context.Context, fileUID types.FileUIDType)
	afterHardDeleteConvertedFileByFileUIDCounter  uint64
	beforeHardDeleteConvertedFileByFileUIDCounter uint64
	HardDeleteConvertedFileByFileUIDMock          mRepositoryMockHardDeleteConvertedFileByFileUID

	funcHardDeleteEmbeddingsByKBFileUID          func(ctx context.Context, kbFileUID types.FileUIDType) (err error)
	funcHardDeleteEmbeddingsByKBFileUIDOrigin    string
	inspectFuncHardDeleteEmbeddingsByKBFileUID   func(ctx context.Context, kbFileUID types.FileUIDType)
	afterHardDeleteEmbeddingsByKBFileUIDCounter  uint64
	beforeHardDeleteEmbeddingsByKBFileUIDCounter uint64
	HardDeleteEmbeddingsByKBFileUIDMock          mRepositoryMockHardDeleteEmbeddingsByKBFileUID

	funcHardDeleteEmbeddingsByKBUID          func(ctx context.Context, kbUID types.KBUIDType) (err error)
	funcHardDeleteEmbeddingsByKBUIDOrigin    string
	inspectFuncHardDeleteEmbeddingsByKBUID   func(ctx context.Context, kbUID types.KBUIDType)
	afterHardDeleteEmbeddingsByKBUIDCounter  uint64
	beforeHardDeleteEmbeddingsByKBUIDCounter uint64
	HardDeleteEmbeddingsByKBUIDMock          mRepositoryMockHardDeleteEmbeddingsByKBUID

	funcHardDeleteTextChunksByKBFileUID          func(ctx context.Context, kbFileUID types.FileUIDType) (err error)
	funcHardDeleteTextChunksByKBFileUIDOrigin    string
	inspectFuncHardDeleteTextChunksByKBFileUID   func(ctx context.Context, kbFileUID types.FileUIDType)
	afterHardDeleteTextChunksByKBFileUIDCounter  uint64
	beforeHardDeleteTextChunksByKBFileUIDCounter uint64
	HardDeleteTextChunksByKBFileUIDMock          mRepositoryMockHardDeleteTextChunksByKBFileUID

	funcHardDeleteTextChunksByKBUID          func(ctx context.Context, kbUID types.KBUIDType) (err error)
	funcHardDeleteTextChunksByKBUIDOrigin    string
	inspectFuncHardDeleteTextChunksByKBUID   func(ctx context.Context, kbUID types.KBUIDType)
	afterHardDeleteTextChunksByKBUIDCounter  uint64
	beforeHardDeleteTextChunksByKBUIDCounter uint64
	HardDeleteTextChunksByKBUIDMock          mRepositoryMockHardDeleteTextChunksByKBUID

	funcIncreaseKnowledgeBaseUsage          func(ctx context.Context, tx *gorm.DB, kbUID string, amount int) (err error)
	funcIncreaseKnowledgeBaseUsageOrigin    string
	inspectFuncIncreaseKnowledgeBaseUsage   func(ctx context.Context, tx *gorm.DB, kbUID string, amount int)
	afterIncreaseKnowledgeBaseUsageCounter  uint64
	beforeIncreaseKnowledgeBaseUsageCounter uint64
	IncreaseKnowledgeBaseUsageMock          mRepositoryMockIncreaseKnowledgeBaseUsage

	funcInsertVectorsInCollection          func(ctx context.Context, collID string, embeddings []mm_repository.VectorEmbedding) (err error)
	funcInsertVectorsInCollectionOrigin    string
	inspectFuncInsertVectorsInCollection   func(ctx context.Context, collID string, embeddings []mm_repository.VectorEmbedding)
	afterInsertVectorsInCollectionCounter  uint64
	beforeInsertVectorsInCollectionCounter uint64
	InsertVectorsInCollectionMock          mRepositoryMockInsertVectorsInCollection

	funcIsCollectionInUse          func(ctx context.Context, collectionUID types.CollectionUIDType) (b1 bool, err error)
	funcIsCollectionInUseOrigin    string
	inspectFuncIsCollectionInUse   func(ctx context.Context, collectionUID types.CollectionUIDType)
	afterIsCollectionInUseCounter  uint64
	beforeIsCollectionInUseCounter uint64
	IsCollectionInUseMock          mRepositoryMockIsCollectionInUse

	funcIsKBUpdating          func(ctx context.Context, kbUID types.KBUIDType) (b1 bool, err error)
	funcIsKBUpdatingOrigin    string
	inspectFuncIsKBUpdating   func(ctx context.Context, kbUID types.KBUIDType)
	afterIsKBUpdatingCounter  uint64
	beforeIsKBUpdatingCounter uint64
	IsKBUpdatingMock          mRepositoryMockIsKBUpdating

	funcListAllKnowledgeBasesAdmin          func(ctx context.Context) (ka1 []mm_repository.KnowledgeBaseModel, err error)
	funcListAllKnowledgeBasesAdminOrigin    string
	inspectFuncListAllKnowledgeBasesAdmin   func(ctx context.Context)
	afterListAllKnowledgeBasesAdminCounter  uint64
	beforeListAllKnowledgeBasesAdminCounter uint64
	ListAllKnowledgeBasesAdminMock          mRepositoryMockListAllKnowledgeBasesAdmin

	funcListAllObjects          func(ctx context.Context, namespaceUID types.NamespaceUIDType, creatorUID types.CreatorUIDType) (oa1 []mm_repository.ObjectModel, err error)
	funcListAllObjectsOrigin    string
	inspectFuncListAllObjects   func(ctx context.Context, namespaceUID types.NamespaceUIDType, creatorUID types.CreatorUIDType)
	afterListAllObjectsCounter  uint64
	beforeListAllObjectsCounter uint64
	ListAllObjectsMock          mRepositoryMockListAllObjects

	funcListEmbeddingsByKBFileUID          func(ctx context.Context, kbFileUID types.FileUIDType) (ea1 []mm_repository.EmbeddingModel, err error)
	funcListEmbeddingsByKBFileUIDOrigin    string
	inspectFuncListEmbeddingsByKBFileUID   func(ctx context.Context, kbFileUID types.FileUIDType)
	afterListEmbeddingsByKBFileUIDCounter  uint64
	beforeListEmbeddingsByKBFileUIDCounter uint64
	ListEmbeddingsByKBFileUIDMock          mRepositoryMockListEmbeddingsByKBFileUID

	funcListKnowledgeBaseFiles          func(ctx context.Context, k1 mm_repository.KnowledgeBaseFileListParams) (kp1 *mm_repository.KnowledgeBaseFileList, err error)
	funcListKnowledgeBaseFilesOrigin    string
	inspectFuncListKnowledgeBaseFiles   func(ctx context.Context, k1 mm_repository.KnowledgeBaseFileListParams)
	afterListKnowledgeBaseFilesCounter  uint64
	beforeListKnowledgeBaseFilesCounter uint64
	ListKnowledgeBaseFilesMock          mRepositoryMockListKnowledgeBaseFiles

	funcListKnowledgeBases          func(ctx context.Context, ownerUID string) (ka1 []mm_repository.KnowledgeBaseModel, err error)
	funcListKnowledgeBasesOrigin    string
	inspectFuncListKnowledgeBases   func(ctx context.Context, ownerUID string)
	afterListKnowledgeBasesCounter  uint64
	beforeListKnowledgeBasesCounter uint64
	ListKnowledgeBasesMock          mRepositoryMockListKnowledgeBases

	funcListKnowledgeBasesByType          func(ctx context.Context, ownerUID string, kbType artifactpb.KnowledgeBaseType) (ka1 []mm_repository.KnowledgeBaseModel, err error)
	funcListKnowledgeBasesByTypeOrigin    string
	inspectFuncListKnowledgeBasesByType   func(ctx context.Context, ownerUID string, kbType artifactpb.KnowledgeBaseType)
	afterListKnowledgeBasesByTypeCounter  uint64
	beforeListKnowledgeBasesByTypeCounter uint64
	ListKnowledgeBasesByTypeMock          mRepositoryMockListKnowledgeBasesByType

	funcListKnowledgeBasesByTypeWithConfig          func(ctx context.Context, ownerUID string, kbType artifactpb.KnowledgeBaseType) (ka1 []mm_repository.KnowledgeBaseWithConfig, err error)
	funcListKnowledgeBasesByTypeWithConfigOrigin    string
	inspectFuncListKnowledgeBasesByTypeWithConfig   func(ctx context.Context, ownerUID string, kbType artifactpb.KnowledgeBaseType)
	afterListKnowledgeBasesByTypeWithConfigCounter  uint64
	beforeListKnowledgeBasesByTypeWithConfigCounter uint64
	ListKnowledgeBasesByTypeWithConfigMock          mRepositoryMockListKnowledgeBasesByTypeWithConfig

	funcListKnowledgeBasesByUpdateStatus          func(ctx context.Context, updateStatus string) (ka1 []mm_repository.KnowledgeBaseModel, err error)
	funcListKnowledgeBasesByUpdateStatusOrigin    string
	inspectFuncListKnowledgeBasesByUpdateStatus   func(ctx context.Context, updateStatus string)
	afterListKnowledgeBasesByUpdateStatusCounter  uint64
	beforeListKnowledgeBasesByUpdateStatusCounter uint64
	ListKnowledgeBasesByUpdateStatusMock          mRepositoryMockListKnowledgeBasesByUpdateStatus

	funcListKnowledgeBasesForUpdate          func(ctx context.Context, tagFilters []string, knowledgeBaseIDs []string) (ka1 []mm_repository.KnowledgeBaseModel, err error)
	funcListKnowledgeBasesForUpdateOrigin    string
	inspectFuncListKnowledgeBasesForUpdate   func(ctx context.Context, tagFilters []string, knowledgeBaseIDs []string)
	afterListKnowledgeBasesForUpdateCounter  uint64
	beforeListKnowledgeBasesForUpdateCounter uint64
	ListKnowledgeBasesForUpdateMock          mRepositoryMockListKnowledgeBasesForUpdate

	funcListSystems          func(ctx context.Context) (sa1 []mm_repository.SystemModel, err error)
	funcListSystemsOrigin    string
	inspectFuncListSystems   func(ctx context.Context)
	afterListSystemsCounter  uint64
	beforeListSystemsCounter uint64
	ListSystemsMock          mRepositoryMockListSystems

	funcListTextChunksByKBFileUID          func(ctx context.Context, kbFileUID types.FileUIDType) (ta1 []mm_repository.TextChunkModel, err error)
	funcListTextChunksByKBFileUIDOrigin    string
	inspectFuncListTextChunksByKBFileUID   func(ctx context.Context, kbFileUID types.FileUIDType)
	afterListTextChunksByKBFileUIDCounter  uint64
	beforeListTextChunksByKBFileUIDCounter uint64
	ListTextChunksByKBFileUIDMock          mRepositoryMockListTextChunksByKBFileUID

	funcProcessKnowledgeBaseFiles          func(ctx context.Context, fileUIDs []string, requester types.RequesterUIDType) (ka1 []mm_repository.KnowledgeBaseFileModel, err error)
	funcProcessKnowledgeBaseFilesOrigin    string
	inspectFuncProcessKnowledgeBaseFiles   func(ctx context.Context, fileUIDs []string, requester types.RequesterUIDType)
	afterProcessKnowledgeBaseFilesCounter  uint64
	beforeProcessKnowledgeBaseFilesCounter uint64
	ProcessKnowledgeBaseFilesMock          mRepositoryMockProcessKnowledgeBaseFiles

	funcRenameSystemByID          func(ctx context.Context, id string, newID string) (err error)
	funcRenameSystemByIDOrigin    string
	inspectFuncRenameSystemByID   func(ctx context.Context, id string, newID string)
	afterRenameSystemByIDCounter  uint64
	beforeRenameSystemByIDCounter uint64
	RenameSystemByIDMock          mRepositoryMockRenameSystemByID

	funcRenewCacheMetadataTTL          func(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType, newTTL time.Duration, newExpireTime time.Time) (err error)
	funcRenewCacheMetadataTTLOrigin    string
	inspectFuncRenewCacheMetadataTTL   func(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType, newTTL time.Duration, newExpireTime time.Time)
	afterRenewCacheMetadataTTLCounter  uint64
	beforeRenewCacheMetadataTTLCounter uint64
	RenewCacheMetadataTTLMock          mRepositoryMockRenewCacheMetadataTTL

	funcScanGCSFilesForCleanup          func(ctx context.Context, maxCount int64) (ga1 []mm_repository.GCSFileInfo, err error)
	funcScanGCSFilesForCleanupOrigin    string
	inspectFuncScanGCSFilesForCleanup   func(ctx context.Context, maxCount int64)
	afterScanGCSFilesForCleanupCounter  uint64
	beforeScanGCSFilesForCleanupCounter uint64
	ScanGCSFilesForCleanupMock          mRepositoryMockScanGCSFilesForCleanup

	funcSearchVectorsInCollection          func(ctx context.Context, s1 mm_repository.SearchVectorParam) (saa1 [][]mm_repository.SimilarVectorEmbedding, err error)
	funcSearchVectorsInCollectionOrigin    string
	inspectFuncSearchVectorsInCollection   func(ctx context.Context, s1 mm_repository.SearchVectorParam)
	afterSearchVectorsInCollectionCounter  uint64
	beforeSearchVectorsInCollectionCounter uint64
	SearchVectorsInCollectionMock          mRepositoryMockSearchVectorsInCollection

	funcSetCacheMetadata          func(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType, metadata *mm_repository.CacheMetadata, ttl time.Duration) (err error)
	funcSetCacheMetadataOrigin    string
	inspectFuncSetCacheMetadata   func(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType, metadata *mm_repository.CacheMetadata, ttl time.Duration)
	afterSetCacheMetadataCounter  uint64
	beforeSetCacheMetadataCounter uint64
	SetCacheMetadataMock          mRepositoryMockSetCacheMetadata

	funcSetDefaultSystem          func(ctx context.Context, id string) (err error)
	funcSetDefaultSystemOrigin    string
	inspectFuncSetDefaultSystem   func(ctx context.Context, id string)
	afterSetDefaultSystemCounter  uint64
	beforeSetDefaultSystemCounter uint64
	SetDefaultSystemMock          mRepositoryMockSetDefaultSystem

	funcSetGCSFileInfo          func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, view string, gcsInfo *mm_repository.GCSFileInfo, ttl time.Duration) (err error)
	funcSetGCSFileInfoOrigin    string
	inspectFuncSetGCSFileInfo   func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, view string, gcsInfo *mm_repository.GCSFileInfo, ttl time.Duration)
	afterSetGCSFileInfoCounter  uint64
	beforeSetGCSFileInfoCounter uint64
	SetGCSFileInfoMock          mRepositoryMockSetGCSFileInfo

	funcUpdateConfigByID          func(ctx context.Context, id string, config mm_repository.SystemConfigJSON) (err error)
	funcUpdateConfigByIDOrigin    string
	inspectFuncUpdateConfigByID   func(ctx context.Context, id string, config mm_repository.SystemConfigJSON)
	afterUpdateConfigByIDCounter  uint64
	beforeUpdateConfigByIDCounter uint64
	UpdateConfigByIDMock          mRepositoryMockUpdateConfigByID

	funcUpdateConvertedFile          func(ctx context.Context, uid types.ConvertedFileUIDType, update map[string]any) (err error)
	funcUpdateConvertedFileOrigin    string
	inspectFuncUpdateConvertedFile   func(ctx context.Context, uid types.ConvertedFileUIDType, update map[string]any)
	afterUpdateConvertedFileCounter  uint64
	beforeUpdateConvertedFileCounter uint64
	UpdateConvertedFileMock          mRepositoryMockUpdateConvertedFile

	funcUpdateEmbeddingTags          func(ctx context.Context, collectionID string, fileUID types.FileUIDType, tags []string) (err error)
	funcUpdateEmbeddingTagsOrigin    string
	inspectFuncUpdateEmbeddingTags   func(ctx context.Context, collectionID string, fileUID types.FileUIDType, tags []string)
	afterUpdateEmbeddingTagsCounter  uint64
	beforeUpdateEmbeddingTagsCounter uint64
	UpdateEmbeddingTagsMock          mRepositoryMockUpdateEmbeddingTags

	funcUpdateEmbeddingTagsForFile          func(ctx context.Context, collectionID string, fileUID types.FileUIDType, tags []string) (err error)
	funcUpdateEmbeddingTagsForFileOrigin    string
	inspectFuncUpdateEmbeddingTagsForFile   func(ctx context.Context, collectionID string, fileUID types.FileUIDType, tags []string)
	afterUpdateEmbeddingTagsForFileCounter  uint64
	beforeUpdateEmbeddingTagsForFileCounter uint64
	UpdateEmbeddingTagsForFileMock          mRepositoryMockUpdateEmbeddingTagsForFile

	funcUpdateKnowledgeBase          func(ctx context.Context, id string, ownerUID string, kb mm_repository.KnowledgeBaseModel) (kp1 *mm_repository.KnowledgeBaseModel, err error)
	funcUpdateKnowledgeBaseOrigin    string
	inspectFuncUpdateKnowledgeBase   func(ctx context.Context, id string, ownerUID string, kb mm_repository.KnowledgeBaseModel)
	afterUpdateKnowledgeBaseCounter  uint64
	beforeUpdateKnowledgeBaseCounter uint64
	UpdateKnowledgeBaseMock          mRepositoryMockUpdateKnowledgeBase

	funcUpdateKnowledgeBaseAborted          func(ctx context.Context, kbUID types.KBUIDType) (err error)
	funcUpdateKnowledgeBaseAbortedOrigin    string
	inspectFuncUpdateKnowledgeBaseAborted   func(ctx context.Context, kbUID types.KBUIDType)
	afterUpdateKnowledgeBaseAbortedCounter  uint64
	beforeUpdateKnowledgeBaseAbortedCounter uint64
	UpdateKnowledgeBaseAbortedMock          mRepositoryMockUpdateKnowledgeBaseAborted

	funcUpdateKnowledgeBaseFile          func(ctx context.Context, fileUID string, updateMap map[string]any) (kp1 *mm_repository.KnowledgeBaseFileModel, err error)
	funcUpdateKnowledgeBaseFileOrigin    string
	inspectFuncUpdateKnowledgeBaseFile   func(ctx context.Context, fileUID string, updateMap map[string]any)
	afterUpdateKnowledgeBaseFileCounter  uint64
	beforeUpdateKnowledgeBaseFileCounter uint64
	UpdateKnowledgeBaseFileMock          mRepositoryMockUpdateKnowledgeBaseFile

	funcUpdateKnowledgeBaseResources          func(ctx context.Context, fromKBUID types.KBUIDType, toKBUID types.KBUIDType) (err error)
	funcUpdateKnowledgeBaseResourcesOrigin    string
	inspectFuncUpdateKnowledgeBaseResources   func(ctx context.Context, fromKBUID types.KBUIDType, toKBUID types.KBUIDType)
	afterUpdateKnowledgeBaseResourcesCounter  uint64
	beforeUpdateKnowledgeBaseResourcesCounter uint64
	UpdateKnowledgeBaseResourcesMock          mRepositoryMockUpdateKnowledgeBaseResources

	funcUpdateKnowledgeBaseResourcesTx          func(ctx context.Context, tx *gorm.DB, fromKBUID types.KBUIDType, toKBUID types.KBUIDType) (err error)
	funcUpdateKnowledgeBaseResourcesTxOrigin    string
	inspectFuncUpdateKnowledgeBaseResourcesTx   func(ctx context.Context, tx *gorm.DB, fromKBUID types.KBUIDType, toKBUID types.KBUIDType)
	afterUpdateKnowledgeBaseResourcesTxCounter  uint64
	beforeUpdateKnowledgeBaseResourcesTxCounter uint64
	UpdateKnowledgeBaseResourcesTxMock          mRepositoryMockUpdateKnowledgeBaseResourcesTx

	funcUpdateKnowledgeBaseUpdateStatus          func(ctx context.Context, kbUID types.KBUIDType, status string, workflowID string, errorMessage string, previousSystemUID types.SystemUIDType) (err error)
	funcUpdateKnowledgeBaseUpdateStatusOrigin    string
	inspectFuncUpdateKnowledgeBaseUpdateStatus   func(ctx context.Context, kbUID types.KBUIDType, status string, workflowID string, errorMessage string, previousSystemUID types.SystemUIDType)
	afterUpdateKnowledgeBaseUpdateStatusCounter  uint64
	beforeUpdateKnowledgeBaseUpdateStatusCounter uint64
	UpdateKnowledgeBaseUpdateStatusMock          mRepositoryMockUpdateKnowledgeBaseUpdateStatus

	funcUpdateKnowledgeBaseWithMap          func(ctx context.Context, id string, owner string, updates map[string]any) (err error)
	funcUpdateKnowledgeBaseWithMapOrigin    string
	inspectFuncUpdateKnowledgeBaseWithMap   func(ctx context.Context, id string, owner string, updates map[string]any)
	afterUpdateKnowledgeBaseWithMapCounter  uint64
	beforeUpdateKnowledgeBaseWithMapCounter uint64
	UpdateKnowledgeBaseWithMapMock          mRepositoryMockUpdateKnowledgeBaseWithMap

	funcUpdateKnowledgeBaseWithMapTx          func(ctx context.Context, tx *gorm.DB, id string, owner string, updates map[string]any) (err error)
	funcUpdateKnowledgeBaseWithMapTxOrigin    string
	inspectFuncUpdateKnowledgeBaseWithMapTx   func(ctx context.Context, tx *gorm.DB, id string, owner string, updates map[string]any)
	afterUpdateKnowledgeBaseWithMapTxCounter  uint64
	beforeUpdateKnowledgeBaseWithMapTxCounter uint64
	UpdateKnowledgeBaseWithMapTxMock          mRepositoryMockUpdateKnowledgeBaseWithMapTx

	funcUpdateKnowledgeFileMetadata          func(ctx context.Context, fileUID types.FileUIDType, e1 mm_repository.ExtraMetaData) (err error)
	funcUpdateKnowledgeFileMetadataOrigin    string
	inspectFuncUpdateKnowledgeFileMetadata   func(ctx context.Context, fileUID types.FileUIDType, e1 mm_repository.ExtraMetaData)
	afterUpdateKnowledgeFileMetadataCounter  uint64
	beforeUpdateKnowledgeFileMetadataCounter uint64
	UpdateKnowledgeFileMetadataMock          mRepositoryMockUpdateKnowledgeFileMetadata

	funcUpdateKnowledgeFileUsageMetadata          func(ctx context.Context, fileUID types.FileUIDType, u1 mm_repository.UsageMetadata) (err error)
	funcUpdateKnowledgeFileUsageMetadataOrigin    string
	inspectFuncUpdateKnowledgeFileUsageMetadata   func(ctx context.Context, fileUID types.FileUIDType, u1 mm_repository.UsageMetadata)
	afterUpdateKnowledgeFileUsageMetadataCounter  uint64
	beforeUpdateKnowledgeFileUsageMetadataCounter uint64
	UpdateKnowledgeFileUsageMetadataMock          mRepositoryMockUpdateKnowledgeFileUsageMetadata

	funcUpdateObject          func(ctx context.Context, obj mm_repository.ObjectModel) (op1 *mm_repository.ObjectModel, err error)
	funcUpdateObjectOrigin    string
	inspectFuncUpdateObject   func(ctx context.Context, obj mm_repository.ObjectModel)
	afterUpdateObjectCounter  uint64
	beforeUpdateObjectCounter uint64
	UpdateObjectMock          mRepositoryMockUpdateObject

	funcUpdateObjectByUpdateMap          func(ctx context.Context, objUID types.ObjectUIDType, updateMap map[string]any) (op1 *mm_repository.ObjectModel, err error)
	funcUpdateObjectByUpdateMapOrigin    string
	inspectFuncUpdateObjectByUpdateMap   func(ctx context.Context, objUID types.ObjectUIDType, updateMap map[string]any)
	afterUpdateObjectByUpdateMapCounter  uint64
	beforeUpdateObjectByUpdateMapCounter uint64
	UpdateObjectByUpdateMapMock          mRepositoryMockUpdateObjectByUpdateMap

	funcUpdateSystem          func(ctx context.Context, id string, config map[string]any, description string) (err error)
	funcUpdateSystemOrigin    string
	inspectFuncUpdateSystem   func(ctx context.Context, id string, config map[string]any, description string)
	afterUpdateSystemCounter  uint64
	beforeUpdateSystemCounter uint64
	UpdateSystemMock          mRepositoryMockUpdateSystem

	funcUpdateSystemByUpdateMap          func(ctx context.Context, id string, updateFields map[string]interface{}) (err error)
	funcUpdateSystemByUpdateMapOrigin    string
	inspectFuncUpdateSystemByUpdateMap   func(ctx context.Context, id string, updateFields map[string]interface{})
	afterUpdateSystemByUpdateMapCounter  uint64
	beforeUpdateSystemByUpdateMapCounter uint64
	UpdateSystemByUpdateMapMock          mRepositoryMockUpdateSystemByUpdateMap

	funcUpdateTextChunk          func(ctx context.Context, chunkUID string, updates map[string]any) (tp1 *mm_repository.TextChunkModel, err error)
	funcUpdateTextChunkOrigin    string
	inspectFuncUpdateTextChunk   func(ctx context.Context, chunkUID string, updates map[string]any)
	afterUpdateTextChunkCounter  uint64
	beforeUpdateTextChunkCounter uint64
	UpdateTextChunkMock          mRepositoryMockUpdateTextChunk

	funcUpdateTextChunkDestinations          func(ctx context.Context, destinations map[string]string) (err error)
	funcUpdateTextChunkDestinationsOrigin    string
	inspectFuncUpdateTextChunkDestinations   func(ctx context.Context, destinations map[string]string)
	afterUpdateTextChunkDestinationsCounter  uint64
	beforeUpdateTextChunkDestinationsCounter uint64
	UpdateTextChunkDestinationsMock          mRepositoryMockUpdateTextChunkDestinations

	funcUpsertRepositoryTag          func(ctx context.Context, tp1 *types.Tag) (tp2 *types.Tag, err error)
	funcUpsertRepositoryTagOrigin    string
	inspectFuncUpsertRepositoryTag   func(ctx context.Context, tp1 *types.Tag)
	afterUpsertRepositoryTagCounter  uint64
	beforeUpsertRepositoryTagCounter uint64
	UpsertRepositoryTagMock          mRepositoryMockUpsertRepositoryTag
}

// NewRepositoryMock returns a mock for mm_repository.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckFileUIDMetadataMock = mRepositoryMockCheckFileUIDMetadata{mock: m}
	m.CheckFileUIDMetadataMock.callArgs = []*RepositoryMockCheckFileUIDMetadataParams{}

	m.CheckGCSFileExistsMock = mRepositoryMockCheckGCSFileExists{mock: m}
	m.CheckGCSFileExistsMock.callArgs = []*RepositoryMockCheckGCSFileExistsParams{}

	m.CollectionExistsMock = mRepositoryMockCollectionExists{mock: m}
	m.CollectionExistsMock.callArgs = []*RepositoryMockCollectionExistsParams{}

	m.CreateCollectionMock = mRepositoryMockCreateCollection{mock: m}
	m.CreateCollectionMock.callArgs = []*RepositoryMockCreateCollectionParams{}

	m.CreateConvertedFileWithDestinationMock = mRepositoryMockCreateConvertedFileWithDestination{mock: m}
	m.CreateConvertedFileWithDestinationMock.callArgs = []*RepositoryMockCreateConvertedFileWithDestinationParams{}

	m.CreateEmbeddingsMock = mRepositoryMockCreateEmbeddings{mock: m}
	m.CreateEmbeddingsMock.callArgs = []*RepositoryMockCreateEmbeddingsParams{}

	m.CreateKnowledgeBaseMock = mRepositoryMockCreateKnowledgeBase{mock: m}
	m.CreateKnowledgeBaseMock.callArgs = []*RepositoryMockCreateKnowledgeBaseParams{}

	m.CreateKnowledgeBaseFileMock = mRepositoryMockCreateKnowledgeBaseFile{mock: m}
	m.CreateKnowledgeBaseFileMock.callArgs = []*RepositoryMockCreateKnowledgeBaseFileParams{}

	m.CreateObjectMock = mRepositoryMockCreateObject{mock: m}
	m.CreateObjectMock.callArgs = []*RepositoryMockCreateObjectParams{}

	m.CreateStagingKnowledgeBaseMock = mRepositoryMockCreateStagingKnowledgeBase{mock: m}
	m.CreateStagingKnowledgeBaseMock.callArgs = []*RepositoryMockCreateStagingKnowledgeBaseParams{}

	m.CreateSystemMock = mRepositoryMockCreateSystem{mock: m}
	m.CreateSystemMock.callArgs = []*RepositoryMockCreateSystemParams{}

	m.CreateTextChunksMock = mRepositoryMockCreateTextChunks{mock: m}
	m.CreateTextChunksMock.callArgs = []*RepositoryMockCreateTextChunksParams{}

	m.DeleteAllConvertedFilesInKbMock = mRepositoryMockDeleteAllConvertedFilesInKb{mock: m}
	m.DeleteAllConvertedFilesInKbMock.callArgs = []*RepositoryMockDeleteAllConvertedFilesInKbParams{}

	m.DeleteAllKnowledgeBaseFilesMock = mRepositoryMockDeleteAllKnowledgeBaseFiles{mock: m}
	m.DeleteAllKnowledgeBaseFilesMock.callArgs = []*RepositoryMockDeleteAllKnowledgeBaseFilesParams{}

	m.DeleteAndCreateEmbeddingsMock = mRepositoryMockDeleteAndCreateEmbeddings{mock: m}
	m.DeleteAndCreateEmbeddingsMock.callArgs = []*RepositoryMockDeleteAndCreateEmbeddingsParams{}

	m.DeleteAndCreateTextChunksMock = mRepositoryMockDeleteAndCreateTextChunks{mock: m}
	m.DeleteAndCreateTextChunksMock.callArgs = []*RepositoryMockDeleteAndCreateTextChunksParams{}

	m.DeleteCacheMetadataMock = mRepositoryMockDeleteCacheMetadata{mock: m}
	m.DeleteCacheMetadataMock.callArgs = []*RepositoryMockDeleteCacheMetadataParams{}

	m.DeleteConvertedFileMock = mRepositoryMockDeleteConvertedFile{mock: m}
	m.DeleteConvertedFileMock.callArgs = []*RepositoryMockDeleteConvertedFileParams{}

	m.DeleteEmbeddingsByKBFileUIDMock = mRepositoryMockDeleteEmbeddingsByKBFileUID{mock: m}
	m.DeleteEmbeddingsByKBFileUIDMock.callArgs = []*RepositoryMockDeleteEmbeddingsByKBFileUIDParams{}

	m.DeleteEmbeddingsWithFileUIDMock = mRepositoryMockDeleteEmbeddingsWithFileUID{mock: m}
	m.DeleteEmbeddingsWithFileUIDMock.callArgs = []*RepositoryMockDeleteEmbeddingsWithFileUIDParams{}

	m.DeleteGCSFileCacheMock = mRepositoryMockDeleteGCSFileCache{mock: m}
	m.DeleteGCSFileCacheMock.callArgs = []*RepositoryMockDeleteGCSFileCacheParams{}

	m.DeleteKnowledgeBaseMock = mRepositoryMockDeleteKnowledgeBase{mock: m}
	m.DeleteKnowledgeBaseMock.callArgs = []*RepositoryMockDeleteKnowledgeBaseParams{}

	m.DeleteKnowledgeBaseFileMock = mRepositoryMockDeleteKnowledgeBaseFile{mock: m}
	m.DeleteKnowledgeBaseFileMock.callArgs = []*RepositoryMockDeleteKnowledgeBaseFileParams{}

	m.DeleteKnowledgeBaseFileAndDecreaseUsageMock = mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage{mock: m}
	m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.callArgs = []*RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParams{}

	m.DeleteKnowledgeBaseTxMock = mRepositoryMockDeleteKnowledgeBaseTx{mock: m}
	m.DeleteKnowledgeBaseTxMock.callArgs = []*RepositoryMockDeleteKnowledgeBaseTxParams{}

	m.DeleteObjectMock = mRepositoryMockDeleteObject{mock: m}
	m.DeleteObjectMock.callArgs = []*RepositoryMockDeleteObjectParams{}

	m.DeleteObjectByDestinationMock = mRepositoryMockDeleteObjectByDestination{mock: m}
	m.DeleteObjectByDestinationMock.callArgs = []*RepositoryMockDeleteObjectByDestinationParams{}

	m.DeleteRepositoryTagMock = mRepositoryMockDeleteRepositoryTag{mock: m}
	m.DeleteRepositoryTagMock.callArgs = []*RepositoryMockDeleteRepositoryTagParams{}

	m.DeleteSystemMock = mRepositoryMockDeleteSystem{mock: m}
	m.DeleteSystemMock.callArgs = []*RepositoryMockDeleteSystemParams{}

	m.DropCollectionMock = mRepositoryMockDropCollection{mock: m}
	m.DropCollectionMock.callArgs = []*RepositoryMockDropCollectionParams{}

	m.FlushCollectionMock = mRepositoryMockFlushCollection{mock: m}
	m.FlushCollectionMock.callArgs = []*RepositoryMockFlushCollectionParams{}

	m.GetActiveCollectionUIDMock = mRepositoryMockGetActiveCollectionUID{mock: m}
	m.GetActiveCollectionUIDMock.callArgs = []*RepositoryMockGetActiveCollectionUIDParams{}

	m.GetAllConvertedFilesByFileUIDMock = mRepositoryMockGetAllConvertedFilesByFileUID{mock: m}
	m.GetAllConvertedFilesByFileUIDMock.callArgs = []*RepositoryMockGetAllConvertedFilesByFileUIDParams{}

	m.GetCacheMetadataMock = mRepositoryMockGetCacheMetadata{mock: m}
	m.GetCacheMetadataMock.callArgs = []*RepositoryMockGetCacheMetadataParams{}

	m.GetChunkCountByKBUIDMock = mRepositoryMockGetChunkCountByKBUID{mock: m}
	m.GetChunkCountByKBUIDMock.callArgs = []*RepositoryMockGetChunkCountByKBUIDParams{}

	m.GetConfigByIDMock = mRepositoryMockGetConfigByID{mock: m}
	m.GetConfigByIDMock.callArgs = []*RepositoryMockGetConfigByIDParams{}

	m.GetContentByFileUIDsMock = mRepositoryMockGetContentByFileUIDs{mock: m}
	m.GetContentByFileUIDsMock.callArgs = []*RepositoryMockGetContentByFileUIDsParams{}

	m.GetConvertedFileByFileUIDMock = mRepositoryMockGetConvertedFileByFileUID{mock: m}
	m.GetConvertedFileByFileUIDMock.callArgs = []*RepositoryMockGetConvertedFileByFileUIDParams{}

	m.GetConvertedFileByFileUIDAndTypeMock = mRepositoryMockGetConvertedFileByFileUIDAndType{mock: m}
	m.GetConvertedFileByFileUIDAndTypeMock.callArgs = []*RepositoryMockGetConvertedFileByFileUIDAndTypeParams{}

	m.GetConvertedFileCountByKBUIDMock = mRepositoryMockGetConvertedFileCountByKBUID{mock: m}
	m.GetConvertedFileCountByKBUIDMock.callArgs = []*RepositoryMockGetConvertedFileCountByKBUIDParams{}

	m.GetDBMock = mRepositoryMockGetDB{mock: m}

	m.GetDefaultSystemMock = mRepositoryMockGetDefaultSystem{mock: m}
	m.GetDefaultSystemMock.callArgs = []*RepositoryMockGetDefaultSystemParams{}

	m.GetDualProcessingTargetMock = mRepositoryMockGetDualProcessingTarget{mock: m}
	m.GetDualProcessingTargetMock.callArgs = []*RepositoryMockGetDualProcessingTargetParams{}

	m.GetEmbeddingCountByKBUIDMock = mRepositoryMockGetEmbeddingCountByKBUID{mock: m}
	m.GetEmbeddingCountByKBUIDMock.callArgs = []*RepositoryMockGetEmbeddingCountByKBUIDParams{}

	m.GetFileByIDOrAliasMock = mRepositoryMockGetFileByIDOrAlias{mock: m}
	m.GetFileByIDOrAliasMock.callArgs = []*RepositoryMockGetFileByIDOrAliasParams{}

	m.GetFileCountByKnowledgeBaseUIDMock = mRepositoryMockGetFileCountByKnowledgeBaseUID{mock: m}
	m.GetFileCountByKnowledgeBaseUIDMock.callArgs = []*RepositoryMockGetFileCountByKnowledgeBaseUIDParams{}

	m.GetFileCountByKnowledgeBaseUIDIncludingDeletedMock = mRepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeleted{mock: m}
	m.GetFileCountByKnowledgeBaseUIDIncludingDeletedMock.callArgs = []*RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedParams{}

	m.GetFilesTotalTokensMock = mRepositoryMockGetFilesTotalTokens{mock: m}
	m.GetFilesTotalTokensMock.callArgs = []*RepositoryMockGetFilesTotalTokensParams{}

	m.GetGCSFileInfoMock = mRepositoryMockGetGCSFileInfo{mock: m}
	m.GetGCSFileInfoMock.callArgs = []*RepositoryMockGetGCSFileInfoParams{}

	m.GetGCSStorageMock = mRepositoryMockGetGCSStorage{mock: m}

	m.GetKnowledgeBaseByIDMock = mRepositoryMockGetKnowledgeBaseByID{mock: m}
	m.GetKnowledgeBaseByIDMock.callArgs = []*RepositoryMockGetKnowledgeBaseByIDParams{}

	m.GetKnowledgeBaseByIDOrAliasMock = mRepositoryMockGetKnowledgeBaseByIDOrAlias{mock: m}
	m.GetKnowledgeBaseByIDOrAliasMock.callArgs = []*RepositoryMockGetKnowledgeBaseByIDOrAliasParams{}

	m.GetKnowledgeBaseByOwnerAndKbIDMock = mRepositoryMockGetKnowledgeBaseByOwnerAndKbID{mock: m}
	m.GetKnowledgeBaseByOwnerAndKbIDMock.callArgs = []*RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParams{}

	m.GetKnowledgeBaseByUIDMock = mRepositoryMockGetKnowledgeBaseByUID{mock: m}
	m.GetKnowledgeBaseByUIDMock.callArgs = []*RepositoryMockGetKnowledgeBaseByUIDParams{}

	m.GetKnowledgeBaseByUIDIncludingDeletedMock = mRepositoryMockGetKnowledgeBaseByUIDIncludingDeleted{mock: m}
	m.GetKnowledgeBaseByUIDIncludingDeletedMock.callArgs = []*RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedParams{}

	m.GetKnowledgeBaseByUIDWithConfigMock = mRepositoryMockGetKnowledgeBaseByUIDWithConfig{mock: m}
	m.GetKnowledgeBaseByUIDWithConfigMock.callArgs = []*RepositoryMockGetKnowledgeBaseByUIDWithConfigParams{}

	m.GetKnowledgeBaseCountByOwnerMock = mRepositoryMockGetKnowledgeBaseCountByOwner{mock: m}
	m.GetKnowledgeBaseCountByOwnerMock.callArgs = []*RepositoryMockGetKnowledgeBaseCountByOwnerParams{}

	m.GetKnowledgeBaseFilesByFileIDsMock = mRepositoryMockGetKnowledgeBaseFilesByFileIDs{mock: m}
	m.GetKnowledgeBaseFilesByFileIDsMock.callArgs = []*RepositoryMockGetKnowledgeBaseFilesByFileIDsParams{}

	m.GetKnowledgeBaseFilesByFileUIDsMock = mRepositoryMockGetKnowledgeBaseFilesByFileUIDs{mock: m}
	m.GetKnowledgeBaseFilesByFileUIDsMock.callArgs = []*RepositoryMockGetKnowledgeBaseFilesByFileUIDsParams{}

	m.GetKnowledgeBaseFilesByFileUIDsIncludingDeletedMock = mRepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeleted{mock: m}
	m.GetKnowledgeBaseFilesByFileUIDsIncludingDeletedMock.callArgs = []*RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedParams{}

	m.GetKnowledgeBaseFilesByNameMock = mRepositoryMockGetKnowledgeBaseFilesByName{mock: m}
	m.GetKnowledgeBaseFilesByNameMock.callArgs = []*RepositoryMockGetKnowledgeBaseFilesByNameParams{}

	m.GetKnowledgeBasesByUIDsMock = mRepositoryMockGetKnowledgeBasesByUIDs{mock: m}
	m.GetKnowledgeBasesByUIDsMock.callArgs = []*RepositoryMockGetKnowledgeBasesByUIDsParams{}

	m.GetKnowledgeBasesByUIDsWithConfigMock = mRepositoryMockGetKnowledgeBasesByUIDsWithConfig{mock: m}
	m.GetKnowledgeBasesByUIDsWithConfigMock.callArgs = []*RepositoryMockGetKnowledgeBasesByUIDsWithConfigParams{}

	m.GetKnowledgebaseFileByKBUIDAndFileIDMock = mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID{mock: m}
	m.GetKnowledgebaseFileByKBUIDAndFileIDMock.callArgs = []*RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParams{}

	m.GetMinIOStorageMock = mRepositoryMockGetMinIOStorage{mock: m}

	m.GetNotStartedFileCountMock = mRepositoryMockGetNotStartedFileCount{mock: m}
	m.GetNotStartedFileCountMock.callArgs = []*RepositoryMockGetNotStartedFileCountParams{}

	m.GetNotStartedFileCountExcludingMock = mRepositoryMockGetNotStartedFileCountExcluding{mock: m}
	m.GetNotStartedFileCountExcludingMock.callArgs = []*RepositoryMockGetNotStartedFileCountExcludingParams{}

	m.GetObjectByUIDMock = mRepositoryMockGetObjectByUID{mock: m}
	m.GetObjectByUIDMock.callArgs = []*RepositoryMockGetObjectByUIDParams{}

	m.GetRepositoryTagMock = mRepositoryMockGetRepositoryTag{mock: m}
	m.GetRepositoryTagMock.callArgs = []*RepositoryMockGetRepositoryTagParams{}

	m.GetRollbackKBForProductionMock = mRepositoryMockGetRollbackKBForProduction{mock: m}
	m.GetRollbackKBForProductionMock.callArgs = []*RepositoryMockGetRollbackKBForProductionParams{}

	m.GetSourceByFileUIDMock = mRepositoryMockGetSourceByFileUID{mock: m}
	m.GetSourceByFileUIDMock.callArgs = []*RepositoryMockGetSourceByFileUIDParams{}

	m.GetStagingKBForProductionMock = mRepositoryMockGetStagingKBForProduction{mock: m}
	m.GetStagingKBForProductionMock.callArgs = []*RepositoryMockGetStagingKBForProductionParams{}

	m.GetSystemMock = mRepositoryMockGetSystem{mock: m}
	m.GetSystemMock.callArgs = []*RepositoryMockGetSystemParams{}

	m.GetSystemByUIDMock = mRepositoryMockGetSystemByUID{mock: m}
	m.GetSystemByUIDMock.callArgs = []*RepositoryMockGetSystemByUIDParams{}

	m.GetTextChunksBySourceMock = mRepositoryMockGetTextChunksBySource{mock: m}
	m.GetTextChunksBySourceMock.callArgs = []*RepositoryMockGetTextChunksBySourceParams{}

	m.GetTextChunksByUIDsMock = mRepositoryMockGetTextChunksByUIDs{mock: m}
	m.GetTextChunksByUIDsMock.callArgs = []*RepositoryMockGetTextChunksByUIDsParams{}

	m.GetTotalTextChunksBySourcesMock = mRepositoryMockGetTotalTextChunksBySources{mock: m}
	m.GetTotalTextChunksBySourcesMock.callArgs = []*RepositoryMockGetTotalTextChunksBySourcesParams{}

	m.GetTotalTokensByListKBUIDsMock = mRepositoryMockGetTotalTokensByListKBUIDs{mock: m}
	m.GetTotalTokensByListKBUIDsMock.callArgs = []*RepositoryMockGetTotalTokensByListKBUIDsParams{}

	m.HardDeleteConvertedFileByFileUIDMock = mRepositoryMockHardDeleteConvertedFileByFileUID{mock: m}
	m.HardDeleteConvertedFileByFileUIDMock.callArgs = []*RepositoryMockHardDeleteConvertedFileByFileUIDParams{}

	m.HardDeleteEmbeddingsByKBFileUIDMock = mRepositoryMockHardDeleteEmbeddingsByKBFileUID{mock: m}
	m.HardDeleteEmbeddingsByKBFileUIDMock.callArgs = []*RepositoryMockHardDeleteEmbeddingsByKBFileUIDParams{}

	m.HardDeleteEmbeddingsByKBUIDMock = mRepositoryMockHardDeleteEmbeddingsByKBUID{mock: m}
	m.HardDeleteEmbeddingsByKBUIDMock.callArgs = []*RepositoryMockHardDeleteEmbeddingsByKBUIDParams{}

	m.HardDeleteTextChunksByKBFileUIDMock = mRepositoryMockHardDeleteTextChunksByKBFileUID{mock: m}
	m.HardDeleteTextChunksByKBFileUIDMock.callArgs = []*RepositoryMockHardDeleteTextChunksByKBFileUIDParams{}

	m.HardDeleteTextChunksByKBUIDMock = mRepositoryMockHardDeleteTextChunksByKBUID{mock: m}
	m.HardDeleteTextChunksByKBUIDMock.callArgs = []*RepositoryMockHardDeleteTextChunksByKBUIDParams{}

	m.IncreaseKnowledgeBaseUsageMock = mRepositoryMockIncreaseKnowledgeBaseUsage{mock: m}
	m.IncreaseKnowledgeBaseUsageMock.callArgs = []*RepositoryMockIncreaseKnowledgeBaseUsageParams{}

	m.InsertVectorsInCollectionMock = mRepositoryMockInsertVectorsInCollection{mock: m}
	m.InsertVectorsInCollectionMock.callArgs = []*RepositoryMockInsertVectorsInCollectionParams{}

	m.IsCollectionInUseMock = mRepositoryMockIsCollectionInUse{mock: m}
	m.IsCollectionInUseMock.callArgs = []*RepositoryMockIsCollectionInUseParams{}

	m.IsKBUpdatingMock = mRepositoryMockIsKBUpdating{mock: m}
	m.IsKBUpdatingMock.callArgs = []*RepositoryMockIsKBUpdatingParams{}

	m.ListAllKnowledgeBasesAdminMock = mRepositoryMockListAllKnowledgeBasesAdmin{mock: m}
	m.ListAllKnowledgeBasesAdminMock.callArgs = []*RepositoryMockListAllKnowledgeBasesAdminParams{}

	m.ListAllObjectsMock = mRepositoryMockListAllObjects{mock: m}
	m.ListAllObjectsMock.callArgs = []*RepositoryMockListAllObjectsParams{}

	m.ListEmbeddingsByKBFileUIDMock = mRepositoryMockListEmbeddingsByKBFileUID{mock: m}
	m.ListEmbeddingsByKBFileUIDMock.callArgs = []*RepositoryMockListEmbeddingsByKBFileUIDParams{}

	m.ListKnowledgeBaseFilesMock = mRepositoryMockListKnowledgeBaseFiles{mock: m}
	m.ListKnowledgeBaseFilesMock.callArgs = []*RepositoryMockListKnowledgeBaseFilesParams{}

	m.ListKnowledgeBasesMock = mRepositoryMockListKnowledgeBases{mock: m}
	m.ListKnowledgeBasesMock.callArgs = []*RepositoryMockListKnowledgeBasesParams{}

	m.ListKnowledgeBasesByTypeMock = mRepositoryMockListKnowledgeBasesByType{mock: m}
	m.ListKnowledgeBasesByTypeMock.callArgs = []*RepositoryMockListKnowledgeBasesByTypeParams{}

	m.ListKnowledgeBasesByTypeWithConfigMock = mRepositoryMockListKnowledgeBasesByTypeWithConfig{mock: m}
	m.ListKnowledgeBasesByTypeWithConfigMock.callArgs = []*RepositoryMockListKnowledgeBasesByTypeWithConfigParams{}

	m.ListKnowledgeBasesByUpdateStatusMock = mRepositoryMockListKnowledgeBasesByUpdateStatus{mock: m}
	m.ListKnowledgeBasesByUpdateStatusMock.callArgs = []*RepositoryMockListKnowledgeBasesByUpdateStatusParams{}

	m.ListKnowledgeBasesForUpdateMock = mRepositoryMockListKnowledgeBasesForUpdate{mock: m}
	m.ListKnowledgeBasesForUpdateMock.callArgs = []*RepositoryMockListKnowledgeBasesForUpdateParams{}

	m.ListSystemsMock = mRepositoryMockListSystems{mock: m}
	m.ListSystemsMock.callArgs = []*RepositoryMockListSystemsParams{}

	m.ListTextChunksByKBFileUIDMock = mRepositoryMockListTextChunksByKBFileUID{mock: m}
	m.ListTextChunksByKBFileUIDMock.callArgs = []*RepositoryMockListTextChunksByKBFileUIDParams{}

	m.ProcessKnowledgeBaseFilesMock = mRepositoryMockProcessKnowledgeBaseFiles{mock: m}
	m.ProcessKnowledgeBaseFilesMock.callArgs = []*RepositoryMockProcessKnowledgeBaseFilesParams{}

	m.RenameSystemByIDMock = mRepositoryMockRenameSystemByID{mock: m}
	m.RenameSystemByIDMock.callArgs = []*RepositoryMockRenameSystemByIDParams{}

	m.RenewCacheMetadataTTLMock = mRepositoryMockRenewCacheMetadataTTL{mock: m}
	m.RenewCacheMetadataTTLMock.callArgs = []*RepositoryMockRenewCacheMetadataTTLParams{}

	m.ScanGCSFilesForCleanupMock = mRepositoryMockScanGCSFilesForCleanup{mock: m}
	m.ScanGCSFilesForCleanupMock.callArgs = []*RepositoryMockScanGCSFilesForCleanupParams{}

	m.SearchVectorsInCollectionMock = mRepositoryMockSearchVectorsInCollection{mock: m}
	m.SearchVectorsInCollectionMock.callArgs = []*RepositoryMockSearchVectorsInCollectionParams{}

	m.SetCacheMetadataMock = mRepositoryMockSetCacheMetadata{mock: m}
	m.SetCacheMetadataMock.callArgs = []*RepositoryMockSetCacheMetadataParams{}

	m.SetDefaultSystemMock = mRepositoryMockSetDefaultSystem{mock: m}
	m.SetDefaultSystemMock.callArgs = []*RepositoryMockSetDefaultSystemParams{}

	m.SetGCSFileInfoMock = mRepositoryMockSetGCSFileInfo{mock: m}
	m.SetGCSFileInfoMock.callArgs = []*RepositoryMockSetGCSFileInfoParams{}

	m.UpdateConfigByIDMock = mRepositoryMockUpdateConfigByID{mock: m}
	m.UpdateConfigByIDMock.callArgs = []*RepositoryMockUpdateConfigByIDParams{}

	m.UpdateConvertedFileMock = mRepositoryMockUpdateConvertedFile{mock: m}
	m.UpdateConvertedFileMock.callArgs = []*RepositoryMockUpdateConvertedFileParams{}

	m.UpdateEmbeddingTagsMock = mRepositoryMockUpdateEmbeddingTags{mock: m}
	m.UpdateEmbeddingTagsMock.callArgs = []*RepositoryMockUpdateEmbeddingTagsParams{}

	m.UpdateEmbeddingTagsForFileMock = mRepositoryMockUpdateEmbeddingTagsForFile{mock: m}
	m.UpdateEmbeddingTagsForFileMock.callArgs = []*RepositoryMockUpdateEmbeddingTagsForFileParams{}

	m.UpdateKnowledgeBaseMock = mRepositoryMockUpdateKnowledgeBase{mock: m}
	m.UpdateKnowledgeBaseMock.callArgs = []*RepositoryMockUpdateKnowledgeBaseParams{}

	m.UpdateKnowledgeBaseAbortedMock = mRepositoryMockUpdateKnowledgeBaseAborted{mock: m}
	m.UpdateKnowledgeBaseAbortedMock.callArgs = []*RepositoryMockUpdateKnowledgeBaseAbortedParams{}

	m.UpdateKnowledgeBaseFileMock = mRepositoryMockUpdateKnowledgeBaseFile{mock: m}
	m.UpdateKnowledgeBaseFileMock.callArgs = []*RepositoryMockUpdateKnowledgeBaseFileParams{}

	m.UpdateKnowledgeBaseResourcesMock = mRepositoryMockUpdateKnowledgeBaseResources{mock: m}
	m.UpdateKnowledgeBaseResourcesMock.callArgs = []*RepositoryMockUpdateKnowledgeBaseResourcesParams{}

	m.UpdateKnowledgeBaseResourcesTxMock = mRepositoryMockUpdateKnowledgeBaseResourcesTx{mock: m}
	m.UpdateKnowledgeBaseResourcesTxMock.callArgs = []*RepositoryMockUpdateKnowledgeBaseResourcesTxParams{}

	m.UpdateKnowledgeBaseUpdateStatusMock = mRepositoryMockUpdateKnowledgeBaseUpdateStatus{mock: m}
	m.UpdateKnowledgeBaseUpdateStatusMock.callArgs = []*RepositoryMockUpdateKnowledgeBaseUpdateStatusParams{}

	m.UpdateKnowledgeBaseWithMapMock = mRepositoryMockUpdateKnowledgeBaseWithMap{mock: m}
	m.UpdateKnowledgeBaseWithMapMock.callArgs = []*RepositoryMockUpdateKnowledgeBaseWithMapParams{}

	m.UpdateKnowledgeBaseWithMapTxMock = mRepositoryMockUpdateKnowledgeBaseWithMapTx{mock: m}
	m.UpdateKnowledgeBaseWithMapTxMock.callArgs = []*RepositoryMockUpdateKnowledgeBaseWithMapTxParams{}

	m.UpdateKnowledgeFileMetadataMock = mRepositoryMockUpdateKnowledgeFileMetadata{mock: m}
	m.UpdateKnowledgeFileMetadataMock.callArgs = []*RepositoryMockUpdateKnowledgeFileMetadataParams{}

	m.UpdateKnowledgeFileUsageMetadataMock = mRepositoryMockUpdateKnowledgeFileUsageMetadata{mock: m}
	m.UpdateKnowledgeFileUsageMetadataMock.callArgs = []*RepositoryMockUpdateKnowledgeFileUsageMetadataParams{}

	m.UpdateObjectMock = mRepositoryMockUpdateObject{mock: m}
	m.UpdateObjectMock.callArgs = []*RepositoryMockUpdateObjectParams{}

	m.UpdateObjectByUpdateMapMock = mRepositoryMockUpdateObjectByUpdateMap{mock: m}
	m.UpdateObjectByUpdateMapMock.callArgs = []*RepositoryMockUpdateObjectByUpdateMapParams{}

	m.UpdateSystemMock = mRepositoryMockUpdateSystem{mock: m}
	m.UpdateSystemMock.callArgs = []*RepositoryMockUpdateSystemParams{}

	m.UpdateSystemByUpdateMapMock = mRepositoryMockUpdateSystemByUpdateMap{mock: m}
	m.UpdateSystemByUpdateMapMock.callArgs = []*RepositoryMockUpdateSystemByUpdateMapParams{}

	m.UpdateTextChunkMock = mRepositoryMockUpdateTextChunk{mock: m}
	m.UpdateTextChunkMock.callArgs = []*RepositoryMockUpdateTextChunkParams{}

	m.UpdateTextChunkDestinationsMock = mRepositoryMockUpdateTextChunkDestinations{mock: m}
	m.UpdateTextChunkDestinationsMock.callArgs = []*RepositoryMockUpdateTextChunkDestinationsParams{}

	m.UpsertRepositoryTagMock = mRepositoryMockUpsertRepositoryTag{mock: m}
	m.UpsertRepositoryTagMock.callArgs = []*RepositoryMockUpsertRepositoryTagParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockCheckFileUIDMetadata struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCheckFileUIDMetadataExpectation
	expectations       []*RepositoryMockCheckFileUIDMetadataExpectation

	callArgs []*RepositoryMockCheckFileUIDMetadataParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCheckFileUIDMetadataExpectation specifies expectation struct of the Repository.CheckFileUIDMetadata
type RepositoryMockCheckFileUIDMetadataExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCheckFileUIDMetadataParams
	paramPtrs          *RepositoryMockCheckFileUIDMetadataParamPtrs
	expectationOrigins RepositoryMockCheckFileUIDMetadataExpectationOrigins
	results            *RepositoryMockCheckFileUIDMetadataResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCheckFileUIDMetadataParams contains parameters of the Repository.CheckFileUIDMetadata
type RepositoryMockCheckFileUIDMetadataParams struct {
	ctx          context.Context
	collectionID string
}

// RepositoryMockCheckFileUIDMetadataParamPtrs contains pointers to parameters of the Repository.CheckFileUIDMetadata
type RepositoryMockCheckFileUIDMetadataParamPtrs struct {
	ctx          *context.Context
	collectionID *string
}

// RepositoryMockCheckFileUIDMetadataResults contains results of the Repository.CheckFileUIDMetadata
type RepositoryMockCheckFileUIDMetadataResults struct {
	b1  bool
	err error
}

// RepositoryMockCheckFileUIDMetadataOrigins contains origins of expectations of the Repository.CheckFileUIDMetadata
type RepositoryMockCheckFileUIDMetadataExpectationOrigins struct {
	origin             string
	originCtx          string
	originCollectionID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckFileUIDMetadata *mRepositoryMockCheckFileUIDMetadata) Optional() *mRepositoryMockCheckFileUIDMetadata {
	mmCheckFileUIDMetadata.optional = true
	return mmCheckFileUIDMetadata
}

// Expect sets up expected params for Repository.CheckFileUIDMetadata
func (mmCheckFileUIDMetadata *mRepositoryMockCheckFileUIDMetadata) Expect(ctx context.Context, collectionID string) *mRepositoryMockCheckFileUIDMetadata {
	if mmCheckFileUIDMetadata.mock.funcCheckFileUIDMetadata != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("RepositoryMock.CheckFileUIDMetadata mock is already set by Set")
	}

	if mmCheckFileUIDMetadata.defaultExpectation == nil {
		mmCheckFileUIDMetadata.defaultExpectation = &RepositoryMockCheckFileUIDMetadataExpectation{}
	}

	if mmCheckFileUIDMetadata.defaultExpectation.paramPtrs != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("RepositoryMock.CheckFileUIDMetadata mock is already set by ExpectParams functions")
	}

	mmCheckFileUIDMetadata.defaultExpectation.params = &RepositoryMockCheckFileUIDMetadataParams{ctx, collectionID}
	mmCheckFileUIDMetadata.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckFileUIDMetadata.expectations {
		if minimock.Equal(e.params, mmCheckFileUIDMetadata.defaultExpectation.params) {
			mmCheckFileUIDMetadata.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckFileUIDMetadata.defaultExpectation.params)
		}
	}

	return mmCheckFileUIDMetadata
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CheckFileUIDMetadata
func (mmCheckFileUIDMetadata *mRepositoryMockCheckFileUIDMetadata) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCheckFileUIDMetadata {
	if mmCheckFileUIDMetadata.mock.funcCheckFileUIDMetadata != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("RepositoryMock.CheckFileUIDMetadata mock is already set by Set")
	}

	if mmCheckFileUIDMetadata.defaultExpectation == nil {
		mmCheckFileUIDMetadata.defaultExpectation = &RepositoryMockCheckFileUIDMetadataExpectation{}
	}

	if mmCheckFileUIDMetadata.defaultExpectation.params != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("RepositoryMock.CheckFileUIDMetadata mock is already set by Expect")
	}

	if mmCheckFileUIDMetadata.defaultExpectation.paramPtrs == nil {
		mmCheckFileUIDMetadata.defaultExpectation.paramPtrs = &RepositoryMockCheckFileUIDMetadataParamPtrs{}
	}
	mmCheckFileUIDMetadata.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckFileUIDMetadata.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckFileUIDMetadata
}

// ExpectCollectionIDParam2 sets up expected param collectionID for Repository.CheckFileUIDMetadata
func (mmCheckFileUIDMetadata *mRepositoryMockCheckFileUIDMetadata) ExpectCollectionIDParam2(collectionID string) *mRepositoryMockCheckFileUIDMetadata {
	if mmCheckFileUIDMetadata.mock.funcCheckFileUIDMetadata != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("RepositoryMock.CheckFileUIDMetadata mock is already set by Set")
	}

	if mmCheckFileUIDMetadata.defaultExpectation == nil {
		mmCheckFileUIDMetadata.defaultExpectation = &RepositoryMockCheckFileUIDMetadataExpectation{}
	}

	if mmCheckFileUIDMetadata.defaultExpectation.params != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("RepositoryMock.CheckFileUIDMetadata mock is already set by Expect")
	}

	if mmCheckFileUIDMetadata.defaultExpectation.paramPtrs == nil {
		mmCheckFileUIDMetadata.defaultExpectation.paramPtrs = &RepositoryMockCheckFileUIDMetadataParamPtrs{}
	}
	mmCheckFileUIDMetadata.defaultExpectation.paramPtrs.collectionID = &collectionID
	mmCheckFileUIDMetadata.defaultExpectation.expectationOrigins.originCollectionID = minimock.CallerInfo(1)

	return mmCheckFileUIDMetadata
}

// Inspect accepts an inspector function that has same arguments as the Repository.CheckFileUIDMetadata
func (mmCheckFileUIDMetadata *mRepositoryMockCheckFileUIDMetadata) Inspect(f func(ctx context.Context, collectionID string)) *mRepositoryMockCheckFileUIDMetadata {
	if mmCheckFileUIDMetadata.mock.inspectFuncCheckFileUIDMetadata != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CheckFileUIDMetadata")
	}

	mmCheckFileUIDMetadata.mock.inspectFuncCheckFileUIDMetadata = f

	return mmCheckFileUIDMetadata
}

// Return sets up results that will be returned by Repository.CheckFileUIDMetadata
func (mmCheckFileUIDMetadata *mRepositoryMockCheckFileUIDMetadata) Return(b1 bool, err error) *RepositoryMock {
	if mmCheckFileUIDMetadata.mock.funcCheckFileUIDMetadata != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("RepositoryMock.CheckFileUIDMetadata mock is already set by Set")
	}

	if mmCheckFileUIDMetadata.defaultExpectation == nil {
		mmCheckFileUIDMetadata.defaultExpectation = &RepositoryMockCheckFileUIDMetadataExpectation{mock: mmCheckFileUIDMetadata.mock}
	}
	mmCheckFileUIDMetadata.defaultExpectation.results = &RepositoryMockCheckFileUIDMetadataResults{b1, err}
	mmCheckFileUIDMetadata.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckFileUIDMetadata.mock
}

// Set uses given function f to mock the Repository.CheckFileUIDMetadata method
func (mmCheckFileUIDMetadata *mRepositoryMockCheckFileUIDMetadata) Set(f func(ctx context.Context, collectionID string) (b1 bool, err error)) *RepositoryMock {
	if mmCheckFileUIDMetadata.defaultExpectation != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("Default expectation is already set for the Repository.CheckFileUIDMetadata method")
	}

	if len(mmCheckFileUIDMetadata.expectations) > 0 {
		mmCheckFileUIDMetadata.mock.t.Fatalf("Some expectations are already set for the Repository.CheckFileUIDMetadata method")
	}

	mmCheckFileUIDMetadata.mock.funcCheckFileUIDMetadata = f
	mmCheckFileUIDMetadata.mock.funcCheckFileUIDMetadataOrigin = minimock.CallerInfo(1)
	return mmCheckFileUIDMetadata.mock
}

// When sets expectation for the Repository.CheckFileUIDMetadata which will trigger the result defined by the following
// Then helper
func (mmCheckFileUIDMetadata *mRepositoryMockCheckFileUIDMetadata) When(ctx context.Context, collectionID string) *RepositoryMockCheckFileUIDMetadataExpectation {
	if mmCheckFileUIDMetadata.mock.funcCheckFileUIDMetadata != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("RepositoryMock.CheckFileUIDMetadata mock is already set by Set")
	}

	expectation := &RepositoryMockCheckFileUIDMetadataExpectation{
		mock:               mmCheckFileUIDMetadata.mock,
		params:             &RepositoryMockCheckFileUIDMetadataParams{ctx, collectionID},
		expectationOrigins: RepositoryMockCheckFileUIDMetadataExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckFileUIDMetadata.expectations = append(mmCheckFileUIDMetadata.expectations, expectation)
	return expectation
}

// Then sets up Repository.CheckFileUIDMetadata return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCheckFileUIDMetadataExpectation) Then(b1 bool, err error) *RepositoryMock {
	e.results = &RepositoryMockCheckFileUIDMetadataResults{b1, err}
	return e.mock
}

// Times sets number of times Repository.CheckFileUIDMetadata should be invoked
func (mmCheckFileUIDMetadata *mRepositoryMockCheckFileUIDMetadata) Times(n uint64) *mRepositoryMockCheckFileUIDMetadata {
	if n == 0 {
		mmCheckFileUIDMetadata.mock.t.Fatalf("Times of RepositoryMock.CheckFileUIDMetadata mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckFileUIDMetadata.expectedInvocations, n)
	mmCheckFileUIDMetadata.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckFileUIDMetadata
}

func (mmCheckFileUIDMetadata *mRepositoryMockCheckFileUIDMetadata) invocationsDone() bool {
	if len(mmCheckFileUIDMetadata.expectations) == 0 && mmCheckFileUIDMetadata.defaultExpectation == nil && mmCheckFileUIDMetadata.mock.funcCheckFileUIDMetadata == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckFileUIDMetadata.mock.afterCheckFileUIDMetadataCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckFileUIDMetadata.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckFileUIDMetadata implements mm_repository.Repository
func (mmCheckFileUIDMetadata *RepositoryMock) CheckFileUIDMetadata(ctx context.Context, collectionID string) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmCheckFileUIDMetadata.beforeCheckFileUIDMetadataCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckFileUIDMetadata.afterCheckFileUIDMetadataCounter, 1)

	mmCheckFileUIDMetadata.t.Helper()

	if mmCheckFileUIDMetadata.inspectFuncCheckFileUIDMetadata != nil {
		mmCheckFileUIDMetadata.inspectFuncCheckFileUIDMetadata(ctx, collectionID)
	}

	mm_params := RepositoryMockCheckFileUIDMetadataParams{ctx, collectionID}

	// Record call args
	mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.mutex.Lock()
	mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.callArgs = append(mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.callArgs, &mm_params)
	mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.mutex.Unlock()

	for _, e := range mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.defaultExpectation.params
		mm_want_ptrs := mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCheckFileUIDMetadataParams{ctx, collectionID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckFileUIDMetadata.t.Errorf("RepositoryMock.CheckFileUIDMetadata got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.collectionID != nil && !minimock.Equal(*mm_want_ptrs.collectionID, mm_got.collectionID) {
				mmCheckFileUIDMetadata.t.Errorf("RepositoryMock.CheckFileUIDMetadata got unexpected parameter collectionID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.defaultExpectation.expectationOrigins.originCollectionID, *mm_want_ptrs.collectionID, mm_got.collectionID, minimock.Diff(*mm_want_ptrs.collectionID, mm_got.collectionID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckFileUIDMetadata.t.Errorf("RepositoryMock.CheckFileUIDMetadata got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckFileUIDMetadata.t.Fatal("No results are set for the RepositoryMock.CheckFileUIDMetadata")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmCheckFileUIDMetadata.funcCheckFileUIDMetadata != nil {
		return mmCheckFileUIDMetadata.funcCheckFileUIDMetadata(ctx, collectionID)
	}
	mmCheckFileUIDMetadata.t.Fatalf("Unexpected call to RepositoryMock.CheckFileUIDMetadata. %v %v", ctx, collectionID)
	return
}

// CheckFileUIDMetadataAfterCounter returns a count of finished RepositoryMock.CheckFileUIDMetadata invocations
func (mmCheckFileUIDMetadata *RepositoryMock) CheckFileUIDMetadataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckFileUIDMetadata.afterCheckFileUIDMetadataCounter)
}

// CheckFileUIDMetadataBeforeCounter returns a count of RepositoryMock.CheckFileUIDMetadata invocations
func (mmCheckFileUIDMetadata *RepositoryMock) CheckFileUIDMetadataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckFileUIDMetadata.beforeCheckFileUIDMetadataCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CheckFileUIDMetadata.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckFileUIDMetadata *mRepositoryMockCheckFileUIDMetadata) Calls() []*RepositoryMockCheckFileUIDMetadataParams {
	mmCheckFileUIDMetadata.mutex.RLock()

	argCopy := make([]*RepositoryMockCheckFileUIDMetadataParams, len(mmCheckFileUIDMetadata.callArgs))
	copy(argCopy, mmCheckFileUIDMetadata.callArgs)

	mmCheckFileUIDMetadata.mutex.RUnlock()

	return argCopy
}

// MinimockCheckFileUIDMetadataDone returns true if the count of the CheckFileUIDMetadata invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCheckFileUIDMetadataDone() bool {
	if m.CheckFileUIDMetadataMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckFileUIDMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckFileUIDMetadataMock.invocationsDone()
}

// MinimockCheckFileUIDMetadataInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCheckFileUIDMetadataInspect() {
	for _, e := range m.CheckFileUIDMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CheckFileUIDMetadata at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckFileUIDMetadataCounter := mm_atomic.LoadUint64(&m.afterCheckFileUIDMetadataCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckFileUIDMetadataMock.defaultExpectation != nil && afterCheckFileUIDMetadataCounter < 1 {
		if m.CheckFileUIDMetadataMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CheckFileUIDMetadata at\n%s", m.CheckFileUIDMetadataMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CheckFileUIDMetadata at\n%s with params: %#v", m.CheckFileUIDMetadataMock.defaultExpectation.expectationOrigins.origin, *m.CheckFileUIDMetadataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckFileUIDMetadata != nil && afterCheckFileUIDMetadataCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CheckFileUIDMetadata at\n%s", m.funcCheckFileUIDMetadataOrigin)
	}

	if !m.CheckFileUIDMetadataMock.invocationsDone() && afterCheckFileUIDMetadataCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CheckFileUIDMetadata at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckFileUIDMetadataMock.expectedInvocations), m.CheckFileUIDMetadataMock.expectedInvocationsOrigin, afterCheckFileUIDMetadataCounter)
	}
}

type mRepositoryMockCheckGCSFileExists struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCheckGCSFileExistsExpectation
	expectations       []*RepositoryMockCheckGCSFileExistsExpectation

	callArgs []*RepositoryMockCheckGCSFileExistsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCheckGCSFileExistsExpectation specifies expectation struct of the Repository.CheckGCSFileExists
type RepositoryMockCheckGCSFileExistsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCheckGCSFileExistsParams
	paramPtrs          *RepositoryMockCheckGCSFileExistsParamPtrs
	expectationOrigins RepositoryMockCheckGCSFileExistsExpectationOrigins
	results            *RepositoryMockCheckGCSFileExistsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCheckGCSFileExistsParams contains parameters of the Repository.CheckGCSFileExists
type RepositoryMockCheckGCSFileExistsParams struct {
	ctx     context.Context
	kbUID   types.KBUIDType
	fileUID types.FileUIDType
	view    string
}

// RepositoryMockCheckGCSFileExistsParamPtrs contains pointers to parameters of the Repository.CheckGCSFileExists
type RepositoryMockCheckGCSFileExistsParamPtrs struct {
	ctx     *context.Context
	kbUID   *types.KBUIDType
	fileUID *types.FileUIDType
	view    *string
}

// RepositoryMockCheckGCSFileExistsResults contains results of the Repository.CheckGCSFileExists
type RepositoryMockCheckGCSFileExistsResults struct {
	b1  bool
	err error
}

// RepositoryMockCheckGCSFileExistsOrigins contains origins of expectations of the Repository.CheckGCSFileExists
type RepositoryMockCheckGCSFileExistsExpectationOrigins struct {
	origin        string
	originCtx     string
	originKbUID   string
	originFileUID string
	originView    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckGCSFileExists *mRepositoryMockCheckGCSFileExists) Optional() *mRepositoryMockCheckGCSFileExists {
	mmCheckGCSFileExists.optional = true
	return mmCheckGCSFileExists
}

// Expect sets up expected params for Repository.CheckGCSFileExists
func (mmCheckGCSFileExists *mRepositoryMockCheckGCSFileExists) Expect(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, view string) *mRepositoryMockCheckGCSFileExists {
	if mmCheckGCSFileExists.mock.funcCheckGCSFileExists != nil {
		mmCheckGCSFileExists.mock.t.Fatalf("RepositoryMock.CheckGCSFileExists mock is already set by Set")
	}

	if mmCheckGCSFileExists.defaultExpectation == nil {
		mmCheckGCSFileExists.defaultExpectation = &RepositoryMockCheckGCSFileExistsExpectation{}
	}

	if mmCheckGCSFileExists.defaultExpectation.paramPtrs != nil {
		mmCheckGCSFileExists.mock.t.Fatalf("RepositoryMock.CheckGCSFileExists mock is already set by ExpectParams functions")
	}

	mmCheckGCSFileExists.defaultExpectation.params = &RepositoryMockCheckGCSFileExistsParams{ctx, kbUID, fileUID, view}
	mmCheckGCSFileExists.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckGCSFileExists.expectations {
		if minimock.Equal(e.params, mmCheckGCSFileExists.defaultExpectation.params) {
			mmCheckGCSFileExists.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckGCSFileExists.defaultExpectation.params)
		}
	}

	return mmCheckGCSFileExists
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CheckGCSFileExists
func (mmCheckGCSFileExists *mRepositoryMockCheckGCSFileExists) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCheckGCSFileExists {
	if mmCheckGCSFileExists.mock.funcCheckGCSFileExists != nil {
		mmCheckGCSFileExists.mock.t.Fatalf("RepositoryMock.CheckGCSFileExists mock is already set by Set")
	}

	if mmCheckGCSFileExists.defaultExpectation == nil {
		mmCheckGCSFileExists.defaultExpectation = &RepositoryMockCheckGCSFileExistsExpectation{}
	}

	if mmCheckGCSFileExists.defaultExpectation.params != nil {
		mmCheckGCSFileExists.mock.t.Fatalf("RepositoryMock.CheckGCSFileExists mock is already set by Expect")
	}

	if mmCheckGCSFileExists.defaultExpectation.paramPtrs == nil {
		mmCheckGCSFileExists.defaultExpectation.paramPtrs = &RepositoryMockCheckGCSFileExistsParamPtrs{}
	}
	mmCheckGCSFileExists.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckGCSFileExists.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckGCSFileExists
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.CheckGCSFileExists
func (mmCheckGCSFileExists *mRepositoryMockCheckGCSFileExists) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockCheckGCSFileExists {
	if mmCheckGCSFileExists.mock.funcCheckGCSFileExists != nil {
		mmCheckGCSFileExists.mock.t.Fatalf("RepositoryMock.CheckGCSFileExists mock is already set by Set")
	}

	if mmCheckGCSFileExists.defaultExpectation == nil {
		mmCheckGCSFileExists.defaultExpectation = &RepositoryMockCheckGCSFileExistsExpectation{}
	}

	if mmCheckGCSFileExists.defaultExpectation.params != nil {
		mmCheckGCSFileExists.mock.t.Fatalf("RepositoryMock.CheckGCSFileExists mock is already set by Expect")
	}

	if mmCheckGCSFileExists.defaultExpectation.paramPtrs == nil {
		mmCheckGCSFileExists.defaultExpectation.paramPtrs = &RepositoryMockCheckGCSFileExistsParamPtrs{}
	}
	mmCheckGCSFileExists.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmCheckGCSFileExists.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmCheckGCSFileExists
}

// ExpectFileUIDParam3 sets up expected param fileUID for Repository.CheckGCSFileExists
func (mmCheckGCSFileExists *mRepositoryMockCheckGCSFileExists) ExpectFileUIDParam3(fileUID types.FileUIDType) *mRepositoryMockCheckGCSFileExists {
	if mmCheckGCSFileExists.mock.funcCheckGCSFileExists != nil {
		mmCheckGCSFileExists.mock.t.Fatalf("RepositoryMock.CheckGCSFileExists mock is already set by Set")
	}

	if mmCheckGCSFileExists.defaultExpectation == nil {
		mmCheckGCSFileExists.defaultExpectation = &RepositoryMockCheckGCSFileExistsExpectation{}
	}

	if mmCheckGCSFileExists.defaultExpectation.params != nil {
		mmCheckGCSFileExists.mock.t.Fatalf("RepositoryMock.CheckGCSFileExists mock is already set by Expect")
	}

	if mmCheckGCSFileExists.defaultExpectation.paramPtrs == nil {
		mmCheckGCSFileExists.defaultExpectation.paramPtrs = &RepositoryMockCheckGCSFileExistsParamPtrs{}
	}
	mmCheckGCSFileExists.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmCheckGCSFileExists.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmCheckGCSFileExists
}

// ExpectViewParam4 sets up expected param view for Repository.CheckGCSFileExists
func (mmCheckGCSFileExists *mRepositoryMockCheckGCSFileExists) ExpectViewParam4(view string) *mRepositoryMockCheckGCSFileExists {
	if mmCheckGCSFileExists.mock.funcCheckGCSFileExists != nil {
		mmCheckGCSFileExists.mock.t.Fatalf("RepositoryMock.CheckGCSFileExists mock is already set by Set")
	}

	if mmCheckGCSFileExists.defaultExpectation == nil {
		mmCheckGCSFileExists.defaultExpectation = &RepositoryMockCheckGCSFileExistsExpectation{}
	}

	if mmCheckGCSFileExists.defaultExpectation.params != nil {
		mmCheckGCSFileExists.mock.t.Fatalf("RepositoryMock.CheckGCSFileExists mock is already set by Expect")
	}

	if mmCheckGCSFileExists.defaultExpectation.paramPtrs == nil {
		mmCheckGCSFileExists.defaultExpectation.paramPtrs = &RepositoryMockCheckGCSFileExistsParamPtrs{}
	}
	mmCheckGCSFileExists.defaultExpectation.paramPtrs.view = &view
	mmCheckGCSFileExists.defaultExpectation.expectationOrigins.originView = minimock.CallerInfo(1)

	return mmCheckGCSFileExists
}

// Inspect accepts an inspector function that has same arguments as the Repository.CheckGCSFileExists
func (mmCheckGCSFileExists *mRepositoryMockCheckGCSFileExists) Inspect(f func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, view string)) *mRepositoryMockCheckGCSFileExists {
	if mmCheckGCSFileExists.mock.inspectFuncCheckGCSFileExists != nil {
		mmCheckGCSFileExists.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CheckGCSFileExists")
	}

	mmCheckGCSFileExists.mock.inspectFuncCheckGCSFileExists = f

	return mmCheckGCSFileExists
}

// Return sets up results that will be returned by Repository.CheckGCSFileExists
func (mmCheckGCSFileExists *mRepositoryMockCheckGCSFileExists) Return(b1 bool, err error) *RepositoryMock {
	if mmCheckGCSFileExists.mock.funcCheckGCSFileExists != nil {
		mmCheckGCSFileExists.mock.t.Fatalf("RepositoryMock.CheckGCSFileExists mock is already set by Set")
	}

	if mmCheckGCSFileExists.defaultExpectation == nil {
		mmCheckGCSFileExists.defaultExpectation = &RepositoryMockCheckGCSFileExistsExpectation{mock: mmCheckGCSFileExists.mock}
	}
	mmCheckGCSFileExists.defaultExpectation.results = &RepositoryMockCheckGCSFileExistsResults{b1, err}
	mmCheckGCSFileExists.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckGCSFileExists.mock
}

// Set uses given function f to mock the Repository.CheckGCSFileExists method
func (mmCheckGCSFileExists *mRepositoryMockCheckGCSFileExists) Set(f func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, view string) (b1 bool, err error)) *RepositoryMock {
	if mmCheckGCSFileExists.defaultExpectation != nil {
		mmCheckGCSFileExists.mock.t.Fatalf("Default expectation is already set for the Repository.CheckGCSFileExists method")
	}

	if len(mmCheckGCSFileExists.expectations) > 0 {
		mmCheckGCSFileExists.mock.t.Fatalf("Some expectations are already set for the Repository.CheckGCSFileExists method")
	}

	mmCheckGCSFileExists.mock.funcCheckGCSFileExists = f
	mmCheckGCSFileExists.mock.funcCheckGCSFileExistsOrigin = minimock.CallerInfo(1)
	return mmCheckGCSFileExists.mock
}

// When sets expectation for the Repository.CheckGCSFileExists which will trigger the result defined by the following
// Then helper
func (mmCheckGCSFileExists *mRepositoryMockCheckGCSFileExists) When(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, view string) *RepositoryMockCheckGCSFileExistsExpectation {
	if mmCheckGCSFileExists.mock.funcCheckGCSFileExists != nil {
		mmCheckGCSFileExists.mock.t.Fatalf("RepositoryMock.CheckGCSFileExists mock is already set by Set")
	}

	expectation := &RepositoryMockCheckGCSFileExistsExpectation{
		mock:               mmCheckGCSFileExists.mock,
		params:             &RepositoryMockCheckGCSFileExistsParams{ctx, kbUID, fileUID, view},
		expectationOrigins: RepositoryMockCheckGCSFileExistsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckGCSFileExists.expectations = append(mmCheckGCSFileExists.expectations, expectation)
	return expectation
}

// Then sets up Repository.CheckGCSFileExists return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCheckGCSFileExistsExpectation) Then(b1 bool, err error) *RepositoryMock {
	e.results = &RepositoryMockCheckGCSFileExistsResults{b1, err}
	return e.mock
}

// Times sets number of times Repository.CheckGCSFileExists should be invoked
func (mmCheckGCSFileExists *mRepositoryMockCheckGCSFileExists) Times(n uint64) *mRepositoryMockCheckGCSFileExists {
	if n == 0 {
		mmCheckGCSFileExists.mock.t.Fatalf("Times of RepositoryMock.CheckGCSFileExists mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckGCSFileExists.expectedInvocations, n)
	mmCheckGCSFileExists.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckGCSFileExists
}

func (mmCheckGCSFileExists *mRepositoryMockCheckGCSFileExists) invocationsDone() bool {
	if len(mmCheckGCSFileExists.expectations) == 0 && mmCheckGCSFileExists.defaultExpectation == nil && mmCheckGCSFileExists.mock.funcCheckGCSFileExists == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckGCSFileExists.mock.afterCheckGCSFileExistsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckGCSFileExists.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckGCSFileExists implements mm_repository.Repository
func (mmCheckGCSFileExists *RepositoryMock) CheckGCSFileExists(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, view string) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmCheckGCSFileExists.beforeCheckGCSFileExistsCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckGCSFileExists.afterCheckGCSFileExistsCounter, 1)

	mmCheckGCSFileExists.t.Helper()

	if mmCheckGCSFileExists.inspectFuncCheckGCSFileExists != nil {
		mmCheckGCSFileExists.inspectFuncCheckGCSFileExists(ctx, kbUID, fileUID, view)
	}

	mm_params := RepositoryMockCheckGCSFileExistsParams{ctx, kbUID, fileUID, view}

	// Record call args
	mmCheckGCSFileExists.CheckGCSFileExistsMock.mutex.Lock()
	mmCheckGCSFileExists.CheckGCSFileExistsMock.callArgs = append(mmCheckGCSFileExists.CheckGCSFileExistsMock.callArgs, &mm_params)
	mmCheckGCSFileExists.CheckGCSFileExistsMock.mutex.Unlock()

	for _, e := range mmCheckGCSFileExists.CheckGCSFileExistsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmCheckGCSFileExists.CheckGCSFileExistsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckGCSFileExists.CheckGCSFileExistsMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckGCSFileExists.CheckGCSFileExistsMock.defaultExpectation.params
		mm_want_ptrs := mmCheckGCSFileExists.CheckGCSFileExistsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCheckGCSFileExistsParams{ctx, kbUID, fileUID, view}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckGCSFileExists.t.Errorf("RepositoryMock.CheckGCSFileExists got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckGCSFileExists.CheckGCSFileExistsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmCheckGCSFileExists.t.Errorf("RepositoryMock.CheckGCSFileExists got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckGCSFileExists.CheckGCSFileExistsMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmCheckGCSFileExists.t.Errorf("RepositoryMock.CheckGCSFileExists got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckGCSFileExists.CheckGCSFileExistsMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

			if mm_want_ptrs.view != nil && !minimock.Equal(*mm_want_ptrs.view, mm_got.view) {
				mmCheckGCSFileExists.t.Errorf("RepositoryMock.CheckGCSFileExists got unexpected parameter view, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckGCSFileExists.CheckGCSFileExistsMock.defaultExpectation.expectationOrigins.originView, *mm_want_ptrs.view, mm_got.view, minimock.Diff(*mm_want_ptrs.view, mm_got.view))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckGCSFileExists.t.Errorf("RepositoryMock.CheckGCSFileExists got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckGCSFileExists.CheckGCSFileExistsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckGCSFileExists.CheckGCSFileExistsMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckGCSFileExists.t.Fatal("No results are set for the RepositoryMock.CheckGCSFileExists")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmCheckGCSFileExists.funcCheckGCSFileExists != nil {
		return mmCheckGCSFileExists.funcCheckGCSFileExists(ctx, kbUID, fileUID, view)
	}
	mmCheckGCSFileExists.t.Fatalf("Unexpected call to RepositoryMock.CheckGCSFileExists. %v %v %v %v", ctx, kbUID, fileUID, view)
	return
}

// CheckGCSFileExistsAfterCounter returns a count of finished RepositoryMock.CheckGCSFileExists invocations
func (mmCheckGCSFileExists *RepositoryMock) CheckGCSFileExistsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckGCSFileExists.afterCheckGCSFileExistsCounter)
}

// CheckGCSFileExistsBeforeCounter returns a count of RepositoryMock.CheckGCSFileExists invocations
func (mmCheckGCSFileExists *RepositoryMock) CheckGCSFileExistsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckGCSFileExists.beforeCheckGCSFileExistsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CheckGCSFileExists.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckGCSFileExists *mRepositoryMockCheckGCSFileExists) Calls() []*RepositoryMockCheckGCSFileExistsParams {
	mmCheckGCSFileExists.mutex.RLock()

	argCopy := make([]*RepositoryMockCheckGCSFileExistsParams, len(mmCheckGCSFileExists.callArgs))
	copy(argCopy, mmCheckGCSFileExists.callArgs)

	mmCheckGCSFileExists.mutex.RUnlock()

	return argCopy
}

// MinimockCheckGCSFileExistsDone returns true if the count of the CheckGCSFileExists invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCheckGCSFileExistsDone() bool {
	if m.CheckGCSFileExistsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckGCSFileExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckGCSFileExistsMock.invocationsDone()
}

// MinimockCheckGCSFileExistsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCheckGCSFileExistsInspect() {
	for _, e := range m.CheckGCSFileExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CheckGCSFileExists at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckGCSFileExistsCounter := mm_atomic.LoadUint64(&m.afterCheckGCSFileExistsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckGCSFileExistsMock.defaultExpectation != nil && afterCheckGCSFileExistsCounter < 1 {
		if m.CheckGCSFileExistsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CheckGCSFileExists at\n%s", m.CheckGCSFileExistsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CheckGCSFileExists at\n%s with params: %#v", m.CheckGCSFileExistsMock.defaultExpectation.expectationOrigins.origin, *m.CheckGCSFileExistsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckGCSFileExists != nil && afterCheckGCSFileExistsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CheckGCSFileExists at\n%s", m.funcCheckGCSFileExistsOrigin)
	}

	if !m.CheckGCSFileExistsMock.invocationsDone() && afterCheckGCSFileExistsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CheckGCSFileExists at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckGCSFileExistsMock.expectedInvocations), m.CheckGCSFileExistsMock.expectedInvocationsOrigin, afterCheckGCSFileExistsCounter)
	}
}

type mRepositoryMockCollectionExists struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCollectionExistsExpectation
	expectations       []*RepositoryMockCollectionExistsExpectation

	callArgs []*RepositoryMockCollectionExistsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCollectionExistsExpectation specifies expectation struct of the Repository.CollectionExists
type RepositoryMockCollectionExistsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCollectionExistsParams
	paramPtrs          *RepositoryMockCollectionExistsParamPtrs
	expectationOrigins RepositoryMockCollectionExistsExpectationOrigins
	results            *RepositoryMockCollectionExistsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCollectionExistsParams contains parameters of the Repository.CollectionExists
type RepositoryMockCollectionExistsParams struct {
	ctx          context.Context
	collectionID string
}

// RepositoryMockCollectionExistsParamPtrs contains pointers to parameters of the Repository.CollectionExists
type RepositoryMockCollectionExistsParamPtrs struct {
	ctx          *context.Context
	collectionID *string
}

// RepositoryMockCollectionExistsResults contains results of the Repository.CollectionExists
type RepositoryMockCollectionExistsResults struct {
	b1  bool
	err error
}

// RepositoryMockCollectionExistsOrigins contains origins of expectations of the Repository.CollectionExists
type RepositoryMockCollectionExistsExpectationOrigins struct {
	origin             string
	originCtx          string
	originCollectionID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCollectionExists *mRepositoryMockCollectionExists) Optional() *mRepositoryMockCollectionExists {
	mmCollectionExists.optional = true
	return mmCollectionExists
}

// Expect sets up expected params for Repository.CollectionExists
func (mmCollectionExists *mRepositoryMockCollectionExists) Expect(ctx context.Context, collectionID string) *mRepositoryMockCollectionExists {
	if mmCollectionExists.mock.funcCollectionExists != nil {
		mmCollectionExists.mock.t.Fatalf("RepositoryMock.CollectionExists mock is already set by Set")
	}

	if mmCollectionExists.defaultExpectation == nil {
		mmCollectionExists.defaultExpectation = &RepositoryMockCollectionExistsExpectation{}
	}

	if mmCollectionExists.defaultExpectation.paramPtrs != nil {
		mmCollectionExists.mock.t.Fatalf("RepositoryMock.CollectionExists mock is already set by ExpectParams functions")
	}

	mmCollectionExists.defaultExpectation.params = &RepositoryMockCollectionExistsParams{ctx, collectionID}
	mmCollectionExists.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCollectionExists.expectations {
		if minimock.Equal(e.params, mmCollectionExists.defaultExpectation.params) {
			mmCollectionExists.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCollectionExists.defaultExpectation.params)
		}
	}

	return mmCollectionExists
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CollectionExists
func (mmCollectionExists *mRepositoryMockCollectionExists) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCollectionExists {
	if mmCollectionExists.mock.funcCollectionExists != nil {
		mmCollectionExists.mock.t.Fatalf("RepositoryMock.CollectionExists mock is already set by Set")
	}

	if mmCollectionExists.defaultExpectation == nil {
		mmCollectionExists.defaultExpectation = &RepositoryMockCollectionExistsExpectation{}
	}

	if mmCollectionExists.defaultExpectation.params != nil {
		mmCollectionExists.mock.t.Fatalf("RepositoryMock.CollectionExists mock is already set by Expect")
	}

	if mmCollectionExists.defaultExpectation.paramPtrs == nil {
		mmCollectionExists.defaultExpectation.paramPtrs = &RepositoryMockCollectionExistsParamPtrs{}
	}
	mmCollectionExists.defaultExpectation.paramPtrs.ctx = &ctx
	mmCollectionExists.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCollectionExists
}

// ExpectCollectionIDParam2 sets up expected param collectionID for Repository.CollectionExists
func (mmCollectionExists *mRepositoryMockCollectionExists) ExpectCollectionIDParam2(collectionID string) *mRepositoryMockCollectionExists {
	if mmCollectionExists.mock.funcCollectionExists != nil {
		mmCollectionExists.mock.t.Fatalf("RepositoryMock.CollectionExists mock is already set by Set")
	}

	if mmCollectionExists.defaultExpectation == nil {
		mmCollectionExists.defaultExpectation = &RepositoryMockCollectionExistsExpectation{}
	}

	if mmCollectionExists.defaultExpectation.params != nil {
		mmCollectionExists.mock.t.Fatalf("RepositoryMock.CollectionExists mock is already set by Expect")
	}

	if mmCollectionExists.defaultExpectation.paramPtrs == nil {
		mmCollectionExists.defaultExpectation.paramPtrs = &RepositoryMockCollectionExistsParamPtrs{}
	}
	mmCollectionExists.defaultExpectation.paramPtrs.collectionID = &collectionID
	mmCollectionExists.defaultExpectation.expectationOrigins.originCollectionID = minimock.CallerInfo(1)

	return mmCollectionExists
}

// Inspect accepts an inspector function that has same arguments as the Repository.CollectionExists
func (mmCollectionExists *mRepositoryMockCollectionExists) Inspect(f func(ctx context.Context, collectionID string)) *mRepositoryMockCollectionExists {
	if mmCollectionExists.mock.inspectFuncCollectionExists != nil {
		mmCollectionExists.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CollectionExists")
	}

	mmCollectionExists.mock.inspectFuncCollectionExists = f

	return mmCollectionExists
}

// Return sets up results that will be returned by Repository.CollectionExists
func (mmCollectionExists *mRepositoryMockCollectionExists) Return(b1 bool, err error) *RepositoryMock {
	if mmCollectionExists.mock.funcCollectionExists != nil {
		mmCollectionExists.mock.t.Fatalf("RepositoryMock.CollectionExists mock is already set by Set")
	}

	if mmCollectionExists.defaultExpectation == nil {
		mmCollectionExists.defaultExpectation = &RepositoryMockCollectionExistsExpectation{mock: mmCollectionExists.mock}
	}
	mmCollectionExists.defaultExpectation.results = &RepositoryMockCollectionExistsResults{b1, err}
	mmCollectionExists.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCollectionExists.mock
}

// Set uses given function f to mock the Repository.CollectionExists method
func (mmCollectionExists *mRepositoryMockCollectionExists) Set(f func(ctx context.Context, collectionID string) (b1 bool, err error)) *RepositoryMock {
	if mmCollectionExists.defaultExpectation != nil {
		mmCollectionExists.mock.t.Fatalf("Default expectation is already set for the Repository.CollectionExists method")
	}

	if len(mmCollectionExists.expectations) > 0 {
		mmCollectionExists.mock.t.Fatalf("Some expectations are already set for the Repository.CollectionExists method")
	}

	mmCollectionExists.mock.funcCollectionExists = f
	mmCollectionExists.mock.funcCollectionExistsOrigin = minimock.CallerInfo(1)
	return mmCollectionExists.mock
}

// When sets expectation for the Repository.CollectionExists which will trigger the result defined by the following
// Then helper
func (mmCollectionExists *mRepositoryMockCollectionExists) When(ctx context.Context, collectionID string) *RepositoryMockCollectionExistsExpectation {
	if mmCollectionExists.mock.funcCollectionExists != nil {
		mmCollectionExists.mock.t.Fatalf("RepositoryMock.CollectionExists mock is already set by Set")
	}

	expectation := &RepositoryMockCollectionExistsExpectation{
		mock:               mmCollectionExists.mock,
		params:             &RepositoryMockCollectionExistsParams{ctx, collectionID},
		expectationOrigins: RepositoryMockCollectionExistsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCollectionExists.expectations = append(mmCollectionExists.expectations, expectation)
	return expectation
}

// Then sets up Repository.CollectionExists return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCollectionExistsExpectation) Then(b1 bool, err error) *RepositoryMock {
	e.results = &RepositoryMockCollectionExistsResults{b1, err}
	return e.mock
}

// Times sets number of times Repository.CollectionExists should be invoked
func (mmCollectionExists *mRepositoryMockCollectionExists) Times(n uint64) *mRepositoryMockCollectionExists {
	if n == 0 {
		mmCollectionExists.mock.t.Fatalf("Times of RepositoryMock.CollectionExists mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCollectionExists.expectedInvocations, n)
	mmCollectionExists.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCollectionExists
}

func (mmCollectionExists *mRepositoryMockCollectionExists) invocationsDone() bool {
	if len(mmCollectionExists.expectations) == 0 && mmCollectionExists.defaultExpectation == nil && mmCollectionExists.mock.funcCollectionExists == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCollectionExists.mock.afterCollectionExistsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCollectionExists.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CollectionExists implements mm_repository.Repository
func (mmCollectionExists *RepositoryMock) CollectionExists(ctx context.Context, collectionID string) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmCollectionExists.beforeCollectionExistsCounter, 1)
	defer mm_atomic.AddUint64(&mmCollectionExists.afterCollectionExistsCounter, 1)

	mmCollectionExists.t.Helper()

	if mmCollectionExists.inspectFuncCollectionExists != nil {
		mmCollectionExists.inspectFuncCollectionExists(ctx, collectionID)
	}

	mm_params := RepositoryMockCollectionExistsParams{ctx, collectionID}

	// Record call args
	mmCollectionExists.CollectionExistsMock.mutex.Lock()
	mmCollectionExists.CollectionExistsMock.callArgs = append(mmCollectionExists.CollectionExistsMock.callArgs, &mm_params)
	mmCollectionExists.CollectionExistsMock.mutex.Unlock()

	for _, e := range mmCollectionExists.CollectionExistsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmCollectionExists.CollectionExistsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCollectionExists.CollectionExistsMock.defaultExpectation.Counter, 1)
		mm_want := mmCollectionExists.CollectionExistsMock.defaultExpectation.params
		mm_want_ptrs := mmCollectionExists.CollectionExistsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCollectionExistsParams{ctx, collectionID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCollectionExists.t.Errorf("RepositoryMock.CollectionExists got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCollectionExists.CollectionExistsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.collectionID != nil && !minimock.Equal(*mm_want_ptrs.collectionID, mm_got.collectionID) {
				mmCollectionExists.t.Errorf("RepositoryMock.CollectionExists got unexpected parameter collectionID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCollectionExists.CollectionExistsMock.defaultExpectation.expectationOrigins.originCollectionID, *mm_want_ptrs.collectionID, mm_got.collectionID, minimock.Diff(*mm_want_ptrs.collectionID, mm_got.collectionID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCollectionExists.t.Errorf("RepositoryMock.CollectionExists got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCollectionExists.CollectionExistsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCollectionExists.CollectionExistsMock.defaultExpectation.results
		if mm_results == nil {
			mmCollectionExists.t.Fatal("No results are set for the RepositoryMock.CollectionExists")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmCollectionExists.funcCollectionExists != nil {
		return mmCollectionExists.funcCollectionExists(ctx, collectionID)
	}
	mmCollectionExists.t.Fatalf("Unexpected call to RepositoryMock.CollectionExists. %v %v", ctx, collectionID)
	return
}

// CollectionExistsAfterCounter returns a count of finished RepositoryMock.CollectionExists invocations
func (mmCollectionExists *RepositoryMock) CollectionExistsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCollectionExists.afterCollectionExistsCounter)
}

// CollectionExistsBeforeCounter returns a count of RepositoryMock.CollectionExists invocations
func (mmCollectionExists *RepositoryMock) CollectionExistsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCollectionExists.beforeCollectionExistsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CollectionExists.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCollectionExists *mRepositoryMockCollectionExists) Calls() []*RepositoryMockCollectionExistsParams {
	mmCollectionExists.mutex.RLock()

	argCopy := make([]*RepositoryMockCollectionExistsParams, len(mmCollectionExists.callArgs))
	copy(argCopy, mmCollectionExists.callArgs)

	mmCollectionExists.mutex.RUnlock()

	return argCopy
}

// MinimockCollectionExistsDone returns true if the count of the CollectionExists invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCollectionExistsDone() bool {
	if m.CollectionExistsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CollectionExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CollectionExistsMock.invocationsDone()
}

// MinimockCollectionExistsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCollectionExistsInspect() {
	for _, e := range m.CollectionExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CollectionExists at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCollectionExistsCounter := mm_atomic.LoadUint64(&m.afterCollectionExistsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CollectionExistsMock.defaultExpectation != nil && afterCollectionExistsCounter < 1 {
		if m.CollectionExistsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CollectionExists at\n%s", m.CollectionExistsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CollectionExists at\n%s with params: %#v", m.CollectionExistsMock.defaultExpectation.expectationOrigins.origin, *m.CollectionExistsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCollectionExists != nil && afterCollectionExistsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CollectionExists at\n%s", m.funcCollectionExistsOrigin)
	}

	if !m.CollectionExistsMock.invocationsDone() && afterCollectionExistsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CollectionExists at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CollectionExistsMock.expectedInvocations), m.CollectionExistsMock.expectedInvocationsOrigin, afterCollectionExistsCounter)
	}
}

type mRepositoryMockCreateCollection struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateCollectionExpectation
	expectations       []*RepositoryMockCreateCollectionExpectation

	callArgs []*RepositoryMockCreateCollectionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateCollectionExpectation specifies expectation struct of the Repository.CreateCollection
type RepositoryMockCreateCollectionExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateCollectionParams
	paramPtrs          *RepositoryMockCreateCollectionParamPtrs
	expectationOrigins RepositoryMockCreateCollectionExpectationOrigins
	results            *RepositoryMockCreateCollectionResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateCollectionParams contains parameters of the Repository.CreateCollection
type RepositoryMockCreateCollectionParams struct {
	ctx            context.Context
	id             string
	dimensionality uint32
}

// RepositoryMockCreateCollectionParamPtrs contains pointers to parameters of the Repository.CreateCollection
type RepositoryMockCreateCollectionParamPtrs struct {
	ctx            *context.Context
	id             *string
	dimensionality *uint32
}

// RepositoryMockCreateCollectionResults contains results of the Repository.CreateCollection
type RepositoryMockCreateCollectionResults struct {
	err error
}

// RepositoryMockCreateCollectionOrigins contains origins of expectations of the Repository.CreateCollection
type RepositoryMockCreateCollectionExpectationOrigins struct {
	origin               string
	originCtx            string
	originId             string
	originDimensionality string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateCollection *mRepositoryMockCreateCollection) Optional() *mRepositoryMockCreateCollection {
	mmCreateCollection.optional = true
	return mmCreateCollection
}

// Expect sets up expected params for Repository.CreateCollection
func (mmCreateCollection *mRepositoryMockCreateCollection) Expect(ctx context.Context, id string, dimensionality uint32) *mRepositoryMockCreateCollection {
	if mmCreateCollection.mock.funcCreateCollection != nil {
		mmCreateCollection.mock.t.Fatalf("RepositoryMock.CreateCollection mock is already set by Set")
	}

	if mmCreateCollection.defaultExpectation == nil {
		mmCreateCollection.defaultExpectation = &RepositoryMockCreateCollectionExpectation{}
	}

	if mmCreateCollection.defaultExpectation.paramPtrs != nil {
		mmCreateCollection.mock.t.Fatalf("RepositoryMock.CreateCollection mock is already set by ExpectParams functions")
	}

	mmCreateCollection.defaultExpectation.params = &RepositoryMockCreateCollectionParams{ctx, id, dimensionality}
	mmCreateCollection.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateCollection.expectations {
		if minimock.Equal(e.params, mmCreateCollection.defaultExpectation.params) {
			mmCreateCollection.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateCollection.defaultExpectation.params)
		}
	}

	return mmCreateCollection
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateCollection
func (mmCreateCollection *mRepositoryMockCreateCollection) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateCollection {
	if mmCreateCollection.mock.funcCreateCollection != nil {
		mmCreateCollection.mock.t.Fatalf("RepositoryMock.CreateCollection mock is already set by Set")
	}

	if mmCreateCollection.defaultExpectation == nil {
		mmCreateCollection.defaultExpectation = &RepositoryMockCreateCollectionExpectation{}
	}

	if mmCreateCollection.defaultExpectation.params != nil {
		mmCreateCollection.mock.t.Fatalf("RepositoryMock.CreateCollection mock is already set by Expect")
	}

	if mmCreateCollection.defaultExpectation.paramPtrs == nil {
		mmCreateCollection.defaultExpectation.paramPtrs = &RepositoryMockCreateCollectionParamPtrs{}
	}
	mmCreateCollection.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateCollection.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateCollection
}

// ExpectIdParam2 sets up expected param id for Repository.CreateCollection
func (mmCreateCollection *mRepositoryMockCreateCollection) ExpectIdParam2(id string) *mRepositoryMockCreateCollection {
	if mmCreateCollection.mock.funcCreateCollection != nil {
		mmCreateCollection.mock.t.Fatalf("RepositoryMock.CreateCollection mock is already set by Set")
	}

	if mmCreateCollection.defaultExpectation == nil {
		mmCreateCollection.defaultExpectation = &RepositoryMockCreateCollectionExpectation{}
	}

	if mmCreateCollection.defaultExpectation.params != nil {
		mmCreateCollection.mock.t.Fatalf("RepositoryMock.CreateCollection mock is already set by Expect")
	}

	if mmCreateCollection.defaultExpectation.paramPtrs == nil {
		mmCreateCollection.defaultExpectation.paramPtrs = &RepositoryMockCreateCollectionParamPtrs{}
	}
	mmCreateCollection.defaultExpectation.paramPtrs.id = &id
	mmCreateCollection.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmCreateCollection
}

// ExpectDimensionalityParam3 sets up expected param dimensionality for Repository.CreateCollection
func (mmCreateCollection *mRepositoryMockCreateCollection) ExpectDimensionalityParam3(dimensionality uint32) *mRepositoryMockCreateCollection {
	if mmCreateCollection.mock.funcCreateCollection != nil {
		mmCreateCollection.mock.t.Fatalf("RepositoryMock.CreateCollection mock is already set by Set")
	}

	if mmCreateCollection.defaultExpectation == nil {
		mmCreateCollection.defaultExpectation = &RepositoryMockCreateCollectionExpectation{}
	}

	if mmCreateCollection.defaultExpectation.params != nil {
		mmCreateCollection.mock.t.Fatalf("RepositoryMock.CreateCollection mock is already set by Expect")
	}

	if mmCreateCollection.defaultExpectation.paramPtrs == nil {
		mmCreateCollection.defaultExpectation.paramPtrs = &RepositoryMockCreateCollectionParamPtrs{}
	}
	mmCreateCollection.defaultExpectation.paramPtrs.dimensionality = &dimensionality
	mmCreateCollection.defaultExpectation.expectationOrigins.originDimensionality = minimock.CallerInfo(1)

	return mmCreateCollection
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateCollection
func (mmCreateCollection *mRepositoryMockCreateCollection) Inspect(f func(ctx context.Context, id string, dimensionality uint32)) *mRepositoryMockCreateCollection {
	if mmCreateCollection.mock.inspectFuncCreateCollection != nil {
		mmCreateCollection.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateCollection")
	}

	mmCreateCollection.mock.inspectFuncCreateCollection = f

	return mmCreateCollection
}

// Return sets up results that will be returned by Repository.CreateCollection
func (mmCreateCollection *mRepositoryMockCreateCollection) Return(err error) *RepositoryMock {
	if mmCreateCollection.mock.funcCreateCollection != nil {
		mmCreateCollection.mock.t.Fatalf("RepositoryMock.CreateCollection mock is already set by Set")
	}

	if mmCreateCollection.defaultExpectation == nil {
		mmCreateCollection.defaultExpectation = &RepositoryMockCreateCollectionExpectation{mock: mmCreateCollection.mock}
	}
	mmCreateCollection.defaultExpectation.results = &RepositoryMockCreateCollectionResults{err}
	mmCreateCollection.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateCollection.mock
}

// Set uses given function f to mock the Repository.CreateCollection method
func (mmCreateCollection *mRepositoryMockCreateCollection) Set(f func(ctx context.Context, id string, dimensionality uint32) (err error)) *RepositoryMock {
	if mmCreateCollection.defaultExpectation != nil {
		mmCreateCollection.mock.t.Fatalf("Default expectation is already set for the Repository.CreateCollection method")
	}

	if len(mmCreateCollection.expectations) > 0 {
		mmCreateCollection.mock.t.Fatalf("Some expectations are already set for the Repository.CreateCollection method")
	}

	mmCreateCollection.mock.funcCreateCollection = f
	mmCreateCollection.mock.funcCreateCollectionOrigin = minimock.CallerInfo(1)
	return mmCreateCollection.mock
}

// When sets expectation for the Repository.CreateCollection which will trigger the result defined by the following
// Then helper
func (mmCreateCollection *mRepositoryMockCreateCollection) When(ctx context.Context, id string, dimensionality uint32) *RepositoryMockCreateCollectionExpectation {
	if mmCreateCollection.mock.funcCreateCollection != nil {
		mmCreateCollection.mock.t.Fatalf("RepositoryMock.CreateCollection mock is already set by Set")
	}

	expectation := &RepositoryMockCreateCollectionExpectation{
		mock:               mmCreateCollection.mock,
		params:             &RepositoryMockCreateCollectionParams{ctx, id, dimensionality},
		expectationOrigins: RepositoryMockCreateCollectionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateCollection.expectations = append(mmCreateCollection.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateCollection return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateCollectionExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreateCollectionResults{err}
	return e.mock
}

// Times sets number of times Repository.CreateCollection should be invoked
func (mmCreateCollection *mRepositoryMockCreateCollection) Times(n uint64) *mRepositoryMockCreateCollection {
	if n == 0 {
		mmCreateCollection.mock.t.Fatalf("Times of RepositoryMock.CreateCollection mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateCollection.expectedInvocations, n)
	mmCreateCollection.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateCollection
}

func (mmCreateCollection *mRepositoryMockCreateCollection) invocationsDone() bool {
	if len(mmCreateCollection.expectations) == 0 && mmCreateCollection.defaultExpectation == nil && mmCreateCollection.mock.funcCreateCollection == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateCollection.mock.afterCreateCollectionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateCollection.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateCollection implements mm_repository.Repository
func (mmCreateCollection *RepositoryMock) CreateCollection(ctx context.Context, id string, dimensionality uint32) (err error) {
	mm_atomic.AddUint64(&mmCreateCollection.beforeCreateCollectionCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateCollection.afterCreateCollectionCounter, 1)

	mmCreateCollection.t.Helper()

	if mmCreateCollection.inspectFuncCreateCollection != nil {
		mmCreateCollection.inspectFuncCreateCollection(ctx, id, dimensionality)
	}

	mm_params := RepositoryMockCreateCollectionParams{ctx, id, dimensionality}

	// Record call args
	mmCreateCollection.CreateCollectionMock.mutex.Lock()
	mmCreateCollection.CreateCollectionMock.callArgs = append(mmCreateCollection.CreateCollectionMock.callArgs, &mm_params)
	mmCreateCollection.CreateCollectionMock.mutex.Unlock()

	for _, e := range mmCreateCollection.CreateCollectionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateCollection.CreateCollectionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateCollection.CreateCollectionMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateCollection.CreateCollectionMock.defaultExpectation.params
		mm_want_ptrs := mmCreateCollection.CreateCollectionMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateCollectionParams{ctx, id, dimensionality}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateCollection.t.Errorf("RepositoryMock.CreateCollection got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCollection.CreateCollectionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmCreateCollection.t.Errorf("RepositoryMock.CreateCollection got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCollection.CreateCollectionMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.dimensionality != nil && !minimock.Equal(*mm_want_ptrs.dimensionality, mm_got.dimensionality) {
				mmCreateCollection.t.Errorf("RepositoryMock.CreateCollection got unexpected parameter dimensionality, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCollection.CreateCollectionMock.defaultExpectation.expectationOrigins.originDimensionality, *mm_want_ptrs.dimensionality, mm_got.dimensionality, minimock.Diff(*mm_want_ptrs.dimensionality, mm_got.dimensionality))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateCollection.t.Errorf("RepositoryMock.CreateCollection got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateCollection.CreateCollectionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateCollection.CreateCollectionMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateCollection.t.Fatal("No results are set for the RepositoryMock.CreateCollection")
		}
		return (*mm_results).err
	}
	if mmCreateCollection.funcCreateCollection != nil {
		return mmCreateCollection.funcCreateCollection(ctx, id, dimensionality)
	}
	mmCreateCollection.t.Fatalf("Unexpected call to RepositoryMock.CreateCollection. %v %v %v", ctx, id, dimensionality)
	return
}

// CreateCollectionAfterCounter returns a count of finished RepositoryMock.CreateCollection invocations
func (mmCreateCollection *RepositoryMock) CreateCollectionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCollection.afterCreateCollectionCounter)
}

// CreateCollectionBeforeCounter returns a count of RepositoryMock.CreateCollection invocations
func (mmCreateCollection *RepositoryMock) CreateCollectionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCollection.beforeCreateCollectionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateCollection.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateCollection *mRepositoryMockCreateCollection) Calls() []*RepositoryMockCreateCollectionParams {
	mmCreateCollection.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateCollectionParams, len(mmCreateCollection.callArgs))
	copy(argCopy, mmCreateCollection.callArgs)

	mmCreateCollection.mutex.RUnlock()

	return argCopy
}

// MinimockCreateCollectionDone returns true if the count of the CreateCollection invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateCollectionDone() bool {
	if m.CreateCollectionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateCollectionMock.invocationsDone()
}

// MinimockCreateCollectionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateCollectionInspect() {
	for _, e := range m.CreateCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateCollection at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCollectionCounter := mm_atomic.LoadUint64(&m.afterCreateCollectionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateCollectionMock.defaultExpectation != nil && afterCreateCollectionCounter < 1 {
		if m.CreateCollectionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateCollection at\n%s", m.CreateCollectionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateCollection at\n%s with params: %#v", m.CreateCollectionMock.defaultExpectation.expectationOrigins.origin, *m.CreateCollectionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateCollection != nil && afterCreateCollectionCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateCollection at\n%s", m.funcCreateCollectionOrigin)
	}

	if !m.CreateCollectionMock.invocationsDone() && afterCreateCollectionCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateCollection at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateCollectionMock.expectedInvocations), m.CreateCollectionMock.expectedInvocationsOrigin, afterCreateCollectionCounter)
	}
}

type mRepositoryMockCreateConvertedFileWithDestination struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateConvertedFileWithDestinationExpectation
	expectations       []*RepositoryMockCreateConvertedFileWithDestinationExpectation

	callArgs []*RepositoryMockCreateConvertedFileWithDestinationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateConvertedFileWithDestinationExpectation specifies expectation struct of the Repository.CreateConvertedFileWithDestination
type RepositoryMockCreateConvertedFileWithDestinationExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateConvertedFileWithDestinationParams
	paramPtrs          *RepositoryMockCreateConvertedFileWithDestinationParamPtrs
	expectationOrigins RepositoryMockCreateConvertedFileWithDestinationExpectationOrigins
	results            *RepositoryMockCreateConvertedFileWithDestinationResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateConvertedFileWithDestinationParams contains parameters of the Repository.CreateConvertedFileWithDestination
type RepositoryMockCreateConvertedFileWithDestinationParams struct {
	ctx context.Context
	cf  mm_repository.ConvertedFileModel
}

// RepositoryMockCreateConvertedFileWithDestinationParamPtrs contains pointers to parameters of the Repository.CreateConvertedFileWithDestination
type RepositoryMockCreateConvertedFileWithDestinationParamPtrs struct {
	ctx *context.Context
	cf  *mm_repository.ConvertedFileModel
}

// RepositoryMockCreateConvertedFileWithDestinationResults contains results of the Repository.CreateConvertedFileWithDestination
type RepositoryMockCreateConvertedFileWithDestinationResults struct {
	cp1 *mm_repository.ConvertedFileModel
	err error
}

// RepositoryMockCreateConvertedFileWithDestinationOrigins contains origins of expectations of the Repository.CreateConvertedFileWithDestination
type RepositoryMockCreateConvertedFileWithDestinationExpectationOrigins struct {
	origin    string
	originCtx string
	originCf  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateConvertedFileWithDestination *mRepositoryMockCreateConvertedFileWithDestination) Optional() *mRepositoryMockCreateConvertedFileWithDestination {
	mmCreateConvertedFileWithDestination.optional = true
	return mmCreateConvertedFileWithDestination
}

// Expect sets up expected params for Repository.CreateConvertedFileWithDestination
func (mmCreateConvertedFileWithDestination *mRepositoryMockCreateConvertedFileWithDestination) Expect(ctx context.Context, cf mm_repository.ConvertedFileModel) *mRepositoryMockCreateConvertedFileWithDestination {
	if mmCreateConvertedFileWithDestination.mock.funcCreateConvertedFileWithDestination != nil {
		mmCreateConvertedFileWithDestination.mock.t.Fatalf("RepositoryMock.CreateConvertedFileWithDestination mock is already set by Set")
	}

	if mmCreateConvertedFileWithDestination.defaultExpectation == nil {
		mmCreateConvertedFileWithDestination.defaultExpectation = &RepositoryMockCreateConvertedFileWithDestinationExpectation{}
	}

	if mmCreateConvertedFileWithDestination.defaultExpectation.paramPtrs != nil {
		mmCreateConvertedFileWithDestination.mock.t.Fatalf("RepositoryMock.CreateConvertedFileWithDestination mock is already set by ExpectParams functions")
	}

	mmCreateConvertedFileWithDestination.defaultExpectation.params = &RepositoryMockCreateConvertedFileWithDestinationParams{ctx, cf}
	mmCreateConvertedFileWithDestination.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateConvertedFileWithDestination.expectations {
		if minimock.Equal(e.params, mmCreateConvertedFileWithDestination.defaultExpectation.params) {
			mmCreateConvertedFileWithDestination.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateConvertedFileWithDestination.defaultExpectation.params)
		}
	}

	return mmCreateConvertedFileWithDestination
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateConvertedFileWithDestination
func (mmCreateConvertedFileWithDestination *mRepositoryMockCreateConvertedFileWithDestination) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateConvertedFileWithDestination {
	if mmCreateConvertedFileWithDestination.mock.funcCreateConvertedFileWithDestination != nil {
		mmCreateConvertedFileWithDestination.mock.t.Fatalf("RepositoryMock.CreateConvertedFileWithDestination mock is already set by Set")
	}

	if mmCreateConvertedFileWithDestination.defaultExpectation == nil {
		mmCreateConvertedFileWithDestination.defaultExpectation = &RepositoryMockCreateConvertedFileWithDestinationExpectation{}
	}

	if mmCreateConvertedFileWithDestination.defaultExpectation.params != nil {
		mmCreateConvertedFileWithDestination.mock.t.Fatalf("RepositoryMock.CreateConvertedFileWithDestination mock is already set by Expect")
	}

	if mmCreateConvertedFileWithDestination.defaultExpectation.paramPtrs == nil {
		mmCreateConvertedFileWithDestination.defaultExpectation.paramPtrs = &RepositoryMockCreateConvertedFileWithDestinationParamPtrs{}
	}
	mmCreateConvertedFileWithDestination.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateConvertedFileWithDestination.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateConvertedFileWithDestination
}

// ExpectCfParam2 sets up expected param cf for Repository.CreateConvertedFileWithDestination
func (mmCreateConvertedFileWithDestination *mRepositoryMockCreateConvertedFileWithDestination) ExpectCfParam2(cf mm_repository.ConvertedFileModel) *mRepositoryMockCreateConvertedFileWithDestination {
	if mmCreateConvertedFileWithDestination.mock.funcCreateConvertedFileWithDestination != nil {
		mmCreateConvertedFileWithDestination.mock.t.Fatalf("RepositoryMock.CreateConvertedFileWithDestination mock is already set by Set")
	}

	if mmCreateConvertedFileWithDestination.defaultExpectation == nil {
		mmCreateConvertedFileWithDestination.defaultExpectation = &RepositoryMockCreateConvertedFileWithDestinationExpectation{}
	}

	if mmCreateConvertedFileWithDestination.defaultExpectation.params != nil {
		mmCreateConvertedFileWithDestination.mock.t.Fatalf("RepositoryMock.CreateConvertedFileWithDestination mock is already set by Expect")
	}

	if mmCreateConvertedFileWithDestination.defaultExpectation.paramPtrs == nil {
		mmCreateConvertedFileWithDestination.defaultExpectation.paramPtrs = &RepositoryMockCreateConvertedFileWithDestinationParamPtrs{}
	}
	mmCreateConvertedFileWithDestination.defaultExpectation.paramPtrs.cf = &cf
	mmCreateConvertedFileWithDestination.defaultExpectation.expectationOrigins.originCf = minimock.CallerInfo(1)

	return mmCreateConvertedFileWithDestination
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateConvertedFileWithDestination
func (mmCreateConvertedFileWithDestination *mRepositoryMockCreateConvertedFileWithDestination) Inspect(f func(ctx context.Context, cf mm_repository.ConvertedFileModel)) *mRepositoryMockCreateConvertedFileWithDestination {
	if mmCreateConvertedFileWithDestination.mock.inspectFuncCreateConvertedFileWithDestination != nil {
		mmCreateConvertedFileWithDestination.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateConvertedFileWithDestination")
	}

	mmCreateConvertedFileWithDestination.mock.inspectFuncCreateConvertedFileWithDestination = f

	return mmCreateConvertedFileWithDestination
}

// Return sets up results that will be returned by Repository.CreateConvertedFileWithDestination
func (mmCreateConvertedFileWithDestination *mRepositoryMockCreateConvertedFileWithDestination) Return(cp1 *mm_repository.ConvertedFileModel, err error) *RepositoryMock {
	if mmCreateConvertedFileWithDestination.mock.funcCreateConvertedFileWithDestination != nil {
		mmCreateConvertedFileWithDestination.mock.t.Fatalf("RepositoryMock.CreateConvertedFileWithDestination mock is already set by Set")
	}

	if mmCreateConvertedFileWithDestination.defaultExpectation == nil {
		mmCreateConvertedFileWithDestination.defaultExpectation = &RepositoryMockCreateConvertedFileWithDestinationExpectation{mock: mmCreateConvertedFileWithDestination.mock}
	}
	mmCreateConvertedFileWithDestination.defaultExpectation.results = &RepositoryMockCreateConvertedFileWithDestinationResults{cp1, err}
	mmCreateConvertedFileWithDestination.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateConvertedFileWithDestination.mock
}

// Set uses given function f to mock the Repository.CreateConvertedFileWithDestination method
func (mmCreateConvertedFileWithDestination *mRepositoryMockCreateConvertedFileWithDestination) Set(f func(ctx context.Context, cf mm_repository.ConvertedFileModel) (cp1 *mm_repository.ConvertedFileModel, err error)) *RepositoryMock {
	if mmCreateConvertedFileWithDestination.defaultExpectation != nil {
		mmCreateConvertedFileWithDestination.mock.t.Fatalf("Default expectation is already set for the Repository.CreateConvertedFileWithDestination method")
	}

	if len(mmCreateConvertedFileWithDestination.expectations) > 0 {
		mmCreateConvertedFileWithDestination.mock.t.Fatalf("Some expectations are already set for the Repository.CreateConvertedFileWithDestination method")
	}

	mmCreateConvertedFileWithDestination.mock.funcCreateConvertedFileWithDestination = f
	mmCreateConvertedFileWithDestination.mock.funcCreateConvertedFileWithDestinationOrigin = minimock.CallerInfo(1)
	return mmCreateConvertedFileWithDestination.mock
}

// When sets expectation for the Repository.CreateConvertedFileWithDestination which will trigger the result defined by the following
// Then helper
func (mmCreateConvertedFileWithDestination *mRepositoryMockCreateConvertedFileWithDestination) When(ctx context.Context, cf mm_repository.ConvertedFileModel) *RepositoryMockCreateConvertedFileWithDestinationExpectation {
	if mmCreateConvertedFileWithDestination.mock.funcCreateConvertedFileWithDestination != nil {
		mmCreateConvertedFileWithDestination.mock.t.Fatalf("RepositoryMock.CreateConvertedFileWithDestination mock is already set by Set")
	}

	expectation := &RepositoryMockCreateConvertedFileWithDestinationExpectation{
		mock:               mmCreateConvertedFileWithDestination.mock,
		params:             &RepositoryMockCreateConvertedFileWithDestinationParams{ctx, cf},
		expectationOrigins: RepositoryMockCreateConvertedFileWithDestinationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateConvertedFileWithDestination.expectations = append(mmCreateConvertedFileWithDestination.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateConvertedFileWithDestination return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateConvertedFileWithDestinationExpectation) Then(cp1 *mm_repository.ConvertedFileModel, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateConvertedFileWithDestinationResults{cp1, err}
	return e.mock
}

// Times sets number of times Repository.CreateConvertedFileWithDestination should be invoked
func (mmCreateConvertedFileWithDestination *mRepositoryMockCreateConvertedFileWithDestination) Times(n uint64) *mRepositoryMockCreateConvertedFileWithDestination {
	if n == 0 {
		mmCreateConvertedFileWithDestination.mock.t.Fatalf("Times of RepositoryMock.CreateConvertedFileWithDestination mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateConvertedFileWithDestination.expectedInvocations, n)
	mmCreateConvertedFileWithDestination.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateConvertedFileWithDestination
}

func (mmCreateConvertedFileWithDestination *mRepositoryMockCreateConvertedFileWithDestination) invocationsDone() bool {
	if len(mmCreateConvertedFileWithDestination.expectations) == 0 && mmCreateConvertedFileWithDestination.defaultExpectation == nil && mmCreateConvertedFileWithDestination.mock.funcCreateConvertedFileWithDestination == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateConvertedFileWithDestination.mock.afterCreateConvertedFileWithDestinationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateConvertedFileWithDestination.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateConvertedFileWithDestination implements mm_repository.Repository
func (mmCreateConvertedFileWithDestination *RepositoryMock) CreateConvertedFileWithDestination(ctx context.Context, cf mm_repository.ConvertedFileModel) (cp1 *mm_repository.ConvertedFileModel, err error) {
	mm_atomic.AddUint64(&mmCreateConvertedFileWithDestination.beforeCreateConvertedFileWithDestinationCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateConvertedFileWithDestination.afterCreateConvertedFileWithDestinationCounter, 1)

	mmCreateConvertedFileWithDestination.t.Helper()

	if mmCreateConvertedFileWithDestination.inspectFuncCreateConvertedFileWithDestination != nil {
		mmCreateConvertedFileWithDestination.inspectFuncCreateConvertedFileWithDestination(ctx, cf)
	}

	mm_params := RepositoryMockCreateConvertedFileWithDestinationParams{ctx, cf}

	// Record call args
	mmCreateConvertedFileWithDestination.CreateConvertedFileWithDestinationMock.mutex.Lock()
	mmCreateConvertedFileWithDestination.CreateConvertedFileWithDestinationMock.callArgs = append(mmCreateConvertedFileWithDestination.CreateConvertedFileWithDestinationMock.callArgs, &mm_params)
	mmCreateConvertedFileWithDestination.CreateConvertedFileWithDestinationMock.mutex.Unlock()

	for _, e := range mmCreateConvertedFileWithDestination.CreateConvertedFileWithDestinationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCreateConvertedFileWithDestination.CreateConvertedFileWithDestinationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateConvertedFileWithDestination.CreateConvertedFileWithDestinationMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateConvertedFileWithDestination.CreateConvertedFileWithDestinationMock.defaultExpectation.params
		mm_want_ptrs := mmCreateConvertedFileWithDestination.CreateConvertedFileWithDestinationMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateConvertedFileWithDestinationParams{ctx, cf}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateConvertedFileWithDestination.t.Errorf("RepositoryMock.CreateConvertedFileWithDestination got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateConvertedFileWithDestination.CreateConvertedFileWithDestinationMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cf != nil && !minimock.Equal(*mm_want_ptrs.cf, mm_got.cf) {
				mmCreateConvertedFileWithDestination.t.Errorf("RepositoryMock.CreateConvertedFileWithDestination got unexpected parameter cf, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateConvertedFileWithDestination.CreateConvertedFileWithDestinationMock.defaultExpectation.expectationOrigins.originCf, *mm_want_ptrs.cf, mm_got.cf, minimock.Diff(*mm_want_ptrs.cf, mm_got.cf))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateConvertedFileWithDestination.t.Errorf("RepositoryMock.CreateConvertedFileWithDestination got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateConvertedFileWithDestination.CreateConvertedFileWithDestinationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateConvertedFileWithDestination.CreateConvertedFileWithDestinationMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateConvertedFileWithDestination.t.Fatal("No results are set for the RepositoryMock.CreateConvertedFileWithDestination")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCreateConvertedFileWithDestination.funcCreateConvertedFileWithDestination != nil {
		return mmCreateConvertedFileWithDestination.funcCreateConvertedFileWithDestination(ctx, cf)
	}
	mmCreateConvertedFileWithDestination.t.Fatalf("Unexpected call to RepositoryMock.CreateConvertedFileWithDestination. %v %v", ctx, cf)
	return
}

// CreateConvertedFileWithDestinationAfterCounter returns a count of finished RepositoryMock.CreateConvertedFileWithDestination invocations
func (mmCreateConvertedFileWithDestination *RepositoryMock) CreateConvertedFileWithDestinationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateConvertedFileWithDestination.afterCreateConvertedFileWithDestinationCounter)
}

// CreateConvertedFileWithDestinationBeforeCounter returns a count of RepositoryMock.CreateConvertedFileWithDestination invocations
func (mmCreateConvertedFileWithDestination *RepositoryMock) CreateConvertedFileWithDestinationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateConvertedFileWithDestination.beforeCreateConvertedFileWithDestinationCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateConvertedFileWithDestination.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateConvertedFileWithDestination *mRepositoryMockCreateConvertedFileWithDestination) Calls() []*RepositoryMockCreateConvertedFileWithDestinationParams {
	mmCreateConvertedFileWithDestination.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateConvertedFileWithDestinationParams, len(mmCreateConvertedFileWithDestination.callArgs))
	copy(argCopy, mmCreateConvertedFileWithDestination.callArgs)

	mmCreateConvertedFileWithDestination.mutex.RUnlock()

	return argCopy
}

// MinimockCreateConvertedFileWithDestinationDone returns true if the count of the CreateConvertedFileWithDestination invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateConvertedFileWithDestinationDone() bool {
	if m.CreateConvertedFileWithDestinationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateConvertedFileWithDestinationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateConvertedFileWithDestinationMock.invocationsDone()
}

// MinimockCreateConvertedFileWithDestinationInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateConvertedFileWithDestinationInspect() {
	for _, e := range m.CreateConvertedFileWithDestinationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateConvertedFileWithDestination at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateConvertedFileWithDestinationCounter := mm_atomic.LoadUint64(&m.afterCreateConvertedFileWithDestinationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateConvertedFileWithDestinationMock.defaultExpectation != nil && afterCreateConvertedFileWithDestinationCounter < 1 {
		if m.CreateConvertedFileWithDestinationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateConvertedFileWithDestination at\n%s", m.CreateConvertedFileWithDestinationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateConvertedFileWithDestination at\n%s with params: %#v", m.CreateConvertedFileWithDestinationMock.defaultExpectation.expectationOrigins.origin, *m.CreateConvertedFileWithDestinationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateConvertedFileWithDestination != nil && afterCreateConvertedFileWithDestinationCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateConvertedFileWithDestination at\n%s", m.funcCreateConvertedFileWithDestinationOrigin)
	}

	if !m.CreateConvertedFileWithDestinationMock.invocationsDone() && afterCreateConvertedFileWithDestinationCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateConvertedFileWithDestination at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateConvertedFileWithDestinationMock.expectedInvocations), m.CreateConvertedFileWithDestinationMock.expectedInvocationsOrigin, afterCreateConvertedFileWithDestinationCounter)
	}
}

type mRepositoryMockCreateEmbeddings struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateEmbeddingsExpectation
	expectations       []*RepositoryMockCreateEmbeddingsExpectation

	callArgs []*RepositoryMockCreateEmbeddingsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateEmbeddingsExpectation specifies expectation struct of the Repository.CreateEmbeddings
type RepositoryMockCreateEmbeddingsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateEmbeddingsParams
	paramPtrs          *RepositoryMockCreateEmbeddingsParamPtrs
	expectationOrigins RepositoryMockCreateEmbeddingsExpectationOrigins
	results            *RepositoryMockCreateEmbeddingsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateEmbeddingsParams contains parameters of the Repository.CreateEmbeddings
type RepositoryMockCreateEmbeddingsParams struct {
	ctx                 context.Context
	embeddings          []mm_repository.EmbeddingModel
	externalServiceCall func([]mm_repository.EmbeddingModel) error
}

// RepositoryMockCreateEmbeddingsParamPtrs contains pointers to parameters of the Repository.CreateEmbeddings
type RepositoryMockCreateEmbeddingsParamPtrs struct {
	ctx                 *context.Context
	embeddings          *[]mm_repository.EmbeddingModel
	externalServiceCall *func([]mm_repository.EmbeddingModel) error
}

// RepositoryMockCreateEmbeddingsResults contains results of the Repository.CreateEmbeddings
type RepositoryMockCreateEmbeddingsResults struct {
	ea1 []mm_repository.EmbeddingModel
	err error
}

// RepositoryMockCreateEmbeddingsOrigins contains origins of expectations of the Repository.CreateEmbeddings
type RepositoryMockCreateEmbeddingsExpectationOrigins struct {
	origin                    string
	originCtx                 string
	originEmbeddings          string
	originExternalServiceCall string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateEmbeddings *mRepositoryMockCreateEmbeddings) Optional() *mRepositoryMockCreateEmbeddings {
	mmCreateEmbeddings.optional = true
	return mmCreateEmbeddings
}

// Expect sets up expected params for Repository.CreateEmbeddings
func (mmCreateEmbeddings *mRepositoryMockCreateEmbeddings) Expect(ctx context.Context, embeddings []mm_repository.EmbeddingModel, externalServiceCall func([]mm_repository.EmbeddingModel) error) *mRepositoryMockCreateEmbeddings {
	if mmCreateEmbeddings.mock.funcCreateEmbeddings != nil {
		mmCreateEmbeddings.mock.t.Fatalf("RepositoryMock.CreateEmbeddings mock is already set by Set")
	}

	if mmCreateEmbeddings.defaultExpectation == nil {
		mmCreateEmbeddings.defaultExpectation = &RepositoryMockCreateEmbeddingsExpectation{}
	}

	if mmCreateEmbeddings.defaultExpectation.paramPtrs != nil {
		mmCreateEmbeddings.mock.t.Fatalf("RepositoryMock.CreateEmbeddings mock is already set by ExpectParams functions")
	}

	mmCreateEmbeddings.defaultExpectation.params = &RepositoryMockCreateEmbeddingsParams{ctx, embeddings, externalServiceCall}
	mmCreateEmbeddings.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateEmbeddings.expectations {
		if minimock.Equal(e.params, mmCreateEmbeddings.defaultExpectation.params) {
			mmCreateEmbeddings.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateEmbeddings.defaultExpectation.params)
		}
	}

	return mmCreateEmbeddings
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateEmbeddings
func (mmCreateEmbeddings *mRepositoryMockCreateEmbeddings) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateEmbeddings {
	if mmCreateEmbeddings.mock.funcCreateEmbeddings != nil {
		mmCreateEmbeddings.mock.t.Fatalf("RepositoryMock.CreateEmbeddings mock is already set by Set")
	}

	if mmCreateEmbeddings.defaultExpectation == nil {
		mmCreateEmbeddings.defaultExpectation = &RepositoryMockCreateEmbeddingsExpectation{}
	}

	if mmCreateEmbeddings.defaultExpectation.params != nil {
		mmCreateEmbeddings.mock.t.Fatalf("RepositoryMock.CreateEmbeddings mock is already set by Expect")
	}

	if mmCreateEmbeddings.defaultExpectation.paramPtrs == nil {
		mmCreateEmbeddings.defaultExpectation.paramPtrs = &RepositoryMockCreateEmbeddingsParamPtrs{}
	}
	mmCreateEmbeddings.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateEmbeddings.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateEmbeddings
}

// ExpectEmbeddingsParam2 sets up expected param embeddings for Repository.CreateEmbeddings
func (mmCreateEmbeddings *mRepositoryMockCreateEmbeddings) ExpectEmbeddingsParam2(embeddings []mm_repository.EmbeddingModel) *mRepositoryMockCreateEmbeddings {
	if mmCreateEmbeddings.mock.funcCreateEmbeddings != nil {
		mmCreateEmbeddings.mock.t.Fatalf("RepositoryMock.CreateEmbeddings mock is already set by Set")
	}

	if mmCreateEmbeddings.defaultExpectation == nil {
		mmCreateEmbeddings.defaultExpectation = &RepositoryMockCreateEmbeddingsExpectation{}
	}

	if mmCreateEmbeddings.defaultExpectation.params != nil {
		mmCreateEmbeddings.mock.t.Fatalf("RepositoryMock.CreateEmbeddings mock is already set by Expect")
	}

	if mmCreateEmbeddings.defaultExpectation.paramPtrs == nil {
		mmCreateEmbeddings.defaultExpectation.paramPtrs = &RepositoryMockCreateEmbeddingsParamPtrs{}
	}
	mmCreateEmbeddings.defaultExpectation.paramPtrs.embeddings = &embeddings
	mmCreateEmbeddings.defaultExpectation.expectationOrigins.originEmbeddings = minimock.CallerInfo(1)

	return mmCreateEmbeddings
}

// ExpectExternalServiceCallParam3 sets up expected param externalServiceCall for Repository.CreateEmbeddings
func (mmCreateEmbeddings *mRepositoryMockCreateEmbeddings) ExpectExternalServiceCallParam3(externalServiceCall func([]mm_repository.EmbeddingModel) error) *mRepositoryMockCreateEmbeddings {
	if mmCreateEmbeddings.mock.funcCreateEmbeddings != nil {
		mmCreateEmbeddings.mock.t.Fatalf("RepositoryMock.CreateEmbeddings mock is already set by Set")
	}

	if mmCreateEmbeddings.defaultExpectation == nil {
		mmCreateEmbeddings.defaultExpectation = &RepositoryMockCreateEmbeddingsExpectation{}
	}

	if mmCreateEmbeddings.defaultExpectation.params != nil {
		mmCreateEmbeddings.mock.t.Fatalf("RepositoryMock.CreateEmbeddings mock is already set by Expect")
	}

	if mmCreateEmbeddings.defaultExpectation.paramPtrs == nil {
		mmCreateEmbeddings.defaultExpectation.paramPtrs = &RepositoryMockCreateEmbeddingsParamPtrs{}
	}
	mmCreateEmbeddings.defaultExpectation.paramPtrs.externalServiceCall = &externalServiceCall
	mmCreateEmbeddings.defaultExpectation.expectationOrigins.originExternalServiceCall = minimock.CallerInfo(1)

	return mmCreateEmbeddings
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateEmbeddings
func (mmCreateEmbeddings *mRepositoryMockCreateEmbeddings) Inspect(f func(ctx context.Context, embeddings []mm_repository.EmbeddingModel, externalServiceCall func([]mm_repository.EmbeddingModel) error)) *mRepositoryMockCreateEmbeddings {
	if mmCreateEmbeddings.mock.inspectFuncCreateEmbeddings != nil {
		mmCreateEmbeddings.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateEmbeddings")
	}

	mmCreateEmbeddings.mock.inspectFuncCreateEmbeddings = f

	return mmCreateEmbeddings
}

// Return sets up results that will be returned by Repository.CreateEmbeddings
func (mmCreateEmbeddings *mRepositoryMockCreateEmbeddings) Return(ea1 []mm_repository.EmbeddingModel, err error) *RepositoryMock {
	if mmCreateEmbeddings.mock.funcCreateEmbeddings != nil {
		mmCreateEmbeddings.mock.t.Fatalf("RepositoryMock.CreateEmbeddings mock is already set by Set")
	}

	if mmCreateEmbeddings.defaultExpectation == nil {
		mmCreateEmbeddings.defaultExpectation = &RepositoryMockCreateEmbeddingsExpectation{mock: mmCreateEmbeddings.mock}
	}
	mmCreateEmbeddings.defaultExpectation.results = &RepositoryMockCreateEmbeddingsResults{ea1, err}
	mmCreateEmbeddings.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateEmbeddings.mock
}

// Set uses given function f to mock the Repository.CreateEmbeddings method
func (mmCreateEmbeddings *mRepositoryMockCreateEmbeddings) Set(f func(ctx context.Context, embeddings []mm_repository.EmbeddingModel, externalServiceCall func([]mm_repository.EmbeddingModel) error) (ea1 []mm_repository.EmbeddingModel, err error)) *RepositoryMock {
	if mmCreateEmbeddings.defaultExpectation != nil {
		mmCreateEmbeddings.mock.t.Fatalf("Default expectation is already set for the Repository.CreateEmbeddings method")
	}

	if len(mmCreateEmbeddings.expectations) > 0 {
		mmCreateEmbeddings.mock.t.Fatalf("Some expectations are already set for the Repository.CreateEmbeddings method")
	}

	mmCreateEmbeddings.mock.funcCreateEmbeddings = f
	mmCreateEmbeddings.mock.funcCreateEmbeddingsOrigin = minimock.CallerInfo(1)
	return mmCreateEmbeddings.mock
}

// When sets expectation for the Repository.CreateEmbeddings which will trigger the result defined by the following
// Then helper
func (mmCreateEmbeddings *mRepositoryMockCreateEmbeddings) When(ctx context.Context, embeddings []mm_repository.EmbeddingModel, externalServiceCall func([]mm_repository.EmbeddingModel) error) *RepositoryMockCreateEmbeddingsExpectation {
	if mmCreateEmbeddings.mock.funcCreateEmbeddings != nil {
		mmCreateEmbeddings.mock.t.Fatalf("RepositoryMock.CreateEmbeddings mock is already set by Set")
	}

	expectation := &RepositoryMockCreateEmbeddingsExpectation{
		mock:               mmCreateEmbeddings.mock,
		params:             &RepositoryMockCreateEmbeddingsParams{ctx, embeddings, externalServiceCall},
		expectationOrigins: RepositoryMockCreateEmbeddingsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateEmbeddings.expectations = append(mmCreateEmbeddings.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateEmbeddings return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateEmbeddingsExpectation) Then(ea1 []mm_repository.EmbeddingModel, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateEmbeddingsResults{ea1, err}
	return e.mock
}

// Times sets number of times Repository.CreateEmbeddings should be invoked
func (mmCreateEmbeddings *mRepositoryMockCreateEmbeddings) Times(n uint64) *mRepositoryMockCreateEmbeddings {
	if n == 0 {
		mmCreateEmbeddings.mock.t.Fatalf("Times of RepositoryMock.CreateEmbeddings mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateEmbeddings.expectedInvocations, n)
	mmCreateEmbeddings.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateEmbeddings
}

func (mmCreateEmbeddings *mRepositoryMockCreateEmbeddings) invocationsDone() bool {
	if len(mmCreateEmbeddings.expectations) == 0 && mmCreateEmbeddings.defaultExpectation == nil && mmCreateEmbeddings.mock.funcCreateEmbeddings == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateEmbeddings.mock.afterCreateEmbeddingsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateEmbeddings.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateEmbeddings implements mm_repository.Repository
func (mmCreateEmbeddings *RepositoryMock) CreateEmbeddings(ctx context.Context, embeddings []mm_repository.EmbeddingModel, externalServiceCall func([]mm_repository.EmbeddingModel) error) (ea1 []mm_repository.EmbeddingModel, err error) {
	mm_atomic.AddUint64(&mmCreateEmbeddings.beforeCreateEmbeddingsCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateEmbeddings.afterCreateEmbeddingsCounter, 1)

	mmCreateEmbeddings.t.Helper()

	if mmCreateEmbeddings.inspectFuncCreateEmbeddings != nil {
		mmCreateEmbeddings.inspectFuncCreateEmbeddings(ctx, embeddings, externalServiceCall)
	}

	mm_params := RepositoryMockCreateEmbeddingsParams{ctx, embeddings, externalServiceCall}

	// Record call args
	mmCreateEmbeddings.CreateEmbeddingsMock.mutex.Lock()
	mmCreateEmbeddings.CreateEmbeddingsMock.callArgs = append(mmCreateEmbeddings.CreateEmbeddingsMock.callArgs, &mm_params)
	mmCreateEmbeddings.CreateEmbeddingsMock.mutex.Unlock()

	for _, e := range mmCreateEmbeddings.CreateEmbeddingsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1, e.results.err
		}
	}

	if mmCreateEmbeddings.CreateEmbeddingsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateEmbeddings.CreateEmbeddingsMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateEmbeddings.CreateEmbeddingsMock.defaultExpectation.params
		mm_want_ptrs := mmCreateEmbeddings.CreateEmbeddingsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateEmbeddingsParams{ctx, embeddings, externalServiceCall}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateEmbeddings.t.Errorf("RepositoryMock.CreateEmbeddings got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateEmbeddings.CreateEmbeddingsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.embeddings != nil && !minimock.Equal(*mm_want_ptrs.embeddings, mm_got.embeddings) {
				mmCreateEmbeddings.t.Errorf("RepositoryMock.CreateEmbeddings got unexpected parameter embeddings, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateEmbeddings.CreateEmbeddingsMock.defaultExpectation.expectationOrigins.originEmbeddings, *mm_want_ptrs.embeddings, mm_got.embeddings, minimock.Diff(*mm_want_ptrs.embeddings, mm_got.embeddings))
			}

			if mm_want_ptrs.externalServiceCall != nil && !minimock.Equal(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall) {
				mmCreateEmbeddings.t.Errorf("RepositoryMock.CreateEmbeddings got unexpected parameter externalServiceCall, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateEmbeddings.CreateEmbeddingsMock.defaultExpectation.expectationOrigins.originExternalServiceCall, *mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall, minimock.Diff(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateEmbeddings.t.Errorf("RepositoryMock.CreateEmbeddings got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateEmbeddings.CreateEmbeddingsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateEmbeddings.CreateEmbeddingsMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateEmbeddings.t.Fatal("No results are set for the RepositoryMock.CreateEmbeddings")
		}
		return (*mm_results).ea1, (*mm_results).err
	}
	if mmCreateEmbeddings.funcCreateEmbeddings != nil {
		return mmCreateEmbeddings.funcCreateEmbeddings(ctx, embeddings, externalServiceCall)
	}
	mmCreateEmbeddings.t.Fatalf("Unexpected call to RepositoryMock.CreateEmbeddings. %v %v %v", ctx, embeddings, externalServiceCall)
	return
}

// CreateEmbeddingsAfterCounter returns a count of finished RepositoryMock.CreateEmbeddings invocations
func (mmCreateEmbeddings *RepositoryMock) CreateEmbeddingsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateEmbeddings.afterCreateEmbeddingsCounter)
}

// CreateEmbeddingsBeforeCounter returns a count of RepositoryMock.CreateEmbeddings invocations
func (mmCreateEmbeddings *RepositoryMock) CreateEmbeddingsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateEmbeddings.beforeCreateEmbeddingsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateEmbeddings.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateEmbeddings *mRepositoryMockCreateEmbeddings) Calls() []*RepositoryMockCreateEmbeddingsParams {
	mmCreateEmbeddings.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateEmbeddingsParams, len(mmCreateEmbeddings.callArgs))
	copy(argCopy, mmCreateEmbeddings.callArgs)

	mmCreateEmbeddings.mutex.RUnlock()

	return argCopy
}

// MinimockCreateEmbeddingsDone returns true if the count of the CreateEmbeddings invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateEmbeddingsDone() bool {
	if m.CreateEmbeddingsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateEmbeddingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateEmbeddingsMock.invocationsDone()
}

// MinimockCreateEmbeddingsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateEmbeddingsInspect() {
	for _, e := range m.CreateEmbeddingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateEmbeddings at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateEmbeddingsCounter := mm_atomic.LoadUint64(&m.afterCreateEmbeddingsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateEmbeddingsMock.defaultExpectation != nil && afterCreateEmbeddingsCounter < 1 {
		if m.CreateEmbeddingsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateEmbeddings at\n%s", m.CreateEmbeddingsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateEmbeddings at\n%s with params: %#v", m.CreateEmbeddingsMock.defaultExpectation.expectationOrigins.origin, *m.CreateEmbeddingsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateEmbeddings != nil && afterCreateEmbeddingsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateEmbeddings at\n%s", m.funcCreateEmbeddingsOrigin)
	}

	if !m.CreateEmbeddingsMock.invocationsDone() && afterCreateEmbeddingsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateEmbeddings at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateEmbeddingsMock.expectedInvocations), m.CreateEmbeddingsMock.expectedInvocationsOrigin, afterCreateEmbeddingsCounter)
	}
}

type mRepositoryMockCreateKnowledgeBase struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateKnowledgeBaseExpectation
	expectations       []*RepositoryMockCreateKnowledgeBaseExpectation

	callArgs []*RepositoryMockCreateKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateKnowledgeBaseExpectation specifies expectation struct of the Repository.CreateKnowledgeBase
type RepositoryMockCreateKnowledgeBaseExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateKnowledgeBaseParams
	paramPtrs          *RepositoryMockCreateKnowledgeBaseParamPtrs
	expectationOrigins RepositoryMockCreateKnowledgeBaseExpectationOrigins
	results            *RepositoryMockCreateKnowledgeBaseResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateKnowledgeBaseParams contains parameters of the Repository.CreateKnowledgeBase
type RepositoryMockCreateKnowledgeBaseParams struct {
	ctx             context.Context
	kb              mm_repository.KnowledgeBaseModel
	externalService func(kbUID types.KBUIDType, collectionUID types.KBUIDType) error
}

// RepositoryMockCreateKnowledgeBaseParamPtrs contains pointers to parameters of the Repository.CreateKnowledgeBase
type RepositoryMockCreateKnowledgeBaseParamPtrs struct {
	ctx             *context.Context
	kb              *mm_repository.KnowledgeBaseModel
	externalService *func(kbUID types.KBUIDType, collectionUID types.KBUIDType) error
}

// RepositoryMockCreateKnowledgeBaseResults contains results of the Repository.CreateKnowledgeBase
type RepositoryMockCreateKnowledgeBaseResults struct {
	kp1 *mm_repository.KnowledgeBaseModel
	err error
}

// RepositoryMockCreateKnowledgeBaseOrigins contains origins of expectations of the Repository.CreateKnowledgeBase
type RepositoryMockCreateKnowledgeBaseExpectationOrigins struct {
	origin                string
	originCtx             string
	originKb              string
	originExternalService string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) Optional() *mRepositoryMockCreateKnowledgeBase {
	mmCreateKnowledgeBase.optional = true
	return mmCreateKnowledgeBase
}

// Expect sets up expected params for Repository.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) Expect(ctx context.Context, kb mm_repository.KnowledgeBaseModel, externalService func(kbUID types.KBUIDType, collectionUID types.KBUIDType) error) *mRepositoryMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmCreateKnowledgeBase.defaultExpectation.params = &RepositoryMockCreateKnowledgeBaseParams{ctx, kb, externalService}
	mmCreateKnowledgeBase.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmCreateKnowledgeBase.defaultExpectation.params) {
			mmCreateKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmCreateKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.params != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBase mock is already set by Expect")
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockCreateKnowledgeBaseParamPtrs{}
	}
	mmCreateKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateKnowledgeBase.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateKnowledgeBase
}

// ExpectKbParam2 sets up expected param kb for Repository.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) ExpectKbParam2(kb mm_repository.KnowledgeBaseModel) *mRepositoryMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.params != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBase mock is already set by Expect")
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockCreateKnowledgeBaseParamPtrs{}
	}
	mmCreateKnowledgeBase.defaultExpectation.paramPtrs.kb = &kb
	mmCreateKnowledgeBase.defaultExpectation.expectationOrigins.originKb = minimock.CallerInfo(1)

	return mmCreateKnowledgeBase
}

// ExpectExternalServiceParam3 sets up expected param externalService for Repository.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) ExpectExternalServiceParam3(externalService func(kbUID types.KBUIDType, collectionUID types.KBUIDType) error) *mRepositoryMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.params != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBase mock is already set by Expect")
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockCreateKnowledgeBaseParamPtrs{}
	}
	mmCreateKnowledgeBase.defaultExpectation.paramPtrs.externalService = &externalService
	mmCreateKnowledgeBase.defaultExpectation.expectationOrigins.originExternalService = minimock.CallerInfo(1)

	return mmCreateKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) Inspect(f func(ctx context.Context, kb mm_repository.KnowledgeBaseModel, externalService func(kbUID types.KBUIDType, collectionUID types.KBUIDType) error)) *mRepositoryMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.inspectFuncCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateKnowledgeBase")
	}

	mmCreateKnowledgeBase.mock.inspectFuncCreateKnowledgeBase = f

	return mmCreateKnowledgeBase
}

// Return sets up results that will be returned by Repository.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) Return(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryMockCreateKnowledgeBaseExpectation{mock: mmCreateKnowledgeBase.mock}
	}
	mmCreateKnowledgeBase.defaultExpectation.results = &RepositoryMockCreateKnowledgeBaseResults{kp1, err}
	mmCreateKnowledgeBase.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateKnowledgeBase.mock
}

// Set uses given function f to mock the Repository.CreateKnowledgeBase method
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) Set(f func(ctx context.Context, kb mm_repository.KnowledgeBaseModel, externalService func(kbUID types.KBUIDType, collectionUID types.KBUIDType) error) (kp1 *mm_repository.KnowledgeBaseModel, err error)) *RepositoryMock {
	if mmCreateKnowledgeBase.defaultExpectation != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the Repository.CreateKnowledgeBase method")
	}

	if len(mmCreateKnowledgeBase.expectations) > 0 {
		mmCreateKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the Repository.CreateKnowledgeBase method")
	}

	mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase = f
	mmCreateKnowledgeBase.mock.funcCreateKnowledgeBaseOrigin = minimock.CallerInfo(1)
	return mmCreateKnowledgeBase.mock
}

// When sets expectation for the Repository.CreateKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) When(ctx context.Context, kb mm_repository.KnowledgeBaseModel, externalService func(kbUID types.KBUIDType, collectionUID types.KBUIDType) error) *RepositoryMockCreateKnowledgeBaseExpectation {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBase mock is already set by Set")
	}

	expectation := &RepositoryMockCreateKnowledgeBaseExpectation{
		mock:               mmCreateKnowledgeBase.mock,
		params:             &RepositoryMockCreateKnowledgeBaseParams{ctx, kb, externalService},
		expectationOrigins: RepositoryMockCreateKnowledgeBaseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateKnowledgeBase.expectations = append(mmCreateKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateKnowledgeBaseExpectation) Then(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateKnowledgeBaseResults{kp1, err}
	return e.mock
}

// Times sets number of times Repository.CreateKnowledgeBase should be invoked
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) Times(n uint64) *mRepositoryMockCreateKnowledgeBase {
	if n == 0 {
		mmCreateKnowledgeBase.mock.t.Fatalf("Times of RepositoryMock.CreateKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateKnowledgeBase.expectedInvocations, n)
	mmCreateKnowledgeBase.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateKnowledgeBase
}

func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) invocationsDone() bool {
	if len(mmCreateKnowledgeBase.expectations) == 0 && mmCreateKnowledgeBase.defaultExpectation == nil && mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateKnowledgeBase.mock.afterCreateKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateKnowledgeBase implements mm_repository.Repository
func (mmCreateKnowledgeBase *RepositoryMock) CreateKnowledgeBase(ctx context.Context, kb mm_repository.KnowledgeBaseModel, externalService func(kbUID types.KBUIDType, collectionUID types.KBUIDType) error) (kp1 *mm_repository.KnowledgeBaseModel, err error) {
	mm_atomic.AddUint64(&mmCreateKnowledgeBase.beforeCreateKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateKnowledgeBase.afterCreateKnowledgeBaseCounter, 1)

	mmCreateKnowledgeBase.t.Helper()

	if mmCreateKnowledgeBase.inspectFuncCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.inspectFuncCreateKnowledgeBase(ctx, kb, externalService)
	}

	mm_params := RepositoryMockCreateKnowledgeBaseParams{ctx, kb, externalService}

	// Record call args
	mmCreateKnowledgeBase.CreateKnowledgeBaseMock.mutex.Lock()
	mmCreateKnowledgeBase.CreateKnowledgeBaseMock.callArgs = append(mmCreateKnowledgeBase.CreateKnowledgeBaseMock.callArgs, &mm_params)
	mmCreateKnowledgeBase.CreateKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmCreateKnowledgeBase.CreateKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateKnowledgeBaseParams{ctx, kb, externalService}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateKnowledgeBase.t.Errorf("RepositoryMock.CreateKnowledgeBase got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kb != nil && !minimock.Equal(*mm_want_ptrs.kb, mm_got.kb) {
				mmCreateKnowledgeBase.t.Errorf("RepositoryMock.CreateKnowledgeBase got unexpected parameter kb, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.expectationOrigins.originKb, *mm_want_ptrs.kb, mm_got.kb, minimock.Diff(*mm_want_ptrs.kb, mm_got.kb))
			}

			if mm_want_ptrs.externalService != nil && !minimock.Equal(*mm_want_ptrs.externalService, mm_got.externalService) {
				mmCreateKnowledgeBase.t.Errorf("RepositoryMock.CreateKnowledgeBase got unexpected parameter externalService, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.expectationOrigins.originExternalService, *mm_want_ptrs.externalService, mm_got.externalService, minimock.Diff(*mm_want_ptrs.externalService, mm_got.externalService))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateKnowledgeBase.t.Errorf("RepositoryMock.CreateKnowledgeBase got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateKnowledgeBase.t.Fatal("No results are set for the RepositoryMock.CreateKnowledgeBase")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmCreateKnowledgeBase.funcCreateKnowledgeBase != nil {
		return mmCreateKnowledgeBase.funcCreateKnowledgeBase(ctx, kb, externalService)
	}
	mmCreateKnowledgeBase.t.Fatalf("Unexpected call to RepositoryMock.CreateKnowledgeBase. %v %v %v", ctx, kb, externalService)
	return
}

// CreateKnowledgeBaseAfterCounter returns a count of finished RepositoryMock.CreateKnowledgeBase invocations
func (mmCreateKnowledgeBase *RepositoryMock) CreateKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateKnowledgeBase.afterCreateKnowledgeBaseCounter)
}

// CreateKnowledgeBaseBeforeCounter returns a count of RepositoryMock.CreateKnowledgeBase invocations
func (mmCreateKnowledgeBase *RepositoryMock) CreateKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateKnowledgeBase.beforeCreateKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) Calls() []*RepositoryMockCreateKnowledgeBaseParams {
	mmCreateKnowledgeBase.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateKnowledgeBaseParams, len(mmCreateKnowledgeBase.callArgs))
	copy(argCopy, mmCreateKnowledgeBase.callArgs)

	mmCreateKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockCreateKnowledgeBaseDone returns true if the count of the CreateKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateKnowledgeBaseDone() bool {
	if m.CreateKnowledgeBaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateKnowledgeBaseMock.invocationsDone()
}

// MinimockCreateKnowledgeBaseInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateKnowledgeBaseInspect() {
	for _, e := range m.CreateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateKnowledgeBase at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterCreateKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateKnowledgeBaseMock.defaultExpectation != nil && afterCreateKnowledgeBaseCounter < 1 {
		if m.CreateKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateKnowledgeBase at\n%s", m.CreateKnowledgeBaseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateKnowledgeBase at\n%s with params: %#v", m.CreateKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *m.CreateKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateKnowledgeBase != nil && afterCreateKnowledgeBaseCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateKnowledgeBase at\n%s", m.funcCreateKnowledgeBaseOrigin)
	}

	if !m.CreateKnowledgeBaseMock.invocationsDone() && afterCreateKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateKnowledgeBase at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateKnowledgeBaseMock.expectedInvocations), m.CreateKnowledgeBaseMock.expectedInvocationsOrigin, afterCreateKnowledgeBaseCounter)
	}
}

type mRepositoryMockCreateKnowledgeBaseFile struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateKnowledgeBaseFileExpectation
	expectations       []*RepositoryMockCreateKnowledgeBaseFileExpectation

	callArgs []*RepositoryMockCreateKnowledgeBaseFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateKnowledgeBaseFileExpectation specifies expectation struct of the Repository.CreateKnowledgeBaseFile
type RepositoryMockCreateKnowledgeBaseFileExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateKnowledgeBaseFileParams
	paramPtrs          *RepositoryMockCreateKnowledgeBaseFileParamPtrs
	expectationOrigins RepositoryMockCreateKnowledgeBaseFileExpectationOrigins
	results            *RepositoryMockCreateKnowledgeBaseFileResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateKnowledgeBaseFileParams contains parameters of the Repository.CreateKnowledgeBaseFile
type RepositoryMockCreateKnowledgeBaseFileParams struct {
	ctx                 context.Context
	kb                  mm_repository.KnowledgeBaseFileModel
	externalServiceCall func(fileUID string) error
}

// RepositoryMockCreateKnowledgeBaseFileParamPtrs contains pointers to parameters of the Repository.CreateKnowledgeBaseFile
type RepositoryMockCreateKnowledgeBaseFileParamPtrs struct {
	ctx                 *context.Context
	kb                  *mm_repository.KnowledgeBaseFileModel
	externalServiceCall *func(fileUID string) error
}

// RepositoryMockCreateKnowledgeBaseFileResults contains results of the Repository.CreateKnowledgeBaseFile
type RepositoryMockCreateKnowledgeBaseFileResults struct {
	kp1 *mm_repository.KnowledgeBaseFileModel
	err error
}

// RepositoryMockCreateKnowledgeBaseFileOrigins contains origins of expectations of the Repository.CreateKnowledgeBaseFile
type RepositoryMockCreateKnowledgeBaseFileExpectationOrigins struct {
	origin                    string
	originCtx                 string
	originKb                  string
	originExternalServiceCall string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateKnowledgeBaseFile *mRepositoryMockCreateKnowledgeBaseFile) Optional() *mRepositoryMockCreateKnowledgeBaseFile {
	mmCreateKnowledgeBaseFile.optional = true
	return mmCreateKnowledgeBaseFile
}

// Expect sets up expected params for Repository.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryMockCreateKnowledgeBaseFile) Expect(ctx context.Context, kb mm_repository.KnowledgeBaseFileModel, externalServiceCall func(fileUID string) error) *mRepositoryMockCreateKnowledgeBaseFile {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation = &RepositoryMockCreateKnowledgeBaseFileExpectation{}
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBaseFile mock is already set by ExpectParams functions")
	}

	mmCreateKnowledgeBaseFile.defaultExpectation.params = &RepositoryMockCreateKnowledgeBaseFileParams{ctx, kb, externalServiceCall}
	mmCreateKnowledgeBaseFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateKnowledgeBaseFile.expectations {
		if minimock.Equal(e.params, mmCreateKnowledgeBaseFile.defaultExpectation.params) {
			mmCreateKnowledgeBaseFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateKnowledgeBaseFile.defaultExpectation.params)
		}
	}

	return mmCreateKnowledgeBaseFile
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryMockCreateKnowledgeBaseFile) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateKnowledgeBaseFile {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation = &RepositoryMockCreateKnowledgeBaseFileExpectation{}
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryMockCreateKnowledgeBaseFileParamPtrs{}
	}
	mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateKnowledgeBaseFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateKnowledgeBaseFile
}

// ExpectKbParam2 sets up expected param kb for Repository.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryMockCreateKnowledgeBaseFile) ExpectKbParam2(kb mm_repository.KnowledgeBaseFileModel) *mRepositoryMockCreateKnowledgeBaseFile {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation = &RepositoryMockCreateKnowledgeBaseFileExpectation{}
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryMockCreateKnowledgeBaseFileParamPtrs{}
	}
	mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs.kb = &kb
	mmCreateKnowledgeBaseFile.defaultExpectation.expectationOrigins.originKb = minimock.CallerInfo(1)

	return mmCreateKnowledgeBaseFile
}

// ExpectExternalServiceCallParam3 sets up expected param externalServiceCall for Repository.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryMockCreateKnowledgeBaseFile) ExpectExternalServiceCallParam3(externalServiceCall func(fileUID string) error) *mRepositoryMockCreateKnowledgeBaseFile {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation = &RepositoryMockCreateKnowledgeBaseFileExpectation{}
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryMockCreateKnowledgeBaseFileParamPtrs{}
	}
	mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs.externalServiceCall = &externalServiceCall
	mmCreateKnowledgeBaseFile.defaultExpectation.expectationOrigins.originExternalServiceCall = minimock.CallerInfo(1)

	return mmCreateKnowledgeBaseFile
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryMockCreateKnowledgeBaseFile) Inspect(f func(ctx context.Context, kb mm_repository.KnowledgeBaseFileModel, externalServiceCall func(fileUID string) error)) *mRepositoryMockCreateKnowledgeBaseFile {
	if mmCreateKnowledgeBaseFile.mock.inspectFuncCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateKnowledgeBaseFile")
	}

	mmCreateKnowledgeBaseFile.mock.inspectFuncCreateKnowledgeBaseFile = f

	return mmCreateKnowledgeBaseFile
}

// Return sets up results that will be returned by Repository.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryMockCreateKnowledgeBaseFile) Return(kp1 *mm_repository.KnowledgeBaseFileModel, err error) *RepositoryMock {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation = &RepositoryMockCreateKnowledgeBaseFileExpectation{mock: mmCreateKnowledgeBaseFile.mock}
	}
	mmCreateKnowledgeBaseFile.defaultExpectation.results = &RepositoryMockCreateKnowledgeBaseFileResults{kp1, err}
	mmCreateKnowledgeBaseFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateKnowledgeBaseFile.mock
}

// Set uses given function f to mock the Repository.CreateKnowledgeBaseFile method
func (mmCreateKnowledgeBaseFile *mRepositoryMockCreateKnowledgeBaseFile) Set(f func(ctx context.Context, kb mm_repository.KnowledgeBaseFileModel, externalServiceCall func(fileUID string) error) (kp1 *mm_repository.KnowledgeBaseFileModel, err error)) *RepositoryMock {
	if mmCreateKnowledgeBaseFile.defaultExpectation != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("Default expectation is already set for the Repository.CreateKnowledgeBaseFile method")
	}

	if len(mmCreateKnowledgeBaseFile.expectations) > 0 {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("Some expectations are already set for the Repository.CreateKnowledgeBaseFile method")
	}

	mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile = f
	mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFileOrigin = minimock.CallerInfo(1)
	return mmCreateKnowledgeBaseFile.mock
}

// When sets expectation for the Repository.CreateKnowledgeBaseFile which will trigger the result defined by the following
// Then helper
func (mmCreateKnowledgeBaseFile *mRepositoryMockCreateKnowledgeBaseFile) When(ctx context.Context, kb mm_repository.KnowledgeBaseFileModel, externalServiceCall func(fileUID string) error) *RepositoryMockCreateKnowledgeBaseFileExpectation {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	expectation := &RepositoryMockCreateKnowledgeBaseFileExpectation{
		mock:               mmCreateKnowledgeBaseFile.mock,
		params:             &RepositoryMockCreateKnowledgeBaseFileParams{ctx, kb, externalServiceCall},
		expectationOrigins: RepositoryMockCreateKnowledgeBaseFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateKnowledgeBaseFile.expectations = append(mmCreateKnowledgeBaseFile.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateKnowledgeBaseFile return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateKnowledgeBaseFileExpectation) Then(kp1 *mm_repository.KnowledgeBaseFileModel, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateKnowledgeBaseFileResults{kp1, err}
	return e.mock
}

// Times sets number of times Repository.CreateKnowledgeBaseFile should be invoked
func (mmCreateKnowledgeBaseFile *mRepositoryMockCreateKnowledgeBaseFile) Times(n uint64) *mRepositoryMockCreateKnowledgeBaseFile {
	if n == 0 {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("Times of RepositoryMock.CreateKnowledgeBaseFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateKnowledgeBaseFile.expectedInvocations, n)
	mmCreateKnowledgeBaseFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateKnowledgeBaseFile
}

func (mmCreateKnowledgeBaseFile *mRepositoryMockCreateKnowledgeBaseFile) invocationsDone() bool {
	if len(mmCreateKnowledgeBaseFile.expectations) == 0 && mmCreateKnowledgeBaseFile.defaultExpectation == nil && mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateKnowledgeBaseFile.mock.afterCreateKnowledgeBaseFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateKnowledgeBaseFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateKnowledgeBaseFile implements mm_repository.Repository
func (mmCreateKnowledgeBaseFile *RepositoryMock) CreateKnowledgeBaseFile(ctx context.Context, kb mm_repository.KnowledgeBaseFileModel, externalServiceCall func(fileUID string) error) (kp1 *mm_repository.KnowledgeBaseFileModel, err error) {
	mm_atomic.AddUint64(&mmCreateKnowledgeBaseFile.beforeCreateKnowledgeBaseFileCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateKnowledgeBaseFile.afterCreateKnowledgeBaseFileCounter, 1)

	mmCreateKnowledgeBaseFile.t.Helper()

	if mmCreateKnowledgeBaseFile.inspectFuncCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.inspectFuncCreateKnowledgeBaseFile(ctx, kb, externalServiceCall)
	}

	mm_params := RepositoryMockCreateKnowledgeBaseFileParams{ctx, kb, externalServiceCall}

	// Record call args
	mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.mutex.Lock()
	mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.callArgs = append(mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.callArgs, &mm_params)
	mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.mutex.Unlock()

	for _, e := range mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation.params
		mm_want_ptrs := mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateKnowledgeBaseFileParams{ctx, kb, externalServiceCall}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateKnowledgeBaseFile.t.Errorf("RepositoryMock.CreateKnowledgeBaseFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kb != nil && !minimock.Equal(*mm_want_ptrs.kb, mm_got.kb) {
				mmCreateKnowledgeBaseFile.t.Errorf("RepositoryMock.CreateKnowledgeBaseFile got unexpected parameter kb, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation.expectationOrigins.originKb, *mm_want_ptrs.kb, mm_got.kb, minimock.Diff(*mm_want_ptrs.kb, mm_got.kb))
			}

			if mm_want_ptrs.externalServiceCall != nil && !minimock.Equal(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall) {
				mmCreateKnowledgeBaseFile.t.Errorf("RepositoryMock.CreateKnowledgeBaseFile got unexpected parameter externalServiceCall, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation.expectationOrigins.originExternalServiceCall, *mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall, minimock.Diff(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateKnowledgeBaseFile.t.Errorf("RepositoryMock.CreateKnowledgeBaseFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateKnowledgeBaseFile.t.Fatal("No results are set for the RepositoryMock.CreateKnowledgeBaseFile")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmCreateKnowledgeBaseFile.funcCreateKnowledgeBaseFile != nil {
		return mmCreateKnowledgeBaseFile.funcCreateKnowledgeBaseFile(ctx, kb, externalServiceCall)
	}
	mmCreateKnowledgeBaseFile.t.Fatalf("Unexpected call to RepositoryMock.CreateKnowledgeBaseFile. %v %v %v", ctx, kb, externalServiceCall)
	return
}

// CreateKnowledgeBaseFileAfterCounter returns a count of finished RepositoryMock.CreateKnowledgeBaseFile invocations
func (mmCreateKnowledgeBaseFile *RepositoryMock) CreateKnowledgeBaseFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateKnowledgeBaseFile.afterCreateKnowledgeBaseFileCounter)
}

// CreateKnowledgeBaseFileBeforeCounter returns a count of RepositoryMock.CreateKnowledgeBaseFile invocations
func (mmCreateKnowledgeBaseFile *RepositoryMock) CreateKnowledgeBaseFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateKnowledgeBaseFile.beforeCreateKnowledgeBaseFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateKnowledgeBaseFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateKnowledgeBaseFile *mRepositoryMockCreateKnowledgeBaseFile) Calls() []*RepositoryMockCreateKnowledgeBaseFileParams {
	mmCreateKnowledgeBaseFile.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateKnowledgeBaseFileParams, len(mmCreateKnowledgeBaseFile.callArgs))
	copy(argCopy, mmCreateKnowledgeBaseFile.callArgs)

	mmCreateKnowledgeBaseFile.mutex.RUnlock()

	return argCopy
}

// MinimockCreateKnowledgeBaseFileDone returns true if the count of the CreateKnowledgeBaseFile invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateKnowledgeBaseFileDone() bool {
	if m.CreateKnowledgeBaseFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateKnowledgeBaseFileMock.invocationsDone()
}

// MinimockCreateKnowledgeBaseFileInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateKnowledgeBaseFileInspect() {
	for _, e := range m.CreateKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateKnowledgeBaseFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateKnowledgeBaseFileCounter := mm_atomic.LoadUint64(&m.afterCreateKnowledgeBaseFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateKnowledgeBaseFileMock.defaultExpectation != nil && afterCreateKnowledgeBaseFileCounter < 1 {
		if m.CreateKnowledgeBaseFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateKnowledgeBaseFile at\n%s", m.CreateKnowledgeBaseFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateKnowledgeBaseFile at\n%s with params: %#v", m.CreateKnowledgeBaseFileMock.defaultExpectation.expectationOrigins.origin, *m.CreateKnowledgeBaseFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateKnowledgeBaseFile != nil && afterCreateKnowledgeBaseFileCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateKnowledgeBaseFile at\n%s", m.funcCreateKnowledgeBaseFileOrigin)
	}

	if !m.CreateKnowledgeBaseFileMock.invocationsDone() && afterCreateKnowledgeBaseFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateKnowledgeBaseFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateKnowledgeBaseFileMock.expectedInvocations), m.CreateKnowledgeBaseFileMock.expectedInvocationsOrigin, afterCreateKnowledgeBaseFileCounter)
	}
}

type mRepositoryMockCreateObject struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateObjectExpectation
	expectations       []*RepositoryMockCreateObjectExpectation

	callArgs []*RepositoryMockCreateObjectParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateObjectExpectation specifies expectation struct of the Repository.CreateObject
type RepositoryMockCreateObjectExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateObjectParams
	paramPtrs          *RepositoryMockCreateObjectParamPtrs
	expectationOrigins RepositoryMockCreateObjectExpectationOrigins
	results            *RepositoryMockCreateObjectResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateObjectParams contains parameters of the Repository.CreateObject
type RepositoryMockCreateObjectParams struct {
	ctx context.Context
	obj mm_repository.ObjectModel
}

// RepositoryMockCreateObjectParamPtrs contains pointers to parameters of the Repository.CreateObject
type RepositoryMockCreateObjectParamPtrs struct {
	ctx *context.Context
	obj *mm_repository.ObjectModel
}

// RepositoryMockCreateObjectResults contains results of the Repository.CreateObject
type RepositoryMockCreateObjectResults struct {
	op1 *mm_repository.ObjectModel
	err error
}

// RepositoryMockCreateObjectOrigins contains origins of expectations of the Repository.CreateObject
type RepositoryMockCreateObjectExpectationOrigins struct {
	origin    string
	originCtx string
	originObj string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateObject *mRepositoryMockCreateObject) Optional() *mRepositoryMockCreateObject {
	mmCreateObject.optional = true
	return mmCreateObject
}

// Expect sets up expected params for Repository.CreateObject
func (mmCreateObject *mRepositoryMockCreateObject) Expect(ctx context.Context, obj mm_repository.ObjectModel) *mRepositoryMockCreateObject {
	if mmCreateObject.mock.funcCreateObject != nil {
		mmCreateObject.mock.t.Fatalf("RepositoryMock.CreateObject mock is already set by Set")
	}

	if mmCreateObject.defaultExpectation == nil {
		mmCreateObject.defaultExpectation = &RepositoryMockCreateObjectExpectation{}
	}

	if mmCreateObject.defaultExpectation.paramPtrs != nil {
		mmCreateObject.mock.t.Fatalf("RepositoryMock.CreateObject mock is already set by ExpectParams functions")
	}

	mmCreateObject.defaultExpectation.params = &RepositoryMockCreateObjectParams{ctx, obj}
	mmCreateObject.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateObject.expectations {
		if minimock.Equal(e.params, mmCreateObject.defaultExpectation.params) {
			mmCreateObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateObject.defaultExpectation.params)
		}
	}

	return mmCreateObject
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateObject
func (mmCreateObject *mRepositoryMockCreateObject) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateObject {
	if mmCreateObject.mock.funcCreateObject != nil {
		mmCreateObject.mock.t.Fatalf("RepositoryMock.CreateObject mock is already set by Set")
	}

	if mmCreateObject.defaultExpectation == nil {
		mmCreateObject.defaultExpectation = &RepositoryMockCreateObjectExpectation{}
	}

	if mmCreateObject.defaultExpectation.params != nil {
		mmCreateObject.mock.t.Fatalf("RepositoryMock.CreateObject mock is already set by Expect")
	}

	if mmCreateObject.defaultExpectation.paramPtrs == nil {
		mmCreateObject.defaultExpectation.paramPtrs = &RepositoryMockCreateObjectParamPtrs{}
	}
	mmCreateObject.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateObject.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateObject
}

// ExpectObjParam2 sets up expected param obj for Repository.CreateObject
func (mmCreateObject *mRepositoryMockCreateObject) ExpectObjParam2(obj mm_repository.ObjectModel) *mRepositoryMockCreateObject {
	if mmCreateObject.mock.funcCreateObject != nil {
		mmCreateObject.mock.t.Fatalf("RepositoryMock.CreateObject mock is already set by Set")
	}

	if mmCreateObject.defaultExpectation == nil {
		mmCreateObject.defaultExpectation = &RepositoryMockCreateObjectExpectation{}
	}

	if mmCreateObject.defaultExpectation.params != nil {
		mmCreateObject.mock.t.Fatalf("RepositoryMock.CreateObject mock is already set by Expect")
	}

	if mmCreateObject.defaultExpectation.paramPtrs == nil {
		mmCreateObject.defaultExpectation.paramPtrs = &RepositoryMockCreateObjectParamPtrs{}
	}
	mmCreateObject.defaultExpectation.paramPtrs.obj = &obj
	mmCreateObject.defaultExpectation.expectationOrigins.originObj = minimock.CallerInfo(1)

	return mmCreateObject
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateObject
func (mmCreateObject *mRepositoryMockCreateObject) Inspect(f func(ctx context.Context, obj mm_repository.ObjectModel)) *mRepositoryMockCreateObject {
	if mmCreateObject.mock.inspectFuncCreateObject != nil {
		mmCreateObject.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateObject")
	}

	mmCreateObject.mock.inspectFuncCreateObject = f

	return mmCreateObject
}

// Return sets up results that will be returned by Repository.CreateObject
func (mmCreateObject *mRepositoryMockCreateObject) Return(op1 *mm_repository.ObjectModel, err error) *RepositoryMock {
	if mmCreateObject.mock.funcCreateObject != nil {
		mmCreateObject.mock.t.Fatalf("RepositoryMock.CreateObject mock is already set by Set")
	}

	if mmCreateObject.defaultExpectation == nil {
		mmCreateObject.defaultExpectation = &RepositoryMockCreateObjectExpectation{mock: mmCreateObject.mock}
	}
	mmCreateObject.defaultExpectation.results = &RepositoryMockCreateObjectResults{op1, err}
	mmCreateObject.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateObject.mock
}

// Set uses given function f to mock the Repository.CreateObject method
func (mmCreateObject *mRepositoryMockCreateObject) Set(f func(ctx context.Context, obj mm_repository.ObjectModel) (op1 *mm_repository.ObjectModel, err error)) *RepositoryMock {
	if mmCreateObject.defaultExpectation != nil {
		mmCreateObject.mock.t.Fatalf("Default expectation is already set for the Repository.CreateObject method")
	}

	if len(mmCreateObject.expectations) > 0 {
		mmCreateObject.mock.t.Fatalf("Some expectations are already set for the Repository.CreateObject method")
	}

	mmCreateObject.mock.funcCreateObject = f
	mmCreateObject.mock.funcCreateObjectOrigin = minimock.CallerInfo(1)
	return mmCreateObject.mock
}

// When sets expectation for the Repository.CreateObject which will trigger the result defined by the following
// Then helper
func (mmCreateObject *mRepositoryMockCreateObject) When(ctx context.Context, obj mm_repository.ObjectModel) *RepositoryMockCreateObjectExpectation {
	if mmCreateObject.mock.funcCreateObject != nil {
		mmCreateObject.mock.t.Fatalf("RepositoryMock.CreateObject mock is already set by Set")
	}

	expectation := &RepositoryMockCreateObjectExpectation{
		mock:               mmCreateObject.mock,
		params:             &RepositoryMockCreateObjectParams{ctx, obj},
		expectationOrigins: RepositoryMockCreateObjectExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateObject.expectations = append(mmCreateObject.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateObject return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateObjectExpectation) Then(op1 *mm_repository.ObjectModel, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateObjectResults{op1, err}
	return e.mock
}

// Times sets number of times Repository.CreateObject should be invoked
func (mmCreateObject *mRepositoryMockCreateObject) Times(n uint64) *mRepositoryMockCreateObject {
	if n == 0 {
		mmCreateObject.mock.t.Fatalf("Times of RepositoryMock.CreateObject mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateObject.expectedInvocations, n)
	mmCreateObject.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateObject
}

func (mmCreateObject *mRepositoryMockCreateObject) invocationsDone() bool {
	if len(mmCreateObject.expectations) == 0 && mmCreateObject.defaultExpectation == nil && mmCreateObject.mock.funcCreateObject == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateObject.mock.afterCreateObjectCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateObject.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateObject implements mm_repository.Repository
func (mmCreateObject *RepositoryMock) CreateObject(ctx context.Context, obj mm_repository.ObjectModel) (op1 *mm_repository.ObjectModel, err error) {
	mm_atomic.AddUint64(&mmCreateObject.beforeCreateObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateObject.afterCreateObjectCounter, 1)

	mmCreateObject.t.Helper()

	if mmCreateObject.inspectFuncCreateObject != nil {
		mmCreateObject.inspectFuncCreateObject(ctx, obj)
	}

	mm_params := RepositoryMockCreateObjectParams{ctx, obj}

	// Record call args
	mmCreateObject.CreateObjectMock.mutex.Lock()
	mmCreateObject.CreateObjectMock.callArgs = append(mmCreateObject.CreateObjectMock.callArgs, &mm_params)
	mmCreateObject.CreateObjectMock.mutex.Unlock()

	for _, e := range mmCreateObject.CreateObjectMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmCreateObject.CreateObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateObject.CreateObjectMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateObject.CreateObjectMock.defaultExpectation.params
		mm_want_ptrs := mmCreateObject.CreateObjectMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateObjectParams{ctx, obj}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateObject.t.Errorf("RepositoryMock.CreateObject got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateObject.CreateObjectMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.obj != nil && !minimock.Equal(*mm_want_ptrs.obj, mm_got.obj) {
				mmCreateObject.t.Errorf("RepositoryMock.CreateObject got unexpected parameter obj, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateObject.CreateObjectMock.defaultExpectation.expectationOrigins.originObj, *mm_want_ptrs.obj, mm_got.obj, minimock.Diff(*mm_want_ptrs.obj, mm_got.obj))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateObject.t.Errorf("RepositoryMock.CreateObject got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateObject.CreateObjectMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateObject.CreateObjectMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateObject.t.Fatal("No results are set for the RepositoryMock.CreateObject")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmCreateObject.funcCreateObject != nil {
		return mmCreateObject.funcCreateObject(ctx, obj)
	}
	mmCreateObject.t.Fatalf("Unexpected call to RepositoryMock.CreateObject. %v %v", ctx, obj)
	return
}

// CreateObjectAfterCounter returns a count of finished RepositoryMock.CreateObject invocations
func (mmCreateObject *RepositoryMock) CreateObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateObject.afterCreateObjectCounter)
}

// CreateObjectBeforeCounter returns a count of RepositoryMock.CreateObject invocations
func (mmCreateObject *RepositoryMock) CreateObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateObject.beforeCreateObjectCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateObject *mRepositoryMockCreateObject) Calls() []*RepositoryMockCreateObjectParams {
	mmCreateObject.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateObjectParams, len(mmCreateObject.callArgs))
	copy(argCopy, mmCreateObject.callArgs)

	mmCreateObject.mutex.RUnlock()

	return argCopy
}

// MinimockCreateObjectDone returns true if the count of the CreateObject invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateObjectDone() bool {
	if m.CreateObjectMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateObjectMock.invocationsDone()
}

// MinimockCreateObjectInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateObjectInspect() {
	for _, e := range m.CreateObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateObject at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateObjectCounter := mm_atomic.LoadUint64(&m.afterCreateObjectCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateObjectMock.defaultExpectation != nil && afterCreateObjectCounter < 1 {
		if m.CreateObjectMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateObject at\n%s", m.CreateObjectMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateObject at\n%s with params: %#v", m.CreateObjectMock.defaultExpectation.expectationOrigins.origin, *m.CreateObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateObject != nil && afterCreateObjectCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateObject at\n%s", m.funcCreateObjectOrigin)
	}

	if !m.CreateObjectMock.invocationsDone() && afterCreateObjectCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateObject at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateObjectMock.expectedInvocations), m.CreateObjectMock.expectedInvocationsOrigin, afterCreateObjectCounter)
	}
}

type mRepositoryMockCreateStagingKnowledgeBase struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateStagingKnowledgeBaseExpectation
	expectations       []*RepositoryMockCreateStagingKnowledgeBaseExpectation

	callArgs []*RepositoryMockCreateStagingKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateStagingKnowledgeBaseExpectation specifies expectation struct of the Repository.CreateStagingKnowledgeBase
type RepositoryMockCreateStagingKnowledgeBaseExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateStagingKnowledgeBaseParams
	paramPtrs          *RepositoryMockCreateStagingKnowledgeBaseParamPtrs
	expectationOrigins RepositoryMockCreateStagingKnowledgeBaseExpectationOrigins
	results            *RepositoryMockCreateStagingKnowledgeBaseResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateStagingKnowledgeBaseParams contains parameters of the Repository.CreateStagingKnowledgeBase
type RepositoryMockCreateStagingKnowledgeBaseParams struct {
	ctx             context.Context
	original        *mm_repository.KnowledgeBaseModel
	newSystemUID    *types.SystemUIDType
	externalService func(kbUID types.KBUIDType, collectionUID types.KBUIDType) error
}

// RepositoryMockCreateStagingKnowledgeBaseParamPtrs contains pointers to parameters of the Repository.CreateStagingKnowledgeBase
type RepositoryMockCreateStagingKnowledgeBaseParamPtrs struct {
	ctx             *context.Context
	original        **mm_repository.KnowledgeBaseModel
	newSystemUID    **types.SystemUIDType
	externalService *func(kbUID types.KBUIDType, collectionUID types.KBUIDType) error
}

// RepositoryMockCreateStagingKnowledgeBaseResults contains results of the Repository.CreateStagingKnowledgeBase
type RepositoryMockCreateStagingKnowledgeBaseResults struct {
	kp1 *mm_repository.KnowledgeBaseModel
	err error
}

// RepositoryMockCreateStagingKnowledgeBaseOrigins contains origins of expectations of the Repository.CreateStagingKnowledgeBase
type RepositoryMockCreateStagingKnowledgeBaseExpectationOrigins struct {
	origin                string
	originCtx             string
	originOriginal        string
	originNewSystemUID    string
	originExternalService string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateStagingKnowledgeBase *mRepositoryMockCreateStagingKnowledgeBase) Optional() *mRepositoryMockCreateStagingKnowledgeBase {
	mmCreateStagingKnowledgeBase.optional = true
	return mmCreateStagingKnowledgeBase
}

// Expect sets up expected params for Repository.CreateStagingKnowledgeBase
func (mmCreateStagingKnowledgeBase *mRepositoryMockCreateStagingKnowledgeBase) Expect(ctx context.Context, original *mm_repository.KnowledgeBaseModel, newSystemUID *types.SystemUIDType, externalService func(kbUID types.KBUIDType, collectionUID types.KBUIDType) error) *mRepositoryMockCreateStagingKnowledgeBase {
	if mmCreateStagingKnowledgeBase.mock.funcCreateStagingKnowledgeBase != nil {
		mmCreateStagingKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateStagingKnowledgeBase mock is already set by Set")
	}

	if mmCreateStagingKnowledgeBase.defaultExpectation == nil {
		mmCreateStagingKnowledgeBase.defaultExpectation = &RepositoryMockCreateStagingKnowledgeBaseExpectation{}
	}

	if mmCreateStagingKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmCreateStagingKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateStagingKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmCreateStagingKnowledgeBase.defaultExpectation.params = &RepositoryMockCreateStagingKnowledgeBaseParams{ctx, original, newSystemUID, externalService}
	mmCreateStagingKnowledgeBase.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateStagingKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmCreateStagingKnowledgeBase.defaultExpectation.params) {
			mmCreateStagingKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateStagingKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmCreateStagingKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateStagingKnowledgeBase
func (mmCreateStagingKnowledgeBase *mRepositoryMockCreateStagingKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateStagingKnowledgeBase {
	if mmCreateStagingKnowledgeBase.mock.funcCreateStagingKnowledgeBase != nil {
		mmCreateStagingKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateStagingKnowledgeBase mock is already set by Set")
	}

	if mmCreateStagingKnowledgeBase.defaultExpectation == nil {
		mmCreateStagingKnowledgeBase.defaultExpectation = &RepositoryMockCreateStagingKnowledgeBaseExpectation{}
	}

	if mmCreateStagingKnowledgeBase.defaultExpectation.params != nil {
		mmCreateStagingKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateStagingKnowledgeBase mock is already set by Expect")
	}

	if mmCreateStagingKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCreateStagingKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockCreateStagingKnowledgeBaseParamPtrs{}
	}
	mmCreateStagingKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateStagingKnowledgeBase.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateStagingKnowledgeBase
}

// ExpectOriginalParam2 sets up expected param original for Repository.CreateStagingKnowledgeBase
func (mmCreateStagingKnowledgeBase *mRepositoryMockCreateStagingKnowledgeBase) ExpectOriginalParam2(original *mm_repository.KnowledgeBaseModel) *mRepositoryMockCreateStagingKnowledgeBase {
	if mmCreateStagingKnowledgeBase.mock.funcCreateStagingKnowledgeBase != nil {
		mmCreateStagingKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateStagingKnowledgeBase mock is already set by Set")
	}

	if mmCreateStagingKnowledgeBase.defaultExpectation == nil {
		mmCreateStagingKnowledgeBase.defaultExpectation = &RepositoryMockCreateStagingKnowledgeBaseExpectation{}
	}

	if mmCreateStagingKnowledgeBase.defaultExpectation.params != nil {
		mmCreateStagingKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateStagingKnowledgeBase mock is already set by Expect")
	}

	if mmCreateStagingKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCreateStagingKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockCreateStagingKnowledgeBaseParamPtrs{}
	}
	mmCreateStagingKnowledgeBase.defaultExpectation.paramPtrs.original = &original
	mmCreateStagingKnowledgeBase.defaultExpectation.expectationOrigins.originOriginal = minimock.CallerInfo(1)

	return mmCreateStagingKnowledgeBase
}

// ExpectNewSystemUIDParam3 sets up expected param newSystemUID for Repository.CreateStagingKnowledgeBase
func (mmCreateStagingKnowledgeBase *mRepositoryMockCreateStagingKnowledgeBase) ExpectNewSystemUIDParam3(newSystemUID *types.SystemUIDType) *mRepositoryMockCreateStagingKnowledgeBase {
	if mmCreateStagingKnowledgeBase.mock.funcCreateStagingKnowledgeBase != nil {
		mmCreateStagingKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateStagingKnowledgeBase mock is already set by Set")
	}

	if mmCreateStagingKnowledgeBase.defaultExpectation == nil {
		mmCreateStagingKnowledgeBase.defaultExpectation = &RepositoryMockCreateStagingKnowledgeBaseExpectation{}
	}

	if mmCreateStagingKnowledgeBase.defaultExpectation.params != nil {
		mmCreateStagingKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateStagingKnowledgeBase mock is already set by Expect")
	}

	if mmCreateStagingKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCreateStagingKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockCreateStagingKnowledgeBaseParamPtrs{}
	}
	mmCreateStagingKnowledgeBase.defaultExpectation.paramPtrs.newSystemUID = &newSystemUID
	mmCreateStagingKnowledgeBase.defaultExpectation.expectationOrigins.originNewSystemUID = minimock.CallerInfo(1)

	return mmCreateStagingKnowledgeBase
}

// ExpectExternalServiceParam4 sets up expected param externalService for Repository.CreateStagingKnowledgeBase
func (mmCreateStagingKnowledgeBase *mRepositoryMockCreateStagingKnowledgeBase) ExpectExternalServiceParam4(externalService func(kbUID types.KBUIDType, collectionUID types.KBUIDType) error) *mRepositoryMockCreateStagingKnowledgeBase {
	if mmCreateStagingKnowledgeBase.mock.funcCreateStagingKnowledgeBase != nil {
		mmCreateStagingKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateStagingKnowledgeBase mock is already set by Set")
	}

	if mmCreateStagingKnowledgeBase.defaultExpectation == nil {
		mmCreateStagingKnowledgeBase.defaultExpectation = &RepositoryMockCreateStagingKnowledgeBaseExpectation{}
	}

	if mmCreateStagingKnowledgeBase.defaultExpectation.params != nil {
		mmCreateStagingKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateStagingKnowledgeBase mock is already set by Expect")
	}

	if mmCreateStagingKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCreateStagingKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockCreateStagingKnowledgeBaseParamPtrs{}
	}
	mmCreateStagingKnowledgeBase.defaultExpectation.paramPtrs.externalService = &externalService
	mmCreateStagingKnowledgeBase.defaultExpectation.expectationOrigins.originExternalService = minimock.CallerInfo(1)

	return mmCreateStagingKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateStagingKnowledgeBase
func (mmCreateStagingKnowledgeBase *mRepositoryMockCreateStagingKnowledgeBase) Inspect(f func(ctx context.Context, original *mm_repository.KnowledgeBaseModel, newSystemUID *types.SystemUIDType, externalService func(kbUID types.KBUIDType, collectionUID types.KBUIDType) error)) *mRepositoryMockCreateStagingKnowledgeBase {
	if mmCreateStagingKnowledgeBase.mock.inspectFuncCreateStagingKnowledgeBase != nil {
		mmCreateStagingKnowledgeBase.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateStagingKnowledgeBase")
	}

	mmCreateStagingKnowledgeBase.mock.inspectFuncCreateStagingKnowledgeBase = f

	return mmCreateStagingKnowledgeBase
}

// Return sets up results that will be returned by Repository.CreateStagingKnowledgeBase
func (mmCreateStagingKnowledgeBase *mRepositoryMockCreateStagingKnowledgeBase) Return(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	if mmCreateStagingKnowledgeBase.mock.funcCreateStagingKnowledgeBase != nil {
		mmCreateStagingKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateStagingKnowledgeBase mock is already set by Set")
	}

	if mmCreateStagingKnowledgeBase.defaultExpectation == nil {
		mmCreateStagingKnowledgeBase.defaultExpectation = &RepositoryMockCreateStagingKnowledgeBaseExpectation{mock: mmCreateStagingKnowledgeBase.mock}
	}
	mmCreateStagingKnowledgeBase.defaultExpectation.results = &RepositoryMockCreateStagingKnowledgeBaseResults{kp1, err}
	mmCreateStagingKnowledgeBase.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateStagingKnowledgeBase.mock
}

// Set uses given function f to mock the Repository.CreateStagingKnowledgeBase method
func (mmCreateStagingKnowledgeBase *mRepositoryMockCreateStagingKnowledgeBase) Set(f func(ctx context.Context, original *mm_repository.KnowledgeBaseModel, newSystemUID *types.SystemUIDType, externalService func(kbUID types.KBUIDType, collectionUID types.KBUIDType) error) (kp1 *mm_repository.KnowledgeBaseModel, err error)) *RepositoryMock {
	if mmCreateStagingKnowledgeBase.defaultExpectation != nil {
		mmCreateStagingKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the Repository.CreateStagingKnowledgeBase method")
	}

	if len(mmCreateStagingKnowledgeBase.expectations) > 0 {
		mmCreateStagingKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the Repository.CreateStagingKnowledgeBase method")
	}

	mmCreateStagingKnowledgeBase.mock.funcCreateStagingKnowledgeBase = f
	mmCreateStagingKnowledgeBase.mock.funcCreateStagingKnowledgeBaseOrigin = minimock.CallerInfo(1)
	return mmCreateStagingKnowledgeBase.mock
}

// When sets expectation for the Repository.CreateStagingKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmCreateStagingKnowledgeBase *mRepositoryMockCreateStagingKnowledgeBase) When(ctx context.Context, original *mm_repository.KnowledgeBaseModel, newSystemUID *types.SystemUIDType, externalService func(kbUID types.KBUIDType, collectionUID types.KBUIDType) error) *RepositoryMockCreateStagingKnowledgeBaseExpectation {
	if mmCreateStagingKnowledgeBase.mock.funcCreateStagingKnowledgeBase != nil {
		mmCreateStagingKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateStagingKnowledgeBase mock is already set by Set")
	}

	expectation := &RepositoryMockCreateStagingKnowledgeBaseExpectation{
		mock:               mmCreateStagingKnowledgeBase.mock,
		params:             &RepositoryMockCreateStagingKnowledgeBaseParams{ctx, original, newSystemUID, externalService},
		expectationOrigins: RepositoryMockCreateStagingKnowledgeBaseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateStagingKnowledgeBase.expectations = append(mmCreateStagingKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateStagingKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateStagingKnowledgeBaseExpectation) Then(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateStagingKnowledgeBaseResults{kp1, err}
	return e.mock
}

// Times sets number of times Repository.CreateStagingKnowledgeBase should be invoked
func (mmCreateStagingKnowledgeBase *mRepositoryMockCreateStagingKnowledgeBase) Times(n uint64) *mRepositoryMockCreateStagingKnowledgeBase {
	if n == 0 {
		mmCreateStagingKnowledgeBase.mock.t.Fatalf("Times of RepositoryMock.CreateStagingKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateStagingKnowledgeBase.expectedInvocations, n)
	mmCreateStagingKnowledgeBase.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateStagingKnowledgeBase
}

func (mmCreateStagingKnowledgeBase *mRepositoryMockCreateStagingKnowledgeBase) invocationsDone() bool {
	if len(mmCreateStagingKnowledgeBase.expectations) == 0 && mmCreateStagingKnowledgeBase.defaultExpectation == nil && mmCreateStagingKnowledgeBase.mock.funcCreateStagingKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateStagingKnowledgeBase.mock.afterCreateStagingKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateStagingKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateStagingKnowledgeBase implements mm_repository.Repository
func (mmCreateStagingKnowledgeBase *RepositoryMock) CreateStagingKnowledgeBase(ctx context.Context, original *mm_repository.KnowledgeBaseModel, newSystemUID *types.SystemUIDType, externalService func(kbUID types.KBUIDType, collectionUID types.KBUIDType) error) (kp1 *mm_repository.KnowledgeBaseModel, err error) {
	mm_atomic.AddUint64(&mmCreateStagingKnowledgeBase.beforeCreateStagingKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateStagingKnowledgeBase.afterCreateStagingKnowledgeBaseCounter, 1)

	mmCreateStagingKnowledgeBase.t.Helper()

	if mmCreateStagingKnowledgeBase.inspectFuncCreateStagingKnowledgeBase != nil {
		mmCreateStagingKnowledgeBase.inspectFuncCreateStagingKnowledgeBase(ctx, original, newSystemUID, externalService)
	}

	mm_params := RepositoryMockCreateStagingKnowledgeBaseParams{ctx, original, newSystemUID, externalService}

	// Record call args
	mmCreateStagingKnowledgeBase.CreateStagingKnowledgeBaseMock.mutex.Lock()
	mmCreateStagingKnowledgeBase.CreateStagingKnowledgeBaseMock.callArgs = append(mmCreateStagingKnowledgeBase.CreateStagingKnowledgeBaseMock.callArgs, &mm_params)
	mmCreateStagingKnowledgeBase.CreateStagingKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmCreateStagingKnowledgeBase.CreateStagingKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmCreateStagingKnowledgeBase.CreateStagingKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateStagingKnowledgeBase.CreateStagingKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateStagingKnowledgeBase.CreateStagingKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmCreateStagingKnowledgeBase.CreateStagingKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateStagingKnowledgeBaseParams{ctx, original, newSystemUID, externalService}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateStagingKnowledgeBase.t.Errorf("RepositoryMock.CreateStagingKnowledgeBase got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateStagingKnowledgeBase.CreateStagingKnowledgeBaseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.original != nil && !minimock.Equal(*mm_want_ptrs.original, mm_got.original) {
				mmCreateStagingKnowledgeBase.t.Errorf("RepositoryMock.CreateStagingKnowledgeBase got unexpected parameter original, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateStagingKnowledgeBase.CreateStagingKnowledgeBaseMock.defaultExpectation.expectationOrigins.originOriginal, *mm_want_ptrs.original, mm_got.original, minimock.Diff(*mm_want_ptrs.original, mm_got.original))
			}

			if mm_want_ptrs.newSystemUID != nil && !minimock.Equal(*mm_want_ptrs.newSystemUID, mm_got.newSystemUID) {
				mmCreateStagingKnowledgeBase.t.Errorf("RepositoryMock.CreateStagingKnowledgeBase got unexpected parameter newSystemUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateStagingKnowledgeBase.CreateStagingKnowledgeBaseMock.defaultExpectation.expectationOrigins.originNewSystemUID, *mm_want_ptrs.newSystemUID, mm_got.newSystemUID, minimock.Diff(*mm_want_ptrs.newSystemUID, mm_got.newSystemUID))
			}

			if mm_want_ptrs.externalService != nil && !minimock.Equal(*mm_want_ptrs.externalService, mm_got.externalService) {
				mmCreateStagingKnowledgeBase.t.Errorf("RepositoryMock.CreateStagingKnowledgeBase got unexpected parameter externalService, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateStagingKnowledgeBase.CreateStagingKnowledgeBaseMock.defaultExpectation.expectationOrigins.originExternalService, *mm_want_ptrs.externalService, mm_got.externalService, minimock.Diff(*mm_want_ptrs.externalService, mm_got.externalService))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateStagingKnowledgeBase.t.Errorf("RepositoryMock.CreateStagingKnowledgeBase got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateStagingKnowledgeBase.CreateStagingKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateStagingKnowledgeBase.CreateStagingKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateStagingKnowledgeBase.t.Fatal("No results are set for the RepositoryMock.CreateStagingKnowledgeBase")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmCreateStagingKnowledgeBase.funcCreateStagingKnowledgeBase != nil {
		return mmCreateStagingKnowledgeBase.funcCreateStagingKnowledgeBase(ctx, original, newSystemUID, externalService)
	}
	mmCreateStagingKnowledgeBase.t.Fatalf("Unexpected call to RepositoryMock.CreateStagingKnowledgeBase. %v %v %v %v", ctx, original, newSystemUID, externalService)
	return
}

// CreateStagingKnowledgeBaseAfterCounter returns a count of finished RepositoryMock.CreateStagingKnowledgeBase invocations
func (mmCreateStagingKnowledgeBase *RepositoryMock) CreateStagingKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateStagingKnowledgeBase.afterCreateStagingKnowledgeBaseCounter)
}

// CreateStagingKnowledgeBaseBeforeCounter returns a count of RepositoryMock.CreateStagingKnowledgeBase invocations
func (mmCreateStagingKnowledgeBase *RepositoryMock) CreateStagingKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateStagingKnowledgeBase.beforeCreateStagingKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateStagingKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateStagingKnowledgeBase *mRepositoryMockCreateStagingKnowledgeBase) Calls() []*RepositoryMockCreateStagingKnowledgeBaseParams {
	mmCreateStagingKnowledgeBase.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateStagingKnowledgeBaseParams, len(mmCreateStagingKnowledgeBase.callArgs))
	copy(argCopy, mmCreateStagingKnowledgeBase.callArgs)

	mmCreateStagingKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockCreateStagingKnowledgeBaseDone returns true if the count of the CreateStagingKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateStagingKnowledgeBaseDone() bool {
	if m.CreateStagingKnowledgeBaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateStagingKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateStagingKnowledgeBaseMock.invocationsDone()
}

// MinimockCreateStagingKnowledgeBaseInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateStagingKnowledgeBaseInspect() {
	for _, e := range m.CreateStagingKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateStagingKnowledgeBase at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateStagingKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterCreateStagingKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateStagingKnowledgeBaseMock.defaultExpectation != nil && afterCreateStagingKnowledgeBaseCounter < 1 {
		if m.CreateStagingKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateStagingKnowledgeBase at\n%s", m.CreateStagingKnowledgeBaseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateStagingKnowledgeBase at\n%s with params: %#v", m.CreateStagingKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *m.CreateStagingKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateStagingKnowledgeBase != nil && afterCreateStagingKnowledgeBaseCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateStagingKnowledgeBase at\n%s", m.funcCreateStagingKnowledgeBaseOrigin)
	}

	if !m.CreateStagingKnowledgeBaseMock.invocationsDone() && afterCreateStagingKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateStagingKnowledgeBase at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateStagingKnowledgeBaseMock.expectedInvocations), m.CreateStagingKnowledgeBaseMock.expectedInvocationsOrigin, afterCreateStagingKnowledgeBaseCounter)
	}
}

type mRepositoryMockCreateSystem struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateSystemExpectation
	expectations       []*RepositoryMockCreateSystemExpectation

	callArgs []*RepositoryMockCreateSystemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateSystemExpectation specifies expectation struct of the Repository.CreateSystem
type RepositoryMockCreateSystemExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateSystemParams
	paramPtrs          *RepositoryMockCreateSystemParamPtrs
	expectationOrigins RepositoryMockCreateSystemExpectationOrigins
	results            *RepositoryMockCreateSystemResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateSystemParams contains parameters of the Repository.CreateSystem
type RepositoryMockCreateSystemParams struct {
	ctx         context.Context
	id          string
	config      map[string]any
	description string
}

// RepositoryMockCreateSystemParamPtrs contains pointers to parameters of the Repository.CreateSystem
type RepositoryMockCreateSystemParamPtrs struct {
	ctx         *context.Context
	id          *string
	config      *map[string]any
	description *string
}

// RepositoryMockCreateSystemResults contains results of the Repository.CreateSystem
type RepositoryMockCreateSystemResults struct {
	err error
}

// RepositoryMockCreateSystemOrigins contains origins of expectations of the Repository.CreateSystem
type RepositoryMockCreateSystemExpectationOrigins struct {
	origin            string
	originCtx         string
	originId          string
	originConfig      string
	originDescription string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateSystem *mRepositoryMockCreateSystem) Optional() *mRepositoryMockCreateSystem {
	mmCreateSystem.optional = true
	return mmCreateSystem
}

// Expect sets up expected params for Repository.CreateSystem
func (mmCreateSystem *mRepositoryMockCreateSystem) Expect(ctx context.Context, id string, config map[string]any, description string) *mRepositoryMockCreateSystem {
	if mmCreateSystem.mock.funcCreateSystem != nil {
		mmCreateSystem.mock.t.Fatalf("RepositoryMock.CreateSystem mock is already set by Set")
	}

	if mmCreateSystem.defaultExpectation == nil {
		mmCreateSystem.defaultExpectation = &RepositoryMockCreateSystemExpectation{}
	}

	if mmCreateSystem.defaultExpectation.paramPtrs != nil {
		mmCreateSystem.mock.t.Fatalf("RepositoryMock.CreateSystem mock is already set by ExpectParams functions")
	}

	mmCreateSystem.defaultExpectation.params = &RepositoryMockCreateSystemParams{ctx, id, config, description}
	mmCreateSystem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateSystem.expectations {
		if minimock.Equal(e.params, mmCreateSystem.defaultExpectation.params) {
			mmCreateSystem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateSystem.defaultExpectation.params)
		}
	}

	return mmCreateSystem
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateSystem
func (mmCreateSystem *mRepositoryMockCreateSystem) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateSystem {
	if mmCreateSystem.mock.funcCreateSystem != nil {
		mmCreateSystem.mock.t.Fatalf("RepositoryMock.CreateSystem mock is already set by Set")
	}

	if mmCreateSystem.defaultExpectation == nil {
		mmCreateSystem.defaultExpectation = &RepositoryMockCreateSystemExpectation{}
	}

	if mmCreateSystem.defaultExpectation.params != nil {
		mmCreateSystem.mock.t.Fatalf("RepositoryMock.CreateSystem mock is already set by Expect")
	}

	if mmCreateSystem.defaultExpectation.paramPtrs == nil {
		mmCreateSystem.defaultExpectation.paramPtrs = &RepositoryMockCreateSystemParamPtrs{}
	}
	mmCreateSystem.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateSystem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateSystem
}

// ExpectIdParam2 sets up expected param id for Repository.CreateSystem
func (mmCreateSystem *mRepositoryMockCreateSystem) ExpectIdParam2(id string) *mRepositoryMockCreateSystem {
	if mmCreateSystem.mock.funcCreateSystem != nil {
		mmCreateSystem.mock.t.Fatalf("RepositoryMock.CreateSystem mock is already set by Set")
	}

	if mmCreateSystem.defaultExpectation == nil {
		mmCreateSystem.defaultExpectation = &RepositoryMockCreateSystemExpectation{}
	}

	if mmCreateSystem.defaultExpectation.params != nil {
		mmCreateSystem.mock.t.Fatalf("RepositoryMock.CreateSystem mock is already set by Expect")
	}

	if mmCreateSystem.defaultExpectation.paramPtrs == nil {
		mmCreateSystem.defaultExpectation.paramPtrs = &RepositoryMockCreateSystemParamPtrs{}
	}
	mmCreateSystem.defaultExpectation.paramPtrs.id = &id
	mmCreateSystem.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmCreateSystem
}

// ExpectConfigParam3 sets up expected param config for Repository.CreateSystem
func (mmCreateSystem *mRepositoryMockCreateSystem) ExpectConfigParam3(config map[string]any) *mRepositoryMockCreateSystem {
	if mmCreateSystem.mock.funcCreateSystem != nil {
		mmCreateSystem.mock.t.Fatalf("RepositoryMock.CreateSystem mock is already set by Set")
	}

	if mmCreateSystem.defaultExpectation == nil {
		mmCreateSystem.defaultExpectation = &RepositoryMockCreateSystemExpectation{}
	}

	if mmCreateSystem.defaultExpectation.params != nil {
		mmCreateSystem.mock.t.Fatalf("RepositoryMock.CreateSystem mock is already set by Expect")
	}

	if mmCreateSystem.defaultExpectation.paramPtrs == nil {
		mmCreateSystem.defaultExpectation.paramPtrs = &RepositoryMockCreateSystemParamPtrs{}
	}
	mmCreateSystem.defaultExpectation.paramPtrs.config = &config
	mmCreateSystem.defaultExpectation.expectationOrigins.originConfig = minimock.CallerInfo(1)

	return mmCreateSystem
}

// ExpectDescriptionParam4 sets up expected param description for Repository.CreateSystem
func (mmCreateSystem *mRepositoryMockCreateSystem) ExpectDescriptionParam4(description string) *mRepositoryMockCreateSystem {
	if mmCreateSystem.mock.funcCreateSystem != nil {
		mmCreateSystem.mock.t.Fatalf("RepositoryMock.CreateSystem mock is already set by Set")
	}

	if mmCreateSystem.defaultExpectation == nil {
		mmCreateSystem.defaultExpectation = &RepositoryMockCreateSystemExpectation{}
	}

	if mmCreateSystem.defaultExpectation.params != nil {
		mmCreateSystem.mock.t.Fatalf("RepositoryMock.CreateSystem mock is already set by Expect")
	}

	if mmCreateSystem.defaultExpectation.paramPtrs == nil {
		mmCreateSystem.defaultExpectation.paramPtrs = &RepositoryMockCreateSystemParamPtrs{}
	}
	mmCreateSystem.defaultExpectation.paramPtrs.description = &description
	mmCreateSystem.defaultExpectation.expectationOrigins.originDescription = minimock.CallerInfo(1)

	return mmCreateSystem
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateSystem
func (mmCreateSystem *mRepositoryMockCreateSystem) Inspect(f func(ctx context.Context, id string, config map[string]any, description string)) *mRepositoryMockCreateSystem {
	if mmCreateSystem.mock.inspectFuncCreateSystem != nil {
		mmCreateSystem.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateSystem")
	}

	mmCreateSystem.mock.inspectFuncCreateSystem = f

	return mmCreateSystem
}

// Return sets up results that will be returned by Repository.CreateSystem
func (mmCreateSystem *mRepositoryMockCreateSystem) Return(err error) *RepositoryMock {
	if mmCreateSystem.mock.funcCreateSystem != nil {
		mmCreateSystem.mock.t.Fatalf("RepositoryMock.CreateSystem mock is already set by Set")
	}

	if mmCreateSystem.defaultExpectation == nil {
		mmCreateSystem.defaultExpectation = &RepositoryMockCreateSystemExpectation{mock: mmCreateSystem.mock}
	}
	mmCreateSystem.defaultExpectation.results = &RepositoryMockCreateSystemResults{err}
	mmCreateSystem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateSystem.mock
}

// Set uses given function f to mock the Repository.CreateSystem method
func (mmCreateSystem *mRepositoryMockCreateSystem) Set(f func(ctx context.Context, id string, config map[string]any, description string) (err error)) *RepositoryMock {
	if mmCreateSystem.defaultExpectation != nil {
		mmCreateSystem.mock.t.Fatalf("Default expectation is already set for the Repository.CreateSystem method")
	}

	if len(mmCreateSystem.expectations) > 0 {
		mmCreateSystem.mock.t.Fatalf("Some expectations are already set for the Repository.CreateSystem method")
	}

	mmCreateSystem.mock.funcCreateSystem = f
	mmCreateSystem.mock.funcCreateSystemOrigin = minimock.CallerInfo(1)
	return mmCreateSystem.mock
}

// When sets expectation for the Repository.CreateSystem which will trigger the result defined by the following
// Then helper
func (mmCreateSystem *mRepositoryMockCreateSystem) When(ctx context.Context, id string, config map[string]any, description string) *RepositoryMockCreateSystemExpectation {
	if mmCreateSystem.mock.funcCreateSystem != nil {
		mmCreateSystem.mock.t.Fatalf("RepositoryMock.CreateSystem mock is already set by Set")
	}

	expectation := &RepositoryMockCreateSystemExpectation{
		mock:               mmCreateSystem.mock,
		params:             &RepositoryMockCreateSystemParams{ctx, id, config, description},
		expectationOrigins: RepositoryMockCreateSystemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateSystem.expectations = append(mmCreateSystem.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateSystem return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateSystemExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreateSystemResults{err}
	return e.mock
}

// Times sets number of times Repository.CreateSystem should be invoked
func (mmCreateSystem *mRepositoryMockCreateSystem) Times(n uint64) *mRepositoryMockCreateSystem {
	if n == 0 {
		mmCreateSystem.mock.t.Fatalf("Times of RepositoryMock.CreateSystem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateSystem.expectedInvocations, n)
	mmCreateSystem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateSystem
}

func (mmCreateSystem *mRepositoryMockCreateSystem) invocationsDone() bool {
	if len(mmCreateSystem.expectations) == 0 && mmCreateSystem.defaultExpectation == nil && mmCreateSystem.mock.funcCreateSystem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateSystem.mock.afterCreateSystemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateSystem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateSystem implements mm_repository.Repository
func (mmCreateSystem *RepositoryMock) CreateSystem(ctx context.Context, id string, config map[string]any, description string) (err error) {
	mm_atomic.AddUint64(&mmCreateSystem.beforeCreateSystemCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateSystem.afterCreateSystemCounter, 1)

	mmCreateSystem.t.Helper()

	if mmCreateSystem.inspectFuncCreateSystem != nil {
		mmCreateSystem.inspectFuncCreateSystem(ctx, id, config, description)
	}

	mm_params := RepositoryMockCreateSystemParams{ctx, id, config, description}

	// Record call args
	mmCreateSystem.CreateSystemMock.mutex.Lock()
	mmCreateSystem.CreateSystemMock.callArgs = append(mmCreateSystem.CreateSystemMock.callArgs, &mm_params)
	mmCreateSystem.CreateSystemMock.mutex.Unlock()

	for _, e := range mmCreateSystem.CreateSystemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateSystem.CreateSystemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateSystem.CreateSystemMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateSystem.CreateSystemMock.defaultExpectation.params
		mm_want_ptrs := mmCreateSystem.CreateSystemMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateSystemParams{ctx, id, config, description}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateSystem.t.Errorf("RepositoryMock.CreateSystem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateSystem.CreateSystemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmCreateSystem.t.Errorf("RepositoryMock.CreateSystem got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateSystem.CreateSystemMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.config != nil && !minimock.Equal(*mm_want_ptrs.config, mm_got.config) {
				mmCreateSystem.t.Errorf("RepositoryMock.CreateSystem got unexpected parameter config, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateSystem.CreateSystemMock.defaultExpectation.expectationOrigins.originConfig, *mm_want_ptrs.config, mm_got.config, minimock.Diff(*mm_want_ptrs.config, mm_got.config))
			}

			if mm_want_ptrs.description != nil && !minimock.Equal(*mm_want_ptrs.description, mm_got.description) {
				mmCreateSystem.t.Errorf("RepositoryMock.CreateSystem got unexpected parameter description, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateSystem.CreateSystemMock.defaultExpectation.expectationOrigins.originDescription, *mm_want_ptrs.description, mm_got.description, minimock.Diff(*mm_want_ptrs.description, mm_got.description))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateSystem.t.Errorf("RepositoryMock.CreateSystem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateSystem.CreateSystemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateSystem.CreateSystemMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateSystem.t.Fatal("No results are set for the RepositoryMock.CreateSystem")
		}
		return (*mm_results).err
	}
	if mmCreateSystem.funcCreateSystem != nil {
		return mmCreateSystem.funcCreateSystem(ctx, id, config, description)
	}
	mmCreateSystem.t.Fatalf("Unexpected call to RepositoryMock.CreateSystem. %v %v %v %v", ctx, id, config, description)
	return
}

// CreateSystemAfterCounter returns a count of finished RepositoryMock.CreateSystem invocations
func (mmCreateSystem *RepositoryMock) CreateSystemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateSystem.afterCreateSystemCounter)
}

// CreateSystemBeforeCounter returns a count of RepositoryMock.CreateSystem invocations
func (mmCreateSystem *RepositoryMock) CreateSystemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateSystem.beforeCreateSystemCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateSystem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateSystem *mRepositoryMockCreateSystem) Calls() []*RepositoryMockCreateSystemParams {
	mmCreateSystem.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateSystemParams, len(mmCreateSystem.callArgs))
	copy(argCopy, mmCreateSystem.callArgs)

	mmCreateSystem.mutex.RUnlock()

	return argCopy
}

// MinimockCreateSystemDone returns true if the count of the CreateSystem invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateSystemDone() bool {
	if m.CreateSystemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateSystemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateSystemMock.invocationsDone()
}

// MinimockCreateSystemInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateSystemInspect() {
	for _, e := range m.CreateSystemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateSystem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateSystemCounter := mm_atomic.LoadUint64(&m.afterCreateSystemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateSystemMock.defaultExpectation != nil && afterCreateSystemCounter < 1 {
		if m.CreateSystemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateSystem at\n%s", m.CreateSystemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateSystem at\n%s with params: %#v", m.CreateSystemMock.defaultExpectation.expectationOrigins.origin, *m.CreateSystemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateSystem != nil && afterCreateSystemCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateSystem at\n%s", m.funcCreateSystemOrigin)
	}

	if !m.CreateSystemMock.invocationsDone() && afterCreateSystemCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateSystem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateSystemMock.expectedInvocations), m.CreateSystemMock.expectedInvocationsOrigin, afterCreateSystemCounter)
	}
}

type mRepositoryMockCreateTextChunks struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateTextChunksExpectation
	expectations       []*RepositoryMockCreateTextChunksExpectation

	callArgs []*RepositoryMockCreateTextChunksParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateTextChunksExpectation specifies expectation struct of the Repository.CreateTextChunks
type RepositoryMockCreateTextChunksExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateTextChunksParams
	paramPtrs          *RepositoryMockCreateTextChunksParamPtrs
	expectationOrigins RepositoryMockCreateTextChunksExpectationOrigins
	results            *RepositoryMockCreateTextChunksResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateTextChunksParams contains parameters of the Repository.CreateTextChunks
type RepositoryMockCreateTextChunksParams struct {
	ctx        context.Context
	textChunks []*mm_repository.TextChunkModel
}

// RepositoryMockCreateTextChunksParamPtrs contains pointers to parameters of the Repository.CreateTextChunks
type RepositoryMockCreateTextChunksParamPtrs struct {
	ctx        *context.Context
	textChunks *[]*mm_repository.TextChunkModel
}

// RepositoryMockCreateTextChunksResults contains results of the Repository.CreateTextChunks
type RepositoryMockCreateTextChunksResults struct {
	err error
}

// RepositoryMockCreateTextChunksOrigins contains origins of expectations of the Repository.CreateTextChunks
type RepositoryMockCreateTextChunksExpectationOrigins struct {
	origin           string
	originCtx        string
	originTextChunks string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateTextChunks *mRepositoryMockCreateTextChunks) Optional() *mRepositoryMockCreateTextChunks {
	mmCreateTextChunks.optional = true
	return mmCreateTextChunks
}

// Expect sets up expected params for Repository.CreateTextChunks
func (mmCreateTextChunks *mRepositoryMockCreateTextChunks) Expect(ctx context.Context, textChunks []*mm_repository.TextChunkModel) *mRepositoryMockCreateTextChunks {
	if mmCreateTextChunks.mock.funcCreateTextChunks != nil {
		mmCreateTextChunks.mock.t.Fatalf("RepositoryMock.CreateTextChunks mock is already set by Set")
	}

	if mmCreateTextChunks.defaultExpectation == nil {
		mmCreateTextChunks.defaultExpectation = &RepositoryMockCreateTextChunksExpectation{}
	}

	if mmCreateTextChunks.defaultExpectation.paramPtrs != nil {
		mmCreateTextChunks.mock.t.Fatalf("RepositoryMock.CreateTextChunks mock is already set by ExpectParams functions")
	}

	mmCreateTextChunks.defaultExpectation.params = &RepositoryMockCreateTextChunksParams{ctx, textChunks}
	mmCreateTextChunks.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateTextChunks.expectations {
		if minimock.Equal(e.params, mmCreateTextChunks.defaultExpectation.params) {
			mmCreateTextChunks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateTextChunks.defaultExpectation.params)
		}
	}

	return mmCreateTextChunks
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateTextChunks
func (mmCreateTextChunks *mRepositoryMockCreateTextChunks) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateTextChunks {
	if mmCreateTextChunks.mock.funcCreateTextChunks != nil {
		mmCreateTextChunks.mock.t.Fatalf("RepositoryMock.CreateTextChunks mock is already set by Set")
	}

	if mmCreateTextChunks.defaultExpectation == nil {
		mmCreateTextChunks.defaultExpectation = &RepositoryMockCreateTextChunksExpectation{}
	}

	if mmCreateTextChunks.defaultExpectation.params != nil {
		mmCreateTextChunks.mock.t.Fatalf("RepositoryMock.CreateTextChunks mock is already set by Expect")
	}

	if mmCreateTextChunks.defaultExpectation.paramPtrs == nil {
		mmCreateTextChunks.defaultExpectation.paramPtrs = &RepositoryMockCreateTextChunksParamPtrs{}
	}
	mmCreateTextChunks.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateTextChunks.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateTextChunks
}

// ExpectTextChunksParam2 sets up expected param textChunks for Repository.CreateTextChunks
func (mmCreateTextChunks *mRepositoryMockCreateTextChunks) ExpectTextChunksParam2(textChunks []*mm_repository.TextChunkModel) *mRepositoryMockCreateTextChunks {
	if mmCreateTextChunks.mock.funcCreateTextChunks != nil {
		mmCreateTextChunks.mock.t.Fatalf("RepositoryMock.CreateTextChunks mock is already set by Set")
	}

	if mmCreateTextChunks.defaultExpectation == nil {
		mmCreateTextChunks.defaultExpectation = &RepositoryMockCreateTextChunksExpectation{}
	}

	if mmCreateTextChunks.defaultExpectation.params != nil {
		mmCreateTextChunks.mock.t.Fatalf("RepositoryMock.CreateTextChunks mock is already set by Expect")
	}

	if mmCreateTextChunks.defaultExpectation.paramPtrs == nil {
		mmCreateTextChunks.defaultExpectation.paramPtrs = &RepositoryMockCreateTextChunksParamPtrs{}
	}
	mmCreateTextChunks.defaultExpectation.paramPtrs.textChunks = &textChunks
	mmCreateTextChunks.defaultExpectation.expectationOrigins.originTextChunks = minimock.CallerInfo(1)

	return mmCreateTextChunks
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateTextChunks
func (mmCreateTextChunks *mRepositoryMockCreateTextChunks) Inspect(f func(ctx context.Context, textChunks []*mm_repository.TextChunkModel)) *mRepositoryMockCreateTextChunks {
	if mmCreateTextChunks.mock.inspectFuncCreateTextChunks != nil {
		mmCreateTextChunks.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateTextChunks")
	}

	mmCreateTextChunks.mock.inspectFuncCreateTextChunks = f

	return mmCreateTextChunks
}

// Return sets up results that will be returned by Repository.CreateTextChunks
func (mmCreateTextChunks *mRepositoryMockCreateTextChunks) Return(err error) *RepositoryMock {
	if mmCreateTextChunks.mock.funcCreateTextChunks != nil {
		mmCreateTextChunks.mock.t.Fatalf("RepositoryMock.CreateTextChunks mock is already set by Set")
	}

	if mmCreateTextChunks.defaultExpectation == nil {
		mmCreateTextChunks.defaultExpectation = &RepositoryMockCreateTextChunksExpectation{mock: mmCreateTextChunks.mock}
	}
	mmCreateTextChunks.defaultExpectation.results = &RepositoryMockCreateTextChunksResults{err}
	mmCreateTextChunks.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateTextChunks.mock
}

// Set uses given function f to mock the Repository.CreateTextChunks method
func (mmCreateTextChunks *mRepositoryMockCreateTextChunks) Set(f func(ctx context.Context, textChunks []*mm_repository.TextChunkModel) (err error)) *RepositoryMock {
	if mmCreateTextChunks.defaultExpectation != nil {
		mmCreateTextChunks.mock.t.Fatalf("Default expectation is already set for the Repository.CreateTextChunks method")
	}

	if len(mmCreateTextChunks.expectations) > 0 {
		mmCreateTextChunks.mock.t.Fatalf("Some expectations are already set for the Repository.CreateTextChunks method")
	}

	mmCreateTextChunks.mock.funcCreateTextChunks = f
	mmCreateTextChunks.mock.funcCreateTextChunksOrigin = minimock.CallerInfo(1)
	return mmCreateTextChunks.mock
}

// When sets expectation for the Repository.CreateTextChunks which will trigger the result defined by the following
// Then helper
func (mmCreateTextChunks *mRepositoryMockCreateTextChunks) When(ctx context.Context, textChunks []*mm_repository.TextChunkModel) *RepositoryMockCreateTextChunksExpectation {
	if mmCreateTextChunks.mock.funcCreateTextChunks != nil {
		mmCreateTextChunks.mock.t.Fatalf("RepositoryMock.CreateTextChunks mock is already set by Set")
	}

	expectation := &RepositoryMockCreateTextChunksExpectation{
		mock:               mmCreateTextChunks.mock,
		params:             &RepositoryMockCreateTextChunksParams{ctx, textChunks},
		expectationOrigins: RepositoryMockCreateTextChunksExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateTextChunks.expectations = append(mmCreateTextChunks.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateTextChunks return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateTextChunksExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreateTextChunksResults{err}
	return e.mock
}

// Times sets number of times Repository.CreateTextChunks should be invoked
func (mmCreateTextChunks *mRepositoryMockCreateTextChunks) Times(n uint64) *mRepositoryMockCreateTextChunks {
	if n == 0 {
		mmCreateTextChunks.mock.t.Fatalf("Times of RepositoryMock.CreateTextChunks mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateTextChunks.expectedInvocations, n)
	mmCreateTextChunks.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateTextChunks
}

func (mmCreateTextChunks *mRepositoryMockCreateTextChunks) invocationsDone() bool {
	if len(mmCreateTextChunks.expectations) == 0 && mmCreateTextChunks.defaultExpectation == nil && mmCreateTextChunks.mock.funcCreateTextChunks == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateTextChunks.mock.afterCreateTextChunksCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateTextChunks.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateTextChunks implements mm_repository.Repository
func (mmCreateTextChunks *RepositoryMock) CreateTextChunks(ctx context.Context, textChunks []*mm_repository.TextChunkModel) (err error) {
	mm_atomic.AddUint64(&mmCreateTextChunks.beforeCreateTextChunksCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateTextChunks.afterCreateTextChunksCounter, 1)

	mmCreateTextChunks.t.Helper()

	if mmCreateTextChunks.inspectFuncCreateTextChunks != nil {
		mmCreateTextChunks.inspectFuncCreateTextChunks(ctx, textChunks)
	}

	mm_params := RepositoryMockCreateTextChunksParams{ctx, textChunks}

	// Record call args
	mmCreateTextChunks.CreateTextChunksMock.mutex.Lock()
	mmCreateTextChunks.CreateTextChunksMock.callArgs = append(mmCreateTextChunks.CreateTextChunksMock.callArgs, &mm_params)
	mmCreateTextChunks.CreateTextChunksMock.mutex.Unlock()

	for _, e := range mmCreateTextChunks.CreateTextChunksMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateTextChunks.CreateTextChunksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateTextChunks.CreateTextChunksMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateTextChunks.CreateTextChunksMock.defaultExpectation.params
		mm_want_ptrs := mmCreateTextChunks.CreateTextChunksMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateTextChunksParams{ctx, textChunks}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateTextChunks.t.Errorf("RepositoryMock.CreateTextChunks got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateTextChunks.CreateTextChunksMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.textChunks != nil && !minimock.Equal(*mm_want_ptrs.textChunks, mm_got.textChunks) {
				mmCreateTextChunks.t.Errorf("RepositoryMock.CreateTextChunks got unexpected parameter textChunks, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateTextChunks.CreateTextChunksMock.defaultExpectation.expectationOrigins.originTextChunks, *mm_want_ptrs.textChunks, mm_got.textChunks, minimock.Diff(*mm_want_ptrs.textChunks, mm_got.textChunks))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateTextChunks.t.Errorf("RepositoryMock.CreateTextChunks got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateTextChunks.CreateTextChunksMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateTextChunks.CreateTextChunksMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateTextChunks.t.Fatal("No results are set for the RepositoryMock.CreateTextChunks")
		}
		return (*mm_results).err
	}
	if mmCreateTextChunks.funcCreateTextChunks != nil {
		return mmCreateTextChunks.funcCreateTextChunks(ctx, textChunks)
	}
	mmCreateTextChunks.t.Fatalf("Unexpected call to RepositoryMock.CreateTextChunks. %v %v", ctx, textChunks)
	return
}

// CreateTextChunksAfterCounter returns a count of finished RepositoryMock.CreateTextChunks invocations
func (mmCreateTextChunks *RepositoryMock) CreateTextChunksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTextChunks.afterCreateTextChunksCounter)
}

// CreateTextChunksBeforeCounter returns a count of RepositoryMock.CreateTextChunks invocations
func (mmCreateTextChunks *RepositoryMock) CreateTextChunksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTextChunks.beforeCreateTextChunksCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateTextChunks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateTextChunks *mRepositoryMockCreateTextChunks) Calls() []*RepositoryMockCreateTextChunksParams {
	mmCreateTextChunks.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateTextChunksParams, len(mmCreateTextChunks.callArgs))
	copy(argCopy, mmCreateTextChunks.callArgs)

	mmCreateTextChunks.mutex.RUnlock()

	return argCopy
}

// MinimockCreateTextChunksDone returns true if the count of the CreateTextChunks invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateTextChunksDone() bool {
	if m.CreateTextChunksMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateTextChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateTextChunksMock.invocationsDone()
}

// MinimockCreateTextChunksInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateTextChunksInspect() {
	for _, e := range m.CreateTextChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateTextChunks at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateTextChunksCounter := mm_atomic.LoadUint64(&m.afterCreateTextChunksCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateTextChunksMock.defaultExpectation != nil && afterCreateTextChunksCounter < 1 {
		if m.CreateTextChunksMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateTextChunks at\n%s", m.CreateTextChunksMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateTextChunks at\n%s with params: %#v", m.CreateTextChunksMock.defaultExpectation.expectationOrigins.origin, *m.CreateTextChunksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateTextChunks != nil && afterCreateTextChunksCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateTextChunks at\n%s", m.funcCreateTextChunksOrigin)
	}

	if !m.CreateTextChunksMock.invocationsDone() && afterCreateTextChunksCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateTextChunks at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateTextChunksMock.expectedInvocations), m.CreateTextChunksMock.expectedInvocationsOrigin, afterCreateTextChunksCounter)
	}
}

type mRepositoryMockDeleteAllConvertedFilesInKb struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteAllConvertedFilesInKbExpectation
	expectations       []*RepositoryMockDeleteAllConvertedFilesInKbExpectation

	callArgs []*RepositoryMockDeleteAllConvertedFilesInKbParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteAllConvertedFilesInKbExpectation specifies expectation struct of the Repository.DeleteAllConvertedFilesInKb
type RepositoryMockDeleteAllConvertedFilesInKbExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteAllConvertedFilesInKbParams
	paramPtrs          *RepositoryMockDeleteAllConvertedFilesInKbParamPtrs
	expectationOrigins RepositoryMockDeleteAllConvertedFilesInKbExpectationOrigins
	results            *RepositoryMockDeleteAllConvertedFilesInKbResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteAllConvertedFilesInKbParams contains parameters of the Repository.DeleteAllConvertedFilesInKb
type RepositoryMockDeleteAllConvertedFilesInKbParams struct {
	ctx   context.Context
	kbUID types.KBUIDType
}

// RepositoryMockDeleteAllConvertedFilesInKbParamPtrs contains pointers to parameters of the Repository.DeleteAllConvertedFilesInKb
type RepositoryMockDeleteAllConvertedFilesInKbParamPtrs struct {
	ctx   *context.Context
	kbUID *types.KBUIDType
}

// RepositoryMockDeleteAllConvertedFilesInKbResults contains results of the Repository.DeleteAllConvertedFilesInKb
type RepositoryMockDeleteAllConvertedFilesInKbResults struct {
	err error
}

// RepositoryMockDeleteAllConvertedFilesInKbOrigins contains origins of expectations of the Repository.DeleteAllConvertedFilesInKb
type RepositoryMockDeleteAllConvertedFilesInKbExpectationOrigins struct {
	origin      string
	originCtx   string
	originKbUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteAllConvertedFilesInKb *mRepositoryMockDeleteAllConvertedFilesInKb) Optional() *mRepositoryMockDeleteAllConvertedFilesInKb {
	mmDeleteAllConvertedFilesInKb.optional = true
	return mmDeleteAllConvertedFilesInKb
}

// Expect sets up expected params for Repository.DeleteAllConvertedFilesInKb
func (mmDeleteAllConvertedFilesInKb *mRepositoryMockDeleteAllConvertedFilesInKb) Expect(ctx context.Context, kbUID types.KBUIDType) *mRepositoryMockDeleteAllConvertedFilesInKb {
	if mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKb != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryMock.DeleteAllConvertedFilesInKb mock is already set by Set")
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation == nil {
		mmDeleteAllConvertedFilesInKb.defaultExpectation = &RepositoryMockDeleteAllConvertedFilesInKbExpectation{}
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation.paramPtrs != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryMock.DeleteAllConvertedFilesInKb mock is already set by ExpectParams functions")
	}

	mmDeleteAllConvertedFilesInKb.defaultExpectation.params = &RepositoryMockDeleteAllConvertedFilesInKbParams{ctx, kbUID}
	mmDeleteAllConvertedFilesInKb.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteAllConvertedFilesInKb.expectations {
		if minimock.Equal(e.params, mmDeleteAllConvertedFilesInKb.defaultExpectation.params) {
			mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteAllConvertedFilesInKb.defaultExpectation.params)
		}
	}

	return mmDeleteAllConvertedFilesInKb
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteAllConvertedFilesInKb
func (mmDeleteAllConvertedFilesInKb *mRepositoryMockDeleteAllConvertedFilesInKb) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteAllConvertedFilesInKb {
	if mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKb != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryMock.DeleteAllConvertedFilesInKb mock is already set by Set")
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation == nil {
		mmDeleteAllConvertedFilesInKb.defaultExpectation = &RepositoryMockDeleteAllConvertedFilesInKbExpectation{}
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation.params != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryMock.DeleteAllConvertedFilesInKb mock is already set by Expect")
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation.paramPtrs == nil {
		mmDeleteAllConvertedFilesInKb.defaultExpectation.paramPtrs = &RepositoryMockDeleteAllConvertedFilesInKbParamPtrs{}
	}
	mmDeleteAllConvertedFilesInKb.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteAllConvertedFilesInKb.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteAllConvertedFilesInKb
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.DeleteAllConvertedFilesInKb
func (mmDeleteAllConvertedFilesInKb *mRepositoryMockDeleteAllConvertedFilesInKb) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockDeleteAllConvertedFilesInKb {
	if mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKb != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryMock.DeleteAllConvertedFilesInKb mock is already set by Set")
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation == nil {
		mmDeleteAllConvertedFilesInKb.defaultExpectation = &RepositoryMockDeleteAllConvertedFilesInKbExpectation{}
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation.params != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryMock.DeleteAllConvertedFilesInKb mock is already set by Expect")
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation.paramPtrs == nil {
		mmDeleteAllConvertedFilesInKb.defaultExpectation.paramPtrs = &RepositoryMockDeleteAllConvertedFilesInKbParamPtrs{}
	}
	mmDeleteAllConvertedFilesInKb.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmDeleteAllConvertedFilesInKb.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmDeleteAllConvertedFilesInKb
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteAllConvertedFilesInKb
func (mmDeleteAllConvertedFilesInKb *mRepositoryMockDeleteAllConvertedFilesInKb) Inspect(f func(ctx context.Context, kbUID types.KBUIDType)) *mRepositoryMockDeleteAllConvertedFilesInKb {
	if mmDeleteAllConvertedFilesInKb.mock.inspectFuncDeleteAllConvertedFilesInKb != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteAllConvertedFilesInKb")
	}

	mmDeleteAllConvertedFilesInKb.mock.inspectFuncDeleteAllConvertedFilesInKb = f

	return mmDeleteAllConvertedFilesInKb
}

// Return sets up results that will be returned by Repository.DeleteAllConvertedFilesInKb
func (mmDeleteAllConvertedFilesInKb *mRepositoryMockDeleteAllConvertedFilesInKb) Return(err error) *RepositoryMock {
	if mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKb != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryMock.DeleteAllConvertedFilesInKb mock is already set by Set")
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation == nil {
		mmDeleteAllConvertedFilesInKb.defaultExpectation = &RepositoryMockDeleteAllConvertedFilesInKbExpectation{mock: mmDeleteAllConvertedFilesInKb.mock}
	}
	mmDeleteAllConvertedFilesInKb.defaultExpectation.results = &RepositoryMockDeleteAllConvertedFilesInKbResults{err}
	mmDeleteAllConvertedFilesInKb.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteAllConvertedFilesInKb.mock
}

// Set uses given function f to mock the Repository.DeleteAllConvertedFilesInKb method
func (mmDeleteAllConvertedFilesInKb *mRepositoryMockDeleteAllConvertedFilesInKb) Set(f func(ctx context.Context, kbUID types.KBUIDType) (err error)) *RepositoryMock {
	if mmDeleteAllConvertedFilesInKb.defaultExpectation != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteAllConvertedFilesInKb method")
	}

	if len(mmDeleteAllConvertedFilesInKb.expectations) > 0 {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteAllConvertedFilesInKb method")
	}

	mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKb = f
	mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKbOrigin = minimock.CallerInfo(1)
	return mmDeleteAllConvertedFilesInKb.mock
}

// When sets expectation for the Repository.DeleteAllConvertedFilesInKb which will trigger the result defined by the following
// Then helper
func (mmDeleteAllConvertedFilesInKb *mRepositoryMockDeleteAllConvertedFilesInKb) When(ctx context.Context, kbUID types.KBUIDType) *RepositoryMockDeleteAllConvertedFilesInKbExpectation {
	if mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKb != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryMock.DeleteAllConvertedFilesInKb mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteAllConvertedFilesInKbExpectation{
		mock:               mmDeleteAllConvertedFilesInKb.mock,
		params:             &RepositoryMockDeleteAllConvertedFilesInKbParams{ctx, kbUID},
		expectationOrigins: RepositoryMockDeleteAllConvertedFilesInKbExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteAllConvertedFilesInKb.expectations = append(mmDeleteAllConvertedFilesInKb.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteAllConvertedFilesInKb return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteAllConvertedFilesInKbExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteAllConvertedFilesInKbResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteAllConvertedFilesInKb should be invoked
func (mmDeleteAllConvertedFilesInKb *mRepositoryMockDeleteAllConvertedFilesInKb) Times(n uint64) *mRepositoryMockDeleteAllConvertedFilesInKb {
	if n == 0 {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("Times of RepositoryMock.DeleteAllConvertedFilesInKb mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteAllConvertedFilesInKb.expectedInvocations, n)
	mmDeleteAllConvertedFilesInKb.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteAllConvertedFilesInKb
}

func (mmDeleteAllConvertedFilesInKb *mRepositoryMockDeleteAllConvertedFilesInKb) invocationsDone() bool {
	if len(mmDeleteAllConvertedFilesInKb.expectations) == 0 && mmDeleteAllConvertedFilesInKb.defaultExpectation == nil && mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKb == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteAllConvertedFilesInKb.mock.afterDeleteAllConvertedFilesInKbCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteAllConvertedFilesInKb.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteAllConvertedFilesInKb implements mm_repository.Repository
func (mmDeleteAllConvertedFilesInKb *RepositoryMock) DeleteAllConvertedFilesInKb(ctx context.Context, kbUID types.KBUIDType) (err error) {
	mm_atomic.AddUint64(&mmDeleteAllConvertedFilesInKb.beforeDeleteAllConvertedFilesInKbCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteAllConvertedFilesInKb.afterDeleteAllConvertedFilesInKbCounter, 1)

	mmDeleteAllConvertedFilesInKb.t.Helper()

	if mmDeleteAllConvertedFilesInKb.inspectFuncDeleteAllConvertedFilesInKb != nil {
		mmDeleteAllConvertedFilesInKb.inspectFuncDeleteAllConvertedFilesInKb(ctx, kbUID)
	}

	mm_params := RepositoryMockDeleteAllConvertedFilesInKbParams{ctx, kbUID}

	// Record call args
	mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.mutex.Lock()
	mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.callArgs = append(mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.callArgs, &mm_params)
	mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.mutex.Unlock()

	for _, e := range mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteAllConvertedFilesInKbParams{ctx, kbUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteAllConvertedFilesInKb.t.Errorf("RepositoryMock.DeleteAllConvertedFilesInKb got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmDeleteAllConvertedFilesInKb.t.Errorf("RepositoryMock.DeleteAllConvertedFilesInKb got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteAllConvertedFilesInKb.t.Errorf("RepositoryMock.DeleteAllConvertedFilesInKb got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteAllConvertedFilesInKb.t.Fatal("No results are set for the RepositoryMock.DeleteAllConvertedFilesInKb")
		}
		return (*mm_results).err
	}
	if mmDeleteAllConvertedFilesInKb.funcDeleteAllConvertedFilesInKb != nil {
		return mmDeleteAllConvertedFilesInKb.funcDeleteAllConvertedFilesInKb(ctx, kbUID)
	}
	mmDeleteAllConvertedFilesInKb.t.Fatalf("Unexpected call to RepositoryMock.DeleteAllConvertedFilesInKb. %v %v", ctx, kbUID)
	return
}

// DeleteAllConvertedFilesInKbAfterCounter returns a count of finished RepositoryMock.DeleteAllConvertedFilesInKb invocations
func (mmDeleteAllConvertedFilesInKb *RepositoryMock) DeleteAllConvertedFilesInKbAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAllConvertedFilesInKb.afterDeleteAllConvertedFilesInKbCounter)
}

// DeleteAllConvertedFilesInKbBeforeCounter returns a count of RepositoryMock.DeleteAllConvertedFilesInKb invocations
func (mmDeleteAllConvertedFilesInKb *RepositoryMock) DeleteAllConvertedFilesInKbBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAllConvertedFilesInKb.beforeDeleteAllConvertedFilesInKbCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteAllConvertedFilesInKb.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteAllConvertedFilesInKb *mRepositoryMockDeleteAllConvertedFilesInKb) Calls() []*RepositoryMockDeleteAllConvertedFilesInKbParams {
	mmDeleteAllConvertedFilesInKb.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteAllConvertedFilesInKbParams, len(mmDeleteAllConvertedFilesInKb.callArgs))
	copy(argCopy, mmDeleteAllConvertedFilesInKb.callArgs)

	mmDeleteAllConvertedFilesInKb.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteAllConvertedFilesInKbDone returns true if the count of the DeleteAllConvertedFilesInKb invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteAllConvertedFilesInKbDone() bool {
	if m.DeleteAllConvertedFilesInKbMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteAllConvertedFilesInKbMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteAllConvertedFilesInKbMock.invocationsDone()
}

// MinimockDeleteAllConvertedFilesInKbInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteAllConvertedFilesInKbInspect() {
	for _, e := range m.DeleteAllConvertedFilesInKbMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteAllConvertedFilesInKb at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteAllConvertedFilesInKbCounter := mm_atomic.LoadUint64(&m.afterDeleteAllConvertedFilesInKbCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteAllConvertedFilesInKbMock.defaultExpectation != nil && afterDeleteAllConvertedFilesInKbCounter < 1 {
		if m.DeleteAllConvertedFilesInKbMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteAllConvertedFilesInKb at\n%s", m.DeleteAllConvertedFilesInKbMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteAllConvertedFilesInKb at\n%s with params: %#v", m.DeleteAllConvertedFilesInKbMock.defaultExpectation.expectationOrigins.origin, *m.DeleteAllConvertedFilesInKbMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteAllConvertedFilesInKb != nil && afterDeleteAllConvertedFilesInKbCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteAllConvertedFilesInKb at\n%s", m.funcDeleteAllConvertedFilesInKbOrigin)
	}

	if !m.DeleteAllConvertedFilesInKbMock.invocationsDone() && afterDeleteAllConvertedFilesInKbCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteAllConvertedFilesInKb at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteAllConvertedFilesInKbMock.expectedInvocations), m.DeleteAllConvertedFilesInKbMock.expectedInvocationsOrigin, afterDeleteAllConvertedFilesInKbCounter)
	}
}

type mRepositoryMockDeleteAllKnowledgeBaseFiles struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteAllKnowledgeBaseFilesExpectation
	expectations       []*RepositoryMockDeleteAllKnowledgeBaseFilesExpectation

	callArgs []*RepositoryMockDeleteAllKnowledgeBaseFilesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteAllKnowledgeBaseFilesExpectation specifies expectation struct of the Repository.DeleteAllKnowledgeBaseFiles
type RepositoryMockDeleteAllKnowledgeBaseFilesExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteAllKnowledgeBaseFilesParams
	paramPtrs          *RepositoryMockDeleteAllKnowledgeBaseFilesParamPtrs
	expectationOrigins RepositoryMockDeleteAllKnowledgeBaseFilesExpectationOrigins
	results            *RepositoryMockDeleteAllKnowledgeBaseFilesResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteAllKnowledgeBaseFilesParams contains parameters of the Repository.DeleteAllKnowledgeBaseFiles
type RepositoryMockDeleteAllKnowledgeBaseFilesParams struct {
	ctx   context.Context
	kbUID string
}

// RepositoryMockDeleteAllKnowledgeBaseFilesParamPtrs contains pointers to parameters of the Repository.DeleteAllKnowledgeBaseFiles
type RepositoryMockDeleteAllKnowledgeBaseFilesParamPtrs struct {
	ctx   *context.Context
	kbUID *string
}

// RepositoryMockDeleteAllKnowledgeBaseFilesResults contains results of the Repository.DeleteAllKnowledgeBaseFiles
type RepositoryMockDeleteAllKnowledgeBaseFilesResults struct {
	err error
}

// RepositoryMockDeleteAllKnowledgeBaseFilesOrigins contains origins of expectations of the Repository.DeleteAllKnowledgeBaseFiles
type RepositoryMockDeleteAllKnowledgeBaseFilesExpectationOrigins struct {
	origin      string
	originCtx   string
	originKbUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryMockDeleteAllKnowledgeBaseFiles) Optional() *mRepositoryMockDeleteAllKnowledgeBaseFiles {
	mmDeleteAllKnowledgeBaseFiles.optional = true
	return mmDeleteAllKnowledgeBaseFiles
}

// Expect sets up expected params for Repository.DeleteAllKnowledgeBaseFiles
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryMockDeleteAllKnowledgeBaseFiles) Expect(ctx context.Context, kbUID string) *mRepositoryMockDeleteAllKnowledgeBaseFiles {
	if mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFiles != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.DeleteAllKnowledgeBaseFiles mock is already set by Set")
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation == nil {
		mmDeleteAllKnowledgeBaseFiles.defaultExpectation = &RepositoryMockDeleteAllKnowledgeBaseFilesExpectation{}
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation.paramPtrs != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.DeleteAllKnowledgeBaseFiles mock is already set by ExpectParams functions")
	}

	mmDeleteAllKnowledgeBaseFiles.defaultExpectation.params = &RepositoryMockDeleteAllKnowledgeBaseFilesParams{ctx, kbUID}
	mmDeleteAllKnowledgeBaseFiles.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteAllKnowledgeBaseFiles.expectations {
		if minimock.Equal(e.params, mmDeleteAllKnowledgeBaseFiles.defaultExpectation.params) {
			mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteAllKnowledgeBaseFiles.defaultExpectation.params)
		}
	}

	return mmDeleteAllKnowledgeBaseFiles
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteAllKnowledgeBaseFiles
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryMockDeleteAllKnowledgeBaseFiles) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteAllKnowledgeBaseFiles {
	if mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFiles != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.DeleteAllKnowledgeBaseFiles mock is already set by Set")
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation == nil {
		mmDeleteAllKnowledgeBaseFiles.defaultExpectation = &RepositoryMockDeleteAllKnowledgeBaseFilesExpectation{}
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.DeleteAllKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmDeleteAllKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryMockDeleteAllKnowledgeBaseFilesParamPtrs{}
	}
	mmDeleteAllKnowledgeBaseFiles.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteAllKnowledgeBaseFiles.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteAllKnowledgeBaseFiles
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.DeleteAllKnowledgeBaseFiles
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryMockDeleteAllKnowledgeBaseFiles) ExpectKbUIDParam2(kbUID string) *mRepositoryMockDeleteAllKnowledgeBaseFiles {
	if mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFiles != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.DeleteAllKnowledgeBaseFiles mock is already set by Set")
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation == nil {
		mmDeleteAllKnowledgeBaseFiles.defaultExpectation = &RepositoryMockDeleteAllKnowledgeBaseFilesExpectation{}
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.DeleteAllKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmDeleteAllKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryMockDeleteAllKnowledgeBaseFilesParamPtrs{}
	}
	mmDeleteAllKnowledgeBaseFiles.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmDeleteAllKnowledgeBaseFiles.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmDeleteAllKnowledgeBaseFiles
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteAllKnowledgeBaseFiles
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryMockDeleteAllKnowledgeBaseFiles) Inspect(f func(ctx context.Context, kbUID string)) *mRepositoryMockDeleteAllKnowledgeBaseFiles {
	if mmDeleteAllKnowledgeBaseFiles.mock.inspectFuncDeleteAllKnowledgeBaseFiles != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteAllKnowledgeBaseFiles")
	}

	mmDeleteAllKnowledgeBaseFiles.mock.inspectFuncDeleteAllKnowledgeBaseFiles = f

	return mmDeleteAllKnowledgeBaseFiles
}

// Return sets up results that will be returned by Repository.DeleteAllKnowledgeBaseFiles
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryMockDeleteAllKnowledgeBaseFiles) Return(err error) *RepositoryMock {
	if mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFiles != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.DeleteAllKnowledgeBaseFiles mock is already set by Set")
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation == nil {
		mmDeleteAllKnowledgeBaseFiles.defaultExpectation = &RepositoryMockDeleteAllKnowledgeBaseFilesExpectation{mock: mmDeleteAllKnowledgeBaseFiles.mock}
	}
	mmDeleteAllKnowledgeBaseFiles.defaultExpectation.results = &RepositoryMockDeleteAllKnowledgeBaseFilesResults{err}
	mmDeleteAllKnowledgeBaseFiles.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteAllKnowledgeBaseFiles.mock
}

// Set uses given function f to mock the Repository.DeleteAllKnowledgeBaseFiles method
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryMockDeleteAllKnowledgeBaseFiles) Set(f func(ctx context.Context, kbUID string) (err error)) *RepositoryMock {
	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteAllKnowledgeBaseFiles method")
	}

	if len(mmDeleteAllKnowledgeBaseFiles.expectations) > 0 {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteAllKnowledgeBaseFiles method")
	}

	mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFiles = f
	mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFilesOrigin = minimock.CallerInfo(1)
	return mmDeleteAllKnowledgeBaseFiles.mock
}

// When sets expectation for the Repository.DeleteAllKnowledgeBaseFiles which will trigger the result defined by the following
// Then helper
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryMockDeleteAllKnowledgeBaseFiles) When(ctx context.Context, kbUID string) *RepositoryMockDeleteAllKnowledgeBaseFilesExpectation {
	if mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFiles != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.DeleteAllKnowledgeBaseFiles mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteAllKnowledgeBaseFilesExpectation{
		mock:               mmDeleteAllKnowledgeBaseFiles.mock,
		params:             &RepositoryMockDeleteAllKnowledgeBaseFilesParams{ctx, kbUID},
		expectationOrigins: RepositoryMockDeleteAllKnowledgeBaseFilesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteAllKnowledgeBaseFiles.expectations = append(mmDeleteAllKnowledgeBaseFiles.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteAllKnowledgeBaseFiles return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteAllKnowledgeBaseFilesExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteAllKnowledgeBaseFilesResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteAllKnowledgeBaseFiles should be invoked
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryMockDeleteAllKnowledgeBaseFiles) Times(n uint64) *mRepositoryMockDeleteAllKnowledgeBaseFiles {
	if n == 0 {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("Times of RepositoryMock.DeleteAllKnowledgeBaseFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteAllKnowledgeBaseFiles.expectedInvocations, n)
	mmDeleteAllKnowledgeBaseFiles.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteAllKnowledgeBaseFiles
}

func (mmDeleteAllKnowledgeBaseFiles *mRepositoryMockDeleteAllKnowledgeBaseFiles) invocationsDone() bool {
	if len(mmDeleteAllKnowledgeBaseFiles.expectations) == 0 && mmDeleteAllKnowledgeBaseFiles.defaultExpectation == nil && mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteAllKnowledgeBaseFiles.mock.afterDeleteAllKnowledgeBaseFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteAllKnowledgeBaseFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteAllKnowledgeBaseFiles implements mm_repository.Repository
func (mmDeleteAllKnowledgeBaseFiles *RepositoryMock) DeleteAllKnowledgeBaseFiles(ctx context.Context, kbUID string) (err error) {
	mm_atomic.AddUint64(&mmDeleteAllKnowledgeBaseFiles.beforeDeleteAllKnowledgeBaseFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteAllKnowledgeBaseFiles.afterDeleteAllKnowledgeBaseFilesCounter, 1)

	mmDeleteAllKnowledgeBaseFiles.t.Helper()

	if mmDeleteAllKnowledgeBaseFiles.inspectFuncDeleteAllKnowledgeBaseFiles != nil {
		mmDeleteAllKnowledgeBaseFiles.inspectFuncDeleteAllKnowledgeBaseFiles(ctx, kbUID)
	}

	mm_params := RepositoryMockDeleteAllKnowledgeBaseFilesParams{ctx, kbUID}

	// Record call args
	mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.mutex.Lock()
	mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.callArgs = append(mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.callArgs, &mm_params)
	mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.mutex.Unlock()

	for _, e := range mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteAllKnowledgeBaseFilesParams{ctx, kbUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteAllKnowledgeBaseFiles.t.Errorf("RepositoryMock.DeleteAllKnowledgeBaseFiles got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmDeleteAllKnowledgeBaseFiles.t.Errorf("RepositoryMock.DeleteAllKnowledgeBaseFiles got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteAllKnowledgeBaseFiles.t.Errorf("RepositoryMock.DeleteAllKnowledgeBaseFiles got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteAllKnowledgeBaseFiles.t.Fatal("No results are set for the RepositoryMock.DeleteAllKnowledgeBaseFiles")
		}
		return (*mm_results).err
	}
	if mmDeleteAllKnowledgeBaseFiles.funcDeleteAllKnowledgeBaseFiles != nil {
		return mmDeleteAllKnowledgeBaseFiles.funcDeleteAllKnowledgeBaseFiles(ctx, kbUID)
	}
	mmDeleteAllKnowledgeBaseFiles.t.Fatalf("Unexpected call to RepositoryMock.DeleteAllKnowledgeBaseFiles. %v %v", ctx, kbUID)
	return
}

// DeleteAllKnowledgeBaseFilesAfterCounter returns a count of finished RepositoryMock.DeleteAllKnowledgeBaseFiles invocations
func (mmDeleteAllKnowledgeBaseFiles *RepositoryMock) DeleteAllKnowledgeBaseFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAllKnowledgeBaseFiles.afterDeleteAllKnowledgeBaseFilesCounter)
}

// DeleteAllKnowledgeBaseFilesBeforeCounter returns a count of RepositoryMock.DeleteAllKnowledgeBaseFiles invocations
func (mmDeleteAllKnowledgeBaseFiles *RepositoryMock) DeleteAllKnowledgeBaseFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAllKnowledgeBaseFiles.beforeDeleteAllKnowledgeBaseFilesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteAllKnowledgeBaseFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryMockDeleteAllKnowledgeBaseFiles) Calls() []*RepositoryMockDeleteAllKnowledgeBaseFilesParams {
	mmDeleteAllKnowledgeBaseFiles.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteAllKnowledgeBaseFilesParams, len(mmDeleteAllKnowledgeBaseFiles.callArgs))
	copy(argCopy, mmDeleteAllKnowledgeBaseFiles.callArgs)

	mmDeleteAllKnowledgeBaseFiles.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteAllKnowledgeBaseFilesDone returns true if the count of the DeleteAllKnowledgeBaseFiles invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteAllKnowledgeBaseFilesDone() bool {
	if m.DeleteAllKnowledgeBaseFilesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteAllKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteAllKnowledgeBaseFilesMock.invocationsDone()
}

// MinimockDeleteAllKnowledgeBaseFilesInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteAllKnowledgeBaseFilesInspect() {
	for _, e := range m.DeleteAllKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteAllKnowledgeBaseFiles at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteAllKnowledgeBaseFilesCounter := mm_atomic.LoadUint64(&m.afterDeleteAllKnowledgeBaseFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteAllKnowledgeBaseFilesMock.defaultExpectation != nil && afterDeleteAllKnowledgeBaseFilesCounter < 1 {
		if m.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteAllKnowledgeBaseFiles at\n%s", m.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteAllKnowledgeBaseFiles at\n%s with params: %#v", m.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.origin, *m.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteAllKnowledgeBaseFiles != nil && afterDeleteAllKnowledgeBaseFilesCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteAllKnowledgeBaseFiles at\n%s", m.funcDeleteAllKnowledgeBaseFilesOrigin)
	}

	if !m.DeleteAllKnowledgeBaseFilesMock.invocationsDone() && afterDeleteAllKnowledgeBaseFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteAllKnowledgeBaseFiles at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteAllKnowledgeBaseFilesMock.expectedInvocations), m.DeleteAllKnowledgeBaseFilesMock.expectedInvocationsOrigin, afterDeleteAllKnowledgeBaseFilesCounter)
	}
}

type mRepositoryMockDeleteAndCreateEmbeddings struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteAndCreateEmbeddingsExpectation
	expectations       []*RepositoryMockDeleteAndCreateEmbeddingsExpectation

	callArgs []*RepositoryMockDeleteAndCreateEmbeddingsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteAndCreateEmbeddingsExpectation specifies expectation struct of the Repository.DeleteAndCreateEmbeddings
type RepositoryMockDeleteAndCreateEmbeddingsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteAndCreateEmbeddingsParams
	paramPtrs          *RepositoryMockDeleteAndCreateEmbeddingsParamPtrs
	expectationOrigins RepositoryMockDeleteAndCreateEmbeddingsExpectationOrigins
	results            *RepositoryMockDeleteAndCreateEmbeddingsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteAndCreateEmbeddingsParams contains parameters of the Repository.DeleteAndCreateEmbeddings
type RepositoryMockDeleteAndCreateEmbeddingsParams struct {
	ctx                 context.Context
	fileUID             types.FileUIDType
	embeddings          []mm_repository.EmbeddingModel
	externalServiceCall func([]mm_repository.EmbeddingModel) error
}

// RepositoryMockDeleteAndCreateEmbeddingsParamPtrs contains pointers to parameters of the Repository.DeleteAndCreateEmbeddings
type RepositoryMockDeleteAndCreateEmbeddingsParamPtrs struct {
	ctx                 *context.Context
	fileUID             *types.FileUIDType
	embeddings          *[]mm_repository.EmbeddingModel
	externalServiceCall *func([]mm_repository.EmbeddingModel) error
}

// RepositoryMockDeleteAndCreateEmbeddingsResults contains results of the Repository.DeleteAndCreateEmbeddings
type RepositoryMockDeleteAndCreateEmbeddingsResults struct {
	ea1 []mm_repository.EmbeddingModel
	err error
}

// RepositoryMockDeleteAndCreateEmbeddingsOrigins contains origins of expectations of the Repository.DeleteAndCreateEmbeddings
type RepositoryMockDeleteAndCreateEmbeddingsExpectationOrigins struct {
	origin                    string
	originCtx                 string
	originFileUID             string
	originEmbeddings          string
	originExternalServiceCall string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteAndCreateEmbeddings *mRepositoryMockDeleteAndCreateEmbeddings) Optional() *mRepositoryMockDeleteAndCreateEmbeddings {
	mmDeleteAndCreateEmbeddings.optional = true
	return mmDeleteAndCreateEmbeddings
}

// Expect sets up expected params for Repository.DeleteAndCreateEmbeddings
func (mmDeleteAndCreateEmbeddings *mRepositoryMockDeleteAndCreateEmbeddings) Expect(ctx context.Context, fileUID types.FileUIDType, embeddings []mm_repository.EmbeddingModel, externalServiceCall func([]mm_repository.EmbeddingModel) error) *mRepositoryMockDeleteAndCreateEmbeddings {
	if mmDeleteAndCreateEmbeddings.mock.funcDeleteAndCreateEmbeddings != nil {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("RepositoryMock.DeleteAndCreateEmbeddings mock is already set by Set")
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation == nil {
		mmDeleteAndCreateEmbeddings.defaultExpectation = &RepositoryMockDeleteAndCreateEmbeddingsExpectation{}
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation.paramPtrs != nil {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("RepositoryMock.DeleteAndCreateEmbeddings mock is already set by ExpectParams functions")
	}

	mmDeleteAndCreateEmbeddings.defaultExpectation.params = &RepositoryMockDeleteAndCreateEmbeddingsParams{ctx, fileUID, embeddings, externalServiceCall}
	mmDeleteAndCreateEmbeddings.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteAndCreateEmbeddings.expectations {
		if minimock.Equal(e.params, mmDeleteAndCreateEmbeddings.defaultExpectation.params) {
			mmDeleteAndCreateEmbeddings.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteAndCreateEmbeddings.defaultExpectation.params)
		}
	}

	return mmDeleteAndCreateEmbeddings
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteAndCreateEmbeddings
func (mmDeleteAndCreateEmbeddings *mRepositoryMockDeleteAndCreateEmbeddings) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteAndCreateEmbeddings {
	if mmDeleteAndCreateEmbeddings.mock.funcDeleteAndCreateEmbeddings != nil {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("RepositoryMock.DeleteAndCreateEmbeddings mock is already set by Set")
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation == nil {
		mmDeleteAndCreateEmbeddings.defaultExpectation = &RepositoryMockDeleteAndCreateEmbeddingsExpectation{}
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation.params != nil {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("RepositoryMock.DeleteAndCreateEmbeddings mock is already set by Expect")
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateEmbeddings.defaultExpectation.paramPtrs = &RepositoryMockDeleteAndCreateEmbeddingsParamPtrs{}
	}
	mmDeleteAndCreateEmbeddings.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteAndCreateEmbeddings.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteAndCreateEmbeddings
}

// ExpectFileUIDParam2 sets up expected param fileUID for Repository.DeleteAndCreateEmbeddings
func (mmDeleteAndCreateEmbeddings *mRepositoryMockDeleteAndCreateEmbeddings) ExpectFileUIDParam2(fileUID types.FileUIDType) *mRepositoryMockDeleteAndCreateEmbeddings {
	if mmDeleteAndCreateEmbeddings.mock.funcDeleteAndCreateEmbeddings != nil {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("RepositoryMock.DeleteAndCreateEmbeddings mock is already set by Set")
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation == nil {
		mmDeleteAndCreateEmbeddings.defaultExpectation = &RepositoryMockDeleteAndCreateEmbeddingsExpectation{}
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation.params != nil {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("RepositoryMock.DeleteAndCreateEmbeddings mock is already set by Expect")
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateEmbeddings.defaultExpectation.paramPtrs = &RepositoryMockDeleteAndCreateEmbeddingsParamPtrs{}
	}
	mmDeleteAndCreateEmbeddings.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmDeleteAndCreateEmbeddings.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmDeleteAndCreateEmbeddings
}

// ExpectEmbeddingsParam3 sets up expected param embeddings for Repository.DeleteAndCreateEmbeddings
func (mmDeleteAndCreateEmbeddings *mRepositoryMockDeleteAndCreateEmbeddings) ExpectEmbeddingsParam3(embeddings []mm_repository.EmbeddingModel) *mRepositoryMockDeleteAndCreateEmbeddings {
	if mmDeleteAndCreateEmbeddings.mock.funcDeleteAndCreateEmbeddings != nil {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("RepositoryMock.DeleteAndCreateEmbeddings mock is already set by Set")
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation == nil {
		mmDeleteAndCreateEmbeddings.defaultExpectation = &RepositoryMockDeleteAndCreateEmbeddingsExpectation{}
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation.params != nil {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("RepositoryMock.DeleteAndCreateEmbeddings mock is already set by Expect")
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateEmbeddings.defaultExpectation.paramPtrs = &RepositoryMockDeleteAndCreateEmbeddingsParamPtrs{}
	}
	mmDeleteAndCreateEmbeddings.defaultExpectation.paramPtrs.embeddings = &embeddings
	mmDeleteAndCreateEmbeddings.defaultExpectation.expectationOrigins.originEmbeddings = minimock.CallerInfo(1)

	return mmDeleteAndCreateEmbeddings
}

// ExpectExternalServiceCallParam4 sets up expected param externalServiceCall for Repository.DeleteAndCreateEmbeddings
func (mmDeleteAndCreateEmbeddings *mRepositoryMockDeleteAndCreateEmbeddings) ExpectExternalServiceCallParam4(externalServiceCall func([]mm_repository.EmbeddingModel) error) *mRepositoryMockDeleteAndCreateEmbeddings {
	if mmDeleteAndCreateEmbeddings.mock.funcDeleteAndCreateEmbeddings != nil {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("RepositoryMock.DeleteAndCreateEmbeddings mock is already set by Set")
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation == nil {
		mmDeleteAndCreateEmbeddings.defaultExpectation = &RepositoryMockDeleteAndCreateEmbeddingsExpectation{}
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation.params != nil {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("RepositoryMock.DeleteAndCreateEmbeddings mock is already set by Expect")
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateEmbeddings.defaultExpectation.paramPtrs = &RepositoryMockDeleteAndCreateEmbeddingsParamPtrs{}
	}
	mmDeleteAndCreateEmbeddings.defaultExpectation.paramPtrs.externalServiceCall = &externalServiceCall
	mmDeleteAndCreateEmbeddings.defaultExpectation.expectationOrigins.originExternalServiceCall = minimock.CallerInfo(1)

	return mmDeleteAndCreateEmbeddings
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteAndCreateEmbeddings
func (mmDeleteAndCreateEmbeddings *mRepositoryMockDeleteAndCreateEmbeddings) Inspect(f func(ctx context.Context, fileUID types.FileUIDType, embeddings []mm_repository.EmbeddingModel, externalServiceCall func([]mm_repository.EmbeddingModel) error)) *mRepositoryMockDeleteAndCreateEmbeddings {
	if mmDeleteAndCreateEmbeddings.mock.inspectFuncDeleteAndCreateEmbeddings != nil {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteAndCreateEmbeddings")
	}

	mmDeleteAndCreateEmbeddings.mock.inspectFuncDeleteAndCreateEmbeddings = f

	return mmDeleteAndCreateEmbeddings
}

// Return sets up results that will be returned by Repository.DeleteAndCreateEmbeddings
func (mmDeleteAndCreateEmbeddings *mRepositoryMockDeleteAndCreateEmbeddings) Return(ea1 []mm_repository.EmbeddingModel, err error) *RepositoryMock {
	if mmDeleteAndCreateEmbeddings.mock.funcDeleteAndCreateEmbeddings != nil {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("RepositoryMock.DeleteAndCreateEmbeddings mock is already set by Set")
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation == nil {
		mmDeleteAndCreateEmbeddings.defaultExpectation = &RepositoryMockDeleteAndCreateEmbeddingsExpectation{mock: mmDeleteAndCreateEmbeddings.mock}
	}
	mmDeleteAndCreateEmbeddings.defaultExpectation.results = &RepositoryMockDeleteAndCreateEmbeddingsResults{ea1, err}
	mmDeleteAndCreateEmbeddings.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteAndCreateEmbeddings.mock
}

// Set uses given function f to mock the Repository.DeleteAndCreateEmbeddings method
func (mmDeleteAndCreateEmbeddings *mRepositoryMockDeleteAndCreateEmbeddings) Set(f func(ctx context.Context, fileUID types.FileUIDType, embeddings []mm_repository.EmbeddingModel, externalServiceCall func([]mm_repository.EmbeddingModel) error) (ea1 []mm_repository.EmbeddingModel, err error)) *RepositoryMock {
	if mmDeleteAndCreateEmbeddings.defaultExpectation != nil {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteAndCreateEmbeddings method")
	}

	if len(mmDeleteAndCreateEmbeddings.expectations) > 0 {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteAndCreateEmbeddings method")
	}

	mmDeleteAndCreateEmbeddings.mock.funcDeleteAndCreateEmbeddings = f
	mmDeleteAndCreateEmbeddings.mock.funcDeleteAndCreateEmbeddingsOrigin = minimock.CallerInfo(1)
	return mmDeleteAndCreateEmbeddings.mock
}

// When sets expectation for the Repository.DeleteAndCreateEmbeddings which will trigger the result defined by the following
// Then helper
func (mmDeleteAndCreateEmbeddings *mRepositoryMockDeleteAndCreateEmbeddings) When(ctx context.Context, fileUID types.FileUIDType, embeddings []mm_repository.EmbeddingModel, externalServiceCall func([]mm_repository.EmbeddingModel) error) *RepositoryMockDeleteAndCreateEmbeddingsExpectation {
	if mmDeleteAndCreateEmbeddings.mock.funcDeleteAndCreateEmbeddings != nil {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("RepositoryMock.DeleteAndCreateEmbeddings mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteAndCreateEmbeddingsExpectation{
		mock:               mmDeleteAndCreateEmbeddings.mock,
		params:             &RepositoryMockDeleteAndCreateEmbeddingsParams{ctx, fileUID, embeddings, externalServiceCall},
		expectationOrigins: RepositoryMockDeleteAndCreateEmbeddingsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteAndCreateEmbeddings.expectations = append(mmDeleteAndCreateEmbeddings.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteAndCreateEmbeddings return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteAndCreateEmbeddingsExpectation) Then(ea1 []mm_repository.EmbeddingModel, err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteAndCreateEmbeddingsResults{ea1, err}
	return e.mock
}

// Times sets number of times Repository.DeleteAndCreateEmbeddings should be invoked
func (mmDeleteAndCreateEmbeddings *mRepositoryMockDeleteAndCreateEmbeddings) Times(n uint64) *mRepositoryMockDeleteAndCreateEmbeddings {
	if n == 0 {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("Times of RepositoryMock.DeleteAndCreateEmbeddings mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteAndCreateEmbeddings.expectedInvocations, n)
	mmDeleteAndCreateEmbeddings.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteAndCreateEmbeddings
}

func (mmDeleteAndCreateEmbeddings *mRepositoryMockDeleteAndCreateEmbeddings) invocationsDone() bool {
	if len(mmDeleteAndCreateEmbeddings.expectations) == 0 && mmDeleteAndCreateEmbeddings.defaultExpectation == nil && mmDeleteAndCreateEmbeddings.mock.funcDeleteAndCreateEmbeddings == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteAndCreateEmbeddings.mock.afterDeleteAndCreateEmbeddingsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteAndCreateEmbeddings.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteAndCreateEmbeddings implements mm_repository.Repository
func (mmDeleteAndCreateEmbeddings *RepositoryMock) DeleteAndCreateEmbeddings(ctx context.Context, fileUID types.FileUIDType, embeddings []mm_repository.EmbeddingModel, externalServiceCall func([]mm_repository.EmbeddingModel) error) (ea1 []mm_repository.EmbeddingModel, err error) {
	mm_atomic.AddUint64(&mmDeleteAndCreateEmbeddings.beforeDeleteAndCreateEmbeddingsCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteAndCreateEmbeddings.afterDeleteAndCreateEmbeddingsCounter, 1)

	mmDeleteAndCreateEmbeddings.t.Helper()

	if mmDeleteAndCreateEmbeddings.inspectFuncDeleteAndCreateEmbeddings != nil {
		mmDeleteAndCreateEmbeddings.inspectFuncDeleteAndCreateEmbeddings(ctx, fileUID, embeddings, externalServiceCall)
	}

	mm_params := RepositoryMockDeleteAndCreateEmbeddingsParams{ctx, fileUID, embeddings, externalServiceCall}

	// Record call args
	mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.mutex.Lock()
	mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.callArgs = append(mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.callArgs, &mm_params)
	mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.mutex.Unlock()

	for _, e := range mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1, e.results.err
		}
	}

	if mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteAndCreateEmbeddingsParams{ctx, fileUID, embeddings, externalServiceCall}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteAndCreateEmbeddings.t.Errorf("RepositoryMock.DeleteAndCreateEmbeddings got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmDeleteAndCreateEmbeddings.t.Errorf("RepositoryMock.DeleteAndCreateEmbeddings got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

			if mm_want_ptrs.embeddings != nil && !minimock.Equal(*mm_want_ptrs.embeddings, mm_got.embeddings) {
				mmDeleteAndCreateEmbeddings.t.Errorf("RepositoryMock.DeleteAndCreateEmbeddings got unexpected parameter embeddings, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.defaultExpectation.expectationOrigins.originEmbeddings, *mm_want_ptrs.embeddings, mm_got.embeddings, minimock.Diff(*mm_want_ptrs.embeddings, mm_got.embeddings))
			}

			if mm_want_ptrs.externalServiceCall != nil && !minimock.Equal(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall) {
				mmDeleteAndCreateEmbeddings.t.Errorf("RepositoryMock.DeleteAndCreateEmbeddings got unexpected parameter externalServiceCall, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.defaultExpectation.expectationOrigins.originExternalServiceCall, *mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall, minimock.Diff(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteAndCreateEmbeddings.t.Errorf("RepositoryMock.DeleteAndCreateEmbeddings got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteAndCreateEmbeddings.t.Fatal("No results are set for the RepositoryMock.DeleteAndCreateEmbeddings")
		}
		return (*mm_results).ea1, (*mm_results).err
	}
	if mmDeleteAndCreateEmbeddings.funcDeleteAndCreateEmbeddings != nil {
		return mmDeleteAndCreateEmbeddings.funcDeleteAndCreateEmbeddings(ctx, fileUID, embeddings, externalServiceCall)
	}
	mmDeleteAndCreateEmbeddings.t.Fatalf("Unexpected call to RepositoryMock.DeleteAndCreateEmbeddings. %v %v %v %v", ctx, fileUID, embeddings, externalServiceCall)
	return
}

// DeleteAndCreateEmbeddingsAfterCounter returns a count of finished RepositoryMock.DeleteAndCreateEmbeddings invocations
func (mmDeleteAndCreateEmbeddings *RepositoryMock) DeleteAndCreateEmbeddingsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAndCreateEmbeddings.afterDeleteAndCreateEmbeddingsCounter)
}

// DeleteAndCreateEmbeddingsBeforeCounter returns a count of RepositoryMock.DeleteAndCreateEmbeddings invocations
func (mmDeleteAndCreateEmbeddings *RepositoryMock) DeleteAndCreateEmbeddingsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAndCreateEmbeddings.beforeDeleteAndCreateEmbeddingsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteAndCreateEmbeddings.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteAndCreateEmbeddings *mRepositoryMockDeleteAndCreateEmbeddings) Calls() []*RepositoryMockDeleteAndCreateEmbeddingsParams {
	mmDeleteAndCreateEmbeddings.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteAndCreateEmbeddingsParams, len(mmDeleteAndCreateEmbeddings.callArgs))
	copy(argCopy, mmDeleteAndCreateEmbeddings.callArgs)

	mmDeleteAndCreateEmbeddings.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteAndCreateEmbeddingsDone returns true if the count of the DeleteAndCreateEmbeddings invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteAndCreateEmbeddingsDone() bool {
	if m.DeleteAndCreateEmbeddingsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteAndCreateEmbeddingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteAndCreateEmbeddingsMock.invocationsDone()
}

// MinimockDeleteAndCreateEmbeddingsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteAndCreateEmbeddingsInspect() {
	for _, e := range m.DeleteAndCreateEmbeddingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteAndCreateEmbeddings at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteAndCreateEmbeddingsCounter := mm_atomic.LoadUint64(&m.afterDeleteAndCreateEmbeddingsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteAndCreateEmbeddingsMock.defaultExpectation != nil && afterDeleteAndCreateEmbeddingsCounter < 1 {
		if m.DeleteAndCreateEmbeddingsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteAndCreateEmbeddings at\n%s", m.DeleteAndCreateEmbeddingsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteAndCreateEmbeddings at\n%s with params: %#v", m.DeleteAndCreateEmbeddingsMock.defaultExpectation.expectationOrigins.origin, *m.DeleteAndCreateEmbeddingsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteAndCreateEmbeddings != nil && afterDeleteAndCreateEmbeddingsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteAndCreateEmbeddings at\n%s", m.funcDeleteAndCreateEmbeddingsOrigin)
	}

	if !m.DeleteAndCreateEmbeddingsMock.invocationsDone() && afterDeleteAndCreateEmbeddingsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteAndCreateEmbeddings at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteAndCreateEmbeddingsMock.expectedInvocations), m.DeleteAndCreateEmbeddingsMock.expectedInvocationsOrigin, afterDeleteAndCreateEmbeddingsCounter)
	}
}

type mRepositoryMockDeleteAndCreateTextChunks struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteAndCreateTextChunksExpectation
	expectations       []*RepositoryMockDeleteAndCreateTextChunksExpectation

	callArgs []*RepositoryMockDeleteAndCreateTextChunksParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteAndCreateTextChunksExpectation specifies expectation struct of the Repository.DeleteAndCreateTextChunks
type RepositoryMockDeleteAndCreateTextChunksExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteAndCreateTextChunksParams
	paramPtrs          *RepositoryMockDeleteAndCreateTextChunksParamPtrs
	expectationOrigins RepositoryMockDeleteAndCreateTextChunksExpectationOrigins
	results            *RepositoryMockDeleteAndCreateTextChunksResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteAndCreateTextChunksParams contains parameters of the Repository.DeleteAndCreateTextChunks
type RepositoryMockDeleteAndCreateTextChunksParams struct {
	ctx                 context.Context
	fileUID             types.FileUIDType
	textChunks          []*mm_repository.TextChunkModel
	externalServiceCall func(chunkUIDs []string) (destinations map[string]string, _ error)
}

// RepositoryMockDeleteAndCreateTextChunksParamPtrs contains pointers to parameters of the Repository.DeleteAndCreateTextChunks
type RepositoryMockDeleteAndCreateTextChunksParamPtrs struct {
	ctx                 *context.Context
	fileUID             *types.FileUIDType
	textChunks          *[]*mm_repository.TextChunkModel
	externalServiceCall *func(chunkUIDs []string) (destinations map[string]string, _ error)
}

// RepositoryMockDeleteAndCreateTextChunksResults contains results of the Repository.DeleteAndCreateTextChunks
type RepositoryMockDeleteAndCreateTextChunksResults struct {
	tpa1 []*mm_repository.TextChunkModel
	err  error
}

// RepositoryMockDeleteAndCreateTextChunksOrigins contains origins of expectations of the Repository.DeleteAndCreateTextChunks
type RepositoryMockDeleteAndCreateTextChunksExpectationOrigins struct {
	origin                    string
	originCtx                 string
	originFileUID             string
	originTextChunks          string
	originExternalServiceCall string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteAndCreateTextChunks *mRepositoryMockDeleteAndCreateTextChunks) Optional() *mRepositoryMockDeleteAndCreateTextChunks {
	mmDeleteAndCreateTextChunks.optional = true
	return mmDeleteAndCreateTextChunks
}

// Expect sets up expected params for Repository.DeleteAndCreateTextChunks
func (mmDeleteAndCreateTextChunks *mRepositoryMockDeleteAndCreateTextChunks) Expect(ctx context.Context, fileUID types.FileUIDType, textChunks []*mm_repository.TextChunkModel, externalServiceCall func(chunkUIDs []string) (destinations map[string]string, _ error)) *mRepositoryMockDeleteAndCreateTextChunks {
	if mmDeleteAndCreateTextChunks.mock.funcDeleteAndCreateTextChunks != nil {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("RepositoryMock.DeleteAndCreateTextChunks mock is already set by Set")
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation == nil {
		mmDeleteAndCreateTextChunks.defaultExpectation = &RepositoryMockDeleteAndCreateTextChunksExpectation{}
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation.paramPtrs != nil {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("RepositoryMock.DeleteAndCreateTextChunks mock is already set by ExpectParams functions")
	}

	mmDeleteAndCreateTextChunks.defaultExpectation.params = &RepositoryMockDeleteAndCreateTextChunksParams{ctx, fileUID, textChunks, externalServiceCall}
	mmDeleteAndCreateTextChunks.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteAndCreateTextChunks.expectations {
		if minimock.Equal(e.params, mmDeleteAndCreateTextChunks.defaultExpectation.params) {
			mmDeleteAndCreateTextChunks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteAndCreateTextChunks.defaultExpectation.params)
		}
	}

	return mmDeleteAndCreateTextChunks
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteAndCreateTextChunks
func (mmDeleteAndCreateTextChunks *mRepositoryMockDeleteAndCreateTextChunks) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteAndCreateTextChunks {
	if mmDeleteAndCreateTextChunks.mock.funcDeleteAndCreateTextChunks != nil {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("RepositoryMock.DeleteAndCreateTextChunks mock is already set by Set")
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation == nil {
		mmDeleteAndCreateTextChunks.defaultExpectation = &RepositoryMockDeleteAndCreateTextChunksExpectation{}
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation.params != nil {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("RepositoryMock.DeleteAndCreateTextChunks mock is already set by Expect")
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateTextChunks.defaultExpectation.paramPtrs = &RepositoryMockDeleteAndCreateTextChunksParamPtrs{}
	}
	mmDeleteAndCreateTextChunks.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteAndCreateTextChunks.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteAndCreateTextChunks
}

// ExpectFileUIDParam2 sets up expected param fileUID for Repository.DeleteAndCreateTextChunks
func (mmDeleteAndCreateTextChunks *mRepositoryMockDeleteAndCreateTextChunks) ExpectFileUIDParam2(fileUID types.FileUIDType) *mRepositoryMockDeleteAndCreateTextChunks {
	if mmDeleteAndCreateTextChunks.mock.funcDeleteAndCreateTextChunks != nil {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("RepositoryMock.DeleteAndCreateTextChunks mock is already set by Set")
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation == nil {
		mmDeleteAndCreateTextChunks.defaultExpectation = &RepositoryMockDeleteAndCreateTextChunksExpectation{}
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation.params != nil {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("RepositoryMock.DeleteAndCreateTextChunks mock is already set by Expect")
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateTextChunks.defaultExpectation.paramPtrs = &RepositoryMockDeleteAndCreateTextChunksParamPtrs{}
	}
	mmDeleteAndCreateTextChunks.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmDeleteAndCreateTextChunks.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmDeleteAndCreateTextChunks
}

// ExpectTextChunksParam3 sets up expected param textChunks for Repository.DeleteAndCreateTextChunks
func (mmDeleteAndCreateTextChunks *mRepositoryMockDeleteAndCreateTextChunks) ExpectTextChunksParam3(textChunks []*mm_repository.TextChunkModel) *mRepositoryMockDeleteAndCreateTextChunks {
	if mmDeleteAndCreateTextChunks.mock.funcDeleteAndCreateTextChunks != nil {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("RepositoryMock.DeleteAndCreateTextChunks mock is already set by Set")
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation == nil {
		mmDeleteAndCreateTextChunks.defaultExpectation = &RepositoryMockDeleteAndCreateTextChunksExpectation{}
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation.params != nil {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("RepositoryMock.DeleteAndCreateTextChunks mock is already set by Expect")
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateTextChunks.defaultExpectation.paramPtrs = &RepositoryMockDeleteAndCreateTextChunksParamPtrs{}
	}
	mmDeleteAndCreateTextChunks.defaultExpectation.paramPtrs.textChunks = &textChunks
	mmDeleteAndCreateTextChunks.defaultExpectation.expectationOrigins.originTextChunks = minimock.CallerInfo(1)

	return mmDeleteAndCreateTextChunks
}

// ExpectExternalServiceCallParam4 sets up expected param externalServiceCall for Repository.DeleteAndCreateTextChunks
func (mmDeleteAndCreateTextChunks *mRepositoryMockDeleteAndCreateTextChunks) ExpectExternalServiceCallParam4(externalServiceCall func(chunkUIDs []string) (destinations map[string]string, _ error)) *mRepositoryMockDeleteAndCreateTextChunks {
	if mmDeleteAndCreateTextChunks.mock.funcDeleteAndCreateTextChunks != nil {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("RepositoryMock.DeleteAndCreateTextChunks mock is already set by Set")
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation == nil {
		mmDeleteAndCreateTextChunks.defaultExpectation = &RepositoryMockDeleteAndCreateTextChunksExpectation{}
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation.params != nil {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("RepositoryMock.DeleteAndCreateTextChunks mock is already set by Expect")
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateTextChunks.defaultExpectation.paramPtrs = &RepositoryMockDeleteAndCreateTextChunksParamPtrs{}
	}
	mmDeleteAndCreateTextChunks.defaultExpectation.paramPtrs.externalServiceCall = &externalServiceCall
	mmDeleteAndCreateTextChunks.defaultExpectation.expectationOrigins.originExternalServiceCall = minimock.CallerInfo(1)

	return mmDeleteAndCreateTextChunks
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteAndCreateTextChunks
func (mmDeleteAndCreateTextChunks *mRepositoryMockDeleteAndCreateTextChunks) Inspect(f func(ctx context.Context, fileUID types.FileUIDType, textChunks []*mm_repository.TextChunkModel, externalServiceCall func(chunkUIDs []string) (destinations map[string]string, _ error))) *mRepositoryMockDeleteAndCreateTextChunks {
	if mmDeleteAndCreateTextChunks.mock.inspectFuncDeleteAndCreateTextChunks != nil {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteAndCreateTextChunks")
	}

	mmDeleteAndCreateTextChunks.mock.inspectFuncDeleteAndCreateTextChunks = f

	return mmDeleteAndCreateTextChunks
}

// Return sets up results that will be returned by Repository.DeleteAndCreateTextChunks
func (mmDeleteAndCreateTextChunks *mRepositoryMockDeleteAndCreateTextChunks) Return(tpa1 []*mm_repository.TextChunkModel, err error) *RepositoryMock {
	if mmDeleteAndCreateTextChunks.mock.funcDeleteAndCreateTextChunks != nil {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("RepositoryMock.DeleteAndCreateTextChunks mock is already set by Set")
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation == nil {
		mmDeleteAndCreateTextChunks.defaultExpectation = &RepositoryMockDeleteAndCreateTextChunksExpectation{mock: mmDeleteAndCreateTextChunks.mock}
	}
	mmDeleteAndCreateTextChunks.defaultExpectation.results = &RepositoryMockDeleteAndCreateTextChunksResults{tpa1, err}
	mmDeleteAndCreateTextChunks.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteAndCreateTextChunks.mock
}

// Set uses given function f to mock the Repository.DeleteAndCreateTextChunks method
func (mmDeleteAndCreateTextChunks *mRepositoryMockDeleteAndCreateTextChunks) Set(f func(ctx context.Context, fileUID types.FileUIDType, textChunks []*mm_repository.TextChunkModel, externalServiceCall func(chunkUIDs []string) (destinations map[string]string, _ error)) (tpa1 []*mm_repository.TextChunkModel, err error)) *RepositoryMock {
	if mmDeleteAndCreateTextChunks.defaultExpectation != nil {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteAndCreateTextChunks method")
	}

	if len(mmDeleteAndCreateTextChunks.expectations) > 0 {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteAndCreateTextChunks method")
	}

	mmDeleteAndCreateTextChunks.mock.funcDeleteAndCreateTextChunks = f
	mmDeleteAndCreateTextChunks.mock.funcDeleteAndCreateTextChunksOrigin = minimock.CallerInfo(1)
	return mmDeleteAndCreateTextChunks.mock
}

// When sets expectation for the Repository.DeleteAndCreateTextChunks which will trigger the result defined by the following
// Then helper
func (mmDeleteAndCreateTextChunks *mRepositoryMockDeleteAndCreateTextChunks) When(ctx context.Context, fileUID types.FileUIDType, textChunks []*mm_repository.TextChunkModel, externalServiceCall func(chunkUIDs []string) (destinations map[string]string, _ error)) *RepositoryMockDeleteAndCreateTextChunksExpectation {
	if mmDeleteAndCreateTextChunks.mock.funcDeleteAndCreateTextChunks != nil {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("RepositoryMock.DeleteAndCreateTextChunks mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteAndCreateTextChunksExpectation{
		mock:               mmDeleteAndCreateTextChunks.mock,
		params:             &RepositoryMockDeleteAndCreateTextChunksParams{ctx, fileUID, textChunks, externalServiceCall},
		expectationOrigins: RepositoryMockDeleteAndCreateTextChunksExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteAndCreateTextChunks.expectations = append(mmDeleteAndCreateTextChunks.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteAndCreateTextChunks return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteAndCreateTextChunksExpectation) Then(tpa1 []*mm_repository.TextChunkModel, err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteAndCreateTextChunksResults{tpa1, err}
	return e.mock
}

// Times sets number of times Repository.DeleteAndCreateTextChunks should be invoked
func (mmDeleteAndCreateTextChunks *mRepositoryMockDeleteAndCreateTextChunks) Times(n uint64) *mRepositoryMockDeleteAndCreateTextChunks {
	if n == 0 {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("Times of RepositoryMock.DeleteAndCreateTextChunks mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteAndCreateTextChunks.expectedInvocations, n)
	mmDeleteAndCreateTextChunks.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteAndCreateTextChunks
}

func (mmDeleteAndCreateTextChunks *mRepositoryMockDeleteAndCreateTextChunks) invocationsDone() bool {
	if len(mmDeleteAndCreateTextChunks.expectations) == 0 && mmDeleteAndCreateTextChunks.defaultExpectation == nil && mmDeleteAndCreateTextChunks.mock.funcDeleteAndCreateTextChunks == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteAndCreateTextChunks.mock.afterDeleteAndCreateTextChunksCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteAndCreateTextChunks.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteAndCreateTextChunks implements mm_repository.Repository
func (mmDeleteAndCreateTextChunks *RepositoryMock) DeleteAndCreateTextChunks(ctx context.Context, fileUID types.FileUIDType, textChunks []*mm_repository.TextChunkModel, externalServiceCall func(chunkUIDs []string) (destinations map[string]string, _ error)) (tpa1 []*mm_repository.TextChunkModel, err error) {
	mm_atomic.AddUint64(&mmDeleteAndCreateTextChunks.beforeDeleteAndCreateTextChunksCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteAndCreateTextChunks.afterDeleteAndCreateTextChunksCounter, 1)

	mmDeleteAndCreateTextChunks.t.Helper()

	if mmDeleteAndCreateTextChunks.inspectFuncDeleteAndCreateTextChunks != nil {
		mmDeleteAndCreateTextChunks.inspectFuncDeleteAndCreateTextChunks(ctx, fileUID, textChunks, externalServiceCall)
	}

	mm_params := RepositoryMockDeleteAndCreateTextChunksParams{ctx, fileUID, textChunks, externalServiceCall}

	// Record call args
	mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.mutex.Lock()
	mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.callArgs = append(mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.callArgs, &mm_params)
	mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.mutex.Unlock()

	for _, e := range mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tpa1, e.results.err
		}
	}

	if mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteAndCreateTextChunksParams{ctx, fileUID, textChunks, externalServiceCall}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteAndCreateTextChunks.t.Errorf("RepositoryMock.DeleteAndCreateTextChunks got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmDeleteAndCreateTextChunks.t.Errorf("RepositoryMock.DeleteAndCreateTextChunks got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

			if mm_want_ptrs.textChunks != nil && !minimock.Equal(*mm_want_ptrs.textChunks, mm_got.textChunks) {
				mmDeleteAndCreateTextChunks.t.Errorf("RepositoryMock.DeleteAndCreateTextChunks got unexpected parameter textChunks, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.defaultExpectation.expectationOrigins.originTextChunks, *mm_want_ptrs.textChunks, mm_got.textChunks, minimock.Diff(*mm_want_ptrs.textChunks, mm_got.textChunks))
			}

			if mm_want_ptrs.externalServiceCall != nil && !minimock.Equal(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall) {
				mmDeleteAndCreateTextChunks.t.Errorf("RepositoryMock.DeleteAndCreateTextChunks got unexpected parameter externalServiceCall, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.defaultExpectation.expectationOrigins.originExternalServiceCall, *mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall, minimock.Diff(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteAndCreateTextChunks.t.Errorf("RepositoryMock.DeleteAndCreateTextChunks got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteAndCreateTextChunks.t.Fatal("No results are set for the RepositoryMock.DeleteAndCreateTextChunks")
		}
		return (*mm_results).tpa1, (*mm_results).err
	}
	if mmDeleteAndCreateTextChunks.funcDeleteAndCreateTextChunks != nil {
		return mmDeleteAndCreateTextChunks.funcDeleteAndCreateTextChunks(ctx, fileUID, textChunks, externalServiceCall)
	}
	mmDeleteAndCreateTextChunks.t.Fatalf("Unexpected call to RepositoryMock.DeleteAndCreateTextChunks. %v %v %v %v", ctx, fileUID, textChunks, externalServiceCall)
	return
}

// DeleteAndCreateTextChunksAfterCounter returns a count of finished RepositoryMock.DeleteAndCreateTextChunks invocations
func (mmDeleteAndCreateTextChunks *RepositoryMock) DeleteAndCreateTextChunksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAndCreateTextChunks.afterDeleteAndCreateTextChunksCounter)
}

// DeleteAndCreateTextChunksBeforeCounter returns a count of RepositoryMock.DeleteAndCreateTextChunks invocations
func (mmDeleteAndCreateTextChunks *RepositoryMock) DeleteAndCreateTextChunksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAndCreateTextChunks.beforeDeleteAndCreateTextChunksCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteAndCreateTextChunks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteAndCreateTextChunks *mRepositoryMockDeleteAndCreateTextChunks) Calls() []*RepositoryMockDeleteAndCreateTextChunksParams {
	mmDeleteAndCreateTextChunks.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteAndCreateTextChunksParams, len(mmDeleteAndCreateTextChunks.callArgs))
	copy(argCopy, mmDeleteAndCreateTextChunks.callArgs)

	mmDeleteAndCreateTextChunks.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteAndCreateTextChunksDone returns true if the count of the DeleteAndCreateTextChunks invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteAndCreateTextChunksDone() bool {
	if m.DeleteAndCreateTextChunksMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteAndCreateTextChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteAndCreateTextChunksMock.invocationsDone()
}

// MinimockDeleteAndCreateTextChunksInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteAndCreateTextChunksInspect() {
	for _, e := range m.DeleteAndCreateTextChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteAndCreateTextChunks at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteAndCreateTextChunksCounter := mm_atomic.LoadUint64(&m.afterDeleteAndCreateTextChunksCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteAndCreateTextChunksMock.defaultExpectation != nil && afterDeleteAndCreateTextChunksCounter < 1 {
		if m.DeleteAndCreateTextChunksMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteAndCreateTextChunks at\n%s", m.DeleteAndCreateTextChunksMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteAndCreateTextChunks at\n%s with params: %#v", m.DeleteAndCreateTextChunksMock.defaultExpectation.expectationOrigins.origin, *m.DeleteAndCreateTextChunksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteAndCreateTextChunks != nil && afterDeleteAndCreateTextChunksCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteAndCreateTextChunks at\n%s", m.funcDeleteAndCreateTextChunksOrigin)
	}

	if !m.DeleteAndCreateTextChunksMock.invocationsDone() && afterDeleteAndCreateTextChunksCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteAndCreateTextChunks at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteAndCreateTextChunksMock.expectedInvocations), m.DeleteAndCreateTextChunksMock.expectedInvocationsOrigin, afterDeleteAndCreateTextChunksCounter)
	}
}

type mRepositoryMockDeleteCacheMetadata struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteCacheMetadataExpectation
	expectations       []*RepositoryMockDeleteCacheMetadataExpectation

	callArgs []*RepositoryMockDeleteCacheMetadataParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteCacheMetadataExpectation specifies expectation struct of the Repository.DeleteCacheMetadata
type RepositoryMockDeleteCacheMetadataExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteCacheMetadataParams
	paramPtrs          *RepositoryMockDeleteCacheMetadataParamPtrs
	expectationOrigins RepositoryMockDeleteCacheMetadataExpectationOrigins
	results            *RepositoryMockDeleteCacheMetadataResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteCacheMetadataParams contains parameters of the Repository.DeleteCacheMetadata
type RepositoryMockDeleteCacheMetadataParams struct {
	ctx      context.Context
	kbUID    types.KBUIDType
	fileUIDs []types.FileUIDType
}

// RepositoryMockDeleteCacheMetadataParamPtrs contains pointers to parameters of the Repository.DeleteCacheMetadata
type RepositoryMockDeleteCacheMetadataParamPtrs struct {
	ctx      *context.Context
	kbUID    *types.KBUIDType
	fileUIDs *[]types.FileUIDType
}

// RepositoryMockDeleteCacheMetadataResults contains results of the Repository.DeleteCacheMetadata
type RepositoryMockDeleteCacheMetadataResults struct {
	err error
}

// RepositoryMockDeleteCacheMetadataOrigins contains origins of expectations of the Repository.DeleteCacheMetadata
type RepositoryMockDeleteCacheMetadataExpectationOrigins struct {
	origin         string
	originCtx      string
	originKbUID    string
	originFileUIDs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteCacheMetadata *mRepositoryMockDeleteCacheMetadata) Optional() *mRepositoryMockDeleteCacheMetadata {
	mmDeleteCacheMetadata.optional = true
	return mmDeleteCacheMetadata
}

// Expect sets up expected params for Repository.DeleteCacheMetadata
func (mmDeleteCacheMetadata *mRepositoryMockDeleteCacheMetadata) Expect(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType) *mRepositoryMockDeleteCacheMetadata {
	if mmDeleteCacheMetadata.mock.funcDeleteCacheMetadata != nil {
		mmDeleteCacheMetadata.mock.t.Fatalf("RepositoryMock.DeleteCacheMetadata mock is already set by Set")
	}

	if mmDeleteCacheMetadata.defaultExpectation == nil {
		mmDeleteCacheMetadata.defaultExpectation = &RepositoryMockDeleteCacheMetadataExpectation{}
	}

	if mmDeleteCacheMetadata.defaultExpectation.paramPtrs != nil {
		mmDeleteCacheMetadata.mock.t.Fatalf("RepositoryMock.DeleteCacheMetadata mock is already set by ExpectParams functions")
	}

	mmDeleteCacheMetadata.defaultExpectation.params = &RepositoryMockDeleteCacheMetadataParams{ctx, kbUID, fileUIDs}
	mmDeleteCacheMetadata.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteCacheMetadata.expectations {
		if minimock.Equal(e.params, mmDeleteCacheMetadata.defaultExpectation.params) {
			mmDeleteCacheMetadata.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteCacheMetadata.defaultExpectation.params)
		}
	}

	return mmDeleteCacheMetadata
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteCacheMetadata
func (mmDeleteCacheMetadata *mRepositoryMockDeleteCacheMetadata) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteCacheMetadata {
	if mmDeleteCacheMetadata.mock.funcDeleteCacheMetadata != nil {
		mmDeleteCacheMetadata.mock.t.Fatalf("RepositoryMock.DeleteCacheMetadata mock is already set by Set")
	}

	if mmDeleteCacheMetadata.defaultExpectation == nil {
		mmDeleteCacheMetadata.defaultExpectation = &RepositoryMockDeleteCacheMetadataExpectation{}
	}

	if mmDeleteCacheMetadata.defaultExpectation.params != nil {
		mmDeleteCacheMetadata.mock.t.Fatalf("RepositoryMock.DeleteCacheMetadata mock is already set by Expect")
	}

	if mmDeleteCacheMetadata.defaultExpectation.paramPtrs == nil {
		mmDeleteCacheMetadata.defaultExpectation.paramPtrs = &RepositoryMockDeleteCacheMetadataParamPtrs{}
	}
	mmDeleteCacheMetadata.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteCacheMetadata.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteCacheMetadata
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.DeleteCacheMetadata
func (mmDeleteCacheMetadata *mRepositoryMockDeleteCacheMetadata) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockDeleteCacheMetadata {
	if mmDeleteCacheMetadata.mock.funcDeleteCacheMetadata != nil {
		mmDeleteCacheMetadata.mock.t.Fatalf("RepositoryMock.DeleteCacheMetadata mock is already set by Set")
	}

	if mmDeleteCacheMetadata.defaultExpectation == nil {
		mmDeleteCacheMetadata.defaultExpectation = &RepositoryMockDeleteCacheMetadataExpectation{}
	}

	if mmDeleteCacheMetadata.defaultExpectation.params != nil {
		mmDeleteCacheMetadata.mock.t.Fatalf("RepositoryMock.DeleteCacheMetadata mock is already set by Expect")
	}

	if mmDeleteCacheMetadata.defaultExpectation.paramPtrs == nil {
		mmDeleteCacheMetadata.defaultExpectation.paramPtrs = &RepositoryMockDeleteCacheMetadataParamPtrs{}
	}
	mmDeleteCacheMetadata.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmDeleteCacheMetadata.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmDeleteCacheMetadata
}

// ExpectFileUIDsParam3 sets up expected param fileUIDs for Repository.DeleteCacheMetadata
func (mmDeleteCacheMetadata *mRepositoryMockDeleteCacheMetadata) ExpectFileUIDsParam3(fileUIDs []types.FileUIDType) *mRepositoryMockDeleteCacheMetadata {
	if mmDeleteCacheMetadata.mock.funcDeleteCacheMetadata != nil {
		mmDeleteCacheMetadata.mock.t.Fatalf("RepositoryMock.DeleteCacheMetadata mock is already set by Set")
	}

	if mmDeleteCacheMetadata.defaultExpectation == nil {
		mmDeleteCacheMetadata.defaultExpectation = &RepositoryMockDeleteCacheMetadataExpectation{}
	}

	if mmDeleteCacheMetadata.defaultExpectation.params != nil {
		mmDeleteCacheMetadata.mock.t.Fatalf("RepositoryMock.DeleteCacheMetadata mock is already set by Expect")
	}

	if mmDeleteCacheMetadata.defaultExpectation.paramPtrs == nil {
		mmDeleteCacheMetadata.defaultExpectation.paramPtrs = &RepositoryMockDeleteCacheMetadataParamPtrs{}
	}
	mmDeleteCacheMetadata.defaultExpectation.paramPtrs.fileUIDs = &fileUIDs
	mmDeleteCacheMetadata.defaultExpectation.expectationOrigins.originFileUIDs = minimock.CallerInfo(1)

	return mmDeleteCacheMetadata
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteCacheMetadata
func (mmDeleteCacheMetadata *mRepositoryMockDeleteCacheMetadata) Inspect(f func(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType)) *mRepositoryMockDeleteCacheMetadata {
	if mmDeleteCacheMetadata.mock.inspectFuncDeleteCacheMetadata != nil {
		mmDeleteCacheMetadata.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteCacheMetadata")
	}

	mmDeleteCacheMetadata.mock.inspectFuncDeleteCacheMetadata = f

	return mmDeleteCacheMetadata
}

// Return sets up results that will be returned by Repository.DeleteCacheMetadata
func (mmDeleteCacheMetadata *mRepositoryMockDeleteCacheMetadata) Return(err error) *RepositoryMock {
	if mmDeleteCacheMetadata.mock.funcDeleteCacheMetadata != nil {
		mmDeleteCacheMetadata.mock.t.Fatalf("RepositoryMock.DeleteCacheMetadata mock is already set by Set")
	}

	if mmDeleteCacheMetadata.defaultExpectation == nil {
		mmDeleteCacheMetadata.defaultExpectation = &RepositoryMockDeleteCacheMetadataExpectation{mock: mmDeleteCacheMetadata.mock}
	}
	mmDeleteCacheMetadata.defaultExpectation.results = &RepositoryMockDeleteCacheMetadataResults{err}
	mmDeleteCacheMetadata.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteCacheMetadata.mock
}

// Set uses given function f to mock the Repository.DeleteCacheMetadata method
func (mmDeleteCacheMetadata *mRepositoryMockDeleteCacheMetadata) Set(f func(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType) (err error)) *RepositoryMock {
	if mmDeleteCacheMetadata.defaultExpectation != nil {
		mmDeleteCacheMetadata.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteCacheMetadata method")
	}

	if len(mmDeleteCacheMetadata.expectations) > 0 {
		mmDeleteCacheMetadata.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteCacheMetadata method")
	}

	mmDeleteCacheMetadata.mock.funcDeleteCacheMetadata = f
	mmDeleteCacheMetadata.mock.funcDeleteCacheMetadataOrigin = minimock.CallerInfo(1)
	return mmDeleteCacheMetadata.mock
}

// When sets expectation for the Repository.DeleteCacheMetadata which will trigger the result defined by the following
// Then helper
func (mmDeleteCacheMetadata *mRepositoryMockDeleteCacheMetadata) When(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType) *RepositoryMockDeleteCacheMetadataExpectation {
	if mmDeleteCacheMetadata.mock.funcDeleteCacheMetadata != nil {
		mmDeleteCacheMetadata.mock.t.Fatalf("RepositoryMock.DeleteCacheMetadata mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteCacheMetadataExpectation{
		mock:               mmDeleteCacheMetadata.mock,
		params:             &RepositoryMockDeleteCacheMetadataParams{ctx, kbUID, fileUIDs},
		expectationOrigins: RepositoryMockDeleteCacheMetadataExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteCacheMetadata.expectations = append(mmDeleteCacheMetadata.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteCacheMetadata return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteCacheMetadataExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteCacheMetadataResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteCacheMetadata should be invoked
func (mmDeleteCacheMetadata *mRepositoryMockDeleteCacheMetadata) Times(n uint64) *mRepositoryMockDeleteCacheMetadata {
	if n == 0 {
		mmDeleteCacheMetadata.mock.t.Fatalf("Times of RepositoryMock.DeleteCacheMetadata mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteCacheMetadata.expectedInvocations, n)
	mmDeleteCacheMetadata.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteCacheMetadata
}

func (mmDeleteCacheMetadata *mRepositoryMockDeleteCacheMetadata) invocationsDone() bool {
	if len(mmDeleteCacheMetadata.expectations) == 0 && mmDeleteCacheMetadata.defaultExpectation == nil && mmDeleteCacheMetadata.mock.funcDeleteCacheMetadata == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteCacheMetadata.mock.afterDeleteCacheMetadataCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteCacheMetadata.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteCacheMetadata implements mm_repository.Repository
func (mmDeleteCacheMetadata *RepositoryMock) DeleteCacheMetadata(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType) (err error) {
	mm_atomic.AddUint64(&mmDeleteCacheMetadata.beforeDeleteCacheMetadataCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteCacheMetadata.afterDeleteCacheMetadataCounter, 1)

	mmDeleteCacheMetadata.t.Helper()

	if mmDeleteCacheMetadata.inspectFuncDeleteCacheMetadata != nil {
		mmDeleteCacheMetadata.inspectFuncDeleteCacheMetadata(ctx, kbUID, fileUIDs)
	}

	mm_params := RepositoryMockDeleteCacheMetadataParams{ctx, kbUID, fileUIDs}

	// Record call args
	mmDeleteCacheMetadata.DeleteCacheMetadataMock.mutex.Lock()
	mmDeleteCacheMetadata.DeleteCacheMetadataMock.callArgs = append(mmDeleteCacheMetadata.DeleteCacheMetadataMock.callArgs, &mm_params)
	mmDeleteCacheMetadata.DeleteCacheMetadataMock.mutex.Unlock()

	for _, e := range mmDeleteCacheMetadata.DeleteCacheMetadataMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteCacheMetadata.DeleteCacheMetadataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteCacheMetadata.DeleteCacheMetadataMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteCacheMetadata.DeleteCacheMetadataMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteCacheMetadata.DeleteCacheMetadataMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteCacheMetadataParams{ctx, kbUID, fileUIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteCacheMetadata.t.Errorf("RepositoryMock.DeleteCacheMetadata got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCacheMetadata.DeleteCacheMetadataMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmDeleteCacheMetadata.t.Errorf("RepositoryMock.DeleteCacheMetadata got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCacheMetadata.DeleteCacheMetadataMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.fileUIDs != nil && !minimock.Equal(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs) {
				mmDeleteCacheMetadata.t.Errorf("RepositoryMock.DeleteCacheMetadata got unexpected parameter fileUIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCacheMetadata.DeleteCacheMetadataMock.defaultExpectation.expectationOrigins.originFileUIDs, *mm_want_ptrs.fileUIDs, mm_got.fileUIDs, minimock.Diff(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteCacheMetadata.t.Errorf("RepositoryMock.DeleteCacheMetadata got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteCacheMetadata.DeleteCacheMetadataMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteCacheMetadata.DeleteCacheMetadataMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteCacheMetadata.t.Fatal("No results are set for the RepositoryMock.DeleteCacheMetadata")
		}
		return (*mm_results).err
	}
	if mmDeleteCacheMetadata.funcDeleteCacheMetadata != nil {
		return mmDeleteCacheMetadata.funcDeleteCacheMetadata(ctx, kbUID, fileUIDs)
	}
	mmDeleteCacheMetadata.t.Fatalf("Unexpected call to RepositoryMock.DeleteCacheMetadata. %v %v %v", ctx, kbUID, fileUIDs)
	return
}

// DeleteCacheMetadataAfterCounter returns a count of finished RepositoryMock.DeleteCacheMetadata invocations
func (mmDeleteCacheMetadata *RepositoryMock) DeleteCacheMetadataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCacheMetadata.afterDeleteCacheMetadataCounter)
}

// DeleteCacheMetadataBeforeCounter returns a count of RepositoryMock.DeleteCacheMetadata invocations
func (mmDeleteCacheMetadata *RepositoryMock) DeleteCacheMetadataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCacheMetadata.beforeDeleteCacheMetadataCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteCacheMetadata.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteCacheMetadata *mRepositoryMockDeleteCacheMetadata) Calls() []*RepositoryMockDeleteCacheMetadataParams {
	mmDeleteCacheMetadata.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteCacheMetadataParams, len(mmDeleteCacheMetadata.callArgs))
	copy(argCopy, mmDeleteCacheMetadata.callArgs)

	mmDeleteCacheMetadata.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCacheMetadataDone returns true if the count of the DeleteCacheMetadata invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteCacheMetadataDone() bool {
	if m.DeleteCacheMetadataMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteCacheMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteCacheMetadataMock.invocationsDone()
}

// MinimockDeleteCacheMetadataInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteCacheMetadataInspect() {
	for _, e := range m.DeleteCacheMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteCacheMetadata at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCacheMetadataCounter := mm_atomic.LoadUint64(&m.afterDeleteCacheMetadataCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCacheMetadataMock.defaultExpectation != nil && afterDeleteCacheMetadataCounter < 1 {
		if m.DeleteCacheMetadataMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteCacheMetadata at\n%s", m.DeleteCacheMetadataMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteCacheMetadata at\n%s with params: %#v", m.DeleteCacheMetadataMock.defaultExpectation.expectationOrigins.origin, *m.DeleteCacheMetadataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCacheMetadata != nil && afterDeleteCacheMetadataCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteCacheMetadata at\n%s", m.funcDeleteCacheMetadataOrigin)
	}

	if !m.DeleteCacheMetadataMock.invocationsDone() && afterDeleteCacheMetadataCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteCacheMetadata at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteCacheMetadataMock.expectedInvocations), m.DeleteCacheMetadataMock.expectedInvocationsOrigin, afterDeleteCacheMetadataCounter)
	}
}

type mRepositoryMockDeleteConvertedFile struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteConvertedFileExpectation
	expectations       []*RepositoryMockDeleteConvertedFileExpectation

	callArgs []*RepositoryMockDeleteConvertedFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteConvertedFileExpectation specifies expectation struct of the Repository.DeleteConvertedFile
type RepositoryMockDeleteConvertedFileExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteConvertedFileParams
	paramPtrs          *RepositoryMockDeleteConvertedFileParamPtrs
	expectationOrigins RepositoryMockDeleteConvertedFileExpectationOrigins
	results            *RepositoryMockDeleteConvertedFileResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteConvertedFileParams contains parameters of the Repository.DeleteConvertedFile
type RepositoryMockDeleteConvertedFileParams struct {
	ctx context.Context
	uid types.ConvertedFileUIDType
}

// RepositoryMockDeleteConvertedFileParamPtrs contains pointers to parameters of the Repository.DeleteConvertedFile
type RepositoryMockDeleteConvertedFileParamPtrs struct {
	ctx *context.Context
	uid *types.ConvertedFileUIDType
}

// RepositoryMockDeleteConvertedFileResults contains results of the Repository.DeleteConvertedFile
type RepositoryMockDeleteConvertedFileResults struct {
	err error
}

// RepositoryMockDeleteConvertedFileOrigins contains origins of expectations of the Repository.DeleteConvertedFile
type RepositoryMockDeleteConvertedFileExpectationOrigins struct {
	origin    string
	originCtx string
	originUid string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteConvertedFile *mRepositoryMockDeleteConvertedFile) Optional() *mRepositoryMockDeleteConvertedFile {
	mmDeleteConvertedFile.optional = true
	return mmDeleteConvertedFile
}

// Expect sets up expected params for Repository.DeleteConvertedFile
func (mmDeleteConvertedFile *mRepositoryMockDeleteConvertedFile) Expect(ctx context.Context, uid types.ConvertedFileUIDType) *mRepositoryMockDeleteConvertedFile {
	if mmDeleteConvertedFile.mock.funcDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryMock.DeleteConvertedFile mock is already set by Set")
	}

	if mmDeleteConvertedFile.defaultExpectation == nil {
		mmDeleteConvertedFile.defaultExpectation = &RepositoryMockDeleteConvertedFileExpectation{}
	}

	if mmDeleteConvertedFile.defaultExpectation.paramPtrs != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryMock.DeleteConvertedFile mock is already set by ExpectParams functions")
	}

	mmDeleteConvertedFile.defaultExpectation.params = &RepositoryMockDeleteConvertedFileParams{ctx, uid}
	mmDeleteConvertedFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteConvertedFile.expectations {
		if minimock.Equal(e.params, mmDeleteConvertedFile.defaultExpectation.params) {
			mmDeleteConvertedFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteConvertedFile.defaultExpectation.params)
		}
	}

	return mmDeleteConvertedFile
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteConvertedFile
func (mmDeleteConvertedFile *mRepositoryMockDeleteConvertedFile) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteConvertedFile {
	if mmDeleteConvertedFile.mock.funcDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryMock.DeleteConvertedFile mock is already set by Set")
	}

	if mmDeleteConvertedFile.defaultExpectation == nil {
		mmDeleteConvertedFile.defaultExpectation = &RepositoryMockDeleteConvertedFileExpectation{}
	}

	if mmDeleteConvertedFile.defaultExpectation.params != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryMock.DeleteConvertedFile mock is already set by Expect")
	}

	if mmDeleteConvertedFile.defaultExpectation.paramPtrs == nil {
		mmDeleteConvertedFile.defaultExpectation.paramPtrs = &RepositoryMockDeleteConvertedFileParamPtrs{}
	}
	mmDeleteConvertedFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteConvertedFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteConvertedFile
}

// ExpectUidParam2 sets up expected param uid for Repository.DeleteConvertedFile
func (mmDeleteConvertedFile *mRepositoryMockDeleteConvertedFile) ExpectUidParam2(uid types.ConvertedFileUIDType) *mRepositoryMockDeleteConvertedFile {
	if mmDeleteConvertedFile.mock.funcDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryMock.DeleteConvertedFile mock is already set by Set")
	}

	if mmDeleteConvertedFile.defaultExpectation == nil {
		mmDeleteConvertedFile.defaultExpectation = &RepositoryMockDeleteConvertedFileExpectation{}
	}

	if mmDeleteConvertedFile.defaultExpectation.params != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryMock.DeleteConvertedFile mock is already set by Expect")
	}

	if mmDeleteConvertedFile.defaultExpectation.paramPtrs == nil {
		mmDeleteConvertedFile.defaultExpectation.paramPtrs = &RepositoryMockDeleteConvertedFileParamPtrs{}
	}
	mmDeleteConvertedFile.defaultExpectation.paramPtrs.uid = &uid
	mmDeleteConvertedFile.defaultExpectation.expectationOrigins.originUid = minimock.CallerInfo(1)

	return mmDeleteConvertedFile
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteConvertedFile
func (mmDeleteConvertedFile *mRepositoryMockDeleteConvertedFile) Inspect(f func(ctx context.Context, uid types.ConvertedFileUIDType)) *mRepositoryMockDeleteConvertedFile {
	if mmDeleteConvertedFile.mock.inspectFuncDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteConvertedFile")
	}

	mmDeleteConvertedFile.mock.inspectFuncDeleteConvertedFile = f

	return mmDeleteConvertedFile
}

// Return sets up results that will be returned by Repository.DeleteConvertedFile
func (mmDeleteConvertedFile *mRepositoryMockDeleteConvertedFile) Return(err error) *RepositoryMock {
	if mmDeleteConvertedFile.mock.funcDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryMock.DeleteConvertedFile mock is already set by Set")
	}

	if mmDeleteConvertedFile.defaultExpectation == nil {
		mmDeleteConvertedFile.defaultExpectation = &RepositoryMockDeleteConvertedFileExpectation{mock: mmDeleteConvertedFile.mock}
	}
	mmDeleteConvertedFile.defaultExpectation.results = &RepositoryMockDeleteConvertedFileResults{err}
	mmDeleteConvertedFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteConvertedFile.mock
}

// Set uses given function f to mock the Repository.DeleteConvertedFile method
func (mmDeleteConvertedFile *mRepositoryMockDeleteConvertedFile) Set(f func(ctx context.Context, uid types.ConvertedFileUIDType) (err error)) *RepositoryMock {
	if mmDeleteConvertedFile.defaultExpectation != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteConvertedFile method")
	}

	if len(mmDeleteConvertedFile.expectations) > 0 {
		mmDeleteConvertedFile.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteConvertedFile method")
	}

	mmDeleteConvertedFile.mock.funcDeleteConvertedFile = f
	mmDeleteConvertedFile.mock.funcDeleteConvertedFileOrigin = minimock.CallerInfo(1)
	return mmDeleteConvertedFile.mock
}

// When sets expectation for the Repository.DeleteConvertedFile which will trigger the result defined by the following
// Then helper
func (mmDeleteConvertedFile *mRepositoryMockDeleteConvertedFile) When(ctx context.Context, uid types.ConvertedFileUIDType) *RepositoryMockDeleteConvertedFileExpectation {
	if mmDeleteConvertedFile.mock.funcDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryMock.DeleteConvertedFile mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteConvertedFileExpectation{
		mock:               mmDeleteConvertedFile.mock,
		params:             &RepositoryMockDeleteConvertedFileParams{ctx, uid},
		expectationOrigins: RepositoryMockDeleteConvertedFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteConvertedFile.expectations = append(mmDeleteConvertedFile.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteConvertedFile return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteConvertedFileExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteConvertedFileResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteConvertedFile should be invoked
func (mmDeleteConvertedFile *mRepositoryMockDeleteConvertedFile) Times(n uint64) *mRepositoryMockDeleteConvertedFile {
	if n == 0 {
		mmDeleteConvertedFile.mock.t.Fatalf("Times of RepositoryMock.DeleteConvertedFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteConvertedFile.expectedInvocations, n)
	mmDeleteConvertedFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteConvertedFile
}

func (mmDeleteConvertedFile *mRepositoryMockDeleteConvertedFile) invocationsDone() bool {
	if len(mmDeleteConvertedFile.expectations) == 0 && mmDeleteConvertedFile.defaultExpectation == nil && mmDeleteConvertedFile.mock.funcDeleteConvertedFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteConvertedFile.mock.afterDeleteConvertedFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteConvertedFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteConvertedFile implements mm_repository.Repository
func (mmDeleteConvertedFile *RepositoryMock) DeleteConvertedFile(ctx context.Context, uid types.ConvertedFileUIDType) (err error) {
	mm_atomic.AddUint64(&mmDeleteConvertedFile.beforeDeleteConvertedFileCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteConvertedFile.afterDeleteConvertedFileCounter, 1)

	mmDeleteConvertedFile.t.Helper()

	if mmDeleteConvertedFile.inspectFuncDeleteConvertedFile != nil {
		mmDeleteConvertedFile.inspectFuncDeleteConvertedFile(ctx, uid)
	}

	mm_params := RepositoryMockDeleteConvertedFileParams{ctx, uid}

	// Record call args
	mmDeleteConvertedFile.DeleteConvertedFileMock.mutex.Lock()
	mmDeleteConvertedFile.DeleteConvertedFileMock.callArgs = append(mmDeleteConvertedFile.DeleteConvertedFileMock.callArgs, &mm_params)
	mmDeleteConvertedFile.DeleteConvertedFileMock.mutex.Unlock()

	for _, e := range mmDeleteConvertedFile.DeleteConvertedFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteConvertedFileParams{ctx, uid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteConvertedFile.t.Errorf("RepositoryMock.DeleteConvertedFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmDeleteConvertedFile.t.Errorf("RepositoryMock.DeleteConvertedFile got unexpected parameter uid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation.expectationOrigins.originUid, *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteConvertedFile.t.Errorf("RepositoryMock.DeleteConvertedFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteConvertedFile.t.Fatal("No results are set for the RepositoryMock.DeleteConvertedFile")
		}
		return (*mm_results).err
	}
	if mmDeleteConvertedFile.funcDeleteConvertedFile != nil {
		return mmDeleteConvertedFile.funcDeleteConvertedFile(ctx, uid)
	}
	mmDeleteConvertedFile.t.Fatalf("Unexpected call to RepositoryMock.DeleteConvertedFile. %v %v", ctx, uid)
	return
}

// DeleteConvertedFileAfterCounter returns a count of finished RepositoryMock.DeleteConvertedFile invocations
func (mmDeleteConvertedFile *RepositoryMock) DeleteConvertedFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteConvertedFile.afterDeleteConvertedFileCounter)
}

// DeleteConvertedFileBeforeCounter returns a count of RepositoryMock.DeleteConvertedFile invocations
func (mmDeleteConvertedFile *RepositoryMock) DeleteConvertedFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteConvertedFile.beforeDeleteConvertedFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteConvertedFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteConvertedFile *mRepositoryMockDeleteConvertedFile) Calls() []*RepositoryMockDeleteConvertedFileParams {
	mmDeleteConvertedFile.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteConvertedFileParams, len(mmDeleteConvertedFile.callArgs))
	copy(argCopy, mmDeleteConvertedFile.callArgs)

	mmDeleteConvertedFile.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteConvertedFileDone returns true if the count of the DeleteConvertedFile invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteConvertedFileDone() bool {
	if m.DeleteConvertedFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteConvertedFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteConvertedFileMock.invocationsDone()
}

// MinimockDeleteConvertedFileInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteConvertedFileInspect() {
	for _, e := range m.DeleteConvertedFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteConvertedFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteConvertedFileCounter := mm_atomic.LoadUint64(&m.afterDeleteConvertedFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteConvertedFileMock.defaultExpectation != nil && afterDeleteConvertedFileCounter < 1 {
		if m.DeleteConvertedFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteConvertedFile at\n%s", m.DeleteConvertedFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteConvertedFile at\n%s with params: %#v", m.DeleteConvertedFileMock.defaultExpectation.expectationOrigins.origin, *m.DeleteConvertedFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteConvertedFile != nil && afterDeleteConvertedFileCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteConvertedFile at\n%s", m.funcDeleteConvertedFileOrigin)
	}

	if !m.DeleteConvertedFileMock.invocationsDone() && afterDeleteConvertedFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteConvertedFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteConvertedFileMock.expectedInvocations), m.DeleteConvertedFileMock.expectedInvocationsOrigin, afterDeleteConvertedFileCounter)
	}
}

type mRepositoryMockDeleteEmbeddingsByKBFileUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteEmbeddingsByKBFileUIDExpectation
	expectations       []*RepositoryMockDeleteEmbeddingsByKBFileUIDExpectation

	callArgs []*RepositoryMockDeleteEmbeddingsByKBFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteEmbeddingsByKBFileUIDExpectation specifies expectation struct of the Repository.DeleteEmbeddingsByKBFileUID
type RepositoryMockDeleteEmbeddingsByKBFileUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteEmbeddingsByKBFileUIDParams
	paramPtrs          *RepositoryMockDeleteEmbeddingsByKBFileUIDParamPtrs
	expectationOrigins RepositoryMockDeleteEmbeddingsByKBFileUIDExpectationOrigins
	results            *RepositoryMockDeleteEmbeddingsByKBFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteEmbeddingsByKBFileUIDParams contains parameters of the Repository.DeleteEmbeddingsByKBFileUID
type RepositoryMockDeleteEmbeddingsByKBFileUIDParams struct {
	ctx       context.Context
	kbFileUID types.FileUIDType
}

// RepositoryMockDeleteEmbeddingsByKBFileUIDParamPtrs contains pointers to parameters of the Repository.DeleteEmbeddingsByKBFileUID
type RepositoryMockDeleteEmbeddingsByKBFileUIDParamPtrs struct {
	ctx       *context.Context
	kbFileUID *types.FileUIDType
}

// RepositoryMockDeleteEmbeddingsByKBFileUIDResults contains results of the Repository.DeleteEmbeddingsByKBFileUID
type RepositoryMockDeleteEmbeddingsByKBFileUIDResults struct {
	err error
}

// RepositoryMockDeleteEmbeddingsByKBFileUIDOrigins contains origins of expectations of the Repository.DeleteEmbeddingsByKBFileUID
type RepositoryMockDeleteEmbeddingsByKBFileUIDExpectationOrigins struct {
	origin          string
	originCtx       string
	originKbFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteEmbeddingsByKBFileUID *mRepositoryMockDeleteEmbeddingsByKBFileUID) Optional() *mRepositoryMockDeleteEmbeddingsByKBFileUID {
	mmDeleteEmbeddingsByKBFileUID.optional = true
	return mmDeleteEmbeddingsByKBFileUID
}

// Expect sets up expected params for Repository.DeleteEmbeddingsByKBFileUID
func (mmDeleteEmbeddingsByKBFileUID *mRepositoryMockDeleteEmbeddingsByKBFileUID) Expect(ctx context.Context, kbFileUID types.FileUIDType) *mRepositoryMockDeleteEmbeddingsByKBFileUID {
	if mmDeleteEmbeddingsByKBFileUID.mock.funcDeleteEmbeddingsByKBFileUID != nil {
		mmDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsByKBFileUID mock is already set by Set")
	}

	if mmDeleteEmbeddingsByKBFileUID.defaultExpectation == nil {
		mmDeleteEmbeddingsByKBFileUID.defaultExpectation = &RepositoryMockDeleteEmbeddingsByKBFileUIDExpectation{}
	}

	if mmDeleteEmbeddingsByKBFileUID.defaultExpectation.paramPtrs != nil {
		mmDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsByKBFileUID mock is already set by ExpectParams functions")
	}

	mmDeleteEmbeddingsByKBFileUID.defaultExpectation.params = &RepositoryMockDeleteEmbeddingsByKBFileUIDParams{ctx, kbFileUID}
	mmDeleteEmbeddingsByKBFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteEmbeddingsByKBFileUID.expectations {
		if minimock.Equal(e.params, mmDeleteEmbeddingsByKBFileUID.defaultExpectation.params) {
			mmDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteEmbeddingsByKBFileUID.defaultExpectation.params)
		}
	}

	return mmDeleteEmbeddingsByKBFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteEmbeddingsByKBFileUID
func (mmDeleteEmbeddingsByKBFileUID *mRepositoryMockDeleteEmbeddingsByKBFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteEmbeddingsByKBFileUID {
	if mmDeleteEmbeddingsByKBFileUID.mock.funcDeleteEmbeddingsByKBFileUID != nil {
		mmDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsByKBFileUID mock is already set by Set")
	}

	if mmDeleteEmbeddingsByKBFileUID.defaultExpectation == nil {
		mmDeleteEmbeddingsByKBFileUID.defaultExpectation = &RepositoryMockDeleteEmbeddingsByKBFileUIDExpectation{}
	}

	if mmDeleteEmbeddingsByKBFileUID.defaultExpectation.params != nil {
		mmDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsByKBFileUID mock is already set by Expect")
	}

	if mmDeleteEmbeddingsByKBFileUID.defaultExpectation.paramPtrs == nil {
		mmDeleteEmbeddingsByKBFileUID.defaultExpectation.paramPtrs = &RepositoryMockDeleteEmbeddingsByKBFileUIDParamPtrs{}
	}
	mmDeleteEmbeddingsByKBFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteEmbeddingsByKBFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteEmbeddingsByKBFileUID
}

// ExpectKbFileUIDParam2 sets up expected param kbFileUID for Repository.DeleteEmbeddingsByKBFileUID
func (mmDeleteEmbeddingsByKBFileUID *mRepositoryMockDeleteEmbeddingsByKBFileUID) ExpectKbFileUIDParam2(kbFileUID types.FileUIDType) *mRepositoryMockDeleteEmbeddingsByKBFileUID {
	if mmDeleteEmbeddingsByKBFileUID.mock.funcDeleteEmbeddingsByKBFileUID != nil {
		mmDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsByKBFileUID mock is already set by Set")
	}

	if mmDeleteEmbeddingsByKBFileUID.defaultExpectation == nil {
		mmDeleteEmbeddingsByKBFileUID.defaultExpectation = &RepositoryMockDeleteEmbeddingsByKBFileUIDExpectation{}
	}

	if mmDeleteEmbeddingsByKBFileUID.defaultExpectation.params != nil {
		mmDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsByKBFileUID mock is already set by Expect")
	}

	if mmDeleteEmbeddingsByKBFileUID.defaultExpectation.paramPtrs == nil {
		mmDeleteEmbeddingsByKBFileUID.defaultExpectation.paramPtrs = &RepositoryMockDeleteEmbeddingsByKBFileUIDParamPtrs{}
	}
	mmDeleteEmbeddingsByKBFileUID.defaultExpectation.paramPtrs.kbFileUID = &kbFileUID
	mmDeleteEmbeddingsByKBFileUID.defaultExpectation.expectationOrigins.originKbFileUID = minimock.CallerInfo(1)

	return mmDeleteEmbeddingsByKBFileUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteEmbeddingsByKBFileUID
func (mmDeleteEmbeddingsByKBFileUID *mRepositoryMockDeleteEmbeddingsByKBFileUID) Inspect(f func(ctx context.Context, kbFileUID types.FileUIDType)) *mRepositoryMockDeleteEmbeddingsByKBFileUID {
	if mmDeleteEmbeddingsByKBFileUID.mock.inspectFuncDeleteEmbeddingsByKBFileUID != nil {
		mmDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteEmbeddingsByKBFileUID")
	}

	mmDeleteEmbeddingsByKBFileUID.mock.inspectFuncDeleteEmbeddingsByKBFileUID = f

	return mmDeleteEmbeddingsByKBFileUID
}

// Return sets up results that will be returned by Repository.DeleteEmbeddingsByKBFileUID
func (mmDeleteEmbeddingsByKBFileUID *mRepositoryMockDeleteEmbeddingsByKBFileUID) Return(err error) *RepositoryMock {
	if mmDeleteEmbeddingsByKBFileUID.mock.funcDeleteEmbeddingsByKBFileUID != nil {
		mmDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsByKBFileUID mock is already set by Set")
	}

	if mmDeleteEmbeddingsByKBFileUID.defaultExpectation == nil {
		mmDeleteEmbeddingsByKBFileUID.defaultExpectation = &RepositoryMockDeleteEmbeddingsByKBFileUIDExpectation{mock: mmDeleteEmbeddingsByKBFileUID.mock}
	}
	mmDeleteEmbeddingsByKBFileUID.defaultExpectation.results = &RepositoryMockDeleteEmbeddingsByKBFileUIDResults{err}
	mmDeleteEmbeddingsByKBFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteEmbeddingsByKBFileUID.mock
}

// Set uses given function f to mock the Repository.DeleteEmbeddingsByKBFileUID method
func (mmDeleteEmbeddingsByKBFileUID *mRepositoryMockDeleteEmbeddingsByKBFileUID) Set(f func(ctx context.Context, kbFileUID types.FileUIDType) (err error)) *RepositoryMock {
	if mmDeleteEmbeddingsByKBFileUID.defaultExpectation != nil {
		mmDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteEmbeddingsByKBFileUID method")
	}

	if len(mmDeleteEmbeddingsByKBFileUID.expectations) > 0 {
		mmDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteEmbeddingsByKBFileUID method")
	}

	mmDeleteEmbeddingsByKBFileUID.mock.funcDeleteEmbeddingsByKBFileUID = f
	mmDeleteEmbeddingsByKBFileUID.mock.funcDeleteEmbeddingsByKBFileUIDOrigin = minimock.CallerInfo(1)
	return mmDeleteEmbeddingsByKBFileUID.mock
}

// When sets expectation for the Repository.DeleteEmbeddingsByKBFileUID which will trigger the result defined by the following
// Then helper
func (mmDeleteEmbeddingsByKBFileUID *mRepositoryMockDeleteEmbeddingsByKBFileUID) When(ctx context.Context, kbFileUID types.FileUIDType) *RepositoryMockDeleteEmbeddingsByKBFileUIDExpectation {
	if mmDeleteEmbeddingsByKBFileUID.mock.funcDeleteEmbeddingsByKBFileUID != nil {
		mmDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsByKBFileUID mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteEmbeddingsByKBFileUIDExpectation{
		mock:               mmDeleteEmbeddingsByKBFileUID.mock,
		params:             &RepositoryMockDeleteEmbeddingsByKBFileUIDParams{ctx, kbFileUID},
		expectationOrigins: RepositoryMockDeleteEmbeddingsByKBFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteEmbeddingsByKBFileUID.expectations = append(mmDeleteEmbeddingsByKBFileUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteEmbeddingsByKBFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteEmbeddingsByKBFileUIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteEmbeddingsByKBFileUIDResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteEmbeddingsByKBFileUID should be invoked
func (mmDeleteEmbeddingsByKBFileUID *mRepositoryMockDeleteEmbeddingsByKBFileUID) Times(n uint64) *mRepositoryMockDeleteEmbeddingsByKBFileUID {
	if n == 0 {
		mmDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("Times of RepositoryMock.DeleteEmbeddingsByKBFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteEmbeddingsByKBFileUID.expectedInvocations, n)
	mmDeleteEmbeddingsByKBFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteEmbeddingsByKBFileUID
}

func (mmDeleteEmbeddingsByKBFileUID *mRepositoryMockDeleteEmbeddingsByKBFileUID) invocationsDone() bool {
	if len(mmDeleteEmbeddingsByKBFileUID.expectations) == 0 && mmDeleteEmbeddingsByKBFileUID.defaultExpectation == nil && mmDeleteEmbeddingsByKBFileUID.mock.funcDeleteEmbeddingsByKBFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteEmbeddingsByKBFileUID.mock.afterDeleteEmbeddingsByKBFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteEmbeddingsByKBFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteEmbeddingsByKBFileUID implements mm_repository.Repository
func (mmDeleteEmbeddingsByKBFileUID *RepositoryMock) DeleteEmbeddingsByKBFileUID(ctx context.Context, kbFileUID types.FileUIDType) (err error) {
	mm_atomic.AddUint64(&mmDeleteEmbeddingsByKBFileUID.beforeDeleteEmbeddingsByKBFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteEmbeddingsByKBFileUID.afterDeleteEmbeddingsByKBFileUIDCounter, 1)

	mmDeleteEmbeddingsByKBFileUID.t.Helper()

	if mmDeleteEmbeddingsByKBFileUID.inspectFuncDeleteEmbeddingsByKBFileUID != nil {
		mmDeleteEmbeddingsByKBFileUID.inspectFuncDeleteEmbeddingsByKBFileUID(ctx, kbFileUID)
	}

	mm_params := RepositoryMockDeleteEmbeddingsByKBFileUIDParams{ctx, kbFileUID}

	// Record call args
	mmDeleteEmbeddingsByKBFileUID.DeleteEmbeddingsByKBFileUIDMock.mutex.Lock()
	mmDeleteEmbeddingsByKBFileUID.DeleteEmbeddingsByKBFileUIDMock.callArgs = append(mmDeleteEmbeddingsByKBFileUID.DeleteEmbeddingsByKBFileUIDMock.callArgs, &mm_params)
	mmDeleteEmbeddingsByKBFileUID.DeleteEmbeddingsByKBFileUIDMock.mutex.Unlock()

	for _, e := range mmDeleteEmbeddingsByKBFileUID.DeleteEmbeddingsByKBFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteEmbeddingsByKBFileUID.DeleteEmbeddingsByKBFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteEmbeddingsByKBFileUID.DeleteEmbeddingsByKBFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteEmbeddingsByKBFileUID.DeleteEmbeddingsByKBFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteEmbeddingsByKBFileUID.DeleteEmbeddingsByKBFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteEmbeddingsByKBFileUIDParams{ctx, kbFileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteEmbeddingsByKBFileUID.t.Errorf("RepositoryMock.DeleteEmbeddingsByKBFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteEmbeddingsByKBFileUID.DeleteEmbeddingsByKBFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbFileUID != nil && !minimock.Equal(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID) {
				mmDeleteEmbeddingsByKBFileUID.t.Errorf("RepositoryMock.DeleteEmbeddingsByKBFileUID got unexpected parameter kbFileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteEmbeddingsByKBFileUID.DeleteEmbeddingsByKBFileUIDMock.defaultExpectation.expectationOrigins.originKbFileUID, *mm_want_ptrs.kbFileUID, mm_got.kbFileUID, minimock.Diff(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteEmbeddingsByKBFileUID.t.Errorf("RepositoryMock.DeleteEmbeddingsByKBFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteEmbeddingsByKBFileUID.DeleteEmbeddingsByKBFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteEmbeddingsByKBFileUID.DeleteEmbeddingsByKBFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteEmbeddingsByKBFileUID.t.Fatal("No results are set for the RepositoryMock.DeleteEmbeddingsByKBFileUID")
		}
		return (*mm_results).err
	}
	if mmDeleteEmbeddingsByKBFileUID.funcDeleteEmbeddingsByKBFileUID != nil {
		return mmDeleteEmbeddingsByKBFileUID.funcDeleteEmbeddingsByKBFileUID(ctx, kbFileUID)
	}
	mmDeleteEmbeddingsByKBFileUID.t.Fatalf("Unexpected call to RepositoryMock.DeleteEmbeddingsByKBFileUID. %v %v", ctx, kbFileUID)
	return
}

// DeleteEmbeddingsByKBFileUIDAfterCounter returns a count of finished RepositoryMock.DeleteEmbeddingsByKBFileUID invocations
func (mmDeleteEmbeddingsByKBFileUID *RepositoryMock) DeleteEmbeddingsByKBFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEmbeddingsByKBFileUID.afterDeleteEmbeddingsByKBFileUIDCounter)
}

// DeleteEmbeddingsByKBFileUIDBeforeCounter returns a count of RepositoryMock.DeleteEmbeddingsByKBFileUID invocations
func (mmDeleteEmbeddingsByKBFileUID *RepositoryMock) DeleteEmbeddingsByKBFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEmbeddingsByKBFileUID.beforeDeleteEmbeddingsByKBFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteEmbeddingsByKBFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteEmbeddingsByKBFileUID *mRepositoryMockDeleteEmbeddingsByKBFileUID) Calls() []*RepositoryMockDeleteEmbeddingsByKBFileUIDParams {
	mmDeleteEmbeddingsByKBFileUID.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteEmbeddingsByKBFileUIDParams, len(mmDeleteEmbeddingsByKBFileUID.callArgs))
	copy(argCopy, mmDeleteEmbeddingsByKBFileUID.callArgs)

	mmDeleteEmbeddingsByKBFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteEmbeddingsByKBFileUIDDone returns true if the count of the DeleteEmbeddingsByKBFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteEmbeddingsByKBFileUIDDone() bool {
	if m.DeleteEmbeddingsByKBFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteEmbeddingsByKBFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteEmbeddingsByKBFileUIDMock.invocationsDone()
}

// MinimockDeleteEmbeddingsByKBFileUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteEmbeddingsByKBFileUIDInspect() {
	for _, e := range m.DeleteEmbeddingsByKBFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteEmbeddingsByKBFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteEmbeddingsByKBFileUIDCounter := mm_atomic.LoadUint64(&m.afterDeleteEmbeddingsByKBFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteEmbeddingsByKBFileUIDMock.defaultExpectation != nil && afterDeleteEmbeddingsByKBFileUIDCounter < 1 {
		if m.DeleteEmbeddingsByKBFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteEmbeddingsByKBFileUID at\n%s", m.DeleteEmbeddingsByKBFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteEmbeddingsByKBFileUID at\n%s with params: %#v", m.DeleteEmbeddingsByKBFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.DeleteEmbeddingsByKBFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteEmbeddingsByKBFileUID != nil && afterDeleteEmbeddingsByKBFileUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteEmbeddingsByKBFileUID at\n%s", m.funcDeleteEmbeddingsByKBFileUIDOrigin)
	}

	if !m.DeleteEmbeddingsByKBFileUIDMock.invocationsDone() && afterDeleteEmbeddingsByKBFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteEmbeddingsByKBFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteEmbeddingsByKBFileUIDMock.expectedInvocations), m.DeleteEmbeddingsByKBFileUIDMock.expectedInvocationsOrigin, afterDeleteEmbeddingsByKBFileUIDCounter)
	}
}

type mRepositoryMockDeleteEmbeddingsWithFileUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteEmbeddingsWithFileUIDExpectation
	expectations       []*RepositoryMockDeleteEmbeddingsWithFileUIDExpectation

	callArgs []*RepositoryMockDeleteEmbeddingsWithFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteEmbeddingsWithFileUIDExpectation specifies expectation struct of the Repository.DeleteEmbeddingsWithFileUID
type RepositoryMockDeleteEmbeddingsWithFileUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteEmbeddingsWithFileUIDParams
	paramPtrs          *RepositoryMockDeleteEmbeddingsWithFileUIDParamPtrs
	expectationOrigins RepositoryMockDeleteEmbeddingsWithFileUIDExpectationOrigins
	results            *RepositoryMockDeleteEmbeddingsWithFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteEmbeddingsWithFileUIDParams contains parameters of the Repository.DeleteEmbeddingsWithFileUID
type RepositoryMockDeleteEmbeddingsWithFileUIDParams struct {
	ctx     context.Context
	collID  string
	fileUID types.FileUIDType
}

// RepositoryMockDeleteEmbeddingsWithFileUIDParamPtrs contains pointers to parameters of the Repository.DeleteEmbeddingsWithFileUID
type RepositoryMockDeleteEmbeddingsWithFileUIDParamPtrs struct {
	ctx     *context.Context
	collID  *string
	fileUID *types.FileUIDType
}

// RepositoryMockDeleteEmbeddingsWithFileUIDResults contains results of the Repository.DeleteEmbeddingsWithFileUID
type RepositoryMockDeleteEmbeddingsWithFileUIDResults struct {
	err error
}

// RepositoryMockDeleteEmbeddingsWithFileUIDOrigins contains origins of expectations of the Repository.DeleteEmbeddingsWithFileUID
type RepositoryMockDeleteEmbeddingsWithFileUIDExpectationOrigins struct {
	origin        string
	originCtx     string
	originCollID  string
	originFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteEmbeddingsWithFileUID *mRepositoryMockDeleteEmbeddingsWithFileUID) Optional() *mRepositoryMockDeleteEmbeddingsWithFileUID {
	mmDeleteEmbeddingsWithFileUID.optional = true
	return mmDeleteEmbeddingsWithFileUID
}

// Expect sets up expected params for Repository.DeleteEmbeddingsWithFileUID
func (mmDeleteEmbeddingsWithFileUID *mRepositoryMockDeleteEmbeddingsWithFileUID) Expect(ctx context.Context, collID string, fileUID types.FileUIDType) *mRepositoryMockDeleteEmbeddingsWithFileUID {
	if mmDeleteEmbeddingsWithFileUID.mock.funcDeleteEmbeddingsWithFileUID != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsWithFileUID mock is already set by Set")
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation == nil {
		mmDeleteEmbeddingsWithFileUID.defaultExpectation = &RepositoryMockDeleteEmbeddingsWithFileUIDExpectation{}
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsWithFileUID mock is already set by ExpectParams functions")
	}

	mmDeleteEmbeddingsWithFileUID.defaultExpectation.params = &RepositoryMockDeleteEmbeddingsWithFileUIDParams{ctx, collID, fileUID}
	mmDeleteEmbeddingsWithFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteEmbeddingsWithFileUID.expectations {
		if minimock.Equal(e.params, mmDeleteEmbeddingsWithFileUID.defaultExpectation.params) {
			mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteEmbeddingsWithFileUID.defaultExpectation.params)
		}
	}

	return mmDeleteEmbeddingsWithFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteEmbeddingsWithFileUID
func (mmDeleteEmbeddingsWithFileUID *mRepositoryMockDeleteEmbeddingsWithFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteEmbeddingsWithFileUID {
	if mmDeleteEmbeddingsWithFileUID.mock.funcDeleteEmbeddingsWithFileUID != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsWithFileUID mock is already set by Set")
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation == nil {
		mmDeleteEmbeddingsWithFileUID.defaultExpectation = &RepositoryMockDeleteEmbeddingsWithFileUIDExpectation{}
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation.params != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsWithFileUID mock is already set by Expect")
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs == nil {
		mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs = &RepositoryMockDeleteEmbeddingsWithFileUIDParamPtrs{}
	}
	mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteEmbeddingsWithFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteEmbeddingsWithFileUID
}

// ExpectCollIDParam2 sets up expected param collID for Repository.DeleteEmbeddingsWithFileUID
func (mmDeleteEmbeddingsWithFileUID *mRepositoryMockDeleteEmbeddingsWithFileUID) ExpectCollIDParam2(collID string) *mRepositoryMockDeleteEmbeddingsWithFileUID {
	if mmDeleteEmbeddingsWithFileUID.mock.funcDeleteEmbeddingsWithFileUID != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsWithFileUID mock is already set by Set")
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation == nil {
		mmDeleteEmbeddingsWithFileUID.defaultExpectation = &RepositoryMockDeleteEmbeddingsWithFileUIDExpectation{}
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation.params != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsWithFileUID mock is already set by Expect")
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs == nil {
		mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs = &RepositoryMockDeleteEmbeddingsWithFileUIDParamPtrs{}
	}
	mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs.collID = &collID
	mmDeleteEmbeddingsWithFileUID.defaultExpectation.expectationOrigins.originCollID = minimock.CallerInfo(1)

	return mmDeleteEmbeddingsWithFileUID
}

// ExpectFileUIDParam3 sets up expected param fileUID for Repository.DeleteEmbeddingsWithFileUID
func (mmDeleteEmbeddingsWithFileUID *mRepositoryMockDeleteEmbeddingsWithFileUID) ExpectFileUIDParam3(fileUID types.FileUIDType) *mRepositoryMockDeleteEmbeddingsWithFileUID {
	if mmDeleteEmbeddingsWithFileUID.mock.funcDeleteEmbeddingsWithFileUID != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsWithFileUID mock is already set by Set")
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation == nil {
		mmDeleteEmbeddingsWithFileUID.defaultExpectation = &RepositoryMockDeleteEmbeddingsWithFileUIDExpectation{}
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation.params != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsWithFileUID mock is already set by Expect")
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs == nil {
		mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs = &RepositoryMockDeleteEmbeddingsWithFileUIDParamPtrs{}
	}
	mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmDeleteEmbeddingsWithFileUID.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmDeleteEmbeddingsWithFileUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteEmbeddingsWithFileUID
func (mmDeleteEmbeddingsWithFileUID *mRepositoryMockDeleteEmbeddingsWithFileUID) Inspect(f func(ctx context.Context, collID string, fileUID types.FileUIDType)) *mRepositoryMockDeleteEmbeddingsWithFileUID {
	if mmDeleteEmbeddingsWithFileUID.mock.inspectFuncDeleteEmbeddingsWithFileUID != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteEmbeddingsWithFileUID")
	}

	mmDeleteEmbeddingsWithFileUID.mock.inspectFuncDeleteEmbeddingsWithFileUID = f

	return mmDeleteEmbeddingsWithFileUID
}

// Return sets up results that will be returned by Repository.DeleteEmbeddingsWithFileUID
func (mmDeleteEmbeddingsWithFileUID *mRepositoryMockDeleteEmbeddingsWithFileUID) Return(err error) *RepositoryMock {
	if mmDeleteEmbeddingsWithFileUID.mock.funcDeleteEmbeddingsWithFileUID != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsWithFileUID mock is already set by Set")
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation == nil {
		mmDeleteEmbeddingsWithFileUID.defaultExpectation = &RepositoryMockDeleteEmbeddingsWithFileUIDExpectation{mock: mmDeleteEmbeddingsWithFileUID.mock}
	}
	mmDeleteEmbeddingsWithFileUID.defaultExpectation.results = &RepositoryMockDeleteEmbeddingsWithFileUIDResults{err}
	mmDeleteEmbeddingsWithFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteEmbeddingsWithFileUID.mock
}

// Set uses given function f to mock the Repository.DeleteEmbeddingsWithFileUID method
func (mmDeleteEmbeddingsWithFileUID *mRepositoryMockDeleteEmbeddingsWithFileUID) Set(f func(ctx context.Context, collID string, fileUID types.FileUIDType) (err error)) *RepositoryMock {
	if mmDeleteEmbeddingsWithFileUID.defaultExpectation != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteEmbeddingsWithFileUID method")
	}

	if len(mmDeleteEmbeddingsWithFileUID.expectations) > 0 {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteEmbeddingsWithFileUID method")
	}

	mmDeleteEmbeddingsWithFileUID.mock.funcDeleteEmbeddingsWithFileUID = f
	mmDeleteEmbeddingsWithFileUID.mock.funcDeleteEmbeddingsWithFileUIDOrigin = minimock.CallerInfo(1)
	return mmDeleteEmbeddingsWithFileUID.mock
}

// When sets expectation for the Repository.DeleteEmbeddingsWithFileUID which will trigger the result defined by the following
// Then helper
func (mmDeleteEmbeddingsWithFileUID *mRepositoryMockDeleteEmbeddingsWithFileUID) When(ctx context.Context, collID string, fileUID types.FileUIDType) *RepositoryMockDeleteEmbeddingsWithFileUIDExpectation {
	if mmDeleteEmbeddingsWithFileUID.mock.funcDeleteEmbeddingsWithFileUID != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsWithFileUID mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteEmbeddingsWithFileUIDExpectation{
		mock:               mmDeleteEmbeddingsWithFileUID.mock,
		params:             &RepositoryMockDeleteEmbeddingsWithFileUIDParams{ctx, collID, fileUID},
		expectationOrigins: RepositoryMockDeleteEmbeddingsWithFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteEmbeddingsWithFileUID.expectations = append(mmDeleteEmbeddingsWithFileUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteEmbeddingsWithFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteEmbeddingsWithFileUIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteEmbeddingsWithFileUIDResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteEmbeddingsWithFileUID should be invoked
func (mmDeleteEmbeddingsWithFileUID *mRepositoryMockDeleteEmbeddingsWithFileUID) Times(n uint64) *mRepositoryMockDeleteEmbeddingsWithFileUID {
	if n == 0 {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("Times of RepositoryMock.DeleteEmbeddingsWithFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteEmbeddingsWithFileUID.expectedInvocations, n)
	mmDeleteEmbeddingsWithFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteEmbeddingsWithFileUID
}

func (mmDeleteEmbeddingsWithFileUID *mRepositoryMockDeleteEmbeddingsWithFileUID) invocationsDone() bool {
	if len(mmDeleteEmbeddingsWithFileUID.expectations) == 0 && mmDeleteEmbeddingsWithFileUID.defaultExpectation == nil && mmDeleteEmbeddingsWithFileUID.mock.funcDeleteEmbeddingsWithFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteEmbeddingsWithFileUID.mock.afterDeleteEmbeddingsWithFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteEmbeddingsWithFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteEmbeddingsWithFileUID implements mm_repository.Repository
func (mmDeleteEmbeddingsWithFileUID *RepositoryMock) DeleteEmbeddingsWithFileUID(ctx context.Context, collID string, fileUID types.FileUIDType) (err error) {
	mm_atomic.AddUint64(&mmDeleteEmbeddingsWithFileUID.beforeDeleteEmbeddingsWithFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteEmbeddingsWithFileUID.afterDeleteEmbeddingsWithFileUIDCounter, 1)

	mmDeleteEmbeddingsWithFileUID.t.Helper()

	if mmDeleteEmbeddingsWithFileUID.inspectFuncDeleteEmbeddingsWithFileUID != nil {
		mmDeleteEmbeddingsWithFileUID.inspectFuncDeleteEmbeddingsWithFileUID(ctx, collID, fileUID)
	}

	mm_params := RepositoryMockDeleteEmbeddingsWithFileUIDParams{ctx, collID, fileUID}

	// Record call args
	mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.mutex.Lock()
	mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.callArgs = append(mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.callArgs, &mm_params)
	mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.mutex.Unlock()

	for _, e := range mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteEmbeddingsWithFileUIDParams{ctx, collID, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteEmbeddingsWithFileUID.t.Errorf("RepositoryMock.DeleteEmbeddingsWithFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.collID != nil && !minimock.Equal(*mm_want_ptrs.collID, mm_got.collID) {
				mmDeleteEmbeddingsWithFileUID.t.Errorf("RepositoryMock.DeleteEmbeddingsWithFileUID got unexpected parameter collID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.expectationOrigins.originCollID, *mm_want_ptrs.collID, mm_got.collID, minimock.Diff(*mm_want_ptrs.collID, mm_got.collID))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmDeleteEmbeddingsWithFileUID.t.Errorf("RepositoryMock.DeleteEmbeddingsWithFileUID got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteEmbeddingsWithFileUID.t.Errorf("RepositoryMock.DeleteEmbeddingsWithFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteEmbeddingsWithFileUID.t.Fatal("No results are set for the RepositoryMock.DeleteEmbeddingsWithFileUID")
		}
		return (*mm_results).err
	}
	if mmDeleteEmbeddingsWithFileUID.funcDeleteEmbeddingsWithFileUID != nil {
		return mmDeleteEmbeddingsWithFileUID.funcDeleteEmbeddingsWithFileUID(ctx, collID, fileUID)
	}
	mmDeleteEmbeddingsWithFileUID.t.Fatalf("Unexpected call to RepositoryMock.DeleteEmbeddingsWithFileUID. %v %v %v", ctx, collID, fileUID)
	return
}

// DeleteEmbeddingsWithFileUIDAfterCounter returns a count of finished RepositoryMock.DeleteEmbeddingsWithFileUID invocations
func (mmDeleteEmbeddingsWithFileUID *RepositoryMock) DeleteEmbeddingsWithFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEmbeddingsWithFileUID.afterDeleteEmbeddingsWithFileUIDCounter)
}

// DeleteEmbeddingsWithFileUIDBeforeCounter returns a count of RepositoryMock.DeleteEmbeddingsWithFileUID invocations
func (mmDeleteEmbeddingsWithFileUID *RepositoryMock) DeleteEmbeddingsWithFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEmbeddingsWithFileUID.beforeDeleteEmbeddingsWithFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteEmbeddingsWithFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteEmbeddingsWithFileUID *mRepositoryMockDeleteEmbeddingsWithFileUID) Calls() []*RepositoryMockDeleteEmbeddingsWithFileUIDParams {
	mmDeleteEmbeddingsWithFileUID.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteEmbeddingsWithFileUIDParams, len(mmDeleteEmbeddingsWithFileUID.callArgs))
	copy(argCopy, mmDeleteEmbeddingsWithFileUID.callArgs)

	mmDeleteEmbeddingsWithFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteEmbeddingsWithFileUIDDone returns true if the count of the DeleteEmbeddingsWithFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteEmbeddingsWithFileUIDDone() bool {
	if m.DeleteEmbeddingsWithFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteEmbeddingsWithFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteEmbeddingsWithFileUIDMock.invocationsDone()
}

// MinimockDeleteEmbeddingsWithFileUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteEmbeddingsWithFileUIDInspect() {
	for _, e := range m.DeleteEmbeddingsWithFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteEmbeddingsWithFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteEmbeddingsWithFileUIDCounter := mm_atomic.LoadUint64(&m.afterDeleteEmbeddingsWithFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteEmbeddingsWithFileUIDMock.defaultExpectation != nil && afterDeleteEmbeddingsWithFileUIDCounter < 1 {
		if m.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteEmbeddingsWithFileUID at\n%s", m.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteEmbeddingsWithFileUID at\n%s with params: %#v", m.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteEmbeddingsWithFileUID != nil && afterDeleteEmbeddingsWithFileUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteEmbeddingsWithFileUID at\n%s", m.funcDeleteEmbeddingsWithFileUIDOrigin)
	}

	if !m.DeleteEmbeddingsWithFileUIDMock.invocationsDone() && afterDeleteEmbeddingsWithFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteEmbeddingsWithFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteEmbeddingsWithFileUIDMock.expectedInvocations), m.DeleteEmbeddingsWithFileUIDMock.expectedInvocationsOrigin, afterDeleteEmbeddingsWithFileUIDCounter)
	}
}

type mRepositoryMockDeleteGCSFileCache struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteGCSFileCacheExpectation
	expectations       []*RepositoryMockDeleteGCSFileCacheExpectation

	callArgs []*RepositoryMockDeleteGCSFileCacheParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteGCSFileCacheExpectation specifies expectation struct of the Repository.DeleteGCSFileCache
type RepositoryMockDeleteGCSFileCacheExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteGCSFileCacheParams
	paramPtrs          *RepositoryMockDeleteGCSFileCacheParamPtrs
	expectationOrigins RepositoryMockDeleteGCSFileCacheExpectationOrigins
	results            *RepositoryMockDeleteGCSFileCacheResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteGCSFileCacheParams contains parameters of the Repository.DeleteGCSFileCache
type RepositoryMockDeleteGCSFileCacheParams struct {
	ctx     context.Context
	kbUID   types.KBUIDType
	fileUID types.FileUIDType
	view    string
}

// RepositoryMockDeleteGCSFileCacheParamPtrs contains pointers to parameters of the Repository.DeleteGCSFileCache
type RepositoryMockDeleteGCSFileCacheParamPtrs struct {
	ctx     *context.Context
	kbUID   *types.KBUIDType
	fileUID *types.FileUIDType
	view    *string
}

// RepositoryMockDeleteGCSFileCacheResults contains results of the Repository.DeleteGCSFileCache
type RepositoryMockDeleteGCSFileCacheResults struct {
	err error
}

// RepositoryMockDeleteGCSFileCacheOrigins contains origins of expectations of the Repository.DeleteGCSFileCache
type RepositoryMockDeleteGCSFileCacheExpectationOrigins struct {
	origin        string
	originCtx     string
	originKbUID   string
	originFileUID string
	originView    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteGCSFileCache *mRepositoryMockDeleteGCSFileCache) Optional() *mRepositoryMockDeleteGCSFileCache {
	mmDeleteGCSFileCache.optional = true
	return mmDeleteGCSFileCache
}

// Expect sets up expected params for Repository.DeleteGCSFileCache
func (mmDeleteGCSFileCache *mRepositoryMockDeleteGCSFileCache) Expect(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, view string) *mRepositoryMockDeleteGCSFileCache {
	if mmDeleteGCSFileCache.mock.funcDeleteGCSFileCache != nil {
		mmDeleteGCSFileCache.mock.t.Fatalf("RepositoryMock.DeleteGCSFileCache mock is already set by Set")
	}

	if mmDeleteGCSFileCache.defaultExpectation == nil {
		mmDeleteGCSFileCache.defaultExpectation = &RepositoryMockDeleteGCSFileCacheExpectation{}
	}

	if mmDeleteGCSFileCache.defaultExpectation.paramPtrs != nil {
		mmDeleteGCSFileCache.mock.t.Fatalf("RepositoryMock.DeleteGCSFileCache mock is already set by ExpectParams functions")
	}

	mmDeleteGCSFileCache.defaultExpectation.params = &RepositoryMockDeleteGCSFileCacheParams{ctx, kbUID, fileUID, view}
	mmDeleteGCSFileCache.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteGCSFileCache.expectations {
		if minimock.Equal(e.params, mmDeleteGCSFileCache.defaultExpectation.params) {
			mmDeleteGCSFileCache.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteGCSFileCache.defaultExpectation.params)
		}
	}

	return mmDeleteGCSFileCache
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteGCSFileCache
func (mmDeleteGCSFileCache *mRepositoryMockDeleteGCSFileCache) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteGCSFileCache {
	if mmDeleteGCSFileCache.mock.funcDeleteGCSFileCache != nil {
		mmDeleteGCSFileCache.mock.t.Fatalf("RepositoryMock.DeleteGCSFileCache mock is already set by Set")
	}

	if mmDeleteGCSFileCache.defaultExpectation == nil {
		mmDeleteGCSFileCache.defaultExpectation = &RepositoryMockDeleteGCSFileCacheExpectation{}
	}

	if mmDeleteGCSFileCache.defaultExpectation.params != nil {
		mmDeleteGCSFileCache.mock.t.Fatalf("RepositoryMock.DeleteGCSFileCache mock is already set by Expect")
	}

	if mmDeleteGCSFileCache.defaultExpectation.paramPtrs == nil {
		mmDeleteGCSFileCache.defaultExpectation.paramPtrs = &RepositoryMockDeleteGCSFileCacheParamPtrs{}
	}
	mmDeleteGCSFileCache.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteGCSFileCache.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteGCSFileCache
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.DeleteGCSFileCache
func (mmDeleteGCSFileCache *mRepositoryMockDeleteGCSFileCache) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockDeleteGCSFileCache {
	if mmDeleteGCSFileCache.mock.funcDeleteGCSFileCache != nil {
		mmDeleteGCSFileCache.mock.t.Fatalf("RepositoryMock.DeleteGCSFileCache mock is already set by Set")
	}

	if mmDeleteGCSFileCache.defaultExpectation == nil {
		mmDeleteGCSFileCache.defaultExpectation = &RepositoryMockDeleteGCSFileCacheExpectation{}
	}

	if mmDeleteGCSFileCache.defaultExpectation.params != nil {
		mmDeleteGCSFileCache.mock.t.Fatalf("RepositoryMock.DeleteGCSFileCache mock is already set by Expect")
	}

	if mmDeleteGCSFileCache.defaultExpectation.paramPtrs == nil {
		mmDeleteGCSFileCache.defaultExpectation.paramPtrs = &RepositoryMockDeleteGCSFileCacheParamPtrs{}
	}
	mmDeleteGCSFileCache.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmDeleteGCSFileCache.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmDeleteGCSFileCache
}

// ExpectFileUIDParam3 sets up expected param fileUID for Repository.DeleteGCSFileCache
func (mmDeleteGCSFileCache *mRepositoryMockDeleteGCSFileCache) ExpectFileUIDParam3(fileUID types.FileUIDType) *mRepositoryMockDeleteGCSFileCache {
	if mmDeleteGCSFileCache.mock.funcDeleteGCSFileCache != nil {
		mmDeleteGCSFileCache.mock.t.Fatalf("RepositoryMock.DeleteGCSFileCache mock is already set by Set")
	}

	if mmDeleteGCSFileCache.defaultExpectation == nil {
		mmDeleteGCSFileCache.defaultExpectation = &RepositoryMockDeleteGCSFileCacheExpectation{}
	}

	if mmDeleteGCSFileCache.defaultExpectation.params != nil {
		mmDeleteGCSFileCache.mock.t.Fatalf("RepositoryMock.DeleteGCSFileCache mock is already set by Expect")
	}

	if mmDeleteGCSFileCache.defaultExpectation.paramPtrs == nil {
		mmDeleteGCSFileCache.defaultExpectation.paramPtrs = &RepositoryMockDeleteGCSFileCacheParamPtrs{}
	}
	mmDeleteGCSFileCache.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmDeleteGCSFileCache.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmDeleteGCSFileCache
}

// ExpectViewParam4 sets up expected param view for Repository.DeleteGCSFileCache
func (mmDeleteGCSFileCache *mRepositoryMockDeleteGCSFileCache) ExpectViewParam4(view string) *mRepositoryMockDeleteGCSFileCache {
	if mmDeleteGCSFileCache.mock.funcDeleteGCSFileCache != nil {
		mmDeleteGCSFileCache.mock.t.Fatalf("RepositoryMock.DeleteGCSFileCache mock is already set by Set")
	}

	if mmDeleteGCSFileCache.defaultExpectation == nil {
		mmDeleteGCSFileCache.defaultExpectation = &RepositoryMockDeleteGCSFileCacheExpectation{}
	}

	if mmDeleteGCSFileCache.defaultExpectation.params != nil {
		mmDeleteGCSFileCache.mock.t.Fatalf("RepositoryMock.DeleteGCSFileCache mock is already set by Expect")
	}

	if mmDeleteGCSFileCache.defaultExpectation.paramPtrs == nil {
		mmDeleteGCSFileCache.defaultExpectation.paramPtrs = &RepositoryMockDeleteGCSFileCacheParamPtrs{}
	}
	mmDeleteGCSFileCache.defaultExpectation.paramPtrs.view = &view
	mmDeleteGCSFileCache.defaultExpectation.expectationOrigins.originView = minimock.CallerInfo(1)

	return mmDeleteGCSFileCache
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteGCSFileCache
func (mmDeleteGCSFileCache *mRepositoryMockDeleteGCSFileCache) Inspect(f func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, view string)) *mRepositoryMockDeleteGCSFileCache {
	if mmDeleteGCSFileCache.mock.inspectFuncDeleteGCSFileCache != nil {
		mmDeleteGCSFileCache.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteGCSFileCache")
	}

	mmDeleteGCSFileCache.mock.inspectFuncDeleteGCSFileCache = f

	return mmDeleteGCSFileCache
}

// Return sets up results that will be returned by Repository.DeleteGCSFileCache
func (mmDeleteGCSFileCache *mRepositoryMockDeleteGCSFileCache) Return(err error) *RepositoryMock {
	if mmDeleteGCSFileCache.mock.funcDeleteGCSFileCache != nil {
		mmDeleteGCSFileCache.mock.t.Fatalf("RepositoryMock.DeleteGCSFileCache mock is already set by Set")
	}

	if mmDeleteGCSFileCache.defaultExpectation == nil {
		mmDeleteGCSFileCache.defaultExpectation = &RepositoryMockDeleteGCSFileCacheExpectation{mock: mmDeleteGCSFileCache.mock}
	}
	mmDeleteGCSFileCache.defaultExpectation.results = &RepositoryMockDeleteGCSFileCacheResults{err}
	mmDeleteGCSFileCache.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteGCSFileCache.mock
}

// Set uses given function f to mock the Repository.DeleteGCSFileCache method
func (mmDeleteGCSFileCache *mRepositoryMockDeleteGCSFileCache) Set(f func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, view string) (err error)) *RepositoryMock {
	if mmDeleteGCSFileCache.defaultExpectation != nil {
		mmDeleteGCSFileCache.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteGCSFileCache method")
	}

	if len(mmDeleteGCSFileCache.expectations) > 0 {
		mmDeleteGCSFileCache.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteGCSFileCache method")
	}

	mmDeleteGCSFileCache.mock.funcDeleteGCSFileCache = f
	mmDeleteGCSFileCache.mock.funcDeleteGCSFileCacheOrigin = minimock.CallerInfo(1)
	return mmDeleteGCSFileCache.mock
}

// When sets expectation for the Repository.DeleteGCSFileCache which will trigger the result defined by the following
// Then helper
func (mmDeleteGCSFileCache *mRepositoryMockDeleteGCSFileCache) When(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, view string) *RepositoryMockDeleteGCSFileCacheExpectation {
	if mmDeleteGCSFileCache.mock.funcDeleteGCSFileCache != nil {
		mmDeleteGCSFileCache.mock.t.Fatalf("RepositoryMock.DeleteGCSFileCache mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteGCSFileCacheExpectation{
		mock:               mmDeleteGCSFileCache.mock,
		params:             &RepositoryMockDeleteGCSFileCacheParams{ctx, kbUID, fileUID, view},
		expectationOrigins: RepositoryMockDeleteGCSFileCacheExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteGCSFileCache.expectations = append(mmDeleteGCSFileCache.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteGCSFileCache return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteGCSFileCacheExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteGCSFileCacheResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteGCSFileCache should be invoked
func (mmDeleteGCSFileCache *mRepositoryMockDeleteGCSFileCache) Times(n uint64) *mRepositoryMockDeleteGCSFileCache {
	if n == 0 {
		mmDeleteGCSFileCache.mock.t.Fatalf("Times of RepositoryMock.DeleteGCSFileCache mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteGCSFileCache.expectedInvocations, n)
	mmDeleteGCSFileCache.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteGCSFileCache
}

func (mmDeleteGCSFileCache *mRepositoryMockDeleteGCSFileCache) invocationsDone() bool {
	if len(mmDeleteGCSFileCache.expectations) == 0 && mmDeleteGCSFileCache.defaultExpectation == nil && mmDeleteGCSFileCache.mock.funcDeleteGCSFileCache == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteGCSFileCache.mock.afterDeleteGCSFileCacheCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteGCSFileCache.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteGCSFileCache implements mm_repository.Repository
func (mmDeleteGCSFileCache *RepositoryMock) DeleteGCSFileCache(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, view string) (err error) {
	mm_atomic.AddUint64(&mmDeleteGCSFileCache.beforeDeleteGCSFileCacheCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteGCSFileCache.afterDeleteGCSFileCacheCounter, 1)

	mmDeleteGCSFileCache.t.Helper()

	if mmDeleteGCSFileCache.inspectFuncDeleteGCSFileCache != nil {
		mmDeleteGCSFileCache.inspectFuncDeleteGCSFileCache(ctx, kbUID, fileUID, view)
	}

	mm_params := RepositoryMockDeleteGCSFileCacheParams{ctx, kbUID, fileUID, view}

	// Record call args
	mmDeleteGCSFileCache.DeleteGCSFileCacheMock.mutex.Lock()
	mmDeleteGCSFileCache.DeleteGCSFileCacheMock.callArgs = append(mmDeleteGCSFileCache.DeleteGCSFileCacheMock.callArgs, &mm_params)
	mmDeleteGCSFileCache.DeleteGCSFileCacheMock.mutex.Unlock()

	for _, e := range mmDeleteGCSFileCache.DeleteGCSFileCacheMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteGCSFileCache.DeleteGCSFileCacheMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteGCSFileCache.DeleteGCSFileCacheMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteGCSFileCache.DeleteGCSFileCacheMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteGCSFileCache.DeleteGCSFileCacheMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteGCSFileCacheParams{ctx, kbUID, fileUID, view}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteGCSFileCache.t.Errorf("RepositoryMock.DeleteGCSFileCache got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteGCSFileCache.DeleteGCSFileCacheMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmDeleteGCSFileCache.t.Errorf("RepositoryMock.DeleteGCSFileCache got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteGCSFileCache.DeleteGCSFileCacheMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmDeleteGCSFileCache.t.Errorf("RepositoryMock.DeleteGCSFileCache got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteGCSFileCache.DeleteGCSFileCacheMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

			if mm_want_ptrs.view != nil && !minimock.Equal(*mm_want_ptrs.view, mm_got.view) {
				mmDeleteGCSFileCache.t.Errorf("RepositoryMock.DeleteGCSFileCache got unexpected parameter view, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteGCSFileCache.DeleteGCSFileCacheMock.defaultExpectation.expectationOrigins.originView, *mm_want_ptrs.view, mm_got.view, minimock.Diff(*mm_want_ptrs.view, mm_got.view))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteGCSFileCache.t.Errorf("RepositoryMock.DeleteGCSFileCache got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteGCSFileCache.DeleteGCSFileCacheMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteGCSFileCache.DeleteGCSFileCacheMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteGCSFileCache.t.Fatal("No results are set for the RepositoryMock.DeleteGCSFileCache")
		}
		return (*mm_results).err
	}
	if mmDeleteGCSFileCache.funcDeleteGCSFileCache != nil {
		return mmDeleteGCSFileCache.funcDeleteGCSFileCache(ctx, kbUID, fileUID, view)
	}
	mmDeleteGCSFileCache.t.Fatalf("Unexpected call to RepositoryMock.DeleteGCSFileCache. %v %v %v %v", ctx, kbUID, fileUID, view)
	return
}

// DeleteGCSFileCacheAfterCounter returns a count of finished RepositoryMock.DeleteGCSFileCache invocations
func (mmDeleteGCSFileCache *RepositoryMock) DeleteGCSFileCacheAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteGCSFileCache.afterDeleteGCSFileCacheCounter)
}

// DeleteGCSFileCacheBeforeCounter returns a count of RepositoryMock.DeleteGCSFileCache invocations
func (mmDeleteGCSFileCache *RepositoryMock) DeleteGCSFileCacheBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteGCSFileCache.beforeDeleteGCSFileCacheCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteGCSFileCache.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteGCSFileCache *mRepositoryMockDeleteGCSFileCache) Calls() []*RepositoryMockDeleteGCSFileCacheParams {
	mmDeleteGCSFileCache.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteGCSFileCacheParams, len(mmDeleteGCSFileCache.callArgs))
	copy(argCopy, mmDeleteGCSFileCache.callArgs)

	mmDeleteGCSFileCache.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteGCSFileCacheDone returns true if the count of the DeleteGCSFileCache invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteGCSFileCacheDone() bool {
	if m.DeleteGCSFileCacheMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteGCSFileCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteGCSFileCacheMock.invocationsDone()
}

// MinimockDeleteGCSFileCacheInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteGCSFileCacheInspect() {
	for _, e := range m.DeleteGCSFileCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteGCSFileCache at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteGCSFileCacheCounter := mm_atomic.LoadUint64(&m.afterDeleteGCSFileCacheCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteGCSFileCacheMock.defaultExpectation != nil && afterDeleteGCSFileCacheCounter < 1 {
		if m.DeleteGCSFileCacheMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteGCSFileCache at\n%s", m.DeleteGCSFileCacheMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteGCSFileCache at\n%s with params: %#v", m.DeleteGCSFileCacheMock.defaultExpectation.expectationOrigins.origin, *m.DeleteGCSFileCacheMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteGCSFileCache != nil && afterDeleteGCSFileCacheCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteGCSFileCache at\n%s", m.funcDeleteGCSFileCacheOrigin)
	}

	if !m.DeleteGCSFileCacheMock.invocationsDone() && afterDeleteGCSFileCacheCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteGCSFileCache at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteGCSFileCacheMock.expectedInvocations), m.DeleteGCSFileCacheMock.expectedInvocationsOrigin, afterDeleteGCSFileCacheCounter)
	}
}

type mRepositoryMockDeleteKnowledgeBase struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteKnowledgeBaseExpectation
	expectations       []*RepositoryMockDeleteKnowledgeBaseExpectation

	callArgs []*RepositoryMockDeleteKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteKnowledgeBaseExpectation specifies expectation struct of the Repository.DeleteKnowledgeBase
type RepositoryMockDeleteKnowledgeBaseExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteKnowledgeBaseParams
	paramPtrs          *RepositoryMockDeleteKnowledgeBaseParamPtrs
	expectationOrigins RepositoryMockDeleteKnowledgeBaseExpectationOrigins
	results            *RepositoryMockDeleteKnowledgeBaseResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteKnowledgeBaseParams contains parameters of the Repository.DeleteKnowledgeBase
type RepositoryMockDeleteKnowledgeBaseParams struct {
	ctx      context.Context
	ownerUID string
	kbID     string
}

// RepositoryMockDeleteKnowledgeBaseParamPtrs contains pointers to parameters of the Repository.DeleteKnowledgeBase
type RepositoryMockDeleteKnowledgeBaseParamPtrs struct {
	ctx      *context.Context
	ownerUID *string
	kbID     *string
}

// RepositoryMockDeleteKnowledgeBaseResults contains results of the Repository.DeleteKnowledgeBase
type RepositoryMockDeleteKnowledgeBaseResults struct {
	kp1 *mm_repository.KnowledgeBaseModel
	err error
}

// RepositoryMockDeleteKnowledgeBaseOrigins contains origins of expectations of the Repository.DeleteKnowledgeBase
type RepositoryMockDeleteKnowledgeBaseExpectationOrigins struct {
	origin         string
	originCtx      string
	originOwnerUID string
	originKbID     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) Optional() *mRepositoryMockDeleteKnowledgeBase {
	mmDeleteKnowledgeBase.optional = true
	return mmDeleteKnowledgeBase
}

// Expect sets up expected params for Repository.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) Expect(ctx context.Context, ownerUID string, kbID string) *mRepositoryMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmDeleteKnowledgeBase.defaultExpectation.params = &RepositoryMockDeleteKnowledgeBaseParams{ctx, ownerUID, kbID}
	mmDeleteKnowledgeBase.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmDeleteKnowledgeBase.defaultExpectation.params) {
			mmDeleteKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmDeleteKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.params != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBase mock is already set by Expect")
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockDeleteKnowledgeBaseParamPtrs{}
	}
	mmDeleteKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteKnowledgeBase.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteKnowledgeBase
}

// ExpectOwnerUIDParam2 sets up expected param ownerUID for Repository.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) ExpectOwnerUIDParam2(ownerUID string) *mRepositoryMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.params != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBase mock is already set by Expect")
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockDeleteKnowledgeBaseParamPtrs{}
	}
	mmDeleteKnowledgeBase.defaultExpectation.paramPtrs.ownerUID = &ownerUID
	mmDeleteKnowledgeBase.defaultExpectation.expectationOrigins.originOwnerUID = minimock.CallerInfo(1)

	return mmDeleteKnowledgeBase
}

// ExpectKbIDParam3 sets up expected param kbID for Repository.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) ExpectKbIDParam3(kbID string) *mRepositoryMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.params != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBase mock is already set by Expect")
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockDeleteKnowledgeBaseParamPtrs{}
	}
	mmDeleteKnowledgeBase.defaultExpectation.paramPtrs.kbID = &kbID
	mmDeleteKnowledgeBase.defaultExpectation.expectationOrigins.originKbID = minimock.CallerInfo(1)

	return mmDeleteKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) Inspect(f func(ctx context.Context, ownerUID string, kbID string)) *mRepositoryMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.inspectFuncDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteKnowledgeBase")
	}

	mmDeleteKnowledgeBase.mock.inspectFuncDeleteKnowledgeBase = f

	return mmDeleteKnowledgeBase
}

// Return sets up results that will be returned by Repository.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) Return(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseExpectation{mock: mmDeleteKnowledgeBase.mock}
	}
	mmDeleteKnowledgeBase.defaultExpectation.results = &RepositoryMockDeleteKnowledgeBaseResults{kp1, err}
	mmDeleteKnowledgeBase.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBase.mock
}

// Set uses given function f to mock the Repository.DeleteKnowledgeBase method
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) Set(f func(ctx context.Context, ownerUID string, kbID string) (kp1 *mm_repository.KnowledgeBaseModel, err error)) *RepositoryMock {
	if mmDeleteKnowledgeBase.defaultExpectation != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteKnowledgeBase method")
	}

	if len(mmDeleteKnowledgeBase.expectations) > 0 {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteKnowledgeBase method")
	}

	mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase = f
	mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBaseOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBase.mock
}

// When sets expectation for the Repository.DeleteKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) When(ctx context.Context, ownerUID string, kbID string) *RepositoryMockDeleteKnowledgeBaseExpectation {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBase mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteKnowledgeBaseExpectation{
		mock:               mmDeleteKnowledgeBase.mock,
		params:             &RepositoryMockDeleteKnowledgeBaseParams{ctx, ownerUID, kbID},
		expectationOrigins: RepositoryMockDeleteKnowledgeBaseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteKnowledgeBase.expectations = append(mmDeleteKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteKnowledgeBaseExpectation) Then(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteKnowledgeBaseResults{kp1, err}
	return e.mock
}

// Times sets number of times Repository.DeleteKnowledgeBase should be invoked
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) Times(n uint64) *mRepositoryMockDeleteKnowledgeBase {
	if n == 0 {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Times of RepositoryMock.DeleteKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteKnowledgeBase.expectedInvocations, n)
	mmDeleteKnowledgeBase.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBase
}

func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) invocationsDone() bool {
	if len(mmDeleteKnowledgeBase.expectations) == 0 && mmDeleteKnowledgeBase.defaultExpectation == nil && mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.mock.afterDeleteKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteKnowledgeBase implements mm_repository.Repository
func (mmDeleteKnowledgeBase *RepositoryMock) DeleteKnowledgeBase(ctx context.Context, ownerUID string, kbID string) (kp1 *mm_repository.KnowledgeBaseModel, err error) {
	mm_atomic.AddUint64(&mmDeleteKnowledgeBase.beforeDeleteKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteKnowledgeBase.afterDeleteKnowledgeBaseCounter, 1)

	mmDeleteKnowledgeBase.t.Helper()

	if mmDeleteKnowledgeBase.inspectFuncDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.inspectFuncDeleteKnowledgeBase(ctx, ownerUID, kbID)
	}

	mm_params := RepositoryMockDeleteKnowledgeBaseParams{ctx, ownerUID, kbID}

	// Record call args
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.mutex.Lock()
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.callArgs = append(mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.callArgs, &mm_params)
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteKnowledgeBaseParams{ctx, ownerUID, kbID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteKnowledgeBase.t.Errorf("RepositoryMock.DeleteKnowledgeBase got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmDeleteKnowledgeBase.t.Errorf("RepositoryMock.DeleteKnowledgeBase got unexpected parameter ownerUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.expectationOrigins.originOwnerUID, *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

			if mm_want_ptrs.kbID != nil && !minimock.Equal(*mm_want_ptrs.kbID, mm_got.kbID) {
				mmDeleteKnowledgeBase.t.Errorf("RepositoryMock.DeleteKnowledgeBase got unexpected parameter kbID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.expectationOrigins.originKbID, *mm_want_ptrs.kbID, mm_got.kbID, minimock.Diff(*mm_want_ptrs.kbID, mm_got.kbID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteKnowledgeBase.t.Errorf("RepositoryMock.DeleteKnowledgeBase got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteKnowledgeBase.t.Fatal("No results are set for the RepositoryMock.DeleteKnowledgeBase")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmDeleteKnowledgeBase.funcDeleteKnowledgeBase != nil {
		return mmDeleteKnowledgeBase.funcDeleteKnowledgeBase(ctx, ownerUID, kbID)
	}
	mmDeleteKnowledgeBase.t.Fatalf("Unexpected call to RepositoryMock.DeleteKnowledgeBase. %v %v %v", ctx, ownerUID, kbID)
	return
}

// DeleteKnowledgeBaseAfterCounter returns a count of finished RepositoryMock.DeleteKnowledgeBase invocations
func (mmDeleteKnowledgeBase *RepositoryMock) DeleteKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.afterDeleteKnowledgeBaseCounter)
}

// DeleteKnowledgeBaseBeforeCounter returns a count of RepositoryMock.DeleteKnowledgeBase invocations
func (mmDeleteKnowledgeBase *RepositoryMock) DeleteKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.beforeDeleteKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) Calls() []*RepositoryMockDeleteKnowledgeBaseParams {
	mmDeleteKnowledgeBase.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteKnowledgeBaseParams, len(mmDeleteKnowledgeBase.callArgs))
	copy(argCopy, mmDeleteKnowledgeBase.callArgs)

	mmDeleteKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteKnowledgeBaseDone returns true if the count of the DeleteKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteKnowledgeBaseDone() bool {
	if m.DeleteKnowledgeBaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteKnowledgeBaseMock.invocationsDone()
}

// MinimockDeleteKnowledgeBaseInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteKnowledgeBaseInspect() {
	for _, e := range m.DeleteKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBase at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterDeleteKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteKnowledgeBaseMock.defaultExpectation != nil && afterDeleteKnowledgeBaseCounter < 1 {
		if m.DeleteKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBase at\n%s", m.DeleteKnowledgeBaseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBase at\n%s with params: %#v", m.DeleteKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *m.DeleteKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteKnowledgeBase != nil && afterDeleteKnowledgeBaseCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBase at\n%s", m.funcDeleteKnowledgeBaseOrigin)
	}

	if !m.DeleteKnowledgeBaseMock.invocationsDone() && afterDeleteKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteKnowledgeBase at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteKnowledgeBaseMock.expectedInvocations), m.DeleteKnowledgeBaseMock.expectedInvocationsOrigin, afterDeleteKnowledgeBaseCounter)
	}
}

type mRepositoryMockDeleteKnowledgeBaseFile struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteKnowledgeBaseFileExpectation
	expectations       []*RepositoryMockDeleteKnowledgeBaseFileExpectation

	callArgs []*RepositoryMockDeleteKnowledgeBaseFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteKnowledgeBaseFileExpectation specifies expectation struct of the Repository.DeleteKnowledgeBaseFile
type RepositoryMockDeleteKnowledgeBaseFileExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteKnowledgeBaseFileParams
	paramPtrs          *RepositoryMockDeleteKnowledgeBaseFileParamPtrs
	expectationOrigins RepositoryMockDeleteKnowledgeBaseFileExpectationOrigins
	results            *RepositoryMockDeleteKnowledgeBaseFileResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteKnowledgeBaseFileParams contains parameters of the Repository.DeleteKnowledgeBaseFile
type RepositoryMockDeleteKnowledgeBaseFileParams struct {
	ctx     context.Context
	fileUID string
}

// RepositoryMockDeleteKnowledgeBaseFileParamPtrs contains pointers to parameters of the Repository.DeleteKnowledgeBaseFile
type RepositoryMockDeleteKnowledgeBaseFileParamPtrs struct {
	ctx     *context.Context
	fileUID *string
}

// RepositoryMockDeleteKnowledgeBaseFileResults contains results of the Repository.DeleteKnowledgeBaseFile
type RepositoryMockDeleteKnowledgeBaseFileResults struct {
	err error
}

// RepositoryMockDeleteKnowledgeBaseFileOrigins contains origins of expectations of the Repository.DeleteKnowledgeBaseFile
type RepositoryMockDeleteKnowledgeBaseFileExpectationOrigins struct {
	origin        string
	originCtx     string
	originFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteKnowledgeBaseFile *mRepositoryMockDeleteKnowledgeBaseFile) Optional() *mRepositoryMockDeleteKnowledgeBaseFile {
	mmDeleteKnowledgeBaseFile.optional = true
	return mmDeleteKnowledgeBaseFile
}

// Expect sets up expected params for Repository.DeleteKnowledgeBaseFile
func (mmDeleteKnowledgeBaseFile *mRepositoryMockDeleteKnowledgeBaseFile) Expect(ctx context.Context, fileUID string) *mRepositoryMockDeleteKnowledgeBaseFile {
	if mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFile mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseFileExpectation{}
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFile mock is already set by ExpectParams functions")
	}

	mmDeleteKnowledgeBaseFile.defaultExpectation.params = &RepositoryMockDeleteKnowledgeBaseFileParams{ctx, fileUID}
	mmDeleteKnowledgeBaseFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteKnowledgeBaseFile.expectations {
		if minimock.Equal(e.params, mmDeleteKnowledgeBaseFile.defaultExpectation.params) {
			mmDeleteKnowledgeBaseFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteKnowledgeBaseFile.defaultExpectation.params)
		}
	}

	return mmDeleteKnowledgeBaseFile
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteKnowledgeBaseFile
func (mmDeleteKnowledgeBaseFile *mRepositoryMockDeleteKnowledgeBaseFile) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteKnowledgeBaseFile {
	if mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFile mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseFileExpectation{}
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation.params != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFile mock is already set by Expect")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryMockDeleteKnowledgeBaseFileParamPtrs{}
	}
	mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteKnowledgeBaseFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteKnowledgeBaseFile
}

// ExpectFileUIDParam2 sets up expected param fileUID for Repository.DeleteKnowledgeBaseFile
func (mmDeleteKnowledgeBaseFile *mRepositoryMockDeleteKnowledgeBaseFile) ExpectFileUIDParam2(fileUID string) *mRepositoryMockDeleteKnowledgeBaseFile {
	if mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFile mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseFileExpectation{}
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation.params != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFile mock is already set by Expect")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryMockDeleteKnowledgeBaseFileParamPtrs{}
	}
	mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmDeleteKnowledgeBaseFile.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmDeleteKnowledgeBaseFile
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteKnowledgeBaseFile
func (mmDeleteKnowledgeBaseFile *mRepositoryMockDeleteKnowledgeBaseFile) Inspect(f func(ctx context.Context, fileUID string)) *mRepositoryMockDeleteKnowledgeBaseFile {
	if mmDeleteKnowledgeBaseFile.mock.inspectFuncDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteKnowledgeBaseFile")
	}

	mmDeleteKnowledgeBaseFile.mock.inspectFuncDeleteKnowledgeBaseFile = f

	return mmDeleteKnowledgeBaseFile
}

// Return sets up results that will be returned by Repository.DeleteKnowledgeBaseFile
func (mmDeleteKnowledgeBaseFile *mRepositoryMockDeleteKnowledgeBaseFile) Return(err error) *RepositoryMock {
	if mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFile mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseFileExpectation{mock: mmDeleteKnowledgeBaseFile.mock}
	}
	mmDeleteKnowledgeBaseFile.defaultExpectation.results = &RepositoryMockDeleteKnowledgeBaseFileResults{err}
	mmDeleteKnowledgeBaseFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBaseFile.mock
}

// Set uses given function f to mock the Repository.DeleteKnowledgeBaseFile method
func (mmDeleteKnowledgeBaseFile *mRepositoryMockDeleteKnowledgeBaseFile) Set(f func(ctx context.Context, fileUID string) (err error)) *RepositoryMock {
	if mmDeleteKnowledgeBaseFile.defaultExpectation != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteKnowledgeBaseFile method")
	}

	if len(mmDeleteKnowledgeBaseFile.expectations) > 0 {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteKnowledgeBaseFile method")
	}

	mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile = f
	mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFileOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBaseFile.mock
}

// When sets expectation for the Repository.DeleteKnowledgeBaseFile which will trigger the result defined by the following
// Then helper
func (mmDeleteKnowledgeBaseFile *mRepositoryMockDeleteKnowledgeBaseFile) When(ctx context.Context, fileUID string) *RepositoryMockDeleteKnowledgeBaseFileExpectation {
	if mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFile mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteKnowledgeBaseFileExpectation{
		mock:               mmDeleteKnowledgeBaseFile.mock,
		params:             &RepositoryMockDeleteKnowledgeBaseFileParams{ctx, fileUID},
		expectationOrigins: RepositoryMockDeleteKnowledgeBaseFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteKnowledgeBaseFile.expectations = append(mmDeleteKnowledgeBaseFile.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteKnowledgeBaseFile return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteKnowledgeBaseFileExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteKnowledgeBaseFileResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteKnowledgeBaseFile should be invoked
func (mmDeleteKnowledgeBaseFile *mRepositoryMockDeleteKnowledgeBaseFile) Times(n uint64) *mRepositoryMockDeleteKnowledgeBaseFile {
	if n == 0 {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("Times of RepositoryMock.DeleteKnowledgeBaseFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteKnowledgeBaseFile.expectedInvocations, n)
	mmDeleteKnowledgeBaseFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBaseFile
}

func (mmDeleteKnowledgeBaseFile *mRepositoryMockDeleteKnowledgeBaseFile) invocationsDone() bool {
	if len(mmDeleteKnowledgeBaseFile.expectations) == 0 && mmDeleteKnowledgeBaseFile.defaultExpectation == nil && mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFile.mock.afterDeleteKnowledgeBaseFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteKnowledgeBaseFile implements mm_repository.Repository
func (mmDeleteKnowledgeBaseFile *RepositoryMock) DeleteKnowledgeBaseFile(ctx context.Context, fileUID string) (err error) {
	mm_atomic.AddUint64(&mmDeleteKnowledgeBaseFile.beforeDeleteKnowledgeBaseFileCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteKnowledgeBaseFile.afterDeleteKnowledgeBaseFileCounter, 1)

	mmDeleteKnowledgeBaseFile.t.Helper()

	if mmDeleteKnowledgeBaseFile.inspectFuncDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.inspectFuncDeleteKnowledgeBaseFile(ctx, fileUID)
	}

	mm_params := RepositoryMockDeleteKnowledgeBaseFileParams{ctx, fileUID}

	// Record call args
	mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.mutex.Lock()
	mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.callArgs = append(mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.callArgs, &mm_params)
	mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.mutex.Unlock()

	for _, e := range mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteKnowledgeBaseFileParams{ctx, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteKnowledgeBaseFile.t.Errorf("RepositoryMock.DeleteKnowledgeBaseFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmDeleteKnowledgeBaseFile.t.Errorf("RepositoryMock.DeleteKnowledgeBaseFile got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteKnowledgeBaseFile.t.Errorf("RepositoryMock.DeleteKnowledgeBaseFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteKnowledgeBaseFile.t.Fatal("No results are set for the RepositoryMock.DeleteKnowledgeBaseFile")
		}
		return (*mm_results).err
	}
	if mmDeleteKnowledgeBaseFile.funcDeleteKnowledgeBaseFile != nil {
		return mmDeleteKnowledgeBaseFile.funcDeleteKnowledgeBaseFile(ctx, fileUID)
	}
	mmDeleteKnowledgeBaseFile.t.Fatalf("Unexpected call to RepositoryMock.DeleteKnowledgeBaseFile. %v %v", ctx, fileUID)
	return
}

// DeleteKnowledgeBaseFileAfterCounter returns a count of finished RepositoryMock.DeleteKnowledgeBaseFile invocations
func (mmDeleteKnowledgeBaseFile *RepositoryMock) DeleteKnowledgeBaseFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFile.afterDeleteKnowledgeBaseFileCounter)
}

// DeleteKnowledgeBaseFileBeforeCounter returns a count of RepositoryMock.DeleteKnowledgeBaseFile invocations
func (mmDeleteKnowledgeBaseFile *RepositoryMock) DeleteKnowledgeBaseFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFile.beforeDeleteKnowledgeBaseFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteKnowledgeBaseFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteKnowledgeBaseFile *mRepositoryMockDeleteKnowledgeBaseFile) Calls() []*RepositoryMockDeleteKnowledgeBaseFileParams {
	mmDeleteKnowledgeBaseFile.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteKnowledgeBaseFileParams, len(mmDeleteKnowledgeBaseFile.callArgs))
	copy(argCopy, mmDeleteKnowledgeBaseFile.callArgs)

	mmDeleteKnowledgeBaseFile.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteKnowledgeBaseFileDone returns true if the count of the DeleteKnowledgeBaseFile invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteKnowledgeBaseFileDone() bool {
	if m.DeleteKnowledgeBaseFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteKnowledgeBaseFileMock.invocationsDone()
}

// MinimockDeleteKnowledgeBaseFileInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteKnowledgeBaseFileInspect() {
	for _, e := range m.DeleteKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBaseFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteKnowledgeBaseFileCounter := mm_atomic.LoadUint64(&m.afterDeleteKnowledgeBaseFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteKnowledgeBaseFileMock.defaultExpectation != nil && afterDeleteKnowledgeBaseFileCounter < 1 {
		if m.DeleteKnowledgeBaseFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBaseFile at\n%s", m.DeleteKnowledgeBaseFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBaseFile at\n%s with params: %#v", m.DeleteKnowledgeBaseFileMock.defaultExpectation.expectationOrigins.origin, *m.DeleteKnowledgeBaseFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteKnowledgeBaseFile != nil && afterDeleteKnowledgeBaseFileCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBaseFile at\n%s", m.funcDeleteKnowledgeBaseFileOrigin)
	}

	if !m.DeleteKnowledgeBaseFileMock.invocationsDone() && afterDeleteKnowledgeBaseFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteKnowledgeBaseFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteKnowledgeBaseFileMock.expectedInvocations), m.DeleteKnowledgeBaseFileMock.expectedInvocationsOrigin, afterDeleteKnowledgeBaseFileCounter)
	}
}

type mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation
	expectations       []*RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation

	callArgs []*RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation specifies expectation struct of the Repository.DeleteKnowledgeBaseFileAndDecreaseUsage
type RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParams
	paramPtrs          *RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParamPtrs
	expectationOrigins RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectationOrigins
	results            *RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParams contains parameters of the Repository.DeleteKnowledgeBaseFileAndDecreaseUsage
type RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParams struct {
	ctx     context.Context
	fileUID types.FileUIDType
}

// RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParamPtrs contains pointers to parameters of the Repository.DeleteKnowledgeBaseFileAndDecreaseUsage
type RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParamPtrs struct {
	ctx     *context.Context
	fileUID *types.FileUIDType
}

// RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageResults contains results of the Repository.DeleteKnowledgeBaseFileAndDecreaseUsage
type RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageResults struct {
	err error
}

// RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageOrigins contains origins of expectations of the Repository.DeleteKnowledgeBaseFileAndDecreaseUsage
type RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectationOrigins struct {
	origin        string
	originCtx     string
	originFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage) Optional() *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage {
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.optional = true
	return mmDeleteKnowledgeBaseFileAndDecreaseUsage
}

// Expect sets up expected params for Repository.DeleteKnowledgeBaseFileAndDecreaseUsage
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage) Expect(ctx context.Context, fileUID types.FileUIDType) *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage {
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation{}
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.paramPtrs != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by ExpectParams functions")
	}

	mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.params = &RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParams{ctx, fileUID}
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectations {
		if minimock.Equal(e.params, mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.params) {
			mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.params)
		}
	}

	return mmDeleteKnowledgeBaseFileAndDecreaseUsage
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteKnowledgeBaseFileAndDecreaseUsage
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage {
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation{}
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.params != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by Expect")
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.paramPtrs = &RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParamPtrs{}
	}
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteKnowledgeBaseFileAndDecreaseUsage
}

// ExpectFileUIDParam2 sets up expected param fileUID for Repository.DeleteKnowledgeBaseFileAndDecreaseUsage
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage) ExpectFileUIDParam2(fileUID types.FileUIDType) *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage {
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation{}
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.params != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by Expect")
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.paramPtrs = &RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParamPtrs{}
	}
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmDeleteKnowledgeBaseFileAndDecreaseUsage
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteKnowledgeBaseFileAndDecreaseUsage
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage) Inspect(f func(ctx context.Context, fileUID types.FileUIDType)) *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage {
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.inspectFuncDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage")
	}

	mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.inspectFuncDeleteKnowledgeBaseFileAndDecreaseUsage = f

	return mmDeleteKnowledgeBaseFileAndDecreaseUsage
}

// Return sets up results that will be returned by Repository.DeleteKnowledgeBaseFileAndDecreaseUsage
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage) Return(err error) *RepositoryMock {
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation{mock: mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock}
	}
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.results = &RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageResults{err}
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock
}

// Set uses given function f to mock the Repository.DeleteKnowledgeBaseFileAndDecreaseUsage method
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage) Set(f func(ctx context.Context, fileUID types.FileUIDType) (err error)) *RepositoryMock {
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteKnowledgeBaseFileAndDecreaseUsage method")
	}

	if len(mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectations) > 0 {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteKnowledgeBaseFileAndDecreaseUsage method")
	}

	mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsage = f
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsageOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock
}

// When sets expectation for the Repository.DeleteKnowledgeBaseFileAndDecreaseUsage which will trigger the result defined by the following
// Then helper
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage) When(ctx context.Context, fileUID types.FileUIDType) *RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation {
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation{
		mock:               mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock,
		params:             &RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParams{ctx, fileUID},
		expectationOrigins: RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectations = append(mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteKnowledgeBaseFileAndDecreaseUsage return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteKnowledgeBaseFileAndDecreaseUsage should be invoked
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage) Times(n uint64) *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage {
	if n == 0 {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("Times of RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectedInvocations, n)
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBaseFileAndDecreaseUsage
}

func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage) invocationsDone() bool {
	if len(mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectations) == 0 && mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation == nil && mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteKnowledgeBaseFileAndDecreaseUsage implements mm_repository.Repository
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *RepositoryMock) DeleteKnowledgeBaseFileAndDecreaseUsage(ctx context.Context, fileUID types.FileUIDType) (err error) {
	mm_atomic.AddUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.beforeDeleteKnowledgeBaseFileAndDecreaseUsageCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter, 1)

	mmDeleteKnowledgeBaseFileAndDecreaseUsage.t.Helper()

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.inspectFuncDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.inspectFuncDeleteKnowledgeBaseFileAndDecreaseUsage(ctx, fileUID)
	}

	mm_params := RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParams{ctx, fileUID}

	// Record call args
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.mutex.Lock()
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.callArgs = append(mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.callArgs, &mm_params)
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.mutex.Unlock()

	for _, e := range mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParams{ctx, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteKnowledgeBaseFileAndDecreaseUsage.t.Errorf("RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmDeleteKnowledgeBaseFileAndDecreaseUsage.t.Errorf("RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteKnowledgeBaseFileAndDecreaseUsage.t.Errorf("RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteKnowledgeBaseFileAndDecreaseUsage.t.Fatal("No results are set for the RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage")
		}
		return (*mm_results).err
	}
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.funcDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		return mmDeleteKnowledgeBaseFileAndDecreaseUsage.funcDeleteKnowledgeBaseFileAndDecreaseUsage(ctx, fileUID)
	}
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.t.Fatalf("Unexpected call to RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage. %v %v", ctx, fileUID)
	return
}

// DeleteKnowledgeBaseFileAndDecreaseUsageAfterCounter returns a count of finished RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage invocations
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *RepositoryMock) DeleteKnowledgeBaseFileAndDecreaseUsageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter)
}

// DeleteKnowledgeBaseFileAndDecreaseUsageBeforeCounter returns a count of RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage invocations
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *RepositoryMock) DeleteKnowledgeBaseFileAndDecreaseUsageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.beforeDeleteKnowledgeBaseFileAndDecreaseUsageCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage) Calls() []*RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParams {
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParams, len(mmDeleteKnowledgeBaseFileAndDecreaseUsage.callArgs))
	copy(argCopy, mmDeleteKnowledgeBaseFileAndDecreaseUsage.callArgs)

	mmDeleteKnowledgeBaseFileAndDecreaseUsage.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteKnowledgeBaseFileAndDecreaseUsageDone returns true if the count of the DeleteKnowledgeBaseFileAndDecreaseUsage invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteKnowledgeBaseFileAndDecreaseUsageDone() bool {
	if m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.invocationsDone()
}

// MinimockDeleteKnowledgeBaseFileAndDecreaseUsageInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteKnowledgeBaseFileAndDecreaseUsageInspect() {
	for _, e := range m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter := mm_atomic.LoadUint64(&m.afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation != nil && afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter < 1 {
		if m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage at\n%s", m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage at\n%s with params: %#v", m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.expectationOrigins.origin, *m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteKnowledgeBaseFileAndDecreaseUsage != nil && afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage at\n%s", m.funcDeleteKnowledgeBaseFileAndDecreaseUsageOrigin)
	}

	if !m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.invocationsDone() && afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.expectedInvocations), m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.expectedInvocationsOrigin, afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter)
	}
}

type mRepositoryMockDeleteKnowledgeBaseTx struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteKnowledgeBaseTxExpectation
	expectations       []*RepositoryMockDeleteKnowledgeBaseTxExpectation

	callArgs []*RepositoryMockDeleteKnowledgeBaseTxParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteKnowledgeBaseTxExpectation specifies expectation struct of the Repository.DeleteKnowledgeBaseTx
type RepositoryMockDeleteKnowledgeBaseTxExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteKnowledgeBaseTxParams
	paramPtrs          *RepositoryMockDeleteKnowledgeBaseTxParamPtrs
	expectationOrigins RepositoryMockDeleteKnowledgeBaseTxExpectationOrigins
	results            *RepositoryMockDeleteKnowledgeBaseTxResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteKnowledgeBaseTxParams contains parameters of the Repository.DeleteKnowledgeBaseTx
type RepositoryMockDeleteKnowledgeBaseTxParams struct {
	ctx   context.Context
	tx    *gorm.DB
	owner string
	kbID  string
}

// RepositoryMockDeleteKnowledgeBaseTxParamPtrs contains pointers to parameters of the Repository.DeleteKnowledgeBaseTx
type RepositoryMockDeleteKnowledgeBaseTxParamPtrs struct {
	ctx   *context.Context
	tx    **gorm.DB
	owner *string
	kbID  *string
}

// RepositoryMockDeleteKnowledgeBaseTxResults contains results of the Repository.DeleteKnowledgeBaseTx
type RepositoryMockDeleteKnowledgeBaseTxResults struct {
	err error
}

// RepositoryMockDeleteKnowledgeBaseTxOrigins contains origins of expectations of the Repository.DeleteKnowledgeBaseTx
type RepositoryMockDeleteKnowledgeBaseTxExpectationOrigins struct {
	origin      string
	originCtx   string
	originTx    string
	originOwner string
	originKbID  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteKnowledgeBaseTx *mRepositoryMockDeleteKnowledgeBaseTx) Optional() *mRepositoryMockDeleteKnowledgeBaseTx {
	mmDeleteKnowledgeBaseTx.optional = true
	return mmDeleteKnowledgeBaseTx
}

// Expect sets up expected params for Repository.DeleteKnowledgeBaseTx
func (mmDeleteKnowledgeBaseTx *mRepositoryMockDeleteKnowledgeBaseTx) Expect(ctx context.Context, tx *gorm.DB, owner string, kbID string) *mRepositoryMockDeleteKnowledgeBaseTx {
	if mmDeleteKnowledgeBaseTx.mock.funcDeleteKnowledgeBaseTx != nil {
		mmDeleteKnowledgeBaseTx.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseTx mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseTx.defaultExpectation == nil {
		mmDeleteKnowledgeBaseTx.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseTxExpectation{}
	}

	if mmDeleteKnowledgeBaseTx.defaultExpectation.paramPtrs != nil {
		mmDeleteKnowledgeBaseTx.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseTx mock is already set by ExpectParams functions")
	}

	mmDeleteKnowledgeBaseTx.defaultExpectation.params = &RepositoryMockDeleteKnowledgeBaseTxParams{ctx, tx, owner, kbID}
	mmDeleteKnowledgeBaseTx.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteKnowledgeBaseTx.expectations {
		if minimock.Equal(e.params, mmDeleteKnowledgeBaseTx.defaultExpectation.params) {
			mmDeleteKnowledgeBaseTx.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteKnowledgeBaseTx.defaultExpectation.params)
		}
	}

	return mmDeleteKnowledgeBaseTx
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteKnowledgeBaseTx
func (mmDeleteKnowledgeBaseTx *mRepositoryMockDeleteKnowledgeBaseTx) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteKnowledgeBaseTx {
	if mmDeleteKnowledgeBaseTx.mock.funcDeleteKnowledgeBaseTx != nil {
		mmDeleteKnowledgeBaseTx.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseTx mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseTx.defaultExpectation == nil {
		mmDeleteKnowledgeBaseTx.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseTxExpectation{}
	}

	if mmDeleteKnowledgeBaseTx.defaultExpectation.params != nil {
		mmDeleteKnowledgeBaseTx.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseTx mock is already set by Expect")
	}

	if mmDeleteKnowledgeBaseTx.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBaseTx.defaultExpectation.paramPtrs = &RepositoryMockDeleteKnowledgeBaseTxParamPtrs{}
	}
	mmDeleteKnowledgeBaseTx.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteKnowledgeBaseTx.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteKnowledgeBaseTx
}

// ExpectTxParam2 sets up expected param tx for Repository.DeleteKnowledgeBaseTx
func (mmDeleteKnowledgeBaseTx *mRepositoryMockDeleteKnowledgeBaseTx) ExpectTxParam2(tx *gorm.DB) *mRepositoryMockDeleteKnowledgeBaseTx {
	if mmDeleteKnowledgeBaseTx.mock.funcDeleteKnowledgeBaseTx != nil {
		mmDeleteKnowledgeBaseTx.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseTx mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseTx.defaultExpectation == nil {
		mmDeleteKnowledgeBaseTx.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseTxExpectation{}
	}

	if mmDeleteKnowledgeBaseTx.defaultExpectation.params != nil {
		mmDeleteKnowledgeBaseTx.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseTx mock is already set by Expect")
	}

	if mmDeleteKnowledgeBaseTx.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBaseTx.defaultExpectation.paramPtrs = &RepositoryMockDeleteKnowledgeBaseTxParamPtrs{}
	}
	mmDeleteKnowledgeBaseTx.defaultExpectation.paramPtrs.tx = &tx
	mmDeleteKnowledgeBaseTx.defaultExpectation.expectationOrigins.originTx = minimock.CallerInfo(1)

	return mmDeleteKnowledgeBaseTx
}

// ExpectOwnerParam3 sets up expected param owner for Repository.DeleteKnowledgeBaseTx
func (mmDeleteKnowledgeBaseTx *mRepositoryMockDeleteKnowledgeBaseTx) ExpectOwnerParam3(owner string) *mRepositoryMockDeleteKnowledgeBaseTx {
	if mmDeleteKnowledgeBaseTx.mock.funcDeleteKnowledgeBaseTx != nil {
		mmDeleteKnowledgeBaseTx.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseTx mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseTx.defaultExpectation == nil {
		mmDeleteKnowledgeBaseTx.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseTxExpectation{}
	}

	if mmDeleteKnowledgeBaseTx.defaultExpectation.params != nil {
		mmDeleteKnowledgeBaseTx.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseTx mock is already set by Expect")
	}

	if mmDeleteKnowledgeBaseTx.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBaseTx.defaultExpectation.paramPtrs = &RepositoryMockDeleteKnowledgeBaseTxParamPtrs{}
	}
	mmDeleteKnowledgeBaseTx.defaultExpectation.paramPtrs.owner = &owner
	mmDeleteKnowledgeBaseTx.defaultExpectation.expectationOrigins.originOwner = minimock.CallerInfo(1)

	return mmDeleteKnowledgeBaseTx
}

// ExpectKbIDParam4 sets up expected param kbID for Repository.DeleteKnowledgeBaseTx
func (mmDeleteKnowledgeBaseTx *mRepositoryMockDeleteKnowledgeBaseTx) ExpectKbIDParam4(kbID string) *mRepositoryMockDeleteKnowledgeBaseTx {
	if mmDeleteKnowledgeBaseTx.mock.funcDeleteKnowledgeBaseTx != nil {
		mmDeleteKnowledgeBaseTx.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseTx mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseTx.defaultExpectation == nil {
		mmDeleteKnowledgeBaseTx.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseTxExpectation{}
	}

	if mmDeleteKnowledgeBaseTx.defaultExpectation.params != nil {
		mmDeleteKnowledgeBaseTx.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseTx mock is already set by Expect")
	}

	if mmDeleteKnowledgeBaseTx.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBaseTx.defaultExpectation.paramPtrs = &RepositoryMockDeleteKnowledgeBaseTxParamPtrs{}
	}
	mmDeleteKnowledgeBaseTx.defaultExpectation.paramPtrs.kbID = &kbID
	mmDeleteKnowledgeBaseTx.defaultExpectation.expectationOrigins.originKbID = minimock.CallerInfo(1)

	return mmDeleteKnowledgeBaseTx
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteKnowledgeBaseTx
func (mmDeleteKnowledgeBaseTx *mRepositoryMockDeleteKnowledgeBaseTx) Inspect(f func(ctx context.Context, tx *gorm.DB, owner string, kbID string)) *mRepositoryMockDeleteKnowledgeBaseTx {
	if mmDeleteKnowledgeBaseTx.mock.inspectFuncDeleteKnowledgeBaseTx != nil {
		mmDeleteKnowledgeBaseTx.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteKnowledgeBaseTx")
	}

	mmDeleteKnowledgeBaseTx.mock.inspectFuncDeleteKnowledgeBaseTx = f

	return mmDeleteKnowledgeBaseTx
}

// Return sets up results that will be returned by Repository.DeleteKnowledgeBaseTx
func (mmDeleteKnowledgeBaseTx *mRepositoryMockDeleteKnowledgeBaseTx) Return(err error) *RepositoryMock {
	if mmDeleteKnowledgeBaseTx.mock.funcDeleteKnowledgeBaseTx != nil {
		mmDeleteKnowledgeBaseTx.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseTx mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseTx.defaultExpectation == nil {
		mmDeleteKnowledgeBaseTx.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseTxExpectation{mock: mmDeleteKnowledgeBaseTx.mock}
	}
	mmDeleteKnowledgeBaseTx.defaultExpectation.results = &RepositoryMockDeleteKnowledgeBaseTxResults{err}
	mmDeleteKnowledgeBaseTx.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBaseTx.mock
}

// Set uses given function f to mock the Repository.DeleteKnowledgeBaseTx method
func (mmDeleteKnowledgeBaseTx *mRepositoryMockDeleteKnowledgeBaseTx) Set(f func(ctx context.Context, tx *gorm.DB, owner string, kbID string) (err error)) *RepositoryMock {
	if mmDeleteKnowledgeBaseTx.defaultExpectation != nil {
		mmDeleteKnowledgeBaseTx.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteKnowledgeBaseTx method")
	}

	if len(mmDeleteKnowledgeBaseTx.expectations) > 0 {
		mmDeleteKnowledgeBaseTx.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteKnowledgeBaseTx method")
	}

	mmDeleteKnowledgeBaseTx.mock.funcDeleteKnowledgeBaseTx = f
	mmDeleteKnowledgeBaseTx.mock.funcDeleteKnowledgeBaseTxOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBaseTx.mock
}

// When sets expectation for the Repository.DeleteKnowledgeBaseTx which will trigger the result defined by the following
// Then helper
func (mmDeleteKnowledgeBaseTx *mRepositoryMockDeleteKnowledgeBaseTx) When(ctx context.Context, tx *gorm.DB, owner string, kbID string) *RepositoryMockDeleteKnowledgeBaseTxExpectation {
	if mmDeleteKnowledgeBaseTx.mock.funcDeleteKnowledgeBaseTx != nil {
		mmDeleteKnowledgeBaseTx.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseTx mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteKnowledgeBaseTxExpectation{
		mock:               mmDeleteKnowledgeBaseTx.mock,
		params:             &RepositoryMockDeleteKnowledgeBaseTxParams{ctx, tx, owner, kbID},
		expectationOrigins: RepositoryMockDeleteKnowledgeBaseTxExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteKnowledgeBaseTx.expectations = append(mmDeleteKnowledgeBaseTx.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteKnowledgeBaseTx return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteKnowledgeBaseTxExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteKnowledgeBaseTxResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteKnowledgeBaseTx should be invoked
func (mmDeleteKnowledgeBaseTx *mRepositoryMockDeleteKnowledgeBaseTx) Times(n uint64) *mRepositoryMockDeleteKnowledgeBaseTx {
	if n == 0 {
		mmDeleteKnowledgeBaseTx.mock.t.Fatalf("Times of RepositoryMock.DeleteKnowledgeBaseTx mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteKnowledgeBaseTx.expectedInvocations, n)
	mmDeleteKnowledgeBaseTx.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBaseTx
}

func (mmDeleteKnowledgeBaseTx *mRepositoryMockDeleteKnowledgeBaseTx) invocationsDone() bool {
	if len(mmDeleteKnowledgeBaseTx.expectations) == 0 && mmDeleteKnowledgeBaseTx.defaultExpectation == nil && mmDeleteKnowledgeBaseTx.mock.funcDeleteKnowledgeBaseTx == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseTx.mock.afterDeleteKnowledgeBaseTxCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseTx.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteKnowledgeBaseTx implements mm_repository.Repository
func (mmDeleteKnowledgeBaseTx *RepositoryMock) DeleteKnowledgeBaseTx(ctx context.Context, tx *gorm.DB, owner string, kbID string) (err error) {
	mm_atomic.AddUint64(&mmDeleteKnowledgeBaseTx.beforeDeleteKnowledgeBaseTxCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteKnowledgeBaseTx.afterDeleteKnowledgeBaseTxCounter, 1)

	mmDeleteKnowledgeBaseTx.t.Helper()

	if mmDeleteKnowledgeBaseTx.inspectFuncDeleteKnowledgeBaseTx != nil {
		mmDeleteKnowledgeBaseTx.inspectFuncDeleteKnowledgeBaseTx(ctx, tx, owner, kbID)
	}

	mm_params := RepositoryMockDeleteKnowledgeBaseTxParams{ctx, tx, owner, kbID}

	// Record call args
	mmDeleteKnowledgeBaseTx.DeleteKnowledgeBaseTxMock.mutex.Lock()
	mmDeleteKnowledgeBaseTx.DeleteKnowledgeBaseTxMock.callArgs = append(mmDeleteKnowledgeBaseTx.DeleteKnowledgeBaseTxMock.callArgs, &mm_params)
	mmDeleteKnowledgeBaseTx.DeleteKnowledgeBaseTxMock.mutex.Unlock()

	for _, e := range mmDeleteKnowledgeBaseTx.DeleteKnowledgeBaseTxMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteKnowledgeBaseTx.DeleteKnowledgeBaseTxMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteKnowledgeBaseTx.DeleteKnowledgeBaseTxMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteKnowledgeBaseTx.DeleteKnowledgeBaseTxMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteKnowledgeBaseTx.DeleteKnowledgeBaseTxMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteKnowledgeBaseTxParams{ctx, tx, owner, kbID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteKnowledgeBaseTx.t.Errorf("RepositoryMock.DeleteKnowledgeBaseTx got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteKnowledgeBaseTx.DeleteKnowledgeBaseTxMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tx != nil && !minimock.Equal(*mm_want_ptrs.tx, mm_got.tx) {
				mmDeleteKnowledgeBaseTx.t.Errorf("RepositoryMock.DeleteKnowledgeBaseTx got unexpected parameter tx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteKnowledgeBaseTx.DeleteKnowledgeBaseTxMock.defaultExpectation.expectationOrigins.originTx, *mm_want_ptrs.tx, mm_got.tx, minimock.Diff(*mm_want_ptrs.tx, mm_got.tx))
			}

			if mm_want_ptrs.owner != nil && !minimock.Equal(*mm_want_ptrs.owner, mm_got.owner) {
				mmDeleteKnowledgeBaseTx.t.Errorf("RepositoryMock.DeleteKnowledgeBaseTx got unexpected parameter owner, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteKnowledgeBaseTx.DeleteKnowledgeBaseTxMock.defaultExpectation.expectationOrigins.originOwner, *mm_want_ptrs.owner, mm_got.owner, minimock.Diff(*mm_want_ptrs.owner, mm_got.owner))
			}

			if mm_want_ptrs.kbID != nil && !minimock.Equal(*mm_want_ptrs.kbID, mm_got.kbID) {
				mmDeleteKnowledgeBaseTx.t.Errorf("RepositoryMock.DeleteKnowledgeBaseTx got unexpected parameter kbID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteKnowledgeBaseTx.DeleteKnowledgeBaseTxMock.defaultExpectation.expectationOrigins.originKbID, *mm_want_ptrs.kbID, mm_got.kbID, minimock.Diff(*mm_want_ptrs.kbID, mm_got.kbID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteKnowledgeBaseTx.t.Errorf("RepositoryMock.DeleteKnowledgeBaseTx got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteKnowledgeBaseTx.DeleteKnowledgeBaseTxMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteKnowledgeBaseTx.DeleteKnowledgeBaseTxMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteKnowledgeBaseTx.t.Fatal("No results are set for the RepositoryMock.DeleteKnowledgeBaseTx")
		}
		return (*mm_results).err
	}
	if mmDeleteKnowledgeBaseTx.funcDeleteKnowledgeBaseTx != nil {
		return mmDeleteKnowledgeBaseTx.funcDeleteKnowledgeBaseTx(ctx, tx, owner, kbID)
	}
	mmDeleteKnowledgeBaseTx.t.Fatalf("Unexpected call to RepositoryMock.DeleteKnowledgeBaseTx. %v %v %v %v", ctx, tx, owner, kbID)
	return
}

// DeleteKnowledgeBaseTxAfterCounter returns a count of finished RepositoryMock.DeleteKnowledgeBaseTx invocations
func (mmDeleteKnowledgeBaseTx *RepositoryMock) DeleteKnowledgeBaseTxAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseTx.afterDeleteKnowledgeBaseTxCounter)
}

// DeleteKnowledgeBaseTxBeforeCounter returns a count of RepositoryMock.DeleteKnowledgeBaseTx invocations
func (mmDeleteKnowledgeBaseTx *RepositoryMock) DeleteKnowledgeBaseTxBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseTx.beforeDeleteKnowledgeBaseTxCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteKnowledgeBaseTx.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteKnowledgeBaseTx *mRepositoryMockDeleteKnowledgeBaseTx) Calls() []*RepositoryMockDeleteKnowledgeBaseTxParams {
	mmDeleteKnowledgeBaseTx.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteKnowledgeBaseTxParams, len(mmDeleteKnowledgeBaseTx.callArgs))
	copy(argCopy, mmDeleteKnowledgeBaseTx.callArgs)

	mmDeleteKnowledgeBaseTx.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteKnowledgeBaseTxDone returns true if the count of the DeleteKnowledgeBaseTx invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteKnowledgeBaseTxDone() bool {
	if m.DeleteKnowledgeBaseTxMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteKnowledgeBaseTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteKnowledgeBaseTxMock.invocationsDone()
}

// MinimockDeleteKnowledgeBaseTxInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteKnowledgeBaseTxInspect() {
	for _, e := range m.DeleteKnowledgeBaseTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBaseTx at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteKnowledgeBaseTxCounter := mm_atomic.LoadUint64(&m.afterDeleteKnowledgeBaseTxCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteKnowledgeBaseTxMock.defaultExpectation != nil && afterDeleteKnowledgeBaseTxCounter < 1 {
		if m.DeleteKnowledgeBaseTxMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBaseTx at\n%s", m.DeleteKnowledgeBaseTxMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBaseTx at\n%s with params: %#v", m.DeleteKnowledgeBaseTxMock.defaultExpectation.expectationOrigins.origin, *m.DeleteKnowledgeBaseTxMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteKnowledgeBaseTx != nil && afterDeleteKnowledgeBaseTxCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBaseTx at\n%s", m.funcDeleteKnowledgeBaseTxOrigin)
	}

	if !m.DeleteKnowledgeBaseTxMock.invocationsDone() && afterDeleteKnowledgeBaseTxCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteKnowledgeBaseTx at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteKnowledgeBaseTxMock.expectedInvocations), m.DeleteKnowledgeBaseTxMock.expectedInvocationsOrigin, afterDeleteKnowledgeBaseTxCounter)
	}
}

type mRepositoryMockDeleteObject struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteObjectExpectation
	expectations       []*RepositoryMockDeleteObjectExpectation

	callArgs []*RepositoryMockDeleteObjectParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteObjectExpectation specifies expectation struct of the Repository.DeleteObject
type RepositoryMockDeleteObjectExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteObjectParams
	paramPtrs          *RepositoryMockDeleteObjectParamPtrs
	expectationOrigins RepositoryMockDeleteObjectExpectationOrigins
	results            *RepositoryMockDeleteObjectResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteObjectParams contains parameters of the Repository.DeleteObject
type RepositoryMockDeleteObjectParams struct {
	ctx context.Context
	uid types.ObjectUIDType
}

// RepositoryMockDeleteObjectParamPtrs contains pointers to parameters of the Repository.DeleteObject
type RepositoryMockDeleteObjectParamPtrs struct {
	ctx *context.Context
	uid *types.ObjectUIDType
}

// RepositoryMockDeleteObjectResults contains results of the Repository.DeleteObject
type RepositoryMockDeleteObjectResults struct {
	err error
}

// RepositoryMockDeleteObjectOrigins contains origins of expectations of the Repository.DeleteObject
type RepositoryMockDeleteObjectExpectationOrigins struct {
	origin    string
	originCtx string
	originUid string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteObject *mRepositoryMockDeleteObject) Optional() *mRepositoryMockDeleteObject {
	mmDeleteObject.optional = true
	return mmDeleteObject
}

// Expect sets up expected params for Repository.DeleteObject
func (mmDeleteObject *mRepositoryMockDeleteObject) Expect(ctx context.Context, uid types.ObjectUIDType) *mRepositoryMockDeleteObject {
	if mmDeleteObject.mock.funcDeleteObject != nil {
		mmDeleteObject.mock.t.Fatalf("RepositoryMock.DeleteObject mock is already set by Set")
	}

	if mmDeleteObject.defaultExpectation == nil {
		mmDeleteObject.defaultExpectation = &RepositoryMockDeleteObjectExpectation{}
	}

	if mmDeleteObject.defaultExpectation.paramPtrs != nil {
		mmDeleteObject.mock.t.Fatalf("RepositoryMock.DeleteObject mock is already set by ExpectParams functions")
	}

	mmDeleteObject.defaultExpectation.params = &RepositoryMockDeleteObjectParams{ctx, uid}
	mmDeleteObject.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteObject.expectations {
		if minimock.Equal(e.params, mmDeleteObject.defaultExpectation.params) {
			mmDeleteObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteObject.defaultExpectation.params)
		}
	}

	return mmDeleteObject
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteObject
func (mmDeleteObject *mRepositoryMockDeleteObject) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteObject {
	if mmDeleteObject.mock.funcDeleteObject != nil {
		mmDeleteObject.mock.t.Fatalf("RepositoryMock.DeleteObject mock is already set by Set")
	}

	if mmDeleteObject.defaultExpectation == nil {
		mmDeleteObject.defaultExpectation = &RepositoryMockDeleteObjectExpectation{}
	}

	if mmDeleteObject.defaultExpectation.params != nil {
		mmDeleteObject.mock.t.Fatalf("RepositoryMock.DeleteObject mock is already set by Expect")
	}

	if mmDeleteObject.defaultExpectation.paramPtrs == nil {
		mmDeleteObject.defaultExpectation.paramPtrs = &RepositoryMockDeleteObjectParamPtrs{}
	}
	mmDeleteObject.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteObject.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteObject
}

// ExpectUidParam2 sets up expected param uid for Repository.DeleteObject
func (mmDeleteObject *mRepositoryMockDeleteObject) ExpectUidParam2(uid types.ObjectUIDType) *mRepositoryMockDeleteObject {
	if mmDeleteObject.mock.funcDeleteObject != nil {
		mmDeleteObject.mock.t.Fatalf("RepositoryMock.DeleteObject mock is already set by Set")
	}

	if mmDeleteObject.defaultExpectation == nil {
		mmDeleteObject.defaultExpectation = &RepositoryMockDeleteObjectExpectation{}
	}

	if mmDeleteObject.defaultExpectation.params != nil {
		mmDeleteObject.mock.t.Fatalf("RepositoryMock.DeleteObject mock is already set by Expect")
	}

	if mmDeleteObject.defaultExpectation.paramPtrs == nil {
		mmDeleteObject.defaultExpectation.paramPtrs = &RepositoryMockDeleteObjectParamPtrs{}
	}
	mmDeleteObject.defaultExpectation.paramPtrs.uid = &uid
	mmDeleteObject.defaultExpectation.expectationOrigins.originUid = minimock.CallerInfo(1)

	return mmDeleteObject
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteObject
func (mmDeleteObject *mRepositoryMockDeleteObject) Inspect(f func(ctx context.Context, uid types.ObjectUIDType)) *mRepositoryMockDeleteObject {
	if mmDeleteObject.mock.inspectFuncDeleteObject != nil {
		mmDeleteObject.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteObject")
	}

	mmDeleteObject.mock.inspectFuncDeleteObject = f

	return mmDeleteObject
}

// Return sets up results that will be returned by Repository.DeleteObject
func (mmDeleteObject *mRepositoryMockDeleteObject) Return(err error) *RepositoryMock {
	if mmDeleteObject.mock.funcDeleteObject != nil {
		mmDeleteObject.mock.t.Fatalf("RepositoryMock.DeleteObject mock is already set by Set")
	}

	if mmDeleteObject.defaultExpectation == nil {
		mmDeleteObject.defaultExpectation = &RepositoryMockDeleteObjectExpectation{mock: mmDeleteObject.mock}
	}
	mmDeleteObject.defaultExpectation.results = &RepositoryMockDeleteObjectResults{err}
	mmDeleteObject.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteObject.mock
}

// Set uses given function f to mock the Repository.DeleteObject method
func (mmDeleteObject *mRepositoryMockDeleteObject) Set(f func(ctx context.Context, uid types.ObjectUIDType) (err error)) *RepositoryMock {
	if mmDeleteObject.defaultExpectation != nil {
		mmDeleteObject.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteObject method")
	}

	if len(mmDeleteObject.expectations) > 0 {
		mmDeleteObject.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteObject method")
	}

	mmDeleteObject.mock.funcDeleteObject = f
	mmDeleteObject.mock.funcDeleteObjectOrigin = minimock.CallerInfo(1)
	return mmDeleteObject.mock
}

// When sets expectation for the Repository.DeleteObject which will trigger the result defined by the following
// Then helper
func (mmDeleteObject *mRepositoryMockDeleteObject) When(ctx context.Context, uid types.ObjectUIDType) *RepositoryMockDeleteObjectExpectation {
	if mmDeleteObject.mock.funcDeleteObject != nil {
		mmDeleteObject.mock.t.Fatalf("RepositoryMock.DeleteObject mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteObjectExpectation{
		mock:               mmDeleteObject.mock,
		params:             &RepositoryMockDeleteObjectParams{ctx, uid},
		expectationOrigins: RepositoryMockDeleteObjectExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteObject.expectations = append(mmDeleteObject.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteObject return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteObjectExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteObjectResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteObject should be invoked
func (mmDeleteObject *mRepositoryMockDeleteObject) Times(n uint64) *mRepositoryMockDeleteObject {
	if n == 0 {
		mmDeleteObject.mock.t.Fatalf("Times of RepositoryMock.DeleteObject mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteObject.expectedInvocations, n)
	mmDeleteObject.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteObject
}

func (mmDeleteObject *mRepositoryMockDeleteObject) invocationsDone() bool {
	if len(mmDeleteObject.expectations) == 0 && mmDeleteObject.defaultExpectation == nil && mmDeleteObject.mock.funcDeleteObject == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteObject.mock.afterDeleteObjectCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteObject.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteObject implements mm_repository.Repository
func (mmDeleteObject *RepositoryMock) DeleteObject(ctx context.Context, uid types.ObjectUIDType) (err error) {
	mm_atomic.AddUint64(&mmDeleteObject.beforeDeleteObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteObject.afterDeleteObjectCounter, 1)

	mmDeleteObject.t.Helper()

	if mmDeleteObject.inspectFuncDeleteObject != nil {
		mmDeleteObject.inspectFuncDeleteObject(ctx, uid)
	}

	mm_params := RepositoryMockDeleteObjectParams{ctx, uid}

	// Record call args
	mmDeleteObject.DeleteObjectMock.mutex.Lock()
	mmDeleteObject.DeleteObjectMock.callArgs = append(mmDeleteObject.DeleteObjectMock.callArgs, &mm_params)
	mmDeleteObject.DeleteObjectMock.mutex.Unlock()

	for _, e := range mmDeleteObject.DeleteObjectMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteObject.DeleteObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteObject.DeleteObjectMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteObject.DeleteObjectMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteObject.DeleteObjectMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteObjectParams{ctx, uid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteObject.t.Errorf("RepositoryMock.DeleteObject got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteObject.DeleteObjectMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmDeleteObject.t.Errorf("RepositoryMock.DeleteObject got unexpected parameter uid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteObject.DeleteObjectMock.defaultExpectation.expectationOrigins.originUid, *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteObject.t.Errorf("RepositoryMock.DeleteObject got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteObject.DeleteObjectMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteObject.DeleteObjectMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteObject.t.Fatal("No results are set for the RepositoryMock.DeleteObject")
		}
		return (*mm_results).err
	}
	if mmDeleteObject.funcDeleteObject != nil {
		return mmDeleteObject.funcDeleteObject(ctx, uid)
	}
	mmDeleteObject.t.Fatalf("Unexpected call to RepositoryMock.DeleteObject. %v %v", ctx, uid)
	return
}

// DeleteObjectAfterCounter returns a count of finished RepositoryMock.DeleteObject invocations
func (mmDeleteObject *RepositoryMock) DeleteObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteObject.afterDeleteObjectCounter)
}

// DeleteObjectBeforeCounter returns a count of RepositoryMock.DeleteObject invocations
func (mmDeleteObject *RepositoryMock) DeleteObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteObject.beforeDeleteObjectCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteObject *mRepositoryMockDeleteObject) Calls() []*RepositoryMockDeleteObjectParams {
	mmDeleteObject.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteObjectParams, len(mmDeleteObject.callArgs))
	copy(argCopy, mmDeleteObject.callArgs)

	mmDeleteObject.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteObjectDone returns true if the count of the DeleteObject invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteObjectDone() bool {
	if m.DeleteObjectMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteObjectMock.invocationsDone()
}

// MinimockDeleteObjectInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteObjectInspect() {
	for _, e := range m.DeleteObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteObject at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteObjectCounter := mm_atomic.LoadUint64(&m.afterDeleteObjectCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteObjectMock.defaultExpectation != nil && afterDeleteObjectCounter < 1 {
		if m.DeleteObjectMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteObject at\n%s", m.DeleteObjectMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteObject at\n%s with params: %#v", m.DeleteObjectMock.defaultExpectation.expectationOrigins.origin, *m.DeleteObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteObject != nil && afterDeleteObjectCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteObject at\n%s", m.funcDeleteObjectOrigin)
	}

	if !m.DeleteObjectMock.invocationsDone() && afterDeleteObjectCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteObject at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteObjectMock.expectedInvocations), m.DeleteObjectMock.expectedInvocationsOrigin, afterDeleteObjectCounter)
	}
}

type mRepositoryMockDeleteObjectByDestination struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteObjectByDestinationExpectation
	expectations       []*RepositoryMockDeleteObjectByDestinationExpectation

	callArgs []*RepositoryMockDeleteObjectByDestinationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteObjectByDestinationExpectation specifies expectation struct of the Repository.DeleteObjectByDestination
type RepositoryMockDeleteObjectByDestinationExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteObjectByDestinationParams
	paramPtrs          *RepositoryMockDeleteObjectByDestinationParamPtrs
	expectationOrigins RepositoryMockDeleteObjectByDestinationExpectationOrigins
	results            *RepositoryMockDeleteObjectByDestinationResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteObjectByDestinationParams contains parameters of the Repository.DeleteObjectByDestination
type RepositoryMockDeleteObjectByDestinationParams struct {
	ctx         context.Context
	destination string
}

// RepositoryMockDeleteObjectByDestinationParamPtrs contains pointers to parameters of the Repository.DeleteObjectByDestination
type RepositoryMockDeleteObjectByDestinationParamPtrs struct {
	ctx         *context.Context
	destination *string
}

// RepositoryMockDeleteObjectByDestinationResults contains results of the Repository.DeleteObjectByDestination
type RepositoryMockDeleteObjectByDestinationResults struct {
	err error
}

// RepositoryMockDeleteObjectByDestinationOrigins contains origins of expectations of the Repository.DeleteObjectByDestination
type RepositoryMockDeleteObjectByDestinationExpectationOrigins struct {
	origin            string
	originCtx         string
	originDestination string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteObjectByDestination *mRepositoryMockDeleteObjectByDestination) Optional() *mRepositoryMockDeleteObjectByDestination {
	mmDeleteObjectByDestination.optional = true
	return mmDeleteObjectByDestination
}

// Expect sets up expected params for Repository.DeleteObjectByDestination
func (mmDeleteObjectByDestination *mRepositoryMockDeleteObjectByDestination) Expect(ctx context.Context, destination string) *mRepositoryMockDeleteObjectByDestination {
	if mmDeleteObjectByDestination.mock.funcDeleteObjectByDestination != nil {
		mmDeleteObjectByDestination.mock.t.Fatalf("RepositoryMock.DeleteObjectByDestination mock is already set by Set")
	}

	if mmDeleteObjectByDestination.defaultExpectation == nil {
		mmDeleteObjectByDestination.defaultExpectation = &RepositoryMockDeleteObjectByDestinationExpectation{}
	}

	if mmDeleteObjectByDestination.defaultExpectation.paramPtrs != nil {
		mmDeleteObjectByDestination.mock.t.Fatalf("RepositoryMock.DeleteObjectByDestination mock is already set by ExpectParams functions")
	}

	mmDeleteObjectByDestination.defaultExpectation.params = &RepositoryMockDeleteObjectByDestinationParams{ctx, destination}
	mmDeleteObjectByDestination.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteObjectByDestination.expectations {
		if minimock.Equal(e.params, mmDeleteObjectByDestination.defaultExpectation.params) {
			mmDeleteObjectByDestination.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteObjectByDestination.defaultExpectation.params)
		}
	}

	return mmDeleteObjectByDestination
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteObjectByDestination
func (mmDeleteObjectByDestination *mRepositoryMockDeleteObjectByDestination) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteObjectByDestination {
	if mmDeleteObjectByDestination.mock.funcDeleteObjectByDestination != nil {
		mmDeleteObjectByDestination.mock.t.Fatalf("RepositoryMock.DeleteObjectByDestination mock is already set by Set")
	}

	if mmDeleteObjectByDestination.defaultExpectation == nil {
		mmDeleteObjectByDestination.defaultExpectation = &RepositoryMockDeleteObjectByDestinationExpectation{}
	}

	if mmDeleteObjectByDestination.defaultExpectation.params != nil {
		mmDeleteObjectByDestination.mock.t.Fatalf("RepositoryMock.DeleteObjectByDestination mock is already set by Expect")
	}

	if mmDeleteObjectByDestination.defaultExpectation.paramPtrs == nil {
		mmDeleteObjectByDestination.defaultExpectation.paramPtrs = &RepositoryMockDeleteObjectByDestinationParamPtrs{}
	}
	mmDeleteObjectByDestination.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteObjectByDestination.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteObjectByDestination
}

// ExpectDestinationParam2 sets up expected param destination for Repository.DeleteObjectByDestination
func (mmDeleteObjectByDestination *mRepositoryMockDeleteObjectByDestination) ExpectDestinationParam2(destination string) *mRepositoryMockDeleteObjectByDestination {
	if mmDeleteObjectByDestination.mock.funcDeleteObjectByDestination != nil {
		mmDeleteObjectByDestination.mock.t.Fatalf("RepositoryMock.DeleteObjectByDestination mock is already set by Set")
	}

	if mmDeleteObjectByDestination.defaultExpectation == nil {
		mmDeleteObjectByDestination.defaultExpectation = &RepositoryMockDeleteObjectByDestinationExpectation{}
	}

	if mmDeleteObjectByDestination.defaultExpectation.params != nil {
		mmDeleteObjectByDestination.mock.t.Fatalf("RepositoryMock.DeleteObjectByDestination mock is already set by Expect")
	}

	if mmDeleteObjectByDestination.defaultExpectation.paramPtrs == nil {
		mmDeleteObjectByDestination.defaultExpectation.paramPtrs = &RepositoryMockDeleteObjectByDestinationParamPtrs{}
	}
	mmDeleteObjectByDestination.defaultExpectation.paramPtrs.destination = &destination
	mmDeleteObjectByDestination.defaultExpectation.expectationOrigins.originDestination = minimock.CallerInfo(1)

	return mmDeleteObjectByDestination
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteObjectByDestination
func (mmDeleteObjectByDestination *mRepositoryMockDeleteObjectByDestination) Inspect(f func(ctx context.Context, destination string)) *mRepositoryMockDeleteObjectByDestination {
	if mmDeleteObjectByDestination.mock.inspectFuncDeleteObjectByDestination != nil {
		mmDeleteObjectByDestination.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteObjectByDestination")
	}

	mmDeleteObjectByDestination.mock.inspectFuncDeleteObjectByDestination = f

	return mmDeleteObjectByDestination
}

// Return sets up results that will be returned by Repository.DeleteObjectByDestination
func (mmDeleteObjectByDestination *mRepositoryMockDeleteObjectByDestination) Return(err error) *RepositoryMock {
	if mmDeleteObjectByDestination.mock.funcDeleteObjectByDestination != nil {
		mmDeleteObjectByDestination.mock.t.Fatalf("RepositoryMock.DeleteObjectByDestination mock is already set by Set")
	}

	if mmDeleteObjectByDestination.defaultExpectation == nil {
		mmDeleteObjectByDestination.defaultExpectation = &RepositoryMockDeleteObjectByDestinationExpectation{mock: mmDeleteObjectByDestination.mock}
	}
	mmDeleteObjectByDestination.defaultExpectation.results = &RepositoryMockDeleteObjectByDestinationResults{err}
	mmDeleteObjectByDestination.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteObjectByDestination.mock
}

// Set uses given function f to mock the Repository.DeleteObjectByDestination method
func (mmDeleteObjectByDestination *mRepositoryMockDeleteObjectByDestination) Set(f func(ctx context.Context, destination string) (err error)) *RepositoryMock {
	if mmDeleteObjectByDestination.defaultExpectation != nil {
		mmDeleteObjectByDestination.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteObjectByDestination method")
	}

	if len(mmDeleteObjectByDestination.expectations) > 0 {
		mmDeleteObjectByDestination.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteObjectByDestination method")
	}

	mmDeleteObjectByDestination.mock.funcDeleteObjectByDestination = f
	mmDeleteObjectByDestination.mock.funcDeleteObjectByDestinationOrigin = minimock.CallerInfo(1)
	return mmDeleteObjectByDestination.mock
}

// When sets expectation for the Repository.DeleteObjectByDestination which will trigger the result defined by the following
// Then helper
func (mmDeleteObjectByDestination *mRepositoryMockDeleteObjectByDestination) When(ctx context.Context, destination string) *RepositoryMockDeleteObjectByDestinationExpectation {
	if mmDeleteObjectByDestination.mock.funcDeleteObjectByDestination != nil {
		mmDeleteObjectByDestination.mock.t.Fatalf("RepositoryMock.DeleteObjectByDestination mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteObjectByDestinationExpectation{
		mock:               mmDeleteObjectByDestination.mock,
		params:             &RepositoryMockDeleteObjectByDestinationParams{ctx, destination},
		expectationOrigins: RepositoryMockDeleteObjectByDestinationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteObjectByDestination.expectations = append(mmDeleteObjectByDestination.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteObjectByDestination return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteObjectByDestinationExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteObjectByDestinationResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteObjectByDestination should be invoked
func (mmDeleteObjectByDestination *mRepositoryMockDeleteObjectByDestination) Times(n uint64) *mRepositoryMockDeleteObjectByDestination {
	if n == 0 {
		mmDeleteObjectByDestination.mock.t.Fatalf("Times of RepositoryMock.DeleteObjectByDestination mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteObjectByDestination.expectedInvocations, n)
	mmDeleteObjectByDestination.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteObjectByDestination
}

func (mmDeleteObjectByDestination *mRepositoryMockDeleteObjectByDestination) invocationsDone() bool {
	if len(mmDeleteObjectByDestination.expectations) == 0 && mmDeleteObjectByDestination.defaultExpectation == nil && mmDeleteObjectByDestination.mock.funcDeleteObjectByDestination == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteObjectByDestination.mock.afterDeleteObjectByDestinationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteObjectByDestination.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteObjectByDestination implements mm_repository.Repository
func (mmDeleteObjectByDestination *RepositoryMock) DeleteObjectByDestination(ctx context.Context, destination string) (err error) {
	mm_atomic.AddUint64(&mmDeleteObjectByDestination.beforeDeleteObjectByDestinationCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteObjectByDestination.afterDeleteObjectByDestinationCounter, 1)

	mmDeleteObjectByDestination.t.Helper()

	if mmDeleteObjectByDestination.inspectFuncDeleteObjectByDestination != nil {
		mmDeleteObjectByDestination.inspectFuncDeleteObjectByDestination(ctx, destination)
	}

	mm_params := RepositoryMockDeleteObjectByDestinationParams{ctx, destination}

	// Record call args
	mmDeleteObjectByDestination.DeleteObjectByDestinationMock.mutex.Lock()
	mmDeleteObjectByDestination.DeleteObjectByDestinationMock.callArgs = append(mmDeleteObjectByDestination.DeleteObjectByDestinationMock.callArgs, &mm_params)
	mmDeleteObjectByDestination.DeleteObjectByDestinationMock.mutex.Unlock()

	for _, e := range mmDeleteObjectByDestination.DeleteObjectByDestinationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteObjectByDestination.DeleteObjectByDestinationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteObjectByDestination.DeleteObjectByDestinationMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteObjectByDestination.DeleteObjectByDestinationMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteObjectByDestination.DeleteObjectByDestinationMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteObjectByDestinationParams{ctx, destination}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteObjectByDestination.t.Errorf("RepositoryMock.DeleteObjectByDestination got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteObjectByDestination.DeleteObjectByDestinationMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.destination != nil && !minimock.Equal(*mm_want_ptrs.destination, mm_got.destination) {
				mmDeleteObjectByDestination.t.Errorf("RepositoryMock.DeleteObjectByDestination got unexpected parameter destination, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteObjectByDestination.DeleteObjectByDestinationMock.defaultExpectation.expectationOrigins.originDestination, *mm_want_ptrs.destination, mm_got.destination, minimock.Diff(*mm_want_ptrs.destination, mm_got.destination))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteObjectByDestination.t.Errorf("RepositoryMock.DeleteObjectByDestination got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteObjectByDestination.DeleteObjectByDestinationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteObjectByDestination.DeleteObjectByDestinationMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteObjectByDestination.t.Fatal("No results are set for the RepositoryMock.DeleteObjectByDestination")
		}
		return (*mm_results).err
	}
	if mmDeleteObjectByDestination.funcDeleteObjectByDestination != nil {
		return mmDeleteObjectByDestination.funcDeleteObjectByDestination(ctx, destination)
	}
	mmDeleteObjectByDestination.t.Fatalf("Unexpected call to RepositoryMock.DeleteObjectByDestination. %v %v", ctx, destination)
	return
}

// DeleteObjectByDestinationAfterCounter returns a count of finished RepositoryMock.DeleteObjectByDestination invocations
func (mmDeleteObjectByDestination *RepositoryMock) DeleteObjectByDestinationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteObjectByDestination.afterDeleteObjectByDestinationCounter)
}

// DeleteObjectByDestinationBeforeCounter returns a count of RepositoryMock.DeleteObjectByDestination invocations
func (mmDeleteObjectByDestination *RepositoryMock) DeleteObjectByDestinationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteObjectByDestination.beforeDeleteObjectByDestinationCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteObjectByDestination.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteObjectByDestination *mRepositoryMockDeleteObjectByDestination) Calls() []*RepositoryMockDeleteObjectByDestinationParams {
	mmDeleteObjectByDestination.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteObjectByDestinationParams, len(mmDeleteObjectByDestination.callArgs))
	copy(argCopy, mmDeleteObjectByDestination.callArgs)

	mmDeleteObjectByDestination.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteObjectByDestinationDone returns true if the count of the DeleteObjectByDestination invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteObjectByDestinationDone() bool {
	if m.DeleteObjectByDestinationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteObjectByDestinationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteObjectByDestinationMock.invocationsDone()
}

// MinimockDeleteObjectByDestinationInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteObjectByDestinationInspect() {
	for _, e := range m.DeleteObjectByDestinationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteObjectByDestination at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteObjectByDestinationCounter := mm_atomic.LoadUint64(&m.afterDeleteObjectByDestinationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteObjectByDestinationMock.defaultExpectation != nil && afterDeleteObjectByDestinationCounter < 1 {
		if m.DeleteObjectByDestinationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteObjectByDestination at\n%s", m.DeleteObjectByDestinationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteObjectByDestination at\n%s with params: %#v", m.DeleteObjectByDestinationMock.defaultExpectation.expectationOrigins.origin, *m.DeleteObjectByDestinationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteObjectByDestination != nil && afterDeleteObjectByDestinationCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteObjectByDestination at\n%s", m.funcDeleteObjectByDestinationOrigin)
	}

	if !m.DeleteObjectByDestinationMock.invocationsDone() && afterDeleteObjectByDestinationCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteObjectByDestination at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteObjectByDestinationMock.expectedInvocations), m.DeleteObjectByDestinationMock.expectedInvocationsOrigin, afterDeleteObjectByDestinationCounter)
	}
}

type mRepositoryMockDeleteRepositoryTag struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteRepositoryTagExpectation
	expectations       []*RepositoryMockDeleteRepositoryTagExpectation

	callArgs []*RepositoryMockDeleteRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteRepositoryTagExpectation specifies expectation struct of the Repository.DeleteRepositoryTag
type RepositoryMockDeleteRepositoryTagExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteRepositoryTagParams
	paramPtrs          *RepositoryMockDeleteRepositoryTagParamPtrs
	expectationOrigins RepositoryMockDeleteRepositoryTagExpectationOrigins
	results            *RepositoryMockDeleteRepositoryTagResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteRepositoryTagParams contains parameters of the Repository.DeleteRepositoryTag
type RepositoryMockDeleteRepositoryTagParams struct {
	ctx context.Context
	s1  string
}

// RepositoryMockDeleteRepositoryTagParamPtrs contains pointers to parameters of the Repository.DeleteRepositoryTag
type RepositoryMockDeleteRepositoryTagParamPtrs struct {
	ctx *context.Context
	s1  *string
}

// RepositoryMockDeleteRepositoryTagResults contains results of the Repository.DeleteRepositoryTag
type RepositoryMockDeleteRepositoryTagResults struct {
	err error
}

// RepositoryMockDeleteRepositoryTagOrigins contains origins of expectations of the Repository.DeleteRepositoryTag
type RepositoryMockDeleteRepositoryTagExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) Optional() *mRepositoryMockDeleteRepositoryTag {
	mmDeleteRepositoryTag.optional = true
	return mmDeleteRepositoryTag
}

// Expect sets up expected params for Repository.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) Expect(ctx context.Context, s1 string) *mRepositoryMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &RepositoryMockDeleteRepositoryTagExpectation{}
	}

	if mmDeleteRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryMock.DeleteRepositoryTag mock is already set by ExpectParams functions")
	}

	mmDeleteRepositoryTag.defaultExpectation.params = &RepositoryMockDeleteRepositoryTagParams{ctx, s1}
	mmDeleteRepositoryTag.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteRepositoryTag.expectations {
		if minimock.Equal(e.params, mmDeleteRepositoryTag.defaultExpectation.params) {
			mmDeleteRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteRepositoryTag.defaultExpectation.params)
		}
	}

	return mmDeleteRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &RepositoryMockDeleteRepositoryTagExpectation{}
	}

	if mmDeleteRepositoryTag.defaultExpectation.params != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryMock.DeleteRepositoryTag mock is already set by Expect")
	}

	if mmDeleteRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmDeleteRepositoryTag.defaultExpectation.paramPtrs = &RepositoryMockDeleteRepositoryTagParamPtrs{}
	}
	mmDeleteRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteRepositoryTag.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteRepositoryTag
}

// ExpectS1Param2 sets up expected param s1 for Repository.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) ExpectS1Param2(s1 string) *mRepositoryMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &RepositoryMockDeleteRepositoryTagExpectation{}
	}

	if mmDeleteRepositoryTag.defaultExpectation.params != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryMock.DeleteRepositoryTag mock is already set by Expect")
	}

	if mmDeleteRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmDeleteRepositoryTag.defaultExpectation.paramPtrs = &RepositoryMockDeleteRepositoryTagParamPtrs{}
	}
	mmDeleteRepositoryTag.defaultExpectation.paramPtrs.s1 = &s1
	mmDeleteRepositoryTag.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmDeleteRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) Inspect(f func(ctx context.Context, s1 string)) *mRepositoryMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.inspectFuncDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteRepositoryTag")
	}

	mmDeleteRepositoryTag.mock.inspectFuncDeleteRepositoryTag = f

	return mmDeleteRepositoryTag
}

// Return sets up results that will be returned by Repository.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) Return(err error) *RepositoryMock {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &RepositoryMockDeleteRepositoryTagExpectation{mock: mmDeleteRepositoryTag.mock}
	}
	mmDeleteRepositoryTag.defaultExpectation.results = &RepositoryMockDeleteRepositoryTagResults{err}
	mmDeleteRepositoryTag.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteRepositoryTag.mock
}

// Set uses given function f to mock the Repository.DeleteRepositoryTag method
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) Set(f func(ctx context.Context, s1 string) (err error)) *RepositoryMock {
	if mmDeleteRepositoryTag.defaultExpectation != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteRepositoryTag method")
	}

	if len(mmDeleteRepositoryTag.expectations) > 0 {
		mmDeleteRepositoryTag.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteRepositoryTag method")
	}

	mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag = f
	mmDeleteRepositoryTag.mock.funcDeleteRepositoryTagOrigin = minimock.CallerInfo(1)
	return mmDeleteRepositoryTag.mock
}

// When sets expectation for the Repository.DeleteRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) When(ctx context.Context, s1 string) *RepositoryMockDeleteRepositoryTagExpectation {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryMock.DeleteRepositoryTag mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteRepositoryTagExpectation{
		mock:               mmDeleteRepositoryTag.mock,
		params:             &RepositoryMockDeleteRepositoryTagParams{ctx, s1},
		expectationOrigins: RepositoryMockDeleteRepositoryTagExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteRepositoryTag.expectations = append(mmDeleteRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteRepositoryTag return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteRepositoryTagExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteRepositoryTagResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteRepositoryTag should be invoked
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) Times(n uint64) *mRepositoryMockDeleteRepositoryTag {
	if n == 0 {
		mmDeleteRepositoryTag.mock.t.Fatalf("Times of RepositoryMock.DeleteRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteRepositoryTag.expectedInvocations, n)
	mmDeleteRepositoryTag.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteRepositoryTag
}

func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) invocationsDone() bool {
	if len(mmDeleteRepositoryTag.expectations) == 0 && mmDeleteRepositoryTag.defaultExpectation == nil && mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteRepositoryTag.mock.afterDeleteRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteRepositoryTag implements mm_repository.Repository
func (mmDeleteRepositoryTag *RepositoryMock) DeleteRepositoryTag(ctx context.Context, s1 string) (err error) {
	mm_atomic.AddUint64(&mmDeleteRepositoryTag.beforeDeleteRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteRepositoryTag.afterDeleteRepositoryTagCounter, 1)

	mmDeleteRepositoryTag.t.Helper()

	if mmDeleteRepositoryTag.inspectFuncDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.inspectFuncDeleteRepositoryTag(ctx, s1)
	}

	mm_params := RepositoryMockDeleteRepositoryTagParams{ctx, s1}

	// Record call args
	mmDeleteRepositoryTag.DeleteRepositoryTagMock.mutex.Lock()
	mmDeleteRepositoryTag.DeleteRepositoryTagMock.callArgs = append(mmDeleteRepositoryTag.DeleteRepositoryTagMock.callArgs, &mm_params)
	mmDeleteRepositoryTag.DeleteRepositoryTagMock.mutex.Unlock()

	for _, e := range mmDeleteRepositoryTag.DeleteRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteRepositoryTagParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteRepositoryTag.t.Errorf("RepositoryMock.DeleteRepositoryTag got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmDeleteRepositoryTag.t.Errorf("RepositoryMock.DeleteRepositoryTag got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteRepositoryTag.t.Errorf("RepositoryMock.DeleteRepositoryTag got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteRepositoryTag.t.Fatal("No results are set for the RepositoryMock.DeleteRepositoryTag")
		}
		return (*mm_results).err
	}
	if mmDeleteRepositoryTag.funcDeleteRepositoryTag != nil {
		return mmDeleteRepositoryTag.funcDeleteRepositoryTag(ctx, s1)
	}
	mmDeleteRepositoryTag.t.Fatalf("Unexpected call to RepositoryMock.DeleteRepositoryTag. %v %v", ctx, s1)
	return
}

// DeleteRepositoryTagAfterCounter returns a count of finished RepositoryMock.DeleteRepositoryTag invocations
func (mmDeleteRepositoryTag *RepositoryMock) DeleteRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRepositoryTag.afterDeleteRepositoryTagCounter)
}

// DeleteRepositoryTagBeforeCounter returns a count of RepositoryMock.DeleteRepositoryTag invocations
func (mmDeleteRepositoryTag *RepositoryMock) DeleteRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRepositoryTag.beforeDeleteRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) Calls() []*RepositoryMockDeleteRepositoryTagParams {
	mmDeleteRepositoryTag.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteRepositoryTagParams, len(mmDeleteRepositoryTag.callArgs))
	copy(argCopy, mmDeleteRepositoryTag.callArgs)

	mmDeleteRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteRepositoryTagDone returns true if the count of the DeleteRepositoryTag invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteRepositoryTagDone() bool {
	if m.DeleteRepositoryTagMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteRepositoryTagMock.invocationsDone()
}

// MinimockDeleteRepositoryTagInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteRepositoryTagInspect() {
	for _, e := range m.DeleteRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteRepositoryTag at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterDeleteRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteRepositoryTagMock.defaultExpectation != nil && afterDeleteRepositoryTagCounter < 1 {
		if m.DeleteRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteRepositoryTag at\n%s", m.DeleteRepositoryTagMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteRepositoryTag at\n%s with params: %#v", m.DeleteRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *m.DeleteRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteRepositoryTag != nil && afterDeleteRepositoryTagCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteRepositoryTag at\n%s", m.funcDeleteRepositoryTagOrigin)
	}

	if !m.DeleteRepositoryTagMock.invocationsDone() && afterDeleteRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteRepositoryTag at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteRepositoryTagMock.expectedInvocations), m.DeleteRepositoryTagMock.expectedInvocationsOrigin, afterDeleteRepositoryTagCounter)
	}
}

type mRepositoryMockDeleteSystem struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteSystemExpectation
	expectations       []*RepositoryMockDeleteSystemExpectation

	callArgs []*RepositoryMockDeleteSystemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteSystemExpectation specifies expectation struct of the Repository.DeleteSystem
type RepositoryMockDeleteSystemExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteSystemParams
	paramPtrs          *RepositoryMockDeleteSystemParamPtrs
	expectationOrigins RepositoryMockDeleteSystemExpectationOrigins
	results            *RepositoryMockDeleteSystemResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteSystemParams contains parameters of the Repository.DeleteSystem
type RepositoryMockDeleteSystemParams struct {
	ctx context.Context
	id  string
}

// RepositoryMockDeleteSystemParamPtrs contains pointers to parameters of the Repository.DeleteSystem
type RepositoryMockDeleteSystemParamPtrs struct {
	ctx *context.Context
	id  *string
}

// RepositoryMockDeleteSystemResults contains results of the Repository.DeleteSystem
type RepositoryMockDeleteSystemResults struct {
	err error
}

// RepositoryMockDeleteSystemOrigins contains origins of expectations of the Repository.DeleteSystem
type RepositoryMockDeleteSystemExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteSystem *mRepositoryMockDeleteSystem) Optional() *mRepositoryMockDeleteSystem {
	mmDeleteSystem.optional = true
	return mmDeleteSystem
}

// Expect sets up expected params for Repository.DeleteSystem
func (mmDeleteSystem *mRepositoryMockDeleteSystem) Expect(ctx context.Context, id string) *mRepositoryMockDeleteSystem {
	if mmDeleteSystem.mock.funcDeleteSystem != nil {
		mmDeleteSystem.mock.t.Fatalf("RepositoryMock.DeleteSystem mock is already set by Set")
	}

	if mmDeleteSystem.defaultExpectation == nil {
		mmDeleteSystem.defaultExpectation = &RepositoryMockDeleteSystemExpectation{}
	}

	if mmDeleteSystem.defaultExpectation.paramPtrs != nil {
		mmDeleteSystem.mock.t.Fatalf("RepositoryMock.DeleteSystem mock is already set by ExpectParams functions")
	}

	mmDeleteSystem.defaultExpectation.params = &RepositoryMockDeleteSystemParams{ctx, id}
	mmDeleteSystem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteSystem.expectations {
		if minimock.Equal(e.params, mmDeleteSystem.defaultExpectation.params) {
			mmDeleteSystem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteSystem.defaultExpectation.params)
		}
	}

	return mmDeleteSystem
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteSystem
func (mmDeleteSystem *mRepositoryMockDeleteSystem) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteSystem {
	if mmDeleteSystem.mock.funcDeleteSystem != nil {
		mmDeleteSystem.mock.t.Fatalf("RepositoryMock.DeleteSystem mock is already set by Set")
	}

	if mmDeleteSystem.defaultExpectation == nil {
		mmDeleteSystem.defaultExpectation = &RepositoryMockDeleteSystemExpectation{}
	}

	if mmDeleteSystem.defaultExpectation.params != nil {
		mmDeleteSystem.mock.t.Fatalf("RepositoryMock.DeleteSystem mock is already set by Expect")
	}

	if mmDeleteSystem.defaultExpectation.paramPtrs == nil {
		mmDeleteSystem.defaultExpectation.paramPtrs = &RepositoryMockDeleteSystemParamPtrs{}
	}
	mmDeleteSystem.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteSystem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteSystem
}

// ExpectIdParam2 sets up expected param id for Repository.DeleteSystem
func (mmDeleteSystem *mRepositoryMockDeleteSystem) ExpectIdParam2(id string) *mRepositoryMockDeleteSystem {
	if mmDeleteSystem.mock.funcDeleteSystem != nil {
		mmDeleteSystem.mock.t.Fatalf("RepositoryMock.DeleteSystem mock is already set by Set")
	}

	if mmDeleteSystem.defaultExpectation == nil {
		mmDeleteSystem.defaultExpectation = &RepositoryMockDeleteSystemExpectation{}
	}

	if mmDeleteSystem.defaultExpectation.params != nil {
		mmDeleteSystem.mock.t.Fatalf("RepositoryMock.DeleteSystem mock is already set by Expect")
	}

	if mmDeleteSystem.defaultExpectation.paramPtrs == nil {
		mmDeleteSystem.defaultExpectation.paramPtrs = &RepositoryMockDeleteSystemParamPtrs{}
	}
	mmDeleteSystem.defaultExpectation.paramPtrs.id = &id
	mmDeleteSystem.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteSystem
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteSystem
func (mmDeleteSystem *mRepositoryMockDeleteSystem) Inspect(f func(ctx context.Context, id string)) *mRepositoryMockDeleteSystem {
	if mmDeleteSystem.mock.inspectFuncDeleteSystem != nil {
		mmDeleteSystem.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteSystem")
	}

	mmDeleteSystem.mock.inspectFuncDeleteSystem = f

	return mmDeleteSystem
}

// Return sets up results that will be returned by Repository.DeleteSystem
func (mmDeleteSystem *mRepositoryMockDeleteSystem) Return(err error) *RepositoryMock {
	if mmDeleteSystem.mock.funcDeleteSystem != nil {
		mmDeleteSystem.mock.t.Fatalf("RepositoryMock.DeleteSystem mock is already set by Set")
	}

	if mmDeleteSystem.defaultExpectation == nil {
		mmDeleteSystem.defaultExpectation = &RepositoryMockDeleteSystemExpectation{mock: mmDeleteSystem.mock}
	}
	mmDeleteSystem.defaultExpectation.results = &RepositoryMockDeleteSystemResults{err}
	mmDeleteSystem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteSystem.mock
}

// Set uses given function f to mock the Repository.DeleteSystem method
func (mmDeleteSystem *mRepositoryMockDeleteSystem) Set(f func(ctx context.Context, id string) (err error)) *RepositoryMock {
	if mmDeleteSystem.defaultExpectation != nil {
		mmDeleteSystem.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteSystem method")
	}

	if len(mmDeleteSystem.expectations) > 0 {
		mmDeleteSystem.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteSystem method")
	}

	mmDeleteSystem.mock.funcDeleteSystem = f
	mmDeleteSystem.mock.funcDeleteSystemOrigin = minimock.CallerInfo(1)
	return mmDeleteSystem.mock
}

// When sets expectation for the Repository.DeleteSystem which will trigger the result defined by the following
// Then helper
func (mmDeleteSystem *mRepositoryMockDeleteSystem) When(ctx context.Context, id string) *RepositoryMockDeleteSystemExpectation {
	if mmDeleteSystem.mock.funcDeleteSystem != nil {
		mmDeleteSystem.mock.t.Fatalf("RepositoryMock.DeleteSystem mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteSystemExpectation{
		mock:               mmDeleteSystem.mock,
		params:             &RepositoryMockDeleteSystemParams{ctx, id},
		expectationOrigins: RepositoryMockDeleteSystemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteSystem.expectations = append(mmDeleteSystem.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteSystem return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteSystemExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteSystemResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteSystem should be invoked
func (mmDeleteSystem *mRepositoryMockDeleteSystem) Times(n uint64) *mRepositoryMockDeleteSystem {
	if n == 0 {
		mmDeleteSystem.mock.t.Fatalf("Times of RepositoryMock.DeleteSystem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteSystem.expectedInvocations, n)
	mmDeleteSystem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteSystem
}

func (mmDeleteSystem *mRepositoryMockDeleteSystem) invocationsDone() bool {
	if len(mmDeleteSystem.expectations) == 0 && mmDeleteSystem.defaultExpectation == nil && mmDeleteSystem.mock.funcDeleteSystem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteSystem.mock.afterDeleteSystemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteSystem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteSystem implements mm_repository.Repository
func (mmDeleteSystem *RepositoryMock) DeleteSystem(ctx context.Context, id string) (err error) {
	mm_atomic.AddUint64(&mmDeleteSystem.beforeDeleteSystemCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteSystem.afterDeleteSystemCounter, 1)

	mmDeleteSystem.t.Helper()

	if mmDeleteSystem.inspectFuncDeleteSystem != nil {
		mmDeleteSystem.inspectFuncDeleteSystem(ctx, id)
	}

	mm_params := RepositoryMockDeleteSystemParams{ctx, id}

	// Record call args
	mmDeleteSystem.DeleteSystemMock.mutex.Lock()
	mmDeleteSystem.DeleteSystemMock.callArgs = append(mmDeleteSystem.DeleteSystemMock.callArgs, &mm_params)
	mmDeleteSystem.DeleteSystemMock.mutex.Unlock()

	for _, e := range mmDeleteSystem.DeleteSystemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteSystem.DeleteSystemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteSystem.DeleteSystemMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteSystem.DeleteSystemMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteSystem.DeleteSystemMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteSystemParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteSystem.t.Errorf("RepositoryMock.DeleteSystem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSystem.DeleteSystemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteSystem.t.Errorf("RepositoryMock.DeleteSystem got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSystem.DeleteSystemMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteSystem.t.Errorf("RepositoryMock.DeleteSystem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteSystem.DeleteSystemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteSystem.DeleteSystemMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteSystem.t.Fatal("No results are set for the RepositoryMock.DeleteSystem")
		}
		return (*mm_results).err
	}
	if mmDeleteSystem.funcDeleteSystem != nil {
		return mmDeleteSystem.funcDeleteSystem(ctx, id)
	}
	mmDeleteSystem.t.Fatalf("Unexpected call to RepositoryMock.DeleteSystem. %v %v", ctx, id)
	return
}

// DeleteSystemAfterCounter returns a count of finished RepositoryMock.DeleteSystem invocations
func (mmDeleteSystem *RepositoryMock) DeleteSystemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSystem.afterDeleteSystemCounter)
}

// DeleteSystemBeforeCounter returns a count of RepositoryMock.DeleteSystem invocations
func (mmDeleteSystem *RepositoryMock) DeleteSystemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSystem.beforeDeleteSystemCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteSystem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteSystem *mRepositoryMockDeleteSystem) Calls() []*RepositoryMockDeleteSystemParams {
	mmDeleteSystem.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteSystemParams, len(mmDeleteSystem.callArgs))
	copy(argCopy, mmDeleteSystem.callArgs)

	mmDeleteSystem.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteSystemDone returns true if the count of the DeleteSystem invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteSystemDone() bool {
	if m.DeleteSystemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteSystemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteSystemMock.invocationsDone()
}

// MinimockDeleteSystemInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteSystemInspect() {
	for _, e := range m.DeleteSystemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteSystem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteSystemCounter := mm_atomic.LoadUint64(&m.afterDeleteSystemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSystemMock.defaultExpectation != nil && afterDeleteSystemCounter < 1 {
		if m.DeleteSystemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteSystem at\n%s", m.DeleteSystemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteSystem at\n%s with params: %#v", m.DeleteSystemMock.defaultExpectation.expectationOrigins.origin, *m.DeleteSystemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSystem != nil && afterDeleteSystemCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteSystem at\n%s", m.funcDeleteSystemOrigin)
	}

	if !m.DeleteSystemMock.invocationsDone() && afterDeleteSystemCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteSystem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteSystemMock.expectedInvocations), m.DeleteSystemMock.expectedInvocationsOrigin, afterDeleteSystemCounter)
	}
}

type mRepositoryMockDropCollection struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDropCollectionExpectation
	expectations       []*RepositoryMockDropCollectionExpectation

	callArgs []*RepositoryMockDropCollectionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDropCollectionExpectation specifies expectation struct of the Repository.DropCollection
type RepositoryMockDropCollectionExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDropCollectionParams
	paramPtrs          *RepositoryMockDropCollectionParamPtrs
	expectationOrigins RepositoryMockDropCollectionExpectationOrigins
	results            *RepositoryMockDropCollectionResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDropCollectionParams contains parameters of the Repository.DropCollection
type RepositoryMockDropCollectionParams struct {
	ctx context.Context
	id  string
}

// RepositoryMockDropCollectionParamPtrs contains pointers to parameters of the Repository.DropCollection
type RepositoryMockDropCollectionParamPtrs struct {
	ctx *context.Context
	id  *string
}

// RepositoryMockDropCollectionResults contains results of the Repository.DropCollection
type RepositoryMockDropCollectionResults struct {
	err error
}

// RepositoryMockDropCollectionOrigins contains origins of expectations of the Repository.DropCollection
type RepositoryMockDropCollectionExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDropCollection *mRepositoryMockDropCollection) Optional() *mRepositoryMockDropCollection {
	mmDropCollection.optional = true
	return mmDropCollection
}

// Expect sets up expected params for Repository.DropCollection
func (mmDropCollection *mRepositoryMockDropCollection) Expect(ctx context.Context, id string) *mRepositoryMockDropCollection {
	if mmDropCollection.mock.funcDropCollection != nil {
		mmDropCollection.mock.t.Fatalf("RepositoryMock.DropCollection mock is already set by Set")
	}

	if mmDropCollection.defaultExpectation == nil {
		mmDropCollection.defaultExpectation = &RepositoryMockDropCollectionExpectation{}
	}

	if mmDropCollection.defaultExpectation.paramPtrs != nil {
		mmDropCollection.mock.t.Fatalf("RepositoryMock.DropCollection mock is already set by ExpectParams functions")
	}

	mmDropCollection.defaultExpectation.params = &RepositoryMockDropCollectionParams{ctx, id}
	mmDropCollection.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDropCollection.expectations {
		if minimock.Equal(e.params, mmDropCollection.defaultExpectation.params) {
			mmDropCollection.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDropCollection.defaultExpectation.params)
		}
	}

	return mmDropCollection
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DropCollection
func (mmDropCollection *mRepositoryMockDropCollection) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDropCollection {
	if mmDropCollection.mock.funcDropCollection != nil {
		mmDropCollection.mock.t.Fatalf("RepositoryMock.DropCollection mock is already set by Set")
	}

	if mmDropCollection.defaultExpectation == nil {
		mmDropCollection.defaultExpectation = &RepositoryMockDropCollectionExpectation{}
	}

	if mmDropCollection.defaultExpectation.params != nil {
		mmDropCollection.mock.t.Fatalf("RepositoryMock.DropCollection mock is already set by Expect")
	}

	if mmDropCollection.defaultExpectation.paramPtrs == nil {
		mmDropCollection.defaultExpectation.paramPtrs = &RepositoryMockDropCollectionParamPtrs{}
	}
	mmDropCollection.defaultExpectation.paramPtrs.ctx = &ctx
	mmDropCollection.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDropCollection
}

// ExpectIdParam2 sets up expected param id for Repository.DropCollection
func (mmDropCollection *mRepositoryMockDropCollection) ExpectIdParam2(id string) *mRepositoryMockDropCollection {
	if mmDropCollection.mock.funcDropCollection != nil {
		mmDropCollection.mock.t.Fatalf("RepositoryMock.DropCollection mock is already set by Set")
	}

	if mmDropCollection.defaultExpectation == nil {
		mmDropCollection.defaultExpectation = &RepositoryMockDropCollectionExpectation{}
	}

	if mmDropCollection.defaultExpectation.params != nil {
		mmDropCollection.mock.t.Fatalf("RepositoryMock.DropCollection mock is already set by Expect")
	}

	if mmDropCollection.defaultExpectation.paramPtrs == nil {
		mmDropCollection.defaultExpectation.paramPtrs = &RepositoryMockDropCollectionParamPtrs{}
	}
	mmDropCollection.defaultExpectation.paramPtrs.id = &id
	mmDropCollection.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDropCollection
}

// Inspect accepts an inspector function that has same arguments as the Repository.DropCollection
func (mmDropCollection *mRepositoryMockDropCollection) Inspect(f func(ctx context.Context, id string)) *mRepositoryMockDropCollection {
	if mmDropCollection.mock.inspectFuncDropCollection != nil {
		mmDropCollection.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DropCollection")
	}

	mmDropCollection.mock.inspectFuncDropCollection = f

	return mmDropCollection
}

// Return sets up results that will be returned by Repository.DropCollection
func (mmDropCollection *mRepositoryMockDropCollection) Return(err error) *RepositoryMock {
	if mmDropCollection.mock.funcDropCollection != nil {
		mmDropCollection.mock.t.Fatalf("RepositoryMock.DropCollection mock is already set by Set")
	}

	if mmDropCollection.defaultExpectation == nil {
		mmDropCollection.defaultExpectation = &RepositoryMockDropCollectionExpectation{mock: mmDropCollection.mock}
	}
	mmDropCollection.defaultExpectation.results = &RepositoryMockDropCollectionResults{err}
	mmDropCollection.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDropCollection.mock
}

// Set uses given function f to mock the Repository.DropCollection method
func (mmDropCollection *mRepositoryMockDropCollection) Set(f func(ctx context.Context, id string) (err error)) *RepositoryMock {
	if mmDropCollection.defaultExpectation != nil {
		mmDropCollection.mock.t.Fatalf("Default expectation is already set for the Repository.DropCollection method")
	}

	if len(mmDropCollection.expectations) > 0 {
		mmDropCollection.mock.t.Fatalf("Some expectations are already set for the Repository.DropCollection method")
	}

	mmDropCollection.mock.funcDropCollection = f
	mmDropCollection.mock.funcDropCollectionOrigin = minimock.CallerInfo(1)
	return mmDropCollection.mock
}

// When sets expectation for the Repository.DropCollection which will trigger the result defined by the following
// Then helper
func (mmDropCollection *mRepositoryMockDropCollection) When(ctx context.Context, id string) *RepositoryMockDropCollectionExpectation {
	if mmDropCollection.mock.funcDropCollection != nil {
		mmDropCollection.mock.t.Fatalf("RepositoryMock.DropCollection mock is already set by Set")
	}

	expectation := &RepositoryMockDropCollectionExpectation{
		mock:               mmDropCollection.mock,
		params:             &RepositoryMockDropCollectionParams{ctx, id},
		expectationOrigins: RepositoryMockDropCollectionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDropCollection.expectations = append(mmDropCollection.expectations, expectation)
	return expectation
}

// Then sets up Repository.DropCollection return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDropCollectionExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDropCollectionResults{err}
	return e.mock
}

// Times sets number of times Repository.DropCollection should be invoked
func (mmDropCollection *mRepositoryMockDropCollection) Times(n uint64) *mRepositoryMockDropCollection {
	if n == 0 {
		mmDropCollection.mock.t.Fatalf("Times of RepositoryMock.DropCollection mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDropCollection.expectedInvocations, n)
	mmDropCollection.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDropCollection
}

func (mmDropCollection *mRepositoryMockDropCollection) invocationsDone() bool {
	if len(mmDropCollection.expectations) == 0 && mmDropCollection.defaultExpectation == nil && mmDropCollection.mock.funcDropCollection == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDropCollection.mock.afterDropCollectionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDropCollection.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DropCollection implements mm_repository.Repository
func (mmDropCollection *RepositoryMock) DropCollection(ctx context.Context, id string) (err error) {
	mm_atomic.AddUint64(&mmDropCollection.beforeDropCollectionCounter, 1)
	defer mm_atomic.AddUint64(&mmDropCollection.afterDropCollectionCounter, 1)

	mmDropCollection.t.Helper()

	if mmDropCollection.inspectFuncDropCollection != nil {
		mmDropCollection.inspectFuncDropCollection(ctx, id)
	}

	mm_params := RepositoryMockDropCollectionParams{ctx, id}

	// Record call args
	mmDropCollection.DropCollectionMock.mutex.Lock()
	mmDropCollection.DropCollectionMock.callArgs = append(mmDropCollection.DropCollectionMock.callArgs, &mm_params)
	mmDropCollection.DropCollectionMock.mutex.Unlock()

	for _, e := range mmDropCollection.DropCollectionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDropCollection.DropCollectionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDropCollection.DropCollectionMock.defaultExpectation.Counter, 1)
		mm_want := mmDropCollection.DropCollectionMock.defaultExpectation.params
		mm_want_ptrs := mmDropCollection.DropCollectionMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDropCollectionParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDropCollection.t.Errorf("RepositoryMock.DropCollection got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDropCollection.DropCollectionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDropCollection.t.Errorf("RepositoryMock.DropCollection got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDropCollection.DropCollectionMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDropCollection.t.Errorf("RepositoryMock.DropCollection got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDropCollection.DropCollectionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDropCollection.DropCollectionMock.defaultExpectation.results
		if mm_results == nil {
			mmDropCollection.t.Fatal("No results are set for the RepositoryMock.DropCollection")
		}
		return (*mm_results).err
	}
	if mmDropCollection.funcDropCollection != nil {
		return mmDropCollection.funcDropCollection(ctx, id)
	}
	mmDropCollection.t.Fatalf("Unexpected call to RepositoryMock.DropCollection. %v %v", ctx, id)
	return
}

// DropCollectionAfterCounter returns a count of finished RepositoryMock.DropCollection invocations
func (mmDropCollection *RepositoryMock) DropCollectionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDropCollection.afterDropCollectionCounter)
}

// DropCollectionBeforeCounter returns a count of RepositoryMock.DropCollection invocations
func (mmDropCollection *RepositoryMock) DropCollectionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDropCollection.beforeDropCollectionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DropCollection.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDropCollection *mRepositoryMockDropCollection) Calls() []*RepositoryMockDropCollectionParams {
	mmDropCollection.mutex.RLock()

	argCopy := make([]*RepositoryMockDropCollectionParams, len(mmDropCollection.callArgs))
	copy(argCopy, mmDropCollection.callArgs)

	mmDropCollection.mutex.RUnlock()

	return argCopy
}

// MinimockDropCollectionDone returns true if the count of the DropCollection invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDropCollectionDone() bool {
	if m.DropCollectionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DropCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DropCollectionMock.invocationsDone()
}

// MinimockDropCollectionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDropCollectionInspect() {
	for _, e := range m.DropCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DropCollection at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDropCollectionCounter := mm_atomic.LoadUint64(&m.afterDropCollectionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DropCollectionMock.defaultExpectation != nil && afterDropCollectionCounter < 1 {
		if m.DropCollectionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DropCollection at\n%s", m.DropCollectionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DropCollection at\n%s with params: %#v", m.DropCollectionMock.defaultExpectation.expectationOrigins.origin, *m.DropCollectionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDropCollection != nil && afterDropCollectionCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DropCollection at\n%s", m.funcDropCollectionOrigin)
	}

	if !m.DropCollectionMock.invocationsDone() && afterDropCollectionCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DropCollection at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DropCollectionMock.expectedInvocations), m.DropCollectionMock.expectedInvocationsOrigin, afterDropCollectionCounter)
	}
}

type mRepositoryMockFlushCollection struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockFlushCollectionExpectation
	expectations       []*RepositoryMockFlushCollectionExpectation

	callArgs []*RepositoryMockFlushCollectionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockFlushCollectionExpectation specifies expectation struct of the Repository.FlushCollection
type RepositoryMockFlushCollectionExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockFlushCollectionParams
	paramPtrs          *RepositoryMockFlushCollectionParamPtrs
	expectationOrigins RepositoryMockFlushCollectionExpectationOrigins
	results            *RepositoryMockFlushCollectionResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockFlushCollectionParams contains parameters of the Repository.FlushCollection
type RepositoryMockFlushCollectionParams struct {
	ctx          context.Context
	collectionID string
}

// RepositoryMockFlushCollectionParamPtrs contains pointers to parameters of the Repository.FlushCollection
type RepositoryMockFlushCollectionParamPtrs struct {
	ctx          *context.Context
	collectionID *string
}

// RepositoryMockFlushCollectionResults contains results of the Repository.FlushCollection
type RepositoryMockFlushCollectionResults struct {
	err error
}

// RepositoryMockFlushCollectionOrigins contains origins of expectations of the Repository.FlushCollection
type RepositoryMockFlushCollectionExpectationOrigins struct {
	origin             string
	originCtx          string
	originCollectionID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFlushCollection *mRepositoryMockFlushCollection) Optional() *mRepositoryMockFlushCollection {
	mmFlushCollection.optional = true
	return mmFlushCollection
}

// Expect sets up expected params for Repository.FlushCollection
func (mmFlushCollection *mRepositoryMockFlushCollection) Expect(ctx context.Context, collectionID string) *mRepositoryMockFlushCollection {
	if mmFlushCollection.mock.funcFlushCollection != nil {
		mmFlushCollection.mock.t.Fatalf("RepositoryMock.FlushCollection mock is already set by Set")
	}

	if mmFlushCollection.defaultExpectation == nil {
		mmFlushCollection.defaultExpectation = &RepositoryMockFlushCollectionExpectation{}
	}

	if mmFlushCollection.defaultExpectation.paramPtrs != nil {
		mmFlushCollection.mock.t.Fatalf("RepositoryMock.FlushCollection mock is already set by ExpectParams functions")
	}

	mmFlushCollection.defaultExpectation.params = &RepositoryMockFlushCollectionParams{ctx, collectionID}
	mmFlushCollection.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFlushCollection.expectations {
		if minimock.Equal(e.params, mmFlushCollection.defaultExpectation.params) {
			mmFlushCollection.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFlushCollection.defaultExpectation.params)
		}
	}

	return mmFlushCollection
}

// ExpectCtxParam1 sets up expected param ctx for Repository.FlushCollection
func (mmFlushCollection *mRepositoryMockFlushCollection) ExpectCtxParam1(ctx context.Context) *mRepositoryMockFlushCollection {
	if mmFlushCollection.mock.funcFlushCollection != nil {
		mmFlushCollection.mock.t.Fatalf("RepositoryMock.FlushCollection mock is already set by Set")
	}

	if mmFlushCollection.defaultExpectation == nil {
		mmFlushCollection.defaultExpectation = &RepositoryMockFlushCollectionExpectation{}
	}

	if mmFlushCollection.defaultExpectation.params != nil {
		mmFlushCollection.mock.t.Fatalf("RepositoryMock.FlushCollection mock is already set by Expect")
	}

	if mmFlushCollection.defaultExpectation.paramPtrs == nil {
		mmFlushCollection.defaultExpectation.paramPtrs = &RepositoryMockFlushCollectionParamPtrs{}
	}
	mmFlushCollection.defaultExpectation.paramPtrs.ctx = &ctx
	mmFlushCollection.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFlushCollection
}

// ExpectCollectionIDParam2 sets up expected param collectionID for Repository.FlushCollection
func (mmFlushCollection *mRepositoryMockFlushCollection) ExpectCollectionIDParam2(collectionID string) *mRepositoryMockFlushCollection {
	if mmFlushCollection.mock.funcFlushCollection != nil {
		mmFlushCollection.mock.t.Fatalf("RepositoryMock.FlushCollection mock is already set by Set")
	}

	if mmFlushCollection.defaultExpectation == nil {
		mmFlushCollection.defaultExpectation = &RepositoryMockFlushCollectionExpectation{}
	}

	if mmFlushCollection.defaultExpectation.params != nil {
		mmFlushCollection.mock.t.Fatalf("RepositoryMock.FlushCollection mock is already set by Expect")
	}

	if mmFlushCollection.defaultExpectation.paramPtrs == nil {
		mmFlushCollection.defaultExpectation.paramPtrs = &RepositoryMockFlushCollectionParamPtrs{}
	}
	mmFlushCollection.defaultExpectation.paramPtrs.collectionID = &collectionID
	mmFlushCollection.defaultExpectation.expectationOrigins.originCollectionID = minimock.CallerInfo(1)

	return mmFlushCollection
}

// Inspect accepts an inspector function that has same arguments as the Repository.FlushCollection
func (mmFlushCollection *mRepositoryMockFlushCollection) Inspect(f func(ctx context.Context, collectionID string)) *mRepositoryMockFlushCollection {
	if mmFlushCollection.mock.inspectFuncFlushCollection != nil {
		mmFlushCollection.mock.t.Fatalf("Inspect function is already set for RepositoryMock.FlushCollection")
	}

	mmFlushCollection.mock.inspectFuncFlushCollection = f

	return mmFlushCollection
}

// Return sets up results that will be returned by Repository.FlushCollection
func (mmFlushCollection *mRepositoryMockFlushCollection) Return(err error) *RepositoryMock {
	if mmFlushCollection.mock.funcFlushCollection != nil {
		mmFlushCollection.mock.t.Fatalf("RepositoryMock.FlushCollection mock is already set by Set")
	}

	if mmFlushCollection.defaultExpectation == nil {
		mmFlushCollection.defaultExpectation = &RepositoryMockFlushCollectionExpectation{mock: mmFlushCollection.mock}
	}
	mmFlushCollection.defaultExpectation.results = &RepositoryMockFlushCollectionResults{err}
	mmFlushCollection.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFlushCollection.mock
}

// Set uses given function f to mock the Repository.FlushCollection method
func (mmFlushCollection *mRepositoryMockFlushCollection) Set(f func(ctx context.Context, collectionID string) (err error)) *RepositoryMock {
	if mmFlushCollection.defaultExpectation != nil {
		mmFlushCollection.mock.t.Fatalf("Default expectation is already set for the Repository.FlushCollection method")
	}

	if len(mmFlushCollection.expectations) > 0 {
		mmFlushCollection.mock.t.Fatalf("Some expectations are already set for the Repository.FlushCollection method")
	}

	mmFlushCollection.mock.funcFlushCollection = f
	mmFlushCollection.mock.funcFlushCollectionOrigin = minimock.CallerInfo(1)
	return mmFlushCollection.mock
}

// When sets expectation for the Repository.FlushCollection which will trigger the result defined by the following
// Then helper
func (mmFlushCollection *mRepositoryMockFlushCollection) When(ctx context.Context, collectionID string) *RepositoryMockFlushCollectionExpectation {
	if mmFlushCollection.mock.funcFlushCollection != nil {
		mmFlushCollection.mock.t.Fatalf("RepositoryMock.FlushCollection mock is already set by Set")
	}

	expectation := &RepositoryMockFlushCollectionExpectation{
		mock:               mmFlushCollection.mock,
		params:             &RepositoryMockFlushCollectionParams{ctx, collectionID},
		expectationOrigins: RepositoryMockFlushCollectionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFlushCollection.expectations = append(mmFlushCollection.expectations, expectation)
	return expectation
}

// Then sets up Repository.FlushCollection return parameters for the expectation previously defined by the When method
func (e *RepositoryMockFlushCollectionExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockFlushCollectionResults{err}
	return e.mock
}

// Times sets number of times Repository.FlushCollection should be invoked
func (mmFlushCollection *mRepositoryMockFlushCollection) Times(n uint64) *mRepositoryMockFlushCollection {
	if n == 0 {
		mmFlushCollection.mock.t.Fatalf("Times of RepositoryMock.FlushCollection mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFlushCollection.expectedInvocations, n)
	mmFlushCollection.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFlushCollection
}

func (mmFlushCollection *mRepositoryMockFlushCollection) invocationsDone() bool {
	if len(mmFlushCollection.expectations) == 0 && mmFlushCollection.defaultExpectation == nil && mmFlushCollection.mock.funcFlushCollection == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFlushCollection.mock.afterFlushCollectionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFlushCollection.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FlushCollection implements mm_repository.Repository
func (mmFlushCollection *RepositoryMock) FlushCollection(ctx context.Context, collectionID string) (err error) {
	mm_atomic.AddUint64(&mmFlushCollection.beforeFlushCollectionCounter, 1)
	defer mm_atomic.AddUint64(&mmFlushCollection.afterFlushCollectionCounter, 1)

	mmFlushCollection.t.Helper()

	if mmFlushCollection.inspectFuncFlushCollection != nil {
		mmFlushCollection.inspectFuncFlushCollection(ctx, collectionID)
	}

	mm_params := RepositoryMockFlushCollectionParams{ctx, collectionID}

	// Record call args
	mmFlushCollection.FlushCollectionMock.mutex.Lock()
	mmFlushCollection.FlushCollectionMock.callArgs = append(mmFlushCollection.FlushCollectionMock.callArgs, &mm_params)
	mmFlushCollection.FlushCollectionMock.mutex.Unlock()

	for _, e := range mmFlushCollection.FlushCollectionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmFlushCollection.FlushCollectionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFlushCollection.FlushCollectionMock.defaultExpectation.Counter, 1)
		mm_want := mmFlushCollection.FlushCollectionMock.defaultExpectation.params
		mm_want_ptrs := mmFlushCollection.FlushCollectionMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockFlushCollectionParams{ctx, collectionID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFlushCollection.t.Errorf("RepositoryMock.FlushCollection got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFlushCollection.FlushCollectionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.collectionID != nil && !minimock.Equal(*mm_want_ptrs.collectionID, mm_got.collectionID) {
				mmFlushCollection.t.Errorf("RepositoryMock.FlushCollection got unexpected parameter collectionID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFlushCollection.FlushCollectionMock.defaultExpectation.expectationOrigins.originCollectionID, *mm_want_ptrs.collectionID, mm_got.collectionID, minimock.Diff(*mm_want_ptrs.collectionID, mm_got.collectionID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFlushCollection.t.Errorf("RepositoryMock.FlushCollection got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFlushCollection.FlushCollectionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFlushCollection.FlushCollectionMock.defaultExpectation.results
		if mm_results == nil {
			mmFlushCollection.t.Fatal("No results are set for the RepositoryMock.FlushCollection")
		}
		return (*mm_results).err
	}
	if mmFlushCollection.funcFlushCollection != nil {
		return mmFlushCollection.funcFlushCollection(ctx, collectionID)
	}
	mmFlushCollection.t.Fatalf("Unexpected call to RepositoryMock.FlushCollection. %v %v", ctx, collectionID)
	return
}

// FlushCollectionAfterCounter returns a count of finished RepositoryMock.FlushCollection invocations
func (mmFlushCollection *RepositoryMock) FlushCollectionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFlushCollection.afterFlushCollectionCounter)
}

// FlushCollectionBeforeCounter returns a count of RepositoryMock.FlushCollection invocations
func (mmFlushCollection *RepositoryMock) FlushCollectionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFlushCollection.beforeFlushCollectionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.FlushCollection.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFlushCollection *mRepositoryMockFlushCollection) Calls() []*RepositoryMockFlushCollectionParams {
	mmFlushCollection.mutex.RLock()

	argCopy := make([]*RepositoryMockFlushCollectionParams, len(mmFlushCollection.callArgs))
	copy(argCopy, mmFlushCollection.callArgs)

	mmFlushCollection.mutex.RUnlock()

	return argCopy
}

// MinimockFlushCollectionDone returns true if the count of the FlushCollection invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockFlushCollectionDone() bool {
	if m.FlushCollectionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FlushCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FlushCollectionMock.invocationsDone()
}

// MinimockFlushCollectionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockFlushCollectionInspect() {
	for _, e := range m.FlushCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.FlushCollection at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFlushCollectionCounter := mm_atomic.LoadUint64(&m.afterFlushCollectionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FlushCollectionMock.defaultExpectation != nil && afterFlushCollectionCounter < 1 {
		if m.FlushCollectionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.FlushCollection at\n%s", m.FlushCollectionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.FlushCollection at\n%s with params: %#v", m.FlushCollectionMock.defaultExpectation.expectationOrigins.origin, *m.FlushCollectionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFlushCollection != nil && afterFlushCollectionCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.FlushCollection at\n%s", m.funcFlushCollectionOrigin)
	}

	if !m.FlushCollectionMock.invocationsDone() && afterFlushCollectionCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.FlushCollection at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FlushCollectionMock.expectedInvocations), m.FlushCollectionMock.expectedInvocationsOrigin, afterFlushCollectionCounter)
	}
}

type mRepositoryMockGetActiveCollectionUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetActiveCollectionUIDExpectation
	expectations       []*RepositoryMockGetActiveCollectionUIDExpectation

	callArgs []*RepositoryMockGetActiveCollectionUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetActiveCollectionUIDExpectation specifies expectation struct of the Repository.GetActiveCollectionUID
type RepositoryMockGetActiveCollectionUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetActiveCollectionUIDParams
	paramPtrs          *RepositoryMockGetActiveCollectionUIDParamPtrs
	expectationOrigins RepositoryMockGetActiveCollectionUIDExpectationOrigins
	results            *RepositoryMockGetActiveCollectionUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetActiveCollectionUIDParams contains parameters of the Repository.GetActiveCollectionUID
type RepositoryMockGetActiveCollectionUIDParams struct {
	ctx   context.Context
	kbUID types.KBUIDType
}

// RepositoryMockGetActiveCollectionUIDParamPtrs contains pointers to parameters of the Repository.GetActiveCollectionUID
type RepositoryMockGetActiveCollectionUIDParamPtrs struct {
	ctx   *context.Context
	kbUID *types.KBUIDType
}

// RepositoryMockGetActiveCollectionUIDResults contains results of the Repository.GetActiveCollectionUID
type RepositoryMockGetActiveCollectionUIDResults struct {
	kp1 *types.KBUIDType
	err error
}

// RepositoryMockGetActiveCollectionUIDOrigins contains origins of expectations of the Repository.GetActiveCollectionUID
type RepositoryMockGetActiveCollectionUIDExpectationOrigins struct {
	origin      string
	originCtx   string
	originKbUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetActiveCollectionUID *mRepositoryMockGetActiveCollectionUID) Optional() *mRepositoryMockGetActiveCollectionUID {
	mmGetActiveCollectionUID.optional = true
	return mmGetActiveCollectionUID
}

// Expect sets up expected params for Repository.GetActiveCollectionUID
func (mmGetActiveCollectionUID *mRepositoryMockGetActiveCollectionUID) Expect(ctx context.Context, kbUID types.KBUIDType) *mRepositoryMockGetActiveCollectionUID {
	if mmGetActiveCollectionUID.mock.funcGetActiveCollectionUID != nil {
		mmGetActiveCollectionUID.mock.t.Fatalf("RepositoryMock.GetActiveCollectionUID mock is already set by Set")
	}

	if mmGetActiveCollectionUID.defaultExpectation == nil {
		mmGetActiveCollectionUID.defaultExpectation = &RepositoryMockGetActiveCollectionUIDExpectation{}
	}

	if mmGetActiveCollectionUID.defaultExpectation.paramPtrs != nil {
		mmGetActiveCollectionUID.mock.t.Fatalf("RepositoryMock.GetActiveCollectionUID mock is already set by ExpectParams functions")
	}

	mmGetActiveCollectionUID.defaultExpectation.params = &RepositoryMockGetActiveCollectionUIDParams{ctx, kbUID}
	mmGetActiveCollectionUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetActiveCollectionUID.expectations {
		if minimock.Equal(e.params, mmGetActiveCollectionUID.defaultExpectation.params) {
			mmGetActiveCollectionUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetActiveCollectionUID.defaultExpectation.params)
		}
	}

	return mmGetActiveCollectionUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetActiveCollectionUID
func (mmGetActiveCollectionUID *mRepositoryMockGetActiveCollectionUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetActiveCollectionUID {
	if mmGetActiveCollectionUID.mock.funcGetActiveCollectionUID != nil {
		mmGetActiveCollectionUID.mock.t.Fatalf("RepositoryMock.GetActiveCollectionUID mock is already set by Set")
	}

	if mmGetActiveCollectionUID.defaultExpectation == nil {
		mmGetActiveCollectionUID.defaultExpectation = &RepositoryMockGetActiveCollectionUIDExpectation{}
	}

	if mmGetActiveCollectionUID.defaultExpectation.params != nil {
		mmGetActiveCollectionUID.mock.t.Fatalf("RepositoryMock.GetActiveCollectionUID mock is already set by Expect")
	}

	if mmGetActiveCollectionUID.defaultExpectation.paramPtrs == nil {
		mmGetActiveCollectionUID.defaultExpectation.paramPtrs = &RepositoryMockGetActiveCollectionUIDParamPtrs{}
	}
	mmGetActiveCollectionUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetActiveCollectionUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetActiveCollectionUID
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.GetActiveCollectionUID
func (mmGetActiveCollectionUID *mRepositoryMockGetActiveCollectionUID) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockGetActiveCollectionUID {
	if mmGetActiveCollectionUID.mock.funcGetActiveCollectionUID != nil {
		mmGetActiveCollectionUID.mock.t.Fatalf("RepositoryMock.GetActiveCollectionUID mock is already set by Set")
	}

	if mmGetActiveCollectionUID.defaultExpectation == nil {
		mmGetActiveCollectionUID.defaultExpectation = &RepositoryMockGetActiveCollectionUIDExpectation{}
	}

	if mmGetActiveCollectionUID.defaultExpectation.params != nil {
		mmGetActiveCollectionUID.mock.t.Fatalf("RepositoryMock.GetActiveCollectionUID mock is already set by Expect")
	}

	if mmGetActiveCollectionUID.defaultExpectation.paramPtrs == nil {
		mmGetActiveCollectionUID.defaultExpectation.paramPtrs = &RepositoryMockGetActiveCollectionUIDParamPtrs{}
	}
	mmGetActiveCollectionUID.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmGetActiveCollectionUID.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmGetActiveCollectionUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetActiveCollectionUID
func (mmGetActiveCollectionUID *mRepositoryMockGetActiveCollectionUID) Inspect(f func(ctx context.Context, kbUID types.KBUIDType)) *mRepositoryMockGetActiveCollectionUID {
	if mmGetActiveCollectionUID.mock.inspectFuncGetActiveCollectionUID != nil {
		mmGetActiveCollectionUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetActiveCollectionUID")
	}

	mmGetActiveCollectionUID.mock.inspectFuncGetActiveCollectionUID = f

	return mmGetActiveCollectionUID
}

// Return sets up results that will be returned by Repository.GetActiveCollectionUID
func (mmGetActiveCollectionUID *mRepositoryMockGetActiveCollectionUID) Return(kp1 *types.KBUIDType, err error) *RepositoryMock {
	if mmGetActiveCollectionUID.mock.funcGetActiveCollectionUID != nil {
		mmGetActiveCollectionUID.mock.t.Fatalf("RepositoryMock.GetActiveCollectionUID mock is already set by Set")
	}

	if mmGetActiveCollectionUID.defaultExpectation == nil {
		mmGetActiveCollectionUID.defaultExpectation = &RepositoryMockGetActiveCollectionUIDExpectation{mock: mmGetActiveCollectionUID.mock}
	}
	mmGetActiveCollectionUID.defaultExpectation.results = &RepositoryMockGetActiveCollectionUIDResults{kp1, err}
	mmGetActiveCollectionUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetActiveCollectionUID.mock
}

// Set uses given function f to mock the Repository.GetActiveCollectionUID method
func (mmGetActiveCollectionUID *mRepositoryMockGetActiveCollectionUID) Set(f func(ctx context.Context, kbUID types.KBUIDType) (kp1 *types.KBUIDType, err error)) *RepositoryMock {
	if mmGetActiveCollectionUID.defaultExpectation != nil {
		mmGetActiveCollectionUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetActiveCollectionUID method")
	}

	if len(mmGetActiveCollectionUID.expectations) > 0 {
		mmGetActiveCollectionUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetActiveCollectionUID method")
	}

	mmGetActiveCollectionUID.mock.funcGetActiveCollectionUID = f
	mmGetActiveCollectionUID.mock.funcGetActiveCollectionUIDOrigin = minimock.CallerInfo(1)
	return mmGetActiveCollectionUID.mock
}

// When sets expectation for the Repository.GetActiveCollectionUID which will trigger the result defined by the following
// Then helper
func (mmGetActiveCollectionUID *mRepositoryMockGetActiveCollectionUID) When(ctx context.Context, kbUID types.KBUIDType) *RepositoryMockGetActiveCollectionUIDExpectation {
	if mmGetActiveCollectionUID.mock.funcGetActiveCollectionUID != nil {
		mmGetActiveCollectionUID.mock.t.Fatalf("RepositoryMock.GetActiveCollectionUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetActiveCollectionUIDExpectation{
		mock:               mmGetActiveCollectionUID.mock,
		params:             &RepositoryMockGetActiveCollectionUIDParams{ctx, kbUID},
		expectationOrigins: RepositoryMockGetActiveCollectionUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetActiveCollectionUID.expectations = append(mmGetActiveCollectionUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetActiveCollectionUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetActiveCollectionUIDExpectation) Then(kp1 *types.KBUIDType, err error) *RepositoryMock {
	e.results = &RepositoryMockGetActiveCollectionUIDResults{kp1, err}
	return e.mock
}

// Times sets number of times Repository.GetActiveCollectionUID should be invoked
func (mmGetActiveCollectionUID *mRepositoryMockGetActiveCollectionUID) Times(n uint64) *mRepositoryMockGetActiveCollectionUID {
	if n == 0 {
		mmGetActiveCollectionUID.mock.t.Fatalf("Times of RepositoryMock.GetActiveCollectionUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetActiveCollectionUID.expectedInvocations, n)
	mmGetActiveCollectionUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetActiveCollectionUID
}

func (mmGetActiveCollectionUID *mRepositoryMockGetActiveCollectionUID) invocationsDone() bool {
	if len(mmGetActiveCollectionUID.expectations) == 0 && mmGetActiveCollectionUID.defaultExpectation == nil && mmGetActiveCollectionUID.mock.funcGetActiveCollectionUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetActiveCollectionUID.mock.afterGetActiveCollectionUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetActiveCollectionUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetActiveCollectionUID implements mm_repository.Repository
func (mmGetActiveCollectionUID *RepositoryMock) GetActiveCollectionUID(ctx context.Context, kbUID types.KBUIDType) (kp1 *types.KBUIDType, err error) {
	mm_atomic.AddUint64(&mmGetActiveCollectionUID.beforeGetActiveCollectionUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetActiveCollectionUID.afterGetActiveCollectionUIDCounter, 1)

	mmGetActiveCollectionUID.t.Helper()

	if mmGetActiveCollectionUID.inspectFuncGetActiveCollectionUID != nil {
		mmGetActiveCollectionUID.inspectFuncGetActiveCollectionUID(ctx, kbUID)
	}

	mm_params := RepositoryMockGetActiveCollectionUIDParams{ctx, kbUID}

	// Record call args
	mmGetActiveCollectionUID.GetActiveCollectionUIDMock.mutex.Lock()
	mmGetActiveCollectionUID.GetActiveCollectionUIDMock.callArgs = append(mmGetActiveCollectionUID.GetActiveCollectionUIDMock.callArgs, &mm_params)
	mmGetActiveCollectionUID.GetActiveCollectionUIDMock.mutex.Unlock()

	for _, e := range mmGetActiveCollectionUID.GetActiveCollectionUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmGetActiveCollectionUID.GetActiveCollectionUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetActiveCollectionUID.GetActiveCollectionUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetActiveCollectionUID.GetActiveCollectionUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetActiveCollectionUID.GetActiveCollectionUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetActiveCollectionUIDParams{ctx, kbUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetActiveCollectionUID.t.Errorf("RepositoryMock.GetActiveCollectionUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetActiveCollectionUID.GetActiveCollectionUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmGetActiveCollectionUID.t.Errorf("RepositoryMock.GetActiveCollectionUID got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetActiveCollectionUID.GetActiveCollectionUIDMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetActiveCollectionUID.t.Errorf("RepositoryMock.GetActiveCollectionUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetActiveCollectionUID.GetActiveCollectionUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetActiveCollectionUID.GetActiveCollectionUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetActiveCollectionUID.t.Fatal("No results are set for the RepositoryMock.GetActiveCollectionUID")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmGetActiveCollectionUID.funcGetActiveCollectionUID != nil {
		return mmGetActiveCollectionUID.funcGetActiveCollectionUID(ctx, kbUID)
	}
	mmGetActiveCollectionUID.t.Fatalf("Unexpected call to RepositoryMock.GetActiveCollectionUID. %v %v", ctx, kbUID)
	return
}

// GetActiveCollectionUIDAfterCounter returns a count of finished RepositoryMock.GetActiveCollectionUID invocations
func (mmGetActiveCollectionUID *RepositoryMock) GetActiveCollectionUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetActiveCollectionUID.afterGetActiveCollectionUIDCounter)
}

// GetActiveCollectionUIDBeforeCounter returns a count of RepositoryMock.GetActiveCollectionUID invocations
func (mmGetActiveCollectionUID *RepositoryMock) GetActiveCollectionUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetActiveCollectionUID.beforeGetActiveCollectionUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetActiveCollectionUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetActiveCollectionUID *mRepositoryMockGetActiveCollectionUID) Calls() []*RepositoryMockGetActiveCollectionUIDParams {
	mmGetActiveCollectionUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetActiveCollectionUIDParams, len(mmGetActiveCollectionUID.callArgs))
	copy(argCopy, mmGetActiveCollectionUID.callArgs)

	mmGetActiveCollectionUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetActiveCollectionUIDDone returns true if the count of the GetActiveCollectionUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetActiveCollectionUIDDone() bool {
	if m.GetActiveCollectionUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetActiveCollectionUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetActiveCollectionUIDMock.invocationsDone()
}

// MinimockGetActiveCollectionUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetActiveCollectionUIDInspect() {
	for _, e := range m.GetActiveCollectionUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetActiveCollectionUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetActiveCollectionUIDCounter := mm_atomic.LoadUint64(&m.afterGetActiveCollectionUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetActiveCollectionUIDMock.defaultExpectation != nil && afterGetActiveCollectionUIDCounter < 1 {
		if m.GetActiveCollectionUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetActiveCollectionUID at\n%s", m.GetActiveCollectionUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetActiveCollectionUID at\n%s with params: %#v", m.GetActiveCollectionUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetActiveCollectionUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetActiveCollectionUID != nil && afterGetActiveCollectionUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetActiveCollectionUID at\n%s", m.funcGetActiveCollectionUIDOrigin)
	}

	if !m.GetActiveCollectionUIDMock.invocationsDone() && afterGetActiveCollectionUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetActiveCollectionUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetActiveCollectionUIDMock.expectedInvocations), m.GetActiveCollectionUIDMock.expectedInvocationsOrigin, afterGetActiveCollectionUIDCounter)
	}
}

type mRepositoryMockGetAllConvertedFilesByFileUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetAllConvertedFilesByFileUIDExpectation
	expectations       []*RepositoryMockGetAllConvertedFilesByFileUIDExpectation

	callArgs []*RepositoryMockGetAllConvertedFilesByFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetAllConvertedFilesByFileUIDExpectation specifies expectation struct of the Repository.GetAllConvertedFilesByFileUID
type RepositoryMockGetAllConvertedFilesByFileUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetAllConvertedFilesByFileUIDParams
	paramPtrs          *RepositoryMockGetAllConvertedFilesByFileUIDParamPtrs
	expectationOrigins RepositoryMockGetAllConvertedFilesByFileUIDExpectationOrigins
	results            *RepositoryMockGetAllConvertedFilesByFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetAllConvertedFilesByFileUIDParams contains parameters of the Repository.GetAllConvertedFilesByFileUID
type RepositoryMockGetAllConvertedFilesByFileUIDParams struct {
	ctx     context.Context
	fileUID types.FileUIDType
}

// RepositoryMockGetAllConvertedFilesByFileUIDParamPtrs contains pointers to parameters of the Repository.GetAllConvertedFilesByFileUID
type RepositoryMockGetAllConvertedFilesByFileUIDParamPtrs struct {
	ctx     *context.Context
	fileUID *types.FileUIDType
}

// RepositoryMockGetAllConvertedFilesByFileUIDResults contains results of the Repository.GetAllConvertedFilesByFileUID
type RepositoryMockGetAllConvertedFilesByFileUIDResults struct {
	ca1 []mm_repository.ConvertedFileModel
	err error
}

// RepositoryMockGetAllConvertedFilesByFileUIDOrigins contains origins of expectations of the Repository.GetAllConvertedFilesByFileUID
type RepositoryMockGetAllConvertedFilesByFileUIDExpectationOrigins struct {
	origin        string
	originCtx     string
	originFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAllConvertedFilesByFileUID *mRepositoryMockGetAllConvertedFilesByFileUID) Optional() *mRepositoryMockGetAllConvertedFilesByFileUID {
	mmGetAllConvertedFilesByFileUID.optional = true
	return mmGetAllConvertedFilesByFileUID
}

// Expect sets up expected params for Repository.GetAllConvertedFilesByFileUID
func (mmGetAllConvertedFilesByFileUID *mRepositoryMockGetAllConvertedFilesByFileUID) Expect(ctx context.Context, fileUID types.FileUIDType) *mRepositoryMockGetAllConvertedFilesByFileUID {
	if mmGetAllConvertedFilesByFileUID.mock.funcGetAllConvertedFilesByFileUID != nil {
		mmGetAllConvertedFilesByFileUID.mock.t.Fatalf("RepositoryMock.GetAllConvertedFilesByFileUID mock is already set by Set")
	}

	if mmGetAllConvertedFilesByFileUID.defaultExpectation == nil {
		mmGetAllConvertedFilesByFileUID.defaultExpectation = &RepositoryMockGetAllConvertedFilesByFileUIDExpectation{}
	}

	if mmGetAllConvertedFilesByFileUID.defaultExpectation.paramPtrs != nil {
		mmGetAllConvertedFilesByFileUID.mock.t.Fatalf("RepositoryMock.GetAllConvertedFilesByFileUID mock is already set by ExpectParams functions")
	}

	mmGetAllConvertedFilesByFileUID.defaultExpectation.params = &RepositoryMockGetAllConvertedFilesByFileUIDParams{ctx, fileUID}
	mmGetAllConvertedFilesByFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetAllConvertedFilesByFileUID.expectations {
		if minimock.Equal(e.params, mmGetAllConvertedFilesByFileUID.defaultExpectation.params) {
			mmGetAllConvertedFilesByFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAllConvertedFilesByFileUID.defaultExpectation.params)
		}
	}

	return mmGetAllConvertedFilesByFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetAllConvertedFilesByFileUID
func (mmGetAllConvertedFilesByFileUID *mRepositoryMockGetAllConvertedFilesByFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetAllConvertedFilesByFileUID {
	if mmGetAllConvertedFilesByFileUID.mock.funcGetAllConvertedFilesByFileUID != nil {
		mmGetAllConvertedFilesByFileUID.mock.t.Fatalf("RepositoryMock.GetAllConvertedFilesByFileUID mock is already set by Set")
	}

	if mmGetAllConvertedFilesByFileUID.defaultExpectation == nil {
		mmGetAllConvertedFilesByFileUID.defaultExpectation = &RepositoryMockGetAllConvertedFilesByFileUIDExpectation{}
	}

	if mmGetAllConvertedFilesByFileUID.defaultExpectation.params != nil {
		mmGetAllConvertedFilesByFileUID.mock.t.Fatalf("RepositoryMock.GetAllConvertedFilesByFileUID mock is already set by Expect")
	}

	if mmGetAllConvertedFilesByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetAllConvertedFilesByFileUID.defaultExpectation.paramPtrs = &RepositoryMockGetAllConvertedFilesByFileUIDParamPtrs{}
	}
	mmGetAllConvertedFilesByFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetAllConvertedFilesByFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetAllConvertedFilesByFileUID
}

// ExpectFileUIDParam2 sets up expected param fileUID for Repository.GetAllConvertedFilesByFileUID
func (mmGetAllConvertedFilesByFileUID *mRepositoryMockGetAllConvertedFilesByFileUID) ExpectFileUIDParam2(fileUID types.FileUIDType) *mRepositoryMockGetAllConvertedFilesByFileUID {
	if mmGetAllConvertedFilesByFileUID.mock.funcGetAllConvertedFilesByFileUID != nil {
		mmGetAllConvertedFilesByFileUID.mock.t.Fatalf("RepositoryMock.GetAllConvertedFilesByFileUID mock is already set by Set")
	}

	if mmGetAllConvertedFilesByFileUID.defaultExpectation == nil {
		mmGetAllConvertedFilesByFileUID.defaultExpectation = &RepositoryMockGetAllConvertedFilesByFileUIDExpectation{}
	}

	if mmGetAllConvertedFilesByFileUID.defaultExpectation.params != nil {
		mmGetAllConvertedFilesByFileUID.mock.t.Fatalf("RepositoryMock.GetAllConvertedFilesByFileUID mock is already set by Expect")
	}

	if mmGetAllConvertedFilesByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetAllConvertedFilesByFileUID.defaultExpectation.paramPtrs = &RepositoryMockGetAllConvertedFilesByFileUIDParamPtrs{}
	}
	mmGetAllConvertedFilesByFileUID.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmGetAllConvertedFilesByFileUID.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmGetAllConvertedFilesByFileUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetAllConvertedFilesByFileUID
func (mmGetAllConvertedFilesByFileUID *mRepositoryMockGetAllConvertedFilesByFileUID) Inspect(f func(ctx context.Context, fileUID types.FileUIDType)) *mRepositoryMockGetAllConvertedFilesByFileUID {
	if mmGetAllConvertedFilesByFileUID.mock.inspectFuncGetAllConvertedFilesByFileUID != nil {
		mmGetAllConvertedFilesByFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetAllConvertedFilesByFileUID")
	}

	mmGetAllConvertedFilesByFileUID.mock.inspectFuncGetAllConvertedFilesByFileUID = f

	return mmGetAllConvertedFilesByFileUID
}

// Return sets up results that will be returned by Repository.GetAllConvertedFilesByFileUID
func (mmGetAllConvertedFilesByFileUID *mRepositoryMockGetAllConvertedFilesByFileUID) Return(ca1 []mm_repository.ConvertedFileModel, err error) *RepositoryMock {
	if mmGetAllConvertedFilesByFileUID.mock.funcGetAllConvertedFilesByFileUID != nil {
		mmGetAllConvertedFilesByFileUID.mock.t.Fatalf("RepositoryMock.GetAllConvertedFilesByFileUID mock is already set by Set")
	}

	if mmGetAllConvertedFilesByFileUID.defaultExpectation == nil {
		mmGetAllConvertedFilesByFileUID.defaultExpectation = &RepositoryMockGetAllConvertedFilesByFileUIDExpectation{mock: mmGetAllConvertedFilesByFileUID.mock}
	}
	mmGetAllConvertedFilesByFileUID.defaultExpectation.results = &RepositoryMockGetAllConvertedFilesByFileUIDResults{ca1, err}
	mmGetAllConvertedFilesByFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAllConvertedFilesByFileUID.mock
}

// Set uses given function f to mock the Repository.GetAllConvertedFilesByFileUID method
func (mmGetAllConvertedFilesByFileUID *mRepositoryMockGetAllConvertedFilesByFileUID) Set(f func(ctx context.Context, fileUID types.FileUIDType) (ca1 []mm_repository.ConvertedFileModel, err error)) *RepositoryMock {
	if mmGetAllConvertedFilesByFileUID.defaultExpectation != nil {
		mmGetAllConvertedFilesByFileUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetAllConvertedFilesByFileUID method")
	}

	if len(mmGetAllConvertedFilesByFileUID.expectations) > 0 {
		mmGetAllConvertedFilesByFileUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetAllConvertedFilesByFileUID method")
	}

	mmGetAllConvertedFilesByFileUID.mock.funcGetAllConvertedFilesByFileUID = f
	mmGetAllConvertedFilesByFileUID.mock.funcGetAllConvertedFilesByFileUIDOrigin = minimock.CallerInfo(1)
	return mmGetAllConvertedFilesByFileUID.mock
}

// When sets expectation for the Repository.GetAllConvertedFilesByFileUID which will trigger the result defined by the following
// Then helper
func (mmGetAllConvertedFilesByFileUID *mRepositoryMockGetAllConvertedFilesByFileUID) When(ctx context.Context, fileUID types.FileUIDType) *RepositoryMockGetAllConvertedFilesByFileUIDExpectation {
	if mmGetAllConvertedFilesByFileUID.mock.funcGetAllConvertedFilesByFileUID != nil {
		mmGetAllConvertedFilesByFileUID.mock.t.Fatalf("RepositoryMock.GetAllConvertedFilesByFileUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetAllConvertedFilesByFileUIDExpectation{
		mock:               mmGetAllConvertedFilesByFileUID.mock,
		params:             &RepositoryMockGetAllConvertedFilesByFileUIDParams{ctx, fileUID},
		expectationOrigins: RepositoryMockGetAllConvertedFilesByFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetAllConvertedFilesByFileUID.expectations = append(mmGetAllConvertedFilesByFileUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetAllConvertedFilesByFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetAllConvertedFilesByFileUIDExpectation) Then(ca1 []mm_repository.ConvertedFileModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetAllConvertedFilesByFileUIDResults{ca1, err}
	return e.mock
}

// Times sets number of times Repository.GetAllConvertedFilesByFileUID should be invoked
func (mmGetAllConvertedFilesByFileUID *mRepositoryMockGetAllConvertedFilesByFileUID) Times(n uint64) *mRepositoryMockGetAllConvertedFilesByFileUID {
	if n == 0 {
		mmGetAllConvertedFilesByFileUID.mock.t.Fatalf("Times of RepositoryMock.GetAllConvertedFilesByFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAllConvertedFilesByFileUID.expectedInvocations, n)
	mmGetAllConvertedFilesByFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAllConvertedFilesByFileUID
}

func (mmGetAllConvertedFilesByFileUID *mRepositoryMockGetAllConvertedFilesByFileUID) invocationsDone() bool {
	if len(mmGetAllConvertedFilesByFileUID.expectations) == 0 && mmGetAllConvertedFilesByFileUID.defaultExpectation == nil && mmGetAllConvertedFilesByFileUID.mock.funcGetAllConvertedFilesByFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAllConvertedFilesByFileUID.mock.afterGetAllConvertedFilesByFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAllConvertedFilesByFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAllConvertedFilesByFileUID implements mm_repository.Repository
func (mmGetAllConvertedFilesByFileUID *RepositoryMock) GetAllConvertedFilesByFileUID(ctx context.Context, fileUID types.FileUIDType) (ca1 []mm_repository.ConvertedFileModel, err error) {
	mm_atomic.AddUint64(&mmGetAllConvertedFilesByFileUID.beforeGetAllConvertedFilesByFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAllConvertedFilesByFileUID.afterGetAllConvertedFilesByFileUIDCounter, 1)

	mmGetAllConvertedFilesByFileUID.t.Helper()

	if mmGetAllConvertedFilesByFileUID.inspectFuncGetAllConvertedFilesByFileUID != nil {
		mmGetAllConvertedFilesByFileUID.inspectFuncGetAllConvertedFilesByFileUID(ctx, fileUID)
	}

	mm_params := RepositoryMockGetAllConvertedFilesByFileUIDParams{ctx, fileUID}

	// Record call args
	mmGetAllConvertedFilesByFileUID.GetAllConvertedFilesByFileUIDMock.mutex.Lock()
	mmGetAllConvertedFilesByFileUID.GetAllConvertedFilesByFileUIDMock.callArgs = append(mmGetAllConvertedFilesByFileUID.GetAllConvertedFilesByFileUIDMock.callArgs, &mm_params)
	mmGetAllConvertedFilesByFileUID.GetAllConvertedFilesByFileUIDMock.mutex.Unlock()

	for _, e := range mmGetAllConvertedFilesByFileUID.GetAllConvertedFilesByFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.err
		}
	}

	if mmGetAllConvertedFilesByFileUID.GetAllConvertedFilesByFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAllConvertedFilesByFileUID.GetAllConvertedFilesByFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAllConvertedFilesByFileUID.GetAllConvertedFilesByFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetAllConvertedFilesByFileUID.GetAllConvertedFilesByFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetAllConvertedFilesByFileUIDParams{ctx, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAllConvertedFilesByFileUID.t.Errorf("RepositoryMock.GetAllConvertedFilesByFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAllConvertedFilesByFileUID.GetAllConvertedFilesByFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmGetAllConvertedFilesByFileUID.t.Errorf("RepositoryMock.GetAllConvertedFilesByFileUID got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAllConvertedFilesByFileUID.GetAllConvertedFilesByFileUIDMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAllConvertedFilesByFileUID.t.Errorf("RepositoryMock.GetAllConvertedFilesByFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetAllConvertedFilesByFileUID.GetAllConvertedFilesByFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAllConvertedFilesByFileUID.GetAllConvertedFilesByFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAllConvertedFilesByFileUID.t.Fatal("No results are set for the RepositoryMock.GetAllConvertedFilesByFileUID")
		}
		return (*mm_results).ca1, (*mm_results).err
	}
	if mmGetAllConvertedFilesByFileUID.funcGetAllConvertedFilesByFileUID != nil {
		return mmGetAllConvertedFilesByFileUID.funcGetAllConvertedFilesByFileUID(ctx, fileUID)
	}
	mmGetAllConvertedFilesByFileUID.t.Fatalf("Unexpected call to RepositoryMock.GetAllConvertedFilesByFileUID. %v %v", ctx, fileUID)
	return
}

// GetAllConvertedFilesByFileUIDAfterCounter returns a count of finished RepositoryMock.GetAllConvertedFilesByFileUID invocations
func (mmGetAllConvertedFilesByFileUID *RepositoryMock) GetAllConvertedFilesByFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllConvertedFilesByFileUID.afterGetAllConvertedFilesByFileUIDCounter)
}

// GetAllConvertedFilesByFileUIDBeforeCounter returns a count of RepositoryMock.GetAllConvertedFilesByFileUID invocations
func (mmGetAllConvertedFilesByFileUID *RepositoryMock) GetAllConvertedFilesByFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllConvertedFilesByFileUID.beforeGetAllConvertedFilesByFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetAllConvertedFilesByFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAllConvertedFilesByFileUID *mRepositoryMockGetAllConvertedFilesByFileUID) Calls() []*RepositoryMockGetAllConvertedFilesByFileUIDParams {
	mmGetAllConvertedFilesByFileUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetAllConvertedFilesByFileUIDParams, len(mmGetAllConvertedFilesByFileUID.callArgs))
	copy(argCopy, mmGetAllConvertedFilesByFileUID.callArgs)

	mmGetAllConvertedFilesByFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllConvertedFilesByFileUIDDone returns true if the count of the GetAllConvertedFilesByFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetAllConvertedFilesByFileUIDDone() bool {
	if m.GetAllConvertedFilesByFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAllConvertedFilesByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAllConvertedFilesByFileUIDMock.invocationsDone()
}

// MinimockGetAllConvertedFilesByFileUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetAllConvertedFilesByFileUIDInspect() {
	for _, e := range m.GetAllConvertedFilesByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetAllConvertedFilesByFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetAllConvertedFilesByFileUIDCounter := mm_atomic.LoadUint64(&m.afterGetAllConvertedFilesByFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllConvertedFilesByFileUIDMock.defaultExpectation != nil && afterGetAllConvertedFilesByFileUIDCounter < 1 {
		if m.GetAllConvertedFilesByFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetAllConvertedFilesByFileUID at\n%s", m.GetAllConvertedFilesByFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetAllConvertedFilesByFileUID at\n%s with params: %#v", m.GetAllConvertedFilesByFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetAllConvertedFilesByFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAllConvertedFilesByFileUID != nil && afterGetAllConvertedFilesByFileUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetAllConvertedFilesByFileUID at\n%s", m.funcGetAllConvertedFilesByFileUIDOrigin)
	}

	if !m.GetAllConvertedFilesByFileUIDMock.invocationsDone() && afterGetAllConvertedFilesByFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetAllConvertedFilesByFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAllConvertedFilesByFileUIDMock.expectedInvocations), m.GetAllConvertedFilesByFileUIDMock.expectedInvocationsOrigin, afterGetAllConvertedFilesByFileUIDCounter)
	}
}

type mRepositoryMockGetCacheMetadata struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetCacheMetadataExpectation
	expectations       []*RepositoryMockGetCacheMetadataExpectation

	callArgs []*RepositoryMockGetCacheMetadataParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetCacheMetadataExpectation specifies expectation struct of the Repository.GetCacheMetadata
type RepositoryMockGetCacheMetadataExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetCacheMetadataParams
	paramPtrs          *RepositoryMockGetCacheMetadataParamPtrs
	expectationOrigins RepositoryMockGetCacheMetadataExpectationOrigins
	results            *RepositoryMockGetCacheMetadataResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetCacheMetadataParams contains parameters of the Repository.GetCacheMetadata
type RepositoryMockGetCacheMetadataParams struct {
	ctx      context.Context
	kbUID    types.KBUIDType
	fileUIDs []types.FileUIDType
}

// RepositoryMockGetCacheMetadataParamPtrs contains pointers to parameters of the Repository.GetCacheMetadata
type RepositoryMockGetCacheMetadataParamPtrs struct {
	ctx      *context.Context
	kbUID    *types.KBUIDType
	fileUIDs *[]types.FileUIDType
}

// RepositoryMockGetCacheMetadataResults contains results of the Repository.GetCacheMetadata
type RepositoryMockGetCacheMetadataResults struct {
	cp1 *mm_repository.CacheMetadata
	err error
}

// RepositoryMockGetCacheMetadataOrigins contains origins of expectations of the Repository.GetCacheMetadata
type RepositoryMockGetCacheMetadataExpectationOrigins struct {
	origin         string
	originCtx      string
	originKbUID    string
	originFileUIDs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCacheMetadata *mRepositoryMockGetCacheMetadata) Optional() *mRepositoryMockGetCacheMetadata {
	mmGetCacheMetadata.optional = true
	return mmGetCacheMetadata
}

// Expect sets up expected params for Repository.GetCacheMetadata
func (mmGetCacheMetadata *mRepositoryMockGetCacheMetadata) Expect(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType) *mRepositoryMockGetCacheMetadata {
	if mmGetCacheMetadata.mock.funcGetCacheMetadata != nil {
		mmGetCacheMetadata.mock.t.Fatalf("RepositoryMock.GetCacheMetadata mock is already set by Set")
	}

	if mmGetCacheMetadata.defaultExpectation == nil {
		mmGetCacheMetadata.defaultExpectation = &RepositoryMockGetCacheMetadataExpectation{}
	}

	if mmGetCacheMetadata.defaultExpectation.paramPtrs != nil {
		mmGetCacheMetadata.mock.t.Fatalf("RepositoryMock.GetCacheMetadata mock is already set by ExpectParams functions")
	}

	mmGetCacheMetadata.defaultExpectation.params = &RepositoryMockGetCacheMetadataParams{ctx, kbUID, fileUIDs}
	mmGetCacheMetadata.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCacheMetadata.expectations {
		if minimock.Equal(e.params, mmGetCacheMetadata.defaultExpectation.params) {
			mmGetCacheMetadata.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCacheMetadata.defaultExpectation.params)
		}
	}

	return mmGetCacheMetadata
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetCacheMetadata
func (mmGetCacheMetadata *mRepositoryMockGetCacheMetadata) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetCacheMetadata {
	if mmGetCacheMetadata.mock.funcGetCacheMetadata != nil {
		mmGetCacheMetadata.mock.t.Fatalf("RepositoryMock.GetCacheMetadata mock is already set by Set")
	}

	if mmGetCacheMetadata.defaultExpectation == nil {
		mmGetCacheMetadata.defaultExpectation = &RepositoryMockGetCacheMetadataExpectation{}
	}

	if mmGetCacheMetadata.defaultExpectation.params != nil {
		mmGetCacheMetadata.mock.t.Fatalf("RepositoryMock.GetCacheMetadata mock is already set by Expect")
	}

	if mmGetCacheMetadata.defaultExpectation.paramPtrs == nil {
		mmGetCacheMetadata.defaultExpectation.paramPtrs = &RepositoryMockGetCacheMetadataParamPtrs{}
	}
	mmGetCacheMetadata.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetCacheMetadata.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetCacheMetadata
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.GetCacheMetadata
func (mmGetCacheMetadata *mRepositoryMockGetCacheMetadata) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockGetCacheMetadata {
	if mmGetCacheMetadata.mock.funcGetCacheMetadata != nil {
		mmGetCacheMetadata.mock.t.Fatalf("RepositoryMock.GetCacheMetadata mock is already set by Set")
	}

	if mmGetCacheMetadata.defaultExpectation == nil {
		mmGetCacheMetadata.defaultExpectation = &RepositoryMockGetCacheMetadataExpectation{}
	}

	if mmGetCacheMetadata.defaultExpectation.params != nil {
		mmGetCacheMetadata.mock.t.Fatalf("RepositoryMock.GetCacheMetadata mock is already set by Expect")
	}

	if mmGetCacheMetadata.defaultExpectation.paramPtrs == nil {
		mmGetCacheMetadata.defaultExpectation.paramPtrs = &RepositoryMockGetCacheMetadataParamPtrs{}
	}
	mmGetCacheMetadata.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmGetCacheMetadata.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmGetCacheMetadata
}

// ExpectFileUIDsParam3 sets up expected param fileUIDs for Repository.GetCacheMetadata
func (mmGetCacheMetadata *mRepositoryMockGetCacheMetadata) ExpectFileUIDsParam3(fileUIDs []types.FileUIDType) *mRepositoryMockGetCacheMetadata {
	if mmGetCacheMetadata.mock.funcGetCacheMetadata != nil {
		mmGetCacheMetadata.mock.t.Fatalf("RepositoryMock.GetCacheMetadata mock is already set by Set")
	}

	if mmGetCacheMetadata.defaultExpectation == nil {
		mmGetCacheMetadata.defaultExpectation = &RepositoryMockGetCacheMetadataExpectation{}
	}

	if mmGetCacheMetadata.defaultExpectation.params != nil {
		mmGetCacheMetadata.mock.t.Fatalf("RepositoryMock.GetCacheMetadata mock is already set by Expect")
	}

	if mmGetCacheMetadata.defaultExpectation.paramPtrs == nil {
		mmGetCacheMetadata.defaultExpectation.paramPtrs = &RepositoryMockGetCacheMetadataParamPtrs{}
	}
	mmGetCacheMetadata.defaultExpectation.paramPtrs.fileUIDs = &fileUIDs
	mmGetCacheMetadata.defaultExpectation.expectationOrigins.originFileUIDs = minimock.CallerInfo(1)

	return mmGetCacheMetadata
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetCacheMetadata
func (mmGetCacheMetadata *mRepositoryMockGetCacheMetadata) Inspect(f func(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType)) *mRepositoryMockGetCacheMetadata {
	if mmGetCacheMetadata.mock.inspectFuncGetCacheMetadata != nil {
		mmGetCacheMetadata.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetCacheMetadata")
	}

	mmGetCacheMetadata.mock.inspectFuncGetCacheMetadata = f

	return mmGetCacheMetadata
}

// Return sets up results that will be returned by Repository.GetCacheMetadata
func (mmGetCacheMetadata *mRepositoryMockGetCacheMetadata) Return(cp1 *mm_repository.CacheMetadata, err error) *RepositoryMock {
	if mmGetCacheMetadata.mock.funcGetCacheMetadata != nil {
		mmGetCacheMetadata.mock.t.Fatalf("RepositoryMock.GetCacheMetadata mock is already set by Set")
	}

	if mmGetCacheMetadata.defaultExpectation == nil {
		mmGetCacheMetadata.defaultExpectation = &RepositoryMockGetCacheMetadataExpectation{mock: mmGetCacheMetadata.mock}
	}
	mmGetCacheMetadata.defaultExpectation.results = &RepositoryMockGetCacheMetadataResults{cp1, err}
	mmGetCacheMetadata.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCacheMetadata.mock
}

// Set uses given function f to mock the Repository.GetCacheMetadata method
func (mmGetCacheMetadata *mRepositoryMockGetCacheMetadata) Set(f func(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType) (cp1 *mm_repository.CacheMetadata, err error)) *RepositoryMock {
	if mmGetCacheMetadata.defaultExpectation != nil {
		mmGetCacheMetadata.mock.t.Fatalf("Default expectation is already set for the Repository.GetCacheMetadata method")
	}

	if len(mmGetCacheMetadata.expectations) > 0 {
		mmGetCacheMetadata.mock.t.Fatalf("Some expectations are already set for the Repository.GetCacheMetadata method")
	}

	mmGetCacheMetadata.mock.funcGetCacheMetadata = f
	mmGetCacheMetadata.mock.funcGetCacheMetadataOrigin = minimock.CallerInfo(1)
	return mmGetCacheMetadata.mock
}

// When sets expectation for the Repository.GetCacheMetadata which will trigger the result defined by the following
// Then helper
func (mmGetCacheMetadata *mRepositoryMockGetCacheMetadata) When(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType) *RepositoryMockGetCacheMetadataExpectation {
	if mmGetCacheMetadata.mock.funcGetCacheMetadata != nil {
		mmGetCacheMetadata.mock.t.Fatalf("RepositoryMock.GetCacheMetadata mock is already set by Set")
	}

	expectation := &RepositoryMockGetCacheMetadataExpectation{
		mock:               mmGetCacheMetadata.mock,
		params:             &RepositoryMockGetCacheMetadataParams{ctx, kbUID, fileUIDs},
		expectationOrigins: RepositoryMockGetCacheMetadataExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCacheMetadata.expectations = append(mmGetCacheMetadata.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetCacheMetadata return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetCacheMetadataExpectation) Then(cp1 *mm_repository.CacheMetadata, err error) *RepositoryMock {
	e.results = &RepositoryMockGetCacheMetadataResults{cp1, err}
	return e.mock
}

// Times sets number of times Repository.GetCacheMetadata should be invoked
func (mmGetCacheMetadata *mRepositoryMockGetCacheMetadata) Times(n uint64) *mRepositoryMockGetCacheMetadata {
	if n == 0 {
		mmGetCacheMetadata.mock.t.Fatalf("Times of RepositoryMock.GetCacheMetadata mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCacheMetadata.expectedInvocations, n)
	mmGetCacheMetadata.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCacheMetadata
}

func (mmGetCacheMetadata *mRepositoryMockGetCacheMetadata) invocationsDone() bool {
	if len(mmGetCacheMetadata.expectations) == 0 && mmGetCacheMetadata.defaultExpectation == nil && mmGetCacheMetadata.mock.funcGetCacheMetadata == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCacheMetadata.mock.afterGetCacheMetadataCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCacheMetadata.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCacheMetadata implements mm_repository.Repository
func (mmGetCacheMetadata *RepositoryMock) GetCacheMetadata(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType) (cp1 *mm_repository.CacheMetadata, err error) {
	mm_atomic.AddUint64(&mmGetCacheMetadata.beforeGetCacheMetadataCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCacheMetadata.afterGetCacheMetadataCounter, 1)

	mmGetCacheMetadata.t.Helper()

	if mmGetCacheMetadata.inspectFuncGetCacheMetadata != nil {
		mmGetCacheMetadata.inspectFuncGetCacheMetadata(ctx, kbUID, fileUIDs)
	}

	mm_params := RepositoryMockGetCacheMetadataParams{ctx, kbUID, fileUIDs}

	// Record call args
	mmGetCacheMetadata.GetCacheMetadataMock.mutex.Lock()
	mmGetCacheMetadata.GetCacheMetadataMock.callArgs = append(mmGetCacheMetadata.GetCacheMetadataMock.callArgs, &mm_params)
	mmGetCacheMetadata.GetCacheMetadataMock.mutex.Unlock()

	for _, e := range mmGetCacheMetadata.GetCacheMetadataMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetCacheMetadata.GetCacheMetadataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCacheMetadata.GetCacheMetadataMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCacheMetadata.GetCacheMetadataMock.defaultExpectation.params
		mm_want_ptrs := mmGetCacheMetadata.GetCacheMetadataMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetCacheMetadataParams{ctx, kbUID, fileUIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCacheMetadata.t.Errorf("RepositoryMock.GetCacheMetadata got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCacheMetadata.GetCacheMetadataMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmGetCacheMetadata.t.Errorf("RepositoryMock.GetCacheMetadata got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCacheMetadata.GetCacheMetadataMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.fileUIDs != nil && !minimock.Equal(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs) {
				mmGetCacheMetadata.t.Errorf("RepositoryMock.GetCacheMetadata got unexpected parameter fileUIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCacheMetadata.GetCacheMetadataMock.defaultExpectation.expectationOrigins.originFileUIDs, *mm_want_ptrs.fileUIDs, mm_got.fileUIDs, minimock.Diff(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCacheMetadata.t.Errorf("RepositoryMock.GetCacheMetadata got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCacheMetadata.GetCacheMetadataMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCacheMetadata.GetCacheMetadataMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCacheMetadata.t.Fatal("No results are set for the RepositoryMock.GetCacheMetadata")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetCacheMetadata.funcGetCacheMetadata != nil {
		return mmGetCacheMetadata.funcGetCacheMetadata(ctx, kbUID, fileUIDs)
	}
	mmGetCacheMetadata.t.Fatalf("Unexpected call to RepositoryMock.GetCacheMetadata. %v %v %v", ctx, kbUID, fileUIDs)
	return
}

// GetCacheMetadataAfterCounter returns a count of finished RepositoryMock.GetCacheMetadata invocations
func (mmGetCacheMetadata *RepositoryMock) GetCacheMetadataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCacheMetadata.afterGetCacheMetadataCounter)
}

// GetCacheMetadataBeforeCounter returns a count of RepositoryMock.GetCacheMetadata invocations
func (mmGetCacheMetadata *RepositoryMock) GetCacheMetadataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCacheMetadata.beforeGetCacheMetadataCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetCacheMetadata.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCacheMetadata *mRepositoryMockGetCacheMetadata) Calls() []*RepositoryMockGetCacheMetadataParams {
	mmGetCacheMetadata.mutex.RLock()

	argCopy := make([]*RepositoryMockGetCacheMetadataParams, len(mmGetCacheMetadata.callArgs))
	copy(argCopy, mmGetCacheMetadata.callArgs)

	mmGetCacheMetadata.mutex.RUnlock()

	return argCopy
}

// MinimockGetCacheMetadataDone returns true if the count of the GetCacheMetadata invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetCacheMetadataDone() bool {
	if m.GetCacheMetadataMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCacheMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCacheMetadataMock.invocationsDone()
}

// MinimockGetCacheMetadataInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetCacheMetadataInspect() {
	for _, e := range m.GetCacheMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetCacheMetadata at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCacheMetadataCounter := mm_atomic.LoadUint64(&m.afterGetCacheMetadataCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCacheMetadataMock.defaultExpectation != nil && afterGetCacheMetadataCounter < 1 {
		if m.GetCacheMetadataMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetCacheMetadata at\n%s", m.GetCacheMetadataMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetCacheMetadata at\n%s with params: %#v", m.GetCacheMetadataMock.defaultExpectation.expectationOrigins.origin, *m.GetCacheMetadataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCacheMetadata != nil && afterGetCacheMetadataCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetCacheMetadata at\n%s", m.funcGetCacheMetadataOrigin)
	}

	if !m.GetCacheMetadataMock.invocationsDone() && afterGetCacheMetadataCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetCacheMetadata at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCacheMetadataMock.expectedInvocations), m.GetCacheMetadataMock.expectedInvocationsOrigin, afterGetCacheMetadataCounter)
	}
}

type mRepositoryMockGetChunkCountByKBUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetChunkCountByKBUIDExpectation
	expectations       []*RepositoryMockGetChunkCountByKBUIDExpectation

	callArgs []*RepositoryMockGetChunkCountByKBUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetChunkCountByKBUIDExpectation specifies expectation struct of the Repository.GetChunkCountByKBUID
type RepositoryMockGetChunkCountByKBUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetChunkCountByKBUIDParams
	paramPtrs          *RepositoryMockGetChunkCountByKBUIDParamPtrs
	expectationOrigins RepositoryMockGetChunkCountByKBUIDExpectationOrigins
	results            *RepositoryMockGetChunkCountByKBUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetChunkCountByKBUIDParams contains parameters of the Repository.GetChunkCountByKBUID
type RepositoryMockGetChunkCountByKBUIDParams struct {
	ctx   context.Context
	kbUID types.KBUIDType
}

// RepositoryMockGetChunkCountByKBUIDParamPtrs contains pointers to parameters of the Repository.GetChunkCountByKBUID
type RepositoryMockGetChunkCountByKBUIDParamPtrs struct {
	ctx   *context.Context
	kbUID *types.KBUIDType
}

// RepositoryMockGetChunkCountByKBUIDResults contains results of the Repository.GetChunkCountByKBUID
type RepositoryMockGetChunkCountByKBUIDResults struct {
	i1  int64
	err error
}

// RepositoryMockGetChunkCountByKBUIDOrigins contains origins of expectations of the Repository.GetChunkCountByKBUID
type RepositoryMockGetChunkCountByKBUIDExpectationOrigins struct {
	origin      string
	originCtx   string
	originKbUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetChunkCountByKBUID *mRepositoryMockGetChunkCountByKBUID) Optional() *mRepositoryMockGetChunkCountByKBUID {
	mmGetChunkCountByKBUID.optional = true
	return mmGetChunkCountByKBUID
}

// Expect sets up expected params for Repository.GetChunkCountByKBUID
func (mmGetChunkCountByKBUID *mRepositoryMockGetChunkCountByKBUID) Expect(ctx context.Context, kbUID types.KBUIDType) *mRepositoryMockGetChunkCountByKBUID {
	if mmGetChunkCountByKBUID.mock.funcGetChunkCountByKBUID != nil {
		mmGetChunkCountByKBUID.mock.t.Fatalf("RepositoryMock.GetChunkCountByKBUID mock is already set by Set")
	}

	if mmGetChunkCountByKBUID.defaultExpectation == nil {
		mmGetChunkCountByKBUID.defaultExpectation = &RepositoryMockGetChunkCountByKBUIDExpectation{}
	}

	if mmGetChunkCountByKBUID.defaultExpectation.paramPtrs != nil {
		mmGetChunkCountByKBUID.mock.t.Fatalf("RepositoryMock.GetChunkCountByKBUID mock is already set by ExpectParams functions")
	}

	mmGetChunkCountByKBUID.defaultExpectation.params = &RepositoryMockGetChunkCountByKBUIDParams{ctx, kbUID}
	mmGetChunkCountByKBUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetChunkCountByKBUID.expectations {
		if minimock.Equal(e.params, mmGetChunkCountByKBUID.defaultExpectation.params) {
			mmGetChunkCountByKBUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChunkCountByKBUID.defaultExpectation.params)
		}
	}

	return mmGetChunkCountByKBUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetChunkCountByKBUID
func (mmGetChunkCountByKBUID *mRepositoryMockGetChunkCountByKBUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetChunkCountByKBUID {
	if mmGetChunkCountByKBUID.mock.funcGetChunkCountByKBUID != nil {
		mmGetChunkCountByKBUID.mock.t.Fatalf("RepositoryMock.GetChunkCountByKBUID mock is already set by Set")
	}

	if mmGetChunkCountByKBUID.defaultExpectation == nil {
		mmGetChunkCountByKBUID.defaultExpectation = &RepositoryMockGetChunkCountByKBUIDExpectation{}
	}

	if mmGetChunkCountByKBUID.defaultExpectation.params != nil {
		mmGetChunkCountByKBUID.mock.t.Fatalf("RepositoryMock.GetChunkCountByKBUID mock is already set by Expect")
	}

	if mmGetChunkCountByKBUID.defaultExpectation.paramPtrs == nil {
		mmGetChunkCountByKBUID.defaultExpectation.paramPtrs = &RepositoryMockGetChunkCountByKBUIDParamPtrs{}
	}
	mmGetChunkCountByKBUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetChunkCountByKBUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetChunkCountByKBUID
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.GetChunkCountByKBUID
func (mmGetChunkCountByKBUID *mRepositoryMockGetChunkCountByKBUID) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockGetChunkCountByKBUID {
	if mmGetChunkCountByKBUID.mock.funcGetChunkCountByKBUID != nil {
		mmGetChunkCountByKBUID.mock.t.Fatalf("RepositoryMock.GetChunkCountByKBUID mock is already set by Set")
	}

	if mmGetChunkCountByKBUID.defaultExpectation == nil {
		mmGetChunkCountByKBUID.defaultExpectation = &RepositoryMockGetChunkCountByKBUIDExpectation{}
	}

	if mmGetChunkCountByKBUID.defaultExpectation.params != nil {
		mmGetChunkCountByKBUID.mock.t.Fatalf("RepositoryMock.GetChunkCountByKBUID mock is already set by Expect")
	}

	if mmGetChunkCountByKBUID.defaultExpectation.paramPtrs == nil {
		mmGetChunkCountByKBUID.defaultExpectation.paramPtrs = &RepositoryMockGetChunkCountByKBUIDParamPtrs{}
	}
	mmGetChunkCountByKBUID.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmGetChunkCountByKBUID.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmGetChunkCountByKBUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetChunkCountByKBUID
func (mmGetChunkCountByKBUID *mRepositoryMockGetChunkCountByKBUID) Inspect(f func(ctx context.Context, kbUID types.KBUIDType)) *mRepositoryMockGetChunkCountByKBUID {
	if mmGetChunkCountByKBUID.mock.inspectFuncGetChunkCountByKBUID != nil {
		mmGetChunkCountByKBUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetChunkCountByKBUID")
	}

	mmGetChunkCountByKBUID.mock.inspectFuncGetChunkCountByKBUID = f

	return mmGetChunkCountByKBUID
}

// Return sets up results that will be returned by Repository.GetChunkCountByKBUID
func (mmGetChunkCountByKBUID *mRepositoryMockGetChunkCountByKBUID) Return(i1 int64, err error) *RepositoryMock {
	if mmGetChunkCountByKBUID.mock.funcGetChunkCountByKBUID != nil {
		mmGetChunkCountByKBUID.mock.t.Fatalf("RepositoryMock.GetChunkCountByKBUID mock is already set by Set")
	}

	if mmGetChunkCountByKBUID.defaultExpectation == nil {
		mmGetChunkCountByKBUID.defaultExpectation = &RepositoryMockGetChunkCountByKBUIDExpectation{mock: mmGetChunkCountByKBUID.mock}
	}
	mmGetChunkCountByKBUID.defaultExpectation.results = &RepositoryMockGetChunkCountByKBUIDResults{i1, err}
	mmGetChunkCountByKBUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetChunkCountByKBUID.mock
}

// Set uses given function f to mock the Repository.GetChunkCountByKBUID method
func (mmGetChunkCountByKBUID *mRepositoryMockGetChunkCountByKBUID) Set(f func(ctx context.Context, kbUID types.KBUIDType) (i1 int64, err error)) *RepositoryMock {
	if mmGetChunkCountByKBUID.defaultExpectation != nil {
		mmGetChunkCountByKBUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetChunkCountByKBUID method")
	}

	if len(mmGetChunkCountByKBUID.expectations) > 0 {
		mmGetChunkCountByKBUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetChunkCountByKBUID method")
	}

	mmGetChunkCountByKBUID.mock.funcGetChunkCountByKBUID = f
	mmGetChunkCountByKBUID.mock.funcGetChunkCountByKBUIDOrigin = minimock.CallerInfo(1)
	return mmGetChunkCountByKBUID.mock
}

// When sets expectation for the Repository.GetChunkCountByKBUID which will trigger the result defined by the following
// Then helper
func (mmGetChunkCountByKBUID *mRepositoryMockGetChunkCountByKBUID) When(ctx context.Context, kbUID types.KBUIDType) *RepositoryMockGetChunkCountByKBUIDExpectation {
	if mmGetChunkCountByKBUID.mock.funcGetChunkCountByKBUID != nil {
		mmGetChunkCountByKBUID.mock.t.Fatalf("RepositoryMock.GetChunkCountByKBUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetChunkCountByKBUIDExpectation{
		mock:               mmGetChunkCountByKBUID.mock,
		params:             &RepositoryMockGetChunkCountByKBUIDParams{ctx, kbUID},
		expectationOrigins: RepositoryMockGetChunkCountByKBUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetChunkCountByKBUID.expectations = append(mmGetChunkCountByKBUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetChunkCountByKBUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetChunkCountByKBUIDExpectation) Then(i1 int64, err error) *RepositoryMock {
	e.results = &RepositoryMockGetChunkCountByKBUIDResults{i1, err}
	return e.mock
}

// Times sets number of times Repository.GetChunkCountByKBUID should be invoked
func (mmGetChunkCountByKBUID *mRepositoryMockGetChunkCountByKBUID) Times(n uint64) *mRepositoryMockGetChunkCountByKBUID {
	if n == 0 {
		mmGetChunkCountByKBUID.mock.t.Fatalf("Times of RepositoryMock.GetChunkCountByKBUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetChunkCountByKBUID.expectedInvocations, n)
	mmGetChunkCountByKBUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetChunkCountByKBUID
}

func (mmGetChunkCountByKBUID *mRepositoryMockGetChunkCountByKBUID) invocationsDone() bool {
	if len(mmGetChunkCountByKBUID.expectations) == 0 && mmGetChunkCountByKBUID.defaultExpectation == nil && mmGetChunkCountByKBUID.mock.funcGetChunkCountByKBUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetChunkCountByKBUID.mock.afterGetChunkCountByKBUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetChunkCountByKBUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetChunkCountByKBUID implements mm_repository.Repository
func (mmGetChunkCountByKBUID *RepositoryMock) GetChunkCountByKBUID(ctx context.Context, kbUID types.KBUIDType) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetChunkCountByKBUID.beforeGetChunkCountByKBUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChunkCountByKBUID.afterGetChunkCountByKBUIDCounter, 1)

	mmGetChunkCountByKBUID.t.Helper()

	if mmGetChunkCountByKBUID.inspectFuncGetChunkCountByKBUID != nil {
		mmGetChunkCountByKBUID.inspectFuncGetChunkCountByKBUID(ctx, kbUID)
	}

	mm_params := RepositoryMockGetChunkCountByKBUIDParams{ctx, kbUID}

	// Record call args
	mmGetChunkCountByKBUID.GetChunkCountByKBUIDMock.mutex.Lock()
	mmGetChunkCountByKBUID.GetChunkCountByKBUIDMock.callArgs = append(mmGetChunkCountByKBUID.GetChunkCountByKBUIDMock.callArgs, &mm_params)
	mmGetChunkCountByKBUID.GetChunkCountByKBUIDMock.mutex.Unlock()

	for _, e := range mmGetChunkCountByKBUID.GetChunkCountByKBUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetChunkCountByKBUID.GetChunkCountByKBUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChunkCountByKBUID.GetChunkCountByKBUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChunkCountByKBUID.GetChunkCountByKBUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetChunkCountByKBUID.GetChunkCountByKBUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetChunkCountByKBUIDParams{ctx, kbUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetChunkCountByKBUID.t.Errorf("RepositoryMock.GetChunkCountByKBUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChunkCountByKBUID.GetChunkCountByKBUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmGetChunkCountByKBUID.t.Errorf("RepositoryMock.GetChunkCountByKBUID got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChunkCountByKBUID.GetChunkCountByKBUIDMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChunkCountByKBUID.t.Errorf("RepositoryMock.GetChunkCountByKBUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetChunkCountByKBUID.GetChunkCountByKBUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChunkCountByKBUID.GetChunkCountByKBUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChunkCountByKBUID.t.Fatal("No results are set for the RepositoryMock.GetChunkCountByKBUID")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetChunkCountByKBUID.funcGetChunkCountByKBUID != nil {
		return mmGetChunkCountByKBUID.funcGetChunkCountByKBUID(ctx, kbUID)
	}
	mmGetChunkCountByKBUID.t.Fatalf("Unexpected call to RepositoryMock.GetChunkCountByKBUID. %v %v", ctx, kbUID)
	return
}

// GetChunkCountByKBUIDAfterCounter returns a count of finished RepositoryMock.GetChunkCountByKBUID invocations
func (mmGetChunkCountByKBUID *RepositoryMock) GetChunkCountByKBUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChunkCountByKBUID.afterGetChunkCountByKBUIDCounter)
}

// GetChunkCountByKBUIDBeforeCounter returns a count of RepositoryMock.GetChunkCountByKBUID invocations
func (mmGetChunkCountByKBUID *RepositoryMock) GetChunkCountByKBUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChunkCountByKBUID.beforeGetChunkCountByKBUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetChunkCountByKBUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChunkCountByKBUID *mRepositoryMockGetChunkCountByKBUID) Calls() []*RepositoryMockGetChunkCountByKBUIDParams {
	mmGetChunkCountByKBUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetChunkCountByKBUIDParams, len(mmGetChunkCountByKBUID.callArgs))
	copy(argCopy, mmGetChunkCountByKBUID.callArgs)

	mmGetChunkCountByKBUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetChunkCountByKBUIDDone returns true if the count of the GetChunkCountByKBUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetChunkCountByKBUIDDone() bool {
	if m.GetChunkCountByKBUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetChunkCountByKBUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetChunkCountByKBUIDMock.invocationsDone()
}

// MinimockGetChunkCountByKBUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetChunkCountByKBUIDInspect() {
	for _, e := range m.GetChunkCountByKBUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetChunkCountByKBUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetChunkCountByKBUIDCounter := mm_atomic.LoadUint64(&m.afterGetChunkCountByKBUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetChunkCountByKBUIDMock.defaultExpectation != nil && afterGetChunkCountByKBUIDCounter < 1 {
		if m.GetChunkCountByKBUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetChunkCountByKBUID at\n%s", m.GetChunkCountByKBUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetChunkCountByKBUID at\n%s with params: %#v", m.GetChunkCountByKBUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetChunkCountByKBUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChunkCountByKBUID != nil && afterGetChunkCountByKBUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetChunkCountByKBUID at\n%s", m.funcGetChunkCountByKBUIDOrigin)
	}

	if !m.GetChunkCountByKBUIDMock.invocationsDone() && afterGetChunkCountByKBUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetChunkCountByKBUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetChunkCountByKBUIDMock.expectedInvocations), m.GetChunkCountByKBUIDMock.expectedInvocationsOrigin, afterGetChunkCountByKBUIDCounter)
	}
}

type mRepositoryMockGetConfigByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetConfigByIDExpectation
	expectations       []*RepositoryMockGetConfigByIDExpectation

	callArgs []*RepositoryMockGetConfigByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetConfigByIDExpectation specifies expectation struct of the Repository.GetConfigByID
type RepositoryMockGetConfigByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetConfigByIDParams
	paramPtrs          *RepositoryMockGetConfigByIDParamPtrs
	expectationOrigins RepositoryMockGetConfigByIDExpectationOrigins
	results            *RepositoryMockGetConfigByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetConfigByIDParams contains parameters of the Repository.GetConfigByID
type RepositoryMockGetConfigByIDParams struct {
	ctx context.Context
	id  string
}

// RepositoryMockGetConfigByIDParamPtrs contains pointers to parameters of the Repository.GetConfigByID
type RepositoryMockGetConfigByIDParamPtrs struct {
	ctx *context.Context
	id  *string
}

// RepositoryMockGetConfigByIDResults contains results of the Repository.GetConfigByID
type RepositoryMockGetConfigByIDResults struct {
	sp1 *mm_repository.SystemConfigJSON
	err error
}

// RepositoryMockGetConfigByIDOrigins contains origins of expectations of the Repository.GetConfigByID
type RepositoryMockGetConfigByIDExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetConfigByID *mRepositoryMockGetConfigByID) Optional() *mRepositoryMockGetConfigByID {
	mmGetConfigByID.optional = true
	return mmGetConfigByID
}

// Expect sets up expected params for Repository.GetConfigByID
func (mmGetConfigByID *mRepositoryMockGetConfigByID) Expect(ctx context.Context, id string) *mRepositoryMockGetConfigByID {
	if mmGetConfigByID.mock.funcGetConfigByID != nil {
		mmGetConfigByID.mock.t.Fatalf("RepositoryMock.GetConfigByID mock is already set by Set")
	}

	if mmGetConfigByID.defaultExpectation == nil {
		mmGetConfigByID.defaultExpectation = &RepositoryMockGetConfigByIDExpectation{}
	}

	if mmGetConfigByID.defaultExpectation.paramPtrs != nil {
		mmGetConfigByID.mock.t.Fatalf("RepositoryMock.GetConfigByID mock is already set by ExpectParams functions")
	}

	mmGetConfigByID.defaultExpectation.params = &RepositoryMockGetConfigByIDParams{ctx, id}
	mmGetConfigByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetConfigByID.expectations {
		if minimock.Equal(e.params, mmGetConfigByID.defaultExpectation.params) {
			mmGetConfigByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetConfigByID.defaultExpectation.params)
		}
	}

	return mmGetConfigByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetConfigByID
func (mmGetConfigByID *mRepositoryMockGetConfigByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetConfigByID {
	if mmGetConfigByID.mock.funcGetConfigByID != nil {
		mmGetConfigByID.mock.t.Fatalf("RepositoryMock.GetConfigByID mock is already set by Set")
	}

	if mmGetConfigByID.defaultExpectation == nil {
		mmGetConfigByID.defaultExpectation = &RepositoryMockGetConfigByIDExpectation{}
	}

	if mmGetConfigByID.defaultExpectation.params != nil {
		mmGetConfigByID.mock.t.Fatalf("RepositoryMock.GetConfigByID mock is already set by Expect")
	}

	if mmGetConfigByID.defaultExpectation.paramPtrs == nil {
		mmGetConfigByID.defaultExpectation.paramPtrs = &RepositoryMockGetConfigByIDParamPtrs{}
	}
	mmGetConfigByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetConfigByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetConfigByID
}

// ExpectIdParam2 sets up expected param id for Repository.GetConfigByID
func (mmGetConfigByID *mRepositoryMockGetConfigByID) ExpectIdParam2(id string) *mRepositoryMockGetConfigByID {
	if mmGetConfigByID.mock.funcGetConfigByID != nil {
		mmGetConfigByID.mock.t.Fatalf("RepositoryMock.GetConfigByID mock is already set by Set")
	}

	if mmGetConfigByID.defaultExpectation == nil {
		mmGetConfigByID.defaultExpectation = &RepositoryMockGetConfigByIDExpectation{}
	}

	if mmGetConfigByID.defaultExpectation.params != nil {
		mmGetConfigByID.mock.t.Fatalf("RepositoryMock.GetConfigByID mock is already set by Expect")
	}

	if mmGetConfigByID.defaultExpectation.paramPtrs == nil {
		mmGetConfigByID.defaultExpectation.paramPtrs = &RepositoryMockGetConfigByIDParamPtrs{}
	}
	mmGetConfigByID.defaultExpectation.paramPtrs.id = &id
	mmGetConfigByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetConfigByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetConfigByID
func (mmGetConfigByID *mRepositoryMockGetConfigByID) Inspect(f func(ctx context.Context, id string)) *mRepositoryMockGetConfigByID {
	if mmGetConfigByID.mock.inspectFuncGetConfigByID != nil {
		mmGetConfigByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetConfigByID")
	}

	mmGetConfigByID.mock.inspectFuncGetConfigByID = f

	return mmGetConfigByID
}

// Return sets up results that will be returned by Repository.GetConfigByID
func (mmGetConfigByID *mRepositoryMockGetConfigByID) Return(sp1 *mm_repository.SystemConfigJSON, err error) *RepositoryMock {
	if mmGetConfigByID.mock.funcGetConfigByID != nil {
		mmGetConfigByID.mock.t.Fatalf("RepositoryMock.GetConfigByID mock is already set by Set")
	}

	if mmGetConfigByID.defaultExpectation == nil {
		mmGetConfigByID.defaultExpectation = &RepositoryMockGetConfigByIDExpectation{mock: mmGetConfigByID.mock}
	}
	mmGetConfigByID.defaultExpectation.results = &RepositoryMockGetConfigByIDResults{sp1, err}
	mmGetConfigByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetConfigByID.mock
}

// Set uses given function f to mock the Repository.GetConfigByID method
func (mmGetConfigByID *mRepositoryMockGetConfigByID) Set(f func(ctx context.Context, id string) (sp1 *mm_repository.SystemConfigJSON, err error)) *RepositoryMock {
	if mmGetConfigByID.defaultExpectation != nil {
		mmGetConfigByID.mock.t.Fatalf("Default expectation is already set for the Repository.GetConfigByID method")
	}

	if len(mmGetConfigByID.expectations) > 0 {
		mmGetConfigByID.mock.t.Fatalf("Some expectations are already set for the Repository.GetConfigByID method")
	}

	mmGetConfigByID.mock.funcGetConfigByID = f
	mmGetConfigByID.mock.funcGetConfigByIDOrigin = minimock.CallerInfo(1)
	return mmGetConfigByID.mock
}

// When sets expectation for the Repository.GetConfigByID which will trigger the result defined by the following
// Then helper
func (mmGetConfigByID *mRepositoryMockGetConfigByID) When(ctx context.Context, id string) *RepositoryMockGetConfigByIDExpectation {
	if mmGetConfigByID.mock.funcGetConfigByID != nil {
		mmGetConfigByID.mock.t.Fatalf("RepositoryMock.GetConfigByID mock is already set by Set")
	}

	expectation := &RepositoryMockGetConfigByIDExpectation{
		mock:               mmGetConfigByID.mock,
		params:             &RepositoryMockGetConfigByIDParams{ctx, id},
		expectationOrigins: RepositoryMockGetConfigByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetConfigByID.expectations = append(mmGetConfigByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetConfigByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetConfigByIDExpectation) Then(sp1 *mm_repository.SystemConfigJSON, err error) *RepositoryMock {
	e.results = &RepositoryMockGetConfigByIDResults{sp1, err}
	return e.mock
}

// Times sets number of times Repository.GetConfigByID should be invoked
func (mmGetConfigByID *mRepositoryMockGetConfigByID) Times(n uint64) *mRepositoryMockGetConfigByID {
	if n == 0 {
		mmGetConfigByID.mock.t.Fatalf("Times of RepositoryMock.GetConfigByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetConfigByID.expectedInvocations, n)
	mmGetConfigByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetConfigByID
}

func (mmGetConfigByID *mRepositoryMockGetConfigByID) invocationsDone() bool {
	if len(mmGetConfigByID.expectations) == 0 && mmGetConfigByID.defaultExpectation == nil && mmGetConfigByID.mock.funcGetConfigByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetConfigByID.mock.afterGetConfigByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetConfigByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetConfigByID implements mm_repository.Repository
func (mmGetConfigByID *RepositoryMock) GetConfigByID(ctx context.Context, id string) (sp1 *mm_repository.SystemConfigJSON, err error) {
	mm_atomic.AddUint64(&mmGetConfigByID.beforeGetConfigByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetConfigByID.afterGetConfigByIDCounter, 1)

	mmGetConfigByID.t.Helper()

	if mmGetConfigByID.inspectFuncGetConfigByID != nil {
		mmGetConfigByID.inspectFuncGetConfigByID(ctx, id)
	}

	mm_params := RepositoryMockGetConfigByIDParams{ctx, id}

	// Record call args
	mmGetConfigByID.GetConfigByIDMock.mutex.Lock()
	mmGetConfigByID.GetConfigByIDMock.callArgs = append(mmGetConfigByID.GetConfigByIDMock.callArgs, &mm_params)
	mmGetConfigByID.GetConfigByIDMock.mutex.Unlock()

	for _, e := range mmGetConfigByID.GetConfigByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGetConfigByID.GetConfigByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetConfigByID.GetConfigByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetConfigByID.GetConfigByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetConfigByID.GetConfigByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetConfigByIDParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetConfigByID.t.Errorf("RepositoryMock.GetConfigByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetConfigByID.GetConfigByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetConfigByID.t.Errorf("RepositoryMock.GetConfigByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetConfigByID.GetConfigByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetConfigByID.t.Errorf("RepositoryMock.GetConfigByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetConfigByID.GetConfigByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetConfigByID.GetConfigByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetConfigByID.t.Fatal("No results are set for the RepositoryMock.GetConfigByID")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGetConfigByID.funcGetConfigByID != nil {
		return mmGetConfigByID.funcGetConfigByID(ctx, id)
	}
	mmGetConfigByID.t.Fatalf("Unexpected call to RepositoryMock.GetConfigByID. %v %v", ctx, id)
	return
}

// GetConfigByIDAfterCounter returns a count of finished RepositoryMock.GetConfigByID invocations
func (mmGetConfigByID *RepositoryMock) GetConfigByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConfigByID.afterGetConfigByIDCounter)
}

// GetConfigByIDBeforeCounter returns a count of RepositoryMock.GetConfigByID invocations
func (mmGetConfigByID *RepositoryMock) GetConfigByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConfigByID.beforeGetConfigByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetConfigByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetConfigByID *mRepositoryMockGetConfigByID) Calls() []*RepositoryMockGetConfigByIDParams {
	mmGetConfigByID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetConfigByIDParams, len(mmGetConfigByID.callArgs))
	copy(argCopy, mmGetConfigByID.callArgs)

	mmGetConfigByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetConfigByIDDone returns true if the count of the GetConfigByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetConfigByIDDone() bool {
	if m.GetConfigByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetConfigByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetConfigByIDMock.invocationsDone()
}

// MinimockGetConfigByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetConfigByIDInspect() {
	for _, e := range m.GetConfigByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetConfigByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetConfigByIDCounter := mm_atomic.LoadUint64(&m.afterGetConfigByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetConfigByIDMock.defaultExpectation != nil && afterGetConfigByIDCounter < 1 {
		if m.GetConfigByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetConfigByID at\n%s", m.GetConfigByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetConfigByID at\n%s with params: %#v", m.GetConfigByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetConfigByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetConfigByID != nil && afterGetConfigByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetConfigByID at\n%s", m.funcGetConfigByIDOrigin)
	}

	if !m.GetConfigByIDMock.invocationsDone() && afterGetConfigByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetConfigByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetConfigByIDMock.expectedInvocations), m.GetConfigByIDMock.expectedInvocationsOrigin, afterGetConfigByIDCounter)
	}
}

type mRepositoryMockGetContentByFileUIDs struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetContentByFileUIDsExpectation
	expectations       []*RepositoryMockGetContentByFileUIDsExpectation

	callArgs []*RepositoryMockGetContentByFileUIDsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetContentByFileUIDsExpectation specifies expectation struct of the Repository.GetContentByFileUIDs
type RepositoryMockGetContentByFileUIDsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetContentByFileUIDsParams
	paramPtrs          *RepositoryMockGetContentByFileUIDsParamPtrs
	expectationOrigins RepositoryMockGetContentByFileUIDsExpectationOrigins
	results            *RepositoryMockGetContentByFileUIDsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetContentByFileUIDsParams contains parameters of the Repository.GetContentByFileUIDs
type RepositoryMockGetContentByFileUIDsParams struct {
	ctx   context.Context
	files []mm_repository.KnowledgeBaseFileModel
}

// RepositoryMockGetContentByFileUIDsParamPtrs contains pointers to parameters of the Repository.GetContentByFileUIDs
type RepositoryMockGetContentByFileUIDsParamPtrs struct {
	ctx   *context.Context
	files *[]mm_repository.KnowledgeBaseFileModel
}

// RepositoryMockGetContentByFileUIDsResults contains results of the Repository.GetContentByFileUIDs
type RepositoryMockGetContentByFileUIDsResults struct {
	m1 map[types.FileUIDType]struct {
		SourceTable string
		SourceUID   types.SourceUIDType
	}
	err error
}

// RepositoryMockGetContentByFileUIDsOrigins contains origins of expectations of the Repository.GetContentByFileUIDs
type RepositoryMockGetContentByFileUIDsExpectationOrigins struct {
	origin      string
	originCtx   string
	originFiles string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetContentByFileUIDs *mRepositoryMockGetContentByFileUIDs) Optional() *mRepositoryMockGetContentByFileUIDs {
	mmGetContentByFileUIDs.optional = true
	return mmGetContentByFileUIDs
}

// Expect sets up expected params for Repository.GetContentByFileUIDs
func (mmGetContentByFileUIDs *mRepositoryMockGetContentByFileUIDs) Expect(ctx context.Context, files []mm_repository.KnowledgeBaseFileModel) *mRepositoryMockGetContentByFileUIDs {
	if mmGetContentByFileUIDs.mock.funcGetContentByFileUIDs != nil {
		mmGetContentByFileUIDs.mock.t.Fatalf("RepositoryMock.GetContentByFileUIDs mock is already set by Set")
	}

	if mmGetContentByFileUIDs.defaultExpectation == nil {
		mmGetContentByFileUIDs.defaultExpectation = &RepositoryMockGetContentByFileUIDsExpectation{}
	}

	if mmGetContentByFileUIDs.defaultExpectation.paramPtrs != nil {
		mmGetContentByFileUIDs.mock.t.Fatalf("RepositoryMock.GetContentByFileUIDs mock is already set by ExpectParams functions")
	}

	mmGetContentByFileUIDs.defaultExpectation.params = &RepositoryMockGetContentByFileUIDsParams{ctx, files}
	mmGetContentByFileUIDs.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetContentByFileUIDs.expectations {
		if minimock.Equal(e.params, mmGetContentByFileUIDs.defaultExpectation.params) {
			mmGetContentByFileUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetContentByFileUIDs.defaultExpectation.params)
		}
	}

	return mmGetContentByFileUIDs
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetContentByFileUIDs
func (mmGetContentByFileUIDs *mRepositoryMockGetContentByFileUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetContentByFileUIDs {
	if mmGetContentByFileUIDs.mock.funcGetContentByFileUIDs != nil {
		mmGetContentByFileUIDs.mock.t.Fatalf("RepositoryMock.GetContentByFileUIDs mock is already set by Set")
	}

	if mmGetContentByFileUIDs.defaultExpectation == nil {
		mmGetContentByFileUIDs.defaultExpectation = &RepositoryMockGetContentByFileUIDsExpectation{}
	}

	if mmGetContentByFileUIDs.defaultExpectation.params != nil {
		mmGetContentByFileUIDs.mock.t.Fatalf("RepositoryMock.GetContentByFileUIDs mock is already set by Expect")
	}

	if mmGetContentByFileUIDs.defaultExpectation.paramPtrs == nil {
		mmGetContentByFileUIDs.defaultExpectation.paramPtrs = &RepositoryMockGetContentByFileUIDsParamPtrs{}
	}
	mmGetContentByFileUIDs.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetContentByFileUIDs.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetContentByFileUIDs
}

// ExpectFilesParam2 sets up expected param files for Repository.GetContentByFileUIDs
func (mmGetContentByFileUIDs *mRepositoryMockGetContentByFileUIDs) ExpectFilesParam2(files []mm_repository.KnowledgeBaseFileModel) *mRepositoryMockGetContentByFileUIDs {
	if mmGetContentByFileUIDs.mock.funcGetContentByFileUIDs != nil {
		mmGetContentByFileUIDs.mock.t.Fatalf("RepositoryMock.GetContentByFileUIDs mock is already set by Set")
	}

	if mmGetContentByFileUIDs.defaultExpectation == nil {
		mmGetContentByFileUIDs.defaultExpectation = &RepositoryMockGetContentByFileUIDsExpectation{}
	}

	if mmGetContentByFileUIDs.defaultExpectation.params != nil {
		mmGetContentByFileUIDs.mock.t.Fatalf("RepositoryMock.GetContentByFileUIDs mock is already set by Expect")
	}

	if mmGetContentByFileUIDs.defaultExpectation.paramPtrs == nil {
		mmGetContentByFileUIDs.defaultExpectation.paramPtrs = &RepositoryMockGetContentByFileUIDsParamPtrs{}
	}
	mmGetContentByFileUIDs.defaultExpectation.paramPtrs.files = &files
	mmGetContentByFileUIDs.defaultExpectation.expectationOrigins.originFiles = minimock.CallerInfo(1)

	return mmGetContentByFileUIDs
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetContentByFileUIDs
func (mmGetContentByFileUIDs *mRepositoryMockGetContentByFileUIDs) Inspect(f func(ctx context.Context, files []mm_repository.KnowledgeBaseFileModel)) *mRepositoryMockGetContentByFileUIDs {
	if mmGetContentByFileUIDs.mock.inspectFuncGetContentByFileUIDs != nil {
		mmGetContentByFileUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetContentByFileUIDs")
	}

	mmGetContentByFileUIDs.mock.inspectFuncGetContentByFileUIDs = f

	return mmGetContentByFileUIDs
}

// Return sets up results that will be returned by Repository.GetContentByFileUIDs
func (mmGetContentByFileUIDs *mRepositoryMockGetContentByFileUIDs) Return(m1 map[types.FileUIDType]struct {
	SourceTable string
	SourceUID   types.SourceUIDType
}, err error) *RepositoryMock {
	if mmGetContentByFileUIDs.mock.funcGetContentByFileUIDs != nil {
		mmGetContentByFileUIDs.mock.t.Fatalf("RepositoryMock.GetContentByFileUIDs mock is already set by Set")
	}

	if mmGetContentByFileUIDs.defaultExpectation == nil {
		mmGetContentByFileUIDs.defaultExpectation = &RepositoryMockGetContentByFileUIDsExpectation{mock: mmGetContentByFileUIDs.mock}
	}
	mmGetContentByFileUIDs.defaultExpectation.results = &RepositoryMockGetContentByFileUIDsResults{m1, err}
	mmGetContentByFileUIDs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetContentByFileUIDs.mock
}

// Set uses given function f to mock the Repository.GetContentByFileUIDs method
func (mmGetContentByFileUIDs *mRepositoryMockGetContentByFileUIDs) Set(f func(ctx context.Context, files []mm_repository.KnowledgeBaseFileModel) (m1 map[types.FileUIDType]struct {
	SourceTable string
	SourceUID   types.SourceUIDType
}, err error)) *RepositoryMock {
	if mmGetContentByFileUIDs.defaultExpectation != nil {
		mmGetContentByFileUIDs.mock.t.Fatalf("Default expectation is already set for the Repository.GetContentByFileUIDs method")
	}

	if len(mmGetContentByFileUIDs.expectations) > 0 {
		mmGetContentByFileUIDs.mock.t.Fatalf("Some expectations are already set for the Repository.GetContentByFileUIDs method")
	}

	mmGetContentByFileUIDs.mock.funcGetContentByFileUIDs = f
	mmGetContentByFileUIDs.mock.funcGetContentByFileUIDsOrigin = minimock.CallerInfo(1)
	return mmGetContentByFileUIDs.mock
}

// When sets expectation for the Repository.GetContentByFileUIDs which will trigger the result defined by the following
// Then helper
func (mmGetContentByFileUIDs *mRepositoryMockGetContentByFileUIDs) When(ctx context.Context, files []mm_repository.KnowledgeBaseFileModel) *RepositoryMockGetContentByFileUIDsExpectation {
	if mmGetContentByFileUIDs.mock.funcGetContentByFileUIDs != nil {
		mmGetContentByFileUIDs.mock.t.Fatalf("RepositoryMock.GetContentByFileUIDs mock is already set by Set")
	}

	expectation := &RepositoryMockGetContentByFileUIDsExpectation{
		mock:               mmGetContentByFileUIDs.mock,
		params:             &RepositoryMockGetContentByFileUIDsParams{ctx, files},
		expectationOrigins: RepositoryMockGetContentByFileUIDsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetContentByFileUIDs.expectations = append(mmGetContentByFileUIDs.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetContentByFileUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetContentByFileUIDsExpectation) Then(m1 map[types.FileUIDType]struct {
	SourceTable string
	SourceUID   types.SourceUIDType
}, err error) *RepositoryMock {
	e.results = &RepositoryMockGetContentByFileUIDsResults{m1, err}
	return e.mock
}

// Times sets number of times Repository.GetContentByFileUIDs should be invoked
func (mmGetContentByFileUIDs *mRepositoryMockGetContentByFileUIDs) Times(n uint64) *mRepositoryMockGetContentByFileUIDs {
	if n == 0 {
		mmGetContentByFileUIDs.mock.t.Fatalf("Times of RepositoryMock.GetContentByFileUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetContentByFileUIDs.expectedInvocations, n)
	mmGetContentByFileUIDs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetContentByFileUIDs
}

func (mmGetContentByFileUIDs *mRepositoryMockGetContentByFileUIDs) invocationsDone() bool {
	if len(mmGetContentByFileUIDs.expectations) == 0 && mmGetContentByFileUIDs.defaultExpectation == nil && mmGetContentByFileUIDs.mock.funcGetContentByFileUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetContentByFileUIDs.mock.afterGetContentByFileUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetContentByFileUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetContentByFileUIDs implements mm_repository.Repository
func (mmGetContentByFileUIDs *RepositoryMock) GetContentByFileUIDs(ctx context.Context, files []mm_repository.KnowledgeBaseFileModel) (m1 map[types.FileUIDType]struct {
	SourceTable string
	SourceUID   types.SourceUIDType
}, err error) {
	mm_atomic.AddUint64(&mmGetContentByFileUIDs.beforeGetContentByFileUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetContentByFileUIDs.afterGetContentByFileUIDsCounter, 1)

	mmGetContentByFileUIDs.t.Helper()

	if mmGetContentByFileUIDs.inspectFuncGetContentByFileUIDs != nil {
		mmGetContentByFileUIDs.inspectFuncGetContentByFileUIDs(ctx, files)
	}

	mm_params := RepositoryMockGetContentByFileUIDsParams{ctx, files}

	// Record call args
	mmGetContentByFileUIDs.GetContentByFileUIDsMock.mutex.Lock()
	mmGetContentByFileUIDs.GetContentByFileUIDsMock.callArgs = append(mmGetContentByFileUIDs.GetContentByFileUIDsMock.callArgs, &mm_params)
	mmGetContentByFileUIDs.GetContentByFileUIDsMock.mutex.Unlock()

	for _, e := range mmGetContentByFileUIDs.GetContentByFileUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetContentByFileUIDs.GetContentByFileUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetContentByFileUIDs.GetContentByFileUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetContentByFileUIDs.GetContentByFileUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmGetContentByFileUIDs.GetContentByFileUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetContentByFileUIDsParams{ctx, files}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetContentByFileUIDs.t.Errorf("RepositoryMock.GetContentByFileUIDs got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetContentByFileUIDs.GetContentByFileUIDsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.files != nil && !minimock.Equal(*mm_want_ptrs.files, mm_got.files) {
				mmGetContentByFileUIDs.t.Errorf("RepositoryMock.GetContentByFileUIDs got unexpected parameter files, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetContentByFileUIDs.GetContentByFileUIDsMock.defaultExpectation.expectationOrigins.originFiles, *mm_want_ptrs.files, mm_got.files, minimock.Diff(*mm_want_ptrs.files, mm_got.files))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetContentByFileUIDs.t.Errorf("RepositoryMock.GetContentByFileUIDs got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetContentByFileUIDs.GetContentByFileUIDsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetContentByFileUIDs.GetContentByFileUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetContentByFileUIDs.t.Fatal("No results are set for the RepositoryMock.GetContentByFileUIDs")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetContentByFileUIDs.funcGetContentByFileUIDs != nil {
		return mmGetContentByFileUIDs.funcGetContentByFileUIDs(ctx, files)
	}
	mmGetContentByFileUIDs.t.Fatalf("Unexpected call to RepositoryMock.GetContentByFileUIDs. %v %v", ctx, files)
	return
}

// GetContentByFileUIDsAfterCounter returns a count of finished RepositoryMock.GetContentByFileUIDs invocations
func (mmGetContentByFileUIDs *RepositoryMock) GetContentByFileUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetContentByFileUIDs.afterGetContentByFileUIDsCounter)
}

// GetContentByFileUIDsBeforeCounter returns a count of RepositoryMock.GetContentByFileUIDs invocations
func (mmGetContentByFileUIDs *RepositoryMock) GetContentByFileUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetContentByFileUIDs.beforeGetContentByFileUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetContentByFileUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetContentByFileUIDs *mRepositoryMockGetContentByFileUIDs) Calls() []*RepositoryMockGetContentByFileUIDsParams {
	mmGetContentByFileUIDs.mutex.RLock()

	argCopy := make([]*RepositoryMockGetContentByFileUIDsParams, len(mmGetContentByFileUIDs.callArgs))
	copy(argCopy, mmGetContentByFileUIDs.callArgs)

	mmGetContentByFileUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockGetContentByFileUIDsDone returns true if the count of the GetContentByFileUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetContentByFileUIDsDone() bool {
	if m.GetContentByFileUIDsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetContentByFileUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetContentByFileUIDsMock.invocationsDone()
}

// MinimockGetContentByFileUIDsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetContentByFileUIDsInspect() {
	for _, e := range m.GetContentByFileUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetContentByFileUIDs at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetContentByFileUIDsCounter := mm_atomic.LoadUint64(&m.afterGetContentByFileUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetContentByFileUIDsMock.defaultExpectation != nil && afterGetContentByFileUIDsCounter < 1 {
		if m.GetContentByFileUIDsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetContentByFileUIDs at\n%s", m.GetContentByFileUIDsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetContentByFileUIDs at\n%s with params: %#v", m.GetContentByFileUIDsMock.defaultExpectation.expectationOrigins.origin, *m.GetContentByFileUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetContentByFileUIDs != nil && afterGetContentByFileUIDsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetContentByFileUIDs at\n%s", m.funcGetContentByFileUIDsOrigin)
	}

	if !m.GetContentByFileUIDsMock.invocationsDone() && afterGetContentByFileUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetContentByFileUIDs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetContentByFileUIDsMock.expectedInvocations), m.GetContentByFileUIDsMock.expectedInvocationsOrigin, afterGetContentByFileUIDsCounter)
	}
}

type mRepositoryMockGetConvertedFileByFileUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetConvertedFileByFileUIDExpectation
	expectations       []*RepositoryMockGetConvertedFileByFileUIDExpectation

	callArgs []*RepositoryMockGetConvertedFileByFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetConvertedFileByFileUIDExpectation specifies expectation struct of the Repository.GetConvertedFileByFileUID
type RepositoryMockGetConvertedFileByFileUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetConvertedFileByFileUIDParams
	paramPtrs          *RepositoryMockGetConvertedFileByFileUIDParamPtrs
	expectationOrigins RepositoryMockGetConvertedFileByFileUIDExpectationOrigins
	results            *RepositoryMockGetConvertedFileByFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetConvertedFileByFileUIDParams contains parameters of the Repository.GetConvertedFileByFileUID
type RepositoryMockGetConvertedFileByFileUIDParams struct {
	ctx     context.Context
	fileUID types.FileUIDType
}

// RepositoryMockGetConvertedFileByFileUIDParamPtrs contains pointers to parameters of the Repository.GetConvertedFileByFileUID
type RepositoryMockGetConvertedFileByFileUIDParamPtrs struct {
	ctx     *context.Context
	fileUID *types.FileUIDType
}

// RepositoryMockGetConvertedFileByFileUIDResults contains results of the Repository.GetConvertedFileByFileUID
type RepositoryMockGetConvertedFileByFileUIDResults struct {
	cp1 *mm_repository.ConvertedFileModel
	err error
}

// RepositoryMockGetConvertedFileByFileUIDOrigins contains origins of expectations of the Repository.GetConvertedFileByFileUID
type RepositoryMockGetConvertedFileByFileUIDExpectationOrigins struct {
	origin        string
	originCtx     string
	originFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetConvertedFileByFileUID *mRepositoryMockGetConvertedFileByFileUID) Optional() *mRepositoryMockGetConvertedFileByFileUID {
	mmGetConvertedFileByFileUID.optional = true
	return mmGetConvertedFileByFileUID
}

// Expect sets up expected params for Repository.GetConvertedFileByFileUID
func (mmGetConvertedFileByFileUID *mRepositoryMockGetConvertedFileByFileUID) Expect(ctx context.Context, fileUID types.FileUIDType) *mRepositoryMockGetConvertedFileByFileUID {
	if mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUID mock is already set by Set")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation == nil {
		mmGetConvertedFileByFileUID.defaultExpectation = &RepositoryMockGetConvertedFileByFileUIDExpectation{}
	}

	if mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUID mock is already set by ExpectParams functions")
	}

	mmGetConvertedFileByFileUID.defaultExpectation.params = &RepositoryMockGetConvertedFileByFileUIDParams{ctx, fileUID}
	mmGetConvertedFileByFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetConvertedFileByFileUID.expectations {
		if minimock.Equal(e.params, mmGetConvertedFileByFileUID.defaultExpectation.params) {
			mmGetConvertedFileByFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetConvertedFileByFileUID.defaultExpectation.params)
		}
	}

	return mmGetConvertedFileByFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetConvertedFileByFileUID
func (mmGetConvertedFileByFileUID *mRepositoryMockGetConvertedFileByFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetConvertedFileByFileUID {
	if mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUID mock is already set by Set")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation == nil {
		mmGetConvertedFileByFileUID.defaultExpectation = &RepositoryMockGetConvertedFileByFileUIDExpectation{}
	}

	if mmGetConvertedFileByFileUID.defaultExpectation.params != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUID mock is already set by Expect")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs = &RepositoryMockGetConvertedFileByFileUIDParamPtrs{}
	}
	mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetConvertedFileByFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetConvertedFileByFileUID
}

// ExpectFileUIDParam2 sets up expected param fileUID for Repository.GetConvertedFileByFileUID
func (mmGetConvertedFileByFileUID *mRepositoryMockGetConvertedFileByFileUID) ExpectFileUIDParam2(fileUID types.FileUIDType) *mRepositoryMockGetConvertedFileByFileUID {
	if mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUID mock is already set by Set")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation == nil {
		mmGetConvertedFileByFileUID.defaultExpectation = &RepositoryMockGetConvertedFileByFileUIDExpectation{}
	}

	if mmGetConvertedFileByFileUID.defaultExpectation.params != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUID mock is already set by Expect")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs = &RepositoryMockGetConvertedFileByFileUIDParamPtrs{}
	}
	mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmGetConvertedFileByFileUID.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmGetConvertedFileByFileUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetConvertedFileByFileUID
func (mmGetConvertedFileByFileUID *mRepositoryMockGetConvertedFileByFileUID) Inspect(f func(ctx context.Context, fileUID types.FileUIDType)) *mRepositoryMockGetConvertedFileByFileUID {
	if mmGetConvertedFileByFileUID.mock.inspectFuncGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetConvertedFileByFileUID")
	}

	mmGetConvertedFileByFileUID.mock.inspectFuncGetConvertedFileByFileUID = f

	return mmGetConvertedFileByFileUID
}

// Return sets up results that will be returned by Repository.GetConvertedFileByFileUID
func (mmGetConvertedFileByFileUID *mRepositoryMockGetConvertedFileByFileUID) Return(cp1 *mm_repository.ConvertedFileModel, err error) *RepositoryMock {
	if mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUID mock is already set by Set")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation == nil {
		mmGetConvertedFileByFileUID.defaultExpectation = &RepositoryMockGetConvertedFileByFileUIDExpectation{mock: mmGetConvertedFileByFileUID.mock}
	}
	mmGetConvertedFileByFileUID.defaultExpectation.results = &RepositoryMockGetConvertedFileByFileUIDResults{cp1, err}
	mmGetConvertedFileByFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetConvertedFileByFileUID.mock
}

// Set uses given function f to mock the Repository.GetConvertedFileByFileUID method
func (mmGetConvertedFileByFileUID *mRepositoryMockGetConvertedFileByFileUID) Set(f func(ctx context.Context, fileUID types.FileUIDType) (cp1 *mm_repository.ConvertedFileModel, err error)) *RepositoryMock {
	if mmGetConvertedFileByFileUID.defaultExpectation != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetConvertedFileByFileUID method")
	}

	if len(mmGetConvertedFileByFileUID.expectations) > 0 {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetConvertedFileByFileUID method")
	}

	mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID = f
	mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUIDOrigin = minimock.CallerInfo(1)
	return mmGetConvertedFileByFileUID.mock
}

// When sets expectation for the Repository.GetConvertedFileByFileUID which will trigger the result defined by the following
// Then helper
func (mmGetConvertedFileByFileUID *mRepositoryMockGetConvertedFileByFileUID) When(ctx context.Context, fileUID types.FileUIDType) *RepositoryMockGetConvertedFileByFileUIDExpectation {
	if mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetConvertedFileByFileUIDExpectation{
		mock:               mmGetConvertedFileByFileUID.mock,
		params:             &RepositoryMockGetConvertedFileByFileUIDParams{ctx, fileUID},
		expectationOrigins: RepositoryMockGetConvertedFileByFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetConvertedFileByFileUID.expectations = append(mmGetConvertedFileByFileUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetConvertedFileByFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetConvertedFileByFileUIDExpectation) Then(cp1 *mm_repository.ConvertedFileModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetConvertedFileByFileUIDResults{cp1, err}
	return e.mock
}

// Times sets number of times Repository.GetConvertedFileByFileUID should be invoked
func (mmGetConvertedFileByFileUID *mRepositoryMockGetConvertedFileByFileUID) Times(n uint64) *mRepositoryMockGetConvertedFileByFileUID {
	if n == 0 {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("Times of RepositoryMock.GetConvertedFileByFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetConvertedFileByFileUID.expectedInvocations, n)
	mmGetConvertedFileByFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetConvertedFileByFileUID
}

func (mmGetConvertedFileByFileUID *mRepositoryMockGetConvertedFileByFileUID) invocationsDone() bool {
	if len(mmGetConvertedFileByFileUID.expectations) == 0 && mmGetConvertedFileByFileUID.defaultExpectation == nil && mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetConvertedFileByFileUID.mock.afterGetConvertedFileByFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetConvertedFileByFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetConvertedFileByFileUID implements mm_repository.Repository
func (mmGetConvertedFileByFileUID *RepositoryMock) GetConvertedFileByFileUID(ctx context.Context, fileUID types.FileUIDType) (cp1 *mm_repository.ConvertedFileModel, err error) {
	mm_atomic.AddUint64(&mmGetConvertedFileByFileUID.beforeGetConvertedFileByFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetConvertedFileByFileUID.afterGetConvertedFileByFileUIDCounter, 1)

	mmGetConvertedFileByFileUID.t.Helper()

	if mmGetConvertedFileByFileUID.inspectFuncGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.inspectFuncGetConvertedFileByFileUID(ctx, fileUID)
	}

	mm_params := RepositoryMockGetConvertedFileByFileUIDParams{ctx, fileUID}

	// Record call args
	mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.mutex.Lock()
	mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.callArgs = append(mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.callArgs, &mm_params)
	mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.mutex.Unlock()

	for _, e := range mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetConvertedFileByFileUIDParams{ctx, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetConvertedFileByFileUID.t.Errorf("RepositoryMock.GetConvertedFileByFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmGetConvertedFileByFileUID.t.Errorf("RepositoryMock.GetConvertedFileByFileUID got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetConvertedFileByFileUID.t.Errorf("RepositoryMock.GetConvertedFileByFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetConvertedFileByFileUID.t.Fatal("No results are set for the RepositoryMock.GetConvertedFileByFileUID")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetConvertedFileByFileUID.funcGetConvertedFileByFileUID != nil {
		return mmGetConvertedFileByFileUID.funcGetConvertedFileByFileUID(ctx, fileUID)
	}
	mmGetConvertedFileByFileUID.t.Fatalf("Unexpected call to RepositoryMock.GetConvertedFileByFileUID. %v %v", ctx, fileUID)
	return
}

// GetConvertedFileByFileUIDAfterCounter returns a count of finished RepositoryMock.GetConvertedFileByFileUID invocations
func (mmGetConvertedFileByFileUID *RepositoryMock) GetConvertedFileByFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConvertedFileByFileUID.afterGetConvertedFileByFileUIDCounter)
}

// GetConvertedFileByFileUIDBeforeCounter returns a count of RepositoryMock.GetConvertedFileByFileUID invocations
func (mmGetConvertedFileByFileUID *RepositoryMock) GetConvertedFileByFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConvertedFileByFileUID.beforeGetConvertedFileByFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetConvertedFileByFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetConvertedFileByFileUID *mRepositoryMockGetConvertedFileByFileUID) Calls() []*RepositoryMockGetConvertedFileByFileUIDParams {
	mmGetConvertedFileByFileUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetConvertedFileByFileUIDParams, len(mmGetConvertedFileByFileUID.callArgs))
	copy(argCopy, mmGetConvertedFileByFileUID.callArgs)

	mmGetConvertedFileByFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetConvertedFileByFileUIDDone returns true if the count of the GetConvertedFileByFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetConvertedFileByFileUIDDone() bool {
	if m.GetConvertedFileByFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetConvertedFileByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetConvertedFileByFileUIDMock.invocationsDone()
}

// MinimockGetConvertedFileByFileUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetConvertedFileByFileUIDInspect() {
	for _, e := range m.GetConvertedFileByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetConvertedFileByFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetConvertedFileByFileUIDCounter := mm_atomic.LoadUint64(&m.afterGetConvertedFileByFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetConvertedFileByFileUIDMock.defaultExpectation != nil && afterGetConvertedFileByFileUIDCounter < 1 {
		if m.GetConvertedFileByFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetConvertedFileByFileUID at\n%s", m.GetConvertedFileByFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetConvertedFileByFileUID at\n%s with params: %#v", m.GetConvertedFileByFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetConvertedFileByFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetConvertedFileByFileUID != nil && afterGetConvertedFileByFileUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetConvertedFileByFileUID at\n%s", m.funcGetConvertedFileByFileUIDOrigin)
	}

	if !m.GetConvertedFileByFileUIDMock.invocationsDone() && afterGetConvertedFileByFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetConvertedFileByFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetConvertedFileByFileUIDMock.expectedInvocations), m.GetConvertedFileByFileUIDMock.expectedInvocationsOrigin, afterGetConvertedFileByFileUIDCounter)
	}
}

type mRepositoryMockGetConvertedFileByFileUIDAndType struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetConvertedFileByFileUIDAndTypeExpectation
	expectations       []*RepositoryMockGetConvertedFileByFileUIDAndTypeExpectation

	callArgs []*RepositoryMockGetConvertedFileByFileUIDAndTypeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetConvertedFileByFileUIDAndTypeExpectation specifies expectation struct of the Repository.GetConvertedFileByFileUIDAndType
type RepositoryMockGetConvertedFileByFileUIDAndTypeExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetConvertedFileByFileUIDAndTypeParams
	paramPtrs          *RepositoryMockGetConvertedFileByFileUIDAndTypeParamPtrs
	expectationOrigins RepositoryMockGetConvertedFileByFileUIDAndTypeExpectationOrigins
	results            *RepositoryMockGetConvertedFileByFileUIDAndTypeResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetConvertedFileByFileUIDAndTypeParams contains parameters of the Repository.GetConvertedFileByFileUIDAndType
type RepositoryMockGetConvertedFileByFileUIDAndTypeParams struct {
	ctx           context.Context
	fileUID       types.FileUIDType
	convertedType artifactpb.ConvertedFileType
}

// RepositoryMockGetConvertedFileByFileUIDAndTypeParamPtrs contains pointers to parameters of the Repository.GetConvertedFileByFileUIDAndType
type RepositoryMockGetConvertedFileByFileUIDAndTypeParamPtrs struct {
	ctx           *context.Context
	fileUID       *types.FileUIDType
	convertedType *artifactpb.ConvertedFileType
}

// RepositoryMockGetConvertedFileByFileUIDAndTypeResults contains results of the Repository.GetConvertedFileByFileUIDAndType
type RepositoryMockGetConvertedFileByFileUIDAndTypeResults struct {
	cp1 *mm_repository.ConvertedFileModel
	err error
}

// RepositoryMockGetConvertedFileByFileUIDAndTypeOrigins contains origins of expectations of the Repository.GetConvertedFileByFileUIDAndType
type RepositoryMockGetConvertedFileByFileUIDAndTypeExpectationOrigins struct {
	origin              string
	originCtx           string
	originFileUID       string
	originConvertedType string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetConvertedFileByFileUIDAndType *mRepositoryMockGetConvertedFileByFileUIDAndType) Optional() *mRepositoryMockGetConvertedFileByFileUIDAndType {
	mmGetConvertedFileByFileUIDAndType.optional = true
	return mmGetConvertedFileByFileUIDAndType
}

// Expect sets up expected params for Repository.GetConvertedFileByFileUIDAndType
func (mmGetConvertedFileByFileUIDAndType *mRepositoryMockGetConvertedFileByFileUIDAndType) Expect(ctx context.Context, fileUID types.FileUIDType, convertedType artifactpb.ConvertedFileType) *mRepositoryMockGetConvertedFileByFileUIDAndType {
	if mmGetConvertedFileByFileUIDAndType.mock.funcGetConvertedFileByFileUIDAndType != nil {
		mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUIDAndType mock is already set by Set")
	}

	if mmGetConvertedFileByFileUIDAndType.defaultExpectation == nil {
		mmGetConvertedFileByFileUIDAndType.defaultExpectation = &RepositoryMockGetConvertedFileByFileUIDAndTypeExpectation{}
	}

	if mmGetConvertedFileByFileUIDAndType.defaultExpectation.paramPtrs != nil {
		mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUIDAndType mock is already set by ExpectParams functions")
	}

	mmGetConvertedFileByFileUIDAndType.defaultExpectation.params = &RepositoryMockGetConvertedFileByFileUIDAndTypeParams{ctx, fileUID, convertedType}
	mmGetConvertedFileByFileUIDAndType.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetConvertedFileByFileUIDAndType.expectations {
		if minimock.Equal(e.params, mmGetConvertedFileByFileUIDAndType.defaultExpectation.params) {
			mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetConvertedFileByFileUIDAndType.defaultExpectation.params)
		}
	}

	return mmGetConvertedFileByFileUIDAndType
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetConvertedFileByFileUIDAndType
func (mmGetConvertedFileByFileUIDAndType *mRepositoryMockGetConvertedFileByFileUIDAndType) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetConvertedFileByFileUIDAndType {
	if mmGetConvertedFileByFileUIDAndType.mock.funcGetConvertedFileByFileUIDAndType != nil {
		mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUIDAndType mock is already set by Set")
	}

	if mmGetConvertedFileByFileUIDAndType.defaultExpectation == nil {
		mmGetConvertedFileByFileUIDAndType.defaultExpectation = &RepositoryMockGetConvertedFileByFileUIDAndTypeExpectation{}
	}

	if mmGetConvertedFileByFileUIDAndType.defaultExpectation.params != nil {
		mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUIDAndType mock is already set by Expect")
	}

	if mmGetConvertedFileByFileUIDAndType.defaultExpectation.paramPtrs == nil {
		mmGetConvertedFileByFileUIDAndType.defaultExpectation.paramPtrs = &RepositoryMockGetConvertedFileByFileUIDAndTypeParamPtrs{}
	}
	mmGetConvertedFileByFileUIDAndType.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetConvertedFileByFileUIDAndType.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetConvertedFileByFileUIDAndType
}

// ExpectFileUIDParam2 sets up expected param fileUID for Repository.GetConvertedFileByFileUIDAndType
func (mmGetConvertedFileByFileUIDAndType *mRepositoryMockGetConvertedFileByFileUIDAndType) ExpectFileUIDParam2(fileUID types.FileUIDType) *mRepositoryMockGetConvertedFileByFileUIDAndType {
	if mmGetConvertedFileByFileUIDAndType.mock.funcGetConvertedFileByFileUIDAndType != nil {
		mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUIDAndType mock is already set by Set")
	}

	if mmGetConvertedFileByFileUIDAndType.defaultExpectation == nil {
		mmGetConvertedFileByFileUIDAndType.defaultExpectation = &RepositoryMockGetConvertedFileByFileUIDAndTypeExpectation{}
	}

	if mmGetConvertedFileByFileUIDAndType.defaultExpectation.params != nil {
		mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUIDAndType mock is already set by Expect")
	}

	if mmGetConvertedFileByFileUIDAndType.defaultExpectation.paramPtrs == nil {
		mmGetConvertedFileByFileUIDAndType.defaultExpectation.paramPtrs = &RepositoryMockGetConvertedFileByFileUIDAndTypeParamPtrs{}
	}
	mmGetConvertedFileByFileUIDAndType.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmGetConvertedFileByFileUIDAndType.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmGetConvertedFileByFileUIDAndType
}

// ExpectConvertedTypeParam3 sets up expected param convertedType for Repository.GetConvertedFileByFileUIDAndType
func (mmGetConvertedFileByFileUIDAndType *mRepositoryMockGetConvertedFileByFileUIDAndType) ExpectConvertedTypeParam3(convertedType artifactpb.ConvertedFileType) *mRepositoryMockGetConvertedFileByFileUIDAndType {
	if mmGetConvertedFileByFileUIDAndType.mock.funcGetConvertedFileByFileUIDAndType != nil {
		mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUIDAndType mock is already set by Set")
	}

	if mmGetConvertedFileByFileUIDAndType.defaultExpectation == nil {
		mmGetConvertedFileByFileUIDAndType.defaultExpectation = &RepositoryMockGetConvertedFileByFileUIDAndTypeExpectation{}
	}

	if mmGetConvertedFileByFileUIDAndType.defaultExpectation.params != nil {
		mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUIDAndType mock is already set by Expect")
	}

	if mmGetConvertedFileByFileUIDAndType.defaultExpectation.paramPtrs == nil {
		mmGetConvertedFileByFileUIDAndType.defaultExpectation.paramPtrs = &RepositoryMockGetConvertedFileByFileUIDAndTypeParamPtrs{}
	}
	mmGetConvertedFileByFileUIDAndType.defaultExpectation.paramPtrs.convertedType = &convertedType
	mmGetConvertedFileByFileUIDAndType.defaultExpectation.expectationOrigins.originConvertedType = minimock.CallerInfo(1)

	return mmGetConvertedFileByFileUIDAndType
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetConvertedFileByFileUIDAndType
func (mmGetConvertedFileByFileUIDAndType *mRepositoryMockGetConvertedFileByFileUIDAndType) Inspect(f func(ctx context.Context, fileUID types.FileUIDType, convertedType artifactpb.ConvertedFileType)) *mRepositoryMockGetConvertedFileByFileUIDAndType {
	if mmGetConvertedFileByFileUIDAndType.mock.inspectFuncGetConvertedFileByFileUIDAndType != nil {
		mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetConvertedFileByFileUIDAndType")
	}

	mmGetConvertedFileByFileUIDAndType.mock.inspectFuncGetConvertedFileByFileUIDAndType = f

	return mmGetConvertedFileByFileUIDAndType
}

// Return sets up results that will be returned by Repository.GetConvertedFileByFileUIDAndType
func (mmGetConvertedFileByFileUIDAndType *mRepositoryMockGetConvertedFileByFileUIDAndType) Return(cp1 *mm_repository.ConvertedFileModel, err error) *RepositoryMock {
	if mmGetConvertedFileByFileUIDAndType.mock.funcGetConvertedFileByFileUIDAndType != nil {
		mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUIDAndType mock is already set by Set")
	}

	if mmGetConvertedFileByFileUIDAndType.defaultExpectation == nil {
		mmGetConvertedFileByFileUIDAndType.defaultExpectation = &RepositoryMockGetConvertedFileByFileUIDAndTypeExpectation{mock: mmGetConvertedFileByFileUIDAndType.mock}
	}
	mmGetConvertedFileByFileUIDAndType.defaultExpectation.results = &RepositoryMockGetConvertedFileByFileUIDAndTypeResults{cp1, err}
	mmGetConvertedFileByFileUIDAndType.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetConvertedFileByFileUIDAndType.mock
}

// Set uses given function f to mock the Repository.GetConvertedFileByFileUIDAndType method
func (mmGetConvertedFileByFileUIDAndType *mRepositoryMockGetConvertedFileByFileUIDAndType) Set(f func(ctx context.Context, fileUID types.FileUIDType, convertedType artifactpb.ConvertedFileType) (cp1 *mm_repository.ConvertedFileModel, err error)) *RepositoryMock {
	if mmGetConvertedFileByFileUIDAndType.defaultExpectation != nil {
		mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("Default expectation is already set for the Repository.GetConvertedFileByFileUIDAndType method")
	}

	if len(mmGetConvertedFileByFileUIDAndType.expectations) > 0 {
		mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("Some expectations are already set for the Repository.GetConvertedFileByFileUIDAndType method")
	}

	mmGetConvertedFileByFileUIDAndType.mock.funcGetConvertedFileByFileUIDAndType = f
	mmGetConvertedFileByFileUIDAndType.mock.funcGetConvertedFileByFileUIDAndTypeOrigin = minimock.CallerInfo(1)
	return mmGetConvertedFileByFileUIDAndType.mock
}

// When sets expectation for the Repository.GetConvertedFileByFileUIDAndType which will trigger the result defined by the following
// Then helper
func (mmGetConvertedFileByFileUIDAndType *mRepositoryMockGetConvertedFileByFileUIDAndType) When(ctx context.Context, fileUID types.FileUIDType, convertedType artifactpb.ConvertedFileType) *RepositoryMockGetConvertedFileByFileUIDAndTypeExpectation {
	if mmGetConvertedFileByFileUIDAndType.mock.funcGetConvertedFileByFileUIDAndType != nil {
		mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUIDAndType mock is already set by Set")
	}

	expectation := &RepositoryMockGetConvertedFileByFileUIDAndTypeExpectation{
		mock:               mmGetConvertedFileByFileUIDAndType.mock,
		params:             &RepositoryMockGetConvertedFileByFileUIDAndTypeParams{ctx, fileUID, convertedType},
		expectationOrigins: RepositoryMockGetConvertedFileByFileUIDAndTypeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetConvertedFileByFileUIDAndType.expectations = append(mmGetConvertedFileByFileUIDAndType.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetConvertedFileByFileUIDAndType return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetConvertedFileByFileUIDAndTypeExpectation) Then(cp1 *mm_repository.ConvertedFileModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetConvertedFileByFileUIDAndTypeResults{cp1, err}
	return e.mock
}

// Times sets number of times Repository.GetConvertedFileByFileUIDAndType should be invoked
func (mmGetConvertedFileByFileUIDAndType *mRepositoryMockGetConvertedFileByFileUIDAndType) Times(n uint64) *mRepositoryMockGetConvertedFileByFileUIDAndType {
	if n == 0 {
		mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("Times of RepositoryMock.GetConvertedFileByFileUIDAndType mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetConvertedFileByFileUIDAndType.expectedInvocations, n)
	mmGetConvertedFileByFileUIDAndType.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetConvertedFileByFileUIDAndType
}

func (mmGetConvertedFileByFileUIDAndType *mRepositoryMockGetConvertedFileByFileUIDAndType) invocationsDone() bool {
	if len(mmGetConvertedFileByFileUIDAndType.expectations) == 0 && mmGetConvertedFileByFileUIDAndType.defaultExpectation == nil && mmGetConvertedFileByFileUIDAndType.mock.funcGetConvertedFileByFileUIDAndType == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetConvertedFileByFileUIDAndType.mock.afterGetConvertedFileByFileUIDAndTypeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetConvertedFileByFileUIDAndType.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetConvertedFileByFileUIDAndType implements mm_repository.Repository
func (mmGetConvertedFileByFileUIDAndType *RepositoryMock) GetConvertedFileByFileUIDAndType(ctx context.Context, fileUID types.FileUIDType, convertedType artifactpb.ConvertedFileType) (cp1 *mm_repository.ConvertedFileModel, err error) {
	mm_atomic.AddUint64(&mmGetConvertedFileByFileUIDAndType.beforeGetConvertedFileByFileUIDAndTypeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetConvertedFileByFileUIDAndType.afterGetConvertedFileByFileUIDAndTypeCounter, 1)

	mmGetConvertedFileByFileUIDAndType.t.Helper()

	if mmGetConvertedFileByFileUIDAndType.inspectFuncGetConvertedFileByFileUIDAndType != nil {
		mmGetConvertedFileByFileUIDAndType.inspectFuncGetConvertedFileByFileUIDAndType(ctx, fileUID, convertedType)
	}

	mm_params := RepositoryMockGetConvertedFileByFileUIDAndTypeParams{ctx, fileUID, convertedType}

	// Record call args
	mmGetConvertedFileByFileUIDAndType.GetConvertedFileByFileUIDAndTypeMock.mutex.Lock()
	mmGetConvertedFileByFileUIDAndType.GetConvertedFileByFileUIDAndTypeMock.callArgs = append(mmGetConvertedFileByFileUIDAndType.GetConvertedFileByFileUIDAndTypeMock.callArgs, &mm_params)
	mmGetConvertedFileByFileUIDAndType.GetConvertedFileByFileUIDAndTypeMock.mutex.Unlock()

	for _, e := range mmGetConvertedFileByFileUIDAndType.GetConvertedFileByFileUIDAndTypeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetConvertedFileByFileUIDAndType.GetConvertedFileByFileUIDAndTypeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetConvertedFileByFileUIDAndType.GetConvertedFileByFileUIDAndTypeMock.defaultExpectation.Counter, 1)
		mm_want := mmGetConvertedFileByFileUIDAndType.GetConvertedFileByFileUIDAndTypeMock.defaultExpectation.params
		mm_want_ptrs := mmGetConvertedFileByFileUIDAndType.GetConvertedFileByFileUIDAndTypeMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetConvertedFileByFileUIDAndTypeParams{ctx, fileUID, convertedType}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetConvertedFileByFileUIDAndType.t.Errorf("RepositoryMock.GetConvertedFileByFileUIDAndType got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetConvertedFileByFileUIDAndType.GetConvertedFileByFileUIDAndTypeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmGetConvertedFileByFileUIDAndType.t.Errorf("RepositoryMock.GetConvertedFileByFileUIDAndType got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetConvertedFileByFileUIDAndType.GetConvertedFileByFileUIDAndTypeMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

			if mm_want_ptrs.convertedType != nil && !minimock.Equal(*mm_want_ptrs.convertedType, mm_got.convertedType) {
				mmGetConvertedFileByFileUIDAndType.t.Errorf("RepositoryMock.GetConvertedFileByFileUIDAndType got unexpected parameter convertedType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetConvertedFileByFileUIDAndType.GetConvertedFileByFileUIDAndTypeMock.defaultExpectation.expectationOrigins.originConvertedType, *mm_want_ptrs.convertedType, mm_got.convertedType, minimock.Diff(*mm_want_ptrs.convertedType, mm_got.convertedType))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetConvertedFileByFileUIDAndType.t.Errorf("RepositoryMock.GetConvertedFileByFileUIDAndType got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetConvertedFileByFileUIDAndType.GetConvertedFileByFileUIDAndTypeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetConvertedFileByFileUIDAndType.GetConvertedFileByFileUIDAndTypeMock.defaultExpectation.results
		if mm_results == nil {
			mmGetConvertedFileByFileUIDAndType.t.Fatal("No results are set for the RepositoryMock.GetConvertedFileByFileUIDAndType")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetConvertedFileByFileUIDAndType.funcGetConvertedFileByFileUIDAndType != nil {
		return mmGetConvertedFileByFileUIDAndType.funcGetConvertedFileByFileUIDAndType(ctx, fileUID, convertedType)
	}
	mmGetConvertedFileByFileUIDAndType.t.Fatalf("Unexpected call to RepositoryMock.GetConvertedFileByFileUIDAndType. %v %v %v", ctx, fileUID, convertedType)
	return
}

// GetConvertedFileByFileUIDAndTypeAfterCounter returns a count of finished RepositoryMock.GetConvertedFileByFileUIDAndType invocations
func (mmGetConvertedFileByFileUIDAndType *RepositoryMock) GetConvertedFileByFileUIDAndTypeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConvertedFileByFileUIDAndType.afterGetConvertedFileByFileUIDAndTypeCounter)
}

// GetConvertedFileByFileUIDAndTypeBeforeCounter returns a count of RepositoryMock.GetConvertedFileByFileUIDAndType invocations
func (mmGetConvertedFileByFileUIDAndType *RepositoryMock) GetConvertedFileByFileUIDAndTypeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConvertedFileByFileUIDAndType.beforeGetConvertedFileByFileUIDAndTypeCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetConvertedFileByFileUIDAndType.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetConvertedFileByFileUIDAndType *mRepositoryMockGetConvertedFileByFileUIDAndType) Calls() []*RepositoryMockGetConvertedFileByFileUIDAndTypeParams {
	mmGetConvertedFileByFileUIDAndType.mutex.RLock()

	argCopy := make([]*RepositoryMockGetConvertedFileByFileUIDAndTypeParams, len(mmGetConvertedFileByFileUIDAndType.callArgs))
	copy(argCopy, mmGetConvertedFileByFileUIDAndType.callArgs)

	mmGetConvertedFileByFileUIDAndType.mutex.RUnlock()

	return argCopy
}

// MinimockGetConvertedFileByFileUIDAndTypeDone returns true if the count of the GetConvertedFileByFileUIDAndType invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetConvertedFileByFileUIDAndTypeDone() bool {
	if m.GetConvertedFileByFileUIDAndTypeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetConvertedFileByFileUIDAndTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetConvertedFileByFileUIDAndTypeMock.invocationsDone()
}

// MinimockGetConvertedFileByFileUIDAndTypeInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetConvertedFileByFileUIDAndTypeInspect() {
	for _, e := range m.GetConvertedFileByFileUIDAndTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetConvertedFileByFileUIDAndType at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetConvertedFileByFileUIDAndTypeCounter := mm_atomic.LoadUint64(&m.afterGetConvertedFileByFileUIDAndTypeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetConvertedFileByFileUIDAndTypeMock.defaultExpectation != nil && afterGetConvertedFileByFileUIDAndTypeCounter < 1 {
		if m.GetConvertedFileByFileUIDAndTypeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetConvertedFileByFileUIDAndType at\n%s", m.GetConvertedFileByFileUIDAndTypeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetConvertedFileByFileUIDAndType at\n%s with params: %#v", m.GetConvertedFileByFileUIDAndTypeMock.defaultExpectation.expectationOrigins.origin, *m.GetConvertedFileByFileUIDAndTypeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetConvertedFileByFileUIDAndType != nil && afterGetConvertedFileByFileUIDAndTypeCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetConvertedFileByFileUIDAndType at\n%s", m.funcGetConvertedFileByFileUIDAndTypeOrigin)
	}

	if !m.GetConvertedFileByFileUIDAndTypeMock.invocationsDone() && afterGetConvertedFileByFileUIDAndTypeCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetConvertedFileByFileUIDAndType at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetConvertedFileByFileUIDAndTypeMock.expectedInvocations), m.GetConvertedFileByFileUIDAndTypeMock.expectedInvocationsOrigin, afterGetConvertedFileByFileUIDAndTypeCounter)
	}
}

type mRepositoryMockGetConvertedFileCountByKBUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetConvertedFileCountByKBUIDExpectation
	expectations       []*RepositoryMockGetConvertedFileCountByKBUIDExpectation

	callArgs []*RepositoryMockGetConvertedFileCountByKBUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetConvertedFileCountByKBUIDExpectation specifies expectation struct of the Repository.GetConvertedFileCountByKBUID
type RepositoryMockGetConvertedFileCountByKBUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetConvertedFileCountByKBUIDParams
	paramPtrs          *RepositoryMockGetConvertedFileCountByKBUIDParamPtrs
	expectationOrigins RepositoryMockGetConvertedFileCountByKBUIDExpectationOrigins
	results            *RepositoryMockGetConvertedFileCountByKBUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetConvertedFileCountByKBUIDParams contains parameters of the Repository.GetConvertedFileCountByKBUID
type RepositoryMockGetConvertedFileCountByKBUIDParams struct {
	ctx   context.Context
	kbUID types.KBUIDType
}

// RepositoryMockGetConvertedFileCountByKBUIDParamPtrs contains pointers to parameters of the Repository.GetConvertedFileCountByKBUID
type RepositoryMockGetConvertedFileCountByKBUIDParamPtrs struct {
	ctx   *context.Context
	kbUID *types.KBUIDType
}

// RepositoryMockGetConvertedFileCountByKBUIDResults contains results of the Repository.GetConvertedFileCountByKBUID
type RepositoryMockGetConvertedFileCountByKBUIDResults struct {
	i1  int64
	err error
}

// RepositoryMockGetConvertedFileCountByKBUIDOrigins contains origins of expectations of the Repository.GetConvertedFileCountByKBUID
type RepositoryMockGetConvertedFileCountByKBUIDExpectationOrigins struct {
	origin      string
	originCtx   string
	originKbUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetConvertedFileCountByKBUID *mRepositoryMockGetConvertedFileCountByKBUID) Optional() *mRepositoryMockGetConvertedFileCountByKBUID {
	mmGetConvertedFileCountByKBUID.optional = true
	return mmGetConvertedFileCountByKBUID
}

// Expect sets up expected params for Repository.GetConvertedFileCountByKBUID
func (mmGetConvertedFileCountByKBUID *mRepositoryMockGetConvertedFileCountByKBUID) Expect(ctx context.Context, kbUID types.KBUIDType) *mRepositoryMockGetConvertedFileCountByKBUID {
	if mmGetConvertedFileCountByKBUID.mock.funcGetConvertedFileCountByKBUID != nil {
		mmGetConvertedFileCountByKBUID.mock.t.Fatalf("RepositoryMock.GetConvertedFileCountByKBUID mock is already set by Set")
	}

	if mmGetConvertedFileCountByKBUID.defaultExpectation == nil {
		mmGetConvertedFileCountByKBUID.defaultExpectation = &RepositoryMockGetConvertedFileCountByKBUIDExpectation{}
	}

	if mmGetConvertedFileCountByKBUID.defaultExpectation.paramPtrs != nil {
		mmGetConvertedFileCountByKBUID.mock.t.Fatalf("RepositoryMock.GetConvertedFileCountByKBUID mock is already set by ExpectParams functions")
	}

	mmGetConvertedFileCountByKBUID.defaultExpectation.params = &RepositoryMockGetConvertedFileCountByKBUIDParams{ctx, kbUID}
	mmGetConvertedFileCountByKBUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetConvertedFileCountByKBUID.expectations {
		if minimock.Equal(e.params, mmGetConvertedFileCountByKBUID.defaultExpectation.params) {
			mmGetConvertedFileCountByKBUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetConvertedFileCountByKBUID.defaultExpectation.params)
		}
	}

	return mmGetConvertedFileCountByKBUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetConvertedFileCountByKBUID
func (mmGetConvertedFileCountByKBUID *mRepositoryMockGetConvertedFileCountByKBUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetConvertedFileCountByKBUID {
	if mmGetConvertedFileCountByKBUID.mock.funcGetConvertedFileCountByKBUID != nil {
		mmGetConvertedFileCountByKBUID.mock.t.Fatalf("RepositoryMock.GetConvertedFileCountByKBUID mock is already set by Set")
	}

	if mmGetConvertedFileCountByKBUID.defaultExpectation == nil {
		mmGetConvertedFileCountByKBUID.defaultExpectation = &RepositoryMockGetConvertedFileCountByKBUIDExpectation{}
	}

	if mmGetConvertedFileCountByKBUID.defaultExpectation.params != nil {
		mmGetConvertedFileCountByKBUID.mock.t.Fatalf("RepositoryMock.GetConvertedFileCountByKBUID mock is already set by Expect")
	}

	if mmGetConvertedFileCountByKBUID.defaultExpectation.paramPtrs == nil {
		mmGetConvertedFileCountByKBUID.defaultExpectation.paramPtrs = &RepositoryMockGetConvertedFileCountByKBUIDParamPtrs{}
	}
	mmGetConvertedFileCountByKBUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetConvertedFileCountByKBUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetConvertedFileCountByKBUID
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.GetConvertedFileCountByKBUID
func (mmGetConvertedFileCountByKBUID *mRepositoryMockGetConvertedFileCountByKBUID) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockGetConvertedFileCountByKBUID {
	if mmGetConvertedFileCountByKBUID.mock.funcGetConvertedFileCountByKBUID != nil {
		mmGetConvertedFileCountByKBUID.mock.t.Fatalf("RepositoryMock.GetConvertedFileCountByKBUID mock is already set by Set")
	}

	if mmGetConvertedFileCountByKBUID.defaultExpectation == nil {
		mmGetConvertedFileCountByKBUID.defaultExpectation = &RepositoryMockGetConvertedFileCountByKBUIDExpectation{}
	}

	if mmGetConvertedFileCountByKBUID.defaultExpectation.params != nil {
		mmGetConvertedFileCountByKBUID.mock.t.Fatalf("RepositoryMock.GetConvertedFileCountByKBUID mock is already set by Expect")
	}

	if mmGetConvertedFileCountByKBUID.defaultExpectation.paramPtrs == nil {
		mmGetConvertedFileCountByKBUID.defaultExpectation.paramPtrs = &RepositoryMockGetConvertedFileCountByKBUIDParamPtrs{}
	}
	mmGetConvertedFileCountByKBUID.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmGetConvertedFileCountByKBUID.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmGetConvertedFileCountByKBUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetConvertedFileCountByKBUID
func (mmGetConvertedFileCountByKBUID *mRepositoryMockGetConvertedFileCountByKBUID) Inspect(f func(ctx context.Context, kbUID types.KBUIDType)) *mRepositoryMockGetConvertedFileCountByKBUID {
	if mmGetConvertedFileCountByKBUID.mock.inspectFuncGetConvertedFileCountByKBUID != nil {
		mmGetConvertedFileCountByKBUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetConvertedFileCountByKBUID")
	}

	mmGetConvertedFileCountByKBUID.mock.inspectFuncGetConvertedFileCountByKBUID = f

	return mmGetConvertedFileCountByKBUID
}

// Return sets up results that will be returned by Repository.GetConvertedFileCountByKBUID
func (mmGetConvertedFileCountByKBUID *mRepositoryMockGetConvertedFileCountByKBUID) Return(i1 int64, err error) *RepositoryMock {
	if mmGetConvertedFileCountByKBUID.mock.funcGetConvertedFileCountByKBUID != nil {
		mmGetConvertedFileCountByKBUID.mock.t.Fatalf("RepositoryMock.GetConvertedFileCountByKBUID mock is already set by Set")
	}

	if mmGetConvertedFileCountByKBUID.defaultExpectation == nil {
		mmGetConvertedFileCountByKBUID.defaultExpectation = &RepositoryMockGetConvertedFileCountByKBUIDExpectation{mock: mmGetConvertedFileCountByKBUID.mock}
	}
	mmGetConvertedFileCountByKBUID.defaultExpectation.results = &RepositoryMockGetConvertedFileCountByKBUIDResults{i1, err}
	mmGetConvertedFileCountByKBUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetConvertedFileCountByKBUID.mock
}

// Set uses given function f to mock the Repository.GetConvertedFileCountByKBUID method
func (mmGetConvertedFileCountByKBUID *mRepositoryMockGetConvertedFileCountByKBUID) Set(f func(ctx context.Context, kbUID types.KBUIDType) (i1 int64, err error)) *RepositoryMock {
	if mmGetConvertedFileCountByKBUID.defaultExpectation != nil {
		mmGetConvertedFileCountByKBUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetConvertedFileCountByKBUID method")
	}

	if len(mmGetConvertedFileCountByKBUID.expectations) > 0 {
		mmGetConvertedFileCountByKBUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetConvertedFileCountByKBUID method")
	}

	mmGetConvertedFileCountByKBUID.mock.funcGetConvertedFileCountByKBUID = f
	mmGetConvertedFileCountByKBUID.mock.funcGetConvertedFileCountByKBUIDOrigin = minimock.CallerInfo(1)
	return mmGetConvertedFileCountByKBUID.mock
}

// When sets expectation for the Repository.GetConvertedFileCountByKBUID which will trigger the result defined by the following
// Then helper
func (mmGetConvertedFileCountByKBUID *mRepositoryMockGetConvertedFileCountByKBUID) When(ctx context.Context, kbUID types.KBUIDType) *RepositoryMockGetConvertedFileCountByKBUIDExpectation {
	if mmGetConvertedFileCountByKBUID.mock.funcGetConvertedFileCountByKBUID != nil {
		mmGetConvertedFileCountByKBUID.mock.t.Fatalf("RepositoryMock.GetConvertedFileCountByKBUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetConvertedFileCountByKBUIDExpectation{
		mock:               mmGetConvertedFileCountByKBUID.mock,
		params:             &RepositoryMockGetConvertedFileCountByKBUIDParams{ctx, kbUID},
		expectationOrigins: RepositoryMockGetConvertedFileCountByKBUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetConvertedFileCountByKBUID.expectations = append(mmGetConvertedFileCountByKBUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetConvertedFileCountByKBUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetConvertedFileCountByKBUIDExpectation) Then(i1 int64, err error) *RepositoryMock {
	e.results = &RepositoryMockGetConvertedFileCountByKBUIDResults{i1, err}
	return e.mock
}

// Times sets number of times Repository.GetConvertedFileCountByKBUID should be invoked
func (mmGetConvertedFileCountByKBUID *mRepositoryMockGetConvertedFileCountByKBUID) Times(n uint64) *mRepositoryMockGetConvertedFileCountByKBUID {
	if n == 0 {
		mmGetConvertedFileCountByKBUID.mock.t.Fatalf("Times of RepositoryMock.GetConvertedFileCountByKBUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetConvertedFileCountByKBUID.expectedInvocations, n)
	mmGetConvertedFileCountByKBUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetConvertedFileCountByKBUID
}

func (mmGetConvertedFileCountByKBUID *mRepositoryMockGetConvertedFileCountByKBUID) invocationsDone() bool {
	if len(mmGetConvertedFileCountByKBUID.expectations) == 0 && mmGetConvertedFileCountByKBUID.defaultExpectation == nil && mmGetConvertedFileCountByKBUID.mock.funcGetConvertedFileCountByKBUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetConvertedFileCountByKBUID.mock.afterGetConvertedFileCountByKBUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetConvertedFileCountByKBUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetConvertedFileCountByKBUID implements mm_repository.Repository
func (mmGetConvertedFileCountByKBUID *RepositoryMock) GetConvertedFileCountByKBUID(ctx context.Context, kbUID types.KBUIDType) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetConvertedFileCountByKBUID.beforeGetConvertedFileCountByKBUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetConvertedFileCountByKBUID.afterGetConvertedFileCountByKBUIDCounter, 1)

	mmGetConvertedFileCountByKBUID.t.Helper()

	if mmGetConvertedFileCountByKBUID.inspectFuncGetConvertedFileCountByKBUID != nil {
		mmGetConvertedFileCountByKBUID.inspectFuncGetConvertedFileCountByKBUID(ctx, kbUID)
	}

	mm_params := RepositoryMockGetConvertedFileCountByKBUIDParams{ctx, kbUID}

	// Record call args
	mmGetConvertedFileCountByKBUID.GetConvertedFileCountByKBUIDMock.mutex.Lock()
	mmGetConvertedFileCountByKBUID.GetConvertedFileCountByKBUIDMock.callArgs = append(mmGetConvertedFileCountByKBUID.GetConvertedFileCountByKBUIDMock.callArgs, &mm_params)
	mmGetConvertedFileCountByKBUID.GetConvertedFileCountByKBUIDMock.mutex.Unlock()

	for _, e := range mmGetConvertedFileCountByKBUID.GetConvertedFileCountByKBUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetConvertedFileCountByKBUID.GetConvertedFileCountByKBUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetConvertedFileCountByKBUID.GetConvertedFileCountByKBUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetConvertedFileCountByKBUID.GetConvertedFileCountByKBUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetConvertedFileCountByKBUID.GetConvertedFileCountByKBUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetConvertedFileCountByKBUIDParams{ctx, kbUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetConvertedFileCountByKBUID.t.Errorf("RepositoryMock.GetConvertedFileCountByKBUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetConvertedFileCountByKBUID.GetConvertedFileCountByKBUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmGetConvertedFileCountByKBUID.t.Errorf("RepositoryMock.GetConvertedFileCountByKBUID got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetConvertedFileCountByKBUID.GetConvertedFileCountByKBUIDMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetConvertedFileCountByKBUID.t.Errorf("RepositoryMock.GetConvertedFileCountByKBUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetConvertedFileCountByKBUID.GetConvertedFileCountByKBUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetConvertedFileCountByKBUID.GetConvertedFileCountByKBUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetConvertedFileCountByKBUID.t.Fatal("No results are set for the RepositoryMock.GetConvertedFileCountByKBUID")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetConvertedFileCountByKBUID.funcGetConvertedFileCountByKBUID != nil {
		return mmGetConvertedFileCountByKBUID.funcGetConvertedFileCountByKBUID(ctx, kbUID)
	}
	mmGetConvertedFileCountByKBUID.t.Fatalf("Unexpected call to RepositoryMock.GetConvertedFileCountByKBUID. %v %v", ctx, kbUID)
	return
}

// GetConvertedFileCountByKBUIDAfterCounter returns a count of finished RepositoryMock.GetConvertedFileCountByKBUID invocations
func (mmGetConvertedFileCountByKBUID *RepositoryMock) GetConvertedFileCountByKBUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConvertedFileCountByKBUID.afterGetConvertedFileCountByKBUIDCounter)
}

// GetConvertedFileCountByKBUIDBeforeCounter returns a count of RepositoryMock.GetConvertedFileCountByKBUID invocations
func (mmGetConvertedFileCountByKBUID *RepositoryMock) GetConvertedFileCountByKBUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConvertedFileCountByKBUID.beforeGetConvertedFileCountByKBUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetConvertedFileCountByKBUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetConvertedFileCountByKBUID *mRepositoryMockGetConvertedFileCountByKBUID) Calls() []*RepositoryMockGetConvertedFileCountByKBUIDParams {
	mmGetConvertedFileCountByKBUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetConvertedFileCountByKBUIDParams, len(mmGetConvertedFileCountByKBUID.callArgs))
	copy(argCopy, mmGetConvertedFileCountByKBUID.callArgs)

	mmGetConvertedFileCountByKBUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetConvertedFileCountByKBUIDDone returns true if the count of the GetConvertedFileCountByKBUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetConvertedFileCountByKBUIDDone() bool {
	if m.GetConvertedFileCountByKBUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetConvertedFileCountByKBUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetConvertedFileCountByKBUIDMock.invocationsDone()
}

// MinimockGetConvertedFileCountByKBUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetConvertedFileCountByKBUIDInspect() {
	for _, e := range m.GetConvertedFileCountByKBUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetConvertedFileCountByKBUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetConvertedFileCountByKBUIDCounter := mm_atomic.LoadUint64(&m.afterGetConvertedFileCountByKBUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetConvertedFileCountByKBUIDMock.defaultExpectation != nil && afterGetConvertedFileCountByKBUIDCounter < 1 {
		if m.GetConvertedFileCountByKBUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetConvertedFileCountByKBUID at\n%s", m.GetConvertedFileCountByKBUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetConvertedFileCountByKBUID at\n%s with params: %#v", m.GetConvertedFileCountByKBUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetConvertedFileCountByKBUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetConvertedFileCountByKBUID != nil && afterGetConvertedFileCountByKBUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetConvertedFileCountByKBUID at\n%s", m.funcGetConvertedFileCountByKBUIDOrigin)
	}

	if !m.GetConvertedFileCountByKBUIDMock.invocationsDone() && afterGetConvertedFileCountByKBUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetConvertedFileCountByKBUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetConvertedFileCountByKBUIDMock.expectedInvocations), m.GetConvertedFileCountByKBUIDMock.expectedInvocationsOrigin, afterGetConvertedFileCountByKBUIDCounter)
	}
}

type mRepositoryMockGetDB struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetDBExpectation
	expectations       []*RepositoryMockGetDBExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetDBExpectation specifies expectation struct of the Repository.GetDB
type RepositoryMockGetDBExpectation struct {
	mock *RepositoryMock

	results      *RepositoryMockGetDBResults
	returnOrigin string
	Counter      uint64
}

// RepositoryMockGetDBResults contains results of the Repository.GetDB
type RepositoryMockGetDBResults struct {
	dp1 *gorm.DB
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetDB *mRepositoryMockGetDB) Optional() *mRepositoryMockGetDB {
	mmGetDB.optional = true
	return mmGetDB
}

// Expect sets up expected params for Repository.GetDB
func (mmGetDB *mRepositoryMockGetDB) Expect() *mRepositoryMockGetDB {
	if mmGetDB.mock.funcGetDB != nil {
		mmGetDB.mock.t.Fatalf("RepositoryMock.GetDB mock is already set by Set")
	}

	if mmGetDB.defaultExpectation == nil {
		mmGetDB.defaultExpectation = &RepositoryMockGetDBExpectation{}
	}

	return mmGetDB
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetDB
func (mmGetDB *mRepositoryMockGetDB) Inspect(f func()) *mRepositoryMockGetDB {
	if mmGetDB.mock.inspectFuncGetDB != nil {
		mmGetDB.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetDB")
	}

	mmGetDB.mock.inspectFuncGetDB = f

	return mmGetDB
}

// Return sets up results that will be returned by Repository.GetDB
func (mmGetDB *mRepositoryMockGetDB) Return(dp1 *gorm.DB) *RepositoryMock {
	if mmGetDB.mock.funcGetDB != nil {
		mmGetDB.mock.t.Fatalf("RepositoryMock.GetDB mock is already set by Set")
	}

	if mmGetDB.defaultExpectation == nil {
		mmGetDB.defaultExpectation = &RepositoryMockGetDBExpectation{mock: mmGetDB.mock}
	}
	mmGetDB.defaultExpectation.results = &RepositoryMockGetDBResults{dp1}
	mmGetDB.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetDB.mock
}

// Set uses given function f to mock the Repository.GetDB method
func (mmGetDB *mRepositoryMockGetDB) Set(f func() (dp1 *gorm.DB)) *RepositoryMock {
	if mmGetDB.defaultExpectation != nil {
		mmGetDB.mock.t.Fatalf("Default expectation is already set for the Repository.GetDB method")
	}

	if len(mmGetDB.expectations) > 0 {
		mmGetDB.mock.t.Fatalf("Some expectations are already set for the Repository.GetDB method")
	}

	mmGetDB.mock.funcGetDB = f
	mmGetDB.mock.funcGetDBOrigin = minimock.CallerInfo(1)
	return mmGetDB.mock
}

// Times sets number of times Repository.GetDB should be invoked
func (mmGetDB *mRepositoryMockGetDB) Times(n uint64) *mRepositoryMockGetDB {
	if n == 0 {
		mmGetDB.mock.t.Fatalf("Times of RepositoryMock.GetDB mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetDB.expectedInvocations, n)
	mmGetDB.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetDB
}

func (mmGetDB *mRepositoryMockGetDB) invocationsDone() bool {
	if len(mmGetDB.expectations) == 0 && mmGetDB.defaultExpectation == nil && mmGetDB.mock.funcGetDB == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetDB.mock.afterGetDBCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetDB.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetDB implements mm_repository.Repository
func (mmGetDB *RepositoryMock) GetDB() (dp1 *gorm.DB) {
	mm_atomic.AddUint64(&mmGetDB.beforeGetDBCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDB.afterGetDBCounter, 1)

	mmGetDB.t.Helper()

	if mmGetDB.inspectFuncGetDB != nil {
		mmGetDB.inspectFuncGetDB()
	}

	if mmGetDB.GetDBMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDB.GetDBMock.defaultExpectation.Counter, 1)

		mm_results := mmGetDB.GetDBMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDB.t.Fatal("No results are set for the RepositoryMock.GetDB")
		}
		return (*mm_results).dp1
	}
	if mmGetDB.funcGetDB != nil {
		return mmGetDB.funcGetDB()
	}
	mmGetDB.t.Fatalf("Unexpected call to RepositoryMock.GetDB.")
	return
}

// GetDBAfterCounter returns a count of finished RepositoryMock.GetDB invocations
func (mmGetDB *RepositoryMock) GetDBAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDB.afterGetDBCounter)
}

// GetDBBeforeCounter returns a count of RepositoryMock.GetDB invocations
func (mmGetDB *RepositoryMock) GetDBBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDB.beforeGetDBCounter)
}

// MinimockGetDBDone returns true if the count of the GetDB invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetDBDone() bool {
	if m.GetDBMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetDBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetDBMock.invocationsDone()
}

// MinimockGetDBInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetDBInspect() {
	for _, e := range m.GetDBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryMock.GetDB")
		}
	}

	afterGetDBCounter := mm_atomic.LoadUint64(&m.afterGetDBCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetDBMock.defaultExpectation != nil && afterGetDBCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetDB at\n%s", m.GetDBMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDB != nil && afterGetDBCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetDB at\n%s", m.funcGetDBOrigin)
	}

	if !m.GetDBMock.invocationsDone() && afterGetDBCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetDB at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetDBMock.expectedInvocations), m.GetDBMock.expectedInvocationsOrigin, afterGetDBCounter)
	}
}

type mRepositoryMockGetDefaultSystem struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetDefaultSystemExpectation
	expectations       []*RepositoryMockGetDefaultSystemExpectation

	callArgs []*RepositoryMockGetDefaultSystemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetDefaultSystemExpectation specifies expectation struct of the Repository.GetDefaultSystem
type RepositoryMockGetDefaultSystemExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetDefaultSystemParams
	paramPtrs          *RepositoryMockGetDefaultSystemParamPtrs
	expectationOrigins RepositoryMockGetDefaultSystemExpectationOrigins
	results            *RepositoryMockGetDefaultSystemResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetDefaultSystemParams contains parameters of the Repository.GetDefaultSystem
type RepositoryMockGetDefaultSystemParams struct {
	ctx context.Context
}

// RepositoryMockGetDefaultSystemParamPtrs contains pointers to parameters of the Repository.GetDefaultSystem
type RepositoryMockGetDefaultSystemParamPtrs struct {
	ctx *context.Context
}

// RepositoryMockGetDefaultSystemResults contains results of the Repository.GetDefaultSystem
type RepositoryMockGetDefaultSystemResults struct {
	sp1 *mm_repository.SystemModel
	err error
}

// RepositoryMockGetDefaultSystemOrigins contains origins of expectations of the Repository.GetDefaultSystem
type RepositoryMockGetDefaultSystemExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetDefaultSystem *mRepositoryMockGetDefaultSystem) Optional() *mRepositoryMockGetDefaultSystem {
	mmGetDefaultSystem.optional = true
	return mmGetDefaultSystem
}

// Expect sets up expected params for Repository.GetDefaultSystem
func (mmGetDefaultSystem *mRepositoryMockGetDefaultSystem) Expect(ctx context.Context) *mRepositoryMockGetDefaultSystem {
	if mmGetDefaultSystem.mock.funcGetDefaultSystem != nil {
		mmGetDefaultSystem.mock.t.Fatalf("RepositoryMock.GetDefaultSystem mock is already set by Set")
	}

	if mmGetDefaultSystem.defaultExpectation == nil {
		mmGetDefaultSystem.defaultExpectation = &RepositoryMockGetDefaultSystemExpectation{}
	}

	if mmGetDefaultSystem.defaultExpectation.paramPtrs != nil {
		mmGetDefaultSystem.mock.t.Fatalf("RepositoryMock.GetDefaultSystem mock is already set by ExpectParams functions")
	}

	mmGetDefaultSystem.defaultExpectation.params = &RepositoryMockGetDefaultSystemParams{ctx}
	mmGetDefaultSystem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetDefaultSystem.expectations {
		if minimock.Equal(e.params, mmGetDefaultSystem.defaultExpectation.params) {
			mmGetDefaultSystem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetDefaultSystem.defaultExpectation.params)
		}
	}

	return mmGetDefaultSystem
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetDefaultSystem
func (mmGetDefaultSystem *mRepositoryMockGetDefaultSystem) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetDefaultSystem {
	if mmGetDefaultSystem.mock.funcGetDefaultSystem != nil {
		mmGetDefaultSystem.mock.t.Fatalf("RepositoryMock.GetDefaultSystem mock is already set by Set")
	}

	if mmGetDefaultSystem.defaultExpectation == nil {
		mmGetDefaultSystem.defaultExpectation = &RepositoryMockGetDefaultSystemExpectation{}
	}

	if mmGetDefaultSystem.defaultExpectation.params != nil {
		mmGetDefaultSystem.mock.t.Fatalf("RepositoryMock.GetDefaultSystem mock is already set by Expect")
	}

	if mmGetDefaultSystem.defaultExpectation.paramPtrs == nil {
		mmGetDefaultSystem.defaultExpectation.paramPtrs = &RepositoryMockGetDefaultSystemParamPtrs{}
	}
	mmGetDefaultSystem.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetDefaultSystem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetDefaultSystem
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetDefaultSystem
func (mmGetDefaultSystem *mRepositoryMockGetDefaultSystem) Inspect(f func(ctx context.Context)) *mRepositoryMockGetDefaultSystem {
	if mmGetDefaultSystem.mock.inspectFuncGetDefaultSystem != nil {
		mmGetDefaultSystem.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetDefaultSystem")
	}

	mmGetDefaultSystem.mock.inspectFuncGetDefaultSystem = f

	return mmGetDefaultSystem
}

// Return sets up results that will be returned by Repository.GetDefaultSystem
func (mmGetDefaultSystem *mRepositoryMockGetDefaultSystem) Return(sp1 *mm_repository.SystemModel, err error) *RepositoryMock {
	if mmGetDefaultSystem.mock.funcGetDefaultSystem != nil {
		mmGetDefaultSystem.mock.t.Fatalf("RepositoryMock.GetDefaultSystem mock is already set by Set")
	}

	if mmGetDefaultSystem.defaultExpectation == nil {
		mmGetDefaultSystem.defaultExpectation = &RepositoryMockGetDefaultSystemExpectation{mock: mmGetDefaultSystem.mock}
	}
	mmGetDefaultSystem.defaultExpectation.results = &RepositoryMockGetDefaultSystemResults{sp1, err}
	mmGetDefaultSystem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetDefaultSystem.mock
}

// Set uses given function f to mock the Repository.GetDefaultSystem method
func (mmGetDefaultSystem *mRepositoryMockGetDefaultSystem) Set(f func(ctx context.Context) (sp1 *mm_repository.SystemModel, err error)) *RepositoryMock {
	if mmGetDefaultSystem.defaultExpectation != nil {
		mmGetDefaultSystem.mock.t.Fatalf("Default expectation is already set for the Repository.GetDefaultSystem method")
	}

	if len(mmGetDefaultSystem.expectations) > 0 {
		mmGetDefaultSystem.mock.t.Fatalf("Some expectations are already set for the Repository.GetDefaultSystem method")
	}

	mmGetDefaultSystem.mock.funcGetDefaultSystem = f
	mmGetDefaultSystem.mock.funcGetDefaultSystemOrigin = minimock.CallerInfo(1)
	return mmGetDefaultSystem.mock
}

// When sets expectation for the Repository.GetDefaultSystem which will trigger the result defined by the following
// Then helper
func (mmGetDefaultSystem *mRepositoryMockGetDefaultSystem) When(ctx context.Context) *RepositoryMockGetDefaultSystemExpectation {
	if mmGetDefaultSystem.mock.funcGetDefaultSystem != nil {
		mmGetDefaultSystem.mock.t.Fatalf("RepositoryMock.GetDefaultSystem mock is already set by Set")
	}

	expectation := &RepositoryMockGetDefaultSystemExpectation{
		mock:               mmGetDefaultSystem.mock,
		params:             &RepositoryMockGetDefaultSystemParams{ctx},
		expectationOrigins: RepositoryMockGetDefaultSystemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetDefaultSystem.expectations = append(mmGetDefaultSystem.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetDefaultSystem return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetDefaultSystemExpectation) Then(sp1 *mm_repository.SystemModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetDefaultSystemResults{sp1, err}
	return e.mock
}

// Times sets number of times Repository.GetDefaultSystem should be invoked
func (mmGetDefaultSystem *mRepositoryMockGetDefaultSystem) Times(n uint64) *mRepositoryMockGetDefaultSystem {
	if n == 0 {
		mmGetDefaultSystem.mock.t.Fatalf("Times of RepositoryMock.GetDefaultSystem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetDefaultSystem.expectedInvocations, n)
	mmGetDefaultSystem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetDefaultSystem
}

func (mmGetDefaultSystem *mRepositoryMockGetDefaultSystem) invocationsDone() bool {
	if len(mmGetDefaultSystem.expectations) == 0 && mmGetDefaultSystem.defaultExpectation == nil && mmGetDefaultSystem.mock.funcGetDefaultSystem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetDefaultSystem.mock.afterGetDefaultSystemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetDefaultSystem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetDefaultSystem implements mm_repository.Repository
func (mmGetDefaultSystem *RepositoryMock) GetDefaultSystem(ctx context.Context) (sp1 *mm_repository.SystemModel, err error) {
	mm_atomic.AddUint64(&mmGetDefaultSystem.beforeGetDefaultSystemCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDefaultSystem.afterGetDefaultSystemCounter, 1)

	mmGetDefaultSystem.t.Helper()

	if mmGetDefaultSystem.inspectFuncGetDefaultSystem != nil {
		mmGetDefaultSystem.inspectFuncGetDefaultSystem(ctx)
	}

	mm_params := RepositoryMockGetDefaultSystemParams{ctx}

	// Record call args
	mmGetDefaultSystem.GetDefaultSystemMock.mutex.Lock()
	mmGetDefaultSystem.GetDefaultSystemMock.callArgs = append(mmGetDefaultSystem.GetDefaultSystemMock.callArgs, &mm_params)
	mmGetDefaultSystem.GetDefaultSystemMock.mutex.Unlock()

	for _, e := range mmGetDefaultSystem.GetDefaultSystemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGetDefaultSystem.GetDefaultSystemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDefaultSystem.GetDefaultSystemMock.defaultExpectation.Counter, 1)
		mm_want := mmGetDefaultSystem.GetDefaultSystemMock.defaultExpectation.params
		mm_want_ptrs := mmGetDefaultSystem.GetDefaultSystemMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetDefaultSystemParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetDefaultSystem.t.Errorf("RepositoryMock.GetDefaultSystem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetDefaultSystem.GetDefaultSystemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetDefaultSystem.t.Errorf("RepositoryMock.GetDefaultSystem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetDefaultSystem.GetDefaultSystemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetDefaultSystem.GetDefaultSystemMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDefaultSystem.t.Fatal("No results are set for the RepositoryMock.GetDefaultSystem")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGetDefaultSystem.funcGetDefaultSystem != nil {
		return mmGetDefaultSystem.funcGetDefaultSystem(ctx)
	}
	mmGetDefaultSystem.t.Fatalf("Unexpected call to RepositoryMock.GetDefaultSystem. %v", ctx)
	return
}

// GetDefaultSystemAfterCounter returns a count of finished RepositoryMock.GetDefaultSystem invocations
func (mmGetDefaultSystem *RepositoryMock) GetDefaultSystemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDefaultSystem.afterGetDefaultSystemCounter)
}

// GetDefaultSystemBeforeCounter returns a count of RepositoryMock.GetDefaultSystem invocations
func (mmGetDefaultSystem *RepositoryMock) GetDefaultSystemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDefaultSystem.beforeGetDefaultSystemCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetDefaultSystem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetDefaultSystem *mRepositoryMockGetDefaultSystem) Calls() []*RepositoryMockGetDefaultSystemParams {
	mmGetDefaultSystem.mutex.RLock()

	argCopy := make([]*RepositoryMockGetDefaultSystemParams, len(mmGetDefaultSystem.callArgs))
	copy(argCopy, mmGetDefaultSystem.callArgs)

	mmGetDefaultSystem.mutex.RUnlock()

	return argCopy
}

// MinimockGetDefaultSystemDone returns true if the count of the GetDefaultSystem invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetDefaultSystemDone() bool {
	if m.GetDefaultSystemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetDefaultSystemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetDefaultSystemMock.invocationsDone()
}

// MinimockGetDefaultSystemInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetDefaultSystemInspect() {
	for _, e := range m.GetDefaultSystemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetDefaultSystem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetDefaultSystemCounter := mm_atomic.LoadUint64(&m.afterGetDefaultSystemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetDefaultSystemMock.defaultExpectation != nil && afterGetDefaultSystemCounter < 1 {
		if m.GetDefaultSystemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetDefaultSystem at\n%s", m.GetDefaultSystemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetDefaultSystem at\n%s with params: %#v", m.GetDefaultSystemMock.defaultExpectation.expectationOrigins.origin, *m.GetDefaultSystemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDefaultSystem != nil && afterGetDefaultSystemCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetDefaultSystem at\n%s", m.funcGetDefaultSystemOrigin)
	}

	if !m.GetDefaultSystemMock.invocationsDone() && afterGetDefaultSystemCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetDefaultSystem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetDefaultSystemMock.expectedInvocations), m.GetDefaultSystemMock.expectedInvocationsOrigin, afterGetDefaultSystemCounter)
	}
}

type mRepositoryMockGetDualProcessingTarget struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetDualProcessingTargetExpectation
	expectations       []*RepositoryMockGetDualProcessingTargetExpectation

	callArgs []*RepositoryMockGetDualProcessingTargetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetDualProcessingTargetExpectation specifies expectation struct of the Repository.GetDualProcessingTarget
type RepositoryMockGetDualProcessingTargetExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetDualProcessingTargetParams
	paramPtrs          *RepositoryMockGetDualProcessingTargetParamPtrs
	expectationOrigins RepositoryMockGetDualProcessingTargetExpectationOrigins
	results            *RepositoryMockGetDualProcessingTargetResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetDualProcessingTargetParams contains parameters of the Repository.GetDualProcessingTarget
type RepositoryMockGetDualProcessingTargetParams struct {
	ctx          context.Context
	productionKB *mm_repository.KnowledgeBaseModel
}

// RepositoryMockGetDualProcessingTargetParamPtrs contains pointers to parameters of the Repository.GetDualProcessingTarget
type RepositoryMockGetDualProcessingTargetParamPtrs struct {
	ctx          *context.Context
	productionKB **mm_repository.KnowledgeBaseModel
}

// RepositoryMockGetDualProcessingTargetResults contains results of the Repository.GetDualProcessingTarget
type RepositoryMockGetDualProcessingTargetResults struct {
	dp1 *mm_repository.DualProcessingTarget
	err error
}

// RepositoryMockGetDualProcessingTargetOrigins contains origins of expectations of the Repository.GetDualProcessingTarget
type RepositoryMockGetDualProcessingTargetExpectationOrigins struct {
	origin             string
	originCtx          string
	originProductionKB string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetDualProcessingTarget *mRepositoryMockGetDualProcessingTarget) Optional() *mRepositoryMockGetDualProcessingTarget {
	mmGetDualProcessingTarget.optional = true
	return mmGetDualProcessingTarget
}

// Expect sets up expected params for Repository.GetDualProcessingTarget
func (mmGetDualProcessingTarget *mRepositoryMockGetDualProcessingTarget) Expect(ctx context.Context, productionKB *mm_repository.KnowledgeBaseModel) *mRepositoryMockGetDualProcessingTarget {
	if mmGetDualProcessingTarget.mock.funcGetDualProcessingTarget != nil {
		mmGetDualProcessingTarget.mock.t.Fatalf("RepositoryMock.GetDualProcessingTarget mock is already set by Set")
	}

	if mmGetDualProcessingTarget.defaultExpectation == nil {
		mmGetDualProcessingTarget.defaultExpectation = &RepositoryMockGetDualProcessingTargetExpectation{}
	}

	if mmGetDualProcessingTarget.defaultExpectation.paramPtrs != nil {
		mmGetDualProcessingTarget.mock.t.Fatalf("RepositoryMock.GetDualProcessingTarget mock is already set by ExpectParams functions")
	}

	mmGetDualProcessingTarget.defaultExpectation.params = &RepositoryMockGetDualProcessingTargetParams{ctx, productionKB}
	mmGetDualProcessingTarget.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetDualProcessingTarget.expectations {
		if minimock.Equal(e.params, mmGetDualProcessingTarget.defaultExpectation.params) {
			mmGetDualProcessingTarget.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetDualProcessingTarget.defaultExpectation.params)
		}
	}

	return mmGetDualProcessingTarget
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetDualProcessingTarget
func (mmGetDualProcessingTarget *mRepositoryMockGetDualProcessingTarget) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetDualProcessingTarget {
	if mmGetDualProcessingTarget.mock.funcGetDualProcessingTarget != nil {
		mmGetDualProcessingTarget.mock.t.Fatalf("RepositoryMock.GetDualProcessingTarget mock is already set by Set")
	}

	if mmGetDualProcessingTarget.defaultExpectation == nil {
		mmGetDualProcessingTarget.defaultExpectation = &RepositoryMockGetDualProcessingTargetExpectation{}
	}

	if mmGetDualProcessingTarget.defaultExpectation.params != nil {
		mmGetDualProcessingTarget.mock.t.Fatalf("RepositoryMock.GetDualProcessingTarget mock is already set by Expect")
	}

	if mmGetDualProcessingTarget.defaultExpectation.paramPtrs == nil {
		mmGetDualProcessingTarget.defaultExpectation.paramPtrs = &RepositoryMockGetDualProcessingTargetParamPtrs{}
	}
	mmGetDualProcessingTarget.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetDualProcessingTarget.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetDualProcessingTarget
}

// ExpectProductionKBParam2 sets up expected param productionKB for Repository.GetDualProcessingTarget
func (mmGetDualProcessingTarget *mRepositoryMockGetDualProcessingTarget) ExpectProductionKBParam2(productionKB *mm_repository.KnowledgeBaseModel) *mRepositoryMockGetDualProcessingTarget {
	if mmGetDualProcessingTarget.mock.funcGetDualProcessingTarget != nil {
		mmGetDualProcessingTarget.mock.t.Fatalf("RepositoryMock.GetDualProcessingTarget mock is already set by Set")
	}

	if mmGetDualProcessingTarget.defaultExpectation == nil {
		mmGetDualProcessingTarget.defaultExpectation = &RepositoryMockGetDualProcessingTargetExpectation{}
	}

	if mmGetDualProcessingTarget.defaultExpectation.params != nil {
		mmGetDualProcessingTarget.mock.t.Fatalf("RepositoryMock.GetDualProcessingTarget mock is already set by Expect")
	}

	if mmGetDualProcessingTarget.defaultExpectation.paramPtrs == nil {
		mmGetDualProcessingTarget.defaultExpectation.paramPtrs = &RepositoryMockGetDualProcessingTargetParamPtrs{}
	}
	mmGetDualProcessingTarget.defaultExpectation.paramPtrs.productionKB = &productionKB
	mmGetDualProcessingTarget.defaultExpectation.expectationOrigins.originProductionKB = minimock.CallerInfo(1)

	return mmGetDualProcessingTarget
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetDualProcessingTarget
func (mmGetDualProcessingTarget *mRepositoryMockGetDualProcessingTarget) Inspect(f func(ctx context.Context, productionKB *mm_repository.KnowledgeBaseModel)) *mRepositoryMockGetDualProcessingTarget {
	if mmGetDualProcessingTarget.mock.inspectFuncGetDualProcessingTarget != nil {
		mmGetDualProcessingTarget.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetDualProcessingTarget")
	}

	mmGetDualProcessingTarget.mock.inspectFuncGetDualProcessingTarget = f

	return mmGetDualProcessingTarget
}

// Return sets up results that will be returned by Repository.GetDualProcessingTarget
func (mmGetDualProcessingTarget *mRepositoryMockGetDualProcessingTarget) Return(dp1 *mm_repository.DualProcessingTarget, err error) *RepositoryMock {
	if mmGetDualProcessingTarget.mock.funcGetDualProcessingTarget != nil {
		mmGetDualProcessingTarget.mock.t.Fatalf("RepositoryMock.GetDualProcessingTarget mock is already set by Set")
	}

	if mmGetDualProcessingTarget.defaultExpectation == nil {
		mmGetDualProcessingTarget.defaultExpectation = &RepositoryMockGetDualProcessingTargetExpectation{mock: mmGetDualProcessingTarget.mock}
	}
	mmGetDualProcessingTarget.defaultExpectation.results = &RepositoryMockGetDualProcessingTargetResults{dp1, err}
	mmGetDualProcessingTarget.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetDualProcessingTarget.mock
}

// Set uses given function f to mock the Repository.GetDualProcessingTarget method
func (mmGetDualProcessingTarget *mRepositoryMockGetDualProcessingTarget) Set(f func(ctx context.Context, productionKB *mm_repository.KnowledgeBaseModel) (dp1 *mm_repository.DualProcessingTarget, err error)) *RepositoryMock {
	if mmGetDualProcessingTarget.defaultExpectation != nil {
		mmGetDualProcessingTarget.mock.t.Fatalf("Default expectation is already set for the Repository.GetDualProcessingTarget method")
	}

	if len(mmGetDualProcessingTarget.expectations) > 0 {
		mmGetDualProcessingTarget.mock.t.Fatalf("Some expectations are already set for the Repository.GetDualProcessingTarget method")
	}

	mmGetDualProcessingTarget.mock.funcGetDualProcessingTarget = f
	mmGetDualProcessingTarget.mock.funcGetDualProcessingTargetOrigin = minimock.CallerInfo(1)
	return mmGetDualProcessingTarget.mock
}

// When sets expectation for the Repository.GetDualProcessingTarget which will trigger the result defined by the following
// Then helper
func (mmGetDualProcessingTarget *mRepositoryMockGetDualProcessingTarget) When(ctx context.Context, productionKB *mm_repository.KnowledgeBaseModel) *RepositoryMockGetDualProcessingTargetExpectation {
	if mmGetDualProcessingTarget.mock.funcGetDualProcessingTarget != nil {
		mmGetDualProcessingTarget.mock.t.Fatalf("RepositoryMock.GetDualProcessingTarget mock is already set by Set")
	}

	expectation := &RepositoryMockGetDualProcessingTargetExpectation{
		mock:               mmGetDualProcessingTarget.mock,
		params:             &RepositoryMockGetDualProcessingTargetParams{ctx, productionKB},
		expectationOrigins: RepositoryMockGetDualProcessingTargetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetDualProcessingTarget.expectations = append(mmGetDualProcessingTarget.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetDualProcessingTarget return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetDualProcessingTargetExpectation) Then(dp1 *mm_repository.DualProcessingTarget, err error) *RepositoryMock {
	e.results = &RepositoryMockGetDualProcessingTargetResults{dp1, err}
	return e.mock
}

// Times sets number of times Repository.GetDualProcessingTarget should be invoked
func (mmGetDualProcessingTarget *mRepositoryMockGetDualProcessingTarget) Times(n uint64) *mRepositoryMockGetDualProcessingTarget {
	if n == 0 {
		mmGetDualProcessingTarget.mock.t.Fatalf("Times of RepositoryMock.GetDualProcessingTarget mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetDualProcessingTarget.expectedInvocations, n)
	mmGetDualProcessingTarget.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetDualProcessingTarget
}

func (mmGetDualProcessingTarget *mRepositoryMockGetDualProcessingTarget) invocationsDone() bool {
	if len(mmGetDualProcessingTarget.expectations) == 0 && mmGetDualProcessingTarget.defaultExpectation == nil && mmGetDualProcessingTarget.mock.funcGetDualProcessingTarget == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetDualProcessingTarget.mock.afterGetDualProcessingTargetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetDualProcessingTarget.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetDualProcessingTarget implements mm_repository.Repository
func (mmGetDualProcessingTarget *RepositoryMock) GetDualProcessingTarget(ctx context.Context, productionKB *mm_repository.KnowledgeBaseModel) (dp1 *mm_repository.DualProcessingTarget, err error) {
	mm_atomic.AddUint64(&mmGetDualProcessingTarget.beforeGetDualProcessingTargetCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDualProcessingTarget.afterGetDualProcessingTargetCounter, 1)

	mmGetDualProcessingTarget.t.Helper()

	if mmGetDualProcessingTarget.inspectFuncGetDualProcessingTarget != nil {
		mmGetDualProcessingTarget.inspectFuncGetDualProcessingTarget(ctx, productionKB)
	}

	mm_params := RepositoryMockGetDualProcessingTargetParams{ctx, productionKB}

	// Record call args
	mmGetDualProcessingTarget.GetDualProcessingTargetMock.mutex.Lock()
	mmGetDualProcessingTarget.GetDualProcessingTargetMock.callArgs = append(mmGetDualProcessingTarget.GetDualProcessingTargetMock.callArgs, &mm_params)
	mmGetDualProcessingTarget.GetDualProcessingTargetMock.mutex.Unlock()

	for _, e := range mmGetDualProcessingTarget.GetDualProcessingTargetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp1, e.results.err
		}
	}

	if mmGetDualProcessingTarget.GetDualProcessingTargetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDualProcessingTarget.GetDualProcessingTargetMock.defaultExpectation.Counter, 1)
		mm_want := mmGetDualProcessingTarget.GetDualProcessingTargetMock.defaultExpectation.params
		mm_want_ptrs := mmGetDualProcessingTarget.GetDualProcessingTargetMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetDualProcessingTargetParams{ctx, productionKB}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetDualProcessingTarget.t.Errorf("RepositoryMock.GetDualProcessingTarget got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetDualProcessingTarget.GetDualProcessingTargetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.productionKB != nil && !minimock.Equal(*mm_want_ptrs.productionKB, mm_got.productionKB) {
				mmGetDualProcessingTarget.t.Errorf("RepositoryMock.GetDualProcessingTarget got unexpected parameter productionKB, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetDualProcessingTarget.GetDualProcessingTargetMock.defaultExpectation.expectationOrigins.originProductionKB, *mm_want_ptrs.productionKB, mm_got.productionKB, minimock.Diff(*mm_want_ptrs.productionKB, mm_got.productionKB))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetDualProcessingTarget.t.Errorf("RepositoryMock.GetDualProcessingTarget got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetDualProcessingTarget.GetDualProcessingTargetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetDualProcessingTarget.GetDualProcessingTargetMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDualProcessingTarget.t.Fatal("No results are set for the RepositoryMock.GetDualProcessingTarget")
		}
		return (*mm_results).dp1, (*mm_results).err
	}
	if mmGetDualProcessingTarget.funcGetDualProcessingTarget != nil {
		return mmGetDualProcessingTarget.funcGetDualProcessingTarget(ctx, productionKB)
	}
	mmGetDualProcessingTarget.t.Fatalf("Unexpected call to RepositoryMock.GetDualProcessingTarget. %v %v", ctx, productionKB)
	return
}

// GetDualProcessingTargetAfterCounter returns a count of finished RepositoryMock.GetDualProcessingTarget invocations
func (mmGetDualProcessingTarget *RepositoryMock) GetDualProcessingTargetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDualProcessingTarget.afterGetDualProcessingTargetCounter)
}

// GetDualProcessingTargetBeforeCounter returns a count of RepositoryMock.GetDualProcessingTarget invocations
func (mmGetDualProcessingTarget *RepositoryMock) GetDualProcessingTargetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDualProcessingTarget.beforeGetDualProcessingTargetCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetDualProcessingTarget.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetDualProcessingTarget *mRepositoryMockGetDualProcessingTarget) Calls() []*RepositoryMockGetDualProcessingTargetParams {
	mmGetDualProcessingTarget.mutex.RLock()

	argCopy := make([]*RepositoryMockGetDualProcessingTargetParams, len(mmGetDualProcessingTarget.callArgs))
	copy(argCopy, mmGetDualProcessingTarget.callArgs)

	mmGetDualProcessingTarget.mutex.RUnlock()

	return argCopy
}

// MinimockGetDualProcessingTargetDone returns true if the count of the GetDualProcessingTarget invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetDualProcessingTargetDone() bool {
	if m.GetDualProcessingTargetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetDualProcessingTargetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetDualProcessingTargetMock.invocationsDone()
}

// MinimockGetDualProcessingTargetInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetDualProcessingTargetInspect() {
	for _, e := range m.GetDualProcessingTargetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetDualProcessingTarget at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetDualProcessingTargetCounter := mm_atomic.LoadUint64(&m.afterGetDualProcessingTargetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetDualProcessingTargetMock.defaultExpectation != nil && afterGetDualProcessingTargetCounter < 1 {
		if m.GetDualProcessingTargetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetDualProcessingTarget at\n%s", m.GetDualProcessingTargetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetDualProcessingTarget at\n%s with params: %#v", m.GetDualProcessingTargetMock.defaultExpectation.expectationOrigins.origin, *m.GetDualProcessingTargetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDualProcessingTarget != nil && afterGetDualProcessingTargetCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetDualProcessingTarget at\n%s", m.funcGetDualProcessingTargetOrigin)
	}

	if !m.GetDualProcessingTargetMock.invocationsDone() && afterGetDualProcessingTargetCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetDualProcessingTarget at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetDualProcessingTargetMock.expectedInvocations), m.GetDualProcessingTargetMock.expectedInvocationsOrigin, afterGetDualProcessingTargetCounter)
	}
}

type mRepositoryMockGetEmbeddingCountByKBUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetEmbeddingCountByKBUIDExpectation
	expectations       []*RepositoryMockGetEmbeddingCountByKBUIDExpectation

	callArgs []*RepositoryMockGetEmbeddingCountByKBUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetEmbeddingCountByKBUIDExpectation specifies expectation struct of the Repository.GetEmbeddingCountByKBUID
type RepositoryMockGetEmbeddingCountByKBUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetEmbeddingCountByKBUIDParams
	paramPtrs          *RepositoryMockGetEmbeddingCountByKBUIDParamPtrs
	expectationOrigins RepositoryMockGetEmbeddingCountByKBUIDExpectationOrigins
	results            *RepositoryMockGetEmbeddingCountByKBUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetEmbeddingCountByKBUIDParams contains parameters of the Repository.GetEmbeddingCountByKBUID
type RepositoryMockGetEmbeddingCountByKBUIDParams struct {
	ctx   context.Context
	kbUID types.KBUIDType
}

// RepositoryMockGetEmbeddingCountByKBUIDParamPtrs contains pointers to parameters of the Repository.GetEmbeddingCountByKBUID
type RepositoryMockGetEmbeddingCountByKBUIDParamPtrs struct {
	ctx   *context.Context
	kbUID *types.KBUIDType
}

// RepositoryMockGetEmbeddingCountByKBUIDResults contains results of the Repository.GetEmbeddingCountByKBUID
type RepositoryMockGetEmbeddingCountByKBUIDResults struct {
	i1  int64
	err error
}

// RepositoryMockGetEmbeddingCountByKBUIDOrigins contains origins of expectations of the Repository.GetEmbeddingCountByKBUID
type RepositoryMockGetEmbeddingCountByKBUIDExpectationOrigins struct {
	origin      string
	originCtx   string
	originKbUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetEmbeddingCountByKBUID *mRepositoryMockGetEmbeddingCountByKBUID) Optional() *mRepositoryMockGetEmbeddingCountByKBUID {
	mmGetEmbeddingCountByKBUID.optional = true
	return mmGetEmbeddingCountByKBUID
}

// Expect sets up expected params for Repository.GetEmbeddingCountByKBUID
func (mmGetEmbeddingCountByKBUID *mRepositoryMockGetEmbeddingCountByKBUID) Expect(ctx context.Context, kbUID types.KBUIDType) *mRepositoryMockGetEmbeddingCountByKBUID {
	if mmGetEmbeddingCountByKBUID.mock.funcGetEmbeddingCountByKBUID != nil {
		mmGetEmbeddingCountByKBUID.mock.t.Fatalf("RepositoryMock.GetEmbeddingCountByKBUID mock is already set by Set")
	}

	if mmGetEmbeddingCountByKBUID.defaultExpectation == nil {
		mmGetEmbeddingCountByKBUID.defaultExpectation = &RepositoryMockGetEmbeddingCountByKBUIDExpectation{}
	}

	if mmGetEmbeddingCountByKBUID.defaultExpectation.paramPtrs != nil {
		mmGetEmbeddingCountByKBUID.mock.t.Fatalf("RepositoryMock.GetEmbeddingCountByKBUID mock is already set by ExpectParams functions")
	}

	mmGetEmbeddingCountByKBUID.defaultExpectation.params = &RepositoryMockGetEmbeddingCountByKBUIDParams{ctx, kbUID}
	mmGetEmbeddingCountByKBUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetEmbeddingCountByKBUID.expectations {
		if minimock.Equal(e.params, mmGetEmbeddingCountByKBUID.defaultExpectation.params) {
			mmGetEmbeddingCountByKBUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetEmbeddingCountByKBUID.defaultExpectation.params)
		}
	}

	return mmGetEmbeddingCountByKBUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetEmbeddingCountByKBUID
func (mmGetEmbeddingCountByKBUID *mRepositoryMockGetEmbeddingCountByKBUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetEmbeddingCountByKBUID {
	if mmGetEmbeddingCountByKBUID.mock.funcGetEmbeddingCountByKBUID != nil {
		mmGetEmbeddingCountByKBUID.mock.t.Fatalf("RepositoryMock.GetEmbeddingCountByKBUID mock is already set by Set")
	}

	if mmGetEmbeddingCountByKBUID.defaultExpectation == nil {
		mmGetEmbeddingCountByKBUID.defaultExpectation = &RepositoryMockGetEmbeddingCountByKBUIDExpectation{}
	}

	if mmGetEmbeddingCountByKBUID.defaultExpectation.params != nil {
		mmGetEmbeddingCountByKBUID.mock.t.Fatalf("RepositoryMock.GetEmbeddingCountByKBUID mock is already set by Expect")
	}

	if mmGetEmbeddingCountByKBUID.defaultExpectation.paramPtrs == nil {
		mmGetEmbeddingCountByKBUID.defaultExpectation.paramPtrs = &RepositoryMockGetEmbeddingCountByKBUIDParamPtrs{}
	}
	mmGetEmbeddingCountByKBUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetEmbeddingCountByKBUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetEmbeddingCountByKBUID
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.GetEmbeddingCountByKBUID
func (mmGetEmbeddingCountByKBUID *mRepositoryMockGetEmbeddingCountByKBUID) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockGetEmbeddingCountByKBUID {
	if mmGetEmbeddingCountByKBUID.mock.funcGetEmbeddingCountByKBUID != nil {
		mmGetEmbeddingCountByKBUID.mock.t.Fatalf("RepositoryMock.GetEmbeddingCountByKBUID mock is already set by Set")
	}

	if mmGetEmbeddingCountByKBUID.defaultExpectation == nil {
		mmGetEmbeddingCountByKBUID.defaultExpectation = &RepositoryMockGetEmbeddingCountByKBUIDExpectation{}
	}

	if mmGetEmbeddingCountByKBUID.defaultExpectation.params != nil {
		mmGetEmbeddingCountByKBUID.mock.t.Fatalf("RepositoryMock.GetEmbeddingCountByKBUID mock is already set by Expect")
	}

	if mmGetEmbeddingCountByKBUID.defaultExpectation.paramPtrs == nil {
		mmGetEmbeddingCountByKBUID.defaultExpectation.paramPtrs = &RepositoryMockGetEmbeddingCountByKBUIDParamPtrs{}
	}
	mmGetEmbeddingCountByKBUID.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmGetEmbeddingCountByKBUID.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmGetEmbeddingCountByKBUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetEmbeddingCountByKBUID
func (mmGetEmbeddingCountByKBUID *mRepositoryMockGetEmbeddingCountByKBUID) Inspect(f func(ctx context.Context, kbUID types.KBUIDType)) *mRepositoryMockGetEmbeddingCountByKBUID {
	if mmGetEmbeddingCountByKBUID.mock.inspectFuncGetEmbeddingCountByKBUID != nil {
		mmGetEmbeddingCountByKBUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetEmbeddingCountByKBUID")
	}

	mmGetEmbeddingCountByKBUID.mock.inspectFuncGetEmbeddingCountByKBUID = f

	return mmGetEmbeddingCountByKBUID
}

// Return sets up results that will be returned by Repository.GetEmbeddingCountByKBUID
func (mmGetEmbeddingCountByKBUID *mRepositoryMockGetEmbeddingCountByKBUID) Return(i1 int64, err error) *RepositoryMock {
	if mmGetEmbeddingCountByKBUID.mock.funcGetEmbeddingCountByKBUID != nil {
		mmGetEmbeddingCountByKBUID.mock.t.Fatalf("RepositoryMock.GetEmbeddingCountByKBUID mock is already set by Set")
	}

	if mmGetEmbeddingCountByKBUID.defaultExpectation == nil {
		mmGetEmbeddingCountByKBUID.defaultExpectation = &RepositoryMockGetEmbeddingCountByKBUIDExpectation{mock: mmGetEmbeddingCountByKBUID.mock}
	}
	mmGetEmbeddingCountByKBUID.defaultExpectation.results = &RepositoryMockGetEmbeddingCountByKBUIDResults{i1, err}
	mmGetEmbeddingCountByKBUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetEmbeddingCountByKBUID.mock
}

// Set uses given function f to mock the Repository.GetEmbeddingCountByKBUID method
func (mmGetEmbeddingCountByKBUID *mRepositoryMockGetEmbeddingCountByKBUID) Set(f func(ctx context.Context, kbUID types.KBUIDType) (i1 int64, err error)) *RepositoryMock {
	if mmGetEmbeddingCountByKBUID.defaultExpectation != nil {
		mmGetEmbeddingCountByKBUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetEmbeddingCountByKBUID method")
	}

	if len(mmGetEmbeddingCountByKBUID.expectations) > 0 {
		mmGetEmbeddingCountByKBUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetEmbeddingCountByKBUID method")
	}

	mmGetEmbeddingCountByKBUID.mock.funcGetEmbeddingCountByKBUID = f
	mmGetEmbeddingCountByKBUID.mock.funcGetEmbeddingCountByKBUIDOrigin = minimock.CallerInfo(1)
	return mmGetEmbeddingCountByKBUID.mock
}

// When sets expectation for the Repository.GetEmbeddingCountByKBUID which will trigger the result defined by the following
// Then helper
func (mmGetEmbeddingCountByKBUID *mRepositoryMockGetEmbeddingCountByKBUID) When(ctx context.Context, kbUID types.KBUIDType) *RepositoryMockGetEmbeddingCountByKBUIDExpectation {
	if mmGetEmbeddingCountByKBUID.mock.funcGetEmbeddingCountByKBUID != nil {
		mmGetEmbeddingCountByKBUID.mock.t.Fatalf("RepositoryMock.GetEmbeddingCountByKBUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetEmbeddingCountByKBUIDExpectation{
		mock:               mmGetEmbeddingCountByKBUID.mock,
		params:             &RepositoryMockGetEmbeddingCountByKBUIDParams{ctx, kbUID},
		expectationOrigins: RepositoryMockGetEmbeddingCountByKBUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetEmbeddingCountByKBUID.expectations = append(mmGetEmbeddingCountByKBUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetEmbeddingCountByKBUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetEmbeddingCountByKBUIDExpectation) Then(i1 int64, err error) *RepositoryMock {
	e.results = &RepositoryMockGetEmbeddingCountByKBUIDResults{i1, err}
	return e.mock
}

// Times sets number of times Repository.GetEmbeddingCountByKBUID should be invoked
func (mmGetEmbeddingCountByKBUID *mRepositoryMockGetEmbeddingCountByKBUID) Times(n uint64) *mRepositoryMockGetEmbeddingCountByKBUID {
	if n == 0 {
		mmGetEmbeddingCountByKBUID.mock.t.Fatalf("Times of RepositoryMock.GetEmbeddingCountByKBUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetEmbeddingCountByKBUID.expectedInvocations, n)
	mmGetEmbeddingCountByKBUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetEmbeddingCountByKBUID
}

func (mmGetEmbeddingCountByKBUID *mRepositoryMockGetEmbeddingCountByKBUID) invocationsDone() bool {
	if len(mmGetEmbeddingCountByKBUID.expectations) == 0 && mmGetEmbeddingCountByKBUID.defaultExpectation == nil && mmGetEmbeddingCountByKBUID.mock.funcGetEmbeddingCountByKBUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetEmbeddingCountByKBUID.mock.afterGetEmbeddingCountByKBUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetEmbeddingCountByKBUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetEmbeddingCountByKBUID implements mm_repository.Repository
func (mmGetEmbeddingCountByKBUID *RepositoryMock) GetEmbeddingCountByKBUID(ctx context.Context, kbUID types.KBUIDType) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetEmbeddingCountByKBUID.beforeGetEmbeddingCountByKBUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetEmbeddingCountByKBUID.afterGetEmbeddingCountByKBUIDCounter, 1)

	mmGetEmbeddingCountByKBUID.t.Helper()

	if mmGetEmbeddingCountByKBUID.inspectFuncGetEmbeddingCountByKBUID != nil {
		mmGetEmbeddingCountByKBUID.inspectFuncGetEmbeddingCountByKBUID(ctx, kbUID)
	}

	mm_params := RepositoryMockGetEmbeddingCountByKBUIDParams{ctx, kbUID}

	// Record call args
	mmGetEmbeddingCountByKBUID.GetEmbeddingCountByKBUIDMock.mutex.Lock()
	mmGetEmbeddingCountByKBUID.GetEmbeddingCountByKBUIDMock.callArgs = append(mmGetEmbeddingCountByKBUID.GetEmbeddingCountByKBUIDMock.callArgs, &mm_params)
	mmGetEmbeddingCountByKBUID.GetEmbeddingCountByKBUIDMock.mutex.Unlock()

	for _, e := range mmGetEmbeddingCountByKBUID.GetEmbeddingCountByKBUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetEmbeddingCountByKBUID.GetEmbeddingCountByKBUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetEmbeddingCountByKBUID.GetEmbeddingCountByKBUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetEmbeddingCountByKBUID.GetEmbeddingCountByKBUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetEmbeddingCountByKBUID.GetEmbeddingCountByKBUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetEmbeddingCountByKBUIDParams{ctx, kbUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetEmbeddingCountByKBUID.t.Errorf("RepositoryMock.GetEmbeddingCountByKBUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetEmbeddingCountByKBUID.GetEmbeddingCountByKBUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmGetEmbeddingCountByKBUID.t.Errorf("RepositoryMock.GetEmbeddingCountByKBUID got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetEmbeddingCountByKBUID.GetEmbeddingCountByKBUIDMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetEmbeddingCountByKBUID.t.Errorf("RepositoryMock.GetEmbeddingCountByKBUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetEmbeddingCountByKBUID.GetEmbeddingCountByKBUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetEmbeddingCountByKBUID.GetEmbeddingCountByKBUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetEmbeddingCountByKBUID.t.Fatal("No results are set for the RepositoryMock.GetEmbeddingCountByKBUID")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetEmbeddingCountByKBUID.funcGetEmbeddingCountByKBUID != nil {
		return mmGetEmbeddingCountByKBUID.funcGetEmbeddingCountByKBUID(ctx, kbUID)
	}
	mmGetEmbeddingCountByKBUID.t.Fatalf("Unexpected call to RepositoryMock.GetEmbeddingCountByKBUID. %v %v", ctx, kbUID)
	return
}

// GetEmbeddingCountByKBUIDAfterCounter returns a count of finished RepositoryMock.GetEmbeddingCountByKBUID invocations
func (mmGetEmbeddingCountByKBUID *RepositoryMock) GetEmbeddingCountByKBUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEmbeddingCountByKBUID.afterGetEmbeddingCountByKBUIDCounter)
}

// GetEmbeddingCountByKBUIDBeforeCounter returns a count of RepositoryMock.GetEmbeddingCountByKBUID invocations
func (mmGetEmbeddingCountByKBUID *RepositoryMock) GetEmbeddingCountByKBUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEmbeddingCountByKBUID.beforeGetEmbeddingCountByKBUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetEmbeddingCountByKBUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetEmbeddingCountByKBUID *mRepositoryMockGetEmbeddingCountByKBUID) Calls() []*RepositoryMockGetEmbeddingCountByKBUIDParams {
	mmGetEmbeddingCountByKBUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetEmbeddingCountByKBUIDParams, len(mmGetEmbeddingCountByKBUID.callArgs))
	copy(argCopy, mmGetEmbeddingCountByKBUID.callArgs)

	mmGetEmbeddingCountByKBUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetEmbeddingCountByKBUIDDone returns true if the count of the GetEmbeddingCountByKBUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetEmbeddingCountByKBUIDDone() bool {
	if m.GetEmbeddingCountByKBUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetEmbeddingCountByKBUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetEmbeddingCountByKBUIDMock.invocationsDone()
}

// MinimockGetEmbeddingCountByKBUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetEmbeddingCountByKBUIDInspect() {
	for _, e := range m.GetEmbeddingCountByKBUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetEmbeddingCountByKBUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetEmbeddingCountByKBUIDCounter := mm_atomic.LoadUint64(&m.afterGetEmbeddingCountByKBUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetEmbeddingCountByKBUIDMock.defaultExpectation != nil && afterGetEmbeddingCountByKBUIDCounter < 1 {
		if m.GetEmbeddingCountByKBUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetEmbeddingCountByKBUID at\n%s", m.GetEmbeddingCountByKBUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetEmbeddingCountByKBUID at\n%s with params: %#v", m.GetEmbeddingCountByKBUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetEmbeddingCountByKBUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetEmbeddingCountByKBUID != nil && afterGetEmbeddingCountByKBUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetEmbeddingCountByKBUID at\n%s", m.funcGetEmbeddingCountByKBUIDOrigin)
	}

	if !m.GetEmbeddingCountByKBUIDMock.invocationsDone() && afterGetEmbeddingCountByKBUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetEmbeddingCountByKBUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetEmbeddingCountByKBUIDMock.expectedInvocations), m.GetEmbeddingCountByKBUIDMock.expectedInvocationsOrigin, afterGetEmbeddingCountByKBUIDCounter)
	}
}

type mRepositoryMockGetFileByIDOrAlias struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetFileByIDOrAliasExpectation
	expectations       []*RepositoryMockGetFileByIDOrAliasExpectation

	callArgs []*RepositoryMockGetFileByIDOrAliasParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetFileByIDOrAliasExpectation specifies expectation struct of the Repository.GetFileByIDOrAlias
type RepositoryMockGetFileByIDOrAliasExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetFileByIDOrAliasParams
	paramPtrs          *RepositoryMockGetFileByIDOrAliasParamPtrs
	expectationOrigins RepositoryMockGetFileByIDOrAliasExpectationOrigins
	results            *RepositoryMockGetFileByIDOrAliasResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetFileByIDOrAliasParams contains parameters of the Repository.GetFileByIDOrAlias
type RepositoryMockGetFileByIDOrAliasParams struct {
	ctx   context.Context
	kbUID types.KBUIDType
	id    string
}

// RepositoryMockGetFileByIDOrAliasParamPtrs contains pointers to parameters of the Repository.GetFileByIDOrAlias
type RepositoryMockGetFileByIDOrAliasParamPtrs struct {
	ctx   *context.Context
	kbUID *types.KBUIDType
	id    *string
}

// RepositoryMockGetFileByIDOrAliasResults contains results of the Repository.GetFileByIDOrAlias
type RepositoryMockGetFileByIDOrAliasResults struct {
	kp1 *mm_repository.KnowledgeBaseFileModel
	err error
}

// RepositoryMockGetFileByIDOrAliasOrigins contains origins of expectations of the Repository.GetFileByIDOrAlias
type RepositoryMockGetFileByIDOrAliasExpectationOrigins struct {
	origin      string
	originCtx   string
	originKbUID string
	originId    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFileByIDOrAlias *mRepositoryMockGetFileByIDOrAlias) Optional() *mRepositoryMockGetFileByIDOrAlias {
	mmGetFileByIDOrAlias.optional = true
	return mmGetFileByIDOrAlias
}

// Expect sets up expected params for Repository.GetFileByIDOrAlias
func (mmGetFileByIDOrAlias *mRepositoryMockGetFileByIDOrAlias) Expect(ctx context.Context, kbUID types.KBUIDType, id string) *mRepositoryMockGetFileByIDOrAlias {
	if mmGetFileByIDOrAlias.mock.funcGetFileByIDOrAlias != nil {
		mmGetFileByIDOrAlias.mock.t.Fatalf("RepositoryMock.GetFileByIDOrAlias mock is already set by Set")
	}

	if mmGetFileByIDOrAlias.defaultExpectation == nil {
		mmGetFileByIDOrAlias.defaultExpectation = &RepositoryMockGetFileByIDOrAliasExpectation{}
	}

	if mmGetFileByIDOrAlias.defaultExpectation.paramPtrs != nil {
		mmGetFileByIDOrAlias.mock.t.Fatalf("RepositoryMock.GetFileByIDOrAlias mock is already set by ExpectParams functions")
	}

	mmGetFileByIDOrAlias.defaultExpectation.params = &RepositoryMockGetFileByIDOrAliasParams{ctx, kbUID, id}
	mmGetFileByIDOrAlias.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetFileByIDOrAlias.expectations {
		if minimock.Equal(e.params, mmGetFileByIDOrAlias.defaultExpectation.params) {
			mmGetFileByIDOrAlias.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFileByIDOrAlias.defaultExpectation.params)
		}
	}

	return mmGetFileByIDOrAlias
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetFileByIDOrAlias
func (mmGetFileByIDOrAlias *mRepositoryMockGetFileByIDOrAlias) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetFileByIDOrAlias {
	if mmGetFileByIDOrAlias.mock.funcGetFileByIDOrAlias != nil {
		mmGetFileByIDOrAlias.mock.t.Fatalf("RepositoryMock.GetFileByIDOrAlias mock is already set by Set")
	}

	if mmGetFileByIDOrAlias.defaultExpectation == nil {
		mmGetFileByIDOrAlias.defaultExpectation = &RepositoryMockGetFileByIDOrAliasExpectation{}
	}

	if mmGetFileByIDOrAlias.defaultExpectation.params != nil {
		mmGetFileByIDOrAlias.mock.t.Fatalf("RepositoryMock.GetFileByIDOrAlias mock is already set by Expect")
	}

	if mmGetFileByIDOrAlias.defaultExpectation.paramPtrs == nil {
		mmGetFileByIDOrAlias.defaultExpectation.paramPtrs = &RepositoryMockGetFileByIDOrAliasParamPtrs{}
	}
	mmGetFileByIDOrAlias.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetFileByIDOrAlias.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetFileByIDOrAlias
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.GetFileByIDOrAlias
func (mmGetFileByIDOrAlias *mRepositoryMockGetFileByIDOrAlias) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockGetFileByIDOrAlias {
	if mmGetFileByIDOrAlias.mock.funcGetFileByIDOrAlias != nil {
		mmGetFileByIDOrAlias.mock.t.Fatalf("RepositoryMock.GetFileByIDOrAlias mock is already set by Set")
	}

	if mmGetFileByIDOrAlias.defaultExpectation == nil {
		mmGetFileByIDOrAlias.defaultExpectation = &RepositoryMockGetFileByIDOrAliasExpectation{}
	}

	if mmGetFileByIDOrAlias.defaultExpectation.params != nil {
		mmGetFileByIDOrAlias.mock.t.Fatalf("RepositoryMock.GetFileByIDOrAlias mock is already set by Expect")
	}

	if mmGetFileByIDOrAlias.defaultExpectation.paramPtrs == nil {
		mmGetFileByIDOrAlias.defaultExpectation.paramPtrs = &RepositoryMockGetFileByIDOrAliasParamPtrs{}
	}
	mmGetFileByIDOrAlias.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmGetFileByIDOrAlias.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmGetFileByIDOrAlias
}

// ExpectIdParam3 sets up expected param id for Repository.GetFileByIDOrAlias
func (mmGetFileByIDOrAlias *mRepositoryMockGetFileByIDOrAlias) ExpectIdParam3(id string) *mRepositoryMockGetFileByIDOrAlias {
	if mmGetFileByIDOrAlias.mock.funcGetFileByIDOrAlias != nil {
		mmGetFileByIDOrAlias.mock.t.Fatalf("RepositoryMock.GetFileByIDOrAlias mock is already set by Set")
	}

	if mmGetFileByIDOrAlias.defaultExpectation == nil {
		mmGetFileByIDOrAlias.defaultExpectation = &RepositoryMockGetFileByIDOrAliasExpectation{}
	}

	if mmGetFileByIDOrAlias.defaultExpectation.params != nil {
		mmGetFileByIDOrAlias.mock.t.Fatalf("RepositoryMock.GetFileByIDOrAlias mock is already set by Expect")
	}

	if mmGetFileByIDOrAlias.defaultExpectation.paramPtrs == nil {
		mmGetFileByIDOrAlias.defaultExpectation.paramPtrs = &RepositoryMockGetFileByIDOrAliasParamPtrs{}
	}
	mmGetFileByIDOrAlias.defaultExpectation.paramPtrs.id = &id
	mmGetFileByIDOrAlias.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetFileByIDOrAlias
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetFileByIDOrAlias
func (mmGetFileByIDOrAlias *mRepositoryMockGetFileByIDOrAlias) Inspect(f func(ctx context.Context, kbUID types.KBUIDType, id string)) *mRepositoryMockGetFileByIDOrAlias {
	if mmGetFileByIDOrAlias.mock.inspectFuncGetFileByIDOrAlias != nil {
		mmGetFileByIDOrAlias.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetFileByIDOrAlias")
	}

	mmGetFileByIDOrAlias.mock.inspectFuncGetFileByIDOrAlias = f

	return mmGetFileByIDOrAlias
}

// Return sets up results that will be returned by Repository.GetFileByIDOrAlias
func (mmGetFileByIDOrAlias *mRepositoryMockGetFileByIDOrAlias) Return(kp1 *mm_repository.KnowledgeBaseFileModel, err error) *RepositoryMock {
	if mmGetFileByIDOrAlias.mock.funcGetFileByIDOrAlias != nil {
		mmGetFileByIDOrAlias.mock.t.Fatalf("RepositoryMock.GetFileByIDOrAlias mock is already set by Set")
	}

	if mmGetFileByIDOrAlias.defaultExpectation == nil {
		mmGetFileByIDOrAlias.defaultExpectation = &RepositoryMockGetFileByIDOrAliasExpectation{mock: mmGetFileByIDOrAlias.mock}
	}
	mmGetFileByIDOrAlias.defaultExpectation.results = &RepositoryMockGetFileByIDOrAliasResults{kp1, err}
	mmGetFileByIDOrAlias.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetFileByIDOrAlias.mock
}

// Set uses given function f to mock the Repository.GetFileByIDOrAlias method
func (mmGetFileByIDOrAlias *mRepositoryMockGetFileByIDOrAlias) Set(f func(ctx context.Context, kbUID types.KBUIDType, id string) (kp1 *mm_repository.KnowledgeBaseFileModel, err error)) *RepositoryMock {
	if mmGetFileByIDOrAlias.defaultExpectation != nil {
		mmGetFileByIDOrAlias.mock.t.Fatalf("Default expectation is already set for the Repository.GetFileByIDOrAlias method")
	}

	if len(mmGetFileByIDOrAlias.expectations) > 0 {
		mmGetFileByIDOrAlias.mock.t.Fatalf("Some expectations are already set for the Repository.GetFileByIDOrAlias method")
	}

	mmGetFileByIDOrAlias.mock.funcGetFileByIDOrAlias = f
	mmGetFileByIDOrAlias.mock.funcGetFileByIDOrAliasOrigin = minimock.CallerInfo(1)
	return mmGetFileByIDOrAlias.mock
}

// When sets expectation for the Repository.GetFileByIDOrAlias which will trigger the result defined by the following
// Then helper
func (mmGetFileByIDOrAlias *mRepositoryMockGetFileByIDOrAlias) When(ctx context.Context, kbUID types.KBUIDType, id string) *RepositoryMockGetFileByIDOrAliasExpectation {
	if mmGetFileByIDOrAlias.mock.funcGetFileByIDOrAlias != nil {
		mmGetFileByIDOrAlias.mock.t.Fatalf("RepositoryMock.GetFileByIDOrAlias mock is already set by Set")
	}

	expectation := &RepositoryMockGetFileByIDOrAliasExpectation{
		mock:               mmGetFileByIDOrAlias.mock,
		params:             &RepositoryMockGetFileByIDOrAliasParams{ctx, kbUID, id},
		expectationOrigins: RepositoryMockGetFileByIDOrAliasExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetFileByIDOrAlias.expectations = append(mmGetFileByIDOrAlias.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetFileByIDOrAlias return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetFileByIDOrAliasExpectation) Then(kp1 *mm_repository.KnowledgeBaseFileModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetFileByIDOrAliasResults{kp1, err}
	return e.mock
}

// Times sets number of times Repository.GetFileByIDOrAlias should be invoked
func (mmGetFileByIDOrAlias *mRepositoryMockGetFileByIDOrAlias) Times(n uint64) *mRepositoryMockGetFileByIDOrAlias {
	if n == 0 {
		mmGetFileByIDOrAlias.mock.t.Fatalf("Times of RepositoryMock.GetFileByIDOrAlias mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFileByIDOrAlias.expectedInvocations, n)
	mmGetFileByIDOrAlias.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetFileByIDOrAlias
}

func (mmGetFileByIDOrAlias *mRepositoryMockGetFileByIDOrAlias) invocationsDone() bool {
	if len(mmGetFileByIDOrAlias.expectations) == 0 && mmGetFileByIDOrAlias.defaultExpectation == nil && mmGetFileByIDOrAlias.mock.funcGetFileByIDOrAlias == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFileByIDOrAlias.mock.afterGetFileByIDOrAliasCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFileByIDOrAlias.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFileByIDOrAlias implements mm_repository.Repository
func (mmGetFileByIDOrAlias *RepositoryMock) GetFileByIDOrAlias(ctx context.Context, kbUID types.KBUIDType, id string) (kp1 *mm_repository.KnowledgeBaseFileModel, err error) {
	mm_atomic.AddUint64(&mmGetFileByIDOrAlias.beforeGetFileByIDOrAliasCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFileByIDOrAlias.afterGetFileByIDOrAliasCounter, 1)

	mmGetFileByIDOrAlias.t.Helper()

	if mmGetFileByIDOrAlias.inspectFuncGetFileByIDOrAlias != nil {
		mmGetFileByIDOrAlias.inspectFuncGetFileByIDOrAlias(ctx, kbUID, id)
	}

	mm_params := RepositoryMockGetFileByIDOrAliasParams{ctx, kbUID, id}

	// Record call args
	mmGetFileByIDOrAlias.GetFileByIDOrAliasMock.mutex.Lock()
	mmGetFileByIDOrAlias.GetFileByIDOrAliasMock.callArgs = append(mmGetFileByIDOrAlias.GetFileByIDOrAliasMock.callArgs, &mm_params)
	mmGetFileByIDOrAlias.GetFileByIDOrAliasMock.mutex.Unlock()

	for _, e := range mmGetFileByIDOrAlias.GetFileByIDOrAliasMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmGetFileByIDOrAlias.GetFileByIDOrAliasMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFileByIDOrAlias.GetFileByIDOrAliasMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFileByIDOrAlias.GetFileByIDOrAliasMock.defaultExpectation.params
		mm_want_ptrs := mmGetFileByIDOrAlias.GetFileByIDOrAliasMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetFileByIDOrAliasParams{ctx, kbUID, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFileByIDOrAlias.t.Errorf("RepositoryMock.GetFileByIDOrAlias got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFileByIDOrAlias.GetFileByIDOrAliasMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmGetFileByIDOrAlias.t.Errorf("RepositoryMock.GetFileByIDOrAlias got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFileByIDOrAlias.GetFileByIDOrAliasMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetFileByIDOrAlias.t.Errorf("RepositoryMock.GetFileByIDOrAlias got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFileByIDOrAlias.GetFileByIDOrAliasMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFileByIDOrAlias.t.Errorf("RepositoryMock.GetFileByIDOrAlias got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetFileByIDOrAlias.GetFileByIDOrAliasMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFileByIDOrAlias.GetFileByIDOrAliasMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFileByIDOrAlias.t.Fatal("No results are set for the RepositoryMock.GetFileByIDOrAlias")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmGetFileByIDOrAlias.funcGetFileByIDOrAlias != nil {
		return mmGetFileByIDOrAlias.funcGetFileByIDOrAlias(ctx, kbUID, id)
	}
	mmGetFileByIDOrAlias.t.Fatalf("Unexpected call to RepositoryMock.GetFileByIDOrAlias. %v %v %v", ctx, kbUID, id)
	return
}

// GetFileByIDOrAliasAfterCounter returns a count of finished RepositoryMock.GetFileByIDOrAlias invocations
func (mmGetFileByIDOrAlias *RepositoryMock) GetFileByIDOrAliasAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFileByIDOrAlias.afterGetFileByIDOrAliasCounter)
}

// GetFileByIDOrAliasBeforeCounter returns a count of RepositoryMock.GetFileByIDOrAlias invocations
func (mmGetFileByIDOrAlias *RepositoryMock) GetFileByIDOrAliasBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFileByIDOrAlias.beforeGetFileByIDOrAliasCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetFileByIDOrAlias.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFileByIDOrAlias *mRepositoryMockGetFileByIDOrAlias) Calls() []*RepositoryMockGetFileByIDOrAliasParams {
	mmGetFileByIDOrAlias.mutex.RLock()

	argCopy := make([]*RepositoryMockGetFileByIDOrAliasParams, len(mmGetFileByIDOrAlias.callArgs))
	copy(argCopy, mmGetFileByIDOrAlias.callArgs)

	mmGetFileByIDOrAlias.mutex.RUnlock()

	return argCopy
}

// MinimockGetFileByIDOrAliasDone returns true if the count of the GetFileByIDOrAlias invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetFileByIDOrAliasDone() bool {
	if m.GetFileByIDOrAliasMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFileByIDOrAliasMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFileByIDOrAliasMock.invocationsDone()
}

// MinimockGetFileByIDOrAliasInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetFileByIDOrAliasInspect() {
	for _, e := range m.GetFileByIDOrAliasMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetFileByIDOrAlias at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetFileByIDOrAliasCounter := mm_atomic.LoadUint64(&m.afterGetFileByIDOrAliasCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFileByIDOrAliasMock.defaultExpectation != nil && afterGetFileByIDOrAliasCounter < 1 {
		if m.GetFileByIDOrAliasMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetFileByIDOrAlias at\n%s", m.GetFileByIDOrAliasMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetFileByIDOrAlias at\n%s with params: %#v", m.GetFileByIDOrAliasMock.defaultExpectation.expectationOrigins.origin, *m.GetFileByIDOrAliasMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFileByIDOrAlias != nil && afterGetFileByIDOrAliasCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetFileByIDOrAlias at\n%s", m.funcGetFileByIDOrAliasOrigin)
	}

	if !m.GetFileByIDOrAliasMock.invocationsDone() && afterGetFileByIDOrAliasCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetFileByIDOrAlias at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetFileByIDOrAliasMock.expectedInvocations), m.GetFileByIDOrAliasMock.expectedInvocationsOrigin, afterGetFileByIDOrAliasCounter)
	}
}

type mRepositoryMockGetFileCountByKnowledgeBaseUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetFileCountByKnowledgeBaseUIDExpectation
	expectations       []*RepositoryMockGetFileCountByKnowledgeBaseUIDExpectation

	callArgs []*RepositoryMockGetFileCountByKnowledgeBaseUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetFileCountByKnowledgeBaseUIDExpectation specifies expectation struct of the Repository.GetFileCountByKnowledgeBaseUID
type RepositoryMockGetFileCountByKnowledgeBaseUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetFileCountByKnowledgeBaseUIDParams
	paramPtrs          *RepositoryMockGetFileCountByKnowledgeBaseUIDParamPtrs
	expectationOrigins RepositoryMockGetFileCountByKnowledgeBaseUIDExpectationOrigins
	results            *RepositoryMockGetFileCountByKnowledgeBaseUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetFileCountByKnowledgeBaseUIDParams contains parameters of the Repository.GetFileCountByKnowledgeBaseUID
type RepositoryMockGetFileCountByKnowledgeBaseUIDParams struct {
	ctx           context.Context
	kbUID         types.KBUIDType
	processStatus string
}

// RepositoryMockGetFileCountByKnowledgeBaseUIDParamPtrs contains pointers to parameters of the Repository.GetFileCountByKnowledgeBaseUID
type RepositoryMockGetFileCountByKnowledgeBaseUIDParamPtrs struct {
	ctx           *context.Context
	kbUID         *types.KBUIDType
	processStatus *string
}

// RepositoryMockGetFileCountByKnowledgeBaseUIDResults contains results of the Repository.GetFileCountByKnowledgeBaseUID
type RepositoryMockGetFileCountByKnowledgeBaseUIDResults struct {
	i1  int64
	err error
}

// RepositoryMockGetFileCountByKnowledgeBaseUIDOrigins contains origins of expectations of the Repository.GetFileCountByKnowledgeBaseUID
type RepositoryMockGetFileCountByKnowledgeBaseUIDExpectationOrigins struct {
	origin              string
	originCtx           string
	originKbUID         string
	originProcessStatus string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFileCountByKnowledgeBaseUID *mRepositoryMockGetFileCountByKnowledgeBaseUID) Optional() *mRepositoryMockGetFileCountByKnowledgeBaseUID {
	mmGetFileCountByKnowledgeBaseUID.optional = true
	return mmGetFileCountByKnowledgeBaseUID
}

// Expect sets up expected params for Repository.GetFileCountByKnowledgeBaseUID
func (mmGetFileCountByKnowledgeBaseUID *mRepositoryMockGetFileCountByKnowledgeBaseUID) Expect(ctx context.Context, kbUID types.KBUIDType, processStatus string) *mRepositoryMockGetFileCountByKnowledgeBaseUID {
	if mmGetFileCountByKnowledgeBaseUID.mock.funcGetFileCountByKnowledgeBaseUID != nil {
		mmGetFileCountByKnowledgeBaseUID.mock.t.Fatalf("RepositoryMock.GetFileCountByKnowledgeBaseUID mock is already set by Set")
	}

	if mmGetFileCountByKnowledgeBaseUID.defaultExpectation == nil {
		mmGetFileCountByKnowledgeBaseUID.defaultExpectation = &RepositoryMockGetFileCountByKnowledgeBaseUIDExpectation{}
	}

	if mmGetFileCountByKnowledgeBaseUID.defaultExpectation.paramPtrs != nil {
		mmGetFileCountByKnowledgeBaseUID.mock.t.Fatalf("RepositoryMock.GetFileCountByKnowledgeBaseUID mock is already set by ExpectParams functions")
	}

	mmGetFileCountByKnowledgeBaseUID.defaultExpectation.params = &RepositoryMockGetFileCountByKnowledgeBaseUIDParams{ctx, kbUID, processStatus}
	mmGetFileCountByKnowledgeBaseUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetFileCountByKnowledgeBaseUID.expectations {
		if minimock.Equal(e.params, mmGetFileCountByKnowledgeBaseUID.defaultExpectation.params) {
			mmGetFileCountByKnowledgeBaseUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFileCountByKnowledgeBaseUID.defaultExpectation.params)
		}
	}

	return mmGetFileCountByKnowledgeBaseUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetFileCountByKnowledgeBaseUID
func (mmGetFileCountByKnowledgeBaseUID *mRepositoryMockGetFileCountByKnowledgeBaseUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetFileCountByKnowledgeBaseUID {
	if mmGetFileCountByKnowledgeBaseUID.mock.funcGetFileCountByKnowledgeBaseUID != nil {
		mmGetFileCountByKnowledgeBaseUID.mock.t.Fatalf("RepositoryMock.GetFileCountByKnowledgeBaseUID mock is already set by Set")
	}

	if mmGetFileCountByKnowledgeBaseUID.defaultExpectation == nil {
		mmGetFileCountByKnowledgeBaseUID.defaultExpectation = &RepositoryMockGetFileCountByKnowledgeBaseUIDExpectation{}
	}

	if mmGetFileCountByKnowledgeBaseUID.defaultExpectation.params != nil {
		mmGetFileCountByKnowledgeBaseUID.mock.t.Fatalf("RepositoryMock.GetFileCountByKnowledgeBaseUID mock is already set by Expect")
	}

	if mmGetFileCountByKnowledgeBaseUID.defaultExpectation.paramPtrs == nil {
		mmGetFileCountByKnowledgeBaseUID.defaultExpectation.paramPtrs = &RepositoryMockGetFileCountByKnowledgeBaseUIDParamPtrs{}
	}
	mmGetFileCountByKnowledgeBaseUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetFileCountByKnowledgeBaseUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetFileCountByKnowledgeBaseUID
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.GetFileCountByKnowledgeBaseUID
func (mmGetFileCountByKnowledgeBaseUID *mRepositoryMockGetFileCountByKnowledgeBaseUID) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockGetFileCountByKnowledgeBaseUID {
	if mmGetFileCountByKnowledgeBaseUID.mock.funcGetFileCountByKnowledgeBaseUID != nil {
		mmGetFileCountByKnowledgeBaseUID.mock.t.Fatalf("RepositoryMock.GetFileCountByKnowledgeBaseUID mock is already set by Set")
	}

	if mmGetFileCountByKnowledgeBaseUID.defaultExpectation == nil {
		mmGetFileCountByKnowledgeBaseUID.defaultExpectation = &RepositoryMockGetFileCountByKnowledgeBaseUIDExpectation{}
	}

	if mmGetFileCountByKnowledgeBaseUID.defaultExpectation.params != nil {
		mmGetFileCountByKnowledgeBaseUID.mock.t.Fatalf("RepositoryMock.GetFileCountByKnowledgeBaseUID mock is already set by Expect")
	}

	if mmGetFileCountByKnowledgeBaseUID.defaultExpectation.paramPtrs == nil {
		mmGetFileCountByKnowledgeBaseUID.defaultExpectation.paramPtrs = &RepositoryMockGetFileCountByKnowledgeBaseUIDParamPtrs{}
	}
	mmGetFileCountByKnowledgeBaseUID.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmGetFileCountByKnowledgeBaseUID.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmGetFileCountByKnowledgeBaseUID
}

// ExpectProcessStatusParam3 sets up expected param processStatus for Repository.GetFileCountByKnowledgeBaseUID
func (mmGetFileCountByKnowledgeBaseUID *mRepositoryMockGetFileCountByKnowledgeBaseUID) ExpectProcessStatusParam3(processStatus string) *mRepositoryMockGetFileCountByKnowledgeBaseUID {
	if mmGetFileCountByKnowledgeBaseUID.mock.funcGetFileCountByKnowledgeBaseUID != nil {
		mmGetFileCountByKnowledgeBaseUID.mock.t.Fatalf("RepositoryMock.GetFileCountByKnowledgeBaseUID mock is already set by Set")
	}

	if mmGetFileCountByKnowledgeBaseUID.defaultExpectation == nil {
		mmGetFileCountByKnowledgeBaseUID.defaultExpectation = &RepositoryMockGetFileCountByKnowledgeBaseUIDExpectation{}
	}

	if mmGetFileCountByKnowledgeBaseUID.defaultExpectation.params != nil {
		mmGetFileCountByKnowledgeBaseUID.mock.t.Fatalf("RepositoryMock.GetFileCountByKnowledgeBaseUID mock is already set by Expect")
	}

	if mmGetFileCountByKnowledgeBaseUID.defaultExpectation.paramPtrs == nil {
		mmGetFileCountByKnowledgeBaseUID.defaultExpectation.paramPtrs = &RepositoryMockGetFileCountByKnowledgeBaseUIDParamPtrs{}
	}
	mmGetFileCountByKnowledgeBaseUID.defaultExpectation.paramPtrs.processStatus = &processStatus
	mmGetFileCountByKnowledgeBaseUID.defaultExpectation.expectationOrigins.originProcessStatus = minimock.CallerInfo(1)

	return mmGetFileCountByKnowledgeBaseUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetFileCountByKnowledgeBaseUID
func (mmGetFileCountByKnowledgeBaseUID *mRepositoryMockGetFileCountByKnowledgeBaseUID) Inspect(f func(ctx context.Context, kbUID types.KBUIDType, processStatus string)) *mRepositoryMockGetFileCountByKnowledgeBaseUID {
	if mmGetFileCountByKnowledgeBaseUID.mock.inspectFuncGetFileCountByKnowledgeBaseUID != nil {
		mmGetFileCountByKnowledgeBaseUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetFileCountByKnowledgeBaseUID")
	}

	mmGetFileCountByKnowledgeBaseUID.mock.inspectFuncGetFileCountByKnowledgeBaseUID = f

	return mmGetFileCountByKnowledgeBaseUID
}

// Return sets up results that will be returned by Repository.GetFileCountByKnowledgeBaseUID
func (mmGetFileCountByKnowledgeBaseUID *mRepositoryMockGetFileCountByKnowledgeBaseUID) Return(i1 int64, err error) *RepositoryMock {
	if mmGetFileCountByKnowledgeBaseUID.mock.funcGetFileCountByKnowledgeBaseUID != nil {
		mmGetFileCountByKnowledgeBaseUID.mock.t.Fatalf("RepositoryMock.GetFileCountByKnowledgeBaseUID mock is already set by Set")
	}

	if mmGetFileCountByKnowledgeBaseUID.defaultExpectation == nil {
		mmGetFileCountByKnowledgeBaseUID.defaultExpectation = &RepositoryMockGetFileCountByKnowledgeBaseUIDExpectation{mock: mmGetFileCountByKnowledgeBaseUID.mock}
	}
	mmGetFileCountByKnowledgeBaseUID.defaultExpectation.results = &RepositoryMockGetFileCountByKnowledgeBaseUIDResults{i1, err}
	mmGetFileCountByKnowledgeBaseUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetFileCountByKnowledgeBaseUID.mock
}

// Set uses given function f to mock the Repository.GetFileCountByKnowledgeBaseUID method
func (mmGetFileCountByKnowledgeBaseUID *mRepositoryMockGetFileCountByKnowledgeBaseUID) Set(f func(ctx context.Context, kbUID types.KBUIDType, processStatus string) (i1 int64, err error)) *RepositoryMock {
	if mmGetFileCountByKnowledgeBaseUID.defaultExpectation != nil {
		mmGetFileCountByKnowledgeBaseUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetFileCountByKnowledgeBaseUID method")
	}

	if len(mmGetFileCountByKnowledgeBaseUID.expectations) > 0 {
		mmGetFileCountByKnowledgeBaseUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetFileCountByKnowledgeBaseUID method")
	}

	mmGetFileCountByKnowledgeBaseUID.mock.funcGetFileCountByKnowledgeBaseUID = f
	mmGetFileCountByKnowledgeBaseUID.mock.funcGetFileCountByKnowledgeBaseUIDOrigin = minimock.CallerInfo(1)
	return mmGetFileCountByKnowledgeBaseUID.mock
}

// When sets expectation for the Repository.GetFileCountByKnowledgeBaseUID which will trigger the result defined by the following
// Then helper
func (mmGetFileCountByKnowledgeBaseUID *mRepositoryMockGetFileCountByKnowledgeBaseUID) When(ctx context.Context, kbUID types.KBUIDType, processStatus string) *RepositoryMockGetFileCountByKnowledgeBaseUIDExpectation {
	if mmGetFileCountByKnowledgeBaseUID.mock.funcGetFileCountByKnowledgeBaseUID != nil {
		mmGetFileCountByKnowledgeBaseUID.mock.t.Fatalf("RepositoryMock.GetFileCountByKnowledgeBaseUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetFileCountByKnowledgeBaseUIDExpectation{
		mock:               mmGetFileCountByKnowledgeBaseUID.mock,
		params:             &RepositoryMockGetFileCountByKnowledgeBaseUIDParams{ctx, kbUID, processStatus},
		expectationOrigins: RepositoryMockGetFileCountByKnowledgeBaseUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetFileCountByKnowledgeBaseUID.expectations = append(mmGetFileCountByKnowledgeBaseUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetFileCountByKnowledgeBaseUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetFileCountByKnowledgeBaseUIDExpectation) Then(i1 int64, err error) *RepositoryMock {
	e.results = &RepositoryMockGetFileCountByKnowledgeBaseUIDResults{i1, err}
	return e.mock
}

// Times sets number of times Repository.GetFileCountByKnowledgeBaseUID should be invoked
func (mmGetFileCountByKnowledgeBaseUID *mRepositoryMockGetFileCountByKnowledgeBaseUID) Times(n uint64) *mRepositoryMockGetFileCountByKnowledgeBaseUID {
	if n == 0 {
		mmGetFileCountByKnowledgeBaseUID.mock.t.Fatalf("Times of RepositoryMock.GetFileCountByKnowledgeBaseUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFileCountByKnowledgeBaseUID.expectedInvocations, n)
	mmGetFileCountByKnowledgeBaseUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetFileCountByKnowledgeBaseUID
}

func (mmGetFileCountByKnowledgeBaseUID *mRepositoryMockGetFileCountByKnowledgeBaseUID) invocationsDone() bool {
	if len(mmGetFileCountByKnowledgeBaseUID.expectations) == 0 && mmGetFileCountByKnowledgeBaseUID.defaultExpectation == nil && mmGetFileCountByKnowledgeBaseUID.mock.funcGetFileCountByKnowledgeBaseUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFileCountByKnowledgeBaseUID.mock.afterGetFileCountByKnowledgeBaseUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFileCountByKnowledgeBaseUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFileCountByKnowledgeBaseUID implements mm_repository.Repository
func (mmGetFileCountByKnowledgeBaseUID *RepositoryMock) GetFileCountByKnowledgeBaseUID(ctx context.Context, kbUID types.KBUIDType, processStatus string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetFileCountByKnowledgeBaseUID.beforeGetFileCountByKnowledgeBaseUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFileCountByKnowledgeBaseUID.afterGetFileCountByKnowledgeBaseUIDCounter, 1)

	mmGetFileCountByKnowledgeBaseUID.t.Helper()

	if mmGetFileCountByKnowledgeBaseUID.inspectFuncGetFileCountByKnowledgeBaseUID != nil {
		mmGetFileCountByKnowledgeBaseUID.inspectFuncGetFileCountByKnowledgeBaseUID(ctx, kbUID, processStatus)
	}

	mm_params := RepositoryMockGetFileCountByKnowledgeBaseUIDParams{ctx, kbUID, processStatus}

	// Record call args
	mmGetFileCountByKnowledgeBaseUID.GetFileCountByKnowledgeBaseUIDMock.mutex.Lock()
	mmGetFileCountByKnowledgeBaseUID.GetFileCountByKnowledgeBaseUIDMock.callArgs = append(mmGetFileCountByKnowledgeBaseUID.GetFileCountByKnowledgeBaseUIDMock.callArgs, &mm_params)
	mmGetFileCountByKnowledgeBaseUID.GetFileCountByKnowledgeBaseUIDMock.mutex.Unlock()

	for _, e := range mmGetFileCountByKnowledgeBaseUID.GetFileCountByKnowledgeBaseUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetFileCountByKnowledgeBaseUID.GetFileCountByKnowledgeBaseUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFileCountByKnowledgeBaseUID.GetFileCountByKnowledgeBaseUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFileCountByKnowledgeBaseUID.GetFileCountByKnowledgeBaseUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetFileCountByKnowledgeBaseUID.GetFileCountByKnowledgeBaseUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetFileCountByKnowledgeBaseUIDParams{ctx, kbUID, processStatus}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFileCountByKnowledgeBaseUID.t.Errorf("RepositoryMock.GetFileCountByKnowledgeBaseUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFileCountByKnowledgeBaseUID.GetFileCountByKnowledgeBaseUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmGetFileCountByKnowledgeBaseUID.t.Errorf("RepositoryMock.GetFileCountByKnowledgeBaseUID got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFileCountByKnowledgeBaseUID.GetFileCountByKnowledgeBaseUIDMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.processStatus != nil && !minimock.Equal(*mm_want_ptrs.processStatus, mm_got.processStatus) {
				mmGetFileCountByKnowledgeBaseUID.t.Errorf("RepositoryMock.GetFileCountByKnowledgeBaseUID got unexpected parameter processStatus, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFileCountByKnowledgeBaseUID.GetFileCountByKnowledgeBaseUIDMock.defaultExpectation.expectationOrigins.originProcessStatus, *mm_want_ptrs.processStatus, mm_got.processStatus, minimock.Diff(*mm_want_ptrs.processStatus, mm_got.processStatus))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFileCountByKnowledgeBaseUID.t.Errorf("RepositoryMock.GetFileCountByKnowledgeBaseUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetFileCountByKnowledgeBaseUID.GetFileCountByKnowledgeBaseUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFileCountByKnowledgeBaseUID.GetFileCountByKnowledgeBaseUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFileCountByKnowledgeBaseUID.t.Fatal("No results are set for the RepositoryMock.GetFileCountByKnowledgeBaseUID")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetFileCountByKnowledgeBaseUID.funcGetFileCountByKnowledgeBaseUID != nil {
		return mmGetFileCountByKnowledgeBaseUID.funcGetFileCountByKnowledgeBaseUID(ctx, kbUID, processStatus)
	}
	mmGetFileCountByKnowledgeBaseUID.t.Fatalf("Unexpected call to RepositoryMock.GetFileCountByKnowledgeBaseUID. %v %v %v", ctx, kbUID, processStatus)
	return
}

// GetFileCountByKnowledgeBaseUIDAfterCounter returns a count of finished RepositoryMock.GetFileCountByKnowledgeBaseUID invocations
func (mmGetFileCountByKnowledgeBaseUID *RepositoryMock) GetFileCountByKnowledgeBaseUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFileCountByKnowledgeBaseUID.afterGetFileCountByKnowledgeBaseUIDCounter)
}

// GetFileCountByKnowledgeBaseUIDBeforeCounter returns a count of RepositoryMock.GetFileCountByKnowledgeBaseUID invocations
func (mmGetFileCountByKnowledgeBaseUID *RepositoryMock) GetFileCountByKnowledgeBaseUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFileCountByKnowledgeBaseUID.beforeGetFileCountByKnowledgeBaseUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetFileCountByKnowledgeBaseUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFileCountByKnowledgeBaseUID *mRepositoryMockGetFileCountByKnowledgeBaseUID) Calls() []*RepositoryMockGetFileCountByKnowledgeBaseUIDParams {
	mmGetFileCountByKnowledgeBaseUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetFileCountByKnowledgeBaseUIDParams, len(mmGetFileCountByKnowledgeBaseUID.callArgs))
	copy(argCopy, mmGetFileCountByKnowledgeBaseUID.callArgs)

	mmGetFileCountByKnowledgeBaseUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetFileCountByKnowledgeBaseUIDDone returns true if the count of the GetFileCountByKnowledgeBaseUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetFileCountByKnowledgeBaseUIDDone() bool {
	if m.GetFileCountByKnowledgeBaseUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFileCountByKnowledgeBaseUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFileCountByKnowledgeBaseUIDMock.invocationsDone()
}

// MinimockGetFileCountByKnowledgeBaseUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetFileCountByKnowledgeBaseUIDInspect() {
	for _, e := range m.GetFileCountByKnowledgeBaseUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetFileCountByKnowledgeBaseUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetFileCountByKnowledgeBaseUIDCounter := mm_atomic.LoadUint64(&m.afterGetFileCountByKnowledgeBaseUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFileCountByKnowledgeBaseUIDMock.defaultExpectation != nil && afterGetFileCountByKnowledgeBaseUIDCounter < 1 {
		if m.GetFileCountByKnowledgeBaseUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetFileCountByKnowledgeBaseUID at\n%s", m.GetFileCountByKnowledgeBaseUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetFileCountByKnowledgeBaseUID at\n%s with params: %#v", m.GetFileCountByKnowledgeBaseUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetFileCountByKnowledgeBaseUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFileCountByKnowledgeBaseUID != nil && afterGetFileCountByKnowledgeBaseUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetFileCountByKnowledgeBaseUID at\n%s", m.funcGetFileCountByKnowledgeBaseUIDOrigin)
	}

	if !m.GetFileCountByKnowledgeBaseUIDMock.invocationsDone() && afterGetFileCountByKnowledgeBaseUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetFileCountByKnowledgeBaseUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetFileCountByKnowledgeBaseUIDMock.expectedInvocations), m.GetFileCountByKnowledgeBaseUIDMock.expectedInvocationsOrigin, afterGetFileCountByKnowledgeBaseUIDCounter)
	}
}

type mRepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeleted struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedExpectation
	expectations       []*RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedExpectation

	callArgs []*RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedExpectation specifies expectation struct of the Repository.GetFileCountByKnowledgeBaseUIDIncludingDeleted
type RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedParams
	paramPtrs          *RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedParamPtrs
	expectationOrigins RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedExpectationOrigins
	results            *RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedParams contains parameters of the Repository.GetFileCountByKnowledgeBaseUIDIncludingDeleted
type RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedParams struct {
	ctx           context.Context
	kbUID         types.KBUIDType
	processStatus string
}

// RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedParamPtrs contains pointers to parameters of the Repository.GetFileCountByKnowledgeBaseUIDIncludingDeleted
type RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedParamPtrs struct {
	ctx           *context.Context
	kbUID         *types.KBUIDType
	processStatus *string
}

// RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedResults contains results of the Repository.GetFileCountByKnowledgeBaseUIDIncludingDeleted
type RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedResults struct {
	i1  int64
	err error
}

// RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedOrigins contains origins of expectations of the Repository.GetFileCountByKnowledgeBaseUIDIncludingDeleted
type RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedExpectationOrigins struct {
	origin              string
	originCtx           string
	originKbUID         string
	originProcessStatus string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFileCountByKnowledgeBaseUIDIncludingDeleted *mRepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeleted) Optional() *mRepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeleted {
	mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.optional = true
	return mmGetFileCountByKnowledgeBaseUIDIncludingDeleted
}

// Expect sets up expected params for Repository.GetFileCountByKnowledgeBaseUIDIncludingDeleted
func (mmGetFileCountByKnowledgeBaseUIDIncludingDeleted *mRepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeleted) Expect(ctx context.Context, kbUID types.KBUIDType, processStatus string) *mRepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeleted {
	if mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock.funcGetFileCountByKnowledgeBaseUIDIncludingDeleted != nil {
		mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock.t.Fatalf("RepositoryMock.GetFileCountByKnowledgeBaseUIDIncludingDeleted mock is already set by Set")
	}

	if mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation == nil {
		mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation = &RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedExpectation{}
	}

	if mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation.paramPtrs != nil {
		mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock.t.Fatalf("RepositoryMock.GetFileCountByKnowledgeBaseUIDIncludingDeleted mock is already set by ExpectParams functions")
	}

	mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation.params = &RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedParams{ctx, kbUID, processStatus}
	mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.expectations {
		if minimock.Equal(e.params, mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation.params) {
			mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation.params)
		}
	}

	return mmGetFileCountByKnowledgeBaseUIDIncludingDeleted
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetFileCountByKnowledgeBaseUIDIncludingDeleted
func (mmGetFileCountByKnowledgeBaseUIDIncludingDeleted *mRepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeleted) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeleted {
	if mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock.funcGetFileCountByKnowledgeBaseUIDIncludingDeleted != nil {
		mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock.t.Fatalf("RepositoryMock.GetFileCountByKnowledgeBaseUIDIncludingDeleted mock is already set by Set")
	}

	if mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation == nil {
		mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation = &RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedExpectation{}
	}

	if mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation.params != nil {
		mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock.t.Fatalf("RepositoryMock.GetFileCountByKnowledgeBaseUIDIncludingDeleted mock is already set by Expect")
	}

	if mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation.paramPtrs == nil {
		mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation.paramPtrs = &RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedParamPtrs{}
	}
	mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetFileCountByKnowledgeBaseUIDIncludingDeleted
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.GetFileCountByKnowledgeBaseUIDIncludingDeleted
func (mmGetFileCountByKnowledgeBaseUIDIncludingDeleted *mRepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeleted) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeleted {
	if mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock.funcGetFileCountByKnowledgeBaseUIDIncludingDeleted != nil {
		mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock.t.Fatalf("RepositoryMock.GetFileCountByKnowledgeBaseUIDIncludingDeleted mock is already set by Set")
	}

	if mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation == nil {
		mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation = &RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedExpectation{}
	}

	if mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation.params != nil {
		mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock.t.Fatalf("RepositoryMock.GetFileCountByKnowledgeBaseUIDIncludingDeleted mock is already set by Expect")
	}

	if mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation.paramPtrs == nil {
		mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation.paramPtrs = &RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedParamPtrs{}
	}
	mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmGetFileCountByKnowledgeBaseUIDIncludingDeleted
}

// ExpectProcessStatusParam3 sets up expected param processStatus for Repository.GetFileCountByKnowledgeBaseUIDIncludingDeleted
func (mmGetFileCountByKnowledgeBaseUIDIncludingDeleted *mRepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeleted) ExpectProcessStatusParam3(processStatus string) *mRepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeleted {
	if mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock.funcGetFileCountByKnowledgeBaseUIDIncludingDeleted != nil {
		mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock.t.Fatalf("RepositoryMock.GetFileCountByKnowledgeBaseUIDIncludingDeleted mock is already set by Set")
	}

	if mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation == nil {
		mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation = &RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedExpectation{}
	}

	if mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation.params != nil {
		mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock.t.Fatalf("RepositoryMock.GetFileCountByKnowledgeBaseUIDIncludingDeleted mock is already set by Expect")
	}

	if mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation.paramPtrs == nil {
		mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation.paramPtrs = &RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedParamPtrs{}
	}
	mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation.paramPtrs.processStatus = &processStatus
	mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation.expectationOrigins.originProcessStatus = minimock.CallerInfo(1)

	return mmGetFileCountByKnowledgeBaseUIDIncludingDeleted
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetFileCountByKnowledgeBaseUIDIncludingDeleted
func (mmGetFileCountByKnowledgeBaseUIDIncludingDeleted *mRepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeleted) Inspect(f func(ctx context.Context, kbUID types.KBUIDType, processStatus string)) *mRepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeleted {
	if mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock.inspectFuncGetFileCountByKnowledgeBaseUIDIncludingDeleted != nil {
		mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetFileCountByKnowledgeBaseUIDIncludingDeleted")
	}

	mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock.inspectFuncGetFileCountByKnowledgeBaseUIDIncludingDeleted = f

	return mmGetFileCountByKnowledgeBaseUIDIncludingDeleted
}

// Return sets up results that will be returned by Repository.GetFileCountByKnowledgeBaseUIDIncludingDeleted
func (mmGetFileCountByKnowledgeBaseUIDIncludingDeleted *mRepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeleted) Return(i1 int64, err error) *RepositoryMock {
	if mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock.funcGetFileCountByKnowledgeBaseUIDIncludingDeleted != nil {
		mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock.t.Fatalf("RepositoryMock.GetFileCountByKnowledgeBaseUIDIncludingDeleted mock is already set by Set")
	}

	if mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation == nil {
		mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation = &RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedExpectation{mock: mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock}
	}
	mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation.results = &RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedResults{i1, err}
	mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock
}

// Set uses given function f to mock the Repository.GetFileCountByKnowledgeBaseUIDIncludingDeleted method
func (mmGetFileCountByKnowledgeBaseUIDIncludingDeleted *mRepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeleted) Set(f func(ctx context.Context, kbUID types.KBUIDType, processStatus string) (i1 int64, err error)) *RepositoryMock {
	if mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation != nil {
		mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock.t.Fatalf("Default expectation is already set for the Repository.GetFileCountByKnowledgeBaseUIDIncludingDeleted method")
	}

	if len(mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.expectations) > 0 {
		mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock.t.Fatalf("Some expectations are already set for the Repository.GetFileCountByKnowledgeBaseUIDIncludingDeleted method")
	}

	mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock.funcGetFileCountByKnowledgeBaseUIDIncludingDeleted = f
	mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock.funcGetFileCountByKnowledgeBaseUIDIncludingDeletedOrigin = minimock.CallerInfo(1)
	return mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock
}

// When sets expectation for the Repository.GetFileCountByKnowledgeBaseUIDIncludingDeleted which will trigger the result defined by the following
// Then helper
func (mmGetFileCountByKnowledgeBaseUIDIncludingDeleted *mRepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeleted) When(ctx context.Context, kbUID types.KBUIDType, processStatus string) *RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedExpectation {
	if mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock.funcGetFileCountByKnowledgeBaseUIDIncludingDeleted != nil {
		mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock.t.Fatalf("RepositoryMock.GetFileCountByKnowledgeBaseUIDIncludingDeleted mock is already set by Set")
	}

	expectation := &RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedExpectation{
		mock:               mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock,
		params:             &RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedParams{ctx, kbUID, processStatus},
		expectationOrigins: RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.expectations = append(mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetFileCountByKnowledgeBaseUIDIncludingDeleted return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedExpectation) Then(i1 int64, err error) *RepositoryMock {
	e.results = &RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedResults{i1, err}
	return e.mock
}

// Times sets number of times Repository.GetFileCountByKnowledgeBaseUIDIncludingDeleted should be invoked
func (mmGetFileCountByKnowledgeBaseUIDIncludingDeleted *mRepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeleted) Times(n uint64) *mRepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeleted {
	if n == 0 {
		mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock.t.Fatalf("Times of RepositoryMock.GetFileCountByKnowledgeBaseUIDIncludingDeleted mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.expectedInvocations, n)
	mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetFileCountByKnowledgeBaseUIDIncludingDeleted
}

func (mmGetFileCountByKnowledgeBaseUIDIncludingDeleted *mRepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeleted) invocationsDone() bool {
	if len(mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.expectations) == 0 && mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.defaultExpectation == nil && mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock.funcGetFileCountByKnowledgeBaseUIDIncludingDeleted == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mock.afterGetFileCountByKnowledgeBaseUIDIncludingDeletedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFileCountByKnowledgeBaseUIDIncludingDeleted implements mm_repository.Repository
func (mmGetFileCountByKnowledgeBaseUIDIncludingDeleted *RepositoryMock) GetFileCountByKnowledgeBaseUIDIncludingDeleted(ctx context.Context, kbUID types.KBUIDType, processStatus string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.beforeGetFileCountByKnowledgeBaseUIDIncludingDeletedCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.afterGetFileCountByKnowledgeBaseUIDIncludingDeletedCounter, 1)

	mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.t.Helper()

	if mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.inspectFuncGetFileCountByKnowledgeBaseUIDIncludingDeleted != nil {
		mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.inspectFuncGetFileCountByKnowledgeBaseUIDIncludingDeleted(ctx, kbUID, processStatus)
	}

	mm_params := RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedParams{ctx, kbUID, processStatus}

	// Record call args
	mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.GetFileCountByKnowledgeBaseUIDIncludingDeletedMock.mutex.Lock()
	mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.GetFileCountByKnowledgeBaseUIDIncludingDeletedMock.callArgs = append(mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.GetFileCountByKnowledgeBaseUIDIncludingDeletedMock.callArgs, &mm_params)
	mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.GetFileCountByKnowledgeBaseUIDIncludingDeletedMock.mutex.Unlock()

	for _, e := range mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.GetFileCountByKnowledgeBaseUIDIncludingDeletedMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.GetFileCountByKnowledgeBaseUIDIncludingDeletedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.GetFileCountByKnowledgeBaseUIDIncludingDeletedMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.GetFileCountByKnowledgeBaseUIDIncludingDeletedMock.defaultExpectation.params
		mm_want_ptrs := mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.GetFileCountByKnowledgeBaseUIDIncludingDeletedMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedParams{ctx, kbUID, processStatus}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.t.Errorf("RepositoryMock.GetFileCountByKnowledgeBaseUIDIncludingDeleted got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.GetFileCountByKnowledgeBaseUIDIncludingDeletedMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.t.Errorf("RepositoryMock.GetFileCountByKnowledgeBaseUIDIncludingDeleted got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.GetFileCountByKnowledgeBaseUIDIncludingDeletedMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.processStatus != nil && !minimock.Equal(*mm_want_ptrs.processStatus, mm_got.processStatus) {
				mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.t.Errorf("RepositoryMock.GetFileCountByKnowledgeBaseUIDIncludingDeleted got unexpected parameter processStatus, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.GetFileCountByKnowledgeBaseUIDIncludingDeletedMock.defaultExpectation.expectationOrigins.originProcessStatus, *mm_want_ptrs.processStatus, mm_got.processStatus, minimock.Diff(*mm_want_ptrs.processStatus, mm_got.processStatus))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.t.Errorf("RepositoryMock.GetFileCountByKnowledgeBaseUIDIncludingDeleted got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.GetFileCountByKnowledgeBaseUIDIncludingDeletedMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.GetFileCountByKnowledgeBaseUIDIncludingDeletedMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.t.Fatal("No results are set for the RepositoryMock.GetFileCountByKnowledgeBaseUIDIncludingDeleted")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.funcGetFileCountByKnowledgeBaseUIDIncludingDeleted != nil {
		return mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.funcGetFileCountByKnowledgeBaseUIDIncludingDeleted(ctx, kbUID, processStatus)
	}
	mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.t.Fatalf("Unexpected call to RepositoryMock.GetFileCountByKnowledgeBaseUIDIncludingDeleted. %v %v %v", ctx, kbUID, processStatus)
	return
}

// GetFileCountByKnowledgeBaseUIDIncludingDeletedAfterCounter returns a count of finished RepositoryMock.GetFileCountByKnowledgeBaseUIDIncludingDeleted invocations
func (mmGetFileCountByKnowledgeBaseUIDIncludingDeleted *RepositoryMock) GetFileCountByKnowledgeBaseUIDIncludingDeletedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.afterGetFileCountByKnowledgeBaseUIDIncludingDeletedCounter)
}

// GetFileCountByKnowledgeBaseUIDIncludingDeletedBeforeCounter returns a count of RepositoryMock.GetFileCountByKnowledgeBaseUIDIncludingDeleted invocations
func (mmGetFileCountByKnowledgeBaseUIDIncludingDeleted *RepositoryMock) GetFileCountByKnowledgeBaseUIDIncludingDeletedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.beforeGetFileCountByKnowledgeBaseUIDIncludingDeletedCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetFileCountByKnowledgeBaseUIDIncludingDeleted.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFileCountByKnowledgeBaseUIDIncludingDeleted *mRepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeleted) Calls() []*RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedParams {
	mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mutex.RLock()

	argCopy := make([]*RepositoryMockGetFileCountByKnowledgeBaseUIDIncludingDeletedParams, len(mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.callArgs))
	copy(argCopy, mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.callArgs)

	mmGetFileCountByKnowledgeBaseUIDIncludingDeleted.mutex.RUnlock()

	return argCopy
}

// MinimockGetFileCountByKnowledgeBaseUIDIncludingDeletedDone returns true if the count of the GetFileCountByKnowledgeBaseUIDIncludingDeleted invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetFileCountByKnowledgeBaseUIDIncludingDeletedDone() bool {
	if m.GetFileCountByKnowledgeBaseUIDIncludingDeletedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFileCountByKnowledgeBaseUIDIncludingDeletedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFileCountByKnowledgeBaseUIDIncludingDeletedMock.invocationsDone()
}

// MinimockGetFileCountByKnowledgeBaseUIDIncludingDeletedInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetFileCountByKnowledgeBaseUIDIncludingDeletedInspect() {
	for _, e := range m.GetFileCountByKnowledgeBaseUIDIncludingDeletedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetFileCountByKnowledgeBaseUIDIncludingDeleted at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetFileCountByKnowledgeBaseUIDIncludingDeletedCounter := mm_atomic.LoadUint64(&m.afterGetFileCountByKnowledgeBaseUIDIncludingDeletedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFileCountByKnowledgeBaseUIDIncludingDeletedMock.defaultExpectation != nil && afterGetFileCountByKnowledgeBaseUIDIncludingDeletedCounter < 1 {
		if m.GetFileCountByKnowledgeBaseUIDIncludingDeletedMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetFileCountByKnowledgeBaseUIDIncludingDeleted at\n%s", m.GetFileCountByKnowledgeBaseUIDIncludingDeletedMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetFileCountByKnowledgeBaseUIDIncludingDeleted at\n%s with params: %#v", m.GetFileCountByKnowledgeBaseUIDIncludingDeletedMock.defaultExpectation.expectationOrigins.origin, *m.GetFileCountByKnowledgeBaseUIDIncludingDeletedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFileCountByKnowledgeBaseUIDIncludingDeleted != nil && afterGetFileCountByKnowledgeBaseUIDIncludingDeletedCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetFileCountByKnowledgeBaseUIDIncludingDeleted at\n%s", m.funcGetFileCountByKnowledgeBaseUIDIncludingDeletedOrigin)
	}

	if !m.GetFileCountByKnowledgeBaseUIDIncludingDeletedMock.invocationsDone() && afterGetFileCountByKnowledgeBaseUIDIncludingDeletedCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetFileCountByKnowledgeBaseUIDIncludingDeleted at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetFileCountByKnowledgeBaseUIDIncludingDeletedMock.expectedInvocations), m.GetFileCountByKnowledgeBaseUIDIncludingDeletedMock.expectedInvocationsOrigin, afterGetFileCountByKnowledgeBaseUIDIncludingDeletedCounter)
	}
}

type mRepositoryMockGetFilesTotalTokens struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetFilesTotalTokensExpectation
	expectations       []*RepositoryMockGetFilesTotalTokensExpectation

	callArgs []*RepositoryMockGetFilesTotalTokensParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetFilesTotalTokensExpectation specifies expectation struct of the Repository.GetFilesTotalTokens
type RepositoryMockGetFilesTotalTokensExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetFilesTotalTokensParams
	paramPtrs          *RepositoryMockGetFilesTotalTokensParamPtrs
	expectationOrigins RepositoryMockGetFilesTotalTokensExpectationOrigins
	results            *RepositoryMockGetFilesTotalTokensResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetFilesTotalTokensParams contains parameters of the Repository.GetFilesTotalTokens
type RepositoryMockGetFilesTotalTokensParams struct {
	ctx     context.Context
	sources map[types.FileUIDType]struct {
		SourceTable types.SourceTableType
		SourceUID   types.SourceUIDType
	}
}

// RepositoryMockGetFilesTotalTokensParamPtrs contains pointers to parameters of the Repository.GetFilesTotalTokens
type RepositoryMockGetFilesTotalTokensParamPtrs struct {
	ctx     *context.Context
	sources *map[types.FileUIDType]struct {
		SourceTable types.SourceTableType
		SourceUID   types.SourceUIDType
	}
}

// RepositoryMockGetFilesTotalTokensResults contains results of the Repository.GetFilesTotalTokens
type RepositoryMockGetFilesTotalTokensResults struct {
	m1  map[types.FileUIDType]int
	err error
}

// RepositoryMockGetFilesTotalTokensOrigins contains origins of expectations of the Repository.GetFilesTotalTokens
type RepositoryMockGetFilesTotalTokensExpectationOrigins struct {
	origin        string
	originCtx     string
	originSources string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFilesTotalTokens *mRepositoryMockGetFilesTotalTokens) Optional() *mRepositoryMockGetFilesTotalTokens {
	mmGetFilesTotalTokens.optional = true
	return mmGetFilesTotalTokens
}

// Expect sets up expected params for Repository.GetFilesTotalTokens
func (mmGetFilesTotalTokens *mRepositoryMockGetFilesTotalTokens) Expect(ctx context.Context, sources map[types.FileUIDType]struct {
	SourceTable types.SourceTableType
	SourceUID   types.SourceUIDType
}) *mRepositoryMockGetFilesTotalTokens {
	if mmGetFilesTotalTokens.mock.funcGetFilesTotalTokens != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryMock.GetFilesTotalTokens mock is already set by Set")
	}

	if mmGetFilesTotalTokens.defaultExpectation == nil {
		mmGetFilesTotalTokens.defaultExpectation = &RepositoryMockGetFilesTotalTokensExpectation{}
	}

	if mmGetFilesTotalTokens.defaultExpectation.paramPtrs != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryMock.GetFilesTotalTokens mock is already set by ExpectParams functions")
	}

	mmGetFilesTotalTokens.defaultExpectation.params = &RepositoryMockGetFilesTotalTokensParams{ctx, sources}
	mmGetFilesTotalTokens.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetFilesTotalTokens.expectations {
		if minimock.Equal(e.params, mmGetFilesTotalTokens.defaultExpectation.params) {
			mmGetFilesTotalTokens.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFilesTotalTokens.defaultExpectation.params)
		}
	}

	return mmGetFilesTotalTokens
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetFilesTotalTokens
func (mmGetFilesTotalTokens *mRepositoryMockGetFilesTotalTokens) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetFilesTotalTokens {
	if mmGetFilesTotalTokens.mock.funcGetFilesTotalTokens != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryMock.GetFilesTotalTokens mock is already set by Set")
	}

	if mmGetFilesTotalTokens.defaultExpectation == nil {
		mmGetFilesTotalTokens.defaultExpectation = &RepositoryMockGetFilesTotalTokensExpectation{}
	}

	if mmGetFilesTotalTokens.defaultExpectation.params != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryMock.GetFilesTotalTokens mock is already set by Expect")
	}

	if mmGetFilesTotalTokens.defaultExpectation.paramPtrs == nil {
		mmGetFilesTotalTokens.defaultExpectation.paramPtrs = &RepositoryMockGetFilesTotalTokensParamPtrs{}
	}
	mmGetFilesTotalTokens.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetFilesTotalTokens.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetFilesTotalTokens
}

// ExpectSourcesParam2 sets up expected param sources for Repository.GetFilesTotalTokens
func (mmGetFilesTotalTokens *mRepositoryMockGetFilesTotalTokens) ExpectSourcesParam2(sources map[types.FileUIDType]struct {
	SourceTable types.SourceTableType
	SourceUID   types.SourceUIDType
}) *mRepositoryMockGetFilesTotalTokens {
	if mmGetFilesTotalTokens.mock.funcGetFilesTotalTokens != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryMock.GetFilesTotalTokens mock is already set by Set")
	}

	if mmGetFilesTotalTokens.defaultExpectation == nil {
		mmGetFilesTotalTokens.defaultExpectation = &RepositoryMockGetFilesTotalTokensExpectation{}
	}

	if mmGetFilesTotalTokens.defaultExpectation.params != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryMock.GetFilesTotalTokens mock is already set by Expect")
	}

	if mmGetFilesTotalTokens.defaultExpectation.paramPtrs == nil {
		mmGetFilesTotalTokens.defaultExpectation.paramPtrs = &RepositoryMockGetFilesTotalTokensParamPtrs{}
	}
	mmGetFilesTotalTokens.defaultExpectation.paramPtrs.sources = &sources
	mmGetFilesTotalTokens.defaultExpectation.expectationOrigins.originSources = minimock.CallerInfo(1)

	return mmGetFilesTotalTokens
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetFilesTotalTokens
func (mmGetFilesTotalTokens *mRepositoryMockGetFilesTotalTokens) Inspect(f func(ctx context.Context, sources map[types.FileUIDType]struct {
	SourceTable types.SourceTableType
	SourceUID   types.SourceUIDType
})) *mRepositoryMockGetFilesTotalTokens {
	if mmGetFilesTotalTokens.mock.inspectFuncGetFilesTotalTokens != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetFilesTotalTokens")
	}

	mmGetFilesTotalTokens.mock.inspectFuncGetFilesTotalTokens = f

	return mmGetFilesTotalTokens
}

// Return sets up results that will be returned by Repository.GetFilesTotalTokens
func (mmGetFilesTotalTokens *mRepositoryMockGetFilesTotalTokens) Return(m1 map[types.FileUIDType]int, err error) *RepositoryMock {
	if mmGetFilesTotalTokens.mock.funcGetFilesTotalTokens != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryMock.GetFilesTotalTokens mock is already set by Set")
	}

	if mmGetFilesTotalTokens.defaultExpectation == nil {
		mmGetFilesTotalTokens.defaultExpectation = &RepositoryMockGetFilesTotalTokensExpectation{mock: mmGetFilesTotalTokens.mock}
	}
	mmGetFilesTotalTokens.defaultExpectation.results = &RepositoryMockGetFilesTotalTokensResults{m1, err}
	mmGetFilesTotalTokens.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetFilesTotalTokens.mock
}

// Set uses given function f to mock the Repository.GetFilesTotalTokens method
func (mmGetFilesTotalTokens *mRepositoryMockGetFilesTotalTokens) Set(f func(ctx context.Context, sources map[types.FileUIDType]struct {
	SourceTable types.SourceTableType
	SourceUID   types.SourceUIDType
}) (m1 map[types.FileUIDType]int, err error)) *RepositoryMock {
	if mmGetFilesTotalTokens.defaultExpectation != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("Default expectation is already set for the Repository.GetFilesTotalTokens method")
	}

	if len(mmGetFilesTotalTokens.expectations) > 0 {
		mmGetFilesTotalTokens.mock.t.Fatalf("Some expectations are already set for the Repository.GetFilesTotalTokens method")
	}

	mmGetFilesTotalTokens.mock.funcGetFilesTotalTokens = f
	mmGetFilesTotalTokens.mock.funcGetFilesTotalTokensOrigin = minimock.CallerInfo(1)
	return mmGetFilesTotalTokens.mock
}

// When sets expectation for the Repository.GetFilesTotalTokens which will trigger the result defined by the following
// Then helper
func (mmGetFilesTotalTokens *mRepositoryMockGetFilesTotalTokens) When(ctx context.Context, sources map[types.FileUIDType]struct {
	SourceTable types.SourceTableType
	SourceUID   types.SourceUIDType
}) *RepositoryMockGetFilesTotalTokensExpectation {
	if mmGetFilesTotalTokens.mock.funcGetFilesTotalTokens != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryMock.GetFilesTotalTokens mock is already set by Set")
	}

	expectation := &RepositoryMockGetFilesTotalTokensExpectation{
		mock:               mmGetFilesTotalTokens.mock,
		params:             &RepositoryMockGetFilesTotalTokensParams{ctx, sources},
		expectationOrigins: RepositoryMockGetFilesTotalTokensExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetFilesTotalTokens.expectations = append(mmGetFilesTotalTokens.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetFilesTotalTokens return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetFilesTotalTokensExpectation) Then(m1 map[types.FileUIDType]int, err error) *RepositoryMock {
	e.results = &RepositoryMockGetFilesTotalTokensResults{m1, err}
	return e.mock
}

// Times sets number of times Repository.GetFilesTotalTokens should be invoked
func (mmGetFilesTotalTokens *mRepositoryMockGetFilesTotalTokens) Times(n uint64) *mRepositoryMockGetFilesTotalTokens {
	if n == 0 {
		mmGetFilesTotalTokens.mock.t.Fatalf("Times of RepositoryMock.GetFilesTotalTokens mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFilesTotalTokens.expectedInvocations, n)
	mmGetFilesTotalTokens.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetFilesTotalTokens
}

func (mmGetFilesTotalTokens *mRepositoryMockGetFilesTotalTokens) invocationsDone() bool {
	if len(mmGetFilesTotalTokens.expectations) == 0 && mmGetFilesTotalTokens.defaultExpectation == nil && mmGetFilesTotalTokens.mock.funcGetFilesTotalTokens == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFilesTotalTokens.mock.afterGetFilesTotalTokensCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFilesTotalTokens.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFilesTotalTokens implements mm_repository.Repository
func (mmGetFilesTotalTokens *RepositoryMock) GetFilesTotalTokens(ctx context.Context, sources map[types.FileUIDType]struct {
	SourceTable types.SourceTableType
	SourceUID   types.SourceUIDType
}) (m1 map[types.FileUIDType]int, err error) {
	mm_atomic.AddUint64(&mmGetFilesTotalTokens.beforeGetFilesTotalTokensCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFilesTotalTokens.afterGetFilesTotalTokensCounter, 1)

	mmGetFilesTotalTokens.t.Helper()

	if mmGetFilesTotalTokens.inspectFuncGetFilesTotalTokens != nil {
		mmGetFilesTotalTokens.inspectFuncGetFilesTotalTokens(ctx, sources)
	}

	mm_params := RepositoryMockGetFilesTotalTokensParams{ctx, sources}

	// Record call args
	mmGetFilesTotalTokens.GetFilesTotalTokensMock.mutex.Lock()
	mmGetFilesTotalTokens.GetFilesTotalTokensMock.callArgs = append(mmGetFilesTotalTokens.GetFilesTotalTokensMock.callArgs, &mm_params)
	mmGetFilesTotalTokens.GetFilesTotalTokensMock.mutex.Unlock()

	for _, e := range mmGetFilesTotalTokens.GetFilesTotalTokensMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetFilesTotalTokens.GetFilesTotalTokensMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFilesTotalTokens.GetFilesTotalTokensMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFilesTotalTokens.GetFilesTotalTokensMock.defaultExpectation.params
		mm_want_ptrs := mmGetFilesTotalTokens.GetFilesTotalTokensMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetFilesTotalTokensParams{ctx, sources}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFilesTotalTokens.t.Errorf("RepositoryMock.GetFilesTotalTokens got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFilesTotalTokens.GetFilesTotalTokensMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sources != nil && !minimock.Equal(*mm_want_ptrs.sources, mm_got.sources) {
				mmGetFilesTotalTokens.t.Errorf("RepositoryMock.GetFilesTotalTokens got unexpected parameter sources, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFilesTotalTokens.GetFilesTotalTokensMock.defaultExpectation.expectationOrigins.originSources, *mm_want_ptrs.sources, mm_got.sources, minimock.Diff(*mm_want_ptrs.sources, mm_got.sources))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFilesTotalTokens.t.Errorf("RepositoryMock.GetFilesTotalTokens got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetFilesTotalTokens.GetFilesTotalTokensMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFilesTotalTokens.GetFilesTotalTokensMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFilesTotalTokens.t.Fatal("No results are set for the RepositoryMock.GetFilesTotalTokens")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetFilesTotalTokens.funcGetFilesTotalTokens != nil {
		return mmGetFilesTotalTokens.funcGetFilesTotalTokens(ctx, sources)
	}
	mmGetFilesTotalTokens.t.Fatalf("Unexpected call to RepositoryMock.GetFilesTotalTokens. %v %v", ctx, sources)
	return
}

// GetFilesTotalTokensAfterCounter returns a count of finished RepositoryMock.GetFilesTotalTokens invocations
func (mmGetFilesTotalTokens *RepositoryMock) GetFilesTotalTokensAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFilesTotalTokens.afterGetFilesTotalTokensCounter)
}

// GetFilesTotalTokensBeforeCounter returns a count of RepositoryMock.GetFilesTotalTokens invocations
func (mmGetFilesTotalTokens *RepositoryMock) GetFilesTotalTokensBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFilesTotalTokens.beforeGetFilesTotalTokensCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetFilesTotalTokens.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFilesTotalTokens *mRepositoryMockGetFilesTotalTokens) Calls() []*RepositoryMockGetFilesTotalTokensParams {
	mmGetFilesTotalTokens.mutex.RLock()

	argCopy := make([]*RepositoryMockGetFilesTotalTokensParams, len(mmGetFilesTotalTokens.callArgs))
	copy(argCopy, mmGetFilesTotalTokens.callArgs)

	mmGetFilesTotalTokens.mutex.RUnlock()

	return argCopy
}

// MinimockGetFilesTotalTokensDone returns true if the count of the GetFilesTotalTokens invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetFilesTotalTokensDone() bool {
	if m.GetFilesTotalTokensMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFilesTotalTokensMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFilesTotalTokensMock.invocationsDone()
}

// MinimockGetFilesTotalTokensInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetFilesTotalTokensInspect() {
	for _, e := range m.GetFilesTotalTokensMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetFilesTotalTokens at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetFilesTotalTokensCounter := mm_atomic.LoadUint64(&m.afterGetFilesTotalTokensCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFilesTotalTokensMock.defaultExpectation != nil && afterGetFilesTotalTokensCounter < 1 {
		if m.GetFilesTotalTokensMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetFilesTotalTokens at\n%s", m.GetFilesTotalTokensMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetFilesTotalTokens at\n%s with params: %#v", m.GetFilesTotalTokensMock.defaultExpectation.expectationOrigins.origin, *m.GetFilesTotalTokensMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFilesTotalTokens != nil && afterGetFilesTotalTokensCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetFilesTotalTokens at\n%s", m.funcGetFilesTotalTokensOrigin)
	}

	if !m.GetFilesTotalTokensMock.invocationsDone() && afterGetFilesTotalTokensCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetFilesTotalTokens at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetFilesTotalTokensMock.expectedInvocations), m.GetFilesTotalTokensMock.expectedInvocationsOrigin, afterGetFilesTotalTokensCounter)
	}
}

type mRepositoryMockGetGCSFileInfo struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetGCSFileInfoExpectation
	expectations       []*RepositoryMockGetGCSFileInfoExpectation

	callArgs []*RepositoryMockGetGCSFileInfoParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetGCSFileInfoExpectation specifies expectation struct of the Repository.GetGCSFileInfo
type RepositoryMockGetGCSFileInfoExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetGCSFileInfoParams
	paramPtrs          *RepositoryMockGetGCSFileInfoParamPtrs
	expectationOrigins RepositoryMockGetGCSFileInfoExpectationOrigins
	results            *RepositoryMockGetGCSFileInfoResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetGCSFileInfoParams contains parameters of the Repository.GetGCSFileInfo
type RepositoryMockGetGCSFileInfoParams struct {
	ctx     context.Context
	kbUID   types.KBUIDType
	fileUID types.FileUIDType
	view    string
}

// RepositoryMockGetGCSFileInfoParamPtrs contains pointers to parameters of the Repository.GetGCSFileInfo
type RepositoryMockGetGCSFileInfoParamPtrs struct {
	ctx     *context.Context
	kbUID   *types.KBUIDType
	fileUID *types.FileUIDType
	view    *string
}

// RepositoryMockGetGCSFileInfoResults contains results of the Repository.GetGCSFileInfo
type RepositoryMockGetGCSFileInfoResults struct {
	gp1 *mm_repository.GCSFileInfo
	err error
}

// RepositoryMockGetGCSFileInfoOrigins contains origins of expectations of the Repository.GetGCSFileInfo
type RepositoryMockGetGCSFileInfoExpectationOrigins struct {
	origin        string
	originCtx     string
	originKbUID   string
	originFileUID string
	originView    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetGCSFileInfo *mRepositoryMockGetGCSFileInfo) Optional() *mRepositoryMockGetGCSFileInfo {
	mmGetGCSFileInfo.optional = true
	return mmGetGCSFileInfo
}

// Expect sets up expected params for Repository.GetGCSFileInfo
func (mmGetGCSFileInfo *mRepositoryMockGetGCSFileInfo) Expect(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, view string) *mRepositoryMockGetGCSFileInfo {
	if mmGetGCSFileInfo.mock.funcGetGCSFileInfo != nil {
		mmGetGCSFileInfo.mock.t.Fatalf("RepositoryMock.GetGCSFileInfo mock is already set by Set")
	}

	if mmGetGCSFileInfo.defaultExpectation == nil {
		mmGetGCSFileInfo.defaultExpectation = &RepositoryMockGetGCSFileInfoExpectation{}
	}

	if mmGetGCSFileInfo.defaultExpectation.paramPtrs != nil {
		mmGetGCSFileInfo.mock.t.Fatalf("RepositoryMock.GetGCSFileInfo mock is already set by ExpectParams functions")
	}

	mmGetGCSFileInfo.defaultExpectation.params = &RepositoryMockGetGCSFileInfoParams{ctx, kbUID, fileUID, view}
	mmGetGCSFileInfo.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetGCSFileInfo.expectations {
		if minimock.Equal(e.params, mmGetGCSFileInfo.defaultExpectation.params) {
			mmGetGCSFileInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetGCSFileInfo.defaultExpectation.params)
		}
	}

	return mmGetGCSFileInfo
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetGCSFileInfo
func (mmGetGCSFileInfo *mRepositoryMockGetGCSFileInfo) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetGCSFileInfo {
	if mmGetGCSFileInfo.mock.funcGetGCSFileInfo != nil {
		mmGetGCSFileInfo.mock.t.Fatalf("RepositoryMock.GetGCSFileInfo mock is already set by Set")
	}

	if mmGetGCSFileInfo.defaultExpectation == nil {
		mmGetGCSFileInfo.defaultExpectation = &RepositoryMockGetGCSFileInfoExpectation{}
	}

	if mmGetGCSFileInfo.defaultExpectation.params != nil {
		mmGetGCSFileInfo.mock.t.Fatalf("RepositoryMock.GetGCSFileInfo mock is already set by Expect")
	}

	if mmGetGCSFileInfo.defaultExpectation.paramPtrs == nil {
		mmGetGCSFileInfo.defaultExpectation.paramPtrs = &RepositoryMockGetGCSFileInfoParamPtrs{}
	}
	mmGetGCSFileInfo.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetGCSFileInfo.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetGCSFileInfo
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.GetGCSFileInfo
func (mmGetGCSFileInfo *mRepositoryMockGetGCSFileInfo) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockGetGCSFileInfo {
	if mmGetGCSFileInfo.mock.funcGetGCSFileInfo != nil {
		mmGetGCSFileInfo.mock.t.Fatalf("RepositoryMock.GetGCSFileInfo mock is already set by Set")
	}

	if mmGetGCSFileInfo.defaultExpectation == nil {
		mmGetGCSFileInfo.defaultExpectation = &RepositoryMockGetGCSFileInfoExpectation{}
	}

	if mmGetGCSFileInfo.defaultExpectation.params != nil {
		mmGetGCSFileInfo.mock.t.Fatalf("RepositoryMock.GetGCSFileInfo mock is already set by Expect")
	}

	if mmGetGCSFileInfo.defaultExpectation.paramPtrs == nil {
		mmGetGCSFileInfo.defaultExpectation.paramPtrs = &RepositoryMockGetGCSFileInfoParamPtrs{}
	}
	mmGetGCSFileInfo.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmGetGCSFileInfo.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmGetGCSFileInfo
}

// ExpectFileUIDParam3 sets up expected param fileUID for Repository.GetGCSFileInfo
func (mmGetGCSFileInfo *mRepositoryMockGetGCSFileInfo) ExpectFileUIDParam3(fileUID types.FileUIDType) *mRepositoryMockGetGCSFileInfo {
	if mmGetGCSFileInfo.mock.funcGetGCSFileInfo != nil {
		mmGetGCSFileInfo.mock.t.Fatalf("RepositoryMock.GetGCSFileInfo mock is already set by Set")
	}

	if mmGetGCSFileInfo.defaultExpectation == nil {
		mmGetGCSFileInfo.defaultExpectation = &RepositoryMockGetGCSFileInfoExpectation{}
	}

	if mmGetGCSFileInfo.defaultExpectation.params != nil {
		mmGetGCSFileInfo.mock.t.Fatalf("RepositoryMock.GetGCSFileInfo mock is already set by Expect")
	}

	if mmGetGCSFileInfo.defaultExpectation.paramPtrs == nil {
		mmGetGCSFileInfo.defaultExpectation.paramPtrs = &RepositoryMockGetGCSFileInfoParamPtrs{}
	}
	mmGetGCSFileInfo.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmGetGCSFileInfo.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmGetGCSFileInfo
}

// ExpectViewParam4 sets up expected param view for Repository.GetGCSFileInfo
func (mmGetGCSFileInfo *mRepositoryMockGetGCSFileInfo) ExpectViewParam4(view string) *mRepositoryMockGetGCSFileInfo {
	if mmGetGCSFileInfo.mock.funcGetGCSFileInfo != nil {
		mmGetGCSFileInfo.mock.t.Fatalf("RepositoryMock.GetGCSFileInfo mock is already set by Set")
	}

	if mmGetGCSFileInfo.defaultExpectation == nil {
		mmGetGCSFileInfo.defaultExpectation = &RepositoryMockGetGCSFileInfoExpectation{}
	}

	if mmGetGCSFileInfo.defaultExpectation.params != nil {
		mmGetGCSFileInfo.mock.t.Fatalf("RepositoryMock.GetGCSFileInfo mock is already set by Expect")
	}

	if mmGetGCSFileInfo.defaultExpectation.paramPtrs == nil {
		mmGetGCSFileInfo.defaultExpectation.paramPtrs = &RepositoryMockGetGCSFileInfoParamPtrs{}
	}
	mmGetGCSFileInfo.defaultExpectation.paramPtrs.view = &view
	mmGetGCSFileInfo.defaultExpectation.expectationOrigins.originView = minimock.CallerInfo(1)

	return mmGetGCSFileInfo
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetGCSFileInfo
func (mmGetGCSFileInfo *mRepositoryMockGetGCSFileInfo) Inspect(f func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, view string)) *mRepositoryMockGetGCSFileInfo {
	if mmGetGCSFileInfo.mock.inspectFuncGetGCSFileInfo != nil {
		mmGetGCSFileInfo.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetGCSFileInfo")
	}

	mmGetGCSFileInfo.mock.inspectFuncGetGCSFileInfo = f

	return mmGetGCSFileInfo
}

// Return sets up results that will be returned by Repository.GetGCSFileInfo
func (mmGetGCSFileInfo *mRepositoryMockGetGCSFileInfo) Return(gp1 *mm_repository.GCSFileInfo, err error) *RepositoryMock {
	if mmGetGCSFileInfo.mock.funcGetGCSFileInfo != nil {
		mmGetGCSFileInfo.mock.t.Fatalf("RepositoryMock.GetGCSFileInfo mock is already set by Set")
	}

	if mmGetGCSFileInfo.defaultExpectation == nil {
		mmGetGCSFileInfo.defaultExpectation = &RepositoryMockGetGCSFileInfoExpectation{mock: mmGetGCSFileInfo.mock}
	}
	mmGetGCSFileInfo.defaultExpectation.results = &RepositoryMockGetGCSFileInfoResults{gp1, err}
	mmGetGCSFileInfo.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetGCSFileInfo.mock
}

// Set uses given function f to mock the Repository.GetGCSFileInfo method
func (mmGetGCSFileInfo *mRepositoryMockGetGCSFileInfo) Set(f func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, view string) (gp1 *mm_repository.GCSFileInfo, err error)) *RepositoryMock {
	if mmGetGCSFileInfo.defaultExpectation != nil {
		mmGetGCSFileInfo.mock.t.Fatalf("Default expectation is already set for the Repository.GetGCSFileInfo method")
	}

	if len(mmGetGCSFileInfo.expectations) > 0 {
		mmGetGCSFileInfo.mock.t.Fatalf("Some expectations are already set for the Repository.GetGCSFileInfo method")
	}

	mmGetGCSFileInfo.mock.funcGetGCSFileInfo = f
	mmGetGCSFileInfo.mock.funcGetGCSFileInfoOrigin = minimock.CallerInfo(1)
	return mmGetGCSFileInfo.mock
}

// When sets expectation for the Repository.GetGCSFileInfo which will trigger the result defined by the following
// Then helper
func (mmGetGCSFileInfo *mRepositoryMockGetGCSFileInfo) When(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, view string) *RepositoryMockGetGCSFileInfoExpectation {
	if mmGetGCSFileInfo.mock.funcGetGCSFileInfo != nil {
		mmGetGCSFileInfo.mock.t.Fatalf("RepositoryMock.GetGCSFileInfo mock is already set by Set")
	}

	expectation := &RepositoryMockGetGCSFileInfoExpectation{
		mock:               mmGetGCSFileInfo.mock,
		params:             &RepositoryMockGetGCSFileInfoParams{ctx, kbUID, fileUID, view},
		expectationOrigins: RepositoryMockGetGCSFileInfoExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetGCSFileInfo.expectations = append(mmGetGCSFileInfo.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetGCSFileInfo return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetGCSFileInfoExpectation) Then(gp1 *mm_repository.GCSFileInfo, err error) *RepositoryMock {
	e.results = &RepositoryMockGetGCSFileInfoResults{gp1, err}
	return e.mock
}

// Times sets number of times Repository.GetGCSFileInfo should be invoked
func (mmGetGCSFileInfo *mRepositoryMockGetGCSFileInfo) Times(n uint64) *mRepositoryMockGetGCSFileInfo {
	if n == 0 {
		mmGetGCSFileInfo.mock.t.Fatalf("Times of RepositoryMock.GetGCSFileInfo mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetGCSFileInfo.expectedInvocations, n)
	mmGetGCSFileInfo.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetGCSFileInfo
}

func (mmGetGCSFileInfo *mRepositoryMockGetGCSFileInfo) invocationsDone() bool {
	if len(mmGetGCSFileInfo.expectations) == 0 && mmGetGCSFileInfo.defaultExpectation == nil && mmGetGCSFileInfo.mock.funcGetGCSFileInfo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetGCSFileInfo.mock.afterGetGCSFileInfoCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetGCSFileInfo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetGCSFileInfo implements mm_repository.Repository
func (mmGetGCSFileInfo *RepositoryMock) GetGCSFileInfo(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, view string) (gp1 *mm_repository.GCSFileInfo, err error) {
	mm_atomic.AddUint64(&mmGetGCSFileInfo.beforeGetGCSFileInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmGetGCSFileInfo.afterGetGCSFileInfoCounter, 1)

	mmGetGCSFileInfo.t.Helper()

	if mmGetGCSFileInfo.inspectFuncGetGCSFileInfo != nil {
		mmGetGCSFileInfo.inspectFuncGetGCSFileInfo(ctx, kbUID, fileUID, view)
	}

	mm_params := RepositoryMockGetGCSFileInfoParams{ctx, kbUID, fileUID, view}

	// Record call args
	mmGetGCSFileInfo.GetGCSFileInfoMock.mutex.Lock()
	mmGetGCSFileInfo.GetGCSFileInfoMock.callArgs = append(mmGetGCSFileInfo.GetGCSFileInfoMock.callArgs, &mm_params)
	mmGetGCSFileInfo.GetGCSFileInfoMock.mutex.Unlock()

	for _, e := range mmGetGCSFileInfo.GetGCSFileInfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGetGCSFileInfo.GetGCSFileInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetGCSFileInfo.GetGCSFileInfoMock.defaultExpectation.Counter, 1)
		mm_want := mmGetGCSFileInfo.GetGCSFileInfoMock.defaultExpectation.params
		mm_want_ptrs := mmGetGCSFileInfo.GetGCSFileInfoMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetGCSFileInfoParams{ctx, kbUID, fileUID, view}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetGCSFileInfo.t.Errorf("RepositoryMock.GetGCSFileInfo got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetGCSFileInfo.GetGCSFileInfoMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmGetGCSFileInfo.t.Errorf("RepositoryMock.GetGCSFileInfo got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetGCSFileInfo.GetGCSFileInfoMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmGetGCSFileInfo.t.Errorf("RepositoryMock.GetGCSFileInfo got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetGCSFileInfo.GetGCSFileInfoMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

			if mm_want_ptrs.view != nil && !minimock.Equal(*mm_want_ptrs.view, mm_got.view) {
				mmGetGCSFileInfo.t.Errorf("RepositoryMock.GetGCSFileInfo got unexpected parameter view, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetGCSFileInfo.GetGCSFileInfoMock.defaultExpectation.expectationOrigins.originView, *mm_want_ptrs.view, mm_got.view, minimock.Diff(*mm_want_ptrs.view, mm_got.view))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetGCSFileInfo.t.Errorf("RepositoryMock.GetGCSFileInfo got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetGCSFileInfo.GetGCSFileInfoMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetGCSFileInfo.GetGCSFileInfoMock.defaultExpectation.results
		if mm_results == nil {
			mmGetGCSFileInfo.t.Fatal("No results are set for the RepositoryMock.GetGCSFileInfo")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGetGCSFileInfo.funcGetGCSFileInfo != nil {
		return mmGetGCSFileInfo.funcGetGCSFileInfo(ctx, kbUID, fileUID, view)
	}
	mmGetGCSFileInfo.t.Fatalf("Unexpected call to RepositoryMock.GetGCSFileInfo. %v %v %v %v", ctx, kbUID, fileUID, view)
	return
}

// GetGCSFileInfoAfterCounter returns a count of finished RepositoryMock.GetGCSFileInfo invocations
func (mmGetGCSFileInfo *RepositoryMock) GetGCSFileInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetGCSFileInfo.afterGetGCSFileInfoCounter)
}

// GetGCSFileInfoBeforeCounter returns a count of RepositoryMock.GetGCSFileInfo invocations
func (mmGetGCSFileInfo *RepositoryMock) GetGCSFileInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetGCSFileInfo.beforeGetGCSFileInfoCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetGCSFileInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetGCSFileInfo *mRepositoryMockGetGCSFileInfo) Calls() []*RepositoryMockGetGCSFileInfoParams {
	mmGetGCSFileInfo.mutex.RLock()

	argCopy := make([]*RepositoryMockGetGCSFileInfoParams, len(mmGetGCSFileInfo.callArgs))
	copy(argCopy, mmGetGCSFileInfo.callArgs)

	mmGetGCSFileInfo.mutex.RUnlock()

	return argCopy
}

// MinimockGetGCSFileInfoDone returns true if the count of the GetGCSFileInfo invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetGCSFileInfoDone() bool {
	if m.GetGCSFileInfoMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetGCSFileInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetGCSFileInfoMock.invocationsDone()
}

// MinimockGetGCSFileInfoInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetGCSFileInfoInspect() {
	for _, e := range m.GetGCSFileInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetGCSFileInfo at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetGCSFileInfoCounter := mm_atomic.LoadUint64(&m.afterGetGCSFileInfoCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetGCSFileInfoMock.defaultExpectation != nil && afterGetGCSFileInfoCounter < 1 {
		if m.GetGCSFileInfoMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetGCSFileInfo at\n%s", m.GetGCSFileInfoMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetGCSFileInfo at\n%s with params: %#v", m.GetGCSFileInfoMock.defaultExpectation.expectationOrigins.origin, *m.GetGCSFileInfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetGCSFileInfo != nil && afterGetGCSFileInfoCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetGCSFileInfo at\n%s", m.funcGetGCSFileInfoOrigin)
	}

	if !m.GetGCSFileInfoMock.invocationsDone() && afterGetGCSFileInfoCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetGCSFileInfo at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetGCSFileInfoMock.expectedInvocations), m.GetGCSFileInfoMock.expectedInvocationsOrigin, afterGetGCSFileInfoCounter)
	}
}

type mRepositoryMockGetGCSStorage struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetGCSStorageExpectation
	expectations       []*RepositoryMockGetGCSStorageExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetGCSStorageExpectation specifies expectation struct of the Repository.GetGCSStorage
type RepositoryMockGetGCSStorageExpectation struct {
	mock *RepositoryMock

	results      *RepositoryMockGetGCSStorageResults
	returnOrigin string
	Counter      uint64
}

// RepositoryMockGetGCSStorageResults contains results of the Repository.GetGCSStorage
type RepositoryMockGetGCSStorageResults struct {
	s1 object.Storage
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetGCSStorage *mRepositoryMockGetGCSStorage) Optional() *mRepositoryMockGetGCSStorage {
	mmGetGCSStorage.optional = true
	return mmGetGCSStorage
}

// Expect sets up expected params for Repository.GetGCSStorage
func (mmGetGCSStorage *mRepositoryMockGetGCSStorage) Expect() *mRepositoryMockGetGCSStorage {
	if mmGetGCSStorage.mock.funcGetGCSStorage != nil {
		mmGetGCSStorage.mock.t.Fatalf("RepositoryMock.GetGCSStorage mock is already set by Set")
	}

	if mmGetGCSStorage.defaultExpectation == nil {
		mmGetGCSStorage.defaultExpectation = &RepositoryMockGetGCSStorageExpectation{}
	}

	return mmGetGCSStorage
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetGCSStorage
func (mmGetGCSStorage *mRepositoryMockGetGCSStorage) Inspect(f func()) *mRepositoryMockGetGCSStorage {
	if mmGetGCSStorage.mock.inspectFuncGetGCSStorage != nil {
		mmGetGCSStorage.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetGCSStorage")
	}

	mmGetGCSStorage.mock.inspectFuncGetGCSStorage = f

	return mmGetGCSStorage
}

// Return sets up results that will be returned by Repository.GetGCSStorage
func (mmGetGCSStorage *mRepositoryMockGetGCSStorage) Return(s1 object.Storage) *RepositoryMock {
	if mmGetGCSStorage.mock.funcGetGCSStorage != nil {
		mmGetGCSStorage.mock.t.Fatalf("RepositoryMock.GetGCSStorage mock is already set by Set")
	}

	if mmGetGCSStorage.defaultExpectation == nil {
		mmGetGCSStorage.defaultExpectation = &RepositoryMockGetGCSStorageExpectation{mock: mmGetGCSStorage.mock}
	}
	mmGetGCSStorage.defaultExpectation.results = &RepositoryMockGetGCSStorageResults{s1}
	mmGetGCSStorage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetGCSStorage.mock
}

// Set uses given function f to mock the Repository.GetGCSStorage method
func (mmGetGCSStorage *mRepositoryMockGetGCSStorage) Set(f func() (s1 object.Storage)) *RepositoryMock {
	if mmGetGCSStorage.defaultExpectation != nil {
		mmGetGCSStorage.mock.t.Fatalf("Default expectation is already set for the Repository.GetGCSStorage method")
	}

	if len(mmGetGCSStorage.expectations) > 0 {
		mmGetGCSStorage.mock.t.Fatalf("Some expectations are already set for the Repository.GetGCSStorage method")
	}

	mmGetGCSStorage.mock.funcGetGCSStorage = f
	mmGetGCSStorage.mock.funcGetGCSStorageOrigin = minimock.CallerInfo(1)
	return mmGetGCSStorage.mock
}

// Times sets number of times Repository.GetGCSStorage should be invoked
func (mmGetGCSStorage *mRepositoryMockGetGCSStorage) Times(n uint64) *mRepositoryMockGetGCSStorage {
	if n == 0 {
		mmGetGCSStorage.mock.t.Fatalf("Times of RepositoryMock.GetGCSStorage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetGCSStorage.expectedInvocations, n)
	mmGetGCSStorage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetGCSStorage
}

func (mmGetGCSStorage *mRepositoryMockGetGCSStorage) invocationsDone() bool {
	if len(mmGetGCSStorage.expectations) == 0 && mmGetGCSStorage.defaultExpectation == nil && mmGetGCSStorage.mock.funcGetGCSStorage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetGCSStorage.mock.afterGetGCSStorageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetGCSStorage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetGCSStorage implements mm_repository.Repository
func (mmGetGCSStorage *RepositoryMock) GetGCSStorage() (s1 object.Storage) {
	mm_atomic.AddUint64(&mmGetGCSStorage.beforeGetGCSStorageCounter, 1)
	defer mm_atomic.AddUint64(&mmGetGCSStorage.afterGetGCSStorageCounter, 1)

	mmGetGCSStorage.t.Helper()

	if mmGetGCSStorage.inspectFuncGetGCSStorage != nil {
		mmGetGCSStorage.inspectFuncGetGCSStorage()
	}

	if mmGetGCSStorage.GetGCSStorageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetGCSStorage.GetGCSStorageMock.defaultExpectation.Counter, 1)

		mm_results := mmGetGCSStorage.GetGCSStorageMock.defaultExpectation.results
		if mm_results == nil {
			mmGetGCSStorage.t.Fatal("No results are set for the RepositoryMock.GetGCSStorage")
		}
		return (*mm_results).s1
	}
	if mmGetGCSStorage.funcGetGCSStorage != nil {
		return mmGetGCSStorage.funcGetGCSStorage()
	}
	mmGetGCSStorage.t.Fatalf("Unexpected call to RepositoryMock.GetGCSStorage.")
	return
}

// GetGCSStorageAfterCounter returns a count of finished RepositoryMock.GetGCSStorage invocations
func (mmGetGCSStorage *RepositoryMock) GetGCSStorageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetGCSStorage.afterGetGCSStorageCounter)
}

// GetGCSStorageBeforeCounter returns a count of RepositoryMock.GetGCSStorage invocations
func (mmGetGCSStorage *RepositoryMock) GetGCSStorageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetGCSStorage.beforeGetGCSStorageCounter)
}

// MinimockGetGCSStorageDone returns true if the count of the GetGCSStorage invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetGCSStorageDone() bool {
	if m.GetGCSStorageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetGCSStorageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetGCSStorageMock.invocationsDone()
}

// MinimockGetGCSStorageInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetGCSStorageInspect() {
	for _, e := range m.GetGCSStorageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryMock.GetGCSStorage")
		}
	}

	afterGetGCSStorageCounter := mm_atomic.LoadUint64(&m.afterGetGCSStorageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetGCSStorageMock.defaultExpectation != nil && afterGetGCSStorageCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetGCSStorage at\n%s", m.GetGCSStorageMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetGCSStorage != nil && afterGetGCSStorageCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetGCSStorage at\n%s", m.funcGetGCSStorageOrigin)
	}

	if !m.GetGCSStorageMock.invocationsDone() && afterGetGCSStorageCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetGCSStorage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetGCSStorageMock.expectedInvocations), m.GetGCSStorageMock.expectedInvocationsOrigin, afterGetGCSStorageCounter)
	}
}

type mRepositoryMockGetKnowledgeBaseByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetKnowledgeBaseByIDExpectation
	expectations       []*RepositoryMockGetKnowledgeBaseByIDExpectation

	callArgs []*RepositoryMockGetKnowledgeBaseByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetKnowledgeBaseByIDExpectation specifies expectation struct of the Repository.GetKnowledgeBaseByID
type RepositoryMockGetKnowledgeBaseByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetKnowledgeBaseByIDParams
	paramPtrs          *RepositoryMockGetKnowledgeBaseByIDParamPtrs
	expectationOrigins RepositoryMockGetKnowledgeBaseByIDExpectationOrigins
	results            *RepositoryMockGetKnowledgeBaseByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetKnowledgeBaseByIDParams contains parameters of the Repository.GetKnowledgeBaseByID
type RepositoryMockGetKnowledgeBaseByIDParams struct {
	ctx  context.Context
	kbID string
}

// RepositoryMockGetKnowledgeBaseByIDParamPtrs contains pointers to parameters of the Repository.GetKnowledgeBaseByID
type RepositoryMockGetKnowledgeBaseByIDParamPtrs struct {
	ctx  *context.Context
	kbID *string
}

// RepositoryMockGetKnowledgeBaseByIDResults contains results of the Repository.GetKnowledgeBaseByID
type RepositoryMockGetKnowledgeBaseByIDResults struct {
	kp1 *mm_repository.KnowledgeBaseModel
	err error
}

// RepositoryMockGetKnowledgeBaseByIDOrigins contains origins of expectations of the Repository.GetKnowledgeBaseByID
type RepositoryMockGetKnowledgeBaseByIDExpectationOrigins struct {
	origin     string
	originCtx  string
	originKbID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetKnowledgeBaseByID *mRepositoryMockGetKnowledgeBaseByID) Optional() *mRepositoryMockGetKnowledgeBaseByID {
	mmGetKnowledgeBaseByID.optional = true
	return mmGetKnowledgeBaseByID
}

// Expect sets up expected params for Repository.GetKnowledgeBaseByID
func (mmGetKnowledgeBaseByID *mRepositoryMockGetKnowledgeBaseByID) Expect(ctx context.Context, kbID string) *mRepositoryMockGetKnowledgeBaseByID {
	if mmGetKnowledgeBaseByID.mock.funcGetKnowledgeBaseByID != nil {
		mmGetKnowledgeBaseByID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByID.defaultExpectation == nil {
		mmGetKnowledgeBaseByID.defaultExpectation = &RepositoryMockGetKnowledgeBaseByIDExpectation{}
	}

	if mmGetKnowledgeBaseByID.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBaseByID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByID mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBaseByID.defaultExpectation.params = &RepositoryMockGetKnowledgeBaseByIDParams{ctx, kbID}
	mmGetKnowledgeBaseByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetKnowledgeBaseByID.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBaseByID.defaultExpectation.params) {
			mmGetKnowledgeBaseByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBaseByID.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBaseByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetKnowledgeBaseByID
func (mmGetKnowledgeBaseByID *mRepositoryMockGetKnowledgeBaseByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetKnowledgeBaseByID {
	if mmGetKnowledgeBaseByID.mock.funcGetKnowledgeBaseByID != nil {
		mmGetKnowledgeBaseByID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByID.defaultExpectation == nil {
		mmGetKnowledgeBaseByID.defaultExpectation = &RepositoryMockGetKnowledgeBaseByIDExpectation{}
	}

	if mmGetKnowledgeBaseByID.defaultExpectation.params != nil {
		mmGetKnowledgeBaseByID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByID mock is already set by Expect")
	}

	if mmGetKnowledgeBaseByID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseByID.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseByIDParamPtrs{}
	}
	mmGetKnowledgeBaseByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetKnowledgeBaseByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseByID
}

// ExpectKbIDParam2 sets up expected param kbID for Repository.GetKnowledgeBaseByID
func (mmGetKnowledgeBaseByID *mRepositoryMockGetKnowledgeBaseByID) ExpectKbIDParam2(kbID string) *mRepositoryMockGetKnowledgeBaseByID {
	if mmGetKnowledgeBaseByID.mock.funcGetKnowledgeBaseByID != nil {
		mmGetKnowledgeBaseByID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByID.defaultExpectation == nil {
		mmGetKnowledgeBaseByID.defaultExpectation = &RepositoryMockGetKnowledgeBaseByIDExpectation{}
	}

	if mmGetKnowledgeBaseByID.defaultExpectation.params != nil {
		mmGetKnowledgeBaseByID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByID mock is already set by Expect")
	}

	if mmGetKnowledgeBaseByID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseByID.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseByIDParamPtrs{}
	}
	mmGetKnowledgeBaseByID.defaultExpectation.paramPtrs.kbID = &kbID
	mmGetKnowledgeBaseByID.defaultExpectation.expectationOrigins.originKbID = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetKnowledgeBaseByID
func (mmGetKnowledgeBaseByID *mRepositoryMockGetKnowledgeBaseByID) Inspect(f func(ctx context.Context, kbID string)) *mRepositoryMockGetKnowledgeBaseByID {
	if mmGetKnowledgeBaseByID.mock.inspectFuncGetKnowledgeBaseByID != nil {
		mmGetKnowledgeBaseByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetKnowledgeBaseByID")
	}

	mmGetKnowledgeBaseByID.mock.inspectFuncGetKnowledgeBaseByID = f

	return mmGetKnowledgeBaseByID
}

// Return sets up results that will be returned by Repository.GetKnowledgeBaseByID
func (mmGetKnowledgeBaseByID *mRepositoryMockGetKnowledgeBaseByID) Return(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	if mmGetKnowledgeBaseByID.mock.funcGetKnowledgeBaseByID != nil {
		mmGetKnowledgeBaseByID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByID.defaultExpectation == nil {
		mmGetKnowledgeBaseByID.defaultExpectation = &RepositoryMockGetKnowledgeBaseByIDExpectation{mock: mmGetKnowledgeBaseByID.mock}
	}
	mmGetKnowledgeBaseByID.defaultExpectation.results = &RepositoryMockGetKnowledgeBaseByIDResults{kp1, err}
	mmGetKnowledgeBaseByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseByID.mock
}

// Set uses given function f to mock the Repository.GetKnowledgeBaseByID method
func (mmGetKnowledgeBaseByID *mRepositoryMockGetKnowledgeBaseByID) Set(f func(ctx context.Context, kbID string) (kp1 *mm_repository.KnowledgeBaseModel, err error)) *RepositoryMock {
	if mmGetKnowledgeBaseByID.defaultExpectation != nil {
		mmGetKnowledgeBaseByID.mock.t.Fatalf("Default expectation is already set for the Repository.GetKnowledgeBaseByID method")
	}

	if len(mmGetKnowledgeBaseByID.expectations) > 0 {
		mmGetKnowledgeBaseByID.mock.t.Fatalf("Some expectations are already set for the Repository.GetKnowledgeBaseByID method")
	}

	mmGetKnowledgeBaseByID.mock.funcGetKnowledgeBaseByID = f
	mmGetKnowledgeBaseByID.mock.funcGetKnowledgeBaseByIDOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseByID.mock
}

// When sets expectation for the Repository.GetKnowledgeBaseByID which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBaseByID *mRepositoryMockGetKnowledgeBaseByID) When(ctx context.Context, kbID string) *RepositoryMockGetKnowledgeBaseByIDExpectation {
	if mmGetKnowledgeBaseByID.mock.funcGetKnowledgeBaseByID != nil {
		mmGetKnowledgeBaseByID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByID mock is already set by Set")
	}

	expectation := &RepositoryMockGetKnowledgeBaseByIDExpectation{
		mock:               mmGetKnowledgeBaseByID.mock,
		params:             &RepositoryMockGetKnowledgeBaseByIDParams{ctx, kbID},
		expectationOrigins: RepositoryMockGetKnowledgeBaseByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetKnowledgeBaseByID.expectations = append(mmGetKnowledgeBaseByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetKnowledgeBaseByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetKnowledgeBaseByIDExpectation) Then(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetKnowledgeBaseByIDResults{kp1, err}
	return e.mock
}

// Times sets number of times Repository.GetKnowledgeBaseByID should be invoked
func (mmGetKnowledgeBaseByID *mRepositoryMockGetKnowledgeBaseByID) Times(n uint64) *mRepositoryMockGetKnowledgeBaseByID {
	if n == 0 {
		mmGetKnowledgeBaseByID.mock.t.Fatalf("Times of RepositoryMock.GetKnowledgeBaseByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBaseByID.expectedInvocations, n)
	mmGetKnowledgeBaseByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseByID
}

func (mmGetKnowledgeBaseByID *mRepositoryMockGetKnowledgeBaseByID) invocationsDone() bool {
	if len(mmGetKnowledgeBaseByID.expectations) == 0 && mmGetKnowledgeBaseByID.defaultExpectation == nil && mmGetKnowledgeBaseByID.mock.funcGetKnowledgeBaseByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseByID.mock.afterGetKnowledgeBaseByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBaseByID implements mm_repository.Repository
func (mmGetKnowledgeBaseByID *RepositoryMock) GetKnowledgeBaseByID(ctx context.Context, kbID string) (kp1 *mm_repository.KnowledgeBaseModel, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBaseByID.beforeGetKnowledgeBaseByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBaseByID.afterGetKnowledgeBaseByIDCounter, 1)

	mmGetKnowledgeBaseByID.t.Helper()

	if mmGetKnowledgeBaseByID.inspectFuncGetKnowledgeBaseByID != nil {
		mmGetKnowledgeBaseByID.inspectFuncGetKnowledgeBaseByID(ctx, kbID)
	}

	mm_params := RepositoryMockGetKnowledgeBaseByIDParams{ctx, kbID}

	// Record call args
	mmGetKnowledgeBaseByID.GetKnowledgeBaseByIDMock.mutex.Lock()
	mmGetKnowledgeBaseByID.GetKnowledgeBaseByIDMock.callArgs = append(mmGetKnowledgeBaseByID.GetKnowledgeBaseByIDMock.callArgs, &mm_params)
	mmGetKnowledgeBaseByID.GetKnowledgeBaseByIDMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBaseByID.GetKnowledgeBaseByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmGetKnowledgeBaseByID.GetKnowledgeBaseByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBaseByID.GetKnowledgeBaseByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBaseByID.GetKnowledgeBaseByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBaseByID.GetKnowledgeBaseByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetKnowledgeBaseByIDParams{ctx, kbID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBaseByID.t.Errorf("RepositoryMock.GetKnowledgeBaseByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseByID.GetKnowledgeBaseByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbID != nil && !minimock.Equal(*mm_want_ptrs.kbID, mm_got.kbID) {
				mmGetKnowledgeBaseByID.t.Errorf("RepositoryMock.GetKnowledgeBaseByID got unexpected parameter kbID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseByID.GetKnowledgeBaseByIDMock.defaultExpectation.expectationOrigins.originKbID, *mm_want_ptrs.kbID, mm_got.kbID, minimock.Diff(*mm_want_ptrs.kbID, mm_got.kbID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBaseByID.t.Errorf("RepositoryMock.GetKnowledgeBaseByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetKnowledgeBaseByID.GetKnowledgeBaseByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBaseByID.GetKnowledgeBaseByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBaseByID.t.Fatal("No results are set for the RepositoryMock.GetKnowledgeBaseByID")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmGetKnowledgeBaseByID.funcGetKnowledgeBaseByID != nil {
		return mmGetKnowledgeBaseByID.funcGetKnowledgeBaseByID(ctx, kbID)
	}
	mmGetKnowledgeBaseByID.t.Fatalf("Unexpected call to RepositoryMock.GetKnowledgeBaseByID. %v %v", ctx, kbID)
	return
}

// GetKnowledgeBaseByIDAfterCounter returns a count of finished RepositoryMock.GetKnowledgeBaseByID invocations
func (mmGetKnowledgeBaseByID *RepositoryMock) GetKnowledgeBaseByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseByID.afterGetKnowledgeBaseByIDCounter)
}

// GetKnowledgeBaseByIDBeforeCounter returns a count of RepositoryMock.GetKnowledgeBaseByID invocations
func (mmGetKnowledgeBaseByID *RepositoryMock) GetKnowledgeBaseByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseByID.beforeGetKnowledgeBaseByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetKnowledgeBaseByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBaseByID *mRepositoryMockGetKnowledgeBaseByID) Calls() []*RepositoryMockGetKnowledgeBaseByIDParams {
	mmGetKnowledgeBaseByID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetKnowledgeBaseByIDParams, len(mmGetKnowledgeBaseByID.callArgs))
	copy(argCopy, mmGetKnowledgeBaseByID.callArgs)

	mmGetKnowledgeBaseByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBaseByIDDone returns true if the count of the GetKnowledgeBaseByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetKnowledgeBaseByIDDone() bool {
	if m.GetKnowledgeBaseByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetKnowledgeBaseByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBaseByIDMock.invocationsDone()
}

// MinimockGetKnowledgeBaseByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetKnowledgeBaseByIDInspect() {
	for _, e := range m.GetKnowledgeBaseByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetKnowledgeBaseByIDCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBaseByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBaseByIDMock.defaultExpectation != nil && afterGetKnowledgeBaseByIDCounter < 1 {
		if m.GetKnowledgeBaseByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByID at\n%s", m.GetKnowledgeBaseByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByID at\n%s with params: %#v", m.GetKnowledgeBaseByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetKnowledgeBaseByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBaseByID != nil && afterGetKnowledgeBaseByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByID at\n%s", m.funcGetKnowledgeBaseByIDOrigin)
	}

	if !m.GetKnowledgeBaseByIDMock.invocationsDone() && afterGetKnowledgeBaseByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetKnowledgeBaseByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBaseByIDMock.expectedInvocations), m.GetKnowledgeBaseByIDMock.expectedInvocationsOrigin, afterGetKnowledgeBaseByIDCounter)
	}
}

type mRepositoryMockGetKnowledgeBaseByIDOrAlias struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetKnowledgeBaseByIDOrAliasExpectation
	expectations       []*RepositoryMockGetKnowledgeBaseByIDOrAliasExpectation

	callArgs []*RepositoryMockGetKnowledgeBaseByIDOrAliasParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetKnowledgeBaseByIDOrAliasExpectation specifies expectation struct of the Repository.GetKnowledgeBaseByIDOrAlias
type RepositoryMockGetKnowledgeBaseByIDOrAliasExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetKnowledgeBaseByIDOrAliasParams
	paramPtrs          *RepositoryMockGetKnowledgeBaseByIDOrAliasParamPtrs
	expectationOrigins RepositoryMockGetKnowledgeBaseByIDOrAliasExpectationOrigins
	results            *RepositoryMockGetKnowledgeBaseByIDOrAliasResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetKnowledgeBaseByIDOrAliasParams contains parameters of the Repository.GetKnowledgeBaseByIDOrAlias
type RepositoryMockGetKnowledgeBaseByIDOrAliasParams struct {
	ctx      context.Context
	ownerUID types.OwnerUIDType
	id       string
}

// RepositoryMockGetKnowledgeBaseByIDOrAliasParamPtrs contains pointers to parameters of the Repository.GetKnowledgeBaseByIDOrAlias
type RepositoryMockGetKnowledgeBaseByIDOrAliasParamPtrs struct {
	ctx      *context.Context
	ownerUID *types.OwnerUIDType
	id       *string
}

// RepositoryMockGetKnowledgeBaseByIDOrAliasResults contains results of the Repository.GetKnowledgeBaseByIDOrAlias
type RepositoryMockGetKnowledgeBaseByIDOrAliasResults struct {
	kp1 *mm_repository.KnowledgeBaseModel
	err error
}

// RepositoryMockGetKnowledgeBaseByIDOrAliasOrigins contains origins of expectations of the Repository.GetKnowledgeBaseByIDOrAlias
type RepositoryMockGetKnowledgeBaseByIDOrAliasExpectationOrigins struct {
	origin         string
	originCtx      string
	originOwnerUID string
	originId       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetKnowledgeBaseByIDOrAlias *mRepositoryMockGetKnowledgeBaseByIDOrAlias) Optional() *mRepositoryMockGetKnowledgeBaseByIDOrAlias {
	mmGetKnowledgeBaseByIDOrAlias.optional = true
	return mmGetKnowledgeBaseByIDOrAlias
}

// Expect sets up expected params for Repository.GetKnowledgeBaseByIDOrAlias
func (mmGetKnowledgeBaseByIDOrAlias *mRepositoryMockGetKnowledgeBaseByIDOrAlias) Expect(ctx context.Context, ownerUID types.OwnerUIDType, id string) *mRepositoryMockGetKnowledgeBaseByIDOrAlias {
	if mmGetKnowledgeBaseByIDOrAlias.mock.funcGetKnowledgeBaseByIDOrAlias != nil {
		mmGetKnowledgeBaseByIDOrAlias.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByIDOrAlias mock is already set by Set")
	}

	if mmGetKnowledgeBaseByIDOrAlias.defaultExpectation == nil {
		mmGetKnowledgeBaseByIDOrAlias.defaultExpectation = &RepositoryMockGetKnowledgeBaseByIDOrAliasExpectation{}
	}

	if mmGetKnowledgeBaseByIDOrAlias.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBaseByIDOrAlias.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByIDOrAlias mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBaseByIDOrAlias.defaultExpectation.params = &RepositoryMockGetKnowledgeBaseByIDOrAliasParams{ctx, ownerUID, id}
	mmGetKnowledgeBaseByIDOrAlias.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetKnowledgeBaseByIDOrAlias.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBaseByIDOrAlias.defaultExpectation.params) {
			mmGetKnowledgeBaseByIDOrAlias.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBaseByIDOrAlias.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBaseByIDOrAlias
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetKnowledgeBaseByIDOrAlias
func (mmGetKnowledgeBaseByIDOrAlias *mRepositoryMockGetKnowledgeBaseByIDOrAlias) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetKnowledgeBaseByIDOrAlias {
	if mmGetKnowledgeBaseByIDOrAlias.mock.funcGetKnowledgeBaseByIDOrAlias != nil {
		mmGetKnowledgeBaseByIDOrAlias.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByIDOrAlias mock is already set by Set")
	}

	if mmGetKnowledgeBaseByIDOrAlias.defaultExpectation == nil {
		mmGetKnowledgeBaseByIDOrAlias.defaultExpectation = &RepositoryMockGetKnowledgeBaseByIDOrAliasExpectation{}
	}

	if mmGetKnowledgeBaseByIDOrAlias.defaultExpectation.params != nil {
		mmGetKnowledgeBaseByIDOrAlias.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByIDOrAlias mock is already set by Expect")
	}

	if mmGetKnowledgeBaseByIDOrAlias.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseByIDOrAlias.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseByIDOrAliasParamPtrs{}
	}
	mmGetKnowledgeBaseByIDOrAlias.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetKnowledgeBaseByIDOrAlias.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseByIDOrAlias
}

// ExpectOwnerUIDParam2 sets up expected param ownerUID for Repository.GetKnowledgeBaseByIDOrAlias
func (mmGetKnowledgeBaseByIDOrAlias *mRepositoryMockGetKnowledgeBaseByIDOrAlias) ExpectOwnerUIDParam2(ownerUID types.OwnerUIDType) *mRepositoryMockGetKnowledgeBaseByIDOrAlias {
	if mmGetKnowledgeBaseByIDOrAlias.mock.funcGetKnowledgeBaseByIDOrAlias != nil {
		mmGetKnowledgeBaseByIDOrAlias.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByIDOrAlias mock is already set by Set")
	}

	if mmGetKnowledgeBaseByIDOrAlias.defaultExpectation == nil {
		mmGetKnowledgeBaseByIDOrAlias.defaultExpectation = &RepositoryMockGetKnowledgeBaseByIDOrAliasExpectation{}
	}

	if mmGetKnowledgeBaseByIDOrAlias.defaultExpectation.params != nil {
		mmGetKnowledgeBaseByIDOrAlias.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByIDOrAlias mock is already set by Expect")
	}

	if mmGetKnowledgeBaseByIDOrAlias.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseByIDOrAlias.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseByIDOrAliasParamPtrs{}
	}
	mmGetKnowledgeBaseByIDOrAlias.defaultExpectation.paramPtrs.ownerUID = &ownerUID
	mmGetKnowledgeBaseByIDOrAlias.defaultExpectation.expectationOrigins.originOwnerUID = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseByIDOrAlias
}

// ExpectIdParam3 sets up expected param id for Repository.GetKnowledgeBaseByIDOrAlias
func (mmGetKnowledgeBaseByIDOrAlias *mRepositoryMockGetKnowledgeBaseByIDOrAlias) ExpectIdParam3(id string) *mRepositoryMockGetKnowledgeBaseByIDOrAlias {
	if mmGetKnowledgeBaseByIDOrAlias.mock.funcGetKnowledgeBaseByIDOrAlias != nil {
		mmGetKnowledgeBaseByIDOrAlias.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByIDOrAlias mock is already set by Set")
	}

	if mmGetKnowledgeBaseByIDOrAlias.defaultExpectation == nil {
		mmGetKnowledgeBaseByIDOrAlias.defaultExpectation = &RepositoryMockGetKnowledgeBaseByIDOrAliasExpectation{}
	}

	if mmGetKnowledgeBaseByIDOrAlias.defaultExpectation.params != nil {
		mmGetKnowledgeBaseByIDOrAlias.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByIDOrAlias mock is already set by Expect")
	}

	if mmGetKnowledgeBaseByIDOrAlias.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseByIDOrAlias.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseByIDOrAliasParamPtrs{}
	}
	mmGetKnowledgeBaseByIDOrAlias.defaultExpectation.paramPtrs.id = &id
	mmGetKnowledgeBaseByIDOrAlias.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseByIDOrAlias
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetKnowledgeBaseByIDOrAlias
func (mmGetKnowledgeBaseByIDOrAlias *mRepositoryMockGetKnowledgeBaseByIDOrAlias) Inspect(f func(ctx context.Context, ownerUID types.OwnerUIDType, id string)) *mRepositoryMockGetKnowledgeBaseByIDOrAlias {
	if mmGetKnowledgeBaseByIDOrAlias.mock.inspectFuncGetKnowledgeBaseByIDOrAlias != nil {
		mmGetKnowledgeBaseByIDOrAlias.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetKnowledgeBaseByIDOrAlias")
	}

	mmGetKnowledgeBaseByIDOrAlias.mock.inspectFuncGetKnowledgeBaseByIDOrAlias = f

	return mmGetKnowledgeBaseByIDOrAlias
}

// Return sets up results that will be returned by Repository.GetKnowledgeBaseByIDOrAlias
func (mmGetKnowledgeBaseByIDOrAlias *mRepositoryMockGetKnowledgeBaseByIDOrAlias) Return(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	if mmGetKnowledgeBaseByIDOrAlias.mock.funcGetKnowledgeBaseByIDOrAlias != nil {
		mmGetKnowledgeBaseByIDOrAlias.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByIDOrAlias mock is already set by Set")
	}

	if mmGetKnowledgeBaseByIDOrAlias.defaultExpectation == nil {
		mmGetKnowledgeBaseByIDOrAlias.defaultExpectation = &RepositoryMockGetKnowledgeBaseByIDOrAliasExpectation{mock: mmGetKnowledgeBaseByIDOrAlias.mock}
	}
	mmGetKnowledgeBaseByIDOrAlias.defaultExpectation.results = &RepositoryMockGetKnowledgeBaseByIDOrAliasResults{kp1, err}
	mmGetKnowledgeBaseByIDOrAlias.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseByIDOrAlias.mock
}

// Set uses given function f to mock the Repository.GetKnowledgeBaseByIDOrAlias method
func (mmGetKnowledgeBaseByIDOrAlias *mRepositoryMockGetKnowledgeBaseByIDOrAlias) Set(f func(ctx context.Context, ownerUID types.OwnerUIDType, id string) (kp1 *mm_repository.KnowledgeBaseModel, err error)) *RepositoryMock {
	if mmGetKnowledgeBaseByIDOrAlias.defaultExpectation != nil {
		mmGetKnowledgeBaseByIDOrAlias.mock.t.Fatalf("Default expectation is already set for the Repository.GetKnowledgeBaseByIDOrAlias method")
	}

	if len(mmGetKnowledgeBaseByIDOrAlias.expectations) > 0 {
		mmGetKnowledgeBaseByIDOrAlias.mock.t.Fatalf("Some expectations are already set for the Repository.GetKnowledgeBaseByIDOrAlias method")
	}

	mmGetKnowledgeBaseByIDOrAlias.mock.funcGetKnowledgeBaseByIDOrAlias = f
	mmGetKnowledgeBaseByIDOrAlias.mock.funcGetKnowledgeBaseByIDOrAliasOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseByIDOrAlias.mock
}

// When sets expectation for the Repository.GetKnowledgeBaseByIDOrAlias which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBaseByIDOrAlias *mRepositoryMockGetKnowledgeBaseByIDOrAlias) When(ctx context.Context, ownerUID types.OwnerUIDType, id string) *RepositoryMockGetKnowledgeBaseByIDOrAliasExpectation {
	if mmGetKnowledgeBaseByIDOrAlias.mock.funcGetKnowledgeBaseByIDOrAlias != nil {
		mmGetKnowledgeBaseByIDOrAlias.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByIDOrAlias mock is already set by Set")
	}

	expectation := &RepositoryMockGetKnowledgeBaseByIDOrAliasExpectation{
		mock:               mmGetKnowledgeBaseByIDOrAlias.mock,
		params:             &RepositoryMockGetKnowledgeBaseByIDOrAliasParams{ctx, ownerUID, id},
		expectationOrigins: RepositoryMockGetKnowledgeBaseByIDOrAliasExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetKnowledgeBaseByIDOrAlias.expectations = append(mmGetKnowledgeBaseByIDOrAlias.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetKnowledgeBaseByIDOrAlias return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetKnowledgeBaseByIDOrAliasExpectation) Then(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetKnowledgeBaseByIDOrAliasResults{kp1, err}
	return e.mock
}

// Times sets number of times Repository.GetKnowledgeBaseByIDOrAlias should be invoked
func (mmGetKnowledgeBaseByIDOrAlias *mRepositoryMockGetKnowledgeBaseByIDOrAlias) Times(n uint64) *mRepositoryMockGetKnowledgeBaseByIDOrAlias {
	if n == 0 {
		mmGetKnowledgeBaseByIDOrAlias.mock.t.Fatalf("Times of RepositoryMock.GetKnowledgeBaseByIDOrAlias mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBaseByIDOrAlias.expectedInvocations, n)
	mmGetKnowledgeBaseByIDOrAlias.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseByIDOrAlias
}

func (mmGetKnowledgeBaseByIDOrAlias *mRepositoryMockGetKnowledgeBaseByIDOrAlias) invocationsDone() bool {
	if len(mmGetKnowledgeBaseByIDOrAlias.expectations) == 0 && mmGetKnowledgeBaseByIDOrAlias.defaultExpectation == nil && mmGetKnowledgeBaseByIDOrAlias.mock.funcGetKnowledgeBaseByIDOrAlias == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseByIDOrAlias.mock.afterGetKnowledgeBaseByIDOrAliasCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseByIDOrAlias.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBaseByIDOrAlias implements mm_repository.Repository
func (mmGetKnowledgeBaseByIDOrAlias *RepositoryMock) GetKnowledgeBaseByIDOrAlias(ctx context.Context, ownerUID types.OwnerUIDType, id string) (kp1 *mm_repository.KnowledgeBaseModel, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBaseByIDOrAlias.beforeGetKnowledgeBaseByIDOrAliasCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBaseByIDOrAlias.afterGetKnowledgeBaseByIDOrAliasCounter, 1)

	mmGetKnowledgeBaseByIDOrAlias.t.Helper()

	if mmGetKnowledgeBaseByIDOrAlias.inspectFuncGetKnowledgeBaseByIDOrAlias != nil {
		mmGetKnowledgeBaseByIDOrAlias.inspectFuncGetKnowledgeBaseByIDOrAlias(ctx, ownerUID, id)
	}

	mm_params := RepositoryMockGetKnowledgeBaseByIDOrAliasParams{ctx, ownerUID, id}

	// Record call args
	mmGetKnowledgeBaseByIDOrAlias.GetKnowledgeBaseByIDOrAliasMock.mutex.Lock()
	mmGetKnowledgeBaseByIDOrAlias.GetKnowledgeBaseByIDOrAliasMock.callArgs = append(mmGetKnowledgeBaseByIDOrAlias.GetKnowledgeBaseByIDOrAliasMock.callArgs, &mm_params)
	mmGetKnowledgeBaseByIDOrAlias.GetKnowledgeBaseByIDOrAliasMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBaseByIDOrAlias.GetKnowledgeBaseByIDOrAliasMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmGetKnowledgeBaseByIDOrAlias.GetKnowledgeBaseByIDOrAliasMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBaseByIDOrAlias.GetKnowledgeBaseByIDOrAliasMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBaseByIDOrAlias.GetKnowledgeBaseByIDOrAliasMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBaseByIDOrAlias.GetKnowledgeBaseByIDOrAliasMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetKnowledgeBaseByIDOrAliasParams{ctx, ownerUID, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBaseByIDOrAlias.t.Errorf("RepositoryMock.GetKnowledgeBaseByIDOrAlias got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseByIDOrAlias.GetKnowledgeBaseByIDOrAliasMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmGetKnowledgeBaseByIDOrAlias.t.Errorf("RepositoryMock.GetKnowledgeBaseByIDOrAlias got unexpected parameter ownerUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseByIDOrAlias.GetKnowledgeBaseByIDOrAliasMock.defaultExpectation.expectationOrigins.originOwnerUID, *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetKnowledgeBaseByIDOrAlias.t.Errorf("RepositoryMock.GetKnowledgeBaseByIDOrAlias got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseByIDOrAlias.GetKnowledgeBaseByIDOrAliasMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBaseByIDOrAlias.t.Errorf("RepositoryMock.GetKnowledgeBaseByIDOrAlias got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetKnowledgeBaseByIDOrAlias.GetKnowledgeBaseByIDOrAliasMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBaseByIDOrAlias.GetKnowledgeBaseByIDOrAliasMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBaseByIDOrAlias.t.Fatal("No results are set for the RepositoryMock.GetKnowledgeBaseByIDOrAlias")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmGetKnowledgeBaseByIDOrAlias.funcGetKnowledgeBaseByIDOrAlias != nil {
		return mmGetKnowledgeBaseByIDOrAlias.funcGetKnowledgeBaseByIDOrAlias(ctx, ownerUID, id)
	}
	mmGetKnowledgeBaseByIDOrAlias.t.Fatalf("Unexpected call to RepositoryMock.GetKnowledgeBaseByIDOrAlias. %v %v %v", ctx, ownerUID, id)
	return
}

// GetKnowledgeBaseByIDOrAliasAfterCounter returns a count of finished RepositoryMock.GetKnowledgeBaseByIDOrAlias invocations
func (mmGetKnowledgeBaseByIDOrAlias *RepositoryMock) GetKnowledgeBaseByIDOrAliasAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseByIDOrAlias.afterGetKnowledgeBaseByIDOrAliasCounter)
}

// GetKnowledgeBaseByIDOrAliasBeforeCounter returns a count of RepositoryMock.GetKnowledgeBaseByIDOrAlias invocations
func (mmGetKnowledgeBaseByIDOrAlias *RepositoryMock) GetKnowledgeBaseByIDOrAliasBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseByIDOrAlias.beforeGetKnowledgeBaseByIDOrAliasCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetKnowledgeBaseByIDOrAlias.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBaseByIDOrAlias *mRepositoryMockGetKnowledgeBaseByIDOrAlias) Calls() []*RepositoryMockGetKnowledgeBaseByIDOrAliasParams {
	mmGetKnowledgeBaseByIDOrAlias.mutex.RLock()

	argCopy := make([]*RepositoryMockGetKnowledgeBaseByIDOrAliasParams, len(mmGetKnowledgeBaseByIDOrAlias.callArgs))
	copy(argCopy, mmGetKnowledgeBaseByIDOrAlias.callArgs)

	mmGetKnowledgeBaseByIDOrAlias.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBaseByIDOrAliasDone returns true if the count of the GetKnowledgeBaseByIDOrAlias invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetKnowledgeBaseByIDOrAliasDone() bool {
	if m.GetKnowledgeBaseByIDOrAliasMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetKnowledgeBaseByIDOrAliasMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBaseByIDOrAliasMock.invocationsDone()
}

// MinimockGetKnowledgeBaseByIDOrAliasInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetKnowledgeBaseByIDOrAliasInspect() {
	for _, e := range m.GetKnowledgeBaseByIDOrAliasMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByIDOrAlias at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetKnowledgeBaseByIDOrAliasCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBaseByIDOrAliasCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBaseByIDOrAliasMock.defaultExpectation != nil && afterGetKnowledgeBaseByIDOrAliasCounter < 1 {
		if m.GetKnowledgeBaseByIDOrAliasMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByIDOrAlias at\n%s", m.GetKnowledgeBaseByIDOrAliasMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByIDOrAlias at\n%s with params: %#v", m.GetKnowledgeBaseByIDOrAliasMock.defaultExpectation.expectationOrigins.origin, *m.GetKnowledgeBaseByIDOrAliasMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBaseByIDOrAlias != nil && afterGetKnowledgeBaseByIDOrAliasCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByIDOrAlias at\n%s", m.funcGetKnowledgeBaseByIDOrAliasOrigin)
	}

	if !m.GetKnowledgeBaseByIDOrAliasMock.invocationsDone() && afterGetKnowledgeBaseByIDOrAliasCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetKnowledgeBaseByIDOrAlias at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBaseByIDOrAliasMock.expectedInvocations), m.GetKnowledgeBaseByIDOrAliasMock.expectedInvocationsOrigin, afterGetKnowledgeBaseByIDOrAliasCounter)
	}
}

type mRepositoryMockGetKnowledgeBaseByOwnerAndKbID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectation
	expectations       []*RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectation

	callArgs []*RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectation specifies expectation struct of the Repository.GetKnowledgeBaseByOwnerAndKbID
type RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParams
	paramPtrs          *RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParamPtrs
	expectationOrigins RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectationOrigins
	results            *RepositoryMockGetKnowledgeBaseByOwnerAndKbIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParams contains parameters of the Repository.GetKnowledgeBaseByOwnerAndKbID
type RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParams struct {
	ctx      context.Context
	ownerUID types.OwnerUIDType
	kbID     string
}

// RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParamPtrs contains pointers to parameters of the Repository.GetKnowledgeBaseByOwnerAndKbID
type RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParamPtrs struct {
	ctx      *context.Context
	ownerUID *types.OwnerUIDType
	kbID     *string
}

// RepositoryMockGetKnowledgeBaseByOwnerAndKbIDResults contains results of the Repository.GetKnowledgeBaseByOwnerAndKbID
type RepositoryMockGetKnowledgeBaseByOwnerAndKbIDResults struct {
	kp1 *mm_repository.KnowledgeBaseModel
	err error
}

// RepositoryMockGetKnowledgeBaseByOwnerAndKbIDOrigins contains origins of expectations of the Repository.GetKnowledgeBaseByOwnerAndKbID
type RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectationOrigins struct {
	origin         string
	originCtx      string
	originOwnerUID string
	originKbID     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID) Optional() *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID {
	mmGetKnowledgeBaseByOwnerAndKbID.optional = true
	return mmGetKnowledgeBaseByOwnerAndKbID
}

// Expect sets up expected params for Repository.GetKnowledgeBaseByOwnerAndKbID
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID) Expect(ctx context.Context, ownerUID types.OwnerUIDType, kbID string) *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID {
	if mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation = &RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectation{}
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.params = &RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParams{ctx, ownerUID, kbID}
	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetKnowledgeBaseByOwnerAndKbID.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.params) {
			mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBaseByOwnerAndKbID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetKnowledgeBaseByOwnerAndKbID
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID {
	if mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation = &RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectation{}
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.params != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Expect")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParamPtrs{}
	}
	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseByOwnerAndKbID
}

// ExpectOwnerUIDParam2 sets up expected param ownerUID for Repository.GetKnowledgeBaseByOwnerAndKbID
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID) ExpectOwnerUIDParam2(ownerUID types.OwnerUIDType) *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID {
	if mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation = &RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectation{}
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.params != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Expect")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParamPtrs{}
	}
	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs.ownerUID = &ownerUID
	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.expectationOrigins.originOwnerUID = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseByOwnerAndKbID
}

// ExpectKbIDParam3 sets up expected param kbID for Repository.GetKnowledgeBaseByOwnerAndKbID
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID) ExpectKbIDParam3(kbID string) *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID {
	if mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation = &RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectation{}
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.params != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Expect")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParamPtrs{}
	}
	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs.kbID = &kbID
	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.expectationOrigins.originKbID = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseByOwnerAndKbID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetKnowledgeBaseByOwnerAndKbID
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID) Inspect(f func(ctx context.Context, ownerUID types.OwnerUIDType, kbID string)) *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID {
	if mmGetKnowledgeBaseByOwnerAndKbID.mock.inspectFuncGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetKnowledgeBaseByOwnerAndKbID")
	}

	mmGetKnowledgeBaseByOwnerAndKbID.mock.inspectFuncGetKnowledgeBaseByOwnerAndKbID = f

	return mmGetKnowledgeBaseByOwnerAndKbID
}

// Return sets up results that will be returned by Repository.GetKnowledgeBaseByOwnerAndKbID
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID) Return(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	if mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation = &RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectation{mock: mmGetKnowledgeBaseByOwnerAndKbID.mock}
	}
	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.results = &RepositoryMockGetKnowledgeBaseByOwnerAndKbIDResults{kp1, err}
	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseByOwnerAndKbID.mock
}

// Set uses given function f to mock the Repository.GetKnowledgeBaseByOwnerAndKbID method
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID) Set(f func(ctx context.Context, ownerUID types.OwnerUIDType, kbID string) (kp1 *mm_repository.KnowledgeBaseModel, err error)) *RepositoryMock {
	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("Default expectation is already set for the Repository.GetKnowledgeBaseByOwnerAndKbID method")
	}

	if len(mmGetKnowledgeBaseByOwnerAndKbID.expectations) > 0 {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("Some expectations are already set for the Repository.GetKnowledgeBaseByOwnerAndKbID method")
	}

	mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID = f
	mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbIDOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseByOwnerAndKbID.mock
}

// When sets expectation for the Repository.GetKnowledgeBaseByOwnerAndKbID which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID) When(ctx context.Context, ownerUID types.OwnerUIDType, kbID string) *RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectation {
	if mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Set")
	}

	expectation := &RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectation{
		mock:               mmGetKnowledgeBaseByOwnerAndKbID.mock,
		params:             &RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParams{ctx, ownerUID, kbID},
		expectationOrigins: RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetKnowledgeBaseByOwnerAndKbID.expectations = append(mmGetKnowledgeBaseByOwnerAndKbID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetKnowledgeBaseByOwnerAndKbID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectation) Then(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetKnowledgeBaseByOwnerAndKbIDResults{kp1, err}
	return e.mock
}

// Times sets number of times Repository.GetKnowledgeBaseByOwnerAndKbID should be invoked
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID) Times(n uint64) *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID {
	if n == 0 {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("Times of RepositoryMock.GetKnowledgeBaseByOwnerAndKbID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBaseByOwnerAndKbID.expectedInvocations, n)
	mmGetKnowledgeBaseByOwnerAndKbID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseByOwnerAndKbID
}

func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID) invocationsDone() bool {
	if len(mmGetKnowledgeBaseByOwnerAndKbID.expectations) == 0 && mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation == nil && mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseByOwnerAndKbID.mock.afterGetKnowledgeBaseByOwnerAndKbIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseByOwnerAndKbID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBaseByOwnerAndKbID implements mm_repository.Repository
func (mmGetKnowledgeBaseByOwnerAndKbID *RepositoryMock) GetKnowledgeBaseByOwnerAndKbID(ctx context.Context, ownerUID types.OwnerUIDType, kbID string) (kp1 *mm_repository.KnowledgeBaseModel, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBaseByOwnerAndKbID.beforeGetKnowledgeBaseByOwnerAndKbIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBaseByOwnerAndKbID.afterGetKnowledgeBaseByOwnerAndKbIDCounter, 1)

	mmGetKnowledgeBaseByOwnerAndKbID.t.Helper()

	if mmGetKnowledgeBaseByOwnerAndKbID.inspectFuncGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.inspectFuncGetKnowledgeBaseByOwnerAndKbID(ctx, ownerUID, kbID)
	}

	mm_params := RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParams{ctx, ownerUID, kbID}

	// Record call args
	mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.mutex.Lock()
	mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.callArgs = append(mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.callArgs, &mm_params)
	mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParams{ctx, ownerUID, kbID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBaseByOwnerAndKbID.t.Errorf("RepositoryMock.GetKnowledgeBaseByOwnerAndKbID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmGetKnowledgeBaseByOwnerAndKbID.t.Errorf("RepositoryMock.GetKnowledgeBaseByOwnerAndKbID got unexpected parameter ownerUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.expectationOrigins.originOwnerUID, *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

			if mm_want_ptrs.kbID != nil && !minimock.Equal(*mm_want_ptrs.kbID, mm_got.kbID) {
				mmGetKnowledgeBaseByOwnerAndKbID.t.Errorf("RepositoryMock.GetKnowledgeBaseByOwnerAndKbID got unexpected parameter kbID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.expectationOrigins.originKbID, *mm_want_ptrs.kbID, mm_got.kbID, minimock.Diff(*mm_want_ptrs.kbID, mm_got.kbID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBaseByOwnerAndKbID.t.Errorf("RepositoryMock.GetKnowledgeBaseByOwnerAndKbID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBaseByOwnerAndKbID.t.Fatal("No results are set for the RepositoryMock.GetKnowledgeBaseByOwnerAndKbID")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmGetKnowledgeBaseByOwnerAndKbID.funcGetKnowledgeBaseByOwnerAndKbID != nil {
		return mmGetKnowledgeBaseByOwnerAndKbID.funcGetKnowledgeBaseByOwnerAndKbID(ctx, ownerUID, kbID)
	}
	mmGetKnowledgeBaseByOwnerAndKbID.t.Fatalf("Unexpected call to RepositoryMock.GetKnowledgeBaseByOwnerAndKbID. %v %v %v", ctx, ownerUID, kbID)
	return
}

// GetKnowledgeBaseByOwnerAndKbIDAfterCounter returns a count of finished RepositoryMock.GetKnowledgeBaseByOwnerAndKbID invocations
func (mmGetKnowledgeBaseByOwnerAndKbID *RepositoryMock) GetKnowledgeBaseByOwnerAndKbIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseByOwnerAndKbID.afterGetKnowledgeBaseByOwnerAndKbIDCounter)
}

// GetKnowledgeBaseByOwnerAndKbIDBeforeCounter returns a count of RepositoryMock.GetKnowledgeBaseByOwnerAndKbID invocations
func (mmGetKnowledgeBaseByOwnerAndKbID *RepositoryMock) GetKnowledgeBaseByOwnerAndKbIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseByOwnerAndKbID.beforeGetKnowledgeBaseByOwnerAndKbIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetKnowledgeBaseByOwnerAndKbID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID) Calls() []*RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParams {
	mmGetKnowledgeBaseByOwnerAndKbID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParams, len(mmGetKnowledgeBaseByOwnerAndKbID.callArgs))
	copy(argCopy, mmGetKnowledgeBaseByOwnerAndKbID.callArgs)

	mmGetKnowledgeBaseByOwnerAndKbID.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBaseByOwnerAndKbIDDone returns true if the count of the GetKnowledgeBaseByOwnerAndKbID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetKnowledgeBaseByOwnerAndKbIDDone() bool {
	if m.GetKnowledgeBaseByOwnerAndKbIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetKnowledgeBaseByOwnerAndKbIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBaseByOwnerAndKbIDMock.invocationsDone()
}

// MinimockGetKnowledgeBaseByOwnerAndKbIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetKnowledgeBaseByOwnerAndKbIDInspect() {
	for _, e := range m.GetKnowledgeBaseByOwnerAndKbIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByOwnerAndKbID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetKnowledgeBaseByOwnerAndKbIDCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBaseByOwnerAndKbIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation != nil && afterGetKnowledgeBaseByOwnerAndKbIDCounter < 1 {
		if m.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByOwnerAndKbID at\n%s", m.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByOwnerAndKbID at\n%s with params: %#v", m.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.expectationOrigins.origin, *m.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBaseByOwnerAndKbID != nil && afterGetKnowledgeBaseByOwnerAndKbIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByOwnerAndKbID at\n%s", m.funcGetKnowledgeBaseByOwnerAndKbIDOrigin)
	}

	if !m.GetKnowledgeBaseByOwnerAndKbIDMock.invocationsDone() && afterGetKnowledgeBaseByOwnerAndKbIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetKnowledgeBaseByOwnerAndKbID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBaseByOwnerAndKbIDMock.expectedInvocations), m.GetKnowledgeBaseByOwnerAndKbIDMock.expectedInvocationsOrigin, afterGetKnowledgeBaseByOwnerAndKbIDCounter)
	}
}

type mRepositoryMockGetKnowledgeBaseByUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetKnowledgeBaseByUIDExpectation
	expectations       []*RepositoryMockGetKnowledgeBaseByUIDExpectation

	callArgs []*RepositoryMockGetKnowledgeBaseByUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetKnowledgeBaseByUIDExpectation specifies expectation struct of the Repository.GetKnowledgeBaseByUID
type RepositoryMockGetKnowledgeBaseByUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetKnowledgeBaseByUIDParams
	paramPtrs          *RepositoryMockGetKnowledgeBaseByUIDParamPtrs
	expectationOrigins RepositoryMockGetKnowledgeBaseByUIDExpectationOrigins
	results            *RepositoryMockGetKnowledgeBaseByUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetKnowledgeBaseByUIDParams contains parameters of the Repository.GetKnowledgeBaseByUID
type RepositoryMockGetKnowledgeBaseByUIDParams struct {
	ctx context.Context
	k1  types.KBUIDType
}

// RepositoryMockGetKnowledgeBaseByUIDParamPtrs contains pointers to parameters of the Repository.GetKnowledgeBaseByUID
type RepositoryMockGetKnowledgeBaseByUIDParamPtrs struct {
	ctx *context.Context
	k1  *types.KBUIDType
}

// RepositoryMockGetKnowledgeBaseByUIDResults contains results of the Repository.GetKnowledgeBaseByUID
type RepositoryMockGetKnowledgeBaseByUIDResults struct {
	kp1 *mm_repository.KnowledgeBaseModel
	err error
}

// RepositoryMockGetKnowledgeBaseByUIDOrigins contains origins of expectations of the Repository.GetKnowledgeBaseByUID
type RepositoryMockGetKnowledgeBaseByUIDExpectationOrigins struct {
	origin    string
	originCtx string
	originK1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetKnowledgeBaseByUID *mRepositoryMockGetKnowledgeBaseByUID) Optional() *mRepositoryMockGetKnowledgeBaseByUID {
	mmGetKnowledgeBaseByUID.optional = true
	return mmGetKnowledgeBaseByUID
}

// Expect sets up expected params for Repository.GetKnowledgeBaseByUID
func (mmGetKnowledgeBaseByUID *mRepositoryMockGetKnowledgeBaseByUID) Expect(ctx context.Context, k1 types.KBUIDType) *mRepositoryMockGetKnowledgeBaseByUID {
	if mmGetKnowledgeBaseByUID.mock.funcGetKnowledgeBaseByUID != nil {
		mmGetKnowledgeBaseByUID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByUID.defaultExpectation == nil {
		mmGetKnowledgeBaseByUID.defaultExpectation = &RepositoryMockGetKnowledgeBaseByUIDExpectation{}
	}

	if mmGetKnowledgeBaseByUID.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBaseByUID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUID mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBaseByUID.defaultExpectation.params = &RepositoryMockGetKnowledgeBaseByUIDParams{ctx, k1}
	mmGetKnowledgeBaseByUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetKnowledgeBaseByUID.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBaseByUID.defaultExpectation.params) {
			mmGetKnowledgeBaseByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBaseByUID.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBaseByUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetKnowledgeBaseByUID
func (mmGetKnowledgeBaseByUID *mRepositoryMockGetKnowledgeBaseByUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetKnowledgeBaseByUID {
	if mmGetKnowledgeBaseByUID.mock.funcGetKnowledgeBaseByUID != nil {
		mmGetKnowledgeBaseByUID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByUID.defaultExpectation == nil {
		mmGetKnowledgeBaseByUID.defaultExpectation = &RepositoryMockGetKnowledgeBaseByUIDExpectation{}
	}

	if mmGetKnowledgeBaseByUID.defaultExpectation.params != nil {
		mmGetKnowledgeBaseByUID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUID mock is already set by Expect")
	}

	if mmGetKnowledgeBaseByUID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseByUID.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseByUIDParamPtrs{}
	}
	mmGetKnowledgeBaseByUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetKnowledgeBaseByUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseByUID
}

// ExpectK1Param2 sets up expected param k1 for Repository.GetKnowledgeBaseByUID
func (mmGetKnowledgeBaseByUID *mRepositoryMockGetKnowledgeBaseByUID) ExpectK1Param2(k1 types.KBUIDType) *mRepositoryMockGetKnowledgeBaseByUID {
	if mmGetKnowledgeBaseByUID.mock.funcGetKnowledgeBaseByUID != nil {
		mmGetKnowledgeBaseByUID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByUID.defaultExpectation == nil {
		mmGetKnowledgeBaseByUID.defaultExpectation = &RepositoryMockGetKnowledgeBaseByUIDExpectation{}
	}

	if mmGetKnowledgeBaseByUID.defaultExpectation.params != nil {
		mmGetKnowledgeBaseByUID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUID mock is already set by Expect")
	}

	if mmGetKnowledgeBaseByUID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseByUID.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseByUIDParamPtrs{}
	}
	mmGetKnowledgeBaseByUID.defaultExpectation.paramPtrs.k1 = &k1
	mmGetKnowledgeBaseByUID.defaultExpectation.expectationOrigins.originK1 = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseByUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetKnowledgeBaseByUID
func (mmGetKnowledgeBaseByUID *mRepositoryMockGetKnowledgeBaseByUID) Inspect(f func(ctx context.Context, k1 types.KBUIDType)) *mRepositoryMockGetKnowledgeBaseByUID {
	if mmGetKnowledgeBaseByUID.mock.inspectFuncGetKnowledgeBaseByUID != nil {
		mmGetKnowledgeBaseByUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetKnowledgeBaseByUID")
	}

	mmGetKnowledgeBaseByUID.mock.inspectFuncGetKnowledgeBaseByUID = f

	return mmGetKnowledgeBaseByUID
}

// Return sets up results that will be returned by Repository.GetKnowledgeBaseByUID
func (mmGetKnowledgeBaseByUID *mRepositoryMockGetKnowledgeBaseByUID) Return(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	if mmGetKnowledgeBaseByUID.mock.funcGetKnowledgeBaseByUID != nil {
		mmGetKnowledgeBaseByUID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByUID.defaultExpectation == nil {
		mmGetKnowledgeBaseByUID.defaultExpectation = &RepositoryMockGetKnowledgeBaseByUIDExpectation{mock: mmGetKnowledgeBaseByUID.mock}
	}
	mmGetKnowledgeBaseByUID.defaultExpectation.results = &RepositoryMockGetKnowledgeBaseByUIDResults{kp1, err}
	mmGetKnowledgeBaseByUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseByUID.mock
}

// Set uses given function f to mock the Repository.GetKnowledgeBaseByUID method
func (mmGetKnowledgeBaseByUID *mRepositoryMockGetKnowledgeBaseByUID) Set(f func(ctx context.Context, k1 types.KBUIDType) (kp1 *mm_repository.KnowledgeBaseModel, err error)) *RepositoryMock {
	if mmGetKnowledgeBaseByUID.defaultExpectation != nil {
		mmGetKnowledgeBaseByUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetKnowledgeBaseByUID method")
	}

	if len(mmGetKnowledgeBaseByUID.expectations) > 0 {
		mmGetKnowledgeBaseByUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetKnowledgeBaseByUID method")
	}

	mmGetKnowledgeBaseByUID.mock.funcGetKnowledgeBaseByUID = f
	mmGetKnowledgeBaseByUID.mock.funcGetKnowledgeBaseByUIDOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseByUID.mock
}

// When sets expectation for the Repository.GetKnowledgeBaseByUID which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBaseByUID *mRepositoryMockGetKnowledgeBaseByUID) When(ctx context.Context, k1 types.KBUIDType) *RepositoryMockGetKnowledgeBaseByUIDExpectation {
	if mmGetKnowledgeBaseByUID.mock.funcGetKnowledgeBaseByUID != nil {
		mmGetKnowledgeBaseByUID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetKnowledgeBaseByUIDExpectation{
		mock:               mmGetKnowledgeBaseByUID.mock,
		params:             &RepositoryMockGetKnowledgeBaseByUIDParams{ctx, k1},
		expectationOrigins: RepositoryMockGetKnowledgeBaseByUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetKnowledgeBaseByUID.expectations = append(mmGetKnowledgeBaseByUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetKnowledgeBaseByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetKnowledgeBaseByUIDExpectation) Then(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetKnowledgeBaseByUIDResults{kp1, err}
	return e.mock
}

// Times sets number of times Repository.GetKnowledgeBaseByUID should be invoked
func (mmGetKnowledgeBaseByUID *mRepositoryMockGetKnowledgeBaseByUID) Times(n uint64) *mRepositoryMockGetKnowledgeBaseByUID {
	if n == 0 {
		mmGetKnowledgeBaseByUID.mock.t.Fatalf("Times of RepositoryMock.GetKnowledgeBaseByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBaseByUID.expectedInvocations, n)
	mmGetKnowledgeBaseByUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseByUID
}

func (mmGetKnowledgeBaseByUID *mRepositoryMockGetKnowledgeBaseByUID) invocationsDone() bool {
	if len(mmGetKnowledgeBaseByUID.expectations) == 0 && mmGetKnowledgeBaseByUID.defaultExpectation == nil && mmGetKnowledgeBaseByUID.mock.funcGetKnowledgeBaseByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseByUID.mock.afterGetKnowledgeBaseByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBaseByUID implements mm_repository.Repository
func (mmGetKnowledgeBaseByUID *RepositoryMock) GetKnowledgeBaseByUID(ctx context.Context, k1 types.KBUIDType) (kp1 *mm_repository.KnowledgeBaseModel, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBaseByUID.beforeGetKnowledgeBaseByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBaseByUID.afterGetKnowledgeBaseByUIDCounter, 1)

	mmGetKnowledgeBaseByUID.t.Helper()

	if mmGetKnowledgeBaseByUID.inspectFuncGetKnowledgeBaseByUID != nil {
		mmGetKnowledgeBaseByUID.inspectFuncGetKnowledgeBaseByUID(ctx, k1)
	}

	mm_params := RepositoryMockGetKnowledgeBaseByUIDParams{ctx, k1}

	// Record call args
	mmGetKnowledgeBaseByUID.GetKnowledgeBaseByUIDMock.mutex.Lock()
	mmGetKnowledgeBaseByUID.GetKnowledgeBaseByUIDMock.callArgs = append(mmGetKnowledgeBaseByUID.GetKnowledgeBaseByUIDMock.callArgs, &mm_params)
	mmGetKnowledgeBaseByUID.GetKnowledgeBaseByUIDMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBaseByUID.GetKnowledgeBaseByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmGetKnowledgeBaseByUID.GetKnowledgeBaseByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBaseByUID.GetKnowledgeBaseByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBaseByUID.GetKnowledgeBaseByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBaseByUID.GetKnowledgeBaseByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetKnowledgeBaseByUIDParams{ctx, k1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBaseByUID.t.Errorf("RepositoryMock.GetKnowledgeBaseByUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseByUID.GetKnowledgeBaseByUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.k1 != nil && !minimock.Equal(*mm_want_ptrs.k1, mm_got.k1) {
				mmGetKnowledgeBaseByUID.t.Errorf("RepositoryMock.GetKnowledgeBaseByUID got unexpected parameter k1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseByUID.GetKnowledgeBaseByUIDMock.defaultExpectation.expectationOrigins.originK1, *mm_want_ptrs.k1, mm_got.k1, minimock.Diff(*mm_want_ptrs.k1, mm_got.k1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBaseByUID.t.Errorf("RepositoryMock.GetKnowledgeBaseByUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetKnowledgeBaseByUID.GetKnowledgeBaseByUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBaseByUID.GetKnowledgeBaseByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBaseByUID.t.Fatal("No results are set for the RepositoryMock.GetKnowledgeBaseByUID")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmGetKnowledgeBaseByUID.funcGetKnowledgeBaseByUID != nil {
		return mmGetKnowledgeBaseByUID.funcGetKnowledgeBaseByUID(ctx, k1)
	}
	mmGetKnowledgeBaseByUID.t.Fatalf("Unexpected call to RepositoryMock.GetKnowledgeBaseByUID. %v %v", ctx, k1)
	return
}

// GetKnowledgeBaseByUIDAfterCounter returns a count of finished RepositoryMock.GetKnowledgeBaseByUID invocations
func (mmGetKnowledgeBaseByUID *RepositoryMock) GetKnowledgeBaseByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseByUID.afterGetKnowledgeBaseByUIDCounter)
}

// GetKnowledgeBaseByUIDBeforeCounter returns a count of RepositoryMock.GetKnowledgeBaseByUID invocations
func (mmGetKnowledgeBaseByUID *RepositoryMock) GetKnowledgeBaseByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseByUID.beforeGetKnowledgeBaseByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetKnowledgeBaseByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBaseByUID *mRepositoryMockGetKnowledgeBaseByUID) Calls() []*RepositoryMockGetKnowledgeBaseByUIDParams {
	mmGetKnowledgeBaseByUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetKnowledgeBaseByUIDParams, len(mmGetKnowledgeBaseByUID.callArgs))
	copy(argCopy, mmGetKnowledgeBaseByUID.callArgs)

	mmGetKnowledgeBaseByUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBaseByUIDDone returns true if the count of the GetKnowledgeBaseByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetKnowledgeBaseByUIDDone() bool {
	if m.GetKnowledgeBaseByUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetKnowledgeBaseByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBaseByUIDMock.invocationsDone()
}

// MinimockGetKnowledgeBaseByUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetKnowledgeBaseByUIDInspect() {
	for _, e := range m.GetKnowledgeBaseByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetKnowledgeBaseByUIDCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBaseByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBaseByUIDMock.defaultExpectation != nil && afterGetKnowledgeBaseByUIDCounter < 1 {
		if m.GetKnowledgeBaseByUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByUID at\n%s", m.GetKnowledgeBaseByUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByUID at\n%s with params: %#v", m.GetKnowledgeBaseByUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetKnowledgeBaseByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBaseByUID != nil && afterGetKnowledgeBaseByUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByUID at\n%s", m.funcGetKnowledgeBaseByUIDOrigin)
	}

	if !m.GetKnowledgeBaseByUIDMock.invocationsDone() && afterGetKnowledgeBaseByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetKnowledgeBaseByUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBaseByUIDMock.expectedInvocations), m.GetKnowledgeBaseByUIDMock.expectedInvocationsOrigin, afterGetKnowledgeBaseByUIDCounter)
	}
}

type mRepositoryMockGetKnowledgeBaseByUIDIncludingDeleted struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedExpectation
	expectations       []*RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedExpectation

	callArgs []*RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedExpectation specifies expectation struct of the Repository.GetKnowledgeBaseByUIDIncludingDeleted
type RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedParams
	paramPtrs          *RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedParamPtrs
	expectationOrigins RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedExpectationOrigins
	results            *RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedParams contains parameters of the Repository.GetKnowledgeBaseByUIDIncludingDeleted
type RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedParams struct {
	ctx   context.Context
	kbUID types.KBUIDType
}

// RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedParamPtrs contains pointers to parameters of the Repository.GetKnowledgeBaseByUIDIncludingDeleted
type RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedParamPtrs struct {
	ctx   *context.Context
	kbUID *types.KBUIDType
}

// RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedResults contains results of the Repository.GetKnowledgeBaseByUIDIncludingDeleted
type RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedResults struct {
	kp1 *mm_repository.KnowledgeBaseModel
	err error
}

// RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedOrigins contains origins of expectations of the Repository.GetKnowledgeBaseByUIDIncludingDeleted
type RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedExpectationOrigins struct {
	origin      string
	originCtx   string
	originKbUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetKnowledgeBaseByUIDIncludingDeleted *mRepositoryMockGetKnowledgeBaseByUIDIncludingDeleted) Optional() *mRepositoryMockGetKnowledgeBaseByUIDIncludingDeleted {
	mmGetKnowledgeBaseByUIDIncludingDeleted.optional = true
	return mmGetKnowledgeBaseByUIDIncludingDeleted
}

// Expect sets up expected params for Repository.GetKnowledgeBaseByUIDIncludingDeleted
func (mmGetKnowledgeBaseByUIDIncludingDeleted *mRepositoryMockGetKnowledgeBaseByUIDIncludingDeleted) Expect(ctx context.Context, kbUID types.KBUIDType) *mRepositoryMockGetKnowledgeBaseByUIDIncludingDeleted {
	if mmGetKnowledgeBaseByUIDIncludingDeleted.mock.funcGetKnowledgeBaseByUIDIncludingDeleted != nil {
		mmGetKnowledgeBaseByUIDIncludingDeleted.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUIDIncludingDeleted mock is already set by Set")
	}

	if mmGetKnowledgeBaseByUIDIncludingDeleted.defaultExpectation == nil {
		mmGetKnowledgeBaseByUIDIncludingDeleted.defaultExpectation = &RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedExpectation{}
	}

	if mmGetKnowledgeBaseByUIDIncludingDeleted.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBaseByUIDIncludingDeleted.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUIDIncludingDeleted mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBaseByUIDIncludingDeleted.defaultExpectation.params = &RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedParams{ctx, kbUID}
	mmGetKnowledgeBaseByUIDIncludingDeleted.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetKnowledgeBaseByUIDIncludingDeleted.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBaseByUIDIncludingDeleted.defaultExpectation.params) {
			mmGetKnowledgeBaseByUIDIncludingDeleted.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBaseByUIDIncludingDeleted.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBaseByUIDIncludingDeleted
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetKnowledgeBaseByUIDIncludingDeleted
func (mmGetKnowledgeBaseByUIDIncludingDeleted *mRepositoryMockGetKnowledgeBaseByUIDIncludingDeleted) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetKnowledgeBaseByUIDIncludingDeleted {
	if mmGetKnowledgeBaseByUIDIncludingDeleted.mock.funcGetKnowledgeBaseByUIDIncludingDeleted != nil {
		mmGetKnowledgeBaseByUIDIncludingDeleted.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUIDIncludingDeleted mock is already set by Set")
	}

	if mmGetKnowledgeBaseByUIDIncludingDeleted.defaultExpectation == nil {
		mmGetKnowledgeBaseByUIDIncludingDeleted.defaultExpectation = &RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedExpectation{}
	}

	if mmGetKnowledgeBaseByUIDIncludingDeleted.defaultExpectation.params != nil {
		mmGetKnowledgeBaseByUIDIncludingDeleted.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUIDIncludingDeleted mock is already set by Expect")
	}

	if mmGetKnowledgeBaseByUIDIncludingDeleted.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseByUIDIncludingDeleted.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedParamPtrs{}
	}
	mmGetKnowledgeBaseByUIDIncludingDeleted.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetKnowledgeBaseByUIDIncludingDeleted.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseByUIDIncludingDeleted
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.GetKnowledgeBaseByUIDIncludingDeleted
func (mmGetKnowledgeBaseByUIDIncludingDeleted *mRepositoryMockGetKnowledgeBaseByUIDIncludingDeleted) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockGetKnowledgeBaseByUIDIncludingDeleted {
	if mmGetKnowledgeBaseByUIDIncludingDeleted.mock.funcGetKnowledgeBaseByUIDIncludingDeleted != nil {
		mmGetKnowledgeBaseByUIDIncludingDeleted.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUIDIncludingDeleted mock is already set by Set")
	}

	if mmGetKnowledgeBaseByUIDIncludingDeleted.defaultExpectation == nil {
		mmGetKnowledgeBaseByUIDIncludingDeleted.defaultExpectation = &RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedExpectation{}
	}

	if mmGetKnowledgeBaseByUIDIncludingDeleted.defaultExpectation.params != nil {
		mmGetKnowledgeBaseByUIDIncludingDeleted.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUIDIncludingDeleted mock is already set by Expect")
	}

	if mmGetKnowledgeBaseByUIDIncludingDeleted.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseByUIDIncludingDeleted.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedParamPtrs{}
	}
	mmGetKnowledgeBaseByUIDIncludingDeleted.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmGetKnowledgeBaseByUIDIncludingDeleted.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseByUIDIncludingDeleted
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetKnowledgeBaseByUIDIncludingDeleted
func (mmGetKnowledgeBaseByUIDIncludingDeleted *mRepositoryMockGetKnowledgeBaseByUIDIncludingDeleted) Inspect(f func(ctx context.Context, kbUID types.KBUIDType)) *mRepositoryMockGetKnowledgeBaseByUIDIncludingDeleted {
	if mmGetKnowledgeBaseByUIDIncludingDeleted.mock.inspectFuncGetKnowledgeBaseByUIDIncludingDeleted != nil {
		mmGetKnowledgeBaseByUIDIncludingDeleted.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetKnowledgeBaseByUIDIncludingDeleted")
	}

	mmGetKnowledgeBaseByUIDIncludingDeleted.mock.inspectFuncGetKnowledgeBaseByUIDIncludingDeleted = f

	return mmGetKnowledgeBaseByUIDIncludingDeleted
}

// Return sets up results that will be returned by Repository.GetKnowledgeBaseByUIDIncludingDeleted
func (mmGetKnowledgeBaseByUIDIncludingDeleted *mRepositoryMockGetKnowledgeBaseByUIDIncludingDeleted) Return(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	if mmGetKnowledgeBaseByUIDIncludingDeleted.mock.funcGetKnowledgeBaseByUIDIncludingDeleted != nil {
		mmGetKnowledgeBaseByUIDIncludingDeleted.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUIDIncludingDeleted mock is already set by Set")
	}

	if mmGetKnowledgeBaseByUIDIncludingDeleted.defaultExpectation == nil {
		mmGetKnowledgeBaseByUIDIncludingDeleted.defaultExpectation = &RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedExpectation{mock: mmGetKnowledgeBaseByUIDIncludingDeleted.mock}
	}
	mmGetKnowledgeBaseByUIDIncludingDeleted.defaultExpectation.results = &RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedResults{kp1, err}
	mmGetKnowledgeBaseByUIDIncludingDeleted.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseByUIDIncludingDeleted.mock
}

// Set uses given function f to mock the Repository.GetKnowledgeBaseByUIDIncludingDeleted method
func (mmGetKnowledgeBaseByUIDIncludingDeleted *mRepositoryMockGetKnowledgeBaseByUIDIncludingDeleted) Set(f func(ctx context.Context, kbUID types.KBUIDType) (kp1 *mm_repository.KnowledgeBaseModel, err error)) *RepositoryMock {
	if mmGetKnowledgeBaseByUIDIncludingDeleted.defaultExpectation != nil {
		mmGetKnowledgeBaseByUIDIncludingDeleted.mock.t.Fatalf("Default expectation is already set for the Repository.GetKnowledgeBaseByUIDIncludingDeleted method")
	}

	if len(mmGetKnowledgeBaseByUIDIncludingDeleted.expectations) > 0 {
		mmGetKnowledgeBaseByUIDIncludingDeleted.mock.t.Fatalf("Some expectations are already set for the Repository.GetKnowledgeBaseByUIDIncludingDeleted method")
	}

	mmGetKnowledgeBaseByUIDIncludingDeleted.mock.funcGetKnowledgeBaseByUIDIncludingDeleted = f
	mmGetKnowledgeBaseByUIDIncludingDeleted.mock.funcGetKnowledgeBaseByUIDIncludingDeletedOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseByUIDIncludingDeleted.mock
}

// When sets expectation for the Repository.GetKnowledgeBaseByUIDIncludingDeleted which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBaseByUIDIncludingDeleted *mRepositoryMockGetKnowledgeBaseByUIDIncludingDeleted) When(ctx context.Context, kbUID types.KBUIDType) *RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedExpectation {
	if mmGetKnowledgeBaseByUIDIncludingDeleted.mock.funcGetKnowledgeBaseByUIDIncludingDeleted != nil {
		mmGetKnowledgeBaseByUIDIncludingDeleted.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUIDIncludingDeleted mock is already set by Set")
	}

	expectation := &RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedExpectation{
		mock:               mmGetKnowledgeBaseByUIDIncludingDeleted.mock,
		params:             &RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedParams{ctx, kbUID},
		expectationOrigins: RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetKnowledgeBaseByUIDIncludingDeleted.expectations = append(mmGetKnowledgeBaseByUIDIncludingDeleted.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetKnowledgeBaseByUIDIncludingDeleted return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedExpectation) Then(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedResults{kp1, err}
	return e.mock
}

// Times sets number of times Repository.GetKnowledgeBaseByUIDIncludingDeleted should be invoked
func (mmGetKnowledgeBaseByUIDIncludingDeleted *mRepositoryMockGetKnowledgeBaseByUIDIncludingDeleted) Times(n uint64) *mRepositoryMockGetKnowledgeBaseByUIDIncludingDeleted {
	if n == 0 {
		mmGetKnowledgeBaseByUIDIncludingDeleted.mock.t.Fatalf("Times of RepositoryMock.GetKnowledgeBaseByUIDIncludingDeleted mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBaseByUIDIncludingDeleted.expectedInvocations, n)
	mmGetKnowledgeBaseByUIDIncludingDeleted.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseByUIDIncludingDeleted
}

func (mmGetKnowledgeBaseByUIDIncludingDeleted *mRepositoryMockGetKnowledgeBaseByUIDIncludingDeleted) invocationsDone() bool {
	if len(mmGetKnowledgeBaseByUIDIncludingDeleted.expectations) == 0 && mmGetKnowledgeBaseByUIDIncludingDeleted.defaultExpectation == nil && mmGetKnowledgeBaseByUIDIncludingDeleted.mock.funcGetKnowledgeBaseByUIDIncludingDeleted == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseByUIDIncludingDeleted.mock.afterGetKnowledgeBaseByUIDIncludingDeletedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseByUIDIncludingDeleted.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBaseByUIDIncludingDeleted implements mm_repository.Repository
func (mmGetKnowledgeBaseByUIDIncludingDeleted *RepositoryMock) GetKnowledgeBaseByUIDIncludingDeleted(ctx context.Context, kbUID types.KBUIDType) (kp1 *mm_repository.KnowledgeBaseModel, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBaseByUIDIncludingDeleted.beforeGetKnowledgeBaseByUIDIncludingDeletedCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBaseByUIDIncludingDeleted.afterGetKnowledgeBaseByUIDIncludingDeletedCounter, 1)

	mmGetKnowledgeBaseByUIDIncludingDeleted.t.Helper()

	if mmGetKnowledgeBaseByUIDIncludingDeleted.inspectFuncGetKnowledgeBaseByUIDIncludingDeleted != nil {
		mmGetKnowledgeBaseByUIDIncludingDeleted.inspectFuncGetKnowledgeBaseByUIDIncludingDeleted(ctx, kbUID)
	}

	mm_params := RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedParams{ctx, kbUID}

	// Record call args
	mmGetKnowledgeBaseByUIDIncludingDeleted.GetKnowledgeBaseByUIDIncludingDeletedMock.mutex.Lock()
	mmGetKnowledgeBaseByUIDIncludingDeleted.GetKnowledgeBaseByUIDIncludingDeletedMock.callArgs = append(mmGetKnowledgeBaseByUIDIncludingDeleted.GetKnowledgeBaseByUIDIncludingDeletedMock.callArgs, &mm_params)
	mmGetKnowledgeBaseByUIDIncludingDeleted.GetKnowledgeBaseByUIDIncludingDeletedMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBaseByUIDIncludingDeleted.GetKnowledgeBaseByUIDIncludingDeletedMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmGetKnowledgeBaseByUIDIncludingDeleted.GetKnowledgeBaseByUIDIncludingDeletedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBaseByUIDIncludingDeleted.GetKnowledgeBaseByUIDIncludingDeletedMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBaseByUIDIncludingDeleted.GetKnowledgeBaseByUIDIncludingDeletedMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBaseByUIDIncludingDeleted.GetKnowledgeBaseByUIDIncludingDeletedMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedParams{ctx, kbUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBaseByUIDIncludingDeleted.t.Errorf("RepositoryMock.GetKnowledgeBaseByUIDIncludingDeleted got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseByUIDIncludingDeleted.GetKnowledgeBaseByUIDIncludingDeletedMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmGetKnowledgeBaseByUIDIncludingDeleted.t.Errorf("RepositoryMock.GetKnowledgeBaseByUIDIncludingDeleted got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseByUIDIncludingDeleted.GetKnowledgeBaseByUIDIncludingDeletedMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBaseByUIDIncludingDeleted.t.Errorf("RepositoryMock.GetKnowledgeBaseByUIDIncludingDeleted got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetKnowledgeBaseByUIDIncludingDeleted.GetKnowledgeBaseByUIDIncludingDeletedMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBaseByUIDIncludingDeleted.GetKnowledgeBaseByUIDIncludingDeletedMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBaseByUIDIncludingDeleted.t.Fatal("No results are set for the RepositoryMock.GetKnowledgeBaseByUIDIncludingDeleted")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmGetKnowledgeBaseByUIDIncludingDeleted.funcGetKnowledgeBaseByUIDIncludingDeleted != nil {
		return mmGetKnowledgeBaseByUIDIncludingDeleted.funcGetKnowledgeBaseByUIDIncludingDeleted(ctx, kbUID)
	}
	mmGetKnowledgeBaseByUIDIncludingDeleted.t.Fatalf("Unexpected call to RepositoryMock.GetKnowledgeBaseByUIDIncludingDeleted. %v %v", ctx, kbUID)
	return
}

// GetKnowledgeBaseByUIDIncludingDeletedAfterCounter returns a count of finished RepositoryMock.GetKnowledgeBaseByUIDIncludingDeleted invocations
func (mmGetKnowledgeBaseByUIDIncludingDeleted *RepositoryMock) GetKnowledgeBaseByUIDIncludingDeletedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseByUIDIncludingDeleted.afterGetKnowledgeBaseByUIDIncludingDeletedCounter)
}

// GetKnowledgeBaseByUIDIncludingDeletedBeforeCounter returns a count of RepositoryMock.GetKnowledgeBaseByUIDIncludingDeleted invocations
func (mmGetKnowledgeBaseByUIDIncludingDeleted *RepositoryMock) GetKnowledgeBaseByUIDIncludingDeletedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseByUIDIncludingDeleted.beforeGetKnowledgeBaseByUIDIncludingDeletedCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetKnowledgeBaseByUIDIncludingDeleted.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBaseByUIDIncludingDeleted *mRepositoryMockGetKnowledgeBaseByUIDIncludingDeleted) Calls() []*RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedParams {
	mmGetKnowledgeBaseByUIDIncludingDeleted.mutex.RLock()

	argCopy := make([]*RepositoryMockGetKnowledgeBaseByUIDIncludingDeletedParams, len(mmGetKnowledgeBaseByUIDIncludingDeleted.callArgs))
	copy(argCopy, mmGetKnowledgeBaseByUIDIncludingDeleted.callArgs)

	mmGetKnowledgeBaseByUIDIncludingDeleted.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBaseByUIDIncludingDeletedDone returns true if the count of the GetKnowledgeBaseByUIDIncludingDeleted invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetKnowledgeBaseByUIDIncludingDeletedDone() bool {
	if m.GetKnowledgeBaseByUIDIncludingDeletedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetKnowledgeBaseByUIDIncludingDeletedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBaseByUIDIncludingDeletedMock.invocationsDone()
}

// MinimockGetKnowledgeBaseByUIDIncludingDeletedInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetKnowledgeBaseByUIDIncludingDeletedInspect() {
	for _, e := range m.GetKnowledgeBaseByUIDIncludingDeletedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByUIDIncludingDeleted at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetKnowledgeBaseByUIDIncludingDeletedCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBaseByUIDIncludingDeletedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBaseByUIDIncludingDeletedMock.defaultExpectation != nil && afterGetKnowledgeBaseByUIDIncludingDeletedCounter < 1 {
		if m.GetKnowledgeBaseByUIDIncludingDeletedMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByUIDIncludingDeleted at\n%s", m.GetKnowledgeBaseByUIDIncludingDeletedMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByUIDIncludingDeleted at\n%s with params: %#v", m.GetKnowledgeBaseByUIDIncludingDeletedMock.defaultExpectation.expectationOrigins.origin, *m.GetKnowledgeBaseByUIDIncludingDeletedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBaseByUIDIncludingDeleted != nil && afterGetKnowledgeBaseByUIDIncludingDeletedCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByUIDIncludingDeleted at\n%s", m.funcGetKnowledgeBaseByUIDIncludingDeletedOrigin)
	}

	if !m.GetKnowledgeBaseByUIDIncludingDeletedMock.invocationsDone() && afterGetKnowledgeBaseByUIDIncludingDeletedCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetKnowledgeBaseByUIDIncludingDeleted at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBaseByUIDIncludingDeletedMock.expectedInvocations), m.GetKnowledgeBaseByUIDIncludingDeletedMock.expectedInvocationsOrigin, afterGetKnowledgeBaseByUIDIncludingDeletedCounter)
	}
}

type mRepositoryMockGetKnowledgeBaseByUIDWithConfig struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetKnowledgeBaseByUIDWithConfigExpectation
	expectations       []*RepositoryMockGetKnowledgeBaseByUIDWithConfigExpectation

	callArgs []*RepositoryMockGetKnowledgeBaseByUIDWithConfigParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetKnowledgeBaseByUIDWithConfigExpectation specifies expectation struct of the Repository.GetKnowledgeBaseByUIDWithConfig
type RepositoryMockGetKnowledgeBaseByUIDWithConfigExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetKnowledgeBaseByUIDWithConfigParams
	paramPtrs          *RepositoryMockGetKnowledgeBaseByUIDWithConfigParamPtrs
	expectationOrigins RepositoryMockGetKnowledgeBaseByUIDWithConfigExpectationOrigins
	results            *RepositoryMockGetKnowledgeBaseByUIDWithConfigResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetKnowledgeBaseByUIDWithConfigParams contains parameters of the Repository.GetKnowledgeBaseByUIDWithConfig
type RepositoryMockGetKnowledgeBaseByUIDWithConfigParams struct {
	ctx   context.Context
	kbUID types.KBUIDType
}

// RepositoryMockGetKnowledgeBaseByUIDWithConfigParamPtrs contains pointers to parameters of the Repository.GetKnowledgeBaseByUIDWithConfig
type RepositoryMockGetKnowledgeBaseByUIDWithConfigParamPtrs struct {
	ctx   *context.Context
	kbUID *types.KBUIDType
}

// RepositoryMockGetKnowledgeBaseByUIDWithConfigResults contains results of the Repository.GetKnowledgeBaseByUIDWithConfig
type RepositoryMockGetKnowledgeBaseByUIDWithConfigResults struct {
	kp1 *mm_repository.KnowledgeBaseWithConfig
	err error
}

// RepositoryMockGetKnowledgeBaseByUIDWithConfigOrigins contains origins of expectations of the Repository.GetKnowledgeBaseByUIDWithConfig
type RepositoryMockGetKnowledgeBaseByUIDWithConfigExpectationOrigins struct {
	origin      string
	originCtx   string
	originKbUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetKnowledgeBaseByUIDWithConfig *mRepositoryMockGetKnowledgeBaseByUIDWithConfig) Optional() *mRepositoryMockGetKnowledgeBaseByUIDWithConfig {
	mmGetKnowledgeBaseByUIDWithConfig.optional = true
	return mmGetKnowledgeBaseByUIDWithConfig
}

// Expect sets up expected params for Repository.GetKnowledgeBaseByUIDWithConfig
func (mmGetKnowledgeBaseByUIDWithConfig *mRepositoryMockGetKnowledgeBaseByUIDWithConfig) Expect(ctx context.Context, kbUID types.KBUIDType) *mRepositoryMockGetKnowledgeBaseByUIDWithConfig {
	if mmGetKnowledgeBaseByUIDWithConfig.mock.funcGetKnowledgeBaseByUIDWithConfig != nil {
		mmGetKnowledgeBaseByUIDWithConfig.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUIDWithConfig mock is already set by Set")
	}

	if mmGetKnowledgeBaseByUIDWithConfig.defaultExpectation == nil {
		mmGetKnowledgeBaseByUIDWithConfig.defaultExpectation = &RepositoryMockGetKnowledgeBaseByUIDWithConfigExpectation{}
	}

	if mmGetKnowledgeBaseByUIDWithConfig.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBaseByUIDWithConfig.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUIDWithConfig mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBaseByUIDWithConfig.defaultExpectation.params = &RepositoryMockGetKnowledgeBaseByUIDWithConfigParams{ctx, kbUID}
	mmGetKnowledgeBaseByUIDWithConfig.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetKnowledgeBaseByUIDWithConfig.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBaseByUIDWithConfig.defaultExpectation.params) {
			mmGetKnowledgeBaseByUIDWithConfig.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBaseByUIDWithConfig.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBaseByUIDWithConfig
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetKnowledgeBaseByUIDWithConfig
func (mmGetKnowledgeBaseByUIDWithConfig *mRepositoryMockGetKnowledgeBaseByUIDWithConfig) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetKnowledgeBaseByUIDWithConfig {
	if mmGetKnowledgeBaseByUIDWithConfig.mock.funcGetKnowledgeBaseByUIDWithConfig != nil {
		mmGetKnowledgeBaseByUIDWithConfig.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUIDWithConfig mock is already set by Set")
	}

	if mmGetKnowledgeBaseByUIDWithConfig.defaultExpectation == nil {
		mmGetKnowledgeBaseByUIDWithConfig.defaultExpectation = &RepositoryMockGetKnowledgeBaseByUIDWithConfigExpectation{}
	}

	if mmGetKnowledgeBaseByUIDWithConfig.defaultExpectation.params != nil {
		mmGetKnowledgeBaseByUIDWithConfig.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUIDWithConfig mock is already set by Expect")
	}

	if mmGetKnowledgeBaseByUIDWithConfig.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseByUIDWithConfig.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseByUIDWithConfigParamPtrs{}
	}
	mmGetKnowledgeBaseByUIDWithConfig.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetKnowledgeBaseByUIDWithConfig.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseByUIDWithConfig
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.GetKnowledgeBaseByUIDWithConfig
func (mmGetKnowledgeBaseByUIDWithConfig *mRepositoryMockGetKnowledgeBaseByUIDWithConfig) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockGetKnowledgeBaseByUIDWithConfig {
	if mmGetKnowledgeBaseByUIDWithConfig.mock.funcGetKnowledgeBaseByUIDWithConfig != nil {
		mmGetKnowledgeBaseByUIDWithConfig.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUIDWithConfig mock is already set by Set")
	}

	if mmGetKnowledgeBaseByUIDWithConfig.defaultExpectation == nil {
		mmGetKnowledgeBaseByUIDWithConfig.defaultExpectation = &RepositoryMockGetKnowledgeBaseByUIDWithConfigExpectation{}
	}

	if mmGetKnowledgeBaseByUIDWithConfig.defaultExpectation.params != nil {
		mmGetKnowledgeBaseByUIDWithConfig.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUIDWithConfig mock is already set by Expect")
	}

	if mmGetKnowledgeBaseByUIDWithConfig.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseByUIDWithConfig.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseByUIDWithConfigParamPtrs{}
	}
	mmGetKnowledgeBaseByUIDWithConfig.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmGetKnowledgeBaseByUIDWithConfig.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseByUIDWithConfig
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetKnowledgeBaseByUIDWithConfig
func (mmGetKnowledgeBaseByUIDWithConfig *mRepositoryMockGetKnowledgeBaseByUIDWithConfig) Inspect(f func(ctx context.Context, kbUID types.KBUIDType)) *mRepositoryMockGetKnowledgeBaseByUIDWithConfig {
	if mmGetKnowledgeBaseByUIDWithConfig.mock.inspectFuncGetKnowledgeBaseByUIDWithConfig != nil {
		mmGetKnowledgeBaseByUIDWithConfig.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetKnowledgeBaseByUIDWithConfig")
	}

	mmGetKnowledgeBaseByUIDWithConfig.mock.inspectFuncGetKnowledgeBaseByUIDWithConfig = f

	return mmGetKnowledgeBaseByUIDWithConfig
}

// Return sets up results that will be returned by Repository.GetKnowledgeBaseByUIDWithConfig
func (mmGetKnowledgeBaseByUIDWithConfig *mRepositoryMockGetKnowledgeBaseByUIDWithConfig) Return(kp1 *mm_repository.KnowledgeBaseWithConfig, err error) *RepositoryMock {
	if mmGetKnowledgeBaseByUIDWithConfig.mock.funcGetKnowledgeBaseByUIDWithConfig != nil {
		mmGetKnowledgeBaseByUIDWithConfig.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUIDWithConfig mock is already set by Set")
	}

	if mmGetKnowledgeBaseByUIDWithConfig.defaultExpectation == nil {
		mmGetKnowledgeBaseByUIDWithConfig.defaultExpectation = &RepositoryMockGetKnowledgeBaseByUIDWithConfigExpectation{mock: mmGetKnowledgeBaseByUIDWithConfig.mock}
	}
	mmGetKnowledgeBaseByUIDWithConfig.defaultExpectation.results = &RepositoryMockGetKnowledgeBaseByUIDWithConfigResults{kp1, err}
	mmGetKnowledgeBaseByUIDWithConfig.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseByUIDWithConfig.mock
}

// Set uses given function f to mock the Repository.GetKnowledgeBaseByUIDWithConfig method
func (mmGetKnowledgeBaseByUIDWithConfig *mRepositoryMockGetKnowledgeBaseByUIDWithConfig) Set(f func(ctx context.Context, kbUID types.KBUIDType) (kp1 *mm_repository.KnowledgeBaseWithConfig, err error)) *RepositoryMock {
	if mmGetKnowledgeBaseByUIDWithConfig.defaultExpectation != nil {
		mmGetKnowledgeBaseByUIDWithConfig.mock.t.Fatalf("Default expectation is already set for the Repository.GetKnowledgeBaseByUIDWithConfig method")
	}

	if len(mmGetKnowledgeBaseByUIDWithConfig.expectations) > 0 {
		mmGetKnowledgeBaseByUIDWithConfig.mock.t.Fatalf("Some expectations are already set for the Repository.GetKnowledgeBaseByUIDWithConfig method")
	}

	mmGetKnowledgeBaseByUIDWithConfig.mock.funcGetKnowledgeBaseByUIDWithConfig = f
	mmGetKnowledgeBaseByUIDWithConfig.mock.funcGetKnowledgeBaseByUIDWithConfigOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseByUIDWithConfig.mock
}

// When sets expectation for the Repository.GetKnowledgeBaseByUIDWithConfig which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBaseByUIDWithConfig *mRepositoryMockGetKnowledgeBaseByUIDWithConfig) When(ctx context.Context, kbUID types.KBUIDType) *RepositoryMockGetKnowledgeBaseByUIDWithConfigExpectation {
	if mmGetKnowledgeBaseByUIDWithConfig.mock.funcGetKnowledgeBaseByUIDWithConfig != nil {
		mmGetKnowledgeBaseByUIDWithConfig.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUIDWithConfig mock is already set by Set")
	}

	expectation := &RepositoryMockGetKnowledgeBaseByUIDWithConfigExpectation{
		mock:               mmGetKnowledgeBaseByUIDWithConfig.mock,
		params:             &RepositoryMockGetKnowledgeBaseByUIDWithConfigParams{ctx, kbUID},
		expectationOrigins: RepositoryMockGetKnowledgeBaseByUIDWithConfigExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetKnowledgeBaseByUIDWithConfig.expectations = append(mmGetKnowledgeBaseByUIDWithConfig.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetKnowledgeBaseByUIDWithConfig return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetKnowledgeBaseByUIDWithConfigExpectation) Then(kp1 *mm_repository.KnowledgeBaseWithConfig, err error) *RepositoryMock {
	e.results = &RepositoryMockGetKnowledgeBaseByUIDWithConfigResults{kp1, err}
	return e.mock
}

// Times sets number of times Repository.GetKnowledgeBaseByUIDWithConfig should be invoked
func (mmGetKnowledgeBaseByUIDWithConfig *mRepositoryMockGetKnowledgeBaseByUIDWithConfig) Times(n uint64) *mRepositoryMockGetKnowledgeBaseByUIDWithConfig {
	if n == 0 {
		mmGetKnowledgeBaseByUIDWithConfig.mock.t.Fatalf("Times of RepositoryMock.GetKnowledgeBaseByUIDWithConfig mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBaseByUIDWithConfig.expectedInvocations, n)
	mmGetKnowledgeBaseByUIDWithConfig.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseByUIDWithConfig
}

func (mmGetKnowledgeBaseByUIDWithConfig *mRepositoryMockGetKnowledgeBaseByUIDWithConfig) invocationsDone() bool {
	if len(mmGetKnowledgeBaseByUIDWithConfig.expectations) == 0 && mmGetKnowledgeBaseByUIDWithConfig.defaultExpectation == nil && mmGetKnowledgeBaseByUIDWithConfig.mock.funcGetKnowledgeBaseByUIDWithConfig == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseByUIDWithConfig.mock.afterGetKnowledgeBaseByUIDWithConfigCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseByUIDWithConfig.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBaseByUIDWithConfig implements mm_repository.Repository
func (mmGetKnowledgeBaseByUIDWithConfig *RepositoryMock) GetKnowledgeBaseByUIDWithConfig(ctx context.Context, kbUID types.KBUIDType) (kp1 *mm_repository.KnowledgeBaseWithConfig, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBaseByUIDWithConfig.beforeGetKnowledgeBaseByUIDWithConfigCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBaseByUIDWithConfig.afterGetKnowledgeBaseByUIDWithConfigCounter, 1)

	mmGetKnowledgeBaseByUIDWithConfig.t.Helper()

	if mmGetKnowledgeBaseByUIDWithConfig.inspectFuncGetKnowledgeBaseByUIDWithConfig != nil {
		mmGetKnowledgeBaseByUIDWithConfig.inspectFuncGetKnowledgeBaseByUIDWithConfig(ctx, kbUID)
	}

	mm_params := RepositoryMockGetKnowledgeBaseByUIDWithConfigParams{ctx, kbUID}

	// Record call args
	mmGetKnowledgeBaseByUIDWithConfig.GetKnowledgeBaseByUIDWithConfigMock.mutex.Lock()
	mmGetKnowledgeBaseByUIDWithConfig.GetKnowledgeBaseByUIDWithConfigMock.callArgs = append(mmGetKnowledgeBaseByUIDWithConfig.GetKnowledgeBaseByUIDWithConfigMock.callArgs, &mm_params)
	mmGetKnowledgeBaseByUIDWithConfig.GetKnowledgeBaseByUIDWithConfigMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBaseByUIDWithConfig.GetKnowledgeBaseByUIDWithConfigMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmGetKnowledgeBaseByUIDWithConfig.GetKnowledgeBaseByUIDWithConfigMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBaseByUIDWithConfig.GetKnowledgeBaseByUIDWithConfigMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBaseByUIDWithConfig.GetKnowledgeBaseByUIDWithConfigMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBaseByUIDWithConfig.GetKnowledgeBaseByUIDWithConfigMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetKnowledgeBaseByUIDWithConfigParams{ctx, kbUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBaseByUIDWithConfig.t.Errorf("RepositoryMock.GetKnowledgeBaseByUIDWithConfig got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseByUIDWithConfig.GetKnowledgeBaseByUIDWithConfigMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmGetKnowledgeBaseByUIDWithConfig.t.Errorf("RepositoryMock.GetKnowledgeBaseByUIDWithConfig got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseByUIDWithConfig.GetKnowledgeBaseByUIDWithConfigMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBaseByUIDWithConfig.t.Errorf("RepositoryMock.GetKnowledgeBaseByUIDWithConfig got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetKnowledgeBaseByUIDWithConfig.GetKnowledgeBaseByUIDWithConfigMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBaseByUIDWithConfig.GetKnowledgeBaseByUIDWithConfigMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBaseByUIDWithConfig.t.Fatal("No results are set for the RepositoryMock.GetKnowledgeBaseByUIDWithConfig")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmGetKnowledgeBaseByUIDWithConfig.funcGetKnowledgeBaseByUIDWithConfig != nil {
		return mmGetKnowledgeBaseByUIDWithConfig.funcGetKnowledgeBaseByUIDWithConfig(ctx, kbUID)
	}
	mmGetKnowledgeBaseByUIDWithConfig.t.Fatalf("Unexpected call to RepositoryMock.GetKnowledgeBaseByUIDWithConfig. %v %v", ctx, kbUID)
	return
}

// GetKnowledgeBaseByUIDWithConfigAfterCounter returns a count of finished RepositoryMock.GetKnowledgeBaseByUIDWithConfig invocations
func (mmGetKnowledgeBaseByUIDWithConfig *RepositoryMock) GetKnowledgeBaseByUIDWithConfigAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseByUIDWithConfig.afterGetKnowledgeBaseByUIDWithConfigCounter)
}

// GetKnowledgeBaseByUIDWithConfigBeforeCounter returns a count of RepositoryMock.GetKnowledgeBaseByUIDWithConfig invocations
func (mmGetKnowledgeBaseByUIDWithConfig *RepositoryMock) GetKnowledgeBaseByUIDWithConfigBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseByUIDWithConfig.beforeGetKnowledgeBaseByUIDWithConfigCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetKnowledgeBaseByUIDWithConfig.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBaseByUIDWithConfig *mRepositoryMockGetKnowledgeBaseByUIDWithConfig) Calls() []*RepositoryMockGetKnowledgeBaseByUIDWithConfigParams {
	mmGetKnowledgeBaseByUIDWithConfig.mutex.RLock()

	argCopy := make([]*RepositoryMockGetKnowledgeBaseByUIDWithConfigParams, len(mmGetKnowledgeBaseByUIDWithConfig.callArgs))
	copy(argCopy, mmGetKnowledgeBaseByUIDWithConfig.callArgs)

	mmGetKnowledgeBaseByUIDWithConfig.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBaseByUIDWithConfigDone returns true if the count of the GetKnowledgeBaseByUIDWithConfig invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetKnowledgeBaseByUIDWithConfigDone() bool {
	if m.GetKnowledgeBaseByUIDWithConfigMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetKnowledgeBaseByUIDWithConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBaseByUIDWithConfigMock.invocationsDone()
}

// MinimockGetKnowledgeBaseByUIDWithConfigInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetKnowledgeBaseByUIDWithConfigInspect() {
	for _, e := range m.GetKnowledgeBaseByUIDWithConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByUIDWithConfig at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetKnowledgeBaseByUIDWithConfigCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBaseByUIDWithConfigCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBaseByUIDWithConfigMock.defaultExpectation != nil && afterGetKnowledgeBaseByUIDWithConfigCounter < 1 {
		if m.GetKnowledgeBaseByUIDWithConfigMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByUIDWithConfig at\n%s", m.GetKnowledgeBaseByUIDWithConfigMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByUIDWithConfig at\n%s with params: %#v", m.GetKnowledgeBaseByUIDWithConfigMock.defaultExpectation.expectationOrigins.origin, *m.GetKnowledgeBaseByUIDWithConfigMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBaseByUIDWithConfig != nil && afterGetKnowledgeBaseByUIDWithConfigCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByUIDWithConfig at\n%s", m.funcGetKnowledgeBaseByUIDWithConfigOrigin)
	}

	if !m.GetKnowledgeBaseByUIDWithConfigMock.invocationsDone() && afterGetKnowledgeBaseByUIDWithConfigCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetKnowledgeBaseByUIDWithConfig at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBaseByUIDWithConfigMock.expectedInvocations), m.GetKnowledgeBaseByUIDWithConfigMock.expectedInvocationsOrigin, afterGetKnowledgeBaseByUIDWithConfigCounter)
	}
}

type mRepositoryMockGetKnowledgeBaseCountByOwner struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetKnowledgeBaseCountByOwnerExpectation
	expectations       []*RepositoryMockGetKnowledgeBaseCountByOwnerExpectation

	callArgs []*RepositoryMockGetKnowledgeBaseCountByOwnerParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetKnowledgeBaseCountByOwnerExpectation specifies expectation struct of the Repository.GetKnowledgeBaseCountByOwner
type RepositoryMockGetKnowledgeBaseCountByOwnerExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetKnowledgeBaseCountByOwnerParams
	paramPtrs          *RepositoryMockGetKnowledgeBaseCountByOwnerParamPtrs
	expectationOrigins RepositoryMockGetKnowledgeBaseCountByOwnerExpectationOrigins
	results            *RepositoryMockGetKnowledgeBaseCountByOwnerResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetKnowledgeBaseCountByOwnerParams contains parameters of the Repository.GetKnowledgeBaseCountByOwner
type RepositoryMockGetKnowledgeBaseCountByOwnerParams struct {
	ctx      context.Context
	ownerUID string
	kbType   artifactpb.KnowledgeBaseType
}

// RepositoryMockGetKnowledgeBaseCountByOwnerParamPtrs contains pointers to parameters of the Repository.GetKnowledgeBaseCountByOwner
type RepositoryMockGetKnowledgeBaseCountByOwnerParamPtrs struct {
	ctx      *context.Context
	ownerUID *string
	kbType   *artifactpb.KnowledgeBaseType
}

// RepositoryMockGetKnowledgeBaseCountByOwnerResults contains results of the Repository.GetKnowledgeBaseCountByOwner
type RepositoryMockGetKnowledgeBaseCountByOwnerResults struct {
	i1  int64
	err error
}

// RepositoryMockGetKnowledgeBaseCountByOwnerOrigins contains origins of expectations of the Repository.GetKnowledgeBaseCountByOwner
type RepositoryMockGetKnowledgeBaseCountByOwnerExpectationOrigins struct {
	origin         string
	originCtx      string
	originOwnerUID string
	originKbType   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetKnowledgeBaseCountByOwner *mRepositoryMockGetKnowledgeBaseCountByOwner) Optional() *mRepositoryMockGetKnowledgeBaseCountByOwner {
	mmGetKnowledgeBaseCountByOwner.optional = true
	return mmGetKnowledgeBaseCountByOwner
}

// Expect sets up expected params for Repository.GetKnowledgeBaseCountByOwner
func (mmGetKnowledgeBaseCountByOwner *mRepositoryMockGetKnowledgeBaseCountByOwner) Expect(ctx context.Context, ownerUID string, kbType artifactpb.KnowledgeBaseType) *mRepositoryMockGetKnowledgeBaseCountByOwner {
	if mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseCountByOwner mock is already set by Set")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation = &RepositoryMockGetKnowledgeBaseCountByOwnerExpectation{}
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseCountByOwner mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBaseCountByOwner.defaultExpectation.params = &RepositoryMockGetKnowledgeBaseCountByOwnerParams{ctx, ownerUID, kbType}
	mmGetKnowledgeBaseCountByOwner.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetKnowledgeBaseCountByOwner.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBaseCountByOwner.defaultExpectation.params) {
			mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBaseCountByOwner.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBaseCountByOwner
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetKnowledgeBaseCountByOwner
func (mmGetKnowledgeBaseCountByOwner *mRepositoryMockGetKnowledgeBaseCountByOwner) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetKnowledgeBaseCountByOwner {
	if mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseCountByOwner mock is already set by Set")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation = &RepositoryMockGetKnowledgeBaseCountByOwnerExpectation{}
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation.params != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseCountByOwner mock is already set by Expect")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseCountByOwnerParamPtrs{}
	}
	mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetKnowledgeBaseCountByOwner.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseCountByOwner
}

// ExpectOwnerUIDParam2 sets up expected param ownerUID for Repository.GetKnowledgeBaseCountByOwner
func (mmGetKnowledgeBaseCountByOwner *mRepositoryMockGetKnowledgeBaseCountByOwner) ExpectOwnerUIDParam2(ownerUID string) *mRepositoryMockGetKnowledgeBaseCountByOwner {
	if mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseCountByOwner mock is already set by Set")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation = &RepositoryMockGetKnowledgeBaseCountByOwnerExpectation{}
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation.params != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseCountByOwner mock is already set by Expect")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseCountByOwnerParamPtrs{}
	}
	mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs.ownerUID = &ownerUID
	mmGetKnowledgeBaseCountByOwner.defaultExpectation.expectationOrigins.originOwnerUID = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseCountByOwner
}

// ExpectKbTypeParam3 sets up expected param kbType for Repository.GetKnowledgeBaseCountByOwner
func (mmGetKnowledgeBaseCountByOwner *mRepositoryMockGetKnowledgeBaseCountByOwner) ExpectKbTypeParam3(kbType artifactpb.KnowledgeBaseType) *mRepositoryMockGetKnowledgeBaseCountByOwner {
	if mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseCountByOwner mock is already set by Set")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation = &RepositoryMockGetKnowledgeBaseCountByOwnerExpectation{}
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation.params != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseCountByOwner mock is already set by Expect")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseCountByOwnerParamPtrs{}
	}
	mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs.kbType = &kbType
	mmGetKnowledgeBaseCountByOwner.defaultExpectation.expectationOrigins.originKbType = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseCountByOwner
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetKnowledgeBaseCountByOwner
func (mmGetKnowledgeBaseCountByOwner *mRepositoryMockGetKnowledgeBaseCountByOwner) Inspect(f func(ctx context.Context, ownerUID string, kbType artifactpb.KnowledgeBaseType)) *mRepositoryMockGetKnowledgeBaseCountByOwner {
	if mmGetKnowledgeBaseCountByOwner.mock.inspectFuncGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetKnowledgeBaseCountByOwner")
	}

	mmGetKnowledgeBaseCountByOwner.mock.inspectFuncGetKnowledgeBaseCountByOwner = f

	return mmGetKnowledgeBaseCountByOwner
}

// Return sets up results that will be returned by Repository.GetKnowledgeBaseCountByOwner
func (mmGetKnowledgeBaseCountByOwner *mRepositoryMockGetKnowledgeBaseCountByOwner) Return(i1 int64, err error) *RepositoryMock {
	if mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseCountByOwner mock is already set by Set")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation = &RepositoryMockGetKnowledgeBaseCountByOwnerExpectation{mock: mmGetKnowledgeBaseCountByOwner.mock}
	}
	mmGetKnowledgeBaseCountByOwner.defaultExpectation.results = &RepositoryMockGetKnowledgeBaseCountByOwnerResults{i1, err}
	mmGetKnowledgeBaseCountByOwner.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseCountByOwner.mock
}

// Set uses given function f to mock the Repository.GetKnowledgeBaseCountByOwner method
func (mmGetKnowledgeBaseCountByOwner *mRepositoryMockGetKnowledgeBaseCountByOwner) Set(f func(ctx context.Context, ownerUID string, kbType artifactpb.KnowledgeBaseType) (i1 int64, err error)) *RepositoryMock {
	if mmGetKnowledgeBaseCountByOwner.defaultExpectation != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("Default expectation is already set for the Repository.GetKnowledgeBaseCountByOwner method")
	}

	if len(mmGetKnowledgeBaseCountByOwner.expectations) > 0 {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("Some expectations are already set for the Repository.GetKnowledgeBaseCountByOwner method")
	}

	mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner = f
	mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwnerOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseCountByOwner.mock
}

// When sets expectation for the Repository.GetKnowledgeBaseCountByOwner which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBaseCountByOwner *mRepositoryMockGetKnowledgeBaseCountByOwner) When(ctx context.Context, ownerUID string, kbType artifactpb.KnowledgeBaseType) *RepositoryMockGetKnowledgeBaseCountByOwnerExpectation {
	if mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseCountByOwner mock is already set by Set")
	}

	expectation := &RepositoryMockGetKnowledgeBaseCountByOwnerExpectation{
		mock:               mmGetKnowledgeBaseCountByOwner.mock,
		params:             &RepositoryMockGetKnowledgeBaseCountByOwnerParams{ctx, ownerUID, kbType},
		expectationOrigins: RepositoryMockGetKnowledgeBaseCountByOwnerExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetKnowledgeBaseCountByOwner.expectations = append(mmGetKnowledgeBaseCountByOwner.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetKnowledgeBaseCountByOwner return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetKnowledgeBaseCountByOwnerExpectation) Then(i1 int64, err error) *RepositoryMock {
	e.results = &RepositoryMockGetKnowledgeBaseCountByOwnerResults{i1, err}
	return e.mock
}

// Times sets number of times Repository.GetKnowledgeBaseCountByOwner should be invoked
func (mmGetKnowledgeBaseCountByOwner *mRepositoryMockGetKnowledgeBaseCountByOwner) Times(n uint64) *mRepositoryMockGetKnowledgeBaseCountByOwner {
	if n == 0 {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("Times of RepositoryMock.GetKnowledgeBaseCountByOwner mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBaseCountByOwner.expectedInvocations, n)
	mmGetKnowledgeBaseCountByOwner.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseCountByOwner
}

func (mmGetKnowledgeBaseCountByOwner *mRepositoryMockGetKnowledgeBaseCountByOwner) invocationsDone() bool {
	if len(mmGetKnowledgeBaseCountByOwner.expectations) == 0 && mmGetKnowledgeBaseCountByOwner.defaultExpectation == nil && mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseCountByOwner.mock.afterGetKnowledgeBaseCountByOwnerCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseCountByOwner.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBaseCountByOwner implements mm_repository.Repository
func (mmGetKnowledgeBaseCountByOwner *RepositoryMock) GetKnowledgeBaseCountByOwner(ctx context.Context, ownerUID string, kbType artifactpb.KnowledgeBaseType) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBaseCountByOwner.beforeGetKnowledgeBaseCountByOwnerCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBaseCountByOwner.afterGetKnowledgeBaseCountByOwnerCounter, 1)

	mmGetKnowledgeBaseCountByOwner.t.Helper()

	if mmGetKnowledgeBaseCountByOwner.inspectFuncGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.inspectFuncGetKnowledgeBaseCountByOwner(ctx, ownerUID, kbType)
	}

	mm_params := RepositoryMockGetKnowledgeBaseCountByOwnerParams{ctx, ownerUID, kbType}

	// Record call args
	mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.mutex.Lock()
	mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.callArgs = append(mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.callArgs, &mm_params)
	mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetKnowledgeBaseCountByOwnerParams{ctx, ownerUID, kbType}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBaseCountByOwner.t.Errorf("RepositoryMock.GetKnowledgeBaseCountByOwner got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmGetKnowledgeBaseCountByOwner.t.Errorf("RepositoryMock.GetKnowledgeBaseCountByOwner got unexpected parameter ownerUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.expectationOrigins.originOwnerUID, *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

			if mm_want_ptrs.kbType != nil && !minimock.Equal(*mm_want_ptrs.kbType, mm_got.kbType) {
				mmGetKnowledgeBaseCountByOwner.t.Errorf("RepositoryMock.GetKnowledgeBaseCountByOwner got unexpected parameter kbType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.expectationOrigins.originKbType, *mm_want_ptrs.kbType, mm_got.kbType, minimock.Diff(*mm_want_ptrs.kbType, mm_got.kbType))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBaseCountByOwner.t.Errorf("RepositoryMock.GetKnowledgeBaseCountByOwner got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBaseCountByOwner.t.Fatal("No results are set for the RepositoryMock.GetKnowledgeBaseCountByOwner")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetKnowledgeBaseCountByOwner.funcGetKnowledgeBaseCountByOwner != nil {
		return mmGetKnowledgeBaseCountByOwner.funcGetKnowledgeBaseCountByOwner(ctx, ownerUID, kbType)
	}
	mmGetKnowledgeBaseCountByOwner.t.Fatalf("Unexpected call to RepositoryMock.GetKnowledgeBaseCountByOwner. %v %v %v", ctx, ownerUID, kbType)
	return
}

// GetKnowledgeBaseCountByOwnerAfterCounter returns a count of finished RepositoryMock.GetKnowledgeBaseCountByOwner invocations
func (mmGetKnowledgeBaseCountByOwner *RepositoryMock) GetKnowledgeBaseCountByOwnerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseCountByOwner.afterGetKnowledgeBaseCountByOwnerCounter)
}

// GetKnowledgeBaseCountByOwnerBeforeCounter returns a count of RepositoryMock.GetKnowledgeBaseCountByOwner invocations
func (mmGetKnowledgeBaseCountByOwner *RepositoryMock) GetKnowledgeBaseCountByOwnerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseCountByOwner.beforeGetKnowledgeBaseCountByOwnerCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetKnowledgeBaseCountByOwner.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBaseCountByOwner *mRepositoryMockGetKnowledgeBaseCountByOwner) Calls() []*RepositoryMockGetKnowledgeBaseCountByOwnerParams {
	mmGetKnowledgeBaseCountByOwner.mutex.RLock()

	argCopy := make([]*RepositoryMockGetKnowledgeBaseCountByOwnerParams, len(mmGetKnowledgeBaseCountByOwner.callArgs))
	copy(argCopy, mmGetKnowledgeBaseCountByOwner.callArgs)

	mmGetKnowledgeBaseCountByOwner.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBaseCountByOwnerDone returns true if the count of the GetKnowledgeBaseCountByOwner invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetKnowledgeBaseCountByOwnerDone() bool {
	if m.GetKnowledgeBaseCountByOwnerMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetKnowledgeBaseCountByOwnerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBaseCountByOwnerMock.invocationsDone()
}

// MinimockGetKnowledgeBaseCountByOwnerInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetKnowledgeBaseCountByOwnerInspect() {
	for _, e := range m.GetKnowledgeBaseCountByOwnerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseCountByOwner at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetKnowledgeBaseCountByOwnerCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBaseCountByOwnerCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBaseCountByOwnerMock.defaultExpectation != nil && afterGetKnowledgeBaseCountByOwnerCounter < 1 {
		if m.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseCountByOwner at\n%s", m.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseCountByOwner at\n%s with params: %#v", m.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.expectationOrigins.origin, *m.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBaseCountByOwner != nil && afterGetKnowledgeBaseCountByOwnerCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseCountByOwner at\n%s", m.funcGetKnowledgeBaseCountByOwnerOrigin)
	}

	if !m.GetKnowledgeBaseCountByOwnerMock.invocationsDone() && afterGetKnowledgeBaseCountByOwnerCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetKnowledgeBaseCountByOwner at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBaseCountByOwnerMock.expectedInvocations), m.GetKnowledgeBaseCountByOwnerMock.expectedInvocationsOrigin, afterGetKnowledgeBaseCountByOwnerCounter)
	}
}

type mRepositoryMockGetKnowledgeBaseFilesByFileIDs struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetKnowledgeBaseFilesByFileIDsExpectation
	expectations       []*RepositoryMockGetKnowledgeBaseFilesByFileIDsExpectation

	callArgs []*RepositoryMockGetKnowledgeBaseFilesByFileIDsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetKnowledgeBaseFilesByFileIDsExpectation specifies expectation struct of the Repository.GetKnowledgeBaseFilesByFileIDs
type RepositoryMockGetKnowledgeBaseFilesByFileIDsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetKnowledgeBaseFilesByFileIDsParams
	paramPtrs          *RepositoryMockGetKnowledgeBaseFilesByFileIDsParamPtrs
	expectationOrigins RepositoryMockGetKnowledgeBaseFilesByFileIDsExpectationOrigins
	results            *RepositoryMockGetKnowledgeBaseFilesByFileIDsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetKnowledgeBaseFilesByFileIDsParams contains parameters of the Repository.GetKnowledgeBaseFilesByFileIDs
type RepositoryMockGetKnowledgeBaseFilesByFileIDsParams struct {
	ctx     context.Context
	fileIDs []string
	columns []string
}

// RepositoryMockGetKnowledgeBaseFilesByFileIDsParamPtrs contains pointers to parameters of the Repository.GetKnowledgeBaseFilesByFileIDs
type RepositoryMockGetKnowledgeBaseFilesByFileIDsParamPtrs struct {
	ctx     *context.Context
	fileIDs *[]string
	columns *[]string
}

// RepositoryMockGetKnowledgeBaseFilesByFileIDsResults contains results of the Repository.GetKnowledgeBaseFilesByFileIDs
type RepositoryMockGetKnowledgeBaseFilesByFileIDsResults struct {
	ka1 []mm_repository.KnowledgeBaseFileModel
	err error
}

// RepositoryMockGetKnowledgeBaseFilesByFileIDsOrigins contains origins of expectations of the Repository.GetKnowledgeBaseFilesByFileIDs
type RepositoryMockGetKnowledgeBaseFilesByFileIDsExpectationOrigins struct {
	origin        string
	originCtx     string
	originFileIDs string
	originColumns string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetKnowledgeBaseFilesByFileIDs *mRepositoryMockGetKnowledgeBaseFilesByFileIDs) Optional() *mRepositoryMockGetKnowledgeBaseFilesByFileIDs {
	mmGetKnowledgeBaseFilesByFileIDs.optional = true
	return mmGetKnowledgeBaseFilesByFileIDs
}

// Expect sets up expected params for Repository.GetKnowledgeBaseFilesByFileIDs
func (mmGetKnowledgeBaseFilesByFileIDs *mRepositoryMockGetKnowledgeBaseFilesByFileIDs) Expect(ctx context.Context, fileIDs []string, columns ...string) *mRepositoryMockGetKnowledgeBaseFilesByFileIDs {
	if mmGetKnowledgeBaseFilesByFileIDs.mock.funcGetKnowledgeBaseFilesByFileIDs != nil {
		mmGetKnowledgeBaseFilesByFileIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileIDs mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation = &RepositoryMockGetKnowledgeBaseFilesByFileIDsExpectation{}
	}

	if mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBaseFilesByFileIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileIDs mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation.params = &RepositoryMockGetKnowledgeBaseFilesByFileIDsParams{ctx, fileIDs, columns}
	mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetKnowledgeBaseFilesByFileIDs.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation.params) {
			mmGetKnowledgeBaseFilesByFileIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBaseFilesByFileIDs
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetKnowledgeBaseFilesByFileIDs
func (mmGetKnowledgeBaseFilesByFileIDs *mRepositoryMockGetKnowledgeBaseFilesByFileIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetKnowledgeBaseFilesByFileIDs {
	if mmGetKnowledgeBaseFilesByFileIDs.mock.funcGetKnowledgeBaseFilesByFileIDs != nil {
		mmGetKnowledgeBaseFilesByFileIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileIDs mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation = &RepositoryMockGetKnowledgeBaseFilesByFileIDsExpectation{}
	}

	if mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation.params != nil {
		mmGetKnowledgeBaseFilesByFileIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileIDs mock is already set by Expect")
	}

	if mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseFilesByFileIDsParamPtrs{}
	}
	mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseFilesByFileIDs
}

// ExpectFileIDsParam2 sets up expected param fileIDs for Repository.GetKnowledgeBaseFilesByFileIDs
func (mmGetKnowledgeBaseFilesByFileIDs *mRepositoryMockGetKnowledgeBaseFilesByFileIDs) ExpectFileIDsParam2(fileIDs []string) *mRepositoryMockGetKnowledgeBaseFilesByFileIDs {
	if mmGetKnowledgeBaseFilesByFileIDs.mock.funcGetKnowledgeBaseFilesByFileIDs != nil {
		mmGetKnowledgeBaseFilesByFileIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileIDs mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation = &RepositoryMockGetKnowledgeBaseFilesByFileIDsExpectation{}
	}

	if mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation.params != nil {
		mmGetKnowledgeBaseFilesByFileIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileIDs mock is already set by Expect")
	}

	if mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseFilesByFileIDsParamPtrs{}
	}
	mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation.paramPtrs.fileIDs = &fileIDs
	mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation.expectationOrigins.originFileIDs = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseFilesByFileIDs
}

// ExpectColumnsParam3 sets up expected param columns for Repository.GetKnowledgeBaseFilesByFileIDs
func (mmGetKnowledgeBaseFilesByFileIDs *mRepositoryMockGetKnowledgeBaseFilesByFileIDs) ExpectColumnsParam3(columns ...string) *mRepositoryMockGetKnowledgeBaseFilesByFileIDs {
	if mmGetKnowledgeBaseFilesByFileIDs.mock.funcGetKnowledgeBaseFilesByFileIDs != nil {
		mmGetKnowledgeBaseFilesByFileIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileIDs mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation = &RepositoryMockGetKnowledgeBaseFilesByFileIDsExpectation{}
	}

	if mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation.params != nil {
		mmGetKnowledgeBaseFilesByFileIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileIDs mock is already set by Expect")
	}

	if mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseFilesByFileIDsParamPtrs{}
	}
	mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation.paramPtrs.columns = &columns
	mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation.expectationOrigins.originColumns = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseFilesByFileIDs
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetKnowledgeBaseFilesByFileIDs
func (mmGetKnowledgeBaseFilesByFileIDs *mRepositoryMockGetKnowledgeBaseFilesByFileIDs) Inspect(f func(ctx context.Context, fileIDs []string, columns ...string)) *mRepositoryMockGetKnowledgeBaseFilesByFileIDs {
	if mmGetKnowledgeBaseFilesByFileIDs.mock.inspectFuncGetKnowledgeBaseFilesByFileIDs != nil {
		mmGetKnowledgeBaseFilesByFileIDs.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetKnowledgeBaseFilesByFileIDs")
	}

	mmGetKnowledgeBaseFilesByFileIDs.mock.inspectFuncGetKnowledgeBaseFilesByFileIDs = f

	return mmGetKnowledgeBaseFilesByFileIDs
}

// Return sets up results that will be returned by Repository.GetKnowledgeBaseFilesByFileIDs
func (mmGetKnowledgeBaseFilesByFileIDs *mRepositoryMockGetKnowledgeBaseFilesByFileIDs) Return(ka1 []mm_repository.KnowledgeBaseFileModel, err error) *RepositoryMock {
	if mmGetKnowledgeBaseFilesByFileIDs.mock.funcGetKnowledgeBaseFilesByFileIDs != nil {
		mmGetKnowledgeBaseFilesByFileIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileIDs mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation = &RepositoryMockGetKnowledgeBaseFilesByFileIDsExpectation{mock: mmGetKnowledgeBaseFilesByFileIDs.mock}
	}
	mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation.results = &RepositoryMockGetKnowledgeBaseFilesByFileIDsResults{ka1, err}
	mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseFilesByFileIDs.mock
}

// Set uses given function f to mock the Repository.GetKnowledgeBaseFilesByFileIDs method
func (mmGetKnowledgeBaseFilesByFileIDs *mRepositoryMockGetKnowledgeBaseFilesByFileIDs) Set(f func(ctx context.Context, fileIDs []string, columns ...string) (ka1 []mm_repository.KnowledgeBaseFileModel, err error)) *RepositoryMock {
	if mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation != nil {
		mmGetKnowledgeBaseFilesByFileIDs.mock.t.Fatalf("Default expectation is already set for the Repository.GetKnowledgeBaseFilesByFileIDs method")
	}

	if len(mmGetKnowledgeBaseFilesByFileIDs.expectations) > 0 {
		mmGetKnowledgeBaseFilesByFileIDs.mock.t.Fatalf("Some expectations are already set for the Repository.GetKnowledgeBaseFilesByFileIDs method")
	}

	mmGetKnowledgeBaseFilesByFileIDs.mock.funcGetKnowledgeBaseFilesByFileIDs = f
	mmGetKnowledgeBaseFilesByFileIDs.mock.funcGetKnowledgeBaseFilesByFileIDsOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseFilesByFileIDs.mock
}

// When sets expectation for the Repository.GetKnowledgeBaseFilesByFileIDs which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBaseFilesByFileIDs *mRepositoryMockGetKnowledgeBaseFilesByFileIDs) When(ctx context.Context, fileIDs []string, columns ...string) *RepositoryMockGetKnowledgeBaseFilesByFileIDsExpectation {
	if mmGetKnowledgeBaseFilesByFileIDs.mock.funcGetKnowledgeBaseFilesByFileIDs != nil {
		mmGetKnowledgeBaseFilesByFileIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileIDs mock is already set by Set")
	}

	expectation := &RepositoryMockGetKnowledgeBaseFilesByFileIDsExpectation{
		mock:               mmGetKnowledgeBaseFilesByFileIDs.mock,
		params:             &RepositoryMockGetKnowledgeBaseFilesByFileIDsParams{ctx, fileIDs, columns},
		expectationOrigins: RepositoryMockGetKnowledgeBaseFilesByFileIDsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetKnowledgeBaseFilesByFileIDs.expectations = append(mmGetKnowledgeBaseFilesByFileIDs.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetKnowledgeBaseFilesByFileIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetKnowledgeBaseFilesByFileIDsExpectation) Then(ka1 []mm_repository.KnowledgeBaseFileModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetKnowledgeBaseFilesByFileIDsResults{ka1, err}
	return e.mock
}

// Times sets number of times Repository.GetKnowledgeBaseFilesByFileIDs should be invoked
func (mmGetKnowledgeBaseFilesByFileIDs *mRepositoryMockGetKnowledgeBaseFilesByFileIDs) Times(n uint64) *mRepositoryMockGetKnowledgeBaseFilesByFileIDs {
	if n == 0 {
		mmGetKnowledgeBaseFilesByFileIDs.mock.t.Fatalf("Times of RepositoryMock.GetKnowledgeBaseFilesByFileIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBaseFilesByFileIDs.expectedInvocations, n)
	mmGetKnowledgeBaseFilesByFileIDs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseFilesByFileIDs
}

func (mmGetKnowledgeBaseFilesByFileIDs *mRepositoryMockGetKnowledgeBaseFilesByFileIDs) invocationsDone() bool {
	if len(mmGetKnowledgeBaseFilesByFileIDs.expectations) == 0 && mmGetKnowledgeBaseFilesByFileIDs.defaultExpectation == nil && mmGetKnowledgeBaseFilesByFileIDs.mock.funcGetKnowledgeBaseFilesByFileIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseFilesByFileIDs.mock.afterGetKnowledgeBaseFilesByFileIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseFilesByFileIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBaseFilesByFileIDs implements mm_repository.Repository
func (mmGetKnowledgeBaseFilesByFileIDs *RepositoryMock) GetKnowledgeBaseFilesByFileIDs(ctx context.Context, fileIDs []string, columns ...string) (ka1 []mm_repository.KnowledgeBaseFileModel, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBaseFilesByFileIDs.beforeGetKnowledgeBaseFilesByFileIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBaseFilesByFileIDs.afterGetKnowledgeBaseFilesByFileIDsCounter, 1)

	mmGetKnowledgeBaseFilesByFileIDs.t.Helper()

	if mmGetKnowledgeBaseFilesByFileIDs.inspectFuncGetKnowledgeBaseFilesByFileIDs != nil {
		mmGetKnowledgeBaseFilesByFileIDs.inspectFuncGetKnowledgeBaseFilesByFileIDs(ctx, fileIDs, columns...)
	}

	mm_params := RepositoryMockGetKnowledgeBaseFilesByFileIDsParams{ctx, fileIDs, columns}

	// Record call args
	mmGetKnowledgeBaseFilesByFileIDs.GetKnowledgeBaseFilesByFileIDsMock.mutex.Lock()
	mmGetKnowledgeBaseFilesByFileIDs.GetKnowledgeBaseFilesByFileIDsMock.callArgs = append(mmGetKnowledgeBaseFilesByFileIDs.GetKnowledgeBaseFilesByFileIDsMock.callArgs, &mm_params)
	mmGetKnowledgeBaseFilesByFileIDs.GetKnowledgeBaseFilesByFileIDsMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBaseFilesByFileIDs.GetKnowledgeBaseFilesByFileIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmGetKnowledgeBaseFilesByFileIDs.GetKnowledgeBaseFilesByFileIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBaseFilesByFileIDs.GetKnowledgeBaseFilesByFileIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBaseFilesByFileIDs.GetKnowledgeBaseFilesByFileIDsMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBaseFilesByFileIDs.GetKnowledgeBaseFilesByFileIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetKnowledgeBaseFilesByFileIDsParams{ctx, fileIDs, columns}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBaseFilesByFileIDs.t.Errorf("RepositoryMock.GetKnowledgeBaseFilesByFileIDs got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseFilesByFileIDs.GetKnowledgeBaseFilesByFileIDsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileIDs != nil && !minimock.Equal(*mm_want_ptrs.fileIDs, mm_got.fileIDs) {
				mmGetKnowledgeBaseFilesByFileIDs.t.Errorf("RepositoryMock.GetKnowledgeBaseFilesByFileIDs got unexpected parameter fileIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseFilesByFileIDs.GetKnowledgeBaseFilesByFileIDsMock.defaultExpectation.expectationOrigins.originFileIDs, *mm_want_ptrs.fileIDs, mm_got.fileIDs, minimock.Diff(*mm_want_ptrs.fileIDs, mm_got.fileIDs))
			}

			if mm_want_ptrs.columns != nil && !minimock.Equal(*mm_want_ptrs.columns, mm_got.columns) {
				mmGetKnowledgeBaseFilesByFileIDs.t.Errorf("RepositoryMock.GetKnowledgeBaseFilesByFileIDs got unexpected parameter columns, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseFilesByFileIDs.GetKnowledgeBaseFilesByFileIDsMock.defaultExpectation.expectationOrigins.originColumns, *mm_want_ptrs.columns, mm_got.columns, minimock.Diff(*mm_want_ptrs.columns, mm_got.columns))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBaseFilesByFileIDs.t.Errorf("RepositoryMock.GetKnowledgeBaseFilesByFileIDs got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetKnowledgeBaseFilesByFileIDs.GetKnowledgeBaseFilesByFileIDsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBaseFilesByFileIDs.GetKnowledgeBaseFilesByFileIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBaseFilesByFileIDs.t.Fatal("No results are set for the RepositoryMock.GetKnowledgeBaseFilesByFileIDs")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmGetKnowledgeBaseFilesByFileIDs.funcGetKnowledgeBaseFilesByFileIDs != nil {
		return mmGetKnowledgeBaseFilesByFileIDs.funcGetKnowledgeBaseFilesByFileIDs(ctx, fileIDs, columns...)
	}
	mmGetKnowledgeBaseFilesByFileIDs.t.Fatalf("Unexpected call to RepositoryMock.GetKnowledgeBaseFilesByFileIDs. %v %v %v", ctx, fileIDs, columns)
	return
}

// GetKnowledgeBaseFilesByFileIDsAfterCounter returns a count of finished RepositoryMock.GetKnowledgeBaseFilesByFileIDs invocations
func (mmGetKnowledgeBaseFilesByFileIDs *RepositoryMock) GetKnowledgeBaseFilesByFileIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseFilesByFileIDs.afterGetKnowledgeBaseFilesByFileIDsCounter)
}

// GetKnowledgeBaseFilesByFileIDsBeforeCounter returns a count of RepositoryMock.GetKnowledgeBaseFilesByFileIDs invocations
func (mmGetKnowledgeBaseFilesByFileIDs *RepositoryMock) GetKnowledgeBaseFilesByFileIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseFilesByFileIDs.beforeGetKnowledgeBaseFilesByFileIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetKnowledgeBaseFilesByFileIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBaseFilesByFileIDs *mRepositoryMockGetKnowledgeBaseFilesByFileIDs) Calls() []*RepositoryMockGetKnowledgeBaseFilesByFileIDsParams {
	mmGetKnowledgeBaseFilesByFileIDs.mutex.RLock()

	argCopy := make([]*RepositoryMockGetKnowledgeBaseFilesByFileIDsParams, len(mmGetKnowledgeBaseFilesByFileIDs.callArgs))
	copy(argCopy, mmGetKnowledgeBaseFilesByFileIDs.callArgs)

	mmGetKnowledgeBaseFilesByFileIDs.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBaseFilesByFileIDsDone returns true if the count of the GetKnowledgeBaseFilesByFileIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetKnowledgeBaseFilesByFileIDsDone() bool {
	if m.GetKnowledgeBaseFilesByFileIDsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetKnowledgeBaseFilesByFileIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBaseFilesByFileIDsMock.invocationsDone()
}

// MinimockGetKnowledgeBaseFilesByFileIDsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetKnowledgeBaseFilesByFileIDsInspect() {
	for _, e := range m.GetKnowledgeBaseFilesByFileIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseFilesByFileIDs at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetKnowledgeBaseFilesByFileIDsCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBaseFilesByFileIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBaseFilesByFileIDsMock.defaultExpectation != nil && afterGetKnowledgeBaseFilesByFileIDsCounter < 1 {
		if m.GetKnowledgeBaseFilesByFileIDsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseFilesByFileIDs at\n%s", m.GetKnowledgeBaseFilesByFileIDsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseFilesByFileIDs at\n%s with params: %#v", m.GetKnowledgeBaseFilesByFileIDsMock.defaultExpectation.expectationOrigins.origin, *m.GetKnowledgeBaseFilesByFileIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBaseFilesByFileIDs != nil && afterGetKnowledgeBaseFilesByFileIDsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseFilesByFileIDs at\n%s", m.funcGetKnowledgeBaseFilesByFileIDsOrigin)
	}

	if !m.GetKnowledgeBaseFilesByFileIDsMock.invocationsDone() && afterGetKnowledgeBaseFilesByFileIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetKnowledgeBaseFilesByFileIDs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBaseFilesByFileIDsMock.expectedInvocations), m.GetKnowledgeBaseFilesByFileIDsMock.expectedInvocationsOrigin, afterGetKnowledgeBaseFilesByFileIDsCounter)
	}
}

type mRepositoryMockGetKnowledgeBaseFilesByFileUIDs struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectation
	expectations       []*RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectation

	callArgs []*RepositoryMockGetKnowledgeBaseFilesByFileUIDsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectation specifies expectation struct of the Repository.GetKnowledgeBaseFilesByFileUIDs
type RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetKnowledgeBaseFilesByFileUIDsParams
	paramPtrs          *RepositoryMockGetKnowledgeBaseFilesByFileUIDsParamPtrs
	expectationOrigins RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectationOrigins
	results            *RepositoryMockGetKnowledgeBaseFilesByFileUIDsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetKnowledgeBaseFilesByFileUIDsParams contains parameters of the Repository.GetKnowledgeBaseFilesByFileUIDs
type RepositoryMockGetKnowledgeBaseFilesByFileUIDsParams struct {
	ctx      context.Context
	fileUIDs []types.FileUIDType
	columns  []string
}

// RepositoryMockGetKnowledgeBaseFilesByFileUIDsParamPtrs contains pointers to parameters of the Repository.GetKnowledgeBaseFilesByFileUIDs
type RepositoryMockGetKnowledgeBaseFilesByFileUIDsParamPtrs struct {
	ctx      *context.Context
	fileUIDs *[]types.FileUIDType
	columns  *[]string
}

// RepositoryMockGetKnowledgeBaseFilesByFileUIDsResults contains results of the Repository.GetKnowledgeBaseFilesByFileUIDs
type RepositoryMockGetKnowledgeBaseFilesByFileUIDsResults struct {
	ka1 []mm_repository.KnowledgeBaseFileModel
	err error
}

// RepositoryMockGetKnowledgeBaseFilesByFileUIDsOrigins contains origins of expectations of the Repository.GetKnowledgeBaseFilesByFileUIDs
type RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectationOrigins struct {
	origin         string
	originCtx      string
	originFileUIDs string
	originColumns  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs) Optional() *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs {
	mmGetKnowledgeBaseFilesByFileUIDs.optional = true
	return mmGetKnowledgeBaseFilesByFileUIDs
}

// Expect sets up expected params for Repository.GetKnowledgeBaseFilesByFileUIDs
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs) Expect(ctx context.Context, fileUIDs []types.FileUIDType, columns ...string) *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs {
	if mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectation{}
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.params = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsParams{ctx, fileUIDs, columns}
	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetKnowledgeBaseFilesByFileUIDs.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.params) {
			mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBaseFilesByFileUIDs
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetKnowledgeBaseFilesByFileUIDs
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs {
	if mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectation{}
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.params != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Expect")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsParamPtrs{}
	}
	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseFilesByFileUIDs
}

// ExpectFileUIDsParam2 sets up expected param fileUIDs for Repository.GetKnowledgeBaseFilesByFileUIDs
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs) ExpectFileUIDsParam2(fileUIDs []types.FileUIDType) *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs {
	if mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectation{}
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.params != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Expect")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsParamPtrs{}
	}
	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs.fileUIDs = &fileUIDs
	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.expectationOrigins.originFileUIDs = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseFilesByFileUIDs
}

// ExpectColumnsParam3 sets up expected param columns for Repository.GetKnowledgeBaseFilesByFileUIDs
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs) ExpectColumnsParam3(columns ...string) *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs {
	if mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectation{}
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.params != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Expect")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsParamPtrs{}
	}
	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs.columns = &columns
	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.expectationOrigins.originColumns = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseFilesByFileUIDs
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetKnowledgeBaseFilesByFileUIDs
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs) Inspect(f func(ctx context.Context, fileUIDs []types.FileUIDType, columns ...string)) *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs {
	if mmGetKnowledgeBaseFilesByFileUIDs.mock.inspectFuncGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetKnowledgeBaseFilesByFileUIDs")
	}

	mmGetKnowledgeBaseFilesByFileUIDs.mock.inspectFuncGetKnowledgeBaseFilesByFileUIDs = f

	return mmGetKnowledgeBaseFilesByFileUIDs
}

// Return sets up results that will be returned by Repository.GetKnowledgeBaseFilesByFileUIDs
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs) Return(ka1 []mm_repository.KnowledgeBaseFileModel, err error) *RepositoryMock {
	if mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectation{mock: mmGetKnowledgeBaseFilesByFileUIDs.mock}
	}
	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.results = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsResults{ka1, err}
	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseFilesByFileUIDs.mock
}

// Set uses given function f to mock the Repository.GetKnowledgeBaseFilesByFileUIDs method
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs) Set(f func(ctx context.Context, fileUIDs []types.FileUIDType, columns ...string) (ka1 []mm_repository.KnowledgeBaseFileModel, err error)) *RepositoryMock {
	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("Default expectation is already set for the Repository.GetKnowledgeBaseFilesByFileUIDs method")
	}

	if len(mmGetKnowledgeBaseFilesByFileUIDs.expectations) > 0 {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("Some expectations are already set for the Repository.GetKnowledgeBaseFilesByFileUIDs method")
	}

	mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs = f
	mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDsOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseFilesByFileUIDs.mock
}

// When sets expectation for the Repository.GetKnowledgeBaseFilesByFileUIDs which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs) When(ctx context.Context, fileUIDs []types.FileUIDType, columns ...string) *RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectation {
	if mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Set")
	}

	expectation := &RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectation{
		mock:               mmGetKnowledgeBaseFilesByFileUIDs.mock,
		params:             &RepositoryMockGetKnowledgeBaseFilesByFileUIDsParams{ctx, fileUIDs, columns},
		expectationOrigins: RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetKnowledgeBaseFilesByFileUIDs.expectations = append(mmGetKnowledgeBaseFilesByFileUIDs.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetKnowledgeBaseFilesByFileUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectation) Then(ka1 []mm_repository.KnowledgeBaseFileModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsResults{ka1, err}
	return e.mock
}

// Times sets number of times Repository.GetKnowledgeBaseFilesByFileUIDs should be invoked
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs) Times(n uint64) *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs {
	if n == 0 {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("Times of RepositoryMock.GetKnowledgeBaseFilesByFileUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBaseFilesByFileUIDs.expectedInvocations, n)
	mmGetKnowledgeBaseFilesByFileUIDs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseFilesByFileUIDs
}

func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs) invocationsDone() bool {
	if len(mmGetKnowledgeBaseFilesByFileUIDs.expectations) == 0 && mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation == nil && mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseFilesByFileUIDs.mock.afterGetKnowledgeBaseFilesByFileUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseFilesByFileUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBaseFilesByFileUIDs implements mm_repository.Repository
func (mmGetKnowledgeBaseFilesByFileUIDs *RepositoryMock) GetKnowledgeBaseFilesByFileUIDs(ctx context.Context, fileUIDs []types.FileUIDType, columns ...string) (ka1 []mm_repository.KnowledgeBaseFileModel, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBaseFilesByFileUIDs.beforeGetKnowledgeBaseFilesByFileUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBaseFilesByFileUIDs.afterGetKnowledgeBaseFilesByFileUIDsCounter, 1)

	mmGetKnowledgeBaseFilesByFileUIDs.t.Helper()

	if mmGetKnowledgeBaseFilesByFileUIDs.inspectFuncGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.inspectFuncGetKnowledgeBaseFilesByFileUIDs(ctx, fileUIDs, columns...)
	}

	mm_params := RepositoryMockGetKnowledgeBaseFilesByFileUIDsParams{ctx, fileUIDs, columns}

	// Record call args
	mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.mutex.Lock()
	mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.callArgs = append(mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.callArgs, &mm_params)
	mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetKnowledgeBaseFilesByFileUIDsParams{ctx, fileUIDs, columns}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBaseFilesByFileUIDs.t.Errorf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDs got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUIDs != nil && !minimock.Equal(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs) {
				mmGetKnowledgeBaseFilesByFileUIDs.t.Errorf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDs got unexpected parameter fileUIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.expectationOrigins.originFileUIDs, *mm_want_ptrs.fileUIDs, mm_got.fileUIDs, minimock.Diff(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs))
			}

			if mm_want_ptrs.columns != nil && !minimock.Equal(*mm_want_ptrs.columns, mm_got.columns) {
				mmGetKnowledgeBaseFilesByFileUIDs.t.Errorf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDs got unexpected parameter columns, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.expectationOrigins.originColumns, *mm_want_ptrs.columns, mm_got.columns, minimock.Diff(*mm_want_ptrs.columns, mm_got.columns))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBaseFilesByFileUIDs.t.Errorf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDs got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBaseFilesByFileUIDs.t.Fatal("No results are set for the RepositoryMock.GetKnowledgeBaseFilesByFileUIDs")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmGetKnowledgeBaseFilesByFileUIDs.funcGetKnowledgeBaseFilesByFileUIDs != nil {
		return mmGetKnowledgeBaseFilesByFileUIDs.funcGetKnowledgeBaseFilesByFileUIDs(ctx, fileUIDs, columns...)
	}
	mmGetKnowledgeBaseFilesByFileUIDs.t.Fatalf("Unexpected call to RepositoryMock.GetKnowledgeBaseFilesByFileUIDs. %v %v %v", ctx, fileUIDs, columns)
	return
}

// GetKnowledgeBaseFilesByFileUIDsAfterCounter returns a count of finished RepositoryMock.GetKnowledgeBaseFilesByFileUIDs invocations
func (mmGetKnowledgeBaseFilesByFileUIDs *RepositoryMock) GetKnowledgeBaseFilesByFileUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseFilesByFileUIDs.afterGetKnowledgeBaseFilesByFileUIDsCounter)
}

// GetKnowledgeBaseFilesByFileUIDsBeforeCounter returns a count of RepositoryMock.GetKnowledgeBaseFilesByFileUIDs invocations
func (mmGetKnowledgeBaseFilesByFileUIDs *RepositoryMock) GetKnowledgeBaseFilesByFileUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseFilesByFileUIDs.beforeGetKnowledgeBaseFilesByFileUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetKnowledgeBaseFilesByFileUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs) Calls() []*RepositoryMockGetKnowledgeBaseFilesByFileUIDsParams {
	mmGetKnowledgeBaseFilesByFileUIDs.mutex.RLock()

	argCopy := make([]*RepositoryMockGetKnowledgeBaseFilesByFileUIDsParams, len(mmGetKnowledgeBaseFilesByFileUIDs.callArgs))
	copy(argCopy, mmGetKnowledgeBaseFilesByFileUIDs.callArgs)

	mmGetKnowledgeBaseFilesByFileUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBaseFilesByFileUIDsDone returns true if the count of the GetKnowledgeBaseFilesByFileUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetKnowledgeBaseFilesByFileUIDsDone() bool {
	if m.GetKnowledgeBaseFilesByFileUIDsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetKnowledgeBaseFilesByFileUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBaseFilesByFileUIDsMock.invocationsDone()
}

// MinimockGetKnowledgeBaseFilesByFileUIDsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetKnowledgeBaseFilesByFileUIDsInspect() {
	for _, e := range m.GetKnowledgeBaseFilesByFileUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseFilesByFileUIDs at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetKnowledgeBaseFilesByFileUIDsCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBaseFilesByFileUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation != nil && afterGetKnowledgeBaseFilesByFileUIDsCounter < 1 {
		if m.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseFilesByFileUIDs at\n%s", m.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseFilesByFileUIDs at\n%s with params: %#v", m.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.expectationOrigins.origin, *m.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBaseFilesByFileUIDs != nil && afterGetKnowledgeBaseFilesByFileUIDsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseFilesByFileUIDs at\n%s", m.funcGetKnowledgeBaseFilesByFileUIDsOrigin)
	}

	if !m.GetKnowledgeBaseFilesByFileUIDsMock.invocationsDone() && afterGetKnowledgeBaseFilesByFileUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetKnowledgeBaseFilesByFileUIDs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBaseFilesByFileUIDsMock.expectedInvocations), m.GetKnowledgeBaseFilesByFileUIDsMock.expectedInvocationsOrigin, afterGetKnowledgeBaseFilesByFileUIDsCounter)
	}
}

type mRepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeleted struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedExpectation
	expectations       []*RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedExpectation

	callArgs []*RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedExpectation specifies expectation struct of the Repository.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted
type RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedParams
	paramPtrs          *RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedParamPtrs
	expectationOrigins RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedExpectationOrigins
	results            *RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedParams contains parameters of the Repository.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted
type RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedParams struct {
	ctx      context.Context
	fileUIDs []types.FileUIDType
	columns  []string
}

// RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedParamPtrs contains pointers to parameters of the Repository.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted
type RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedParamPtrs struct {
	ctx      *context.Context
	fileUIDs *[]types.FileUIDType
	columns  *[]string
}

// RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedResults contains results of the Repository.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted
type RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedResults struct {
	ka1 []mm_repository.KnowledgeBaseFileModel
	err error
}

// RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedOrigins contains origins of expectations of the Repository.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted
type RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedExpectationOrigins struct {
	origin         string
	originCtx      string
	originFileUIDs string
	originColumns  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted *mRepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeleted) Optional() *mRepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeleted {
	mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.optional = true
	return mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted
}

// Expect sets up expected params for Repository.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted
func (mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted *mRepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeleted) Expect(ctx context.Context, fileUIDs []types.FileUIDType, columns ...string) *mRepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeleted {
	if mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock.funcGetKnowledgeBaseFilesByFileUIDsIncludingDeleted != nil {
		mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedExpectation{}
	}

	if mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation.params = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedParams{ctx, fileUIDs, columns}
	mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation.params) {
			mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted
func (mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted *mRepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeleted) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeleted {
	if mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock.funcGetKnowledgeBaseFilesByFileUIDsIncludingDeleted != nil {
		mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedExpectation{}
	}

	if mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation.params != nil {
		mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted mock is already set by Expect")
	}

	if mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedParamPtrs{}
	}
	mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted
}

// ExpectFileUIDsParam2 sets up expected param fileUIDs for Repository.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted
func (mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted *mRepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeleted) ExpectFileUIDsParam2(fileUIDs []types.FileUIDType) *mRepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeleted {
	if mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock.funcGetKnowledgeBaseFilesByFileUIDsIncludingDeleted != nil {
		mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedExpectation{}
	}

	if mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation.params != nil {
		mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted mock is already set by Expect")
	}

	if mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedParamPtrs{}
	}
	mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation.paramPtrs.fileUIDs = &fileUIDs
	mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation.expectationOrigins.originFileUIDs = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted
}

// ExpectColumnsParam3 sets up expected param columns for Repository.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted
func (mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted *mRepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeleted) ExpectColumnsParam3(columns ...string) *mRepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeleted {
	if mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock.funcGetKnowledgeBaseFilesByFileUIDsIncludingDeleted != nil {
		mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedExpectation{}
	}

	if mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation.params != nil {
		mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted mock is already set by Expect")
	}

	if mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedParamPtrs{}
	}
	mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation.paramPtrs.columns = &columns
	mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation.expectationOrigins.originColumns = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted
func (mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted *mRepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeleted) Inspect(f func(ctx context.Context, fileUIDs []types.FileUIDType, columns ...string)) *mRepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeleted {
	if mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock.inspectFuncGetKnowledgeBaseFilesByFileUIDsIncludingDeleted != nil {
		mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted")
	}

	mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock.inspectFuncGetKnowledgeBaseFilesByFileUIDsIncludingDeleted = f

	return mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted
}

// Return sets up results that will be returned by Repository.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted
func (mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted *mRepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeleted) Return(ka1 []mm_repository.KnowledgeBaseFileModel, err error) *RepositoryMock {
	if mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock.funcGetKnowledgeBaseFilesByFileUIDsIncludingDeleted != nil {
		mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedExpectation{mock: mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock}
	}
	mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation.results = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedResults{ka1, err}
	mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock
}

// Set uses given function f to mock the Repository.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted method
func (mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted *mRepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeleted) Set(f func(ctx context.Context, fileUIDs []types.FileUIDType, columns ...string) (ka1 []mm_repository.KnowledgeBaseFileModel, err error)) *RepositoryMock {
	if mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation != nil {
		mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock.t.Fatalf("Default expectation is already set for the Repository.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted method")
	}

	if len(mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.expectations) > 0 {
		mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock.t.Fatalf("Some expectations are already set for the Repository.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted method")
	}

	mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock.funcGetKnowledgeBaseFilesByFileUIDsIncludingDeleted = f
	mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock.funcGetKnowledgeBaseFilesByFileUIDsIncludingDeletedOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock
}

// When sets expectation for the Repository.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted *mRepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeleted) When(ctx context.Context, fileUIDs []types.FileUIDType, columns ...string) *RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedExpectation {
	if mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock.funcGetKnowledgeBaseFilesByFileUIDsIncludingDeleted != nil {
		mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted mock is already set by Set")
	}

	expectation := &RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedExpectation{
		mock:               mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock,
		params:             &RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedParams{ctx, fileUIDs, columns},
		expectationOrigins: RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.expectations = append(mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedExpectation) Then(ka1 []mm_repository.KnowledgeBaseFileModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedResults{ka1, err}
	return e.mock
}

// Times sets number of times Repository.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted should be invoked
func (mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted *mRepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeleted) Times(n uint64) *mRepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeleted {
	if n == 0 {
		mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock.t.Fatalf("Times of RepositoryMock.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.expectedInvocations, n)
	mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted
}

func (mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted *mRepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeleted) invocationsDone() bool {
	if len(mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.expectations) == 0 && mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.defaultExpectation == nil && mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock.funcGetKnowledgeBaseFilesByFileUIDsIncludingDeleted == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mock.afterGetKnowledgeBaseFilesByFileUIDsIncludingDeletedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBaseFilesByFileUIDsIncludingDeleted implements mm_repository.Repository
func (mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted *RepositoryMock) GetKnowledgeBaseFilesByFileUIDsIncludingDeleted(ctx context.Context, fileUIDs []types.FileUIDType, columns ...string) (ka1 []mm_repository.KnowledgeBaseFileModel, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.beforeGetKnowledgeBaseFilesByFileUIDsIncludingDeletedCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.afterGetKnowledgeBaseFilesByFileUIDsIncludingDeletedCounter, 1)

	mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.t.Helper()

	if mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.inspectFuncGetKnowledgeBaseFilesByFileUIDsIncludingDeleted != nil {
		mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.inspectFuncGetKnowledgeBaseFilesByFileUIDsIncludingDeleted(ctx, fileUIDs, columns...)
	}

	mm_params := RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedParams{ctx, fileUIDs, columns}

	// Record call args
	mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.GetKnowledgeBaseFilesByFileUIDsIncludingDeletedMock.mutex.Lock()
	mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.GetKnowledgeBaseFilesByFileUIDsIncludingDeletedMock.callArgs = append(mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.GetKnowledgeBaseFilesByFileUIDsIncludingDeletedMock.callArgs, &mm_params)
	mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.GetKnowledgeBaseFilesByFileUIDsIncludingDeletedMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.GetKnowledgeBaseFilesByFileUIDsIncludingDeletedMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.GetKnowledgeBaseFilesByFileUIDsIncludingDeletedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.GetKnowledgeBaseFilesByFileUIDsIncludingDeletedMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.GetKnowledgeBaseFilesByFileUIDsIncludingDeletedMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.GetKnowledgeBaseFilesByFileUIDsIncludingDeletedMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedParams{ctx, fileUIDs, columns}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.t.Errorf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.GetKnowledgeBaseFilesByFileUIDsIncludingDeletedMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUIDs != nil && !minimock.Equal(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs) {
				mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.t.Errorf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted got unexpected parameter fileUIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.GetKnowledgeBaseFilesByFileUIDsIncludingDeletedMock.defaultExpectation.expectationOrigins.originFileUIDs, *mm_want_ptrs.fileUIDs, mm_got.fileUIDs, minimock.Diff(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs))
			}

			if mm_want_ptrs.columns != nil && !minimock.Equal(*mm_want_ptrs.columns, mm_got.columns) {
				mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.t.Errorf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted got unexpected parameter columns, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.GetKnowledgeBaseFilesByFileUIDsIncludingDeletedMock.defaultExpectation.expectationOrigins.originColumns, *mm_want_ptrs.columns, mm_got.columns, minimock.Diff(*mm_want_ptrs.columns, mm_got.columns))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.t.Errorf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.GetKnowledgeBaseFilesByFileUIDsIncludingDeletedMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.GetKnowledgeBaseFilesByFileUIDsIncludingDeletedMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.t.Fatal("No results are set for the RepositoryMock.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.funcGetKnowledgeBaseFilesByFileUIDsIncludingDeleted != nil {
		return mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.funcGetKnowledgeBaseFilesByFileUIDsIncludingDeleted(ctx, fileUIDs, columns...)
	}
	mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.t.Fatalf("Unexpected call to RepositoryMock.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted. %v %v %v", ctx, fileUIDs, columns)
	return
}

// GetKnowledgeBaseFilesByFileUIDsIncludingDeletedAfterCounter returns a count of finished RepositoryMock.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted invocations
func (mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted *RepositoryMock) GetKnowledgeBaseFilesByFileUIDsIncludingDeletedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.afterGetKnowledgeBaseFilesByFileUIDsIncludingDeletedCounter)
}

// GetKnowledgeBaseFilesByFileUIDsIncludingDeletedBeforeCounter returns a count of RepositoryMock.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted invocations
func (mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted *RepositoryMock) GetKnowledgeBaseFilesByFileUIDsIncludingDeletedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.beforeGetKnowledgeBaseFilesByFileUIDsIncludingDeletedCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted *mRepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeleted) Calls() []*RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedParams {
	mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mutex.RLock()

	argCopy := make([]*RepositoryMockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedParams, len(mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.callArgs))
	copy(argCopy, mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.callArgs)

	mmGetKnowledgeBaseFilesByFileUIDsIncludingDeleted.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedDone returns true if the count of the GetKnowledgeBaseFilesByFileUIDsIncludingDeleted invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedDone() bool {
	if m.GetKnowledgeBaseFilesByFileUIDsIncludingDeletedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetKnowledgeBaseFilesByFileUIDsIncludingDeletedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBaseFilesByFileUIDsIncludingDeletedMock.invocationsDone()
}

// MinimockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedInspect() {
	for _, e := range m.GetKnowledgeBaseFilesByFileUIDsIncludingDeletedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetKnowledgeBaseFilesByFileUIDsIncludingDeletedCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBaseFilesByFileUIDsIncludingDeletedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBaseFilesByFileUIDsIncludingDeletedMock.defaultExpectation != nil && afterGetKnowledgeBaseFilesByFileUIDsIncludingDeletedCounter < 1 {
		if m.GetKnowledgeBaseFilesByFileUIDsIncludingDeletedMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted at\n%s", m.GetKnowledgeBaseFilesByFileUIDsIncludingDeletedMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted at\n%s with params: %#v", m.GetKnowledgeBaseFilesByFileUIDsIncludingDeletedMock.defaultExpectation.expectationOrigins.origin, *m.GetKnowledgeBaseFilesByFileUIDsIncludingDeletedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBaseFilesByFileUIDsIncludingDeleted != nil && afterGetKnowledgeBaseFilesByFileUIDsIncludingDeletedCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted at\n%s", m.funcGetKnowledgeBaseFilesByFileUIDsIncludingDeletedOrigin)
	}

	if !m.GetKnowledgeBaseFilesByFileUIDsIncludingDeletedMock.invocationsDone() && afterGetKnowledgeBaseFilesByFileUIDsIncludingDeletedCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetKnowledgeBaseFilesByFileUIDsIncludingDeleted at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBaseFilesByFileUIDsIncludingDeletedMock.expectedInvocations), m.GetKnowledgeBaseFilesByFileUIDsIncludingDeletedMock.expectedInvocationsOrigin, afterGetKnowledgeBaseFilesByFileUIDsIncludingDeletedCounter)
	}
}

type mRepositoryMockGetKnowledgeBaseFilesByName struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetKnowledgeBaseFilesByNameExpectation
	expectations       []*RepositoryMockGetKnowledgeBaseFilesByNameExpectation

	callArgs []*RepositoryMockGetKnowledgeBaseFilesByNameParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetKnowledgeBaseFilesByNameExpectation specifies expectation struct of the Repository.GetKnowledgeBaseFilesByName
type RepositoryMockGetKnowledgeBaseFilesByNameExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetKnowledgeBaseFilesByNameParams
	paramPtrs          *RepositoryMockGetKnowledgeBaseFilesByNameParamPtrs
	expectationOrigins RepositoryMockGetKnowledgeBaseFilesByNameExpectationOrigins
	results            *RepositoryMockGetKnowledgeBaseFilesByNameResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetKnowledgeBaseFilesByNameParams contains parameters of the Repository.GetKnowledgeBaseFilesByName
type RepositoryMockGetKnowledgeBaseFilesByNameParams struct {
	ctx      context.Context
	kbUID    types.KBUIDType
	filename string
}

// RepositoryMockGetKnowledgeBaseFilesByNameParamPtrs contains pointers to parameters of the Repository.GetKnowledgeBaseFilesByName
type RepositoryMockGetKnowledgeBaseFilesByNameParamPtrs struct {
	ctx      *context.Context
	kbUID    *types.KBUIDType
	filename *string
}

// RepositoryMockGetKnowledgeBaseFilesByNameResults contains results of the Repository.GetKnowledgeBaseFilesByName
type RepositoryMockGetKnowledgeBaseFilesByNameResults struct {
	ka1 []mm_repository.KnowledgeBaseFileModel
	err error
}

// RepositoryMockGetKnowledgeBaseFilesByNameOrigins contains origins of expectations of the Repository.GetKnowledgeBaseFilesByName
type RepositoryMockGetKnowledgeBaseFilesByNameExpectationOrigins struct {
	origin         string
	originCtx      string
	originKbUID    string
	originFilename string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetKnowledgeBaseFilesByName *mRepositoryMockGetKnowledgeBaseFilesByName) Optional() *mRepositoryMockGetKnowledgeBaseFilesByName {
	mmGetKnowledgeBaseFilesByName.optional = true
	return mmGetKnowledgeBaseFilesByName
}

// Expect sets up expected params for Repository.GetKnowledgeBaseFilesByName
func (mmGetKnowledgeBaseFilesByName *mRepositoryMockGetKnowledgeBaseFilesByName) Expect(ctx context.Context, kbUID types.KBUIDType, filename string) *mRepositoryMockGetKnowledgeBaseFilesByName {
	if mmGetKnowledgeBaseFilesByName.mock.funcGetKnowledgeBaseFilesByName != nil {
		mmGetKnowledgeBaseFilesByName.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByName mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByName.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByName.defaultExpectation = &RepositoryMockGetKnowledgeBaseFilesByNameExpectation{}
	}

	if mmGetKnowledgeBaseFilesByName.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBaseFilesByName.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByName mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBaseFilesByName.defaultExpectation.params = &RepositoryMockGetKnowledgeBaseFilesByNameParams{ctx, kbUID, filename}
	mmGetKnowledgeBaseFilesByName.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetKnowledgeBaseFilesByName.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBaseFilesByName.defaultExpectation.params) {
			mmGetKnowledgeBaseFilesByName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBaseFilesByName.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBaseFilesByName
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetKnowledgeBaseFilesByName
func (mmGetKnowledgeBaseFilesByName *mRepositoryMockGetKnowledgeBaseFilesByName) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetKnowledgeBaseFilesByName {
	if mmGetKnowledgeBaseFilesByName.mock.funcGetKnowledgeBaseFilesByName != nil {
		mmGetKnowledgeBaseFilesByName.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByName mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByName.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByName.defaultExpectation = &RepositoryMockGetKnowledgeBaseFilesByNameExpectation{}
	}

	if mmGetKnowledgeBaseFilesByName.defaultExpectation.params != nil {
		mmGetKnowledgeBaseFilesByName.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByName mock is already set by Expect")
	}

	if mmGetKnowledgeBaseFilesByName.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseFilesByName.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseFilesByNameParamPtrs{}
	}
	mmGetKnowledgeBaseFilesByName.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetKnowledgeBaseFilesByName.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseFilesByName
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.GetKnowledgeBaseFilesByName
func (mmGetKnowledgeBaseFilesByName *mRepositoryMockGetKnowledgeBaseFilesByName) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockGetKnowledgeBaseFilesByName {
	if mmGetKnowledgeBaseFilesByName.mock.funcGetKnowledgeBaseFilesByName != nil {
		mmGetKnowledgeBaseFilesByName.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByName mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByName.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByName.defaultExpectation = &RepositoryMockGetKnowledgeBaseFilesByNameExpectation{}
	}

	if mmGetKnowledgeBaseFilesByName.defaultExpectation.params != nil {
		mmGetKnowledgeBaseFilesByName.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByName mock is already set by Expect")
	}

	if mmGetKnowledgeBaseFilesByName.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseFilesByName.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseFilesByNameParamPtrs{}
	}
	mmGetKnowledgeBaseFilesByName.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmGetKnowledgeBaseFilesByName.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseFilesByName
}

// ExpectFilenameParam3 sets up expected param filename for Repository.GetKnowledgeBaseFilesByName
func (mmGetKnowledgeBaseFilesByName *mRepositoryMockGetKnowledgeBaseFilesByName) ExpectFilenameParam3(filename string) *mRepositoryMockGetKnowledgeBaseFilesByName {
	if mmGetKnowledgeBaseFilesByName.mock.funcGetKnowledgeBaseFilesByName != nil {
		mmGetKnowledgeBaseFilesByName.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByName mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByName.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByName.defaultExpectation = &RepositoryMockGetKnowledgeBaseFilesByNameExpectation{}
	}

	if mmGetKnowledgeBaseFilesByName.defaultExpectation.params != nil {
		mmGetKnowledgeBaseFilesByName.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByName mock is already set by Expect")
	}

	if mmGetKnowledgeBaseFilesByName.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseFilesByName.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseFilesByNameParamPtrs{}
	}
	mmGetKnowledgeBaseFilesByName.defaultExpectation.paramPtrs.filename = &filename
	mmGetKnowledgeBaseFilesByName.defaultExpectation.expectationOrigins.originFilename = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseFilesByName
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetKnowledgeBaseFilesByName
func (mmGetKnowledgeBaseFilesByName *mRepositoryMockGetKnowledgeBaseFilesByName) Inspect(f func(ctx context.Context, kbUID types.KBUIDType, filename string)) *mRepositoryMockGetKnowledgeBaseFilesByName {
	if mmGetKnowledgeBaseFilesByName.mock.inspectFuncGetKnowledgeBaseFilesByName != nil {
		mmGetKnowledgeBaseFilesByName.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetKnowledgeBaseFilesByName")
	}

	mmGetKnowledgeBaseFilesByName.mock.inspectFuncGetKnowledgeBaseFilesByName = f

	return mmGetKnowledgeBaseFilesByName
}

// Return sets up results that will be returned by Repository.GetKnowledgeBaseFilesByName
func (mmGetKnowledgeBaseFilesByName *mRepositoryMockGetKnowledgeBaseFilesByName) Return(ka1 []mm_repository.KnowledgeBaseFileModel, err error) *RepositoryMock {
	if mmGetKnowledgeBaseFilesByName.mock.funcGetKnowledgeBaseFilesByName != nil {
		mmGetKnowledgeBaseFilesByName.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByName mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByName.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByName.defaultExpectation = &RepositoryMockGetKnowledgeBaseFilesByNameExpectation{mock: mmGetKnowledgeBaseFilesByName.mock}
	}
	mmGetKnowledgeBaseFilesByName.defaultExpectation.results = &RepositoryMockGetKnowledgeBaseFilesByNameResults{ka1, err}
	mmGetKnowledgeBaseFilesByName.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseFilesByName.mock
}

// Set uses given function f to mock the Repository.GetKnowledgeBaseFilesByName method
func (mmGetKnowledgeBaseFilesByName *mRepositoryMockGetKnowledgeBaseFilesByName) Set(f func(ctx context.Context, kbUID types.KBUIDType, filename string) (ka1 []mm_repository.KnowledgeBaseFileModel, err error)) *RepositoryMock {
	if mmGetKnowledgeBaseFilesByName.defaultExpectation != nil {
		mmGetKnowledgeBaseFilesByName.mock.t.Fatalf("Default expectation is already set for the Repository.GetKnowledgeBaseFilesByName method")
	}

	if len(mmGetKnowledgeBaseFilesByName.expectations) > 0 {
		mmGetKnowledgeBaseFilesByName.mock.t.Fatalf("Some expectations are already set for the Repository.GetKnowledgeBaseFilesByName method")
	}

	mmGetKnowledgeBaseFilesByName.mock.funcGetKnowledgeBaseFilesByName = f
	mmGetKnowledgeBaseFilesByName.mock.funcGetKnowledgeBaseFilesByNameOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseFilesByName.mock
}

// When sets expectation for the Repository.GetKnowledgeBaseFilesByName which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBaseFilesByName *mRepositoryMockGetKnowledgeBaseFilesByName) When(ctx context.Context, kbUID types.KBUIDType, filename string) *RepositoryMockGetKnowledgeBaseFilesByNameExpectation {
	if mmGetKnowledgeBaseFilesByName.mock.funcGetKnowledgeBaseFilesByName != nil {
		mmGetKnowledgeBaseFilesByName.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByName mock is already set by Set")
	}

	expectation := &RepositoryMockGetKnowledgeBaseFilesByNameExpectation{
		mock:               mmGetKnowledgeBaseFilesByName.mock,
		params:             &RepositoryMockGetKnowledgeBaseFilesByNameParams{ctx, kbUID, filename},
		expectationOrigins: RepositoryMockGetKnowledgeBaseFilesByNameExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetKnowledgeBaseFilesByName.expectations = append(mmGetKnowledgeBaseFilesByName.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetKnowledgeBaseFilesByName return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetKnowledgeBaseFilesByNameExpectation) Then(ka1 []mm_repository.KnowledgeBaseFileModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetKnowledgeBaseFilesByNameResults{ka1, err}
	return e.mock
}

// Times sets number of times Repository.GetKnowledgeBaseFilesByName should be invoked
func (mmGetKnowledgeBaseFilesByName *mRepositoryMockGetKnowledgeBaseFilesByName) Times(n uint64) *mRepositoryMockGetKnowledgeBaseFilesByName {
	if n == 0 {
		mmGetKnowledgeBaseFilesByName.mock.t.Fatalf("Times of RepositoryMock.GetKnowledgeBaseFilesByName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBaseFilesByName.expectedInvocations, n)
	mmGetKnowledgeBaseFilesByName.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseFilesByName
}

func (mmGetKnowledgeBaseFilesByName *mRepositoryMockGetKnowledgeBaseFilesByName) invocationsDone() bool {
	if len(mmGetKnowledgeBaseFilesByName.expectations) == 0 && mmGetKnowledgeBaseFilesByName.defaultExpectation == nil && mmGetKnowledgeBaseFilesByName.mock.funcGetKnowledgeBaseFilesByName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseFilesByName.mock.afterGetKnowledgeBaseFilesByNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseFilesByName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBaseFilesByName implements mm_repository.Repository
func (mmGetKnowledgeBaseFilesByName *RepositoryMock) GetKnowledgeBaseFilesByName(ctx context.Context, kbUID types.KBUIDType, filename string) (ka1 []mm_repository.KnowledgeBaseFileModel, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBaseFilesByName.beforeGetKnowledgeBaseFilesByNameCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBaseFilesByName.afterGetKnowledgeBaseFilesByNameCounter, 1)

	mmGetKnowledgeBaseFilesByName.t.Helper()

	if mmGetKnowledgeBaseFilesByName.inspectFuncGetKnowledgeBaseFilesByName != nil {
		mmGetKnowledgeBaseFilesByName.inspectFuncGetKnowledgeBaseFilesByName(ctx, kbUID, filename)
	}

	mm_params := RepositoryMockGetKnowledgeBaseFilesByNameParams{ctx, kbUID, filename}

	// Record call args
	mmGetKnowledgeBaseFilesByName.GetKnowledgeBaseFilesByNameMock.mutex.Lock()
	mmGetKnowledgeBaseFilesByName.GetKnowledgeBaseFilesByNameMock.callArgs = append(mmGetKnowledgeBaseFilesByName.GetKnowledgeBaseFilesByNameMock.callArgs, &mm_params)
	mmGetKnowledgeBaseFilesByName.GetKnowledgeBaseFilesByNameMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBaseFilesByName.GetKnowledgeBaseFilesByNameMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmGetKnowledgeBaseFilesByName.GetKnowledgeBaseFilesByNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBaseFilesByName.GetKnowledgeBaseFilesByNameMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBaseFilesByName.GetKnowledgeBaseFilesByNameMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBaseFilesByName.GetKnowledgeBaseFilesByNameMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetKnowledgeBaseFilesByNameParams{ctx, kbUID, filename}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBaseFilesByName.t.Errorf("RepositoryMock.GetKnowledgeBaseFilesByName got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseFilesByName.GetKnowledgeBaseFilesByNameMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmGetKnowledgeBaseFilesByName.t.Errorf("RepositoryMock.GetKnowledgeBaseFilesByName got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseFilesByName.GetKnowledgeBaseFilesByNameMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.filename != nil && !minimock.Equal(*mm_want_ptrs.filename, mm_got.filename) {
				mmGetKnowledgeBaseFilesByName.t.Errorf("RepositoryMock.GetKnowledgeBaseFilesByName got unexpected parameter filename, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseFilesByName.GetKnowledgeBaseFilesByNameMock.defaultExpectation.expectationOrigins.originFilename, *mm_want_ptrs.filename, mm_got.filename, minimock.Diff(*mm_want_ptrs.filename, mm_got.filename))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBaseFilesByName.t.Errorf("RepositoryMock.GetKnowledgeBaseFilesByName got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetKnowledgeBaseFilesByName.GetKnowledgeBaseFilesByNameMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBaseFilesByName.GetKnowledgeBaseFilesByNameMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBaseFilesByName.t.Fatal("No results are set for the RepositoryMock.GetKnowledgeBaseFilesByName")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmGetKnowledgeBaseFilesByName.funcGetKnowledgeBaseFilesByName != nil {
		return mmGetKnowledgeBaseFilesByName.funcGetKnowledgeBaseFilesByName(ctx, kbUID, filename)
	}
	mmGetKnowledgeBaseFilesByName.t.Fatalf("Unexpected call to RepositoryMock.GetKnowledgeBaseFilesByName. %v %v %v", ctx, kbUID, filename)
	return
}

// GetKnowledgeBaseFilesByNameAfterCounter returns a count of finished RepositoryMock.GetKnowledgeBaseFilesByName invocations
func (mmGetKnowledgeBaseFilesByName *RepositoryMock) GetKnowledgeBaseFilesByNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseFilesByName.afterGetKnowledgeBaseFilesByNameCounter)
}

// GetKnowledgeBaseFilesByNameBeforeCounter returns a count of RepositoryMock.GetKnowledgeBaseFilesByName invocations
func (mmGetKnowledgeBaseFilesByName *RepositoryMock) GetKnowledgeBaseFilesByNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseFilesByName.beforeGetKnowledgeBaseFilesByNameCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetKnowledgeBaseFilesByName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBaseFilesByName *mRepositoryMockGetKnowledgeBaseFilesByName) Calls() []*RepositoryMockGetKnowledgeBaseFilesByNameParams {
	mmGetKnowledgeBaseFilesByName.mutex.RLock()

	argCopy := make([]*RepositoryMockGetKnowledgeBaseFilesByNameParams, len(mmGetKnowledgeBaseFilesByName.callArgs))
	copy(argCopy, mmGetKnowledgeBaseFilesByName.callArgs)

	mmGetKnowledgeBaseFilesByName.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBaseFilesByNameDone returns true if the count of the GetKnowledgeBaseFilesByName invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetKnowledgeBaseFilesByNameDone() bool {
	if m.GetKnowledgeBaseFilesByNameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetKnowledgeBaseFilesByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBaseFilesByNameMock.invocationsDone()
}

// MinimockGetKnowledgeBaseFilesByNameInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetKnowledgeBaseFilesByNameInspect() {
	for _, e := range m.GetKnowledgeBaseFilesByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseFilesByName at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetKnowledgeBaseFilesByNameCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBaseFilesByNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBaseFilesByNameMock.defaultExpectation != nil && afterGetKnowledgeBaseFilesByNameCounter < 1 {
		if m.GetKnowledgeBaseFilesByNameMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseFilesByName at\n%s", m.GetKnowledgeBaseFilesByNameMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseFilesByName at\n%s with params: %#v", m.GetKnowledgeBaseFilesByNameMock.defaultExpectation.expectationOrigins.origin, *m.GetKnowledgeBaseFilesByNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBaseFilesByName != nil && afterGetKnowledgeBaseFilesByNameCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseFilesByName at\n%s", m.funcGetKnowledgeBaseFilesByNameOrigin)
	}

	if !m.GetKnowledgeBaseFilesByNameMock.invocationsDone() && afterGetKnowledgeBaseFilesByNameCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetKnowledgeBaseFilesByName at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBaseFilesByNameMock.expectedInvocations), m.GetKnowledgeBaseFilesByNameMock.expectedInvocationsOrigin, afterGetKnowledgeBaseFilesByNameCounter)
	}
}

type mRepositoryMockGetKnowledgeBasesByUIDs struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetKnowledgeBasesByUIDsExpectation
	expectations       []*RepositoryMockGetKnowledgeBasesByUIDsExpectation

	callArgs []*RepositoryMockGetKnowledgeBasesByUIDsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetKnowledgeBasesByUIDsExpectation specifies expectation struct of the Repository.GetKnowledgeBasesByUIDs
type RepositoryMockGetKnowledgeBasesByUIDsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetKnowledgeBasesByUIDsParams
	paramPtrs          *RepositoryMockGetKnowledgeBasesByUIDsParamPtrs
	expectationOrigins RepositoryMockGetKnowledgeBasesByUIDsExpectationOrigins
	results            *RepositoryMockGetKnowledgeBasesByUIDsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetKnowledgeBasesByUIDsParams contains parameters of the Repository.GetKnowledgeBasesByUIDs
type RepositoryMockGetKnowledgeBasesByUIDsParams struct {
	ctx    context.Context
	kbUIDs []types.KBUIDType
}

// RepositoryMockGetKnowledgeBasesByUIDsParamPtrs contains pointers to parameters of the Repository.GetKnowledgeBasesByUIDs
type RepositoryMockGetKnowledgeBasesByUIDsParamPtrs struct {
	ctx    *context.Context
	kbUIDs *[]types.KBUIDType
}

// RepositoryMockGetKnowledgeBasesByUIDsResults contains results of the Repository.GetKnowledgeBasesByUIDs
type RepositoryMockGetKnowledgeBasesByUIDsResults struct {
	ka1 []mm_repository.KnowledgeBaseModel
	err error
}

// RepositoryMockGetKnowledgeBasesByUIDsOrigins contains origins of expectations of the Repository.GetKnowledgeBasesByUIDs
type RepositoryMockGetKnowledgeBasesByUIDsExpectationOrigins struct {
	origin       string
	originCtx    string
	originKbUIDs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetKnowledgeBasesByUIDs *mRepositoryMockGetKnowledgeBasesByUIDs) Optional() *mRepositoryMockGetKnowledgeBasesByUIDs {
	mmGetKnowledgeBasesByUIDs.optional = true
	return mmGetKnowledgeBasesByUIDs
}

// Expect sets up expected params for Repository.GetKnowledgeBasesByUIDs
func (mmGetKnowledgeBasesByUIDs *mRepositoryMockGetKnowledgeBasesByUIDs) Expect(ctx context.Context, kbUIDs []types.KBUIDType) *mRepositoryMockGetKnowledgeBasesByUIDs {
	if mmGetKnowledgeBasesByUIDs.mock.funcGetKnowledgeBasesByUIDs != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBasesByUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBasesByUIDs.defaultExpectation == nil {
		mmGetKnowledgeBasesByUIDs.defaultExpectation = &RepositoryMockGetKnowledgeBasesByUIDsExpectation{}
	}

	if mmGetKnowledgeBasesByUIDs.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBasesByUIDs mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBasesByUIDs.defaultExpectation.params = &RepositoryMockGetKnowledgeBasesByUIDsParams{ctx, kbUIDs}
	mmGetKnowledgeBasesByUIDs.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetKnowledgeBasesByUIDs.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBasesByUIDs.defaultExpectation.params) {
			mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBasesByUIDs.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBasesByUIDs
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetKnowledgeBasesByUIDs
func (mmGetKnowledgeBasesByUIDs *mRepositoryMockGetKnowledgeBasesByUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetKnowledgeBasesByUIDs {
	if mmGetKnowledgeBasesByUIDs.mock.funcGetKnowledgeBasesByUIDs != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBasesByUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBasesByUIDs.defaultExpectation == nil {
		mmGetKnowledgeBasesByUIDs.defaultExpectation = &RepositoryMockGetKnowledgeBasesByUIDsExpectation{}
	}

	if mmGetKnowledgeBasesByUIDs.defaultExpectation.params != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBasesByUIDs mock is already set by Expect")
	}

	if mmGetKnowledgeBasesByUIDs.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBasesByUIDs.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBasesByUIDsParamPtrs{}
	}
	mmGetKnowledgeBasesByUIDs.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetKnowledgeBasesByUIDs.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetKnowledgeBasesByUIDs
}

// ExpectKbUIDsParam2 sets up expected param kbUIDs for Repository.GetKnowledgeBasesByUIDs
func (mmGetKnowledgeBasesByUIDs *mRepositoryMockGetKnowledgeBasesByUIDs) ExpectKbUIDsParam2(kbUIDs []types.KBUIDType) *mRepositoryMockGetKnowledgeBasesByUIDs {
	if mmGetKnowledgeBasesByUIDs.mock.funcGetKnowledgeBasesByUIDs != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBasesByUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBasesByUIDs.defaultExpectation == nil {
		mmGetKnowledgeBasesByUIDs.defaultExpectation = &RepositoryMockGetKnowledgeBasesByUIDsExpectation{}
	}

	if mmGetKnowledgeBasesByUIDs.defaultExpectation.params != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBasesByUIDs mock is already set by Expect")
	}

	if mmGetKnowledgeBasesByUIDs.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBasesByUIDs.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBasesByUIDsParamPtrs{}
	}
	mmGetKnowledgeBasesByUIDs.defaultExpectation.paramPtrs.kbUIDs = &kbUIDs
	mmGetKnowledgeBasesByUIDs.defaultExpectation.expectationOrigins.originKbUIDs = minimock.CallerInfo(1)

	return mmGetKnowledgeBasesByUIDs
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetKnowledgeBasesByUIDs
func (mmGetKnowledgeBasesByUIDs *mRepositoryMockGetKnowledgeBasesByUIDs) Inspect(f func(ctx context.Context, kbUIDs []types.KBUIDType)) *mRepositoryMockGetKnowledgeBasesByUIDs {
	if mmGetKnowledgeBasesByUIDs.mock.inspectFuncGetKnowledgeBasesByUIDs != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetKnowledgeBasesByUIDs")
	}

	mmGetKnowledgeBasesByUIDs.mock.inspectFuncGetKnowledgeBasesByUIDs = f

	return mmGetKnowledgeBasesByUIDs
}

// Return sets up results that will be returned by Repository.GetKnowledgeBasesByUIDs
func (mmGetKnowledgeBasesByUIDs *mRepositoryMockGetKnowledgeBasesByUIDs) Return(ka1 []mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	if mmGetKnowledgeBasesByUIDs.mock.funcGetKnowledgeBasesByUIDs != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBasesByUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBasesByUIDs.defaultExpectation == nil {
		mmGetKnowledgeBasesByUIDs.defaultExpectation = &RepositoryMockGetKnowledgeBasesByUIDsExpectation{mock: mmGetKnowledgeBasesByUIDs.mock}
	}
	mmGetKnowledgeBasesByUIDs.defaultExpectation.results = &RepositoryMockGetKnowledgeBasesByUIDsResults{ka1, err}
	mmGetKnowledgeBasesByUIDs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBasesByUIDs.mock
}

// Set uses given function f to mock the Repository.GetKnowledgeBasesByUIDs method
func (mmGetKnowledgeBasesByUIDs *mRepositoryMockGetKnowledgeBasesByUIDs) Set(f func(ctx context.Context, kbUIDs []types.KBUIDType) (ka1 []mm_repository.KnowledgeBaseModel, err error)) *RepositoryMock {
	if mmGetKnowledgeBasesByUIDs.defaultExpectation != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("Default expectation is already set for the Repository.GetKnowledgeBasesByUIDs method")
	}

	if len(mmGetKnowledgeBasesByUIDs.expectations) > 0 {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("Some expectations are already set for the Repository.GetKnowledgeBasesByUIDs method")
	}

	mmGetKnowledgeBasesByUIDs.mock.funcGetKnowledgeBasesByUIDs = f
	mmGetKnowledgeBasesByUIDs.mock.funcGetKnowledgeBasesByUIDsOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBasesByUIDs.mock
}

// When sets expectation for the Repository.GetKnowledgeBasesByUIDs which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBasesByUIDs *mRepositoryMockGetKnowledgeBasesByUIDs) When(ctx context.Context, kbUIDs []types.KBUIDType) *RepositoryMockGetKnowledgeBasesByUIDsExpectation {
	if mmGetKnowledgeBasesByUIDs.mock.funcGetKnowledgeBasesByUIDs != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBasesByUIDs mock is already set by Set")
	}

	expectation := &RepositoryMockGetKnowledgeBasesByUIDsExpectation{
		mock:               mmGetKnowledgeBasesByUIDs.mock,
		params:             &RepositoryMockGetKnowledgeBasesByUIDsParams{ctx, kbUIDs},
		expectationOrigins: RepositoryMockGetKnowledgeBasesByUIDsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetKnowledgeBasesByUIDs.expectations = append(mmGetKnowledgeBasesByUIDs.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetKnowledgeBasesByUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetKnowledgeBasesByUIDsExpectation) Then(ka1 []mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetKnowledgeBasesByUIDsResults{ka1, err}
	return e.mock
}

// Times sets number of times Repository.GetKnowledgeBasesByUIDs should be invoked
func (mmGetKnowledgeBasesByUIDs *mRepositoryMockGetKnowledgeBasesByUIDs) Times(n uint64) *mRepositoryMockGetKnowledgeBasesByUIDs {
	if n == 0 {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("Times of RepositoryMock.GetKnowledgeBasesByUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBasesByUIDs.expectedInvocations, n)
	mmGetKnowledgeBasesByUIDs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBasesByUIDs
}

func (mmGetKnowledgeBasesByUIDs *mRepositoryMockGetKnowledgeBasesByUIDs) invocationsDone() bool {
	if len(mmGetKnowledgeBasesByUIDs.expectations) == 0 && mmGetKnowledgeBasesByUIDs.defaultExpectation == nil && mmGetKnowledgeBasesByUIDs.mock.funcGetKnowledgeBasesByUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBasesByUIDs.mock.afterGetKnowledgeBasesByUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBasesByUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBasesByUIDs implements mm_repository.Repository
func (mmGetKnowledgeBasesByUIDs *RepositoryMock) GetKnowledgeBasesByUIDs(ctx context.Context, kbUIDs []types.KBUIDType) (ka1 []mm_repository.KnowledgeBaseModel, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBasesByUIDs.beforeGetKnowledgeBasesByUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBasesByUIDs.afterGetKnowledgeBasesByUIDsCounter, 1)

	mmGetKnowledgeBasesByUIDs.t.Helper()

	if mmGetKnowledgeBasesByUIDs.inspectFuncGetKnowledgeBasesByUIDs != nil {
		mmGetKnowledgeBasesByUIDs.inspectFuncGetKnowledgeBasesByUIDs(ctx, kbUIDs)
	}

	mm_params := RepositoryMockGetKnowledgeBasesByUIDsParams{ctx, kbUIDs}

	// Record call args
	mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.mutex.Lock()
	mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.callArgs = append(mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.callArgs, &mm_params)
	mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetKnowledgeBasesByUIDsParams{ctx, kbUIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBasesByUIDs.t.Errorf("RepositoryMock.GetKnowledgeBasesByUIDs got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUIDs != nil && !minimock.Equal(*mm_want_ptrs.kbUIDs, mm_got.kbUIDs) {
				mmGetKnowledgeBasesByUIDs.t.Errorf("RepositoryMock.GetKnowledgeBasesByUIDs got unexpected parameter kbUIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.defaultExpectation.expectationOrigins.originKbUIDs, *mm_want_ptrs.kbUIDs, mm_got.kbUIDs, minimock.Diff(*mm_want_ptrs.kbUIDs, mm_got.kbUIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBasesByUIDs.t.Errorf("RepositoryMock.GetKnowledgeBasesByUIDs got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBasesByUIDs.t.Fatal("No results are set for the RepositoryMock.GetKnowledgeBasesByUIDs")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmGetKnowledgeBasesByUIDs.funcGetKnowledgeBasesByUIDs != nil {
		return mmGetKnowledgeBasesByUIDs.funcGetKnowledgeBasesByUIDs(ctx, kbUIDs)
	}
	mmGetKnowledgeBasesByUIDs.t.Fatalf("Unexpected call to RepositoryMock.GetKnowledgeBasesByUIDs. %v %v", ctx, kbUIDs)
	return
}

// GetKnowledgeBasesByUIDsAfterCounter returns a count of finished RepositoryMock.GetKnowledgeBasesByUIDs invocations
func (mmGetKnowledgeBasesByUIDs *RepositoryMock) GetKnowledgeBasesByUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBasesByUIDs.afterGetKnowledgeBasesByUIDsCounter)
}

// GetKnowledgeBasesByUIDsBeforeCounter returns a count of RepositoryMock.GetKnowledgeBasesByUIDs invocations
func (mmGetKnowledgeBasesByUIDs *RepositoryMock) GetKnowledgeBasesByUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBasesByUIDs.beforeGetKnowledgeBasesByUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetKnowledgeBasesByUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBasesByUIDs *mRepositoryMockGetKnowledgeBasesByUIDs) Calls() []*RepositoryMockGetKnowledgeBasesByUIDsParams {
	mmGetKnowledgeBasesByUIDs.mutex.RLock()

	argCopy := make([]*RepositoryMockGetKnowledgeBasesByUIDsParams, len(mmGetKnowledgeBasesByUIDs.callArgs))
	copy(argCopy, mmGetKnowledgeBasesByUIDs.callArgs)

	mmGetKnowledgeBasesByUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBasesByUIDsDone returns true if the count of the GetKnowledgeBasesByUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetKnowledgeBasesByUIDsDone() bool {
	if m.GetKnowledgeBasesByUIDsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetKnowledgeBasesByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBasesByUIDsMock.invocationsDone()
}

// MinimockGetKnowledgeBasesByUIDsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetKnowledgeBasesByUIDsInspect() {
	for _, e := range m.GetKnowledgeBasesByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBasesByUIDs at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetKnowledgeBasesByUIDsCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBasesByUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBasesByUIDsMock.defaultExpectation != nil && afterGetKnowledgeBasesByUIDsCounter < 1 {
		if m.GetKnowledgeBasesByUIDsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBasesByUIDs at\n%s", m.GetKnowledgeBasesByUIDsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBasesByUIDs at\n%s with params: %#v", m.GetKnowledgeBasesByUIDsMock.defaultExpectation.expectationOrigins.origin, *m.GetKnowledgeBasesByUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBasesByUIDs != nil && afterGetKnowledgeBasesByUIDsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBasesByUIDs at\n%s", m.funcGetKnowledgeBasesByUIDsOrigin)
	}

	if !m.GetKnowledgeBasesByUIDsMock.invocationsDone() && afterGetKnowledgeBasesByUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetKnowledgeBasesByUIDs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBasesByUIDsMock.expectedInvocations), m.GetKnowledgeBasesByUIDsMock.expectedInvocationsOrigin, afterGetKnowledgeBasesByUIDsCounter)
	}
}

type mRepositoryMockGetKnowledgeBasesByUIDsWithConfig struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetKnowledgeBasesByUIDsWithConfigExpectation
	expectations       []*RepositoryMockGetKnowledgeBasesByUIDsWithConfigExpectation

	callArgs []*RepositoryMockGetKnowledgeBasesByUIDsWithConfigParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetKnowledgeBasesByUIDsWithConfigExpectation specifies expectation struct of the Repository.GetKnowledgeBasesByUIDsWithConfig
type RepositoryMockGetKnowledgeBasesByUIDsWithConfigExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetKnowledgeBasesByUIDsWithConfigParams
	paramPtrs          *RepositoryMockGetKnowledgeBasesByUIDsWithConfigParamPtrs
	expectationOrigins RepositoryMockGetKnowledgeBasesByUIDsWithConfigExpectationOrigins
	results            *RepositoryMockGetKnowledgeBasesByUIDsWithConfigResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetKnowledgeBasesByUIDsWithConfigParams contains parameters of the Repository.GetKnowledgeBasesByUIDsWithConfig
type RepositoryMockGetKnowledgeBasesByUIDsWithConfigParams struct {
	ctx    context.Context
	kbUIDs []types.KBUIDType
}

// RepositoryMockGetKnowledgeBasesByUIDsWithConfigParamPtrs contains pointers to parameters of the Repository.GetKnowledgeBasesByUIDsWithConfig
type RepositoryMockGetKnowledgeBasesByUIDsWithConfigParamPtrs struct {
	ctx    *context.Context
	kbUIDs *[]types.KBUIDType
}

// RepositoryMockGetKnowledgeBasesByUIDsWithConfigResults contains results of the Repository.GetKnowledgeBasesByUIDsWithConfig
type RepositoryMockGetKnowledgeBasesByUIDsWithConfigResults struct {
	ka1 []mm_repository.KnowledgeBaseWithConfig
	err error
}

// RepositoryMockGetKnowledgeBasesByUIDsWithConfigOrigins contains origins of expectations of the Repository.GetKnowledgeBasesByUIDsWithConfig
type RepositoryMockGetKnowledgeBasesByUIDsWithConfigExpectationOrigins struct {
	origin       string
	originCtx    string
	originKbUIDs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetKnowledgeBasesByUIDsWithConfig *mRepositoryMockGetKnowledgeBasesByUIDsWithConfig) Optional() *mRepositoryMockGetKnowledgeBasesByUIDsWithConfig {
	mmGetKnowledgeBasesByUIDsWithConfig.optional = true
	return mmGetKnowledgeBasesByUIDsWithConfig
}

// Expect sets up expected params for Repository.GetKnowledgeBasesByUIDsWithConfig
func (mmGetKnowledgeBasesByUIDsWithConfig *mRepositoryMockGetKnowledgeBasesByUIDsWithConfig) Expect(ctx context.Context, kbUIDs []types.KBUIDType) *mRepositoryMockGetKnowledgeBasesByUIDsWithConfig {
	if mmGetKnowledgeBasesByUIDsWithConfig.mock.funcGetKnowledgeBasesByUIDsWithConfig != nil {
		mmGetKnowledgeBasesByUIDsWithConfig.mock.t.Fatalf("RepositoryMock.GetKnowledgeBasesByUIDsWithConfig mock is already set by Set")
	}

	if mmGetKnowledgeBasesByUIDsWithConfig.defaultExpectation == nil {
		mmGetKnowledgeBasesByUIDsWithConfig.defaultExpectation = &RepositoryMockGetKnowledgeBasesByUIDsWithConfigExpectation{}
	}

	if mmGetKnowledgeBasesByUIDsWithConfig.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBasesByUIDsWithConfig.mock.t.Fatalf("RepositoryMock.GetKnowledgeBasesByUIDsWithConfig mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBasesByUIDsWithConfig.defaultExpectation.params = &RepositoryMockGetKnowledgeBasesByUIDsWithConfigParams{ctx, kbUIDs}
	mmGetKnowledgeBasesByUIDsWithConfig.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetKnowledgeBasesByUIDsWithConfig.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBasesByUIDsWithConfig.defaultExpectation.params) {
			mmGetKnowledgeBasesByUIDsWithConfig.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBasesByUIDsWithConfig.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBasesByUIDsWithConfig
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetKnowledgeBasesByUIDsWithConfig
func (mmGetKnowledgeBasesByUIDsWithConfig *mRepositoryMockGetKnowledgeBasesByUIDsWithConfig) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetKnowledgeBasesByUIDsWithConfig {
	if mmGetKnowledgeBasesByUIDsWithConfig.mock.funcGetKnowledgeBasesByUIDsWithConfig != nil {
		mmGetKnowledgeBasesByUIDsWithConfig.mock.t.Fatalf("RepositoryMock.GetKnowledgeBasesByUIDsWithConfig mock is already set by Set")
	}

	if mmGetKnowledgeBasesByUIDsWithConfig.defaultExpectation == nil {
		mmGetKnowledgeBasesByUIDsWithConfig.defaultExpectation = &RepositoryMockGetKnowledgeBasesByUIDsWithConfigExpectation{}
	}

	if mmGetKnowledgeBasesByUIDsWithConfig.defaultExpectation.params != nil {
		mmGetKnowledgeBasesByUIDsWithConfig.mock.t.Fatalf("RepositoryMock.GetKnowledgeBasesByUIDsWithConfig mock is already set by Expect")
	}

	if mmGetKnowledgeBasesByUIDsWithConfig.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBasesByUIDsWithConfig.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBasesByUIDsWithConfigParamPtrs{}
	}
	mmGetKnowledgeBasesByUIDsWithConfig.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetKnowledgeBasesByUIDsWithConfig.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetKnowledgeBasesByUIDsWithConfig
}

// ExpectKbUIDsParam2 sets up expected param kbUIDs for Repository.GetKnowledgeBasesByUIDsWithConfig
func (mmGetKnowledgeBasesByUIDsWithConfig *mRepositoryMockGetKnowledgeBasesByUIDsWithConfig) ExpectKbUIDsParam2(kbUIDs []types.KBUIDType) *mRepositoryMockGetKnowledgeBasesByUIDsWithConfig {
	if mmGetKnowledgeBasesByUIDsWithConfig.mock.funcGetKnowledgeBasesByUIDsWithConfig != nil {
		mmGetKnowledgeBasesByUIDsWithConfig.mock.t.Fatalf("RepositoryMock.GetKnowledgeBasesByUIDsWithConfig mock is already set by Set")
	}

	if mmGetKnowledgeBasesByUIDsWithConfig.defaultExpectation == nil {
		mmGetKnowledgeBasesByUIDsWithConfig.defaultExpectation = &RepositoryMockGetKnowledgeBasesByUIDsWithConfigExpectation{}
	}

	if mmGetKnowledgeBasesByUIDsWithConfig.defaultExpectation.params != nil {
		mmGetKnowledgeBasesByUIDsWithConfig.mock.t.Fatalf("RepositoryMock.GetKnowledgeBasesByUIDsWithConfig mock is already set by Expect")
	}

	if mmGetKnowledgeBasesByUIDsWithConfig.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBasesByUIDsWithConfig.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBasesByUIDsWithConfigParamPtrs{}
	}
	mmGetKnowledgeBasesByUIDsWithConfig.defaultExpectation.paramPtrs.kbUIDs = &kbUIDs
	mmGetKnowledgeBasesByUIDsWithConfig.defaultExpectation.expectationOrigins.originKbUIDs = minimock.CallerInfo(1)

	return mmGetKnowledgeBasesByUIDsWithConfig
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetKnowledgeBasesByUIDsWithConfig
func (mmGetKnowledgeBasesByUIDsWithConfig *mRepositoryMockGetKnowledgeBasesByUIDsWithConfig) Inspect(f func(ctx context.Context, kbUIDs []types.KBUIDType)) *mRepositoryMockGetKnowledgeBasesByUIDsWithConfig {
	if mmGetKnowledgeBasesByUIDsWithConfig.mock.inspectFuncGetKnowledgeBasesByUIDsWithConfig != nil {
		mmGetKnowledgeBasesByUIDsWithConfig.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetKnowledgeBasesByUIDsWithConfig")
	}

	mmGetKnowledgeBasesByUIDsWithConfig.mock.inspectFuncGetKnowledgeBasesByUIDsWithConfig = f

	return mmGetKnowledgeBasesByUIDsWithConfig
}

// Return sets up results that will be returned by Repository.GetKnowledgeBasesByUIDsWithConfig
func (mmGetKnowledgeBasesByUIDsWithConfig *mRepositoryMockGetKnowledgeBasesByUIDsWithConfig) Return(ka1 []mm_repository.KnowledgeBaseWithConfig, err error) *RepositoryMock {
	if mmGetKnowledgeBasesByUIDsWithConfig.mock.funcGetKnowledgeBasesByUIDsWithConfig != nil {
		mmGetKnowledgeBasesByUIDsWithConfig.mock.t.Fatalf("RepositoryMock.GetKnowledgeBasesByUIDsWithConfig mock is already set by Set")
	}

	if mmGetKnowledgeBasesByUIDsWithConfig.defaultExpectation == nil {
		mmGetKnowledgeBasesByUIDsWithConfig.defaultExpectation = &RepositoryMockGetKnowledgeBasesByUIDsWithConfigExpectation{mock: mmGetKnowledgeBasesByUIDsWithConfig.mock}
	}
	mmGetKnowledgeBasesByUIDsWithConfig.defaultExpectation.results = &RepositoryMockGetKnowledgeBasesByUIDsWithConfigResults{ka1, err}
	mmGetKnowledgeBasesByUIDsWithConfig.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBasesByUIDsWithConfig.mock
}

// Set uses given function f to mock the Repository.GetKnowledgeBasesByUIDsWithConfig method
func (mmGetKnowledgeBasesByUIDsWithConfig *mRepositoryMockGetKnowledgeBasesByUIDsWithConfig) Set(f func(ctx context.Context, kbUIDs []types.KBUIDType) (ka1 []mm_repository.KnowledgeBaseWithConfig, err error)) *RepositoryMock {
	if mmGetKnowledgeBasesByUIDsWithConfig.defaultExpectation != nil {
		mmGetKnowledgeBasesByUIDsWithConfig.mock.t.Fatalf("Default expectation is already set for the Repository.GetKnowledgeBasesByUIDsWithConfig method")
	}

	if len(mmGetKnowledgeBasesByUIDsWithConfig.expectations) > 0 {
		mmGetKnowledgeBasesByUIDsWithConfig.mock.t.Fatalf("Some expectations are already set for the Repository.GetKnowledgeBasesByUIDsWithConfig method")
	}

	mmGetKnowledgeBasesByUIDsWithConfig.mock.funcGetKnowledgeBasesByUIDsWithConfig = f
	mmGetKnowledgeBasesByUIDsWithConfig.mock.funcGetKnowledgeBasesByUIDsWithConfigOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBasesByUIDsWithConfig.mock
}

// When sets expectation for the Repository.GetKnowledgeBasesByUIDsWithConfig which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBasesByUIDsWithConfig *mRepositoryMockGetKnowledgeBasesByUIDsWithConfig) When(ctx context.Context, kbUIDs []types.KBUIDType) *RepositoryMockGetKnowledgeBasesByUIDsWithConfigExpectation {
	if mmGetKnowledgeBasesByUIDsWithConfig.mock.funcGetKnowledgeBasesByUIDsWithConfig != nil {
		mmGetKnowledgeBasesByUIDsWithConfig.mock.t.Fatalf("RepositoryMock.GetKnowledgeBasesByUIDsWithConfig mock is already set by Set")
	}

	expectation := &RepositoryMockGetKnowledgeBasesByUIDsWithConfigExpectation{
		mock:               mmGetKnowledgeBasesByUIDsWithConfig.mock,
		params:             &RepositoryMockGetKnowledgeBasesByUIDsWithConfigParams{ctx, kbUIDs},
		expectationOrigins: RepositoryMockGetKnowledgeBasesByUIDsWithConfigExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetKnowledgeBasesByUIDsWithConfig.expectations = append(mmGetKnowledgeBasesByUIDsWithConfig.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetKnowledgeBasesByUIDsWithConfig return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetKnowledgeBasesByUIDsWithConfigExpectation) Then(ka1 []mm_repository.KnowledgeBaseWithConfig, err error) *RepositoryMock {
	e.results = &RepositoryMockGetKnowledgeBasesByUIDsWithConfigResults{ka1, err}
	return e.mock
}

// Times sets number of times Repository.GetKnowledgeBasesByUIDsWithConfig should be invoked
func (mmGetKnowledgeBasesByUIDsWithConfig *mRepositoryMockGetKnowledgeBasesByUIDsWithConfig) Times(n uint64) *mRepositoryMockGetKnowledgeBasesByUIDsWithConfig {
	if n == 0 {
		mmGetKnowledgeBasesByUIDsWithConfig.mock.t.Fatalf("Times of RepositoryMock.GetKnowledgeBasesByUIDsWithConfig mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBasesByUIDsWithConfig.expectedInvocations, n)
	mmGetKnowledgeBasesByUIDsWithConfig.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBasesByUIDsWithConfig
}

func (mmGetKnowledgeBasesByUIDsWithConfig *mRepositoryMockGetKnowledgeBasesByUIDsWithConfig) invocationsDone() bool {
	if len(mmGetKnowledgeBasesByUIDsWithConfig.expectations) == 0 && mmGetKnowledgeBasesByUIDsWithConfig.defaultExpectation == nil && mmGetKnowledgeBasesByUIDsWithConfig.mock.funcGetKnowledgeBasesByUIDsWithConfig == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBasesByUIDsWithConfig.mock.afterGetKnowledgeBasesByUIDsWithConfigCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBasesByUIDsWithConfig.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBasesByUIDsWithConfig implements mm_repository.Repository
func (mmGetKnowledgeBasesByUIDsWithConfig *RepositoryMock) GetKnowledgeBasesByUIDsWithConfig(ctx context.Context, kbUIDs []types.KBUIDType) (ka1 []mm_repository.KnowledgeBaseWithConfig, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBasesByUIDsWithConfig.beforeGetKnowledgeBasesByUIDsWithConfigCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBasesByUIDsWithConfig.afterGetKnowledgeBasesByUIDsWithConfigCounter, 1)

	mmGetKnowledgeBasesByUIDsWithConfig.t.Helper()

	if mmGetKnowledgeBasesByUIDsWithConfig.inspectFuncGetKnowledgeBasesByUIDsWithConfig != nil {
		mmGetKnowledgeBasesByUIDsWithConfig.inspectFuncGetKnowledgeBasesByUIDsWithConfig(ctx, kbUIDs)
	}

	mm_params := RepositoryMockGetKnowledgeBasesByUIDsWithConfigParams{ctx, kbUIDs}

	// Record call args
	mmGetKnowledgeBasesByUIDsWithConfig.GetKnowledgeBasesByUIDsWithConfigMock.mutex.Lock()
	mmGetKnowledgeBasesByUIDsWithConfig.GetKnowledgeBasesByUIDsWithConfigMock.callArgs = append(mmGetKnowledgeBasesByUIDsWithConfig.GetKnowledgeBasesByUIDsWithConfigMock.callArgs, &mm_params)
	mmGetKnowledgeBasesByUIDsWithConfig.GetKnowledgeBasesByUIDsWithConfigMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBasesByUIDsWithConfig.GetKnowledgeBasesByUIDsWithConfigMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmGetKnowledgeBasesByUIDsWithConfig.GetKnowledgeBasesByUIDsWithConfigMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBasesByUIDsWithConfig.GetKnowledgeBasesByUIDsWithConfigMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBasesByUIDsWithConfig.GetKnowledgeBasesByUIDsWithConfigMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBasesByUIDsWithConfig.GetKnowledgeBasesByUIDsWithConfigMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetKnowledgeBasesByUIDsWithConfigParams{ctx, kbUIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBasesByUIDsWithConfig.t.Errorf("RepositoryMock.GetKnowledgeBasesByUIDsWithConfig got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBasesByUIDsWithConfig.GetKnowledgeBasesByUIDsWithConfigMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUIDs != nil && !minimock.Equal(*mm_want_ptrs.kbUIDs, mm_got.kbUIDs) {
				mmGetKnowledgeBasesByUIDsWithConfig.t.Errorf("RepositoryMock.GetKnowledgeBasesByUIDsWithConfig got unexpected parameter kbUIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBasesByUIDsWithConfig.GetKnowledgeBasesByUIDsWithConfigMock.defaultExpectation.expectationOrigins.originKbUIDs, *mm_want_ptrs.kbUIDs, mm_got.kbUIDs, minimock.Diff(*mm_want_ptrs.kbUIDs, mm_got.kbUIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBasesByUIDsWithConfig.t.Errorf("RepositoryMock.GetKnowledgeBasesByUIDsWithConfig got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetKnowledgeBasesByUIDsWithConfig.GetKnowledgeBasesByUIDsWithConfigMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBasesByUIDsWithConfig.GetKnowledgeBasesByUIDsWithConfigMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBasesByUIDsWithConfig.t.Fatal("No results are set for the RepositoryMock.GetKnowledgeBasesByUIDsWithConfig")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmGetKnowledgeBasesByUIDsWithConfig.funcGetKnowledgeBasesByUIDsWithConfig != nil {
		return mmGetKnowledgeBasesByUIDsWithConfig.funcGetKnowledgeBasesByUIDsWithConfig(ctx, kbUIDs)
	}
	mmGetKnowledgeBasesByUIDsWithConfig.t.Fatalf("Unexpected call to RepositoryMock.GetKnowledgeBasesByUIDsWithConfig. %v %v", ctx, kbUIDs)
	return
}

// GetKnowledgeBasesByUIDsWithConfigAfterCounter returns a count of finished RepositoryMock.GetKnowledgeBasesByUIDsWithConfig invocations
func (mmGetKnowledgeBasesByUIDsWithConfig *RepositoryMock) GetKnowledgeBasesByUIDsWithConfigAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBasesByUIDsWithConfig.afterGetKnowledgeBasesByUIDsWithConfigCounter)
}

// GetKnowledgeBasesByUIDsWithConfigBeforeCounter returns a count of RepositoryMock.GetKnowledgeBasesByUIDsWithConfig invocations
func (mmGetKnowledgeBasesByUIDsWithConfig *RepositoryMock) GetKnowledgeBasesByUIDsWithConfigBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBasesByUIDsWithConfig.beforeGetKnowledgeBasesByUIDsWithConfigCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetKnowledgeBasesByUIDsWithConfig.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBasesByUIDsWithConfig *mRepositoryMockGetKnowledgeBasesByUIDsWithConfig) Calls() []*RepositoryMockGetKnowledgeBasesByUIDsWithConfigParams {
	mmGetKnowledgeBasesByUIDsWithConfig.mutex.RLock()

	argCopy := make([]*RepositoryMockGetKnowledgeBasesByUIDsWithConfigParams, len(mmGetKnowledgeBasesByUIDsWithConfig.callArgs))
	copy(argCopy, mmGetKnowledgeBasesByUIDsWithConfig.callArgs)

	mmGetKnowledgeBasesByUIDsWithConfig.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBasesByUIDsWithConfigDone returns true if the count of the GetKnowledgeBasesByUIDsWithConfig invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetKnowledgeBasesByUIDsWithConfigDone() bool {
	if m.GetKnowledgeBasesByUIDsWithConfigMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetKnowledgeBasesByUIDsWithConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBasesByUIDsWithConfigMock.invocationsDone()
}

// MinimockGetKnowledgeBasesByUIDsWithConfigInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetKnowledgeBasesByUIDsWithConfigInspect() {
	for _, e := range m.GetKnowledgeBasesByUIDsWithConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBasesByUIDsWithConfig at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetKnowledgeBasesByUIDsWithConfigCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBasesByUIDsWithConfigCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBasesByUIDsWithConfigMock.defaultExpectation != nil && afterGetKnowledgeBasesByUIDsWithConfigCounter < 1 {
		if m.GetKnowledgeBasesByUIDsWithConfigMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBasesByUIDsWithConfig at\n%s", m.GetKnowledgeBasesByUIDsWithConfigMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBasesByUIDsWithConfig at\n%s with params: %#v", m.GetKnowledgeBasesByUIDsWithConfigMock.defaultExpectation.expectationOrigins.origin, *m.GetKnowledgeBasesByUIDsWithConfigMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBasesByUIDsWithConfig != nil && afterGetKnowledgeBasesByUIDsWithConfigCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBasesByUIDsWithConfig at\n%s", m.funcGetKnowledgeBasesByUIDsWithConfigOrigin)
	}

	if !m.GetKnowledgeBasesByUIDsWithConfigMock.invocationsDone() && afterGetKnowledgeBasesByUIDsWithConfigCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetKnowledgeBasesByUIDsWithConfig at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBasesByUIDsWithConfigMock.expectedInvocations), m.GetKnowledgeBasesByUIDsWithConfigMock.expectedInvocationsOrigin, afterGetKnowledgeBasesByUIDsWithConfigCounter)
	}
}

type mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectation
	expectations       []*RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectation

	callArgs []*RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectation specifies expectation struct of the Repository.GetKnowledgebaseFileByKBUIDAndFileID
type RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParams
	paramPtrs          *RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParamPtrs
	expectationOrigins RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectationOrigins
	results            *RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParams contains parameters of the Repository.GetKnowledgebaseFileByKBUIDAndFileID
type RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParams struct {
	ctx    context.Context
	kbUID  types.KBUIDType
	fileID string
}

// RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParamPtrs contains pointers to parameters of the Repository.GetKnowledgebaseFileByKBUIDAndFileID
type RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParamPtrs struct {
	ctx    *context.Context
	kbUID  *types.KBUIDType
	fileID *string
}

// RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDResults contains results of the Repository.GetKnowledgebaseFileByKBUIDAndFileID
type RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDResults struct {
	kp1 *mm_repository.KnowledgeBaseFileModel
	err error
}

// RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDOrigins contains origins of expectations of the Repository.GetKnowledgebaseFileByKBUIDAndFileID
type RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectationOrigins struct {
	origin       string
	originCtx    string
	originKbUID  string
	originFileID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetKnowledgebaseFileByKBUIDAndFileID *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID) Optional() *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID {
	mmGetKnowledgebaseFileByKBUIDAndFileID.optional = true
	return mmGetKnowledgebaseFileByKBUIDAndFileID
}

// Expect sets up expected params for Repository.GetKnowledgebaseFileByKBUIDAndFileID
func (mmGetKnowledgebaseFileByKBUIDAndFileID *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID) Expect(ctx context.Context, kbUID types.KBUIDType, fileID string) *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID {
	if mmGetKnowledgebaseFileByKBUIDAndFileID.mock.funcGetKnowledgebaseFileByKBUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID mock is already set by Set")
	}

	if mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation == nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation = &RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectation{}
	}

	if mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID mock is already set by ExpectParams functions")
	}

	mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.params = &RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParams{ctx, kbUID, fileID}
	mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetKnowledgebaseFileByKBUIDAndFileID.expectations {
		if minimock.Equal(e.params, mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.params) {
			mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.params)
		}
	}

	return mmGetKnowledgebaseFileByKBUIDAndFileID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetKnowledgebaseFileByKBUIDAndFileID
func (mmGetKnowledgebaseFileByKBUIDAndFileID *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID {
	if mmGetKnowledgebaseFileByKBUIDAndFileID.mock.funcGetKnowledgebaseFileByKBUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID mock is already set by Set")
	}

	if mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation == nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation = &RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectation{}
	}

	if mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.params != nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID mock is already set by Expect")
	}

	if mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParamPtrs{}
	}
	mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetKnowledgebaseFileByKBUIDAndFileID
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.GetKnowledgebaseFileByKBUIDAndFileID
func (mmGetKnowledgebaseFileByKBUIDAndFileID *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID {
	if mmGetKnowledgebaseFileByKBUIDAndFileID.mock.funcGetKnowledgebaseFileByKBUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID mock is already set by Set")
	}

	if mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation == nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation = &RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectation{}
	}

	if mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.params != nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID mock is already set by Expect")
	}

	if mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParamPtrs{}
	}
	mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmGetKnowledgebaseFileByKBUIDAndFileID
}

// ExpectFileIDParam3 sets up expected param fileID for Repository.GetKnowledgebaseFileByKBUIDAndFileID
func (mmGetKnowledgebaseFileByKBUIDAndFileID *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID) ExpectFileIDParam3(fileID string) *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID {
	if mmGetKnowledgebaseFileByKBUIDAndFileID.mock.funcGetKnowledgebaseFileByKBUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID mock is already set by Set")
	}

	if mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation == nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation = &RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectation{}
	}

	if mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.params != nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID mock is already set by Expect")
	}

	if mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParamPtrs{}
	}
	mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.paramPtrs.fileID = &fileID
	mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.expectationOrigins.originFileID = minimock.CallerInfo(1)

	return mmGetKnowledgebaseFileByKBUIDAndFileID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetKnowledgebaseFileByKBUIDAndFileID
func (mmGetKnowledgebaseFileByKBUIDAndFileID *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID) Inspect(f func(ctx context.Context, kbUID types.KBUIDType, fileID string)) *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID {
	if mmGetKnowledgebaseFileByKBUIDAndFileID.mock.inspectFuncGetKnowledgebaseFileByKBUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID")
	}

	mmGetKnowledgebaseFileByKBUIDAndFileID.mock.inspectFuncGetKnowledgebaseFileByKBUIDAndFileID = f

	return mmGetKnowledgebaseFileByKBUIDAndFileID
}

// Return sets up results that will be returned by Repository.GetKnowledgebaseFileByKBUIDAndFileID
func (mmGetKnowledgebaseFileByKBUIDAndFileID *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID) Return(kp1 *mm_repository.KnowledgeBaseFileModel, err error) *RepositoryMock {
	if mmGetKnowledgebaseFileByKBUIDAndFileID.mock.funcGetKnowledgebaseFileByKBUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID mock is already set by Set")
	}

	if mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation == nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation = &RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectation{mock: mmGetKnowledgebaseFileByKBUIDAndFileID.mock}
	}
	mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.results = &RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDResults{kp1, err}
	mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgebaseFileByKBUIDAndFileID.mock
}

// Set uses given function f to mock the Repository.GetKnowledgebaseFileByKBUIDAndFileID method
func (mmGetKnowledgebaseFileByKBUIDAndFileID *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID) Set(f func(ctx context.Context, kbUID types.KBUIDType, fileID string) (kp1 *mm_repository.KnowledgeBaseFileModel, err error)) *RepositoryMock {
	if mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation != nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("Default expectation is already set for the Repository.GetKnowledgebaseFileByKBUIDAndFileID method")
	}

	if len(mmGetKnowledgebaseFileByKBUIDAndFileID.expectations) > 0 {
		mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("Some expectations are already set for the Repository.GetKnowledgebaseFileByKBUIDAndFileID method")
	}

	mmGetKnowledgebaseFileByKBUIDAndFileID.mock.funcGetKnowledgebaseFileByKBUIDAndFileID = f
	mmGetKnowledgebaseFileByKBUIDAndFileID.mock.funcGetKnowledgebaseFileByKBUIDAndFileIDOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgebaseFileByKBUIDAndFileID.mock
}

// When sets expectation for the Repository.GetKnowledgebaseFileByKBUIDAndFileID which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgebaseFileByKBUIDAndFileID *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID) When(ctx context.Context, kbUID types.KBUIDType, fileID string) *RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectation {
	if mmGetKnowledgebaseFileByKBUIDAndFileID.mock.funcGetKnowledgebaseFileByKBUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID mock is already set by Set")
	}

	expectation := &RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectation{
		mock:               mmGetKnowledgebaseFileByKBUIDAndFileID.mock,
		params:             &RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParams{ctx, kbUID, fileID},
		expectationOrigins: RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetKnowledgebaseFileByKBUIDAndFileID.expectations = append(mmGetKnowledgebaseFileByKBUIDAndFileID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetKnowledgebaseFileByKBUIDAndFileID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectation) Then(kp1 *mm_repository.KnowledgeBaseFileModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDResults{kp1, err}
	return e.mock
}

// Times sets number of times Repository.GetKnowledgebaseFileByKBUIDAndFileID should be invoked
func (mmGetKnowledgebaseFileByKBUIDAndFileID *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID) Times(n uint64) *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID {
	if n == 0 {
		mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("Times of RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgebaseFileByKBUIDAndFileID.expectedInvocations, n)
	mmGetKnowledgebaseFileByKBUIDAndFileID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgebaseFileByKBUIDAndFileID
}

func (mmGetKnowledgebaseFileByKBUIDAndFileID *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID) invocationsDone() bool {
	if len(mmGetKnowledgebaseFileByKBUIDAndFileID.expectations) == 0 && mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation == nil && mmGetKnowledgebaseFileByKBUIDAndFileID.mock.funcGetKnowledgebaseFileByKBUIDAndFileID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgebaseFileByKBUIDAndFileID.mock.afterGetKnowledgebaseFileByKBUIDAndFileIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgebaseFileByKBUIDAndFileID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgebaseFileByKBUIDAndFileID implements mm_repository.Repository
func (mmGetKnowledgebaseFileByKBUIDAndFileID *RepositoryMock) GetKnowledgebaseFileByKBUIDAndFileID(ctx context.Context, kbUID types.KBUIDType, fileID string) (kp1 *mm_repository.KnowledgeBaseFileModel, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgebaseFileByKBUIDAndFileID.beforeGetKnowledgebaseFileByKBUIDAndFileIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgebaseFileByKBUIDAndFileID.afterGetKnowledgebaseFileByKBUIDAndFileIDCounter, 1)

	mmGetKnowledgebaseFileByKBUIDAndFileID.t.Helper()

	if mmGetKnowledgebaseFileByKBUIDAndFileID.inspectFuncGetKnowledgebaseFileByKBUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.inspectFuncGetKnowledgebaseFileByKBUIDAndFileID(ctx, kbUID, fileID)
	}

	mm_params := RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParams{ctx, kbUID, fileID}

	// Record call args
	mmGetKnowledgebaseFileByKBUIDAndFileID.GetKnowledgebaseFileByKBUIDAndFileIDMock.mutex.Lock()
	mmGetKnowledgebaseFileByKBUIDAndFileID.GetKnowledgebaseFileByKBUIDAndFileIDMock.callArgs = append(mmGetKnowledgebaseFileByKBUIDAndFileID.GetKnowledgebaseFileByKBUIDAndFileIDMock.callArgs, &mm_params)
	mmGetKnowledgebaseFileByKBUIDAndFileID.GetKnowledgebaseFileByKBUIDAndFileIDMock.mutex.Unlock()

	for _, e := range mmGetKnowledgebaseFileByKBUIDAndFileID.GetKnowledgebaseFileByKBUIDAndFileIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmGetKnowledgebaseFileByKBUIDAndFileID.GetKnowledgebaseFileByKBUIDAndFileIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgebaseFileByKBUIDAndFileID.GetKnowledgebaseFileByKBUIDAndFileIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgebaseFileByKBUIDAndFileID.GetKnowledgebaseFileByKBUIDAndFileIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgebaseFileByKBUIDAndFileID.GetKnowledgebaseFileByKBUIDAndFileIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParams{ctx, kbUID, fileID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgebaseFileByKBUIDAndFileID.t.Errorf("RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgebaseFileByKBUIDAndFileID.GetKnowledgebaseFileByKBUIDAndFileIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmGetKnowledgebaseFileByKBUIDAndFileID.t.Errorf("RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgebaseFileByKBUIDAndFileID.GetKnowledgebaseFileByKBUIDAndFileIDMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.fileID != nil && !minimock.Equal(*mm_want_ptrs.fileID, mm_got.fileID) {
				mmGetKnowledgebaseFileByKBUIDAndFileID.t.Errorf("RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID got unexpected parameter fileID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgebaseFileByKBUIDAndFileID.GetKnowledgebaseFileByKBUIDAndFileIDMock.defaultExpectation.expectationOrigins.originFileID, *mm_want_ptrs.fileID, mm_got.fileID, minimock.Diff(*mm_want_ptrs.fileID, mm_got.fileID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgebaseFileByKBUIDAndFileID.t.Errorf("RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetKnowledgebaseFileByKBUIDAndFileID.GetKnowledgebaseFileByKBUIDAndFileIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgebaseFileByKBUIDAndFileID.GetKnowledgebaseFileByKBUIDAndFileIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgebaseFileByKBUIDAndFileID.t.Fatal("No results are set for the RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmGetKnowledgebaseFileByKBUIDAndFileID.funcGetKnowledgebaseFileByKBUIDAndFileID != nil {
		return mmGetKnowledgebaseFileByKBUIDAndFileID.funcGetKnowledgebaseFileByKBUIDAndFileID(ctx, kbUID, fileID)
	}
	mmGetKnowledgebaseFileByKBUIDAndFileID.t.Fatalf("Unexpected call to RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID. %v %v %v", ctx, kbUID, fileID)
	return
}

// GetKnowledgebaseFileByKBUIDAndFileIDAfterCounter returns a count of finished RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID invocations
func (mmGetKnowledgebaseFileByKBUIDAndFileID *RepositoryMock) GetKnowledgebaseFileByKBUIDAndFileIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgebaseFileByKBUIDAndFileID.afterGetKnowledgebaseFileByKBUIDAndFileIDCounter)
}

// GetKnowledgebaseFileByKBUIDAndFileIDBeforeCounter returns a count of RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID invocations
func (mmGetKnowledgebaseFileByKBUIDAndFileID *RepositoryMock) GetKnowledgebaseFileByKBUIDAndFileIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgebaseFileByKBUIDAndFileID.beforeGetKnowledgebaseFileByKBUIDAndFileIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgebaseFileByKBUIDAndFileID *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID) Calls() []*RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParams {
	mmGetKnowledgebaseFileByKBUIDAndFileID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParams, len(mmGetKnowledgebaseFileByKBUIDAndFileID.callArgs))
	copy(argCopy, mmGetKnowledgebaseFileByKBUIDAndFileID.callArgs)

	mmGetKnowledgebaseFileByKBUIDAndFileID.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgebaseFileByKBUIDAndFileIDDone returns true if the count of the GetKnowledgebaseFileByKBUIDAndFileID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetKnowledgebaseFileByKBUIDAndFileIDDone() bool {
	if m.GetKnowledgebaseFileByKBUIDAndFileIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetKnowledgebaseFileByKBUIDAndFileIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgebaseFileByKBUIDAndFileIDMock.invocationsDone()
}

// MinimockGetKnowledgebaseFileByKBUIDAndFileIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetKnowledgebaseFileByKBUIDAndFileIDInspect() {
	for _, e := range m.GetKnowledgebaseFileByKBUIDAndFileIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetKnowledgebaseFileByKBUIDAndFileIDCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgebaseFileByKBUIDAndFileIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgebaseFileByKBUIDAndFileIDMock.defaultExpectation != nil && afterGetKnowledgebaseFileByKBUIDAndFileIDCounter < 1 {
		if m.GetKnowledgebaseFileByKBUIDAndFileIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID at\n%s", m.GetKnowledgebaseFileByKBUIDAndFileIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID at\n%s with params: %#v", m.GetKnowledgebaseFileByKBUIDAndFileIDMock.defaultExpectation.expectationOrigins.origin, *m.GetKnowledgebaseFileByKBUIDAndFileIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgebaseFileByKBUIDAndFileID != nil && afterGetKnowledgebaseFileByKBUIDAndFileIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID at\n%s", m.funcGetKnowledgebaseFileByKBUIDAndFileIDOrigin)
	}

	if !m.GetKnowledgebaseFileByKBUIDAndFileIDMock.invocationsDone() && afterGetKnowledgebaseFileByKBUIDAndFileIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgebaseFileByKBUIDAndFileIDMock.expectedInvocations), m.GetKnowledgebaseFileByKBUIDAndFileIDMock.expectedInvocationsOrigin, afterGetKnowledgebaseFileByKBUIDAndFileIDCounter)
	}
}

type mRepositoryMockGetMinIOStorage struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetMinIOStorageExpectation
	expectations       []*RepositoryMockGetMinIOStorageExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetMinIOStorageExpectation specifies expectation struct of the Repository.GetMinIOStorage
type RepositoryMockGetMinIOStorageExpectation struct {
	mock *RepositoryMock

	results      *RepositoryMockGetMinIOStorageResults
	returnOrigin string
	Counter      uint64
}

// RepositoryMockGetMinIOStorageResults contains results of the Repository.GetMinIOStorage
type RepositoryMockGetMinIOStorageResults struct {
	s1 object.Storage
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetMinIOStorage *mRepositoryMockGetMinIOStorage) Optional() *mRepositoryMockGetMinIOStorage {
	mmGetMinIOStorage.optional = true
	return mmGetMinIOStorage
}

// Expect sets up expected params for Repository.GetMinIOStorage
func (mmGetMinIOStorage *mRepositoryMockGetMinIOStorage) Expect() *mRepositoryMockGetMinIOStorage {
	if mmGetMinIOStorage.mock.funcGetMinIOStorage != nil {
		mmGetMinIOStorage.mock.t.Fatalf("RepositoryMock.GetMinIOStorage mock is already set by Set")
	}

	if mmGetMinIOStorage.defaultExpectation == nil {
		mmGetMinIOStorage.defaultExpectation = &RepositoryMockGetMinIOStorageExpectation{}
	}

	return mmGetMinIOStorage
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetMinIOStorage
func (mmGetMinIOStorage *mRepositoryMockGetMinIOStorage) Inspect(f func()) *mRepositoryMockGetMinIOStorage {
	if mmGetMinIOStorage.mock.inspectFuncGetMinIOStorage != nil {
		mmGetMinIOStorage.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetMinIOStorage")
	}

	mmGetMinIOStorage.mock.inspectFuncGetMinIOStorage = f

	return mmGetMinIOStorage
}

// Return sets up results that will be returned by Repository.GetMinIOStorage
func (mmGetMinIOStorage *mRepositoryMockGetMinIOStorage) Return(s1 object.Storage) *RepositoryMock {
	if mmGetMinIOStorage.mock.funcGetMinIOStorage != nil {
		mmGetMinIOStorage.mock.t.Fatalf("RepositoryMock.GetMinIOStorage mock is already set by Set")
	}

	if mmGetMinIOStorage.defaultExpectation == nil {
		mmGetMinIOStorage.defaultExpectation = &RepositoryMockGetMinIOStorageExpectation{mock: mmGetMinIOStorage.mock}
	}
	mmGetMinIOStorage.defaultExpectation.results = &RepositoryMockGetMinIOStorageResults{s1}
	mmGetMinIOStorage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetMinIOStorage.mock
}

// Set uses given function f to mock the Repository.GetMinIOStorage method
func (mmGetMinIOStorage *mRepositoryMockGetMinIOStorage) Set(f func() (s1 object.Storage)) *RepositoryMock {
	if mmGetMinIOStorage.defaultExpectation != nil {
		mmGetMinIOStorage.mock.t.Fatalf("Default expectation is already set for the Repository.GetMinIOStorage method")
	}

	if len(mmGetMinIOStorage.expectations) > 0 {
		mmGetMinIOStorage.mock.t.Fatalf("Some expectations are already set for the Repository.GetMinIOStorage method")
	}

	mmGetMinIOStorage.mock.funcGetMinIOStorage = f
	mmGetMinIOStorage.mock.funcGetMinIOStorageOrigin = minimock.CallerInfo(1)
	return mmGetMinIOStorage.mock
}

// Times sets number of times Repository.GetMinIOStorage should be invoked
func (mmGetMinIOStorage *mRepositoryMockGetMinIOStorage) Times(n uint64) *mRepositoryMockGetMinIOStorage {
	if n == 0 {
		mmGetMinIOStorage.mock.t.Fatalf("Times of RepositoryMock.GetMinIOStorage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetMinIOStorage.expectedInvocations, n)
	mmGetMinIOStorage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetMinIOStorage
}

func (mmGetMinIOStorage *mRepositoryMockGetMinIOStorage) invocationsDone() bool {
	if len(mmGetMinIOStorage.expectations) == 0 && mmGetMinIOStorage.defaultExpectation == nil && mmGetMinIOStorage.mock.funcGetMinIOStorage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetMinIOStorage.mock.afterGetMinIOStorageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetMinIOStorage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetMinIOStorage implements mm_repository.Repository
func (mmGetMinIOStorage *RepositoryMock) GetMinIOStorage() (s1 object.Storage) {
	mm_atomic.AddUint64(&mmGetMinIOStorage.beforeGetMinIOStorageCounter, 1)
	defer mm_atomic.AddUint64(&mmGetMinIOStorage.afterGetMinIOStorageCounter, 1)

	mmGetMinIOStorage.t.Helper()

	if mmGetMinIOStorage.inspectFuncGetMinIOStorage != nil {
		mmGetMinIOStorage.inspectFuncGetMinIOStorage()
	}

	if mmGetMinIOStorage.GetMinIOStorageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetMinIOStorage.GetMinIOStorageMock.defaultExpectation.Counter, 1)

		mm_results := mmGetMinIOStorage.GetMinIOStorageMock.defaultExpectation.results
		if mm_results == nil {
			mmGetMinIOStorage.t.Fatal("No results are set for the RepositoryMock.GetMinIOStorage")
		}
		return (*mm_results).s1
	}
	if mmGetMinIOStorage.funcGetMinIOStorage != nil {
		return mmGetMinIOStorage.funcGetMinIOStorage()
	}
	mmGetMinIOStorage.t.Fatalf("Unexpected call to RepositoryMock.GetMinIOStorage.")
	return
}

// GetMinIOStorageAfterCounter returns a count of finished RepositoryMock.GetMinIOStorage invocations
func (mmGetMinIOStorage *RepositoryMock) GetMinIOStorageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMinIOStorage.afterGetMinIOStorageCounter)
}

// GetMinIOStorageBeforeCounter returns a count of RepositoryMock.GetMinIOStorage invocations
func (mmGetMinIOStorage *RepositoryMock) GetMinIOStorageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMinIOStorage.beforeGetMinIOStorageCounter)
}

// MinimockGetMinIOStorageDone returns true if the count of the GetMinIOStorage invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetMinIOStorageDone() bool {
	if m.GetMinIOStorageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMinIOStorageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMinIOStorageMock.invocationsDone()
}

// MinimockGetMinIOStorageInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetMinIOStorageInspect() {
	for _, e := range m.GetMinIOStorageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryMock.GetMinIOStorage")
		}
	}

	afterGetMinIOStorageCounter := mm_atomic.LoadUint64(&m.afterGetMinIOStorageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMinIOStorageMock.defaultExpectation != nil && afterGetMinIOStorageCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetMinIOStorage at\n%s", m.GetMinIOStorageMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMinIOStorage != nil && afterGetMinIOStorageCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetMinIOStorage at\n%s", m.funcGetMinIOStorageOrigin)
	}

	if !m.GetMinIOStorageMock.invocationsDone() && afterGetMinIOStorageCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetMinIOStorage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMinIOStorageMock.expectedInvocations), m.GetMinIOStorageMock.expectedInvocationsOrigin, afterGetMinIOStorageCounter)
	}
}

type mRepositoryMockGetNotStartedFileCount struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetNotStartedFileCountExpectation
	expectations       []*RepositoryMockGetNotStartedFileCountExpectation

	callArgs []*RepositoryMockGetNotStartedFileCountParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetNotStartedFileCountExpectation specifies expectation struct of the Repository.GetNotStartedFileCount
type RepositoryMockGetNotStartedFileCountExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetNotStartedFileCountParams
	paramPtrs          *RepositoryMockGetNotStartedFileCountParamPtrs
	expectationOrigins RepositoryMockGetNotStartedFileCountExpectationOrigins
	results            *RepositoryMockGetNotStartedFileCountResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetNotStartedFileCountParams contains parameters of the Repository.GetNotStartedFileCount
type RepositoryMockGetNotStartedFileCountParams struct {
	ctx   context.Context
	kbUID types.KBUIDType
}

// RepositoryMockGetNotStartedFileCountParamPtrs contains pointers to parameters of the Repository.GetNotStartedFileCount
type RepositoryMockGetNotStartedFileCountParamPtrs struct {
	ctx   *context.Context
	kbUID *types.KBUIDType
}

// RepositoryMockGetNotStartedFileCountResults contains results of the Repository.GetNotStartedFileCount
type RepositoryMockGetNotStartedFileCountResults struct {
	i1  int64
	err error
}

// RepositoryMockGetNotStartedFileCountOrigins contains origins of expectations of the Repository.GetNotStartedFileCount
type RepositoryMockGetNotStartedFileCountExpectationOrigins struct {
	origin      string
	originCtx   string
	originKbUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetNotStartedFileCount *mRepositoryMockGetNotStartedFileCount) Optional() *mRepositoryMockGetNotStartedFileCount {
	mmGetNotStartedFileCount.optional = true
	return mmGetNotStartedFileCount
}

// Expect sets up expected params for Repository.GetNotStartedFileCount
func (mmGetNotStartedFileCount *mRepositoryMockGetNotStartedFileCount) Expect(ctx context.Context, kbUID types.KBUIDType) *mRepositoryMockGetNotStartedFileCount {
	if mmGetNotStartedFileCount.mock.funcGetNotStartedFileCount != nil {
		mmGetNotStartedFileCount.mock.t.Fatalf("RepositoryMock.GetNotStartedFileCount mock is already set by Set")
	}

	if mmGetNotStartedFileCount.defaultExpectation == nil {
		mmGetNotStartedFileCount.defaultExpectation = &RepositoryMockGetNotStartedFileCountExpectation{}
	}

	if mmGetNotStartedFileCount.defaultExpectation.paramPtrs != nil {
		mmGetNotStartedFileCount.mock.t.Fatalf("RepositoryMock.GetNotStartedFileCount mock is already set by ExpectParams functions")
	}

	mmGetNotStartedFileCount.defaultExpectation.params = &RepositoryMockGetNotStartedFileCountParams{ctx, kbUID}
	mmGetNotStartedFileCount.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetNotStartedFileCount.expectations {
		if minimock.Equal(e.params, mmGetNotStartedFileCount.defaultExpectation.params) {
			mmGetNotStartedFileCount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetNotStartedFileCount.defaultExpectation.params)
		}
	}

	return mmGetNotStartedFileCount
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetNotStartedFileCount
func (mmGetNotStartedFileCount *mRepositoryMockGetNotStartedFileCount) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetNotStartedFileCount {
	if mmGetNotStartedFileCount.mock.funcGetNotStartedFileCount != nil {
		mmGetNotStartedFileCount.mock.t.Fatalf("RepositoryMock.GetNotStartedFileCount mock is already set by Set")
	}

	if mmGetNotStartedFileCount.defaultExpectation == nil {
		mmGetNotStartedFileCount.defaultExpectation = &RepositoryMockGetNotStartedFileCountExpectation{}
	}

	if mmGetNotStartedFileCount.defaultExpectation.params != nil {
		mmGetNotStartedFileCount.mock.t.Fatalf("RepositoryMock.GetNotStartedFileCount mock is already set by Expect")
	}

	if mmGetNotStartedFileCount.defaultExpectation.paramPtrs == nil {
		mmGetNotStartedFileCount.defaultExpectation.paramPtrs = &RepositoryMockGetNotStartedFileCountParamPtrs{}
	}
	mmGetNotStartedFileCount.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetNotStartedFileCount.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetNotStartedFileCount
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.GetNotStartedFileCount
func (mmGetNotStartedFileCount *mRepositoryMockGetNotStartedFileCount) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockGetNotStartedFileCount {
	if mmGetNotStartedFileCount.mock.funcGetNotStartedFileCount != nil {
		mmGetNotStartedFileCount.mock.t.Fatalf("RepositoryMock.GetNotStartedFileCount mock is already set by Set")
	}

	if mmGetNotStartedFileCount.defaultExpectation == nil {
		mmGetNotStartedFileCount.defaultExpectation = &RepositoryMockGetNotStartedFileCountExpectation{}
	}

	if mmGetNotStartedFileCount.defaultExpectation.params != nil {
		mmGetNotStartedFileCount.mock.t.Fatalf("RepositoryMock.GetNotStartedFileCount mock is already set by Expect")
	}

	if mmGetNotStartedFileCount.defaultExpectation.paramPtrs == nil {
		mmGetNotStartedFileCount.defaultExpectation.paramPtrs = &RepositoryMockGetNotStartedFileCountParamPtrs{}
	}
	mmGetNotStartedFileCount.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmGetNotStartedFileCount.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmGetNotStartedFileCount
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetNotStartedFileCount
func (mmGetNotStartedFileCount *mRepositoryMockGetNotStartedFileCount) Inspect(f func(ctx context.Context, kbUID types.KBUIDType)) *mRepositoryMockGetNotStartedFileCount {
	if mmGetNotStartedFileCount.mock.inspectFuncGetNotStartedFileCount != nil {
		mmGetNotStartedFileCount.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetNotStartedFileCount")
	}

	mmGetNotStartedFileCount.mock.inspectFuncGetNotStartedFileCount = f

	return mmGetNotStartedFileCount
}

// Return sets up results that will be returned by Repository.GetNotStartedFileCount
func (mmGetNotStartedFileCount *mRepositoryMockGetNotStartedFileCount) Return(i1 int64, err error) *RepositoryMock {
	if mmGetNotStartedFileCount.mock.funcGetNotStartedFileCount != nil {
		mmGetNotStartedFileCount.mock.t.Fatalf("RepositoryMock.GetNotStartedFileCount mock is already set by Set")
	}

	if mmGetNotStartedFileCount.defaultExpectation == nil {
		mmGetNotStartedFileCount.defaultExpectation = &RepositoryMockGetNotStartedFileCountExpectation{mock: mmGetNotStartedFileCount.mock}
	}
	mmGetNotStartedFileCount.defaultExpectation.results = &RepositoryMockGetNotStartedFileCountResults{i1, err}
	mmGetNotStartedFileCount.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetNotStartedFileCount.mock
}

// Set uses given function f to mock the Repository.GetNotStartedFileCount method
func (mmGetNotStartedFileCount *mRepositoryMockGetNotStartedFileCount) Set(f func(ctx context.Context, kbUID types.KBUIDType) (i1 int64, err error)) *RepositoryMock {
	if mmGetNotStartedFileCount.defaultExpectation != nil {
		mmGetNotStartedFileCount.mock.t.Fatalf("Default expectation is already set for the Repository.GetNotStartedFileCount method")
	}

	if len(mmGetNotStartedFileCount.expectations) > 0 {
		mmGetNotStartedFileCount.mock.t.Fatalf("Some expectations are already set for the Repository.GetNotStartedFileCount method")
	}

	mmGetNotStartedFileCount.mock.funcGetNotStartedFileCount = f
	mmGetNotStartedFileCount.mock.funcGetNotStartedFileCountOrigin = minimock.CallerInfo(1)
	return mmGetNotStartedFileCount.mock
}

// When sets expectation for the Repository.GetNotStartedFileCount which will trigger the result defined by the following
// Then helper
func (mmGetNotStartedFileCount *mRepositoryMockGetNotStartedFileCount) When(ctx context.Context, kbUID types.KBUIDType) *RepositoryMockGetNotStartedFileCountExpectation {
	if mmGetNotStartedFileCount.mock.funcGetNotStartedFileCount != nil {
		mmGetNotStartedFileCount.mock.t.Fatalf("RepositoryMock.GetNotStartedFileCount mock is already set by Set")
	}

	expectation := &RepositoryMockGetNotStartedFileCountExpectation{
		mock:               mmGetNotStartedFileCount.mock,
		params:             &RepositoryMockGetNotStartedFileCountParams{ctx, kbUID},
		expectationOrigins: RepositoryMockGetNotStartedFileCountExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetNotStartedFileCount.expectations = append(mmGetNotStartedFileCount.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetNotStartedFileCount return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetNotStartedFileCountExpectation) Then(i1 int64, err error) *RepositoryMock {
	e.results = &RepositoryMockGetNotStartedFileCountResults{i1, err}
	return e.mock
}

// Times sets number of times Repository.GetNotStartedFileCount should be invoked
func (mmGetNotStartedFileCount *mRepositoryMockGetNotStartedFileCount) Times(n uint64) *mRepositoryMockGetNotStartedFileCount {
	if n == 0 {
		mmGetNotStartedFileCount.mock.t.Fatalf("Times of RepositoryMock.GetNotStartedFileCount mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetNotStartedFileCount.expectedInvocations, n)
	mmGetNotStartedFileCount.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetNotStartedFileCount
}

func (mmGetNotStartedFileCount *mRepositoryMockGetNotStartedFileCount) invocationsDone() bool {
	if len(mmGetNotStartedFileCount.expectations) == 0 && mmGetNotStartedFileCount.defaultExpectation == nil && mmGetNotStartedFileCount.mock.funcGetNotStartedFileCount == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetNotStartedFileCount.mock.afterGetNotStartedFileCountCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetNotStartedFileCount.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetNotStartedFileCount implements mm_repository.Repository
func (mmGetNotStartedFileCount *RepositoryMock) GetNotStartedFileCount(ctx context.Context, kbUID types.KBUIDType) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetNotStartedFileCount.beforeGetNotStartedFileCountCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNotStartedFileCount.afterGetNotStartedFileCountCounter, 1)

	mmGetNotStartedFileCount.t.Helper()

	if mmGetNotStartedFileCount.inspectFuncGetNotStartedFileCount != nil {
		mmGetNotStartedFileCount.inspectFuncGetNotStartedFileCount(ctx, kbUID)
	}

	mm_params := RepositoryMockGetNotStartedFileCountParams{ctx, kbUID}

	// Record call args
	mmGetNotStartedFileCount.GetNotStartedFileCountMock.mutex.Lock()
	mmGetNotStartedFileCount.GetNotStartedFileCountMock.callArgs = append(mmGetNotStartedFileCount.GetNotStartedFileCountMock.callArgs, &mm_params)
	mmGetNotStartedFileCount.GetNotStartedFileCountMock.mutex.Unlock()

	for _, e := range mmGetNotStartedFileCount.GetNotStartedFileCountMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetNotStartedFileCount.GetNotStartedFileCountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNotStartedFileCount.GetNotStartedFileCountMock.defaultExpectation.Counter, 1)
		mm_want := mmGetNotStartedFileCount.GetNotStartedFileCountMock.defaultExpectation.params
		mm_want_ptrs := mmGetNotStartedFileCount.GetNotStartedFileCountMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetNotStartedFileCountParams{ctx, kbUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetNotStartedFileCount.t.Errorf("RepositoryMock.GetNotStartedFileCount got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNotStartedFileCount.GetNotStartedFileCountMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmGetNotStartedFileCount.t.Errorf("RepositoryMock.GetNotStartedFileCount got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNotStartedFileCount.GetNotStartedFileCountMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetNotStartedFileCount.t.Errorf("RepositoryMock.GetNotStartedFileCount got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetNotStartedFileCount.GetNotStartedFileCountMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetNotStartedFileCount.GetNotStartedFileCountMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNotStartedFileCount.t.Fatal("No results are set for the RepositoryMock.GetNotStartedFileCount")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetNotStartedFileCount.funcGetNotStartedFileCount != nil {
		return mmGetNotStartedFileCount.funcGetNotStartedFileCount(ctx, kbUID)
	}
	mmGetNotStartedFileCount.t.Fatalf("Unexpected call to RepositoryMock.GetNotStartedFileCount. %v %v", ctx, kbUID)
	return
}

// GetNotStartedFileCountAfterCounter returns a count of finished RepositoryMock.GetNotStartedFileCount invocations
func (mmGetNotStartedFileCount *RepositoryMock) GetNotStartedFileCountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNotStartedFileCount.afterGetNotStartedFileCountCounter)
}

// GetNotStartedFileCountBeforeCounter returns a count of RepositoryMock.GetNotStartedFileCount invocations
func (mmGetNotStartedFileCount *RepositoryMock) GetNotStartedFileCountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNotStartedFileCount.beforeGetNotStartedFileCountCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetNotStartedFileCount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetNotStartedFileCount *mRepositoryMockGetNotStartedFileCount) Calls() []*RepositoryMockGetNotStartedFileCountParams {
	mmGetNotStartedFileCount.mutex.RLock()

	argCopy := make([]*RepositoryMockGetNotStartedFileCountParams, len(mmGetNotStartedFileCount.callArgs))
	copy(argCopy, mmGetNotStartedFileCount.callArgs)

	mmGetNotStartedFileCount.mutex.RUnlock()

	return argCopy
}

// MinimockGetNotStartedFileCountDone returns true if the count of the GetNotStartedFileCount invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetNotStartedFileCountDone() bool {
	if m.GetNotStartedFileCountMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetNotStartedFileCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetNotStartedFileCountMock.invocationsDone()
}

// MinimockGetNotStartedFileCountInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetNotStartedFileCountInspect() {
	for _, e := range m.GetNotStartedFileCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetNotStartedFileCount at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetNotStartedFileCountCounter := mm_atomic.LoadUint64(&m.afterGetNotStartedFileCountCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetNotStartedFileCountMock.defaultExpectation != nil && afterGetNotStartedFileCountCounter < 1 {
		if m.GetNotStartedFileCountMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetNotStartedFileCount at\n%s", m.GetNotStartedFileCountMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetNotStartedFileCount at\n%s with params: %#v", m.GetNotStartedFileCountMock.defaultExpectation.expectationOrigins.origin, *m.GetNotStartedFileCountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNotStartedFileCount != nil && afterGetNotStartedFileCountCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetNotStartedFileCount at\n%s", m.funcGetNotStartedFileCountOrigin)
	}

	if !m.GetNotStartedFileCountMock.invocationsDone() && afterGetNotStartedFileCountCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetNotStartedFileCount at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetNotStartedFileCountMock.expectedInvocations), m.GetNotStartedFileCountMock.expectedInvocationsOrigin, afterGetNotStartedFileCountCounter)
	}
}

type mRepositoryMockGetNotStartedFileCountExcluding struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetNotStartedFileCountExcludingExpectation
	expectations       []*RepositoryMockGetNotStartedFileCountExcludingExpectation

	callArgs []*RepositoryMockGetNotStartedFileCountExcludingParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetNotStartedFileCountExcludingExpectation specifies expectation struct of the Repository.GetNotStartedFileCountExcluding
type RepositoryMockGetNotStartedFileCountExcludingExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetNotStartedFileCountExcludingParams
	paramPtrs          *RepositoryMockGetNotStartedFileCountExcludingParamPtrs
	expectationOrigins RepositoryMockGetNotStartedFileCountExcludingExpectationOrigins
	results            *RepositoryMockGetNotStartedFileCountExcludingResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetNotStartedFileCountExcludingParams contains parameters of the Repository.GetNotStartedFileCountExcluding
type RepositoryMockGetNotStartedFileCountExcludingParams struct {
	ctx         context.Context
	kbUID       types.KBUIDType
	excludeUIDs []types.FileUIDType
}

// RepositoryMockGetNotStartedFileCountExcludingParamPtrs contains pointers to parameters of the Repository.GetNotStartedFileCountExcluding
type RepositoryMockGetNotStartedFileCountExcludingParamPtrs struct {
	ctx         *context.Context
	kbUID       *types.KBUIDType
	excludeUIDs *[]types.FileUIDType
}

// RepositoryMockGetNotStartedFileCountExcludingResults contains results of the Repository.GetNotStartedFileCountExcluding
type RepositoryMockGetNotStartedFileCountExcludingResults struct {
	i1  int64
	err error
}

// RepositoryMockGetNotStartedFileCountExcludingOrigins contains origins of expectations of the Repository.GetNotStartedFileCountExcluding
type RepositoryMockGetNotStartedFileCountExcludingExpectationOrigins struct {
	origin            string
	originCtx         string
	originKbUID       string
	originExcludeUIDs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetNotStartedFileCountExcluding *mRepositoryMockGetNotStartedFileCountExcluding) Optional() *mRepositoryMockGetNotStartedFileCountExcluding {
	mmGetNotStartedFileCountExcluding.optional = true
	return mmGetNotStartedFileCountExcluding
}

// Expect sets up expected params for Repository.GetNotStartedFileCountExcluding
func (mmGetNotStartedFileCountExcluding *mRepositoryMockGetNotStartedFileCountExcluding) Expect(ctx context.Context, kbUID types.KBUIDType, excludeUIDs []types.FileUIDType) *mRepositoryMockGetNotStartedFileCountExcluding {
	if mmGetNotStartedFileCountExcluding.mock.funcGetNotStartedFileCountExcluding != nil {
		mmGetNotStartedFileCountExcluding.mock.t.Fatalf("RepositoryMock.GetNotStartedFileCountExcluding mock is already set by Set")
	}

	if mmGetNotStartedFileCountExcluding.defaultExpectation == nil {
		mmGetNotStartedFileCountExcluding.defaultExpectation = &RepositoryMockGetNotStartedFileCountExcludingExpectation{}
	}

	if mmGetNotStartedFileCountExcluding.defaultExpectation.paramPtrs != nil {
		mmGetNotStartedFileCountExcluding.mock.t.Fatalf("RepositoryMock.GetNotStartedFileCountExcluding mock is already set by ExpectParams functions")
	}

	mmGetNotStartedFileCountExcluding.defaultExpectation.params = &RepositoryMockGetNotStartedFileCountExcludingParams{ctx, kbUID, excludeUIDs}
	mmGetNotStartedFileCountExcluding.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetNotStartedFileCountExcluding.expectations {
		if minimock.Equal(e.params, mmGetNotStartedFileCountExcluding.defaultExpectation.params) {
			mmGetNotStartedFileCountExcluding.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetNotStartedFileCountExcluding.defaultExpectation.params)
		}
	}

	return mmGetNotStartedFileCountExcluding
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetNotStartedFileCountExcluding
func (mmGetNotStartedFileCountExcluding *mRepositoryMockGetNotStartedFileCountExcluding) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetNotStartedFileCountExcluding {
	if mmGetNotStartedFileCountExcluding.mock.funcGetNotStartedFileCountExcluding != nil {
		mmGetNotStartedFileCountExcluding.mock.t.Fatalf("RepositoryMock.GetNotStartedFileCountExcluding mock is already set by Set")
	}

	if mmGetNotStartedFileCountExcluding.defaultExpectation == nil {
		mmGetNotStartedFileCountExcluding.defaultExpectation = &RepositoryMockGetNotStartedFileCountExcludingExpectation{}
	}

	if mmGetNotStartedFileCountExcluding.defaultExpectation.params != nil {
		mmGetNotStartedFileCountExcluding.mock.t.Fatalf("RepositoryMock.GetNotStartedFileCountExcluding mock is already set by Expect")
	}

	if mmGetNotStartedFileCountExcluding.defaultExpectation.paramPtrs == nil {
		mmGetNotStartedFileCountExcluding.defaultExpectation.paramPtrs = &RepositoryMockGetNotStartedFileCountExcludingParamPtrs{}
	}
	mmGetNotStartedFileCountExcluding.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetNotStartedFileCountExcluding.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetNotStartedFileCountExcluding
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.GetNotStartedFileCountExcluding
func (mmGetNotStartedFileCountExcluding *mRepositoryMockGetNotStartedFileCountExcluding) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockGetNotStartedFileCountExcluding {
	if mmGetNotStartedFileCountExcluding.mock.funcGetNotStartedFileCountExcluding != nil {
		mmGetNotStartedFileCountExcluding.mock.t.Fatalf("RepositoryMock.GetNotStartedFileCountExcluding mock is already set by Set")
	}

	if mmGetNotStartedFileCountExcluding.defaultExpectation == nil {
		mmGetNotStartedFileCountExcluding.defaultExpectation = &RepositoryMockGetNotStartedFileCountExcludingExpectation{}
	}

	if mmGetNotStartedFileCountExcluding.defaultExpectation.params != nil {
		mmGetNotStartedFileCountExcluding.mock.t.Fatalf("RepositoryMock.GetNotStartedFileCountExcluding mock is already set by Expect")
	}

	if mmGetNotStartedFileCountExcluding.defaultExpectation.paramPtrs == nil {
		mmGetNotStartedFileCountExcluding.defaultExpectation.paramPtrs = &RepositoryMockGetNotStartedFileCountExcludingParamPtrs{}
	}
	mmGetNotStartedFileCountExcluding.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmGetNotStartedFileCountExcluding.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmGetNotStartedFileCountExcluding
}

// ExpectExcludeUIDsParam3 sets up expected param excludeUIDs for Repository.GetNotStartedFileCountExcluding
func (mmGetNotStartedFileCountExcluding *mRepositoryMockGetNotStartedFileCountExcluding) ExpectExcludeUIDsParam3(excludeUIDs []types.FileUIDType) *mRepositoryMockGetNotStartedFileCountExcluding {
	if mmGetNotStartedFileCountExcluding.mock.funcGetNotStartedFileCountExcluding != nil {
		mmGetNotStartedFileCountExcluding.mock.t.Fatalf("RepositoryMock.GetNotStartedFileCountExcluding mock is already set by Set")
	}

	if mmGetNotStartedFileCountExcluding.defaultExpectation == nil {
		mmGetNotStartedFileCountExcluding.defaultExpectation = &RepositoryMockGetNotStartedFileCountExcludingExpectation{}
	}

	if mmGetNotStartedFileCountExcluding.defaultExpectation.params != nil {
		mmGetNotStartedFileCountExcluding.mock.t.Fatalf("RepositoryMock.GetNotStartedFileCountExcluding mock is already set by Expect")
	}

	if mmGetNotStartedFileCountExcluding.defaultExpectation.paramPtrs == nil {
		mmGetNotStartedFileCountExcluding.defaultExpectation.paramPtrs = &RepositoryMockGetNotStartedFileCountExcludingParamPtrs{}
	}
	mmGetNotStartedFileCountExcluding.defaultExpectation.paramPtrs.excludeUIDs = &excludeUIDs
	mmGetNotStartedFileCountExcluding.defaultExpectation.expectationOrigins.originExcludeUIDs = minimock.CallerInfo(1)

	return mmGetNotStartedFileCountExcluding
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetNotStartedFileCountExcluding
func (mmGetNotStartedFileCountExcluding *mRepositoryMockGetNotStartedFileCountExcluding) Inspect(f func(ctx context.Context, kbUID types.KBUIDType, excludeUIDs []types.FileUIDType)) *mRepositoryMockGetNotStartedFileCountExcluding {
	if mmGetNotStartedFileCountExcluding.mock.inspectFuncGetNotStartedFileCountExcluding != nil {
		mmGetNotStartedFileCountExcluding.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetNotStartedFileCountExcluding")
	}

	mmGetNotStartedFileCountExcluding.mock.inspectFuncGetNotStartedFileCountExcluding = f

	return mmGetNotStartedFileCountExcluding
}

// Return sets up results that will be returned by Repository.GetNotStartedFileCountExcluding
func (mmGetNotStartedFileCountExcluding *mRepositoryMockGetNotStartedFileCountExcluding) Return(i1 int64, err error) *RepositoryMock {
	if mmGetNotStartedFileCountExcluding.mock.funcGetNotStartedFileCountExcluding != nil {
		mmGetNotStartedFileCountExcluding.mock.t.Fatalf("RepositoryMock.GetNotStartedFileCountExcluding mock is already set by Set")
	}

	if mmGetNotStartedFileCountExcluding.defaultExpectation == nil {
		mmGetNotStartedFileCountExcluding.defaultExpectation = &RepositoryMockGetNotStartedFileCountExcludingExpectation{mock: mmGetNotStartedFileCountExcluding.mock}
	}
	mmGetNotStartedFileCountExcluding.defaultExpectation.results = &RepositoryMockGetNotStartedFileCountExcludingResults{i1, err}
	mmGetNotStartedFileCountExcluding.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetNotStartedFileCountExcluding.mock
}

// Set uses given function f to mock the Repository.GetNotStartedFileCountExcluding method
func (mmGetNotStartedFileCountExcluding *mRepositoryMockGetNotStartedFileCountExcluding) Set(f func(ctx context.Context, kbUID types.KBUIDType, excludeUIDs []types.FileUIDType) (i1 int64, err error)) *RepositoryMock {
	if mmGetNotStartedFileCountExcluding.defaultExpectation != nil {
		mmGetNotStartedFileCountExcluding.mock.t.Fatalf("Default expectation is already set for the Repository.GetNotStartedFileCountExcluding method")
	}

	if len(mmGetNotStartedFileCountExcluding.expectations) > 0 {
		mmGetNotStartedFileCountExcluding.mock.t.Fatalf("Some expectations are already set for the Repository.GetNotStartedFileCountExcluding method")
	}

	mmGetNotStartedFileCountExcluding.mock.funcGetNotStartedFileCountExcluding = f
	mmGetNotStartedFileCountExcluding.mock.funcGetNotStartedFileCountExcludingOrigin = minimock.CallerInfo(1)
	return mmGetNotStartedFileCountExcluding.mock
}

// When sets expectation for the Repository.GetNotStartedFileCountExcluding which will trigger the result defined by the following
// Then helper
func (mmGetNotStartedFileCountExcluding *mRepositoryMockGetNotStartedFileCountExcluding) When(ctx context.Context, kbUID types.KBUIDType, excludeUIDs []types.FileUIDType) *RepositoryMockGetNotStartedFileCountExcludingExpectation {
	if mmGetNotStartedFileCountExcluding.mock.funcGetNotStartedFileCountExcluding != nil {
		mmGetNotStartedFileCountExcluding.mock.t.Fatalf("RepositoryMock.GetNotStartedFileCountExcluding mock is already set by Set")
	}

	expectation := &RepositoryMockGetNotStartedFileCountExcludingExpectation{
		mock:               mmGetNotStartedFileCountExcluding.mock,
		params:             &RepositoryMockGetNotStartedFileCountExcludingParams{ctx, kbUID, excludeUIDs},
		expectationOrigins: RepositoryMockGetNotStartedFileCountExcludingExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetNotStartedFileCountExcluding.expectations = append(mmGetNotStartedFileCountExcluding.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetNotStartedFileCountExcluding return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetNotStartedFileCountExcludingExpectation) Then(i1 int64, err error) *RepositoryMock {
	e.results = &RepositoryMockGetNotStartedFileCountExcludingResults{i1, err}
	return e.mock
}

// Times sets number of times Repository.GetNotStartedFileCountExcluding should be invoked
func (mmGetNotStartedFileCountExcluding *mRepositoryMockGetNotStartedFileCountExcluding) Times(n uint64) *mRepositoryMockGetNotStartedFileCountExcluding {
	if n == 0 {
		mmGetNotStartedFileCountExcluding.mock.t.Fatalf("Times of RepositoryMock.GetNotStartedFileCountExcluding mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetNotStartedFileCountExcluding.expectedInvocations, n)
	mmGetNotStartedFileCountExcluding.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetNotStartedFileCountExcluding
}

func (mmGetNotStartedFileCountExcluding *mRepositoryMockGetNotStartedFileCountExcluding) invocationsDone() bool {
	if len(mmGetNotStartedFileCountExcluding.expectations) == 0 && mmGetNotStartedFileCountExcluding.defaultExpectation == nil && mmGetNotStartedFileCountExcluding.mock.funcGetNotStartedFileCountExcluding == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetNotStartedFileCountExcluding.mock.afterGetNotStartedFileCountExcludingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetNotStartedFileCountExcluding.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetNotStartedFileCountExcluding implements mm_repository.Repository
func (mmGetNotStartedFileCountExcluding *RepositoryMock) GetNotStartedFileCountExcluding(ctx context.Context, kbUID types.KBUIDType, excludeUIDs []types.FileUIDType) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetNotStartedFileCountExcluding.beforeGetNotStartedFileCountExcludingCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNotStartedFileCountExcluding.afterGetNotStartedFileCountExcludingCounter, 1)

	mmGetNotStartedFileCountExcluding.t.Helper()

	if mmGetNotStartedFileCountExcluding.inspectFuncGetNotStartedFileCountExcluding != nil {
		mmGetNotStartedFileCountExcluding.inspectFuncGetNotStartedFileCountExcluding(ctx, kbUID, excludeUIDs)
	}

	mm_params := RepositoryMockGetNotStartedFileCountExcludingParams{ctx, kbUID, excludeUIDs}

	// Record call args
	mmGetNotStartedFileCountExcluding.GetNotStartedFileCountExcludingMock.mutex.Lock()
	mmGetNotStartedFileCountExcluding.GetNotStartedFileCountExcludingMock.callArgs = append(mmGetNotStartedFileCountExcluding.GetNotStartedFileCountExcludingMock.callArgs, &mm_params)
	mmGetNotStartedFileCountExcluding.GetNotStartedFileCountExcludingMock.mutex.Unlock()

	for _, e := range mmGetNotStartedFileCountExcluding.GetNotStartedFileCountExcludingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetNotStartedFileCountExcluding.GetNotStartedFileCountExcludingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNotStartedFileCountExcluding.GetNotStartedFileCountExcludingMock.defaultExpectation.Counter, 1)
		mm_want := mmGetNotStartedFileCountExcluding.GetNotStartedFileCountExcludingMock.defaultExpectation.params
		mm_want_ptrs := mmGetNotStartedFileCountExcluding.GetNotStartedFileCountExcludingMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetNotStartedFileCountExcludingParams{ctx, kbUID, excludeUIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetNotStartedFileCountExcluding.t.Errorf("RepositoryMock.GetNotStartedFileCountExcluding got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNotStartedFileCountExcluding.GetNotStartedFileCountExcludingMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmGetNotStartedFileCountExcluding.t.Errorf("RepositoryMock.GetNotStartedFileCountExcluding got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNotStartedFileCountExcluding.GetNotStartedFileCountExcludingMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.excludeUIDs != nil && !minimock.Equal(*mm_want_ptrs.excludeUIDs, mm_got.excludeUIDs) {
				mmGetNotStartedFileCountExcluding.t.Errorf("RepositoryMock.GetNotStartedFileCountExcluding got unexpected parameter excludeUIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNotStartedFileCountExcluding.GetNotStartedFileCountExcludingMock.defaultExpectation.expectationOrigins.originExcludeUIDs, *mm_want_ptrs.excludeUIDs, mm_got.excludeUIDs, minimock.Diff(*mm_want_ptrs.excludeUIDs, mm_got.excludeUIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetNotStartedFileCountExcluding.t.Errorf("RepositoryMock.GetNotStartedFileCountExcluding got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetNotStartedFileCountExcluding.GetNotStartedFileCountExcludingMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetNotStartedFileCountExcluding.GetNotStartedFileCountExcludingMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNotStartedFileCountExcluding.t.Fatal("No results are set for the RepositoryMock.GetNotStartedFileCountExcluding")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetNotStartedFileCountExcluding.funcGetNotStartedFileCountExcluding != nil {
		return mmGetNotStartedFileCountExcluding.funcGetNotStartedFileCountExcluding(ctx, kbUID, excludeUIDs)
	}
	mmGetNotStartedFileCountExcluding.t.Fatalf("Unexpected call to RepositoryMock.GetNotStartedFileCountExcluding. %v %v %v", ctx, kbUID, excludeUIDs)
	return
}

// GetNotStartedFileCountExcludingAfterCounter returns a count of finished RepositoryMock.GetNotStartedFileCountExcluding invocations
func (mmGetNotStartedFileCountExcluding *RepositoryMock) GetNotStartedFileCountExcludingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNotStartedFileCountExcluding.afterGetNotStartedFileCountExcludingCounter)
}

// GetNotStartedFileCountExcludingBeforeCounter returns a count of RepositoryMock.GetNotStartedFileCountExcluding invocations
func (mmGetNotStartedFileCountExcluding *RepositoryMock) GetNotStartedFileCountExcludingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNotStartedFileCountExcluding.beforeGetNotStartedFileCountExcludingCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetNotStartedFileCountExcluding.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetNotStartedFileCountExcluding *mRepositoryMockGetNotStartedFileCountExcluding) Calls() []*RepositoryMockGetNotStartedFileCountExcludingParams {
	mmGetNotStartedFileCountExcluding.mutex.RLock()

	argCopy := make([]*RepositoryMockGetNotStartedFileCountExcludingParams, len(mmGetNotStartedFileCountExcluding.callArgs))
	copy(argCopy, mmGetNotStartedFileCountExcluding.callArgs)

	mmGetNotStartedFileCountExcluding.mutex.RUnlock()

	return argCopy
}

// MinimockGetNotStartedFileCountExcludingDone returns true if the count of the GetNotStartedFileCountExcluding invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetNotStartedFileCountExcludingDone() bool {
	if m.GetNotStartedFileCountExcludingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetNotStartedFileCountExcludingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetNotStartedFileCountExcludingMock.invocationsDone()
}

// MinimockGetNotStartedFileCountExcludingInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetNotStartedFileCountExcludingInspect() {
	for _, e := range m.GetNotStartedFileCountExcludingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetNotStartedFileCountExcluding at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetNotStartedFileCountExcludingCounter := mm_atomic.LoadUint64(&m.afterGetNotStartedFileCountExcludingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetNotStartedFileCountExcludingMock.defaultExpectation != nil && afterGetNotStartedFileCountExcludingCounter < 1 {
		if m.GetNotStartedFileCountExcludingMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetNotStartedFileCountExcluding at\n%s", m.GetNotStartedFileCountExcludingMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetNotStartedFileCountExcluding at\n%s with params: %#v", m.GetNotStartedFileCountExcludingMock.defaultExpectation.expectationOrigins.origin, *m.GetNotStartedFileCountExcludingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNotStartedFileCountExcluding != nil && afterGetNotStartedFileCountExcludingCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetNotStartedFileCountExcluding at\n%s", m.funcGetNotStartedFileCountExcludingOrigin)
	}

	if !m.GetNotStartedFileCountExcludingMock.invocationsDone() && afterGetNotStartedFileCountExcludingCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetNotStartedFileCountExcluding at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetNotStartedFileCountExcludingMock.expectedInvocations), m.GetNotStartedFileCountExcludingMock.expectedInvocationsOrigin, afterGetNotStartedFileCountExcludingCounter)
	}
}

type mRepositoryMockGetObjectByUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetObjectByUIDExpectation
	expectations       []*RepositoryMockGetObjectByUIDExpectation

	callArgs []*RepositoryMockGetObjectByUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetObjectByUIDExpectation specifies expectation struct of the Repository.GetObjectByUID
type RepositoryMockGetObjectByUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetObjectByUIDParams
	paramPtrs          *RepositoryMockGetObjectByUIDParamPtrs
	expectationOrigins RepositoryMockGetObjectByUIDExpectationOrigins
	results            *RepositoryMockGetObjectByUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetObjectByUIDParams contains parameters of the Repository.GetObjectByUID
type RepositoryMockGetObjectByUIDParams struct {
	ctx context.Context
	uid types.ObjectUIDType
}

// RepositoryMockGetObjectByUIDParamPtrs contains pointers to parameters of the Repository.GetObjectByUID
type RepositoryMockGetObjectByUIDParamPtrs struct {
	ctx *context.Context
	uid *types.ObjectUIDType
}

// RepositoryMockGetObjectByUIDResults contains results of the Repository.GetObjectByUID
type RepositoryMockGetObjectByUIDResults struct {
	op1 *mm_repository.ObjectModel
	err error
}

// RepositoryMockGetObjectByUIDOrigins contains origins of expectations of the Repository.GetObjectByUID
type RepositoryMockGetObjectByUIDExpectationOrigins struct {
	origin    string
	originCtx string
	originUid string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetObjectByUID *mRepositoryMockGetObjectByUID) Optional() *mRepositoryMockGetObjectByUID {
	mmGetObjectByUID.optional = true
	return mmGetObjectByUID
}

// Expect sets up expected params for Repository.GetObjectByUID
func (mmGetObjectByUID *mRepositoryMockGetObjectByUID) Expect(ctx context.Context, uid types.ObjectUIDType) *mRepositoryMockGetObjectByUID {
	if mmGetObjectByUID.mock.funcGetObjectByUID != nil {
		mmGetObjectByUID.mock.t.Fatalf("RepositoryMock.GetObjectByUID mock is already set by Set")
	}

	if mmGetObjectByUID.defaultExpectation == nil {
		mmGetObjectByUID.defaultExpectation = &RepositoryMockGetObjectByUIDExpectation{}
	}

	if mmGetObjectByUID.defaultExpectation.paramPtrs != nil {
		mmGetObjectByUID.mock.t.Fatalf("RepositoryMock.GetObjectByUID mock is already set by ExpectParams functions")
	}

	mmGetObjectByUID.defaultExpectation.params = &RepositoryMockGetObjectByUIDParams{ctx, uid}
	mmGetObjectByUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetObjectByUID.expectations {
		if minimock.Equal(e.params, mmGetObjectByUID.defaultExpectation.params) {
			mmGetObjectByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetObjectByUID.defaultExpectation.params)
		}
	}

	return mmGetObjectByUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetObjectByUID
func (mmGetObjectByUID *mRepositoryMockGetObjectByUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetObjectByUID {
	if mmGetObjectByUID.mock.funcGetObjectByUID != nil {
		mmGetObjectByUID.mock.t.Fatalf("RepositoryMock.GetObjectByUID mock is already set by Set")
	}

	if mmGetObjectByUID.defaultExpectation == nil {
		mmGetObjectByUID.defaultExpectation = &RepositoryMockGetObjectByUIDExpectation{}
	}

	if mmGetObjectByUID.defaultExpectation.params != nil {
		mmGetObjectByUID.mock.t.Fatalf("RepositoryMock.GetObjectByUID mock is already set by Expect")
	}

	if mmGetObjectByUID.defaultExpectation.paramPtrs == nil {
		mmGetObjectByUID.defaultExpectation.paramPtrs = &RepositoryMockGetObjectByUIDParamPtrs{}
	}
	mmGetObjectByUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetObjectByUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetObjectByUID
}

// ExpectUidParam2 sets up expected param uid for Repository.GetObjectByUID
func (mmGetObjectByUID *mRepositoryMockGetObjectByUID) ExpectUidParam2(uid types.ObjectUIDType) *mRepositoryMockGetObjectByUID {
	if mmGetObjectByUID.mock.funcGetObjectByUID != nil {
		mmGetObjectByUID.mock.t.Fatalf("RepositoryMock.GetObjectByUID mock is already set by Set")
	}

	if mmGetObjectByUID.defaultExpectation == nil {
		mmGetObjectByUID.defaultExpectation = &RepositoryMockGetObjectByUIDExpectation{}
	}

	if mmGetObjectByUID.defaultExpectation.params != nil {
		mmGetObjectByUID.mock.t.Fatalf("RepositoryMock.GetObjectByUID mock is already set by Expect")
	}

	if mmGetObjectByUID.defaultExpectation.paramPtrs == nil {
		mmGetObjectByUID.defaultExpectation.paramPtrs = &RepositoryMockGetObjectByUIDParamPtrs{}
	}
	mmGetObjectByUID.defaultExpectation.paramPtrs.uid = &uid
	mmGetObjectByUID.defaultExpectation.expectationOrigins.originUid = minimock.CallerInfo(1)

	return mmGetObjectByUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetObjectByUID
func (mmGetObjectByUID *mRepositoryMockGetObjectByUID) Inspect(f func(ctx context.Context, uid types.ObjectUIDType)) *mRepositoryMockGetObjectByUID {
	if mmGetObjectByUID.mock.inspectFuncGetObjectByUID != nil {
		mmGetObjectByUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetObjectByUID")
	}

	mmGetObjectByUID.mock.inspectFuncGetObjectByUID = f

	return mmGetObjectByUID
}

// Return sets up results that will be returned by Repository.GetObjectByUID
func (mmGetObjectByUID *mRepositoryMockGetObjectByUID) Return(op1 *mm_repository.ObjectModel, err error) *RepositoryMock {
	if mmGetObjectByUID.mock.funcGetObjectByUID != nil {
		mmGetObjectByUID.mock.t.Fatalf("RepositoryMock.GetObjectByUID mock is already set by Set")
	}

	if mmGetObjectByUID.defaultExpectation == nil {
		mmGetObjectByUID.defaultExpectation = &RepositoryMockGetObjectByUIDExpectation{mock: mmGetObjectByUID.mock}
	}
	mmGetObjectByUID.defaultExpectation.results = &RepositoryMockGetObjectByUIDResults{op1, err}
	mmGetObjectByUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetObjectByUID.mock
}

// Set uses given function f to mock the Repository.GetObjectByUID method
func (mmGetObjectByUID *mRepositoryMockGetObjectByUID) Set(f func(ctx context.Context, uid types.ObjectUIDType) (op1 *mm_repository.ObjectModel, err error)) *RepositoryMock {
	if mmGetObjectByUID.defaultExpectation != nil {
		mmGetObjectByUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetObjectByUID method")
	}

	if len(mmGetObjectByUID.expectations) > 0 {
		mmGetObjectByUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetObjectByUID method")
	}

	mmGetObjectByUID.mock.funcGetObjectByUID = f
	mmGetObjectByUID.mock.funcGetObjectByUIDOrigin = minimock.CallerInfo(1)
	return mmGetObjectByUID.mock
}

// When sets expectation for the Repository.GetObjectByUID which will trigger the result defined by the following
// Then helper
func (mmGetObjectByUID *mRepositoryMockGetObjectByUID) When(ctx context.Context, uid types.ObjectUIDType) *RepositoryMockGetObjectByUIDExpectation {
	if mmGetObjectByUID.mock.funcGetObjectByUID != nil {
		mmGetObjectByUID.mock.t.Fatalf("RepositoryMock.GetObjectByUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetObjectByUIDExpectation{
		mock:               mmGetObjectByUID.mock,
		params:             &RepositoryMockGetObjectByUIDParams{ctx, uid},
		expectationOrigins: RepositoryMockGetObjectByUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetObjectByUID.expectations = append(mmGetObjectByUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetObjectByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetObjectByUIDExpectation) Then(op1 *mm_repository.ObjectModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetObjectByUIDResults{op1, err}
	return e.mock
}

// Times sets number of times Repository.GetObjectByUID should be invoked
func (mmGetObjectByUID *mRepositoryMockGetObjectByUID) Times(n uint64) *mRepositoryMockGetObjectByUID {
	if n == 0 {
		mmGetObjectByUID.mock.t.Fatalf("Times of RepositoryMock.GetObjectByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetObjectByUID.expectedInvocations, n)
	mmGetObjectByUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetObjectByUID
}

func (mmGetObjectByUID *mRepositoryMockGetObjectByUID) invocationsDone() bool {
	if len(mmGetObjectByUID.expectations) == 0 && mmGetObjectByUID.defaultExpectation == nil && mmGetObjectByUID.mock.funcGetObjectByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetObjectByUID.mock.afterGetObjectByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetObjectByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetObjectByUID implements mm_repository.Repository
func (mmGetObjectByUID *RepositoryMock) GetObjectByUID(ctx context.Context, uid types.ObjectUIDType) (op1 *mm_repository.ObjectModel, err error) {
	mm_atomic.AddUint64(&mmGetObjectByUID.beforeGetObjectByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetObjectByUID.afterGetObjectByUIDCounter, 1)

	mmGetObjectByUID.t.Helper()

	if mmGetObjectByUID.inspectFuncGetObjectByUID != nil {
		mmGetObjectByUID.inspectFuncGetObjectByUID(ctx, uid)
	}

	mm_params := RepositoryMockGetObjectByUIDParams{ctx, uid}

	// Record call args
	mmGetObjectByUID.GetObjectByUIDMock.mutex.Lock()
	mmGetObjectByUID.GetObjectByUIDMock.callArgs = append(mmGetObjectByUID.GetObjectByUIDMock.callArgs, &mm_params)
	mmGetObjectByUID.GetObjectByUIDMock.mutex.Unlock()

	for _, e := range mmGetObjectByUID.GetObjectByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetObjectByUID.GetObjectByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetObjectByUID.GetObjectByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetObjectByUID.GetObjectByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetObjectByUID.GetObjectByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetObjectByUIDParams{ctx, uid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetObjectByUID.t.Errorf("RepositoryMock.GetObjectByUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectByUID.GetObjectByUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmGetObjectByUID.t.Errorf("RepositoryMock.GetObjectByUID got unexpected parameter uid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectByUID.GetObjectByUIDMock.defaultExpectation.expectationOrigins.originUid, *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetObjectByUID.t.Errorf("RepositoryMock.GetObjectByUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetObjectByUID.GetObjectByUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetObjectByUID.GetObjectByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetObjectByUID.t.Fatal("No results are set for the RepositoryMock.GetObjectByUID")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetObjectByUID.funcGetObjectByUID != nil {
		return mmGetObjectByUID.funcGetObjectByUID(ctx, uid)
	}
	mmGetObjectByUID.t.Fatalf("Unexpected call to RepositoryMock.GetObjectByUID. %v %v", ctx, uid)
	return
}

// GetObjectByUIDAfterCounter returns a count of finished RepositoryMock.GetObjectByUID invocations
func (mmGetObjectByUID *RepositoryMock) GetObjectByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectByUID.afterGetObjectByUIDCounter)
}

// GetObjectByUIDBeforeCounter returns a count of RepositoryMock.GetObjectByUID invocations
func (mmGetObjectByUID *RepositoryMock) GetObjectByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectByUID.beforeGetObjectByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetObjectByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetObjectByUID *mRepositoryMockGetObjectByUID) Calls() []*RepositoryMockGetObjectByUIDParams {
	mmGetObjectByUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetObjectByUIDParams, len(mmGetObjectByUID.callArgs))
	copy(argCopy, mmGetObjectByUID.callArgs)

	mmGetObjectByUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetObjectByUIDDone returns true if the count of the GetObjectByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetObjectByUIDDone() bool {
	if m.GetObjectByUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetObjectByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetObjectByUIDMock.invocationsDone()
}

// MinimockGetObjectByUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetObjectByUIDInspect() {
	for _, e := range m.GetObjectByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetObjectByUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetObjectByUIDCounter := mm_atomic.LoadUint64(&m.afterGetObjectByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetObjectByUIDMock.defaultExpectation != nil && afterGetObjectByUIDCounter < 1 {
		if m.GetObjectByUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetObjectByUID at\n%s", m.GetObjectByUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetObjectByUID at\n%s with params: %#v", m.GetObjectByUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetObjectByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetObjectByUID != nil && afterGetObjectByUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetObjectByUID at\n%s", m.funcGetObjectByUIDOrigin)
	}

	if !m.GetObjectByUIDMock.invocationsDone() && afterGetObjectByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetObjectByUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetObjectByUIDMock.expectedInvocations), m.GetObjectByUIDMock.expectedInvocationsOrigin, afterGetObjectByUIDCounter)
	}
}

type mRepositoryMockGetRepositoryTag struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetRepositoryTagExpectation
	expectations       []*RepositoryMockGetRepositoryTagExpectation

	callArgs []*RepositoryMockGetRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetRepositoryTagExpectation specifies expectation struct of the Repository.GetRepositoryTag
type RepositoryMockGetRepositoryTagExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetRepositoryTagParams
	paramPtrs          *RepositoryMockGetRepositoryTagParamPtrs
	expectationOrigins RepositoryMockGetRepositoryTagExpectationOrigins
	results            *RepositoryMockGetRepositoryTagResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetRepositoryTagParams contains parameters of the Repository.GetRepositoryTag
type RepositoryMockGetRepositoryTagParams struct {
	ctx context.Context
	r1  utils.RepositoryTagName
}

// RepositoryMockGetRepositoryTagParamPtrs contains pointers to parameters of the Repository.GetRepositoryTag
type RepositoryMockGetRepositoryTagParamPtrs struct {
	ctx *context.Context
	r1  *utils.RepositoryTagName
}

// RepositoryMockGetRepositoryTagResults contains results of the Repository.GetRepositoryTag
type RepositoryMockGetRepositoryTagResults struct {
	tp1 *types.Tag
	err error
}

// RepositoryMockGetRepositoryTagOrigins contains origins of expectations of the Repository.GetRepositoryTag
type RepositoryMockGetRepositoryTagExpectationOrigins struct {
	origin    string
	originCtx string
	originR1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) Optional() *mRepositoryMockGetRepositoryTag {
	mmGetRepositoryTag.optional = true
	return mmGetRepositoryTag
}

// Expect sets up expected params for Repository.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) Expect(ctx context.Context, r1 utils.RepositoryTagName) *mRepositoryMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by ExpectParams functions")
	}

	mmGetRepositoryTag.defaultExpectation.params = &RepositoryMockGetRepositoryTagParams{ctx, r1}
	mmGetRepositoryTag.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetRepositoryTag.expectations {
		if minimock.Equal(e.params, mmGetRepositoryTag.defaultExpectation.params) {
			mmGetRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRepositoryTag.defaultExpectation.params)
		}
	}

	return mmGetRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.params != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by Expect")
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmGetRepositoryTag.defaultExpectation.paramPtrs = &RepositoryMockGetRepositoryTagParamPtrs{}
	}
	mmGetRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetRepositoryTag.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetRepositoryTag
}

// ExpectR1Param2 sets up expected param r1 for Repository.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) ExpectR1Param2(r1 utils.RepositoryTagName) *mRepositoryMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.params != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by Expect")
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmGetRepositoryTag.defaultExpectation.paramPtrs = &RepositoryMockGetRepositoryTagParamPtrs{}
	}
	mmGetRepositoryTag.defaultExpectation.paramPtrs.r1 = &r1
	mmGetRepositoryTag.defaultExpectation.expectationOrigins.originR1 = minimock.CallerInfo(1)

	return mmGetRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) Inspect(f func(ctx context.Context, r1 utils.RepositoryTagName)) *mRepositoryMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.inspectFuncGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetRepositoryTag")
	}

	mmGetRepositoryTag.mock.inspectFuncGetRepositoryTag = f

	return mmGetRepositoryTag
}

// Return sets up results that will be returned by Repository.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) Return(tp1 *types.Tag, err error) *RepositoryMock {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryMockGetRepositoryTagExpectation{mock: mmGetRepositoryTag.mock}
	}
	mmGetRepositoryTag.defaultExpectation.results = &RepositoryMockGetRepositoryTagResults{tp1, err}
	mmGetRepositoryTag.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetRepositoryTag.mock
}

// Set uses given function f to mock the Repository.GetRepositoryTag method
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) Set(f func(ctx context.Context, r1 utils.RepositoryTagName) (tp1 *types.Tag, err error)) *RepositoryMock {
	if mmGetRepositoryTag.defaultExpectation != nil {
		mmGetRepositoryTag.mock.t.Fatalf("Default expectation is already set for the Repository.GetRepositoryTag method")
	}

	if len(mmGetRepositoryTag.expectations) > 0 {
		mmGetRepositoryTag.mock.t.Fatalf("Some expectations are already set for the Repository.GetRepositoryTag method")
	}

	mmGetRepositoryTag.mock.funcGetRepositoryTag = f
	mmGetRepositoryTag.mock.funcGetRepositoryTagOrigin = minimock.CallerInfo(1)
	return mmGetRepositoryTag.mock
}

// When sets expectation for the Repository.GetRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) When(ctx context.Context, r1 utils.RepositoryTagName) *RepositoryMockGetRepositoryTagExpectation {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by Set")
	}

	expectation := &RepositoryMockGetRepositoryTagExpectation{
		mock:               mmGetRepositoryTag.mock,
		params:             &RepositoryMockGetRepositoryTagParams{ctx, r1},
		expectationOrigins: RepositoryMockGetRepositoryTagExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetRepositoryTag.expectations = append(mmGetRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetRepositoryTag return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetRepositoryTagExpectation) Then(tp1 *types.Tag, err error) *RepositoryMock {
	e.results = &RepositoryMockGetRepositoryTagResults{tp1, err}
	return e.mock
}

// Times sets number of times Repository.GetRepositoryTag should be invoked
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) Times(n uint64) *mRepositoryMockGetRepositoryTag {
	if n == 0 {
		mmGetRepositoryTag.mock.t.Fatalf("Times of RepositoryMock.GetRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRepositoryTag.expectedInvocations, n)
	mmGetRepositoryTag.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetRepositoryTag
}

func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) invocationsDone() bool {
	if len(mmGetRepositoryTag.expectations) == 0 && mmGetRepositoryTag.defaultExpectation == nil && mmGetRepositoryTag.mock.funcGetRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRepositoryTag.mock.afterGetRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRepositoryTag implements mm_repository.Repository
func (mmGetRepositoryTag *RepositoryMock) GetRepositoryTag(ctx context.Context, r1 utils.RepositoryTagName) (tp1 *types.Tag, err error) {
	mm_atomic.AddUint64(&mmGetRepositoryTag.beforeGetRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRepositoryTag.afterGetRepositoryTagCounter, 1)

	mmGetRepositoryTag.t.Helper()

	if mmGetRepositoryTag.inspectFuncGetRepositoryTag != nil {
		mmGetRepositoryTag.inspectFuncGetRepositoryTag(ctx, r1)
	}

	mm_params := RepositoryMockGetRepositoryTagParams{ctx, r1}

	// Record call args
	mmGetRepositoryTag.GetRepositoryTagMock.mutex.Lock()
	mmGetRepositoryTag.GetRepositoryTagMock.callArgs = append(mmGetRepositoryTag.GetRepositoryTagMock.callArgs, &mm_params)
	mmGetRepositoryTag.GetRepositoryTagMock.mutex.Unlock()

	for _, e := range mmGetRepositoryTag.GetRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp1, e.results.err
		}
	}

	if mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetRepositoryTagParams{ctx, r1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetRepositoryTag.t.Errorf("RepositoryMock.GetRepositoryTag got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.r1 != nil && !minimock.Equal(*mm_want_ptrs.r1, mm_got.r1) {
				mmGetRepositoryTag.t.Errorf("RepositoryMock.GetRepositoryTag got unexpected parameter r1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.expectationOrigins.originR1, *mm_want_ptrs.r1, mm_got.r1, minimock.Diff(*mm_want_ptrs.r1, mm_got.r1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRepositoryTag.t.Errorf("RepositoryMock.GetRepositoryTag got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRepositoryTag.t.Fatal("No results are set for the RepositoryMock.GetRepositoryTag")
		}
		return (*mm_results).tp1, (*mm_results).err
	}
	if mmGetRepositoryTag.funcGetRepositoryTag != nil {
		return mmGetRepositoryTag.funcGetRepositoryTag(ctx, r1)
	}
	mmGetRepositoryTag.t.Fatalf("Unexpected call to RepositoryMock.GetRepositoryTag. %v %v", ctx, r1)
	return
}

// GetRepositoryTagAfterCounter returns a count of finished RepositoryMock.GetRepositoryTag invocations
func (mmGetRepositoryTag *RepositoryMock) GetRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRepositoryTag.afterGetRepositoryTagCounter)
}

// GetRepositoryTagBeforeCounter returns a count of RepositoryMock.GetRepositoryTag invocations
func (mmGetRepositoryTag *RepositoryMock) GetRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRepositoryTag.beforeGetRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) Calls() []*RepositoryMockGetRepositoryTagParams {
	mmGetRepositoryTag.mutex.RLock()

	argCopy := make([]*RepositoryMockGetRepositoryTagParams, len(mmGetRepositoryTag.callArgs))
	copy(argCopy, mmGetRepositoryTag.callArgs)

	mmGetRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockGetRepositoryTagDone returns true if the count of the GetRepositoryTag invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetRepositoryTagDone() bool {
	if m.GetRepositoryTagMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRepositoryTagMock.invocationsDone()
}

// MinimockGetRepositoryTagInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetRepositoryTagInspect() {
	for _, e := range m.GetRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetRepositoryTag at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterGetRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRepositoryTagMock.defaultExpectation != nil && afterGetRepositoryTagCounter < 1 {
		if m.GetRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetRepositoryTag at\n%s", m.GetRepositoryTagMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetRepositoryTag at\n%s with params: %#v", m.GetRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *m.GetRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRepositoryTag != nil && afterGetRepositoryTagCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetRepositoryTag at\n%s", m.funcGetRepositoryTagOrigin)
	}

	if !m.GetRepositoryTagMock.invocationsDone() && afterGetRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetRepositoryTag at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetRepositoryTagMock.expectedInvocations), m.GetRepositoryTagMock.expectedInvocationsOrigin, afterGetRepositoryTagCounter)
	}
}

type mRepositoryMockGetRollbackKBForProduction struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetRollbackKBForProductionExpectation
	expectations       []*RepositoryMockGetRollbackKBForProductionExpectation

	callArgs []*RepositoryMockGetRollbackKBForProductionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetRollbackKBForProductionExpectation specifies expectation struct of the Repository.GetRollbackKBForProduction
type RepositoryMockGetRollbackKBForProductionExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetRollbackKBForProductionParams
	paramPtrs          *RepositoryMockGetRollbackKBForProductionParamPtrs
	expectationOrigins RepositoryMockGetRollbackKBForProductionExpectationOrigins
	results            *RepositoryMockGetRollbackKBForProductionResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetRollbackKBForProductionParams contains parameters of the Repository.GetRollbackKBForProduction
type RepositoryMockGetRollbackKBForProductionParams struct {
	ctx            context.Context
	ownerUID       types.OwnerUIDType
	productionKBID string
}

// RepositoryMockGetRollbackKBForProductionParamPtrs contains pointers to parameters of the Repository.GetRollbackKBForProduction
type RepositoryMockGetRollbackKBForProductionParamPtrs struct {
	ctx            *context.Context
	ownerUID       *types.OwnerUIDType
	productionKBID *string
}

// RepositoryMockGetRollbackKBForProductionResults contains results of the Repository.GetRollbackKBForProduction
type RepositoryMockGetRollbackKBForProductionResults struct {
	kp1 *mm_repository.KnowledgeBaseModel
	err error
}

// RepositoryMockGetRollbackKBForProductionOrigins contains origins of expectations of the Repository.GetRollbackKBForProduction
type RepositoryMockGetRollbackKBForProductionExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerUID       string
	originProductionKBID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetRollbackKBForProduction *mRepositoryMockGetRollbackKBForProduction) Optional() *mRepositoryMockGetRollbackKBForProduction {
	mmGetRollbackKBForProduction.optional = true
	return mmGetRollbackKBForProduction
}

// Expect sets up expected params for Repository.GetRollbackKBForProduction
func (mmGetRollbackKBForProduction *mRepositoryMockGetRollbackKBForProduction) Expect(ctx context.Context, ownerUID types.OwnerUIDType, productionKBID string) *mRepositoryMockGetRollbackKBForProduction {
	if mmGetRollbackKBForProduction.mock.funcGetRollbackKBForProduction != nil {
		mmGetRollbackKBForProduction.mock.t.Fatalf("RepositoryMock.GetRollbackKBForProduction mock is already set by Set")
	}

	if mmGetRollbackKBForProduction.defaultExpectation == nil {
		mmGetRollbackKBForProduction.defaultExpectation = &RepositoryMockGetRollbackKBForProductionExpectation{}
	}

	if mmGetRollbackKBForProduction.defaultExpectation.paramPtrs != nil {
		mmGetRollbackKBForProduction.mock.t.Fatalf("RepositoryMock.GetRollbackKBForProduction mock is already set by ExpectParams functions")
	}

	mmGetRollbackKBForProduction.defaultExpectation.params = &RepositoryMockGetRollbackKBForProductionParams{ctx, ownerUID, productionKBID}
	mmGetRollbackKBForProduction.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetRollbackKBForProduction.expectations {
		if minimock.Equal(e.params, mmGetRollbackKBForProduction.defaultExpectation.params) {
			mmGetRollbackKBForProduction.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRollbackKBForProduction.defaultExpectation.params)
		}
	}

	return mmGetRollbackKBForProduction
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetRollbackKBForProduction
func (mmGetRollbackKBForProduction *mRepositoryMockGetRollbackKBForProduction) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetRollbackKBForProduction {
	if mmGetRollbackKBForProduction.mock.funcGetRollbackKBForProduction != nil {
		mmGetRollbackKBForProduction.mock.t.Fatalf("RepositoryMock.GetRollbackKBForProduction mock is already set by Set")
	}

	if mmGetRollbackKBForProduction.defaultExpectation == nil {
		mmGetRollbackKBForProduction.defaultExpectation = &RepositoryMockGetRollbackKBForProductionExpectation{}
	}

	if mmGetRollbackKBForProduction.defaultExpectation.params != nil {
		mmGetRollbackKBForProduction.mock.t.Fatalf("RepositoryMock.GetRollbackKBForProduction mock is already set by Expect")
	}

	if mmGetRollbackKBForProduction.defaultExpectation.paramPtrs == nil {
		mmGetRollbackKBForProduction.defaultExpectation.paramPtrs = &RepositoryMockGetRollbackKBForProductionParamPtrs{}
	}
	mmGetRollbackKBForProduction.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetRollbackKBForProduction.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetRollbackKBForProduction
}

// ExpectOwnerUIDParam2 sets up expected param ownerUID for Repository.GetRollbackKBForProduction
func (mmGetRollbackKBForProduction *mRepositoryMockGetRollbackKBForProduction) ExpectOwnerUIDParam2(ownerUID types.OwnerUIDType) *mRepositoryMockGetRollbackKBForProduction {
	if mmGetRollbackKBForProduction.mock.funcGetRollbackKBForProduction != nil {
		mmGetRollbackKBForProduction.mock.t.Fatalf("RepositoryMock.GetRollbackKBForProduction mock is already set by Set")
	}

	if mmGetRollbackKBForProduction.defaultExpectation == nil {
		mmGetRollbackKBForProduction.defaultExpectation = &RepositoryMockGetRollbackKBForProductionExpectation{}
	}

	if mmGetRollbackKBForProduction.defaultExpectation.params != nil {
		mmGetRollbackKBForProduction.mock.t.Fatalf("RepositoryMock.GetRollbackKBForProduction mock is already set by Expect")
	}

	if mmGetRollbackKBForProduction.defaultExpectation.paramPtrs == nil {
		mmGetRollbackKBForProduction.defaultExpectation.paramPtrs = &RepositoryMockGetRollbackKBForProductionParamPtrs{}
	}
	mmGetRollbackKBForProduction.defaultExpectation.paramPtrs.ownerUID = &ownerUID
	mmGetRollbackKBForProduction.defaultExpectation.expectationOrigins.originOwnerUID = minimock.CallerInfo(1)

	return mmGetRollbackKBForProduction
}

// ExpectProductionKBIDParam3 sets up expected param productionKBID for Repository.GetRollbackKBForProduction
func (mmGetRollbackKBForProduction *mRepositoryMockGetRollbackKBForProduction) ExpectProductionKBIDParam3(productionKBID string) *mRepositoryMockGetRollbackKBForProduction {
	if mmGetRollbackKBForProduction.mock.funcGetRollbackKBForProduction != nil {
		mmGetRollbackKBForProduction.mock.t.Fatalf("RepositoryMock.GetRollbackKBForProduction mock is already set by Set")
	}

	if mmGetRollbackKBForProduction.defaultExpectation == nil {
		mmGetRollbackKBForProduction.defaultExpectation = &RepositoryMockGetRollbackKBForProductionExpectation{}
	}

	if mmGetRollbackKBForProduction.defaultExpectation.params != nil {
		mmGetRollbackKBForProduction.mock.t.Fatalf("RepositoryMock.GetRollbackKBForProduction mock is already set by Expect")
	}

	if mmGetRollbackKBForProduction.defaultExpectation.paramPtrs == nil {
		mmGetRollbackKBForProduction.defaultExpectation.paramPtrs = &RepositoryMockGetRollbackKBForProductionParamPtrs{}
	}
	mmGetRollbackKBForProduction.defaultExpectation.paramPtrs.productionKBID = &productionKBID
	mmGetRollbackKBForProduction.defaultExpectation.expectationOrigins.originProductionKBID = minimock.CallerInfo(1)

	return mmGetRollbackKBForProduction
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetRollbackKBForProduction
func (mmGetRollbackKBForProduction *mRepositoryMockGetRollbackKBForProduction) Inspect(f func(ctx context.Context, ownerUID types.OwnerUIDType, productionKBID string)) *mRepositoryMockGetRollbackKBForProduction {
	if mmGetRollbackKBForProduction.mock.inspectFuncGetRollbackKBForProduction != nil {
		mmGetRollbackKBForProduction.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetRollbackKBForProduction")
	}

	mmGetRollbackKBForProduction.mock.inspectFuncGetRollbackKBForProduction = f

	return mmGetRollbackKBForProduction
}

// Return sets up results that will be returned by Repository.GetRollbackKBForProduction
func (mmGetRollbackKBForProduction *mRepositoryMockGetRollbackKBForProduction) Return(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	if mmGetRollbackKBForProduction.mock.funcGetRollbackKBForProduction != nil {
		mmGetRollbackKBForProduction.mock.t.Fatalf("RepositoryMock.GetRollbackKBForProduction mock is already set by Set")
	}

	if mmGetRollbackKBForProduction.defaultExpectation == nil {
		mmGetRollbackKBForProduction.defaultExpectation = &RepositoryMockGetRollbackKBForProductionExpectation{mock: mmGetRollbackKBForProduction.mock}
	}
	mmGetRollbackKBForProduction.defaultExpectation.results = &RepositoryMockGetRollbackKBForProductionResults{kp1, err}
	mmGetRollbackKBForProduction.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetRollbackKBForProduction.mock
}

// Set uses given function f to mock the Repository.GetRollbackKBForProduction method
func (mmGetRollbackKBForProduction *mRepositoryMockGetRollbackKBForProduction) Set(f func(ctx context.Context, ownerUID types.OwnerUIDType, productionKBID string) (kp1 *mm_repository.KnowledgeBaseModel, err error)) *RepositoryMock {
	if mmGetRollbackKBForProduction.defaultExpectation != nil {
		mmGetRollbackKBForProduction.mock.t.Fatalf("Default expectation is already set for the Repository.GetRollbackKBForProduction method")
	}

	if len(mmGetRollbackKBForProduction.expectations) > 0 {
		mmGetRollbackKBForProduction.mock.t.Fatalf("Some expectations are already set for the Repository.GetRollbackKBForProduction method")
	}

	mmGetRollbackKBForProduction.mock.funcGetRollbackKBForProduction = f
	mmGetRollbackKBForProduction.mock.funcGetRollbackKBForProductionOrigin = minimock.CallerInfo(1)
	return mmGetRollbackKBForProduction.mock
}

// When sets expectation for the Repository.GetRollbackKBForProduction which will trigger the result defined by the following
// Then helper
func (mmGetRollbackKBForProduction *mRepositoryMockGetRollbackKBForProduction) When(ctx context.Context, ownerUID types.OwnerUIDType, productionKBID string) *RepositoryMockGetRollbackKBForProductionExpectation {
	if mmGetRollbackKBForProduction.mock.funcGetRollbackKBForProduction != nil {
		mmGetRollbackKBForProduction.mock.t.Fatalf("RepositoryMock.GetRollbackKBForProduction mock is already set by Set")
	}

	expectation := &RepositoryMockGetRollbackKBForProductionExpectation{
		mock:               mmGetRollbackKBForProduction.mock,
		params:             &RepositoryMockGetRollbackKBForProductionParams{ctx, ownerUID, productionKBID},
		expectationOrigins: RepositoryMockGetRollbackKBForProductionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetRollbackKBForProduction.expectations = append(mmGetRollbackKBForProduction.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetRollbackKBForProduction return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetRollbackKBForProductionExpectation) Then(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetRollbackKBForProductionResults{kp1, err}
	return e.mock
}

// Times sets number of times Repository.GetRollbackKBForProduction should be invoked
func (mmGetRollbackKBForProduction *mRepositoryMockGetRollbackKBForProduction) Times(n uint64) *mRepositoryMockGetRollbackKBForProduction {
	if n == 0 {
		mmGetRollbackKBForProduction.mock.t.Fatalf("Times of RepositoryMock.GetRollbackKBForProduction mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRollbackKBForProduction.expectedInvocations, n)
	mmGetRollbackKBForProduction.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetRollbackKBForProduction
}

func (mmGetRollbackKBForProduction *mRepositoryMockGetRollbackKBForProduction) invocationsDone() bool {
	if len(mmGetRollbackKBForProduction.expectations) == 0 && mmGetRollbackKBForProduction.defaultExpectation == nil && mmGetRollbackKBForProduction.mock.funcGetRollbackKBForProduction == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRollbackKBForProduction.mock.afterGetRollbackKBForProductionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRollbackKBForProduction.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRollbackKBForProduction implements mm_repository.Repository
func (mmGetRollbackKBForProduction *RepositoryMock) GetRollbackKBForProduction(ctx context.Context, ownerUID types.OwnerUIDType, productionKBID string) (kp1 *mm_repository.KnowledgeBaseModel, err error) {
	mm_atomic.AddUint64(&mmGetRollbackKBForProduction.beforeGetRollbackKBForProductionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRollbackKBForProduction.afterGetRollbackKBForProductionCounter, 1)

	mmGetRollbackKBForProduction.t.Helper()

	if mmGetRollbackKBForProduction.inspectFuncGetRollbackKBForProduction != nil {
		mmGetRollbackKBForProduction.inspectFuncGetRollbackKBForProduction(ctx, ownerUID, productionKBID)
	}

	mm_params := RepositoryMockGetRollbackKBForProductionParams{ctx, ownerUID, productionKBID}

	// Record call args
	mmGetRollbackKBForProduction.GetRollbackKBForProductionMock.mutex.Lock()
	mmGetRollbackKBForProduction.GetRollbackKBForProductionMock.callArgs = append(mmGetRollbackKBForProduction.GetRollbackKBForProductionMock.callArgs, &mm_params)
	mmGetRollbackKBForProduction.GetRollbackKBForProductionMock.mutex.Unlock()

	for _, e := range mmGetRollbackKBForProduction.GetRollbackKBForProductionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmGetRollbackKBForProduction.GetRollbackKBForProductionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRollbackKBForProduction.GetRollbackKBForProductionMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRollbackKBForProduction.GetRollbackKBForProductionMock.defaultExpectation.params
		mm_want_ptrs := mmGetRollbackKBForProduction.GetRollbackKBForProductionMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetRollbackKBForProductionParams{ctx, ownerUID, productionKBID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetRollbackKBForProduction.t.Errorf("RepositoryMock.GetRollbackKBForProduction got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRollbackKBForProduction.GetRollbackKBForProductionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmGetRollbackKBForProduction.t.Errorf("RepositoryMock.GetRollbackKBForProduction got unexpected parameter ownerUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRollbackKBForProduction.GetRollbackKBForProductionMock.defaultExpectation.expectationOrigins.originOwnerUID, *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

			if mm_want_ptrs.productionKBID != nil && !minimock.Equal(*mm_want_ptrs.productionKBID, mm_got.productionKBID) {
				mmGetRollbackKBForProduction.t.Errorf("RepositoryMock.GetRollbackKBForProduction got unexpected parameter productionKBID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRollbackKBForProduction.GetRollbackKBForProductionMock.defaultExpectation.expectationOrigins.originProductionKBID, *mm_want_ptrs.productionKBID, mm_got.productionKBID, minimock.Diff(*mm_want_ptrs.productionKBID, mm_got.productionKBID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRollbackKBForProduction.t.Errorf("RepositoryMock.GetRollbackKBForProduction got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetRollbackKBForProduction.GetRollbackKBForProductionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRollbackKBForProduction.GetRollbackKBForProductionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRollbackKBForProduction.t.Fatal("No results are set for the RepositoryMock.GetRollbackKBForProduction")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmGetRollbackKBForProduction.funcGetRollbackKBForProduction != nil {
		return mmGetRollbackKBForProduction.funcGetRollbackKBForProduction(ctx, ownerUID, productionKBID)
	}
	mmGetRollbackKBForProduction.t.Fatalf("Unexpected call to RepositoryMock.GetRollbackKBForProduction. %v %v %v", ctx, ownerUID, productionKBID)
	return
}

// GetRollbackKBForProductionAfterCounter returns a count of finished RepositoryMock.GetRollbackKBForProduction invocations
func (mmGetRollbackKBForProduction *RepositoryMock) GetRollbackKBForProductionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRollbackKBForProduction.afterGetRollbackKBForProductionCounter)
}

// GetRollbackKBForProductionBeforeCounter returns a count of RepositoryMock.GetRollbackKBForProduction invocations
func (mmGetRollbackKBForProduction *RepositoryMock) GetRollbackKBForProductionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRollbackKBForProduction.beforeGetRollbackKBForProductionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetRollbackKBForProduction.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRollbackKBForProduction *mRepositoryMockGetRollbackKBForProduction) Calls() []*RepositoryMockGetRollbackKBForProductionParams {
	mmGetRollbackKBForProduction.mutex.RLock()

	argCopy := make([]*RepositoryMockGetRollbackKBForProductionParams, len(mmGetRollbackKBForProduction.callArgs))
	copy(argCopy, mmGetRollbackKBForProduction.callArgs)

	mmGetRollbackKBForProduction.mutex.RUnlock()

	return argCopy
}

// MinimockGetRollbackKBForProductionDone returns true if the count of the GetRollbackKBForProduction invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetRollbackKBForProductionDone() bool {
	if m.GetRollbackKBForProductionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetRollbackKBForProductionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRollbackKBForProductionMock.invocationsDone()
}

// MinimockGetRollbackKBForProductionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetRollbackKBForProductionInspect() {
	for _, e := range m.GetRollbackKBForProductionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetRollbackKBForProduction at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetRollbackKBForProductionCounter := mm_atomic.LoadUint64(&m.afterGetRollbackKBForProductionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRollbackKBForProductionMock.defaultExpectation != nil && afterGetRollbackKBForProductionCounter < 1 {
		if m.GetRollbackKBForProductionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetRollbackKBForProduction at\n%s", m.GetRollbackKBForProductionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetRollbackKBForProduction at\n%s with params: %#v", m.GetRollbackKBForProductionMock.defaultExpectation.expectationOrigins.origin, *m.GetRollbackKBForProductionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRollbackKBForProduction != nil && afterGetRollbackKBForProductionCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetRollbackKBForProduction at\n%s", m.funcGetRollbackKBForProductionOrigin)
	}

	if !m.GetRollbackKBForProductionMock.invocationsDone() && afterGetRollbackKBForProductionCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetRollbackKBForProduction at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetRollbackKBForProductionMock.expectedInvocations), m.GetRollbackKBForProductionMock.expectedInvocationsOrigin, afterGetRollbackKBForProductionCounter)
	}
}

type mRepositoryMockGetSourceByFileUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetSourceByFileUIDExpectation
	expectations       []*RepositoryMockGetSourceByFileUIDExpectation

	callArgs []*RepositoryMockGetSourceByFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetSourceByFileUIDExpectation specifies expectation struct of the Repository.GetSourceByFileUID
type RepositoryMockGetSourceByFileUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetSourceByFileUIDParams
	paramPtrs          *RepositoryMockGetSourceByFileUIDParamPtrs
	expectationOrigins RepositoryMockGetSourceByFileUIDExpectationOrigins
	results            *RepositoryMockGetSourceByFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetSourceByFileUIDParams contains parameters of the Repository.GetSourceByFileUID
type RepositoryMockGetSourceByFileUIDParams struct {
	ctx     context.Context
	fileUID types.FileUIDType
}

// RepositoryMockGetSourceByFileUIDParamPtrs contains pointers to parameters of the Repository.GetSourceByFileUID
type RepositoryMockGetSourceByFileUIDParamPtrs struct {
	ctx     *context.Context
	fileUID *types.FileUIDType
}

// RepositoryMockGetSourceByFileUIDResults contains results of the Repository.GetSourceByFileUID
type RepositoryMockGetSourceByFileUIDResults struct {
	sp1 *mm_repository.SourceMeta
	err error
}

// RepositoryMockGetSourceByFileUIDOrigins contains origins of expectations of the Repository.GetSourceByFileUID
type RepositoryMockGetSourceByFileUIDExpectationOrigins struct {
	origin        string
	originCtx     string
	originFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetSourceByFileUID *mRepositoryMockGetSourceByFileUID) Optional() *mRepositoryMockGetSourceByFileUID {
	mmGetSourceByFileUID.optional = true
	return mmGetSourceByFileUID
}

// Expect sets up expected params for Repository.GetSourceByFileUID
func (mmGetSourceByFileUID *mRepositoryMockGetSourceByFileUID) Expect(ctx context.Context, fileUID types.FileUIDType) *mRepositoryMockGetSourceByFileUID {
	if mmGetSourceByFileUID.mock.funcGetSourceByFileUID != nil {
		mmGetSourceByFileUID.mock.t.Fatalf("RepositoryMock.GetSourceByFileUID mock is already set by Set")
	}

	if mmGetSourceByFileUID.defaultExpectation == nil {
		mmGetSourceByFileUID.defaultExpectation = &RepositoryMockGetSourceByFileUIDExpectation{}
	}

	if mmGetSourceByFileUID.defaultExpectation.paramPtrs != nil {
		mmGetSourceByFileUID.mock.t.Fatalf("RepositoryMock.GetSourceByFileUID mock is already set by ExpectParams functions")
	}

	mmGetSourceByFileUID.defaultExpectation.params = &RepositoryMockGetSourceByFileUIDParams{ctx, fileUID}
	mmGetSourceByFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetSourceByFileUID.expectations {
		if minimock.Equal(e.params, mmGetSourceByFileUID.defaultExpectation.params) {
			mmGetSourceByFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSourceByFileUID.defaultExpectation.params)
		}
	}

	return mmGetSourceByFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetSourceByFileUID
func (mmGetSourceByFileUID *mRepositoryMockGetSourceByFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetSourceByFileUID {
	if mmGetSourceByFileUID.mock.funcGetSourceByFileUID != nil {
		mmGetSourceByFileUID.mock.t.Fatalf("RepositoryMock.GetSourceByFileUID mock is already set by Set")
	}

	if mmGetSourceByFileUID.defaultExpectation == nil {
		mmGetSourceByFileUID.defaultExpectation = &RepositoryMockGetSourceByFileUIDExpectation{}
	}

	if mmGetSourceByFileUID.defaultExpectation.params != nil {
		mmGetSourceByFileUID.mock.t.Fatalf("RepositoryMock.GetSourceByFileUID mock is already set by Expect")
	}

	if mmGetSourceByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetSourceByFileUID.defaultExpectation.paramPtrs = &RepositoryMockGetSourceByFileUIDParamPtrs{}
	}
	mmGetSourceByFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetSourceByFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetSourceByFileUID
}

// ExpectFileUIDParam2 sets up expected param fileUID for Repository.GetSourceByFileUID
func (mmGetSourceByFileUID *mRepositoryMockGetSourceByFileUID) ExpectFileUIDParam2(fileUID types.FileUIDType) *mRepositoryMockGetSourceByFileUID {
	if mmGetSourceByFileUID.mock.funcGetSourceByFileUID != nil {
		mmGetSourceByFileUID.mock.t.Fatalf("RepositoryMock.GetSourceByFileUID mock is already set by Set")
	}

	if mmGetSourceByFileUID.defaultExpectation == nil {
		mmGetSourceByFileUID.defaultExpectation = &RepositoryMockGetSourceByFileUIDExpectation{}
	}

	if mmGetSourceByFileUID.defaultExpectation.params != nil {
		mmGetSourceByFileUID.mock.t.Fatalf("RepositoryMock.GetSourceByFileUID mock is already set by Expect")
	}

	if mmGetSourceByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetSourceByFileUID.defaultExpectation.paramPtrs = &RepositoryMockGetSourceByFileUIDParamPtrs{}
	}
	mmGetSourceByFileUID.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmGetSourceByFileUID.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmGetSourceByFileUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetSourceByFileUID
func (mmGetSourceByFileUID *mRepositoryMockGetSourceByFileUID) Inspect(f func(ctx context.Context, fileUID types.FileUIDType)) *mRepositoryMockGetSourceByFileUID {
	if mmGetSourceByFileUID.mock.inspectFuncGetSourceByFileUID != nil {
		mmGetSourceByFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetSourceByFileUID")
	}

	mmGetSourceByFileUID.mock.inspectFuncGetSourceByFileUID = f

	return mmGetSourceByFileUID
}

// Return sets up results that will be returned by Repository.GetSourceByFileUID
func (mmGetSourceByFileUID *mRepositoryMockGetSourceByFileUID) Return(sp1 *mm_repository.SourceMeta, err error) *RepositoryMock {
	if mmGetSourceByFileUID.mock.funcGetSourceByFileUID != nil {
		mmGetSourceByFileUID.mock.t.Fatalf("RepositoryMock.GetSourceByFileUID mock is already set by Set")
	}

	if mmGetSourceByFileUID.defaultExpectation == nil {
		mmGetSourceByFileUID.defaultExpectation = &RepositoryMockGetSourceByFileUIDExpectation{mock: mmGetSourceByFileUID.mock}
	}
	mmGetSourceByFileUID.defaultExpectation.results = &RepositoryMockGetSourceByFileUIDResults{sp1, err}
	mmGetSourceByFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetSourceByFileUID.mock
}

// Set uses given function f to mock the Repository.GetSourceByFileUID method
func (mmGetSourceByFileUID *mRepositoryMockGetSourceByFileUID) Set(f func(ctx context.Context, fileUID types.FileUIDType) (sp1 *mm_repository.SourceMeta, err error)) *RepositoryMock {
	if mmGetSourceByFileUID.defaultExpectation != nil {
		mmGetSourceByFileUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetSourceByFileUID method")
	}

	if len(mmGetSourceByFileUID.expectations) > 0 {
		mmGetSourceByFileUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetSourceByFileUID method")
	}

	mmGetSourceByFileUID.mock.funcGetSourceByFileUID = f
	mmGetSourceByFileUID.mock.funcGetSourceByFileUIDOrigin = minimock.CallerInfo(1)
	return mmGetSourceByFileUID.mock
}

// When sets expectation for the Repository.GetSourceByFileUID which will trigger the result defined by the following
// Then helper
func (mmGetSourceByFileUID *mRepositoryMockGetSourceByFileUID) When(ctx context.Context, fileUID types.FileUIDType) *RepositoryMockGetSourceByFileUIDExpectation {
	if mmGetSourceByFileUID.mock.funcGetSourceByFileUID != nil {
		mmGetSourceByFileUID.mock.t.Fatalf("RepositoryMock.GetSourceByFileUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetSourceByFileUIDExpectation{
		mock:               mmGetSourceByFileUID.mock,
		params:             &RepositoryMockGetSourceByFileUIDParams{ctx, fileUID},
		expectationOrigins: RepositoryMockGetSourceByFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetSourceByFileUID.expectations = append(mmGetSourceByFileUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetSourceByFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetSourceByFileUIDExpectation) Then(sp1 *mm_repository.SourceMeta, err error) *RepositoryMock {
	e.results = &RepositoryMockGetSourceByFileUIDResults{sp1, err}
	return e.mock
}

// Times sets number of times Repository.GetSourceByFileUID should be invoked
func (mmGetSourceByFileUID *mRepositoryMockGetSourceByFileUID) Times(n uint64) *mRepositoryMockGetSourceByFileUID {
	if n == 0 {
		mmGetSourceByFileUID.mock.t.Fatalf("Times of RepositoryMock.GetSourceByFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetSourceByFileUID.expectedInvocations, n)
	mmGetSourceByFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetSourceByFileUID
}

func (mmGetSourceByFileUID *mRepositoryMockGetSourceByFileUID) invocationsDone() bool {
	if len(mmGetSourceByFileUID.expectations) == 0 && mmGetSourceByFileUID.defaultExpectation == nil && mmGetSourceByFileUID.mock.funcGetSourceByFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetSourceByFileUID.mock.afterGetSourceByFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetSourceByFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetSourceByFileUID implements mm_repository.Repository
func (mmGetSourceByFileUID *RepositoryMock) GetSourceByFileUID(ctx context.Context, fileUID types.FileUIDType) (sp1 *mm_repository.SourceMeta, err error) {
	mm_atomic.AddUint64(&mmGetSourceByFileUID.beforeGetSourceByFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSourceByFileUID.afterGetSourceByFileUIDCounter, 1)

	mmGetSourceByFileUID.t.Helper()

	if mmGetSourceByFileUID.inspectFuncGetSourceByFileUID != nil {
		mmGetSourceByFileUID.inspectFuncGetSourceByFileUID(ctx, fileUID)
	}

	mm_params := RepositoryMockGetSourceByFileUIDParams{ctx, fileUID}

	// Record call args
	mmGetSourceByFileUID.GetSourceByFileUIDMock.mutex.Lock()
	mmGetSourceByFileUID.GetSourceByFileUIDMock.callArgs = append(mmGetSourceByFileUID.GetSourceByFileUIDMock.callArgs, &mm_params)
	mmGetSourceByFileUID.GetSourceByFileUIDMock.mutex.Unlock()

	for _, e := range mmGetSourceByFileUID.GetSourceByFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGetSourceByFileUID.GetSourceByFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSourceByFileUID.GetSourceByFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSourceByFileUID.GetSourceByFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetSourceByFileUID.GetSourceByFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetSourceByFileUIDParams{ctx, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetSourceByFileUID.t.Errorf("RepositoryMock.GetSourceByFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetSourceByFileUID.GetSourceByFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmGetSourceByFileUID.t.Errorf("RepositoryMock.GetSourceByFileUID got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetSourceByFileUID.GetSourceByFileUIDMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSourceByFileUID.t.Errorf("RepositoryMock.GetSourceByFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetSourceByFileUID.GetSourceByFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSourceByFileUID.GetSourceByFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSourceByFileUID.t.Fatal("No results are set for the RepositoryMock.GetSourceByFileUID")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGetSourceByFileUID.funcGetSourceByFileUID != nil {
		return mmGetSourceByFileUID.funcGetSourceByFileUID(ctx, fileUID)
	}
	mmGetSourceByFileUID.t.Fatalf("Unexpected call to RepositoryMock.GetSourceByFileUID. %v %v", ctx, fileUID)
	return
}

// GetSourceByFileUIDAfterCounter returns a count of finished RepositoryMock.GetSourceByFileUID invocations
func (mmGetSourceByFileUID *RepositoryMock) GetSourceByFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSourceByFileUID.afterGetSourceByFileUIDCounter)
}

// GetSourceByFileUIDBeforeCounter returns a count of RepositoryMock.GetSourceByFileUID invocations
func (mmGetSourceByFileUID *RepositoryMock) GetSourceByFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSourceByFileUID.beforeGetSourceByFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetSourceByFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSourceByFileUID *mRepositoryMockGetSourceByFileUID) Calls() []*RepositoryMockGetSourceByFileUIDParams {
	mmGetSourceByFileUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetSourceByFileUIDParams, len(mmGetSourceByFileUID.callArgs))
	copy(argCopy, mmGetSourceByFileUID.callArgs)

	mmGetSourceByFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetSourceByFileUIDDone returns true if the count of the GetSourceByFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetSourceByFileUIDDone() bool {
	if m.GetSourceByFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetSourceByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetSourceByFileUIDMock.invocationsDone()
}

// MinimockGetSourceByFileUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetSourceByFileUIDInspect() {
	for _, e := range m.GetSourceByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetSourceByFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetSourceByFileUIDCounter := mm_atomic.LoadUint64(&m.afterGetSourceByFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetSourceByFileUIDMock.defaultExpectation != nil && afterGetSourceByFileUIDCounter < 1 {
		if m.GetSourceByFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetSourceByFileUID at\n%s", m.GetSourceByFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetSourceByFileUID at\n%s with params: %#v", m.GetSourceByFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetSourceByFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSourceByFileUID != nil && afterGetSourceByFileUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetSourceByFileUID at\n%s", m.funcGetSourceByFileUIDOrigin)
	}

	if !m.GetSourceByFileUIDMock.invocationsDone() && afterGetSourceByFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetSourceByFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetSourceByFileUIDMock.expectedInvocations), m.GetSourceByFileUIDMock.expectedInvocationsOrigin, afterGetSourceByFileUIDCounter)
	}
}

type mRepositoryMockGetStagingKBForProduction struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetStagingKBForProductionExpectation
	expectations       []*RepositoryMockGetStagingKBForProductionExpectation

	callArgs []*RepositoryMockGetStagingKBForProductionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetStagingKBForProductionExpectation specifies expectation struct of the Repository.GetStagingKBForProduction
type RepositoryMockGetStagingKBForProductionExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetStagingKBForProductionParams
	paramPtrs          *RepositoryMockGetStagingKBForProductionParamPtrs
	expectationOrigins RepositoryMockGetStagingKBForProductionExpectationOrigins
	results            *RepositoryMockGetStagingKBForProductionResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetStagingKBForProductionParams contains parameters of the Repository.GetStagingKBForProduction
type RepositoryMockGetStagingKBForProductionParams struct {
	ctx            context.Context
	ownerUID       types.OwnerUIDType
	productionKBID string
}

// RepositoryMockGetStagingKBForProductionParamPtrs contains pointers to parameters of the Repository.GetStagingKBForProduction
type RepositoryMockGetStagingKBForProductionParamPtrs struct {
	ctx            *context.Context
	ownerUID       *types.OwnerUIDType
	productionKBID *string
}

// RepositoryMockGetStagingKBForProductionResults contains results of the Repository.GetStagingKBForProduction
type RepositoryMockGetStagingKBForProductionResults struct {
	kp1 *mm_repository.KnowledgeBaseModel
	err error
}

// RepositoryMockGetStagingKBForProductionOrigins contains origins of expectations of the Repository.GetStagingKBForProduction
type RepositoryMockGetStagingKBForProductionExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerUID       string
	originProductionKBID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetStagingKBForProduction *mRepositoryMockGetStagingKBForProduction) Optional() *mRepositoryMockGetStagingKBForProduction {
	mmGetStagingKBForProduction.optional = true
	return mmGetStagingKBForProduction
}

// Expect sets up expected params for Repository.GetStagingKBForProduction
func (mmGetStagingKBForProduction *mRepositoryMockGetStagingKBForProduction) Expect(ctx context.Context, ownerUID types.OwnerUIDType, productionKBID string) *mRepositoryMockGetStagingKBForProduction {
	if mmGetStagingKBForProduction.mock.funcGetStagingKBForProduction != nil {
		mmGetStagingKBForProduction.mock.t.Fatalf("RepositoryMock.GetStagingKBForProduction mock is already set by Set")
	}

	if mmGetStagingKBForProduction.defaultExpectation == nil {
		mmGetStagingKBForProduction.defaultExpectation = &RepositoryMockGetStagingKBForProductionExpectation{}
	}

	if mmGetStagingKBForProduction.defaultExpectation.paramPtrs != nil {
		mmGetStagingKBForProduction.mock.t.Fatalf("RepositoryMock.GetStagingKBForProduction mock is already set by ExpectParams functions")
	}

	mmGetStagingKBForProduction.defaultExpectation.params = &RepositoryMockGetStagingKBForProductionParams{ctx, ownerUID, productionKBID}
	mmGetStagingKBForProduction.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetStagingKBForProduction.expectations {
		if minimock.Equal(e.params, mmGetStagingKBForProduction.defaultExpectation.params) {
			mmGetStagingKBForProduction.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetStagingKBForProduction.defaultExpectation.params)
		}
	}

	return mmGetStagingKBForProduction
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetStagingKBForProduction
func (mmGetStagingKBForProduction *mRepositoryMockGetStagingKBForProduction) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetStagingKBForProduction {
	if mmGetStagingKBForProduction.mock.funcGetStagingKBForProduction != nil {
		mmGetStagingKBForProduction.mock.t.Fatalf("RepositoryMock.GetStagingKBForProduction mock is already set by Set")
	}

	if mmGetStagingKBForProduction.defaultExpectation == nil {
		mmGetStagingKBForProduction.defaultExpectation = &RepositoryMockGetStagingKBForProductionExpectation{}
	}

	if mmGetStagingKBForProduction.defaultExpectation.params != nil {
		mmGetStagingKBForProduction.mock.t.Fatalf("RepositoryMock.GetStagingKBForProduction mock is already set by Expect")
	}

	if mmGetStagingKBForProduction.defaultExpectation.paramPtrs == nil {
		mmGetStagingKBForProduction.defaultExpectation.paramPtrs = &RepositoryMockGetStagingKBForProductionParamPtrs{}
	}
	mmGetStagingKBForProduction.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetStagingKBForProduction.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetStagingKBForProduction
}

// ExpectOwnerUIDParam2 sets up expected param ownerUID for Repository.GetStagingKBForProduction
func (mmGetStagingKBForProduction *mRepositoryMockGetStagingKBForProduction) ExpectOwnerUIDParam2(ownerUID types.OwnerUIDType) *mRepositoryMockGetStagingKBForProduction {
	if mmGetStagingKBForProduction.mock.funcGetStagingKBForProduction != nil {
		mmGetStagingKBForProduction.mock.t.Fatalf("RepositoryMock.GetStagingKBForProduction mock is already set by Set")
	}

	if mmGetStagingKBForProduction.defaultExpectation == nil {
		mmGetStagingKBForProduction.defaultExpectation = &RepositoryMockGetStagingKBForProductionExpectation{}
	}

	if mmGetStagingKBForProduction.defaultExpectation.params != nil {
		mmGetStagingKBForProduction.mock.t.Fatalf("RepositoryMock.GetStagingKBForProduction mock is already set by Expect")
	}

	if mmGetStagingKBForProduction.defaultExpectation.paramPtrs == nil {
		mmGetStagingKBForProduction.defaultExpectation.paramPtrs = &RepositoryMockGetStagingKBForProductionParamPtrs{}
	}
	mmGetStagingKBForProduction.defaultExpectation.paramPtrs.ownerUID = &ownerUID
	mmGetStagingKBForProduction.defaultExpectation.expectationOrigins.originOwnerUID = minimock.CallerInfo(1)

	return mmGetStagingKBForProduction
}

// ExpectProductionKBIDParam3 sets up expected param productionKBID for Repository.GetStagingKBForProduction
func (mmGetStagingKBForProduction *mRepositoryMockGetStagingKBForProduction) ExpectProductionKBIDParam3(productionKBID string) *mRepositoryMockGetStagingKBForProduction {
	if mmGetStagingKBForProduction.mock.funcGetStagingKBForProduction != nil {
		mmGetStagingKBForProduction.mock.t.Fatalf("RepositoryMock.GetStagingKBForProduction mock is already set by Set")
	}

	if mmGetStagingKBForProduction.defaultExpectation == nil {
		mmGetStagingKBForProduction.defaultExpectation = &RepositoryMockGetStagingKBForProductionExpectation{}
	}

	if mmGetStagingKBForProduction.defaultExpectation.params != nil {
		mmGetStagingKBForProduction.mock.t.Fatalf("RepositoryMock.GetStagingKBForProduction mock is already set by Expect")
	}

	if mmGetStagingKBForProduction.defaultExpectation.paramPtrs == nil {
		mmGetStagingKBForProduction.defaultExpectation.paramPtrs = &RepositoryMockGetStagingKBForProductionParamPtrs{}
	}
	mmGetStagingKBForProduction.defaultExpectation.paramPtrs.productionKBID = &productionKBID
	mmGetStagingKBForProduction.defaultExpectation.expectationOrigins.originProductionKBID = minimock.CallerInfo(1)

	return mmGetStagingKBForProduction
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetStagingKBForProduction
func (mmGetStagingKBForProduction *mRepositoryMockGetStagingKBForProduction) Inspect(f func(ctx context.Context, ownerUID types.OwnerUIDType, productionKBID string)) *mRepositoryMockGetStagingKBForProduction {
	if mmGetStagingKBForProduction.mock.inspectFuncGetStagingKBForProduction != nil {
		mmGetStagingKBForProduction.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetStagingKBForProduction")
	}

	mmGetStagingKBForProduction.mock.inspectFuncGetStagingKBForProduction = f

	return mmGetStagingKBForProduction
}

// Return sets up results that will be returned by Repository.GetStagingKBForProduction
func (mmGetStagingKBForProduction *mRepositoryMockGetStagingKBForProduction) Return(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	if mmGetStagingKBForProduction.mock.funcGetStagingKBForProduction != nil {
		mmGetStagingKBForProduction.mock.t.Fatalf("RepositoryMock.GetStagingKBForProduction mock is already set by Set")
	}

	if mmGetStagingKBForProduction.defaultExpectation == nil {
		mmGetStagingKBForProduction.defaultExpectation = &RepositoryMockGetStagingKBForProductionExpectation{mock: mmGetStagingKBForProduction.mock}
	}
	mmGetStagingKBForProduction.defaultExpectation.results = &RepositoryMockGetStagingKBForProductionResults{kp1, err}
	mmGetStagingKBForProduction.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetStagingKBForProduction.mock
}

// Set uses given function f to mock the Repository.GetStagingKBForProduction method
func (mmGetStagingKBForProduction *mRepositoryMockGetStagingKBForProduction) Set(f func(ctx context.Context, ownerUID types.OwnerUIDType, productionKBID string) (kp1 *mm_repository.KnowledgeBaseModel, err error)) *RepositoryMock {
	if mmGetStagingKBForProduction.defaultExpectation != nil {
		mmGetStagingKBForProduction.mock.t.Fatalf("Default expectation is already set for the Repository.GetStagingKBForProduction method")
	}

	if len(mmGetStagingKBForProduction.expectations) > 0 {
		mmGetStagingKBForProduction.mock.t.Fatalf("Some expectations are already set for the Repository.GetStagingKBForProduction method")
	}

	mmGetStagingKBForProduction.mock.funcGetStagingKBForProduction = f
	mmGetStagingKBForProduction.mock.funcGetStagingKBForProductionOrigin = minimock.CallerInfo(1)
	return mmGetStagingKBForProduction.mock
}

// When sets expectation for the Repository.GetStagingKBForProduction which will trigger the result defined by the following
// Then helper
func (mmGetStagingKBForProduction *mRepositoryMockGetStagingKBForProduction) When(ctx context.Context, ownerUID types.OwnerUIDType, productionKBID string) *RepositoryMockGetStagingKBForProductionExpectation {
	if mmGetStagingKBForProduction.mock.funcGetStagingKBForProduction != nil {
		mmGetStagingKBForProduction.mock.t.Fatalf("RepositoryMock.GetStagingKBForProduction mock is already set by Set")
	}

	expectation := &RepositoryMockGetStagingKBForProductionExpectation{
		mock:               mmGetStagingKBForProduction.mock,
		params:             &RepositoryMockGetStagingKBForProductionParams{ctx, ownerUID, productionKBID},
		expectationOrigins: RepositoryMockGetStagingKBForProductionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetStagingKBForProduction.expectations = append(mmGetStagingKBForProduction.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetStagingKBForProduction return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetStagingKBForProductionExpectation) Then(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetStagingKBForProductionResults{kp1, err}
	return e.mock
}

// Times sets number of times Repository.GetStagingKBForProduction should be invoked
func (mmGetStagingKBForProduction *mRepositoryMockGetStagingKBForProduction) Times(n uint64) *mRepositoryMockGetStagingKBForProduction {
	if n == 0 {
		mmGetStagingKBForProduction.mock.t.Fatalf("Times of RepositoryMock.GetStagingKBForProduction mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetStagingKBForProduction.expectedInvocations, n)
	mmGetStagingKBForProduction.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetStagingKBForProduction
}

func (mmGetStagingKBForProduction *mRepositoryMockGetStagingKBForProduction) invocationsDone() bool {
	if len(mmGetStagingKBForProduction.expectations) == 0 && mmGetStagingKBForProduction.defaultExpectation == nil && mmGetStagingKBForProduction.mock.funcGetStagingKBForProduction == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetStagingKBForProduction.mock.afterGetStagingKBForProductionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetStagingKBForProduction.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetStagingKBForProduction implements mm_repository.Repository
func (mmGetStagingKBForProduction *RepositoryMock) GetStagingKBForProduction(ctx context.Context, ownerUID types.OwnerUIDType, productionKBID string) (kp1 *mm_repository.KnowledgeBaseModel, err error) {
	mm_atomic.AddUint64(&mmGetStagingKBForProduction.beforeGetStagingKBForProductionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetStagingKBForProduction.afterGetStagingKBForProductionCounter, 1)

	mmGetStagingKBForProduction.t.Helper()

	if mmGetStagingKBForProduction.inspectFuncGetStagingKBForProduction != nil {
		mmGetStagingKBForProduction.inspectFuncGetStagingKBForProduction(ctx, ownerUID, productionKBID)
	}

	mm_params := RepositoryMockGetStagingKBForProductionParams{ctx, ownerUID, productionKBID}

	// Record call args
	mmGetStagingKBForProduction.GetStagingKBForProductionMock.mutex.Lock()
	mmGetStagingKBForProduction.GetStagingKBForProductionMock.callArgs = append(mmGetStagingKBForProduction.GetStagingKBForProductionMock.callArgs, &mm_params)
	mmGetStagingKBForProduction.GetStagingKBForProductionMock.mutex.Unlock()

	for _, e := range mmGetStagingKBForProduction.GetStagingKBForProductionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmGetStagingKBForProduction.GetStagingKBForProductionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetStagingKBForProduction.GetStagingKBForProductionMock.defaultExpectation.Counter, 1)
		mm_want := mmGetStagingKBForProduction.GetStagingKBForProductionMock.defaultExpectation.params
		mm_want_ptrs := mmGetStagingKBForProduction.GetStagingKBForProductionMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetStagingKBForProductionParams{ctx, ownerUID, productionKBID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetStagingKBForProduction.t.Errorf("RepositoryMock.GetStagingKBForProduction got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetStagingKBForProduction.GetStagingKBForProductionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmGetStagingKBForProduction.t.Errorf("RepositoryMock.GetStagingKBForProduction got unexpected parameter ownerUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetStagingKBForProduction.GetStagingKBForProductionMock.defaultExpectation.expectationOrigins.originOwnerUID, *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

			if mm_want_ptrs.productionKBID != nil && !minimock.Equal(*mm_want_ptrs.productionKBID, mm_got.productionKBID) {
				mmGetStagingKBForProduction.t.Errorf("RepositoryMock.GetStagingKBForProduction got unexpected parameter productionKBID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetStagingKBForProduction.GetStagingKBForProductionMock.defaultExpectation.expectationOrigins.originProductionKBID, *mm_want_ptrs.productionKBID, mm_got.productionKBID, minimock.Diff(*mm_want_ptrs.productionKBID, mm_got.productionKBID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetStagingKBForProduction.t.Errorf("RepositoryMock.GetStagingKBForProduction got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetStagingKBForProduction.GetStagingKBForProductionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetStagingKBForProduction.GetStagingKBForProductionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetStagingKBForProduction.t.Fatal("No results are set for the RepositoryMock.GetStagingKBForProduction")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmGetStagingKBForProduction.funcGetStagingKBForProduction != nil {
		return mmGetStagingKBForProduction.funcGetStagingKBForProduction(ctx, ownerUID, productionKBID)
	}
	mmGetStagingKBForProduction.t.Fatalf("Unexpected call to RepositoryMock.GetStagingKBForProduction. %v %v %v", ctx, ownerUID, productionKBID)
	return
}

// GetStagingKBForProductionAfterCounter returns a count of finished RepositoryMock.GetStagingKBForProduction invocations
func (mmGetStagingKBForProduction *RepositoryMock) GetStagingKBForProductionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStagingKBForProduction.afterGetStagingKBForProductionCounter)
}

// GetStagingKBForProductionBeforeCounter returns a count of RepositoryMock.GetStagingKBForProduction invocations
func (mmGetStagingKBForProduction *RepositoryMock) GetStagingKBForProductionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStagingKBForProduction.beforeGetStagingKBForProductionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetStagingKBForProduction.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetStagingKBForProduction *mRepositoryMockGetStagingKBForProduction) Calls() []*RepositoryMockGetStagingKBForProductionParams {
	mmGetStagingKBForProduction.mutex.RLock()

	argCopy := make([]*RepositoryMockGetStagingKBForProductionParams, len(mmGetStagingKBForProduction.callArgs))
	copy(argCopy, mmGetStagingKBForProduction.callArgs)

	mmGetStagingKBForProduction.mutex.RUnlock()

	return argCopy
}

// MinimockGetStagingKBForProductionDone returns true if the count of the GetStagingKBForProduction invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetStagingKBForProductionDone() bool {
	if m.GetStagingKBForProductionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetStagingKBForProductionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetStagingKBForProductionMock.invocationsDone()
}

// MinimockGetStagingKBForProductionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetStagingKBForProductionInspect() {
	for _, e := range m.GetStagingKBForProductionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetStagingKBForProduction at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetStagingKBForProductionCounter := mm_atomic.LoadUint64(&m.afterGetStagingKBForProductionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetStagingKBForProductionMock.defaultExpectation != nil && afterGetStagingKBForProductionCounter < 1 {
		if m.GetStagingKBForProductionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetStagingKBForProduction at\n%s", m.GetStagingKBForProductionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetStagingKBForProduction at\n%s with params: %#v", m.GetStagingKBForProductionMock.defaultExpectation.expectationOrigins.origin, *m.GetStagingKBForProductionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStagingKBForProduction != nil && afterGetStagingKBForProductionCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetStagingKBForProduction at\n%s", m.funcGetStagingKBForProductionOrigin)
	}

	if !m.GetStagingKBForProductionMock.invocationsDone() && afterGetStagingKBForProductionCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetStagingKBForProduction at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetStagingKBForProductionMock.expectedInvocations), m.GetStagingKBForProductionMock.expectedInvocationsOrigin, afterGetStagingKBForProductionCounter)
	}
}

type mRepositoryMockGetSystem struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetSystemExpectation
	expectations       []*RepositoryMockGetSystemExpectation

	callArgs []*RepositoryMockGetSystemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetSystemExpectation specifies expectation struct of the Repository.GetSystem
type RepositoryMockGetSystemExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetSystemParams
	paramPtrs          *RepositoryMockGetSystemParamPtrs
	expectationOrigins RepositoryMockGetSystemExpectationOrigins
	results            *RepositoryMockGetSystemResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetSystemParams contains parameters of the Repository.GetSystem
type RepositoryMockGetSystemParams struct {
	ctx context.Context
	id  string
}

// RepositoryMockGetSystemParamPtrs contains pointers to parameters of the Repository.GetSystem
type RepositoryMockGetSystemParamPtrs struct {
	ctx *context.Context
	id  *string
}

// RepositoryMockGetSystemResults contains results of the Repository.GetSystem
type RepositoryMockGetSystemResults struct {
	sp1 *mm_repository.SystemModel
	err error
}

// RepositoryMockGetSystemOrigins contains origins of expectations of the Repository.GetSystem
type RepositoryMockGetSystemExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetSystem *mRepositoryMockGetSystem) Optional() *mRepositoryMockGetSystem {
	mmGetSystem.optional = true
	return mmGetSystem
}

// Expect sets up expected params for Repository.GetSystem
func (mmGetSystem *mRepositoryMockGetSystem) Expect(ctx context.Context, id string) *mRepositoryMockGetSystem {
	if mmGetSystem.mock.funcGetSystem != nil {
		mmGetSystem.mock.t.Fatalf("RepositoryMock.GetSystem mock is already set by Set")
	}

	if mmGetSystem.defaultExpectation == nil {
		mmGetSystem.defaultExpectation = &RepositoryMockGetSystemExpectation{}
	}

	if mmGetSystem.defaultExpectation.paramPtrs != nil {
		mmGetSystem.mock.t.Fatalf("RepositoryMock.GetSystem mock is already set by ExpectParams functions")
	}

	mmGetSystem.defaultExpectation.params = &RepositoryMockGetSystemParams{ctx, id}
	mmGetSystem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetSystem.expectations {
		if minimock.Equal(e.params, mmGetSystem.defaultExpectation.params) {
			mmGetSystem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSystem.defaultExpectation.params)
		}
	}

	return mmGetSystem
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetSystem
func (mmGetSystem *mRepositoryMockGetSystem) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetSystem {
	if mmGetSystem.mock.funcGetSystem != nil {
		mmGetSystem.mock.t.Fatalf("RepositoryMock.GetSystem mock is already set by Set")
	}

	if mmGetSystem.defaultExpectation == nil {
		mmGetSystem.defaultExpectation = &RepositoryMockGetSystemExpectation{}
	}

	if mmGetSystem.defaultExpectation.params != nil {
		mmGetSystem.mock.t.Fatalf("RepositoryMock.GetSystem mock is already set by Expect")
	}

	if mmGetSystem.defaultExpectation.paramPtrs == nil {
		mmGetSystem.defaultExpectation.paramPtrs = &RepositoryMockGetSystemParamPtrs{}
	}
	mmGetSystem.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetSystem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetSystem
}

// ExpectIdParam2 sets up expected param id for Repository.GetSystem
func (mmGetSystem *mRepositoryMockGetSystem) ExpectIdParam2(id string) *mRepositoryMockGetSystem {
	if mmGetSystem.mock.funcGetSystem != nil {
		mmGetSystem.mock.t.Fatalf("RepositoryMock.GetSystem mock is already set by Set")
	}

	if mmGetSystem.defaultExpectation == nil {
		mmGetSystem.defaultExpectation = &RepositoryMockGetSystemExpectation{}
	}

	if mmGetSystem.defaultExpectation.params != nil {
		mmGetSystem.mock.t.Fatalf("RepositoryMock.GetSystem mock is already set by Expect")
	}

	if mmGetSystem.defaultExpectation.paramPtrs == nil {
		mmGetSystem.defaultExpectation.paramPtrs = &RepositoryMockGetSystemParamPtrs{}
	}
	mmGetSystem.defaultExpectation.paramPtrs.id = &id
	mmGetSystem.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetSystem
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetSystem
func (mmGetSystem *mRepositoryMockGetSystem) Inspect(f func(ctx context.Context, id string)) *mRepositoryMockGetSystem {
	if mmGetSystem.mock.inspectFuncGetSystem != nil {
		mmGetSystem.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetSystem")
	}

	mmGetSystem.mock.inspectFuncGetSystem = f

	return mmGetSystem
}

// Return sets up results that will be returned by Repository.GetSystem
func (mmGetSystem *mRepositoryMockGetSystem) Return(sp1 *mm_repository.SystemModel, err error) *RepositoryMock {
	if mmGetSystem.mock.funcGetSystem != nil {
		mmGetSystem.mock.t.Fatalf("RepositoryMock.GetSystem mock is already set by Set")
	}

	if mmGetSystem.defaultExpectation == nil {
		mmGetSystem.defaultExpectation = &RepositoryMockGetSystemExpectation{mock: mmGetSystem.mock}
	}
	mmGetSystem.defaultExpectation.results = &RepositoryMockGetSystemResults{sp1, err}
	mmGetSystem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetSystem.mock
}

// Set uses given function f to mock the Repository.GetSystem method
func (mmGetSystem *mRepositoryMockGetSystem) Set(f func(ctx context.Context, id string) (sp1 *mm_repository.SystemModel, err error)) *RepositoryMock {
	if mmGetSystem.defaultExpectation != nil {
		mmGetSystem.mock.t.Fatalf("Default expectation is already set for the Repository.GetSystem method")
	}

	if len(mmGetSystem.expectations) > 0 {
		mmGetSystem.mock.t.Fatalf("Some expectations are already set for the Repository.GetSystem method")
	}

	mmGetSystem.mock.funcGetSystem = f
	mmGetSystem.mock.funcGetSystemOrigin = minimock.CallerInfo(1)
	return mmGetSystem.mock
}

// When sets expectation for the Repository.GetSystem which will trigger the result defined by the following
// Then helper
func (mmGetSystem *mRepositoryMockGetSystem) When(ctx context.Context, id string) *RepositoryMockGetSystemExpectation {
	if mmGetSystem.mock.funcGetSystem != nil {
		mmGetSystem.mock.t.Fatalf("RepositoryMock.GetSystem mock is already set by Set")
	}

	expectation := &RepositoryMockGetSystemExpectation{
		mock:               mmGetSystem.mock,
		params:             &RepositoryMockGetSystemParams{ctx, id},
		expectationOrigins: RepositoryMockGetSystemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetSystem.expectations = append(mmGetSystem.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetSystem return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetSystemExpectation) Then(sp1 *mm_repository.SystemModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetSystemResults{sp1, err}
	return e.mock
}

// Times sets number of times Repository.GetSystem should be invoked
func (mmGetSystem *mRepositoryMockGetSystem) Times(n uint64) *mRepositoryMockGetSystem {
	if n == 0 {
		mmGetSystem.mock.t.Fatalf("Times of RepositoryMock.GetSystem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetSystem.expectedInvocations, n)
	mmGetSystem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetSystem
}

func (mmGetSystem *mRepositoryMockGetSystem) invocationsDone() bool {
	if len(mmGetSystem.expectations) == 0 && mmGetSystem.defaultExpectation == nil && mmGetSystem.mock.funcGetSystem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetSystem.mock.afterGetSystemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetSystem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetSystem implements mm_repository.Repository
func (mmGetSystem *RepositoryMock) GetSystem(ctx context.Context, id string) (sp1 *mm_repository.SystemModel, err error) {
	mm_atomic.AddUint64(&mmGetSystem.beforeGetSystemCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSystem.afterGetSystemCounter, 1)

	mmGetSystem.t.Helper()

	if mmGetSystem.inspectFuncGetSystem != nil {
		mmGetSystem.inspectFuncGetSystem(ctx, id)
	}

	mm_params := RepositoryMockGetSystemParams{ctx, id}

	// Record call args
	mmGetSystem.GetSystemMock.mutex.Lock()
	mmGetSystem.GetSystemMock.callArgs = append(mmGetSystem.GetSystemMock.callArgs, &mm_params)
	mmGetSystem.GetSystemMock.mutex.Unlock()

	for _, e := range mmGetSystem.GetSystemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGetSystem.GetSystemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSystem.GetSystemMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSystem.GetSystemMock.defaultExpectation.params
		mm_want_ptrs := mmGetSystem.GetSystemMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetSystemParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetSystem.t.Errorf("RepositoryMock.GetSystem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetSystem.GetSystemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetSystem.t.Errorf("RepositoryMock.GetSystem got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetSystem.GetSystemMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSystem.t.Errorf("RepositoryMock.GetSystem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetSystem.GetSystemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSystem.GetSystemMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSystem.t.Fatal("No results are set for the RepositoryMock.GetSystem")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGetSystem.funcGetSystem != nil {
		return mmGetSystem.funcGetSystem(ctx, id)
	}
	mmGetSystem.t.Fatalf("Unexpected call to RepositoryMock.GetSystem. %v %v", ctx, id)
	return
}

// GetSystemAfterCounter returns a count of finished RepositoryMock.GetSystem invocations
func (mmGetSystem *RepositoryMock) GetSystemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSystem.afterGetSystemCounter)
}

// GetSystemBeforeCounter returns a count of RepositoryMock.GetSystem invocations
func (mmGetSystem *RepositoryMock) GetSystemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSystem.beforeGetSystemCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetSystem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSystem *mRepositoryMockGetSystem) Calls() []*RepositoryMockGetSystemParams {
	mmGetSystem.mutex.RLock()

	argCopy := make([]*RepositoryMockGetSystemParams, len(mmGetSystem.callArgs))
	copy(argCopy, mmGetSystem.callArgs)

	mmGetSystem.mutex.RUnlock()

	return argCopy
}

// MinimockGetSystemDone returns true if the count of the GetSystem invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetSystemDone() bool {
	if m.GetSystemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetSystemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetSystemMock.invocationsDone()
}

// MinimockGetSystemInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetSystemInspect() {
	for _, e := range m.GetSystemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetSystem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetSystemCounter := mm_atomic.LoadUint64(&m.afterGetSystemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetSystemMock.defaultExpectation != nil && afterGetSystemCounter < 1 {
		if m.GetSystemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetSystem at\n%s", m.GetSystemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetSystem at\n%s with params: %#v", m.GetSystemMock.defaultExpectation.expectationOrigins.origin, *m.GetSystemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSystem != nil && afterGetSystemCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetSystem at\n%s", m.funcGetSystemOrigin)
	}

	if !m.GetSystemMock.invocationsDone() && afterGetSystemCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetSystem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetSystemMock.expectedInvocations), m.GetSystemMock.expectedInvocationsOrigin, afterGetSystemCounter)
	}
}

type mRepositoryMockGetSystemByUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetSystemByUIDExpectation
	expectations       []*RepositoryMockGetSystemByUIDExpectation

	callArgs []*RepositoryMockGetSystemByUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetSystemByUIDExpectation specifies expectation struct of the Repository.GetSystemByUID
type RepositoryMockGetSystemByUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetSystemByUIDParams
	paramPtrs          *RepositoryMockGetSystemByUIDParamPtrs
	expectationOrigins RepositoryMockGetSystemByUIDExpectationOrigins
	results            *RepositoryMockGetSystemByUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetSystemByUIDParams contains parameters of the Repository.GetSystemByUID
type RepositoryMockGetSystemByUIDParams struct {
	ctx context.Context
	uid types.SystemUIDType
}

// RepositoryMockGetSystemByUIDParamPtrs contains pointers to parameters of the Repository.GetSystemByUID
type RepositoryMockGetSystemByUIDParamPtrs struct {
	ctx *context.Context
	uid *types.SystemUIDType
}

// RepositoryMockGetSystemByUIDResults contains results of the Repository.GetSystemByUID
type RepositoryMockGetSystemByUIDResults struct {
	sp1 *mm_repository.SystemModel
	err error
}

// RepositoryMockGetSystemByUIDOrigins contains origins of expectations of the Repository.GetSystemByUID
type RepositoryMockGetSystemByUIDExpectationOrigins struct {
	origin    string
	originCtx string
	originUid string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetSystemByUID *mRepositoryMockGetSystemByUID) Optional() *mRepositoryMockGetSystemByUID {
	mmGetSystemByUID.optional = true
	return mmGetSystemByUID
}

// Expect sets up expected params for Repository.GetSystemByUID
func (mmGetSystemByUID *mRepositoryMockGetSystemByUID) Expect(ctx context.Context, uid types.SystemUIDType) *mRepositoryMockGetSystemByUID {
	if mmGetSystemByUID.mock.funcGetSystemByUID != nil {
		mmGetSystemByUID.mock.t.Fatalf("RepositoryMock.GetSystemByUID mock is already set by Set")
	}

	if mmGetSystemByUID.defaultExpectation == nil {
		mmGetSystemByUID.defaultExpectation = &RepositoryMockGetSystemByUIDExpectation{}
	}

	if mmGetSystemByUID.defaultExpectation.paramPtrs != nil {
		mmGetSystemByUID.mock.t.Fatalf("RepositoryMock.GetSystemByUID mock is already set by ExpectParams functions")
	}

	mmGetSystemByUID.defaultExpectation.params = &RepositoryMockGetSystemByUIDParams{ctx, uid}
	mmGetSystemByUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetSystemByUID.expectations {
		if minimock.Equal(e.params, mmGetSystemByUID.defaultExpectation.params) {
			mmGetSystemByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSystemByUID.defaultExpectation.params)
		}
	}

	return mmGetSystemByUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetSystemByUID
func (mmGetSystemByUID *mRepositoryMockGetSystemByUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetSystemByUID {
	if mmGetSystemByUID.mock.funcGetSystemByUID != nil {
		mmGetSystemByUID.mock.t.Fatalf("RepositoryMock.GetSystemByUID mock is already set by Set")
	}

	if mmGetSystemByUID.defaultExpectation == nil {
		mmGetSystemByUID.defaultExpectation = &RepositoryMockGetSystemByUIDExpectation{}
	}

	if mmGetSystemByUID.defaultExpectation.params != nil {
		mmGetSystemByUID.mock.t.Fatalf("RepositoryMock.GetSystemByUID mock is already set by Expect")
	}

	if mmGetSystemByUID.defaultExpectation.paramPtrs == nil {
		mmGetSystemByUID.defaultExpectation.paramPtrs = &RepositoryMockGetSystemByUIDParamPtrs{}
	}
	mmGetSystemByUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetSystemByUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetSystemByUID
}

// ExpectUidParam2 sets up expected param uid for Repository.GetSystemByUID
func (mmGetSystemByUID *mRepositoryMockGetSystemByUID) ExpectUidParam2(uid types.SystemUIDType) *mRepositoryMockGetSystemByUID {
	if mmGetSystemByUID.mock.funcGetSystemByUID != nil {
		mmGetSystemByUID.mock.t.Fatalf("RepositoryMock.GetSystemByUID mock is already set by Set")
	}

	if mmGetSystemByUID.defaultExpectation == nil {
		mmGetSystemByUID.defaultExpectation = &RepositoryMockGetSystemByUIDExpectation{}
	}

	if mmGetSystemByUID.defaultExpectation.params != nil {
		mmGetSystemByUID.mock.t.Fatalf("RepositoryMock.GetSystemByUID mock is already set by Expect")
	}

	if mmGetSystemByUID.defaultExpectation.paramPtrs == nil {
		mmGetSystemByUID.defaultExpectation.paramPtrs = &RepositoryMockGetSystemByUIDParamPtrs{}
	}
	mmGetSystemByUID.defaultExpectation.paramPtrs.uid = &uid
	mmGetSystemByUID.defaultExpectation.expectationOrigins.originUid = minimock.CallerInfo(1)

	return mmGetSystemByUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetSystemByUID
func (mmGetSystemByUID *mRepositoryMockGetSystemByUID) Inspect(f func(ctx context.Context, uid types.SystemUIDType)) *mRepositoryMockGetSystemByUID {
	if mmGetSystemByUID.mock.inspectFuncGetSystemByUID != nil {
		mmGetSystemByUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetSystemByUID")
	}

	mmGetSystemByUID.mock.inspectFuncGetSystemByUID = f

	return mmGetSystemByUID
}

// Return sets up results that will be returned by Repository.GetSystemByUID
func (mmGetSystemByUID *mRepositoryMockGetSystemByUID) Return(sp1 *mm_repository.SystemModel, err error) *RepositoryMock {
	if mmGetSystemByUID.mock.funcGetSystemByUID != nil {
		mmGetSystemByUID.mock.t.Fatalf("RepositoryMock.GetSystemByUID mock is already set by Set")
	}

	if mmGetSystemByUID.defaultExpectation == nil {
		mmGetSystemByUID.defaultExpectation = &RepositoryMockGetSystemByUIDExpectation{mock: mmGetSystemByUID.mock}
	}
	mmGetSystemByUID.defaultExpectation.results = &RepositoryMockGetSystemByUIDResults{sp1, err}
	mmGetSystemByUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetSystemByUID.mock
}

// Set uses given function f to mock the Repository.GetSystemByUID method
func (mmGetSystemByUID *mRepositoryMockGetSystemByUID) Set(f func(ctx context.Context, uid types.SystemUIDType) (sp1 *mm_repository.SystemModel, err error)) *RepositoryMock {
	if mmGetSystemByUID.defaultExpectation != nil {
		mmGetSystemByUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetSystemByUID method")
	}

	if len(mmGetSystemByUID.expectations) > 0 {
		mmGetSystemByUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetSystemByUID method")
	}

	mmGetSystemByUID.mock.funcGetSystemByUID = f
	mmGetSystemByUID.mock.funcGetSystemByUIDOrigin = minimock.CallerInfo(1)
	return mmGetSystemByUID.mock
}

// When sets expectation for the Repository.GetSystemByUID which will trigger the result defined by the following
// Then helper
func (mmGetSystemByUID *mRepositoryMockGetSystemByUID) When(ctx context.Context, uid types.SystemUIDType) *RepositoryMockGetSystemByUIDExpectation {
	if mmGetSystemByUID.mock.funcGetSystemByUID != nil {
		mmGetSystemByUID.mock.t.Fatalf("RepositoryMock.GetSystemByUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetSystemByUIDExpectation{
		mock:               mmGetSystemByUID.mock,
		params:             &RepositoryMockGetSystemByUIDParams{ctx, uid},
		expectationOrigins: RepositoryMockGetSystemByUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetSystemByUID.expectations = append(mmGetSystemByUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetSystemByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetSystemByUIDExpectation) Then(sp1 *mm_repository.SystemModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetSystemByUIDResults{sp1, err}
	return e.mock
}

// Times sets number of times Repository.GetSystemByUID should be invoked
func (mmGetSystemByUID *mRepositoryMockGetSystemByUID) Times(n uint64) *mRepositoryMockGetSystemByUID {
	if n == 0 {
		mmGetSystemByUID.mock.t.Fatalf("Times of RepositoryMock.GetSystemByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetSystemByUID.expectedInvocations, n)
	mmGetSystemByUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetSystemByUID
}

func (mmGetSystemByUID *mRepositoryMockGetSystemByUID) invocationsDone() bool {
	if len(mmGetSystemByUID.expectations) == 0 && mmGetSystemByUID.defaultExpectation == nil && mmGetSystemByUID.mock.funcGetSystemByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetSystemByUID.mock.afterGetSystemByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetSystemByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetSystemByUID implements mm_repository.Repository
func (mmGetSystemByUID *RepositoryMock) GetSystemByUID(ctx context.Context, uid types.SystemUIDType) (sp1 *mm_repository.SystemModel, err error) {
	mm_atomic.AddUint64(&mmGetSystemByUID.beforeGetSystemByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSystemByUID.afterGetSystemByUIDCounter, 1)

	mmGetSystemByUID.t.Helper()

	if mmGetSystemByUID.inspectFuncGetSystemByUID != nil {
		mmGetSystemByUID.inspectFuncGetSystemByUID(ctx, uid)
	}

	mm_params := RepositoryMockGetSystemByUIDParams{ctx, uid}

	// Record call args
	mmGetSystemByUID.GetSystemByUIDMock.mutex.Lock()
	mmGetSystemByUID.GetSystemByUIDMock.callArgs = append(mmGetSystemByUID.GetSystemByUIDMock.callArgs, &mm_params)
	mmGetSystemByUID.GetSystemByUIDMock.mutex.Unlock()

	for _, e := range mmGetSystemByUID.GetSystemByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGetSystemByUID.GetSystemByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSystemByUID.GetSystemByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSystemByUID.GetSystemByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetSystemByUID.GetSystemByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetSystemByUIDParams{ctx, uid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetSystemByUID.t.Errorf("RepositoryMock.GetSystemByUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetSystemByUID.GetSystemByUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmGetSystemByUID.t.Errorf("RepositoryMock.GetSystemByUID got unexpected parameter uid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetSystemByUID.GetSystemByUIDMock.defaultExpectation.expectationOrigins.originUid, *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSystemByUID.t.Errorf("RepositoryMock.GetSystemByUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetSystemByUID.GetSystemByUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSystemByUID.GetSystemByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSystemByUID.t.Fatal("No results are set for the RepositoryMock.GetSystemByUID")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGetSystemByUID.funcGetSystemByUID != nil {
		return mmGetSystemByUID.funcGetSystemByUID(ctx, uid)
	}
	mmGetSystemByUID.t.Fatalf("Unexpected call to RepositoryMock.GetSystemByUID. %v %v", ctx, uid)
	return
}

// GetSystemByUIDAfterCounter returns a count of finished RepositoryMock.GetSystemByUID invocations
func (mmGetSystemByUID *RepositoryMock) GetSystemByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSystemByUID.afterGetSystemByUIDCounter)
}

// GetSystemByUIDBeforeCounter returns a count of RepositoryMock.GetSystemByUID invocations
func (mmGetSystemByUID *RepositoryMock) GetSystemByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSystemByUID.beforeGetSystemByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetSystemByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSystemByUID *mRepositoryMockGetSystemByUID) Calls() []*RepositoryMockGetSystemByUIDParams {
	mmGetSystemByUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetSystemByUIDParams, len(mmGetSystemByUID.callArgs))
	copy(argCopy, mmGetSystemByUID.callArgs)

	mmGetSystemByUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetSystemByUIDDone returns true if the count of the GetSystemByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetSystemByUIDDone() bool {
	if m.GetSystemByUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetSystemByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetSystemByUIDMock.invocationsDone()
}

// MinimockGetSystemByUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetSystemByUIDInspect() {
	for _, e := range m.GetSystemByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetSystemByUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetSystemByUIDCounter := mm_atomic.LoadUint64(&m.afterGetSystemByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetSystemByUIDMock.defaultExpectation != nil && afterGetSystemByUIDCounter < 1 {
		if m.GetSystemByUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetSystemByUID at\n%s", m.GetSystemByUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetSystemByUID at\n%s with params: %#v", m.GetSystemByUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetSystemByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSystemByUID != nil && afterGetSystemByUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetSystemByUID at\n%s", m.funcGetSystemByUIDOrigin)
	}

	if !m.GetSystemByUIDMock.invocationsDone() && afterGetSystemByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetSystemByUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetSystemByUIDMock.expectedInvocations), m.GetSystemByUIDMock.expectedInvocationsOrigin, afterGetSystemByUIDCounter)
	}
}

type mRepositoryMockGetTextChunksBySource struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetTextChunksBySourceExpectation
	expectations       []*RepositoryMockGetTextChunksBySourceExpectation

	callArgs []*RepositoryMockGetTextChunksBySourceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetTextChunksBySourceExpectation specifies expectation struct of the Repository.GetTextChunksBySource
type RepositoryMockGetTextChunksBySourceExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetTextChunksBySourceParams
	paramPtrs          *RepositoryMockGetTextChunksBySourceParamPtrs
	expectationOrigins RepositoryMockGetTextChunksBySourceExpectationOrigins
	results            *RepositoryMockGetTextChunksBySourceResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetTextChunksBySourceParams contains parameters of the Repository.GetTextChunksBySource
type RepositoryMockGetTextChunksBySourceParams struct {
	ctx         context.Context
	sourceTable string
	sourceUID   types.SourceUIDType
}

// RepositoryMockGetTextChunksBySourceParamPtrs contains pointers to parameters of the Repository.GetTextChunksBySource
type RepositoryMockGetTextChunksBySourceParamPtrs struct {
	ctx         *context.Context
	sourceTable *string
	sourceUID   *types.SourceUIDType
}

// RepositoryMockGetTextChunksBySourceResults contains results of the Repository.GetTextChunksBySource
type RepositoryMockGetTextChunksBySourceResults struct {
	ta1 []mm_repository.TextChunkModel
	err error
}

// RepositoryMockGetTextChunksBySourceOrigins contains origins of expectations of the Repository.GetTextChunksBySource
type RepositoryMockGetTextChunksBySourceExpectationOrigins struct {
	origin            string
	originCtx         string
	originSourceTable string
	originSourceUID   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetTextChunksBySource *mRepositoryMockGetTextChunksBySource) Optional() *mRepositoryMockGetTextChunksBySource {
	mmGetTextChunksBySource.optional = true
	return mmGetTextChunksBySource
}

// Expect sets up expected params for Repository.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryMockGetTextChunksBySource) Expect(ctx context.Context, sourceTable string, sourceUID types.SourceUIDType) *mRepositoryMockGetTextChunksBySource {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryMock.GetTextChunksBySource mock is already set by Set")
	}

	if mmGetTextChunksBySource.defaultExpectation == nil {
		mmGetTextChunksBySource.defaultExpectation = &RepositoryMockGetTextChunksBySourceExpectation{}
	}

	if mmGetTextChunksBySource.defaultExpectation.paramPtrs != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryMock.GetTextChunksBySource mock is already set by ExpectParams functions")
	}

	mmGetTextChunksBySource.defaultExpectation.params = &RepositoryMockGetTextChunksBySourceParams{ctx, sourceTable, sourceUID}
	mmGetTextChunksBySource.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetTextChunksBySource.expectations {
		if minimock.Equal(e.params, mmGetTextChunksBySource.defaultExpectation.params) {
			mmGetTextChunksBySource.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTextChunksBySource.defaultExpectation.params)
		}
	}

	return mmGetTextChunksBySource
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryMockGetTextChunksBySource) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetTextChunksBySource {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryMock.GetTextChunksBySource mock is already set by Set")
	}

	if mmGetTextChunksBySource.defaultExpectation == nil {
		mmGetTextChunksBySource.defaultExpectation = &RepositoryMockGetTextChunksBySourceExpectation{}
	}

	if mmGetTextChunksBySource.defaultExpectation.params != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryMock.GetTextChunksBySource mock is already set by Expect")
	}

	if mmGetTextChunksBySource.defaultExpectation.paramPtrs == nil {
		mmGetTextChunksBySource.defaultExpectation.paramPtrs = &RepositoryMockGetTextChunksBySourceParamPtrs{}
	}
	mmGetTextChunksBySource.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetTextChunksBySource.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetTextChunksBySource
}

// ExpectSourceTableParam2 sets up expected param sourceTable for Repository.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryMockGetTextChunksBySource) ExpectSourceTableParam2(sourceTable string) *mRepositoryMockGetTextChunksBySource {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryMock.GetTextChunksBySource mock is already set by Set")
	}

	if mmGetTextChunksBySource.defaultExpectation == nil {
		mmGetTextChunksBySource.defaultExpectation = &RepositoryMockGetTextChunksBySourceExpectation{}
	}

	if mmGetTextChunksBySource.defaultExpectation.params != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryMock.GetTextChunksBySource mock is already set by Expect")
	}

	if mmGetTextChunksBySource.defaultExpectation.paramPtrs == nil {
		mmGetTextChunksBySource.defaultExpectation.paramPtrs = &RepositoryMockGetTextChunksBySourceParamPtrs{}
	}
	mmGetTextChunksBySource.defaultExpectation.paramPtrs.sourceTable = &sourceTable
	mmGetTextChunksBySource.defaultExpectation.expectationOrigins.originSourceTable = minimock.CallerInfo(1)

	return mmGetTextChunksBySource
}

// ExpectSourceUIDParam3 sets up expected param sourceUID for Repository.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryMockGetTextChunksBySource) ExpectSourceUIDParam3(sourceUID types.SourceUIDType) *mRepositoryMockGetTextChunksBySource {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryMock.GetTextChunksBySource mock is already set by Set")
	}

	if mmGetTextChunksBySource.defaultExpectation == nil {
		mmGetTextChunksBySource.defaultExpectation = &RepositoryMockGetTextChunksBySourceExpectation{}
	}

	if mmGetTextChunksBySource.defaultExpectation.params != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryMock.GetTextChunksBySource mock is already set by Expect")
	}

	if mmGetTextChunksBySource.defaultExpectation.paramPtrs == nil {
		mmGetTextChunksBySource.defaultExpectation.paramPtrs = &RepositoryMockGetTextChunksBySourceParamPtrs{}
	}
	mmGetTextChunksBySource.defaultExpectation.paramPtrs.sourceUID = &sourceUID
	mmGetTextChunksBySource.defaultExpectation.expectationOrigins.originSourceUID = minimock.CallerInfo(1)

	return mmGetTextChunksBySource
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryMockGetTextChunksBySource) Inspect(f func(ctx context.Context, sourceTable string, sourceUID types.SourceUIDType)) *mRepositoryMockGetTextChunksBySource {
	if mmGetTextChunksBySource.mock.inspectFuncGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetTextChunksBySource")
	}

	mmGetTextChunksBySource.mock.inspectFuncGetTextChunksBySource = f

	return mmGetTextChunksBySource
}

// Return sets up results that will be returned by Repository.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryMockGetTextChunksBySource) Return(ta1 []mm_repository.TextChunkModel, err error) *RepositoryMock {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryMock.GetTextChunksBySource mock is already set by Set")
	}

	if mmGetTextChunksBySource.defaultExpectation == nil {
		mmGetTextChunksBySource.defaultExpectation = &RepositoryMockGetTextChunksBySourceExpectation{mock: mmGetTextChunksBySource.mock}
	}
	mmGetTextChunksBySource.defaultExpectation.results = &RepositoryMockGetTextChunksBySourceResults{ta1, err}
	mmGetTextChunksBySource.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetTextChunksBySource.mock
}

// Set uses given function f to mock the Repository.GetTextChunksBySource method
func (mmGetTextChunksBySource *mRepositoryMockGetTextChunksBySource) Set(f func(ctx context.Context, sourceTable string, sourceUID types.SourceUIDType) (ta1 []mm_repository.TextChunkModel, err error)) *RepositoryMock {
	if mmGetTextChunksBySource.defaultExpectation != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("Default expectation is already set for the Repository.GetTextChunksBySource method")
	}

	if len(mmGetTextChunksBySource.expectations) > 0 {
		mmGetTextChunksBySource.mock.t.Fatalf("Some expectations are already set for the Repository.GetTextChunksBySource method")
	}

	mmGetTextChunksBySource.mock.funcGetTextChunksBySource = f
	mmGetTextChunksBySource.mock.funcGetTextChunksBySourceOrigin = minimock.CallerInfo(1)
	return mmGetTextChunksBySource.mock
}

// When sets expectation for the Repository.GetTextChunksBySource which will trigger the result defined by the following
// Then helper
func (mmGetTextChunksBySource *mRepositoryMockGetTextChunksBySource) When(ctx context.Context, sourceTable string, sourceUID types.SourceUIDType) *RepositoryMockGetTextChunksBySourceExpectation {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryMock.GetTextChunksBySource mock is already set by Set")
	}

	expectation := &RepositoryMockGetTextChunksBySourceExpectation{
		mock:               mmGetTextChunksBySource.mock,
		params:             &RepositoryMockGetTextChunksBySourceParams{ctx, sourceTable, sourceUID},
		expectationOrigins: RepositoryMockGetTextChunksBySourceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetTextChunksBySource.expectations = append(mmGetTextChunksBySource.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetTextChunksBySource return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetTextChunksBySourceExpectation) Then(ta1 []mm_repository.TextChunkModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetTextChunksBySourceResults{ta1, err}
	return e.mock
}

// Times sets number of times Repository.GetTextChunksBySource should be invoked
func (mmGetTextChunksBySource *mRepositoryMockGetTextChunksBySource) Times(n uint64) *mRepositoryMockGetTextChunksBySource {
	if n == 0 {
		mmGetTextChunksBySource.mock.t.Fatalf("Times of RepositoryMock.GetTextChunksBySource mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTextChunksBySource.expectedInvocations, n)
	mmGetTextChunksBySource.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetTextChunksBySource
}

func (mmGetTextChunksBySource *mRepositoryMockGetTextChunksBySource) invocationsDone() bool {
	if len(mmGetTextChunksBySource.expectations) == 0 && mmGetTextChunksBySource.defaultExpectation == nil && mmGetTextChunksBySource.mock.funcGetTextChunksBySource == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTextChunksBySource.mock.afterGetTextChunksBySourceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTextChunksBySource.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTextChunksBySource implements mm_repository.Repository
func (mmGetTextChunksBySource *RepositoryMock) GetTextChunksBySource(ctx context.Context, sourceTable string, sourceUID types.SourceUIDType) (ta1 []mm_repository.TextChunkModel, err error) {
	mm_atomic.AddUint64(&mmGetTextChunksBySource.beforeGetTextChunksBySourceCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTextChunksBySource.afterGetTextChunksBySourceCounter, 1)

	mmGetTextChunksBySource.t.Helper()

	if mmGetTextChunksBySource.inspectFuncGetTextChunksBySource != nil {
		mmGetTextChunksBySource.inspectFuncGetTextChunksBySource(ctx, sourceTable, sourceUID)
	}

	mm_params := RepositoryMockGetTextChunksBySourceParams{ctx, sourceTable, sourceUID}

	// Record call args
	mmGetTextChunksBySource.GetTextChunksBySourceMock.mutex.Lock()
	mmGetTextChunksBySource.GetTextChunksBySourceMock.callArgs = append(mmGetTextChunksBySource.GetTextChunksBySourceMock.callArgs, &mm_params)
	mmGetTextChunksBySource.GetTextChunksBySourceMock.mutex.Unlock()

	for _, e := range mmGetTextChunksBySource.GetTextChunksBySourceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ta1, e.results.err
		}
	}

	if mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation.params
		mm_want_ptrs := mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetTextChunksBySourceParams{ctx, sourceTable, sourceUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTextChunksBySource.t.Errorf("RepositoryMock.GetTextChunksBySource got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sourceTable != nil && !minimock.Equal(*mm_want_ptrs.sourceTable, mm_got.sourceTable) {
				mmGetTextChunksBySource.t.Errorf("RepositoryMock.GetTextChunksBySource got unexpected parameter sourceTable, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation.expectationOrigins.originSourceTable, *mm_want_ptrs.sourceTable, mm_got.sourceTable, minimock.Diff(*mm_want_ptrs.sourceTable, mm_got.sourceTable))
			}

			if mm_want_ptrs.sourceUID != nil && !minimock.Equal(*mm_want_ptrs.sourceUID, mm_got.sourceUID) {
				mmGetTextChunksBySource.t.Errorf("RepositoryMock.GetTextChunksBySource got unexpected parameter sourceUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation.expectationOrigins.originSourceUID, *mm_want_ptrs.sourceUID, mm_got.sourceUID, minimock.Diff(*mm_want_ptrs.sourceUID, mm_got.sourceUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTextChunksBySource.t.Errorf("RepositoryMock.GetTextChunksBySource got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTextChunksBySource.t.Fatal("No results are set for the RepositoryMock.GetTextChunksBySource")
		}
		return (*mm_results).ta1, (*mm_results).err
	}
	if mmGetTextChunksBySource.funcGetTextChunksBySource != nil {
		return mmGetTextChunksBySource.funcGetTextChunksBySource(ctx, sourceTable, sourceUID)
	}
	mmGetTextChunksBySource.t.Fatalf("Unexpected call to RepositoryMock.GetTextChunksBySource. %v %v %v", ctx, sourceTable, sourceUID)
	return
}

// GetTextChunksBySourceAfterCounter returns a count of finished RepositoryMock.GetTextChunksBySource invocations
func (mmGetTextChunksBySource *RepositoryMock) GetTextChunksBySourceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTextChunksBySource.afterGetTextChunksBySourceCounter)
}

// GetTextChunksBySourceBeforeCounter returns a count of RepositoryMock.GetTextChunksBySource invocations
func (mmGetTextChunksBySource *RepositoryMock) GetTextChunksBySourceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTextChunksBySource.beforeGetTextChunksBySourceCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetTextChunksBySource.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTextChunksBySource *mRepositoryMockGetTextChunksBySource) Calls() []*RepositoryMockGetTextChunksBySourceParams {
	mmGetTextChunksBySource.mutex.RLock()

	argCopy := make([]*RepositoryMockGetTextChunksBySourceParams, len(mmGetTextChunksBySource.callArgs))
	copy(argCopy, mmGetTextChunksBySource.callArgs)

	mmGetTextChunksBySource.mutex.RUnlock()

	return argCopy
}

// MinimockGetTextChunksBySourceDone returns true if the count of the GetTextChunksBySource invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetTextChunksBySourceDone() bool {
	if m.GetTextChunksBySourceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetTextChunksBySourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTextChunksBySourceMock.invocationsDone()
}

// MinimockGetTextChunksBySourceInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetTextChunksBySourceInspect() {
	for _, e := range m.GetTextChunksBySourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetTextChunksBySource at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetTextChunksBySourceCounter := mm_atomic.LoadUint64(&m.afterGetTextChunksBySourceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTextChunksBySourceMock.defaultExpectation != nil && afterGetTextChunksBySourceCounter < 1 {
		if m.GetTextChunksBySourceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetTextChunksBySource at\n%s", m.GetTextChunksBySourceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetTextChunksBySource at\n%s with params: %#v", m.GetTextChunksBySourceMock.defaultExpectation.expectationOrigins.origin, *m.GetTextChunksBySourceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTextChunksBySource != nil && afterGetTextChunksBySourceCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetTextChunksBySource at\n%s", m.funcGetTextChunksBySourceOrigin)
	}

	if !m.GetTextChunksBySourceMock.invocationsDone() && afterGetTextChunksBySourceCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetTextChunksBySource at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetTextChunksBySourceMock.expectedInvocations), m.GetTextChunksBySourceMock.expectedInvocationsOrigin, afterGetTextChunksBySourceCounter)
	}
}

type mRepositoryMockGetTextChunksByUIDs struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetTextChunksByUIDsExpectation
	expectations       []*RepositoryMockGetTextChunksByUIDsExpectation

	callArgs []*RepositoryMockGetTextChunksByUIDsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetTextChunksByUIDsExpectation specifies expectation struct of the Repository.GetTextChunksByUIDs
type RepositoryMockGetTextChunksByUIDsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetTextChunksByUIDsParams
	paramPtrs          *RepositoryMockGetTextChunksByUIDsParamPtrs
	expectationOrigins RepositoryMockGetTextChunksByUIDsExpectationOrigins
	results            *RepositoryMockGetTextChunksByUIDsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetTextChunksByUIDsParams contains parameters of the Repository.GetTextChunksByUIDs
type RepositoryMockGetTextChunksByUIDsParams struct {
	ctx       context.Context
	chunkUIDs []types.TextChunkUIDType
}

// RepositoryMockGetTextChunksByUIDsParamPtrs contains pointers to parameters of the Repository.GetTextChunksByUIDs
type RepositoryMockGetTextChunksByUIDsParamPtrs struct {
	ctx       *context.Context
	chunkUIDs *[]types.TextChunkUIDType
}

// RepositoryMockGetTextChunksByUIDsResults contains results of the Repository.GetTextChunksByUIDs
type RepositoryMockGetTextChunksByUIDsResults struct {
	ta1 []mm_repository.TextChunkModel
	err error
}

// RepositoryMockGetTextChunksByUIDsOrigins contains origins of expectations of the Repository.GetTextChunksByUIDs
type RepositoryMockGetTextChunksByUIDsExpectationOrigins struct {
	origin          string
	originCtx       string
	originChunkUIDs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetTextChunksByUIDs *mRepositoryMockGetTextChunksByUIDs) Optional() *mRepositoryMockGetTextChunksByUIDs {
	mmGetTextChunksByUIDs.optional = true
	return mmGetTextChunksByUIDs
}

// Expect sets up expected params for Repository.GetTextChunksByUIDs
func (mmGetTextChunksByUIDs *mRepositoryMockGetTextChunksByUIDs) Expect(ctx context.Context, chunkUIDs []types.TextChunkUIDType) *mRepositoryMockGetTextChunksByUIDs {
	if mmGetTextChunksByUIDs.mock.funcGetTextChunksByUIDs != nil {
		mmGetTextChunksByUIDs.mock.t.Fatalf("RepositoryMock.GetTextChunksByUIDs mock is already set by Set")
	}

	if mmGetTextChunksByUIDs.defaultExpectation == nil {
		mmGetTextChunksByUIDs.defaultExpectation = &RepositoryMockGetTextChunksByUIDsExpectation{}
	}

	if mmGetTextChunksByUIDs.defaultExpectation.paramPtrs != nil {
		mmGetTextChunksByUIDs.mock.t.Fatalf("RepositoryMock.GetTextChunksByUIDs mock is already set by ExpectParams functions")
	}

	mmGetTextChunksByUIDs.defaultExpectation.params = &RepositoryMockGetTextChunksByUIDsParams{ctx, chunkUIDs}
	mmGetTextChunksByUIDs.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetTextChunksByUIDs.expectations {
		if minimock.Equal(e.params, mmGetTextChunksByUIDs.defaultExpectation.params) {
			mmGetTextChunksByUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTextChunksByUIDs.defaultExpectation.params)
		}
	}

	return mmGetTextChunksByUIDs
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetTextChunksByUIDs
func (mmGetTextChunksByUIDs *mRepositoryMockGetTextChunksByUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetTextChunksByUIDs {
	if mmGetTextChunksByUIDs.mock.funcGetTextChunksByUIDs != nil {
		mmGetTextChunksByUIDs.mock.t.Fatalf("RepositoryMock.GetTextChunksByUIDs mock is already set by Set")
	}

	if mmGetTextChunksByUIDs.defaultExpectation == nil {
		mmGetTextChunksByUIDs.defaultExpectation = &RepositoryMockGetTextChunksByUIDsExpectation{}
	}

	if mmGetTextChunksByUIDs.defaultExpectation.params != nil {
		mmGetTextChunksByUIDs.mock.t.Fatalf("RepositoryMock.GetTextChunksByUIDs mock is already set by Expect")
	}

	if mmGetTextChunksByUIDs.defaultExpectation.paramPtrs == nil {
		mmGetTextChunksByUIDs.defaultExpectation.paramPtrs = &RepositoryMockGetTextChunksByUIDsParamPtrs{}
	}
	mmGetTextChunksByUIDs.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetTextChunksByUIDs.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetTextChunksByUIDs
}

// ExpectChunkUIDsParam2 sets up expected param chunkUIDs for Repository.GetTextChunksByUIDs
func (mmGetTextChunksByUIDs *mRepositoryMockGetTextChunksByUIDs) ExpectChunkUIDsParam2(chunkUIDs []types.TextChunkUIDType) *mRepositoryMockGetTextChunksByUIDs {
	if mmGetTextChunksByUIDs.mock.funcGetTextChunksByUIDs != nil {
		mmGetTextChunksByUIDs.mock.t.Fatalf("RepositoryMock.GetTextChunksByUIDs mock is already set by Set")
	}

	if mmGetTextChunksByUIDs.defaultExpectation == nil {
		mmGetTextChunksByUIDs.defaultExpectation = &RepositoryMockGetTextChunksByUIDsExpectation{}
	}

	if mmGetTextChunksByUIDs.defaultExpectation.params != nil {
		mmGetTextChunksByUIDs.mock.t.Fatalf("RepositoryMock.GetTextChunksByUIDs mock is already set by Expect")
	}

	if mmGetTextChunksByUIDs.defaultExpectation.paramPtrs == nil {
		mmGetTextChunksByUIDs.defaultExpectation.paramPtrs = &RepositoryMockGetTextChunksByUIDsParamPtrs{}
	}
	mmGetTextChunksByUIDs.defaultExpectation.paramPtrs.chunkUIDs = &chunkUIDs
	mmGetTextChunksByUIDs.defaultExpectation.expectationOrigins.originChunkUIDs = minimock.CallerInfo(1)

	return mmGetTextChunksByUIDs
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetTextChunksByUIDs
func (mmGetTextChunksByUIDs *mRepositoryMockGetTextChunksByUIDs) Inspect(f func(ctx context.Context, chunkUIDs []types.TextChunkUIDType)) *mRepositoryMockGetTextChunksByUIDs {
	if mmGetTextChunksByUIDs.mock.inspectFuncGetTextChunksByUIDs != nil {
		mmGetTextChunksByUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetTextChunksByUIDs")
	}

	mmGetTextChunksByUIDs.mock.inspectFuncGetTextChunksByUIDs = f

	return mmGetTextChunksByUIDs
}

// Return sets up results that will be returned by Repository.GetTextChunksByUIDs
func (mmGetTextChunksByUIDs *mRepositoryMockGetTextChunksByUIDs) Return(ta1 []mm_repository.TextChunkModel, err error) *RepositoryMock {
	if mmGetTextChunksByUIDs.mock.funcGetTextChunksByUIDs != nil {
		mmGetTextChunksByUIDs.mock.t.Fatalf("RepositoryMock.GetTextChunksByUIDs mock is already set by Set")
	}

	if mmGetTextChunksByUIDs.defaultExpectation == nil {
		mmGetTextChunksByUIDs.defaultExpectation = &RepositoryMockGetTextChunksByUIDsExpectation{mock: mmGetTextChunksByUIDs.mock}
	}
	mmGetTextChunksByUIDs.defaultExpectation.results = &RepositoryMockGetTextChunksByUIDsResults{ta1, err}
	mmGetTextChunksByUIDs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetTextChunksByUIDs.mock
}

// Set uses given function f to mock the Repository.GetTextChunksByUIDs method
func (mmGetTextChunksByUIDs *mRepositoryMockGetTextChunksByUIDs) Set(f func(ctx context.Context, chunkUIDs []types.TextChunkUIDType) (ta1 []mm_repository.TextChunkModel, err error)) *RepositoryMock {
	if mmGetTextChunksByUIDs.defaultExpectation != nil {
		mmGetTextChunksByUIDs.mock.t.Fatalf("Default expectation is already set for the Repository.GetTextChunksByUIDs method")
	}

	if len(mmGetTextChunksByUIDs.expectations) > 0 {
		mmGetTextChunksByUIDs.mock.t.Fatalf("Some expectations are already set for the Repository.GetTextChunksByUIDs method")
	}

	mmGetTextChunksByUIDs.mock.funcGetTextChunksByUIDs = f
	mmGetTextChunksByUIDs.mock.funcGetTextChunksByUIDsOrigin = minimock.CallerInfo(1)
	return mmGetTextChunksByUIDs.mock
}

// When sets expectation for the Repository.GetTextChunksByUIDs which will trigger the result defined by the following
// Then helper
func (mmGetTextChunksByUIDs *mRepositoryMockGetTextChunksByUIDs) When(ctx context.Context, chunkUIDs []types.TextChunkUIDType) *RepositoryMockGetTextChunksByUIDsExpectation {
	if mmGetTextChunksByUIDs.mock.funcGetTextChunksByUIDs != nil {
		mmGetTextChunksByUIDs.mock.t.Fatalf("RepositoryMock.GetTextChunksByUIDs mock is already set by Set")
	}

	expectation := &RepositoryMockGetTextChunksByUIDsExpectation{
		mock:               mmGetTextChunksByUIDs.mock,
		params:             &RepositoryMockGetTextChunksByUIDsParams{ctx, chunkUIDs},
		expectationOrigins: RepositoryMockGetTextChunksByUIDsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetTextChunksByUIDs.expectations = append(mmGetTextChunksByUIDs.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetTextChunksByUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetTextChunksByUIDsExpectation) Then(ta1 []mm_repository.TextChunkModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetTextChunksByUIDsResults{ta1, err}
	return e.mock
}

// Times sets number of times Repository.GetTextChunksByUIDs should be invoked
func (mmGetTextChunksByUIDs *mRepositoryMockGetTextChunksByUIDs) Times(n uint64) *mRepositoryMockGetTextChunksByUIDs {
	if n == 0 {
		mmGetTextChunksByUIDs.mock.t.Fatalf("Times of RepositoryMock.GetTextChunksByUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTextChunksByUIDs.expectedInvocations, n)
	mmGetTextChunksByUIDs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetTextChunksByUIDs
}

func (mmGetTextChunksByUIDs *mRepositoryMockGetTextChunksByUIDs) invocationsDone() bool {
	if len(mmGetTextChunksByUIDs.expectations) == 0 && mmGetTextChunksByUIDs.defaultExpectation == nil && mmGetTextChunksByUIDs.mock.funcGetTextChunksByUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTextChunksByUIDs.mock.afterGetTextChunksByUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTextChunksByUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTextChunksByUIDs implements mm_repository.Repository
func (mmGetTextChunksByUIDs *RepositoryMock) GetTextChunksByUIDs(ctx context.Context, chunkUIDs []types.TextChunkUIDType) (ta1 []mm_repository.TextChunkModel, err error) {
	mm_atomic.AddUint64(&mmGetTextChunksByUIDs.beforeGetTextChunksByUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTextChunksByUIDs.afterGetTextChunksByUIDsCounter, 1)

	mmGetTextChunksByUIDs.t.Helper()

	if mmGetTextChunksByUIDs.inspectFuncGetTextChunksByUIDs != nil {
		mmGetTextChunksByUIDs.inspectFuncGetTextChunksByUIDs(ctx, chunkUIDs)
	}

	mm_params := RepositoryMockGetTextChunksByUIDsParams{ctx, chunkUIDs}

	// Record call args
	mmGetTextChunksByUIDs.GetTextChunksByUIDsMock.mutex.Lock()
	mmGetTextChunksByUIDs.GetTextChunksByUIDsMock.callArgs = append(mmGetTextChunksByUIDs.GetTextChunksByUIDsMock.callArgs, &mm_params)
	mmGetTextChunksByUIDs.GetTextChunksByUIDsMock.mutex.Unlock()

	for _, e := range mmGetTextChunksByUIDs.GetTextChunksByUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ta1, e.results.err
		}
	}

	if mmGetTextChunksByUIDs.GetTextChunksByUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTextChunksByUIDs.GetTextChunksByUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTextChunksByUIDs.GetTextChunksByUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmGetTextChunksByUIDs.GetTextChunksByUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetTextChunksByUIDsParams{ctx, chunkUIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTextChunksByUIDs.t.Errorf("RepositoryMock.GetTextChunksByUIDs got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTextChunksByUIDs.GetTextChunksByUIDsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chunkUIDs != nil && !minimock.Equal(*mm_want_ptrs.chunkUIDs, mm_got.chunkUIDs) {
				mmGetTextChunksByUIDs.t.Errorf("RepositoryMock.GetTextChunksByUIDs got unexpected parameter chunkUIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTextChunksByUIDs.GetTextChunksByUIDsMock.defaultExpectation.expectationOrigins.originChunkUIDs, *mm_want_ptrs.chunkUIDs, mm_got.chunkUIDs, minimock.Diff(*mm_want_ptrs.chunkUIDs, mm_got.chunkUIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTextChunksByUIDs.t.Errorf("RepositoryMock.GetTextChunksByUIDs got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetTextChunksByUIDs.GetTextChunksByUIDsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTextChunksByUIDs.GetTextChunksByUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTextChunksByUIDs.t.Fatal("No results are set for the RepositoryMock.GetTextChunksByUIDs")
		}
		return (*mm_results).ta1, (*mm_results).err
	}
	if mmGetTextChunksByUIDs.funcGetTextChunksByUIDs != nil {
		return mmGetTextChunksByUIDs.funcGetTextChunksByUIDs(ctx, chunkUIDs)
	}
	mmGetTextChunksByUIDs.t.Fatalf("Unexpected call to RepositoryMock.GetTextChunksByUIDs. %v %v", ctx, chunkUIDs)
	return
}

// GetTextChunksByUIDsAfterCounter returns a count of finished RepositoryMock.GetTextChunksByUIDs invocations
func (mmGetTextChunksByUIDs *RepositoryMock) GetTextChunksByUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTextChunksByUIDs.afterGetTextChunksByUIDsCounter)
}

// GetTextChunksByUIDsBeforeCounter returns a count of RepositoryMock.GetTextChunksByUIDs invocations
func (mmGetTextChunksByUIDs *RepositoryMock) GetTextChunksByUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTextChunksByUIDs.beforeGetTextChunksByUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetTextChunksByUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTextChunksByUIDs *mRepositoryMockGetTextChunksByUIDs) Calls() []*RepositoryMockGetTextChunksByUIDsParams {
	mmGetTextChunksByUIDs.mutex.RLock()

	argCopy := make([]*RepositoryMockGetTextChunksByUIDsParams, len(mmGetTextChunksByUIDs.callArgs))
	copy(argCopy, mmGetTextChunksByUIDs.callArgs)

	mmGetTextChunksByUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockGetTextChunksByUIDsDone returns true if the count of the GetTextChunksByUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetTextChunksByUIDsDone() bool {
	if m.GetTextChunksByUIDsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetTextChunksByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTextChunksByUIDsMock.invocationsDone()
}

// MinimockGetTextChunksByUIDsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetTextChunksByUIDsInspect() {
	for _, e := range m.GetTextChunksByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetTextChunksByUIDs at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetTextChunksByUIDsCounter := mm_atomic.LoadUint64(&m.afterGetTextChunksByUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTextChunksByUIDsMock.defaultExpectation != nil && afterGetTextChunksByUIDsCounter < 1 {
		if m.GetTextChunksByUIDsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetTextChunksByUIDs at\n%s", m.GetTextChunksByUIDsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetTextChunksByUIDs at\n%s with params: %#v", m.GetTextChunksByUIDsMock.defaultExpectation.expectationOrigins.origin, *m.GetTextChunksByUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTextChunksByUIDs != nil && afterGetTextChunksByUIDsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetTextChunksByUIDs at\n%s", m.funcGetTextChunksByUIDsOrigin)
	}

	if !m.GetTextChunksByUIDsMock.invocationsDone() && afterGetTextChunksByUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetTextChunksByUIDs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetTextChunksByUIDsMock.expectedInvocations), m.GetTextChunksByUIDsMock.expectedInvocationsOrigin, afterGetTextChunksByUIDsCounter)
	}
}

type mRepositoryMockGetTotalTextChunksBySources struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetTotalTextChunksBySourcesExpectation
	expectations       []*RepositoryMockGetTotalTextChunksBySourcesExpectation

	callArgs []*RepositoryMockGetTotalTextChunksBySourcesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetTotalTextChunksBySourcesExpectation specifies expectation struct of the Repository.GetTotalTextChunksBySources
type RepositoryMockGetTotalTextChunksBySourcesExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetTotalTextChunksBySourcesParams
	paramPtrs          *RepositoryMockGetTotalTextChunksBySourcesParamPtrs
	expectationOrigins RepositoryMockGetTotalTextChunksBySourcesExpectationOrigins
	results            *RepositoryMockGetTotalTextChunksBySourcesResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetTotalTextChunksBySourcesParams contains parameters of the Repository.GetTotalTextChunksBySources
type RepositoryMockGetTotalTextChunksBySourcesParams struct {
	ctx     context.Context
	sources map[types.FileUIDType]struct {
		SourceTable types.SourceTableType
		SourceUID   types.SourceUIDType
	}
}

// RepositoryMockGetTotalTextChunksBySourcesParamPtrs contains pointers to parameters of the Repository.GetTotalTextChunksBySources
type RepositoryMockGetTotalTextChunksBySourcesParamPtrs struct {
	ctx     *context.Context
	sources *map[types.FileUIDType]struct {
		SourceTable types.SourceTableType
		SourceUID   types.SourceUIDType
	}
}

// RepositoryMockGetTotalTextChunksBySourcesResults contains results of the Repository.GetTotalTextChunksBySources
type RepositoryMockGetTotalTextChunksBySourcesResults struct {
	m1  map[types.FileUIDType]int
	err error
}

// RepositoryMockGetTotalTextChunksBySourcesOrigins contains origins of expectations of the Repository.GetTotalTextChunksBySources
type RepositoryMockGetTotalTextChunksBySourcesExpectationOrigins struct {
	origin        string
	originCtx     string
	originSources string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetTotalTextChunksBySources *mRepositoryMockGetTotalTextChunksBySources) Optional() *mRepositoryMockGetTotalTextChunksBySources {
	mmGetTotalTextChunksBySources.optional = true
	return mmGetTotalTextChunksBySources
}

// Expect sets up expected params for Repository.GetTotalTextChunksBySources
func (mmGetTotalTextChunksBySources *mRepositoryMockGetTotalTextChunksBySources) Expect(ctx context.Context, sources map[types.FileUIDType]struct {
	SourceTable types.SourceTableType
	SourceUID   types.SourceUIDType
}) *mRepositoryMockGetTotalTextChunksBySources {
	if mmGetTotalTextChunksBySources.mock.funcGetTotalTextChunksBySources != nil {
		mmGetTotalTextChunksBySources.mock.t.Fatalf("RepositoryMock.GetTotalTextChunksBySources mock is already set by Set")
	}

	if mmGetTotalTextChunksBySources.defaultExpectation == nil {
		mmGetTotalTextChunksBySources.defaultExpectation = &RepositoryMockGetTotalTextChunksBySourcesExpectation{}
	}

	if mmGetTotalTextChunksBySources.defaultExpectation.paramPtrs != nil {
		mmGetTotalTextChunksBySources.mock.t.Fatalf("RepositoryMock.GetTotalTextChunksBySources mock is already set by ExpectParams functions")
	}

	mmGetTotalTextChunksBySources.defaultExpectation.params = &RepositoryMockGetTotalTextChunksBySourcesParams{ctx, sources}
	mmGetTotalTextChunksBySources.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetTotalTextChunksBySources.expectations {
		if minimock.Equal(e.params, mmGetTotalTextChunksBySources.defaultExpectation.params) {
			mmGetTotalTextChunksBySources.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTotalTextChunksBySources.defaultExpectation.params)
		}
	}

	return mmGetTotalTextChunksBySources
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetTotalTextChunksBySources
func (mmGetTotalTextChunksBySources *mRepositoryMockGetTotalTextChunksBySources) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetTotalTextChunksBySources {
	if mmGetTotalTextChunksBySources.mock.funcGetTotalTextChunksBySources != nil {
		mmGetTotalTextChunksBySources.mock.t.Fatalf("RepositoryMock.GetTotalTextChunksBySources mock is already set by Set")
	}

	if mmGetTotalTextChunksBySources.defaultExpectation == nil {
		mmGetTotalTextChunksBySources.defaultExpectation = &RepositoryMockGetTotalTextChunksBySourcesExpectation{}
	}

	if mmGetTotalTextChunksBySources.defaultExpectation.params != nil {
		mmGetTotalTextChunksBySources.mock.t.Fatalf("RepositoryMock.GetTotalTextChunksBySources mock is already set by Expect")
	}

	if mmGetTotalTextChunksBySources.defaultExpectation.paramPtrs == nil {
		mmGetTotalTextChunksBySources.defaultExpectation.paramPtrs = &RepositoryMockGetTotalTextChunksBySourcesParamPtrs{}
	}
	mmGetTotalTextChunksBySources.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetTotalTextChunksBySources.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetTotalTextChunksBySources
}

// ExpectSourcesParam2 sets up expected param sources for Repository.GetTotalTextChunksBySources
func (mmGetTotalTextChunksBySources *mRepositoryMockGetTotalTextChunksBySources) ExpectSourcesParam2(sources map[types.FileUIDType]struct {
	SourceTable types.SourceTableType
	SourceUID   types.SourceUIDType
}) *mRepositoryMockGetTotalTextChunksBySources {
	if mmGetTotalTextChunksBySources.mock.funcGetTotalTextChunksBySources != nil {
		mmGetTotalTextChunksBySources.mock.t.Fatalf("RepositoryMock.GetTotalTextChunksBySources mock is already set by Set")
	}

	if mmGetTotalTextChunksBySources.defaultExpectation == nil {
		mmGetTotalTextChunksBySources.defaultExpectation = &RepositoryMockGetTotalTextChunksBySourcesExpectation{}
	}

	if mmGetTotalTextChunksBySources.defaultExpectation.params != nil {
		mmGetTotalTextChunksBySources.mock.t.Fatalf("RepositoryMock.GetTotalTextChunksBySources mock is already set by Expect")
	}

	if mmGetTotalTextChunksBySources.defaultExpectation.paramPtrs == nil {
		mmGetTotalTextChunksBySources.defaultExpectation.paramPtrs = &RepositoryMockGetTotalTextChunksBySourcesParamPtrs{}
	}
	mmGetTotalTextChunksBySources.defaultExpectation.paramPtrs.sources = &sources
	mmGetTotalTextChunksBySources.defaultExpectation.expectationOrigins.originSources = minimock.CallerInfo(1)

	return mmGetTotalTextChunksBySources
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetTotalTextChunksBySources
func (mmGetTotalTextChunksBySources *mRepositoryMockGetTotalTextChunksBySources) Inspect(f func(ctx context.Context, sources map[types.FileUIDType]struct {
	SourceTable types.SourceTableType
	SourceUID   types.SourceUIDType
})) *mRepositoryMockGetTotalTextChunksBySources {
	if mmGetTotalTextChunksBySources.mock.inspectFuncGetTotalTextChunksBySources != nil {
		mmGetTotalTextChunksBySources.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetTotalTextChunksBySources")
	}

	mmGetTotalTextChunksBySources.mock.inspectFuncGetTotalTextChunksBySources = f

	return mmGetTotalTextChunksBySources
}

// Return sets up results that will be returned by Repository.GetTotalTextChunksBySources
func (mmGetTotalTextChunksBySources *mRepositoryMockGetTotalTextChunksBySources) Return(m1 map[types.FileUIDType]int, err error) *RepositoryMock {
	if mmGetTotalTextChunksBySources.mock.funcGetTotalTextChunksBySources != nil {
		mmGetTotalTextChunksBySources.mock.t.Fatalf("RepositoryMock.GetTotalTextChunksBySources mock is already set by Set")
	}

	if mmGetTotalTextChunksBySources.defaultExpectation == nil {
		mmGetTotalTextChunksBySources.defaultExpectation = &RepositoryMockGetTotalTextChunksBySourcesExpectation{mock: mmGetTotalTextChunksBySources.mock}
	}
	mmGetTotalTextChunksBySources.defaultExpectation.results = &RepositoryMockGetTotalTextChunksBySourcesResults{m1, err}
	mmGetTotalTextChunksBySources.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetTotalTextChunksBySources.mock
}

// Set uses given function f to mock the Repository.GetTotalTextChunksBySources method
func (mmGetTotalTextChunksBySources *mRepositoryMockGetTotalTextChunksBySources) Set(f func(ctx context.Context, sources map[types.FileUIDType]struct {
	SourceTable types.SourceTableType
	SourceUID   types.SourceUIDType
}) (m1 map[types.FileUIDType]int, err error)) *RepositoryMock {
	if mmGetTotalTextChunksBySources.defaultExpectation != nil {
		mmGetTotalTextChunksBySources.mock.t.Fatalf("Default expectation is already set for the Repository.GetTotalTextChunksBySources method")
	}

	if len(mmGetTotalTextChunksBySources.expectations) > 0 {
		mmGetTotalTextChunksBySources.mock.t.Fatalf("Some expectations are already set for the Repository.GetTotalTextChunksBySources method")
	}

	mmGetTotalTextChunksBySources.mock.funcGetTotalTextChunksBySources = f
	mmGetTotalTextChunksBySources.mock.funcGetTotalTextChunksBySourcesOrigin = minimock.CallerInfo(1)
	return mmGetTotalTextChunksBySources.mock
}

// When sets expectation for the Repository.GetTotalTextChunksBySources which will trigger the result defined by the following
// Then helper
func (mmGetTotalTextChunksBySources *mRepositoryMockGetTotalTextChunksBySources) When(ctx context.Context, sources map[types.FileUIDType]struct {
	SourceTable types.SourceTableType
	SourceUID   types.SourceUIDType
}) *RepositoryMockGetTotalTextChunksBySourcesExpectation {
	if mmGetTotalTextChunksBySources.mock.funcGetTotalTextChunksBySources != nil {
		mmGetTotalTextChunksBySources.mock.t.Fatalf("RepositoryMock.GetTotalTextChunksBySources mock is already set by Set")
	}

	expectation := &RepositoryMockGetTotalTextChunksBySourcesExpectation{
		mock:               mmGetTotalTextChunksBySources.mock,
		params:             &RepositoryMockGetTotalTextChunksBySourcesParams{ctx, sources},
		expectationOrigins: RepositoryMockGetTotalTextChunksBySourcesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetTotalTextChunksBySources.expectations = append(mmGetTotalTextChunksBySources.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetTotalTextChunksBySources return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetTotalTextChunksBySourcesExpectation) Then(m1 map[types.FileUIDType]int, err error) *RepositoryMock {
	e.results = &RepositoryMockGetTotalTextChunksBySourcesResults{m1, err}
	return e.mock
}

// Times sets number of times Repository.GetTotalTextChunksBySources should be invoked
func (mmGetTotalTextChunksBySources *mRepositoryMockGetTotalTextChunksBySources) Times(n uint64) *mRepositoryMockGetTotalTextChunksBySources {
	if n == 0 {
		mmGetTotalTextChunksBySources.mock.t.Fatalf("Times of RepositoryMock.GetTotalTextChunksBySources mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTotalTextChunksBySources.expectedInvocations, n)
	mmGetTotalTextChunksBySources.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetTotalTextChunksBySources
}

func (mmGetTotalTextChunksBySources *mRepositoryMockGetTotalTextChunksBySources) invocationsDone() bool {
	if len(mmGetTotalTextChunksBySources.expectations) == 0 && mmGetTotalTextChunksBySources.defaultExpectation == nil && mmGetTotalTextChunksBySources.mock.funcGetTotalTextChunksBySources == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTotalTextChunksBySources.mock.afterGetTotalTextChunksBySourcesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTotalTextChunksBySources.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTotalTextChunksBySources implements mm_repository.Repository
func (mmGetTotalTextChunksBySources *RepositoryMock) GetTotalTextChunksBySources(ctx context.Context, sources map[types.FileUIDType]struct {
	SourceTable types.SourceTableType
	SourceUID   types.SourceUIDType
}) (m1 map[types.FileUIDType]int, err error) {
	mm_atomic.AddUint64(&mmGetTotalTextChunksBySources.beforeGetTotalTextChunksBySourcesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTotalTextChunksBySources.afterGetTotalTextChunksBySourcesCounter, 1)

	mmGetTotalTextChunksBySources.t.Helper()

	if mmGetTotalTextChunksBySources.inspectFuncGetTotalTextChunksBySources != nil {
		mmGetTotalTextChunksBySources.inspectFuncGetTotalTextChunksBySources(ctx, sources)
	}

	mm_params := RepositoryMockGetTotalTextChunksBySourcesParams{ctx, sources}

	// Record call args
	mmGetTotalTextChunksBySources.GetTotalTextChunksBySourcesMock.mutex.Lock()
	mmGetTotalTextChunksBySources.GetTotalTextChunksBySourcesMock.callArgs = append(mmGetTotalTextChunksBySources.GetTotalTextChunksBySourcesMock.callArgs, &mm_params)
	mmGetTotalTextChunksBySources.GetTotalTextChunksBySourcesMock.mutex.Unlock()

	for _, e := range mmGetTotalTextChunksBySources.GetTotalTextChunksBySourcesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetTotalTextChunksBySources.GetTotalTextChunksBySourcesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTotalTextChunksBySources.GetTotalTextChunksBySourcesMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTotalTextChunksBySources.GetTotalTextChunksBySourcesMock.defaultExpectation.params
		mm_want_ptrs := mmGetTotalTextChunksBySources.GetTotalTextChunksBySourcesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetTotalTextChunksBySourcesParams{ctx, sources}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTotalTextChunksBySources.t.Errorf("RepositoryMock.GetTotalTextChunksBySources got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTotalTextChunksBySources.GetTotalTextChunksBySourcesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sources != nil && !minimock.Equal(*mm_want_ptrs.sources, mm_got.sources) {
				mmGetTotalTextChunksBySources.t.Errorf("RepositoryMock.GetTotalTextChunksBySources got unexpected parameter sources, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTotalTextChunksBySources.GetTotalTextChunksBySourcesMock.defaultExpectation.expectationOrigins.originSources, *mm_want_ptrs.sources, mm_got.sources, minimock.Diff(*mm_want_ptrs.sources, mm_got.sources))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTotalTextChunksBySources.t.Errorf("RepositoryMock.GetTotalTextChunksBySources got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetTotalTextChunksBySources.GetTotalTextChunksBySourcesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTotalTextChunksBySources.GetTotalTextChunksBySourcesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTotalTextChunksBySources.t.Fatal("No results are set for the RepositoryMock.GetTotalTextChunksBySources")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetTotalTextChunksBySources.funcGetTotalTextChunksBySources != nil {
		return mmGetTotalTextChunksBySources.funcGetTotalTextChunksBySources(ctx, sources)
	}
	mmGetTotalTextChunksBySources.t.Fatalf("Unexpected call to RepositoryMock.GetTotalTextChunksBySources. %v %v", ctx, sources)
	return
}

// GetTotalTextChunksBySourcesAfterCounter returns a count of finished RepositoryMock.GetTotalTextChunksBySources invocations
func (mmGetTotalTextChunksBySources *RepositoryMock) GetTotalTextChunksBySourcesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotalTextChunksBySources.afterGetTotalTextChunksBySourcesCounter)
}

// GetTotalTextChunksBySourcesBeforeCounter returns a count of RepositoryMock.GetTotalTextChunksBySources invocations
func (mmGetTotalTextChunksBySources *RepositoryMock) GetTotalTextChunksBySourcesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotalTextChunksBySources.beforeGetTotalTextChunksBySourcesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetTotalTextChunksBySources.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTotalTextChunksBySources *mRepositoryMockGetTotalTextChunksBySources) Calls() []*RepositoryMockGetTotalTextChunksBySourcesParams {
	mmGetTotalTextChunksBySources.mutex.RLock()

	argCopy := make([]*RepositoryMockGetTotalTextChunksBySourcesParams, len(mmGetTotalTextChunksBySources.callArgs))
	copy(argCopy, mmGetTotalTextChunksBySources.callArgs)

	mmGetTotalTextChunksBySources.mutex.RUnlock()

	return argCopy
}

// MinimockGetTotalTextChunksBySourcesDone returns true if the count of the GetTotalTextChunksBySources invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetTotalTextChunksBySourcesDone() bool {
	if m.GetTotalTextChunksBySourcesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetTotalTextChunksBySourcesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTotalTextChunksBySourcesMock.invocationsDone()
}

// MinimockGetTotalTextChunksBySourcesInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetTotalTextChunksBySourcesInspect() {
	for _, e := range m.GetTotalTextChunksBySourcesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetTotalTextChunksBySources at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetTotalTextChunksBySourcesCounter := mm_atomic.LoadUint64(&m.afterGetTotalTextChunksBySourcesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTotalTextChunksBySourcesMock.defaultExpectation != nil && afterGetTotalTextChunksBySourcesCounter < 1 {
		if m.GetTotalTextChunksBySourcesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetTotalTextChunksBySources at\n%s", m.GetTotalTextChunksBySourcesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetTotalTextChunksBySources at\n%s with params: %#v", m.GetTotalTextChunksBySourcesMock.defaultExpectation.expectationOrigins.origin, *m.GetTotalTextChunksBySourcesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTotalTextChunksBySources != nil && afterGetTotalTextChunksBySourcesCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetTotalTextChunksBySources at\n%s", m.funcGetTotalTextChunksBySourcesOrigin)
	}

	if !m.GetTotalTextChunksBySourcesMock.invocationsDone() && afterGetTotalTextChunksBySourcesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetTotalTextChunksBySources at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetTotalTextChunksBySourcesMock.expectedInvocations), m.GetTotalTextChunksBySourcesMock.expectedInvocationsOrigin, afterGetTotalTextChunksBySourcesCounter)
	}
}

type mRepositoryMockGetTotalTokensByListKBUIDs struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetTotalTokensByListKBUIDsExpectation
	expectations       []*RepositoryMockGetTotalTokensByListKBUIDsExpectation

	callArgs []*RepositoryMockGetTotalTokensByListKBUIDsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetTotalTokensByListKBUIDsExpectation specifies expectation struct of the Repository.GetTotalTokensByListKBUIDs
type RepositoryMockGetTotalTokensByListKBUIDsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetTotalTokensByListKBUIDsParams
	paramPtrs          *RepositoryMockGetTotalTokensByListKBUIDsParamPtrs
	expectationOrigins RepositoryMockGetTotalTokensByListKBUIDsExpectationOrigins
	results            *RepositoryMockGetTotalTokensByListKBUIDsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetTotalTokensByListKBUIDsParams contains parameters of the Repository.GetTotalTokensByListKBUIDs
type RepositoryMockGetTotalTokensByListKBUIDsParams struct {
	ctx    context.Context
	kbUIDs []types.KBUIDType
}

// RepositoryMockGetTotalTokensByListKBUIDsParamPtrs contains pointers to parameters of the Repository.GetTotalTokensByListKBUIDs
type RepositoryMockGetTotalTokensByListKBUIDsParamPtrs struct {
	ctx    *context.Context
	kbUIDs *[]types.KBUIDType
}

// RepositoryMockGetTotalTokensByListKBUIDsResults contains results of the Repository.GetTotalTokensByListKBUIDs
type RepositoryMockGetTotalTokensByListKBUIDsResults struct {
	m1  map[types.KBUIDType]int
	err error
}

// RepositoryMockGetTotalTokensByListKBUIDsOrigins contains origins of expectations of the Repository.GetTotalTokensByListKBUIDs
type RepositoryMockGetTotalTokensByListKBUIDsExpectationOrigins struct {
	origin       string
	originCtx    string
	originKbUIDs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetTotalTokensByListKBUIDs *mRepositoryMockGetTotalTokensByListKBUIDs) Optional() *mRepositoryMockGetTotalTokensByListKBUIDs {
	mmGetTotalTokensByListKBUIDs.optional = true
	return mmGetTotalTokensByListKBUIDs
}

// Expect sets up expected params for Repository.GetTotalTokensByListKBUIDs
func (mmGetTotalTokensByListKBUIDs *mRepositoryMockGetTotalTokensByListKBUIDs) Expect(ctx context.Context, kbUIDs []types.KBUIDType) *mRepositoryMockGetTotalTokensByListKBUIDs {
	if mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDs != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryMock.GetTotalTokensByListKBUIDs mock is already set by Set")
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation == nil {
		mmGetTotalTokensByListKBUIDs.defaultExpectation = &RepositoryMockGetTotalTokensByListKBUIDsExpectation{}
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation.paramPtrs != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryMock.GetTotalTokensByListKBUIDs mock is already set by ExpectParams functions")
	}

	mmGetTotalTokensByListKBUIDs.defaultExpectation.params = &RepositoryMockGetTotalTokensByListKBUIDsParams{ctx, kbUIDs}
	mmGetTotalTokensByListKBUIDs.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetTotalTokensByListKBUIDs.expectations {
		if minimock.Equal(e.params, mmGetTotalTokensByListKBUIDs.defaultExpectation.params) {
			mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTotalTokensByListKBUIDs.defaultExpectation.params)
		}
	}

	return mmGetTotalTokensByListKBUIDs
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetTotalTokensByListKBUIDs
func (mmGetTotalTokensByListKBUIDs *mRepositoryMockGetTotalTokensByListKBUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetTotalTokensByListKBUIDs {
	if mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDs != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryMock.GetTotalTokensByListKBUIDs mock is already set by Set")
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation == nil {
		mmGetTotalTokensByListKBUIDs.defaultExpectation = &RepositoryMockGetTotalTokensByListKBUIDsExpectation{}
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation.params != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryMock.GetTotalTokensByListKBUIDs mock is already set by Expect")
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation.paramPtrs == nil {
		mmGetTotalTokensByListKBUIDs.defaultExpectation.paramPtrs = &RepositoryMockGetTotalTokensByListKBUIDsParamPtrs{}
	}
	mmGetTotalTokensByListKBUIDs.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetTotalTokensByListKBUIDs.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetTotalTokensByListKBUIDs
}

// ExpectKbUIDsParam2 sets up expected param kbUIDs for Repository.GetTotalTokensByListKBUIDs
func (mmGetTotalTokensByListKBUIDs *mRepositoryMockGetTotalTokensByListKBUIDs) ExpectKbUIDsParam2(kbUIDs []types.KBUIDType) *mRepositoryMockGetTotalTokensByListKBUIDs {
	if mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDs != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryMock.GetTotalTokensByListKBUIDs mock is already set by Set")
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation == nil {
		mmGetTotalTokensByListKBUIDs.defaultExpectation = &RepositoryMockGetTotalTokensByListKBUIDsExpectation{}
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation.params != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryMock.GetTotalTokensByListKBUIDs mock is already set by Expect")
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation.paramPtrs == nil {
		mmGetTotalTokensByListKBUIDs.defaultExpectation.paramPtrs = &RepositoryMockGetTotalTokensByListKBUIDsParamPtrs{}
	}
	mmGetTotalTokensByListKBUIDs.defaultExpectation.paramPtrs.kbUIDs = &kbUIDs
	mmGetTotalTokensByListKBUIDs.defaultExpectation.expectationOrigins.originKbUIDs = minimock.CallerInfo(1)

	return mmGetTotalTokensByListKBUIDs
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetTotalTokensByListKBUIDs
func (mmGetTotalTokensByListKBUIDs *mRepositoryMockGetTotalTokensByListKBUIDs) Inspect(f func(ctx context.Context, kbUIDs []types.KBUIDType)) *mRepositoryMockGetTotalTokensByListKBUIDs {
	if mmGetTotalTokensByListKBUIDs.mock.inspectFuncGetTotalTokensByListKBUIDs != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetTotalTokensByListKBUIDs")
	}

	mmGetTotalTokensByListKBUIDs.mock.inspectFuncGetTotalTokensByListKBUIDs = f

	return mmGetTotalTokensByListKBUIDs
}

// Return sets up results that will be returned by Repository.GetTotalTokensByListKBUIDs
func (mmGetTotalTokensByListKBUIDs *mRepositoryMockGetTotalTokensByListKBUIDs) Return(m1 map[types.KBUIDType]int, err error) *RepositoryMock {
	if mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDs != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryMock.GetTotalTokensByListKBUIDs mock is already set by Set")
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation == nil {
		mmGetTotalTokensByListKBUIDs.defaultExpectation = &RepositoryMockGetTotalTokensByListKBUIDsExpectation{mock: mmGetTotalTokensByListKBUIDs.mock}
	}
	mmGetTotalTokensByListKBUIDs.defaultExpectation.results = &RepositoryMockGetTotalTokensByListKBUIDsResults{m1, err}
	mmGetTotalTokensByListKBUIDs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetTotalTokensByListKBUIDs.mock
}

// Set uses given function f to mock the Repository.GetTotalTokensByListKBUIDs method
func (mmGetTotalTokensByListKBUIDs *mRepositoryMockGetTotalTokensByListKBUIDs) Set(f func(ctx context.Context, kbUIDs []types.KBUIDType) (m1 map[types.KBUIDType]int, err error)) *RepositoryMock {
	if mmGetTotalTokensByListKBUIDs.defaultExpectation != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("Default expectation is already set for the Repository.GetTotalTokensByListKBUIDs method")
	}

	if len(mmGetTotalTokensByListKBUIDs.expectations) > 0 {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("Some expectations are already set for the Repository.GetTotalTokensByListKBUIDs method")
	}

	mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDs = f
	mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDsOrigin = minimock.CallerInfo(1)
	return mmGetTotalTokensByListKBUIDs.mock
}

// When sets expectation for the Repository.GetTotalTokensByListKBUIDs which will trigger the result defined by the following
// Then helper
func (mmGetTotalTokensByListKBUIDs *mRepositoryMockGetTotalTokensByListKBUIDs) When(ctx context.Context, kbUIDs []types.KBUIDType) *RepositoryMockGetTotalTokensByListKBUIDsExpectation {
	if mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDs != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryMock.GetTotalTokensByListKBUIDs mock is already set by Set")
	}

	expectation := &RepositoryMockGetTotalTokensByListKBUIDsExpectation{
		mock:               mmGetTotalTokensByListKBUIDs.mock,
		params:             &RepositoryMockGetTotalTokensByListKBUIDsParams{ctx, kbUIDs},
		expectationOrigins: RepositoryMockGetTotalTokensByListKBUIDsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetTotalTokensByListKBUIDs.expectations = append(mmGetTotalTokensByListKBUIDs.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetTotalTokensByListKBUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetTotalTokensByListKBUIDsExpectation) Then(m1 map[types.KBUIDType]int, err error) *RepositoryMock {
	e.results = &RepositoryMockGetTotalTokensByListKBUIDsResults{m1, err}
	return e.mock
}

// Times sets number of times Repository.GetTotalTokensByListKBUIDs should be invoked
func (mmGetTotalTokensByListKBUIDs *mRepositoryMockGetTotalTokensByListKBUIDs) Times(n uint64) *mRepositoryMockGetTotalTokensByListKBUIDs {
	if n == 0 {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("Times of RepositoryMock.GetTotalTokensByListKBUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTotalTokensByListKBUIDs.expectedInvocations, n)
	mmGetTotalTokensByListKBUIDs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetTotalTokensByListKBUIDs
}

func (mmGetTotalTokensByListKBUIDs *mRepositoryMockGetTotalTokensByListKBUIDs) invocationsDone() bool {
	if len(mmGetTotalTokensByListKBUIDs.expectations) == 0 && mmGetTotalTokensByListKBUIDs.defaultExpectation == nil && mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTotalTokensByListKBUIDs.mock.afterGetTotalTokensByListKBUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTotalTokensByListKBUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTotalTokensByListKBUIDs implements mm_repository.Repository
func (mmGetTotalTokensByListKBUIDs *RepositoryMock) GetTotalTokensByListKBUIDs(ctx context.Context, kbUIDs []types.KBUIDType) (m1 map[types.KBUIDType]int, err error) {
	mm_atomic.AddUint64(&mmGetTotalTokensByListKBUIDs.beforeGetTotalTokensByListKBUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTotalTokensByListKBUIDs.afterGetTotalTokensByListKBUIDsCounter, 1)

	mmGetTotalTokensByListKBUIDs.t.Helper()

	if mmGetTotalTokensByListKBUIDs.inspectFuncGetTotalTokensByListKBUIDs != nil {
		mmGetTotalTokensByListKBUIDs.inspectFuncGetTotalTokensByListKBUIDs(ctx, kbUIDs)
	}

	mm_params := RepositoryMockGetTotalTokensByListKBUIDsParams{ctx, kbUIDs}

	// Record call args
	mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.mutex.Lock()
	mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.callArgs = append(mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.callArgs, &mm_params)
	mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.mutex.Unlock()

	for _, e := range mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetTotalTokensByListKBUIDsParams{ctx, kbUIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTotalTokensByListKBUIDs.t.Errorf("RepositoryMock.GetTotalTokensByListKBUIDs got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUIDs != nil && !minimock.Equal(*mm_want_ptrs.kbUIDs, mm_got.kbUIDs) {
				mmGetTotalTokensByListKBUIDs.t.Errorf("RepositoryMock.GetTotalTokensByListKBUIDs got unexpected parameter kbUIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.defaultExpectation.expectationOrigins.originKbUIDs, *mm_want_ptrs.kbUIDs, mm_got.kbUIDs, minimock.Diff(*mm_want_ptrs.kbUIDs, mm_got.kbUIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTotalTokensByListKBUIDs.t.Errorf("RepositoryMock.GetTotalTokensByListKBUIDs got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTotalTokensByListKBUIDs.t.Fatal("No results are set for the RepositoryMock.GetTotalTokensByListKBUIDs")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetTotalTokensByListKBUIDs.funcGetTotalTokensByListKBUIDs != nil {
		return mmGetTotalTokensByListKBUIDs.funcGetTotalTokensByListKBUIDs(ctx, kbUIDs)
	}
	mmGetTotalTokensByListKBUIDs.t.Fatalf("Unexpected call to RepositoryMock.GetTotalTokensByListKBUIDs. %v %v", ctx, kbUIDs)
	return
}

// GetTotalTokensByListKBUIDsAfterCounter returns a count of finished RepositoryMock.GetTotalTokensByListKBUIDs invocations
func (mmGetTotalTokensByListKBUIDs *RepositoryMock) GetTotalTokensByListKBUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotalTokensByListKBUIDs.afterGetTotalTokensByListKBUIDsCounter)
}

// GetTotalTokensByListKBUIDsBeforeCounter returns a count of RepositoryMock.GetTotalTokensByListKBUIDs invocations
func (mmGetTotalTokensByListKBUIDs *RepositoryMock) GetTotalTokensByListKBUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotalTokensByListKBUIDs.beforeGetTotalTokensByListKBUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetTotalTokensByListKBUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTotalTokensByListKBUIDs *mRepositoryMockGetTotalTokensByListKBUIDs) Calls() []*RepositoryMockGetTotalTokensByListKBUIDsParams {
	mmGetTotalTokensByListKBUIDs.mutex.RLock()

	argCopy := make([]*RepositoryMockGetTotalTokensByListKBUIDsParams, len(mmGetTotalTokensByListKBUIDs.callArgs))
	copy(argCopy, mmGetTotalTokensByListKBUIDs.callArgs)

	mmGetTotalTokensByListKBUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockGetTotalTokensByListKBUIDsDone returns true if the count of the GetTotalTokensByListKBUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetTotalTokensByListKBUIDsDone() bool {
	if m.GetTotalTokensByListKBUIDsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetTotalTokensByListKBUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTotalTokensByListKBUIDsMock.invocationsDone()
}

// MinimockGetTotalTokensByListKBUIDsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetTotalTokensByListKBUIDsInspect() {
	for _, e := range m.GetTotalTokensByListKBUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetTotalTokensByListKBUIDs at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetTotalTokensByListKBUIDsCounter := mm_atomic.LoadUint64(&m.afterGetTotalTokensByListKBUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTotalTokensByListKBUIDsMock.defaultExpectation != nil && afterGetTotalTokensByListKBUIDsCounter < 1 {
		if m.GetTotalTokensByListKBUIDsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetTotalTokensByListKBUIDs at\n%s", m.GetTotalTokensByListKBUIDsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetTotalTokensByListKBUIDs at\n%s with params: %#v", m.GetTotalTokensByListKBUIDsMock.defaultExpectation.expectationOrigins.origin, *m.GetTotalTokensByListKBUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTotalTokensByListKBUIDs != nil && afterGetTotalTokensByListKBUIDsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetTotalTokensByListKBUIDs at\n%s", m.funcGetTotalTokensByListKBUIDsOrigin)
	}

	if !m.GetTotalTokensByListKBUIDsMock.invocationsDone() && afterGetTotalTokensByListKBUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetTotalTokensByListKBUIDs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetTotalTokensByListKBUIDsMock.expectedInvocations), m.GetTotalTokensByListKBUIDsMock.expectedInvocationsOrigin, afterGetTotalTokensByListKBUIDsCounter)
	}
}

type mRepositoryMockHardDeleteConvertedFileByFileUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockHardDeleteConvertedFileByFileUIDExpectation
	expectations       []*RepositoryMockHardDeleteConvertedFileByFileUIDExpectation

	callArgs []*RepositoryMockHardDeleteConvertedFileByFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockHardDeleteConvertedFileByFileUIDExpectation specifies expectation struct of the Repository.HardDeleteConvertedFileByFileUID
type RepositoryMockHardDeleteConvertedFileByFileUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockHardDeleteConvertedFileByFileUIDParams
	paramPtrs          *RepositoryMockHardDeleteConvertedFileByFileUIDParamPtrs
	expectationOrigins RepositoryMockHardDeleteConvertedFileByFileUIDExpectationOrigins
	results            *RepositoryMockHardDeleteConvertedFileByFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockHardDeleteConvertedFileByFileUIDParams contains parameters of the Repository.HardDeleteConvertedFileByFileUID
type RepositoryMockHardDeleteConvertedFileByFileUIDParams struct {
	ctx     context.Context
	fileUID types.FileUIDType
}

// RepositoryMockHardDeleteConvertedFileByFileUIDParamPtrs contains pointers to parameters of the Repository.HardDeleteConvertedFileByFileUID
type RepositoryMockHardDeleteConvertedFileByFileUIDParamPtrs struct {
	ctx     *context.Context
	fileUID *types.FileUIDType
}

// RepositoryMockHardDeleteConvertedFileByFileUIDResults contains results of the Repository.HardDeleteConvertedFileByFileUID
type RepositoryMockHardDeleteConvertedFileByFileUIDResults struct {
	err error
}

// RepositoryMockHardDeleteConvertedFileByFileUIDOrigins contains origins of expectations of the Repository.HardDeleteConvertedFileByFileUID
type RepositoryMockHardDeleteConvertedFileByFileUIDExpectationOrigins struct {
	origin        string
	originCtx     string
	originFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHardDeleteConvertedFileByFileUID *mRepositoryMockHardDeleteConvertedFileByFileUID) Optional() *mRepositoryMockHardDeleteConvertedFileByFileUID {
	mmHardDeleteConvertedFileByFileUID.optional = true
	return mmHardDeleteConvertedFileByFileUID
}

// Expect sets up expected params for Repository.HardDeleteConvertedFileByFileUID
func (mmHardDeleteConvertedFileByFileUID *mRepositoryMockHardDeleteConvertedFileByFileUID) Expect(ctx context.Context, fileUID types.FileUIDType) *mRepositoryMockHardDeleteConvertedFileByFileUID {
	if mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUID != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteConvertedFileByFileUID mock is already set by Set")
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation == nil {
		mmHardDeleteConvertedFileByFileUID.defaultExpectation = &RepositoryMockHardDeleteConvertedFileByFileUIDExpectation{}
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteConvertedFileByFileUID mock is already set by ExpectParams functions")
	}

	mmHardDeleteConvertedFileByFileUID.defaultExpectation.params = &RepositoryMockHardDeleteConvertedFileByFileUIDParams{ctx, fileUID}
	mmHardDeleteConvertedFileByFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHardDeleteConvertedFileByFileUID.expectations {
		if minimock.Equal(e.params, mmHardDeleteConvertedFileByFileUID.defaultExpectation.params) {
			mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHardDeleteConvertedFileByFileUID.defaultExpectation.params)
		}
	}

	return mmHardDeleteConvertedFileByFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.HardDeleteConvertedFileByFileUID
func (mmHardDeleteConvertedFileByFileUID *mRepositoryMockHardDeleteConvertedFileByFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockHardDeleteConvertedFileByFileUID {
	if mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUID != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteConvertedFileByFileUID mock is already set by Set")
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation == nil {
		mmHardDeleteConvertedFileByFileUID.defaultExpectation = &RepositoryMockHardDeleteConvertedFileByFileUIDExpectation{}
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation.params != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteConvertedFileByFileUID mock is already set by Expect")
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs = &RepositoryMockHardDeleteConvertedFileByFileUIDParamPtrs{}
	}
	mmHardDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmHardDeleteConvertedFileByFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmHardDeleteConvertedFileByFileUID
}

// ExpectFileUIDParam2 sets up expected param fileUID for Repository.HardDeleteConvertedFileByFileUID
func (mmHardDeleteConvertedFileByFileUID *mRepositoryMockHardDeleteConvertedFileByFileUID) ExpectFileUIDParam2(fileUID types.FileUIDType) *mRepositoryMockHardDeleteConvertedFileByFileUID {
	if mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUID != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteConvertedFileByFileUID mock is already set by Set")
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation == nil {
		mmHardDeleteConvertedFileByFileUID.defaultExpectation = &RepositoryMockHardDeleteConvertedFileByFileUIDExpectation{}
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation.params != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteConvertedFileByFileUID mock is already set by Expect")
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs = &RepositoryMockHardDeleteConvertedFileByFileUIDParamPtrs{}
	}
	mmHardDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmHardDeleteConvertedFileByFileUID.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmHardDeleteConvertedFileByFileUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.HardDeleteConvertedFileByFileUID
func (mmHardDeleteConvertedFileByFileUID *mRepositoryMockHardDeleteConvertedFileByFileUID) Inspect(f func(ctx context.Context, fileUID types.FileUIDType)) *mRepositoryMockHardDeleteConvertedFileByFileUID {
	if mmHardDeleteConvertedFileByFileUID.mock.inspectFuncHardDeleteConvertedFileByFileUID != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.HardDeleteConvertedFileByFileUID")
	}

	mmHardDeleteConvertedFileByFileUID.mock.inspectFuncHardDeleteConvertedFileByFileUID = f

	return mmHardDeleteConvertedFileByFileUID
}

// Return sets up results that will be returned by Repository.HardDeleteConvertedFileByFileUID
func (mmHardDeleteConvertedFileByFileUID *mRepositoryMockHardDeleteConvertedFileByFileUID) Return(err error) *RepositoryMock {
	if mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUID != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteConvertedFileByFileUID mock is already set by Set")
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation == nil {
		mmHardDeleteConvertedFileByFileUID.defaultExpectation = &RepositoryMockHardDeleteConvertedFileByFileUIDExpectation{mock: mmHardDeleteConvertedFileByFileUID.mock}
	}
	mmHardDeleteConvertedFileByFileUID.defaultExpectation.results = &RepositoryMockHardDeleteConvertedFileByFileUIDResults{err}
	mmHardDeleteConvertedFileByFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHardDeleteConvertedFileByFileUID.mock
}

// Set uses given function f to mock the Repository.HardDeleteConvertedFileByFileUID method
func (mmHardDeleteConvertedFileByFileUID *mRepositoryMockHardDeleteConvertedFileByFileUID) Set(f func(ctx context.Context, fileUID types.FileUIDType) (err error)) *RepositoryMock {
	if mmHardDeleteConvertedFileByFileUID.defaultExpectation != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("Default expectation is already set for the Repository.HardDeleteConvertedFileByFileUID method")
	}

	if len(mmHardDeleteConvertedFileByFileUID.expectations) > 0 {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("Some expectations are already set for the Repository.HardDeleteConvertedFileByFileUID method")
	}

	mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUID = f
	mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUIDOrigin = minimock.CallerInfo(1)
	return mmHardDeleteConvertedFileByFileUID.mock
}

// When sets expectation for the Repository.HardDeleteConvertedFileByFileUID which will trigger the result defined by the following
// Then helper
func (mmHardDeleteConvertedFileByFileUID *mRepositoryMockHardDeleteConvertedFileByFileUID) When(ctx context.Context, fileUID types.FileUIDType) *RepositoryMockHardDeleteConvertedFileByFileUIDExpectation {
	if mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUID != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteConvertedFileByFileUID mock is already set by Set")
	}

	expectation := &RepositoryMockHardDeleteConvertedFileByFileUIDExpectation{
		mock:               mmHardDeleteConvertedFileByFileUID.mock,
		params:             &RepositoryMockHardDeleteConvertedFileByFileUIDParams{ctx, fileUID},
		expectationOrigins: RepositoryMockHardDeleteConvertedFileByFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHardDeleteConvertedFileByFileUID.expectations = append(mmHardDeleteConvertedFileByFileUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.HardDeleteConvertedFileByFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockHardDeleteConvertedFileByFileUIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockHardDeleteConvertedFileByFileUIDResults{err}
	return e.mock
}

// Times sets number of times Repository.HardDeleteConvertedFileByFileUID should be invoked
func (mmHardDeleteConvertedFileByFileUID *mRepositoryMockHardDeleteConvertedFileByFileUID) Times(n uint64) *mRepositoryMockHardDeleteConvertedFileByFileUID {
	if n == 0 {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("Times of RepositoryMock.HardDeleteConvertedFileByFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHardDeleteConvertedFileByFileUID.expectedInvocations, n)
	mmHardDeleteConvertedFileByFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHardDeleteConvertedFileByFileUID
}

func (mmHardDeleteConvertedFileByFileUID *mRepositoryMockHardDeleteConvertedFileByFileUID) invocationsDone() bool {
	if len(mmHardDeleteConvertedFileByFileUID.expectations) == 0 && mmHardDeleteConvertedFileByFileUID.defaultExpectation == nil && mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHardDeleteConvertedFileByFileUID.mock.afterHardDeleteConvertedFileByFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHardDeleteConvertedFileByFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HardDeleteConvertedFileByFileUID implements mm_repository.Repository
func (mmHardDeleteConvertedFileByFileUID *RepositoryMock) HardDeleteConvertedFileByFileUID(ctx context.Context, fileUID types.FileUIDType) (err error) {
	mm_atomic.AddUint64(&mmHardDeleteConvertedFileByFileUID.beforeHardDeleteConvertedFileByFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmHardDeleteConvertedFileByFileUID.afterHardDeleteConvertedFileByFileUIDCounter, 1)

	mmHardDeleteConvertedFileByFileUID.t.Helper()

	if mmHardDeleteConvertedFileByFileUID.inspectFuncHardDeleteConvertedFileByFileUID != nil {
		mmHardDeleteConvertedFileByFileUID.inspectFuncHardDeleteConvertedFileByFileUID(ctx, fileUID)
	}

	mm_params := RepositoryMockHardDeleteConvertedFileByFileUIDParams{ctx, fileUID}

	// Record call args
	mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.mutex.Lock()
	mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.callArgs = append(mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.callArgs, &mm_params)
	mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.mutex.Unlock()

	for _, e := range mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockHardDeleteConvertedFileByFileUIDParams{ctx, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHardDeleteConvertedFileByFileUID.t.Errorf("RepositoryMock.HardDeleteConvertedFileByFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmHardDeleteConvertedFileByFileUID.t.Errorf("RepositoryMock.HardDeleteConvertedFileByFileUID got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHardDeleteConvertedFileByFileUID.t.Errorf("RepositoryMock.HardDeleteConvertedFileByFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmHardDeleteConvertedFileByFileUID.t.Fatal("No results are set for the RepositoryMock.HardDeleteConvertedFileByFileUID")
		}
		return (*mm_results).err
	}
	if mmHardDeleteConvertedFileByFileUID.funcHardDeleteConvertedFileByFileUID != nil {
		return mmHardDeleteConvertedFileByFileUID.funcHardDeleteConvertedFileByFileUID(ctx, fileUID)
	}
	mmHardDeleteConvertedFileByFileUID.t.Fatalf("Unexpected call to RepositoryMock.HardDeleteConvertedFileByFileUID. %v %v", ctx, fileUID)
	return
}

// HardDeleteConvertedFileByFileUIDAfterCounter returns a count of finished RepositoryMock.HardDeleteConvertedFileByFileUID invocations
func (mmHardDeleteConvertedFileByFileUID *RepositoryMock) HardDeleteConvertedFileByFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteConvertedFileByFileUID.afterHardDeleteConvertedFileByFileUIDCounter)
}

// HardDeleteConvertedFileByFileUIDBeforeCounter returns a count of RepositoryMock.HardDeleteConvertedFileByFileUID invocations
func (mmHardDeleteConvertedFileByFileUID *RepositoryMock) HardDeleteConvertedFileByFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteConvertedFileByFileUID.beforeHardDeleteConvertedFileByFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.HardDeleteConvertedFileByFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHardDeleteConvertedFileByFileUID *mRepositoryMockHardDeleteConvertedFileByFileUID) Calls() []*RepositoryMockHardDeleteConvertedFileByFileUIDParams {
	mmHardDeleteConvertedFileByFileUID.mutex.RLock()

	argCopy := make([]*RepositoryMockHardDeleteConvertedFileByFileUIDParams, len(mmHardDeleteConvertedFileByFileUID.callArgs))
	copy(argCopy, mmHardDeleteConvertedFileByFileUID.callArgs)

	mmHardDeleteConvertedFileByFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockHardDeleteConvertedFileByFileUIDDone returns true if the count of the HardDeleteConvertedFileByFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockHardDeleteConvertedFileByFileUIDDone() bool {
	if m.HardDeleteConvertedFileByFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HardDeleteConvertedFileByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HardDeleteConvertedFileByFileUIDMock.invocationsDone()
}

// MinimockHardDeleteConvertedFileByFileUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockHardDeleteConvertedFileByFileUIDInspect() {
	for _, e := range m.HardDeleteConvertedFileByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteConvertedFileByFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHardDeleteConvertedFileByFileUIDCounter := mm_atomic.LoadUint64(&m.afterHardDeleteConvertedFileByFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HardDeleteConvertedFileByFileUIDMock.defaultExpectation != nil && afterHardDeleteConvertedFileByFileUIDCounter < 1 {
		if m.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteConvertedFileByFileUID at\n%s", m.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteConvertedFileByFileUID at\n%s with params: %#v", m.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHardDeleteConvertedFileByFileUID != nil && afterHardDeleteConvertedFileByFileUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.HardDeleteConvertedFileByFileUID at\n%s", m.funcHardDeleteConvertedFileByFileUIDOrigin)
	}

	if !m.HardDeleteConvertedFileByFileUIDMock.invocationsDone() && afterHardDeleteConvertedFileByFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.HardDeleteConvertedFileByFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HardDeleteConvertedFileByFileUIDMock.expectedInvocations), m.HardDeleteConvertedFileByFileUIDMock.expectedInvocationsOrigin, afterHardDeleteConvertedFileByFileUIDCounter)
	}
}

type mRepositoryMockHardDeleteEmbeddingsByKBFileUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockHardDeleteEmbeddingsByKBFileUIDExpectation
	expectations       []*RepositoryMockHardDeleteEmbeddingsByKBFileUIDExpectation

	callArgs []*RepositoryMockHardDeleteEmbeddingsByKBFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockHardDeleteEmbeddingsByKBFileUIDExpectation specifies expectation struct of the Repository.HardDeleteEmbeddingsByKBFileUID
type RepositoryMockHardDeleteEmbeddingsByKBFileUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockHardDeleteEmbeddingsByKBFileUIDParams
	paramPtrs          *RepositoryMockHardDeleteEmbeddingsByKBFileUIDParamPtrs
	expectationOrigins RepositoryMockHardDeleteEmbeddingsByKBFileUIDExpectationOrigins
	results            *RepositoryMockHardDeleteEmbeddingsByKBFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockHardDeleteEmbeddingsByKBFileUIDParams contains parameters of the Repository.HardDeleteEmbeddingsByKBFileUID
type RepositoryMockHardDeleteEmbeddingsByKBFileUIDParams struct {
	ctx       context.Context
	kbFileUID types.FileUIDType
}

// RepositoryMockHardDeleteEmbeddingsByKBFileUIDParamPtrs contains pointers to parameters of the Repository.HardDeleteEmbeddingsByKBFileUID
type RepositoryMockHardDeleteEmbeddingsByKBFileUIDParamPtrs struct {
	ctx       *context.Context
	kbFileUID *types.FileUIDType
}

// RepositoryMockHardDeleteEmbeddingsByKBFileUIDResults contains results of the Repository.HardDeleteEmbeddingsByKBFileUID
type RepositoryMockHardDeleteEmbeddingsByKBFileUIDResults struct {
	err error
}

// RepositoryMockHardDeleteEmbeddingsByKBFileUIDOrigins contains origins of expectations of the Repository.HardDeleteEmbeddingsByKBFileUID
type RepositoryMockHardDeleteEmbeddingsByKBFileUIDExpectationOrigins struct {
	origin          string
	originCtx       string
	originKbFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHardDeleteEmbeddingsByKBFileUID *mRepositoryMockHardDeleteEmbeddingsByKBFileUID) Optional() *mRepositoryMockHardDeleteEmbeddingsByKBFileUID {
	mmHardDeleteEmbeddingsByKBFileUID.optional = true
	return mmHardDeleteEmbeddingsByKBFileUID
}

// Expect sets up expected params for Repository.HardDeleteEmbeddingsByKBFileUID
func (mmHardDeleteEmbeddingsByKBFileUID *mRepositoryMockHardDeleteEmbeddingsByKBFileUID) Expect(ctx context.Context, kbFileUID types.FileUIDType) *mRepositoryMockHardDeleteEmbeddingsByKBFileUID {
	if mmHardDeleteEmbeddingsByKBFileUID.mock.funcHardDeleteEmbeddingsByKBFileUID != nil {
		mmHardDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBFileUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation = &RepositoryMockHardDeleteEmbeddingsByKBFileUIDExpectation{}
	}

	if mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.paramPtrs != nil {
		mmHardDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBFileUID mock is already set by ExpectParams functions")
	}

	mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.params = &RepositoryMockHardDeleteEmbeddingsByKBFileUIDParams{ctx, kbFileUID}
	mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHardDeleteEmbeddingsByKBFileUID.expectations {
		if minimock.Equal(e.params, mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.params) {
			mmHardDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.params)
		}
	}

	return mmHardDeleteEmbeddingsByKBFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.HardDeleteEmbeddingsByKBFileUID
func (mmHardDeleteEmbeddingsByKBFileUID *mRepositoryMockHardDeleteEmbeddingsByKBFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockHardDeleteEmbeddingsByKBFileUID {
	if mmHardDeleteEmbeddingsByKBFileUID.mock.funcHardDeleteEmbeddingsByKBFileUID != nil {
		mmHardDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBFileUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation = &RepositoryMockHardDeleteEmbeddingsByKBFileUIDExpectation{}
	}

	if mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.params != nil {
		mmHardDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBFileUID mock is already set by Expect")
	}

	if mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.paramPtrs = &RepositoryMockHardDeleteEmbeddingsByKBFileUIDParamPtrs{}
	}
	mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmHardDeleteEmbeddingsByKBFileUID
}

// ExpectKbFileUIDParam2 sets up expected param kbFileUID for Repository.HardDeleteEmbeddingsByKBFileUID
func (mmHardDeleteEmbeddingsByKBFileUID *mRepositoryMockHardDeleteEmbeddingsByKBFileUID) ExpectKbFileUIDParam2(kbFileUID types.FileUIDType) *mRepositoryMockHardDeleteEmbeddingsByKBFileUID {
	if mmHardDeleteEmbeddingsByKBFileUID.mock.funcHardDeleteEmbeddingsByKBFileUID != nil {
		mmHardDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBFileUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation = &RepositoryMockHardDeleteEmbeddingsByKBFileUIDExpectation{}
	}

	if mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.params != nil {
		mmHardDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBFileUID mock is already set by Expect")
	}

	if mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.paramPtrs = &RepositoryMockHardDeleteEmbeddingsByKBFileUIDParamPtrs{}
	}
	mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.paramPtrs.kbFileUID = &kbFileUID
	mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.expectationOrigins.originKbFileUID = minimock.CallerInfo(1)

	return mmHardDeleteEmbeddingsByKBFileUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.HardDeleteEmbeddingsByKBFileUID
func (mmHardDeleteEmbeddingsByKBFileUID *mRepositoryMockHardDeleteEmbeddingsByKBFileUID) Inspect(f func(ctx context.Context, kbFileUID types.FileUIDType)) *mRepositoryMockHardDeleteEmbeddingsByKBFileUID {
	if mmHardDeleteEmbeddingsByKBFileUID.mock.inspectFuncHardDeleteEmbeddingsByKBFileUID != nil {
		mmHardDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.HardDeleteEmbeddingsByKBFileUID")
	}

	mmHardDeleteEmbeddingsByKBFileUID.mock.inspectFuncHardDeleteEmbeddingsByKBFileUID = f

	return mmHardDeleteEmbeddingsByKBFileUID
}

// Return sets up results that will be returned by Repository.HardDeleteEmbeddingsByKBFileUID
func (mmHardDeleteEmbeddingsByKBFileUID *mRepositoryMockHardDeleteEmbeddingsByKBFileUID) Return(err error) *RepositoryMock {
	if mmHardDeleteEmbeddingsByKBFileUID.mock.funcHardDeleteEmbeddingsByKBFileUID != nil {
		mmHardDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBFileUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation = &RepositoryMockHardDeleteEmbeddingsByKBFileUIDExpectation{mock: mmHardDeleteEmbeddingsByKBFileUID.mock}
	}
	mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.results = &RepositoryMockHardDeleteEmbeddingsByKBFileUIDResults{err}
	mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHardDeleteEmbeddingsByKBFileUID.mock
}

// Set uses given function f to mock the Repository.HardDeleteEmbeddingsByKBFileUID method
func (mmHardDeleteEmbeddingsByKBFileUID *mRepositoryMockHardDeleteEmbeddingsByKBFileUID) Set(f func(ctx context.Context, kbFileUID types.FileUIDType) (err error)) *RepositoryMock {
	if mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation != nil {
		mmHardDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("Default expectation is already set for the Repository.HardDeleteEmbeddingsByKBFileUID method")
	}

	if len(mmHardDeleteEmbeddingsByKBFileUID.expectations) > 0 {
		mmHardDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("Some expectations are already set for the Repository.HardDeleteEmbeddingsByKBFileUID method")
	}

	mmHardDeleteEmbeddingsByKBFileUID.mock.funcHardDeleteEmbeddingsByKBFileUID = f
	mmHardDeleteEmbeddingsByKBFileUID.mock.funcHardDeleteEmbeddingsByKBFileUIDOrigin = minimock.CallerInfo(1)
	return mmHardDeleteEmbeddingsByKBFileUID.mock
}

// When sets expectation for the Repository.HardDeleteEmbeddingsByKBFileUID which will trigger the result defined by the following
// Then helper
func (mmHardDeleteEmbeddingsByKBFileUID *mRepositoryMockHardDeleteEmbeddingsByKBFileUID) When(ctx context.Context, kbFileUID types.FileUIDType) *RepositoryMockHardDeleteEmbeddingsByKBFileUIDExpectation {
	if mmHardDeleteEmbeddingsByKBFileUID.mock.funcHardDeleteEmbeddingsByKBFileUID != nil {
		mmHardDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBFileUID mock is already set by Set")
	}

	expectation := &RepositoryMockHardDeleteEmbeddingsByKBFileUIDExpectation{
		mock:               mmHardDeleteEmbeddingsByKBFileUID.mock,
		params:             &RepositoryMockHardDeleteEmbeddingsByKBFileUIDParams{ctx, kbFileUID},
		expectationOrigins: RepositoryMockHardDeleteEmbeddingsByKBFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHardDeleteEmbeddingsByKBFileUID.expectations = append(mmHardDeleteEmbeddingsByKBFileUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.HardDeleteEmbeddingsByKBFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockHardDeleteEmbeddingsByKBFileUIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockHardDeleteEmbeddingsByKBFileUIDResults{err}
	return e.mock
}

// Times sets number of times Repository.HardDeleteEmbeddingsByKBFileUID should be invoked
func (mmHardDeleteEmbeddingsByKBFileUID *mRepositoryMockHardDeleteEmbeddingsByKBFileUID) Times(n uint64) *mRepositoryMockHardDeleteEmbeddingsByKBFileUID {
	if n == 0 {
		mmHardDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("Times of RepositoryMock.HardDeleteEmbeddingsByKBFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHardDeleteEmbeddingsByKBFileUID.expectedInvocations, n)
	mmHardDeleteEmbeddingsByKBFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHardDeleteEmbeddingsByKBFileUID
}

func (mmHardDeleteEmbeddingsByKBFileUID *mRepositoryMockHardDeleteEmbeddingsByKBFileUID) invocationsDone() bool {
	if len(mmHardDeleteEmbeddingsByKBFileUID.expectations) == 0 && mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation == nil && mmHardDeleteEmbeddingsByKBFileUID.mock.funcHardDeleteEmbeddingsByKBFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKBFileUID.mock.afterHardDeleteEmbeddingsByKBFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKBFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HardDeleteEmbeddingsByKBFileUID implements mm_repository.Repository
func (mmHardDeleteEmbeddingsByKBFileUID *RepositoryMock) HardDeleteEmbeddingsByKBFileUID(ctx context.Context, kbFileUID types.FileUIDType) (err error) {
	mm_atomic.AddUint64(&mmHardDeleteEmbeddingsByKBFileUID.beforeHardDeleteEmbeddingsByKBFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmHardDeleteEmbeddingsByKBFileUID.afterHardDeleteEmbeddingsByKBFileUIDCounter, 1)

	mmHardDeleteEmbeddingsByKBFileUID.t.Helper()

	if mmHardDeleteEmbeddingsByKBFileUID.inspectFuncHardDeleteEmbeddingsByKBFileUID != nil {
		mmHardDeleteEmbeddingsByKBFileUID.inspectFuncHardDeleteEmbeddingsByKBFileUID(ctx, kbFileUID)
	}

	mm_params := RepositoryMockHardDeleteEmbeddingsByKBFileUIDParams{ctx, kbFileUID}

	// Record call args
	mmHardDeleteEmbeddingsByKBFileUID.HardDeleteEmbeddingsByKBFileUIDMock.mutex.Lock()
	mmHardDeleteEmbeddingsByKBFileUID.HardDeleteEmbeddingsByKBFileUIDMock.callArgs = append(mmHardDeleteEmbeddingsByKBFileUID.HardDeleteEmbeddingsByKBFileUIDMock.callArgs, &mm_params)
	mmHardDeleteEmbeddingsByKBFileUID.HardDeleteEmbeddingsByKBFileUIDMock.mutex.Unlock()

	for _, e := range mmHardDeleteEmbeddingsByKBFileUID.HardDeleteEmbeddingsByKBFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHardDeleteEmbeddingsByKBFileUID.HardDeleteEmbeddingsByKBFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHardDeleteEmbeddingsByKBFileUID.HardDeleteEmbeddingsByKBFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmHardDeleteEmbeddingsByKBFileUID.HardDeleteEmbeddingsByKBFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmHardDeleteEmbeddingsByKBFileUID.HardDeleteEmbeddingsByKBFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockHardDeleteEmbeddingsByKBFileUIDParams{ctx, kbFileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHardDeleteEmbeddingsByKBFileUID.t.Errorf("RepositoryMock.HardDeleteEmbeddingsByKBFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHardDeleteEmbeddingsByKBFileUID.HardDeleteEmbeddingsByKBFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbFileUID != nil && !minimock.Equal(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID) {
				mmHardDeleteEmbeddingsByKBFileUID.t.Errorf("RepositoryMock.HardDeleteEmbeddingsByKBFileUID got unexpected parameter kbFileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHardDeleteEmbeddingsByKBFileUID.HardDeleteEmbeddingsByKBFileUIDMock.defaultExpectation.expectationOrigins.originKbFileUID, *mm_want_ptrs.kbFileUID, mm_got.kbFileUID, minimock.Diff(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHardDeleteEmbeddingsByKBFileUID.t.Errorf("RepositoryMock.HardDeleteEmbeddingsByKBFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHardDeleteEmbeddingsByKBFileUID.HardDeleteEmbeddingsByKBFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHardDeleteEmbeddingsByKBFileUID.HardDeleteEmbeddingsByKBFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmHardDeleteEmbeddingsByKBFileUID.t.Fatal("No results are set for the RepositoryMock.HardDeleteEmbeddingsByKBFileUID")
		}
		return (*mm_results).err
	}
	if mmHardDeleteEmbeddingsByKBFileUID.funcHardDeleteEmbeddingsByKBFileUID != nil {
		return mmHardDeleteEmbeddingsByKBFileUID.funcHardDeleteEmbeddingsByKBFileUID(ctx, kbFileUID)
	}
	mmHardDeleteEmbeddingsByKBFileUID.t.Fatalf("Unexpected call to RepositoryMock.HardDeleteEmbeddingsByKBFileUID. %v %v", ctx, kbFileUID)
	return
}

// HardDeleteEmbeddingsByKBFileUIDAfterCounter returns a count of finished RepositoryMock.HardDeleteEmbeddingsByKBFileUID invocations
func (mmHardDeleteEmbeddingsByKBFileUID *RepositoryMock) HardDeleteEmbeddingsByKBFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKBFileUID.afterHardDeleteEmbeddingsByKBFileUIDCounter)
}

// HardDeleteEmbeddingsByKBFileUIDBeforeCounter returns a count of RepositoryMock.HardDeleteEmbeddingsByKBFileUID invocations
func (mmHardDeleteEmbeddingsByKBFileUID *RepositoryMock) HardDeleteEmbeddingsByKBFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKBFileUID.beforeHardDeleteEmbeddingsByKBFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.HardDeleteEmbeddingsByKBFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHardDeleteEmbeddingsByKBFileUID *mRepositoryMockHardDeleteEmbeddingsByKBFileUID) Calls() []*RepositoryMockHardDeleteEmbeddingsByKBFileUIDParams {
	mmHardDeleteEmbeddingsByKBFileUID.mutex.RLock()

	argCopy := make([]*RepositoryMockHardDeleteEmbeddingsByKBFileUIDParams, len(mmHardDeleteEmbeddingsByKBFileUID.callArgs))
	copy(argCopy, mmHardDeleteEmbeddingsByKBFileUID.callArgs)

	mmHardDeleteEmbeddingsByKBFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockHardDeleteEmbeddingsByKBFileUIDDone returns true if the count of the HardDeleteEmbeddingsByKBFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockHardDeleteEmbeddingsByKBFileUIDDone() bool {
	if m.HardDeleteEmbeddingsByKBFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HardDeleteEmbeddingsByKBFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HardDeleteEmbeddingsByKBFileUIDMock.invocationsDone()
}

// MinimockHardDeleteEmbeddingsByKBFileUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockHardDeleteEmbeddingsByKBFileUIDInspect() {
	for _, e := range m.HardDeleteEmbeddingsByKBFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteEmbeddingsByKBFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHardDeleteEmbeddingsByKBFileUIDCounter := mm_atomic.LoadUint64(&m.afterHardDeleteEmbeddingsByKBFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HardDeleteEmbeddingsByKBFileUIDMock.defaultExpectation != nil && afterHardDeleteEmbeddingsByKBFileUIDCounter < 1 {
		if m.HardDeleteEmbeddingsByKBFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteEmbeddingsByKBFileUID at\n%s", m.HardDeleteEmbeddingsByKBFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteEmbeddingsByKBFileUID at\n%s with params: %#v", m.HardDeleteEmbeddingsByKBFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.HardDeleteEmbeddingsByKBFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHardDeleteEmbeddingsByKBFileUID != nil && afterHardDeleteEmbeddingsByKBFileUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.HardDeleteEmbeddingsByKBFileUID at\n%s", m.funcHardDeleteEmbeddingsByKBFileUIDOrigin)
	}

	if !m.HardDeleteEmbeddingsByKBFileUIDMock.invocationsDone() && afterHardDeleteEmbeddingsByKBFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.HardDeleteEmbeddingsByKBFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HardDeleteEmbeddingsByKBFileUIDMock.expectedInvocations), m.HardDeleteEmbeddingsByKBFileUIDMock.expectedInvocationsOrigin, afterHardDeleteEmbeddingsByKBFileUIDCounter)
	}
}

type mRepositoryMockHardDeleteEmbeddingsByKBUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockHardDeleteEmbeddingsByKBUIDExpectation
	expectations       []*RepositoryMockHardDeleteEmbeddingsByKBUIDExpectation

	callArgs []*RepositoryMockHardDeleteEmbeddingsByKBUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockHardDeleteEmbeddingsByKBUIDExpectation specifies expectation struct of the Repository.HardDeleteEmbeddingsByKBUID
type RepositoryMockHardDeleteEmbeddingsByKBUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockHardDeleteEmbeddingsByKBUIDParams
	paramPtrs          *RepositoryMockHardDeleteEmbeddingsByKBUIDParamPtrs
	expectationOrigins RepositoryMockHardDeleteEmbeddingsByKBUIDExpectationOrigins
	results            *RepositoryMockHardDeleteEmbeddingsByKBUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockHardDeleteEmbeddingsByKBUIDParams contains parameters of the Repository.HardDeleteEmbeddingsByKBUID
type RepositoryMockHardDeleteEmbeddingsByKBUIDParams struct {
	ctx   context.Context
	kbUID types.KBUIDType
}

// RepositoryMockHardDeleteEmbeddingsByKBUIDParamPtrs contains pointers to parameters of the Repository.HardDeleteEmbeddingsByKBUID
type RepositoryMockHardDeleteEmbeddingsByKBUIDParamPtrs struct {
	ctx   *context.Context
	kbUID *types.KBUIDType
}

// RepositoryMockHardDeleteEmbeddingsByKBUIDResults contains results of the Repository.HardDeleteEmbeddingsByKBUID
type RepositoryMockHardDeleteEmbeddingsByKBUIDResults struct {
	err error
}

// RepositoryMockHardDeleteEmbeddingsByKBUIDOrigins contains origins of expectations of the Repository.HardDeleteEmbeddingsByKBUID
type RepositoryMockHardDeleteEmbeddingsByKBUIDExpectationOrigins struct {
	origin      string
	originCtx   string
	originKbUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHardDeleteEmbeddingsByKBUID *mRepositoryMockHardDeleteEmbeddingsByKBUID) Optional() *mRepositoryMockHardDeleteEmbeddingsByKBUID {
	mmHardDeleteEmbeddingsByKBUID.optional = true
	return mmHardDeleteEmbeddingsByKBUID
}

// Expect sets up expected params for Repository.HardDeleteEmbeddingsByKBUID
func (mmHardDeleteEmbeddingsByKBUID *mRepositoryMockHardDeleteEmbeddingsByKBUID) Expect(ctx context.Context, kbUID types.KBUIDType) *mRepositoryMockHardDeleteEmbeddingsByKBUID {
	if mmHardDeleteEmbeddingsByKBUID.mock.funcHardDeleteEmbeddingsByKBUID != nil {
		mmHardDeleteEmbeddingsByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKBUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKBUID.defaultExpectation = &RepositoryMockHardDeleteEmbeddingsByKBUIDExpectation{}
	}

	if mmHardDeleteEmbeddingsByKBUID.defaultExpectation.paramPtrs != nil {
		mmHardDeleteEmbeddingsByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBUID mock is already set by ExpectParams functions")
	}

	mmHardDeleteEmbeddingsByKBUID.defaultExpectation.params = &RepositoryMockHardDeleteEmbeddingsByKBUIDParams{ctx, kbUID}
	mmHardDeleteEmbeddingsByKBUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHardDeleteEmbeddingsByKBUID.expectations {
		if minimock.Equal(e.params, mmHardDeleteEmbeddingsByKBUID.defaultExpectation.params) {
			mmHardDeleteEmbeddingsByKBUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHardDeleteEmbeddingsByKBUID.defaultExpectation.params)
		}
	}

	return mmHardDeleteEmbeddingsByKBUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.HardDeleteEmbeddingsByKBUID
func (mmHardDeleteEmbeddingsByKBUID *mRepositoryMockHardDeleteEmbeddingsByKBUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockHardDeleteEmbeddingsByKBUID {
	if mmHardDeleteEmbeddingsByKBUID.mock.funcHardDeleteEmbeddingsByKBUID != nil {
		mmHardDeleteEmbeddingsByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKBUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKBUID.defaultExpectation = &RepositoryMockHardDeleteEmbeddingsByKBUIDExpectation{}
	}

	if mmHardDeleteEmbeddingsByKBUID.defaultExpectation.params != nil {
		mmHardDeleteEmbeddingsByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBUID mock is already set by Expect")
	}

	if mmHardDeleteEmbeddingsByKBUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteEmbeddingsByKBUID.defaultExpectation.paramPtrs = &RepositoryMockHardDeleteEmbeddingsByKBUIDParamPtrs{}
	}
	mmHardDeleteEmbeddingsByKBUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmHardDeleteEmbeddingsByKBUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmHardDeleteEmbeddingsByKBUID
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.HardDeleteEmbeddingsByKBUID
func (mmHardDeleteEmbeddingsByKBUID *mRepositoryMockHardDeleteEmbeddingsByKBUID) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockHardDeleteEmbeddingsByKBUID {
	if mmHardDeleteEmbeddingsByKBUID.mock.funcHardDeleteEmbeddingsByKBUID != nil {
		mmHardDeleteEmbeddingsByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKBUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKBUID.defaultExpectation = &RepositoryMockHardDeleteEmbeddingsByKBUIDExpectation{}
	}

	if mmHardDeleteEmbeddingsByKBUID.defaultExpectation.params != nil {
		mmHardDeleteEmbeddingsByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBUID mock is already set by Expect")
	}

	if mmHardDeleteEmbeddingsByKBUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteEmbeddingsByKBUID.defaultExpectation.paramPtrs = &RepositoryMockHardDeleteEmbeddingsByKBUIDParamPtrs{}
	}
	mmHardDeleteEmbeddingsByKBUID.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmHardDeleteEmbeddingsByKBUID.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmHardDeleteEmbeddingsByKBUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.HardDeleteEmbeddingsByKBUID
func (mmHardDeleteEmbeddingsByKBUID *mRepositoryMockHardDeleteEmbeddingsByKBUID) Inspect(f func(ctx context.Context, kbUID types.KBUIDType)) *mRepositoryMockHardDeleteEmbeddingsByKBUID {
	if mmHardDeleteEmbeddingsByKBUID.mock.inspectFuncHardDeleteEmbeddingsByKBUID != nil {
		mmHardDeleteEmbeddingsByKBUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.HardDeleteEmbeddingsByKBUID")
	}

	mmHardDeleteEmbeddingsByKBUID.mock.inspectFuncHardDeleteEmbeddingsByKBUID = f

	return mmHardDeleteEmbeddingsByKBUID
}

// Return sets up results that will be returned by Repository.HardDeleteEmbeddingsByKBUID
func (mmHardDeleteEmbeddingsByKBUID *mRepositoryMockHardDeleteEmbeddingsByKBUID) Return(err error) *RepositoryMock {
	if mmHardDeleteEmbeddingsByKBUID.mock.funcHardDeleteEmbeddingsByKBUID != nil {
		mmHardDeleteEmbeddingsByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKBUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKBUID.defaultExpectation = &RepositoryMockHardDeleteEmbeddingsByKBUIDExpectation{mock: mmHardDeleteEmbeddingsByKBUID.mock}
	}
	mmHardDeleteEmbeddingsByKBUID.defaultExpectation.results = &RepositoryMockHardDeleteEmbeddingsByKBUIDResults{err}
	mmHardDeleteEmbeddingsByKBUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHardDeleteEmbeddingsByKBUID.mock
}

// Set uses given function f to mock the Repository.HardDeleteEmbeddingsByKBUID method
func (mmHardDeleteEmbeddingsByKBUID *mRepositoryMockHardDeleteEmbeddingsByKBUID) Set(f func(ctx context.Context, kbUID types.KBUIDType) (err error)) *RepositoryMock {
	if mmHardDeleteEmbeddingsByKBUID.defaultExpectation != nil {
		mmHardDeleteEmbeddingsByKBUID.mock.t.Fatalf("Default expectation is already set for the Repository.HardDeleteEmbeddingsByKBUID method")
	}

	if len(mmHardDeleteEmbeddingsByKBUID.expectations) > 0 {
		mmHardDeleteEmbeddingsByKBUID.mock.t.Fatalf("Some expectations are already set for the Repository.HardDeleteEmbeddingsByKBUID method")
	}

	mmHardDeleteEmbeddingsByKBUID.mock.funcHardDeleteEmbeddingsByKBUID = f
	mmHardDeleteEmbeddingsByKBUID.mock.funcHardDeleteEmbeddingsByKBUIDOrigin = minimock.CallerInfo(1)
	return mmHardDeleteEmbeddingsByKBUID.mock
}

// When sets expectation for the Repository.HardDeleteEmbeddingsByKBUID which will trigger the result defined by the following
// Then helper
func (mmHardDeleteEmbeddingsByKBUID *mRepositoryMockHardDeleteEmbeddingsByKBUID) When(ctx context.Context, kbUID types.KBUIDType) *RepositoryMockHardDeleteEmbeddingsByKBUIDExpectation {
	if mmHardDeleteEmbeddingsByKBUID.mock.funcHardDeleteEmbeddingsByKBUID != nil {
		mmHardDeleteEmbeddingsByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBUID mock is already set by Set")
	}

	expectation := &RepositoryMockHardDeleteEmbeddingsByKBUIDExpectation{
		mock:               mmHardDeleteEmbeddingsByKBUID.mock,
		params:             &RepositoryMockHardDeleteEmbeddingsByKBUIDParams{ctx, kbUID},
		expectationOrigins: RepositoryMockHardDeleteEmbeddingsByKBUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHardDeleteEmbeddingsByKBUID.expectations = append(mmHardDeleteEmbeddingsByKBUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.HardDeleteEmbeddingsByKBUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockHardDeleteEmbeddingsByKBUIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockHardDeleteEmbeddingsByKBUIDResults{err}
	return e.mock
}

// Times sets number of times Repository.HardDeleteEmbeddingsByKBUID should be invoked
func (mmHardDeleteEmbeddingsByKBUID *mRepositoryMockHardDeleteEmbeddingsByKBUID) Times(n uint64) *mRepositoryMockHardDeleteEmbeddingsByKBUID {
	if n == 0 {
		mmHardDeleteEmbeddingsByKBUID.mock.t.Fatalf("Times of RepositoryMock.HardDeleteEmbeddingsByKBUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHardDeleteEmbeddingsByKBUID.expectedInvocations, n)
	mmHardDeleteEmbeddingsByKBUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHardDeleteEmbeddingsByKBUID
}

func (mmHardDeleteEmbeddingsByKBUID *mRepositoryMockHardDeleteEmbeddingsByKBUID) invocationsDone() bool {
	if len(mmHardDeleteEmbeddingsByKBUID.expectations) == 0 && mmHardDeleteEmbeddingsByKBUID.defaultExpectation == nil && mmHardDeleteEmbeddingsByKBUID.mock.funcHardDeleteEmbeddingsByKBUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKBUID.mock.afterHardDeleteEmbeddingsByKBUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKBUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HardDeleteEmbeddingsByKBUID implements mm_repository.Repository
func (mmHardDeleteEmbeddingsByKBUID *RepositoryMock) HardDeleteEmbeddingsByKBUID(ctx context.Context, kbUID types.KBUIDType) (err error) {
	mm_atomic.AddUint64(&mmHardDeleteEmbeddingsByKBUID.beforeHardDeleteEmbeddingsByKBUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmHardDeleteEmbeddingsByKBUID.afterHardDeleteEmbeddingsByKBUIDCounter, 1)

	mmHardDeleteEmbeddingsByKBUID.t.Helper()

	if mmHardDeleteEmbeddingsByKBUID.inspectFuncHardDeleteEmbeddingsByKBUID != nil {
		mmHardDeleteEmbeddingsByKBUID.inspectFuncHardDeleteEmbeddingsByKBUID(ctx, kbUID)
	}

	mm_params := RepositoryMockHardDeleteEmbeddingsByKBUIDParams{ctx, kbUID}

	// Record call args
	mmHardDeleteEmbeddingsByKBUID.HardDeleteEmbeddingsByKBUIDMock.mutex.Lock()
	mmHardDeleteEmbeddingsByKBUID.HardDeleteEmbeddingsByKBUIDMock.callArgs = append(mmHardDeleteEmbeddingsByKBUID.HardDeleteEmbeddingsByKBUIDMock.callArgs, &mm_params)
	mmHardDeleteEmbeddingsByKBUID.HardDeleteEmbeddingsByKBUIDMock.mutex.Unlock()

	for _, e := range mmHardDeleteEmbeddingsByKBUID.HardDeleteEmbeddingsByKBUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHardDeleteEmbeddingsByKBUID.HardDeleteEmbeddingsByKBUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHardDeleteEmbeddingsByKBUID.HardDeleteEmbeddingsByKBUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmHardDeleteEmbeddingsByKBUID.HardDeleteEmbeddingsByKBUIDMock.defaultExpectation.params
		mm_want_ptrs := mmHardDeleteEmbeddingsByKBUID.HardDeleteEmbeddingsByKBUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockHardDeleteEmbeddingsByKBUIDParams{ctx, kbUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHardDeleteEmbeddingsByKBUID.t.Errorf("RepositoryMock.HardDeleteEmbeddingsByKBUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHardDeleteEmbeddingsByKBUID.HardDeleteEmbeddingsByKBUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmHardDeleteEmbeddingsByKBUID.t.Errorf("RepositoryMock.HardDeleteEmbeddingsByKBUID got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHardDeleteEmbeddingsByKBUID.HardDeleteEmbeddingsByKBUIDMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHardDeleteEmbeddingsByKBUID.t.Errorf("RepositoryMock.HardDeleteEmbeddingsByKBUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHardDeleteEmbeddingsByKBUID.HardDeleteEmbeddingsByKBUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHardDeleteEmbeddingsByKBUID.HardDeleteEmbeddingsByKBUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmHardDeleteEmbeddingsByKBUID.t.Fatal("No results are set for the RepositoryMock.HardDeleteEmbeddingsByKBUID")
		}
		return (*mm_results).err
	}
	if mmHardDeleteEmbeddingsByKBUID.funcHardDeleteEmbeddingsByKBUID != nil {
		return mmHardDeleteEmbeddingsByKBUID.funcHardDeleteEmbeddingsByKBUID(ctx, kbUID)
	}
	mmHardDeleteEmbeddingsByKBUID.t.Fatalf("Unexpected call to RepositoryMock.HardDeleteEmbeddingsByKBUID. %v %v", ctx, kbUID)
	return
}

// HardDeleteEmbeddingsByKBUIDAfterCounter returns a count of finished RepositoryMock.HardDeleteEmbeddingsByKBUID invocations
func (mmHardDeleteEmbeddingsByKBUID *RepositoryMock) HardDeleteEmbeddingsByKBUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKBUID.afterHardDeleteEmbeddingsByKBUIDCounter)
}

// HardDeleteEmbeddingsByKBUIDBeforeCounter returns a count of RepositoryMock.HardDeleteEmbeddingsByKBUID invocations
func (mmHardDeleteEmbeddingsByKBUID *RepositoryMock) HardDeleteEmbeddingsByKBUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKBUID.beforeHardDeleteEmbeddingsByKBUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.HardDeleteEmbeddingsByKBUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHardDeleteEmbeddingsByKBUID *mRepositoryMockHardDeleteEmbeddingsByKBUID) Calls() []*RepositoryMockHardDeleteEmbeddingsByKBUIDParams {
	mmHardDeleteEmbeddingsByKBUID.mutex.RLock()

	argCopy := make([]*RepositoryMockHardDeleteEmbeddingsByKBUIDParams, len(mmHardDeleteEmbeddingsByKBUID.callArgs))
	copy(argCopy, mmHardDeleteEmbeddingsByKBUID.callArgs)

	mmHardDeleteEmbeddingsByKBUID.mutex.RUnlock()

	return argCopy
}

// MinimockHardDeleteEmbeddingsByKBUIDDone returns true if the count of the HardDeleteEmbeddingsByKBUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockHardDeleteEmbeddingsByKBUIDDone() bool {
	if m.HardDeleteEmbeddingsByKBUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HardDeleteEmbeddingsByKBUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HardDeleteEmbeddingsByKBUIDMock.invocationsDone()
}

// MinimockHardDeleteEmbeddingsByKBUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockHardDeleteEmbeddingsByKBUIDInspect() {
	for _, e := range m.HardDeleteEmbeddingsByKBUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteEmbeddingsByKBUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHardDeleteEmbeddingsByKBUIDCounter := mm_atomic.LoadUint64(&m.afterHardDeleteEmbeddingsByKBUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HardDeleteEmbeddingsByKBUIDMock.defaultExpectation != nil && afterHardDeleteEmbeddingsByKBUIDCounter < 1 {
		if m.HardDeleteEmbeddingsByKBUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteEmbeddingsByKBUID at\n%s", m.HardDeleteEmbeddingsByKBUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteEmbeddingsByKBUID at\n%s with params: %#v", m.HardDeleteEmbeddingsByKBUIDMock.defaultExpectation.expectationOrigins.origin, *m.HardDeleteEmbeddingsByKBUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHardDeleteEmbeddingsByKBUID != nil && afterHardDeleteEmbeddingsByKBUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.HardDeleteEmbeddingsByKBUID at\n%s", m.funcHardDeleteEmbeddingsByKBUIDOrigin)
	}

	if !m.HardDeleteEmbeddingsByKBUIDMock.invocationsDone() && afterHardDeleteEmbeddingsByKBUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.HardDeleteEmbeddingsByKBUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HardDeleteEmbeddingsByKBUIDMock.expectedInvocations), m.HardDeleteEmbeddingsByKBUIDMock.expectedInvocationsOrigin, afterHardDeleteEmbeddingsByKBUIDCounter)
	}
}

type mRepositoryMockHardDeleteTextChunksByKBFileUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockHardDeleteTextChunksByKBFileUIDExpectation
	expectations       []*RepositoryMockHardDeleteTextChunksByKBFileUIDExpectation

	callArgs []*RepositoryMockHardDeleteTextChunksByKBFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockHardDeleteTextChunksByKBFileUIDExpectation specifies expectation struct of the Repository.HardDeleteTextChunksByKBFileUID
type RepositoryMockHardDeleteTextChunksByKBFileUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockHardDeleteTextChunksByKBFileUIDParams
	paramPtrs          *RepositoryMockHardDeleteTextChunksByKBFileUIDParamPtrs
	expectationOrigins RepositoryMockHardDeleteTextChunksByKBFileUIDExpectationOrigins
	results            *RepositoryMockHardDeleteTextChunksByKBFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockHardDeleteTextChunksByKBFileUIDParams contains parameters of the Repository.HardDeleteTextChunksByKBFileUID
type RepositoryMockHardDeleteTextChunksByKBFileUIDParams struct {
	ctx       context.Context
	kbFileUID types.FileUIDType
}

// RepositoryMockHardDeleteTextChunksByKBFileUIDParamPtrs contains pointers to parameters of the Repository.HardDeleteTextChunksByKBFileUID
type RepositoryMockHardDeleteTextChunksByKBFileUIDParamPtrs struct {
	ctx       *context.Context
	kbFileUID *types.FileUIDType
}

// RepositoryMockHardDeleteTextChunksByKBFileUIDResults contains results of the Repository.HardDeleteTextChunksByKBFileUID
type RepositoryMockHardDeleteTextChunksByKBFileUIDResults struct {
	err error
}

// RepositoryMockHardDeleteTextChunksByKBFileUIDOrigins contains origins of expectations of the Repository.HardDeleteTextChunksByKBFileUID
type RepositoryMockHardDeleteTextChunksByKBFileUIDExpectationOrigins struct {
	origin          string
	originCtx       string
	originKbFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHardDeleteTextChunksByKBFileUID *mRepositoryMockHardDeleteTextChunksByKBFileUID) Optional() *mRepositoryMockHardDeleteTextChunksByKBFileUID {
	mmHardDeleteTextChunksByKBFileUID.optional = true
	return mmHardDeleteTextChunksByKBFileUID
}

// Expect sets up expected params for Repository.HardDeleteTextChunksByKBFileUID
func (mmHardDeleteTextChunksByKBFileUID *mRepositoryMockHardDeleteTextChunksByKBFileUID) Expect(ctx context.Context, kbFileUID types.FileUIDType) *mRepositoryMockHardDeleteTextChunksByKBFileUID {
	if mmHardDeleteTextChunksByKBFileUID.mock.funcHardDeleteTextChunksByKBFileUID != nil {
		mmHardDeleteTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBFileUID mock is already set by Set")
	}

	if mmHardDeleteTextChunksByKBFileUID.defaultExpectation == nil {
		mmHardDeleteTextChunksByKBFileUID.defaultExpectation = &RepositoryMockHardDeleteTextChunksByKBFileUIDExpectation{}
	}

	if mmHardDeleteTextChunksByKBFileUID.defaultExpectation.paramPtrs != nil {
		mmHardDeleteTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBFileUID mock is already set by ExpectParams functions")
	}

	mmHardDeleteTextChunksByKBFileUID.defaultExpectation.params = &RepositoryMockHardDeleteTextChunksByKBFileUIDParams{ctx, kbFileUID}
	mmHardDeleteTextChunksByKBFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHardDeleteTextChunksByKBFileUID.expectations {
		if minimock.Equal(e.params, mmHardDeleteTextChunksByKBFileUID.defaultExpectation.params) {
			mmHardDeleteTextChunksByKBFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHardDeleteTextChunksByKBFileUID.defaultExpectation.params)
		}
	}

	return mmHardDeleteTextChunksByKBFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.HardDeleteTextChunksByKBFileUID
func (mmHardDeleteTextChunksByKBFileUID *mRepositoryMockHardDeleteTextChunksByKBFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockHardDeleteTextChunksByKBFileUID {
	if mmHardDeleteTextChunksByKBFileUID.mock.funcHardDeleteTextChunksByKBFileUID != nil {
		mmHardDeleteTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBFileUID mock is already set by Set")
	}

	if mmHardDeleteTextChunksByKBFileUID.defaultExpectation == nil {
		mmHardDeleteTextChunksByKBFileUID.defaultExpectation = &RepositoryMockHardDeleteTextChunksByKBFileUIDExpectation{}
	}

	if mmHardDeleteTextChunksByKBFileUID.defaultExpectation.params != nil {
		mmHardDeleteTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBFileUID mock is already set by Expect")
	}

	if mmHardDeleteTextChunksByKBFileUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteTextChunksByKBFileUID.defaultExpectation.paramPtrs = &RepositoryMockHardDeleteTextChunksByKBFileUIDParamPtrs{}
	}
	mmHardDeleteTextChunksByKBFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmHardDeleteTextChunksByKBFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmHardDeleteTextChunksByKBFileUID
}

// ExpectKbFileUIDParam2 sets up expected param kbFileUID for Repository.HardDeleteTextChunksByKBFileUID
func (mmHardDeleteTextChunksByKBFileUID *mRepositoryMockHardDeleteTextChunksByKBFileUID) ExpectKbFileUIDParam2(kbFileUID types.FileUIDType) *mRepositoryMockHardDeleteTextChunksByKBFileUID {
	if mmHardDeleteTextChunksByKBFileUID.mock.funcHardDeleteTextChunksByKBFileUID != nil {
		mmHardDeleteTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBFileUID mock is already set by Set")
	}

	if mmHardDeleteTextChunksByKBFileUID.defaultExpectation == nil {
		mmHardDeleteTextChunksByKBFileUID.defaultExpectation = &RepositoryMockHardDeleteTextChunksByKBFileUIDExpectation{}
	}

	if mmHardDeleteTextChunksByKBFileUID.defaultExpectation.params != nil {
		mmHardDeleteTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBFileUID mock is already set by Expect")
	}

	if mmHardDeleteTextChunksByKBFileUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteTextChunksByKBFileUID.defaultExpectation.paramPtrs = &RepositoryMockHardDeleteTextChunksByKBFileUIDParamPtrs{}
	}
	mmHardDeleteTextChunksByKBFileUID.defaultExpectation.paramPtrs.kbFileUID = &kbFileUID
	mmHardDeleteTextChunksByKBFileUID.defaultExpectation.expectationOrigins.originKbFileUID = minimock.CallerInfo(1)

	return mmHardDeleteTextChunksByKBFileUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.HardDeleteTextChunksByKBFileUID
func (mmHardDeleteTextChunksByKBFileUID *mRepositoryMockHardDeleteTextChunksByKBFileUID) Inspect(f func(ctx context.Context, kbFileUID types.FileUIDType)) *mRepositoryMockHardDeleteTextChunksByKBFileUID {
	if mmHardDeleteTextChunksByKBFileUID.mock.inspectFuncHardDeleteTextChunksByKBFileUID != nil {
		mmHardDeleteTextChunksByKBFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.HardDeleteTextChunksByKBFileUID")
	}

	mmHardDeleteTextChunksByKBFileUID.mock.inspectFuncHardDeleteTextChunksByKBFileUID = f

	return mmHardDeleteTextChunksByKBFileUID
}

// Return sets up results that will be returned by Repository.HardDeleteTextChunksByKBFileUID
func (mmHardDeleteTextChunksByKBFileUID *mRepositoryMockHardDeleteTextChunksByKBFileUID) Return(err error) *RepositoryMock {
	if mmHardDeleteTextChunksByKBFileUID.mock.funcHardDeleteTextChunksByKBFileUID != nil {
		mmHardDeleteTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBFileUID mock is already set by Set")
	}

	if mmHardDeleteTextChunksByKBFileUID.defaultExpectation == nil {
		mmHardDeleteTextChunksByKBFileUID.defaultExpectation = &RepositoryMockHardDeleteTextChunksByKBFileUIDExpectation{mock: mmHardDeleteTextChunksByKBFileUID.mock}
	}
	mmHardDeleteTextChunksByKBFileUID.defaultExpectation.results = &RepositoryMockHardDeleteTextChunksByKBFileUIDResults{err}
	mmHardDeleteTextChunksByKBFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHardDeleteTextChunksByKBFileUID.mock
}

// Set uses given function f to mock the Repository.HardDeleteTextChunksByKBFileUID method
func (mmHardDeleteTextChunksByKBFileUID *mRepositoryMockHardDeleteTextChunksByKBFileUID) Set(f func(ctx context.Context, kbFileUID types.FileUIDType) (err error)) *RepositoryMock {
	if mmHardDeleteTextChunksByKBFileUID.defaultExpectation != nil {
		mmHardDeleteTextChunksByKBFileUID.mock.t.Fatalf("Default expectation is already set for the Repository.HardDeleteTextChunksByKBFileUID method")
	}

	if len(mmHardDeleteTextChunksByKBFileUID.expectations) > 0 {
		mmHardDeleteTextChunksByKBFileUID.mock.t.Fatalf("Some expectations are already set for the Repository.HardDeleteTextChunksByKBFileUID method")
	}

	mmHardDeleteTextChunksByKBFileUID.mock.funcHardDeleteTextChunksByKBFileUID = f
	mmHardDeleteTextChunksByKBFileUID.mock.funcHardDeleteTextChunksByKBFileUIDOrigin = minimock.CallerInfo(1)
	return mmHardDeleteTextChunksByKBFileUID.mock
}

// When sets expectation for the Repository.HardDeleteTextChunksByKBFileUID which will trigger the result defined by the following
// Then helper
func (mmHardDeleteTextChunksByKBFileUID *mRepositoryMockHardDeleteTextChunksByKBFileUID) When(ctx context.Context, kbFileUID types.FileUIDType) *RepositoryMockHardDeleteTextChunksByKBFileUIDExpectation {
	if mmHardDeleteTextChunksByKBFileUID.mock.funcHardDeleteTextChunksByKBFileUID != nil {
		mmHardDeleteTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBFileUID mock is already set by Set")
	}

	expectation := &RepositoryMockHardDeleteTextChunksByKBFileUIDExpectation{
		mock:               mmHardDeleteTextChunksByKBFileUID.mock,
		params:             &RepositoryMockHardDeleteTextChunksByKBFileUIDParams{ctx, kbFileUID},
		expectationOrigins: RepositoryMockHardDeleteTextChunksByKBFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHardDeleteTextChunksByKBFileUID.expectations = append(mmHardDeleteTextChunksByKBFileUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.HardDeleteTextChunksByKBFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockHardDeleteTextChunksByKBFileUIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockHardDeleteTextChunksByKBFileUIDResults{err}
	return e.mock
}

// Times sets number of times Repository.HardDeleteTextChunksByKBFileUID should be invoked
func (mmHardDeleteTextChunksByKBFileUID *mRepositoryMockHardDeleteTextChunksByKBFileUID) Times(n uint64) *mRepositoryMockHardDeleteTextChunksByKBFileUID {
	if n == 0 {
		mmHardDeleteTextChunksByKBFileUID.mock.t.Fatalf("Times of RepositoryMock.HardDeleteTextChunksByKBFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHardDeleteTextChunksByKBFileUID.expectedInvocations, n)
	mmHardDeleteTextChunksByKBFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHardDeleteTextChunksByKBFileUID
}

func (mmHardDeleteTextChunksByKBFileUID *mRepositoryMockHardDeleteTextChunksByKBFileUID) invocationsDone() bool {
	if len(mmHardDeleteTextChunksByKBFileUID.expectations) == 0 && mmHardDeleteTextChunksByKBFileUID.defaultExpectation == nil && mmHardDeleteTextChunksByKBFileUID.mock.funcHardDeleteTextChunksByKBFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHardDeleteTextChunksByKBFileUID.mock.afterHardDeleteTextChunksByKBFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHardDeleteTextChunksByKBFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HardDeleteTextChunksByKBFileUID implements mm_repository.Repository
func (mmHardDeleteTextChunksByKBFileUID *RepositoryMock) HardDeleteTextChunksByKBFileUID(ctx context.Context, kbFileUID types.FileUIDType) (err error) {
	mm_atomic.AddUint64(&mmHardDeleteTextChunksByKBFileUID.beforeHardDeleteTextChunksByKBFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmHardDeleteTextChunksByKBFileUID.afterHardDeleteTextChunksByKBFileUIDCounter, 1)

	mmHardDeleteTextChunksByKBFileUID.t.Helper()

	if mmHardDeleteTextChunksByKBFileUID.inspectFuncHardDeleteTextChunksByKBFileUID != nil {
		mmHardDeleteTextChunksByKBFileUID.inspectFuncHardDeleteTextChunksByKBFileUID(ctx, kbFileUID)
	}

	mm_params := RepositoryMockHardDeleteTextChunksByKBFileUIDParams{ctx, kbFileUID}

	// Record call args
	mmHardDeleteTextChunksByKBFileUID.HardDeleteTextChunksByKBFileUIDMock.mutex.Lock()
	mmHardDeleteTextChunksByKBFileUID.HardDeleteTextChunksByKBFileUIDMock.callArgs = append(mmHardDeleteTextChunksByKBFileUID.HardDeleteTextChunksByKBFileUIDMock.callArgs, &mm_params)
	mmHardDeleteTextChunksByKBFileUID.HardDeleteTextChunksByKBFileUIDMock.mutex.Unlock()

	for _, e := range mmHardDeleteTextChunksByKBFileUID.HardDeleteTextChunksByKBFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHardDeleteTextChunksByKBFileUID.HardDeleteTextChunksByKBFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHardDeleteTextChunksByKBFileUID.HardDeleteTextChunksByKBFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmHardDeleteTextChunksByKBFileUID.HardDeleteTextChunksByKBFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmHardDeleteTextChunksByKBFileUID.HardDeleteTextChunksByKBFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockHardDeleteTextChunksByKBFileUIDParams{ctx, kbFileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHardDeleteTextChunksByKBFileUID.t.Errorf("RepositoryMock.HardDeleteTextChunksByKBFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHardDeleteTextChunksByKBFileUID.HardDeleteTextChunksByKBFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbFileUID != nil && !minimock.Equal(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID) {
				mmHardDeleteTextChunksByKBFileUID.t.Errorf("RepositoryMock.HardDeleteTextChunksByKBFileUID got unexpected parameter kbFileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHardDeleteTextChunksByKBFileUID.HardDeleteTextChunksByKBFileUIDMock.defaultExpectation.expectationOrigins.originKbFileUID, *mm_want_ptrs.kbFileUID, mm_got.kbFileUID, minimock.Diff(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHardDeleteTextChunksByKBFileUID.t.Errorf("RepositoryMock.HardDeleteTextChunksByKBFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHardDeleteTextChunksByKBFileUID.HardDeleteTextChunksByKBFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHardDeleteTextChunksByKBFileUID.HardDeleteTextChunksByKBFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmHardDeleteTextChunksByKBFileUID.t.Fatal("No results are set for the RepositoryMock.HardDeleteTextChunksByKBFileUID")
		}
		return (*mm_results).err
	}
	if mmHardDeleteTextChunksByKBFileUID.funcHardDeleteTextChunksByKBFileUID != nil {
		return mmHardDeleteTextChunksByKBFileUID.funcHardDeleteTextChunksByKBFileUID(ctx, kbFileUID)
	}
	mmHardDeleteTextChunksByKBFileUID.t.Fatalf("Unexpected call to RepositoryMock.HardDeleteTextChunksByKBFileUID. %v %v", ctx, kbFileUID)
	return
}

// HardDeleteTextChunksByKBFileUIDAfterCounter returns a count of finished RepositoryMock.HardDeleteTextChunksByKBFileUID invocations
func (mmHardDeleteTextChunksByKBFileUID *RepositoryMock) HardDeleteTextChunksByKBFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteTextChunksByKBFileUID.afterHardDeleteTextChunksByKBFileUIDCounter)
}

// HardDeleteTextChunksByKBFileUIDBeforeCounter returns a count of RepositoryMock.HardDeleteTextChunksByKBFileUID invocations
func (mmHardDeleteTextChunksByKBFileUID *RepositoryMock) HardDeleteTextChunksByKBFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteTextChunksByKBFileUID.beforeHardDeleteTextChunksByKBFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.HardDeleteTextChunksByKBFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHardDeleteTextChunksByKBFileUID *mRepositoryMockHardDeleteTextChunksByKBFileUID) Calls() []*RepositoryMockHardDeleteTextChunksByKBFileUIDParams {
	mmHardDeleteTextChunksByKBFileUID.mutex.RLock()

	argCopy := make([]*RepositoryMockHardDeleteTextChunksByKBFileUIDParams, len(mmHardDeleteTextChunksByKBFileUID.callArgs))
	copy(argCopy, mmHardDeleteTextChunksByKBFileUID.callArgs)

	mmHardDeleteTextChunksByKBFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockHardDeleteTextChunksByKBFileUIDDone returns true if the count of the HardDeleteTextChunksByKBFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockHardDeleteTextChunksByKBFileUIDDone() bool {
	if m.HardDeleteTextChunksByKBFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HardDeleteTextChunksByKBFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HardDeleteTextChunksByKBFileUIDMock.invocationsDone()
}

// MinimockHardDeleteTextChunksByKBFileUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockHardDeleteTextChunksByKBFileUIDInspect() {
	for _, e := range m.HardDeleteTextChunksByKBFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteTextChunksByKBFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHardDeleteTextChunksByKBFileUIDCounter := mm_atomic.LoadUint64(&m.afterHardDeleteTextChunksByKBFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HardDeleteTextChunksByKBFileUIDMock.defaultExpectation != nil && afterHardDeleteTextChunksByKBFileUIDCounter < 1 {
		if m.HardDeleteTextChunksByKBFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteTextChunksByKBFileUID at\n%s", m.HardDeleteTextChunksByKBFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteTextChunksByKBFileUID at\n%s with params: %#v", m.HardDeleteTextChunksByKBFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.HardDeleteTextChunksByKBFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHardDeleteTextChunksByKBFileUID != nil && afterHardDeleteTextChunksByKBFileUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.HardDeleteTextChunksByKBFileUID at\n%s", m.funcHardDeleteTextChunksByKBFileUIDOrigin)
	}

	if !m.HardDeleteTextChunksByKBFileUIDMock.invocationsDone() && afterHardDeleteTextChunksByKBFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.HardDeleteTextChunksByKBFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HardDeleteTextChunksByKBFileUIDMock.expectedInvocations), m.HardDeleteTextChunksByKBFileUIDMock.expectedInvocationsOrigin, afterHardDeleteTextChunksByKBFileUIDCounter)
	}
}

type mRepositoryMockHardDeleteTextChunksByKBUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockHardDeleteTextChunksByKBUIDExpectation
	expectations       []*RepositoryMockHardDeleteTextChunksByKBUIDExpectation

	callArgs []*RepositoryMockHardDeleteTextChunksByKBUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockHardDeleteTextChunksByKBUIDExpectation specifies expectation struct of the Repository.HardDeleteTextChunksByKBUID
type RepositoryMockHardDeleteTextChunksByKBUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockHardDeleteTextChunksByKBUIDParams
	paramPtrs          *RepositoryMockHardDeleteTextChunksByKBUIDParamPtrs
	expectationOrigins RepositoryMockHardDeleteTextChunksByKBUIDExpectationOrigins
	results            *RepositoryMockHardDeleteTextChunksByKBUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockHardDeleteTextChunksByKBUIDParams contains parameters of the Repository.HardDeleteTextChunksByKBUID
type RepositoryMockHardDeleteTextChunksByKBUIDParams struct {
	ctx   context.Context
	kbUID types.KBUIDType
}

// RepositoryMockHardDeleteTextChunksByKBUIDParamPtrs contains pointers to parameters of the Repository.HardDeleteTextChunksByKBUID
type RepositoryMockHardDeleteTextChunksByKBUIDParamPtrs struct {
	ctx   *context.Context
	kbUID *types.KBUIDType
}

// RepositoryMockHardDeleteTextChunksByKBUIDResults contains results of the Repository.HardDeleteTextChunksByKBUID
type RepositoryMockHardDeleteTextChunksByKBUIDResults struct {
	err error
}

// RepositoryMockHardDeleteTextChunksByKBUIDOrigins contains origins of expectations of the Repository.HardDeleteTextChunksByKBUID
type RepositoryMockHardDeleteTextChunksByKBUIDExpectationOrigins struct {
	origin      string
	originCtx   string
	originKbUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHardDeleteTextChunksByKBUID *mRepositoryMockHardDeleteTextChunksByKBUID) Optional() *mRepositoryMockHardDeleteTextChunksByKBUID {
	mmHardDeleteTextChunksByKBUID.optional = true
	return mmHardDeleteTextChunksByKBUID
}

// Expect sets up expected params for Repository.HardDeleteTextChunksByKBUID
func (mmHardDeleteTextChunksByKBUID *mRepositoryMockHardDeleteTextChunksByKBUID) Expect(ctx context.Context, kbUID types.KBUIDType) *mRepositoryMockHardDeleteTextChunksByKBUID {
	if mmHardDeleteTextChunksByKBUID.mock.funcHardDeleteTextChunksByKBUID != nil {
		mmHardDeleteTextChunksByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBUID mock is already set by Set")
	}

	if mmHardDeleteTextChunksByKBUID.defaultExpectation == nil {
		mmHardDeleteTextChunksByKBUID.defaultExpectation = &RepositoryMockHardDeleteTextChunksByKBUIDExpectation{}
	}

	if mmHardDeleteTextChunksByKBUID.defaultExpectation.paramPtrs != nil {
		mmHardDeleteTextChunksByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBUID mock is already set by ExpectParams functions")
	}

	mmHardDeleteTextChunksByKBUID.defaultExpectation.params = &RepositoryMockHardDeleteTextChunksByKBUIDParams{ctx, kbUID}
	mmHardDeleteTextChunksByKBUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHardDeleteTextChunksByKBUID.expectations {
		if minimock.Equal(e.params, mmHardDeleteTextChunksByKBUID.defaultExpectation.params) {
			mmHardDeleteTextChunksByKBUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHardDeleteTextChunksByKBUID.defaultExpectation.params)
		}
	}

	return mmHardDeleteTextChunksByKBUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.HardDeleteTextChunksByKBUID
func (mmHardDeleteTextChunksByKBUID *mRepositoryMockHardDeleteTextChunksByKBUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockHardDeleteTextChunksByKBUID {
	if mmHardDeleteTextChunksByKBUID.mock.funcHardDeleteTextChunksByKBUID != nil {
		mmHardDeleteTextChunksByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBUID mock is already set by Set")
	}

	if mmHardDeleteTextChunksByKBUID.defaultExpectation == nil {
		mmHardDeleteTextChunksByKBUID.defaultExpectation = &RepositoryMockHardDeleteTextChunksByKBUIDExpectation{}
	}

	if mmHardDeleteTextChunksByKBUID.defaultExpectation.params != nil {
		mmHardDeleteTextChunksByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBUID mock is already set by Expect")
	}

	if mmHardDeleteTextChunksByKBUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteTextChunksByKBUID.defaultExpectation.paramPtrs = &RepositoryMockHardDeleteTextChunksByKBUIDParamPtrs{}
	}
	mmHardDeleteTextChunksByKBUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmHardDeleteTextChunksByKBUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmHardDeleteTextChunksByKBUID
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.HardDeleteTextChunksByKBUID
func (mmHardDeleteTextChunksByKBUID *mRepositoryMockHardDeleteTextChunksByKBUID) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockHardDeleteTextChunksByKBUID {
	if mmHardDeleteTextChunksByKBUID.mock.funcHardDeleteTextChunksByKBUID != nil {
		mmHardDeleteTextChunksByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBUID mock is already set by Set")
	}

	if mmHardDeleteTextChunksByKBUID.defaultExpectation == nil {
		mmHardDeleteTextChunksByKBUID.defaultExpectation = &RepositoryMockHardDeleteTextChunksByKBUIDExpectation{}
	}

	if mmHardDeleteTextChunksByKBUID.defaultExpectation.params != nil {
		mmHardDeleteTextChunksByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBUID mock is already set by Expect")
	}

	if mmHardDeleteTextChunksByKBUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteTextChunksByKBUID.defaultExpectation.paramPtrs = &RepositoryMockHardDeleteTextChunksByKBUIDParamPtrs{}
	}
	mmHardDeleteTextChunksByKBUID.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmHardDeleteTextChunksByKBUID.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmHardDeleteTextChunksByKBUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.HardDeleteTextChunksByKBUID
func (mmHardDeleteTextChunksByKBUID *mRepositoryMockHardDeleteTextChunksByKBUID) Inspect(f func(ctx context.Context, kbUID types.KBUIDType)) *mRepositoryMockHardDeleteTextChunksByKBUID {
	if mmHardDeleteTextChunksByKBUID.mock.inspectFuncHardDeleteTextChunksByKBUID != nil {
		mmHardDeleteTextChunksByKBUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.HardDeleteTextChunksByKBUID")
	}

	mmHardDeleteTextChunksByKBUID.mock.inspectFuncHardDeleteTextChunksByKBUID = f

	return mmHardDeleteTextChunksByKBUID
}

// Return sets up results that will be returned by Repository.HardDeleteTextChunksByKBUID
func (mmHardDeleteTextChunksByKBUID *mRepositoryMockHardDeleteTextChunksByKBUID) Return(err error) *RepositoryMock {
	if mmHardDeleteTextChunksByKBUID.mock.funcHardDeleteTextChunksByKBUID != nil {
		mmHardDeleteTextChunksByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBUID mock is already set by Set")
	}

	if mmHardDeleteTextChunksByKBUID.defaultExpectation == nil {
		mmHardDeleteTextChunksByKBUID.defaultExpectation = &RepositoryMockHardDeleteTextChunksByKBUIDExpectation{mock: mmHardDeleteTextChunksByKBUID.mock}
	}
	mmHardDeleteTextChunksByKBUID.defaultExpectation.results = &RepositoryMockHardDeleteTextChunksByKBUIDResults{err}
	mmHardDeleteTextChunksByKBUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHardDeleteTextChunksByKBUID.mock
}

// Set uses given function f to mock the Repository.HardDeleteTextChunksByKBUID method
func (mmHardDeleteTextChunksByKBUID *mRepositoryMockHardDeleteTextChunksByKBUID) Set(f func(ctx context.Context, kbUID types.KBUIDType) (err error)) *RepositoryMock {
	if mmHardDeleteTextChunksByKBUID.defaultExpectation != nil {
		mmHardDeleteTextChunksByKBUID.mock.t.Fatalf("Default expectation is already set for the Repository.HardDeleteTextChunksByKBUID method")
	}

	if len(mmHardDeleteTextChunksByKBUID.expectations) > 0 {
		mmHardDeleteTextChunksByKBUID.mock.t.Fatalf("Some expectations are already set for the Repository.HardDeleteTextChunksByKBUID method")
	}

	mmHardDeleteTextChunksByKBUID.mock.funcHardDeleteTextChunksByKBUID = f
	mmHardDeleteTextChunksByKBUID.mock.funcHardDeleteTextChunksByKBUIDOrigin = minimock.CallerInfo(1)
	return mmHardDeleteTextChunksByKBUID.mock
}

// When sets expectation for the Repository.HardDeleteTextChunksByKBUID which will trigger the result defined by the following
// Then helper
func (mmHardDeleteTextChunksByKBUID *mRepositoryMockHardDeleteTextChunksByKBUID) When(ctx context.Context, kbUID types.KBUIDType) *RepositoryMockHardDeleteTextChunksByKBUIDExpectation {
	if mmHardDeleteTextChunksByKBUID.mock.funcHardDeleteTextChunksByKBUID != nil {
		mmHardDeleteTextChunksByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBUID mock is already set by Set")
	}

	expectation := &RepositoryMockHardDeleteTextChunksByKBUIDExpectation{
		mock:               mmHardDeleteTextChunksByKBUID.mock,
		params:             &RepositoryMockHardDeleteTextChunksByKBUIDParams{ctx, kbUID},
		expectationOrigins: RepositoryMockHardDeleteTextChunksByKBUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHardDeleteTextChunksByKBUID.expectations = append(mmHardDeleteTextChunksByKBUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.HardDeleteTextChunksByKBUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockHardDeleteTextChunksByKBUIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockHardDeleteTextChunksByKBUIDResults{err}
	return e.mock
}

// Times sets number of times Repository.HardDeleteTextChunksByKBUID should be invoked
func (mmHardDeleteTextChunksByKBUID *mRepositoryMockHardDeleteTextChunksByKBUID) Times(n uint64) *mRepositoryMockHardDeleteTextChunksByKBUID {
	if n == 0 {
		mmHardDeleteTextChunksByKBUID.mock.t.Fatalf("Times of RepositoryMock.HardDeleteTextChunksByKBUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHardDeleteTextChunksByKBUID.expectedInvocations, n)
	mmHardDeleteTextChunksByKBUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHardDeleteTextChunksByKBUID
}

func (mmHardDeleteTextChunksByKBUID *mRepositoryMockHardDeleteTextChunksByKBUID) invocationsDone() bool {
	if len(mmHardDeleteTextChunksByKBUID.expectations) == 0 && mmHardDeleteTextChunksByKBUID.defaultExpectation == nil && mmHardDeleteTextChunksByKBUID.mock.funcHardDeleteTextChunksByKBUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHardDeleteTextChunksByKBUID.mock.afterHardDeleteTextChunksByKBUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHardDeleteTextChunksByKBUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HardDeleteTextChunksByKBUID implements mm_repository.Repository
func (mmHardDeleteTextChunksByKBUID *RepositoryMock) HardDeleteTextChunksByKBUID(ctx context.Context, kbUID types.KBUIDType) (err error) {
	mm_atomic.AddUint64(&mmHardDeleteTextChunksByKBUID.beforeHardDeleteTextChunksByKBUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmHardDeleteTextChunksByKBUID.afterHardDeleteTextChunksByKBUIDCounter, 1)

	mmHardDeleteTextChunksByKBUID.t.Helper()

	if mmHardDeleteTextChunksByKBUID.inspectFuncHardDeleteTextChunksByKBUID != nil {
		mmHardDeleteTextChunksByKBUID.inspectFuncHardDeleteTextChunksByKBUID(ctx, kbUID)
	}

	mm_params := RepositoryMockHardDeleteTextChunksByKBUIDParams{ctx, kbUID}

	// Record call args
	mmHardDeleteTextChunksByKBUID.HardDeleteTextChunksByKBUIDMock.mutex.Lock()
	mmHardDeleteTextChunksByKBUID.HardDeleteTextChunksByKBUIDMock.callArgs = append(mmHardDeleteTextChunksByKBUID.HardDeleteTextChunksByKBUIDMock.callArgs, &mm_params)
	mmHardDeleteTextChunksByKBUID.HardDeleteTextChunksByKBUIDMock.mutex.Unlock()

	for _, e := range mmHardDeleteTextChunksByKBUID.HardDeleteTextChunksByKBUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHardDeleteTextChunksByKBUID.HardDeleteTextChunksByKBUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHardDeleteTextChunksByKBUID.HardDeleteTextChunksByKBUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmHardDeleteTextChunksByKBUID.HardDeleteTextChunksByKBUIDMock.defaultExpectation.params
		mm_want_ptrs := mmHardDeleteTextChunksByKBUID.HardDeleteTextChunksByKBUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockHardDeleteTextChunksByKBUIDParams{ctx, kbUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHardDeleteTextChunksByKBUID.t.Errorf("RepositoryMock.HardDeleteTextChunksByKBUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHardDeleteTextChunksByKBUID.HardDeleteTextChunksByKBUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmHardDeleteTextChunksByKBUID.t.Errorf("RepositoryMock.HardDeleteTextChunksByKBUID got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHardDeleteTextChunksByKBUID.HardDeleteTextChunksByKBUIDMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHardDeleteTextChunksByKBUID.t.Errorf("RepositoryMock.HardDeleteTextChunksByKBUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHardDeleteTextChunksByKBUID.HardDeleteTextChunksByKBUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHardDeleteTextChunksByKBUID.HardDeleteTextChunksByKBUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmHardDeleteTextChunksByKBUID.t.Fatal("No results are set for the RepositoryMock.HardDeleteTextChunksByKBUID")
		}
		return (*mm_results).err
	}
	if mmHardDeleteTextChunksByKBUID.funcHardDeleteTextChunksByKBUID != nil {
		return mmHardDeleteTextChunksByKBUID.funcHardDeleteTextChunksByKBUID(ctx, kbUID)
	}
	mmHardDeleteTextChunksByKBUID.t.Fatalf("Unexpected call to RepositoryMock.HardDeleteTextChunksByKBUID. %v %v", ctx, kbUID)
	return
}

// HardDeleteTextChunksByKBUIDAfterCounter returns a count of finished RepositoryMock.HardDeleteTextChunksByKBUID invocations
func (mmHardDeleteTextChunksByKBUID *RepositoryMock) HardDeleteTextChunksByKBUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteTextChunksByKBUID.afterHardDeleteTextChunksByKBUIDCounter)
}

// HardDeleteTextChunksByKBUIDBeforeCounter returns a count of RepositoryMock.HardDeleteTextChunksByKBUID invocations
func (mmHardDeleteTextChunksByKBUID *RepositoryMock) HardDeleteTextChunksByKBUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteTextChunksByKBUID.beforeHardDeleteTextChunksByKBUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.HardDeleteTextChunksByKBUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHardDeleteTextChunksByKBUID *mRepositoryMockHardDeleteTextChunksByKBUID) Calls() []*RepositoryMockHardDeleteTextChunksByKBUIDParams {
	mmHardDeleteTextChunksByKBUID.mutex.RLock()

	argCopy := make([]*RepositoryMockHardDeleteTextChunksByKBUIDParams, len(mmHardDeleteTextChunksByKBUID.callArgs))
	copy(argCopy, mmHardDeleteTextChunksByKBUID.callArgs)

	mmHardDeleteTextChunksByKBUID.mutex.RUnlock()

	return argCopy
}

// MinimockHardDeleteTextChunksByKBUIDDone returns true if the count of the HardDeleteTextChunksByKBUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockHardDeleteTextChunksByKBUIDDone() bool {
	if m.HardDeleteTextChunksByKBUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HardDeleteTextChunksByKBUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HardDeleteTextChunksByKBUIDMock.invocationsDone()
}

// MinimockHardDeleteTextChunksByKBUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockHardDeleteTextChunksByKBUIDInspect() {
	for _, e := range m.HardDeleteTextChunksByKBUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteTextChunksByKBUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHardDeleteTextChunksByKBUIDCounter := mm_atomic.LoadUint64(&m.afterHardDeleteTextChunksByKBUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HardDeleteTextChunksByKBUIDMock.defaultExpectation != nil && afterHardDeleteTextChunksByKBUIDCounter < 1 {
		if m.HardDeleteTextChunksByKBUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteTextChunksByKBUID at\n%s", m.HardDeleteTextChunksByKBUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteTextChunksByKBUID at\n%s with params: %#v", m.HardDeleteTextChunksByKBUIDMock.defaultExpectation.expectationOrigins.origin, *m.HardDeleteTextChunksByKBUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHardDeleteTextChunksByKBUID != nil && afterHardDeleteTextChunksByKBUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.HardDeleteTextChunksByKBUID at\n%s", m.funcHardDeleteTextChunksByKBUIDOrigin)
	}

	if !m.HardDeleteTextChunksByKBUIDMock.invocationsDone() && afterHardDeleteTextChunksByKBUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.HardDeleteTextChunksByKBUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HardDeleteTextChunksByKBUIDMock.expectedInvocations), m.HardDeleteTextChunksByKBUIDMock.expectedInvocationsOrigin, afterHardDeleteTextChunksByKBUIDCounter)
	}
}

type mRepositoryMockIncreaseKnowledgeBaseUsage struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockIncreaseKnowledgeBaseUsageExpectation
	expectations       []*RepositoryMockIncreaseKnowledgeBaseUsageExpectation

	callArgs []*RepositoryMockIncreaseKnowledgeBaseUsageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockIncreaseKnowledgeBaseUsageExpectation specifies expectation struct of the Repository.IncreaseKnowledgeBaseUsage
type RepositoryMockIncreaseKnowledgeBaseUsageExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockIncreaseKnowledgeBaseUsageParams
	paramPtrs          *RepositoryMockIncreaseKnowledgeBaseUsageParamPtrs
	expectationOrigins RepositoryMockIncreaseKnowledgeBaseUsageExpectationOrigins
	results            *RepositoryMockIncreaseKnowledgeBaseUsageResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockIncreaseKnowledgeBaseUsageParams contains parameters of the Repository.IncreaseKnowledgeBaseUsage
type RepositoryMockIncreaseKnowledgeBaseUsageParams struct {
	ctx    context.Context
	tx     *gorm.DB
	kbUID  string
	amount int
}

// RepositoryMockIncreaseKnowledgeBaseUsageParamPtrs contains pointers to parameters of the Repository.IncreaseKnowledgeBaseUsage
type RepositoryMockIncreaseKnowledgeBaseUsageParamPtrs struct {
	ctx    *context.Context
	tx     **gorm.DB
	kbUID  *string
	amount *int
}

// RepositoryMockIncreaseKnowledgeBaseUsageResults contains results of the Repository.IncreaseKnowledgeBaseUsage
type RepositoryMockIncreaseKnowledgeBaseUsageResults struct {
	err error
}

// RepositoryMockIncreaseKnowledgeBaseUsageOrigins contains origins of expectations of the Repository.IncreaseKnowledgeBaseUsage
type RepositoryMockIncreaseKnowledgeBaseUsageExpectationOrigins struct {
	origin       string
	originCtx    string
	originTx     string
	originKbUID  string
	originAmount string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIncreaseKnowledgeBaseUsage *mRepositoryMockIncreaseKnowledgeBaseUsage) Optional() *mRepositoryMockIncreaseKnowledgeBaseUsage {
	mmIncreaseKnowledgeBaseUsage.optional = true
	return mmIncreaseKnowledgeBaseUsage
}

// Expect sets up expected params for Repository.IncreaseKnowledgeBaseUsage
func (mmIncreaseKnowledgeBaseUsage *mRepositoryMockIncreaseKnowledgeBaseUsage) Expect(ctx context.Context, tx *gorm.DB, kbUID string, amount int) *mRepositoryMockIncreaseKnowledgeBaseUsage {
	if mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryMock.IncreaseKnowledgeBaseUsage mock is already set by Set")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation = &RepositoryMockIncreaseKnowledgeBaseUsageExpectation{}
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryMock.IncreaseKnowledgeBaseUsage mock is already set by ExpectParams functions")
	}

	mmIncreaseKnowledgeBaseUsage.defaultExpectation.params = &RepositoryMockIncreaseKnowledgeBaseUsageParams{ctx, tx, kbUID, amount}
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIncreaseKnowledgeBaseUsage.expectations {
		if minimock.Equal(e.params, mmIncreaseKnowledgeBaseUsage.defaultExpectation.params) {
			mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIncreaseKnowledgeBaseUsage.defaultExpectation.params)
		}
	}

	return mmIncreaseKnowledgeBaseUsage
}

// ExpectCtxParam1 sets up expected param ctx for Repository.IncreaseKnowledgeBaseUsage
func (mmIncreaseKnowledgeBaseUsage *mRepositoryMockIncreaseKnowledgeBaseUsage) ExpectCtxParam1(ctx context.Context) *mRepositoryMockIncreaseKnowledgeBaseUsage {
	if mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryMock.IncreaseKnowledgeBaseUsage mock is already set by Set")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation = &RepositoryMockIncreaseKnowledgeBaseUsageExpectation{}
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.params != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryMock.IncreaseKnowledgeBaseUsage mock is already set by Expect")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs = &RepositoryMockIncreaseKnowledgeBaseUsageParamPtrs{}
	}
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs.ctx = &ctx
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmIncreaseKnowledgeBaseUsage
}

// ExpectTxParam2 sets up expected param tx for Repository.IncreaseKnowledgeBaseUsage
func (mmIncreaseKnowledgeBaseUsage *mRepositoryMockIncreaseKnowledgeBaseUsage) ExpectTxParam2(tx *gorm.DB) *mRepositoryMockIncreaseKnowledgeBaseUsage {
	if mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryMock.IncreaseKnowledgeBaseUsage mock is already set by Set")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation = &RepositoryMockIncreaseKnowledgeBaseUsageExpectation{}
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.params != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryMock.IncreaseKnowledgeBaseUsage mock is already set by Expect")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs = &RepositoryMockIncreaseKnowledgeBaseUsageParamPtrs{}
	}
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs.tx = &tx
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.expectationOrigins.originTx = minimock.CallerInfo(1)

	return mmIncreaseKnowledgeBaseUsage
}

// ExpectKbUIDParam3 sets up expected param kbUID for Repository.IncreaseKnowledgeBaseUsage
func (mmIncreaseKnowledgeBaseUsage *mRepositoryMockIncreaseKnowledgeBaseUsage) ExpectKbUIDParam3(kbUID string) *mRepositoryMockIncreaseKnowledgeBaseUsage {
	if mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryMock.IncreaseKnowledgeBaseUsage mock is already set by Set")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation = &RepositoryMockIncreaseKnowledgeBaseUsageExpectation{}
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.params != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryMock.IncreaseKnowledgeBaseUsage mock is already set by Expect")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs = &RepositoryMockIncreaseKnowledgeBaseUsageParamPtrs{}
	}
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmIncreaseKnowledgeBaseUsage
}

// ExpectAmountParam4 sets up expected param amount for Repository.IncreaseKnowledgeBaseUsage
func (mmIncreaseKnowledgeBaseUsage *mRepositoryMockIncreaseKnowledgeBaseUsage) ExpectAmountParam4(amount int) *mRepositoryMockIncreaseKnowledgeBaseUsage {
	if mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryMock.IncreaseKnowledgeBaseUsage mock is already set by Set")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation = &RepositoryMockIncreaseKnowledgeBaseUsageExpectation{}
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.params != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryMock.IncreaseKnowledgeBaseUsage mock is already set by Expect")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs = &RepositoryMockIncreaseKnowledgeBaseUsageParamPtrs{}
	}
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs.amount = &amount
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.expectationOrigins.originAmount = minimock.CallerInfo(1)

	return mmIncreaseKnowledgeBaseUsage
}

// Inspect accepts an inspector function that has same arguments as the Repository.IncreaseKnowledgeBaseUsage
func (mmIncreaseKnowledgeBaseUsage *mRepositoryMockIncreaseKnowledgeBaseUsage) Inspect(f func(ctx context.Context, tx *gorm.DB, kbUID string, amount int)) *mRepositoryMockIncreaseKnowledgeBaseUsage {
	if mmIncreaseKnowledgeBaseUsage.mock.inspectFuncIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("Inspect function is already set for RepositoryMock.IncreaseKnowledgeBaseUsage")
	}

	mmIncreaseKnowledgeBaseUsage.mock.inspectFuncIncreaseKnowledgeBaseUsage = f

	return mmIncreaseKnowledgeBaseUsage
}

// Return sets up results that will be returned by Repository.IncreaseKnowledgeBaseUsage
func (mmIncreaseKnowledgeBaseUsage *mRepositoryMockIncreaseKnowledgeBaseUsage) Return(err error) *RepositoryMock {
	if mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryMock.IncreaseKnowledgeBaseUsage mock is already set by Set")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation = &RepositoryMockIncreaseKnowledgeBaseUsageExpectation{mock: mmIncreaseKnowledgeBaseUsage.mock}
	}
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.results = &RepositoryMockIncreaseKnowledgeBaseUsageResults{err}
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIncreaseKnowledgeBaseUsage.mock
}

// Set uses given function f to mock the Repository.IncreaseKnowledgeBaseUsage method
func (mmIncreaseKnowledgeBaseUsage *mRepositoryMockIncreaseKnowledgeBaseUsage) Set(f func(ctx context.Context, tx *gorm.DB, kbUID string, amount int) (err error)) *RepositoryMock {
	if mmIncreaseKnowledgeBaseUsage.defaultExpectation != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("Default expectation is already set for the Repository.IncreaseKnowledgeBaseUsage method")
	}

	if len(mmIncreaseKnowledgeBaseUsage.expectations) > 0 {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("Some expectations are already set for the Repository.IncreaseKnowledgeBaseUsage method")
	}

	mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage = f
	mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsageOrigin = minimock.CallerInfo(1)
	return mmIncreaseKnowledgeBaseUsage.mock
}

// When sets expectation for the Repository.IncreaseKnowledgeBaseUsage which will trigger the result defined by the following
// Then helper
func (mmIncreaseKnowledgeBaseUsage *mRepositoryMockIncreaseKnowledgeBaseUsage) When(ctx context.Context, tx *gorm.DB, kbUID string, amount int) *RepositoryMockIncreaseKnowledgeBaseUsageExpectation {
	if mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryMock.IncreaseKnowledgeBaseUsage mock is already set by Set")
	}

	expectation := &RepositoryMockIncreaseKnowledgeBaseUsageExpectation{
		mock:               mmIncreaseKnowledgeBaseUsage.mock,
		params:             &RepositoryMockIncreaseKnowledgeBaseUsageParams{ctx, tx, kbUID, amount},
		expectationOrigins: RepositoryMockIncreaseKnowledgeBaseUsageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIncreaseKnowledgeBaseUsage.expectations = append(mmIncreaseKnowledgeBaseUsage.expectations, expectation)
	return expectation
}

// Then sets up Repository.IncreaseKnowledgeBaseUsage return parameters for the expectation previously defined by the When method
func (e *RepositoryMockIncreaseKnowledgeBaseUsageExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockIncreaseKnowledgeBaseUsageResults{err}
	return e.mock
}

// Times sets number of times Repository.IncreaseKnowledgeBaseUsage should be invoked
func (mmIncreaseKnowledgeBaseUsage *mRepositoryMockIncreaseKnowledgeBaseUsage) Times(n uint64) *mRepositoryMockIncreaseKnowledgeBaseUsage {
	if n == 0 {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("Times of RepositoryMock.IncreaseKnowledgeBaseUsage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIncreaseKnowledgeBaseUsage.expectedInvocations, n)
	mmIncreaseKnowledgeBaseUsage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIncreaseKnowledgeBaseUsage
}

func (mmIncreaseKnowledgeBaseUsage *mRepositoryMockIncreaseKnowledgeBaseUsage) invocationsDone() bool {
	if len(mmIncreaseKnowledgeBaseUsage.expectations) == 0 && mmIncreaseKnowledgeBaseUsage.defaultExpectation == nil && mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIncreaseKnowledgeBaseUsage.mock.afterIncreaseKnowledgeBaseUsageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIncreaseKnowledgeBaseUsage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IncreaseKnowledgeBaseUsage implements mm_repository.Repository
func (mmIncreaseKnowledgeBaseUsage *RepositoryMock) IncreaseKnowledgeBaseUsage(ctx context.Context, tx *gorm.DB, kbUID string, amount int) (err error) {
	mm_atomic.AddUint64(&mmIncreaseKnowledgeBaseUsage.beforeIncreaseKnowledgeBaseUsageCounter, 1)
	defer mm_atomic.AddUint64(&mmIncreaseKnowledgeBaseUsage.afterIncreaseKnowledgeBaseUsageCounter, 1)

	mmIncreaseKnowledgeBaseUsage.t.Helper()

	if mmIncreaseKnowledgeBaseUsage.inspectFuncIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.inspectFuncIncreaseKnowledgeBaseUsage(ctx, tx, kbUID, amount)
	}

	mm_params := RepositoryMockIncreaseKnowledgeBaseUsageParams{ctx, tx, kbUID, amount}

	// Record call args
	mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.mutex.Lock()
	mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.callArgs = append(mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.callArgs, &mm_params)
	mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.mutex.Unlock()

	for _, e := range mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation.Counter, 1)
		mm_want := mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation.params
		mm_want_ptrs := mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockIncreaseKnowledgeBaseUsageParams{ctx, tx, kbUID, amount}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmIncreaseKnowledgeBaseUsage.t.Errorf("RepositoryMock.IncreaseKnowledgeBaseUsage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tx != nil && !minimock.Equal(*mm_want_ptrs.tx, mm_got.tx) {
				mmIncreaseKnowledgeBaseUsage.t.Errorf("RepositoryMock.IncreaseKnowledgeBaseUsage got unexpected parameter tx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation.expectationOrigins.originTx, *mm_want_ptrs.tx, mm_got.tx, minimock.Diff(*mm_want_ptrs.tx, mm_got.tx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmIncreaseKnowledgeBaseUsage.t.Errorf("RepositoryMock.IncreaseKnowledgeBaseUsage got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.amount != nil && !minimock.Equal(*mm_want_ptrs.amount, mm_got.amount) {
				mmIncreaseKnowledgeBaseUsage.t.Errorf("RepositoryMock.IncreaseKnowledgeBaseUsage got unexpected parameter amount, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation.expectationOrigins.originAmount, *mm_want_ptrs.amount, mm_got.amount, minimock.Diff(*mm_want_ptrs.amount, mm_got.amount))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIncreaseKnowledgeBaseUsage.t.Errorf("RepositoryMock.IncreaseKnowledgeBaseUsage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation.results
		if mm_results == nil {
			mmIncreaseKnowledgeBaseUsage.t.Fatal("No results are set for the RepositoryMock.IncreaseKnowledgeBaseUsage")
		}
		return (*mm_results).err
	}
	if mmIncreaseKnowledgeBaseUsage.funcIncreaseKnowledgeBaseUsage != nil {
		return mmIncreaseKnowledgeBaseUsage.funcIncreaseKnowledgeBaseUsage(ctx, tx, kbUID, amount)
	}
	mmIncreaseKnowledgeBaseUsage.t.Fatalf("Unexpected call to RepositoryMock.IncreaseKnowledgeBaseUsage. %v %v %v %v", ctx, tx, kbUID, amount)
	return
}

// IncreaseKnowledgeBaseUsageAfterCounter returns a count of finished RepositoryMock.IncreaseKnowledgeBaseUsage invocations
func (mmIncreaseKnowledgeBaseUsage *RepositoryMock) IncreaseKnowledgeBaseUsageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIncreaseKnowledgeBaseUsage.afterIncreaseKnowledgeBaseUsageCounter)
}

// IncreaseKnowledgeBaseUsageBeforeCounter returns a count of RepositoryMock.IncreaseKnowledgeBaseUsage invocations
func (mmIncreaseKnowledgeBaseUsage *RepositoryMock) IncreaseKnowledgeBaseUsageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIncreaseKnowledgeBaseUsage.beforeIncreaseKnowledgeBaseUsageCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.IncreaseKnowledgeBaseUsage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIncreaseKnowledgeBaseUsage *mRepositoryMockIncreaseKnowledgeBaseUsage) Calls() []*RepositoryMockIncreaseKnowledgeBaseUsageParams {
	mmIncreaseKnowledgeBaseUsage.mutex.RLock()

	argCopy := make([]*RepositoryMockIncreaseKnowledgeBaseUsageParams, len(mmIncreaseKnowledgeBaseUsage.callArgs))
	copy(argCopy, mmIncreaseKnowledgeBaseUsage.callArgs)

	mmIncreaseKnowledgeBaseUsage.mutex.RUnlock()

	return argCopy
}

// MinimockIncreaseKnowledgeBaseUsageDone returns true if the count of the IncreaseKnowledgeBaseUsage invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockIncreaseKnowledgeBaseUsageDone() bool {
	if m.IncreaseKnowledgeBaseUsageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IncreaseKnowledgeBaseUsageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IncreaseKnowledgeBaseUsageMock.invocationsDone()
}

// MinimockIncreaseKnowledgeBaseUsageInspect logs each unmet expectation
func (m *RepositoryMock) MinimockIncreaseKnowledgeBaseUsageInspect() {
	for _, e := range m.IncreaseKnowledgeBaseUsageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.IncreaseKnowledgeBaseUsage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIncreaseKnowledgeBaseUsageCounter := mm_atomic.LoadUint64(&m.afterIncreaseKnowledgeBaseUsageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IncreaseKnowledgeBaseUsageMock.defaultExpectation != nil && afterIncreaseKnowledgeBaseUsageCounter < 1 {
		if m.IncreaseKnowledgeBaseUsageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.IncreaseKnowledgeBaseUsage at\n%s", m.IncreaseKnowledgeBaseUsageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.IncreaseKnowledgeBaseUsage at\n%s with params: %#v", m.IncreaseKnowledgeBaseUsageMock.defaultExpectation.expectationOrigins.origin, *m.IncreaseKnowledgeBaseUsageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIncreaseKnowledgeBaseUsage != nil && afterIncreaseKnowledgeBaseUsageCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.IncreaseKnowledgeBaseUsage at\n%s", m.funcIncreaseKnowledgeBaseUsageOrigin)
	}

	if !m.IncreaseKnowledgeBaseUsageMock.invocationsDone() && afterIncreaseKnowledgeBaseUsageCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.IncreaseKnowledgeBaseUsage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IncreaseKnowledgeBaseUsageMock.expectedInvocations), m.IncreaseKnowledgeBaseUsageMock.expectedInvocationsOrigin, afterIncreaseKnowledgeBaseUsageCounter)
	}
}

type mRepositoryMockInsertVectorsInCollection struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockInsertVectorsInCollectionExpectation
	expectations       []*RepositoryMockInsertVectorsInCollectionExpectation

	callArgs []*RepositoryMockInsertVectorsInCollectionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockInsertVectorsInCollectionExpectation specifies expectation struct of the Repository.InsertVectorsInCollection
type RepositoryMockInsertVectorsInCollectionExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockInsertVectorsInCollectionParams
	paramPtrs          *RepositoryMockInsertVectorsInCollectionParamPtrs
	expectationOrigins RepositoryMockInsertVectorsInCollectionExpectationOrigins
	results            *RepositoryMockInsertVectorsInCollectionResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockInsertVectorsInCollectionParams contains parameters of the Repository.InsertVectorsInCollection
type RepositoryMockInsertVectorsInCollectionParams struct {
	ctx        context.Context
	collID     string
	embeddings []mm_repository.VectorEmbedding
}

// RepositoryMockInsertVectorsInCollectionParamPtrs contains pointers to parameters of the Repository.InsertVectorsInCollection
type RepositoryMockInsertVectorsInCollectionParamPtrs struct {
	ctx        *context.Context
	collID     *string
	embeddings *[]mm_repository.VectorEmbedding
}

// RepositoryMockInsertVectorsInCollectionResults contains results of the Repository.InsertVectorsInCollection
type RepositoryMockInsertVectorsInCollectionResults struct {
	err error
}

// RepositoryMockInsertVectorsInCollectionOrigins contains origins of expectations of the Repository.InsertVectorsInCollection
type RepositoryMockInsertVectorsInCollectionExpectationOrigins struct {
	origin           string
	originCtx        string
	originCollID     string
	originEmbeddings string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInsertVectorsInCollection *mRepositoryMockInsertVectorsInCollection) Optional() *mRepositoryMockInsertVectorsInCollection {
	mmInsertVectorsInCollection.optional = true
	return mmInsertVectorsInCollection
}

// Expect sets up expected params for Repository.InsertVectorsInCollection
func (mmInsertVectorsInCollection *mRepositoryMockInsertVectorsInCollection) Expect(ctx context.Context, collID string, embeddings []mm_repository.VectorEmbedding) *mRepositoryMockInsertVectorsInCollection {
	if mmInsertVectorsInCollection.mock.funcInsertVectorsInCollection != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("RepositoryMock.InsertVectorsInCollection mock is already set by Set")
	}

	if mmInsertVectorsInCollection.defaultExpectation == nil {
		mmInsertVectorsInCollection.defaultExpectation = &RepositoryMockInsertVectorsInCollectionExpectation{}
	}

	if mmInsertVectorsInCollection.defaultExpectation.paramPtrs != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("RepositoryMock.InsertVectorsInCollection mock is already set by ExpectParams functions")
	}

	mmInsertVectorsInCollection.defaultExpectation.params = &RepositoryMockInsertVectorsInCollectionParams{ctx, collID, embeddings}
	mmInsertVectorsInCollection.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmInsertVectorsInCollection.expectations {
		if minimock.Equal(e.params, mmInsertVectorsInCollection.defaultExpectation.params) {
			mmInsertVectorsInCollection.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInsertVectorsInCollection.defaultExpectation.params)
		}
	}

	return mmInsertVectorsInCollection
}

// ExpectCtxParam1 sets up expected param ctx for Repository.InsertVectorsInCollection
func (mmInsertVectorsInCollection *mRepositoryMockInsertVectorsInCollection) ExpectCtxParam1(ctx context.Context) *mRepositoryMockInsertVectorsInCollection {
	if mmInsertVectorsInCollection.mock.funcInsertVectorsInCollection != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("RepositoryMock.InsertVectorsInCollection mock is already set by Set")
	}

	if mmInsertVectorsInCollection.defaultExpectation == nil {
		mmInsertVectorsInCollection.defaultExpectation = &RepositoryMockInsertVectorsInCollectionExpectation{}
	}

	if mmInsertVectorsInCollection.defaultExpectation.params != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("RepositoryMock.InsertVectorsInCollection mock is already set by Expect")
	}

	if mmInsertVectorsInCollection.defaultExpectation.paramPtrs == nil {
		mmInsertVectorsInCollection.defaultExpectation.paramPtrs = &RepositoryMockInsertVectorsInCollectionParamPtrs{}
	}
	mmInsertVectorsInCollection.defaultExpectation.paramPtrs.ctx = &ctx
	mmInsertVectorsInCollection.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmInsertVectorsInCollection
}

// ExpectCollIDParam2 sets up expected param collID for Repository.InsertVectorsInCollection
func (mmInsertVectorsInCollection *mRepositoryMockInsertVectorsInCollection) ExpectCollIDParam2(collID string) *mRepositoryMockInsertVectorsInCollection {
	if mmInsertVectorsInCollection.mock.funcInsertVectorsInCollection != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("RepositoryMock.InsertVectorsInCollection mock is already set by Set")
	}

	if mmInsertVectorsInCollection.defaultExpectation == nil {
		mmInsertVectorsInCollection.defaultExpectation = &RepositoryMockInsertVectorsInCollectionExpectation{}
	}

	if mmInsertVectorsInCollection.defaultExpectation.params != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("RepositoryMock.InsertVectorsInCollection mock is already set by Expect")
	}

	if mmInsertVectorsInCollection.defaultExpectation.paramPtrs == nil {
		mmInsertVectorsInCollection.defaultExpectation.paramPtrs = &RepositoryMockInsertVectorsInCollectionParamPtrs{}
	}
	mmInsertVectorsInCollection.defaultExpectation.paramPtrs.collID = &collID
	mmInsertVectorsInCollection.defaultExpectation.expectationOrigins.originCollID = minimock.CallerInfo(1)

	return mmInsertVectorsInCollection
}

// ExpectEmbeddingsParam3 sets up expected param embeddings for Repository.InsertVectorsInCollection
func (mmInsertVectorsInCollection *mRepositoryMockInsertVectorsInCollection) ExpectEmbeddingsParam3(embeddings []mm_repository.VectorEmbedding) *mRepositoryMockInsertVectorsInCollection {
	if mmInsertVectorsInCollection.mock.funcInsertVectorsInCollection != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("RepositoryMock.InsertVectorsInCollection mock is already set by Set")
	}

	if mmInsertVectorsInCollection.defaultExpectation == nil {
		mmInsertVectorsInCollection.defaultExpectation = &RepositoryMockInsertVectorsInCollectionExpectation{}
	}

	if mmInsertVectorsInCollection.defaultExpectation.params != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("RepositoryMock.InsertVectorsInCollection mock is already set by Expect")
	}

	if mmInsertVectorsInCollection.defaultExpectation.paramPtrs == nil {
		mmInsertVectorsInCollection.defaultExpectation.paramPtrs = &RepositoryMockInsertVectorsInCollectionParamPtrs{}
	}
	mmInsertVectorsInCollection.defaultExpectation.paramPtrs.embeddings = &embeddings
	mmInsertVectorsInCollection.defaultExpectation.expectationOrigins.originEmbeddings = minimock.CallerInfo(1)

	return mmInsertVectorsInCollection
}

// Inspect accepts an inspector function that has same arguments as the Repository.InsertVectorsInCollection
func (mmInsertVectorsInCollection *mRepositoryMockInsertVectorsInCollection) Inspect(f func(ctx context.Context, collID string, embeddings []mm_repository.VectorEmbedding)) *mRepositoryMockInsertVectorsInCollection {
	if mmInsertVectorsInCollection.mock.inspectFuncInsertVectorsInCollection != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("Inspect function is already set for RepositoryMock.InsertVectorsInCollection")
	}

	mmInsertVectorsInCollection.mock.inspectFuncInsertVectorsInCollection = f

	return mmInsertVectorsInCollection
}

// Return sets up results that will be returned by Repository.InsertVectorsInCollection
func (mmInsertVectorsInCollection *mRepositoryMockInsertVectorsInCollection) Return(err error) *RepositoryMock {
	if mmInsertVectorsInCollection.mock.funcInsertVectorsInCollection != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("RepositoryMock.InsertVectorsInCollection mock is already set by Set")
	}

	if mmInsertVectorsInCollection.defaultExpectation == nil {
		mmInsertVectorsInCollection.defaultExpectation = &RepositoryMockInsertVectorsInCollectionExpectation{mock: mmInsertVectorsInCollection.mock}
	}
	mmInsertVectorsInCollection.defaultExpectation.results = &RepositoryMockInsertVectorsInCollectionResults{err}
	mmInsertVectorsInCollection.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInsertVectorsInCollection.mock
}

// Set uses given function f to mock the Repository.InsertVectorsInCollection method
func (mmInsertVectorsInCollection *mRepositoryMockInsertVectorsInCollection) Set(f func(ctx context.Context, collID string, embeddings []mm_repository.VectorEmbedding) (err error)) *RepositoryMock {
	if mmInsertVectorsInCollection.defaultExpectation != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("Default expectation is already set for the Repository.InsertVectorsInCollection method")
	}

	if len(mmInsertVectorsInCollection.expectations) > 0 {
		mmInsertVectorsInCollection.mock.t.Fatalf("Some expectations are already set for the Repository.InsertVectorsInCollection method")
	}

	mmInsertVectorsInCollection.mock.funcInsertVectorsInCollection = f
	mmInsertVectorsInCollection.mock.funcInsertVectorsInCollectionOrigin = minimock.CallerInfo(1)
	return mmInsertVectorsInCollection.mock
}

// When sets expectation for the Repository.InsertVectorsInCollection which will trigger the result defined by the following
// Then helper
func (mmInsertVectorsInCollection *mRepositoryMockInsertVectorsInCollection) When(ctx context.Context, collID string, embeddings []mm_repository.VectorEmbedding) *RepositoryMockInsertVectorsInCollectionExpectation {
	if mmInsertVectorsInCollection.mock.funcInsertVectorsInCollection != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("RepositoryMock.InsertVectorsInCollection mock is already set by Set")
	}

	expectation := &RepositoryMockInsertVectorsInCollectionExpectation{
		mock:               mmInsertVectorsInCollection.mock,
		params:             &RepositoryMockInsertVectorsInCollectionParams{ctx, collID, embeddings},
		expectationOrigins: RepositoryMockInsertVectorsInCollectionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmInsertVectorsInCollection.expectations = append(mmInsertVectorsInCollection.expectations, expectation)
	return expectation
}

// Then sets up Repository.InsertVectorsInCollection return parameters for the expectation previously defined by the When method
func (e *RepositoryMockInsertVectorsInCollectionExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockInsertVectorsInCollectionResults{err}
	return e.mock
}

// Times sets number of times Repository.InsertVectorsInCollection should be invoked
func (mmInsertVectorsInCollection *mRepositoryMockInsertVectorsInCollection) Times(n uint64) *mRepositoryMockInsertVectorsInCollection {
	if n == 0 {
		mmInsertVectorsInCollection.mock.t.Fatalf("Times of RepositoryMock.InsertVectorsInCollection mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInsertVectorsInCollection.expectedInvocations, n)
	mmInsertVectorsInCollection.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInsertVectorsInCollection
}

func (mmInsertVectorsInCollection *mRepositoryMockInsertVectorsInCollection) invocationsDone() bool {
	if len(mmInsertVectorsInCollection.expectations) == 0 && mmInsertVectorsInCollection.defaultExpectation == nil && mmInsertVectorsInCollection.mock.funcInsertVectorsInCollection == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInsertVectorsInCollection.mock.afterInsertVectorsInCollectionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInsertVectorsInCollection.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// InsertVectorsInCollection implements mm_repository.Repository
func (mmInsertVectorsInCollection *RepositoryMock) InsertVectorsInCollection(ctx context.Context, collID string, embeddings []mm_repository.VectorEmbedding) (err error) {
	mm_atomic.AddUint64(&mmInsertVectorsInCollection.beforeInsertVectorsInCollectionCounter, 1)
	defer mm_atomic.AddUint64(&mmInsertVectorsInCollection.afterInsertVectorsInCollectionCounter, 1)

	mmInsertVectorsInCollection.t.Helper()

	if mmInsertVectorsInCollection.inspectFuncInsertVectorsInCollection != nil {
		mmInsertVectorsInCollection.inspectFuncInsertVectorsInCollection(ctx, collID, embeddings)
	}

	mm_params := RepositoryMockInsertVectorsInCollectionParams{ctx, collID, embeddings}

	// Record call args
	mmInsertVectorsInCollection.InsertVectorsInCollectionMock.mutex.Lock()
	mmInsertVectorsInCollection.InsertVectorsInCollectionMock.callArgs = append(mmInsertVectorsInCollection.InsertVectorsInCollectionMock.callArgs, &mm_params)
	mmInsertVectorsInCollection.InsertVectorsInCollectionMock.mutex.Unlock()

	for _, e := range mmInsertVectorsInCollection.InsertVectorsInCollectionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmInsertVectorsInCollection.InsertVectorsInCollectionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInsertVectorsInCollection.InsertVectorsInCollectionMock.defaultExpectation.Counter, 1)
		mm_want := mmInsertVectorsInCollection.InsertVectorsInCollectionMock.defaultExpectation.params
		mm_want_ptrs := mmInsertVectorsInCollection.InsertVectorsInCollectionMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockInsertVectorsInCollectionParams{ctx, collID, embeddings}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmInsertVectorsInCollection.t.Errorf("RepositoryMock.InsertVectorsInCollection got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInsertVectorsInCollection.InsertVectorsInCollectionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.collID != nil && !minimock.Equal(*mm_want_ptrs.collID, mm_got.collID) {
				mmInsertVectorsInCollection.t.Errorf("RepositoryMock.InsertVectorsInCollection got unexpected parameter collID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInsertVectorsInCollection.InsertVectorsInCollectionMock.defaultExpectation.expectationOrigins.originCollID, *mm_want_ptrs.collID, mm_got.collID, minimock.Diff(*mm_want_ptrs.collID, mm_got.collID))
			}

			if mm_want_ptrs.embeddings != nil && !minimock.Equal(*mm_want_ptrs.embeddings, mm_got.embeddings) {
				mmInsertVectorsInCollection.t.Errorf("RepositoryMock.InsertVectorsInCollection got unexpected parameter embeddings, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInsertVectorsInCollection.InsertVectorsInCollectionMock.defaultExpectation.expectationOrigins.originEmbeddings, *mm_want_ptrs.embeddings, mm_got.embeddings, minimock.Diff(*mm_want_ptrs.embeddings, mm_got.embeddings))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInsertVectorsInCollection.t.Errorf("RepositoryMock.InsertVectorsInCollection got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmInsertVectorsInCollection.InsertVectorsInCollectionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInsertVectorsInCollection.InsertVectorsInCollectionMock.defaultExpectation.results
		if mm_results == nil {
			mmInsertVectorsInCollection.t.Fatal("No results are set for the RepositoryMock.InsertVectorsInCollection")
		}
		return (*mm_results).err
	}
	if mmInsertVectorsInCollection.funcInsertVectorsInCollection != nil {
		return mmInsertVectorsInCollection.funcInsertVectorsInCollection(ctx, collID, embeddings)
	}
	mmInsertVectorsInCollection.t.Fatalf("Unexpected call to RepositoryMock.InsertVectorsInCollection. %v %v %v", ctx, collID, embeddings)
	return
}

// InsertVectorsInCollectionAfterCounter returns a count of finished RepositoryMock.InsertVectorsInCollection invocations
func (mmInsertVectorsInCollection *RepositoryMock) InsertVectorsInCollectionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertVectorsInCollection.afterInsertVectorsInCollectionCounter)
}

// InsertVectorsInCollectionBeforeCounter returns a count of RepositoryMock.InsertVectorsInCollection invocations
func (mmInsertVectorsInCollection *RepositoryMock) InsertVectorsInCollectionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertVectorsInCollection.beforeInsertVectorsInCollectionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.InsertVectorsInCollection.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInsertVectorsInCollection *mRepositoryMockInsertVectorsInCollection) Calls() []*RepositoryMockInsertVectorsInCollectionParams {
	mmInsertVectorsInCollection.mutex.RLock()

	argCopy := make([]*RepositoryMockInsertVectorsInCollectionParams, len(mmInsertVectorsInCollection.callArgs))
	copy(argCopy, mmInsertVectorsInCollection.callArgs)

	mmInsertVectorsInCollection.mutex.RUnlock()

	return argCopy
}

// MinimockInsertVectorsInCollectionDone returns true if the count of the InsertVectorsInCollection invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockInsertVectorsInCollectionDone() bool {
	if m.InsertVectorsInCollectionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InsertVectorsInCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InsertVectorsInCollectionMock.invocationsDone()
}

// MinimockInsertVectorsInCollectionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockInsertVectorsInCollectionInspect() {
	for _, e := range m.InsertVectorsInCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.InsertVectorsInCollection at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterInsertVectorsInCollectionCounter := mm_atomic.LoadUint64(&m.afterInsertVectorsInCollectionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InsertVectorsInCollectionMock.defaultExpectation != nil && afterInsertVectorsInCollectionCounter < 1 {
		if m.InsertVectorsInCollectionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.InsertVectorsInCollection at\n%s", m.InsertVectorsInCollectionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.InsertVectorsInCollection at\n%s with params: %#v", m.InsertVectorsInCollectionMock.defaultExpectation.expectationOrigins.origin, *m.InsertVectorsInCollectionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertVectorsInCollection != nil && afterInsertVectorsInCollectionCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.InsertVectorsInCollection at\n%s", m.funcInsertVectorsInCollectionOrigin)
	}

	if !m.InsertVectorsInCollectionMock.invocationsDone() && afterInsertVectorsInCollectionCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.InsertVectorsInCollection at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InsertVectorsInCollectionMock.expectedInvocations), m.InsertVectorsInCollectionMock.expectedInvocationsOrigin, afterInsertVectorsInCollectionCounter)
	}
}

type mRepositoryMockIsCollectionInUse struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockIsCollectionInUseExpectation
	expectations       []*RepositoryMockIsCollectionInUseExpectation

	callArgs []*RepositoryMockIsCollectionInUseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockIsCollectionInUseExpectation specifies expectation struct of the Repository.IsCollectionInUse
type RepositoryMockIsCollectionInUseExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockIsCollectionInUseParams
	paramPtrs          *RepositoryMockIsCollectionInUseParamPtrs
	expectationOrigins RepositoryMockIsCollectionInUseExpectationOrigins
	results            *RepositoryMockIsCollectionInUseResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockIsCollectionInUseParams contains parameters of the Repository.IsCollectionInUse
type RepositoryMockIsCollectionInUseParams struct {
	ctx           context.Context
	collectionUID types.CollectionUIDType
}

// RepositoryMockIsCollectionInUseParamPtrs contains pointers to parameters of the Repository.IsCollectionInUse
type RepositoryMockIsCollectionInUseParamPtrs struct {
	ctx           *context.Context
	collectionUID *types.CollectionUIDType
}

// RepositoryMockIsCollectionInUseResults contains results of the Repository.IsCollectionInUse
type RepositoryMockIsCollectionInUseResults struct {
	b1  bool
	err error
}

// RepositoryMockIsCollectionInUseOrigins contains origins of expectations of the Repository.IsCollectionInUse
type RepositoryMockIsCollectionInUseExpectationOrigins struct {
	origin              string
	originCtx           string
	originCollectionUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsCollectionInUse *mRepositoryMockIsCollectionInUse) Optional() *mRepositoryMockIsCollectionInUse {
	mmIsCollectionInUse.optional = true
	return mmIsCollectionInUse
}

// Expect sets up expected params for Repository.IsCollectionInUse
func (mmIsCollectionInUse *mRepositoryMockIsCollectionInUse) Expect(ctx context.Context, collectionUID types.CollectionUIDType) *mRepositoryMockIsCollectionInUse {
	if mmIsCollectionInUse.mock.funcIsCollectionInUse != nil {
		mmIsCollectionInUse.mock.t.Fatalf("RepositoryMock.IsCollectionInUse mock is already set by Set")
	}

	if mmIsCollectionInUse.defaultExpectation == nil {
		mmIsCollectionInUse.defaultExpectation = &RepositoryMockIsCollectionInUseExpectation{}
	}

	if mmIsCollectionInUse.defaultExpectation.paramPtrs != nil {
		mmIsCollectionInUse.mock.t.Fatalf("RepositoryMock.IsCollectionInUse mock is already set by ExpectParams functions")
	}

	mmIsCollectionInUse.defaultExpectation.params = &RepositoryMockIsCollectionInUseParams{ctx, collectionUID}
	mmIsCollectionInUse.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIsCollectionInUse.expectations {
		if minimock.Equal(e.params, mmIsCollectionInUse.defaultExpectation.params) {
			mmIsCollectionInUse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsCollectionInUse.defaultExpectation.params)
		}
	}

	return mmIsCollectionInUse
}

// ExpectCtxParam1 sets up expected param ctx for Repository.IsCollectionInUse
func (mmIsCollectionInUse *mRepositoryMockIsCollectionInUse) ExpectCtxParam1(ctx context.Context) *mRepositoryMockIsCollectionInUse {
	if mmIsCollectionInUse.mock.funcIsCollectionInUse != nil {
		mmIsCollectionInUse.mock.t.Fatalf("RepositoryMock.IsCollectionInUse mock is already set by Set")
	}

	if mmIsCollectionInUse.defaultExpectation == nil {
		mmIsCollectionInUse.defaultExpectation = &RepositoryMockIsCollectionInUseExpectation{}
	}

	if mmIsCollectionInUse.defaultExpectation.params != nil {
		mmIsCollectionInUse.mock.t.Fatalf("RepositoryMock.IsCollectionInUse mock is already set by Expect")
	}

	if mmIsCollectionInUse.defaultExpectation.paramPtrs == nil {
		mmIsCollectionInUse.defaultExpectation.paramPtrs = &RepositoryMockIsCollectionInUseParamPtrs{}
	}
	mmIsCollectionInUse.defaultExpectation.paramPtrs.ctx = &ctx
	mmIsCollectionInUse.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmIsCollectionInUse
}

// ExpectCollectionUIDParam2 sets up expected param collectionUID for Repository.IsCollectionInUse
func (mmIsCollectionInUse *mRepositoryMockIsCollectionInUse) ExpectCollectionUIDParam2(collectionUID types.CollectionUIDType) *mRepositoryMockIsCollectionInUse {
	if mmIsCollectionInUse.mock.funcIsCollectionInUse != nil {
		mmIsCollectionInUse.mock.t.Fatalf("RepositoryMock.IsCollectionInUse mock is already set by Set")
	}

	if mmIsCollectionInUse.defaultExpectation == nil {
		mmIsCollectionInUse.defaultExpectation = &RepositoryMockIsCollectionInUseExpectation{}
	}

	if mmIsCollectionInUse.defaultExpectation.params != nil {
		mmIsCollectionInUse.mock.t.Fatalf("RepositoryMock.IsCollectionInUse mock is already set by Expect")
	}

	if mmIsCollectionInUse.defaultExpectation.paramPtrs == nil {
		mmIsCollectionInUse.defaultExpectation.paramPtrs = &RepositoryMockIsCollectionInUseParamPtrs{}
	}
	mmIsCollectionInUse.defaultExpectation.paramPtrs.collectionUID = &collectionUID
	mmIsCollectionInUse.defaultExpectation.expectationOrigins.originCollectionUID = minimock.CallerInfo(1)

	return mmIsCollectionInUse
}

// Inspect accepts an inspector function that has same arguments as the Repository.IsCollectionInUse
func (mmIsCollectionInUse *mRepositoryMockIsCollectionInUse) Inspect(f func(ctx context.Context, collectionUID types.CollectionUIDType)) *mRepositoryMockIsCollectionInUse {
	if mmIsCollectionInUse.mock.inspectFuncIsCollectionInUse != nil {
		mmIsCollectionInUse.mock.t.Fatalf("Inspect function is already set for RepositoryMock.IsCollectionInUse")
	}

	mmIsCollectionInUse.mock.inspectFuncIsCollectionInUse = f

	return mmIsCollectionInUse
}

// Return sets up results that will be returned by Repository.IsCollectionInUse
func (mmIsCollectionInUse *mRepositoryMockIsCollectionInUse) Return(b1 bool, err error) *RepositoryMock {
	if mmIsCollectionInUse.mock.funcIsCollectionInUse != nil {
		mmIsCollectionInUse.mock.t.Fatalf("RepositoryMock.IsCollectionInUse mock is already set by Set")
	}

	if mmIsCollectionInUse.defaultExpectation == nil {
		mmIsCollectionInUse.defaultExpectation = &RepositoryMockIsCollectionInUseExpectation{mock: mmIsCollectionInUse.mock}
	}
	mmIsCollectionInUse.defaultExpectation.results = &RepositoryMockIsCollectionInUseResults{b1, err}
	mmIsCollectionInUse.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsCollectionInUse.mock
}

// Set uses given function f to mock the Repository.IsCollectionInUse method
func (mmIsCollectionInUse *mRepositoryMockIsCollectionInUse) Set(f func(ctx context.Context, collectionUID types.CollectionUIDType) (b1 bool, err error)) *RepositoryMock {
	if mmIsCollectionInUse.defaultExpectation != nil {
		mmIsCollectionInUse.mock.t.Fatalf("Default expectation is already set for the Repository.IsCollectionInUse method")
	}

	if len(mmIsCollectionInUse.expectations) > 0 {
		mmIsCollectionInUse.mock.t.Fatalf("Some expectations are already set for the Repository.IsCollectionInUse method")
	}

	mmIsCollectionInUse.mock.funcIsCollectionInUse = f
	mmIsCollectionInUse.mock.funcIsCollectionInUseOrigin = minimock.CallerInfo(1)
	return mmIsCollectionInUse.mock
}

// When sets expectation for the Repository.IsCollectionInUse which will trigger the result defined by the following
// Then helper
func (mmIsCollectionInUse *mRepositoryMockIsCollectionInUse) When(ctx context.Context, collectionUID types.CollectionUIDType) *RepositoryMockIsCollectionInUseExpectation {
	if mmIsCollectionInUse.mock.funcIsCollectionInUse != nil {
		mmIsCollectionInUse.mock.t.Fatalf("RepositoryMock.IsCollectionInUse mock is already set by Set")
	}

	expectation := &RepositoryMockIsCollectionInUseExpectation{
		mock:               mmIsCollectionInUse.mock,
		params:             &RepositoryMockIsCollectionInUseParams{ctx, collectionUID},
		expectationOrigins: RepositoryMockIsCollectionInUseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIsCollectionInUse.expectations = append(mmIsCollectionInUse.expectations, expectation)
	return expectation
}

// Then sets up Repository.IsCollectionInUse return parameters for the expectation previously defined by the When method
func (e *RepositoryMockIsCollectionInUseExpectation) Then(b1 bool, err error) *RepositoryMock {
	e.results = &RepositoryMockIsCollectionInUseResults{b1, err}
	return e.mock
}

// Times sets number of times Repository.IsCollectionInUse should be invoked
func (mmIsCollectionInUse *mRepositoryMockIsCollectionInUse) Times(n uint64) *mRepositoryMockIsCollectionInUse {
	if n == 0 {
		mmIsCollectionInUse.mock.t.Fatalf("Times of RepositoryMock.IsCollectionInUse mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsCollectionInUse.expectedInvocations, n)
	mmIsCollectionInUse.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsCollectionInUse
}

func (mmIsCollectionInUse *mRepositoryMockIsCollectionInUse) invocationsDone() bool {
	if len(mmIsCollectionInUse.expectations) == 0 && mmIsCollectionInUse.defaultExpectation == nil && mmIsCollectionInUse.mock.funcIsCollectionInUse == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsCollectionInUse.mock.afterIsCollectionInUseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsCollectionInUse.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsCollectionInUse implements mm_repository.Repository
func (mmIsCollectionInUse *RepositoryMock) IsCollectionInUse(ctx context.Context, collectionUID types.CollectionUIDType) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmIsCollectionInUse.beforeIsCollectionInUseCounter, 1)
	defer mm_atomic.AddUint64(&mmIsCollectionInUse.afterIsCollectionInUseCounter, 1)

	mmIsCollectionInUse.t.Helper()

	if mmIsCollectionInUse.inspectFuncIsCollectionInUse != nil {
		mmIsCollectionInUse.inspectFuncIsCollectionInUse(ctx, collectionUID)
	}

	mm_params := RepositoryMockIsCollectionInUseParams{ctx, collectionUID}

	// Record call args
	mmIsCollectionInUse.IsCollectionInUseMock.mutex.Lock()
	mmIsCollectionInUse.IsCollectionInUseMock.callArgs = append(mmIsCollectionInUse.IsCollectionInUseMock.callArgs, &mm_params)
	mmIsCollectionInUse.IsCollectionInUseMock.mutex.Unlock()

	for _, e := range mmIsCollectionInUse.IsCollectionInUseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmIsCollectionInUse.IsCollectionInUseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsCollectionInUse.IsCollectionInUseMock.defaultExpectation.Counter, 1)
		mm_want := mmIsCollectionInUse.IsCollectionInUseMock.defaultExpectation.params
		mm_want_ptrs := mmIsCollectionInUse.IsCollectionInUseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockIsCollectionInUseParams{ctx, collectionUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmIsCollectionInUse.t.Errorf("RepositoryMock.IsCollectionInUse got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsCollectionInUse.IsCollectionInUseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.collectionUID != nil && !minimock.Equal(*mm_want_ptrs.collectionUID, mm_got.collectionUID) {
				mmIsCollectionInUse.t.Errorf("RepositoryMock.IsCollectionInUse got unexpected parameter collectionUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsCollectionInUse.IsCollectionInUseMock.defaultExpectation.expectationOrigins.originCollectionUID, *mm_want_ptrs.collectionUID, mm_got.collectionUID, minimock.Diff(*mm_want_ptrs.collectionUID, mm_got.collectionUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsCollectionInUse.t.Errorf("RepositoryMock.IsCollectionInUse got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIsCollectionInUse.IsCollectionInUseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsCollectionInUse.IsCollectionInUseMock.defaultExpectation.results
		if mm_results == nil {
			mmIsCollectionInUse.t.Fatal("No results are set for the RepositoryMock.IsCollectionInUse")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmIsCollectionInUse.funcIsCollectionInUse != nil {
		return mmIsCollectionInUse.funcIsCollectionInUse(ctx, collectionUID)
	}
	mmIsCollectionInUse.t.Fatalf("Unexpected call to RepositoryMock.IsCollectionInUse. %v %v", ctx, collectionUID)
	return
}

// IsCollectionInUseAfterCounter returns a count of finished RepositoryMock.IsCollectionInUse invocations
func (mmIsCollectionInUse *RepositoryMock) IsCollectionInUseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsCollectionInUse.afterIsCollectionInUseCounter)
}

// IsCollectionInUseBeforeCounter returns a count of RepositoryMock.IsCollectionInUse invocations
func (mmIsCollectionInUse *RepositoryMock) IsCollectionInUseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsCollectionInUse.beforeIsCollectionInUseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.IsCollectionInUse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsCollectionInUse *mRepositoryMockIsCollectionInUse) Calls() []*RepositoryMockIsCollectionInUseParams {
	mmIsCollectionInUse.mutex.RLock()

	argCopy := make([]*RepositoryMockIsCollectionInUseParams, len(mmIsCollectionInUse.callArgs))
	copy(argCopy, mmIsCollectionInUse.callArgs)

	mmIsCollectionInUse.mutex.RUnlock()

	return argCopy
}

// MinimockIsCollectionInUseDone returns true if the count of the IsCollectionInUse invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockIsCollectionInUseDone() bool {
	if m.IsCollectionInUseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsCollectionInUseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsCollectionInUseMock.invocationsDone()
}

// MinimockIsCollectionInUseInspect logs each unmet expectation
func (m *RepositoryMock) MinimockIsCollectionInUseInspect() {
	for _, e := range m.IsCollectionInUseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.IsCollectionInUse at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIsCollectionInUseCounter := mm_atomic.LoadUint64(&m.afterIsCollectionInUseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsCollectionInUseMock.defaultExpectation != nil && afterIsCollectionInUseCounter < 1 {
		if m.IsCollectionInUseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.IsCollectionInUse at\n%s", m.IsCollectionInUseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.IsCollectionInUse at\n%s with params: %#v", m.IsCollectionInUseMock.defaultExpectation.expectationOrigins.origin, *m.IsCollectionInUseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsCollectionInUse != nil && afterIsCollectionInUseCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.IsCollectionInUse at\n%s", m.funcIsCollectionInUseOrigin)
	}

	if !m.IsCollectionInUseMock.invocationsDone() && afterIsCollectionInUseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.IsCollectionInUse at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsCollectionInUseMock.expectedInvocations), m.IsCollectionInUseMock.expectedInvocationsOrigin, afterIsCollectionInUseCounter)
	}
}

type mRepositoryMockIsKBUpdating struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockIsKBUpdatingExpectation
	expectations       []*RepositoryMockIsKBUpdatingExpectation

	callArgs []*RepositoryMockIsKBUpdatingParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockIsKBUpdatingExpectation specifies expectation struct of the Repository.IsKBUpdating
type RepositoryMockIsKBUpdatingExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockIsKBUpdatingParams
	paramPtrs          *RepositoryMockIsKBUpdatingParamPtrs
	expectationOrigins RepositoryMockIsKBUpdatingExpectationOrigins
	results            *RepositoryMockIsKBUpdatingResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockIsKBUpdatingParams contains parameters of the Repository.IsKBUpdating
type RepositoryMockIsKBUpdatingParams struct {
	ctx   context.Context
	kbUID types.KBUIDType
}

// RepositoryMockIsKBUpdatingParamPtrs contains pointers to parameters of the Repository.IsKBUpdating
type RepositoryMockIsKBUpdatingParamPtrs struct {
	ctx   *context.Context
	kbUID *types.KBUIDType
}

// RepositoryMockIsKBUpdatingResults contains results of the Repository.IsKBUpdating
type RepositoryMockIsKBUpdatingResults struct {
	b1  bool
	err error
}

// RepositoryMockIsKBUpdatingOrigins contains origins of expectations of the Repository.IsKBUpdating
type RepositoryMockIsKBUpdatingExpectationOrigins struct {
	origin      string
	originCtx   string
	originKbUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsKBUpdating *mRepositoryMockIsKBUpdating) Optional() *mRepositoryMockIsKBUpdating {
	mmIsKBUpdating.optional = true
	return mmIsKBUpdating
}

// Expect sets up expected params for Repository.IsKBUpdating
func (mmIsKBUpdating *mRepositoryMockIsKBUpdating) Expect(ctx context.Context, kbUID types.KBUIDType) *mRepositoryMockIsKBUpdating {
	if mmIsKBUpdating.mock.funcIsKBUpdating != nil {
		mmIsKBUpdating.mock.t.Fatalf("RepositoryMock.IsKBUpdating mock is already set by Set")
	}

	if mmIsKBUpdating.defaultExpectation == nil {
		mmIsKBUpdating.defaultExpectation = &RepositoryMockIsKBUpdatingExpectation{}
	}

	if mmIsKBUpdating.defaultExpectation.paramPtrs != nil {
		mmIsKBUpdating.mock.t.Fatalf("RepositoryMock.IsKBUpdating mock is already set by ExpectParams functions")
	}

	mmIsKBUpdating.defaultExpectation.params = &RepositoryMockIsKBUpdatingParams{ctx, kbUID}
	mmIsKBUpdating.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIsKBUpdating.expectations {
		if minimock.Equal(e.params, mmIsKBUpdating.defaultExpectation.params) {
			mmIsKBUpdating.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsKBUpdating.defaultExpectation.params)
		}
	}

	return mmIsKBUpdating
}

// ExpectCtxParam1 sets up expected param ctx for Repository.IsKBUpdating
func (mmIsKBUpdating *mRepositoryMockIsKBUpdating) ExpectCtxParam1(ctx context.Context) *mRepositoryMockIsKBUpdating {
	if mmIsKBUpdating.mock.funcIsKBUpdating != nil {
		mmIsKBUpdating.mock.t.Fatalf("RepositoryMock.IsKBUpdating mock is already set by Set")
	}

	if mmIsKBUpdating.defaultExpectation == nil {
		mmIsKBUpdating.defaultExpectation = &RepositoryMockIsKBUpdatingExpectation{}
	}

	if mmIsKBUpdating.defaultExpectation.params != nil {
		mmIsKBUpdating.mock.t.Fatalf("RepositoryMock.IsKBUpdating mock is already set by Expect")
	}

	if mmIsKBUpdating.defaultExpectation.paramPtrs == nil {
		mmIsKBUpdating.defaultExpectation.paramPtrs = &RepositoryMockIsKBUpdatingParamPtrs{}
	}
	mmIsKBUpdating.defaultExpectation.paramPtrs.ctx = &ctx
	mmIsKBUpdating.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmIsKBUpdating
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.IsKBUpdating
func (mmIsKBUpdating *mRepositoryMockIsKBUpdating) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockIsKBUpdating {
	if mmIsKBUpdating.mock.funcIsKBUpdating != nil {
		mmIsKBUpdating.mock.t.Fatalf("RepositoryMock.IsKBUpdating mock is already set by Set")
	}

	if mmIsKBUpdating.defaultExpectation == nil {
		mmIsKBUpdating.defaultExpectation = &RepositoryMockIsKBUpdatingExpectation{}
	}

	if mmIsKBUpdating.defaultExpectation.params != nil {
		mmIsKBUpdating.mock.t.Fatalf("RepositoryMock.IsKBUpdating mock is already set by Expect")
	}

	if mmIsKBUpdating.defaultExpectation.paramPtrs == nil {
		mmIsKBUpdating.defaultExpectation.paramPtrs = &RepositoryMockIsKBUpdatingParamPtrs{}
	}
	mmIsKBUpdating.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmIsKBUpdating.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmIsKBUpdating
}

// Inspect accepts an inspector function that has same arguments as the Repository.IsKBUpdating
func (mmIsKBUpdating *mRepositoryMockIsKBUpdating) Inspect(f func(ctx context.Context, kbUID types.KBUIDType)) *mRepositoryMockIsKBUpdating {
	if mmIsKBUpdating.mock.inspectFuncIsKBUpdating != nil {
		mmIsKBUpdating.mock.t.Fatalf("Inspect function is already set for RepositoryMock.IsKBUpdating")
	}

	mmIsKBUpdating.mock.inspectFuncIsKBUpdating = f

	return mmIsKBUpdating
}

// Return sets up results that will be returned by Repository.IsKBUpdating
func (mmIsKBUpdating *mRepositoryMockIsKBUpdating) Return(b1 bool, err error) *RepositoryMock {
	if mmIsKBUpdating.mock.funcIsKBUpdating != nil {
		mmIsKBUpdating.mock.t.Fatalf("RepositoryMock.IsKBUpdating mock is already set by Set")
	}

	if mmIsKBUpdating.defaultExpectation == nil {
		mmIsKBUpdating.defaultExpectation = &RepositoryMockIsKBUpdatingExpectation{mock: mmIsKBUpdating.mock}
	}
	mmIsKBUpdating.defaultExpectation.results = &RepositoryMockIsKBUpdatingResults{b1, err}
	mmIsKBUpdating.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsKBUpdating.mock
}

// Set uses given function f to mock the Repository.IsKBUpdating method
func (mmIsKBUpdating *mRepositoryMockIsKBUpdating) Set(f func(ctx context.Context, kbUID types.KBUIDType) (b1 bool, err error)) *RepositoryMock {
	if mmIsKBUpdating.defaultExpectation != nil {
		mmIsKBUpdating.mock.t.Fatalf("Default expectation is already set for the Repository.IsKBUpdating method")
	}

	if len(mmIsKBUpdating.expectations) > 0 {
		mmIsKBUpdating.mock.t.Fatalf("Some expectations are already set for the Repository.IsKBUpdating method")
	}

	mmIsKBUpdating.mock.funcIsKBUpdating = f
	mmIsKBUpdating.mock.funcIsKBUpdatingOrigin = minimock.CallerInfo(1)
	return mmIsKBUpdating.mock
}

// When sets expectation for the Repository.IsKBUpdating which will trigger the result defined by the following
// Then helper
func (mmIsKBUpdating *mRepositoryMockIsKBUpdating) When(ctx context.Context, kbUID types.KBUIDType) *RepositoryMockIsKBUpdatingExpectation {
	if mmIsKBUpdating.mock.funcIsKBUpdating != nil {
		mmIsKBUpdating.mock.t.Fatalf("RepositoryMock.IsKBUpdating mock is already set by Set")
	}

	expectation := &RepositoryMockIsKBUpdatingExpectation{
		mock:               mmIsKBUpdating.mock,
		params:             &RepositoryMockIsKBUpdatingParams{ctx, kbUID},
		expectationOrigins: RepositoryMockIsKBUpdatingExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIsKBUpdating.expectations = append(mmIsKBUpdating.expectations, expectation)
	return expectation
}

// Then sets up Repository.IsKBUpdating return parameters for the expectation previously defined by the When method
func (e *RepositoryMockIsKBUpdatingExpectation) Then(b1 bool, err error) *RepositoryMock {
	e.results = &RepositoryMockIsKBUpdatingResults{b1, err}
	return e.mock
}

// Times sets number of times Repository.IsKBUpdating should be invoked
func (mmIsKBUpdating *mRepositoryMockIsKBUpdating) Times(n uint64) *mRepositoryMockIsKBUpdating {
	if n == 0 {
		mmIsKBUpdating.mock.t.Fatalf("Times of RepositoryMock.IsKBUpdating mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsKBUpdating.expectedInvocations, n)
	mmIsKBUpdating.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsKBUpdating
}

func (mmIsKBUpdating *mRepositoryMockIsKBUpdating) invocationsDone() bool {
	if len(mmIsKBUpdating.expectations) == 0 && mmIsKBUpdating.defaultExpectation == nil && mmIsKBUpdating.mock.funcIsKBUpdating == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsKBUpdating.mock.afterIsKBUpdatingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsKBUpdating.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsKBUpdating implements mm_repository.Repository
func (mmIsKBUpdating *RepositoryMock) IsKBUpdating(ctx context.Context, kbUID types.KBUIDType) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmIsKBUpdating.beforeIsKBUpdatingCounter, 1)
	defer mm_atomic.AddUint64(&mmIsKBUpdating.afterIsKBUpdatingCounter, 1)

	mmIsKBUpdating.t.Helper()

	if mmIsKBUpdating.inspectFuncIsKBUpdating != nil {
		mmIsKBUpdating.inspectFuncIsKBUpdating(ctx, kbUID)
	}

	mm_params := RepositoryMockIsKBUpdatingParams{ctx, kbUID}

	// Record call args
	mmIsKBUpdating.IsKBUpdatingMock.mutex.Lock()
	mmIsKBUpdating.IsKBUpdatingMock.callArgs = append(mmIsKBUpdating.IsKBUpdatingMock.callArgs, &mm_params)
	mmIsKBUpdating.IsKBUpdatingMock.mutex.Unlock()

	for _, e := range mmIsKBUpdating.IsKBUpdatingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmIsKBUpdating.IsKBUpdatingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsKBUpdating.IsKBUpdatingMock.defaultExpectation.Counter, 1)
		mm_want := mmIsKBUpdating.IsKBUpdatingMock.defaultExpectation.params
		mm_want_ptrs := mmIsKBUpdating.IsKBUpdatingMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockIsKBUpdatingParams{ctx, kbUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmIsKBUpdating.t.Errorf("RepositoryMock.IsKBUpdating got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsKBUpdating.IsKBUpdatingMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmIsKBUpdating.t.Errorf("RepositoryMock.IsKBUpdating got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsKBUpdating.IsKBUpdatingMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsKBUpdating.t.Errorf("RepositoryMock.IsKBUpdating got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIsKBUpdating.IsKBUpdatingMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsKBUpdating.IsKBUpdatingMock.defaultExpectation.results
		if mm_results == nil {
			mmIsKBUpdating.t.Fatal("No results are set for the RepositoryMock.IsKBUpdating")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmIsKBUpdating.funcIsKBUpdating != nil {
		return mmIsKBUpdating.funcIsKBUpdating(ctx, kbUID)
	}
	mmIsKBUpdating.t.Fatalf("Unexpected call to RepositoryMock.IsKBUpdating. %v %v", ctx, kbUID)
	return
}

// IsKBUpdatingAfterCounter returns a count of finished RepositoryMock.IsKBUpdating invocations
func (mmIsKBUpdating *RepositoryMock) IsKBUpdatingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsKBUpdating.afterIsKBUpdatingCounter)
}

// IsKBUpdatingBeforeCounter returns a count of RepositoryMock.IsKBUpdating invocations
func (mmIsKBUpdating *RepositoryMock) IsKBUpdatingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsKBUpdating.beforeIsKBUpdatingCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.IsKBUpdating.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsKBUpdating *mRepositoryMockIsKBUpdating) Calls() []*RepositoryMockIsKBUpdatingParams {
	mmIsKBUpdating.mutex.RLock()

	argCopy := make([]*RepositoryMockIsKBUpdatingParams, len(mmIsKBUpdating.callArgs))
	copy(argCopy, mmIsKBUpdating.callArgs)

	mmIsKBUpdating.mutex.RUnlock()

	return argCopy
}

// MinimockIsKBUpdatingDone returns true if the count of the IsKBUpdating invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockIsKBUpdatingDone() bool {
	if m.IsKBUpdatingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsKBUpdatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsKBUpdatingMock.invocationsDone()
}

// MinimockIsKBUpdatingInspect logs each unmet expectation
func (m *RepositoryMock) MinimockIsKBUpdatingInspect() {
	for _, e := range m.IsKBUpdatingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.IsKBUpdating at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIsKBUpdatingCounter := mm_atomic.LoadUint64(&m.afterIsKBUpdatingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsKBUpdatingMock.defaultExpectation != nil && afterIsKBUpdatingCounter < 1 {
		if m.IsKBUpdatingMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.IsKBUpdating at\n%s", m.IsKBUpdatingMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.IsKBUpdating at\n%s with params: %#v", m.IsKBUpdatingMock.defaultExpectation.expectationOrigins.origin, *m.IsKBUpdatingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsKBUpdating != nil && afterIsKBUpdatingCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.IsKBUpdating at\n%s", m.funcIsKBUpdatingOrigin)
	}

	if !m.IsKBUpdatingMock.invocationsDone() && afterIsKBUpdatingCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.IsKBUpdating at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsKBUpdatingMock.expectedInvocations), m.IsKBUpdatingMock.expectedInvocationsOrigin, afterIsKBUpdatingCounter)
	}
}

type mRepositoryMockListAllKnowledgeBasesAdmin struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListAllKnowledgeBasesAdminExpectation
	expectations       []*RepositoryMockListAllKnowledgeBasesAdminExpectation

	callArgs []*RepositoryMockListAllKnowledgeBasesAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListAllKnowledgeBasesAdminExpectation specifies expectation struct of the Repository.ListAllKnowledgeBasesAdmin
type RepositoryMockListAllKnowledgeBasesAdminExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListAllKnowledgeBasesAdminParams
	paramPtrs          *RepositoryMockListAllKnowledgeBasesAdminParamPtrs
	expectationOrigins RepositoryMockListAllKnowledgeBasesAdminExpectationOrigins
	results            *RepositoryMockListAllKnowledgeBasesAdminResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListAllKnowledgeBasesAdminParams contains parameters of the Repository.ListAllKnowledgeBasesAdmin
type RepositoryMockListAllKnowledgeBasesAdminParams struct {
	ctx context.Context
}

// RepositoryMockListAllKnowledgeBasesAdminParamPtrs contains pointers to parameters of the Repository.ListAllKnowledgeBasesAdmin
type RepositoryMockListAllKnowledgeBasesAdminParamPtrs struct {
	ctx *context.Context
}

// RepositoryMockListAllKnowledgeBasesAdminResults contains results of the Repository.ListAllKnowledgeBasesAdmin
type RepositoryMockListAllKnowledgeBasesAdminResults struct {
	ka1 []mm_repository.KnowledgeBaseModel
	err error
}

// RepositoryMockListAllKnowledgeBasesAdminOrigins contains origins of expectations of the Repository.ListAllKnowledgeBasesAdmin
type RepositoryMockListAllKnowledgeBasesAdminExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListAllKnowledgeBasesAdmin *mRepositoryMockListAllKnowledgeBasesAdmin) Optional() *mRepositoryMockListAllKnowledgeBasesAdmin {
	mmListAllKnowledgeBasesAdmin.optional = true
	return mmListAllKnowledgeBasesAdmin
}

// Expect sets up expected params for Repository.ListAllKnowledgeBasesAdmin
func (mmListAllKnowledgeBasesAdmin *mRepositoryMockListAllKnowledgeBasesAdmin) Expect(ctx context.Context) *mRepositoryMockListAllKnowledgeBasesAdmin {
	if mmListAllKnowledgeBasesAdmin.mock.funcListAllKnowledgeBasesAdmin != nil {
		mmListAllKnowledgeBasesAdmin.mock.t.Fatalf("RepositoryMock.ListAllKnowledgeBasesAdmin mock is already set by Set")
	}

	if mmListAllKnowledgeBasesAdmin.defaultExpectation == nil {
		mmListAllKnowledgeBasesAdmin.defaultExpectation = &RepositoryMockListAllKnowledgeBasesAdminExpectation{}
	}

	if mmListAllKnowledgeBasesAdmin.defaultExpectation.paramPtrs != nil {
		mmListAllKnowledgeBasesAdmin.mock.t.Fatalf("RepositoryMock.ListAllKnowledgeBasesAdmin mock is already set by ExpectParams functions")
	}

	mmListAllKnowledgeBasesAdmin.defaultExpectation.params = &RepositoryMockListAllKnowledgeBasesAdminParams{ctx}
	mmListAllKnowledgeBasesAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListAllKnowledgeBasesAdmin.expectations {
		if minimock.Equal(e.params, mmListAllKnowledgeBasesAdmin.defaultExpectation.params) {
			mmListAllKnowledgeBasesAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListAllKnowledgeBasesAdmin.defaultExpectation.params)
		}
	}

	return mmListAllKnowledgeBasesAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListAllKnowledgeBasesAdmin
func (mmListAllKnowledgeBasesAdmin *mRepositoryMockListAllKnowledgeBasesAdmin) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListAllKnowledgeBasesAdmin {
	if mmListAllKnowledgeBasesAdmin.mock.funcListAllKnowledgeBasesAdmin != nil {
		mmListAllKnowledgeBasesAdmin.mock.t.Fatalf("RepositoryMock.ListAllKnowledgeBasesAdmin mock is already set by Set")
	}

	if mmListAllKnowledgeBasesAdmin.defaultExpectation == nil {
		mmListAllKnowledgeBasesAdmin.defaultExpectation = &RepositoryMockListAllKnowledgeBasesAdminExpectation{}
	}

	if mmListAllKnowledgeBasesAdmin.defaultExpectation.params != nil {
		mmListAllKnowledgeBasesAdmin.mock.t.Fatalf("RepositoryMock.ListAllKnowledgeBasesAdmin mock is already set by Expect")
	}

	if mmListAllKnowledgeBasesAdmin.defaultExpectation.paramPtrs == nil {
		mmListAllKnowledgeBasesAdmin.defaultExpectation.paramPtrs = &RepositoryMockListAllKnowledgeBasesAdminParamPtrs{}
	}
	mmListAllKnowledgeBasesAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmListAllKnowledgeBasesAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListAllKnowledgeBasesAdmin
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListAllKnowledgeBasesAdmin
func (mmListAllKnowledgeBasesAdmin *mRepositoryMockListAllKnowledgeBasesAdmin) Inspect(f func(ctx context.Context)) *mRepositoryMockListAllKnowledgeBasesAdmin {
	if mmListAllKnowledgeBasesAdmin.mock.inspectFuncListAllKnowledgeBasesAdmin != nil {
		mmListAllKnowledgeBasesAdmin.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListAllKnowledgeBasesAdmin")
	}

	mmListAllKnowledgeBasesAdmin.mock.inspectFuncListAllKnowledgeBasesAdmin = f

	return mmListAllKnowledgeBasesAdmin
}

// Return sets up results that will be returned by Repository.ListAllKnowledgeBasesAdmin
func (mmListAllKnowledgeBasesAdmin *mRepositoryMockListAllKnowledgeBasesAdmin) Return(ka1 []mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	if mmListAllKnowledgeBasesAdmin.mock.funcListAllKnowledgeBasesAdmin != nil {
		mmListAllKnowledgeBasesAdmin.mock.t.Fatalf("RepositoryMock.ListAllKnowledgeBasesAdmin mock is already set by Set")
	}

	if mmListAllKnowledgeBasesAdmin.defaultExpectation == nil {
		mmListAllKnowledgeBasesAdmin.defaultExpectation = &RepositoryMockListAllKnowledgeBasesAdminExpectation{mock: mmListAllKnowledgeBasesAdmin.mock}
	}
	mmListAllKnowledgeBasesAdmin.defaultExpectation.results = &RepositoryMockListAllKnowledgeBasesAdminResults{ka1, err}
	mmListAllKnowledgeBasesAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListAllKnowledgeBasesAdmin.mock
}

// Set uses given function f to mock the Repository.ListAllKnowledgeBasesAdmin method
func (mmListAllKnowledgeBasesAdmin *mRepositoryMockListAllKnowledgeBasesAdmin) Set(f func(ctx context.Context) (ka1 []mm_repository.KnowledgeBaseModel, err error)) *RepositoryMock {
	if mmListAllKnowledgeBasesAdmin.defaultExpectation != nil {
		mmListAllKnowledgeBasesAdmin.mock.t.Fatalf("Default expectation is already set for the Repository.ListAllKnowledgeBasesAdmin method")
	}

	if len(mmListAllKnowledgeBasesAdmin.expectations) > 0 {
		mmListAllKnowledgeBasesAdmin.mock.t.Fatalf("Some expectations are already set for the Repository.ListAllKnowledgeBasesAdmin method")
	}

	mmListAllKnowledgeBasesAdmin.mock.funcListAllKnowledgeBasesAdmin = f
	mmListAllKnowledgeBasesAdmin.mock.funcListAllKnowledgeBasesAdminOrigin = minimock.CallerInfo(1)
	return mmListAllKnowledgeBasesAdmin.mock
}

// When sets expectation for the Repository.ListAllKnowledgeBasesAdmin which will trigger the result defined by the following
// Then helper
func (mmListAllKnowledgeBasesAdmin *mRepositoryMockListAllKnowledgeBasesAdmin) When(ctx context.Context) *RepositoryMockListAllKnowledgeBasesAdminExpectation {
	if mmListAllKnowledgeBasesAdmin.mock.funcListAllKnowledgeBasesAdmin != nil {
		mmListAllKnowledgeBasesAdmin.mock.t.Fatalf("RepositoryMock.ListAllKnowledgeBasesAdmin mock is already set by Set")
	}

	expectation := &RepositoryMockListAllKnowledgeBasesAdminExpectation{
		mock:               mmListAllKnowledgeBasesAdmin.mock,
		params:             &RepositoryMockListAllKnowledgeBasesAdminParams{ctx},
		expectationOrigins: RepositoryMockListAllKnowledgeBasesAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListAllKnowledgeBasesAdmin.expectations = append(mmListAllKnowledgeBasesAdmin.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListAllKnowledgeBasesAdmin return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListAllKnowledgeBasesAdminExpectation) Then(ka1 []mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	e.results = &RepositoryMockListAllKnowledgeBasesAdminResults{ka1, err}
	return e.mock
}

// Times sets number of times Repository.ListAllKnowledgeBasesAdmin should be invoked
func (mmListAllKnowledgeBasesAdmin *mRepositoryMockListAllKnowledgeBasesAdmin) Times(n uint64) *mRepositoryMockListAllKnowledgeBasesAdmin {
	if n == 0 {
		mmListAllKnowledgeBasesAdmin.mock.t.Fatalf("Times of RepositoryMock.ListAllKnowledgeBasesAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListAllKnowledgeBasesAdmin.expectedInvocations, n)
	mmListAllKnowledgeBasesAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListAllKnowledgeBasesAdmin
}

func (mmListAllKnowledgeBasesAdmin *mRepositoryMockListAllKnowledgeBasesAdmin) invocationsDone() bool {
	if len(mmListAllKnowledgeBasesAdmin.expectations) == 0 && mmListAllKnowledgeBasesAdmin.defaultExpectation == nil && mmListAllKnowledgeBasesAdmin.mock.funcListAllKnowledgeBasesAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListAllKnowledgeBasesAdmin.mock.afterListAllKnowledgeBasesAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListAllKnowledgeBasesAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListAllKnowledgeBasesAdmin implements mm_repository.Repository
func (mmListAllKnowledgeBasesAdmin *RepositoryMock) ListAllKnowledgeBasesAdmin(ctx context.Context) (ka1 []mm_repository.KnowledgeBaseModel, err error) {
	mm_atomic.AddUint64(&mmListAllKnowledgeBasesAdmin.beforeListAllKnowledgeBasesAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmListAllKnowledgeBasesAdmin.afterListAllKnowledgeBasesAdminCounter, 1)

	mmListAllKnowledgeBasesAdmin.t.Helper()

	if mmListAllKnowledgeBasesAdmin.inspectFuncListAllKnowledgeBasesAdmin != nil {
		mmListAllKnowledgeBasesAdmin.inspectFuncListAllKnowledgeBasesAdmin(ctx)
	}

	mm_params := RepositoryMockListAllKnowledgeBasesAdminParams{ctx}

	// Record call args
	mmListAllKnowledgeBasesAdmin.ListAllKnowledgeBasesAdminMock.mutex.Lock()
	mmListAllKnowledgeBasesAdmin.ListAllKnowledgeBasesAdminMock.callArgs = append(mmListAllKnowledgeBasesAdmin.ListAllKnowledgeBasesAdminMock.callArgs, &mm_params)
	mmListAllKnowledgeBasesAdmin.ListAllKnowledgeBasesAdminMock.mutex.Unlock()

	for _, e := range mmListAllKnowledgeBasesAdmin.ListAllKnowledgeBasesAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmListAllKnowledgeBasesAdmin.ListAllKnowledgeBasesAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListAllKnowledgeBasesAdmin.ListAllKnowledgeBasesAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmListAllKnowledgeBasesAdmin.ListAllKnowledgeBasesAdminMock.defaultExpectation.params
		mm_want_ptrs := mmListAllKnowledgeBasesAdmin.ListAllKnowledgeBasesAdminMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListAllKnowledgeBasesAdminParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListAllKnowledgeBasesAdmin.t.Errorf("RepositoryMock.ListAllKnowledgeBasesAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListAllKnowledgeBasesAdmin.ListAllKnowledgeBasesAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListAllKnowledgeBasesAdmin.t.Errorf("RepositoryMock.ListAllKnowledgeBasesAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListAllKnowledgeBasesAdmin.ListAllKnowledgeBasesAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListAllKnowledgeBasesAdmin.ListAllKnowledgeBasesAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmListAllKnowledgeBasesAdmin.t.Fatal("No results are set for the RepositoryMock.ListAllKnowledgeBasesAdmin")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmListAllKnowledgeBasesAdmin.funcListAllKnowledgeBasesAdmin != nil {
		return mmListAllKnowledgeBasesAdmin.funcListAllKnowledgeBasesAdmin(ctx)
	}
	mmListAllKnowledgeBasesAdmin.t.Fatalf("Unexpected call to RepositoryMock.ListAllKnowledgeBasesAdmin. %v", ctx)
	return
}

// ListAllKnowledgeBasesAdminAfterCounter returns a count of finished RepositoryMock.ListAllKnowledgeBasesAdmin invocations
func (mmListAllKnowledgeBasesAdmin *RepositoryMock) ListAllKnowledgeBasesAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAllKnowledgeBasesAdmin.afterListAllKnowledgeBasesAdminCounter)
}

// ListAllKnowledgeBasesAdminBeforeCounter returns a count of RepositoryMock.ListAllKnowledgeBasesAdmin invocations
func (mmListAllKnowledgeBasesAdmin *RepositoryMock) ListAllKnowledgeBasesAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAllKnowledgeBasesAdmin.beforeListAllKnowledgeBasesAdminCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListAllKnowledgeBasesAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListAllKnowledgeBasesAdmin *mRepositoryMockListAllKnowledgeBasesAdmin) Calls() []*RepositoryMockListAllKnowledgeBasesAdminParams {
	mmListAllKnowledgeBasesAdmin.mutex.RLock()

	argCopy := make([]*RepositoryMockListAllKnowledgeBasesAdminParams, len(mmListAllKnowledgeBasesAdmin.callArgs))
	copy(argCopy, mmListAllKnowledgeBasesAdmin.callArgs)

	mmListAllKnowledgeBasesAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockListAllKnowledgeBasesAdminDone returns true if the count of the ListAllKnowledgeBasesAdmin invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListAllKnowledgeBasesAdminDone() bool {
	if m.ListAllKnowledgeBasesAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListAllKnowledgeBasesAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListAllKnowledgeBasesAdminMock.invocationsDone()
}

// MinimockListAllKnowledgeBasesAdminInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListAllKnowledgeBasesAdminInspect() {
	for _, e := range m.ListAllKnowledgeBasesAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListAllKnowledgeBasesAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListAllKnowledgeBasesAdminCounter := mm_atomic.LoadUint64(&m.afterListAllKnowledgeBasesAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListAllKnowledgeBasesAdminMock.defaultExpectation != nil && afterListAllKnowledgeBasesAdminCounter < 1 {
		if m.ListAllKnowledgeBasesAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListAllKnowledgeBasesAdmin at\n%s", m.ListAllKnowledgeBasesAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListAllKnowledgeBasesAdmin at\n%s with params: %#v", m.ListAllKnowledgeBasesAdminMock.defaultExpectation.expectationOrigins.origin, *m.ListAllKnowledgeBasesAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListAllKnowledgeBasesAdmin != nil && afterListAllKnowledgeBasesAdminCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListAllKnowledgeBasesAdmin at\n%s", m.funcListAllKnowledgeBasesAdminOrigin)
	}

	if !m.ListAllKnowledgeBasesAdminMock.invocationsDone() && afterListAllKnowledgeBasesAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListAllKnowledgeBasesAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListAllKnowledgeBasesAdminMock.expectedInvocations), m.ListAllKnowledgeBasesAdminMock.expectedInvocationsOrigin, afterListAllKnowledgeBasesAdminCounter)
	}
}

type mRepositoryMockListAllObjects struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListAllObjectsExpectation
	expectations       []*RepositoryMockListAllObjectsExpectation

	callArgs []*RepositoryMockListAllObjectsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListAllObjectsExpectation specifies expectation struct of the Repository.ListAllObjects
type RepositoryMockListAllObjectsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListAllObjectsParams
	paramPtrs          *RepositoryMockListAllObjectsParamPtrs
	expectationOrigins RepositoryMockListAllObjectsExpectationOrigins
	results            *RepositoryMockListAllObjectsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListAllObjectsParams contains parameters of the Repository.ListAllObjects
type RepositoryMockListAllObjectsParams struct {
	ctx          context.Context
	namespaceUID types.NamespaceUIDType
	creatorUID   types.CreatorUIDType
}

// RepositoryMockListAllObjectsParamPtrs contains pointers to parameters of the Repository.ListAllObjects
type RepositoryMockListAllObjectsParamPtrs struct {
	ctx          *context.Context
	namespaceUID *types.NamespaceUIDType
	creatorUID   *types.CreatorUIDType
}

// RepositoryMockListAllObjectsResults contains results of the Repository.ListAllObjects
type RepositoryMockListAllObjectsResults struct {
	oa1 []mm_repository.ObjectModel
	err error
}

// RepositoryMockListAllObjectsOrigins contains origins of expectations of the Repository.ListAllObjects
type RepositoryMockListAllObjectsExpectationOrigins struct {
	origin             string
	originCtx          string
	originNamespaceUID string
	originCreatorUID   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListAllObjects *mRepositoryMockListAllObjects) Optional() *mRepositoryMockListAllObjects {
	mmListAllObjects.optional = true
	return mmListAllObjects
}

// Expect sets up expected params for Repository.ListAllObjects
func (mmListAllObjects *mRepositoryMockListAllObjects) Expect(ctx context.Context, namespaceUID types.NamespaceUIDType, creatorUID types.CreatorUIDType) *mRepositoryMockListAllObjects {
	if mmListAllObjects.mock.funcListAllObjects != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryMock.ListAllObjects mock is already set by Set")
	}

	if mmListAllObjects.defaultExpectation == nil {
		mmListAllObjects.defaultExpectation = &RepositoryMockListAllObjectsExpectation{}
	}

	if mmListAllObjects.defaultExpectation.paramPtrs != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryMock.ListAllObjects mock is already set by ExpectParams functions")
	}

	mmListAllObjects.defaultExpectation.params = &RepositoryMockListAllObjectsParams{ctx, namespaceUID, creatorUID}
	mmListAllObjects.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListAllObjects.expectations {
		if minimock.Equal(e.params, mmListAllObjects.defaultExpectation.params) {
			mmListAllObjects.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListAllObjects.defaultExpectation.params)
		}
	}

	return mmListAllObjects
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListAllObjects
func (mmListAllObjects *mRepositoryMockListAllObjects) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListAllObjects {
	if mmListAllObjects.mock.funcListAllObjects != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryMock.ListAllObjects mock is already set by Set")
	}

	if mmListAllObjects.defaultExpectation == nil {
		mmListAllObjects.defaultExpectation = &RepositoryMockListAllObjectsExpectation{}
	}

	if mmListAllObjects.defaultExpectation.params != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryMock.ListAllObjects mock is already set by Expect")
	}

	if mmListAllObjects.defaultExpectation.paramPtrs == nil {
		mmListAllObjects.defaultExpectation.paramPtrs = &RepositoryMockListAllObjectsParamPtrs{}
	}
	mmListAllObjects.defaultExpectation.paramPtrs.ctx = &ctx
	mmListAllObjects.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListAllObjects
}

// ExpectNamespaceUIDParam2 sets up expected param namespaceUID for Repository.ListAllObjects
func (mmListAllObjects *mRepositoryMockListAllObjects) ExpectNamespaceUIDParam2(namespaceUID types.NamespaceUIDType) *mRepositoryMockListAllObjects {
	if mmListAllObjects.mock.funcListAllObjects != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryMock.ListAllObjects mock is already set by Set")
	}

	if mmListAllObjects.defaultExpectation == nil {
		mmListAllObjects.defaultExpectation = &RepositoryMockListAllObjectsExpectation{}
	}

	if mmListAllObjects.defaultExpectation.params != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryMock.ListAllObjects mock is already set by Expect")
	}

	if mmListAllObjects.defaultExpectation.paramPtrs == nil {
		mmListAllObjects.defaultExpectation.paramPtrs = &RepositoryMockListAllObjectsParamPtrs{}
	}
	mmListAllObjects.defaultExpectation.paramPtrs.namespaceUID = &namespaceUID
	mmListAllObjects.defaultExpectation.expectationOrigins.originNamespaceUID = minimock.CallerInfo(1)

	return mmListAllObjects
}

// ExpectCreatorUIDParam3 sets up expected param creatorUID for Repository.ListAllObjects
func (mmListAllObjects *mRepositoryMockListAllObjects) ExpectCreatorUIDParam3(creatorUID types.CreatorUIDType) *mRepositoryMockListAllObjects {
	if mmListAllObjects.mock.funcListAllObjects != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryMock.ListAllObjects mock is already set by Set")
	}

	if mmListAllObjects.defaultExpectation == nil {
		mmListAllObjects.defaultExpectation = &RepositoryMockListAllObjectsExpectation{}
	}

	if mmListAllObjects.defaultExpectation.params != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryMock.ListAllObjects mock is already set by Expect")
	}

	if mmListAllObjects.defaultExpectation.paramPtrs == nil {
		mmListAllObjects.defaultExpectation.paramPtrs = &RepositoryMockListAllObjectsParamPtrs{}
	}
	mmListAllObjects.defaultExpectation.paramPtrs.creatorUID = &creatorUID
	mmListAllObjects.defaultExpectation.expectationOrigins.originCreatorUID = minimock.CallerInfo(1)

	return mmListAllObjects
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListAllObjects
func (mmListAllObjects *mRepositoryMockListAllObjects) Inspect(f func(ctx context.Context, namespaceUID types.NamespaceUIDType, creatorUID types.CreatorUIDType)) *mRepositoryMockListAllObjects {
	if mmListAllObjects.mock.inspectFuncListAllObjects != nil {
		mmListAllObjects.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListAllObjects")
	}

	mmListAllObjects.mock.inspectFuncListAllObjects = f

	return mmListAllObjects
}

// Return sets up results that will be returned by Repository.ListAllObjects
func (mmListAllObjects *mRepositoryMockListAllObjects) Return(oa1 []mm_repository.ObjectModel, err error) *RepositoryMock {
	if mmListAllObjects.mock.funcListAllObjects != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryMock.ListAllObjects mock is already set by Set")
	}

	if mmListAllObjects.defaultExpectation == nil {
		mmListAllObjects.defaultExpectation = &RepositoryMockListAllObjectsExpectation{mock: mmListAllObjects.mock}
	}
	mmListAllObjects.defaultExpectation.results = &RepositoryMockListAllObjectsResults{oa1, err}
	mmListAllObjects.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListAllObjects.mock
}

// Set uses given function f to mock the Repository.ListAllObjects method
func (mmListAllObjects *mRepositoryMockListAllObjects) Set(f func(ctx context.Context, namespaceUID types.NamespaceUIDType, creatorUID types.CreatorUIDType) (oa1 []mm_repository.ObjectModel, err error)) *RepositoryMock {
	if mmListAllObjects.defaultExpectation != nil {
		mmListAllObjects.mock.t.Fatalf("Default expectation is already set for the Repository.ListAllObjects method")
	}

	if len(mmListAllObjects.expectations) > 0 {
		mmListAllObjects.mock.t.Fatalf("Some expectations are already set for the Repository.ListAllObjects method")
	}

	mmListAllObjects.mock.funcListAllObjects = f
	mmListAllObjects.mock.funcListAllObjectsOrigin = minimock.CallerInfo(1)
	return mmListAllObjects.mock
}

// When sets expectation for the Repository.ListAllObjects which will trigger the result defined by the following
// Then helper
func (mmListAllObjects *mRepositoryMockListAllObjects) When(ctx context.Context, namespaceUID types.NamespaceUIDType, creatorUID types.CreatorUIDType) *RepositoryMockListAllObjectsExpectation {
	if mmListAllObjects.mock.funcListAllObjects != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryMock.ListAllObjects mock is already set by Set")
	}

	expectation := &RepositoryMockListAllObjectsExpectation{
		mock:               mmListAllObjects.mock,
		params:             &RepositoryMockListAllObjectsParams{ctx, namespaceUID, creatorUID},
		expectationOrigins: RepositoryMockListAllObjectsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListAllObjects.expectations = append(mmListAllObjects.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListAllObjects return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListAllObjectsExpectation) Then(oa1 []mm_repository.ObjectModel, err error) *RepositoryMock {
	e.results = &RepositoryMockListAllObjectsResults{oa1, err}
	return e.mock
}

// Times sets number of times Repository.ListAllObjects should be invoked
func (mmListAllObjects *mRepositoryMockListAllObjects) Times(n uint64) *mRepositoryMockListAllObjects {
	if n == 0 {
		mmListAllObjects.mock.t.Fatalf("Times of RepositoryMock.ListAllObjects mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListAllObjects.expectedInvocations, n)
	mmListAllObjects.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListAllObjects
}

func (mmListAllObjects *mRepositoryMockListAllObjects) invocationsDone() bool {
	if len(mmListAllObjects.expectations) == 0 && mmListAllObjects.defaultExpectation == nil && mmListAllObjects.mock.funcListAllObjects == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListAllObjects.mock.afterListAllObjectsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListAllObjects.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListAllObjects implements mm_repository.Repository
func (mmListAllObjects *RepositoryMock) ListAllObjects(ctx context.Context, namespaceUID types.NamespaceUIDType, creatorUID types.CreatorUIDType) (oa1 []mm_repository.ObjectModel, err error) {
	mm_atomic.AddUint64(&mmListAllObjects.beforeListAllObjectsCounter, 1)
	defer mm_atomic.AddUint64(&mmListAllObjects.afterListAllObjectsCounter, 1)

	mmListAllObjects.t.Helper()

	if mmListAllObjects.inspectFuncListAllObjects != nil {
		mmListAllObjects.inspectFuncListAllObjects(ctx, namespaceUID, creatorUID)
	}

	mm_params := RepositoryMockListAllObjectsParams{ctx, namespaceUID, creatorUID}

	// Record call args
	mmListAllObjects.ListAllObjectsMock.mutex.Lock()
	mmListAllObjects.ListAllObjectsMock.callArgs = append(mmListAllObjects.ListAllObjectsMock.callArgs, &mm_params)
	mmListAllObjects.ListAllObjectsMock.mutex.Unlock()

	for _, e := range mmListAllObjects.ListAllObjectsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmListAllObjects.ListAllObjectsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListAllObjects.ListAllObjectsMock.defaultExpectation.Counter, 1)
		mm_want := mmListAllObjects.ListAllObjectsMock.defaultExpectation.params
		mm_want_ptrs := mmListAllObjects.ListAllObjectsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListAllObjectsParams{ctx, namespaceUID, creatorUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListAllObjects.t.Errorf("RepositoryMock.ListAllObjects got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListAllObjects.ListAllObjectsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.namespaceUID != nil && !minimock.Equal(*mm_want_ptrs.namespaceUID, mm_got.namespaceUID) {
				mmListAllObjects.t.Errorf("RepositoryMock.ListAllObjects got unexpected parameter namespaceUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListAllObjects.ListAllObjectsMock.defaultExpectation.expectationOrigins.originNamespaceUID, *mm_want_ptrs.namespaceUID, mm_got.namespaceUID, minimock.Diff(*mm_want_ptrs.namespaceUID, mm_got.namespaceUID))
			}

			if mm_want_ptrs.creatorUID != nil && !minimock.Equal(*mm_want_ptrs.creatorUID, mm_got.creatorUID) {
				mmListAllObjects.t.Errorf("RepositoryMock.ListAllObjects got unexpected parameter creatorUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListAllObjects.ListAllObjectsMock.defaultExpectation.expectationOrigins.originCreatorUID, *mm_want_ptrs.creatorUID, mm_got.creatorUID, minimock.Diff(*mm_want_ptrs.creatorUID, mm_got.creatorUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListAllObjects.t.Errorf("RepositoryMock.ListAllObjects got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListAllObjects.ListAllObjectsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListAllObjects.ListAllObjectsMock.defaultExpectation.results
		if mm_results == nil {
			mmListAllObjects.t.Fatal("No results are set for the RepositoryMock.ListAllObjects")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmListAllObjects.funcListAllObjects != nil {
		return mmListAllObjects.funcListAllObjects(ctx, namespaceUID, creatorUID)
	}
	mmListAllObjects.t.Fatalf("Unexpected call to RepositoryMock.ListAllObjects. %v %v %v", ctx, namespaceUID, creatorUID)
	return
}

// ListAllObjectsAfterCounter returns a count of finished RepositoryMock.ListAllObjects invocations
func (mmListAllObjects *RepositoryMock) ListAllObjectsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAllObjects.afterListAllObjectsCounter)
}

// ListAllObjectsBeforeCounter returns a count of RepositoryMock.ListAllObjects invocations
func (mmListAllObjects *RepositoryMock) ListAllObjectsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAllObjects.beforeListAllObjectsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListAllObjects.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListAllObjects *mRepositoryMockListAllObjects) Calls() []*RepositoryMockListAllObjectsParams {
	mmListAllObjects.mutex.RLock()

	argCopy := make([]*RepositoryMockListAllObjectsParams, len(mmListAllObjects.callArgs))
	copy(argCopy, mmListAllObjects.callArgs)

	mmListAllObjects.mutex.RUnlock()

	return argCopy
}

// MinimockListAllObjectsDone returns true if the count of the ListAllObjects invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListAllObjectsDone() bool {
	if m.ListAllObjectsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListAllObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListAllObjectsMock.invocationsDone()
}

// MinimockListAllObjectsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListAllObjectsInspect() {
	for _, e := range m.ListAllObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListAllObjects at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListAllObjectsCounter := mm_atomic.LoadUint64(&m.afterListAllObjectsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListAllObjectsMock.defaultExpectation != nil && afterListAllObjectsCounter < 1 {
		if m.ListAllObjectsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListAllObjects at\n%s", m.ListAllObjectsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListAllObjects at\n%s with params: %#v", m.ListAllObjectsMock.defaultExpectation.expectationOrigins.origin, *m.ListAllObjectsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListAllObjects != nil && afterListAllObjectsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListAllObjects at\n%s", m.funcListAllObjectsOrigin)
	}

	if !m.ListAllObjectsMock.invocationsDone() && afterListAllObjectsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListAllObjects at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListAllObjectsMock.expectedInvocations), m.ListAllObjectsMock.expectedInvocationsOrigin, afterListAllObjectsCounter)
	}
}

type mRepositoryMockListEmbeddingsByKBFileUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListEmbeddingsByKBFileUIDExpectation
	expectations       []*RepositoryMockListEmbeddingsByKBFileUIDExpectation

	callArgs []*RepositoryMockListEmbeddingsByKBFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListEmbeddingsByKBFileUIDExpectation specifies expectation struct of the Repository.ListEmbeddingsByKBFileUID
type RepositoryMockListEmbeddingsByKBFileUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListEmbeddingsByKBFileUIDParams
	paramPtrs          *RepositoryMockListEmbeddingsByKBFileUIDParamPtrs
	expectationOrigins RepositoryMockListEmbeddingsByKBFileUIDExpectationOrigins
	results            *RepositoryMockListEmbeddingsByKBFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListEmbeddingsByKBFileUIDParams contains parameters of the Repository.ListEmbeddingsByKBFileUID
type RepositoryMockListEmbeddingsByKBFileUIDParams struct {
	ctx       context.Context
	kbFileUID types.FileUIDType
}

// RepositoryMockListEmbeddingsByKBFileUIDParamPtrs contains pointers to parameters of the Repository.ListEmbeddingsByKBFileUID
type RepositoryMockListEmbeddingsByKBFileUIDParamPtrs struct {
	ctx       *context.Context
	kbFileUID *types.FileUIDType
}

// RepositoryMockListEmbeddingsByKBFileUIDResults contains results of the Repository.ListEmbeddingsByKBFileUID
type RepositoryMockListEmbeddingsByKBFileUIDResults struct {
	ea1 []mm_repository.EmbeddingModel
	err error
}

// RepositoryMockListEmbeddingsByKBFileUIDOrigins contains origins of expectations of the Repository.ListEmbeddingsByKBFileUID
type RepositoryMockListEmbeddingsByKBFileUIDExpectationOrigins struct {
	origin          string
	originCtx       string
	originKbFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListEmbeddingsByKBFileUID *mRepositoryMockListEmbeddingsByKBFileUID) Optional() *mRepositoryMockListEmbeddingsByKBFileUID {
	mmListEmbeddingsByKBFileUID.optional = true
	return mmListEmbeddingsByKBFileUID
}

// Expect sets up expected params for Repository.ListEmbeddingsByKBFileUID
func (mmListEmbeddingsByKBFileUID *mRepositoryMockListEmbeddingsByKBFileUID) Expect(ctx context.Context, kbFileUID types.FileUIDType) *mRepositoryMockListEmbeddingsByKBFileUID {
	if mmListEmbeddingsByKBFileUID.mock.funcListEmbeddingsByKBFileUID != nil {
		mmListEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.ListEmbeddingsByKBFileUID mock is already set by Set")
	}

	if mmListEmbeddingsByKBFileUID.defaultExpectation == nil {
		mmListEmbeddingsByKBFileUID.defaultExpectation = &RepositoryMockListEmbeddingsByKBFileUIDExpectation{}
	}

	if mmListEmbeddingsByKBFileUID.defaultExpectation.paramPtrs != nil {
		mmListEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.ListEmbeddingsByKBFileUID mock is already set by ExpectParams functions")
	}

	mmListEmbeddingsByKBFileUID.defaultExpectation.params = &RepositoryMockListEmbeddingsByKBFileUIDParams{ctx, kbFileUID}
	mmListEmbeddingsByKBFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListEmbeddingsByKBFileUID.expectations {
		if minimock.Equal(e.params, mmListEmbeddingsByKBFileUID.defaultExpectation.params) {
			mmListEmbeddingsByKBFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListEmbeddingsByKBFileUID.defaultExpectation.params)
		}
	}

	return mmListEmbeddingsByKBFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListEmbeddingsByKBFileUID
func (mmListEmbeddingsByKBFileUID *mRepositoryMockListEmbeddingsByKBFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListEmbeddingsByKBFileUID {
	if mmListEmbeddingsByKBFileUID.mock.funcListEmbeddingsByKBFileUID != nil {
		mmListEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.ListEmbeddingsByKBFileUID mock is already set by Set")
	}

	if mmListEmbeddingsByKBFileUID.defaultExpectation == nil {
		mmListEmbeddingsByKBFileUID.defaultExpectation = &RepositoryMockListEmbeddingsByKBFileUIDExpectation{}
	}

	if mmListEmbeddingsByKBFileUID.defaultExpectation.params != nil {
		mmListEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.ListEmbeddingsByKBFileUID mock is already set by Expect")
	}

	if mmListEmbeddingsByKBFileUID.defaultExpectation.paramPtrs == nil {
		mmListEmbeddingsByKBFileUID.defaultExpectation.paramPtrs = &RepositoryMockListEmbeddingsByKBFileUIDParamPtrs{}
	}
	mmListEmbeddingsByKBFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmListEmbeddingsByKBFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListEmbeddingsByKBFileUID
}

// ExpectKbFileUIDParam2 sets up expected param kbFileUID for Repository.ListEmbeddingsByKBFileUID
func (mmListEmbeddingsByKBFileUID *mRepositoryMockListEmbeddingsByKBFileUID) ExpectKbFileUIDParam2(kbFileUID types.FileUIDType) *mRepositoryMockListEmbeddingsByKBFileUID {
	if mmListEmbeddingsByKBFileUID.mock.funcListEmbeddingsByKBFileUID != nil {
		mmListEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.ListEmbeddingsByKBFileUID mock is already set by Set")
	}

	if mmListEmbeddingsByKBFileUID.defaultExpectation == nil {
		mmListEmbeddingsByKBFileUID.defaultExpectation = &RepositoryMockListEmbeddingsByKBFileUIDExpectation{}
	}

	if mmListEmbeddingsByKBFileUID.defaultExpectation.params != nil {
		mmListEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.ListEmbeddingsByKBFileUID mock is already set by Expect")
	}

	if mmListEmbeddingsByKBFileUID.defaultExpectation.paramPtrs == nil {
		mmListEmbeddingsByKBFileUID.defaultExpectation.paramPtrs = &RepositoryMockListEmbeddingsByKBFileUIDParamPtrs{}
	}
	mmListEmbeddingsByKBFileUID.defaultExpectation.paramPtrs.kbFileUID = &kbFileUID
	mmListEmbeddingsByKBFileUID.defaultExpectation.expectationOrigins.originKbFileUID = minimock.CallerInfo(1)

	return mmListEmbeddingsByKBFileUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListEmbeddingsByKBFileUID
func (mmListEmbeddingsByKBFileUID *mRepositoryMockListEmbeddingsByKBFileUID) Inspect(f func(ctx context.Context, kbFileUID types.FileUIDType)) *mRepositoryMockListEmbeddingsByKBFileUID {
	if mmListEmbeddingsByKBFileUID.mock.inspectFuncListEmbeddingsByKBFileUID != nil {
		mmListEmbeddingsByKBFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListEmbeddingsByKBFileUID")
	}

	mmListEmbeddingsByKBFileUID.mock.inspectFuncListEmbeddingsByKBFileUID = f

	return mmListEmbeddingsByKBFileUID
}

// Return sets up results that will be returned by Repository.ListEmbeddingsByKBFileUID
func (mmListEmbeddingsByKBFileUID *mRepositoryMockListEmbeddingsByKBFileUID) Return(ea1 []mm_repository.EmbeddingModel, err error) *RepositoryMock {
	if mmListEmbeddingsByKBFileUID.mock.funcListEmbeddingsByKBFileUID != nil {
		mmListEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.ListEmbeddingsByKBFileUID mock is already set by Set")
	}

	if mmListEmbeddingsByKBFileUID.defaultExpectation == nil {
		mmListEmbeddingsByKBFileUID.defaultExpectation = &RepositoryMockListEmbeddingsByKBFileUIDExpectation{mock: mmListEmbeddingsByKBFileUID.mock}
	}
	mmListEmbeddingsByKBFileUID.defaultExpectation.results = &RepositoryMockListEmbeddingsByKBFileUIDResults{ea1, err}
	mmListEmbeddingsByKBFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListEmbeddingsByKBFileUID.mock
}

// Set uses given function f to mock the Repository.ListEmbeddingsByKBFileUID method
func (mmListEmbeddingsByKBFileUID *mRepositoryMockListEmbeddingsByKBFileUID) Set(f func(ctx context.Context, kbFileUID types.FileUIDType) (ea1 []mm_repository.EmbeddingModel, err error)) *RepositoryMock {
	if mmListEmbeddingsByKBFileUID.defaultExpectation != nil {
		mmListEmbeddingsByKBFileUID.mock.t.Fatalf("Default expectation is already set for the Repository.ListEmbeddingsByKBFileUID method")
	}

	if len(mmListEmbeddingsByKBFileUID.expectations) > 0 {
		mmListEmbeddingsByKBFileUID.mock.t.Fatalf("Some expectations are already set for the Repository.ListEmbeddingsByKBFileUID method")
	}

	mmListEmbeddingsByKBFileUID.mock.funcListEmbeddingsByKBFileUID = f
	mmListEmbeddingsByKBFileUID.mock.funcListEmbeddingsByKBFileUIDOrigin = minimock.CallerInfo(1)
	return mmListEmbeddingsByKBFileUID.mock
}

// When sets expectation for the Repository.ListEmbeddingsByKBFileUID which will trigger the result defined by the following
// Then helper
func (mmListEmbeddingsByKBFileUID *mRepositoryMockListEmbeddingsByKBFileUID) When(ctx context.Context, kbFileUID types.FileUIDType) *RepositoryMockListEmbeddingsByKBFileUIDExpectation {
	if mmListEmbeddingsByKBFileUID.mock.funcListEmbeddingsByKBFileUID != nil {
		mmListEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.ListEmbeddingsByKBFileUID mock is already set by Set")
	}

	expectation := &RepositoryMockListEmbeddingsByKBFileUIDExpectation{
		mock:               mmListEmbeddingsByKBFileUID.mock,
		params:             &RepositoryMockListEmbeddingsByKBFileUIDParams{ctx, kbFileUID},
		expectationOrigins: RepositoryMockListEmbeddingsByKBFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListEmbeddingsByKBFileUID.expectations = append(mmListEmbeddingsByKBFileUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListEmbeddingsByKBFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListEmbeddingsByKBFileUIDExpectation) Then(ea1 []mm_repository.EmbeddingModel, err error) *RepositoryMock {
	e.results = &RepositoryMockListEmbeddingsByKBFileUIDResults{ea1, err}
	return e.mock
}

// Times sets number of times Repository.ListEmbeddingsByKBFileUID should be invoked
func (mmListEmbeddingsByKBFileUID *mRepositoryMockListEmbeddingsByKBFileUID) Times(n uint64) *mRepositoryMockListEmbeddingsByKBFileUID {
	if n == 0 {
		mmListEmbeddingsByKBFileUID.mock.t.Fatalf("Times of RepositoryMock.ListEmbeddingsByKBFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListEmbeddingsByKBFileUID.expectedInvocations, n)
	mmListEmbeddingsByKBFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListEmbeddingsByKBFileUID
}

func (mmListEmbeddingsByKBFileUID *mRepositoryMockListEmbeddingsByKBFileUID) invocationsDone() bool {
	if len(mmListEmbeddingsByKBFileUID.expectations) == 0 && mmListEmbeddingsByKBFileUID.defaultExpectation == nil && mmListEmbeddingsByKBFileUID.mock.funcListEmbeddingsByKBFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListEmbeddingsByKBFileUID.mock.afterListEmbeddingsByKBFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListEmbeddingsByKBFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListEmbeddingsByKBFileUID implements mm_repository.Repository
func (mmListEmbeddingsByKBFileUID *RepositoryMock) ListEmbeddingsByKBFileUID(ctx context.Context, kbFileUID types.FileUIDType) (ea1 []mm_repository.EmbeddingModel, err error) {
	mm_atomic.AddUint64(&mmListEmbeddingsByKBFileUID.beforeListEmbeddingsByKBFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmListEmbeddingsByKBFileUID.afterListEmbeddingsByKBFileUIDCounter, 1)

	mmListEmbeddingsByKBFileUID.t.Helper()

	if mmListEmbeddingsByKBFileUID.inspectFuncListEmbeddingsByKBFileUID != nil {
		mmListEmbeddingsByKBFileUID.inspectFuncListEmbeddingsByKBFileUID(ctx, kbFileUID)
	}

	mm_params := RepositoryMockListEmbeddingsByKBFileUIDParams{ctx, kbFileUID}

	// Record call args
	mmListEmbeddingsByKBFileUID.ListEmbeddingsByKBFileUIDMock.mutex.Lock()
	mmListEmbeddingsByKBFileUID.ListEmbeddingsByKBFileUIDMock.callArgs = append(mmListEmbeddingsByKBFileUID.ListEmbeddingsByKBFileUIDMock.callArgs, &mm_params)
	mmListEmbeddingsByKBFileUID.ListEmbeddingsByKBFileUIDMock.mutex.Unlock()

	for _, e := range mmListEmbeddingsByKBFileUID.ListEmbeddingsByKBFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1, e.results.err
		}
	}

	if mmListEmbeddingsByKBFileUID.ListEmbeddingsByKBFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListEmbeddingsByKBFileUID.ListEmbeddingsByKBFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmListEmbeddingsByKBFileUID.ListEmbeddingsByKBFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmListEmbeddingsByKBFileUID.ListEmbeddingsByKBFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListEmbeddingsByKBFileUIDParams{ctx, kbFileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListEmbeddingsByKBFileUID.t.Errorf("RepositoryMock.ListEmbeddingsByKBFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListEmbeddingsByKBFileUID.ListEmbeddingsByKBFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbFileUID != nil && !minimock.Equal(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID) {
				mmListEmbeddingsByKBFileUID.t.Errorf("RepositoryMock.ListEmbeddingsByKBFileUID got unexpected parameter kbFileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListEmbeddingsByKBFileUID.ListEmbeddingsByKBFileUIDMock.defaultExpectation.expectationOrigins.originKbFileUID, *mm_want_ptrs.kbFileUID, mm_got.kbFileUID, minimock.Diff(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListEmbeddingsByKBFileUID.t.Errorf("RepositoryMock.ListEmbeddingsByKBFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListEmbeddingsByKBFileUID.ListEmbeddingsByKBFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListEmbeddingsByKBFileUID.ListEmbeddingsByKBFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmListEmbeddingsByKBFileUID.t.Fatal("No results are set for the RepositoryMock.ListEmbeddingsByKBFileUID")
		}
		return (*mm_results).ea1, (*mm_results).err
	}
	if mmListEmbeddingsByKBFileUID.funcListEmbeddingsByKBFileUID != nil {
		return mmListEmbeddingsByKBFileUID.funcListEmbeddingsByKBFileUID(ctx, kbFileUID)
	}
	mmListEmbeddingsByKBFileUID.t.Fatalf("Unexpected call to RepositoryMock.ListEmbeddingsByKBFileUID. %v %v", ctx, kbFileUID)
	return
}

// ListEmbeddingsByKBFileUIDAfterCounter returns a count of finished RepositoryMock.ListEmbeddingsByKBFileUID invocations
func (mmListEmbeddingsByKBFileUID *RepositoryMock) ListEmbeddingsByKBFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListEmbeddingsByKBFileUID.afterListEmbeddingsByKBFileUIDCounter)
}

// ListEmbeddingsByKBFileUIDBeforeCounter returns a count of RepositoryMock.ListEmbeddingsByKBFileUID invocations
func (mmListEmbeddingsByKBFileUID *RepositoryMock) ListEmbeddingsByKBFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListEmbeddingsByKBFileUID.beforeListEmbeddingsByKBFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListEmbeddingsByKBFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListEmbeddingsByKBFileUID *mRepositoryMockListEmbeddingsByKBFileUID) Calls() []*RepositoryMockListEmbeddingsByKBFileUIDParams {
	mmListEmbeddingsByKBFileUID.mutex.RLock()

	argCopy := make([]*RepositoryMockListEmbeddingsByKBFileUIDParams, len(mmListEmbeddingsByKBFileUID.callArgs))
	copy(argCopy, mmListEmbeddingsByKBFileUID.callArgs)

	mmListEmbeddingsByKBFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockListEmbeddingsByKBFileUIDDone returns true if the count of the ListEmbeddingsByKBFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListEmbeddingsByKBFileUIDDone() bool {
	if m.ListEmbeddingsByKBFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListEmbeddingsByKBFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListEmbeddingsByKBFileUIDMock.invocationsDone()
}

// MinimockListEmbeddingsByKBFileUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListEmbeddingsByKBFileUIDInspect() {
	for _, e := range m.ListEmbeddingsByKBFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListEmbeddingsByKBFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListEmbeddingsByKBFileUIDCounter := mm_atomic.LoadUint64(&m.afterListEmbeddingsByKBFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListEmbeddingsByKBFileUIDMock.defaultExpectation != nil && afterListEmbeddingsByKBFileUIDCounter < 1 {
		if m.ListEmbeddingsByKBFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListEmbeddingsByKBFileUID at\n%s", m.ListEmbeddingsByKBFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListEmbeddingsByKBFileUID at\n%s with params: %#v", m.ListEmbeddingsByKBFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.ListEmbeddingsByKBFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListEmbeddingsByKBFileUID != nil && afterListEmbeddingsByKBFileUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListEmbeddingsByKBFileUID at\n%s", m.funcListEmbeddingsByKBFileUIDOrigin)
	}

	if !m.ListEmbeddingsByKBFileUIDMock.invocationsDone() && afterListEmbeddingsByKBFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListEmbeddingsByKBFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListEmbeddingsByKBFileUIDMock.expectedInvocations), m.ListEmbeddingsByKBFileUIDMock.expectedInvocationsOrigin, afterListEmbeddingsByKBFileUIDCounter)
	}
}

type mRepositoryMockListKnowledgeBaseFiles struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListKnowledgeBaseFilesExpectation
	expectations       []*RepositoryMockListKnowledgeBaseFilesExpectation

	callArgs []*RepositoryMockListKnowledgeBaseFilesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListKnowledgeBaseFilesExpectation specifies expectation struct of the Repository.ListKnowledgeBaseFiles
type RepositoryMockListKnowledgeBaseFilesExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListKnowledgeBaseFilesParams
	paramPtrs          *RepositoryMockListKnowledgeBaseFilesParamPtrs
	expectationOrigins RepositoryMockListKnowledgeBaseFilesExpectationOrigins
	results            *RepositoryMockListKnowledgeBaseFilesResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListKnowledgeBaseFilesParams contains parameters of the Repository.ListKnowledgeBaseFiles
type RepositoryMockListKnowledgeBaseFilesParams struct {
	ctx context.Context
	k1  mm_repository.KnowledgeBaseFileListParams
}

// RepositoryMockListKnowledgeBaseFilesParamPtrs contains pointers to parameters of the Repository.ListKnowledgeBaseFiles
type RepositoryMockListKnowledgeBaseFilesParamPtrs struct {
	ctx *context.Context
	k1  *mm_repository.KnowledgeBaseFileListParams
}

// RepositoryMockListKnowledgeBaseFilesResults contains results of the Repository.ListKnowledgeBaseFiles
type RepositoryMockListKnowledgeBaseFilesResults struct {
	kp1 *mm_repository.KnowledgeBaseFileList
	err error
}

// RepositoryMockListKnowledgeBaseFilesOrigins contains origins of expectations of the Repository.ListKnowledgeBaseFiles
type RepositoryMockListKnowledgeBaseFilesExpectationOrigins struct {
	origin    string
	originCtx string
	originK1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListKnowledgeBaseFiles *mRepositoryMockListKnowledgeBaseFiles) Optional() *mRepositoryMockListKnowledgeBaseFiles {
	mmListKnowledgeBaseFiles.optional = true
	return mmListKnowledgeBaseFiles
}

// Expect sets up expected params for Repository.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryMockListKnowledgeBaseFiles) Expect(ctx context.Context, k1 mm_repository.KnowledgeBaseFileListParams) *mRepositoryMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ListKnowledgeBaseFiles mock is already set by ExpectParams functions")
	}

	mmListKnowledgeBaseFiles.defaultExpectation.params = &RepositoryMockListKnowledgeBaseFilesParams{ctx, k1}
	mmListKnowledgeBaseFiles.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListKnowledgeBaseFiles.expectations {
		if minimock.Equal(e.params, mmListKnowledgeBaseFiles.defaultExpectation.params) {
			mmListKnowledgeBaseFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListKnowledgeBaseFiles.defaultExpectation.params)
		}
	}

	return mmListKnowledgeBaseFiles
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryMockListKnowledgeBaseFiles) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ListKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryMockListKnowledgeBaseFilesParamPtrs{}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs.ctx = &ctx
	mmListKnowledgeBaseFiles.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListKnowledgeBaseFiles
}

// ExpectK1Param2 sets up expected param k1 for Repository.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryMockListKnowledgeBaseFiles) ExpectK1Param2(k1 mm_repository.KnowledgeBaseFileListParams) *mRepositoryMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ListKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryMockListKnowledgeBaseFilesParamPtrs{}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs.k1 = &k1
	mmListKnowledgeBaseFiles.defaultExpectation.expectationOrigins.originK1 = minimock.CallerInfo(1)

	return mmListKnowledgeBaseFiles
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryMockListKnowledgeBaseFiles) Inspect(f func(ctx context.Context, k1 mm_repository.KnowledgeBaseFileListParams)) *mRepositoryMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.inspectFuncListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListKnowledgeBaseFiles")
	}

	mmListKnowledgeBaseFiles.mock.inspectFuncListKnowledgeBaseFiles = f

	return mmListKnowledgeBaseFiles
}

// Return sets up results that will be returned by Repository.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryMockListKnowledgeBaseFiles) Return(kp1 *mm_repository.KnowledgeBaseFileList, err error) *RepositoryMock {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryMockListKnowledgeBaseFilesExpectation{mock: mmListKnowledgeBaseFiles.mock}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.results = &RepositoryMockListKnowledgeBaseFilesResults{kp1, err}
	mmListKnowledgeBaseFiles.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBaseFiles.mock
}

// Set uses given function f to mock the Repository.ListKnowledgeBaseFiles method
func (mmListKnowledgeBaseFiles *mRepositoryMockListKnowledgeBaseFiles) Set(f func(ctx context.Context, k1 mm_repository.KnowledgeBaseFileListParams) (kp1 *mm_repository.KnowledgeBaseFileList, err error)) *RepositoryMock {
	if mmListKnowledgeBaseFiles.defaultExpectation != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("Default expectation is already set for the Repository.ListKnowledgeBaseFiles method")
	}

	if len(mmListKnowledgeBaseFiles.expectations) > 0 {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("Some expectations are already set for the Repository.ListKnowledgeBaseFiles method")
	}

	mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles = f
	mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFilesOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBaseFiles.mock
}

// When sets expectation for the Repository.ListKnowledgeBaseFiles which will trigger the result defined by the following
// Then helper
func (mmListKnowledgeBaseFiles *mRepositoryMockListKnowledgeBaseFiles) When(ctx context.Context, k1 mm_repository.KnowledgeBaseFileListParams) *RepositoryMockListKnowledgeBaseFilesExpectation {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	expectation := &RepositoryMockListKnowledgeBaseFilesExpectation{
		mock:               mmListKnowledgeBaseFiles.mock,
		params:             &RepositoryMockListKnowledgeBaseFilesParams{ctx, k1},
		expectationOrigins: RepositoryMockListKnowledgeBaseFilesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListKnowledgeBaseFiles.expectations = append(mmListKnowledgeBaseFiles.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListKnowledgeBaseFiles return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListKnowledgeBaseFilesExpectation) Then(kp1 *mm_repository.KnowledgeBaseFileList, err error) *RepositoryMock {
	e.results = &RepositoryMockListKnowledgeBaseFilesResults{kp1, err}
	return e.mock
}

// Times sets number of times Repository.ListKnowledgeBaseFiles should be invoked
func (mmListKnowledgeBaseFiles *mRepositoryMockListKnowledgeBaseFiles) Times(n uint64) *mRepositoryMockListKnowledgeBaseFiles {
	if n == 0 {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("Times of RepositoryMock.ListKnowledgeBaseFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListKnowledgeBaseFiles.expectedInvocations, n)
	mmListKnowledgeBaseFiles.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBaseFiles
}

func (mmListKnowledgeBaseFiles *mRepositoryMockListKnowledgeBaseFiles) invocationsDone() bool {
	if len(mmListKnowledgeBaseFiles.expectations) == 0 && mmListKnowledgeBaseFiles.defaultExpectation == nil && mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBaseFiles.mock.afterListKnowledgeBaseFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBaseFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListKnowledgeBaseFiles implements mm_repository.Repository
func (mmListKnowledgeBaseFiles *RepositoryMock) ListKnowledgeBaseFiles(ctx context.Context, k1 mm_repository.KnowledgeBaseFileListParams) (kp1 *mm_repository.KnowledgeBaseFileList, err error) {
	mm_atomic.AddUint64(&mmListKnowledgeBaseFiles.beforeListKnowledgeBaseFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmListKnowledgeBaseFiles.afterListKnowledgeBaseFilesCounter, 1)

	mmListKnowledgeBaseFiles.t.Helper()

	if mmListKnowledgeBaseFiles.inspectFuncListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.inspectFuncListKnowledgeBaseFiles(ctx, k1)
	}

	mm_params := RepositoryMockListKnowledgeBaseFilesParams{ctx, k1}

	// Record call args
	mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.mutex.Lock()
	mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.callArgs = append(mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.callArgs, &mm_params)
	mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.mutex.Unlock()

	for _, e := range mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.params
		mm_want_ptrs := mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListKnowledgeBaseFilesParams{ctx, k1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListKnowledgeBaseFiles.t.Errorf("RepositoryMock.ListKnowledgeBaseFiles got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.k1 != nil && !minimock.Equal(*mm_want_ptrs.k1, mm_got.k1) {
				mmListKnowledgeBaseFiles.t.Errorf("RepositoryMock.ListKnowledgeBaseFiles got unexpected parameter k1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.originK1, *mm_want_ptrs.k1, mm_got.k1, minimock.Diff(*mm_want_ptrs.k1, mm_got.k1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListKnowledgeBaseFiles.t.Errorf("RepositoryMock.ListKnowledgeBaseFiles got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmListKnowledgeBaseFiles.t.Fatal("No results are set for the RepositoryMock.ListKnowledgeBaseFiles")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmListKnowledgeBaseFiles.funcListKnowledgeBaseFiles != nil {
		return mmListKnowledgeBaseFiles.funcListKnowledgeBaseFiles(ctx, k1)
	}
	mmListKnowledgeBaseFiles.t.Fatalf("Unexpected call to RepositoryMock.ListKnowledgeBaseFiles. %v %v", ctx, k1)
	return
}

// ListKnowledgeBaseFilesAfterCounter returns a count of finished RepositoryMock.ListKnowledgeBaseFiles invocations
func (mmListKnowledgeBaseFiles *RepositoryMock) ListKnowledgeBaseFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBaseFiles.afterListKnowledgeBaseFilesCounter)
}

// ListKnowledgeBaseFilesBeforeCounter returns a count of RepositoryMock.ListKnowledgeBaseFiles invocations
func (mmListKnowledgeBaseFiles *RepositoryMock) ListKnowledgeBaseFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBaseFiles.beforeListKnowledgeBaseFilesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListKnowledgeBaseFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListKnowledgeBaseFiles *mRepositoryMockListKnowledgeBaseFiles) Calls() []*RepositoryMockListKnowledgeBaseFilesParams {
	mmListKnowledgeBaseFiles.mutex.RLock()

	argCopy := make([]*RepositoryMockListKnowledgeBaseFilesParams, len(mmListKnowledgeBaseFiles.callArgs))
	copy(argCopy, mmListKnowledgeBaseFiles.callArgs)

	mmListKnowledgeBaseFiles.mutex.RUnlock()

	return argCopy
}

// MinimockListKnowledgeBaseFilesDone returns true if the count of the ListKnowledgeBaseFiles invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListKnowledgeBaseFilesDone() bool {
	if m.ListKnowledgeBaseFilesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListKnowledgeBaseFilesMock.invocationsDone()
}

// MinimockListKnowledgeBaseFilesInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListKnowledgeBaseFilesInspect() {
	for _, e := range m.ListKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBaseFiles at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListKnowledgeBaseFilesCounter := mm_atomic.LoadUint64(&m.afterListKnowledgeBaseFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListKnowledgeBaseFilesMock.defaultExpectation != nil && afterListKnowledgeBaseFilesCounter < 1 {
		if m.ListKnowledgeBaseFilesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBaseFiles at\n%s", m.ListKnowledgeBaseFilesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBaseFiles at\n%s with params: %#v", m.ListKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.origin, *m.ListKnowledgeBaseFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListKnowledgeBaseFiles != nil && afterListKnowledgeBaseFilesCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBaseFiles at\n%s", m.funcListKnowledgeBaseFilesOrigin)
	}

	if !m.ListKnowledgeBaseFilesMock.invocationsDone() && afterListKnowledgeBaseFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListKnowledgeBaseFiles at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListKnowledgeBaseFilesMock.expectedInvocations), m.ListKnowledgeBaseFilesMock.expectedInvocationsOrigin, afterListKnowledgeBaseFilesCounter)
	}
}

type mRepositoryMockListKnowledgeBases struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListKnowledgeBasesExpectation
	expectations       []*RepositoryMockListKnowledgeBasesExpectation

	callArgs []*RepositoryMockListKnowledgeBasesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListKnowledgeBasesExpectation specifies expectation struct of the Repository.ListKnowledgeBases
type RepositoryMockListKnowledgeBasesExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListKnowledgeBasesParams
	paramPtrs          *RepositoryMockListKnowledgeBasesParamPtrs
	expectationOrigins RepositoryMockListKnowledgeBasesExpectationOrigins
	results            *RepositoryMockListKnowledgeBasesResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListKnowledgeBasesParams contains parameters of the Repository.ListKnowledgeBases
type RepositoryMockListKnowledgeBasesParams struct {
	ctx      context.Context
	ownerUID string
}

// RepositoryMockListKnowledgeBasesParamPtrs contains pointers to parameters of the Repository.ListKnowledgeBases
type RepositoryMockListKnowledgeBasesParamPtrs struct {
	ctx      *context.Context
	ownerUID *string
}

// RepositoryMockListKnowledgeBasesResults contains results of the Repository.ListKnowledgeBases
type RepositoryMockListKnowledgeBasesResults struct {
	ka1 []mm_repository.KnowledgeBaseModel
	err error
}

// RepositoryMockListKnowledgeBasesOrigins contains origins of expectations of the Repository.ListKnowledgeBases
type RepositoryMockListKnowledgeBasesExpectationOrigins struct {
	origin         string
	originCtx      string
	originOwnerUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListKnowledgeBases *mRepositoryMockListKnowledgeBases) Optional() *mRepositoryMockListKnowledgeBases {
	mmListKnowledgeBases.optional = true
	return mmListKnowledgeBases
}

// Expect sets up expected params for Repository.ListKnowledgeBases
func (mmListKnowledgeBases *mRepositoryMockListKnowledgeBases) Expect(ctx context.Context, ownerUID string) *mRepositoryMockListKnowledgeBases {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryMock.ListKnowledgeBases mock is already set by Set")
	}

	if mmListKnowledgeBases.defaultExpectation == nil {
		mmListKnowledgeBases.defaultExpectation = &RepositoryMockListKnowledgeBasesExpectation{}
	}

	if mmListKnowledgeBases.defaultExpectation.paramPtrs != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryMock.ListKnowledgeBases mock is already set by ExpectParams functions")
	}

	mmListKnowledgeBases.defaultExpectation.params = &RepositoryMockListKnowledgeBasesParams{ctx, ownerUID}
	mmListKnowledgeBases.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListKnowledgeBases.expectations {
		if minimock.Equal(e.params, mmListKnowledgeBases.defaultExpectation.params) {
			mmListKnowledgeBases.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListKnowledgeBases.defaultExpectation.params)
		}
	}

	return mmListKnowledgeBases
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListKnowledgeBases
func (mmListKnowledgeBases *mRepositoryMockListKnowledgeBases) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListKnowledgeBases {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryMock.ListKnowledgeBases mock is already set by Set")
	}

	if mmListKnowledgeBases.defaultExpectation == nil {
		mmListKnowledgeBases.defaultExpectation = &RepositoryMockListKnowledgeBasesExpectation{}
	}

	if mmListKnowledgeBases.defaultExpectation.params != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryMock.ListKnowledgeBases mock is already set by Expect")
	}

	if mmListKnowledgeBases.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBases.defaultExpectation.paramPtrs = &RepositoryMockListKnowledgeBasesParamPtrs{}
	}
	mmListKnowledgeBases.defaultExpectation.paramPtrs.ctx = &ctx
	mmListKnowledgeBases.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListKnowledgeBases
}

// ExpectOwnerUIDParam2 sets up expected param ownerUID for Repository.ListKnowledgeBases
func (mmListKnowledgeBases *mRepositoryMockListKnowledgeBases) ExpectOwnerUIDParam2(ownerUID string) *mRepositoryMockListKnowledgeBases {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryMock.ListKnowledgeBases mock is already set by Set")
	}

	if mmListKnowledgeBases.defaultExpectation == nil {
		mmListKnowledgeBases.defaultExpectation = &RepositoryMockListKnowledgeBasesExpectation{}
	}

	if mmListKnowledgeBases.defaultExpectation.params != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryMock.ListKnowledgeBases mock is already set by Expect")
	}

	if mmListKnowledgeBases.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBases.defaultExpectation.paramPtrs = &RepositoryMockListKnowledgeBasesParamPtrs{}
	}
	mmListKnowledgeBases.defaultExpectation.paramPtrs.ownerUID = &ownerUID
	mmListKnowledgeBases.defaultExpectation.expectationOrigins.originOwnerUID = minimock.CallerInfo(1)

	return mmListKnowledgeBases
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListKnowledgeBases
func (mmListKnowledgeBases *mRepositoryMockListKnowledgeBases) Inspect(f func(ctx context.Context, ownerUID string)) *mRepositoryMockListKnowledgeBases {
	if mmListKnowledgeBases.mock.inspectFuncListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListKnowledgeBases")
	}

	mmListKnowledgeBases.mock.inspectFuncListKnowledgeBases = f

	return mmListKnowledgeBases
}

// Return sets up results that will be returned by Repository.ListKnowledgeBases
func (mmListKnowledgeBases *mRepositoryMockListKnowledgeBases) Return(ka1 []mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryMock.ListKnowledgeBases mock is already set by Set")
	}

	if mmListKnowledgeBases.defaultExpectation == nil {
		mmListKnowledgeBases.defaultExpectation = &RepositoryMockListKnowledgeBasesExpectation{mock: mmListKnowledgeBases.mock}
	}
	mmListKnowledgeBases.defaultExpectation.results = &RepositoryMockListKnowledgeBasesResults{ka1, err}
	mmListKnowledgeBases.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBases.mock
}

// Set uses given function f to mock the Repository.ListKnowledgeBases method
func (mmListKnowledgeBases *mRepositoryMockListKnowledgeBases) Set(f func(ctx context.Context, ownerUID string) (ka1 []mm_repository.KnowledgeBaseModel, err error)) *RepositoryMock {
	if mmListKnowledgeBases.defaultExpectation != nil {
		mmListKnowledgeBases.mock.t.Fatalf("Default expectation is already set for the Repository.ListKnowledgeBases method")
	}

	if len(mmListKnowledgeBases.expectations) > 0 {
		mmListKnowledgeBases.mock.t.Fatalf("Some expectations are already set for the Repository.ListKnowledgeBases method")
	}

	mmListKnowledgeBases.mock.funcListKnowledgeBases = f
	mmListKnowledgeBases.mock.funcListKnowledgeBasesOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBases.mock
}

// When sets expectation for the Repository.ListKnowledgeBases which will trigger the result defined by the following
// Then helper
func (mmListKnowledgeBases *mRepositoryMockListKnowledgeBases) When(ctx context.Context, ownerUID string) *RepositoryMockListKnowledgeBasesExpectation {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryMock.ListKnowledgeBases mock is already set by Set")
	}

	expectation := &RepositoryMockListKnowledgeBasesExpectation{
		mock:               mmListKnowledgeBases.mock,
		params:             &RepositoryMockListKnowledgeBasesParams{ctx, ownerUID},
		expectationOrigins: RepositoryMockListKnowledgeBasesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListKnowledgeBases.expectations = append(mmListKnowledgeBases.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListKnowledgeBases return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListKnowledgeBasesExpectation) Then(ka1 []mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	e.results = &RepositoryMockListKnowledgeBasesResults{ka1, err}
	return e.mock
}

// Times sets number of times Repository.ListKnowledgeBases should be invoked
func (mmListKnowledgeBases *mRepositoryMockListKnowledgeBases) Times(n uint64) *mRepositoryMockListKnowledgeBases {
	if n == 0 {
		mmListKnowledgeBases.mock.t.Fatalf("Times of RepositoryMock.ListKnowledgeBases mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListKnowledgeBases.expectedInvocations, n)
	mmListKnowledgeBases.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBases
}

func (mmListKnowledgeBases *mRepositoryMockListKnowledgeBases) invocationsDone() bool {
	if len(mmListKnowledgeBases.expectations) == 0 && mmListKnowledgeBases.defaultExpectation == nil && mmListKnowledgeBases.mock.funcListKnowledgeBases == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBases.mock.afterListKnowledgeBasesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBases.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListKnowledgeBases implements mm_repository.Repository
func (mmListKnowledgeBases *RepositoryMock) ListKnowledgeBases(ctx context.Context, ownerUID string) (ka1 []mm_repository.KnowledgeBaseModel, err error) {
	mm_atomic.AddUint64(&mmListKnowledgeBases.beforeListKnowledgeBasesCounter, 1)
	defer mm_atomic.AddUint64(&mmListKnowledgeBases.afterListKnowledgeBasesCounter, 1)

	mmListKnowledgeBases.t.Helper()

	if mmListKnowledgeBases.inspectFuncListKnowledgeBases != nil {
		mmListKnowledgeBases.inspectFuncListKnowledgeBases(ctx, ownerUID)
	}

	mm_params := RepositoryMockListKnowledgeBasesParams{ctx, ownerUID}

	// Record call args
	mmListKnowledgeBases.ListKnowledgeBasesMock.mutex.Lock()
	mmListKnowledgeBases.ListKnowledgeBasesMock.callArgs = append(mmListKnowledgeBases.ListKnowledgeBasesMock.callArgs, &mm_params)
	mmListKnowledgeBases.ListKnowledgeBasesMock.mutex.Unlock()

	for _, e := range mmListKnowledgeBases.ListKnowledgeBasesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.Counter, 1)
		mm_want := mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.params
		mm_want_ptrs := mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListKnowledgeBasesParams{ctx, ownerUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListKnowledgeBases.t.Errorf("RepositoryMock.ListKnowledgeBases got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmListKnowledgeBases.t.Errorf("RepositoryMock.ListKnowledgeBases got unexpected parameter ownerUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.expectationOrigins.originOwnerUID, *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListKnowledgeBases.t.Errorf("RepositoryMock.ListKnowledgeBases got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.results
		if mm_results == nil {
			mmListKnowledgeBases.t.Fatal("No results are set for the RepositoryMock.ListKnowledgeBases")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmListKnowledgeBases.funcListKnowledgeBases != nil {
		return mmListKnowledgeBases.funcListKnowledgeBases(ctx, ownerUID)
	}
	mmListKnowledgeBases.t.Fatalf("Unexpected call to RepositoryMock.ListKnowledgeBases. %v %v", ctx, ownerUID)
	return
}

// ListKnowledgeBasesAfterCounter returns a count of finished RepositoryMock.ListKnowledgeBases invocations
func (mmListKnowledgeBases *RepositoryMock) ListKnowledgeBasesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBases.afterListKnowledgeBasesCounter)
}

// ListKnowledgeBasesBeforeCounter returns a count of RepositoryMock.ListKnowledgeBases invocations
func (mmListKnowledgeBases *RepositoryMock) ListKnowledgeBasesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBases.beforeListKnowledgeBasesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListKnowledgeBases.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListKnowledgeBases *mRepositoryMockListKnowledgeBases) Calls() []*RepositoryMockListKnowledgeBasesParams {
	mmListKnowledgeBases.mutex.RLock()

	argCopy := make([]*RepositoryMockListKnowledgeBasesParams, len(mmListKnowledgeBases.callArgs))
	copy(argCopy, mmListKnowledgeBases.callArgs)

	mmListKnowledgeBases.mutex.RUnlock()

	return argCopy
}

// MinimockListKnowledgeBasesDone returns true if the count of the ListKnowledgeBases invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListKnowledgeBasesDone() bool {
	if m.ListKnowledgeBasesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListKnowledgeBasesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListKnowledgeBasesMock.invocationsDone()
}

// MinimockListKnowledgeBasesInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListKnowledgeBasesInspect() {
	for _, e := range m.ListKnowledgeBasesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBases at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListKnowledgeBasesCounter := mm_atomic.LoadUint64(&m.afterListKnowledgeBasesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListKnowledgeBasesMock.defaultExpectation != nil && afterListKnowledgeBasesCounter < 1 {
		if m.ListKnowledgeBasesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBases at\n%s", m.ListKnowledgeBasesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBases at\n%s with params: %#v", m.ListKnowledgeBasesMock.defaultExpectation.expectationOrigins.origin, *m.ListKnowledgeBasesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListKnowledgeBases != nil && afterListKnowledgeBasesCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBases at\n%s", m.funcListKnowledgeBasesOrigin)
	}

	if !m.ListKnowledgeBasesMock.invocationsDone() && afterListKnowledgeBasesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListKnowledgeBases at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListKnowledgeBasesMock.expectedInvocations), m.ListKnowledgeBasesMock.expectedInvocationsOrigin, afterListKnowledgeBasesCounter)
	}
}

type mRepositoryMockListKnowledgeBasesByType struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListKnowledgeBasesByTypeExpectation
	expectations       []*RepositoryMockListKnowledgeBasesByTypeExpectation

	callArgs []*RepositoryMockListKnowledgeBasesByTypeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListKnowledgeBasesByTypeExpectation specifies expectation struct of the Repository.ListKnowledgeBasesByType
type RepositoryMockListKnowledgeBasesByTypeExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListKnowledgeBasesByTypeParams
	paramPtrs          *RepositoryMockListKnowledgeBasesByTypeParamPtrs
	expectationOrigins RepositoryMockListKnowledgeBasesByTypeExpectationOrigins
	results            *RepositoryMockListKnowledgeBasesByTypeResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListKnowledgeBasesByTypeParams contains parameters of the Repository.ListKnowledgeBasesByType
type RepositoryMockListKnowledgeBasesByTypeParams struct {
	ctx      context.Context
	ownerUID string
	kbType   artifactpb.KnowledgeBaseType
}

// RepositoryMockListKnowledgeBasesByTypeParamPtrs contains pointers to parameters of the Repository.ListKnowledgeBasesByType
type RepositoryMockListKnowledgeBasesByTypeParamPtrs struct {
	ctx      *context.Context
	ownerUID *string
	kbType   *artifactpb.KnowledgeBaseType
}

// RepositoryMockListKnowledgeBasesByTypeResults contains results of the Repository.ListKnowledgeBasesByType
type RepositoryMockListKnowledgeBasesByTypeResults struct {
	ka1 []mm_repository.KnowledgeBaseModel
	err error
}

// RepositoryMockListKnowledgeBasesByTypeOrigins contains origins of expectations of the Repository.ListKnowledgeBasesByType
type RepositoryMockListKnowledgeBasesByTypeExpectationOrigins struct {
	origin         string
	originCtx      string
	originOwnerUID string
	originKbType   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListKnowledgeBasesByType *mRepositoryMockListKnowledgeBasesByType) Optional() *mRepositoryMockListKnowledgeBasesByType {
	mmListKnowledgeBasesByType.optional = true
	return mmListKnowledgeBasesByType
}

// Expect sets up expected params for Repository.ListKnowledgeBasesByType
func (mmListKnowledgeBasesByType *mRepositoryMockListKnowledgeBasesByType) Expect(ctx context.Context, ownerUID string, kbType artifactpb.KnowledgeBaseType) *mRepositoryMockListKnowledgeBasesByType {
	if mmListKnowledgeBasesByType.mock.funcListKnowledgeBasesByType != nil {
		mmListKnowledgeBasesByType.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByType mock is already set by Set")
	}

	if mmListKnowledgeBasesByType.defaultExpectation == nil {
		mmListKnowledgeBasesByType.defaultExpectation = &RepositoryMockListKnowledgeBasesByTypeExpectation{}
	}

	if mmListKnowledgeBasesByType.defaultExpectation.paramPtrs != nil {
		mmListKnowledgeBasesByType.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByType mock is already set by ExpectParams functions")
	}

	mmListKnowledgeBasesByType.defaultExpectation.params = &RepositoryMockListKnowledgeBasesByTypeParams{ctx, ownerUID, kbType}
	mmListKnowledgeBasesByType.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListKnowledgeBasesByType.expectations {
		if minimock.Equal(e.params, mmListKnowledgeBasesByType.defaultExpectation.params) {
			mmListKnowledgeBasesByType.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListKnowledgeBasesByType.defaultExpectation.params)
		}
	}

	return mmListKnowledgeBasesByType
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListKnowledgeBasesByType
func (mmListKnowledgeBasesByType *mRepositoryMockListKnowledgeBasesByType) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListKnowledgeBasesByType {
	if mmListKnowledgeBasesByType.mock.funcListKnowledgeBasesByType != nil {
		mmListKnowledgeBasesByType.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByType mock is already set by Set")
	}

	if mmListKnowledgeBasesByType.defaultExpectation == nil {
		mmListKnowledgeBasesByType.defaultExpectation = &RepositoryMockListKnowledgeBasesByTypeExpectation{}
	}

	if mmListKnowledgeBasesByType.defaultExpectation.params != nil {
		mmListKnowledgeBasesByType.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByType mock is already set by Expect")
	}

	if mmListKnowledgeBasesByType.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBasesByType.defaultExpectation.paramPtrs = &RepositoryMockListKnowledgeBasesByTypeParamPtrs{}
	}
	mmListKnowledgeBasesByType.defaultExpectation.paramPtrs.ctx = &ctx
	mmListKnowledgeBasesByType.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListKnowledgeBasesByType
}

// ExpectOwnerUIDParam2 sets up expected param ownerUID for Repository.ListKnowledgeBasesByType
func (mmListKnowledgeBasesByType *mRepositoryMockListKnowledgeBasesByType) ExpectOwnerUIDParam2(ownerUID string) *mRepositoryMockListKnowledgeBasesByType {
	if mmListKnowledgeBasesByType.mock.funcListKnowledgeBasesByType != nil {
		mmListKnowledgeBasesByType.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByType mock is already set by Set")
	}

	if mmListKnowledgeBasesByType.defaultExpectation == nil {
		mmListKnowledgeBasesByType.defaultExpectation = &RepositoryMockListKnowledgeBasesByTypeExpectation{}
	}

	if mmListKnowledgeBasesByType.defaultExpectation.params != nil {
		mmListKnowledgeBasesByType.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByType mock is already set by Expect")
	}

	if mmListKnowledgeBasesByType.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBasesByType.defaultExpectation.paramPtrs = &RepositoryMockListKnowledgeBasesByTypeParamPtrs{}
	}
	mmListKnowledgeBasesByType.defaultExpectation.paramPtrs.ownerUID = &ownerUID
	mmListKnowledgeBasesByType.defaultExpectation.expectationOrigins.originOwnerUID = minimock.CallerInfo(1)

	return mmListKnowledgeBasesByType
}

// ExpectKbTypeParam3 sets up expected param kbType for Repository.ListKnowledgeBasesByType
func (mmListKnowledgeBasesByType *mRepositoryMockListKnowledgeBasesByType) ExpectKbTypeParam3(kbType artifactpb.KnowledgeBaseType) *mRepositoryMockListKnowledgeBasesByType {
	if mmListKnowledgeBasesByType.mock.funcListKnowledgeBasesByType != nil {
		mmListKnowledgeBasesByType.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByType mock is already set by Set")
	}

	if mmListKnowledgeBasesByType.defaultExpectation == nil {
		mmListKnowledgeBasesByType.defaultExpectation = &RepositoryMockListKnowledgeBasesByTypeExpectation{}
	}

	if mmListKnowledgeBasesByType.defaultExpectation.params != nil {
		mmListKnowledgeBasesByType.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByType mock is already set by Expect")
	}

	if mmListKnowledgeBasesByType.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBasesByType.defaultExpectation.paramPtrs = &RepositoryMockListKnowledgeBasesByTypeParamPtrs{}
	}
	mmListKnowledgeBasesByType.defaultExpectation.paramPtrs.kbType = &kbType
	mmListKnowledgeBasesByType.defaultExpectation.expectationOrigins.originKbType = minimock.CallerInfo(1)

	return mmListKnowledgeBasesByType
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListKnowledgeBasesByType
func (mmListKnowledgeBasesByType *mRepositoryMockListKnowledgeBasesByType) Inspect(f func(ctx context.Context, ownerUID string, kbType artifactpb.KnowledgeBaseType)) *mRepositoryMockListKnowledgeBasesByType {
	if mmListKnowledgeBasesByType.mock.inspectFuncListKnowledgeBasesByType != nil {
		mmListKnowledgeBasesByType.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListKnowledgeBasesByType")
	}

	mmListKnowledgeBasesByType.mock.inspectFuncListKnowledgeBasesByType = f

	return mmListKnowledgeBasesByType
}

// Return sets up results that will be returned by Repository.ListKnowledgeBasesByType
func (mmListKnowledgeBasesByType *mRepositoryMockListKnowledgeBasesByType) Return(ka1 []mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	if mmListKnowledgeBasesByType.mock.funcListKnowledgeBasesByType != nil {
		mmListKnowledgeBasesByType.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByType mock is already set by Set")
	}

	if mmListKnowledgeBasesByType.defaultExpectation == nil {
		mmListKnowledgeBasesByType.defaultExpectation = &RepositoryMockListKnowledgeBasesByTypeExpectation{mock: mmListKnowledgeBasesByType.mock}
	}
	mmListKnowledgeBasesByType.defaultExpectation.results = &RepositoryMockListKnowledgeBasesByTypeResults{ka1, err}
	mmListKnowledgeBasesByType.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBasesByType.mock
}

// Set uses given function f to mock the Repository.ListKnowledgeBasesByType method
func (mmListKnowledgeBasesByType *mRepositoryMockListKnowledgeBasesByType) Set(f func(ctx context.Context, ownerUID string, kbType artifactpb.KnowledgeBaseType) (ka1 []mm_repository.KnowledgeBaseModel, err error)) *RepositoryMock {
	if mmListKnowledgeBasesByType.defaultExpectation != nil {
		mmListKnowledgeBasesByType.mock.t.Fatalf("Default expectation is already set for the Repository.ListKnowledgeBasesByType method")
	}

	if len(mmListKnowledgeBasesByType.expectations) > 0 {
		mmListKnowledgeBasesByType.mock.t.Fatalf("Some expectations are already set for the Repository.ListKnowledgeBasesByType method")
	}

	mmListKnowledgeBasesByType.mock.funcListKnowledgeBasesByType = f
	mmListKnowledgeBasesByType.mock.funcListKnowledgeBasesByTypeOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBasesByType.mock
}

// When sets expectation for the Repository.ListKnowledgeBasesByType which will trigger the result defined by the following
// Then helper
func (mmListKnowledgeBasesByType *mRepositoryMockListKnowledgeBasesByType) When(ctx context.Context, ownerUID string, kbType artifactpb.KnowledgeBaseType) *RepositoryMockListKnowledgeBasesByTypeExpectation {
	if mmListKnowledgeBasesByType.mock.funcListKnowledgeBasesByType != nil {
		mmListKnowledgeBasesByType.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByType mock is already set by Set")
	}

	expectation := &RepositoryMockListKnowledgeBasesByTypeExpectation{
		mock:               mmListKnowledgeBasesByType.mock,
		params:             &RepositoryMockListKnowledgeBasesByTypeParams{ctx, ownerUID, kbType},
		expectationOrigins: RepositoryMockListKnowledgeBasesByTypeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListKnowledgeBasesByType.expectations = append(mmListKnowledgeBasesByType.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListKnowledgeBasesByType return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListKnowledgeBasesByTypeExpectation) Then(ka1 []mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	e.results = &RepositoryMockListKnowledgeBasesByTypeResults{ka1, err}
	return e.mock
}

// Times sets number of times Repository.ListKnowledgeBasesByType should be invoked
func (mmListKnowledgeBasesByType *mRepositoryMockListKnowledgeBasesByType) Times(n uint64) *mRepositoryMockListKnowledgeBasesByType {
	if n == 0 {
		mmListKnowledgeBasesByType.mock.t.Fatalf("Times of RepositoryMock.ListKnowledgeBasesByType mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListKnowledgeBasesByType.expectedInvocations, n)
	mmListKnowledgeBasesByType.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBasesByType
}

func (mmListKnowledgeBasesByType *mRepositoryMockListKnowledgeBasesByType) invocationsDone() bool {
	if len(mmListKnowledgeBasesByType.expectations) == 0 && mmListKnowledgeBasesByType.defaultExpectation == nil && mmListKnowledgeBasesByType.mock.funcListKnowledgeBasesByType == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBasesByType.mock.afterListKnowledgeBasesByTypeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBasesByType.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListKnowledgeBasesByType implements mm_repository.Repository
func (mmListKnowledgeBasesByType *RepositoryMock) ListKnowledgeBasesByType(ctx context.Context, ownerUID string, kbType artifactpb.KnowledgeBaseType) (ka1 []mm_repository.KnowledgeBaseModel, err error) {
	mm_atomic.AddUint64(&mmListKnowledgeBasesByType.beforeListKnowledgeBasesByTypeCounter, 1)
	defer mm_atomic.AddUint64(&mmListKnowledgeBasesByType.afterListKnowledgeBasesByTypeCounter, 1)

	mmListKnowledgeBasesByType.t.Helper()

	if mmListKnowledgeBasesByType.inspectFuncListKnowledgeBasesByType != nil {
		mmListKnowledgeBasesByType.inspectFuncListKnowledgeBasesByType(ctx, ownerUID, kbType)
	}

	mm_params := RepositoryMockListKnowledgeBasesByTypeParams{ctx, ownerUID, kbType}

	// Record call args
	mmListKnowledgeBasesByType.ListKnowledgeBasesByTypeMock.mutex.Lock()
	mmListKnowledgeBasesByType.ListKnowledgeBasesByTypeMock.callArgs = append(mmListKnowledgeBasesByType.ListKnowledgeBasesByTypeMock.callArgs, &mm_params)
	mmListKnowledgeBasesByType.ListKnowledgeBasesByTypeMock.mutex.Unlock()

	for _, e := range mmListKnowledgeBasesByType.ListKnowledgeBasesByTypeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmListKnowledgeBasesByType.ListKnowledgeBasesByTypeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListKnowledgeBasesByType.ListKnowledgeBasesByTypeMock.defaultExpectation.Counter, 1)
		mm_want := mmListKnowledgeBasesByType.ListKnowledgeBasesByTypeMock.defaultExpectation.params
		mm_want_ptrs := mmListKnowledgeBasesByType.ListKnowledgeBasesByTypeMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListKnowledgeBasesByTypeParams{ctx, ownerUID, kbType}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListKnowledgeBasesByType.t.Errorf("RepositoryMock.ListKnowledgeBasesByType got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBasesByType.ListKnowledgeBasesByTypeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmListKnowledgeBasesByType.t.Errorf("RepositoryMock.ListKnowledgeBasesByType got unexpected parameter ownerUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBasesByType.ListKnowledgeBasesByTypeMock.defaultExpectation.expectationOrigins.originOwnerUID, *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

			if mm_want_ptrs.kbType != nil && !minimock.Equal(*mm_want_ptrs.kbType, mm_got.kbType) {
				mmListKnowledgeBasesByType.t.Errorf("RepositoryMock.ListKnowledgeBasesByType got unexpected parameter kbType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBasesByType.ListKnowledgeBasesByTypeMock.defaultExpectation.expectationOrigins.originKbType, *mm_want_ptrs.kbType, mm_got.kbType, minimock.Diff(*mm_want_ptrs.kbType, mm_got.kbType))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListKnowledgeBasesByType.t.Errorf("RepositoryMock.ListKnowledgeBasesByType got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListKnowledgeBasesByType.ListKnowledgeBasesByTypeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListKnowledgeBasesByType.ListKnowledgeBasesByTypeMock.defaultExpectation.results
		if mm_results == nil {
			mmListKnowledgeBasesByType.t.Fatal("No results are set for the RepositoryMock.ListKnowledgeBasesByType")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmListKnowledgeBasesByType.funcListKnowledgeBasesByType != nil {
		return mmListKnowledgeBasesByType.funcListKnowledgeBasesByType(ctx, ownerUID, kbType)
	}
	mmListKnowledgeBasesByType.t.Fatalf("Unexpected call to RepositoryMock.ListKnowledgeBasesByType. %v %v %v", ctx, ownerUID, kbType)
	return
}

// ListKnowledgeBasesByTypeAfterCounter returns a count of finished RepositoryMock.ListKnowledgeBasesByType invocations
func (mmListKnowledgeBasesByType *RepositoryMock) ListKnowledgeBasesByTypeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBasesByType.afterListKnowledgeBasesByTypeCounter)
}

// ListKnowledgeBasesByTypeBeforeCounter returns a count of RepositoryMock.ListKnowledgeBasesByType invocations
func (mmListKnowledgeBasesByType *RepositoryMock) ListKnowledgeBasesByTypeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBasesByType.beforeListKnowledgeBasesByTypeCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListKnowledgeBasesByType.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListKnowledgeBasesByType *mRepositoryMockListKnowledgeBasesByType) Calls() []*RepositoryMockListKnowledgeBasesByTypeParams {
	mmListKnowledgeBasesByType.mutex.RLock()

	argCopy := make([]*RepositoryMockListKnowledgeBasesByTypeParams, len(mmListKnowledgeBasesByType.callArgs))
	copy(argCopy, mmListKnowledgeBasesByType.callArgs)

	mmListKnowledgeBasesByType.mutex.RUnlock()

	return argCopy
}

// MinimockListKnowledgeBasesByTypeDone returns true if the count of the ListKnowledgeBasesByType invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListKnowledgeBasesByTypeDone() bool {
	if m.ListKnowledgeBasesByTypeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListKnowledgeBasesByTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListKnowledgeBasesByTypeMock.invocationsDone()
}

// MinimockListKnowledgeBasesByTypeInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListKnowledgeBasesByTypeInspect() {
	for _, e := range m.ListKnowledgeBasesByTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBasesByType at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListKnowledgeBasesByTypeCounter := mm_atomic.LoadUint64(&m.afterListKnowledgeBasesByTypeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListKnowledgeBasesByTypeMock.defaultExpectation != nil && afterListKnowledgeBasesByTypeCounter < 1 {
		if m.ListKnowledgeBasesByTypeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBasesByType at\n%s", m.ListKnowledgeBasesByTypeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBasesByType at\n%s with params: %#v", m.ListKnowledgeBasesByTypeMock.defaultExpectation.expectationOrigins.origin, *m.ListKnowledgeBasesByTypeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListKnowledgeBasesByType != nil && afterListKnowledgeBasesByTypeCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBasesByType at\n%s", m.funcListKnowledgeBasesByTypeOrigin)
	}

	if !m.ListKnowledgeBasesByTypeMock.invocationsDone() && afterListKnowledgeBasesByTypeCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListKnowledgeBasesByType at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListKnowledgeBasesByTypeMock.expectedInvocations), m.ListKnowledgeBasesByTypeMock.expectedInvocationsOrigin, afterListKnowledgeBasesByTypeCounter)
	}
}

type mRepositoryMockListKnowledgeBasesByTypeWithConfig struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListKnowledgeBasesByTypeWithConfigExpectation
	expectations       []*RepositoryMockListKnowledgeBasesByTypeWithConfigExpectation

	callArgs []*RepositoryMockListKnowledgeBasesByTypeWithConfigParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListKnowledgeBasesByTypeWithConfigExpectation specifies expectation struct of the Repository.ListKnowledgeBasesByTypeWithConfig
type RepositoryMockListKnowledgeBasesByTypeWithConfigExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListKnowledgeBasesByTypeWithConfigParams
	paramPtrs          *RepositoryMockListKnowledgeBasesByTypeWithConfigParamPtrs
	expectationOrigins RepositoryMockListKnowledgeBasesByTypeWithConfigExpectationOrigins
	results            *RepositoryMockListKnowledgeBasesByTypeWithConfigResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListKnowledgeBasesByTypeWithConfigParams contains parameters of the Repository.ListKnowledgeBasesByTypeWithConfig
type RepositoryMockListKnowledgeBasesByTypeWithConfigParams struct {
	ctx      context.Context
	ownerUID string
	kbType   artifactpb.KnowledgeBaseType
}

// RepositoryMockListKnowledgeBasesByTypeWithConfigParamPtrs contains pointers to parameters of the Repository.ListKnowledgeBasesByTypeWithConfig
type RepositoryMockListKnowledgeBasesByTypeWithConfigParamPtrs struct {
	ctx      *context.Context
	ownerUID *string
	kbType   *artifactpb.KnowledgeBaseType
}

// RepositoryMockListKnowledgeBasesByTypeWithConfigResults contains results of the Repository.ListKnowledgeBasesByTypeWithConfig
type RepositoryMockListKnowledgeBasesByTypeWithConfigResults struct {
	ka1 []mm_repository.KnowledgeBaseWithConfig
	err error
}

// RepositoryMockListKnowledgeBasesByTypeWithConfigOrigins contains origins of expectations of the Repository.ListKnowledgeBasesByTypeWithConfig
type RepositoryMockListKnowledgeBasesByTypeWithConfigExpectationOrigins struct {
	origin         string
	originCtx      string
	originOwnerUID string
	originKbType   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListKnowledgeBasesByTypeWithConfig *mRepositoryMockListKnowledgeBasesByTypeWithConfig) Optional() *mRepositoryMockListKnowledgeBasesByTypeWithConfig {
	mmListKnowledgeBasesByTypeWithConfig.optional = true
	return mmListKnowledgeBasesByTypeWithConfig
}

// Expect sets up expected params for Repository.ListKnowledgeBasesByTypeWithConfig
func (mmListKnowledgeBasesByTypeWithConfig *mRepositoryMockListKnowledgeBasesByTypeWithConfig) Expect(ctx context.Context, ownerUID string, kbType artifactpb.KnowledgeBaseType) *mRepositoryMockListKnowledgeBasesByTypeWithConfig {
	if mmListKnowledgeBasesByTypeWithConfig.mock.funcListKnowledgeBasesByTypeWithConfig != nil {
		mmListKnowledgeBasesByTypeWithConfig.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByTypeWithConfig mock is already set by Set")
	}

	if mmListKnowledgeBasesByTypeWithConfig.defaultExpectation == nil {
		mmListKnowledgeBasesByTypeWithConfig.defaultExpectation = &RepositoryMockListKnowledgeBasesByTypeWithConfigExpectation{}
	}

	if mmListKnowledgeBasesByTypeWithConfig.defaultExpectation.paramPtrs != nil {
		mmListKnowledgeBasesByTypeWithConfig.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByTypeWithConfig mock is already set by ExpectParams functions")
	}

	mmListKnowledgeBasesByTypeWithConfig.defaultExpectation.params = &RepositoryMockListKnowledgeBasesByTypeWithConfigParams{ctx, ownerUID, kbType}
	mmListKnowledgeBasesByTypeWithConfig.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListKnowledgeBasesByTypeWithConfig.expectations {
		if minimock.Equal(e.params, mmListKnowledgeBasesByTypeWithConfig.defaultExpectation.params) {
			mmListKnowledgeBasesByTypeWithConfig.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListKnowledgeBasesByTypeWithConfig.defaultExpectation.params)
		}
	}

	return mmListKnowledgeBasesByTypeWithConfig
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListKnowledgeBasesByTypeWithConfig
func (mmListKnowledgeBasesByTypeWithConfig *mRepositoryMockListKnowledgeBasesByTypeWithConfig) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListKnowledgeBasesByTypeWithConfig {
	if mmListKnowledgeBasesByTypeWithConfig.mock.funcListKnowledgeBasesByTypeWithConfig != nil {
		mmListKnowledgeBasesByTypeWithConfig.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByTypeWithConfig mock is already set by Set")
	}

	if mmListKnowledgeBasesByTypeWithConfig.defaultExpectation == nil {
		mmListKnowledgeBasesByTypeWithConfig.defaultExpectation = &RepositoryMockListKnowledgeBasesByTypeWithConfigExpectation{}
	}

	if mmListKnowledgeBasesByTypeWithConfig.defaultExpectation.params != nil {
		mmListKnowledgeBasesByTypeWithConfig.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByTypeWithConfig mock is already set by Expect")
	}

	if mmListKnowledgeBasesByTypeWithConfig.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBasesByTypeWithConfig.defaultExpectation.paramPtrs = &RepositoryMockListKnowledgeBasesByTypeWithConfigParamPtrs{}
	}
	mmListKnowledgeBasesByTypeWithConfig.defaultExpectation.paramPtrs.ctx = &ctx
	mmListKnowledgeBasesByTypeWithConfig.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListKnowledgeBasesByTypeWithConfig
}

// ExpectOwnerUIDParam2 sets up expected param ownerUID for Repository.ListKnowledgeBasesByTypeWithConfig
func (mmListKnowledgeBasesByTypeWithConfig *mRepositoryMockListKnowledgeBasesByTypeWithConfig) ExpectOwnerUIDParam2(ownerUID string) *mRepositoryMockListKnowledgeBasesByTypeWithConfig {
	if mmListKnowledgeBasesByTypeWithConfig.mock.funcListKnowledgeBasesByTypeWithConfig != nil {
		mmListKnowledgeBasesByTypeWithConfig.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByTypeWithConfig mock is already set by Set")
	}

	if mmListKnowledgeBasesByTypeWithConfig.defaultExpectation == nil {
		mmListKnowledgeBasesByTypeWithConfig.defaultExpectation = &RepositoryMockListKnowledgeBasesByTypeWithConfigExpectation{}
	}

	if mmListKnowledgeBasesByTypeWithConfig.defaultExpectation.params != nil {
		mmListKnowledgeBasesByTypeWithConfig.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByTypeWithConfig mock is already set by Expect")
	}

	if mmListKnowledgeBasesByTypeWithConfig.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBasesByTypeWithConfig.defaultExpectation.paramPtrs = &RepositoryMockListKnowledgeBasesByTypeWithConfigParamPtrs{}
	}
	mmListKnowledgeBasesByTypeWithConfig.defaultExpectation.paramPtrs.ownerUID = &ownerUID
	mmListKnowledgeBasesByTypeWithConfig.defaultExpectation.expectationOrigins.originOwnerUID = minimock.CallerInfo(1)

	return mmListKnowledgeBasesByTypeWithConfig
}

// ExpectKbTypeParam3 sets up expected param kbType for Repository.ListKnowledgeBasesByTypeWithConfig
func (mmListKnowledgeBasesByTypeWithConfig *mRepositoryMockListKnowledgeBasesByTypeWithConfig) ExpectKbTypeParam3(kbType artifactpb.KnowledgeBaseType) *mRepositoryMockListKnowledgeBasesByTypeWithConfig {
	if mmListKnowledgeBasesByTypeWithConfig.mock.funcListKnowledgeBasesByTypeWithConfig != nil {
		mmListKnowledgeBasesByTypeWithConfig.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByTypeWithConfig mock is already set by Set")
	}

	if mmListKnowledgeBasesByTypeWithConfig.defaultExpectation == nil {
		mmListKnowledgeBasesByTypeWithConfig.defaultExpectation = &RepositoryMockListKnowledgeBasesByTypeWithConfigExpectation{}
	}

	if mmListKnowledgeBasesByTypeWithConfig.defaultExpectation.params != nil {
		mmListKnowledgeBasesByTypeWithConfig.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByTypeWithConfig mock is already set by Expect")
	}

	if mmListKnowledgeBasesByTypeWithConfig.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBasesByTypeWithConfig.defaultExpectation.paramPtrs = &RepositoryMockListKnowledgeBasesByTypeWithConfigParamPtrs{}
	}
	mmListKnowledgeBasesByTypeWithConfig.defaultExpectation.paramPtrs.kbType = &kbType
	mmListKnowledgeBasesByTypeWithConfig.defaultExpectation.expectationOrigins.originKbType = minimock.CallerInfo(1)

	return mmListKnowledgeBasesByTypeWithConfig
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListKnowledgeBasesByTypeWithConfig
func (mmListKnowledgeBasesByTypeWithConfig *mRepositoryMockListKnowledgeBasesByTypeWithConfig) Inspect(f func(ctx context.Context, ownerUID string, kbType artifactpb.KnowledgeBaseType)) *mRepositoryMockListKnowledgeBasesByTypeWithConfig {
	if mmListKnowledgeBasesByTypeWithConfig.mock.inspectFuncListKnowledgeBasesByTypeWithConfig != nil {
		mmListKnowledgeBasesByTypeWithConfig.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListKnowledgeBasesByTypeWithConfig")
	}

	mmListKnowledgeBasesByTypeWithConfig.mock.inspectFuncListKnowledgeBasesByTypeWithConfig = f

	return mmListKnowledgeBasesByTypeWithConfig
}

// Return sets up results that will be returned by Repository.ListKnowledgeBasesByTypeWithConfig
func (mmListKnowledgeBasesByTypeWithConfig *mRepositoryMockListKnowledgeBasesByTypeWithConfig) Return(ka1 []mm_repository.KnowledgeBaseWithConfig, err error) *RepositoryMock {
	if mmListKnowledgeBasesByTypeWithConfig.mock.funcListKnowledgeBasesByTypeWithConfig != nil {
		mmListKnowledgeBasesByTypeWithConfig.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByTypeWithConfig mock is already set by Set")
	}

	if mmListKnowledgeBasesByTypeWithConfig.defaultExpectation == nil {
		mmListKnowledgeBasesByTypeWithConfig.defaultExpectation = &RepositoryMockListKnowledgeBasesByTypeWithConfigExpectation{mock: mmListKnowledgeBasesByTypeWithConfig.mock}
	}
	mmListKnowledgeBasesByTypeWithConfig.defaultExpectation.results = &RepositoryMockListKnowledgeBasesByTypeWithConfigResults{ka1, err}
	mmListKnowledgeBasesByTypeWithConfig.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBasesByTypeWithConfig.mock
}

// Set uses given function f to mock the Repository.ListKnowledgeBasesByTypeWithConfig method
func (mmListKnowledgeBasesByTypeWithConfig *mRepositoryMockListKnowledgeBasesByTypeWithConfig) Set(f func(ctx context.Context, ownerUID string, kbType artifactpb.KnowledgeBaseType) (ka1 []mm_repository.KnowledgeBaseWithConfig, err error)) *RepositoryMock {
	if mmListKnowledgeBasesByTypeWithConfig.defaultExpectation != nil {
		mmListKnowledgeBasesByTypeWithConfig.mock.t.Fatalf("Default expectation is already set for the Repository.ListKnowledgeBasesByTypeWithConfig method")
	}

	if len(mmListKnowledgeBasesByTypeWithConfig.expectations) > 0 {
		mmListKnowledgeBasesByTypeWithConfig.mock.t.Fatalf("Some expectations are already set for the Repository.ListKnowledgeBasesByTypeWithConfig method")
	}

	mmListKnowledgeBasesByTypeWithConfig.mock.funcListKnowledgeBasesByTypeWithConfig = f
	mmListKnowledgeBasesByTypeWithConfig.mock.funcListKnowledgeBasesByTypeWithConfigOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBasesByTypeWithConfig.mock
}

// When sets expectation for the Repository.ListKnowledgeBasesByTypeWithConfig which will trigger the result defined by the following
// Then helper
func (mmListKnowledgeBasesByTypeWithConfig *mRepositoryMockListKnowledgeBasesByTypeWithConfig) When(ctx context.Context, ownerUID string, kbType artifactpb.KnowledgeBaseType) *RepositoryMockListKnowledgeBasesByTypeWithConfigExpectation {
	if mmListKnowledgeBasesByTypeWithConfig.mock.funcListKnowledgeBasesByTypeWithConfig != nil {
		mmListKnowledgeBasesByTypeWithConfig.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByTypeWithConfig mock is already set by Set")
	}

	expectation := &RepositoryMockListKnowledgeBasesByTypeWithConfigExpectation{
		mock:               mmListKnowledgeBasesByTypeWithConfig.mock,
		params:             &RepositoryMockListKnowledgeBasesByTypeWithConfigParams{ctx, ownerUID, kbType},
		expectationOrigins: RepositoryMockListKnowledgeBasesByTypeWithConfigExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListKnowledgeBasesByTypeWithConfig.expectations = append(mmListKnowledgeBasesByTypeWithConfig.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListKnowledgeBasesByTypeWithConfig return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListKnowledgeBasesByTypeWithConfigExpectation) Then(ka1 []mm_repository.KnowledgeBaseWithConfig, err error) *RepositoryMock {
	e.results = &RepositoryMockListKnowledgeBasesByTypeWithConfigResults{ka1, err}
	return e.mock
}

// Times sets number of times Repository.ListKnowledgeBasesByTypeWithConfig should be invoked
func (mmListKnowledgeBasesByTypeWithConfig *mRepositoryMockListKnowledgeBasesByTypeWithConfig) Times(n uint64) *mRepositoryMockListKnowledgeBasesByTypeWithConfig {
	if n == 0 {
		mmListKnowledgeBasesByTypeWithConfig.mock.t.Fatalf("Times of RepositoryMock.ListKnowledgeBasesByTypeWithConfig mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListKnowledgeBasesByTypeWithConfig.expectedInvocations, n)
	mmListKnowledgeBasesByTypeWithConfig.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBasesByTypeWithConfig
}

func (mmListKnowledgeBasesByTypeWithConfig *mRepositoryMockListKnowledgeBasesByTypeWithConfig) invocationsDone() bool {
	if len(mmListKnowledgeBasesByTypeWithConfig.expectations) == 0 && mmListKnowledgeBasesByTypeWithConfig.defaultExpectation == nil && mmListKnowledgeBasesByTypeWithConfig.mock.funcListKnowledgeBasesByTypeWithConfig == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBasesByTypeWithConfig.mock.afterListKnowledgeBasesByTypeWithConfigCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBasesByTypeWithConfig.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListKnowledgeBasesByTypeWithConfig implements mm_repository.Repository
func (mmListKnowledgeBasesByTypeWithConfig *RepositoryMock) ListKnowledgeBasesByTypeWithConfig(ctx context.Context, ownerUID string, kbType artifactpb.KnowledgeBaseType) (ka1 []mm_repository.KnowledgeBaseWithConfig, err error) {
	mm_atomic.AddUint64(&mmListKnowledgeBasesByTypeWithConfig.beforeListKnowledgeBasesByTypeWithConfigCounter, 1)
	defer mm_atomic.AddUint64(&mmListKnowledgeBasesByTypeWithConfig.afterListKnowledgeBasesByTypeWithConfigCounter, 1)

	mmListKnowledgeBasesByTypeWithConfig.t.Helper()

	if mmListKnowledgeBasesByTypeWithConfig.inspectFuncListKnowledgeBasesByTypeWithConfig != nil {
		mmListKnowledgeBasesByTypeWithConfig.inspectFuncListKnowledgeBasesByTypeWithConfig(ctx, ownerUID, kbType)
	}

	mm_params := RepositoryMockListKnowledgeBasesByTypeWithConfigParams{ctx, ownerUID, kbType}

	// Record call args
	mmListKnowledgeBasesByTypeWithConfig.ListKnowledgeBasesByTypeWithConfigMock.mutex.Lock()
	mmListKnowledgeBasesByTypeWithConfig.ListKnowledgeBasesByTypeWithConfigMock.callArgs = append(mmListKnowledgeBasesByTypeWithConfig.ListKnowledgeBasesByTypeWithConfigMock.callArgs, &mm_params)
	mmListKnowledgeBasesByTypeWithConfig.ListKnowledgeBasesByTypeWithConfigMock.mutex.Unlock()

	for _, e := range mmListKnowledgeBasesByTypeWithConfig.ListKnowledgeBasesByTypeWithConfigMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmListKnowledgeBasesByTypeWithConfig.ListKnowledgeBasesByTypeWithConfigMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListKnowledgeBasesByTypeWithConfig.ListKnowledgeBasesByTypeWithConfigMock.defaultExpectation.Counter, 1)
		mm_want := mmListKnowledgeBasesByTypeWithConfig.ListKnowledgeBasesByTypeWithConfigMock.defaultExpectation.params
		mm_want_ptrs := mmListKnowledgeBasesByTypeWithConfig.ListKnowledgeBasesByTypeWithConfigMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListKnowledgeBasesByTypeWithConfigParams{ctx, ownerUID, kbType}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListKnowledgeBasesByTypeWithConfig.t.Errorf("RepositoryMock.ListKnowledgeBasesByTypeWithConfig got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBasesByTypeWithConfig.ListKnowledgeBasesByTypeWithConfigMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmListKnowledgeBasesByTypeWithConfig.t.Errorf("RepositoryMock.ListKnowledgeBasesByTypeWithConfig got unexpected parameter ownerUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBasesByTypeWithConfig.ListKnowledgeBasesByTypeWithConfigMock.defaultExpectation.expectationOrigins.originOwnerUID, *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

			if mm_want_ptrs.kbType != nil && !minimock.Equal(*mm_want_ptrs.kbType, mm_got.kbType) {
				mmListKnowledgeBasesByTypeWithConfig.t.Errorf("RepositoryMock.ListKnowledgeBasesByTypeWithConfig got unexpected parameter kbType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBasesByTypeWithConfig.ListKnowledgeBasesByTypeWithConfigMock.defaultExpectation.expectationOrigins.originKbType, *mm_want_ptrs.kbType, mm_got.kbType, minimock.Diff(*mm_want_ptrs.kbType, mm_got.kbType))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListKnowledgeBasesByTypeWithConfig.t.Errorf("RepositoryMock.ListKnowledgeBasesByTypeWithConfig got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListKnowledgeBasesByTypeWithConfig.ListKnowledgeBasesByTypeWithConfigMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListKnowledgeBasesByTypeWithConfig.ListKnowledgeBasesByTypeWithConfigMock.defaultExpectation.results
		if mm_results == nil {
			mmListKnowledgeBasesByTypeWithConfig.t.Fatal("No results are set for the RepositoryMock.ListKnowledgeBasesByTypeWithConfig")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmListKnowledgeBasesByTypeWithConfig.funcListKnowledgeBasesByTypeWithConfig != nil {
		return mmListKnowledgeBasesByTypeWithConfig.funcListKnowledgeBasesByTypeWithConfig(ctx, ownerUID, kbType)
	}
	mmListKnowledgeBasesByTypeWithConfig.t.Fatalf("Unexpected call to RepositoryMock.ListKnowledgeBasesByTypeWithConfig. %v %v %v", ctx, ownerUID, kbType)
	return
}

// ListKnowledgeBasesByTypeWithConfigAfterCounter returns a count of finished RepositoryMock.ListKnowledgeBasesByTypeWithConfig invocations
func (mmListKnowledgeBasesByTypeWithConfig *RepositoryMock) ListKnowledgeBasesByTypeWithConfigAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBasesByTypeWithConfig.afterListKnowledgeBasesByTypeWithConfigCounter)
}

// ListKnowledgeBasesByTypeWithConfigBeforeCounter returns a count of RepositoryMock.ListKnowledgeBasesByTypeWithConfig invocations
func (mmListKnowledgeBasesByTypeWithConfig *RepositoryMock) ListKnowledgeBasesByTypeWithConfigBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBasesByTypeWithConfig.beforeListKnowledgeBasesByTypeWithConfigCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListKnowledgeBasesByTypeWithConfig.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListKnowledgeBasesByTypeWithConfig *mRepositoryMockListKnowledgeBasesByTypeWithConfig) Calls() []*RepositoryMockListKnowledgeBasesByTypeWithConfigParams {
	mmListKnowledgeBasesByTypeWithConfig.mutex.RLock()

	argCopy := make([]*RepositoryMockListKnowledgeBasesByTypeWithConfigParams, len(mmListKnowledgeBasesByTypeWithConfig.callArgs))
	copy(argCopy, mmListKnowledgeBasesByTypeWithConfig.callArgs)

	mmListKnowledgeBasesByTypeWithConfig.mutex.RUnlock()

	return argCopy
}

// MinimockListKnowledgeBasesByTypeWithConfigDone returns true if the count of the ListKnowledgeBasesByTypeWithConfig invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListKnowledgeBasesByTypeWithConfigDone() bool {
	if m.ListKnowledgeBasesByTypeWithConfigMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListKnowledgeBasesByTypeWithConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListKnowledgeBasesByTypeWithConfigMock.invocationsDone()
}

// MinimockListKnowledgeBasesByTypeWithConfigInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListKnowledgeBasesByTypeWithConfigInspect() {
	for _, e := range m.ListKnowledgeBasesByTypeWithConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBasesByTypeWithConfig at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListKnowledgeBasesByTypeWithConfigCounter := mm_atomic.LoadUint64(&m.afterListKnowledgeBasesByTypeWithConfigCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListKnowledgeBasesByTypeWithConfigMock.defaultExpectation != nil && afterListKnowledgeBasesByTypeWithConfigCounter < 1 {
		if m.ListKnowledgeBasesByTypeWithConfigMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBasesByTypeWithConfig at\n%s", m.ListKnowledgeBasesByTypeWithConfigMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBasesByTypeWithConfig at\n%s with params: %#v", m.ListKnowledgeBasesByTypeWithConfigMock.defaultExpectation.expectationOrigins.origin, *m.ListKnowledgeBasesByTypeWithConfigMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListKnowledgeBasesByTypeWithConfig != nil && afterListKnowledgeBasesByTypeWithConfigCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBasesByTypeWithConfig at\n%s", m.funcListKnowledgeBasesByTypeWithConfigOrigin)
	}

	if !m.ListKnowledgeBasesByTypeWithConfigMock.invocationsDone() && afterListKnowledgeBasesByTypeWithConfigCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListKnowledgeBasesByTypeWithConfig at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListKnowledgeBasesByTypeWithConfigMock.expectedInvocations), m.ListKnowledgeBasesByTypeWithConfigMock.expectedInvocationsOrigin, afterListKnowledgeBasesByTypeWithConfigCounter)
	}
}

type mRepositoryMockListKnowledgeBasesByUpdateStatus struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListKnowledgeBasesByUpdateStatusExpectation
	expectations       []*RepositoryMockListKnowledgeBasesByUpdateStatusExpectation

	callArgs []*RepositoryMockListKnowledgeBasesByUpdateStatusParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListKnowledgeBasesByUpdateStatusExpectation specifies expectation struct of the Repository.ListKnowledgeBasesByUpdateStatus
type RepositoryMockListKnowledgeBasesByUpdateStatusExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListKnowledgeBasesByUpdateStatusParams
	paramPtrs          *RepositoryMockListKnowledgeBasesByUpdateStatusParamPtrs
	expectationOrigins RepositoryMockListKnowledgeBasesByUpdateStatusExpectationOrigins
	results            *RepositoryMockListKnowledgeBasesByUpdateStatusResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListKnowledgeBasesByUpdateStatusParams contains parameters of the Repository.ListKnowledgeBasesByUpdateStatus
type RepositoryMockListKnowledgeBasesByUpdateStatusParams struct {
	ctx          context.Context
	updateStatus string
}

// RepositoryMockListKnowledgeBasesByUpdateStatusParamPtrs contains pointers to parameters of the Repository.ListKnowledgeBasesByUpdateStatus
type RepositoryMockListKnowledgeBasesByUpdateStatusParamPtrs struct {
	ctx          *context.Context
	updateStatus *string
}

// RepositoryMockListKnowledgeBasesByUpdateStatusResults contains results of the Repository.ListKnowledgeBasesByUpdateStatus
type RepositoryMockListKnowledgeBasesByUpdateStatusResults struct {
	ka1 []mm_repository.KnowledgeBaseModel
	err error
}

// RepositoryMockListKnowledgeBasesByUpdateStatusOrigins contains origins of expectations of the Repository.ListKnowledgeBasesByUpdateStatus
type RepositoryMockListKnowledgeBasesByUpdateStatusExpectationOrigins struct {
	origin             string
	originCtx          string
	originUpdateStatus string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListKnowledgeBasesByUpdateStatus *mRepositoryMockListKnowledgeBasesByUpdateStatus) Optional() *mRepositoryMockListKnowledgeBasesByUpdateStatus {
	mmListKnowledgeBasesByUpdateStatus.optional = true
	return mmListKnowledgeBasesByUpdateStatus
}

// Expect sets up expected params for Repository.ListKnowledgeBasesByUpdateStatus
func (mmListKnowledgeBasesByUpdateStatus *mRepositoryMockListKnowledgeBasesByUpdateStatus) Expect(ctx context.Context, updateStatus string) *mRepositoryMockListKnowledgeBasesByUpdateStatus {
	if mmListKnowledgeBasesByUpdateStatus.mock.funcListKnowledgeBasesByUpdateStatus != nil {
		mmListKnowledgeBasesByUpdateStatus.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByUpdateStatus mock is already set by Set")
	}

	if mmListKnowledgeBasesByUpdateStatus.defaultExpectation == nil {
		mmListKnowledgeBasesByUpdateStatus.defaultExpectation = &RepositoryMockListKnowledgeBasesByUpdateStatusExpectation{}
	}

	if mmListKnowledgeBasesByUpdateStatus.defaultExpectation.paramPtrs != nil {
		mmListKnowledgeBasesByUpdateStatus.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByUpdateStatus mock is already set by ExpectParams functions")
	}

	mmListKnowledgeBasesByUpdateStatus.defaultExpectation.params = &RepositoryMockListKnowledgeBasesByUpdateStatusParams{ctx, updateStatus}
	mmListKnowledgeBasesByUpdateStatus.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListKnowledgeBasesByUpdateStatus.expectations {
		if minimock.Equal(e.params, mmListKnowledgeBasesByUpdateStatus.defaultExpectation.params) {
			mmListKnowledgeBasesByUpdateStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListKnowledgeBasesByUpdateStatus.defaultExpectation.params)
		}
	}

	return mmListKnowledgeBasesByUpdateStatus
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListKnowledgeBasesByUpdateStatus
func (mmListKnowledgeBasesByUpdateStatus *mRepositoryMockListKnowledgeBasesByUpdateStatus) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListKnowledgeBasesByUpdateStatus {
	if mmListKnowledgeBasesByUpdateStatus.mock.funcListKnowledgeBasesByUpdateStatus != nil {
		mmListKnowledgeBasesByUpdateStatus.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByUpdateStatus mock is already set by Set")
	}

	if mmListKnowledgeBasesByUpdateStatus.defaultExpectation == nil {
		mmListKnowledgeBasesByUpdateStatus.defaultExpectation = &RepositoryMockListKnowledgeBasesByUpdateStatusExpectation{}
	}

	if mmListKnowledgeBasesByUpdateStatus.defaultExpectation.params != nil {
		mmListKnowledgeBasesByUpdateStatus.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByUpdateStatus mock is already set by Expect")
	}

	if mmListKnowledgeBasesByUpdateStatus.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBasesByUpdateStatus.defaultExpectation.paramPtrs = &RepositoryMockListKnowledgeBasesByUpdateStatusParamPtrs{}
	}
	mmListKnowledgeBasesByUpdateStatus.defaultExpectation.paramPtrs.ctx = &ctx
	mmListKnowledgeBasesByUpdateStatus.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListKnowledgeBasesByUpdateStatus
}

// ExpectUpdateStatusParam2 sets up expected param updateStatus for Repository.ListKnowledgeBasesByUpdateStatus
func (mmListKnowledgeBasesByUpdateStatus *mRepositoryMockListKnowledgeBasesByUpdateStatus) ExpectUpdateStatusParam2(updateStatus string) *mRepositoryMockListKnowledgeBasesByUpdateStatus {
	if mmListKnowledgeBasesByUpdateStatus.mock.funcListKnowledgeBasesByUpdateStatus != nil {
		mmListKnowledgeBasesByUpdateStatus.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByUpdateStatus mock is already set by Set")
	}

	if mmListKnowledgeBasesByUpdateStatus.defaultExpectation == nil {
		mmListKnowledgeBasesByUpdateStatus.defaultExpectation = &RepositoryMockListKnowledgeBasesByUpdateStatusExpectation{}
	}

	if mmListKnowledgeBasesByUpdateStatus.defaultExpectation.params != nil {
		mmListKnowledgeBasesByUpdateStatus.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByUpdateStatus mock is already set by Expect")
	}

	if mmListKnowledgeBasesByUpdateStatus.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBasesByUpdateStatus.defaultExpectation.paramPtrs = &RepositoryMockListKnowledgeBasesByUpdateStatusParamPtrs{}
	}
	mmListKnowledgeBasesByUpdateStatus.defaultExpectation.paramPtrs.updateStatus = &updateStatus
	mmListKnowledgeBasesByUpdateStatus.defaultExpectation.expectationOrigins.originUpdateStatus = minimock.CallerInfo(1)

	return mmListKnowledgeBasesByUpdateStatus
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListKnowledgeBasesByUpdateStatus
func (mmListKnowledgeBasesByUpdateStatus *mRepositoryMockListKnowledgeBasesByUpdateStatus) Inspect(f func(ctx context.Context, updateStatus string)) *mRepositoryMockListKnowledgeBasesByUpdateStatus {
	if mmListKnowledgeBasesByUpdateStatus.mock.inspectFuncListKnowledgeBasesByUpdateStatus != nil {
		mmListKnowledgeBasesByUpdateStatus.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListKnowledgeBasesByUpdateStatus")
	}

	mmListKnowledgeBasesByUpdateStatus.mock.inspectFuncListKnowledgeBasesByUpdateStatus = f

	return mmListKnowledgeBasesByUpdateStatus
}

// Return sets up results that will be returned by Repository.ListKnowledgeBasesByUpdateStatus
func (mmListKnowledgeBasesByUpdateStatus *mRepositoryMockListKnowledgeBasesByUpdateStatus) Return(ka1 []mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	if mmListKnowledgeBasesByUpdateStatus.mock.funcListKnowledgeBasesByUpdateStatus != nil {
		mmListKnowledgeBasesByUpdateStatus.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByUpdateStatus mock is already set by Set")
	}

	if mmListKnowledgeBasesByUpdateStatus.defaultExpectation == nil {
		mmListKnowledgeBasesByUpdateStatus.defaultExpectation = &RepositoryMockListKnowledgeBasesByUpdateStatusExpectation{mock: mmListKnowledgeBasesByUpdateStatus.mock}
	}
	mmListKnowledgeBasesByUpdateStatus.defaultExpectation.results = &RepositoryMockListKnowledgeBasesByUpdateStatusResults{ka1, err}
	mmListKnowledgeBasesByUpdateStatus.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBasesByUpdateStatus.mock
}

// Set uses given function f to mock the Repository.ListKnowledgeBasesByUpdateStatus method
func (mmListKnowledgeBasesByUpdateStatus *mRepositoryMockListKnowledgeBasesByUpdateStatus) Set(f func(ctx context.Context, updateStatus string) (ka1 []mm_repository.KnowledgeBaseModel, err error)) *RepositoryMock {
	if mmListKnowledgeBasesByUpdateStatus.defaultExpectation != nil {
		mmListKnowledgeBasesByUpdateStatus.mock.t.Fatalf("Default expectation is already set for the Repository.ListKnowledgeBasesByUpdateStatus method")
	}

	if len(mmListKnowledgeBasesByUpdateStatus.expectations) > 0 {
		mmListKnowledgeBasesByUpdateStatus.mock.t.Fatalf("Some expectations are already set for the Repository.ListKnowledgeBasesByUpdateStatus method")
	}

	mmListKnowledgeBasesByUpdateStatus.mock.funcListKnowledgeBasesByUpdateStatus = f
	mmListKnowledgeBasesByUpdateStatus.mock.funcListKnowledgeBasesByUpdateStatusOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBasesByUpdateStatus.mock
}

// When sets expectation for the Repository.ListKnowledgeBasesByUpdateStatus which will trigger the result defined by the following
// Then helper
func (mmListKnowledgeBasesByUpdateStatus *mRepositoryMockListKnowledgeBasesByUpdateStatus) When(ctx context.Context, updateStatus string) *RepositoryMockListKnowledgeBasesByUpdateStatusExpectation {
	if mmListKnowledgeBasesByUpdateStatus.mock.funcListKnowledgeBasesByUpdateStatus != nil {
		mmListKnowledgeBasesByUpdateStatus.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByUpdateStatus mock is already set by Set")
	}

	expectation := &RepositoryMockListKnowledgeBasesByUpdateStatusExpectation{
		mock:               mmListKnowledgeBasesByUpdateStatus.mock,
		params:             &RepositoryMockListKnowledgeBasesByUpdateStatusParams{ctx, updateStatus},
		expectationOrigins: RepositoryMockListKnowledgeBasesByUpdateStatusExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListKnowledgeBasesByUpdateStatus.expectations = append(mmListKnowledgeBasesByUpdateStatus.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListKnowledgeBasesByUpdateStatus return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListKnowledgeBasesByUpdateStatusExpectation) Then(ka1 []mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	e.results = &RepositoryMockListKnowledgeBasesByUpdateStatusResults{ka1, err}
	return e.mock
}

// Times sets number of times Repository.ListKnowledgeBasesByUpdateStatus should be invoked
func (mmListKnowledgeBasesByUpdateStatus *mRepositoryMockListKnowledgeBasesByUpdateStatus) Times(n uint64) *mRepositoryMockListKnowledgeBasesByUpdateStatus {
	if n == 0 {
		mmListKnowledgeBasesByUpdateStatus.mock.t.Fatalf("Times of RepositoryMock.ListKnowledgeBasesByUpdateStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListKnowledgeBasesByUpdateStatus.expectedInvocations, n)
	mmListKnowledgeBasesByUpdateStatus.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBasesByUpdateStatus
}

func (mmListKnowledgeBasesByUpdateStatus *mRepositoryMockListKnowledgeBasesByUpdateStatus) invocationsDone() bool {
	if len(mmListKnowledgeBasesByUpdateStatus.expectations) == 0 && mmListKnowledgeBasesByUpdateStatus.defaultExpectation == nil && mmListKnowledgeBasesByUpdateStatus.mock.funcListKnowledgeBasesByUpdateStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBasesByUpdateStatus.mock.afterListKnowledgeBasesByUpdateStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBasesByUpdateStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListKnowledgeBasesByUpdateStatus implements mm_repository.Repository
func (mmListKnowledgeBasesByUpdateStatus *RepositoryMock) ListKnowledgeBasesByUpdateStatus(ctx context.Context, updateStatus string) (ka1 []mm_repository.KnowledgeBaseModel, err error) {
	mm_atomic.AddUint64(&mmListKnowledgeBasesByUpdateStatus.beforeListKnowledgeBasesByUpdateStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmListKnowledgeBasesByUpdateStatus.afterListKnowledgeBasesByUpdateStatusCounter, 1)

	mmListKnowledgeBasesByUpdateStatus.t.Helper()

	if mmListKnowledgeBasesByUpdateStatus.inspectFuncListKnowledgeBasesByUpdateStatus != nil {
		mmListKnowledgeBasesByUpdateStatus.inspectFuncListKnowledgeBasesByUpdateStatus(ctx, updateStatus)
	}

	mm_params := RepositoryMockListKnowledgeBasesByUpdateStatusParams{ctx, updateStatus}

	// Record call args
	mmListKnowledgeBasesByUpdateStatus.ListKnowledgeBasesByUpdateStatusMock.mutex.Lock()
	mmListKnowledgeBasesByUpdateStatus.ListKnowledgeBasesByUpdateStatusMock.callArgs = append(mmListKnowledgeBasesByUpdateStatus.ListKnowledgeBasesByUpdateStatusMock.callArgs, &mm_params)
	mmListKnowledgeBasesByUpdateStatus.ListKnowledgeBasesByUpdateStatusMock.mutex.Unlock()

	for _, e := range mmListKnowledgeBasesByUpdateStatus.ListKnowledgeBasesByUpdateStatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmListKnowledgeBasesByUpdateStatus.ListKnowledgeBasesByUpdateStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListKnowledgeBasesByUpdateStatus.ListKnowledgeBasesByUpdateStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmListKnowledgeBasesByUpdateStatus.ListKnowledgeBasesByUpdateStatusMock.defaultExpectation.params
		mm_want_ptrs := mmListKnowledgeBasesByUpdateStatus.ListKnowledgeBasesByUpdateStatusMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListKnowledgeBasesByUpdateStatusParams{ctx, updateStatus}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListKnowledgeBasesByUpdateStatus.t.Errorf("RepositoryMock.ListKnowledgeBasesByUpdateStatus got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBasesByUpdateStatus.ListKnowledgeBasesByUpdateStatusMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.updateStatus != nil && !minimock.Equal(*mm_want_ptrs.updateStatus, mm_got.updateStatus) {
				mmListKnowledgeBasesByUpdateStatus.t.Errorf("RepositoryMock.ListKnowledgeBasesByUpdateStatus got unexpected parameter updateStatus, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBasesByUpdateStatus.ListKnowledgeBasesByUpdateStatusMock.defaultExpectation.expectationOrigins.originUpdateStatus, *mm_want_ptrs.updateStatus, mm_got.updateStatus, minimock.Diff(*mm_want_ptrs.updateStatus, mm_got.updateStatus))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListKnowledgeBasesByUpdateStatus.t.Errorf("RepositoryMock.ListKnowledgeBasesByUpdateStatus got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListKnowledgeBasesByUpdateStatus.ListKnowledgeBasesByUpdateStatusMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListKnowledgeBasesByUpdateStatus.ListKnowledgeBasesByUpdateStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmListKnowledgeBasesByUpdateStatus.t.Fatal("No results are set for the RepositoryMock.ListKnowledgeBasesByUpdateStatus")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmListKnowledgeBasesByUpdateStatus.funcListKnowledgeBasesByUpdateStatus != nil {
		return mmListKnowledgeBasesByUpdateStatus.funcListKnowledgeBasesByUpdateStatus(ctx, updateStatus)
	}
	mmListKnowledgeBasesByUpdateStatus.t.Fatalf("Unexpected call to RepositoryMock.ListKnowledgeBasesByUpdateStatus. %v %v", ctx, updateStatus)
	return
}

// ListKnowledgeBasesByUpdateStatusAfterCounter returns a count of finished RepositoryMock.ListKnowledgeBasesByUpdateStatus invocations
func (mmListKnowledgeBasesByUpdateStatus *RepositoryMock) ListKnowledgeBasesByUpdateStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBasesByUpdateStatus.afterListKnowledgeBasesByUpdateStatusCounter)
}

// ListKnowledgeBasesByUpdateStatusBeforeCounter returns a count of RepositoryMock.ListKnowledgeBasesByUpdateStatus invocations
func (mmListKnowledgeBasesByUpdateStatus *RepositoryMock) ListKnowledgeBasesByUpdateStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBasesByUpdateStatus.beforeListKnowledgeBasesByUpdateStatusCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListKnowledgeBasesByUpdateStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListKnowledgeBasesByUpdateStatus *mRepositoryMockListKnowledgeBasesByUpdateStatus) Calls() []*RepositoryMockListKnowledgeBasesByUpdateStatusParams {
	mmListKnowledgeBasesByUpdateStatus.mutex.RLock()

	argCopy := make([]*RepositoryMockListKnowledgeBasesByUpdateStatusParams, len(mmListKnowledgeBasesByUpdateStatus.callArgs))
	copy(argCopy, mmListKnowledgeBasesByUpdateStatus.callArgs)

	mmListKnowledgeBasesByUpdateStatus.mutex.RUnlock()

	return argCopy
}

// MinimockListKnowledgeBasesByUpdateStatusDone returns true if the count of the ListKnowledgeBasesByUpdateStatus invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListKnowledgeBasesByUpdateStatusDone() bool {
	if m.ListKnowledgeBasesByUpdateStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListKnowledgeBasesByUpdateStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListKnowledgeBasesByUpdateStatusMock.invocationsDone()
}

// MinimockListKnowledgeBasesByUpdateStatusInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListKnowledgeBasesByUpdateStatusInspect() {
	for _, e := range m.ListKnowledgeBasesByUpdateStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBasesByUpdateStatus at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListKnowledgeBasesByUpdateStatusCounter := mm_atomic.LoadUint64(&m.afterListKnowledgeBasesByUpdateStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListKnowledgeBasesByUpdateStatusMock.defaultExpectation != nil && afterListKnowledgeBasesByUpdateStatusCounter < 1 {
		if m.ListKnowledgeBasesByUpdateStatusMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBasesByUpdateStatus at\n%s", m.ListKnowledgeBasesByUpdateStatusMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBasesByUpdateStatus at\n%s with params: %#v", m.ListKnowledgeBasesByUpdateStatusMock.defaultExpectation.expectationOrigins.origin, *m.ListKnowledgeBasesByUpdateStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListKnowledgeBasesByUpdateStatus != nil && afterListKnowledgeBasesByUpdateStatusCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBasesByUpdateStatus at\n%s", m.funcListKnowledgeBasesByUpdateStatusOrigin)
	}

	if !m.ListKnowledgeBasesByUpdateStatusMock.invocationsDone() && afterListKnowledgeBasesByUpdateStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListKnowledgeBasesByUpdateStatus at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListKnowledgeBasesByUpdateStatusMock.expectedInvocations), m.ListKnowledgeBasesByUpdateStatusMock.expectedInvocationsOrigin, afterListKnowledgeBasesByUpdateStatusCounter)
	}
}

type mRepositoryMockListKnowledgeBasesForUpdate struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListKnowledgeBasesForUpdateExpectation
	expectations       []*RepositoryMockListKnowledgeBasesForUpdateExpectation

	callArgs []*RepositoryMockListKnowledgeBasesForUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListKnowledgeBasesForUpdateExpectation specifies expectation struct of the Repository.ListKnowledgeBasesForUpdate
type RepositoryMockListKnowledgeBasesForUpdateExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListKnowledgeBasesForUpdateParams
	paramPtrs          *RepositoryMockListKnowledgeBasesForUpdateParamPtrs
	expectationOrigins RepositoryMockListKnowledgeBasesForUpdateExpectationOrigins
	results            *RepositoryMockListKnowledgeBasesForUpdateResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListKnowledgeBasesForUpdateParams contains parameters of the Repository.ListKnowledgeBasesForUpdate
type RepositoryMockListKnowledgeBasesForUpdateParams struct {
	ctx              context.Context
	tagFilters       []string
	knowledgeBaseIDs []string
}

// RepositoryMockListKnowledgeBasesForUpdateParamPtrs contains pointers to parameters of the Repository.ListKnowledgeBasesForUpdate
type RepositoryMockListKnowledgeBasesForUpdateParamPtrs struct {
	ctx              *context.Context
	tagFilters       *[]string
	knowledgeBaseIDs *[]string
}

// RepositoryMockListKnowledgeBasesForUpdateResults contains results of the Repository.ListKnowledgeBasesForUpdate
type RepositoryMockListKnowledgeBasesForUpdateResults struct {
	ka1 []mm_repository.KnowledgeBaseModel
	err error
}

// RepositoryMockListKnowledgeBasesForUpdateOrigins contains origins of expectations of the Repository.ListKnowledgeBasesForUpdate
type RepositoryMockListKnowledgeBasesForUpdateExpectationOrigins struct {
	origin                 string
	originCtx              string
	originTagFilters       string
	originKnowledgeBaseIDs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListKnowledgeBasesForUpdate *mRepositoryMockListKnowledgeBasesForUpdate) Optional() *mRepositoryMockListKnowledgeBasesForUpdate {
	mmListKnowledgeBasesForUpdate.optional = true
	return mmListKnowledgeBasesForUpdate
}

// Expect sets up expected params for Repository.ListKnowledgeBasesForUpdate
func (mmListKnowledgeBasesForUpdate *mRepositoryMockListKnowledgeBasesForUpdate) Expect(ctx context.Context, tagFilters []string, knowledgeBaseIDs []string) *mRepositoryMockListKnowledgeBasesForUpdate {
	if mmListKnowledgeBasesForUpdate.mock.funcListKnowledgeBasesForUpdate != nil {
		mmListKnowledgeBasesForUpdate.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesForUpdate mock is already set by Set")
	}

	if mmListKnowledgeBasesForUpdate.defaultExpectation == nil {
		mmListKnowledgeBasesForUpdate.defaultExpectation = &RepositoryMockListKnowledgeBasesForUpdateExpectation{}
	}

	if mmListKnowledgeBasesForUpdate.defaultExpectation.paramPtrs != nil {
		mmListKnowledgeBasesForUpdate.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesForUpdate mock is already set by ExpectParams functions")
	}

	mmListKnowledgeBasesForUpdate.defaultExpectation.params = &RepositoryMockListKnowledgeBasesForUpdateParams{ctx, tagFilters, knowledgeBaseIDs}
	mmListKnowledgeBasesForUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListKnowledgeBasesForUpdate.expectations {
		if minimock.Equal(e.params, mmListKnowledgeBasesForUpdate.defaultExpectation.params) {
			mmListKnowledgeBasesForUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListKnowledgeBasesForUpdate.defaultExpectation.params)
		}
	}

	return mmListKnowledgeBasesForUpdate
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListKnowledgeBasesForUpdate
func (mmListKnowledgeBasesForUpdate *mRepositoryMockListKnowledgeBasesForUpdate) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListKnowledgeBasesForUpdate {
	if mmListKnowledgeBasesForUpdate.mock.funcListKnowledgeBasesForUpdate != nil {
		mmListKnowledgeBasesForUpdate.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesForUpdate mock is already set by Set")
	}

	if mmListKnowledgeBasesForUpdate.defaultExpectation == nil {
		mmListKnowledgeBasesForUpdate.defaultExpectation = &RepositoryMockListKnowledgeBasesForUpdateExpectation{}
	}

	if mmListKnowledgeBasesForUpdate.defaultExpectation.params != nil {
		mmListKnowledgeBasesForUpdate.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesForUpdate mock is already set by Expect")
	}

	if mmListKnowledgeBasesForUpdate.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBasesForUpdate.defaultExpectation.paramPtrs = &RepositoryMockListKnowledgeBasesForUpdateParamPtrs{}
	}
	mmListKnowledgeBasesForUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmListKnowledgeBasesForUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListKnowledgeBasesForUpdate
}

// ExpectTagFiltersParam2 sets up expected param tagFilters for Repository.ListKnowledgeBasesForUpdate
func (mmListKnowledgeBasesForUpdate *mRepositoryMockListKnowledgeBasesForUpdate) ExpectTagFiltersParam2(tagFilters []string) *mRepositoryMockListKnowledgeBasesForUpdate {
	if mmListKnowledgeBasesForUpdate.mock.funcListKnowledgeBasesForUpdate != nil {
		mmListKnowledgeBasesForUpdate.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesForUpdate mock is already set by Set")
	}

	if mmListKnowledgeBasesForUpdate.defaultExpectation == nil {
		mmListKnowledgeBasesForUpdate.defaultExpectation = &RepositoryMockListKnowledgeBasesForUpdateExpectation{}
	}

	if mmListKnowledgeBasesForUpdate.defaultExpectation.params != nil {
		mmListKnowledgeBasesForUpdate.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesForUpdate mock is already set by Expect")
	}

	if mmListKnowledgeBasesForUpdate.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBasesForUpdate.defaultExpectation.paramPtrs = &RepositoryMockListKnowledgeBasesForUpdateParamPtrs{}
	}
	mmListKnowledgeBasesForUpdate.defaultExpectation.paramPtrs.tagFilters = &tagFilters
	mmListKnowledgeBasesForUpdate.defaultExpectation.expectationOrigins.originTagFilters = minimock.CallerInfo(1)

	return mmListKnowledgeBasesForUpdate
}

// ExpectKnowledgeBaseIDsParam3 sets up expected param knowledgeBaseIDs for Repository.ListKnowledgeBasesForUpdate
func (mmListKnowledgeBasesForUpdate *mRepositoryMockListKnowledgeBasesForUpdate) ExpectKnowledgeBaseIDsParam3(knowledgeBaseIDs []string) *mRepositoryMockListKnowledgeBasesForUpdate {
	if mmListKnowledgeBasesForUpdate.mock.funcListKnowledgeBasesForUpdate != nil {
		mmListKnowledgeBasesForUpdate.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesForUpdate mock is already set by Set")
	}

	if mmListKnowledgeBasesForUpdate.defaultExpectation == nil {
		mmListKnowledgeBasesForUpdate.defaultExpectation = &RepositoryMockListKnowledgeBasesForUpdateExpectation{}
	}

	if mmListKnowledgeBasesForUpdate.defaultExpectation.params != nil {
		mmListKnowledgeBasesForUpdate.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesForUpdate mock is already set by Expect")
	}

	if mmListKnowledgeBasesForUpdate.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBasesForUpdate.defaultExpectation.paramPtrs = &RepositoryMockListKnowledgeBasesForUpdateParamPtrs{}
	}
	mmListKnowledgeBasesForUpdate.defaultExpectation.paramPtrs.knowledgeBaseIDs = &knowledgeBaseIDs
	mmListKnowledgeBasesForUpdate.defaultExpectation.expectationOrigins.originKnowledgeBaseIDs = minimock.CallerInfo(1)

	return mmListKnowledgeBasesForUpdate
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListKnowledgeBasesForUpdate
func (mmListKnowledgeBasesForUpdate *mRepositoryMockListKnowledgeBasesForUpdate) Inspect(f func(ctx context.Context, tagFilters []string, knowledgeBaseIDs []string)) *mRepositoryMockListKnowledgeBasesForUpdate {
	if mmListKnowledgeBasesForUpdate.mock.inspectFuncListKnowledgeBasesForUpdate != nil {
		mmListKnowledgeBasesForUpdate.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListKnowledgeBasesForUpdate")
	}

	mmListKnowledgeBasesForUpdate.mock.inspectFuncListKnowledgeBasesForUpdate = f

	return mmListKnowledgeBasesForUpdate
}

// Return sets up results that will be returned by Repository.ListKnowledgeBasesForUpdate
func (mmListKnowledgeBasesForUpdate *mRepositoryMockListKnowledgeBasesForUpdate) Return(ka1 []mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	if mmListKnowledgeBasesForUpdate.mock.funcListKnowledgeBasesForUpdate != nil {
		mmListKnowledgeBasesForUpdate.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesForUpdate mock is already set by Set")
	}

	if mmListKnowledgeBasesForUpdate.defaultExpectation == nil {
		mmListKnowledgeBasesForUpdate.defaultExpectation = &RepositoryMockListKnowledgeBasesForUpdateExpectation{mock: mmListKnowledgeBasesForUpdate.mock}
	}
	mmListKnowledgeBasesForUpdate.defaultExpectation.results = &RepositoryMockListKnowledgeBasesForUpdateResults{ka1, err}
	mmListKnowledgeBasesForUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBasesForUpdate.mock
}

// Set uses given function f to mock the Repository.ListKnowledgeBasesForUpdate method
func (mmListKnowledgeBasesForUpdate *mRepositoryMockListKnowledgeBasesForUpdate) Set(f func(ctx context.Context, tagFilters []string, knowledgeBaseIDs []string) (ka1 []mm_repository.KnowledgeBaseModel, err error)) *RepositoryMock {
	if mmListKnowledgeBasesForUpdate.defaultExpectation != nil {
		mmListKnowledgeBasesForUpdate.mock.t.Fatalf("Default expectation is already set for the Repository.ListKnowledgeBasesForUpdate method")
	}

	if len(mmListKnowledgeBasesForUpdate.expectations) > 0 {
		mmListKnowledgeBasesForUpdate.mock.t.Fatalf("Some expectations are already set for the Repository.ListKnowledgeBasesForUpdate method")
	}

	mmListKnowledgeBasesForUpdate.mock.funcListKnowledgeBasesForUpdate = f
	mmListKnowledgeBasesForUpdate.mock.funcListKnowledgeBasesForUpdateOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBasesForUpdate.mock
}

// When sets expectation for the Repository.ListKnowledgeBasesForUpdate which will trigger the result defined by the following
// Then helper
func (mmListKnowledgeBasesForUpdate *mRepositoryMockListKnowledgeBasesForUpdate) When(ctx context.Context, tagFilters []string, knowledgeBaseIDs []string) *RepositoryMockListKnowledgeBasesForUpdateExpectation {
	if mmListKnowledgeBasesForUpdate.mock.funcListKnowledgeBasesForUpdate != nil {
		mmListKnowledgeBasesForUpdate.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesForUpdate mock is already set by Set")
	}

	expectation := &RepositoryMockListKnowledgeBasesForUpdateExpectation{
		mock:               mmListKnowledgeBasesForUpdate.mock,
		params:             &RepositoryMockListKnowledgeBasesForUpdateParams{ctx, tagFilters, knowledgeBaseIDs},
		expectationOrigins: RepositoryMockListKnowledgeBasesForUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListKnowledgeBasesForUpdate.expectations = append(mmListKnowledgeBasesForUpdate.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListKnowledgeBasesForUpdate return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListKnowledgeBasesForUpdateExpectation) Then(ka1 []mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	e.results = &RepositoryMockListKnowledgeBasesForUpdateResults{ka1, err}
	return e.mock
}

// Times sets number of times Repository.ListKnowledgeBasesForUpdate should be invoked
func (mmListKnowledgeBasesForUpdate *mRepositoryMockListKnowledgeBasesForUpdate) Times(n uint64) *mRepositoryMockListKnowledgeBasesForUpdate {
	if n == 0 {
		mmListKnowledgeBasesForUpdate.mock.t.Fatalf("Times of RepositoryMock.ListKnowledgeBasesForUpdate mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListKnowledgeBasesForUpdate.expectedInvocations, n)
	mmListKnowledgeBasesForUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBasesForUpdate
}

func (mmListKnowledgeBasesForUpdate *mRepositoryMockListKnowledgeBasesForUpdate) invocationsDone() bool {
	if len(mmListKnowledgeBasesForUpdate.expectations) == 0 && mmListKnowledgeBasesForUpdate.defaultExpectation == nil && mmListKnowledgeBasesForUpdate.mock.funcListKnowledgeBasesForUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBasesForUpdate.mock.afterListKnowledgeBasesForUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBasesForUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListKnowledgeBasesForUpdate implements mm_repository.Repository
func (mmListKnowledgeBasesForUpdate *RepositoryMock) ListKnowledgeBasesForUpdate(ctx context.Context, tagFilters []string, knowledgeBaseIDs []string) (ka1 []mm_repository.KnowledgeBaseModel, err error) {
	mm_atomic.AddUint64(&mmListKnowledgeBasesForUpdate.beforeListKnowledgeBasesForUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmListKnowledgeBasesForUpdate.afterListKnowledgeBasesForUpdateCounter, 1)

	mmListKnowledgeBasesForUpdate.t.Helper()

	if mmListKnowledgeBasesForUpdate.inspectFuncListKnowledgeBasesForUpdate != nil {
		mmListKnowledgeBasesForUpdate.inspectFuncListKnowledgeBasesForUpdate(ctx, tagFilters, knowledgeBaseIDs)
	}

	mm_params := RepositoryMockListKnowledgeBasesForUpdateParams{ctx, tagFilters, knowledgeBaseIDs}

	// Record call args
	mmListKnowledgeBasesForUpdate.ListKnowledgeBasesForUpdateMock.mutex.Lock()
	mmListKnowledgeBasesForUpdate.ListKnowledgeBasesForUpdateMock.callArgs = append(mmListKnowledgeBasesForUpdate.ListKnowledgeBasesForUpdateMock.callArgs, &mm_params)
	mmListKnowledgeBasesForUpdate.ListKnowledgeBasesForUpdateMock.mutex.Unlock()

	for _, e := range mmListKnowledgeBasesForUpdate.ListKnowledgeBasesForUpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmListKnowledgeBasesForUpdate.ListKnowledgeBasesForUpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListKnowledgeBasesForUpdate.ListKnowledgeBasesForUpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmListKnowledgeBasesForUpdate.ListKnowledgeBasesForUpdateMock.defaultExpectation.params
		mm_want_ptrs := mmListKnowledgeBasesForUpdate.ListKnowledgeBasesForUpdateMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListKnowledgeBasesForUpdateParams{ctx, tagFilters, knowledgeBaseIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListKnowledgeBasesForUpdate.t.Errorf("RepositoryMock.ListKnowledgeBasesForUpdate got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBasesForUpdate.ListKnowledgeBasesForUpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tagFilters != nil && !minimock.Equal(*mm_want_ptrs.tagFilters, mm_got.tagFilters) {
				mmListKnowledgeBasesForUpdate.t.Errorf("RepositoryMock.ListKnowledgeBasesForUpdate got unexpected parameter tagFilters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBasesForUpdate.ListKnowledgeBasesForUpdateMock.defaultExpectation.expectationOrigins.originTagFilters, *mm_want_ptrs.tagFilters, mm_got.tagFilters, minimock.Diff(*mm_want_ptrs.tagFilters, mm_got.tagFilters))
			}

			if mm_want_ptrs.knowledgeBaseIDs != nil && !minimock.Equal(*mm_want_ptrs.knowledgeBaseIDs, mm_got.knowledgeBaseIDs) {
				mmListKnowledgeBasesForUpdate.t.Errorf("RepositoryMock.ListKnowledgeBasesForUpdate got unexpected parameter knowledgeBaseIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBasesForUpdate.ListKnowledgeBasesForUpdateMock.defaultExpectation.expectationOrigins.originKnowledgeBaseIDs, *mm_want_ptrs.knowledgeBaseIDs, mm_got.knowledgeBaseIDs, minimock.Diff(*mm_want_ptrs.knowledgeBaseIDs, mm_got.knowledgeBaseIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListKnowledgeBasesForUpdate.t.Errorf("RepositoryMock.ListKnowledgeBasesForUpdate got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListKnowledgeBasesForUpdate.ListKnowledgeBasesForUpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListKnowledgeBasesForUpdate.ListKnowledgeBasesForUpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmListKnowledgeBasesForUpdate.t.Fatal("No results are set for the RepositoryMock.ListKnowledgeBasesForUpdate")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmListKnowledgeBasesForUpdate.funcListKnowledgeBasesForUpdate != nil {
		return mmListKnowledgeBasesForUpdate.funcListKnowledgeBasesForUpdate(ctx, tagFilters, knowledgeBaseIDs)
	}
	mmListKnowledgeBasesForUpdate.t.Fatalf("Unexpected call to RepositoryMock.ListKnowledgeBasesForUpdate. %v %v %v", ctx, tagFilters, knowledgeBaseIDs)
	return
}

// ListKnowledgeBasesForUpdateAfterCounter returns a count of finished RepositoryMock.ListKnowledgeBasesForUpdate invocations
func (mmListKnowledgeBasesForUpdate *RepositoryMock) ListKnowledgeBasesForUpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBasesForUpdate.afterListKnowledgeBasesForUpdateCounter)
}

// ListKnowledgeBasesForUpdateBeforeCounter returns a count of RepositoryMock.ListKnowledgeBasesForUpdate invocations
func (mmListKnowledgeBasesForUpdate *RepositoryMock) ListKnowledgeBasesForUpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBasesForUpdate.beforeListKnowledgeBasesForUpdateCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListKnowledgeBasesForUpdate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListKnowledgeBasesForUpdate *mRepositoryMockListKnowledgeBasesForUpdate) Calls() []*RepositoryMockListKnowledgeBasesForUpdateParams {
	mmListKnowledgeBasesForUpdate.mutex.RLock()

	argCopy := make([]*RepositoryMockListKnowledgeBasesForUpdateParams, len(mmListKnowledgeBasesForUpdate.callArgs))
	copy(argCopy, mmListKnowledgeBasesForUpdate.callArgs)

	mmListKnowledgeBasesForUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockListKnowledgeBasesForUpdateDone returns true if the count of the ListKnowledgeBasesForUpdate invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListKnowledgeBasesForUpdateDone() bool {
	if m.ListKnowledgeBasesForUpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListKnowledgeBasesForUpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListKnowledgeBasesForUpdateMock.invocationsDone()
}

// MinimockListKnowledgeBasesForUpdateInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListKnowledgeBasesForUpdateInspect() {
	for _, e := range m.ListKnowledgeBasesForUpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBasesForUpdate at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListKnowledgeBasesForUpdateCounter := mm_atomic.LoadUint64(&m.afterListKnowledgeBasesForUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListKnowledgeBasesForUpdateMock.defaultExpectation != nil && afterListKnowledgeBasesForUpdateCounter < 1 {
		if m.ListKnowledgeBasesForUpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBasesForUpdate at\n%s", m.ListKnowledgeBasesForUpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBasesForUpdate at\n%s with params: %#v", m.ListKnowledgeBasesForUpdateMock.defaultExpectation.expectationOrigins.origin, *m.ListKnowledgeBasesForUpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListKnowledgeBasesForUpdate != nil && afterListKnowledgeBasesForUpdateCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBasesForUpdate at\n%s", m.funcListKnowledgeBasesForUpdateOrigin)
	}

	if !m.ListKnowledgeBasesForUpdateMock.invocationsDone() && afterListKnowledgeBasesForUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListKnowledgeBasesForUpdate at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListKnowledgeBasesForUpdateMock.expectedInvocations), m.ListKnowledgeBasesForUpdateMock.expectedInvocationsOrigin, afterListKnowledgeBasesForUpdateCounter)
	}
}

type mRepositoryMockListSystems struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListSystemsExpectation
	expectations       []*RepositoryMockListSystemsExpectation

	callArgs []*RepositoryMockListSystemsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListSystemsExpectation specifies expectation struct of the Repository.ListSystems
type RepositoryMockListSystemsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListSystemsParams
	paramPtrs          *RepositoryMockListSystemsParamPtrs
	expectationOrigins RepositoryMockListSystemsExpectationOrigins
	results            *RepositoryMockListSystemsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListSystemsParams contains parameters of the Repository.ListSystems
type RepositoryMockListSystemsParams struct {
	ctx context.Context
}

// RepositoryMockListSystemsParamPtrs contains pointers to parameters of the Repository.ListSystems
type RepositoryMockListSystemsParamPtrs struct {
	ctx *context.Context
}

// RepositoryMockListSystemsResults contains results of the Repository.ListSystems
type RepositoryMockListSystemsResults struct {
	sa1 []mm_repository.SystemModel
	err error
}

// RepositoryMockListSystemsOrigins contains origins of expectations of the Repository.ListSystems
type RepositoryMockListSystemsExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListSystems *mRepositoryMockListSystems) Optional() *mRepositoryMockListSystems {
	mmListSystems.optional = true
	return mmListSystems
}

// Expect sets up expected params for Repository.ListSystems
func (mmListSystems *mRepositoryMockListSystems) Expect(ctx context.Context) *mRepositoryMockListSystems {
	if mmListSystems.mock.funcListSystems != nil {
		mmListSystems.mock.t.Fatalf("RepositoryMock.ListSystems mock is already set by Set")
	}

	if mmListSystems.defaultExpectation == nil {
		mmListSystems.defaultExpectation = &RepositoryMockListSystemsExpectation{}
	}

	if mmListSystems.defaultExpectation.paramPtrs != nil {
		mmListSystems.mock.t.Fatalf("RepositoryMock.ListSystems mock is already set by ExpectParams functions")
	}

	mmListSystems.defaultExpectation.params = &RepositoryMockListSystemsParams{ctx}
	mmListSystems.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListSystems.expectations {
		if minimock.Equal(e.params, mmListSystems.defaultExpectation.params) {
			mmListSystems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListSystems.defaultExpectation.params)
		}
	}

	return mmListSystems
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListSystems
func (mmListSystems *mRepositoryMockListSystems) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListSystems {
	if mmListSystems.mock.funcListSystems != nil {
		mmListSystems.mock.t.Fatalf("RepositoryMock.ListSystems mock is already set by Set")
	}

	if mmListSystems.defaultExpectation == nil {
		mmListSystems.defaultExpectation = &RepositoryMockListSystemsExpectation{}
	}

	if mmListSystems.defaultExpectation.params != nil {
		mmListSystems.mock.t.Fatalf("RepositoryMock.ListSystems mock is already set by Expect")
	}

	if mmListSystems.defaultExpectation.paramPtrs == nil {
		mmListSystems.defaultExpectation.paramPtrs = &RepositoryMockListSystemsParamPtrs{}
	}
	mmListSystems.defaultExpectation.paramPtrs.ctx = &ctx
	mmListSystems.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListSystems
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListSystems
func (mmListSystems *mRepositoryMockListSystems) Inspect(f func(ctx context.Context)) *mRepositoryMockListSystems {
	if mmListSystems.mock.inspectFuncListSystems != nil {
		mmListSystems.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListSystems")
	}

	mmListSystems.mock.inspectFuncListSystems = f

	return mmListSystems
}

// Return sets up results that will be returned by Repository.ListSystems
func (mmListSystems *mRepositoryMockListSystems) Return(sa1 []mm_repository.SystemModel, err error) *RepositoryMock {
	if mmListSystems.mock.funcListSystems != nil {
		mmListSystems.mock.t.Fatalf("RepositoryMock.ListSystems mock is already set by Set")
	}

	if mmListSystems.defaultExpectation == nil {
		mmListSystems.defaultExpectation = &RepositoryMockListSystemsExpectation{mock: mmListSystems.mock}
	}
	mmListSystems.defaultExpectation.results = &RepositoryMockListSystemsResults{sa1, err}
	mmListSystems.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListSystems.mock
}

// Set uses given function f to mock the Repository.ListSystems method
func (mmListSystems *mRepositoryMockListSystems) Set(f func(ctx context.Context) (sa1 []mm_repository.SystemModel, err error)) *RepositoryMock {
	if mmListSystems.defaultExpectation != nil {
		mmListSystems.mock.t.Fatalf("Default expectation is already set for the Repository.ListSystems method")
	}

	if len(mmListSystems.expectations) > 0 {
		mmListSystems.mock.t.Fatalf("Some expectations are already set for the Repository.ListSystems method")
	}

	mmListSystems.mock.funcListSystems = f
	mmListSystems.mock.funcListSystemsOrigin = minimock.CallerInfo(1)
	return mmListSystems.mock
}

// When sets expectation for the Repository.ListSystems which will trigger the result defined by the following
// Then helper
func (mmListSystems *mRepositoryMockListSystems) When(ctx context.Context) *RepositoryMockListSystemsExpectation {
	if mmListSystems.mock.funcListSystems != nil {
		mmListSystems.mock.t.Fatalf("RepositoryMock.ListSystems mock is already set by Set")
	}

	expectation := &RepositoryMockListSystemsExpectation{
		mock:               mmListSystems.mock,
		params:             &RepositoryMockListSystemsParams{ctx},
		expectationOrigins: RepositoryMockListSystemsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListSystems.expectations = append(mmListSystems.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListSystems return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListSystemsExpectation) Then(sa1 []mm_repository.SystemModel, err error) *RepositoryMock {
	e.results = &RepositoryMockListSystemsResults{sa1, err}
	return e.mock
}

// Times sets number of times Repository.ListSystems should be invoked
func (mmListSystems *mRepositoryMockListSystems) Times(n uint64) *mRepositoryMockListSystems {
	if n == 0 {
		mmListSystems.mock.t.Fatalf("Times of RepositoryMock.ListSystems mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListSystems.expectedInvocations, n)
	mmListSystems.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListSystems
}

func (mmListSystems *mRepositoryMockListSystems) invocationsDone() bool {
	if len(mmListSystems.expectations) == 0 && mmListSystems.defaultExpectation == nil && mmListSystems.mock.funcListSystems == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListSystems.mock.afterListSystemsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListSystems.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListSystems implements mm_repository.Repository
func (mmListSystems *RepositoryMock) ListSystems(ctx context.Context) (sa1 []mm_repository.SystemModel, err error) {
	mm_atomic.AddUint64(&mmListSystems.beforeListSystemsCounter, 1)
	defer mm_atomic.AddUint64(&mmListSystems.afterListSystemsCounter, 1)

	mmListSystems.t.Helper()

	if mmListSystems.inspectFuncListSystems != nil {
		mmListSystems.inspectFuncListSystems(ctx)
	}

	mm_params := RepositoryMockListSystemsParams{ctx}

	// Record call args
	mmListSystems.ListSystemsMock.mutex.Lock()
	mmListSystems.ListSystemsMock.callArgs = append(mmListSystems.ListSystemsMock.callArgs, &mm_params)
	mmListSystems.ListSystemsMock.mutex.Unlock()

	for _, e := range mmListSystems.ListSystemsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmListSystems.ListSystemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListSystems.ListSystemsMock.defaultExpectation.Counter, 1)
		mm_want := mmListSystems.ListSystemsMock.defaultExpectation.params
		mm_want_ptrs := mmListSystems.ListSystemsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListSystemsParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListSystems.t.Errorf("RepositoryMock.ListSystems got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListSystems.ListSystemsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListSystems.t.Errorf("RepositoryMock.ListSystems got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListSystems.ListSystemsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListSystems.ListSystemsMock.defaultExpectation.results
		if mm_results == nil {
			mmListSystems.t.Fatal("No results are set for the RepositoryMock.ListSystems")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmListSystems.funcListSystems != nil {
		return mmListSystems.funcListSystems(ctx)
	}
	mmListSystems.t.Fatalf("Unexpected call to RepositoryMock.ListSystems. %v", ctx)
	return
}

// ListSystemsAfterCounter returns a count of finished RepositoryMock.ListSystems invocations
func (mmListSystems *RepositoryMock) ListSystemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSystems.afterListSystemsCounter)
}

// ListSystemsBeforeCounter returns a count of RepositoryMock.ListSystems invocations
func (mmListSystems *RepositoryMock) ListSystemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSystems.beforeListSystemsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListSystems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListSystems *mRepositoryMockListSystems) Calls() []*RepositoryMockListSystemsParams {
	mmListSystems.mutex.RLock()

	argCopy := make([]*RepositoryMockListSystemsParams, len(mmListSystems.callArgs))
	copy(argCopy, mmListSystems.callArgs)

	mmListSystems.mutex.RUnlock()

	return argCopy
}

// MinimockListSystemsDone returns true if the count of the ListSystems invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListSystemsDone() bool {
	if m.ListSystemsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListSystemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListSystemsMock.invocationsDone()
}

// MinimockListSystemsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListSystemsInspect() {
	for _, e := range m.ListSystemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListSystems at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListSystemsCounter := mm_atomic.LoadUint64(&m.afterListSystemsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListSystemsMock.defaultExpectation != nil && afterListSystemsCounter < 1 {
		if m.ListSystemsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListSystems at\n%s", m.ListSystemsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListSystems at\n%s with params: %#v", m.ListSystemsMock.defaultExpectation.expectationOrigins.origin, *m.ListSystemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListSystems != nil && afterListSystemsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListSystems at\n%s", m.funcListSystemsOrigin)
	}

	if !m.ListSystemsMock.invocationsDone() && afterListSystemsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListSystems at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListSystemsMock.expectedInvocations), m.ListSystemsMock.expectedInvocationsOrigin, afterListSystemsCounter)
	}
}

type mRepositoryMockListTextChunksByKBFileUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListTextChunksByKBFileUIDExpectation
	expectations       []*RepositoryMockListTextChunksByKBFileUIDExpectation

	callArgs []*RepositoryMockListTextChunksByKBFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListTextChunksByKBFileUIDExpectation specifies expectation struct of the Repository.ListTextChunksByKBFileUID
type RepositoryMockListTextChunksByKBFileUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListTextChunksByKBFileUIDParams
	paramPtrs          *RepositoryMockListTextChunksByKBFileUIDParamPtrs
	expectationOrigins RepositoryMockListTextChunksByKBFileUIDExpectationOrigins
	results            *RepositoryMockListTextChunksByKBFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListTextChunksByKBFileUIDParams contains parameters of the Repository.ListTextChunksByKBFileUID
type RepositoryMockListTextChunksByKBFileUIDParams struct {
	ctx       context.Context
	kbFileUID types.FileUIDType
}

// RepositoryMockListTextChunksByKBFileUIDParamPtrs contains pointers to parameters of the Repository.ListTextChunksByKBFileUID
type RepositoryMockListTextChunksByKBFileUIDParamPtrs struct {
	ctx       *context.Context
	kbFileUID *types.FileUIDType
}

// RepositoryMockListTextChunksByKBFileUIDResults contains results of the Repository.ListTextChunksByKBFileUID
type RepositoryMockListTextChunksByKBFileUIDResults struct {
	ta1 []mm_repository.TextChunkModel
	err error
}

// RepositoryMockListTextChunksByKBFileUIDOrigins contains origins of expectations of the Repository.ListTextChunksByKBFileUID
type RepositoryMockListTextChunksByKBFileUIDExpectationOrigins struct {
	origin          string
	originCtx       string
	originKbFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListTextChunksByKBFileUID *mRepositoryMockListTextChunksByKBFileUID) Optional() *mRepositoryMockListTextChunksByKBFileUID {
	mmListTextChunksByKBFileUID.optional = true
	return mmListTextChunksByKBFileUID
}

// Expect sets up expected params for Repository.ListTextChunksByKBFileUID
func (mmListTextChunksByKBFileUID *mRepositoryMockListTextChunksByKBFileUID) Expect(ctx context.Context, kbFileUID types.FileUIDType) *mRepositoryMockListTextChunksByKBFileUID {
	if mmListTextChunksByKBFileUID.mock.funcListTextChunksByKBFileUID != nil {
		mmListTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.ListTextChunksByKBFileUID mock is already set by Set")
	}

	if mmListTextChunksByKBFileUID.defaultExpectation == nil {
		mmListTextChunksByKBFileUID.defaultExpectation = &RepositoryMockListTextChunksByKBFileUIDExpectation{}
	}

	if mmListTextChunksByKBFileUID.defaultExpectation.paramPtrs != nil {
		mmListTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.ListTextChunksByKBFileUID mock is already set by ExpectParams functions")
	}

	mmListTextChunksByKBFileUID.defaultExpectation.params = &RepositoryMockListTextChunksByKBFileUIDParams{ctx, kbFileUID}
	mmListTextChunksByKBFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListTextChunksByKBFileUID.expectations {
		if minimock.Equal(e.params, mmListTextChunksByKBFileUID.defaultExpectation.params) {
			mmListTextChunksByKBFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListTextChunksByKBFileUID.defaultExpectation.params)
		}
	}

	return mmListTextChunksByKBFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListTextChunksByKBFileUID
func (mmListTextChunksByKBFileUID *mRepositoryMockListTextChunksByKBFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListTextChunksByKBFileUID {
	if mmListTextChunksByKBFileUID.mock.funcListTextChunksByKBFileUID != nil {
		mmListTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.ListTextChunksByKBFileUID mock is already set by Set")
	}

	if mmListTextChunksByKBFileUID.defaultExpectation == nil {
		mmListTextChunksByKBFileUID.defaultExpectation = &RepositoryMockListTextChunksByKBFileUIDExpectation{}
	}

	if mmListTextChunksByKBFileUID.defaultExpectation.params != nil {
		mmListTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.ListTextChunksByKBFileUID mock is already set by Expect")
	}

	if mmListTextChunksByKBFileUID.defaultExpectation.paramPtrs == nil {
		mmListTextChunksByKBFileUID.defaultExpectation.paramPtrs = &RepositoryMockListTextChunksByKBFileUIDParamPtrs{}
	}
	mmListTextChunksByKBFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmListTextChunksByKBFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListTextChunksByKBFileUID
}

// ExpectKbFileUIDParam2 sets up expected param kbFileUID for Repository.ListTextChunksByKBFileUID
func (mmListTextChunksByKBFileUID *mRepositoryMockListTextChunksByKBFileUID) ExpectKbFileUIDParam2(kbFileUID types.FileUIDType) *mRepositoryMockListTextChunksByKBFileUID {
	if mmListTextChunksByKBFileUID.mock.funcListTextChunksByKBFileUID != nil {
		mmListTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.ListTextChunksByKBFileUID mock is already set by Set")
	}

	if mmListTextChunksByKBFileUID.defaultExpectation == nil {
		mmListTextChunksByKBFileUID.defaultExpectation = &RepositoryMockListTextChunksByKBFileUIDExpectation{}
	}

	if mmListTextChunksByKBFileUID.defaultExpectation.params != nil {
		mmListTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.ListTextChunksByKBFileUID mock is already set by Expect")
	}

	if mmListTextChunksByKBFileUID.defaultExpectation.paramPtrs == nil {
		mmListTextChunksByKBFileUID.defaultExpectation.paramPtrs = &RepositoryMockListTextChunksByKBFileUIDParamPtrs{}
	}
	mmListTextChunksByKBFileUID.defaultExpectation.paramPtrs.kbFileUID = &kbFileUID
	mmListTextChunksByKBFileUID.defaultExpectation.expectationOrigins.originKbFileUID = minimock.CallerInfo(1)

	return mmListTextChunksByKBFileUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListTextChunksByKBFileUID
func (mmListTextChunksByKBFileUID *mRepositoryMockListTextChunksByKBFileUID) Inspect(f func(ctx context.Context, kbFileUID types.FileUIDType)) *mRepositoryMockListTextChunksByKBFileUID {
	if mmListTextChunksByKBFileUID.mock.inspectFuncListTextChunksByKBFileUID != nil {
		mmListTextChunksByKBFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListTextChunksByKBFileUID")
	}

	mmListTextChunksByKBFileUID.mock.inspectFuncListTextChunksByKBFileUID = f

	return mmListTextChunksByKBFileUID
}

// Return sets up results that will be returned by Repository.ListTextChunksByKBFileUID
func (mmListTextChunksByKBFileUID *mRepositoryMockListTextChunksByKBFileUID) Return(ta1 []mm_repository.TextChunkModel, err error) *RepositoryMock {
	if mmListTextChunksByKBFileUID.mock.funcListTextChunksByKBFileUID != nil {
		mmListTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.ListTextChunksByKBFileUID mock is already set by Set")
	}

	if mmListTextChunksByKBFileUID.defaultExpectation == nil {
		mmListTextChunksByKBFileUID.defaultExpectation = &RepositoryMockListTextChunksByKBFileUIDExpectation{mock: mmListTextChunksByKBFileUID.mock}
	}
	mmListTextChunksByKBFileUID.defaultExpectation.results = &RepositoryMockListTextChunksByKBFileUIDResults{ta1, err}
	mmListTextChunksByKBFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListTextChunksByKBFileUID.mock
}

// Set uses given function f to mock the Repository.ListTextChunksByKBFileUID method
func (mmListTextChunksByKBFileUID *mRepositoryMockListTextChunksByKBFileUID) Set(f func(ctx context.Context, kbFileUID types.FileUIDType) (ta1 []mm_repository.TextChunkModel, err error)) *RepositoryMock {
	if mmListTextChunksByKBFileUID.defaultExpectation != nil {
		mmListTextChunksByKBFileUID.mock.t.Fatalf("Default expectation is already set for the Repository.ListTextChunksByKBFileUID method")
	}

	if len(mmListTextChunksByKBFileUID.expectations) > 0 {
		mmListTextChunksByKBFileUID.mock.t.Fatalf("Some expectations are already set for the Repository.ListTextChunksByKBFileUID method")
	}

	mmListTextChunksByKBFileUID.mock.funcListTextChunksByKBFileUID = f
	mmListTextChunksByKBFileUID.mock.funcListTextChunksByKBFileUIDOrigin = minimock.CallerInfo(1)
	return mmListTextChunksByKBFileUID.mock
}

// When sets expectation for the Repository.ListTextChunksByKBFileUID which will trigger the result defined by the following
// Then helper
func (mmListTextChunksByKBFileUID *mRepositoryMockListTextChunksByKBFileUID) When(ctx context.Context, kbFileUID types.FileUIDType) *RepositoryMockListTextChunksByKBFileUIDExpectation {
	if mmListTextChunksByKBFileUID.mock.funcListTextChunksByKBFileUID != nil {
		mmListTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.ListTextChunksByKBFileUID mock is already set by Set")
	}

	expectation := &RepositoryMockListTextChunksByKBFileUIDExpectation{
		mock:               mmListTextChunksByKBFileUID.mock,
		params:             &RepositoryMockListTextChunksByKBFileUIDParams{ctx, kbFileUID},
		expectationOrigins: RepositoryMockListTextChunksByKBFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListTextChunksByKBFileUID.expectations = append(mmListTextChunksByKBFileUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListTextChunksByKBFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListTextChunksByKBFileUIDExpectation) Then(ta1 []mm_repository.TextChunkModel, err error) *RepositoryMock {
	e.results = &RepositoryMockListTextChunksByKBFileUIDResults{ta1, err}
	return e.mock
}

// Times sets number of times Repository.ListTextChunksByKBFileUID should be invoked
func (mmListTextChunksByKBFileUID *mRepositoryMockListTextChunksByKBFileUID) Times(n uint64) *mRepositoryMockListTextChunksByKBFileUID {
	if n == 0 {
		mmListTextChunksByKBFileUID.mock.t.Fatalf("Times of RepositoryMock.ListTextChunksByKBFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListTextChunksByKBFileUID.expectedInvocations, n)
	mmListTextChunksByKBFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListTextChunksByKBFileUID
}

func (mmListTextChunksByKBFileUID *mRepositoryMockListTextChunksByKBFileUID) invocationsDone() bool {
	if len(mmListTextChunksByKBFileUID.expectations) == 0 && mmListTextChunksByKBFileUID.defaultExpectation == nil && mmListTextChunksByKBFileUID.mock.funcListTextChunksByKBFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListTextChunksByKBFileUID.mock.afterListTextChunksByKBFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListTextChunksByKBFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListTextChunksByKBFileUID implements mm_repository.Repository
func (mmListTextChunksByKBFileUID *RepositoryMock) ListTextChunksByKBFileUID(ctx context.Context, kbFileUID types.FileUIDType) (ta1 []mm_repository.TextChunkModel, err error) {
	mm_atomic.AddUint64(&mmListTextChunksByKBFileUID.beforeListTextChunksByKBFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmListTextChunksByKBFileUID.afterListTextChunksByKBFileUIDCounter, 1)

	mmListTextChunksByKBFileUID.t.Helper()

	if mmListTextChunksByKBFileUID.inspectFuncListTextChunksByKBFileUID != nil {
		mmListTextChunksByKBFileUID.inspectFuncListTextChunksByKBFileUID(ctx, kbFileUID)
	}

	mm_params := RepositoryMockListTextChunksByKBFileUIDParams{ctx, kbFileUID}

	// Record call args
	mmListTextChunksByKBFileUID.ListTextChunksByKBFileUIDMock.mutex.Lock()
	mmListTextChunksByKBFileUID.ListTextChunksByKBFileUIDMock.callArgs = append(mmListTextChunksByKBFileUID.ListTextChunksByKBFileUIDMock.callArgs, &mm_params)
	mmListTextChunksByKBFileUID.ListTextChunksByKBFileUIDMock.mutex.Unlock()

	for _, e := range mmListTextChunksByKBFileUID.ListTextChunksByKBFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ta1, e.results.err
		}
	}

	if mmListTextChunksByKBFileUID.ListTextChunksByKBFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListTextChunksByKBFileUID.ListTextChunksByKBFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmListTextChunksByKBFileUID.ListTextChunksByKBFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmListTextChunksByKBFileUID.ListTextChunksByKBFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListTextChunksByKBFileUIDParams{ctx, kbFileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListTextChunksByKBFileUID.t.Errorf("RepositoryMock.ListTextChunksByKBFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTextChunksByKBFileUID.ListTextChunksByKBFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbFileUID != nil && !minimock.Equal(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID) {
				mmListTextChunksByKBFileUID.t.Errorf("RepositoryMock.ListTextChunksByKBFileUID got unexpected parameter kbFileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTextChunksByKBFileUID.ListTextChunksByKBFileUIDMock.defaultExpectation.expectationOrigins.originKbFileUID, *mm_want_ptrs.kbFileUID, mm_got.kbFileUID, minimock.Diff(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListTextChunksByKBFileUID.t.Errorf("RepositoryMock.ListTextChunksByKBFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListTextChunksByKBFileUID.ListTextChunksByKBFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListTextChunksByKBFileUID.ListTextChunksByKBFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmListTextChunksByKBFileUID.t.Fatal("No results are set for the RepositoryMock.ListTextChunksByKBFileUID")
		}
		return (*mm_results).ta1, (*mm_results).err
	}
	if mmListTextChunksByKBFileUID.funcListTextChunksByKBFileUID != nil {
		return mmListTextChunksByKBFileUID.funcListTextChunksByKBFileUID(ctx, kbFileUID)
	}
	mmListTextChunksByKBFileUID.t.Fatalf("Unexpected call to RepositoryMock.ListTextChunksByKBFileUID. %v %v", ctx, kbFileUID)
	return
}

// ListTextChunksByKBFileUIDAfterCounter returns a count of finished RepositoryMock.ListTextChunksByKBFileUID invocations
func (mmListTextChunksByKBFileUID *RepositoryMock) ListTextChunksByKBFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTextChunksByKBFileUID.afterListTextChunksByKBFileUIDCounter)
}

// ListTextChunksByKBFileUIDBeforeCounter returns a count of RepositoryMock.ListTextChunksByKBFileUID invocations
func (mmListTextChunksByKBFileUID *RepositoryMock) ListTextChunksByKBFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTextChunksByKBFileUID.beforeListTextChunksByKBFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListTextChunksByKBFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListTextChunksByKBFileUID *mRepositoryMockListTextChunksByKBFileUID) Calls() []*RepositoryMockListTextChunksByKBFileUIDParams {
	mmListTextChunksByKBFileUID.mutex.RLock()

	argCopy := make([]*RepositoryMockListTextChunksByKBFileUIDParams, len(mmListTextChunksByKBFileUID.callArgs))
	copy(argCopy, mmListTextChunksByKBFileUID.callArgs)

	mmListTextChunksByKBFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockListTextChunksByKBFileUIDDone returns true if the count of the ListTextChunksByKBFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListTextChunksByKBFileUIDDone() bool {
	if m.ListTextChunksByKBFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListTextChunksByKBFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListTextChunksByKBFileUIDMock.invocationsDone()
}

// MinimockListTextChunksByKBFileUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListTextChunksByKBFileUIDInspect() {
	for _, e := range m.ListTextChunksByKBFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListTextChunksByKBFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListTextChunksByKBFileUIDCounter := mm_atomic.LoadUint64(&m.afterListTextChunksByKBFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListTextChunksByKBFileUIDMock.defaultExpectation != nil && afterListTextChunksByKBFileUIDCounter < 1 {
		if m.ListTextChunksByKBFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListTextChunksByKBFileUID at\n%s", m.ListTextChunksByKBFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListTextChunksByKBFileUID at\n%s with params: %#v", m.ListTextChunksByKBFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.ListTextChunksByKBFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListTextChunksByKBFileUID != nil && afterListTextChunksByKBFileUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListTextChunksByKBFileUID at\n%s", m.funcListTextChunksByKBFileUIDOrigin)
	}

	if !m.ListTextChunksByKBFileUIDMock.invocationsDone() && afterListTextChunksByKBFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListTextChunksByKBFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListTextChunksByKBFileUIDMock.expectedInvocations), m.ListTextChunksByKBFileUIDMock.expectedInvocationsOrigin, afterListTextChunksByKBFileUIDCounter)
	}
}

type mRepositoryMockProcessKnowledgeBaseFiles struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockProcessKnowledgeBaseFilesExpectation
	expectations       []*RepositoryMockProcessKnowledgeBaseFilesExpectation

	callArgs []*RepositoryMockProcessKnowledgeBaseFilesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockProcessKnowledgeBaseFilesExpectation specifies expectation struct of the Repository.ProcessKnowledgeBaseFiles
type RepositoryMockProcessKnowledgeBaseFilesExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockProcessKnowledgeBaseFilesParams
	paramPtrs          *RepositoryMockProcessKnowledgeBaseFilesParamPtrs
	expectationOrigins RepositoryMockProcessKnowledgeBaseFilesExpectationOrigins
	results            *RepositoryMockProcessKnowledgeBaseFilesResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockProcessKnowledgeBaseFilesParams contains parameters of the Repository.ProcessKnowledgeBaseFiles
type RepositoryMockProcessKnowledgeBaseFilesParams struct {
	ctx       context.Context
	fileUIDs  []string
	requester types.RequesterUIDType
}

// RepositoryMockProcessKnowledgeBaseFilesParamPtrs contains pointers to parameters of the Repository.ProcessKnowledgeBaseFiles
type RepositoryMockProcessKnowledgeBaseFilesParamPtrs struct {
	ctx       *context.Context
	fileUIDs  *[]string
	requester *types.RequesterUIDType
}

// RepositoryMockProcessKnowledgeBaseFilesResults contains results of the Repository.ProcessKnowledgeBaseFiles
type RepositoryMockProcessKnowledgeBaseFilesResults struct {
	ka1 []mm_repository.KnowledgeBaseFileModel
	err error
}

// RepositoryMockProcessKnowledgeBaseFilesOrigins contains origins of expectations of the Repository.ProcessKnowledgeBaseFiles
type RepositoryMockProcessKnowledgeBaseFilesExpectationOrigins struct {
	origin          string
	originCtx       string
	originFileUIDs  string
	originRequester string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmProcessKnowledgeBaseFiles *mRepositoryMockProcessKnowledgeBaseFiles) Optional() *mRepositoryMockProcessKnowledgeBaseFiles {
	mmProcessKnowledgeBaseFiles.optional = true
	return mmProcessKnowledgeBaseFiles
}

// Expect sets up expected params for Repository.ProcessKnowledgeBaseFiles
func (mmProcessKnowledgeBaseFiles *mRepositoryMockProcessKnowledgeBaseFiles) Expect(ctx context.Context, fileUIDs []string, requester types.RequesterUIDType) *mRepositoryMockProcessKnowledgeBaseFiles {
	if mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ProcessKnowledgeBaseFiles mock is already set by Set")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation = &RepositoryMockProcessKnowledgeBaseFilesExpectation{}
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ProcessKnowledgeBaseFiles mock is already set by ExpectParams functions")
	}

	mmProcessKnowledgeBaseFiles.defaultExpectation.params = &RepositoryMockProcessKnowledgeBaseFilesParams{ctx, fileUIDs, requester}
	mmProcessKnowledgeBaseFiles.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmProcessKnowledgeBaseFiles.expectations {
		if minimock.Equal(e.params, mmProcessKnowledgeBaseFiles.defaultExpectation.params) {
			mmProcessKnowledgeBaseFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmProcessKnowledgeBaseFiles.defaultExpectation.params)
		}
	}

	return mmProcessKnowledgeBaseFiles
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ProcessKnowledgeBaseFiles
func (mmProcessKnowledgeBaseFiles *mRepositoryMockProcessKnowledgeBaseFiles) ExpectCtxParam1(ctx context.Context) *mRepositoryMockProcessKnowledgeBaseFiles {
	if mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ProcessKnowledgeBaseFiles mock is already set by Set")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation = &RepositoryMockProcessKnowledgeBaseFilesExpectation{}
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ProcessKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryMockProcessKnowledgeBaseFilesParamPtrs{}
	}
	mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs.ctx = &ctx
	mmProcessKnowledgeBaseFiles.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmProcessKnowledgeBaseFiles
}

// ExpectFileUIDsParam2 sets up expected param fileUIDs for Repository.ProcessKnowledgeBaseFiles
func (mmProcessKnowledgeBaseFiles *mRepositoryMockProcessKnowledgeBaseFiles) ExpectFileUIDsParam2(fileUIDs []string) *mRepositoryMockProcessKnowledgeBaseFiles {
	if mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ProcessKnowledgeBaseFiles mock is already set by Set")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation = &RepositoryMockProcessKnowledgeBaseFilesExpectation{}
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ProcessKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryMockProcessKnowledgeBaseFilesParamPtrs{}
	}
	mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs.fileUIDs = &fileUIDs
	mmProcessKnowledgeBaseFiles.defaultExpectation.expectationOrigins.originFileUIDs = minimock.CallerInfo(1)

	return mmProcessKnowledgeBaseFiles
}

// ExpectRequesterParam3 sets up expected param requester for Repository.ProcessKnowledgeBaseFiles
func (mmProcessKnowledgeBaseFiles *mRepositoryMockProcessKnowledgeBaseFiles) ExpectRequesterParam3(requester types.RequesterUIDType) *mRepositoryMockProcessKnowledgeBaseFiles {
	if mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ProcessKnowledgeBaseFiles mock is already set by Set")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation = &RepositoryMockProcessKnowledgeBaseFilesExpectation{}
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ProcessKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryMockProcessKnowledgeBaseFilesParamPtrs{}
	}
	mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs.requester = &requester
	mmProcessKnowledgeBaseFiles.defaultExpectation.expectationOrigins.originRequester = minimock.CallerInfo(1)

	return mmProcessKnowledgeBaseFiles
}

// Inspect accepts an inspector function that has same arguments as the Repository.ProcessKnowledgeBaseFiles
func (mmProcessKnowledgeBaseFiles *mRepositoryMockProcessKnowledgeBaseFiles) Inspect(f func(ctx context.Context, fileUIDs []string, requester types.RequesterUIDType)) *mRepositoryMockProcessKnowledgeBaseFiles {
	if mmProcessKnowledgeBaseFiles.mock.inspectFuncProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ProcessKnowledgeBaseFiles")
	}

	mmProcessKnowledgeBaseFiles.mock.inspectFuncProcessKnowledgeBaseFiles = f

	return mmProcessKnowledgeBaseFiles
}

// Return sets up results that will be returned by Repository.ProcessKnowledgeBaseFiles
func (mmProcessKnowledgeBaseFiles *mRepositoryMockProcessKnowledgeBaseFiles) Return(ka1 []mm_repository.KnowledgeBaseFileModel, err error) *RepositoryMock {
	if mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ProcessKnowledgeBaseFiles mock is already set by Set")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation = &RepositoryMockProcessKnowledgeBaseFilesExpectation{mock: mmProcessKnowledgeBaseFiles.mock}
	}
	mmProcessKnowledgeBaseFiles.defaultExpectation.results = &RepositoryMockProcessKnowledgeBaseFilesResults{ka1, err}
	mmProcessKnowledgeBaseFiles.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmProcessKnowledgeBaseFiles.mock
}

// Set uses given function f to mock the Repository.ProcessKnowledgeBaseFiles method
func (mmProcessKnowledgeBaseFiles *mRepositoryMockProcessKnowledgeBaseFiles) Set(f func(ctx context.Context, fileUIDs []string, requester types.RequesterUIDType) (ka1 []mm_repository.KnowledgeBaseFileModel, err error)) *RepositoryMock {
	if mmProcessKnowledgeBaseFiles.defaultExpectation != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("Default expectation is already set for the Repository.ProcessKnowledgeBaseFiles method")
	}

	if len(mmProcessKnowledgeBaseFiles.expectations) > 0 {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("Some expectations are already set for the Repository.ProcessKnowledgeBaseFiles method")
	}

	mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles = f
	mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFilesOrigin = minimock.CallerInfo(1)
	return mmProcessKnowledgeBaseFiles.mock
}

// When sets expectation for the Repository.ProcessKnowledgeBaseFiles which will trigger the result defined by the following
// Then helper
func (mmProcessKnowledgeBaseFiles *mRepositoryMockProcessKnowledgeBaseFiles) When(ctx context.Context, fileUIDs []string, requester types.RequesterUIDType) *RepositoryMockProcessKnowledgeBaseFilesExpectation {
	if mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ProcessKnowledgeBaseFiles mock is already set by Set")
	}

	expectation := &RepositoryMockProcessKnowledgeBaseFilesExpectation{
		mock:               mmProcessKnowledgeBaseFiles.mock,
		params:             &RepositoryMockProcessKnowledgeBaseFilesParams{ctx, fileUIDs, requester},
		expectationOrigins: RepositoryMockProcessKnowledgeBaseFilesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmProcessKnowledgeBaseFiles.expectations = append(mmProcessKnowledgeBaseFiles.expectations, expectation)
	return expectation
}

// Then sets up Repository.ProcessKnowledgeBaseFiles return parameters for the expectation previously defined by the When method
func (e *RepositoryMockProcessKnowledgeBaseFilesExpectation) Then(ka1 []mm_repository.KnowledgeBaseFileModel, err error) *RepositoryMock {
	e.results = &RepositoryMockProcessKnowledgeBaseFilesResults{ka1, err}
	return e.mock
}

// Times sets number of times Repository.ProcessKnowledgeBaseFiles should be invoked
func (mmProcessKnowledgeBaseFiles *mRepositoryMockProcessKnowledgeBaseFiles) Times(n uint64) *mRepositoryMockProcessKnowledgeBaseFiles {
	if n == 0 {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("Times of RepositoryMock.ProcessKnowledgeBaseFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmProcessKnowledgeBaseFiles.expectedInvocations, n)
	mmProcessKnowledgeBaseFiles.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmProcessKnowledgeBaseFiles
}

func (mmProcessKnowledgeBaseFiles *mRepositoryMockProcessKnowledgeBaseFiles) invocationsDone() bool {
	if len(mmProcessKnowledgeBaseFiles.expectations) == 0 && mmProcessKnowledgeBaseFiles.defaultExpectation == nil && mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmProcessKnowledgeBaseFiles.mock.afterProcessKnowledgeBaseFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmProcessKnowledgeBaseFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ProcessKnowledgeBaseFiles implements mm_repository.Repository
func (mmProcessKnowledgeBaseFiles *RepositoryMock) ProcessKnowledgeBaseFiles(ctx context.Context, fileUIDs []string, requester types.RequesterUIDType) (ka1 []mm_repository.KnowledgeBaseFileModel, err error) {
	mm_atomic.AddUint64(&mmProcessKnowledgeBaseFiles.beforeProcessKnowledgeBaseFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmProcessKnowledgeBaseFiles.afterProcessKnowledgeBaseFilesCounter, 1)

	mmProcessKnowledgeBaseFiles.t.Helper()

	if mmProcessKnowledgeBaseFiles.inspectFuncProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.inspectFuncProcessKnowledgeBaseFiles(ctx, fileUIDs, requester)
	}

	mm_params := RepositoryMockProcessKnowledgeBaseFilesParams{ctx, fileUIDs, requester}

	// Record call args
	mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.mutex.Lock()
	mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.callArgs = append(mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.callArgs, &mm_params)
	mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.mutex.Unlock()

	for _, e := range mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation.params
		mm_want_ptrs := mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockProcessKnowledgeBaseFilesParams{ctx, fileUIDs, requester}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmProcessKnowledgeBaseFiles.t.Errorf("RepositoryMock.ProcessKnowledgeBaseFiles got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUIDs != nil && !minimock.Equal(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs) {
				mmProcessKnowledgeBaseFiles.t.Errorf("RepositoryMock.ProcessKnowledgeBaseFiles got unexpected parameter fileUIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.originFileUIDs, *mm_want_ptrs.fileUIDs, mm_got.fileUIDs, minimock.Diff(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs))
			}

			if mm_want_ptrs.requester != nil && !minimock.Equal(*mm_want_ptrs.requester, mm_got.requester) {
				mmProcessKnowledgeBaseFiles.t.Errorf("RepositoryMock.ProcessKnowledgeBaseFiles got unexpected parameter requester, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.originRequester, *mm_want_ptrs.requester, mm_got.requester, minimock.Diff(*mm_want_ptrs.requester, mm_got.requester))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmProcessKnowledgeBaseFiles.t.Errorf("RepositoryMock.ProcessKnowledgeBaseFiles got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmProcessKnowledgeBaseFiles.t.Fatal("No results are set for the RepositoryMock.ProcessKnowledgeBaseFiles")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmProcessKnowledgeBaseFiles.funcProcessKnowledgeBaseFiles != nil {
		return mmProcessKnowledgeBaseFiles.funcProcessKnowledgeBaseFiles(ctx, fileUIDs, requester)
	}
	mmProcessKnowledgeBaseFiles.t.Fatalf("Unexpected call to RepositoryMock.ProcessKnowledgeBaseFiles. %v %v %v", ctx, fileUIDs, requester)
	return
}

// ProcessKnowledgeBaseFilesAfterCounter returns a count of finished RepositoryMock.ProcessKnowledgeBaseFiles invocations
func (mmProcessKnowledgeBaseFiles *RepositoryMock) ProcessKnowledgeBaseFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessKnowledgeBaseFiles.afterProcessKnowledgeBaseFilesCounter)
}

// ProcessKnowledgeBaseFilesBeforeCounter returns a count of RepositoryMock.ProcessKnowledgeBaseFiles invocations
func (mmProcessKnowledgeBaseFiles *RepositoryMock) ProcessKnowledgeBaseFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessKnowledgeBaseFiles.beforeProcessKnowledgeBaseFilesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ProcessKnowledgeBaseFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmProcessKnowledgeBaseFiles *mRepositoryMockProcessKnowledgeBaseFiles) Calls() []*RepositoryMockProcessKnowledgeBaseFilesParams {
	mmProcessKnowledgeBaseFiles.mutex.RLock()

	argCopy := make([]*RepositoryMockProcessKnowledgeBaseFilesParams, len(mmProcessKnowledgeBaseFiles.callArgs))
	copy(argCopy, mmProcessKnowledgeBaseFiles.callArgs)

	mmProcessKnowledgeBaseFiles.mutex.RUnlock()

	return argCopy
}

// MinimockProcessKnowledgeBaseFilesDone returns true if the count of the ProcessKnowledgeBaseFiles invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockProcessKnowledgeBaseFilesDone() bool {
	if m.ProcessKnowledgeBaseFilesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ProcessKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ProcessKnowledgeBaseFilesMock.invocationsDone()
}

// MinimockProcessKnowledgeBaseFilesInspect logs each unmet expectation
func (m *RepositoryMock) MinimockProcessKnowledgeBaseFilesInspect() {
	for _, e := range m.ProcessKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ProcessKnowledgeBaseFiles at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterProcessKnowledgeBaseFilesCounter := mm_atomic.LoadUint64(&m.afterProcessKnowledgeBaseFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ProcessKnowledgeBaseFilesMock.defaultExpectation != nil && afterProcessKnowledgeBaseFilesCounter < 1 {
		if m.ProcessKnowledgeBaseFilesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ProcessKnowledgeBaseFiles at\n%s", m.ProcessKnowledgeBaseFilesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ProcessKnowledgeBaseFiles at\n%s with params: %#v", m.ProcessKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.origin, *m.ProcessKnowledgeBaseFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProcessKnowledgeBaseFiles != nil && afterProcessKnowledgeBaseFilesCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ProcessKnowledgeBaseFiles at\n%s", m.funcProcessKnowledgeBaseFilesOrigin)
	}

	if !m.ProcessKnowledgeBaseFilesMock.invocationsDone() && afterProcessKnowledgeBaseFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ProcessKnowledgeBaseFiles at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ProcessKnowledgeBaseFilesMock.expectedInvocations), m.ProcessKnowledgeBaseFilesMock.expectedInvocationsOrigin, afterProcessKnowledgeBaseFilesCounter)
	}
}

type mRepositoryMockRenameSystemByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockRenameSystemByIDExpectation
	expectations       []*RepositoryMockRenameSystemByIDExpectation

	callArgs []*RepositoryMockRenameSystemByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockRenameSystemByIDExpectation specifies expectation struct of the Repository.RenameSystemByID
type RepositoryMockRenameSystemByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockRenameSystemByIDParams
	paramPtrs          *RepositoryMockRenameSystemByIDParamPtrs
	expectationOrigins RepositoryMockRenameSystemByIDExpectationOrigins
	results            *RepositoryMockRenameSystemByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockRenameSystemByIDParams contains parameters of the Repository.RenameSystemByID
type RepositoryMockRenameSystemByIDParams struct {
	ctx   context.Context
	id    string
	newID string
}

// RepositoryMockRenameSystemByIDParamPtrs contains pointers to parameters of the Repository.RenameSystemByID
type RepositoryMockRenameSystemByIDParamPtrs struct {
	ctx   *context.Context
	id    *string
	newID *string
}

// RepositoryMockRenameSystemByIDResults contains results of the Repository.RenameSystemByID
type RepositoryMockRenameSystemByIDResults struct {
	err error
}

// RepositoryMockRenameSystemByIDOrigins contains origins of expectations of the Repository.RenameSystemByID
type RepositoryMockRenameSystemByIDExpectationOrigins struct {
	origin      string
	originCtx   string
	originId    string
	originNewID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRenameSystemByID *mRepositoryMockRenameSystemByID) Optional() *mRepositoryMockRenameSystemByID {
	mmRenameSystemByID.optional = true
	return mmRenameSystemByID
}

// Expect sets up expected params for Repository.RenameSystemByID
func (mmRenameSystemByID *mRepositoryMockRenameSystemByID) Expect(ctx context.Context, id string, newID string) *mRepositoryMockRenameSystemByID {
	if mmRenameSystemByID.mock.funcRenameSystemByID != nil {
		mmRenameSystemByID.mock.t.Fatalf("RepositoryMock.RenameSystemByID mock is already set by Set")
	}

	if mmRenameSystemByID.defaultExpectation == nil {
		mmRenameSystemByID.defaultExpectation = &RepositoryMockRenameSystemByIDExpectation{}
	}

	if mmRenameSystemByID.defaultExpectation.paramPtrs != nil {
		mmRenameSystemByID.mock.t.Fatalf("RepositoryMock.RenameSystemByID mock is already set by ExpectParams functions")
	}

	mmRenameSystemByID.defaultExpectation.params = &RepositoryMockRenameSystemByIDParams{ctx, id, newID}
	mmRenameSystemByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRenameSystemByID.expectations {
		if minimock.Equal(e.params, mmRenameSystemByID.defaultExpectation.params) {
			mmRenameSystemByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRenameSystemByID.defaultExpectation.params)
		}
	}

	return mmRenameSystemByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.RenameSystemByID
func (mmRenameSystemByID *mRepositoryMockRenameSystemByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockRenameSystemByID {
	if mmRenameSystemByID.mock.funcRenameSystemByID != nil {
		mmRenameSystemByID.mock.t.Fatalf("RepositoryMock.RenameSystemByID mock is already set by Set")
	}

	if mmRenameSystemByID.defaultExpectation == nil {
		mmRenameSystemByID.defaultExpectation = &RepositoryMockRenameSystemByIDExpectation{}
	}

	if mmRenameSystemByID.defaultExpectation.params != nil {
		mmRenameSystemByID.mock.t.Fatalf("RepositoryMock.RenameSystemByID mock is already set by Expect")
	}

	if mmRenameSystemByID.defaultExpectation.paramPtrs == nil {
		mmRenameSystemByID.defaultExpectation.paramPtrs = &RepositoryMockRenameSystemByIDParamPtrs{}
	}
	mmRenameSystemByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmRenameSystemByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRenameSystemByID
}

// ExpectIdParam2 sets up expected param id for Repository.RenameSystemByID
func (mmRenameSystemByID *mRepositoryMockRenameSystemByID) ExpectIdParam2(id string) *mRepositoryMockRenameSystemByID {
	if mmRenameSystemByID.mock.funcRenameSystemByID != nil {
		mmRenameSystemByID.mock.t.Fatalf("RepositoryMock.RenameSystemByID mock is already set by Set")
	}

	if mmRenameSystemByID.defaultExpectation == nil {
		mmRenameSystemByID.defaultExpectation = &RepositoryMockRenameSystemByIDExpectation{}
	}

	if mmRenameSystemByID.defaultExpectation.params != nil {
		mmRenameSystemByID.mock.t.Fatalf("RepositoryMock.RenameSystemByID mock is already set by Expect")
	}

	if mmRenameSystemByID.defaultExpectation.paramPtrs == nil {
		mmRenameSystemByID.defaultExpectation.paramPtrs = &RepositoryMockRenameSystemByIDParamPtrs{}
	}
	mmRenameSystemByID.defaultExpectation.paramPtrs.id = &id
	mmRenameSystemByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmRenameSystemByID
}

// ExpectNewIDParam3 sets up expected param newID for Repository.RenameSystemByID
func (mmRenameSystemByID *mRepositoryMockRenameSystemByID) ExpectNewIDParam3(newID string) *mRepositoryMockRenameSystemByID {
	if mmRenameSystemByID.mock.funcRenameSystemByID != nil {
		mmRenameSystemByID.mock.t.Fatalf("RepositoryMock.RenameSystemByID mock is already set by Set")
	}

	if mmRenameSystemByID.defaultExpectation == nil {
		mmRenameSystemByID.defaultExpectation = &RepositoryMockRenameSystemByIDExpectation{}
	}

	if mmRenameSystemByID.defaultExpectation.params != nil {
		mmRenameSystemByID.mock.t.Fatalf("RepositoryMock.RenameSystemByID mock is already set by Expect")
	}

	if mmRenameSystemByID.defaultExpectation.paramPtrs == nil {
		mmRenameSystemByID.defaultExpectation.paramPtrs = &RepositoryMockRenameSystemByIDParamPtrs{}
	}
	mmRenameSystemByID.defaultExpectation.paramPtrs.newID = &newID
	mmRenameSystemByID.defaultExpectation.expectationOrigins.originNewID = minimock.CallerInfo(1)

	return mmRenameSystemByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.RenameSystemByID
func (mmRenameSystemByID *mRepositoryMockRenameSystemByID) Inspect(f func(ctx context.Context, id string, newID string)) *mRepositoryMockRenameSystemByID {
	if mmRenameSystemByID.mock.inspectFuncRenameSystemByID != nil {
		mmRenameSystemByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.RenameSystemByID")
	}

	mmRenameSystemByID.mock.inspectFuncRenameSystemByID = f

	return mmRenameSystemByID
}

// Return sets up results that will be returned by Repository.RenameSystemByID
func (mmRenameSystemByID *mRepositoryMockRenameSystemByID) Return(err error) *RepositoryMock {
	if mmRenameSystemByID.mock.funcRenameSystemByID != nil {
		mmRenameSystemByID.mock.t.Fatalf("RepositoryMock.RenameSystemByID mock is already set by Set")
	}

	if mmRenameSystemByID.defaultExpectation == nil {
		mmRenameSystemByID.defaultExpectation = &RepositoryMockRenameSystemByIDExpectation{mock: mmRenameSystemByID.mock}
	}
	mmRenameSystemByID.defaultExpectation.results = &RepositoryMockRenameSystemByIDResults{err}
	mmRenameSystemByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRenameSystemByID.mock
}

// Set uses given function f to mock the Repository.RenameSystemByID method
func (mmRenameSystemByID *mRepositoryMockRenameSystemByID) Set(f func(ctx context.Context, id string, newID string) (err error)) *RepositoryMock {
	if mmRenameSystemByID.defaultExpectation != nil {
		mmRenameSystemByID.mock.t.Fatalf("Default expectation is already set for the Repository.RenameSystemByID method")
	}

	if len(mmRenameSystemByID.expectations) > 0 {
		mmRenameSystemByID.mock.t.Fatalf("Some expectations are already set for the Repository.RenameSystemByID method")
	}

	mmRenameSystemByID.mock.funcRenameSystemByID = f
	mmRenameSystemByID.mock.funcRenameSystemByIDOrigin = minimock.CallerInfo(1)
	return mmRenameSystemByID.mock
}

// When sets expectation for the Repository.RenameSystemByID which will trigger the result defined by the following
// Then helper
func (mmRenameSystemByID *mRepositoryMockRenameSystemByID) When(ctx context.Context, id string, newID string) *RepositoryMockRenameSystemByIDExpectation {
	if mmRenameSystemByID.mock.funcRenameSystemByID != nil {
		mmRenameSystemByID.mock.t.Fatalf("RepositoryMock.RenameSystemByID mock is already set by Set")
	}

	expectation := &RepositoryMockRenameSystemByIDExpectation{
		mock:               mmRenameSystemByID.mock,
		params:             &RepositoryMockRenameSystemByIDParams{ctx, id, newID},
		expectationOrigins: RepositoryMockRenameSystemByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRenameSystemByID.expectations = append(mmRenameSystemByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.RenameSystemByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockRenameSystemByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockRenameSystemByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.RenameSystemByID should be invoked
func (mmRenameSystemByID *mRepositoryMockRenameSystemByID) Times(n uint64) *mRepositoryMockRenameSystemByID {
	if n == 0 {
		mmRenameSystemByID.mock.t.Fatalf("Times of RepositoryMock.RenameSystemByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRenameSystemByID.expectedInvocations, n)
	mmRenameSystemByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRenameSystemByID
}

func (mmRenameSystemByID *mRepositoryMockRenameSystemByID) invocationsDone() bool {
	if len(mmRenameSystemByID.expectations) == 0 && mmRenameSystemByID.defaultExpectation == nil && mmRenameSystemByID.mock.funcRenameSystemByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRenameSystemByID.mock.afterRenameSystemByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRenameSystemByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RenameSystemByID implements mm_repository.Repository
func (mmRenameSystemByID *RepositoryMock) RenameSystemByID(ctx context.Context, id string, newID string) (err error) {
	mm_atomic.AddUint64(&mmRenameSystemByID.beforeRenameSystemByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmRenameSystemByID.afterRenameSystemByIDCounter, 1)

	mmRenameSystemByID.t.Helper()

	if mmRenameSystemByID.inspectFuncRenameSystemByID != nil {
		mmRenameSystemByID.inspectFuncRenameSystemByID(ctx, id, newID)
	}

	mm_params := RepositoryMockRenameSystemByIDParams{ctx, id, newID}

	// Record call args
	mmRenameSystemByID.RenameSystemByIDMock.mutex.Lock()
	mmRenameSystemByID.RenameSystemByIDMock.callArgs = append(mmRenameSystemByID.RenameSystemByIDMock.callArgs, &mm_params)
	mmRenameSystemByID.RenameSystemByIDMock.mutex.Unlock()

	for _, e := range mmRenameSystemByID.RenameSystemByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRenameSystemByID.RenameSystemByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRenameSystemByID.RenameSystemByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmRenameSystemByID.RenameSystemByIDMock.defaultExpectation.params
		mm_want_ptrs := mmRenameSystemByID.RenameSystemByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockRenameSystemByIDParams{ctx, id, newID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRenameSystemByID.t.Errorf("RepositoryMock.RenameSystemByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRenameSystemByID.RenameSystemByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmRenameSystemByID.t.Errorf("RepositoryMock.RenameSystemByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRenameSystemByID.RenameSystemByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.newID != nil && !minimock.Equal(*mm_want_ptrs.newID, mm_got.newID) {
				mmRenameSystemByID.t.Errorf("RepositoryMock.RenameSystemByID got unexpected parameter newID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRenameSystemByID.RenameSystemByIDMock.defaultExpectation.expectationOrigins.originNewID, *mm_want_ptrs.newID, mm_got.newID, minimock.Diff(*mm_want_ptrs.newID, mm_got.newID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRenameSystemByID.t.Errorf("RepositoryMock.RenameSystemByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRenameSystemByID.RenameSystemByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRenameSystemByID.RenameSystemByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmRenameSystemByID.t.Fatal("No results are set for the RepositoryMock.RenameSystemByID")
		}
		return (*mm_results).err
	}
	if mmRenameSystemByID.funcRenameSystemByID != nil {
		return mmRenameSystemByID.funcRenameSystemByID(ctx, id, newID)
	}
	mmRenameSystemByID.t.Fatalf("Unexpected call to RepositoryMock.RenameSystemByID. %v %v %v", ctx, id, newID)
	return
}

// RenameSystemByIDAfterCounter returns a count of finished RepositoryMock.RenameSystemByID invocations
func (mmRenameSystemByID *RepositoryMock) RenameSystemByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRenameSystemByID.afterRenameSystemByIDCounter)
}

// RenameSystemByIDBeforeCounter returns a count of RepositoryMock.RenameSystemByID invocations
func (mmRenameSystemByID *RepositoryMock) RenameSystemByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRenameSystemByID.beforeRenameSystemByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.RenameSystemByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRenameSystemByID *mRepositoryMockRenameSystemByID) Calls() []*RepositoryMockRenameSystemByIDParams {
	mmRenameSystemByID.mutex.RLock()

	argCopy := make([]*RepositoryMockRenameSystemByIDParams, len(mmRenameSystemByID.callArgs))
	copy(argCopy, mmRenameSystemByID.callArgs)

	mmRenameSystemByID.mutex.RUnlock()

	return argCopy
}

// MinimockRenameSystemByIDDone returns true if the count of the RenameSystemByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockRenameSystemByIDDone() bool {
	if m.RenameSystemByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RenameSystemByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RenameSystemByIDMock.invocationsDone()
}

// MinimockRenameSystemByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockRenameSystemByIDInspect() {
	for _, e := range m.RenameSystemByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.RenameSystemByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRenameSystemByIDCounter := mm_atomic.LoadUint64(&m.afterRenameSystemByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RenameSystemByIDMock.defaultExpectation != nil && afterRenameSystemByIDCounter < 1 {
		if m.RenameSystemByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.RenameSystemByID at\n%s", m.RenameSystemByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.RenameSystemByID at\n%s with params: %#v", m.RenameSystemByIDMock.defaultExpectation.expectationOrigins.origin, *m.RenameSystemByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRenameSystemByID != nil && afterRenameSystemByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.RenameSystemByID at\n%s", m.funcRenameSystemByIDOrigin)
	}

	if !m.RenameSystemByIDMock.invocationsDone() && afterRenameSystemByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.RenameSystemByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RenameSystemByIDMock.expectedInvocations), m.RenameSystemByIDMock.expectedInvocationsOrigin, afterRenameSystemByIDCounter)
	}
}

type mRepositoryMockRenewCacheMetadataTTL struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockRenewCacheMetadataTTLExpectation
	expectations       []*RepositoryMockRenewCacheMetadataTTLExpectation

	callArgs []*RepositoryMockRenewCacheMetadataTTLParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockRenewCacheMetadataTTLExpectation specifies expectation struct of the Repository.RenewCacheMetadataTTL
type RepositoryMockRenewCacheMetadataTTLExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockRenewCacheMetadataTTLParams
	paramPtrs          *RepositoryMockRenewCacheMetadataTTLParamPtrs
	expectationOrigins RepositoryMockRenewCacheMetadataTTLExpectationOrigins
	results            *RepositoryMockRenewCacheMetadataTTLResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockRenewCacheMetadataTTLParams contains parameters of the Repository.RenewCacheMetadataTTL
type RepositoryMockRenewCacheMetadataTTLParams struct {
	ctx           context.Context
	kbUID         types.KBUIDType
	fileUIDs      []types.FileUIDType
	newTTL        time.Duration
	newExpireTime time.Time
}

// RepositoryMockRenewCacheMetadataTTLParamPtrs contains pointers to parameters of the Repository.RenewCacheMetadataTTL
type RepositoryMockRenewCacheMetadataTTLParamPtrs struct {
	ctx           *context.Context
	kbUID         *types.KBUIDType
	fileUIDs      *[]types.FileUIDType
	newTTL        *time.Duration
	newExpireTime *time.Time
}

// RepositoryMockRenewCacheMetadataTTLResults contains results of the Repository.RenewCacheMetadataTTL
type RepositoryMockRenewCacheMetadataTTLResults struct {
	err error
}

// RepositoryMockRenewCacheMetadataTTLOrigins contains origins of expectations of the Repository.RenewCacheMetadataTTL
type RepositoryMockRenewCacheMetadataTTLExpectationOrigins struct {
	origin              string
	originCtx           string
	originKbUID         string
	originFileUIDs      string
	originNewTTL        string
	originNewExpireTime string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRenewCacheMetadataTTL *mRepositoryMockRenewCacheMetadataTTL) Optional() *mRepositoryMockRenewCacheMetadataTTL {
	mmRenewCacheMetadataTTL.optional = true
	return mmRenewCacheMetadataTTL
}

// Expect sets up expected params for Repository.RenewCacheMetadataTTL
func (mmRenewCacheMetadataTTL *mRepositoryMockRenewCacheMetadataTTL) Expect(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType, newTTL time.Duration, newExpireTime time.Time) *mRepositoryMockRenewCacheMetadataTTL {
	if mmRenewCacheMetadataTTL.mock.funcRenewCacheMetadataTTL != nil {
		mmRenewCacheMetadataTTL.mock.t.Fatalf("RepositoryMock.RenewCacheMetadataTTL mock is already set by Set")
	}

	if mmRenewCacheMetadataTTL.defaultExpectation == nil {
		mmRenewCacheMetadataTTL.defaultExpectation = &RepositoryMockRenewCacheMetadataTTLExpectation{}
	}

	if mmRenewCacheMetadataTTL.defaultExpectation.paramPtrs != nil {
		mmRenewCacheMetadataTTL.mock.t.Fatalf("RepositoryMock.RenewCacheMetadataTTL mock is already set by ExpectParams functions")
	}

	mmRenewCacheMetadataTTL.defaultExpectation.params = &RepositoryMockRenewCacheMetadataTTLParams{ctx, kbUID, fileUIDs, newTTL, newExpireTime}
	mmRenewCacheMetadataTTL.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRenewCacheMetadataTTL.expectations {
		if minimock.Equal(e.params, mmRenewCacheMetadataTTL.defaultExpectation.params) {
			mmRenewCacheMetadataTTL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRenewCacheMetadataTTL.defaultExpectation.params)
		}
	}

	return mmRenewCacheMetadataTTL
}

// ExpectCtxParam1 sets up expected param ctx for Repository.RenewCacheMetadataTTL
func (mmRenewCacheMetadataTTL *mRepositoryMockRenewCacheMetadataTTL) ExpectCtxParam1(ctx context.Context) *mRepositoryMockRenewCacheMetadataTTL {
	if mmRenewCacheMetadataTTL.mock.funcRenewCacheMetadataTTL != nil {
		mmRenewCacheMetadataTTL.mock.t.Fatalf("RepositoryMock.RenewCacheMetadataTTL mock is already set by Set")
	}

	if mmRenewCacheMetadataTTL.defaultExpectation == nil {
		mmRenewCacheMetadataTTL.defaultExpectation = &RepositoryMockRenewCacheMetadataTTLExpectation{}
	}

	if mmRenewCacheMetadataTTL.defaultExpectation.params != nil {
		mmRenewCacheMetadataTTL.mock.t.Fatalf("RepositoryMock.RenewCacheMetadataTTL mock is already set by Expect")
	}

	if mmRenewCacheMetadataTTL.defaultExpectation.paramPtrs == nil {
		mmRenewCacheMetadataTTL.defaultExpectation.paramPtrs = &RepositoryMockRenewCacheMetadataTTLParamPtrs{}
	}
	mmRenewCacheMetadataTTL.defaultExpectation.paramPtrs.ctx = &ctx
	mmRenewCacheMetadataTTL.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRenewCacheMetadataTTL
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.RenewCacheMetadataTTL
func (mmRenewCacheMetadataTTL *mRepositoryMockRenewCacheMetadataTTL) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockRenewCacheMetadataTTL {
	if mmRenewCacheMetadataTTL.mock.funcRenewCacheMetadataTTL != nil {
		mmRenewCacheMetadataTTL.mock.t.Fatalf("RepositoryMock.RenewCacheMetadataTTL mock is already set by Set")
	}

	if mmRenewCacheMetadataTTL.defaultExpectation == nil {
		mmRenewCacheMetadataTTL.defaultExpectation = &RepositoryMockRenewCacheMetadataTTLExpectation{}
	}

	if mmRenewCacheMetadataTTL.defaultExpectation.params != nil {
		mmRenewCacheMetadataTTL.mock.t.Fatalf("RepositoryMock.RenewCacheMetadataTTL mock is already set by Expect")
	}

	if mmRenewCacheMetadataTTL.defaultExpectation.paramPtrs == nil {
		mmRenewCacheMetadataTTL.defaultExpectation.paramPtrs = &RepositoryMockRenewCacheMetadataTTLParamPtrs{}
	}
	mmRenewCacheMetadataTTL.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmRenewCacheMetadataTTL.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmRenewCacheMetadataTTL
}

// ExpectFileUIDsParam3 sets up expected param fileUIDs for Repository.RenewCacheMetadataTTL
func (mmRenewCacheMetadataTTL *mRepositoryMockRenewCacheMetadataTTL) ExpectFileUIDsParam3(fileUIDs []types.FileUIDType) *mRepositoryMockRenewCacheMetadataTTL {
	if mmRenewCacheMetadataTTL.mock.funcRenewCacheMetadataTTL != nil {
		mmRenewCacheMetadataTTL.mock.t.Fatalf("RepositoryMock.RenewCacheMetadataTTL mock is already set by Set")
	}

	if mmRenewCacheMetadataTTL.defaultExpectation == nil {
		mmRenewCacheMetadataTTL.defaultExpectation = &RepositoryMockRenewCacheMetadataTTLExpectation{}
	}

	if mmRenewCacheMetadataTTL.defaultExpectation.params != nil {
		mmRenewCacheMetadataTTL.mock.t.Fatalf("RepositoryMock.RenewCacheMetadataTTL mock is already set by Expect")
	}

	if mmRenewCacheMetadataTTL.defaultExpectation.paramPtrs == nil {
		mmRenewCacheMetadataTTL.defaultExpectation.paramPtrs = &RepositoryMockRenewCacheMetadataTTLParamPtrs{}
	}
	mmRenewCacheMetadataTTL.defaultExpectation.paramPtrs.fileUIDs = &fileUIDs
	mmRenewCacheMetadataTTL.defaultExpectation.expectationOrigins.originFileUIDs = minimock.CallerInfo(1)

	return mmRenewCacheMetadataTTL
}

// ExpectNewTTLParam4 sets up expected param newTTL for Repository.RenewCacheMetadataTTL
func (mmRenewCacheMetadataTTL *mRepositoryMockRenewCacheMetadataTTL) ExpectNewTTLParam4(newTTL time.Duration) *mRepositoryMockRenewCacheMetadataTTL {
	if mmRenewCacheMetadataTTL.mock.funcRenewCacheMetadataTTL != nil {
		mmRenewCacheMetadataTTL.mock.t.Fatalf("RepositoryMock.RenewCacheMetadataTTL mock is already set by Set")
	}

	if mmRenewCacheMetadataTTL.defaultExpectation == nil {
		mmRenewCacheMetadataTTL.defaultExpectation = &RepositoryMockRenewCacheMetadataTTLExpectation{}
	}

	if mmRenewCacheMetadataTTL.defaultExpectation.params != nil {
		mmRenewCacheMetadataTTL.mock.t.Fatalf("RepositoryMock.RenewCacheMetadataTTL mock is already set by Expect")
	}

	if mmRenewCacheMetadataTTL.defaultExpectation.paramPtrs == nil {
		mmRenewCacheMetadataTTL.defaultExpectation.paramPtrs = &RepositoryMockRenewCacheMetadataTTLParamPtrs{}
	}
	mmRenewCacheMetadataTTL.defaultExpectation.paramPtrs.newTTL = &newTTL
	mmRenewCacheMetadataTTL.defaultExpectation.expectationOrigins.originNewTTL = minimock.CallerInfo(1)

	return mmRenewCacheMetadataTTL
}

// ExpectNewExpireTimeParam5 sets up expected param newExpireTime for Repository.RenewCacheMetadataTTL
func (mmRenewCacheMetadataTTL *mRepositoryMockRenewCacheMetadataTTL) ExpectNewExpireTimeParam5(newExpireTime time.Time) *mRepositoryMockRenewCacheMetadataTTL {
	if mmRenewCacheMetadataTTL.mock.funcRenewCacheMetadataTTL != nil {
		mmRenewCacheMetadataTTL.mock.t.Fatalf("RepositoryMock.RenewCacheMetadataTTL mock is already set by Set")
	}

	if mmRenewCacheMetadataTTL.defaultExpectation == nil {
		mmRenewCacheMetadataTTL.defaultExpectation = &RepositoryMockRenewCacheMetadataTTLExpectation{}
	}

	if mmRenewCacheMetadataTTL.defaultExpectation.params != nil {
		mmRenewCacheMetadataTTL.mock.t.Fatalf("RepositoryMock.RenewCacheMetadataTTL mock is already set by Expect")
	}

	if mmRenewCacheMetadataTTL.defaultExpectation.paramPtrs == nil {
		mmRenewCacheMetadataTTL.defaultExpectation.paramPtrs = &RepositoryMockRenewCacheMetadataTTLParamPtrs{}
	}
	mmRenewCacheMetadataTTL.defaultExpectation.paramPtrs.newExpireTime = &newExpireTime
	mmRenewCacheMetadataTTL.defaultExpectation.expectationOrigins.originNewExpireTime = minimock.CallerInfo(1)

	return mmRenewCacheMetadataTTL
}

// Inspect accepts an inspector function that has same arguments as the Repository.RenewCacheMetadataTTL
func (mmRenewCacheMetadataTTL *mRepositoryMockRenewCacheMetadataTTL) Inspect(f func(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType, newTTL time.Duration, newExpireTime time.Time)) *mRepositoryMockRenewCacheMetadataTTL {
	if mmRenewCacheMetadataTTL.mock.inspectFuncRenewCacheMetadataTTL != nil {
		mmRenewCacheMetadataTTL.mock.t.Fatalf("Inspect function is already set for RepositoryMock.RenewCacheMetadataTTL")
	}

	mmRenewCacheMetadataTTL.mock.inspectFuncRenewCacheMetadataTTL = f

	return mmRenewCacheMetadataTTL
}

// Return sets up results that will be returned by Repository.RenewCacheMetadataTTL
func (mmRenewCacheMetadataTTL *mRepositoryMockRenewCacheMetadataTTL) Return(err error) *RepositoryMock {
	if mmRenewCacheMetadataTTL.mock.funcRenewCacheMetadataTTL != nil {
		mmRenewCacheMetadataTTL.mock.t.Fatalf("RepositoryMock.RenewCacheMetadataTTL mock is already set by Set")
	}

	if mmRenewCacheMetadataTTL.defaultExpectation == nil {
		mmRenewCacheMetadataTTL.defaultExpectation = &RepositoryMockRenewCacheMetadataTTLExpectation{mock: mmRenewCacheMetadataTTL.mock}
	}
	mmRenewCacheMetadataTTL.defaultExpectation.results = &RepositoryMockRenewCacheMetadataTTLResults{err}
	mmRenewCacheMetadataTTL.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRenewCacheMetadataTTL.mock
}

// Set uses given function f to mock the Repository.RenewCacheMetadataTTL method
func (mmRenewCacheMetadataTTL *mRepositoryMockRenewCacheMetadataTTL) Set(f func(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType, newTTL time.Duration, newExpireTime time.Time) (err error)) *RepositoryMock {
	if mmRenewCacheMetadataTTL.defaultExpectation != nil {
		mmRenewCacheMetadataTTL.mock.t.Fatalf("Default expectation is already set for the Repository.RenewCacheMetadataTTL method")
	}

	if len(mmRenewCacheMetadataTTL.expectations) > 0 {
		mmRenewCacheMetadataTTL.mock.t.Fatalf("Some expectations are already set for the Repository.RenewCacheMetadataTTL method")
	}

	mmRenewCacheMetadataTTL.mock.funcRenewCacheMetadataTTL = f
	mmRenewCacheMetadataTTL.mock.funcRenewCacheMetadataTTLOrigin = minimock.CallerInfo(1)
	return mmRenewCacheMetadataTTL.mock
}

// When sets expectation for the Repository.RenewCacheMetadataTTL which will trigger the result defined by the following
// Then helper
func (mmRenewCacheMetadataTTL *mRepositoryMockRenewCacheMetadataTTL) When(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType, newTTL time.Duration, newExpireTime time.Time) *RepositoryMockRenewCacheMetadataTTLExpectation {
	if mmRenewCacheMetadataTTL.mock.funcRenewCacheMetadataTTL != nil {
		mmRenewCacheMetadataTTL.mock.t.Fatalf("RepositoryMock.RenewCacheMetadataTTL mock is already set by Set")
	}

	expectation := &RepositoryMockRenewCacheMetadataTTLExpectation{
		mock:               mmRenewCacheMetadataTTL.mock,
		params:             &RepositoryMockRenewCacheMetadataTTLParams{ctx, kbUID, fileUIDs, newTTL, newExpireTime},
		expectationOrigins: RepositoryMockRenewCacheMetadataTTLExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRenewCacheMetadataTTL.expectations = append(mmRenewCacheMetadataTTL.expectations, expectation)
	return expectation
}

// Then sets up Repository.RenewCacheMetadataTTL return parameters for the expectation previously defined by the When method
func (e *RepositoryMockRenewCacheMetadataTTLExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockRenewCacheMetadataTTLResults{err}
	return e.mock
}

// Times sets number of times Repository.RenewCacheMetadataTTL should be invoked
func (mmRenewCacheMetadataTTL *mRepositoryMockRenewCacheMetadataTTL) Times(n uint64) *mRepositoryMockRenewCacheMetadataTTL {
	if n == 0 {
		mmRenewCacheMetadataTTL.mock.t.Fatalf("Times of RepositoryMock.RenewCacheMetadataTTL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRenewCacheMetadataTTL.expectedInvocations, n)
	mmRenewCacheMetadataTTL.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRenewCacheMetadataTTL
}

func (mmRenewCacheMetadataTTL *mRepositoryMockRenewCacheMetadataTTL) invocationsDone() bool {
	if len(mmRenewCacheMetadataTTL.expectations) == 0 && mmRenewCacheMetadataTTL.defaultExpectation == nil && mmRenewCacheMetadataTTL.mock.funcRenewCacheMetadataTTL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRenewCacheMetadataTTL.mock.afterRenewCacheMetadataTTLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRenewCacheMetadataTTL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RenewCacheMetadataTTL implements mm_repository.Repository
func (mmRenewCacheMetadataTTL *RepositoryMock) RenewCacheMetadataTTL(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType, newTTL time.Duration, newExpireTime time.Time) (err error) {
	mm_atomic.AddUint64(&mmRenewCacheMetadataTTL.beforeRenewCacheMetadataTTLCounter, 1)
	defer mm_atomic.AddUint64(&mmRenewCacheMetadataTTL.afterRenewCacheMetadataTTLCounter, 1)

	mmRenewCacheMetadataTTL.t.Helper()

	if mmRenewCacheMetadataTTL.inspectFuncRenewCacheMetadataTTL != nil {
		mmRenewCacheMetadataTTL.inspectFuncRenewCacheMetadataTTL(ctx, kbUID, fileUIDs, newTTL, newExpireTime)
	}

	mm_params := RepositoryMockRenewCacheMetadataTTLParams{ctx, kbUID, fileUIDs, newTTL, newExpireTime}

	// Record call args
	mmRenewCacheMetadataTTL.RenewCacheMetadataTTLMock.mutex.Lock()
	mmRenewCacheMetadataTTL.RenewCacheMetadataTTLMock.callArgs = append(mmRenewCacheMetadataTTL.RenewCacheMetadataTTLMock.callArgs, &mm_params)
	mmRenewCacheMetadataTTL.RenewCacheMetadataTTLMock.mutex.Unlock()

	for _, e := range mmRenewCacheMetadataTTL.RenewCacheMetadataTTLMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRenewCacheMetadataTTL.RenewCacheMetadataTTLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRenewCacheMetadataTTL.RenewCacheMetadataTTLMock.defaultExpectation.Counter, 1)
		mm_want := mmRenewCacheMetadataTTL.RenewCacheMetadataTTLMock.defaultExpectation.params
		mm_want_ptrs := mmRenewCacheMetadataTTL.RenewCacheMetadataTTLMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockRenewCacheMetadataTTLParams{ctx, kbUID, fileUIDs, newTTL, newExpireTime}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRenewCacheMetadataTTL.t.Errorf("RepositoryMock.RenewCacheMetadataTTL got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRenewCacheMetadataTTL.RenewCacheMetadataTTLMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmRenewCacheMetadataTTL.t.Errorf("RepositoryMock.RenewCacheMetadataTTL got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRenewCacheMetadataTTL.RenewCacheMetadataTTLMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.fileUIDs != nil && !minimock.Equal(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs) {
				mmRenewCacheMetadataTTL.t.Errorf("RepositoryMock.RenewCacheMetadataTTL got unexpected parameter fileUIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRenewCacheMetadataTTL.RenewCacheMetadataTTLMock.defaultExpectation.expectationOrigins.originFileUIDs, *mm_want_ptrs.fileUIDs, mm_got.fileUIDs, minimock.Diff(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs))
			}

			if mm_want_ptrs.newTTL != nil && !minimock.Equal(*mm_want_ptrs.newTTL, mm_got.newTTL) {
				mmRenewCacheMetadataTTL.t.Errorf("RepositoryMock.RenewCacheMetadataTTL got unexpected parameter newTTL, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRenewCacheMetadataTTL.RenewCacheMetadataTTLMock.defaultExpectation.expectationOrigins.originNewTTL, *mm_want_ptrs.newTTL, mm_got.newTTL, minimock.Diff(*mm_want_ptrs.newTTL, mm_got.newTTL))
			}

			if mm_want_ptrs.newExpireTime != nil && !minimock.Equal(*mm_want_ptrs.newExpireTime, mm_got.newExpireTime) {
				mmRenewCacheMetadataTTL.t.Errorf("RepositoryMock.RenewCacheMetadataTTL got unexpected parameter newExpireTime, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRenewCacheMetadataTTL.RenewCacheMetadataTTLMock.defaultExpectation.expectationOrigins.originNewExpireTime, *mm_want_ptrs.newExpireTime, mm_got.newExpireTime, minimock.Diff(*mm_want_ptrs.newExpireTime, mm_got.newExpireTime))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRenewCacheMetadataTTL.t.Errorf("RepositoryMock.RenewCacheMetadataTTL got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRenewCacheMetadataTTL.RenewCacheMetadataTTLMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRenewCacheMetadataTTL.RenewCacheMetadataTTLMock.defaultExpectation.results
		if mm_results == nil {
			mmRenewCacheMetadataTTL.t.Fatal("No results are set for the RepositoryMock.RenewCacheMetadataTTL")
		}
		return (*mm_results).err
	}
	if mmRenewCacheMetadataTTL.funcRenewCacheMetadataTTL != nil {
		return mmRenewCacheMetadataTTL.funcRenewCacheMetadataTTL(ctx, kbUID, fileUIDs, newTTL, newExpireTime)
	}
	mmRenewCacheMetadataTTL.t.Fatalf("Unexpected call to RepositoryMock.RenewCacheMetadataTTL. %v %v %v %v %v", ctx, kbUID, fileUIDs, newTTL, newExpireTime)
	return
}

// RenewCacheMetadataTTLAfterCounter returns a count of finished RepositoryMock.RenewCacheMetadataTTL invocations
func (mmRenewCacheMetadataTTL *RepositoryMock) RenewCacheMetadataTTLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRenewCacheMetadataTTL.afterRenewCacheMetadataTTLCounter)
}

// RenewCacheMetadataTTLBeforeCounter returns a count of RepositoryMock.RenewCacheMetadataTTL invocations
func (mmRenewCacheMetadataTTL *RepositoryMock) RenewCacheMetadataTTLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRenewCacheMetadataTTL.beforeRenewCacheMetadataTTLCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.RenewCacheMetadataTTL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRenewCacheMetadataTTL *mRepositoryMockRenewCacheMetadataTTL) Calls() []*RepositoryMockRenewCacheMetadataTTLParams {
	mmRenewCacheMetadataTTL.mutex.RLock()

	argCopy := make([]*RepositoryMockRenewCacheMetadataTTLParams, len(mmRenewCacheMetadataTTL.callArgs))
	copy(argCopy, mmRenewCacheMetadataTTL.callArgs)

	mmRenewCacheMetadataTTL.mutex.RUnlock()

	return argCopy
}

// MinimockRenewCacheMetadataTTLDone returns true if the count of the RenewCacheMetadataTTL invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockRenewCacheMetadataTTLDone() bool {
	if m.RenewCacheMetadataTTLMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RenewCacheMetadataTTLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RenewCacheMetadataTTLMock.invocationsDone()
}

// MinimockRenewCacheMetadataTTLInspect logs each unmet expectation
func (m *RepositoryMock) MinimockRenewCacheMetadataTTLInspect() {
	for _, e := range m.RenewCacheMetadataTTLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.RenewCacheMetadataTTL at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRenewCacheMetadataTTLCounter := mm_atomic.LoadUint64(&m.afterRenewCacheMetadataTTLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RenewCacheMetadataTTLMock.defaultExpectation != nil && afterRenewCacheMetadataTTLCounter < 1 {
		if m.RenewCacheMetadataTTLMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.RenewCacheMetadataTTL at\n%s", m.RenewCacheMetadataTTLMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.RenewCacheMetadataTTL at\n%s with params: %#v", m.RenewCacheMetadataTTLMock.defaultExpectation.expectationOrigins.origin, *m.RenewCacheMetadataTTLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRenewCacheMetadataTTL != nil && afterRenewCacheMetadataTTLCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.RenewCacheMetadataTTL at\n%s", m.funcRenewCacheMetadataTTLOrigin)
	}

	if !m.RenewCacheMetadataTTLMock.invocationsDone() && afterRenewCacheMetadataTTLCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.RenewCacheMetadataTTL at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RenewCacheMetadataTTLMock.expectedInvocations), m.RenewCacheMetadataTTLMock.expectedInvocationsOrigin, afterRenewCacheMetadataTTLCounter)
	}
}

type mRepositoryMockScanGCSFilesForCleanup struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockScanGCSFilesForCleanupExpectation
	expectations       []*RepositoryMockScanGCSFilesForCleanupExpectation

	callArgs []*RepositoryMockScanGCSFilesForCleanupParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockScanGCSFilesForCleanupExpectation specifies expectation struct of the Repository.ScanGCSFilesForCleanup
type RepositoryMockScanGCSFilesForCleanupExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockScanGCSFilesForCleanupParams
	paramPtrs          *RepositoryMockScanGCSFilesForCleanupParamPtrs
	expectationOrigins RepositoryMockScanGCSFilesForCleanupExpectationOrigins
	results            *RepositoryMockScanGCSFilesForCleanupResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockScanGCSFilesForCleanupParams contains parameters of the Repository.ScanGCSFilesForCleanup
type RepositoryMockScanGCSFilesForCleanupParams struct {
	ctx      context.Context
	maxCount int64
}

// RepositoryMockScanGCSFilesForCleanupParamPtrs contains pointers to parameters of the Repository.ScanGCSFilesForCleanup
type RepositoryMockScanGCSFilesForCleanupParamPtrs struct {
	ctx      *context.Context
	maxCount *int64
}

// RepositoryMockScanGCSFilesForCleanupResults contains results of the Repository.ScanGCSFilesForCleanup
type RepositoryMockScanGCSFilesForCleanupResults struct {
	ga1 []mm_repository.GCSFileInfo
	err error
}

// RepositoryMockScanGCSFilesForCleanupOrigins contains origins of expectations of the Repository.ScanGCSFilesForCleanup
type RepositoryMockScanGCSFilesForCleanupExpectationOrigins struct {
	origin         string
	originCtx      string
	originMaxCount string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmScanGCSFilesForCleanup *mRepositoryMockScanGCSFilesForCleanup) Optional() *mRepositoryMockScanGCSFilesForCleanup {
	mmScanGCSFilesForCleanup.optional = true
	return mmScanGCSFilesForCleanup
}

// Expect sets up expected params for Repository.ScanGCSFilesForCleanup
func (mmScanGCSFilesForCleanup *mRepositoryMockScanGCSFilesForCleanup) Expect(ctx context.Context, maxCount int64) *mRepositoryMockScanGCSFilesForCleanup {
	if mmScanGCSFilesForCleanup.mock.funcScanGCSFilesForCleanup != nil {
		mmScanGCSFilesForCleanup.mock.t.Fatalf("RepositoryMock.ScanGCSFilesForCleanup mock is already set by Set")
	}

	if mmScanGCSFilesForCleanup.defaultExpectation == nil {
		mmScanGCSFilesForCleanup.defaultExpectation = &RepositoryMockScanGCSFilesForCleanupExpectation{}
	}

	if mmScanGCSFilesForCleanup.defaultExpectation.paramPtrs != nil {
		mmScanGCSFilesForCleanup.mock.t.Fatalf("RepositoryMock.ScanGCSFilesForCleanup mock is already set by ExpectParams functions")
	}

	mmScanGCSFilesForCleanup.defaultExpectation.params = &RepositoryMockScanGCSFilesForCleanupParams{ctx, maxCount}
	mmScanGCSFilesForCleanup.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmScanGCSFilesForCleanup.expectations {
		if minimock.Equal(e.params, mmScanGCSFilesForCleanup.defaultExpectation.params) {
			mmScanGCSFilesForCleanup.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmScanGCSFilesForCleanup.defaultExpectation.params)
		}
	}

	return mmScanGCSFilesForCleanup
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ScanGCSFilesForCleanup
func (mmScanGCSFilesForCleanup *mRepositoryMockScanGCSFilesForCleanup) ExpectCtxParam1(ctx context.Context) *mRepositoryMockScanGCSFilesForCleanup {
	if mmScanGCSFilesForCleanup.mock.funcScanGCSFilesForCleanup != nil {
		mmScanGCSFilesForCleanup.mock.t.Fatalf("RepositoryMock.ScanGCSFilesForCleanup mock is already set by Set")
	}

	if mmScanGCSFilesForCleanup.defaultExpectation == nil {
		mmScanGCSFilesForCleanup.defaultExpectation = &RepositoryMockScanGCSFilesForCleanupExpectation{}
	}

	if mmScanGCSFilesForCleanup.defaultExpectation.params != nil {
		mmScanGCSFilesForCleanup.mock.t.Fatalf("RepositoryMock.ScanGCSFilesForCleanup mock is already set by Expect")
	}

	if mmScanGCSFilesForCleanup.defaultExpectation.paramPtrs == nil {
		mmScanGCSFilesForCleanup.defaultExpectation.paramPtrs = &RepositoryMockScanGCSFilesForCleanupParamPtrs{}
	}
	mmScanGCSFilesForCleanup.defaultExpectation.paramPtrs.ctx = &ctx
	mmScanGCSFilesForCleanup.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmScanGCSFilesForCleanup
}

// ExpectMaxCountParam2 sets up expected param maxCount for Repository.ScanGCSFilesForCleanup
func (mmScanGCSFilesForCleanup *mRepositoryMockScanGCSFilesForCleanup) ExpectMaxCountParam2(maxCount int64) *mRepositoryMockScanGCSFilesForCleanup {
	if mmScanGCSFilesForCleanup.mock.funcScanGCSFilesForCleanup != nil {
		mmScanGCSFilesForCleanup.mock.t.Fatalf("RepositoryMock.ScanGCSFilesForCleanup mock is already set by Set")
	}

	if mmScanGCSFilesForCleanup.defaultExpectation == nil {
		mmScanGCSFilesForCleanup.defaultExpectation = &RepositoryMockScanGCSFilesForCleanupExpectation{}
	}

	if mmScanGCSFilesForCleanup.defaultExpectation.params != nil {
		mmScanGCSFilesForCleanup.mock.t.Fatalf("RepositoryMock.ScanGCSFilesForCleanup mock is already set by Expect")
	}

	if mmScanGCSFilesForCleanup.defaultExpectation.paramPtrs == nil {
		mmScanGCSFilesForCleanup.defaultExpectation.paramPtrs = &RepositoryMockScanGCSFilesForCleanupParamPtrs{}
	}
	mmScanGCSFilesForCleanup.defaultExpectation.paramPtrs.maxCount = &maxCount
	mmScanGCSFilesForCleanup.defaultExpectation.expectationOrigins.originMaxCount = minimock.CallerInfo(1)

	return mmScanGCSFilesForCleanup
}

// Inspect accepts an inspector function that has same arguments as the Repository.ScanGCSFilesForCleanup
func (mmScanGCSFilesForCleanup *mRepositoryMockScanGCSFilesForCleanup) Inspect(f func(ctx context.Context, maxCount int64)) *mRepositoryMockScanGCSFilesForCleanup {
	if mmScanGCSFilesForCleanup.mock.inspectFuncScanGCSFilesForCleanup != nil {
		mmScanGCSFilesForCleanup.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ScanGCSFilesForCleanup")
	}

	mmScanGCSFilesForCleanup.mock.inspectFuncScanGCSFilesForCleanup = f

	return mmScanGCSFilesForCleanup
}

// Return sets up results that will be returned by Repository.ScanGCSFilesForCleanup
func (mmScanGCSFilesForCleanup *mRepositoryMockScanGCSFilesForCleanup) Return(ga1 []mm_repository.GCSFileInfo, err error) *RepositoryMock {
	if mmScanGCSFilesForCleanup.mock.funcScanGCSFilesForCleanup != nil {
		mmScanGCSFilesForCleanup.mock.t.Fatalf("RepositoryMock.ScanGCSFilesForCleanup mock is already set by Set")
	}

	if mmScanGCSFilesForCleanup.defaultExpectation == nil {
		mmScanGCSFilesForCleanup.defaultExpectation = &RepositoryMockScanGCSFilesForCleanupExpectation{mock: mmScanGCSFilesForCleanup.mock}
	}
	mmScanGCSFilesForCleanup.defaultExpectation.results = &RepositoryMockScanGCSFilesForCleanupResults{ga1, err}
	mmScanGCSFilesForCleanup.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmScanGCSFilesForCleanup.mock
}

// Set uses given function f to mock the Repository.ScanGCSFilesForCleanup method
func (mmScanGCSFilesForCleanup *mRepositoryMockScanGCSFilesForCleanup) Set(f func(ctx context.Context, maxCount int64) (ga1 []mm_repository.GCSFileInfo, err error)) *RepositoryMock {
	if mmScanGCSFilesForCleanup.defaultExpectation != nil {
		mmScanGCSFilesForCleanup.mock.t.Fatalf("Default expectation is already set for the Repository.ScanGCSFilesForCleanup method")
	}

	if len(mmScanGCSFilesForCleanup.expectations) > 0 {
		mmScanGCSFilesForCleanup.mock.t.Fatalf("Some expectations are already set for the Repository.ScanGCSFilesForCleanup method")
	}

	mmScanGCSFilesForCleanup.mock.funcScanGCSFilesForCleanup = f
	mmScanGCSFilesForCleanup.mock.funcScanGCSFilesForCleanupOrigin = minimock.CallerInfo(1)
	return mmScanGCSFilesForCleanup.mock
}

// When sets expectation for the Repository.ScanGCSFilesForCleanup which will trigger the result defined by the following
// Then helper
func (mmScanGCSFilesForCleanup *mRepositoryMockScanGCSFilesForCleanup) When(ctx context.Context, maxCount int64) *RepositoryMockScanGCSFilesForCleanupExpectation {
	if mmScanGCSFilesForCleanup.mock.funcScanGCSFilesForCleanup != nil {
		mmScanGCSFilesForCleanup.mock.t.Fatalf("RepositoryMock.ScanGCSFilesForCleanup mock is already set by Set")
	}

	expectation := &RepositoryMockScanGCSFilesForCleanupExpectation{
		mock:               mmScanGCSFilesForCleanup.mock,
		params:             &RepositoryMockScanGCSFilesForCleanupParams{ctx, maxCount},
		expectationOrigins: RepositoryMockScanGCSFilesForCleanupExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmScanGCSFilesForCleanup.expectations = append(mmScanGCSFilesForCleanup.expectations, expectation)
	return expectation
}

// Then sets up Repository.ScanGCSFilesForCleanup return parameters for the expectation previously defined by the When method
func (e *RepositoryMockScanGCSFilesForCleanupExpectation) Then(ga1 []mm_repository.GCSFileInfo, err error) *RepositoryMock {
	e.results = &RepositoryMockScanGCSFilesForCleanupResults{ga1, err}
	return e.mock
}

// Times sets number of times Repository.ScanGCSFilesForCleanup should be invoked
func (mmScanGCSFilesForCleanup *mRepositoryMockScanGCSFilesForCleanup) Times(n uint64) *mRepositoryMockScanGCSFilesForCleanup {
	if n == 0 {
		mmScanGCSFilesForCleanup.mock.t.Fatalf("Times of RepositoryMock.ScanGCSFilesForCleanup mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmScanGCSFilesForCleanup.expectedInvocations, n)
	mmScanGCSFilesForCleanup.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmScanGCSFilesForCleanup
}

func (mmScanGCSFilesForCleanup *mRepositoryMockScanGCSFilesForCleanup) invocationsDone() bool {
	if len(mmScanGCSFilesForCleanup.expectations) == 0 && mmScanGCSFilesForCleanup.defaultExpectation == nil && mmScanGCSFilesForCleanup.mock.funcScanGCSFilesForCleanup == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmScanGCSFilesForCleanup.mock.afterScanGCSFilesForCleanupCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmScanGCSFilesForCleanup.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ScanGCSFilesForCleanup implements mm_repository.Repository
func (mmScanGCSFilesForCleanup *RepositoryMock) ScanGCSFilesForCleanup(ctx context.Context, maxCount int64) (ga1 []mm_repository.GCSFileInfo, err error) {
	mm_atomic.AddUint64(&mmScanGCSFilesForCleanup.beforeScanGCSFilesForCleanupCounter, 1)
	defer mm_atomic.AddUint64(&mmScanGCSFilesForCleanup.afterScanGCSFilesForCleanupCounter, 1)

	mmScanGCSFilesForCleanup.t.Helper()

	if mmScanGCSFilesForCleanup.inspectFuncScanGCSFilesForCleanup != nil {
		mmScanGCSFilesForCleanup.inspectFuncScanGCSFilesForCleanup(ctx, maxCount)
	}

	mm_params := RepositoryMockScanGCSFilesForCleanupParams{ctx, maxCount}

	// Record call args
	mmScanGCSFilesForCleanup.ScanGCSFilesForCleanupMock.mutex.Lock()
	mmScanGCSFilesForCleanup.ScanGCSFilesForCleanupMock.callArgs = append(mmScanGCSFilesForCleanup.ScanGCSFilesForCleanupMock.callArgs, &mm_params)
	mmScanGCSFilesForCleanup.ScanGCSFilesForCleanupMock.mutex.Unlock()

	for _, e := range mmScanGCSFilesForCleanup.ScanGCSFilesForCleanupMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ga1, e.results.err
		}
	}

	if mmScanGCSFilesForCleanup.ScanGCSFilesForCleanupMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmScanGCSFilesForCleanup.ScanGCSFilesForCleanupMock.defaultExpectation.Counter, 1)
		mm_want := mmScanGCSFilesForCleanup.ScanGCSFilesForCleanupMock.defaultExpectation.params
		mm_want_ptrs := mmScanGCSFilesForCleanup.ScanGCSFilesForCleanupMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockScanGCSFilesForCleanupParams{ctx, maxCount}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmScanGCSFilesForCleanup.t.Errorf("RepositoryMock.ScanGCSFilesForCleanup got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmScanGCSFilesForCleanup.ScanGCSFilesForCleanupMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.maxCount != nil && !minimock.Equal(*mm_want_ptrs.maxCount, mm_got.maxCount) {
				mmScanGCSFilesForCleanup.t.Errorf("RepositoryMock.ScanGCSFilesForCleanup got unexpected parameter maxCount, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmScanGCSFilesForCleanup.ScanGCSFilesForCleanupMock.defaultExpectation.expectationOrigins.originMaxCount, *mm_want_ptrs.maxCount, mm_got.maxCount, minimock.Diff(*mm_want_ptrs.maxCount, mm_got.maxCount))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmScanGCSFilesForCleanup.t.Errorf("RepositoryMock.ScanGCSFilesForCleanup got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmScanGCSFilesForCleanup.ScanGCSFilesForCleanupMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmScanGCSFilesForCleanup.ScanGCSFilesForCleanupMock.defaultExpectation.results
		if mm_results == nil {
			mmScanGCSFilesForCleanup.t.Fatal("No results are set for the RepositoryMock.ScanGCSFilesForCleanup")
		}
		return (*mm_results).ga1, (*mm_results).err
	}
	if mmScanGCSFilesForCleanup.funcScanGCSFilesForCleanup != nil {
		return mmScanGCSFilesForCleanup.funcScanGCSFilesForCleanup(ctx, maxCount)
	}
	mmScanGCSFilesForCleanup.t.Fatalf("Unexpected call to RepositoryMock.ScanGCSFilesForCleanup. %v %v", ctx, maxCount)
	return
}

// ScanGCSFilesForCleanupAfterCounter returns a count of finished RepositoryMock.ScanGCSFilesForCleanup invocations
func (mmScanGCSFilesForCleanup *RepositoryMock) ScanGCSFilesForCleanupAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScanGCSFilesForCleanup.afterScanGCSFilesForCleanupCounter)
}

// ScanGCSFilesForCleanupBeforeCounter returns a count of RepositoryMock.ScanGCSFilesForCleanup invocations
func (mmScanGCSFilesForCleanup *RepositoryMock) ScanGCSFilesForCleanupBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScanGCSFilesForCleanup.beforeScanGCSFilesForCleanupCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ScanGCSFilesForCleanup.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmScanGCSFilesForCleanup *mRepositoryMockScanGCSFilesForCleanup) Calls() []*RepositoryMockScanGCSFilesForCleanupParams {
	mmScanGCSFilesForCleanup.mutex.RLock()

	argCopy := make([]*RepositoryMockScanGCSFilesForCleanupParams, len(mmScanGCSFilesForCleanup.callArgs))
	copy(argCopy, mmScanGCSFilesForCleanup.callArgs)

	mmScanGCSFilesForCleanup.mutex.RUnlock()

	return argCopy
}

// MinimockScanGCSFilesForCleanupDone returns true if the count of the ScanGCSFilesForCleanup invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockScanGCSFilesForCleanupDone() bool {
	if m.ScanGCSFilesForCleanupMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ScanGCSFilesForCleanupMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ScanGCSFilesForCleanupMock.invocationsDone()
}

// MinimockScanGCSFilesForCleanupInspect logs each unmet expectation
func (m *RepositoryMock) MinimockScanGCSFilesForCleanupInspect() {
	for _, e := range m.ScanGCSFilesForCleanupMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ScanGCSFilesForCleanup at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterScanGCSFilesForCleanupCounter := mm_atomic.LoadUint64(&m.afterScanGCSFilesForCleanupCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ScanGCSFilesForCleanupMock.defaultExpectation != nil && afterScanGCSFilesForCleanupCounter < 1 {
		if m.ScanGCSFilesForCleanupMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ScanGCSFilesForCleanup at\n%s", m.ScanGCSFilesForCleanupMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ScanGCSFilesForCleanup at\n%s with params: %#v", m.ScanGCSFilesForCleanupMock.defaultExpectation.expectationOrigins.origin, *m.ScanGCSFilesForCleanupMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScanGCSFilesForCleanup != nil && afterScanGCSFilesForCleanupCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ScanGCSFilesForCleanup at\n%s", m.funcScanGCSFilesForCleanupOrigin)
	}

	if !m.ScanGCSFilesForCleanupMock.invocationsDone() && afterScanGCSFilesForCleanupCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ScanGCSFilesForCleanup at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ScanGCSFilesForCleanupMock.expectedInvocations), m.ScanGCSFilesForCleanupMock.expectedInvocationsOrigin, afterScanGCSFilesForCleanupCounter)
	}
}

type mRepositoryMockSearchVectorsInCollection struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockSearchVectorsInCollectionExpectation
	expectations       []*RepositoryMockSearchVectorsInCollectionExpectation

	callArgs []*RepositoryMockSearchVectorsInCollectionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockSearchVectorsInCollectionExpectation specifies expectation struct of the Repository.SearchVectorsInCollection
type RepositoryMockSearchVectorsInCollectionExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockSearchVectorsInCollectionParams
	paramPtrs          *RepositoryMockSearchVectorsInCollectionParamPtrs
	expectationOrigins RepositoryMockSearchVectorsInCollectionExpectationOrigins
	results            *RepositoryMockSearchVectorsInCollectionResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockSearchVectorsInCollectionParams contains parameters of the Repository.SearchVectorsInCollection
type RepositoryMockSearchVectorsInCollectionParams struct {
	ctx context.Context
	s1  mm_repository.SearchVectorParam
}

// RepositoryMockSearchVectorsInCollectionParamPtrs contains pointers to parameters of the Repository.SearchVectorsInCollection
type RepositoryMockSearchVectorsInCollectionParamPtrs struct {
	ctx *context.Context
	s1  *mm_repository.SearchVectorParam
}

// RepositoryMockSearchVectorsInCollectionResults contains results of the Repository.SearchVectorsInCollection
type RepositoryMockSearchVectorsInCollectionResults struct {
	saa1 [][]mm_repository.SimilarVectorEmbedding
	err  error
}

// RepositoryMockSearchVectorsInCollectionOrigins contains origins of expectations of the Repository.SearchVectorsInCollection
type RepositoryMockSearchVectorsInCollectionExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearchVectorsInCollection *mRepositoryMockSearchVectorsInCollection) Optional() *mRepositoryMockSearchVectorsInCollection {
	mmSearchVectorsInCollection.optional = true
	return mmSearchVectorsInCollection
}

// Expect sets up expected params for Repository.SearchVectorsInCollection
func (mmSearchVectorsInCollection *mRepositoryMockSearchVectorsInCollection) Expect(ctx context.Context, s1 mm_repository.SearchVectorParam) *mRepositoryMockSearchVectorsInCollection {
	if mmSearchVectorsInCollection.mock.funcSearchVectorsInCollection != nil {
		mmSearchVectorsInCollection.mock.t.Fatalf("RepositoryMock.SearchVectorsInCollection mock is already set by Set")
	}

	if mmSearchVectorsInCollection.defaultExpectation == nil {
		mmSearchVectorsInCollection.defaultExpectation = &RepositoryMockSearchVectorsInCollectionExpectation{}
	}

	if mmSearchVectorsInCollection.defaultExpectation.paramPtrs != nil {
		mmSearchVectorsInCollection.mock.t.Fatalf("RepositoryMock.SearchVectorsInCollection mock is already set by ExpectParams functions")
	}

	mmSearchVectorsInCollection.defaultExpectation.params = &RepositoryMockSearchVectorsInCollectionParams{ctx, s1}
	mmSearchVectorsInCollection.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearchVectorsInCollection.expectations {
		if minimock.Equal(e.params, mmSearchVectorsInCollection.defaultExpectation.params) {
			mmSearchVectorsInCollection.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearchVectorsInCollection.defaultExpectation.params)
		}
	}

	return mmSearchVectorsInCollection
}

// ExpectCtxParam1 sets up expected param ctx for Repository.SearchVectorsInCollection
func (mmSearchVectorsInCollection *mRepositoryMockSearchVectorsInCollection) ExpectCtxParam1(ctx context.Context) *mRepositoryMockSearchVectorsInCollection {
	if mmSearchVectorsInCollection.mock.funcSearchVectorsInCollection != nil {
		mmSearchVectorsInCollection.mock.t.Fatalf("RepositoryMock.SearchVectorsInCollection mock is already set by Set")
	}

	if mmSearchVectorsInCollection.defaultExpectation == nil {
		mmSearchVectorsInCollection.defaultExpectation = &RepositoryMockSearchVectorsInCollectionExpectation{}
	}

	if mmSearchVectorsInCollection.defaultExpectation.params != nil {
		mmSearchVectorsInCollection.mock.t.Fatalf("RepositoryMock.SearchVectorsInCollection mock is already set by Expect")
	}

	if mmSearchVectorsInCollection.defaultExpectation.paramPtrs == nil {
		mmSearchVectorsInCollection.defaultExpectation.paramPtrs = &RepositoryMockSearchVectorsInCollectionParamPtrs{}
	}
	mmSearchVectorsInCollection.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearchVectorsInCollection.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearchVectorsInCollection
}

// ExpectS1Param2 sets up expected param s1 for Repository.SearchVectorsInCollection
func (mmSearchVectorsInCollection *mRepositoryMockSearchVectorsInCollection) ExpectS1Param2(s1 mm_repository.SearchVectorParam) *mRepositoryMockSearchVectorsInCollection {
	if mmSearchVectorsInCollection.mock.funcSearchVectorsInCollection != nil {
		mmSearchVectorsInCollection.mock.t.Fatalf("RepositoryMock.SearchVectorsInCollection mock is already set by Set")
	}

	if mmSearchVectorsInCollection.defaultExpectation == nil {
		mmSearchVectorsInCollection.defaultExpectation = &RepositoryMockSearchVectorsInCollectionExpectation{}
	}

	if mmSearchVectorsInCollection.defaultExpectation.params != nil {
		mmSearchVectorsInCollection.mock.t.Fatalf("RepositoryMock.SearchVectorsInCollection mock is already set by Expect")
	}

	if mmSearchVectorsInCollection.defaultExpectation.paramPtrs == nil {
		mmSearchVectorsInCollection.defaultExpectation.paramPtrs = &RepositoryMockSearchVectorsInCollectionParamPtrs{}
	}
	mmSearchVectorsInCollection.defaultExpectation.paramPtrs.s1 = &s1
	mmSearchVectorsInCollection.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmSearchVectorsInCollection
}

// Inspect accepts an inspector function that has same arguments as the Repository.SearchVectorsInCollection
func (mmSearchVectorsInCollection *mRepositoryMockSearchVectorsInCollection) Inspect(f func(ctx context.Context, s1 mm_repository.SearchVectorParam)) *mRepositoryMockSearchVectorsInCollection {
	if mmSearchVectorsInCollection.mock.inspectFuncSearchVectorsInCollection != nil {
		mmSearchVectorsInCollection.mock.t.Fatalf("Inspect function is already set for RepositoryMock.SearchVectorsInCollection")
	}

	mmSearchVectorsInCollection.mock.inspectFuncSearchVectorsInCollection = f

	return mmSearchVectorsInCollection
}

// Return sets up results that will be returned by Repository.SearchVectorsInCollection
func (mmSearchVectorsInCollection *mRepositoryMockSearchVectorsInCollection) Return(saa1 [][]mm_repository.SimilarVectorEmbedding, err error) *RepositoryMock {
	if mmSearchVectorsInCollection.mock.funcSearchVectorsInCollection != nil {
		mmSearchVectorsInCollection.mock.t.Fatalf("RepositoryMock.SearchVectorsInCollection mock is already set by Set")
	}

	if mmSearchVectorsInCollection.defaultExpectation == nil {
		mmSearchVectorsInCollection.defaultExpectation = &RepositoryMockSearchVectorsInCollectionExpectation{mock: mmSearchVectorsInCollection.mock}
	}
	mmSearchVectorsInCollection.defaultExpectation.results = &RepositoryMockSearchVectorsInCollectionResults{saa1, err}
	mmSearchVectorsInCollection.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearchVectorsInCollection.mock
}

// Set uses given function f to mock the Repository.SearchVectorsInCollection method
func (mmSearchVectorsInCollection *mRepositoryMockSearchVectorsInCollection) Set(f func(ctx context.Context, s1 mm_repository.SearchVectorParam) (saa1 [][]mm_repository.SimilarVectorEmbedding, err error)) *RepositoryMock {
	if mmSearchVectorsInCollection.defaultExpectation != nil {
		mmSearchVectorsInCollection.mock.t.Fatalf("Default expectation is already set for the Repository.SearchVectorsInCollection method")
	}

	if len(mmSearchVectorsInCollection.expectations) > 0 {
		mmSearchVectorsInCollection.mock.t.Fatalf("Some expectations are already set for the Repository.SearchVectorsInCollection method")
	}

	mmSearchVectorsInCollection.mock.funcSearchVectorsInCollection = f
	mmSearchVectorsInCollection.mock.funcSearchVectorsInCollectionOrigin = minimock.CallerInfo(1)
	return mmSearchVectorsInCollection.mock
}

// When sets expectation for the Repository.SearchVectorsInCollection which will trigger the result defined by the following
// Then helper
func (mmSearchVectorsInCollection *mRepositoryMockSearchVectorsInCollection) When(ctx context.Context, s1 mm_repository.SearchVectorParam) *RepositoryMockSearchVectorsInCollectionExpectation {
	if mmSearchVectorsInCollection.mock.funcSearchVectorsInCollection != nil {
		mmSearchVectorsInCollection.mock.t.Fatalf("RepositoryMock.SearchVectorsInCollection mock is already set by Set")
	}

	expectation := &RepositoryMockSearchVectorsInCollectionExpectation{
		mock:               mmSearchVectorsInCollection.mock,
		params:             &RepositoryMockSearchVectorsInCollectionParams{ctx, s1},
		expectationOrigins: RepositoryMockSearchVectorsInCollectionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearchVectorsInCollection.expectations = append(mmSearchVectorsInCollection.expectations, expectation)
	return expectation
}

// Then sets up Repository.SearchVectorsInCollection return parameters for the expectation previously defined by the When method
func (e *RepositoryMockSearchVectorsInCollectionExpectation) Then(saa1 [][]mm_repository.SimilarVectorEmbedding, err error) *RepositoryMock {
	e.results = &RepositoryMockSearchVectorsInCollectionResults{saa1, err}
	return e.mock
}

// Times sets number of times Repository.SearchVectorsInCollection should be invoked
func (mmSearchVectorsInCollection *mRepositoryMockSearchVectorsInCollection) Times(n uint64) *mRepositoryMockSearchVectorsInCollection {
	if n == 0 {
		mmSearchVectorsInCollection.mock.t.Fatalf("Times of RepositoryMock.SearchVectorsInCollection mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearchVectorsInCollection.expectedInvocations, n)
	mmSearchVectorsInCollection.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearchVectorsInCollection
}

func (mmSearchVectorsInCollection *mRepositoryMockSearchVectorsInCollection) invocationsDone() bool {
	if len(mmSearchVectorsInCollection.expectations) == 0 && mmSearchVectorsInCollection.defaultExpectation == nil && mmSearchVectorsInCollection.mock.funcSearchVectorsInCollection == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearchVectorsInCollection.mock.afterSearchVectorsInCollectionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearchVectorsInCollection.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SearchVectorsInCollection implements mm_repository.Repository
func (mmSearchVectorsInCollection *RepositoryMock) SearchVectorsInCollection(ctx context.Context, s1 mm_repository.SearchVectorParam) (saa1 [][]mm_repository.SimilarVectorEmbedding, err error) {
	mm_atomic.AddUint64(&mmSearchVectorsInCollection.beforeSearchVectorsInCollectionCounter, 1)
	defer mm_atomic.AddUint64(&mmSearchVectorsInCollection.afterSearchVectorsInCollectionCounter, 1)

	mmSearchVectorsInCollection.t.Helper()

	if mmSearchVectorsInCollection.inspectFuncSearchVectorsInCollection != nil {
		mmSearchVectorsInCollection.inspectFuncSearchVectorsInCollection(ctx, s1)
	}

	mm_params := RepositoryMockSearchVectorsInCollectionParams{ctx, s1}

	// Record call args
	mmSearchVectorsInCollection.SearchVectorsInCollectionMock.mutex.Lock()
	mmSearchVectorsInCollection.SearchVectorsInCollectionMock.callArgs = append(mmSearchVectorsInCollection.SearchVectorsInCollectionMock.callArgs, &mm_params)
	mmSearchVectorsInCollection.SearchVectorsInCollectionMock.mutex.Unlock()

	for _, e := range mmSearchVectorsInCollection.SearchVectorsInCollectionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.saa1, e.results.err
		}
	}

	if mmSearchVectorsInCollection.SearchVectorsInCollectionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearchVectorsInCollection.SearchVectorsInCollectionMock.defaultExpectation.Counter, 1)
		mm_want := mmSearchVectorsInCollection.SearchVectorsInCollectionMock.defaultExpectation.params
		mm_want_ptrs := mmSearchVectorsInCollection.SearchVectorsInCollectionMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockSearchVectorsInCollectionParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearchVectorsInCollection.t.Errorf("RepositoryMock.SearchVectorsInCollection got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchVectorsInCollection.SearchVectorsInCollectionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmSearchVectorsInCollection.t.Errorf("RepositoryMock.SearchVectorsInCollection got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchVectorsInCollection.SearchVectorsInCollectionMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearchVectorsInCollection.t.Errorf("RepositoryMock.SearchVectorsInCollection got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearchVectorsInCollection.SearchVectorsInCollectionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearchVectorsInCollection.SearchVectorsInCollectionMock.defaultExpectation.results
		if mm_results == nil {
			mmSearchVectorsInCollection.t.Fatal("No results are set for the RepositoryMock.SearchVectorsInCollection")
		}
		return (*mm_results).saa1, (*mm_results).err
	}
	if mmSearchVectorsInCollection.funcSearchVectorsInCollection != nil {
		return mmSearchVectorsInCollection.funcSearchVectorsInCollection(ctx, s1)
	}
	mmSearchVectorsInCollection.t.Fatalf("Unexpected call to RepositoryMock.SearchVectorsInCollection. %v %v", ctx, s1)
	return
}

// SearchVectorsInCollectionAfterCounter returns a count of finished RepositoryMock.SearchVectorsInCollection invocations
func (mmSearchVectorsInCollection *RepositoryMock) SearchVectorsInCollectionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchVectorsInCollection.afterSearchVectorsInCollectionCounter)
}

// SearchVectorsInCollectionBeforeCounter returns a count of RepositoryMock.SearchVectorsInCollection invocations
func (mmSearchVectorsInCollection *RepositoryMock) SearchVectorsInCollectionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchVectorsInCollection.beforeSearchVectorsInCollectionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.SearchVectorsInCollection.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearchVectorsInCollection *mRepositoryMockSearchVectorsInCollection) Calls() []*RepositoryMockSearchVectorsInCollectionParams {
	mmSearchVectorsInCollection.mutex.RLock()

	argCopy := make([]*RepositoryMockSearchVectorsInCollectionParams, len(mmSearchVectorsInCollection.callArgs))
	copy(argCopy, mmSearchVectorsInCollection.callArgs)

	mmSearchVectorsInCollection.mutex.RUnlock()

	return argCopy
}

// MinimockSearchVectorsInCollectionDone returns true if the count of the SearchVectorsInCollection invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockSearchVectorsInCollectionDone() bool {
	if m.SearchVectorsInCollectionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchVectorsInCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchVectorsInCollectionMock.invocationsDone()
}

// MinimockSearchVectorsInCollectionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockSearchVectorsInCollectionInspect() {
	for _, e := range m.SearchVectorsInCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.SearchVectorsInCollection at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchVectorsInCollectionCounter := mm_atomic.LoadUint64(&m.afterSearchVectorsInCollectionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchVectorsInCollectionMock.defaultExpectation != nil && afterSearchVectorsInCollectionCounter < 1 {
		if m.SearchVectorsInCollectionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.SearchVectorsInCollection at\n%s", m.SearchVectorsInCollectionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.SearchVectorsInCollection at\n%s with params: %#v", m.SearchVectorsInCollectionMock.defaultExpectation.expectationOrigins.origin, *m.SearchVectorsInCollectionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchVectorsInCollection != nil && afterSearchVectorsInCollectionCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.SearchVectorsInCollection at\n%s", m.funcSearchVectorsInCollectionOrigin)
	}

	if !m.SearchVectorsInCollectionMock.invocationsDone() && afterSearchVectorsInCollectionCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.SearchVectorsInCollection at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchVectorsInCollectionMock.expectedInvocations), m.SearchVectorsInCollectionMock.expectedInvocationsOrigin, afterSearchVectorsInCollectionCounter)
	}
}

type mRepositoryMockSetCacheMetadata struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockSetCacheMetadataExpectation
	expectations       []*RepositoryMockSetCacheMetadataExpectation

	callArgs []*RepositoryMockSetCacheMetadataParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockSetCacheMetadataExpectation specifies expectation struct of the Repository.SetCacheMetadata
type RepositoryMockSetCacheMetadataExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockSetCacheMetadataParams
	paramPtrs          *RepositoryMockSetCacheMetadataParamPtrs
	expectationOrigins RepositoryMockSetCacheMetadataExpectationOrigins
	results            *RepositoryMockSetCacheMetadataResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockSetCacheMetadataParams contains parameters of the Repository.SetCacheMetadata
type RepositoryMockSetCacheMetadataParams struct {
	ctx      context.Context
	kbUID    types.KBUIDType
	fileUIDs []types.FileUIDType
	metadata *mm_repository.CacheMetadata
	ttl      time.Duration
}

// RepositoryMockSetCacheMetadataParamPtrs contains pointers to parameters of the Repository.SetCacheMetadata
type RepositoryMockSetCacheMetadataParamPtrs struct {
	ctx      *context.Context
	kbUID    *types.KBUIDType
	fileUIDs *[]types.FileUIDType
	metadata **mm_repository.CacheMetadata
	ttl      *time.Duration
}

// RepositoryMockSetCacheMetadataResults contains results of the Repository.SetCacheMetadata
type RepositoryMockSetCacheMetadataResults struct {
	err error
}

// RepositoryMockSetCacheMetadataOrigins contains origins of expectations of the Repository.SetCacheMetadata
type RepositoryMockSetCacheMetadataExpectationOrigins struct {
	origin         string
	originCtx      string
	originKbUID    string
	originFileUIDs string
	originMetadata string
	originTtl      string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetCacheMetadata *mRepositoryMockSetCacheMetadata) Optional() *mRepositoryMockSetCacheMetadata {
	mmSetCacheMetadata.optional = true
	return mmSetCacheMetadata
}

// Expect sets up expected params for Repository.SetCacheMetadata
func (mmSetCacheMetadata *mRepositoryMockSetCacheMetadata) Expect(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType, metadata *mm_repository.CacheMetadata, ttl time.Duration) *mRepositoryMockSetCacheMetadata {
	if mmSetCacheMetadata.mock.funcSetCacheMetadata != nil {
		mmSetCacheMetadata.mock.t.Fatalf("RepositoryMock.SetCacheMetadata mock is already set by Set")
	}

	if mmSetCacheMetadata.defaultExpectation == nil {
		mmSetCacheMetadata.defaultExpectation = &RepositoryMockSetCacheMetadataExpectation{}
	}

	if mmSetCacheMetadata.defaultExpectation.paramPtrs != nil {
		mmSetCacheMetadata.mock.t.Fatalf("RepositoryMock.SetCacheMetadata mock is already set by ExpectParams functions")
	}

	mmSetCacheMetadata.defaultExpectation.params = &RepositoryMockSetCacheMetadataParams{ctx, kbUID, fileUIDs, metadata, ttl}
	mmSetCacheMetadata.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetCacheMetadata.expectations {
		if minimock.Equal(e.params, mmSetCacheMetadata.defaultExpectation.params) {
			mmSetCacheMetadata.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetCacheMetadata.defaultExpectation.params)
		}
	}

	return mmSetCacheMetadata
}

// ExpectCtxParam1 sets up expected param ctx for Repository.SetCacheMetadata
func (mmSetCacheMetadata *mRepositoryMockSetCacheMetadata) ExpectCtxParam1(ctx context.Context) *mRepositoryMockSetCacheMetadata {
	if mmSetCacheMetadata.mock.funcSetCacheMetadata != nil {
		mmSetCacheMetadata.mock.t.Fatalf("RepositoryMock.SetCacheMetadata mock is already set by Set")
	}

	if mmSetCacheMetadata.defaultExpectation == nil {
		mmSetCacheMetadata.defaultExpectation = &RepositoryMockSetCacheMetadataExpectation{}
	}

	if mmSetCacheMetadata.defaultExpectation.params != nil {
		mmSetCacheMetadata.mock.t.Fatalf("RepositoryMock.SetCacheMetadata mock is already set by Expect")
	}

	if mmSetCacheMetadata.defaultExpectation.paramPtrs == nil {
		mmSetCacheMetadata.defaultExpectation.paramPtrs = &RepositoryMockSetCacheMetadataParamPtrs{}
	}
	mmSetCacheMetadata.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetCacheMetadata.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetCacheMetadata
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.SetCacheMetadata
func (mmSetCacheMetadata *mRepositoryMockSetCacheMetadata) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockSetCacheMetadata {
	if mmSetCacheMetadata.mock.funcSetCacheMetadata != nil {
		mmSetCacheMetadata.mock.t.Fatalf("RepositoryMock.SetCacheMetadata mock is already set by Set")
	}

	if mmSetCacheMetadata.defaultExpectation == nil {
		mmSetCacheMetadata.defaultExpectation = &RepositoryMockSetCacheMetadataExpectation{}
	}

	if mmSetCacheMetadata.defaultExpectation.params != nil {
		mmSetCacheMetadata.mock.t.Fatalf("RepositoryMock.SetCacheMetadata mock is already set by Expect")
	}

	if mmSetCacheMetadata.defaultExpectation.paramPtrs == nil {
		mmSetCacheMetadata.defaultExpectation.paramPtrs = &RepositoryMockSetCacheMetadataParamPtrs{}
	}
	mmSetCacheMetadata.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmSetCacheMetadata.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmSetCacheMetadata
}

// ExpectFileUIDsParam3 sets up expected param fileUIDs for Repository.SetCacheMetadata
func (mmSetCacheMetadata *mRepositoryMockSetCacheMetadata) ExpectFileUIDsParam3(fileUIDs []types.FileUIDType) *mRepositoryMockSetCacheMetadata {
	if mmSetCacheMetadata.mock.funcSetCacheMetadata != nil {
		mmSetCacheMetadata.mock.t.Fatalf("RepositoryMock.SetCacheMetadata mock is already set by Set")
	}

	if mmSetCacheMetadata.defaultExpectation == nil {
		mmSetCacheMetadata.defaultExpectation = &RepositoryMockSetCacheMetadataExpectation{}
	}

	if mmSetCacheMetadata.defaultExpectation.params != nil {
		mmSetCacheMetadata.mock.t.Fatalf("RepositoryMock.SetCacheMetadata mock is already set by Expect")
	}

	if mmSetCacheMetadata.defaultExpectation.paramPtrs == nil {
		mmSetCacheMetadata.defaultExpectation.paramPtrs = &RepositoryMockSetCacheMetadataParamPtrs{}
	}
	mmSetCacheMetadata.defaultExpectation.paramPtrs.fileUIDs = &fileUIDs
	mmSetCacheMetadata.defaultExpectation.expectationOrigins.originFileUIDs = minimock.CallerInfo(1)

	return mmSetCacheMetadata
}

// ExpectMetadataParam4 sets up expected param metadata for Repository.SetCacheMetadata
func (mmSetCacheMetadata *mRepositoryMockSetCacheMetadata) ExpectMetadataParam4(metadata *mm_repository.CacheMetadata) *mRepositoryMockSetCacheMetadata {
	if mmSetCacheMetadata.mock.funcSetCacheMetadata != nil {
		mmSetCacheMetadata.mock.t.Fatalf("RepositoryMock.SetCacheMetadata mock is already set by Set")
	}

	if mmSetCacheMetadata.defaultExpectation == nil {
		mmSetCacheMetadata.defaultExpectation = &RepositoryMockSetCacheMetadataExpectation{}
	}

	if mmSetCacheMetadata.defaultExpectation.params != nil {
		mmSetCacheMetadata.mock.t.Fatalf("RepositoryMock.SetCacheMetadata mock is already set by Expect")
	}

	if mmSetCacheMetadata.defaultExpectation.paramPtrs == nil {
		mmSetCacheMetadata.defaultExpectation.paramPtrs = &RepositoryMockSetCacheMetadataParamPtrs{}
	}
	mmSetCacheMetadata.defaultExpectation.paramPtrs.metadata = &metadata
	mmSetCacheMetadata.defaultExpectation.expectationOrigins.originMetadata = minimock.CallerInfo(1)

	return mmSetCacheMetadata
}

// ExpectTtlParam5 sets up expected param ttl for Repository.SetCacheMetadata
func (mmSetCacheMetadata *mRepositoryMockSetCacheMetadata) ExpectTtlParam5(ttl time.Duration) *mRepositoryMockSetCacheMetadata {
	if mmSetCacheMetadata.mock.funcSetCacheMetadata != nil {
		mmSetCacheMetadata.mock.t.Fatalf("RepositoryMock.SetCacheMetadata mock is already set by Set")
	}

	if mmSetCacheMetadata.defaultExpectation == nil {
		mmSetCacheMetadata.defaultExpectation = &RepositoryMockSetCacheMetadataExpectation{}
	}

	if mmSetCacheMetadata.defaultExpectation.params != nil {
		mmSetCacheMetadata.mock.t.Fatalf("RepositoryMock.SetCacheMetadata mock is already set by Expect")
	}

	if mmSetCacheMetadata.defaultExpectation.paramPtrs == nil {
		mmSetCacheMetadata.defaultExpectation.paramPtrs = &RepositoryMockSetCacheMetadataParamPtrs{}
	}
	mmSetCacheMetadata.defaultExpectation.paramPtrs.ttl = &ttl
	mmSetCacheMetadata.defaultExpectation.expectationOrigins.originTtl = minimock.CallerInfo(1)

	return mmSetCacheMetadata
}

// Inspect accepts an inspector function that has same arguments as the Repository.SetCacheMetadata
func (mmSetCacheMetadata *mRepositoryMockSetCacheMetadata) Inspect(f func(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType, metadata *mm_repository.CacheMetadata, ttl time.Duration)) *mRepositoryMockSetCacheMetadata {
	if mmSetCacheMetadata.mock.inspectFuncSetCacheMetadata != nil {
		mmSetCacheMetadata.mock.t.Fatalf("Inspect function is already set for RepositoryMock.SetCacheMetadata")
	}

	mmSetCacheMetadata.mock.inspectFuncSetCacheMetadata = f

	return mmSetCacheMetadata
}

// Return sets up results that will be returned by Repository.SetCacheMetadata
func (mmSetCacheMetadata *mRepositoryMockSetCacheMetadata) Return(err error) *RepositoryMock {
	if mmSetCacheMetadata.mock.funcSetCacheMetadata != nil {
		mmSetCacheMetadata.mock.t.Fatalf("RepositoryMock.SetCacheMetadata mock is already set by Set")
	}

	if mmSetCacheMetadata.defaultExpectation == nil {
		mmSetCacheMetadata.defaultExpectation = &RepositoryMockSetCacheMetadataExpectation{mock: mmSetCacheMetadata.mock}
	}
	mmSetCacheMetadata.defaultExpectation.results = &RepositoryMockSetCacheMetadataResults{err}
	mmSetCacheMetadata.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetCacheMetadata.mock
}

// Set uses given function f to mock the Repository.SetCacheMetadata method
func (mmSetCacheMetadata *mRepositoryMockSetCacheMetadata) Set(f func(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType, metadata *mm_repository.CacheMetadata, ttl time.Duration) (err error)) *RepositoryMock {
	if mmSetCacheMetadata.defaultExpectation != nil {
		mmSetCacheMetadata.mock.t.Fatalf("Default expectation is already set for the Repository.SetCacheMetadata method")
	}

	if len(mmSetCacheMetadata.expectations) > 0 {
		mmSetCacheMetadata.mock.t.Fatalf("Some expectations are already set for the Repository.SetCacheMetadata method")
	}

	mmSetCacheMetadata.mock.funcSetCacheMetadata = f
	mmSetCacheMetadata.mock.funcSetCacheMetadataOrigin = minimock.CallerInfo(1)
	return mmSetCacheMetadata.mock
}

// When sets expectation for the Repository.SetCacheMetadata which will trigger the result defined by the following
// Then helper
func (mmSetCacheMetadata *mRepositoryMockSetCacheMetadata) When(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType, metadata *mm_repository.CacheMetadata, ttl time.Duration) *RepositoryMockSetCacheMetadataExpectation {
	if mmSetCacheMetadata.mock.funcSetCacheMetadata != nil {
		mmSetCacheMetadata.mock.t.Fatalf("RepositoryMock.SetCacheMetadata mock is already set by Set")
	}

	expectation := &RepositoryMockSetCacheMetadataExpectation{
		mock:               mmSetCacheMetadata.mock,
		params:             &RepositoryMockSetCacheMetadataParams{ctx, kbUID, fileUIDs, metadata, ttl},
		expectationOrigins: RepositoryMockSetCacheMetadataExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetCacheMetadata.expectations = append(mmSetCacheMetadata.expectations, expectation)
	return expectation
}

// Then sets up Repository.SetCacheMetadata return parameters for the expectation previously defined by the When method
func (e *RepositoryMockSetCacheMetadataExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockSetCacheMetadataResults{err}
	return e.mock
}

// Times sets number of times Repository.SetCacheMetadata should be invoked
func (mmSetCacheMetadata *mRepositoryMockSetCacheMetadata) Times(n uint64) *mRepositoryMockSetCacheMetadata {
	if n == 0 {
		mmSetCacheMetadata.mock.t.Fatalf("Times of RepositoryMock.SetCacheMetadata mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetCacheMetadata.expectedInvocations, n)
	mmSetCacheMetadata.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetCacheMetadata
}

func (mmSetCacheMetadata *mRepositoryMockSetCacheMetadata) invocationsDone() bool {
	if len(mmSetCacheMetadata.expectations) == 0 && mmSetCacheMetadata.defaultExpectation == nil && mmSetCacheMetadata.mock.funcSetCacheMetadata == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetCacheMetadata.mock.afterSetCacheMetadataCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetCacheMetadata.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetCacheMetadata implements mm_repository.Repository
func (mmSetCacheMetadata *RepositoryMock) SetCacheMetadata(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType, metadata *mm_repository.CacheMetadata, ttl time.Duration) (err error) {
	mm_atomic.AddUint64(&mmSetCacheMetadata.beforeSetCacheMetadataCounter, 1)
	defer mm_atomic.AddUint64(&mmSetCacheMetadata.afterSetCacheMetadataCounter, 1)

	mmSetCacheMetadata.t.Helper()

	if mmSetCacheMetadata.inspectFuncSetCacheMetadata != nil {
		mmSetCacheMetadata.inspectFuncSetCacheMetadata(ctx, kbUID, fileUIDs, metadata, ttl)
	}

	mm_params := RepositoryMockSetCacheMetadataParams{ctx, kbUID, fileUIDs, metadata, ttl}

	// Record call args
	mmSetCacheMetadata.SetCacheMetadataMock.mutex.Lock()
	mmSetCacheMetadata.SetCacheMetadataMock.callArgs = append(mmSetCacheMetadata.SetCacheMetadataMock.callArgs, &mm_params)
	mmSetCacheMetadata.SetCacheMetadataMock.mutex.Unlock()

	for _, e := range mmSetCacheMetadata.SetCacheMetadataMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetCacheMetadata.SetCacheMetadataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetCacheMetadata.SetCacheMetadataMock.defaultExpectation.Counter, 1)
		mm_want := mmSetCacheMetadata.SetCacheMetadataMock.defaultExpectation.params
		mm_want_ptrs := mmSetCacheMetadata.SetCacheMetadataMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockSetCacheMetadataParams{ctx, kbUID, fileUIDs, metadata, ttl}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetCacheMetadata.t.Errorf("RepositoryMock.SetCacheMetadata got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetCacheMetadata.SetCacheMetadataMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmSetCacheMetadata.t.Errorf("RepositoryMock.SetCacheMetadata got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetCacheMetadata.SetCacheMetadataMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.fileUIDs != nil && !minimock.Equal(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs) {
				mmSetCacheMetadata.t.Errorf("RepositoryMock.SetCacheMetadata got unexpected parameter fileUIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetCacheMetadata.SetCacheMetadataMock.defaultExpectation.expectationOrigins.originFileUIDs, *mm_want_ptrs.fileUIDs, mm_got.fileUIDs, minimock.Diff(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs))
			}

			if mm_want_ptrs.metadata != nil && !minimock.Equal(*mm_want_ptrs.metadata, mm_got.metadata) {
				mmSetCacheMetadata.t.Errorf("RepositoryMock.SetCacheMetadata got unexpected parameter metadata, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetCacheMetadata.SetCacheMetadataMock.defaultExpectation.expectationOrigins.originMetadata, *mm_want_ptrs.metadata, mm_got.metadata, minimock.Diff(*mm_want_ptrs.metadata, mm_got.metadata))
			}

			if mm_want_ptrs.ttl != nil && !minimock.Equal(*mm_want_ptrs.ttl, mm_got.ttl) {
				mmSetCacheMetadata.t.Errorf("RepositoryMock.SetCacheMetadata got unexpected parameter ttl, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetCacheMetadata.SetCacheMetadataMock.defaultExpectation.expectationOrigins.originTtl, *mm_want_ptrs.ttl, mm_got.ttl, minimock.Diff(*mm_want_ptrs.ttl, mm_got.ttl))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetCacheMetadata.t.Errorf("RepositoryMock.SetCacheMetadata got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetCacheMetadata.SetCacheMetadataMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetCacheMetadata.SetCacheMetadataMock.defaultExpectation.results
		if mm_results == nil {
			mmSetCacheMetadata.t.Fatal("No results are set for the RepositoryMock.SetCacheMetadata")
		}
		return (*mm_results).err
	}
	if mmSetCacheMetadata.funcSetCacheMetadata != nil {
		return mmSetCacheMetadata.funcSetCacheMetadata(ctx, kbUID, fileUIDs, metadata, ttl)
	}
	mmSetCacheMetadata.t.Fatalf("Unexpected call to RepositoryMock.SetCacheMetadata. %v %v %v %v %v", ctx, kbUID, fileUIDs, metadata, ttl)
	return
}

// SetCacheMetadataAfterCounter returns a count of finished RepositoryMock.SetCacheMetadata invocations
func (mmSetCacheMetadata *RepositoryMock) SetCacheMetadataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetCacheMetadata.afterSetCacheMetadataCounter)
}

// SetCacheMetadataBeforeCounter returns a count of RepositoryMock.SetCacheMetadata invocations
func (mmSetCacheMetadata *RepositoryMock) SetCacheMetadataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetCacheMetadata.beforeSetCacheMetadataCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.SetCacheMetadata.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetCacheMetadata *mRepositoryMockSetCacheMetadata) Calls() []*RepositoryMockSetCacheMetadataParams {
	mmSetCacheMetadata.mutex.RLock()

	argCopy := make([]*RepositoryMockSetCacheMetadataParams, len(mmSetCacheMetadata.callArgs))
	copy(argCopy, mmSetCacheMetadata.callArgs)

	mmSetCacheMetadata.mutex.RUnlock()

	return argCopy
}

// MinimockSetCacheMetadataDone returns true if the count of the SetCacheMetadata invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockSetCacheMetadataDone() bool {
	if m.SetCacheMetadataMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetCacheMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetCacheMetadataMock.invocationsDone()
}

// MinimockSetCacheMetadataInspect logs each unmet expectation
func (m *RepositoryMock) MinimockSetCacheMetadataInspect() {
	for _, e := range m.SetCacheMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.SetCacheMetadata at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetCacheMetadataCounter := mm_atomic.LoadUint64(&m.afterSetCacheMetadataCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetCacheMetadataMock.defaultExpectation != nil && afterSetCacheMetadataCounter < 1 {
		if m.SetCacheMetadataMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.SetCacheMetadata at\n%s", m.SetCacheMetadataMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.SetCacheMetadata at\n%s with params: %#v", m.SetCacheMetadataMock.defaultExpectation.expectationOrigins.origin, *m.SetCacheMetadataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetCacheMetadata != nil && afterSetCacheMetadataCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.SetCacheMetadata at\n%s", m.funcSetCacheMetadataOrigin)
	}

	if !m.SetCacheMetadataMock.invocationsDone() && afterSetCacheMetadataCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.SetCacheMetadata at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetCacheMetadataMock.expectedInvocations), m.SetCacheMetadataMock.expectedInvocationsOrigin, afterSetCacheMetadataCounter)
	}
}

type mRepositoryMockSetDefaultSystem struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockSetDefaultSystemExpectation
	expectations       []*RepositoryMockSetDefaultSystemExpectation

	callArgs []*RepositoryMockSetDefaultSystemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockSetDefaultSystemExpectation specifies expectation struct of the Repository.SetDefaultSystem
type RepositoryMockSetDefaultSystemExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockSetDefaultSystemParams
	paramPtrs          *RepositoryMockSetDefaultSystemParamPtrs
	expectationOrigins RepositoryMockSetDefaultSystemExpectationOrigins
	results            *RepositoryMockSetDefaultSystemResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockSetDefaultSystemParams contains parameters of the Repository.SetDefaultSystem
type RepositoryMockSetDefaultSystemParams struct {
	ctx context.Context
	id  string
}

// RepositoryMockSetDefaultSystemParamPtrs contains pointers to parameters of the Repository.SetDefaultSystem
type RepositoryMockSetDefaultSystemParamPtrs struct {
	ctx *context.Context
	id  *string
}

// RepositoryMockSetDefaultSystemResults contains results of the Repository.SetDefaultSystem
type RepositoryMockSetDefaultSystemResults struct {
	err error
}

// RepositoryMockSetDefaultSystemOrigins contains origins of expectations of the Repository.SetDefaultSystem
type RepositoryMockSetDefaultSystemExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetDefaultSystem *mRepositoryMockSetDefaultSystem) Optional() *mRepositoryMockSetDefaultSystem {
	mmSetDefaultSystem.optional = true
	return mmSetDefaultSystem
}

// Expect sets up expected params for Repository.SetDefaultSystem
func (mmSetDefaultSystem *mRepositoryMockSetDefaultSystem) Expect(ctx context.Context, id string) *mRepositoryMockSetDefaultSystem {
	if mmSetDefaultSystem.mock.funcSetDefaultSystem != nil {
		mmSetDefaultSystem.mock.t.Fatalf("RepositoryMock.SetDefaultSystem mock is already set by Set")
	}

	if mmSetDefaultSystem.defaultExpectation == nil {
		mmSetDefaultSystem.defaultExpectation = &RepositoryMockSetDefaultSystemExpectation{}
	}

	if mmSetDefaultSystem.defaultExpectation.paramPtrs != nil {
		mmSetDefaultSystem.mock.t.Fatalf("RepositoryMock.SetDefaultSystem mock is already set by ExpectParams functions")
	}

	mmSetDefaultSystem.defaultExpectation.params = &RepositoryMockSetDefaultSystemParams{ctx, id}
	mmSetDefaultSystem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetDefaultSystem.expectations {
		if minimock.Equal(e.params, mmSetDefaultSystem.defaultExpectation.params) {
			mmSetDefaultSystem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetDefaultSystem.defaultExpectation.params)
		}
	}

	return mmSetDefaultSystem
}

// ExpectCtxParam1 sets up expected param ctx for Repository.SetDefaultSystem
func (mmSetDefaultSystem *mRepositoryMockSetDefaultSystem) ExpectCtxParam1(ctx context.Context) *mRepositoryMockSetDefaultSystem {
	if mmSetDefaultSystem.mock.funcSetDefaultSystem != nil {
		mmSetDefaultSystem.mock.t.Fatalf("RepositoryMock.SetDefaultSystem mock is already set by Set")
	}

	if mmSetDefaultSystem.defaultExpectation == nil {
		mmSetDefaultSystem.defaultExpectation = &RepositoryMockSetDefaultSystemExpectation{}
	}

	if mmSetDefaultSystem.defaultExpectation.params != nil {
		mmSetDefaultSystem.mock.t.Fatalf("RepositoryMock.SetDefaultSystem mock is already set by Expect")
	}

	if mmSetDefaultSystem.defaultExpectation.paramPtrs == nil {
		mmSetDefaultSystem.defaultExpectation.paramPtrs = &RepositoryMockSetDefaultSystemParamPtrs{}
	}
	mmSetDefaultSystem.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetDefaultSystem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetDefaultSystem
}

// ExpectIdParam2 sets up expected param id for Repository.SetDefaultSystem
func (mmSetDefaultSystem *mRepositoryMockSetDefaultSystem) ExpectIdParam2(id string) *mRepositoryMockSetDefaultSystem {
	if mmSetDefaultSystem.mock.funcSetDefaultSystem != nil {
		mmSetDefaultSystem.mock.t.Fatalf("RepositoryMock.SetDefaultSystem mock is already set by Set")
	}

	if mmSetDefaultSystem.defaultExpectation == nil {
		mmSetDefaultSystem.defaultExpectation = &RepositoryMockSetDefaultSystemExpectation{}
	}

	if mmSetDefaultSystem.defaultExpectation.params != nil {
		mmSetDefaultSystem.mock.t.Fatalf("RepositoryMock.SetDefaultSystem mock is already set by Expect")
	}

	if mmSetDefaultSystem.defaultExpectation.paramPtrs == nil {
		mmSetDefaultSystem.defaultExpectation.paramPtrs = &RepositoryMockSetDefaultSystemParamPtrs{}
	}
	mmSetDefaultSystem.defaultExpectation.paramPtrs.id = &id
	mmSetDefaultSystem.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmSetDefaultSystem
}

// Inspect accepts an inspector function that has same arguments as the Repository.SetDefaultSystem
func (mmSetDefaultSystem *mRepositoryMockSetDefaultSystem) Inspect(f func(ctx context.Context, id string)) *mRepositoryMockSetDefaultSystem {
	if mmSetDefaultSystem.mock.inspectFuncSetDefaultSystem != nil {
		mmSetDefaultSystem.mock.t.Fatalf("Inspect function is already set for RepositoryMock.SetDefaultSystem")
	}

	mmSetDefaultSystem.mock.inspectFuncSetDefaultSystem = f

	return mmSetDefaultSystem
}

// Return sets up results that will be returned by Repository.SetDefaultSystem
func (mmSetDefaultSystem *mRepositoryMockSetDefaultSystem) Return(err error) *RepositoryMock {
	if mmSetDefaultSystem.mock.funcSetDefaultSystem != nil {
		mmSetDefaultSystem.mock.t.Fatalf("RepositoryMock.SetDefaultSystem mock is already set by Set")
	}

	if mmSetDefaultSystem.defaultExpectation == nil {
		mmSetDefaultSystem.defaultExpectation = &RepositoryMockSetDefaultSystemExpectation{mock: mmSetDefaultSystem.mock}
	}
	mmSetDefaultSystem.defaultExpectation.results = &RepositoryMockSetDefaultSystemResults{err}
	mmSetDefaultSystem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetDefaultSystem.mock
}

// Set uses given function f to mock the Repository.SetDefaultSystem method
func (mmSetDefaultSystem *mRepositoryMockSetDefaultSystem) Set(f func(ctx context.Context, id string) (err error)) *RepositoryMock {
	if mmSetDefaultSystem.defaultExpectation != nil {
		mmSetDefaultSystem.mock.t.Fatalf("Default expectation is already set for the Repository.SetDefaultSystem method")
	}

	if len(mmSetDefaultSystem.expectations) > 0 {
		mmSetDefaultSystem.mock.t.Fatalf("Some expectations are already set for the Repository.SetDefaultSystem method")
	}

	mmSetDefaultSystem.mock.funcSetDefaultSystem = f
	mmSetDefaultSystem.mock.funcSetDefaultSystemOrigin = minimock.CallerInfo(1)
	return mmSetDefaultSystem.mock
}

// When sets expectation for the Repository.SetDefaultSystem which will trigger the result defined by the following
// Then helper
func (mmSetDefaultSystem *mRepositoryMockSetDefaultSystem) When(ctx context.Context, id string) *RepositoryMockSetDefaultSystemExpectation {
	if mmSetDefaultSystem.mock.funcSetDefaultSystem != nil {
		mmSetDefaultSystem.mock.t.Fatalf("RepositoryMock.SetDefaultSystem mock is already set by Set")
	}

	expectation := &RepositoryMockSetDefaultSystemExpectation{
		mock:               mmSetDefaultSystem.mock,
		params:             &RepositoryMockSetDefaultSystemParams{ctx, id},
		expectationOrigins: RepositoryMockSetDefaultSystemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetDefaultSystem.expectations = append(mmSetDefaultSystem.expectations, expectation)
	return expectation
}

// Then sets up Repository.SetDefaultSystem return parameters for the expectation previously defined by the When method
func (e *RepositoryMockSetDefaultSystemExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockSetDefaultSystemResults{err}
	return e.mock
}

// Times sets number of times Repository.SetDefaultSystem should be invoked
func (mmSetDefaultSystem *mRepositoryMockSetDefaultSystem) Times(n uint64) *mRepositoryMockSetDefaultSystem {
	if n == 0 {
		mmSetDefaultSystem.mock.t.Fatalf("Times of RepositoryMock.SetDefaultSystem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetDefaultSystem.expectedInvocations, n)
	mmSetDefaultSystem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetDefaultSystem
}

func (mmSetDefaultSystem *mRepositoryMockSetDefaultSystem) invocationsDone() bool {
	if len(mmSetDefaultSystem.expectations) == 0 && mmSetDefaultSystem.defaultExpectation == nil && mmSetDefaultSystem.mock.funcSetDefaultSystem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetDefaultSystem.mock.afterSetDefaultSystemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetDefaultSystem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetDefaultSystem implements mm_repository.Repository
func (mmSetDefaultSystem *RepositoryMock) SetDefaultSystem(ctx context.Context, id string) (err error) {
	mm_atomic.AddUint64(&mmSetDefaultSystem.beforeSetDefaultSystemCounter, 1)
	defer mm_atomic.AddUint64(&mmSetDefaultSystem.afterSetDefaultSystemCounter, 1)

	mmSetDefaultSystem.t.Helper()

	if mmSetDefaultSystem.inspectFuncSetDefaultSystem != nil {
		mmSetDefaultSystem.inspectFuncSetDefaultSystem(ctx, id)
	}

	mm_params := RepositoryMockSetDefaultSystemParams{ctx, id}

	// Record call args
	mmSetDefaultSystem.SetDefaultSystemMock.mutex.Lock()
	mmSetDefaultSystem.SetDefaultSystemMock.callArgs = append(mmSetDefaultSystem.SetDefaultSystemMock.callArgs, &mm_params)
	mmSetDefaultSystem.SetDefaultSystemMock.mutex.Unlock()

	for _, e := range mmSetDefaultSystem.SetDefaultSystemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetDefaultSystem.SetDefaultSystemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetDefaultSystem.SetDefaultSystemMock.defaultExpectation.Counter, 1)
		mm_want := mmSetDefaultSystem.SetDefaultSystemMock.defaultExpectation.params
		mm_want_ptrs := mmSetDefaultSystem.SetDefaultSystemMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockSetDefaultSystemParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetDefaultSystem.t.Errorf("RepositoryMock.SetDefaultSystem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetDefaultSystem.SetDefaultSystemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmSetDefaultSystem.t.Errorf("RepositoryMock.SetDefaultSystem got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetDefaultSystem.SetDefaultSystemMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetDefaultSystem.t.Errorf("RepositoryMock.SetDefaultSystem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetDefaultSystem.SetDefaultSystemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetDefaultSystem.SetDefaultSystemMock.defaultExpectation.results
		if mm_results == nil {
			mmSetDefaultSystem.t.Fatal("No results are set for the RepositoryMock.SetDefaultSystem")
		}
		return (*mm_results).err
	}
	if mmSetDefaultSystem.funcSetDefaultSystem != nil {
		return mmSetDefaultSystem.funcSetDefaultSystem(ctx, id)
	}
	mmSetDefaultSystem.t.Fatalf("Unexpected call to RepositoryMock.SetDefaultSystem. %v %v", ctx, id)
	return
}

// SetDefaultSystemAfterCounter returns a count of finished RepositoryMock.SetDefaultSystem invocations
func (mmSetDefaultSystem *RepositoryMock) SetDefaultSystemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDefaultSystem.afterSetDefaultSystemCounter)
}

// SetDefaultSystemBeforeCounter returns a count of RepositoryMock.SetDefaultSystem invocations
func (mmSetDefaultSystem *RepositoryMock) SetDefaultSystemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDefaultSystem.beforeSetDefaultSystemCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.SetDefaultSystem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetDefaultSystem *mRepositoryMockSetDefaultSystem) Calls() []*RepositoryMockSetDefaultSystemParams {
	mmSetDefaultSystem.mutex.RLock()

	argCopy := make([]*RepositoryMockSetDefaultSystemParams, len(mmSetDefaultSystem.callArgs))
	copy(argCopy, mmSetDefaultSystem.callArgs)

	mmSetDefaultSystem.mutex.RUnlock()

	return argCopy
}

// MinimockSetDefaultSystemDone returns true if the count of the SetDefaultSystem invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockSetDefaultSystemDone() bool {
	if m.SetDefaultSystemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetDefaultSystemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetDefaultSystemMock.invocationsDone()
}

// MinimockSetDefaultSystemInspect logs each unmet expectation
func (m *RepositoryMock) MinimockSetDefaultSystemInspect() {
	for _, e := range m.SetDefaultSystemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.SetDefaultSystem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetDefaultSystemCounter := mm_atomic.LoadUint64(&m.afterSetDefaultSystemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetDefaultSystemMock.defaultExpectation != nil && afterSetDefaultSystemCounter < 1 {
		if m.SetDefaultSystemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.SetDefaultSystem at\n%s", m.SetDefaultSystemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.SetDefaultSystem at\n%s with params: %#v", m.SetDefaultSystemMock.defaultExpectation.expectationOrigins.origin, *m.SetDefaultSystemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDefaultSystem != nil && afterSetDefaultSystemCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.SetDefaultSystem at\n%s", m.funcSetDefaultSystemOrigin)
	}

	if !m.SetDefaultSystemMock.invocationsDone() && afterSetDefaultSystemCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.SetDefaultSystem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetDefaultSystemMock.expectedInvocations), m.SetDefaultSystemMock.expectedInvocationsOrigin, afterSetDefaultSystemCounter)
	}
}

type mRepositoryMockSetGCSFileInfo struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockSetGCSFileInfoExpectation
	expectations       []*RepositoryMockSetGCSFileInfoExpectation

	callArgs []*RepositoryMockSetGCSFileInfoParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockSetGCSFileInfoExpectation specifies expectation struct of the Repository.SetGCSFileInfo
type RepositoryMockSetGCSFileInfoExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockSetGCSFileInfoParams
	paramPtrs          *RepositoryMockSetGCSFileInfoParamPtrs
	expectationOrigins RepositoryMockSetGCSFileInfoExpectationOrigins
	results            *RepositoryMockSetGCSFileInfoResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockSetGCSFileInfoParams contains parameters of the Repository.SetGCSFileInfo
type RepositoryMockSetGCSFileInfoParams struct {
	ctx     context.Context
	kbUID   types.KBUIDType
	fileUID types.FileUIDType
	view    string
	gcsInfo *mm_repository.GCSFileInfo
	ttl     time.Duration
}

// RepositoryMockSetGCSFileInfoParamPtrs contains pointers to parameters of the Repository.SetGCSFileInfo
type RepositoryMockSetGCSFileInfoParamPtrs struct {
	ctx     *context.Context
	kbUID   *types.KBUIDType
	fileUID *types.FileUIDType
	view    *string
	gcsInfo **mm_repository.GCSFileInfo
	ttl     *time.Duration
}

// RepositoryMockSetGCSFileInfoResults contains results of the Repository.SetGCSFileInfo
type RepositoryMockSetGCSFileInfoResults struct {
	err error
}

// RepositoryMockSetGCSFileInfoOrigins contains origins of expectations of the Repository.SetGCSFileInfo
type RepositoryMockSetGCSFileInfoExpectationOrigins struct {
	origin        string
	originCtx     string
	originKbUID   string
	originFileUID string
	originView    string
	originGcsInfo string
	originTtl     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetGCSFileInfo *mRepositoryMockSetGCSFileInfo) Optional() *mRepositoryMockSetGCSFileInfo {
	mmSetGCSFileInfo.optional = true
	return mmSetGCSFileInfo
}

// Expect sets up expected params for Repository.SetGCSFileInfo
func (mmSetGCSFileInfo *mRepositoryMockSetGCSFileInfo) Expect(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, view string, gcsInfo *mm_repository.GCSFileInfo, ttl time.Duration) *mRepositoryMockSetGCSFileInfo {
	if mmSetGCSFileInfo.mock.funcSetGCSFileInfo != nil {
		mmSetGCSFileInfo.mock.t.Fatalf("RepositoryMock.SetGCSFileInfo mock is already set by Set")
	}

	if mmSetGCSFileInfo.defaultExpectation == nil {
		mmSetGCSFileInfo.defaultExpectation = &RepositoryMockSetGCSFileInfoExpectation{}
	}

	if mmSetGCSFileInfo.defaultExpectation.paramPtrs != nil {
		mmSetGCSFileInfo.mock.t.Fatalf("RepositoryMock.SetGCSFileInfo mock is already set by ExpectParams functions")
	}

	mmSetGCSFileInfo.defaultExpectation.params = &RepositoryMockSetGCSFileInfoParams{ctx, kbUID, fileUID, view, gcsInfo, ttl}
	mmSetGCSFileInfo.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetGCSFileInfo.expectations {
		if minimock.Equal(e.params, mmSetGCSFileInfo.defaultExpectation.params) {
			mmSetGCSFileInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetGCSFileInfo.defaultExpectation.params)
		}
	}

	return mmSetGCSFileInfo
}

// ExpectCtxParam1 sets up expected param ctx for Repository.SetGCSFileInfo
func (mmSetGCSFileInfo *mRepositoryMockSetGCSFileInfo) ExpectCtxParam1(ctx context.Context) *mRepositoryMockSetGCSFileInfo {
	if mmSetGCSFileInfo.mock.funcSetGCSFileInfo != nil {
		mmSetGCSFileInfo.mock.t.Fatalf("RepositoryMock.SetGCSFileInfo mock is already set by Set")
	}

	if mmSetGCSFileInfo.defaultExpectation == nil {
		mmSetGCSFileInfo.defaultExpectation = &RepositoryMockSetGCSFileInfoExpectation{}
	}

	if mmSetGCSFileInfo.defaultExpectation.params != nil {
		mmSetGCSFileInfo.mock.t.Fatalf("RepositoryMock.SetGCSFileInfo mock is already set by Expect")
	}

	if mmSetGCSFileInfo.defaultExpectation.paramPtrs == nil {
		mmSetGCSFileInfo.defaultExpectation.paramPtrs = &RepositoryMockSetGCSFileInfoParamPtrs{}
	}
	mmSetGCSFileInfo.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetGCSFileInfo.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetGCSFileInfo
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.SetGCSFileInfo
func (mmSetGCSFileInfo *mRepositoryMockSetGCSFileInfo) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockSetGCSFileInfo {
	if mmSetGCSFileInfo.mock.funcSetGCSFileInfo != nil {
		mmSetGCSFileInfo.mock.t.Fatalf("RepositoryMock.SetGCSFileInfo mock is already set by Set")
	}

	if mmSetGCSFileInfo.defaultExpectation == nil {
		mmSetGCSFileInfo.defaultExpectation = &RepositoryMockSetGCSFileInfoExpectation{}
	}

	if mmSetGCSFileInfo.defaultExpectation.params != nil {
		mmSetGCSFileInfo.mock.t.Fatalf("RepositoryMock.SetGCSFileInfo mock is already set by Expect")
	}

	if mmSetGCSFileInfo.defaultExpectation.paramPtrs == nil {
		mmSetGCSFileInfo.defaultExpectation.paramPtrs = &RepositoryMockSetGCSFileInfoParamPtrs{}
	}
	mmSetGCSFileInfo.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmSetGCSFileInfo.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmSetGCSFileInfo
}

// ExpectFileUIDParam3 sets up expected param fileUID for Repository.SetGCSFileInfo
func (mmSetGCSFileInfo *mRepositoryMockSetGCSFileInfo) ExpectFileUIDParam3(fileUID types.FileUIDType) *mRepositoryMockSetGCSFileInfo {
	if mmSetGCSFileInfo.mock.funcSetGCSFileInfo != nil {
		mmSetGCSFileInfo.mock.t.Fatalf("RepositoryMock.SetGCSFileInfo mock is already set by Set")
	}

	if mmSetGCSFileInfo.defaultExpectation == nil {
		mmSetGCSFileInfo.defaultExpectation = &RepositoryMockSetGCSFileInfoExpectation{}
	}

	if mmSetGCSFileInfo.defaultExpectation.params != nil {
		mmSetGCSFileInfo.mock.t.Fatalf("RepositoryMock.SetGCSFileInfo mock is already set by Expect")
	}

	if mmSetGCSFileInfo.defaultExpectation.paramPtrs == nil {
		mmSetGCSFileInfo.defaultExpectation.paramPtrs = &RepositoryMockSetGCSFileInfoParamPtrs{}
	}
	mmSetGCSFileInfo.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmSetGCSFileInfo.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmSetGCSFileInfo
}

// ExpectViewParam4 sets up expected param view for Repository.SetGCSFileInfo
func (mmSetGCSFileInfo *mRepositoryMockSetGCSFileInfo) ExpectViewParam4(view string) *mRepositoryMockSetGCSFileInfo {
	if mmSetGCSFileInfo.mock.funcSetGCSFileInfo != nil {
		mmSetGCSFileInfo.mock.t.Fatalf("RepositoryMock.SetGCSFileInfo mock is already set by Set")
	}

	if mmSetGCSFileInfo.defaultExpectation == nil {
		mmSetGCSFileInfo.defaultExpectation = &RepositoryMockSetGCSFileInfoExpectation{}
	}

	if mmSetGCSFileInfo.defaultExpectation.params != nil {
		mmSetGCSFileInfo.mock.t.Fatalf("RepositoryMock.SetGCSFileInfo mock is already set by Expect")
	}

	if mmSetGCSFileInfo.defaultExpectation.paramPtrs == nil {
		mmSetGCSFileInfo.defaultExpectation.paramPtrs = &RepositoryMockSetGCSFileInfoParamPtrs{}
	}
	mmSetGCSFileInfo.defaultExpectation.paramPtrs.view = &view
	mmSetGCSFileInfo.defaultExpectation.expectationOrigins.originView = minimock.CallerInfo(1)

	return mmSetGCSFileInfo
}

// ExpectGcsInfoParam5 sets up expected param gcsInfo for Repository.SetGCSFileInfo
func (mmSetGCSFileInfo *mRepositoryMockSetGCSFileInfo) ExpectGcsInfoParam5(gcsInfo *mm_repository.GCSFileInfo) *mRepositoryMockSetGCSFileInfo {
	if mmSetGCSFileInfo.mock.funcSetGCSFileInfo != nil {
		mmSetGCSFileInfo.mock.t.Fatalf("RepositoryMock.SetGCSFileInfo mock is already set by Set")
	}

	if mmSetGCSFileInfo.defaultExpectation == nil {
		mmSetGCSFileInfo.defaultExpectation = &RepositoryMockSetGCSFileInfoExpectation{}
	}

	if mmSetGCSFileInfo.defaultExpectation.params != nil {
		mmSetGCSFileInfo.mock.t.Fatalf("RepositoryMock.SetGCSFileInfo mock is already set by Expect")
	}

	if mmSetGCSFileInfo.defaultExpectation.paramPtrs == nil {
		mmSetGCSFileInfo.defaultExpectation.paramPtrs = &RepositoryMockSetGCSFileInfoParamPtrs{}
	}
	mmSetGCSFileInfo.defaultExpectation.paramPtrs.gcsInfo = &gcsInfo
	mmSetGCSFileInfo.defaultExpectation.expectationOrigins.originGcsInfo = minimock.CallerInfo(1)

	return mmSetGCSFileInfo
}

// ExpectTtlParam6 sets up expected param ttl for Repository.SetGCSFileInfo
func (mmSetGCSFileInfo *mRepositoryMockSetGCSFileInfo) ExpectTtlParam6(ttl time.Duration) *mRepositoryMockSetGCSFileInfo {
	if mmSetGCSFileInfo.mock.funcSetGCSFileInfo != nil {
		mmSetGCSFileInfo.mock.t.Fatalf("RepositoryMock.SetGCSFileInfo mock is already set by Set")
	}

	if mmSetGCSFileInfo.defaultExpectation == nil {
		mmSetGCSFileInfo.defaultExpectation = &RepositoryMockSetGCSFileInfoExpectation{}
	}

	if mmSetGCSFileInfo.defaultExpectation.params != nil {
		mmSetGCSFileInfo.mock.t.Fatalf("RepositoryMock.SetGCSFileInfo mock is already set by Expect")
	}

	if mmSetGCSFileInfo.defaultExpectation.paramPtrs == nil {
		mmSetGCSFileInfo.defaultExpectation.paramPtrs = &RepositoryMockSetGCSFileInfoParamPtrs{}
	}
	mmSetGCSFileInfo.defaultExpectation.paramPtrs.ttl = &ttl
	mmSetGCSFileInfo.defaultExpectation.expectationOrigins.originTtl = minimock.CallerInfo(1)

	return mmSetGCSFileInfo
}

// Inspect accepts an inspector function that has same arguments as the Repository.SetGCSFileInfo
func (mmSetGCSFileInfo *mRepositoryMockSetGCSFileInfo) Inspect(f func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, view string, gcsInfo *mm_repository.GCSFileInfo, ttl time.Duration)) *mRepositoryMockSetGCSFileInfo {
	if mmSetGCSFileInfo.mock.inspectFuncSetGCSFileInfo != nil {
		mmSetGCSFileInfo.mock.t.Fatalf("Inspect function is already set for RepositoryMock.SetGCSFileInfo")
	}

	mmSetGCSFileInfo.mock.inspectFuncSetGCSFileInfo = f

	return mmSetGCSFileInfo
}

// Return sets up results that will be returned by Repository.SetGCSFileInfo
func (mmSetGCSFileInfo *mRepositoryMockSetGCSFileInfo) Return(err error) *RepositoryMock {
	if mmSetGCSFileInfo.mock.funcSetGCSFileInfo != nil {
		mmSetGCSFileInfo.mock.t.Fatalf("RepositoryMock.SetGCSFileInfo mock is already set by Set")
	}

	if mmSetGCSFileInfo.defaultExpectation == nil {
		mmSetGCSFileInfo.defaultExpectation = &RepositoryMockSetGCSFileInfoExpectation{mock: mmSetGCSFileInfo.mock}
	}
	mmSetGCSFileInfo.defaultExpectation.results = &RepositoryMockSetGCSFileInfoResults{err}
	mmSetGCSFileInfo.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetGCSFileInfo.mock
}

// Set uses given function f to mock the Repository.SetGCSFileInfo method
func (mmSetGCSFileInfo *mRepositoryMockSetGCSFileInfo) Set(f func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, view string, gcsInfo *mm_repository.GCSFileInfo, ttl time.Duration) (err error)) *RepositoryMock {
	if mmSetGCSFileInfo.defaultExpectation != nil {
		mmSetGCSFileInfo.mock.t.Fatalf("Default expectation is already set for the Repository.SetGCSFileInfo method")
	}

	if len(mmSetGCSFileInfo.expectations) > 0 {
		mmSetGCSFileInfo.mock.t.Fatalf("Some expectations are already set for the Repository.SetGCSFileInfo method")
	}

	mmSetGCSFileInfo.mock.funcSetGCSFileInfo = f
	mmSetGCSFileInfo.mock.funcSetGCSFileInfoOrigin = minimock.CallerInfo(1)
	return mmSetGCSFileInfo.mock
}

// When sets expectation for the Repository.SetGCSFileInfo which will trigger the result defined by the following
// Then helper
func (mmSetGCSFileInfo *mRepositoryMockSetGCSFileInfo) When(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, view string, gcsInfo *mm_repository.GCSFileInfo, ttl time.Duration) *RepositoryMockSetGCSFileInfoExpectation {
	if mmSetGCSFileInfo.mock.funcSetGCSFileInfo != nil {
		mmSetGCSFileInfo.mock.t.Fatalf("RepositoryMock.SetGCSFileInfo mock is already set by Set")
	}

	expectation := &RepositoryMockSetGCSFileInfoExpectation{
		mock:               mmSetGCSFileInfo.mock,
		params:             &RepositoryMockSetGCSFileInfoParams{ctx, kbUID, fileUID, view, gcsInfo, ttl},
		expectationOrigins: RepositoryMockSetGCSFileInfoExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetGCSFileInfo.expectations = append(mmSetGCSFileInfo.expectations, expectation)
	return expectation
}

// Then sets up Repository.SetGCSFileInfo return parameters for the expectation previously defined by the When method
func (e *RepositoryMockSetGCSFileInfoExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockSetGCSFileInfoResults{err}
	return e.mock
}

// Times sets number of times Repository.SetGCSFileInfo should be invoked
func (mmSetGCSFileInfo *mRepositoryMockSetGCSFileInfo) Times(n uint64) *mRepositoryMockSetGCSFileInfo {
	if n == 0 {
		mmSetGCSFileInfo.mock.t.Fatalf("Times of RepositoryMock.SetGCSFileInfo mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetGCSFileInfo.expectedInvocations, n)
	mmSetGCSFileInfo.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetGCSFileInfo
}

func (mmSetGCSFileInfo *mRepositoryMockSetGCSFileInfo) invocationsDone() bool {
	if len(mmSetGCSFileInfo.expectations) == 0 && mmSetGCSFileInfo.defaultExpectation == nil && mmSetGCSFileInfo.mock.funcSetGCSFileInfo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetGCSFileInfo.mock.afterSetGCSFileInfoCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetGCSFileInfo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetGCSFileInfo implements mm_repository.Repository
func (mmSetGCSFileInfo *RepositoryMock) SetGCSFileInfo(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, view string, gcsInfo *mm_repository.GCSFileInfo, ttl time.Duration) (err error) {
	mm_atomic.AddUint64(&mmSetGCSFileInfo.beforeSetGCSFileInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmSetGCSFileInfo.afterSetGCSFileInfoCounter, 1)

	mmSetGCSFileInfo.t.Helper()

	if mmSetGCSFileInfo.inspectFuncSetGCSFileInfo != nil {
		mmSetGCSFileInfo.inspectFuncSetGCSFileInfo(ctx, kbUID, fileUID, view, gcsInfo, ttl)
	}

	mm_params := RepositoryMockSetGCSFileInfoParams{ctx, kbUID, fileUID, view, gcsInfo, ttl}

	// Record call args
	mmSetGCSFileInfo.SetGCSFileInfoMock.mutex.Lock()
	mmSetGCSFileInfo.SetGCSFileInfoMock.callArgs = append(mmSetGCSFileInfo.SetGCSFileInfoMock.callArgs, &mm_params)
	mmSetGCSFileInfo.SetGCSFileInfoMock.mutex.Unlock()

	for _, e := range mmSetGCSFileInfo.SetGCSFileInfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetGCSFileInfo.SetGCSFileInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetGCSFileInfo.SetGCSFileInfoMock.defaultExpectation.Counter, 1)
		mm_want := mmSetGCSFileInfo.SetGCSFileInfoMock.defaultExpectation.params
		mm_want_ptrs := mmSetGCSFileInfo.SetGCSFileInfoMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockSetGCSFileInfoParams{ctx, kbUID, fileUID, view, gcsInfo, ttl}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetGCSFileInfo.t.Errorf("RepositoryMock.SetGCSFileInfo got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetGCSFileInfo.SetGCSFileInfoMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmSetGCSFileInfo.t.Errorf("RepositoryMock.SetGCSFileInfo got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetGCSFileInfo.SetGCSFileInfoMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmSetGCSFileInfo.t.Errorf("RepositoryMock.SetGCSFileInfo got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetGCSFileInfo.SetGCSFileInfoMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

			if mm_want_ptrs.view != nil && !minimock.Equal(*mm_want_ptrs.view, mm_got.view) {
				mmSetGCSFileInfo.t.Errorf("RepositoryMock.SetGCSFileInfo got unexpected parameter view, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetGCSFileInfo.SetGCSFileInfoMock.defaultExpectation.expectationOrigins.originView, *mm_want_ptrs.view, mm_got.view, minimock.Diff(*mm_want_ptrs.view, mm_got.view))
			}

			if mm_want_ptrs.gcsInfo != nil && !minimock.Equal(*mm_want_ptrs.gcsInfo, mm_got.gcsInfo) {
				mmSetGCSFileInfo.t.Errorf("RepositoryMock.SetGCSFileInfo got unexpected parameter gcsInfo, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetGCSFileInfo.SetGCSFileInfoMock.defaultExpectation.expectationOrigins.originGcsInfo, *mm_want_ptrs.gcsInfo, mm_got.gcsInfo, minimock.Diff(*mm_want_ptrs.gcsInfo, mm_got.gcsInfo))
			}

			if mm_want_ptrs.ttl != nil && !minimock.Equal(*mm_want_ptrs.ttl, mm_got.ttl) {
				mmSetGCSFileInfo.t.Errorf("RepositoryMock.SetGCSFileInfo got unexpected parameter ttl, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetGCSFileInfo.SetGCSFileInfoMock.defaultExpectation.expectationOrigins.originTtl, *mm_want_ptrs.ttl, mm_got.ttl, minimock.Diff(*mm_want_ptrs.ttl, mm_got.ttl))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetGCSFileInfo.t.Errorf("RepositoryMock.SetGCSFileInfo got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetGCSFileInfo.SetGCSFileInfoMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetGCSFileInfo.SetGCSFileInfoMock.defaultExpectation.results
		if mm_results == nil {
			mmSetGCSFileInfo.t.Fatal("No results are set for the RepositoryMock.SetGCSFileInfo")
		}
		return (*mm_results).err
	}
	if mmSetGCSFileInfo.funcSetGCSFileInfo != nil {
		return mmSetGCSFileInfo.funcSetGCSFileInfo(ctx, kbUID, fileUID, view, gcsInfo, ttl)
	}
	mmSetGCSFileInfo.t.Fatalf("Unexpected call to RepositoryMock.SetGCSFileInfo. %v %v %v %v %v %v", ctx, kbUID, fileUID, view, gcsInfo, ttl)
	return
}

// SetGCSFileInfoAfterCounter returns a count of finished RepositoryMock.SetGCSFileInfo invocations
func (mmSetGCSFileInfo *RepositoryMock) SetGCSFileInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetGCSFileInfo.afterSetGCSFileInfoCounter)
}

// SetGCSFileInfoBeforeCounter returns a count of RepositoryMock.SetGCSFileInfo invocations
func (mmSetGCSFileInfo *RepositoryMock) SetGCSFileInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetGCSFileInfo.beforeSetGCSFileInfoCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.SetGCSFileInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetGCSFileInfo *mRepositoryMockSetGCSFileInfo) Calls() []*RepositoryMockSetGCSFileInfoParams {
	mmSetGCSFileInfo.mutex.RLock()

	argCopy := make([]*RepositoryMockSetGCSFileInfoParams, len(mmSetGCSFileInfo.callArgs))
	copy(argCopy, mmSetGCSFileInfo.callArgs)

	mmSetGCSFileInfo.mutex.RUnlock()

	return argCopy
}

// MinimockSetGCSFileInfoDone returns true if the count of the SetGCSFileInfo invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockSetGCSFileInfoDone() bool {
	if m.SetGCSFileInfoMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetGCSFileInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetGCSFileInfoMock.invocationsDone()
}

// MinimockSetGCSFileInfoInspect logs each unmet expectation
func (m *RepositoryMock) MinimockSetGCSFileInfoInspect() {
	for _, e := range m.SetGCSFileInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.SetGCSFileInfo at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetGCSFileInfoCounter := mm_atomic.LoadUint64(&m.afterSetGCSFileInfoCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetGCSFileInfoMock.defaultExpectation != nil && afterSetGCSFileInfoCounter < 1 {
		if m.SetGCSFileInfoMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.SetGCSFileInfo at\n%s", m.SetGCSFileInfoMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.SetGCSFileInfo at\n%s with params: %#v", m.SetGCSFileInfoMock.defaultExpectation.expectationOrigins.origin, *m.SetGCSFileInfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetGCSFileInfo != nil && afterSetGCSFileInfoCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.SetGCSFileInfo at\n%s", m.funcSetGCSFileInfoOrigin)
	}

	if !m.SetGCSFileInfoMock.invocationsDone() && afterSetGCSFileInfoCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.SetGCSFileInfo at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetGCSFileInfoMock.expectedInvocations), m.SetGCSFileInfoMock.expectedInvocationsOrigin, afterSetGCSFileInfoCounter)
	}
}

type mRepositoryMockUpdateConfigByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateConfigByIDExpectation
	expectations       []*RepositoryMockUpdateConfigByIDExpectation

	callArgs []*RepositoryMockUpdateConfigByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateConfigByIDExpectation specifies expectation struct of the Repository.UpdateConfigByID
type RepositoryMockUpdateConfigByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateConfigByIDParams
	paramPtrs          *RepositoryMockUpdateConfigByIDParamPtrs
	expectationOrigins RepositoryMockUpdateConfigByIDExpectationOrigins
	results            *RepositoryMockUpdateConfigByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateConfigByIDParams contains parameters of the Repository.UpdateConfigByID
type RepositoryMockUpdateConfigByIDParams struct {
	ctx    context.Context
	id     string
	config mm_repository.SystemConfigJSON
}

// RepositoryMockUpdateConfigByIDParamPtrs contains pointers to parameters of the Repository.UpdateConfigByID
type RepositoryMockUpdateConfigByIDParamPtrs struct {
	ctx    *context.Context
	id     *string
	config *mm_repository.SystemConfigJSON
}

// RepositoryMockUpdateConfigByIDResults contains results of the Repository.UpdateConfigByID
type RepositoryMockUpdateConfigByIDResults struct {
	err error
}

// RepositoryMockUpdateConfigByIDOrigins contains origins of expectations of the Repository.UpdateConfigByID
type RepositoryMockUpdateConfigByIDExpectationOrigins struct {
	origin       string
	originCtx    string
	originId     string
	originConfig string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateConfigByID *mRepositoryMockUpdateConfigByID) Optional() *mRepositoryMockUpdateConfigByID {
	mmUpdateConfigByID.optional = true
	return mmUpdateConfigByID
}

// Expect sets up expected params for Repository.UpdateConfigByID
func (mmUpdateConfigByID *mRepositoryMockUpdateConfigByID) Expect(ctx context.Context, id string, config mm_repository.SystemConfigJSON) *mRepositoryMockUpdateConfigByID {
	if mmUpdateConfigByID.mock.funcUpdateConfigByID != nil {
		mmUpdateConfigByID.mock.t.Fatalf("RepositoryMock.UpdateConfigByID mock is already set by Set")
	}

	if mmUpdateConfigByID.defaultExpectation == nil {
		mmUpdateConfigByID.defaultExpectation = &RepositoryMockUpdateConfigByIDExpectation{}
	}

	if mmUpdateConfigByID.defaultExpectation.paramPtrs != nil {
		mmUpdateConfigByID.mock.t.Fatalf("RepositoryMock.UpdateConfigByID mock is already set by ExpectParams functions")
	}

	mmUpdateConfigByID.defaultExpectation.params = &RepositoryMockUpdateConfigByIDParams{ctx, id, config}
	mmUpdateConfigByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateConfigByID.expectations {
		if minimock.Equal(e.params, mmUpdateConfigByID.defaultExpectation.params) {
			mmUpdateConfigByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateConfigByID.defaultExpectation.params)
		}
	}

	return mmUpdateConfigByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateConfigByID
func (mmUpdateConfigByID *mRepositoryMockUpdateConfigByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateConfigByID {
	if mmUpdateConfigByID.mock.funcUpdateConfigByID != nil {
		mmUpdateConfigByID.mock.t.Fatalf("RepositoryMock.UpdateConfigByID mock is already set by Set")
	}

	if mmUpdateConfigByID.defaultExpectation == nil {
		mmUpdateConfigByID.defaultExpectation = &RepositoryMockUpdateConfigByIDExpectation{}
	}

	if mmUpdateConfigByID.defaultExpectation.params != nil {
		mmUpdateConfigByID.mock.t.Fatalf("RepositoryMock.UpdateConfigByID mock is already set by Expect")
	}

	if mmUpdateConfigByID.defaultExpectation.paramPtrs == nil {
		mmUpdateConfigByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateConfigByIDParamPtrs{}
	}
	mmUpdateConfigByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateConfigByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateConfigByID
}

// ExpectIdParam2 sets up expected param id for Repository.UpdateConfigByID
func (mmUpdateConfigByID *mRepositoryMockUpdateConfigByID) ExpectIdParam2(id string) *mRepositoryMockUpdateConfigByID {
	if mmUpdateConfigByID.mock.funcUpdateConfigByID != nil {
		mmUpdateConfigByID.mock.t.Fatalf("RepositoryMock.UpdateConfigByID mock is already set by Set")
	}

	if mmUpdateConfigByID.defaultExpectation == nil {
		mmUpdateConfigByID.defaultExpectation = &RepositoryMockUpdateConfigByIDExpectation{}
	}

	if mmUpdateConfigByID.defaultExpectation.params != nil {
		mmUpdateConfigByID.mock.t.Fatalf("RepositoryMock.UpdateConfigByID mock is already set by Expect")
	}

	if mmUpdateConfigByID.defaultExpectation.paramPtrs == nil {
		mmUpdateConfigByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateConfigByIDParamPtrs{}
	}
	mmUpdateConfigByID.defaultExpectation.paramPtrs.id = &id
	mmUpdateConfigByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdateConfigByID
}

// ExpectConfigParam3 sets up expected param config for Repository.UpdateConfigByID
func (mmUpdateConfigByID *mRepositoryMockUpdateConfigByID) ExpectConfigParam3(config mm_repository.SystemConfigJSON) *mRepositoryMockUpdateConfigByID {
	if mmUpdateConfigByID.mock.funcUpdateConfigByID != nil {
		mmUpdateConfigByID.mock.t.Fatalf("RepositoryMock.UpdateConfigByID mock is already set by Set")
	}

	if mmUpdateConfigByID.defaultExpectation == nil {
		mmUpdateConfigByID.defaultExpectation = &RepositoryMockUpdateConfigByIDExpectation{}
	}

	if mmUpdateConfigByID.defaultExpectation.params != nil {
		mmUpdateConfigByID.mock.t.Fatalf("RepositoryMock.UpdateConfigByID mock is already set by Expect")
	}

	if mmUpdateConfigByID.defaultExpectation.paramPtrs == nil {
		mmUpdateConfigByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateConfigByIDParamPtrs{}
	}
	mmUpdateConfigByID.defaultExpectation.paramPtrs.config = &config
	mmUpdateConfigByID.defaultExpectation.expectationOrigins.originConfig = minimock.CallerInfo(1)

	return mmUpdateConfigByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateConfigByID
func (mmUpdateConfigByID *mRepositoryMockUpdateConfigByID) Inspect(f func(ctx context.Context, id string, config mm_repository.SystemConfigJSON)) *mRepositoryMockUpdateConfigByID {
	if mmUpdateConfigByID.mock.inspectFuncUpdateConfigByID != nil {
		mmUpdateConfigByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateConfigByID")
	}

	mmUpdateConfigByID.mock.inspectFuncUpdateConfigByID = f

	return mmUpdateConfigByID
}

// Return sets up results that will be returned by Repository.UpdateConfigByID
func (mmUpdateConfigByID *mRepositoryMockUpdateConfigByID) Return(err error) *RepositoryMock {
	if mmUpdateConfigByID.mock.funcUpdateConfigByID != nil {
		mmUpdateConfigByID.mock.t.Fatalf("RepositoryMock.UpdateConfigByID mock is already set by Set")
	}

	if mmUpdateConfigByID.defaultExpectation == nil {
		mmUpdateConfigByID.defaultExpectation = &RepositoryMockUpdateConfigByIDExpectation{mock: mmUpdateConfigByID.mock}
	}
	mmUpdateConfigByID.defaultExpectation.results = &RepositoryMockUpdateConfigByIDResults{err}
	mmUpdateConfigByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateConfigByID.mock
}

// Set uses given function f to mock the Repository.UpdateConfigByID method
func (mmUpdateConfigByID *mRepositoryMockUpdateConfigByID) Set(f func(ctx context.Context, id string, config mm_repository.SystemConfigJSON) (err error)) *RepositoryMock {
	if mmUpdateConfigByID.defaultExpectation != nil {
		mmUpdateConfigByID.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateConfigByID method")
	}

	if len(mmUpdateConfigByID.expectations) > 0 {
		mmUpdateConfigByID.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateConfigByID method")
	}

	mmUpdateConfigByID.mock.funcUpdateConfigByID = f
	mmUpdateConfigByID.mock.funcUpdateConfigByIDOrigin = minimock.CallerInfo(1)
	return mmUpdateConfigByID.mock
}

// When sets expectation for the Repository.UpdateConfigByID which will trigger the result defined by the following
// Then helper
func (mmUpdateConfigByID *mRepositoryMockUpdateConfigByID) When(ctx context.Context, id string, config mm_repository.SystemConfigJSON) *RepositoryMockUpdateConfigByIDExpectation {
	if mmUpdateConfigByID.mock.funcUpdateConfigByID != nil {
		mmUpdateConfigByID.mock.t.Fatalf("RepositoryMock.UpdateConfigByID mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateConfigByIDExpectation{
		mock:               mmUpdateConfigByID.mock,
		params:             &RepositoryMockUpdateConfigByIDParams{ctx, id, config},
		expectationOrigins: RepositoryMockUpdateConfigByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateConfigByID.expectations = append(mmUpdateConfigByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateConfigByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateConfigByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateConfigByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateConfigByID should be invoked
func (mmUpdateConfigByID *mRepositoryMockUpdateConfigByID) Times(n uint64) *mRepositoryMockUpdateConfigByID {
	if n == 0 {
		mmUpdateConfigByID.mock.t.Fatalf("Times of RepositoryMock.UpdateConfigByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateConfigByID.expectedInvocations, n)
	mmUpdateConfigByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateConfigByID
}

func (mmUpdateConfigByID *mRepositoryMockUpdateConfigByID) invocationsDone() bool {
	if len(mmUpdateConfigByID.expectations) == 0 && mmUpdateConfigByID.defaultExpectation == nil && mmUpdateConfigByID.mock.funcUpdateConfigByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateConfigByID.mock.afterUpdateConfigByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateConfigByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateConfigByID implements mm_repository.Repository
func (mmUpdateConfigByID *RepositoryMock) UpdateConfigByID(ctx context.Context, id string, config mm_repository.SystemConfigJSON) (err error) {
	mm_atomic.AddUint64(&mmUpdateConfigByID.beforeUpdateConfigByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateConfigByID.afterUpdateConfigByIDCounter, 1)

	mmUpdateConfigByID.t.Helper()

	if mmUpdateConfigByID.inspectFuncUpdateConfigByID != nil {
		mmUpdateConfigByID.inspectFuncUpdateConfigByID(ctx, id, config)
	}

	mm_params := RepositoryMockUpdateConfigByIDParams{ctx, id, config}

	// Record call args
	mmUpdateConfigByID.UpdateConfigByIDMock.mutex.Lock()
	mmUpdateConfigByID.UpdateConfigByIDMock.callArgs = append(mmUpdateConfigByID.UpdateConfigByIDMock.callArgs, &mm_params)
	mmUpdateConfigByID.UpdateConfigByIDMock.mutex.Unlock()

	for _, e := range mmUpdateConfigByID.UpdateConfigByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateConfigByID.UpdateConfigByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateConfigByID.UpdateConfigByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateConfigByID.UpdateConfigByIDMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateConfigByID.UpdateConfigByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateConfigByIDParams{ctx, id, config}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateConfigByID.t.Errorf("RepositoryMock.UpdateConfigByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateConfigByID.UpdateConfigByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateConfigByID.t.Errorf("RepositoryMock.UpdateConfigByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateConfigByID.UpdateConfigByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.config != nil && !minimock.Equal(*mm_want_ptrs.config, mm_got.config) {
				mmUpdateConfigByID.t.Errorf("RepositoryMock.UpdateConfigByID got unexpected parameter config, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateConfigByID.UpdateConfigByIDMock.defaultExpectation.expectationOrigins.originConfig, *mm_want_ptrs.config, mm_got.config, minimock.Diff(*mm_want_ptrs.config, mm_got.config))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateConfigByID.t.Errorf("RepositoryMock.UpdateConfigByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateConfigByID.UpdateConfigByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateConfigByID.UpdateConfigByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateConfigByID.t.Fatal("No results are set for the RepositoryMock.UpdateConfigByID")
		}
		return (*mm_results).err
	}
	if mmUpdateConfigByID.funcUpdateConfigByID != nil {
		return mmUpdateConfigByID.funcUpdateConfigByID(ctx, id, config)
	}
	mmUpdateConfigByID.t.Fatalf("Unexpected call to RepositoryMock.UpdateConfigByID. %v %v %v", ctx, id, config)
	return
}

// UpdateConfigByIDAfterCounter returns a count of finished RepositoryMock.UpdateConfigByID invocations
func (mmUpdateConfigByID *RepositoryMock) UpdateConfigByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateConfigByID.afterUpdateConfigByIDCounter)
}

// UpdateConfigByIDBeforeCounter returns a count of RepositoryMock.UpdateConfigByID invocations
func (mmUpdateConfigByID *RepositoryMock) UpdateConfigByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateConfigByID.beforeUpdateConfigByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateConfigByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateConfigByID *mRepositoryMockUpdateConfigByID) Calls() []*RepositoryMockUpdateConfigByIDParams {
	mmUpdateConfigByID.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateConfigByIDParams, len(mmUpdateConfigByID.callArgs))
	copy(argCopy, mmUpdateConfigByID.callArgs)

	mmUpdateConfigByID.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateConfigByIDDone returns true if the count of the UpdateConfigByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateConfigByIDDone() bool {
	if m.UpdateConfigByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateConfigByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateConfigByIDMock.invocationsDone()
}

// MinimockUpdateConfigByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateConfigByIDInspect() {
	for _, e := range m.UpdateConfigByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateConfigByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateConfigByIDCounter := mm_atomic.LoadUint64(&m.afterUpdateConfigByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateConfigByIDMock.defaultExpectation != nil && afterUpdateConfigByIDCounter < 1 {
		if m.UpdateConfigByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateConfigByID at\n%s", m.UpdateConfigByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateConfigByID at\n%s with params: %#v", m.UpdateConfigByIDMock.defaultExpectation.expectationOrigins.origin, *m.UpdateConfigByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateConfigByID != nil && afterUpdateConfigByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateConfigByID at\n%s", m.funcUpdateConfigByIDOrigin)
	}

	if !m.UpdateConfigByIDMock.invocationsDone() && afterUpdateConfigByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateConfigByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateConfigByIDMock.expectedInvocations), m.UpdateConfigByIDMock.expectedInvocationsOrigin, afterUpdateConfigByIDCounter)
	}
}

type mRepositoryMockUpdateConvertedFile struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateConvertedFileExpectation
	expectations       []*RepositoryMockUpdateConvertedFileExpectation

	callArgs []*RepositoryMockUpdateConvertedFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateConvertedFileExpectation specifies expectation struct of the Repository.UpdateConvertedFile
type RepositoryMockUpdateConvertedFileExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateConvertedFileParams
	paramPtrs          *RepositoryMockUpdateConvertedFileParamPtrs
	expectationOrigins RepositoryMockUpdateConvertedFileExpectationOrigins
	results            *RepositoryMockUpdateConvertedFileResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateConvertedFileParams contains parameters of the Repository.UpdateConvertedFile
type RepositoryMockUpdateConvertedFileParams struct {
	ctx    context.Context
	uid    types.ConvertedFileUIDType
	update map[string]any
}

// RepositoryMockUpdateConvertedFileParamPtrs contains pointers to parameters of the Repository.UpdateConvertedFile
type RepositoryMockUpdateConvertedFileParamPtrs struct {
	ctx    *context.Context
	uid    *types.ConvertedFileUIDType
	update *map[string]any
}

// RepositoryMockUpdateConvertedFileResults contains results of the Repository.UpdateConvertedFile
type RepositoryMockUpdateConvertedFileResults struct {
	err error
}

// RepositoryMockUpdateConvertedFileOrigins contains origins of expectations of the Repository.UpdateConvertedFile
type RepositoryMockUpdateConvertedFileExpectationOrigins struct {
	origin       string
	originCtx    string
	originUid    string
	originUpdate string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateConvertedFile *mRepositoryMockUpdateConvertedFile) Optional() *mRepositoryMockUpdateConvertedFile {
	mmUpdateConvertedFile.optional = true
	return mmUpdateConvertedFile
}

// Expect sets up expected params for Repository.UpdateConvertedFile
func (mmUpdateConvertedFile *mRepositoryMockUpdateConvertedFile) Expect(ctx context.Context, uid types.ConvertedFileUIDType, update map[string]any) *mRepositoryMockUpdateConvertedFile {
	if mmUpdateConvertedFile.mock.funcUpdateConvertedFile != nil {
		mmUpdateConvertedFile.mock.t.Fatalf("RepositoryMock.UpdateConvertedFile mock is already set by Set")
	}

	if mmUpdateConvertedFile.defaultExpectation == nil {
		mmUpdateConvertedFile.defaultExpectation = &RepositoryMockUpdateConvertedFileExpectation{}
	}

	if mmUpdateConvertedFile.defaultExpectation.paramPtrs != nil {
		mmUpdateConvertedFile.mock.t.Fatalf("RepositoryMock.UpdateConvertedFile mock is already set by ExpectParams functions")
	}

	mmUpdateConvertedFile.defaultExpectation.params = &RepositoryMockUpdateConvertedFileParams{ctx, uid, update}
	mmUpdateConvertedFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateConvertedFile.expectations {
		if minimock.Equal(e.params, mmUpdateConvertedFile.defaultExpectation.params) {
			mmUpdateConvertedFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateConvertedFile.defaultExpectation.params)
		}
	}

	return mmUpdateConvertedFile
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateConvertedFile
func (mmUpdateConvertedFile *mRepositoryMockUpdateConvertedFile) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateConvertedFile {
	if mmUpdateConvertedFile.mock.funcUpdateConvertedFile != nil {
		mmUpdateConvertedFile.mock.t.Fatalf("RepositoryMock.UpdateConvertedFile mock is already set by Set")
	}

	if mmUpdateConvertedFile.defaultExpectation == nil {
		mmUpdateConvertedFile.defaultExpectation = &RepositoryMockUpdateConvertedFileExpectation{}
	}

	if mmUpdateConvertedFile.defaultExpectation.params != nil {
		mmUpdateConvertedFile.mock.t.Fatalf("RepositoryMock.UpdateConvertedFile mock is already set by Expect")
	}

	if mmUpdateConvertedFile.defaultExpectation.paramPtrs == nil {
		mmUpdateConvertedFile.defaultExpectation.paramPtrs = &RepositoryMockUpdateConvertedFileParamPtrs{}
	}
	mmUpdateConvertedFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateConvertedFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateConvertedFile
}

// ExpectUidParam2 sets up expected param uid for Repository.UpdateConvertedFile
func (mmUpdateConvertedFile *mRepositoryMockUpdateConvertedFile) ExpectUidParam2(uid types.ConvertedFileUIDType) *mRepositoryMockUpdateConvertedFile {
	if mmUpdateConvertedFile.mock.funcUpdateConvertedFile != nil {
		mmUpdateConvertedFile.mock.t.Fatalf("RepositoryMock.UpdateConvertedFile mock is already set by Set")
	}

	if mmUpdateConvertedFile.defaultExpectation == nil {
		mmUpdateConvertedFile.defaultExpectation = &RepositoryMockUpdateConvertedFileExpectation{}
	}

	if mmUpdateConvertedFile.defaultExpectation.params != nil {
		mmUpdateConvertedFile.mock.t.Fatalf("RepositoryMock.UpdateConvertedFile mock is already set by Expect")
	}

	if mmUpdateConvertedFile.defaultExpectation.paramPtrs == nil {
		mmUpdateConvertedFile.defaultExpectation.paramPtrs = &RepositoryMockUpdateConvertedFileParamPtrs{}
	}
	mmUpdateConvertedFile.defaultExpectation.paramPtrs.uid = &uid
	mmUpdateConvertedFile.defaultExpectation.expectationOrigins.originUid = minimock.CallerInfo(1)

	return mmUpdateConvertedFile
}

// ExpectUpdateParam3 sets up expected param update for Repository.UpdateConvertedFile
func (mmUpdateConvertedFile *mRepositoryMockUpdateConvertedFile) ExpectUpdateParam3(update map[string]any) *mRepositoryMockUpdateConvertedFile {
	if mmUpdateConvertedFile.mock.funcUpdateConvertedFile != nil {
		mmUpdateConvertedFile.mock.t.Fatalf("RepositoryMock.UpdateConvertedFile mock is already set by Set")
	}

	if mmUpdateConvertedFile.defaultExpectation == nil {
		mmUpdateConvertedFile.defaultExpectation = &RepositoryMockUpdateConvertedFileExpectation{}
	}

	if mmUpdateConvertedFile.defaultExpectation.params != nil {
		mmUpdateConvertedFile.mock.t.Fatalf("RepositoryMock.UpdateConvertedFile mock is already set by Expect")
	}

	if mmUpdateConvertedFile.defaultExpectation.paramPtrs == nil {
		mmUpdateConvertedFile.defaultExpectation.paramPtrs = &RepositoryMockUpdateConvertedFileParamPtrs{}
	}
	mmUpdateConvertedFile.defaultExpectation.paramPtrs.update = &update
	mmUpdateConvertedFile.defaultExpectation.expectationOrigins.originUpdate = minimock.CallerInfo(1)

	return mmUpdateConvertedFile
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateConvertedFile
func (mmUpdateConvertedFile *mRepositoryMockUpdateConvertedFile) Inspect(f func(ctx context.Context, uid types.ConvertedFileUIDType, update map[string]any)) *mRepositoryMockUpdateConvertedFile {
	if mmUpdateConvertedFile.mock.inspectFuncUpdateConvertedFile != nil {
		mmUpdateConvertedFile.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateConvertedFile")
	}

	mmUpdateConvertedFile.mock.inspectFuncUpdateConvertedFile = f

	return mmUpdateConvertedFile
}

// Return sets up results that will be returned by Repository.UpdateConvertedFile
func (mmUpdateConvertedFile *mRepositoryMockUpdateConvertedFile) Return(err error) *RepositoryMock {
	if mmUpdateConvertedFile.mock.funcUpdateConvertedFile != nil {
		mmUpdateConvertedFile.mock.t.Fatalf("RepositoryMock.UpdateConvertedFile mock is already set by Set")
	}

	if mmUpdateConvertedFile.defaultExpectation == nil {
		mmUpdateConvertedFile.defaultExpectation = &RepositoryMockUpdateConvertedFileExpectation{mock: mmUpdateConvertedFile.mock}
	}
	mmUpdateConvertedFile.defaultExpectation.results = &RepositoryMockUpdateConvertedFileResults{err}
	mmUpdateConvertedFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateConvertedFile.mock
}

// Set uses given function f to mock the Repository.UpdateConvertedFile method
func (mmUpdateConvertedFile *mRepositoryMockUpdateConvertedFile) Set(f func(ctx context.Context, uid types.ConvertedFileUIDType, update map[string]any) (err error)) *RepositoryMock {
	if mmUpdateConvertedFile.defaultExpectation != nil {
		mmUpdateConvertedFile.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateConvertedFile method")
	}

	if len(mmUpdateConvertedFile.expectations) > 0 {
		mmUpdateConvertedFile.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateConvertedFile method")
	}

	mmUpdateConvertedFile.mock.funcUpdateConvertedFile = f
	mmUpdateConvertedFile.mock.funcUpdateConvertedFileOrigin = minimock.CallerInfo(1)
	return mmUpdateConvertedFile.mock
}

// When sets expectation for the Repository.UpdateConvertedFile which will trigger the result defined by the following
// Then helper
func (mmUpdateConvertedFile *mRepositoryMockUpdateConvertedFile) When(ctx context.Context, uid types.ConvertedFileUIDType, update map[string]any) *RepositoryMockUpdateConvertedFileExpectation {
	if mmUpdateConvertedFile.mock.funcUpdateConvertedFile != nil {
		mmUpdateConvertedFile.mock.t.Fatalf("RepositoryMock.UpdateConvertedFile mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateConvertedFileExpectation{
		mock:               mmUpdateConvertedFile.mock,
		params:             &RepositoryMockUpdateConvertedFileParams{ctx, uid, update},
		expectationOrigins: RepositoryMockUpdateConvertedFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateConvertedFile.expectations = append(mmUpdateConvertedFile.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateConvertedFile return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateConvertedFileExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateConvertedFileResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateConvertedFile should be invoked
func (mmUpdateConvertedFile *mRepositoryMockUpdateConvertedFile) Times(n uint64) *mRepositoryMockUpdateConvertedFile {
	if n == 0 {
		mmUpdateConvertedFile.mock.t.Fatalf("Times of RepositoryMock.UpdateConvertedFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateConvertedFile.expectedInvocations, n)
	mmUpdateConvertedFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateConvertedFile
}

func (mmUpdateConvertedFile *mRepositoryMockUpdateConvertedFile) invocationsDone() bool {
	if len(mmUpdateConvertedFile.expectations) == 0 && mmUpdateConvertedFile.defaultExpectation == nil && mmUpdateConvertedFile.mock.funcUpdateConvertedFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateConvertedFile.mock.afterUpdateConvertedFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateConvertedFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateConvertedFile implements mm_repository.Repository
func (mmUpdateConvertedFile *RepositoryMock) UpdateConvertedFile(ctx context.Context, uid types.ConvertedFileUIDType, update map[string]any) (err error) {
	mm_atomic.AddUint64(&mmUpdateConvertedFile.beforeUpdateConvertedFileCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateConvertedFile.afterUpdateConvertedFileCounter, 1)

	mmUpdateConvertedFile.t.Helper()

	if mmUpdateConvertedFile.inspectFuncUpdateConvertedFile != nil {
		mmUpdateConvertedFile.inspectFuncUpdateConvertedFile(ctx, uid, update)
	}

	mm_params := RepositoryMockUpdateConvertedFileParams{ctx, uid, update}

	// Record call args
	mmUpdateConvertedFile.UpdateConvertedFileMock.mutex.Lock()
	mmUpdateConvertedFile.UpdateConvertedFileMock.callArgs = append(mmUpdateConvertedFile.UpdateConvertedFileMock.callArgs, &mm_params)
	mmUpdateConvertedFile.UpdateConvertedFileMock.mutex.Unlock()

	for _, e := range mmUpdateConvertedFile.UpdateConvertedFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateConvertedFile.UpdateConvertedFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateConvertedFile.UpdateConvertedFileMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateConvertedFile.UpdateConvertedFileMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateConvertedFile.UpdateConvertedFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateConvertedFileParams{ctx, uid, update}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateConvertedFile.t.Errorf("RepositoryMock.UpdateConvertedFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateConvertedFile.UpdateConvertedFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmUpdateConvertedFile.t.Errorf("RepositoryMock.UpdateConvertedFile got unexpected parameter uid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateConvertedFile.UpdateConvertedFileMock.defaultExpectation.expectationOrigins.originUid, *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

			if mm_want_ptrs.update != nil && !minimock.Equal(*mm_want_ptrs.update, mm_got.update) {
				mmUpdateConvertedFile.t.Errorf("RepositoryMock.UpdateConvertedFile got unexpected parameter update, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateConvertedFile.UpdateConvertedFileMock.defaultExpectation.expectationOrigins.originUpdate, *mm_want_ptrs.update, mm_got.update, minimock.Diff(*mm_want_ptrs.update, mm_got.update))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateConvertedFile.t.Errorf("RepositoryMock.UpdateConvertedFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateConvertedFile.UpdateConvertedFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateConvertedFile.UpdateConvertedFileMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateConvertedFile.t.Fatal("No results are set for the RepositoryMock.UpdateConvertedFile")
		}
		return (*mm_results).err
	}
	if mmUpdateConvertedFile.funcUpdateConvertedFile != nil {
		return mmUpdateConvertedFile.funcUpdateConvertedFile(ctx, uid, update)
	}
	mmUpdateConvertedFile.t.Fatalf("Unexpected call to RepositoryMock.UpdateConvertedFile. %v %v %v", ctx, uid, update)
	return
}

// UpdateConvertedFileAfterCounter returns a count of finished RepositoryMock.UpdateConvertedFile invocations
func (mmUpdateConvertedFile *RepositoryMock) UpdateConvertedFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateConvertedFile.afterUpdateConvertedFileCounter)
}

// UpdateConvertedFileBeforeCounter returns a count of RepositoryMock.UpdateConvertedFile invocations
func (mmUpdateConvertedFile *RepositoryMock) UpdateConvertedFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateConvertedFile.beforeUpdateConvertedFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateConvertedFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateConvertedFile *mRepositoryMockUpdateConvertedFile) Calls() []*RepositoryMockUpdateConvertedFileParams {
	mmUpdateConvertedFile.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateConvertedFileParams, len(mmUpdateConvertedFile.callArgs))
	copy(argCopy, mmUpdateConvertedFile.callArgs)

	mmUpdateConvertedFile.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateConvertedFileDone returns true if the count of the UpdateConvertedFile invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateConvertedFileDone() bool {
	if m.UpdateConvertedFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateConvertedFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateConvertedFileMock.invocationsDone()
}

// MinimockUpdateConvertedFileInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateConvertedFileInspect() {
	for _, e := range m.UpdateConvertedFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateConvertedFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateConvertedFileCounter := mm_atomic.LoadUint64(&m.afterUpdateConvertedFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateConvertedFileMock.defaultExpectation != nil && afterUpdateConvertedFileCounter < 1 {
		if m.UpdateConvertedFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateConvertedFile at\n%s", m.UpdateConvertedFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateConvertedFile at\n%s with params: %#v", m.UpdateConvertedFileMock.defaultExpectation.expectationOrigins.origin, *m.UpdateConvertedFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateConvertedFile != nil && afterUpdateConvertedFileCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateConvertedFile at\n%s", m.funcUpdateConvertedFileOrigin)
	}

	if !m.UpdateConvertedFileMock.invocationsDone() && afterUpdateConvertedFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateConvertedFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateConvertedFileMock.expectedInvocations), m.UpdateConvertedFileMock.expectedInvocationsOrigin, afterUpdateConvertedFileCounter)
	}
}

type mRepositoryMockUpdateEmbeddingTags struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateEmbeddingTagsExpectation
	expectations       []*RepositoryMockUpdateEmbeddingTagsExpectation

	callArgs []*RepositoryMockUpdateEmbeddingTagsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateEmbeddingTagsExpectation specifies expectation struct of the Repository.UpdateEmbeddingTags
type RepositoryMockUpdateEmbeddingTagsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateEmbeddingTagsParams
	paramPtrs          *RepositoryMockUpdateEmbeddingTagsParamPtrs
	expectationOrigins RepositoryMockUpdateEmbeddingTagsExpectationOrigins
	results            *RepositoryMockUpdateEmbeddingTagsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateEmbeddingTagsParams contains parameters of the Repository.UpdateEmbeddingTags
type RepositoryMockUpdateEmbeddingTagsParams struct {
	ctx          context.Context
	collectionID string
	fileUID      types.FileUIDType
	tags         []string
}

// RepositoryMockUpdateEmbeddingTagsParamPtrs contains pointers to parameters of the Repository.UpdateEmbeddingTags
type RepositoryMockUpdateEmbeddingTagsParamPtrs struct {
	ctx          *context.Context
	collectionID *string
	fileUID      *types.FileUIDType
	tags         *[]string
}

// RepositoryMockUpdateEmbeddingTagsResults contains results of the Repository.UpdateEmbeddingTags
type RepositoryMockUpdateEmbeddingTagsResults struct {
	err error
}

// RepositoryMockUpdateEmbeddingTagsOrigins contains origins of expectations of the Repository.UpdateEmbeddingTags
type RepositoryMockUpdateEmbeddingTagsExpectationOrigins struct {
	origin             string
	originCtx          string
	originCollectionID string
	originFileUID      string
	originTags         string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateEmbeddingTags *mRepositoryMockUpdateEmbeddingTags) Optional() *mRepositoryMockUpdateEmbeddingTags {
	mmUpdateEmbeddingTags.optional = true
	return mmUpdateEmbeddingTags
}

// Expect sets up expected params for Repository.UpdateEmbeddingTags
func (mmUpdateEmbeddingTags *mRepositoryMockUpdateEmbeddingTags) Expect(ctx context.Context, collectionID string, fileUID types.FileUIDType, tags []string) *mRepositoryMockUpdateEmbeddingTags {
	if mmUpdateEmbeddingTags.mock.funcUpdateEmbeddingTags != nil {
		mmUpdateEmbeddingTags.mock.t.Fatalf("RepositoryMock.UpdateEmbeddingTags mock is already set by Set")
	}

	if mmUpdateEmbeddingTags.defaultExpectation == nil {
		mmUpdateEmbeddingTags.defaultExpectation = &RepositoryMockUpdateEmbeddingTagsExpectation{}
	}

	if mmUpdateEmbeddingTags.defaultExpectation.paramPtrs != nil {
		mmUpdateEmbeddingTags.mock.t.Fatalf("RepositoryMock.UpdateEmbeddingTags mock is already set by ExpectParams functions")
	}

	mmUpdateEmbeddingTags.defaultExpectation.params = &RepositoryMockUpdateEmbeddingTagsParams{ctx, collectionID, fileUID, tags}
	mmUpdateEmbeddingTags.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateEmbeddingTags.expectations {
		if minimock.Equal(e.params, mmUpdateEmbeddingTags.defaultExpectation.params) {
			mmUpdateEmbeddingTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateEmbeddingTags.defaultExpectation.params)
		}
	}

	return mmUpdateEmbeddingTags
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateEmbeddingTags
func (mmUpdateEmbeddingTags *mRepositoryMockUpdateEmbeddingTags) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateEmbeddingTags {
	if mmUpdateEmbeddingTags.mock.funcUpdateEmbeddingTags != nil {
		mmUpdateEmbeddingTags.mock.t.Fatalf("RepositoryMock.UpdateEmbeddingTags mock is already set by Set")
	}

	if mmUpdateEmbeddingTags.defaultExpectation == nil {
		mmUpdateEmbeddingTags.defaultExpectation = &RepositoryMockUpdateEmbeddingTagsExpectation{}
	}

	if mmUpdateEmbeddingTags.defaultExpectation.params != nil {
		mmUpdateEmbeddingTags.mock.t.Fatalf("RepositoryMock.UpdateEmbeddingTags mock is already set by Expect")
	}

	if mmUpdateEmbeddingTags.defaultExpectation.paramPtrs == nil {
		mmUpdateEmbeddingTags.defaultExpectation.paramPtrs = &RepositoryMockUpdateEmbeddingTagsParamPtrs{}
	}
	mmUpdateEmbeddingTags.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateEmbeddingTags.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateEmbeddingTags
}

// ExpectCollectionIDParam2 sets up expected param collectionID for Repository.UpdateEmbeddingTags
func (mmUpdateEmbeddingTags *mRepositoryMockUpdateEmbeddingTags) ExpectCollectionIDParam2(collectionID string) *mRepositoryMockUpdateEmbeddingTags {
	if mmUpdateEmbeddingTags.mock.funcUpdateEmbeddingTags != nil {
		mmUpdateEmbeddingTags.mock.t.Fatalf("RepositoryMock.UpdateEmbeddingTags mock is already set by Set")
	}

	if mmUpdateEmbeddingTags.defaultExpectation == nil {
		mmUpdateEmbeddingTags.defaultExpectation = &RepositoryMockUpdateEmbeddingTagsExpectation{}
	}

	if mmUpdateEmbeddingTags.defaultExpectation.params != nil {
		mmUpdateEmbeddingTags.mock.t.Fatalf("RepositoryMock.UpdateEmbeddingTags mock is already set by Expect")
	}

	if mmUpdateEmbeddingTags.defaultExpectation.paramPtrs == nil {
		mmUpdateEmbeddingTags.defaultExpectation.paramPtrs = &RepositoryMockUpdateEmbeddingTagsParamPtrs{}
	}
	mmUpdateEmbeddingTags.defaultExpectation.paramPtrs.collectionID = &collectionID
	mmUpdateEmbeddingTags.defaultExpectation.expectationOrigins.originCollectionID = minimock.CallerInfo(1)

	return mmUpdateEmbeddingTags
}

// ExpectFileUIDParam3 sets up expected param fileUID for Repository.UpdateEmbeddingTags
func (mmUpdateEmbeddingTags *mRepositoryMockUpdateEmbeddingTags) ExpectFileUIDParam3(fileUID types.FileUIDType) *mRepositoryMockUpdateEmbeddingTags {
	if mmUpdateEmbeddingTags.mock.funcUpdateEmbeddingTags != nil {
		mmUpdateEmbeddingTags.mock.t.Fatalf("RepositoryMock.UpdateEmbeddingTags mock is already set by Set")
	}

	if mmUpdateEmbeddingTags.defaultExpectation == nil {
		mmUpdateEmbeddingTags.defaultExpectation = &RepositoryMockUpdateEmbeddingTagsExpectation{}
	}

	if mmUpdateEmbeddingTags.defaultExpectation.params != nil {
		mmUpdateEmbeddingTags.mock.t.Fatalf("RepositoryMock.UpdateEmbeddingTags mock is already set by Expect")
	}

	if mmUpdateEmbeddingTags.defaultExpectation.paramPtrs == nil {
		mmUpdateEmbeddingTags.defaultExpectation.paramPtrs = &RepositoryMockUpdateEmbeddingTagsParamPtrs{}
	}
	mmUpdateEmbeddingTags.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmUpdateEmbeddingTags.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmUpdateEmbeddingTags
}

// ExpectTagsParam4 sets up expected param tags for Repository.UpdateEmbeddingTags
func (mmUpdateEmbeddingTags *mRepositoryMockUpdateEmbeddingTags) ExpectTagsParam4(tags []string) *mRepositoryMockUpdateEmbeddingTags {
	if mmUpdateEmbeddingTags.mock.funcUpdateEmbeddingTags != nil {
		mmUpdateEmbeddingTags.mock.t.Fatalf("RepositoryMock.UpdateEmbeddingTags mock is already set by Set")
	}

	if mmUpdateEmbeddingTags.defaultExpectation == nil {
		mmUpdateEmbeddingTags.defaultExpectation = &RepositoryMockUpdateEmbeddingTagsExpectation{}
	}

	if mmUpdateEmbeddingTags.defaultExpectation.params != nil {
		mmUpdateEmbeddingTags.mock.t.Fatalf("RepositoryMock.UpdateEmbeddingTags mock is already set by Expect")
	}

	if mmUpdateEmbeddingTags.defaultExpectation.paramPtrs == nil {
		mmUpdateEmbeddingTags.defaultExpectation.paramPtrs = &RepositoryMockUpdateEmbeddingTagsParamPtrs{}
	}
	mmUpdateEmbeddingTags.defaultExpectation.paramPtrs.tags = &tags
	mmUpdateEmbeddingTags.defaultExpectation.expectationOrigins.originTags = minimock.CallerInfo(1)

	return mmUpdateEmbeddingTags
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateEmbeddingTags
func (mmUpdateEmbeddingTags *mRepositoryMockUpdateEmbeddingTags) Inspect(f func(ctx context.Context, collectionID string, fileUID types.FileUIDType, tags []string)) *mRepositoryMockUpdateEmbeddingTags {
	if mmUpdateEmbeddingTags.mock.inspectFuncUpdateEmbeddingTags != nil {
		mmUpdateEmbeddingTags.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateEmbeddingTags")
	}

	mmUpdateEmbeddingTags.mock.inspectFuncUpdateEmbeddingTags = f

	return mmUpdateEmbeddingTags
}

// Return sets up results that will be returned by Repository.UpdateEmbeddingTags
func (mmUpdateEmbeddingTags *mRepositoryMockUpdateEmbeddingTags) Return(err error) *RepositoryMock {
	if mmUpdateEmbeddingTags.mock.funcUpdateEmbeddingTags != nil {
		mmUpdateEmbeddingTags.mock.t.Fatalf("RepositoryMock.UpdateEmbeddingTags mock is already set by Set")
	}

	if mmUpdateEmbeddingTags.defaultExpectation == nil {
		mmUpdateEmbeddingTags.defaultExpectation = &RepositoryMockUpdateEmbeddingTagsExpectation{mock: mmUpdateEmbeddingTags.mock}
	}
	mmUpdateEmbeddingTags.defaultExpectation.results = &RepositoryMockUpdateEmbeddingTagsResults{err}
	mmUpdateEmbeddingTags.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateEmbeddingTags.mock
}

// Set uses given function f to mock the Repository.UpdateEmbeddingTags method
func (mmUpdateEmbeddingTags *mRepositoryMockUpdateEmbeddingTags) Set(f func(ctx context.Context, collectionID string, fileUID types.FileUIDType, tags []string) (err error)) *RepositoryMock {
	if mmUpdateEmbeddingTags.defaultExpectation != nil {
		mmUpdateEmbeddingTags.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateEmbeddingTags method")
	}

	if len(mmUpdateEmbeddingTags.expectations) > 0 {
		mmUpdateEmbeddingTags.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateEmbeddingTags method")
	}

	mmUpdateEmbeddingTags.mock.funcUpdateEmbeddingTags = f
	mmUpdateEmbeddingTags.mock.funcUpdateEmbeddingTagsOrigin = minimock.CallerInfo(1)
	return mmUpdateEmbeddingTags.mock
}

// When sets expectation for the Repository.UpdateEmbeddingTags which will trigger the result defined by the following
// Then helper
func (mmUpdateEmbeddingTags *mRepositoryMockUpdateEmbeddingTags) When(ctx context.Context, collectionID string, fileUID types.FileUIDType, tags []string) *RepositoryMockUpdateEmbeddingTagsExpectation {
	if mmUpdateEmbeddingTags.mock.funcUpdateEmbeddingTags != nil {
		mmUpdateEmbeddingTags.mock.t.Fatalf("RepositoryMock.UpdateEmbeddingTags mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateEmbeddingTagsExpectation{
		mock:               mmUpdateEmbeddingTags.mock,
		params:             &RepositoryMockUpdateEmbeddingTagsParams{ctx, collectionID, fileUID, tags},
		expectationOrigins: RepositoryMockUpdateEmbeddingTagsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateEmbeddingTags.expectations = append(mmUpdateEmbeddingTags.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateEmbeddingTags return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateEmbeddingTagsExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateEmbeddingTagsResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateEmbeddingTags should be invoked
func (mmUpdateEmbeddingTags *mRepositoryMockUpdateEmbeddingTags) Times(n uint64) *mRepositoryMockUpdateEmbeddingTags {
	if n == 0 {
		mmUpdateEmbeddingTags.mock.t.Fatalf("Times of RepositoryMock.UpdateEmbeddingTags mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateEmbeddingTags.expectedInvocations, n)
	mmUpdateEmbeddingTags.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateEmbeddingTags
}

func (mmUpdateEmbeddingTags *mRepositoryMockUpdateEmbeddingTags) invocationsDone() bool {
	if len(mmUpdateEmbeddingTags.expectations) == 0 && mmUpdateEmbeddingTags.defaultExpectation == nil && mmUpdateEmbeddingTags.mock.funcUpdateEmbeddingTags == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateEmbeddingTags.mock.afterUpdateEmbeddingTagsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateEmbeddingTags.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateEmbeddingTags implements mm_repository.Repository
func (mmUpdateEmbeddingTags *RepositoryMock) UpdateEmbeddingTags(ctx context.Context, collectionID string, fileUID types.FileUIDType, tags []string) (err error) {
	mm_atomic.AddUint64(&mmUpdateEmbeddingTags.beforeUpdateEmbeddingTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateEmbeddingTags.afterUpdateEmbeddingTagsCounter, 1)

	mmUpdateEmbeddingTags.t.Helper()

	if mmUpdateEmbeddingTags.inspectFuncUpdateEmbeddingTags != nil {
		mmUpdateEmbeddingTags.inspectFuncUpdateEmbeddingTags(ctx, collectionID, fileUID, tags)
	}

	mm_params := RepositoryMockUpdateEmbeddingTagsParams{ctx, collectionID, fileUID, tags}

	// Record call args
	mmUpdateEmbeddingTags.UpdateEmbeddingTagsMock.mutex.Lock()
	mmUpdateEmbeddingTags.UpdateEmbeddingTagsMock.callArgs = append(mmUpdateEmbeddingTags.UpdateEmbeddingTagsMock.callArgs, &mm_params)
	mmUpdateEmbeddingTags.UpdateEmbeddingTagsMock.mutex.Unlock()

	for _, e := range mmUpdateEmbeddingTags.UpdateEmbeddingTagsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateEmbeddingTags.UpdateEmbeddingTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateEmbeddingTags.UpdateEmbeddingTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateEmbeddingTags.UpdateEmbeddingTagsMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateEmbeddingTags.UpdateEmbeddingTagsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateEmbeddingTagsParams{ctx, collectionID, fileUID, tags}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateEmbeddingTags.t.Errorf("RepositoryMock.UpdateEmbeddingTags got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateEmbeddingTags.UpdateEmbeddingTagsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.collectionID != nil && !minimock.Equal(*mm_want_ptrs.collectionID, mm_got.collectionID) {
				mmUpdateEmbeddingTags.t.Errorf("RepositoryMock.UpdateEmbeddingTags got unexpected parameter collectionID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateEmbeddingTags.UpdateEmbeddingTagsMock.defaultExpectation.expectationOrigins.originCollectionID, *mm_want_ptrs.collectionID, mm_got.collectionID, minimock.Diff(*mm_want_ptrs.collectionID, mm_got.collectionID))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmUpdateEmbeddingTags.t.Errorf("RepositoryMock.UpdateEmbeddingTags got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateEmbeddingTags.UpdateEmbeddingTagsMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

			if mm_want_ptrs.tags != nil && !minimock.Equal(*mm_want_ptrs.tags, mm_got.tags) {
				mmUpdateEmbeddingTags.t.Errorf("RepositoryMock.UpdateEmbeddingTags got unexpected parameter tags, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateEmbeddingTags.UpdateEmbeddingTagsMock.defaultExpectation.expectationOrigins.originTags, *mm_want_ptrs.tags, mm_got.tags, minimock.Diff(*mm_want_ptrs.tags, mm_got.tags))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateEmbeddingTags.t.Errorf("RepositoryMock.UpdateEmbeddingTags got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateEmbeddingTags.UpdateEmbeddingTagsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateEmbeddingTags.UpdateEmbeddingTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateEmbeddingTags.t.Fatal("No results are set for the RepositoryMock.UpdateEmbeddingTags")
		}
		return (*mm_results).err
	}
	if mmUpdateEmbeddingTags.funcUpdateEmbeddingTags != nil {
		return mmUpdateEmbeddingTags.funcUpdateEmbeddingTags(ctx, collectionID, fileUID, tags)
	}
	mmUpdateEmbeddingTags.t.Fatalf("Unexpected call to RepositoryMock.UpdateEmbeddingTags. %v %v %v %v", ctx, collectionID, fileUID, tags)
	return
}

// UpdateEmbeddingTagsAfterCounter returns a count of finished RepositoryMock.UpdateEmbeddingTags invocations
func (mmUpdateEmbeddingTags *RepositoryMock) UpdateEmbeddingTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateEmbeddingTags.afterUpdateEmbeddingTagsCounter)
}

// UpdateEmbeddingTagsBeforeCounter returns a count of RepositoryMock.UpdateEmbeddingTags invocations
func (mmUpdateEmbeddingTags *RepositoryMock) UpdateEmbeddingTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateEmbeddingTags.beforeUpdateEmbeddingTagsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateEmbeddingTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateEmbeddingTags *mRepositoryMockUpdateEmbeddingTags) Calls() []*RepositoryMockUpdateEmbeddingTagsParams {
	mmUpdateEmbeddingTags.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateEmbeddingTagsParams, len(mmUpdateEmbeddingTags.callArgs))
	copy(argCopy, mmUpdateEmbeddingTags.callArgs)

	mmUpdateEmbeddingTags.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateEmbeddingTagsDone returns true if the count of the UpdateEmbeddingTags invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateEmbeddingTagsDone() bool {
	if m.UpdateEmbeddingTagsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateEmbeddingTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateEmbeddingTagsMock.invocationsDone()
}

// MinimockUpdateEmbeddingTagsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateEmbeddingTagsInspect() {
	for _, e := range m.UpdateEmbeddingTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateEmbeddingTags at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateEmbeddingTagsCounter := mm_atomic.LoadUint64(&m.afterUpdateEmbeddingTagsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateEmbeddingTagsMock.defaultExpectation != nil && afterUpdateEmbeddingTagsCounter < 1 {
		if m.UpdateEmbeddingTagsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateEmbeddingTags at\n%s", m.UpdateEmbeddingTagsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateEmbeddingTags at\n%s with params: %#v", m.UpdateEmbeddingTagsMock.defaultExpectation.expectationOrigins.origin, *m.UpdateEmbeddingTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateEmbeddingTags != nil && afterUpdateEmbeddingTagsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateEmbeddingTags at\n%s", m.funcUpdateEmbeddingTagsOrigin)
	}

	if !m.UpdateEmbeddingTagsMock.invocationsDone() && afterUpdateEmbeddingTagsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateEmbeddingTags at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateEmbeddingTagsMock.expectedInvocations), m.UpdateEmbeddingTagsMock.expectedInvocationsOrigin, afterUpdateEmbeddingTagsCounter)
	}
}

type mRepositoryMockUpdateEmbeddingTagsForFile struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateEmbeddingTagsForFileExpectation
	expectations       []*RepositoryMockUpdateEmbeddingTagsForFileExpectation

	callArgs []*RepositoryMockUpdateEmbeddingTagsForFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateEmbeddingTagsForFileExpectation specifies expectation struct of the Repository.UpdateEmbeddingTagsForFile
type RepositoryMockUpdateEmbeddingTagsForFileExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateEmbeddingTagsForFileParams
	paramPtrs          *RepositoryMockUpdateEmbeddingTagsForFileParamPtrs
	expectationOrigins RepositoryMockUpdateEmbeddingTagsForFileExpectationOrigins
	results            *RepositoryMockUpdateEmbeddingTagsForFileResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateEmbeddingTagsForFileParams contains parameters of the Repository.UpdateEmbeddingTagsForFile
type RepositoryMockUpdateEmbeddingTagsForFileParams struct {
	ctx          context.Context
	collectionID string
	fileUID      types.FileUIDType
	tags         []string
}

// RepositoryMockUpdateEmbeddingTagsForFileParamPtrs contains pointers to parameters of the Repository.UpdateEmbeddingTagsForFile
type RepositoryMockUpdateEmbeddingTagsForFileParamPtrs struct {
	ctx          *context.Context
	collectionID *string
	fileUID      *types.FileUIDType
	tags         *[]string
}

// RepositoryMockUpdateEmbeddingTagsForFileResults contains results of the Repository.UpdateEmbeddingTagsForFile
type RepositoryMockUpdateEmbeddingTagsForFileResults struct {
	err error
}

// RepositoryMockUpdateEmbeddingTagsForFileOrigins contains origins of expectations of the Repository.UpdateEmbeddingTagsForFile
type RepositoryMockUpdateEmbeddingTagsForFileExpectationOrigins struct {
	origin             string
	originCtx          string
	originCollectionID string
	originFileUID      string
	originTags         string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateEmbeddingTagsForFile *mRepositoryMockUpdateEmbeddingTagsForFile) Optional() *mRepositoryMockUpdateEmbeddingTagsForFile {
	mmUpdateEmbeddingTagsForFile.optional = true
	return mmUpdateEmbeddingTagsForFile
}

// Expect sets up expected params for Repository.UpdateEmbeddingTagsForFile
func (mmUpdateEmbeddingTagsForFile *mRepositoryMockUpdateEmbeddingTagsForFile) Expect(ctx context.Context, collectionID string, fileUID types.FileUIDType, tags []string) *mRepositoryMockUpdateEmbeddingTagsForFile {
	if mmUpdateEmbeddingTagsForFile.mock.funcUpdateEmbeddingTagsForFile != nil {
		mmUpdateEmbeddingTagsForFile.mock.t.Fatalf("RepositoryMock.UpdateEmbeddingTagsForFile mock is already set by Set")
	}

	if mmUpdateEmbeddingTagsForFile.defaultExpectation == nil {
		mmUpdateEmbeddingTagsForFile.defaultExpectation = &RepositoryMockUpdateEmbeddingTagsForFileExpectation{}
	}

	if mmUpdateEmbeddingTagsForFile.defaultExpectation.paramPtrs != nil {
		mmUpdateEmbeddingTagsForFile.mock.t.Fatalf("RepositoryMock.UpdateEmbeddingTagsForFile mock is already set by ExpectParams functions")
	}

	mmUpdateEmbeddingTagsForFile.defaultExpectation.params = &RepositoryMockUpdateEmbeddingTagsForFileParams{ctx, collectionID, fileUID, tags}
	mmUpdateEmbeddingTagsForFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateEmbeddingTagsForFile.expectations {
		if minimock.Equal(e.params, mmUpdateEmbeddingTagsForFile.defaultExpectation.params) {
			mmUpdateEmbeddingTagsForFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateEmbeddingTagsForFile.defaultExpectation.params)
		}
	}

	return mmUpdateEmbeddingTagsForFile
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateEmbeddingTagsForFile
func (mmUpdateEmbeddingTagsForFile *mRepositoryMockUpdateEmbeddingTagsForFile) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateEmbeddingTagsForFile {
	if mmUpdateEmbeddingTagsForFile.mock.funcUpdateEmbeddingTagsForFile != nil {
		mmUpdateEmbeddingTagsForFile.mock.t.Fatalf("RepositoryMock.UpdateEmbeddingTagsForFile mock is already set by Set")
	}

	if mmUpdateEmbeddingTagsForFile.defaultExpectation == nil {
		mmUpdateEmbeddingTagsForFile.defaultExpectation = &RepositoryMockUpdateEmbeddingTagsForFileExpectation{}
	}

	if mmUpdateEmbeddingTagsForFile.defaultExpectation.params != nil {
		mmUpdateEmbeddingTagsForFile.mock.t.Fatalf("RepositoryMock.UpdateEmbeddingTagsForFile mock is already set by Expect")
	}

	if mmUpdateEmbeddingTagsForFile.defaultExpectation.paramPtrs == nil {
		mmUpdateEmbeddingTagsForFile.defaultExpectation.paramPtrs = &RepositoryMockUpdateEmbeddingTagsForFileParamPtrs{}
	}
	mmUpdateEmbeddingTagsForFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateEmbeddingTagsForFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateEmbeddingTagsForFile
}

// ExpectCollectionIDParam2 sets up expected param collectionID for Repository.UpdateEmbeddingTagsForFile
func (mmUpdateEmbeddingTagsForFile *mRepositoryMockUpdateEmbeddingTagsForFile) ExpectCollectionIDParam2(collectionID string) *mRepositoryMockUpdateEmbeddingTagsForFile {
	if mmUpdateEmbeddingTagsForFile.mock.funcUpdateEmbeddingTagsForFile != nil {
		mmUpdateEmbeddingTagsForFile.mock.t.Fatalf("RepositoryMock.UpdateEmbeddingTagsForFile mock is already set by Set")
	}

	if mmUpdateEmbeddingTagsForFile.defaultExpectation == nil {
		mmUpdateEmbeddingTagsForFile.defaultExpectation = &RepositoryMockUpdateEmbeddingTagsForFileExpectation{}
	}

	if mmUpdateEmbeddingTagsForFile.defaultExpectation.params != nil {
		mmUpdateEmbeddingTagsForFile.mock.t.Fatalf("RepositoryMock.UpdateEmbeddingTagsForFile mock is already set by Expect")
	}

	if mmUpdateEmbeddingTagsForFile.defaultExpectation.paramPtrs == nil {
		mmUpdateEmbeddingTagsForFile.defaultExpectation.paramPtrs = &RepositoryMockUpdateEmbeddingTagsForFileParamPtrs{}
	}
	mmUpdateEmbeddingTagsForFile.defaultExpectation.paramPtrs.collectionID = &collectionID
	mmUpdateEmbeddingTagsForFile.defaultExpectation.expectationOrigins.originCollectionID = minimock.CallerInfo(1)

	return mmUpdateEmbeddingTagsForFile
}

// ExpectFileUIDParam3 sets up expected param fileUID for Repository.UpdateEmbeddingTagsForFile
func (mmUpdateEmbeddingTagsForFile *mRepositoryMockUpdateEmbeddingTagsForFile) ExpectFileUIDParam3(fileUID types.FileUIDType) *mRepositoryMockUpdateEmbeddingTagsForFile {
	if mmUpdateEmbeddingTagsForFile.mock.funcUpdateEmbeddingTagsForFile != nil {
		mmUpdateEmbeddingTagsForFile.mock.t.Fatalf("RepositoryMock.UpdateEmbeddingTagsForFile mock is already set by Set")
	}

	if mmUpdateEmbeddingTagsForFile.defaultExpectation == nil {
		mmUpdateEmbeddingTagsForFile.defaultExpectation = &RepositoryMockUpdateEmbeddingTagsForFileExpectation{}
	}

	if mmUpdateEmbeddingTagsForFile.defaultExpectation.params != nil {
		mmUpdateEmbeddingTagsForFile.mock.t.Fatalf("RepositoryMock.UpdateEmbeddingTagsForFile mock is already set by Expect")
	}

	if mmUpdateEmbeddingTagsForFile.defaultExpectation.paramPtrs == nil {
		mmUpdateEmbeddingTagsForFile.defaultExpectation.paramPtrs = &RepositoryMockUpdateEmbeddingTagsForFileParamPtrs{}
	}
	mmUpdateEmbeddingTagsForFile.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmUpdateEmbeddingTagsForFile.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmUpdateEmbeddingTagsForFile
}

// ExpectTagsParam4 sets up expected param tags for Repository.UpdateEmbeddingTagsForFile
func (mmUpdateEmbeddingTagsForFile *mRepositoryMockUpdateEmbeddingTagsForFile) ExpectTagsParam4(tags []string) *mRepositoryMockUpdateEmbeddingTagsForFile {
	if mmUpdateEmbeddingTagsForFile.mock.funcUpdateEmbeddingTagsForFile != nil {
		mmUpdateEmbeddingTagsForFile.mock.t.Fatalf("RepositoryMock.UpdateEmbeddingTagsForFile mock is already set by Set")
	}

	if mmUpdateEmbeddingTagsForFile.defaultExpectation == nil {
		mmUpdateEmbeddingTagsForFile.defaultExpectation = &RepositoryMockUpdateEmbeddingTagsForFileExpectation{}
	}

	if mmUpdateEmbeddingTagsForFile.defaultExpectation.params != nil {
		mmUpdateEmbeddingTagsForFile.mock.t.Fatalf("RepositoryMock.UpdateEmbeddingTagsForFile mock is already set by Expect")
	}

	if mmUpdateEmbeddingTagsForFile.defaultExpectation.paramPtrs == nil {
		mmUpdateEmbeddingTagsForFile.defaultExpectation.paramPtrs = &RepositoryMockUpdateEmbeddingTagsForFileParamPtrs{}
	}
	mmUpdateEmbeddingTagsForFile.defaultExpectation.paramPtrs.tags = &tags
	mmUpdateEmbeddingTagsForFile.defaultExpectation.expectationOrigins.originTags = minimock.CallerInfo(1)

	return mmUpdateEmbeddingTagsForFile
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateEmbeddingTagsForFile
func (mmUpdateEmbeddingTagsForFile *mRepositoryMockUpdateEmbeddingTagsForFile) Inspect(f func(ctx context.Context, collectionID string, fileUID types.FileUIDType, tags []string)) *mRepositoryMockUpdateEmbeddingTagsForFile {
	if mmUpdateEmbeddingTagsForFile.mock.inspectFuncUpdateEmbeddingTagsForFile != nil {
		mmUpdateEmbeddingTagsForFile.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateEmbeddingTagsForFile")
	}

	mmUpdateEmbeddingTagsForFile.mock.inspectFuncUpdateEmbeddingTagsForFile = f

	return mmUpdateEmbeddingTagsForFile
}

// Return sets up results that will be returned by Repository.UpdateEmbeddingTagsForFile
func (mmUpdateEmbeddingTagsForFile *mRepositoryMockUpdateEmbeddingTagsForFile) Return(err error) *RepositoryMock {
	if mmUpdateEmbeddingTagsForFile.mock.funcUpdateEmbeddingTagsForFile != nil {
		mmUpdateEmbeddingTagsForFile.mock.t.Fatalf("RepositoryMock.UpdateEmbeddingTagsForFile mock is already set by Set")
	}

	if mmUpdateEmbeddingTagsForFile.defaultExpectation == nil {
		mmUpdateEmbeddingTagsForFile.defaultExpectation = &RepositoryMockUpdateEmbeddingTagsForFileExpectation{mock: mmUpdateEmbeddingTagsForFile.mock}
	}
	mmUpdateEmbeddingTagsForFile.defaultExpectation.results = &RepositoryMockUpdateEmbeddingTagsForFileResults{err}
	mmUpdateEmbeddingTagsForFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateEmbeddingTagsForFile.mock
}

// Set uses given function f to mock the Repository.UpdateEmbeddingTagsForFile method
func (mmUpdateEmbeddingTagsForFile *mRepositoryMockUpdateEmbeddingTagsForFile) Set(f func(ctx context.Context, collectionID string, fileUID types.FileUIDType, tags []string) (err error)) *RepositoryMock {
	if mmUpdateEmbeddingTagsForFile.defaultExpectation != nil {
		mmUpdateEmbeddingTagsForFile.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateEmbeddingTagsForFile method")
	}

	if len(mmUpdateEmbeddingTagsForFile.expectations) > 0 {
		mmUpdateEmbeddingTagsForFile.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateEmbeddingTagsForFile method")
	}

	mmUpdateEmbeddingTagsForFile.mock.funcUpdateEmbeddingTagsForFile = f
	mmUpdateEmbeddingTagsForFile.mock.funcUpdateEmbeddingTagsForFileOrigin = minimock.CallerInfo(1)
	return mmUpdateEmbeddingTagsForFile.mock
}

// When sets expectation for the Repository.UpdateEmbeddingTagsForFile which will trigger the result defined by the following
// Then helper
func (mmUpdateEmbeddingTagsForFile *mRepositoryMockUpdateEmbeddingTagsForFile) When(ctx context.Context, collectionID string, fileUID types.FileUIDType, tags []string) *RepositoryMockUpdateEmbeddingTagsForFileExpectation {
	if mmUpdateEmbeddingTagsForFile.mock.funcUpdateEmbeddingTagsForFile != nil {
		mmUpdateEmbeddingTagsForFile.mock.t.Fatalf("RepositoryMock.UpdateEmbeddingTagsForFile mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateEmbeddingTagsForFileExpectation{
		mock:               mmUpdateEmbeddingTagsForFile.mock,
		params:             &RepositoryMockUpdateEmbeddingTagsForFileParams{ctx, collectionID, fileUID, tags},
		expectationOrigins: RepositoryMockUpdateEmbeddingTagsForFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateEmbeddingTagsForFile.expectations = append(mmUpdateEmbeddingTagsForFile.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateEmbeddingTagsForFile return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateEmbeddingTagsForFileExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateEmbeddingTagsForFileResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateEmbeddingTagsForFile should be invoked
func (mmUpdateEmbeddingTagsForFile *mRepositoryMockUpdateEmbeddingTagsForFile) Times(n uint64) *mRepositoryMockUpdateEmbeddingTagsForFile {
	if n == 0 {
		mmUpdateEmbeddingTagsForFile.mock.t.Fatalf("Times of RepositoryMock.UpdateEmbeddingTagsForFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateEmbeddingTagsForFile.expectedInvocations, n)
	mmUpdateEmbeddingTagsForFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateEmbeddingTagsForFile
}

func (mmUpdateEmbeddingTagsForFile *mRepositoryMockUpdateEmbeddingTagsForFile) invocationsDone() bool {
	if len(mmUpdateEmbeddingTagsForFile.expectations) == 0 && mmUpdateEmbeddingTagsForFile.defaultExpectation == nil && mmUpdateEmbeddingTagsForFile.mock.funcUpdateEmbeddingTagsForFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateEmbeddingTagsForFile.mock.afterUpdateEmbeddingTagsForFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateEmbeddingTagsForFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateEmbeddingTagsForFile implements mm_repository.Repository
func (mmUpdateEmbeddingTagsForFile *RepositoryMock) UpdateEmbeddingTagsForFile(ctx context.Context, collectionID string, fileUID types.FileUIDType, tags []string) (err error) {
	mm_atomic.AddUint64(&mmUpdateEmbeddingTagsForFile.beforeUpdateEmbeddingTagsForFileCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateEmbeddingTagsForFile.afterUpdateEmbeddingTagsForFileCounter, 1)

	mmUpdateEmbeddingTagsForFile.t.Helper()

	if mmUpdateEmbeddingTagsForFile.inspectFuncUpdateEmbeddingTagsForFile != nil {
		mmUpdateEmbeddingTagsForFile.inspectFuncUpdateEmbeddingTagsForFile(ctx, collectionID, fileUID, tags)
	}

	mm_params := RepositoryMockUpdateEmbeddingTagsForFileParams{ctx, collectionID, fileUID, tags}

	// Record call args
	mmUpdateEmbeddingTagsForFile.UpdateEmbeddingTagsForFileMock.mutex.Lock()
	mmUpdateEmbeddingTagsForFile.UpdateEmbeddingTagsForFileMock.callArgs = append(mmUpdateEmbeddingTagsForFile.UpdateEmbeddingTagsForFileMock.callArgs, &mm_params)
	mmUpdateEmbeddingTagsForFile.UpdateEmbeddingTagsForFileMock.mutex.Unlock()

	for _, e := range mmUpdateEmbeddingTagsForFile.UpdateEmbeddingTagsForFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateEmbeddingTagsForFile.UpdateEmbeddingTagsForFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateEmbeddingTagsForFile.UpdateEmbeddingTagsForFileMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateEmbeddingTagsForFile.UpdateEmbeddingTagsForFileMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateEmbeddingTagsForFile.UpdateEmbeddingTagsForFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateEmbeddingTagsForFileParams{ctx, collectionID, fileUID, tags}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateEmbeddingTagsForFile.t.Errorf("RepositoryMock.UpdateEmbeddingTagsForFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateEmbeddingTagsForFile.UpdateEmbeddingTagsForFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.collectionID != nil && !minimock.Equal(*mm_want_ptrs.collectionID, mm_got.collectionID) {
				mmUpdateEmbeddingTagsForFile.t.Errorf("RepositoryMock.UpdateEmbeddingTagsForFile got unexpected parameter collectionID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateEmbeddingTagsForFile.UpdateEmbeddingTagsForFileMock.defaultExpectation.expectationOrigins.originCollectionID, *mm_want_ptrs.collectionID, mm_got.collectionID, minimock.Diff(*mm_want_ptrs.collectionID, mm_got.collectionID))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmUpdateEmbeddingTagsForFile.t.Errorf("RepositoryMock.UpdateEmbeddingTagsForFile got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateEmbeddingTagsForFile.UpdateEmbeddingTagsForFileMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

			if mm_want_ptrs.tags != nil && !minimock.Equal(*mm_want_ptrs.tags, mm_got.tags) {
				mmUpdateEmbeddingTagsForFile.t.Errorf("RepositoryMock.UpdateEmbeddingTagsForFile got unexpected parameter tags, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateEmbeddingTagsForFile.UpdateEmbeddingTagsForFileMock.defaultExpectation.expectationOrigins.originTags, *mm_want_ptrs.tags, mm_got.tags, minimock.Diff(*mm_want_ptrs.tags, mm_got.tags))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateEmbeddingTagsForFile.t.Errorf("RepositoryMock.UpdateEmbeddingTagsForFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateEmbeddingTagsForFile.UpdateEmbeddingTagsForFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateEmbeddingTagsForFile.UpdateEmbeddingTagsForFileMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateEmbeddingTagsForFile.t.Fatal("No results are set for the RepositoryMock.UpdateEmbeddingTagsForFile")
		}
		return (*mm_results).err
	}
	if mmUpdateEmbeddingTagsForFile.funcUpdateEmbeddingTagsForFile != nil {
		return mmUpdateEmbeddingTagsForFile.funcUpdateEmbeddingTagsForFile(ctx, collectionID, fileUID, tags)
	}
	mmUpdateEmbeddingTagsForFile.t.Fatalf("Unexpected call to RepositoryMock.UpdateEmbeddingTagsForFile. %v %v %v %v", ctx, collectionID, fileUID, tags)
	return
}

// UpdateEmbeddingTagsForFileAfterCounter returns a count of finished RepositoryMock.UpdateEmbeddingTagsForFile invocations
func (mmUpdateEmbeddingTagsForFile *RepositoryMock) UpdateEmbeddingTagsForFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateEmbeddingTagsForFile.afterUpdateEmbeddingTagsForFileCounter)
}

// UpdateEmbeddingTagsForFileBeforeCounter returns a count of RepositoryMock.UpdateEmbeddingTagsForFile invocations
func (mmUpdateEmbeddingTagsForFile *RepositoryMock) UpdateEmbeddingTagsForFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateEmbeddingTagsForFile.beforeUpdateEmbeddingTagsForFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateEmbeddingTagsForFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateEmbeddingTagsForFile *mRepositoryMockUpdateEmbeddingTagsForFile) Calls() []*RepositoryMockUpdateEmbeddingTagsForFileParams {
	mmUpdateEmbeddingTagsForFile.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateEmbeddingTagsForFileParams, len(mmUpdateEmbeddingTagsForFile.callArgs))
	copy(argCopy, mmUpdateEmbeddingTagsForFile.callArgs)

	mmUpdateEmbeddingTagsForFile.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateEmbeddingTagsForFileDone returns true if the count of the UpdateEmbeddingTagsForFile invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateEmbeddingTagsForFileDone() bool {
	if m.UpdateEmbeddingTagsForFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateEmbeddingTagsForFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateEmbeddingTagsForFileMock.invocationsDone()
}

// MinimockUpdateEmbeddingTagsForFileInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateEmbeddingTagsForFileInspect() {
	for _, e := range m.UpdateEmbeddingTagsForFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateEmbeddingTagsForFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateEmbeddingTagsForFileCounter := mm_atomic.LoadUint64(&m.afterUpdateEmbeddingTagsForFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateEmbeddingTagsForFileMock.defaultExpectation != nil && afterUpdateEmbeddingTagsForFileCounter < 1 {
		if m.UpdateEmbeddingTagsForFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateEmbeddingTagsForFile at\n%s", m.UpdateEmbeddingTagsForFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateEmbeddingTagsForFile at\n%s with params: %#v", m.UpdateEmbeddingTagsForFileMock.defaultExpectation.expectationOrigins.origin, *m.UpdateEmbeddingTagsForFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateEmbeddingTagsForFile != nil && afterUpdateEmbeddingTagsForFileCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateEmbeddingTagsForFile at\n%s", m.funcUpdateEmbeddingTagsForFileOrigin)
	}

	if !m.UpdateEmbeddingTagsForFileMock.invocationsDone() && afterUpdateEmbeddingTagsForFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateEmbeddingTagsForFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateEmbeddingTagsForFileMock.expectedInvocations), m.UpdateEmbeddingTagsForFileMock.expectedInvocationsOrigin, afterUpdateEmbeddingTagsForFileCounter)
	}
}

type mRepositoryMockUpdateKnowledgeBase struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateKnowledgeBaseExpectation
	expectations       []*RepositoryMockUpdateKnowledgeBaseExpectation

	callArgs []*RepositoryMockUpdateKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateKnowledgeBaseExpectation specifies expectation struct of the Repository.UpdateKnowledgeBase
type RepositoryMockUpdateKnowledgeBaseExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateKnowledgeBaseParams
	paramPtrs          *RepositoryMockUpdateKnowledgeBaseParamPtrs
	expectationOrigins RepositoryMockUpdateKnowledgeBaseExpectationOrigins
	results            *RepositoryMockUpdateKnowledgeBaseResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateKnowledgeBaseParams contains parameters of the Repository.UpdateKnowledgeBase
type RepositoryMockUpdateKnowledgeBaseParams struct {
	ctx      context.Context
	id       string
	ownerUID string
	kb       mm_repository.KnowledgeBaseModel
}

// RepositoryMockUpdateKnowledgeBaseParamPtrs contains pointers to parameters of the Repository.UpdateKnowledgeBase
type RepositoryMockUpdateKnowledgeBaseParamPtrs struct {
	ctx      *context.Context
	id       *string
	ownerUID *string
	kb       *mm_repository.KnowledgeBaseModel
}

// RepositoryMockUpdateKnowledgeBaseResults contains results of the Repository.UpdateKnowledgeBase
type RepositoryMockUpdateKnowledgeBaseResults struct {
	kp1 *mm_repository.KnowledgeBaseModel
	err error
}

// RepositoryMockUpdateKnowledgeBaseOrigins contains origins of expectations of the Repository.UpdateKnowledgeBase
type RepositoryMockUpdateKnowledgeBaseExpectationOrigins struct {
	origin         string
	originCtx      string
	originId       string
	originOwnerUID string
	originKb       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) Optional() *mRepositoryMockUpdateKnowledgeBase {
	mmUpdateKnowledgeBase.optional = true
	return mmUpdateKnowledgeBase
}

// Expect sets up expected params for Repository.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) Expect(ctx context.Context, id string, ownerUID string, kb mm_repository.KnowledgeBaseModel) *mRepositoryMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmUpdateKnowledgeBase.defaultExpectation.params = &RepositoryMockUpdateKnowledgeBaseParams{ctx, id, ownerUID, kb}
	mmUpdateKnowledgeBase.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmUpdateKnowledgeBase.defaultExpectation.params) {
			mmUpdateKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmUpdateKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.params != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by Expect")
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseParamPtrs{}
	}
	mmUpdateKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateKnowledgeBase.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBase
}

// ExpectIdParam2 sets up expected param id for Repository.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) ExpectIdParam2(id string) *mRepositoryMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.params != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by Expect")
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseParamPtrs{}
	}
	mmUpdateKnowledgeBase.defaultExpectation.paramPtrs.id = &id
	mmUpdateKnowledgeBase.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBase
}

// ExpectOwnerUIDParam3 sets up expected param ownerUID for Repository.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) ExpectOwnerUIDParam3(ownerUID string) *mRepositoryMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.params != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by Expect")
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseParamPtrs{}
	}
	mmUpdateKnowledgeBase.defaultExpectation.paramPtrs.ownerUID = &ownerUID
	mmUpdateKnowledgeBase.defaultExpectation.expectationOrigins.originOwnerUID = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBase
}

// ExpectKbParam4 sets up expected param kb for Repository.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) ExpectKbParam4(kb mm_repository.KnowledgeBaseModel) *mRepositoryMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.params != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by Expect")
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseParamPtrs{}
	}
	mmUpdateKnowledgeBase.defaultExpectation.paramPtrs.kb = &kb
	mmUpdateKnowledgeBase.defaultExpectation.expectationOrigins.originKb = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) Inspect(f func(ctx context.Context, id string, ownerUID string, kb mm_repository.KnowledgeBaseModel)) *mRepositoryMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.inspectFuncUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateKnowledgeBase")
	}

	mmUpdateKnowledgeBase.mock.inspectFuncUpdateKnowledgeBase = f

	return mmUpdateKnowledgeBase
}

// Return sets up results that will be returned by Repository.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) Return(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseExpectation{mock: mmUpdateKnowledgeBase.mock}
	}
	mmUpdateKnowledgeBase.defaultExpectation.results = &RepositoryMockUpdateKnowledgeBaseResults{kp1, err}
	mmUpdateKnowledgeBase.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBase.mock
}

// Set uses given function f to mock the Repository.UpdateKnowledgeBase method
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) Set(f func(ctx context.Context, id string, ownerUID string, kb mm_repository.KnowledgeBaseModel) (kp1 *mm_repository.KnowledgeBaseModel, err error)) *RepositoryMock {
	if mmUpdateKnowledgeBase.defaultExpectation != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateKnowledgeBase method")
	}

	if len(mmUpdateKnowledgeBase.expectations) > 0 {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateKnowledgeBase method")
	}

	mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase = f
	mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBaseOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBase.mock
}

// When sets expectation for the Repository.UpdateKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) When(ctx context.Context, id string, ownerUID string, kb mm_repository.KnowledgeBaseModel) *RepositoryMockUpdateKnowledgeBaseExpectation {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateKnowledgeBaseExpectation{
		mock:               mmUpdateKnowledgeBase.mock,
		params:             &RepositoryMockUpdateKnowledgeBaseParams{ctx, id, ownerUID, kb},
		expectationOrigins: RepositoryMockUpdateKnowledgeBaseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateKnowledgeBase.expectations = append(mmUpdateKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateKnowledgeBaseExpectation) Then(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateKnowledgeBaseResults{kp1, err}
	return e.mock
}

// Times sets number of times Repository.UpdateKnowledgeBase should be invoked
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) Times(n uint64) *mRepositoryMockUpdateKnowledgeBase {
	if n == 0 {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Times of RepositoryMock.UpdateKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateKnowledgeBase.expectedInvocations, n)
	mmUpdateKnowledgeBase.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBase
}

func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) invocationsDone() bool {
	if len(mmUpdateKnowledgeBase.expectations) == 0 && mmUpdateKnowledgeBase.defaultExpectation == nil && mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.mock.afterUpdateKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateKnowledgeBase implements mm_repository.Repository
func (mmUpdateKnowledgeBase *RepositoryMock) UpdateKnowledgeBase(ctx context.Context, id string, ownerUID string, kb mm_repository.KnowledgeBaseModel) (kp1 *mm_repository.KnowledgeBaseModel, err error) {
	mm_atomic.AddUint64(&mmUpdateKnowledgeBase.beforeUpdateKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateKnowledgeBase.afterUpdateKnowledgeBaseCounter, 1)

	mmUpdateKnowledgeBase.t.Helper()

	if mmUpdateKnowledgeBase.inspectFuncUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.inspectFuncUpdateKnowledgeBase(ctx, id, ownerUID, kb)
	}

	mm_params := RepositoryMockUpdateKnowledgeBaseParams{ctx, id, ownerUID, kb}

	// Record call args
	mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.mutex.Lock()
	mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.callArgs = append(mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.callArgs, &mm_params)
	mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateKnowledgeBaseParams{ctx, id, ownerUID, kb}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateKnowledgeBase.t.Errorf("RepositoryMock.UpdateKnowledgeBase got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateKnowledgeBase.t.Errorf("RepositoryMock.UpdateKnowledgeBase got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmUpdateKnowledgeBase.t.Errorf("RepositoryMock.UpdateKnowledgeBase got unexpected parameter ownerUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.expectationOrigins.originOwnerUID, *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

			if mm_want_ptrs.kb != nil && !minimock.Equal(*mm_want_ptrs.kb, mm_got.kb) {
				mmUpdateKnowledgeBase.t.Errorf("RepositoryMock.UpdateKnowledgeBase got unexpected parameter kb, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.expectationOrigins.originKb, *mm_want_ptrs.kb, mm_got.kb, minimock.Diff(*mm_want_ptrs.kb, mm_got.kb))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateKnowledgeBase.t.Errorf("RepositoryMock.UpdateKnowledgeBase got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateKnowledgeBase.t.Fatal("No results are set for the RepositoryMock.UpdateKnowledgeBase")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmUpdateKnowledgeBase.funcUpdateKnowledgeBase != nil {
		return mmUpdateKnowledgeBase.funcUpdateKnowledgeBase(ctx, id, ownerUID, kb)
	}
	mmUpdateKnowledgeBase.t.Fatalf("Unexpected call to RepositoryMock.UpdateKnowledgeBase. %v %v %v %v", ctx, id, ownerUID, kb)
	return
}

// UpdateKnowledgeBaseAfterCounter returns a count of finished RepositoryMock.UpdateKnowledgeBase invocations
func (mmUpdateKnowledgeBase *RepositoryMock) UpdateKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.afterUpdateKnowledgeBaseCounter)
}

// UpdateKnowledgeBaseBeforeCounter returns a count of RepositoryMock.UpdateKnowledgeBase invocations
func (mmUpdateKnowledgeBase *RepositoryMock) UpdateKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.beforeUpdateKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) Calls() []*RepositoryMockUpdateKnowledgeBaseParams {
	mmUpdateKnowledgeBase.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateKnowledgeBaseParams, len(mmUpdateKnowledgeBase.callArgs))
	copy(argCopy, mmUpdateKnowledgeBase.callArgs)

	mmUpdateKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateKnowledgeBaseDone returns true if the count of the UpdateKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateKnowledgeBaseDone() bool {
	if m.UpdateKnowledgeBaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateKnowledgeBaseMock.invocationsDone()
}

// MinimockUpdateKnowledgeBaseInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateKnowledgeBaseInspect() {
	for _, e := range m.UpdateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBase at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterUpdateKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateKnowledgeBaseMock.defaultExpectation != nil && afterUpdateKnowledgeBaseCounter < 1 {
		if m.UpdateKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBase at\n%s", m.UpdateKnowledgeBaseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBase at\n%s with params: %#v", m.UpdateKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *m.UpdateKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateKnowledgeBase != nil && afterUpdateKnowledgeBaseCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBase at\n%s", m.funcUpdateKnowledgeBaseOrigin)
	}

	if !m.UpdateKnowledgeBaseMock.invocationsDone() && afterUpdateKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateKnowledgeBase at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateKnowledgeBaseMock.expectedInvocations), m.UpdateKnowledgeBaseMock.expectedInvocationsOrigin, afterUpdateKnowledgeBaseCounter)
	}
}

type mRepositoryMockUpdateKnowledgeBaseAborted struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateKnowledgeBaseAbortedExpectation
	expectations       []*RepositoryMockUpdateKnowledgeBaseAbortedExpectation

	callArgs []*RepositoryMockUpdateKnowledgeBaseAbortedParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateKnowledgeBaseAbortedExpectation specifies expectation struct of the Repository.UpdateKnowledgeBaseAborted
type RepositoryMockUpdateKnowledgeBaseAbortedExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateKnowledgeBaseAbortedParams
	paramPtrs          *RepositoryMockUpdateKnowledgeBaseAbortedParamPtrs
	expectationOrigins RepositoryMockUpdateKnowledgeBaseAbortedExpectationOrigins
	results            *RepositoryMockUpdateKnowledgeBaseAbortedResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateKnowledgeBaseAbortedParams contains parameters of the Repository.UpdateKnowledgeBaseAborted
type RepositoryMockUpdateKnowledgeBaseAbortedParams struct {
	ctx   context.Context
	kbUID types.KBUIDType
}

// RepositoryMockUpdateKnowledgeBaseAbortedParamPtrs contains pointers to parameters of the Repository.UpdateKnowledgeBaseAborted
type RepositoryMockUpdateKnowledgeBaseAbortedParamPtrs struct {
	ctx   *context.Context
	kbUID *types.KBUIDType
}

// RepositoryMockUpdateKnowledgeBaseAbortedResults contains results of the Repository.UpdateKnowledgeBaseAborted
type RepositoryMockUpdateKnowledgeBaseAbortedResults struct {
	err error
}

// RepositoryMockUpdateKnowledgeBaseAbortedOrigins contains origins of expectations of the Repository.UpdateKnowledgeBaseAborted
type RepositoryMockUpdateKnowledgeBaseAbortedExpectationOrigins struct {
	origin      string
	originCtx   string
	originKbUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateKnowledgeBaseAborted *mRepositoryMockUpdateKnowledgeBaseAborted) Optional() *mRepositoryMockUpdateKnowledgeBaseAborted {
	mmUpdateKnowledgeBaseAborted.optional = true
	return mmUpdateKnowledgeBaseAborted
}

// Expect sets up expected params for Repository.UpdateKnowledgeBaseAborted
func (mmUpdateKnowledgeBaseAborted *mRepositoryMockUpdateKnowledgeBaseAborted) Expect(ctx context.Context, kbUID types.KBUIDType) *mRepositoryMockUpdateKnowledgeBaseAborted {
	if mmUpdateKnowledgeBaseAborted.mock.funcUpdateKnowledgeBaseAborted != nil {
		mmUpdateKnowledgeBaseAborted.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseAborted mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseAborted.defaultExpectation == nil {
		mmUpdateKnowledgeBaseAborted.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseAbortedExpectation{}
	}

	if mmUpdateKnowledgeBaseAborted.defaultExpectation.paramPtrs != nil {
		mmUpdateKnowledgeBaseAborted.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseAborted mock is already set by ExpectParams functions")
	}

	mmUpdateKnowledgeBaseAborted.defaultExpectation.params = &RepositoryMockUpdateKnowledgeBaseAbortedParams{ctx, kbUID}
	mmUpdateKnowledgeBaseAborted.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateKnowledgeBaseAborted.expectations {
		if minimock.Equal(e.params, mmUpdateKnowledgeBaseAborted.defaultExpectation.params) {
			mmUpdateKnowledgeBaseAborted.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateKnowledgeBaseAborted.defaultExpectation.params)
		}
	}

	return mmUpdateKnowledgeBaseAborted
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateKnowledgeBaseAborted
func (mmUpdateKnowledgeBaseAborted *mRepositoryMockUpdateKnowledgeBaseAborted) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateKnowledgeBaseAborted {
	if mmUpdateKnowledgeBaseAborted.mock.funcUpdateKnowledgeBaseAborted != nil {
		mmUpdateKnowledgeBaseAborted.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseAborted mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseAborted.defaultExpectation == nil {
		mmUpdateKnowledgeBaseAborted.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseAbortedExpectation{}
	}

	if mmUpdateKnowledgeBaseAborted.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseAborted.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseAborted mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseAborted.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseAborted.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseAbortedParamPtrs{}
	}
	mmUpdateKnowledgeBaseAborted.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateKnowledgeBaseAborted.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseAborted
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.UpdateKnowledgeBaseAborted
func (mmUpdateKnowledgeBaseAborted *mRepositoryMockUpdateKnowledgeBaseAborted) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockUpdateKnowledgeBaseAborted {
	if mmUpdateKnowledgeBaseAborted.mock.funcUpdateKnowledgeBaseAborted != nil {
		mmUpdateKnowledgeBaseAborted.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseAborted mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseAborted.defaultExpectation == nil {
		mmUpdateKnowledgeBaseAborted.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseAbortedExpectation{}
	}

	if mmUpdateKnowledgeBaseAborted.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseAborted.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseAborted mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseAborted.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseAborted.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseAbortedParamPtrs{}
	}
	mmUpdateKnowledgeBaseAborted.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmUpdateKnowledgeBaseAborted.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseAborted
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateKnowledgeBaseAborted
func (mmUpdateKnowledgeBaseAborted *mRepositoryMockUpdateKnowledgeBaseAborted) Inspect(f func(ctx context.Context, kbUID types.KBUIDType)) *mRepositoryMockUpdateKnowledgeBaseAborted {
	if mmUpdateKnowledgeBaseAborted.mock.inspectFuncUpdateKnowledgeBaseAborted != nil {
		mmUpdateKnowledgeBaseAborted.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateKnowledgeBaseAborted")
	}

	mmUpdateKnowledgeBaseAborted.mock.inspectFuncUpdateKnowledgeBaseAborted = f

	return mmUpdateKnowledgeBaseAborted
}

// Return sets up results that will be returned by Repository.UpdateKnowledgeBaseAborted
func (mmUpdateKnowledgeBaseAborted *mRepositoryMockUpdateKnowledgeBaseAborted) Return(err error) *RepositoryMock {
	if mmUpdateKnowledgeBaseAborted.mock.funcUpdateKnowledgeBaseAborted != nil {
		mmUpdateKnowledgeBaseAborted.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseAborted mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseAborted.defaultExpectation == nil {
		mmUpdateKnowledgeBaseAborted.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseAbortedExpectation{mock: mmUpdateKnowledgeBaseAborted.mock}
	}
	mmUpdateKnowledgeBaseAborted.defaultExpectation.results = &RepositoryMockUpdateKnowledgeBaseAbortedResults{err}
	mmUpdateKnowledgeBaseAborted.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBaseAborted.mock
}

// Set uses given function f to mock the Repository.UpdateKnowledgeBaseAborted method
func (mmUpdateKnowledgeBaseAborted *mRepositoryMockUpdateKnowledgeBaseAborted) Set(f func(ctx context.Context, kbUID types.KBUIDType) (err error)) *RepositoryMock {
	if mmUpdateKnowledgeBaseAborted.defaultExpectation != nil {
		mmUpdateKnowledgeBaseAborted.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateKnowledgeBaseAborted method")
	}

	if len(mmUpdateKnowledgeBaseAborted.expectations) > 0 {
		mmUpdateKnowledgeBaseAborted.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateKnowledgeBaseAborted method")
	}

	mmUpdateKnowledgeBaseAborted.mock.funcUpdateKnowledgeBaseAborted = f
	mmUpdateKnowledgeBaseAborted.mock.funcUpdateKnowledgeBaseAbortedOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBaseAborted.mock
}

// When sets expectation for the Repository.UpdateKnowledgeBaseAborted which will trigger the result defined by the following
// Then helper
func (mmUpdateKnowledgeBaseAborted *mRepositoryMockUpdateKnowledgeBaseAborted) When(ctx context.Context, kbUID types.KBUIDType) *RepositoryMockUpdateKnowledgeBaseAbortedExpectation {
	if mmUpdateKnowledgeBaseAborted.mock.funcUpdateKnowledgeBaseAborted != nil {
		mmUpdateKnowledgeBaseAborted.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseAborted mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateKnowledgeBaseAbortedExpectation{
		mock:               mmUpdateKnowledgeBaseAborted.mock,
		params:             &RepositoryMockUpdateKnowledgeBaseAbortedParams{ctx, kbUID},
		expectationOrigins: RepositoryMockUpdateKnowledgeBaseAbortedExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateKnowledgeBaseAborted.expectations = append(mmUpdateKnowledgeBaseAborted.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateKnowledgeBaseAborted return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateKnowledgeBaseAbortedExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateKnowledgeBaseAbortedResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateKnowledgeBaseAborted should be invoked
func (mmUpdateKnowledgeBaseAborted *mRepositoryMockUpdateKnowledgeBaseAborted) Times(n uint64) *mRepositoryMockUpdateKnowledgeBaseAborted {
	if n == 0 {
		mmUpdateKnowledgeBaseAborted.mock.t.Fatalf("Times of RepositoryMock.UpdateKnowledgeBaseAborted mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateKnowledgeBaseAborted.expectedInvocations, n)
	mmUpdateKnowledgeBaseAborted.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBaseAborted
}

func (mmUpdateKnowledgeBaseAborted *mRepositoryMockUpdateKnowledgeBaseAborted) invocationsDone() bool {
	if len(mmUpdateKnowledgeBaseAborted.expectations) == 0 && mmUpdateKnowledgeBaseAborted.defaultExpectation == nil && mmUpdateKnowledgeBaseAborted.mock.funcUpdateKnowledgeBaseAborted == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseAborted.mock.afterUpdateKnowledgeBaseAbortedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseAborted.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateKnowledgeBaseAborted implements mm_repository.Repository
func (mmUpdateKnowledgeBaseAborted *RepositoryMock) UpdateKnowledgeBaseAborted(ctx context.Context, kbUID types.KBUIDType) (err error) {
	mm_atomic.AddUint64(&mmUpdateKnowledgeBaseAborted.beforeUpdateKnowledgeBaseAbortedCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateKnowledgeBaseAborted.afterUpdateKnowledgeBaseAbortedCounter, 1)

	mmUpdateKnowledgeBaseAborted.t.Helper()

	if mmUpdateKnowledgeBaseAborted.inspectFuncUpdateKnowledgeBaseAborted != nil {
		mmUpdateKnowledgeBaseAborted.inspectFuncUpdateKnowledgeBaseAborted(ctx, kbUID)
	}

	mm_params := RepositoryMockUpdateKnowledgeBaseAbortedParams{ctx, kbUID}

	// Record call args
	mmUpdateKnowledgeBaseAborted.UpdateKnowledgeBaseAbortedMock.mutex.Lock()
	mmUpdateKnowledgeBaseAborted.UpdateKnowledgeBaseAbortedMock.callArgs = append(mmUpdateKnowledgeBaseAborted.UpdateKnowledgeBaseAbortedMock.callArgs, &mm_params)
	mmUpdateKnowledgeBaseAborted.UpdateKnowledgeBaseAbortedMock.mutex.Unlock()

	for _, e := range mmUpdateKnowledgeBaseAborted.UpdateKnowledgeBaseAbortedMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateKnowledgeBaseAborted.UpdateKnowledgeBaseAbortedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateKnowledgeBaseAborted.UpdateKnowledgeBaseAbortedMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateKnowledgeBaseAborted.UpdateKnowledgeBaseAbortedMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateKnowledgeBaseAborted.UpdateKnowledgeBaseAbortedMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateKnowledgeBaseAbortedParams{ctx, kbUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateKnowledgeBaseAborted.t.Errorf("RepositoryMock.UpdateKnowledgeBaseAborted got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseAborted.UpdateKnowledgeBaseAbortedMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmUpdateKnowledgeBaseAborted.t.Errorf("RepositoryMock.UpdateKnowledgeBaseAborted got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseAborted.UpdateKnowledgeBaseAbortedMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateKnowledgeBaseAborted.t.Errorf("RepositoryMock.UpdateKnowledgeBaseAborted got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateKnowledgeBaseAborted.UpdateKnowledgeBaseAbortedMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateKnowledgeBaseAborted.UpdateKnowledgeBaseAbortedMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateKnowledgeBaseAborted.t.Fatal("No results are set for the RepositoryMock.UpdateKnowledgeBaseAborted")
		}
		return (*mm_results).err
	}
	if mmUpdateKnowledgeBaseAborted.funcUpdateKnowledgeBaseAborted != nil {
		return mmUpdateKnowledgeBaseAborted.funcUpdateKnowledgeBaseAborted(ctx, kbUID)
	}
	mmUpdateKnowledgeBaseAborted.t.Fatalf("Unexpected call to RepositoryMock.UpdateKnowledgeBaseAborted. %v %v", ctx, kbUID)
	return
}

// UpdateKnowledgeBaseAbortedAfterCounter returns a count of finished RepositoryMock.UpdateKnowledgeBaseAborted invocations
func (mmUpdateKnowledgeBaseAborted *RepositoryMock) UpdateKnowledgeBaseAbortedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseAborted.afterUpdateKnowledgeBaseAbortedCounter)
}

// UpdateKnowledgeBaseAbortedBeforeCounter returns a count of RepositoryMock.UpdateKnowledgeBaseAborted invocations
func (mmUpdateKnowledgeBaseAborted *RepositoryMock) UpdateKnowledgeBaseAbortedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseAborted.beforeUpdateKnowledgeBaseAbortedCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateKnowledgeBaseAborted.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateKnowledgeBaseAborted *mRepositoryMockUpdateKnowledgeBaseAborted) Calls() []*RepositoryMockUpdateKnowledgeBaseAbortedParams {
	mmUpdateKnowledgeBaseAborted.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateKnowledgeBaseAbortedParams, len(mmUpdateKnowledgeBaseAborted.callArgs))
	copy(argCopy, mmUpdateKnowledgeBaseAborted.callArgs)

	mmUpdateKnowledgeBaseAborted.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateKnowledgeBaseAbortedDone returns true if the count of the UpdateKnowledgeBaseAborted invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateKnowledgeBaseAbortedDone() bool {
	if m.UpdateKnowledgeBaseAbortedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateKnowledgeBaseAbortedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateKnowledgeBaseAbortedMock.invocationsDone()
}

// MinimockUpdateKnowledgeBaseAbortedInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateKnowledgeBaseAbortedInspect() {
	for _, e := range m.UpdateKnowledgeBaseAbortedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseAborted at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateKnowledgeBaseAbortedCounter := mm_atomic.LoadUint64(&m.afterUpdateKnowledgeBaseAbortedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateKnowledgeBaseAbortedMock.defaultExpectation != nil && afterUpdateKnowledgeBaseAbortedCounter < 1 {
		if m.UpdateKnowledgeBaseAbortedMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseAborted at\n%s", m.UpdateKnowledgeBaseAbortedMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseAborted at\n%s with params: %#v", m.UpdateKnowledgeBaseAbortedMock.defaultExpectation.expectationOrigins.origin, *m.UpdateKnowledgeBaseAbortedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateKnowledgeBaseAborted != nil && afterUpdateKnowledgeBaseAbortedCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseAborted at\n%s", m.funcUpdateKnowledgeBaseAbortedOrigin)
	}

	if !m.UpdateKnowledgeBaseAbortedMock.invocationsDone() && afterUpdateKnowledgeBaseAbortedCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateKnowledgeBaseAborted at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateKnowledgeBaseAbortedMock.expectedInvocations), m.UpdateKnowledgeBaseAbortedMock.expectedInvocationsOrigin, afterUpdateKnowledgeBaseAbortedCounter)
	}
}

type mRepositoryMockUpdateKnowledgeBaseFile struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateKnowledgeBaseFileExpectation
	expectations       []*RepositoryMockUpdateKnowledgeBaseFileExpectation

	callArgs []*RepositoryMockUpdateKnowledgeBaseFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateKnowledgeBaseFileExpectation specifies expectation struct of the Repository.UpdateKnowledgeBaseFile
type RepositoryMockUpdateKnowledgeBaseFileExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateKnowledgeBaseFileParams
	paramPtrs          *RepositoryMockUpdateKnowledgeBaseFileParamPtrs
	expectationOrigins RepositoryMockUpdateKnowledgeBaseFileExpectationOrigins
	results            *RepositoryMockUpdateKnowledgeBaseFileResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateKnowledgeBaseFileParams contains parameters of the Repository.UpdateKnowledgeBaseFile
type RepositoryMockUpdateKnowledgeBaseFileParams struct {
	ctx       context.Context
	fileUID   string
	updateMap map[string]any
}

// RepositoryMockUpdateKnowledgeBaseFileParamPtrs contains pointers to parameters of the Repository.UpdateKnowledgeBaseFile
type RepositoryMockUpdateKnowledgeBaseFileParamPtrs struct {
	ctx       *context.Context
	fileUID   *string
	updateMap *map[string]any
}

// RepositoryMockUpdateKnowledgeBaseFileResults contains results of the Repository.UpdateKnowledgeBaseFile
type RepositoryMockUpdateKnowledgeBaseFileResults struct {
	kp1 *mm_repository.KnowledgeBaseFileModel
	err error
}

// RepositoryMockUpdateKnowledgeBaseFileOrigins contains origins of expectations of the Repository.UpdateKnowledgeBaseFile
type RepositoryMockUpdateKnowledgeBaseFileExpectationOrigins struct {
	origin          string
	originCtx       string
	originFileUID   string
	originUpdateMap string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateKnowledgeBaseFile *mRepositoryMockUpdateKnowledgeBaseFile) Optional() *mRepositoryMockUpdateKnowledgeBaseFile {
	mmUpdateKnowledgeBaseFile.optional = true
	return mmUpdateKnowledgeBaseFile
}

// Expect sets up expected params for Repository.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryMockUpdateKnowledgeBaseFile) Expect(ctx context.Context, fileUID string, updateMap map[string]any) *mRepositoryMockUpdateKnowledgeBaseFile {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseFileExpectation{}
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseFile mock is already set by ExpectParams functions")
	}

	mmUpdateKnowledgeBaseFile.defaultExpectation.params = &RepositoryMockUpdateKnowledgeBaseFileParams{ctx, fileUID, updateMap}
	mmUpdateKnowledgeBaseFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateKnowledgeBaseFile.expectations {
		if minimock.Equal(e.params, mmUpdateKnowledgeBaseFile.defaultExpectation.params) {
			mmUpdateKnowledgeBaseFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateKnowledgeBaseFile.defaultExpectation.params)
		}
	}

	return mmUpdateKnowledgeBaseFile
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryMockUpdateKnowledgeBaseFile) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateKnowledgeBaseFile {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseFileExpectation{}
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseFileParamPtrs{}
	}
	mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateKnowledgeBaseFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseFile
}

// ExpectFileUIDParam2 sets up expected param fileUID for Repository.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryMockUpdateKnowledgeBaseFile) ExpectFileUIDParam2(fileUID string) *mRepositoryMockUpdateKnowledgeBaseFile {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseFileExpectation{}
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseFileParamPtrs{}
	}
	mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmUpdateKnowledgeBaseFile.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseFile
}

// ExpectUpdateMapParam3 sets up expected param updateMap for Repository.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryMockUpdateKnowledgeBaseFile) ExpectUpdateMapParam3(updateMap map[string]any) *mRepositoryMockUpdateKnowledgeBaseFile {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseFileExpectation{}
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseFileParamPtrs{}
	}
	mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs.updateMap = &updateMap
	mmUpdateKnowledgeBaseFile.defaultExpectation.expectationOrigins.originUpdateMap = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseFile
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryMockUpdateKnowledgeBaseFile) Inspect(f func(ctx context.Context, fileUID string, updateMap map[string]any)) *mRepositoryMockUpdateKnowledgeBaseFile {
	if mmUpdateKnowledgeBaseFile.mock.inspectFuncUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateKnowledgeBaseFile")
	}

	mmUpdateKnowledgeBaseFile.mock.inspectFuncUpdateKnowledgeBaseFile = f

	return mmUpdateKnowledgeBaseFile
}

// Return sets up results that will be returned by Repository.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryMockUpdateKnowledgeBaseFile) Return(kp1 *mm_repository.KnowledgeBaseFileModel, err error) *RepositoryMock {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseFileExpectation{mock: mmUpdateKnowledgeBaseFile.mock}
	}
	mmUpdateKnowledgeBaseFile.defaultExpectation.results = &RepositoryMockUpdateKnowledgeBaseFileResults{kp1, err}
	mmUpdateKnowledgeBaseFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBaseFile.mock
}

// Set uses given function f to mock the Repository.UpdateKnowledgeBaseFile method
func (mmUpdateKnowledgeBaseFile *mRepositoryMockUpdateKnowledgeBaseFile) Set(f func(ctx context.Context, fileUID string, updateMap map[string]any) (kp1 *mm_repository.KnowledgeBaseFileModel, err error)) *RepositoryMock {
	if mmUpdateKnowledgeBaseFile.defaultExpectation != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateKnowledgeBaseFile method")
	}

	if len(mmUpdateKnowledgeBaseFile.expectations) > 0 {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateKnowledgeBaseFile method")
	}

	mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile = f
	mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFileOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBaseFile.mock
}

// When sets expectation for the Repository.UpdateKnowledgeBaseFile which will trigger the result defined by the following
// Then helper
func (mmUpdateKnowledgeBaseFile *mRepositoryMockUpdateKnowledgeBaseFile) When(ctx context.Context, fileUID string, updateMap map[string]any) *RepositoryMockUpdateKnowledgeBaseFileExpectation {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateKnowledgeBaseFileExpectation{
		mock:               mmUpdateKnowledgeBaseFile.mock,
		params:             &RepositoryMockUpdateKnowledgeBaseFileParams{ctx, fileUID, updateMap},
		expectationOrigins: RepositoryMockUpdateKnowledgeBaseFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateKnowledgeBaseFile.expectations = append(mmUpdateKnowledgeBaseFile.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateKnowledgeBaseFile return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateKnowledgeBaseFileExpectation) Then(kp1 *mm_repository.KnowledgeBaseFileModel, err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateKnowledgeBaseFileResults{kp1, err}
	return e.mock
}

// Times sets number of times Repository.UpdateKnowledgeBaseFile should be invoked
func (mmUpdateKnowledgeBaseFile *mRepositoryMockUpdateKnowledgeBaseFile) Times(n uint64) *mRepositoryMockUpdateKnowledgeBaseFile {
	if n == 0 {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("Times of RepositoryMock.UpdateKnowledgeBaseFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateKnowledgeBaseFile.expectedInvocations, n)
	mmUpdateKnowledgeBaseFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBaseFile
}

func (mmUpdateKnowledgeBaseFile *mRepositoryMockUpdateKnowledgeBaseFile) invocationsDone() bool {
	if len(mmUpdateKnowledgeBaseFile.expectations) == 0 && mmUpdateKnowledgeBaseFile.defaultExpectation == nil && mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseFile.mock.afterUpdateKnowledgeBaseFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateKnowledgeBaseFile implements mm_repository.Repository
func (mmUpdateKnowledgeBaseFile *RepositoryMock) UpdateKnowledgeBaseFile(ctx context.Context, fileUID string, updateMap map[string]any) (kp1 *mm_repository.KnowledgeBaseFileModel, err error) {
	mm_atomic.AddUint64(&mmUpdateKnowledgeBaseFile.beforeUpdateKnowledgeBaseFileCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateKnowledgeBaseFile.afterUpdateKnowledgeBaseFileCounter, 1)

	mmUpdateKnowledgeBaseFile.t.Helper()

	if mmUpdateKnowledgeBaseFile.inspectFuncUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.inspectFuncUpdateKnowledgeBaseFile(ctx, fileUID, updateMap)
	}

	mm_params := RepositoryMockUpdateKnowledgeBaseFileParams{ctx, fileUID, updateMap}

	// Record call args
	mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.mutex.Lock()
	mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.callArgs = append(mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.callArgs, &mm_params)
	mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.mutex.Unlock()

	for _, e := range mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateKnowledgeBaseFileParams{ctx, fileUID, updateMap}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateKnowledgeBaseFile.t.Errorf("RepositoryMock.UpdateKnowledgeBaseFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmUpdateKnowledgeBaseFile.t.Errorf("RepositoryMock.UpdateKnowledgeBaseFile got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

			if mm_want_ptrs.updateMap != nil && !minimock.Equal(*mm_want_ptrs.updateMap, mm_got.updateMap) {
				mmUpdateKnowledgeBaseFile.t.Errorf("RepositoryMock.UpdateKnowledgeBaseFile got unexpected parameter updateMap, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation.expectationOrigins.originUpdateMap, *mm_want_ptrs.updateMap, mm_got.updateMap, minimock.Diff(*mm_want_ptrs.updateMap, mm_got.updateMap))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateKnowledgeBaseFile.t.Errorf("RepositoryMock.UpdateKnowledgeBaseFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateKnowledgeBaseFile.t.Fatal("No results are set for the RepositoryMock.UpdateKnowledgeBaseFile")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmUpdateKnowledgeBaseFile.funcUpdateKnowledgeBaseFile != nil {
		return mmUpdateKnowledgeBaseFile.funcUpdateKnowledgeBaseFile(ctx, fileUID, updateMap)
	}
	mmUpdateKnowledgeBaseFile.t.Fatalf("Unexpected call to RepositoryMock.UpdateKnowledgeBaseFile. %v %v %v", ctx, fileUID, updateMap)
	return
}

// UpdateKnowledgeBaseFileAfterCounter returns a count of finished RepositoryMock.UpdateKnowledgeBaseFile invocations
func (mmUpdateKnowledgeBaseFile *RepositoryMock) UpdateKnowledgeBaseFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseFile.afterUpdateKnowledgeBaseFileCounter)
}

// UpdateKnowledgeBaseFileBeforeCounter returns a count of RepositoryMock.UpdateKnowledgeBaseFile invocations
func (mmUpdateKnowledgeBaseFile *RepositoryMock) UpdateKnowledgeBaseFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseFile.beforeUpdateKnowledgeBaseFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateKnowledgeBaseFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateKnowledgeBaseFile *mRepositoryMockUpdateKnowledgeBaseFile) Calls() []*RepositoryMockUpdateKnowledgeBaseFileParams {
	mmUpdateKnowledgeBaseFile.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateKnowledgeBaseFileParams, len(mmUpdateKnowledgeBaseFile.callArgs))
	copy(argCopy, mmUpdateKnowledgeBaseFile.callArgs)

	mmUpdateKnowledgeBaseFile.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateKnowledgeBaseFileDone returns true if the count of the UpdateKnowledgeBaseFile invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateKnowledgeBaseFileDone() bool {
	if m.UpdateKnowledgeBaseFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateKnowledgeBaseFileMock.invocationsDone()
}

// MinimockUpdateKnowledgeBaseFileInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateKnowledgeBaseFileInspect() {
	for _, e := range m.UpdateKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateKnowledgeBaseFileCounter := mm_atomic.LoadUint64(&m.afterUpdateKnowledgeBaseFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateKnowledgeBaseFileMock.defaultExpectation != nil && afterUpdateKnowledgeBaseFileCounter < 1 {
		if m.UpdateKnowledgeBaseFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseFile at\n%s", m.UpdateKnowledgeBaseFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseFile at\n%s with params: %#v", m.UpdateKnowledgeBaseFileMock.defaultExpectation.expectationOrigins.origin, *m.UpdateKnowledgeBaseFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateKnowledgeBaseFile != nil && afterUpdateKnowledgeBaseFileCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseFile at\n%s", m.funcUpdateKnowledgeBaseFileOrigin)
	}

	if !m.UpdateKnowledgeBaseFileMock.invocationsDone() && afterUpdateKnowledgeBaseFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateKnowledgeBaseFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateKnowledgeBaseFileMock.expectedInvocations), m.UpdateKnowledgeBaseFileMock.expectedInvocationsOrigin, afterUpdateKnowledgeBaseFileCounter)
	}
}

type mRepositoryMockUpdateKnowledgeBaseResources struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateKnowledgeBaseResourcesExpectation
	expectations       []*RepositoryMockUpdateKnowledgeBaseResourcesExpectation

	callArgs []*RepositoryMockUpdateKnowledgeBaseResourcesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateKnowledgeBaseResourcesExpectation specifies expectation struct of the Repository.UpdateKnowledgeBaseResources
type RepositoryMockUpdateKnowledgeBaseResourcesExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateKnowledgeBaseResourcesParams
	paramPtrs          *RepositoryMockUpdateKnowledgeBaseResourcesParamPtrs
	expectationOrigins RepositoryMockUpdateKnowledgeBaseResourcesExpectationOrigins
	results            *RepositoryMockUpdateKnowledgeBaseResourcesResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateKnowledgeBaseResourcesParams contains parameters of the Repository.UpdateKnowledgeBaseResources
type RepositoryMockUpdateKnowledgeBaseResourcesParams struct {
	ctx       context.Context
	fromKBUID types.KBUIDType
	toKBUID   types.KBUIDType
}

// RepositoryMockUpdateKnowledgeBaseResourcesParamPtrs contains pointers to parameters of the Repository.UpdateKnowledgeBaseResources
type RepositoryMockUpdateKnowledgeBaseResourcesParamPtrs struct {
	ctx       *context.Context
	fromKBUID *types.KBUIDType
	toKBUID   *types.KBUIDType
}

// RepositoryMockUpdateKnowledgeBaseResourcesResults contains results of the Repository.UpdateKnowledgeBaseResources
type RepositoryMockUpdateKnowledgeBaseResourcesResults struct {
	err error
}

// RepositoryMockUpdateKnowledgeBaseResourcesOrigins contains origins of expectations of the Repository.UpdateKnowledgeBaseResources
type RepositoryMockUpdateKnowledgeBaseResourcesExpectationOrigins struct {
	origin          string
	originCtx       string
	originFromKBUID string
	originToKBUID   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateKnowledgeBaseResources *mRepositoryMockUpdateKnowledgeBaseResources) Optional() *mRepositoryMockUpdateKnowledgeBaseResources {
	mmUpdateKnowledgeBaseResources.optional = true
	return mmUpdateKnowledgeBaseResources
}

// Expect sets up expected params for Repository.UpdateKnowledgeBaseResources
func (mmUpdateKnowledgeBaseResources *mRepositoryMockUpdateKnowledgeBaseResources) Expect(ctx context.Context, fromKBUID types.KBUIDType, toKBUID types.KBUIDType) *mRepositoryMockUpdateKnowledgeBaseResources {
	if mmUpdateKnowledgeBaseResources.mock.funcUpdateKnowledgeBaseResources != nil {
		mmUpdateKnowledgeBaseResources.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseResources mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseResources.defaultExpectation == nil {
		mmUpdateKnowledgeBaseResources.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseResourcesExpectation{}
	}

	if mmUpdateKnowledgeBaseResources.defaultExpectation.paramPtrs != nil {
		mmUpdateKnowledgeBaseResources.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseResources mock is already set by ExpectParams functions")
	}

	mmUpdateKnowledgeBaseResources.defaultExpectation.params = &RepositoryMockUpdateKnowledgeBaseResourcesParams{ctx, fromKBUID, toKBUID}
	mmUpdateKnowledgeBaseResources.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateKnowledgeBaseResources.expectations {
		if minimock.Equal(e.params, mmUpdateKnowledgeBaseResources.defaultExpectation.params) {
			mmUpdateKnowledgeBaseResources.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateKnowledgeBaseResources.defaultExpectation.params)
		}
	}

	return mmUpdateKnowledgeBaseResources
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateKnowledgeBaseResources
func (mmUpdateKnowledgeBaseResources *mRepositoryMockUpdateKnowledgeBaseResources) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateKnowledgeBaseResources {
	if mmUpdateKnowledgeBaseResources.mock.funcUpdateKnowledgeBaseResources != nil {
		mmUpdateKnowledgeBaseResources.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseResources mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseResources.defaultExpectation == nil {
		mmUpdateKnowledgeBaseResources.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseResourcesExpectation{}
	}

	if mmUpdateKnowledgeBaseResources.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseResources.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseResources mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseResources.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseResources.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseResourcesParamPtrs{}
	}
	mmUpdateKnowledgeBaseResources.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateKnowledgeBaseResources.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseResources
}

// ExpectFromKBUIDParam2 sets up expected param fromKBUID for Repository.UpdateKnowledgeBaseResources
func (mmUpdateKnowledgeBaseResources *mRepositoryMockUpdateKnowledgeBaseResources) ExpectFromKBUIDParam2(fromKBUID types.KBUIDType) *mRepositoryMockUpdateKnowledgeBaseResources {
	if mmUpdateKnowledgeBaseResources.mock.funcUpdateKnowledgeBaseResources != nil {
		mmUpdateKnowledgeBaseResources.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseResources mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseResources.defaultExpectation == nil {
		mmUpdateKnowledgeBaseResources.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseResourcesExpectation{}
	}

	if mmUpdateKnowledgeBaseResources.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseResources.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseResources mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseResources.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseResources.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseResourcesParamPtrs{}
	}
	mmUpdateKnowledgeBaseResources.defaultExpectation.paramPtrs.fromKBUID = &fromKBUID
	mmUpdateKnowledgeBaseResources.defaultExpectation.expectationOrigins.originFromKBUID = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseResources
}

// ExpectToKBUIDParam3 sets up expected param toKBUID for Repository.UpdateKnowledgeBaseResources
func (mmUpdateKnowledgeBaseResources *mRepositoryMockUpdateKnowledgeBaseResources) ExpectToKBUIDParam3(toKBUID types.KBUIDType) *mRepositoryMockUpdateKnowledgeBaseResources {
	if mmUpdateKnowledgeBaseResources.mock.funcUpdateKnowledgeBaseResources != nil {
		mmUpdateKnowledgeBaseResources.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseResources mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseResources.defaultExpectation == nil {
		mmUpdateKnowledgeBaseResources.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseResourcesExpectation{}
	}

	if mmUpdateKnowledgeBaseResources.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseResources.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseResources mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseResources.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseResources.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseResourcesParamPtrs{}
	}
	mmUpdateKnowledgeBaseResources.defaultExpectation.paramPtrs.toKBUID = &toKBUID
	mmUpdateKnowledgeBaseResources.defaultExpectation.expectationOrigins.originToKBUID = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseResources
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateKnowledgeBaseResources
func (mmUpdateKnowledgeBaseResources *mRepositoryMockUpdateKnowledgeBaseResources) Inspect(f func(ctx context.Context, fromKBUID types.KBUIDType, toKBUID types.KBUIDType)) *mRepositoryMockUpdateKnowledgeBaseResources {
	if mmUpdateKnowledgeBaseResources.mock.inspectFuncUpdateKnowledgeBaseResources != nil {
		mmUpdateKnowledgeBaseResources.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateKnowledgeBaseResources")
	}

	mmUpdateKnowledgeBaseResources.mock.inspectFuncUpdateKnowledgeBaseResources = f

	return mmUpdateKnowledgeBaseResources
}

// Return sets up results that will be returned by Repository.UpdateKnowledgeBaseResources
func (mmUpdateKnowledgeBaseResources *mRepositoryMockUpdateKnowledgeBaseResources) Return(err error) *RepositoryMock {
	if mmUpdateKnowledgeBaseResources.mock.funcUpdateKnowledgeBaseResources != nil {
		mmUpdateKnowledgeBaseResources.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseResources mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseResources.defaultExpectation == nil {
		mmUpdateKnowledgeBaseResources.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseResourcesExpectation{mock: mmUpdateKnowledgeBaseResources.mock}
	}
	mmUpdateKnowledgeBaseResources.defaultExpectation.results = &RepositoryMockUpdateKnowledgeBaseResourcesResults{err}
	mmUpdateKnowledgeBaseResources.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBaseResources.mock
}

// Set uses given function f to mock the Repository.UpdateKnowledgeBaseResources method
func (mmUpdateKnowledgeBaseResources *mRepositoryMockUpdateKnowledgeBaseResources) Set(f func(ctx context.Context, fromKBUID types.KBUIDType, toKBUID types.KBUIDType) (err error)) *RepositoryMock {
	if mmUpdateKnowledgeBaseResources.defaultExpectation != nil {
		mmUpdateKnowledgeBaseResources.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateKnowledgeBaseResources method")
	}

	if len(mmUpdateKnowledgeBaseResources.expectations) > 0 {
		mmUpdateKnowledgeBaseResources.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateKnowledgeBaseResources method")
	}

	mmUpdateKnowledgeBaseResources.mock.funcUpdateKnowledgeBaseResources = f
	mmUpdateKnowledgeBaseResources.mock.funcUpdateKnowledgeBaseResourcesOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBaseResources.mock
}

// When sets expectation for the Repository.UpdateKnowledgeBaseResources which will trigger the result defined by the following
// Then helper
func (mmUpdateKnowledgeBaseResources *mRepositoryMockUpdateKnowledgeBaseResources) When(ctx context.Context, fromKBUID types.KBUIDType, toKBUID types.KBUIDType) *RepositoryMockUpdateKnowledgeBaseResourcesExpectation {
	if mmUpdateKnowledgeBaseResources.mock.funcUpdateKnowledgeBaseResources != nil {
		mmUpdateKnowledgeBaseResources.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseResources mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateKnowledgeBaseResourcesExpectation{
		mock:               mmUpdateKnowledgeBaseResources.mock,
		params:             &RepositoryMockUpdateKnowledgeBaseResourcesParams{ctx, fromKBUID, toKBUID},
		expectationOrigins: RepositoryMockUpdateKnowledgeBaseResourcesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateKnowledgeBaseResources.expectations = append(mmUpdateKnowledgeBaseResources.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateKnowledgeBaseResources return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateKnowledgeBaseResourcesExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateKnowledgeBaseResourcesResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateKnowledgeBaseResources should be invoked
func (mmUpdateKnowledgeBaseResources *mRepositoryMockUpdateKnowledgeBaseResources) Times(n uint64) *mRepositoryMockUpdateKnowledgeBaseResources {
	if n == 0 {
		mmUpdateKnowledgeBaseResources.mock.t.Fatalf("Times of RepositoryMock.UpdateKnowledgeBaseResources mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateKnowledgeBaseResources.expectedInvocations, n)
	mmUpdateKnowledgeBaseResources.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBaseResources
}

func (mmUpdateKnowledgeBaseResources *mRepositoryMockUpdateKnowledgeBaseResources) invocationsDone() bool {
	if len(mmUpdateKnowledgeBaseResources.expectations) == 0 && mmUpdateKnowledgeBaseResources.defaultExpectation == nil && mmUpdateKnowledgeBaseResources.mock.funcUpdateKnowledgeBaseResources == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseResources.mock.afterUpdateKnowledgeBaseResourcesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseResources.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateKnowledgeBaseResources implements mm_repository.Repository
func (mmUpdateKnowledgeBaseResources *RepositoryMock) UpdateKnowledgeBaseResources(ctx context.Context, fromKBUID types.KBUIDType, toKBUID types.KBUIDType) (err error) {
	mm_atomic.AddUint64(&mmUpdateKnowledgeBaseResources.beforeUpdateKnowledgeBaseResourcesCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateKnowledgeBaseResources.afterUpdateKnowledgeBaseResourcesCounter, 1)

	mmUpdateKnowledgeBaseResources.t.Helper()

	if mmUpdateKnowledgeBaseResources.inspectFuncUpdateKnowledgeBaseResources != nil {
		mmUpdateKnowledgeBaseResources.inspectFuncUpdateKnowledgeBaseResources(ctx, fromKBUID, toKBUID)
	}

	mm_params := RepositoryMockUpdateKnowledgeBaseResourcesParams{ctx, fromKBUID, toKBUID}

	// Record call args
	mmUpdateKnowledgeBaseResources.UpdateKnowledgeBaseResourcesMock.mutex.Lock()
	mmUpdateKnowledgeBaseResources.UpdateKnowledgeBaseResourcesMock.callArgs = append(mmUpdateKnowledgeBaseResources.UpdateKnowledgeBaseResourcesMock.callArgs, &mm_params)
	mmUpdateKnowledgeBaseResources.UpdateKnowledgeBaseResourcesMock.mutex.Unlock()

	for _, e := range mmUpdateKnowledgeBaseResources.UpdateKnowledgeBaseResourcesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateKnowledgeBaseResources.UpdateKnowledgeBaseResourcesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateKnowledgeBaseResources.UpdateKnowledgeBaseResourcesMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateKnowledgeBaseResources.UpdateKnowledgeBaseResourcesMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateKnowledgeBaseResources.UpdateKnowledgeBaseResourcesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateKnowledgeBaseResourcesParams{ctx, fromKBUID, toKBUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateKnowledgeBaseResources.t.Errorf("RepositoryMock.UpdateKnowledgeBaseResources got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseResources.UpdateKnowledgeBaseResourcesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fromKBUID != nil && !minimock.Equal(*mm_want_ptrs.fromKBUID, mm_got.fromKBUID) {
				mmUpdateKnowledgeBaseResources.t.Errorf("RepositoryMock.UpdateKnowledgeBaseResources got unexpected parameter fromKBUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseResources.UpdateKnowledgeBaseResourcesMock.defaultExpectation.expectationOrigins.originFromKBUID, *mm_want_ptrs.fromKBUID, mm_got.fromKBUID, minimock.Diff(*mm_want_ptrs.fromKBUID, mm_got.fromKBUID))
			}

			if mm_want_ptrs.toKBUID != nil && !minimock.Equal(*mm_want_ptrs.toKBUID, mm_got.toKBUID) {
				mmUpdateKnowledgeBaseResources.t.Errorf("RepositoryMock.UpdateKnowledgeBaseResources got unexpected parameter toKBUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseResources.UpdateKnowledgeBaseResourcesMock.defaultExpectation.expectationOrigins.originToKBUID, *mm_want_ptrs.toKBUID, mm_got.toKBUID, minimock.Diff(*mm_want_ptrs.toKBUID, mm_got.toKBUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateKnowledgeBaseResources.t.Errorf("RepositoryMock.UpdateKnowledgeBaseResources got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateKnowledgeBaseResources.UpdateKnowledgeBaseResourcesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateKnowledgeBaseResources.UpdateKnowledgeBaseResourcesMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateKnowledgeBaseResources.t.Fatal("No results are set for the RepositoryMock.UpdateKnowledgeBaseResources")
		}
		return (*mm_results).err
	}
	if mmUpdateKnowledgeBaseResources.funcUpdateKnowledgeBaseResources != nil {
		return mmUpdateKnowledgeBaseResources.funcUpdateKnowledgeBaseResources(ctx, fromKBUID, toKBUID)
	}
	mmUpdateKnowledgeBaseResources.t.Fatalf("Unexpected call to RepositoryMock.UpdateKnowledgeBaseResources. %v %v %v", ctx, fromKBUID, toKBUID)
	return
}

// UpdateKnowledgeBaseResourcesAfterCounter returns a count of finished RepositoryMock.UpdateKnowledgeBaseResources invocations
func (mmUpdateKnowledgeBaseResources *RepositoryMock) UpdateKnowledgeBaseResourcesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseResources.afterUpdateKnowledgeBaseResourcesCounter)
}

// UpdateKnowledgeBaseResourcesBeforeCounter returns a count of RepositoryMock.UpdateKnowledgeBaseResources invocations
func (mmUpdateKnowledgeBaseResources *RepositoryMock) UpdateKnowledgeBaseResourcesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseResources.beforeUpdateKnowledgeBaseResourcesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateKnowledgeBaseResources.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateKnowledgeBaseResources *mRepositoryMockUpdateKnowledgeBaseResources) Calls() []*RepositoryMockUpdateKnowledgeBaseResourcesParams {
	mmUpdateKnowledgeBaseResources.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateKnowledgeBaseResourcesParams, len(mmUpdateKnowledgeBaseResources.callArgs))
	copy(argCopy, mmUpdateKnowledgeBaseResources.callArgs)

	mmUpdateKnowledgeBaseResources.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateKnowledgeBaseResourcesDone returns true if the count of the UpdateKnowledgeBaseResources invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateKnowledgeBaseResourcesDone() bool {
	if m.UpdateKnowledgeBaseResourcesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateKnowledgeBaseResourcesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateKnowledgeBaseResourcesMock.invocationsDone()
}

// MinimockUpdateKnowledgeBaseResourcesInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateKnowledgeBaseResourcesInspect() {
	for _, e := range m.UpdateKnowledgeBaseResourcesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseResources at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateKnowledgeBaseResourcesCounter := mm_atomic.LoadUint64(&m.afterUpdateKnowledgeBaseResourcesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateKnowledgeBaseResourcesMock.defaultExpectation != nil && afterUpdateKnowledgeBaseResourcesCounter < 1 {
		if m.UpdateKnowledgeBaseResourcesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseResources at\n%s", m.UpdateKnowledgeBaseResourcesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseResources at\n%s with params: %#v", m.UpdateKnowledgeBaseResourcesMock.defaultExpectation.expectationOrigins.origin, *m.UpdateKnowledgeBaseResourcesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateKnowledgeBaseResources != nil && afterUpdateKnowledgeBaseResourcesCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseResources at\n%s", m.funcUpdateKnowledgeBaseResourcesOrigin)
	}

	if !m.UpdateKnowledgeBaseResourcesMock.invocationsDone() && afterUpdateKnowledgeBaseResourcesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateKnowledgeBaseResources at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateKnowledgeBaseResourcesMock.expectedInvocations), m.UpdateKnowledgeBaseResourcesMock.expectedInvocationsOrigin, afterUpdateKnowledgeBaseResourcesCounter)
	}
}

type mRepositoryMockUpdateKnowledgeBaseResourcesTx struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateKnowledgeBaseResourcesTxExpectation
	expectations       []*RepositoryMockUpdateKnowledgeBaseResourcesTxExpectation

	callArgs []*RepositoryMockUpdateKnowledgeBaseResourcesTxParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateKnowledgeBaseResourcesTxExpectation specifies expectation struct of the Repository.UpdateKnowledgeBaseResourcesTx
type RepositoryMockUpdateKnowledgeBaseResourcesTxExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateKnowledgeBaseResourcesTxParams
	paramPtrs          *RepositoryMockUpdateKnowledgeBaseResourcesTxParamPtrs
	expectationOrigins RepositoryMockUpdateKnowledgeBaseResourcesTxExpectationOrigins
	results            *RepositoryMockUpdateKnowledgeBaseResourcesTxResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateKnowledgeBaseResourcesTxParams contains parameters of the Repository.UpdateKnowledgeBaseResourcesTx
type RepositoryMockUpdateKnowledgeBaseResourcesTxParams struct {
	ctx       context.Context
	tx        *gorm.DB
	fromKBUID types.KBUIDType
	toKBUID   types.KBUIDType
}

// RepositoryMockUpdateKnowledgeBaseResourcesTxParamPtrs contains pointers to parameters of the Repository.UpdateKnowledgeBaseResourcesTx
type RepositoryMockUpdateKnowledgeBaseResourcesTxParamPtrs struct {
	ctx       *context.Context
	tx        **gorm.DB
	fromKBUID *types.KBUIDType
	toKBUID   *types.KBUIDType
}

// RepositoryMockUpdateKnowledgeBaseResourcesTxResults contains results of the Repository.UpdateKnowledgeBaseResourcesTx
type RepositoryMockUpdateKnowledgeBaseResourcesTxResults struct {
	err error
}

// RepositoryMockUpdateKnowledgeBaseResourcesTxOrigins contains origins of expectations of the Repository.UpdateKnowledgeBaseResourcesTx
type RepositoryMockUpdateKnowledgeBaseResourcesTxExpectationOrigins struct {
	origin          string
	originCtx       string
	originTx        string
	originFromKBUID string
	originToKBUID   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateKnowledgeBaseResourcesTx *mRepositoryMockUpdateKnowledgeBaseResourcesTx) Optional() *mRepositoryMockUpdateKnowledgeBaseResourcesTx {
	mmUpdateKnowledgeBaseResourcesTx.optional = true
	return mmUpdateKnowledgeBaseResourcesTx
}

// Expect sets up expected params for Repository.UpdateKnowledgeBaseResourcesTx
func (mmUpdateKnowledgeBaseResourcesTx *mRepositoryMockUpdateKnowledgeBaseResourcesTx) Expect(ctx context.Context, tx *gorm.DB, fromKBUID types.KBUIDType, toKBUID types.KBUIDType) *mRepositoryMockUpdateKnowledgeBaseResourcesTx {
	if mmUpdateKnowledgeBaseResourcesTx.mock.funcUpdateKnowledgeBaseResourcesTx != nil {
		mmUpdateKnowledgeBaseResourcesTx.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseResourcesTx mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseResourcesTx.defaultExpectation == nil {
		mmUpdateKnowledgeBaseResourcesTx.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseResourcesTxExpectation{}
	}

	if mmUpdateKnowledgeBaseResourcesTx.defaultExpectation.paramPtrs != nil {
		mmUpdateKnowledgeBaseResourcesTx.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseResourcesTx mock is already set by ExpectParams functions")
	}

	mmUpdateKnowledgeBaseResourcesTx.defaultExpectation.params = &RepositoryMockUpdateKnowledgeBaseResourcesTxParams{ctx, tx, fromKBUID, toKBUID}
	mmUpdateKnowledgeBaseResourcesTx.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateKnowledgeBaseResourcesTx.expectations {
		if minimock.Equal(e.params, mmUpdateKnowledgeBaseResourcesTx.defaultExpectation.params) {
			mmUpdateKnowledgeBaseResourcesTx.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateKnowledgeBaseResourcesTx.defaultExpectation.params)
		}
	}

	return mmUpdateKnowledgeBaseResourcesTx
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateKnowledgeBaseResourcesTx
func (mmUpdateKnowledgeBaseResourcesTx *mRepositoryMockUpdateKnowledgeBaseResourcesTx) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateKnowledgeBaseResourcesTx {
	if mmUpdateKnowledgeBaseResourcesTx.mock.funcUpdateKnowledgeBaseResourcesTx != nil {
		mmUpdateKnowledgeBaseResourcesTx.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseResourcesTx mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseResourcesTx.defaultExpectation == nil {
		mmUpdateKnowledgeBaseResourcesTx.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseResourcesTxExpectation{}
	}

	if mmUpdateKnowledgeBaseResourcesTx.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseResourcesTx.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseResourcesTx mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseResourcesTx.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseResourcesTx.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseResourcesTxParamPtrs{}
	}
	mmUpdateKnowledgeBaseResourcesTx.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateKnowledgeBaseResourcesTx.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseResourcesTx
}

// ExpectTxParam2 sets up expected param tx for Repository.UpdateKnowledgeBaseResourcesTx
func (mmUpdateKnowledgeBaseResourcesTx *mRepositoryMockUpdateKnowledgeBaseResourcesTx) ExpectTxParam2(tx *gorm.DB) *mRepositoryMockUpdateKnowledgeBaseResourcesTx {
	if mmUpdateKnowledgeBaseResourcesTx.mock.funcUpdateKnowledgeBaseResourcesTx != nil {
		mmUpdateKnowledgeBaseResourcesTx.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseResourcesTx mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseResourcesTx.defaultExpectation == nil {
		mmUpdateKnowledgeBaseResourcesTx.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseResourcesTxExpectation{}
	}

	if mmUpdateKnowledgeBaseResourcesTx.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseResourcesTx.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseResourcesTx mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseResourcesTx.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseResourcesTx.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseResourcesTxParamPtrs{}
	}
	mmUpdateKnowledgeBaseResourcesTx.defaultExpectation.paramPtrs.tx = &tx
	mmUpdateKnowledgeBaseResourcesTx.defaultExpectation.expectationOrigins.originTx = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseResourcesTx
}

// ExpectFromKBUIDParam3 sets up expected param fromKBUID for Repository.UpdateKnowledgeBaseResourcesTx
func (mmUpdateKnowledgeBaseResourcesTx *mRepositoryMockUpdateKnowledgeBaseResourcesTx) ExpectFromKBUIDParam3(fromKBUID types.KBUIDType) *mRepositoryMockUpdateKnowledgeBaseResourcesTx {
	if mmUpdateKnowledgeBaseResourcesTx.mock.funcUpdateKnowledgeBaseResourcesTx != nil {
		mmUpdateKnowledgeBaseResourcesTx.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseResourcesTx mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseResourcesTx.defaultExpectation == nil {
		mmUpdateKnowledgeBaseResourcesTx.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseResourcesTxExpectation{}
	}

	if mmUpdateKnowledgeBaseResourcesTx.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseResourcesTx.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseResourcesTx mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseResourcesTx.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseResourcesTx.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseResourcesTxParamPtrs{}
	}
	mmUpdateKnowledgeBaseResourcesTx.defaultExpectation.paramPtrs.fromKBUID = &fromKBUID
	mmUpdateKnowledgeBaseResourcesTx.defaultExpectation.expectationOrigins.originFromKBUID = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseResourcesTx
}

// ExpectToKBUIDParam4 sets up expected param toKBUID for Repository.UpdateKnowledgeBaseResourcesTx
func (mmUpdateKnowledgeBaseResourcesTx *mRepositoryMockUpdateKnowledgeBaseResourcesTx) ExpectToKBUIDParam4(toKBUID types.KBUIDType) *mRepositoryMockUpdateKnowledgeBaseResourcesTx {
	if mmUpdateKnowledgeBaseResourcesTx.mock.funcUpdateKnowledgeBaseResourcesTx != nil {
		mmUpdateKnowledgeBaseResourcesTx.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseResourcesTx mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseResourcesTx.defaultExpectation == nil {
		mmUpdateKnowledgeBaseResourcesTx.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseResourcesTxExpectation{}
	}

	if mmUpdateKnowledgeBaseResourcesTx.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseResourcesTx.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseResourcesTx mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseResourcesTx.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseResourcesTx.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseResourcesTxParamPtrs{}
	}
	mmUpdateKnowledgeBaseResourcesTx.defaultExpectation.paramPtrs.toKBUID = &toKBUID
	mmUpdateKnowledgeBaseResourcesTx.defaultExpectation.expectationOrigins.originToKBUID = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseResourcesTx
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateKnowledgeBaseResourcesTx
func (mmUpdateKnowledgeBaseResourcesTx *mRepositoryMockUpdateKnowledgeBaseResourcesTx) Inspect(f func(ctx context.Context, tx *gorm.DB, fromKBUID types.KBUIDType, toKBUID types.KBUIDType)) *mRepositoryMockUpdateKnowledgeBaseResourcesTx {
	if mmUpdateKnowledgeBaseResourcesTx.mock.inspectFuncUpdateKnowledgeBaseResourcesTx != nil {
		mmUpdateKnowledgeBaseResourcesTx.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateKnowledgeBaseResourcesTx")
	}

	mmUpdateKnowledgeBaseResourcesTx.mock.inspectFuncUpdateKnowledgeBaseResourcesTx = f

	return mmUpdateKnowledgeBaseResourcesTx
}

// Return sets up results that will be returned by Repository.UpdateKnowledgeBaseResourcesTx
func (mmUpdateKnowledgeBaseResourcesTx *mRepositoryMockUpdateKnowledgeBaseResourcesTx) Return(err error) *RepositoryMock {
	if mmUpdateKnowledgeBaseResourcesTx.mock.funcUpdateKnowledgeBaseResourcesTx != nil {
		mmUpdateKnowledgeBaseResourcesTx.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseResourcesTx mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseResourcesTx.defaultExpectation == nil {
		mmUpdateKnowledgeBaseResourcesTx.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseResourcesTxExpectation{mock: mmUpdateKnowledgeBaseResourcesTx.mock}
	}
	mmUpdateKnowledgeBaseResourcesTx.defaultExpectation.results = &RepositoryMockUpdateKnowledgeBaseResourcesTxResults{err}
	mmUpdateKnowledgeBaseResourcesTx.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBaseResourcesTx.mock
}

// Set uses given function f to mock the Repository.UpdateKnowledgeBaseResourcesTx method
func (mmUpdateKnowledgeBaseResourcesTx *mRepositoryMockUpdateKnowledgeBaseResourcesTx) Set(f func(ctx context.Context, tx *gorm.DB, fromKBUID types.KBUIDType, toKBUID types.KBUIDType) (err error)) *RepositoryMock {
	if mmUpdateKnowledgeBaseResourcesTx.defaultExpectation != nil {
		mmUpdateKnowledgeBaseResourcesTx.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateKnowledgeBaseResourcesTx method")
	}

	if len(mmUpdateKnowledgeBaseResourcesTx.expectations) > 0 {
		mmUpdateKnowledgeBaseResourcesTx.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateKnowledgeBaseResourcesTx method")
	}

	mmUpdateKnowledgeBaseResourcesTx.mock.funcUpdateKnowledgeBaseResourcesTx = f
	mmUpdateKnowledgeBaseResourcesTx.mock.funcUpdateKnowledgeBaseResourcesTxOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBaseResourcesTx.mock
}

// When sets expectation for the Repository.UpdateKnowledgeBaseResourcesTx which will trigger the result defined by the following
// Then helper
func (mmUpdateKnowledgeBaseResourcesTx *mRepositoryMockUpdateKnowledgeBaseResourcesTx) When(ctx context.Context, tx *gorm.DB, fromKBUID types.KBUIDType, toKBUID types.KBUIDType) *RepositoryMockUpdateKnowledgeBaseResourcesTxExpectation {
	if mmUpdateKnowledgeBaseResourcesTx.mock.funcUpdateKnowledgeBaseResourcesTx != nil {
		mmUpdateKnowledgeBaseResourcesTx.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseResourcesTx mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateKnowledgeBaseResourcesTxExpectation{
		mock:               mmUpdateKnowledgeBaseResourcesTx.mock,
		params:             &RepositoryMockUpdateKnowledgeBaseResourcesTxParams{ctx, tx, fromKBUID, toKBUID},
		expectationOrigins: RepositoryMockUpdateKnowledgeBaseResourcesTxExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateKnowledgeBaseResourcesTx.expectations = append(mmUpdateKnowledgeBaseResourcesTx.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateKnowledgeBaseResourcesTx return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateKnowledgeBaseResourcesTxExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateKnowledgeBaseResourcesTxResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateKnowledgeBaseResourcesTx should be invoked
func (mmUpdateKnowledgeBaseResourcesTx *mRepositoryMockUpdateKnowledgeBaseResourcesTx) Times(n uint64) *mRepositoryMockUpdateKnowledgeBaseResourcesTx {
	if n == 0 {
		mmUpdateKnowledgeBaseResourcesTx.mock.t.Fatalf("Times of RepositoryMock.UpdateKnowledgeBaseResourcesTx mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateKnowledgeBaseResourcesTx.expectedInvocations, n)
	mmUpdateKnowledgeBaseResourcesTx.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBaseResourcesTx
}

func (mmUpdateKnowledgeBaseResourcesTx *mRepositoryMockUpdateKnowledgeBaseResourcesTx) invocationsDone() bool {
	if len(mmUpdateKnowledgeBaseResourcesTx.expectations) == 0 && mmUpdateKnowledgeBaseResourcesTx.defaultExpectation == nil && mmUpdateKnowledgeBaseResourcesTx.mock.funcUpdateKnowledgeBaseResourcesTx == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseResourcesTx.mock.afterUpdateKnowledgeBaseResourcesTxCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseResourcesTx.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateKnowledgeBaseResourcesTx implements mm_repository.Repository
func (mmUpdateKnowledgeBaseResourcesTx *RepositoryMock) UpdateKnowledgeBaseResourcesTx(ctx context.Context, tx *gorm.DB, fromKBUID types.KBUIDType, toKBUID types.KBUIDType) (err error) {
	mm_atomic.AddUint64(&mmUpdateKnowledgeBaseResourcesTx.beforeUpdateKnowledgeBaseResourcesTxCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateKnowledgeBaseResourcesTx.afterUpdateKnowledgeBaseResourcesTxCounter, 1)

	mmUpdateKnowledgeBaseResourcesTx.t.Helper()

	if mmUpdateKnowledgeBaseResourcesTx.inspectFuncUpdateKnowledgeBaseResourcesTx != nil {
		mmUpdateKnowledgeBaseResourcesTx.inspectFuncUpdateKnowledgeBaseResourcesTx(ctx, tx, fromKBUID, toKBUID)
	}

	mm_params := RepositoryMockUpdateKnowledgeBaseResourcesTxParams{ctx, tx, fromKBUID, toKBUID}

	// Record call args
	mmUpdateKnowledgeBaseResourcesTx.UpdateKnowledgeBaseResourcesTxMock.mutex.Lock()
	mmUpdateKnowledgeBaseResourcesTx.UpdateKnowledgeBaseResourcesTxMock.callArgs = append(mmUpdateKnowledgeBaseResourcesTx.UpdateKnowledgeBaseResourcesTxMock.callArgs, &mm_params)
	mmUpdateKnowledgeBaseResourcesTx.UpdateKnowledgeBaseResourcesTxMock.mutex.Unlock()

	for _, e := range mmUpdateKnowledgeBaseResourcesTx.UpdateKnowledgeBaseResourcesTxMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateKnowledgeBaseResourcesTx.UpdateKnowledgeBaseResourcesTxMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateKnowledgeBaseResourcesTx.UpdateKnowledgeBaseResourcesTxMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateKnowledgeBaseResourcesTx.UpdateKnowledgeBaseResourcesTxMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateKnowledgeBaseResourcesTx.UpdateKnowledgeBaseResourcesTxMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateKnowledgeBaseResourcesTxParams{ctx, tx, fromKBUID, toKBUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateKnowledgeBaseResourcesTx.t.Errorf("RepositoryMock.UpdateKnowledgeBaseResourcesTx got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseResourcesTx.UpdateKnowledgeBaseResourcesTxMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tx != nil && !minimock.Equal(*mm_want_ptrs.tx, mm_got.tx) {
				mmUpdateKnowledgeBaseResourcesTx.t.Errorf("RepositoryMock.UpdateKnowledgeBaseResourcesTx got unexpected parameter tx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseResourcesTx.UpdateKnowledgeBaseResourcesTxMock.defaultExpectation.expectationOrigins.originTx, *mm_want_ptrs.tx, mm_got.tx, minimock.Diff(*mm_want_ptrs.tx, mm_got.tx))
			}

			if mm_want_ptrs.fromKBUID != nil && !minimock.Equal(*mm_want_ptrs.fromKBUID, mm_got.fromKBUID) {
				mmUpdateKnowledgeBaseResourcesTx.t.Errorf("RepositoryMock.UpdateKnowledgeBaseResourcesTx got unexpected parameter fromKBUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseResourcesTx.UpdateKnowledgeBaseResourcesTxMock.defaultExpectation.expectationOrigins.originFromKBUID, *mm_want_ptrs.fromKBUID, mm_got.fromKBUID, minimock.Diff(*mm_want_ptrs.fromKBUID, mm_got.fromKBUID))
			}

			if mm_want_ptrs.toKBUID != nil && !minimock.Equal(*mm_want_ptrs.toKBUID, mm_got.toKBUID) {
				mmUpdateKnowledgeBaseResourcesTx.t.Errorf("RepositoryMock.UpdateKnowledgeBaseResourcesTx got unexpected parameter toKBUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseResourcesTx.UpdateKnowledgeBaseResourcesTxMock.defaultExpectation.expectationOrigins.originToKBUID, *mm_want_ptrs.toKBUID, mm_got.toKBUID, minimock.Diff(*mm_want_ptrs.toKBUID, mm_got.toKBUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateKnowledgeBaseResourcesTx.t.Errorf("RepositoryMock.UpdateKnowledgeBaseResourcesTx got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateKnowledgeBaseResourcesTx.UpdateKnowledgeBaseResourcesTxMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateKnowledgeBaseResourcesTx.UpdateKnowledgeBaseResourcesTxMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateKnowledgeBaseResourcesTx.t.Fatal("No results are set for the RepositoryMock.UpdateKnowledgeBaseResourcesTx")
		}
		return (*mm_results).err
	}
	if mmUpdateKnowledgeBaseResourcesTx.funcUpdateKnowledgeBaseResourcesTx != nil {
		return mmUpdateKnowledgeBaseResourcesTx.funcUpdateKnowledgeBaseResourcesTx(ctx, tx, fromKBUID, toKBUID)
	}
	mmUpdateKnowledgeBaseResourcesTx.t.Fatalf("Unexpected call to RepositoryMock.UpdateKnowledgeBaseResourcesTx. %v %v %v %v", ctx, tx, fromKBUID, toKBUID)
	return
}

// UpdateKnowledgeBaseResourcesTxAfterCounter returns a count of finished RepositoryMock.UpdateKnowledgeBaseResourcesTx invocations
func (mmUpdateKnowledgeBaseResourcesTx *RepositoryMock) UpdateKnowledgeBaseResourcesTxAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseResourcesTx.afterUpdateKnowledgeBaseResourcesTxCounter)
}

// UpdateKnowledgeBaseResourcesTxBeforeCounter returns a count of RepositoryMock.UpdateKnowledgeBaseResourcesTx invocations
func (mmUpdateKnowledgeBaseResourcesTx *RepositoryMock) UpdateKnowledgeBaseResourcesTxBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseResourcesTx.beforeUpdateKnowledgeBaseResourcesTxCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateKnowledgeBaseResourcesTx.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateKnowledgeBaseResourcesTx *mRepositoryMockUpdateKnowledgeBaseResourcesTx) Calls() []*RepositoryMockUpdateKnowledgeBaseResourcesTxParams {
	mmUpdateKnowledgeBaseResourcesTx.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateKnowledgeBaseResourcesTxParams, len(mmUpdateKnowledgeBaseResourcesTx.callArgs))
	copy(argCopy, mmUpdateKnowledgeBaseResourcesTx.callArgs)

	mmUpdateKnowledgeBaseResourcesTx.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateKnowledgeBaseResourcesTxDone returns true if the count of the UpdateKnowledgeBaseResourcesTx invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateKnowledgeBaseResourcesTxDone() bool {
	if m.UpdateKnowledgeBaseResourcesTxMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateKnowledgeBaseResourcesTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateKnowledgeBaseResourcesTxMock.invocationsDone()
}

// MinimockUpdateKnowledgeBaseResourcesTxInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateKnowledgeBaseResourcesTxInspect() {
	for _, e := range m.UpdateKnowledgeBaseResourcesTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseResourcesTx at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateKnowledgeBaseResourcesTxCounter := mm_atomic.LoadUint64(&m.afterUpdateKnowledgeBaseResourcesTxCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateKnowledgeBaseResourcesTxMock.defaultExpectation != nil && afterUpdateKnowledgeBaseResourcesTxCounter < 1 {
		if m.UpdateKnowledgeBaseResourcesTxMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseResourcesTx at\n%s", m.UpdateKnowledgeBaseResourcesTxMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseResourcesTx at\n%s with params: %#v", m.UpdateKnowledgeBaseResourcesTxMock.defaultExpectation.expectationOrigins.origin, *m.UpdateKnowledgeBaseResourcesTxMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateKnowledgeBaseResourcesTx != nil && afterUpdateKnowledgeBaseResourcesTxCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseResourcesTx at\n%s", m.funcUpdateKnowledgeBaseResourcesTxOrigin)
	}

	if !m.UpdateKnowledgeBaseResourcesTxMock.invocationsDone() && afterUpdateKnowledgeBaseResourcesTxCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateKnowledgeBaseResourcesTx at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateKnowledgeBaseResourcesTxMock.expectedInvocations), m.UpdateKnowledgeBaseResourcesTxMock.expectedInvocationsOrigin, afterUpdateKnowledgeBaseResourcesTxCounter)
	}
}

type mRepositoryMockUpdateKnowledgeBaseUpdateStatus struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateKnowledgeBaseUpdateStatusExpectation
	expectations       []*RepositoryMockUpdateKnowledgeBaseUpdateStatusExpectation

	callArgs []*RepositoryMockUpdateKnowledgeBaseUpdateStatusParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateKnowledgeBaseUpdateStatusExpectation specifies expectation struct of the Repository.UpdateKnowledgeBaseUpdateStatus
type RepositoryMockUpdateKnowledgeBaseUpdateStatusExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateKnowledgeBaseUpdateStatusParams
	paramPtrs          *RepositoryMockUpdateKnowledgeBaseUpdateStatusParamPtrs
	expectationOrigins RepositoryMockUpdateKnowledgeBaseUpdateStatusExpectationOrigins
	results            *RepositoryMockUpdateKnowledgeBaseUpdateStatusResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateKnowledgeBaseUpdateStatusParams contains parameters of the Repository.UpdateKnowledgeBaseUpdateStatus
type RepositoryMockUpdateKnowledgeBaseUpdateStatusParams struct {
	ctx               context.Context
	kbUID             types.KBUIDType
	status            string
	workflowID        string
	errorMessage      string
	previousSystemUID types.SystemUIDType
}

// RepositoryMockUpdateKnowledgeBaseUpdateStatusParamPtrs contains pointers to parameters of the Repository.UpdateKnowledgeBaseUpdateStatus
type RepositoryMockUpdateKnowledgeBaseUpdateStatusParamPtrs struct {
	ctx               *context.Context
	kbUID             *types.KBUIDType
	status            *string
	workflowID        *string
	errorMessage      *string
	previousSystemUID *types.SystemUIDType
}

// RepositoryMockUpdateKnowledgeBaseUpdateStatusResults contains results of the Repository.UpdateKnowledgeBaseUpdateStatus
type RepositoryMockUpdateKnowledgeBaseUpdateStatusResults struct {
	err error
}

// RepositoryMockUpdateKnowledgeBaseUpdateStatusOrigins contains origins of expectations of the Repository.UpdateKnowledgeBaseUpdateStatus
type RepositoryMockUpdateKnowledgeBaseUpdateStatusExpectationOrigins struct {
	origin                  string
	originCtx               string
	originKbUID             string
	originStatus            string
	originWorkflowID        string
	originErrorMessage      string
	originPreviousSystemUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateKnowledgeBaseUpdateStatus *mRepositoryMockUpdateKnowledgeBaseUpdateStatus) Optional() *mRepositoryMockUpdateKnowledgeBaseUpdateStatus {
	mmUpdateKnowledgeBaseUpdateStatus.optional = true
	return mmUpdateKnowledgeBaseUpdateStatus
}

// Expect sets up expected params for Repository.UpdateKnowledgeBaseUpdateStatus
func (mmUpdateKnowledgeBaseUpdateStatus *mRepositoryMockUpdateKnowledgeBaseUpdateStatus) Expect(ctx context.Context, kbUID types.KBUIDType, status string, workflowID string, errorMessage string, previousSystemUID types.SystemUIDType) *mRepositoryMockUpdateKnowledgeBaseUpdateStatus {
	if mmUpdateKnowledgeBaseUpdateStatus.mock.funcUpdateKnowledgeBaseUpdateStatus != nil {
		mmUpdateKnowledgeBaseUpdateStatus.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseUpdateStatus mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation == nil {
		mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseUpdateStatusExpectation{}
	}

	if mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.paramPtrs != nil {
		mmUpdateKnowledgeBaseUpdateStatus.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseUpdateStatus mock is already set by ExpectParams functions")
	}

	mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.params = &RepositoryMockUpdateKnowledgeBaseUpdateStatusParams{ctx, kbUID, status, workflowID, errorMessage, previousSystemUID}
	mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateKnowledgeBaseUpdateStatus.expectations {
		if minimock.Equal(e.params, mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.params) {
			mmUpdateKnowledgeBaseUpdateStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.params)
		}
	}

	return mmUpdateKnowledgeBaseUpdateStatus
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateKnowledgeBaseUpdateStatus
func (mmUpdateKnowledgeBaseUpdateStatus *mRepositoryMockUpdateKnowledgeBaseUpdateStatus) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateKnowledgeBaseUpdateStatus {
	if mmUpdateKnowledgeBaseUpdateStatus.mock.funcUpdateKnowledgeBaseUpdateStatus != nil {
		mmUpdateKnowledgeBaseUpdateStatus.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseUpdateStatus mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation == nil {
		mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseUpdateStatusExpectation{}
	}

	if mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseUpdateStatus.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseUpdateStatus mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseUpdateStatusParamPtrs{}
	}
	mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseUpdateStatus
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.UpdateKnowledgeBaseUpdateStatus
func (mmUpdateKnowledgeBaseUpdateStatus *mRepositoryMockUpdateKnowledgeBaseUpdateStatus) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockUpdateKnowledgeBaseUpdateStatus {
	if mmUpdateKnowledgeBaseUpdateStatus.mock.funcUpdateKnowledgeBaseUpdateStatus != nil {
		mmUpdateKnowledgeBaseUpdateStatus.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseUpdateStatus mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation == nil {
		mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseUpdateStatusExpectation{}
	}

	if mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseUpdateStatus.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseUpdateStatus mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseUpdateStatusParamPtrs{}
	}
	mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseUpdateStatus
}

// ExpectStatusParam3 sets up expected param status for Repository.UpdateKnowledgeBaseUpdateStatus
func (mmUpdateKnowledgeBaseUpdateStatus *mRepositoryMockUpdateKnowledgeBaseUpdateStatus) ExpectStatusParam3(status string) *mRepositoryMockUpdateKnowledgeBaseUpdateStatus {
	if mmUpdateKnowledgeBaseUpdateStatus.mock.funcUpdateKnowledgeBaseUpdateStatus != nil {
		mmUpdateKnowledgeBaseUpdateStatus.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseUpdateStatus mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation == nil {
		mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseUpdateStatusExpectation{}
	}

	if mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseUpdateStatus.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseUpdateStatus mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseUpdateStatusParamPtrs{}
	}
	mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.paramPtrs.status = &status
	mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.expectationOrigins.originStatus = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseUpdateStatus
}

// ExpectWorkflowIDParam4 sets up expected param workflowID for Repository.UpdateKnowledgeBaseUpdateStatus
func (mmUpdateKnowledgeBaseUpdateStatus *mRepositoryMockUpdateKnowledgeBaseUpdateStatus) ExpectWorkflowIDParam4(workflowID string) *mRepositoryMockUpdateKnowledgeBaseUpdateStatus {
	if mmUpdateKnowledgeBaseUpdateStatus.mock.funcUpdateKnowledgeBaseUpdateStatus != nil {
		mmUpdateKnowledgeBaseUpdateStatus.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseUpdateStatus mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation == nil {
		mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseUpdateStatusExpectation{}
	}

	if mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseUpdateStatus.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseUpdateStatus mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseUpdateStatusParamPtrs{}
	}
	mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.paramPtrs.workflowID = &workflowID
	mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.expectationOrigins.originWorkflowID = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseUpdateStatus
}

// ExpectErrorMessageParam5 sets up expected param errorMessage for Repository.UpdateKnowledgeBaseUpdateStatus
func (mmUpdateKnowledgeBaseUpdateStatus *mRepositoryMockUpdateKnowledgeBaseUpdateStatus) ExpectErrorMessageParam5(errorMessage string) *mRepositoryMockUpdateKnowledgeBaseUpdateStatus {
	if mmUpdateKnowledgeBaseUpdateStatus.mock.funcUpdateKnowledgeBaseUpdateStatus != nil {
		mmUpdateKnowledgeBaseUpdateStatus.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseUpdateStatus mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation == nil {
		mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseUpdateStatusExpectation{}
	}

	if mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseUpdateStatus.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseUpdateStatus mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseUpdateStatusParamPtrs{}
	}
	mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.paramPtrs.errorMessage = &errorMessage
	mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.expectationOrigins.originErrorMessage = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseUpdateStatus
}

// ExpectPreviousSystemUIDParam6 sets up expected param previousSystemUID for Repository.UpdateKnowledgeBaseUpdateStatus
func (mmUpdateKnowledgeBaseUpdateStatus *mRepositoryMockUpdateKnowledgeBaseUpdateStatus) ExpectPreviousSystemUIDParam6(previousSystemUID types.SystemUIDType) *mRepositoryMockUpdateKnowledgeBaseUpdateStatus {
	if mmUpdateKnowledgeBaseUpdateStatus.mock.funcUpdateKnowledgeBaseUpdateStatus != nil {
		mmUpdateKnowledgeBaseUpdateStatus.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseUpdateStatus mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation == nil {
		mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseUpdateStatusExpectation{}
	}

	if mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseUpdateStatus.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseUpdateStatus mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseUpdateStatusParamPtrs{}
	}
	mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.paramPtrs.previousSystemUID = &previousSystemUID
	mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.expectationOrigins.originPreviousSystemUID = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseUpdateStatus
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateKnowledgeBaseUpdateStatus
func (mmUpdateKnowledgeBaseUpdateStatus *mRepositoryMockUpdateKnowledgeBaseUpdateStatus) Inspect(f func(ctx context.Context, kbUID types.KBUIDType, status string, workflowID string, errorMessage string, previousSystemUID types.SystemUIDType)) *mRepositoryMockUpdateKnowledgeBaseUpdateStatus {
	if mmUpdateKnowledgeBaseUpdateStatus.mock.inspectFuncUpdateKnowledgeBaseUpdateStatus != nil {
		mmUpdateKnowledgeBaseUpdateStatus.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateKnowledgeBaseUpdateStatus")
	}

	mmUpdateKnowledgeBaseUpdateStatus.mock.inspectFuncUpdateKnowledgeBaseUpdateStatus = f

	return mmUpdateKnowledgeBaseUpdateStatus
}

// Return sets up results that will be returned by Repository.UpdateKnowledgeBaseUpdateStatus
func (mmUpdateKnowledgeBaseUpdateStatus *mRepositoryMockUpdateKnowledgeBaseUpdateStatus) Return(err error) *RepositoryMock {
	if mmUpdateKnowledgeBaseUpdateStatus.mock.funcUpdateKnowledgeBaseUpdateStatus != nil {
		mmUpdateKnowledgeBaseUpdateStatus.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseUpdateStatus mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation == nil {
		mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseUpdateStatusExpectation{mock: mmUpdateKnowledgeBaseUpdateStatus.mock}
	}
	mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.results = &RepositoryMockUpdateKnowledgeBaseUpdateStatusResults{err}
	mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBaseUpdateStatus.mock
}

// Set uses given function f to mock the Repository.UpdateKnowledgeBaseUpdateStatus method
func (mmUpdateKnowledgeBaseUpdateStatus *mRepositoryMockUpdateKnowledgeBaseUpdateStatus) Set(f func(ctx context.Context, kbUID types.KBUIDType, status string, workflowID string, errorMessage string, previousSystemUID types.SystemUIDType) (err error)) *RepositoryMock {
	if mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation != nil {
		mmUpdateKnowledgeBaseUpdateStatus.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateKnowledgeBaseUpdateStatus method")
	}

	if len(mmUpdateKnowledgeBaseUpdateStatus.expectations) > 0 {
		mmUpdateKnowledgeBaseUpdateStatus.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateKnowledgeBaseUpdateStatus method")
	}

	mmUpdateKnowledgeBaseUpdateStatus.mock.funcUpdateKnowledgeBaseUpdateStatus = f
	mmUpdateKnowledgeBaseUpdateStatus.mock.funcUpdateKnowledgeBaseUpdateStatusOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBaseUpdateStatus.mock
}

// When sets expectation for the Repository.UpdateKnowledgeBaseUpdateStatus which will trigger the result defined by the following
// Then helper
func (mmUpdateKnowledgeBaseUpdateStatus *mRepositoryMockUpdateKnowledgeBaseUpdateStatus) When(ctx context.Context, kbUID types.KBUIDType, status string, workflowID string, errorMessage string, previousSystemUID types.SystemUIDType) *RepositoryMockUpdateKnowledgeBaseUpdateStatusExpectation {
	if mmUpdateKnowledgeBaseUpdateStatus.mock.funcUpdateKnowledgeBaseUpdateStatus != nil {
		mmUpdateKnowledgeBaseUpdateStatus.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseUpdateStatus mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateKnowledgeBaseUpdateStatusExpectation{
		mock:               mmUpdateKnowledgeBaseUpdateStatus.mock,
		params:             &RepositoryMockUpdateKnowledgeBaseUpdateStatusParams{ctx, kbUID, status, workflowID, errorMessage, previousSystemUID},
		expectationOrigins: RepositoryMockUpdateKnowledgeBaseUpdateStatusExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateKnowledgeBaseUpdateStatus.expectations = append(mmUpdateKnowledgeBaseUpdateStatus.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateKnowledgeBaseUpdateStatus return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateKnowledgeBaseUpdateStatusExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateKnowledgeBaseUpdateStatusResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateKnowledgeBaseUpdateStatus should be invoked
func (mmUpdateKnowledgeBaseUpdateStatus *mRepositoryMockUpdateKnowledgeBaseUpdateStatus) Times(n uint64) *mRepositoryMockUpdateKnowledgeBaseUpdateStatus {
	if n == 0 {
		mmUpdateKnowledgeBaseUpdateStatus.mock.t.Fatalf("Times of RepositoryMock.UpdateKnowledgeBaseUpdateStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateKnowledgeBaseUpdateStatus.expectedInvocations, n)
	mmUpdateKnowledgeBaseUpdateStatus.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBaseUpdateStatus
}

func (mmUpdateKnowledgeBaseUpdateStatus *mRepositoryMockUpdateKnowledgeBaseUpdateStatus) invocationsDone() bool {
	if len(mmUpdateKnowledgeBaseUpdateStatus.expectations) == 0 && mmUpdateKnowledgeBaseUpdateStatus.defaultExpectation == nil && mmUpdateKnowledgeBaseUpdateStatus.mock.funcUpdateKnowledgeBaseUpdateStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseUpdateStatus.mock.afterUpdateKnowledgeBaseUpdateStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseUpdateStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateKnowledgeBaseUpdateStatus implements mm_repository.Repository
func (mmUpdateKnowledgeBaseUpdateStatus *RepositoryMock) UpdateKnowledgeBaseUpdateStatus(ctx context.Context, kbUID types.KBUIDType, status string, workflowID string, errorMessage string, previousSystemUID types.SystemUIDType) (err error) {
	mm_atomic.AddUint64(&mmUpdateKnowledgeBaseUpdateStatus.beforeUpdateKnowledgeBaseUpdateStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateKnowledgeBaseUpdateStatus.afterUpdateKnowledgeBaseUpdateStatusCounter, 1)

	mmUpdateKnowledgeBaseUpdateStatus.t.Helper()

	if mmUpdateKnowledgeBaseUpdateStatus.inspectFuncUpdateKnowledgeBaseUpdateStatus != nil {
		mmUpdateKnowledgeBaseUpdateStatus.inspectFuncUpdateKnowledgeBaseUpdateStatus(ctx, kbUID, status, workflowID, errorMessage, previousSystemUID)
	}

	mm_params := RepositoryMockUpdateKnowledgeBaseUpdateStatusParams{ctx, kbUID, status, workflowID, errorMessage, previousSystemUID}

	// Record call args
	mmUpdateKnowledgeBaseUpdateStatus.UpdateKnowledgeBaseUpdateStatusMock.mutex.Lock()
	mmUpdateKnowledgeBaseUpdateStatus.UpdateKnowledgeBaseUpdateStatusMock.callArgs = append(mmUpdateKnowledgeBaseUpdateStatus.UpdateKnowledgeBaseUpdateStatusMock.callArgs, &mm_params)
	mmUpdateKnowledgeBaseUpdateStatus.UpdateKnowledgeBaseUpdateStatusMock.mutex.Unlock()

	for _, e := range mmUpdateKnowledgeBaseUpdateStatus.UpdateKnowledgeBaseUpdateStatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateKnowledgeBaseUpdateStatus.UpdateKnowledgeBaseUpdateStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateKnowledgeBaseUpdateStatus.UpdateKnowledgeBaseUpdateStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateKnowledgeBaseUpdateStatus.UpdateKnowledgeBaseUpdateStatusMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateKnowledgeBaseUpdateStatus.UpdateKnowledgeBaseUpdateStatusMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateKnowledgeBaseUpdateStatusParams{ctx, kbUID, status, workflowID, errorMessage, previousSystemUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateKnowledgeBaseUpdateStatus.t.Errorf("RepositoryMock.UpdateKnowledgeBaseUpdateStatus got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseUpdateStatus.UpdateKnowledgeBaseUpdateStatusMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmUpdateKnowledgeBaseUpdateStatus.t.Errorf("RepositoryMock.UpdateKnowledgeBaseUpdateStatus got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseUpdateStatus.UpdateKnowledgeBaseUpdateStatusMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.status != nil && !minimock.Equal(*mm_want_ptrs.status, mm_got.status) {
				mmUpdateKnowledgeBaseUpdateStatus.t.Errorf("RepositoryMock.UpdateKnowledgeBaseUpdateStatus got unexpected parameter status, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseUpdateStatus.UpdateKnowledgeBaseUpdateStatusMock.defaultExpectation.expectationOrigins.originStatus, *mm_want_ptrs.status, mm_got.status, minimock.Diff(*mm_want_ptrs.status, mm_got.status))
			}

			if mm_want_ptrs.workflowID != nil && !minimock.Equal(*mm_want_ptrs.workflowID, mm_got.workflowID) {
				mmUpdateKnowledgeBaseUpdateStatus.t.Errorf("RepositoryMock.UpdateKnowledgeBaseUpdateStatus got unexpected parameter workflowID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseUpdateStatus.UpdateKnowledgeBaseUpdateStatusMock.defaultExpectation.expectationOrigins.originWorkflowID, *mm_want_ptrs.workflowID, mm_got.workflowID, minimock.Diff(*mm_want_ptrs.workflowID, mm_got.workflowID))
			}

			if mm_want_ptrs.errorMessage != nil && !minimock.Equal(*mm_want_ptrs.errorMessage, mm_got.errorMessage) {
				mmUpdateKnowledgeBaseUpdateStatus.t.Errorf("RepositoryMock.UpdateKnowledgeBaseUpdateStatus got unexpected parameter errorMessage, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseUpdateStatus.UpdateKnowledgeBaseUpdateStatusMock.defaultExpectation.expectationOrigins.originErrorMessage, *mm_want_ptrs.errorMessage, mm_got.errorMessage, minimock.Diff(*mm_want_ptrs.errorMessage, mm_got.errorMessage))
			}

			if mm_want_ptrs.previousSystemUID != nil && !minimock.Equal(*mm_want_ptrs.previousSystemUID, mm_got.previousSystemUID) {
				mmUpdateKnowledgeBaseUpdateStatus.t.Errorf("RepositoryMock.UpdateKnowledgeBaseUpdateStatus got unexpected parameter previousSystemUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseUpdateStatus.UpdateKnowledgeBaseUpdateStatusMock.defaultExpectation.expectationOrigins.originPreviousSystemUID, *mm_want_ptrs.previousSystemUID, mm_got.previousSystemUID, minimock.Diff(*mm_want_ptrs.previousSystemUID, mm_got.previousSystemUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateKnowledgeBaseUpdateStatus.t.Errorf("RepositoryMock.UpdateKnowledgeBaseUpdateStatus got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateKnowledgeBaseUpdateStatus.UpdateKnowledgeBaseUpdateStatusMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateKnowledgeBaseUpdateStatus.UpdateKnowledgeBaseUpdateStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateKnowledgeBaseUpdateStatus.t.Fatal("No results are set for the RepositoryMock.UpdateKnowledgeBaseUpdateStatus")
		}
		return (*mm_results).err
	}
	if mmUpdateKnowledgeBaseUpdateStatus.funcUpdateKnowledgeBaseUpdateStatus != nil {
		return mmUpdateKnowledgeBaseUpdateStatus.funcUpdateKnowledgeBaseUpdateStatus(ctx, kbUID, status, workflowID, errorMessage, previousSystemUID)
	}
	mmUpdateKnowledgeBaseUpdateStatus.t.Fatalf("Unexpected call to RepositoryMock.UpdateKnowledgeBaseUpdateStatus. %v %v %v %v %v %v", ctx, kbUID, status, workflowID, errorMessage, previousSystemUID)
	return
}

// UpdateKnowledgeBaseUpdateStatusAfterCounter returns a count of finished RepositoryMock.UpdateKnowledgeBaseUpdateStatus invocations
func (mmUpdateKnowledgeBaseUpdateStatus *RepositoryMock) UpdateKnowledgeBaseUpdateStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseUpdateStatus.afterUpdateKnowledgeBaseUpdateStatusCounter)
}

// UpdateKnowledgeBaseUpdateStatusBeforeCounter returns a count of RepositoryMock.UpdateKnowledgeBaseUpdateStatus invocations
func (mmUpdateKnowledgeBaseUpdateStatus *RepositoryMock) UpdateKnowledgeBaseUpdateStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseUpdateStatus.beforeUpdateKnowledgeBaseUpdateStatusCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateKnowledgeBaseUpdateStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateKnowledgeBaseUpdateStatus *mRepositoryMockUpdateKnowledgeBaseUpdateStatus) Calls() []*RepositoryMockUpdateKnowledgeBaseUpdateStatusParams {
	mmUpdateKnowledgeBaseUpdateStatus.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateKnowledgeBaseUpdateStatusParams, len(mmUpdateKnowledgeBaseUpdateStatus.callArgs))
	copy(argCopy, mmUpdateKnowledgeBaseUpdateStatus.callArgs)

	mmUpdateKnowledgeBaseUpdateStatus.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateKnowledgeBaseUpdateStatusDone returns true if the count of the UpdateKnowledgeBaseUpdateStatus invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateKnowledgeBaseUpdateStatusDone() bool {
	if m.UpdateKnowledgeBaseUpdateStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateKnowledgeBaseUpdateStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateKnowledgeBaseUpdateStatusMock.invocationsDone()
}

// MinimockUpdateKnowledgeBaseUpdateStatusInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateKnowledgeBaseUpdateStatusInspect() {
	for _, e := range m.UpdateKnowledgeBaseUpdateStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseUpdateStatus at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateKnowledgeBaseUpdateStatusCounter := mm_atomic.LoadUint64(&m.afterUpdateKnowledgeBaseUpdateStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateKnowledgeBaseUpdateStatusMock.defaultExpectation != nil && afterUpdateKnowledgeBaseUpdateStatusCounter < 1 {
		if m.UpdateKnowledgeBaseUpdateStatusMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseUpdateStatus at\n%s", m.UpdateKnowledgeBaseUpdateStatusMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseUpdateStatus at\n%s with params: %#v", m.UpdateKnowledgeBaseUpdateStatusMock.defaultExpectation.expectationOrigins.origin, *m.UpdateKnowledgeBaseUpdateStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateKnowledgeBaseUpdateStatus != nil && afterUpdateKnowledgeBaseUpdateStatusCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseUpdateStatus at\n%s", m.funcUpdateKnowledgeBaseUpdateStatusOrigin)
	}

	if !m.UpdateKnowledgeBaseUpdateStatusMock.invocationsDone() && afterUpdateKnowledgeBaseUpdateStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateKnowledgeBaseUpdateStatus at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateKnowledgeBaseUpdateStatusMock.expectedInvocations), m.UpdateKnowledgeBaseUpdateStatusMock.expectedInvocationsOrigin, afterUpdateKnowledgeBaseUpdateStatusCounter)
	}
}

type mRepositoryMockUpdateKnowledgeBaseWithMap struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateKnowledgeBaseWithMapExpectation
	expectations       []*RepositoryMockUpdateKnowledgeBaseWithMapExpectation

	callArgs []*RepositoryMockUpdateKnowledgeBaseWithMapParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateKnowledgeBaseWithMapExpectation specifies expectation struct of the Repository.UpdateKnowledgeBaseWithMap
type RepositoryMockUpdateKnowledgeBaseWithMapExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateKnowledgeBaseWithMapParams
	paramPtrs          *RepositoryMockUpdateKnowledgeBaseWithMapParamPtrs
	expectationOrigins RepositoryMockUpdateKnowledgeBaseWithMapExpectationOrigins
	results            *RepositoryMockUpdateKnowledgeBaseWithMapResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateKnowledgeBaseWithMapParams contains parameters of the Repository.UpdateKnowledgeBaseWithMap
type RepositoryMockUpdateKnowledgeBaseWithMapParams struct {
	ctx     context.Context
	id      string
	owner   string
	updates map[string]any
}

// RepositoryMockUpdateKnowledgeBaseWithMapParamPtrs contains pointers to parameters of the Repository.UpdateKnowledgeBaseWithMap
type RepositoryMockUpdateKnowledgeBaseWithMapParamPtrs struct {
	ctx     *context.Context
	id      *string
	owner   *string
	updates *map[string]any
}

// RepositoryMockUpdateKnowledgeBaseWithMapResults contains results of the Repository.UpdateKnowledgeBaseWithMap
type RepositoryMockUpdateKnowledgeBaseWithMapResults struct {
	err error
}

// RepositoryMockUpdateKnowledgeBaseWithMapOrigins contains origins of expectations of the Repository.UpdateKnowledgeBaseWithMap
type RepositoryMockUpdateKnowledgeBaseWithMapExpectationOrigins struct {
	origin        string
	originCtx     string
	originId      string
	originOwner   string
	originUpdates string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateKnowledgeBaseWithMap *mRepositoryMockUpdateKnowledgeBaseWithMap) Optional() *mRepositoryMockUpdateKnowledgeBaseWithMap {
	mmUpdateKnowledgeBaseWithMap.optional = true
	return mmUpdateKnowledgeBaseWithMap
}

// Expect sets up expected params for Repository.UpdateKnowledgeBaseWithMap
func (mmUpdateKnowledgeBaseWithMap *mRepositoryMockUpdateKnowledgeBaseWithMap) Expect(ctx context.Context, id string, owner string, updates map[string]any) *mRepositoryMockUpdateKnowledgeBaseWithMap {
	if mmUpdateKnowledgeBaseWithMap.mock.funcUpdateKnowledgeBaseWithMap != nil {
		mmUpdateKnowledgeBaseWithMap.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseWithMap mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseWithMap.defaultExpectation == nil {
		mmUpdateKnowledgeBaseWithMap.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseWithMapExpectation{}
	}

	if mmUpdateKnowledgeBaseWithMap.defaultExpectation.paramPtrs != nil {
		mmUpdateKnowledgeBaseWithMap.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseWithMap mock is already set by ExpectParams functions")
	}

	mmUpdateKnowledgeBaseWithMap.defaultExpectation.params = &RepositoryMockUpdateKnowledgeBaseWithMapParams{ctx, id, owner, updates}
	mmUpdateKnowledgeBaseWithMap.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateKnowledgeBaseWithMap.expectations {
		if minimock.Equal(e.params, mmUpdateKnowledgeBaseWithMap.defaultExpectation.params) {
			mmUpdateKnowledgeBaseWithMap.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateKnowledgeBaseWithMap.defaultExpectation.params)
		}
	}

	return mmUpdateKnowledgeBaseWithMap
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateKnowledgeBaseWithMap
func (mmUpdateKnowledgeBaseWithMap *mRepositoryMockUpdateKnowledgeBaseWithMap) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateKnowledgeBaseWithMap {
	if mmUpdateKnowledgeBaseWithMap.mock.funcUpdateKnowledgeBaseWithMap != nil {
		mmUpdateKnowledgeBaseWithMap.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseWithMap mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseWithMap.defaultExpectation == nil {
		mmUpdateKnowledgeBaseWithMap.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseWithMapExpectation{}
	}

	if mmUpdateKnowledgeBaseWithMap.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseWithMap.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseWithMap mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseWithMap.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseWithMap.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseWithMapParamPtrs{}
	}
	mmUpdateKnowledgeBaseWithMap.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateKnowledgeBaseWithMap.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseWithMap
}

// ExpectIdParam2 sets up expected param id for Repository.UpdateKnowledgeBaseWithMap
func (mmUpdateKnowledgeBaseWithMap *mRepositoryMockUpdateKnowledgeBaseWithMap) ExpectIdParam2(id string) *mRepositoryMockUpdateKnowledgeBaseWithMap {
	if mmUpdateKnowledgeBaseWithMap.mock.funcUpdateKnowledgeBaseWithMap != nil {
		mmUpdateKnowledgeBaseWithMap.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseWithMap mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseWithMap.defaultExpectation == nil {
		mmUpdateKnowledgeBaseWithMap.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseWithMapExpectation{}
	}

	if mmUpdateKnowledgeBaseWithMap.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseWithMap.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseWithMap mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseWithMap.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseWithMap.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseWithMapParamPtrs{}
	}
	mmUpdateKnowledgeBaseWithMap.defaultExpectation.paramPtrs.id = &id
	mmUpdateKnowledgeBaseWithMap.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseWithMap
}

// ExpectOwnerParam3 sets up expected param owner for Repository.UpdateKnowledgeBaseWithMap
func (mmUpdateKnowledgeBaseWithMap *mRepositoryMockUpdateKnowledgeBaseWithMap) ExpectOwnerParam3(owner string) *mRepositoryMockUpdateKnowledgeBaseWithMap {
	if mmUpdateKnowledgeBaseWithMap.mock.funcUpdateKnowledgeBaseWithMap != nil {
		mmUpdateKnowledgeBaseWithMap.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseWithMap mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseWithMap.defaultExpectation == nil {
		mmUpdateKnowledgeBaseWithMap.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseWithMapExpectation{}
	}

	if mmUpdateKnowledgeBaseWithMap.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseWithMap.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseWithMap mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseWithMap.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseWithMap.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseWithMapParamPtrs{}
	}
	mmUpdateKnowledgeBaseWithMap.defaultExpectation.paramPtrs.owner = &owner
	mmUpdateKnowledgeBaseWithMap.defaultExpectation.expectationOrigins.originOwner = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseWithMap
}

// ExpectUpdatesParam4 sets up expected param updates for Repository.UpdateKnowledgeBaseWithMap
func (mmUpdateKnowledgeBaseWithMap *mRepositoryMockUpdateKnowledgeBaseWithMap) ExpectUpdatesParam4(updates map[string]any) *mRepositoryMockUpdateKnowledgeBaseWithMap {
	if mmUpdateKnowledgeBaseWithMap.mock.funcUpdateKnowledgeBaseWithMap != nil {
		mmUpdateKnowledgeBaseWithMap.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseWithMap mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseWithMap.defaultExpectation == nil {
		mmUpdateKnowledgeBaseWithMap.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseWithMapExpectation{}
	}

	if mmUpdateKnowledgeBaseWithMap.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseWithMap.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseWithMap mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseWithMap.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseWithMap.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseWithMapParamPtrs{}
	}
	mmUpdateKnowledgeBaseWithMap.defaultExpectation.paramPtrs.updates = &updates
	mmUpdateKnowledgeBaseWithMap.defaultExpectation.expectationOrigins.originUpdates = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseWithMap
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateKnowledgeBaseWithMap
func (mmUpdateKnowledgeBaseWithMap *mRepositoryMockUpdateKnowledgeBaseWithMap) Inspect(f func(ctx context.Context, id string, owner string, updates map[string]any)) *mRepositoryMockUpdateKnowledgeBaseWithMap {
	if mmUpdateKnowledgeBaseWithMap.mock.inspectFuncUpdateKnowledgeBaseWithMap != nil {
		mmUpdateKnowledgeBaseWithMap.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateKnowledgeBaseWithMap")
	}

	mmUpdateKnowledgeBaseWithMap.mock.inspectFuncUpdateKnowledgeBaseWithMap = f

	return mmUpdateKnowledgeBaseWithMap
}

// Return sets up results that will be returned by Repository.UpdateKnowledgeBaseWithMap
func (mmUpdateKnowledgeBaseWithMap *mRepositoryMockUpdateKnowledgeBaseWithMap) Return(err error) *RepositoryMock {
	if mmUpdateKnowledgeBaseWithMap.mock.funcUpdateKnowledgeBaseWithMap != nil {
		mmUpdateKnowledgeBaseWithMap.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseWithMap mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseWithMap.defaultExpectation == nil {
		mmUpdateKnowledgeBaseWithMap.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseWithMapExpectation{mock: mmUpdateKnowledgeBaseWithMap.mock}
	}
	mmUpdateKnowledgeBaseWithMap.defaultExpectation.results = &RepositoryMockUpdateKnowledgeBaseWithMapResults{err}
	mmUpdateKnowledgeBaseWithMap.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBaseWithMap.mock
}

// Set uses given function f to mock the Repository.UpdateKnowledgeBaseWithMap method
func (mmUpdateKnowledgeBaseWithMap *mRepositoryMockUpdateKnowledgeBaseWithMap) Set(f func(ctx context.Context, id string, owner string, updates map[string]any) (err error)) *RepositoryMock {
	if mmUpdateKnowledgeBaseWithMap.defaultExpectation != nil {
		mmUpdateKnowledgeBaseWithMap.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateKnowledgeBaseWithMap method")
	}

	if len(mmUpdateKnowledgeBaseWithMap.expectations) > 0 {
		mmUpdateKnowledgeBaseWithMap.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateKnowledgeBaseWithMap method")
	}

	mmUpdateKnowledgeBaseWithMap.mock.funcUpdateKnowledgeBaseWithMap = f
	mmUpdateKnowledgeBaseWithMap.mock.funcUpdateKnowledgeBaseWithMapOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBaseWithMap.mock
}

// When sets expectation for the Repository.UpdateKnowledgeBaseWithMap which will trigger the result defined by the following
// Then helper
func (mmUpdateKnowledgeBaseWithMap *mRepositoryMockUpdateKnowledgeBaseWithMap) When(ctx context.Context, id string, owner string, updates map[string]any) *RepositoryMockUpdateKnowledgeBaseWithMapExpectation {
	if mmUpdateKnowledgeBaseWithMap.mock.funcUpdateKnowledgeBaseWithMap != nil {
		mmUpdateKnowledgeBaseWithMap.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseWithMap mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateKnowledgeBaseWithMapExpectation{
		mock:               mmUpdateKnowledgeBaseWithMap.mock,
		params:             &RepositoryMockUpdateKnowledgeBaseWithMapParams{ctx, id, owner, updates},
		expectationOrigins: RepositoryMockUpdateKnowledgeBaseWithMapExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateKnowledgeBaseWithMap.expectations = append(mmUpdateKnowledgeBaseWithMap.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateKnowledgeBaseWithMap return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateKnowledgeBaseWithMapExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateKnowledgeBaseWithMapResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateKnowledgeBaseWithMap should be invoked
func (mmUpdateKnowledgeBaseWithMap *mRepositoryMockUpdateKnowledgeBaseWithMap) Times(n uint64) *mRepositoryMockUpdateKnowledgeBaseWithMap {
	if n == 0 {
		mmUpdateKnowledgeBaseWithMap.mock.t.Fatalf("Times of RepositoryMock.UpdateKnowledgeBaseWithMap mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateKnowledgeBaseWithMap.expectedInvocations, n)
	mmUpdateKnowledgeBaseWithMap.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBaseWithMap
}

func (mmUpdateKnowledgeBaseWithMap *mRepositoryMockUpdateKnowledgeBaseWithMap) invocationsDone() bool {
	if len(mmUpdateKnowledgeBaseWithMap.expectations) == 0 && mmUpdateKnowledgeBaseWithMap.defaultExpectation == nil && mmUpdateKnowledgeBaseWithMap.mock.funcUpdateKnowledgeBaseWithMap == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseWithMap.mock.afterUpdateKnowledgeBaseWithMapCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseWithMap.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateKnowledgeBaseWithMap implements mm_repository.Repository
func (mmUpdateKnowledgeBaseWithMap *RepositoryMock) UpdateKnowledgeBaseWithMap(ctx context.Context, id string, owner string, updates map[string]any) (err error) {
	mm_atomic.AddUint64(&mmUpdateKnowledgeBaseWithMap.beforeUpdateKnowledgeBaseWithMapCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateKnowledgeBaseWithMap.afterUpdateKnowledgeBaseWithMapCounter, 1)

	mmUpdateKnowledgeBaseWithMap.t.Helper()

	if mmUpdateKnowledgeBaseWithMap.inspectFuncUpdateKnowledgeBaseWithMap != nil {
		mmUpdateKnowledgeBaseWithMap.inspectFuncUpdateKnowledgeBaseWithMap(ctx, id, owner, updates)
	}

	mm_params := RepositoryMockUpdateKnowledgeBaseWithMapParams{ctx, id, owner, updates}

	// Record call args
	mmUpdateKnowledgeBaseWithMap.UpdateKnowledgeBaseWithMapMock.mutex.Lock()
	mmUpdateKnowledgeBaseWithMap.UpdateKnowledgeBaseWithMapMock.callArgs = append(mmUpdateKnowledgeBaseWithMap.UpdateKnowledgeBaseWithMapMock.callArgs, &mm_params)
	mmUpdateKnowledgeBaseWithMap.UpdateKnowledgeBaseWithMapMock.mutex.Unlock()

	for _, e := range mmUpdateKnowledgeBaseWithMap.UpdateKnowledgeBaseWithMapMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateKnowledgeBaseWithMap.UpdateKnowledgeBaseWithMapMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateKnowledgeBaseWithMap.UpdateKnowledgeBaseWithMapMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateKnowledgeBaseWithMap.UpdateKnowledgeBaseWithMapMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateKnowledgeBaseWithMap.UpdateKnowledgeBaseWithMapMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateKnowledgeBaseWithMapParams{ctx, id, owner, updates}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateKnowledgeBaseWithMap.t.Errorf("RepositoryMock.UpdateKnowledgeBaseWithMap got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseWithMap.UpdateKnowledgeBaseWithMapMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateKnowledgeBaseWithMap.t.Errorf("RepositoryMock.UpdateKnowledgeBaseWithMap got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseWithMap.UpdateKnowledgeBaseWithMapMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.owner != nil && !minimock.Equal(*mm_want_ptrs.owner, mm_got.owner) {
				mmUpdateKnowledgeBaseWithMap.t.Errorf("RepositoryMock.UpdateKnowledgeBaseWithMap got unexpected parameter owner, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseWithMap.UpdateKnowledgeBaseWithMapMock.defaultExpectation.expectationOrigins.originOwner, *mm_want_ptrs.owner, mm_got.owner, minimock.Diff(*mm_want_ptrs.owner, mm_got.owner))
			}

			if mm_want_ptrs.updates != nil && !minimock.Equal(*mm_want_ptrs.updates, mm_got.updates) {
				mmUpdateKnowledgeBaseWithMap.t.Errorf("RepositoryMock.UpdateKnowledgeBaseWithMap got unexpected parameter updates, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseWithMap.UpdateKnowledgeBaseWithMapMock.defaultExpectation.expectationOrigins.originUpdates, *mm_want_ptrs.updates, mm_got.updates, minimock.Diff(*mm_want_ptrs.updates, mm_got.updates))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateKnowledgeBaseWithMap.t.Errorf("RepositoryMock.UpdateKnowledgeBaseWithMap got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateKnowledgeBaseWithMap.UpdateKnowledgeBaseWithMapMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateKnowledgeBaseWithMap.UpdateKnowledgeBaseWithMapMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateKnowledgeBaseWithMap.t.Fatal("No results are set for the RepositoryMock.UpdateKnowledgeBaseWithMap")
		}
		return (*mm_results).err
	}
	if mmUpdateKnowledgeBaseWithMap.funcUpdateKnowledgeBaseWithMap != nil {
		return mmUpdateKnowledgeBaseWithMap.funcUpdateKnowledgeBaseWithMap(ctx, id, owner, updates)
	}
	mmUpdateKnowledgeBaseWithMap.t.Fatalf("Unexpected call to RepositoryMock.UpdateKnowledgeBaseWithMap. %v %v %v %v", ctx, id, owner, updates)
	return
}

// UpdateKnowledgeBaseWithMapAfterCounter returns a count of finished RepositoryMock.UpdateKnowledgeBaseWithMap invocations
func (mmUpdateKnowledgeBaseWithMap *RepositoryMock) UpdateKnowledgeBaseWithMapAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseWithMap.afterUpdateKnowledgeBaseWithMapCounter)
}

// UpdateKnowledgeBaseWithMapBeforeCounter returns a count of RepositoryMock.UpdateKnowledgeBaseWithMap invocations
func (mmUpdateKnowledgeBaseWithMap *RepositoryMock) UpdateKnowledgeBaseWithMapBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseWithMap.beforeUpdateKnowledgeBaseWithMapCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateKnowledgeBaseWithMap.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateKnowledgeBaseWithMap *mRepositoryMockUpdateKnowledgeBaseWithMap) Calls() []*RepositoryMockUpdateKnowledgeBaseWithMapParams {
	mmUpdateKnowledgeBaseWithMap.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateKnowledgeBaseWithMapParams, len(mmUpdateKnowledgeBaseWithMap.callArgs))
	copy(argCopy, mmUpdateKnowledgeBaseWithMap.callArgs)

	mmUpdateKnowledgeBaseWithMap.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateKnowledgeBaseWithMapDone returns true if the count of the UpdateKnowledgeBaseWithMap invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateKnowledgeBaseWithMapDone() bool {
	if m.UpdateKnowledgeBaseWithMapMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateKnowledgeBaseWithMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateKnowledgeBaseWithMapMock.invocationsDone()
}

// MinimockUpdateKnowledgeBaseWithMapInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateKnowledgeBaseWithMapInspect() {
	for _, e := range m.UpdateKnowledgeBaseWithMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseWithMap at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateKnowledgeBaseWithMapCounter := mm_atomic.LoadUint64(&m.afterUpdateKnowledgeBaseWithMapCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateKnowledgeBaseWithMapMock.defaultExpectation != nil && afterUpdateKnowledgeBaseWithMapCounter < 1 {
		if m.UpdateKnowledgeBaseWithMapMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseWithMap at\n%s", m.UpdateKnowledgeBaseWithMapMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseWithMap at\n%s with params: %#v", m.UpdateKnowledgeBaseWithMapMock.defaultExpectation.expectationOrigins.origin, *m.UpdateKnowledgeBaseWithMapMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateKnowledgeBaseWithMap != nil && afterUpdateKnowledgeBaseWithMapCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseWithMap at\n%s", m.funcUpdateKnowledgeBaseWithMapOrigin)
	}

	if !m.UpdateKnowledgeBaseWithMapMock.invocationsDone() && afterUpdateKnowledgeBaseWithMapCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateKnowledgeBaseWithMap at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateKnowledgeBaseWithMapMock.expectedInvocations), m.UpdateKnowledgeBaseWithMapMock.expectedInvocationsOrigin, afterUpdateKnowledgeBaseWithMapCounter)
	}
}

type mRepositoryMockUpdateKnowledgeBaseWithMapTx struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateKnowledgeBaseWithMapTxExpectation
	expectations       []*RepositoryMockUpdateKnowledgeBaseWithMapTxExpectation

	callArgs []*RepositoryMockUpdateKnowledgeBaseWithMapTxParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateKnowledgeBaseWithMapTxExpectation specifies expectation struct of the Repository.UpdateKnowledgeBaseWithMapTx
type RepositoryMockUpdateKnowledgeBaseWithMapTxExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateKnowledgeBaseWithMapTxParams
	paramPtrs          *RepositoryMockUpdateKnowledgeBaseWithMapTxParamPtrs
	expectationOrigins RepositoryMockUpdateKnowledgeBaseWithMapTxExpectationOrigins
	results            *RepositoryMockUpdateKnowledgeBaseWithMapTxResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateKnowledgeBaseWithMapTxParams contains parameters of the Repository.UpdateKnowledgeBaseWithMapTx
type RepositoryMockUpdateKnowledgeBaseWithMapTxParams struct {
	ctx     context.Context
	tx      *gorm.DB
	id      string
	owner   string
	updates map[string]any
}

// RepositoryMockUpdateKnowledgeBaseWithMapTxParamPtrs contains pointers to parameters of the Repository.UpdateKnowledgeBaseWithMapTx
type RepositoryMockUpdateKnowledgeBaseWithMapTxParamPtrs struct {
	ctx     *context.Context
	tx      **gorm.DB
	id      *string
	owner   *string
	updates *map[string]any
}

// RepositoryMockUpdateKnowledgeBaseWithMapTxResults contains results of the Repository.UpdateKnowledgeBaseWithMapTx
type RepositoryMockUpdateKnowledgeBaseWithMapTxResults struct {
	err error
}

// RepositoryMockUpdateKnowledgeBaseWithMapTxOrigins contains origins of expectations of the Repository.UpdateKnowledgeBaseWithMapTx
type RepositoryMockUpdateKnowledgeBaseWithMapTxExpectationOrigins struct {
	origin        string
	originCtx     string
	originTx      string
	originId      string
	originOwner   string
	originUpdates string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateKnowledgeBaseWithMapTx *mRepositoryMockUpdateKnowledgeBaseWithMapTx) Optional() *mRepositoryMockUpdateKnowledgeBaseWithMapTx {
	mmUpdateKnowledgeBaseWithMapTx.optional = true
	return mmUpdateKnowledgeBaseWithMapTx
}

// Expect sets up expected params for Repository.UpdateKnowledgeBaseWithMapTx
func (mmUpdateKnowledgeBaseWithMapTx *mRepositoryMockUpdateKnowledgeBaseWithMapTx) Expect(ctx context.Context, tx *gorm.DB, id string, owner string, updates map[string]any) *mRepositoryMockUpdateKnowledgeBaseWithMapTx {
	if mmUpdateKnowledgeBaseWithMapTx.mock.funcUpdateKnowledgeBaseWithMapTx != nil {
		mmUpdateKnowledgeBaseWithMapTx.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseWithMapTx mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseWithMapTx.defaultExpectation == nil {
		mmUpdateKnowledgeBaseWithMapTx.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseWithMapTxExpectation{}
	}

	if mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.paramPtrs != nil {
		mmUpdateKnowledgeBaseWithMapTx.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseWithMapTx mock is already set by ExpectParams functions")
	}

	mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.params = &RepositoryMockUpdateKnowledgeBaseWithMapTxParams{ctx, tx, id, owner, updates}
	mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateKnowledgeBaseWithMapTx.expectations {
		if minimock.Equal(e.params, mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.params) {
			mmUpdateKnowledgeBaseWithMapTx.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.params)
		}
	}

	return mmUpdateKnowledgeBaseWithMapTx
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateKnowledgeBaseWithMapTx
func (mmUpdateKnowledgeBaseWithMapTx *mRepositoryMockUpdateKnowledgeBaseWithMapTx) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateKnowledgeBaseWithMapTx {
	if mmUpdateKnowledgeBaseWithMapTx.mock.funcUpdateKnowledgeBaseWithMapTx != nil {
		mmUpdateKnowledgeBaseWithMapTx.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseWithMapTx mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseWithMapTx.defaultExpectation == nil {
		mmUpdateKnowledgeBaseWithMapTx.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseWithMapTxExpectation{}
	}

	if mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseWithMapTx.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseWithMapTx mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseWithMapTxParamPtrs{}
	}
	mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseWithMapTx
}

// ExpectTxParam2 sets up expected param tx for Repository.UpdateKnowledgeBaseWithMapTx
func (mmUpdateKnowledgeBaseWithMapTx *mRepositoryMockUpdateKnowledgeBaseWithMapTx) ExpectTxParam2(tx *gorm.DB) *mRepositoryMockUpdateKnowledgeBaseWithMapTx {
	if mmUpdateKnowledgeBaseWithMapTx.mock.funcUpdateKnowledgeBaseWithMapTx != nil {
		mmUpdateKnowledgeBaseWithMapTx.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseWithMapTx mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseWithMapTx.defaultExpectation == nil {
		mmUpdateKnowledgeBaseWithMapTx.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseWithMapTxExpectation{}
	}

	if mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseWithMapTx.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseWithMapTx mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseWithMapTxParamPtrs{}
	}
	mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.paramPtrs.tx = &tx
	mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.expectationOrigins.originTx = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseWithMapTx
}

// ExpectIdParam3 sets up expected param id for Repository.UpdateKnowledgeBaseWithMapTx
func (mmUpdateKnowledgeBaseWithMapTx *mRepositoryMockUpdateKnowledgeBaseWithMapTx) ExpectIdParam3(id string) *mRepositoryMockUpdateKnowledgeBaseWithMapTx {
	if mmUpdateKnowledgeBaseWithMapTx.mock.funcUpdateKnowledgeBaseWithMapTx != nil {
		mmUpdateKnowledgeBaseWithMapTx.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseWithMapTx mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseWithMapTx.defaultExpectation == nil {
		mmUpdateKnowledgeBaseWithMapTx.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseWithMapTxExpectation{}
	}

	if mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseWithMapTx.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseWithMapTx mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseWithMapTxParamPtrs{}
	}
	mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.paramPtrs.id = &id
	mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseWithMapTx
}

// ExpectOwnerParam4 sets up expected param owner for Repository.UpdateKnowledgeBaseWithMapTx
func (mmUpdateKnowledgeBaseWithMapTx *mRepositoryMockUpdateKnowledgeBaseWithMapTx) ExpectOwnerParam4(owner string) *mRepositoryMockUpdateKnowledgeBaseWithMapTx {
	if mmUpdateKnowledgeBaseWithMapTx.mock.funcUpdateKnowledgeBaseWithMapTx != nil {
		mmUpdateKnowledgeBaseWithMapTx.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseWithMapTx mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseWithMapTx.defaultExpectation == nil {
		mmUpdateKnowledgeBaseWithMapTx.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseWithMapTxExpectation{}
	}

	if mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseWithMapTx.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseWithMapTx mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseWithMapTxParamPtrs{}
	}
	mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.paramPtrs.owner = &owner
	mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.expectationOrigins.originOwner = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseWithMapTx
}

// ExpectUpdatesParam5 sets up expected param updates for Repository.UpdateKnowledgeBaseWithMapTx
func (mmUpdateKnowledgeBaseWithMapTx *mRepositoryMockUpdateKnowledgeBaseWithMapTx) ExpectUpdatesParam5(updates map[string]any) *mRepositoryMockUpdateKnowledgeBaseWithMapTx {
	if mmUpdateKnowledgeBaseWithMapTx.mock.funcUpdateKnowledgeBaseWithMapTx != nil {
		mmUpdateKnowledgeBaseWithMapTx.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseWithMapTx mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseWithMapTx.defaultExpectation == nil {
		mmUpdateKnowledgeBaseWithMapTx.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseWithMapTxExpectation{}
	}

	if mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseWithMapTx.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseWithMapTx mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseWithMapTxParamPtrs{}
	}
	mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.paramPtrs.updates = &updates
	mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.expectationOrigins.originUpdates = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseWithMapTx
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateKnowledgeBaseWithMapTx
func (mmUpdateKnowledgeBaseWithMapTx *mRepositoryMockUpdateKnowledgeBaseWithMapTx) Inspect(f func(ctx context.Context, tx *gorm.DB, id string, owner string, updates map[string]any)) *mRepositoryMockUpdateKnowledgeBaseWithMapTx {
	if mmUpdateKnowledgeBaseWithMapTx.mock.inspectFuncUpdateKnowledgeBaseWithMapTx != nil {
		mmUpdateKnowledgeBaseWithMapTx.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateKnowledgeBaseWithMapTx")
	}

	mmUpdateKnowledgeBaseWithMapTx.mock.inspectFuncUpdateKnowledgeBaseWithMapTx = f

	return mmUpdateKnowledgeBaseWithMapTx
}

// Return sets up results that will be returned by Repository.UpdateKnowledgeBaseWithMapTx
func (mmUpdateKnowledgeBaseWithMapTx *mRepositoryMockUpdateKnowledgeBaseWithMapTx) Return(err error) *RepositoryMock {
	if mmUpdateKnowledgeBaseWithMapTx.mock.funcUpdateKnowledgeBaseWithMapTx != nil {
		mmUpdateKnowledgeBaseWithMapTx.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseWithMapTx mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseWithMapTx.defaultExpectation == nil {
		mmUpdateKnowledgeBaseWithMapTx.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseWithMapTxExpectation{mock: mmUpdateKnowledgeBaseWithMapTx.mock}
	}
	mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.results = &RepositoryMockUpdateKnowledgeBaseWithMapTxResults{err}
	mmUpdateKnowledgeBaseWithMapTx.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBaseWithMapTx.mock
}

// Set uses given function f to mock the Repository.UpdateKnowledgeBaseWithMapTx method
func (mmUpdateKnowledgeBaseWithMapTx *mRepositoryMockUpdateKnowledgeBaseWithMapTx) Set(f func(ctx context.Context, tx *gorm.DB, id string, owner string, updates map[string]any) (err error)) *RepositoryMock {
	if mmUpdateKnowledgeBaseWithMapTx.defaultExpectation != nil {
		mmUpdateKnowledgeBaseWithMapTx.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateKnowledgeBaseWithMapTx method")
	}

	if len(mmUpdateKnowledgeBaseWithMapTx.expectations) > 0 {
		mmUpdateKnowledgeBaseWithMapTx.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateKnowledgeBaseWithMapTx method")
	}

	mmUpdateKnowledgeBaseWithMapTx.mock.funcUpdateKnowledgeBaseWithMapTx = f
	mmUpdateKnowledgeBaseWithMapTx.mock.funcUpdateKnowledgeBaseWithMapTxOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBaseWithMapTx.mock
}

// When sets expectation for the Repository.UpdateKnowledgeBaseWithMapTx which will trigger the result defined by the following
// Then helper
func (mmUpdateKnowledgeBaseWithMapTx *mRepositoryMockUpdateKnowledgeBaseWithMapTx) When(ctx context.Context, tx *gorm.DB, id string, owner string, updates map[string]any) *RepositoryMockUpdateKnowledgeBaseWithMapTxExpectation {
	if mmUpdateKnowledgeBaseWithMapTx.mock.funcUpdateKnowledgeBaseWithMapTx != nil {
		mmUpdateKnowledgeBaseWithMapTx.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseWithMapTx mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateKnowledgeBaseWithMapTxExpectation{
		mock:               mmUpdateKnowledgeBaseWithMapTx.mock,
		params:             &RepositoryMockUpdateKnowledgeBaseWithMapTxParams{ctx, tx, id, owner, updates},
		expectationOrigins: RepositoryMockUpdateKnowledgeBaseWithMapTxExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateKnowledgeBaseWithMapTx.expectations = append(mmUpdateKnowledgeBaseWithMapTx.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateKnowledgeBaseWithMapTx return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateKnowledgeBaseWithMapTxExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateKnowledgeBaseWithMapTxResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateKnowledgeBaseWithMapTx should be invoked
func (mmUpdateKnowledgeBaseWithMapTx *mRepositoryMockUpdateKnowledgeBaseWithMapTx) Times(n uint64) *mRepositoryMockUpdateKnowledgeBaseWithMapTx {
	if n == 0 {
		mmUpdateKnowledgeBaseWithMapTx.mock.t.Fatalf("Times of RepositoryMock.UpdateKnowledgeBaseWithMapTx mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateKnowledgeBaseWithMapTx.expectedInvocations, n)
	mmUpdateKnowledgeBaseWithMapTx.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBaseWithMapTx
}

func (mmUpdateKnowledgeBaseWithMapTx *mRepositoryMockUpdateKnowledgeBaseWithMapTx) invocationsDone() bool {
	if len(mmUpdateKnowledgeBaseWithMapTx.expectations) == 0 && mmUpdateKnowledgeBaseWithMapTx.defaultExpectation == nil && mmUpdateKnowledgeBaseWithMapTx.mock.funcUpdateKnowledgeBaseWithMapTx == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseWithMapTx.mock.afterUpdateKnowledgeBaseWithMapTxCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseWithMapTx.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateKnowledgeBaseWithMapTx implements mm_repository.Repository
func (mmUpdateKnowledgeBaseWithMapTx *RepositoryMock) UpdateKnowledgeBaseWithMapTx(ctx context.Context, tx *gorm.DB, id string, owner string, updates map[string]any) (err error) {
	mm_atomic.AddUint64(&mmUpdateKnowledgeBaseWithMapTx.beforeUpdateKnowledgeBaseWithMapTxCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateKnowledgeBaseWithMapTx.afterUpdateKnowledgeBaseWithMapTxCounter, 1)

	mmUpdateKnowledgeBaseWithMapTx.t.Helper()

	if mmUpdateKnowledgeBaseWithMapTx.inspectFuncUpdateKnowledgeBaseWithMapTx != nil {
		mmUpdateKnowledgeBaseWithMapTx.inspectFuncUpdateKnowledgeBaseWithMapTx(ctx, tx, id, owner, updates)
	}

	mm_params := RepositoryMockUpdateKnowledgeBaseWithMapTxParams{ctx, tx, id, owner, updates}

	// Record call args
	mmUpdateKnowledgeBaseWithMapTx.UpdateKnowledgeBaseWithMapTxMock.mutex.Lock()
	mmUpdateKnowledgeBaseWithMapTx.UpdateKnowledgeBaseWithMapTxMock.callArgs = append(mmUpdateKnowledgeBaseWithMapTx.UpdateKnowledgeBaseWithMapTxMock.callArgs, &mm_params)
	mmUpdateKnowledgeBaseWithMapTx.UpdateKnowledgeBaseWithMapTxMock.mutex.Unlock()

	for _, e := range mmUpdateKnowledgeBaseWithMapTx.UpdateKnowledgeBaseWithMapTxMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateKnowledgeBaseWithMapTx.UpdateKnowledgeBaseWithMapTxMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateKnowledgeBaseWithMapTx.UpdateKnowledgeBaseWithMapTxMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateKnowledgeBaseWithMapTx.UpdateKnowledgeBaseWithMapTxMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateKnowledgeBaseWithMapTx.UpdateKnowledgeBaseWithMapTxMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateKnowledgeBaseWithMapTxParams{ctx, tx, id, owner, updates}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateKnowledgeBaseWithMapTx.t.Errorf("RepositoryMock.UpdateKnowledgeBaseWithMapTx got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseWithMapTx.UpdateKnowledgeBaseWithMapTxMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tx != nil && !minimock.Equal(*mm_want_ptrs.tx, mm_got.tx) {
				mmUpdateKnowledgeBaseWithMapTx.t.Errorf("RepositoryMock.UpdateKnowledgeBaseWithMapTx got unexpected parameter tx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseWithMapTx.UpdateKnowledgeBaseWithMapTxMock.defaultExpectation.expectationOrigins.originTx, *mm_want_ptrs.tx, mm_got.tx, minimock.Diff(*mm_want_ptrs.tx, mm_got.tx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateKnowledgeBaseWithMapTx.t.Errorf("RepositoryMock.UpdateKnowledgeBaseWithMapTx got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseWithMapTx.UpdateKnowledgeBaseWithMapTxMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.owner != nil && !minimock.Equal(*mm_want_ptrs.owner, mm_got.owner) {
				mmUpdateKnowledgeBaseWithMapTx.t.Errorf("RepositoryMock.UpdateKnowledgeBaseWithMapTx got unexpected parameter owner, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseWithMapTx.UpdateKnowledgeBaseWithMapTxMock.defaultExpectation.expectationOrigins.originOwner, *mm_want_ptrs.owner, mm_got.owner, minimock.Diff(*mm_want_ptrs.owner, mm_got.owner))
			}

			if mm_want_ptrs.updates != nil && !minimock.Equal(*mm_want_ptrs.updates, mm_got.updates) {
				mmUpdateKnowledgeBaseWithMapTx.t.Errorf("RepositoryMock.UpdateKnowledgeBaseWithMapTx got unexpected parameter updates, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseWithMapTx.UpdateKnowledgeBaseWithMapTxMock.defaultExpectation.expectationOrigins.originUpdates, *mm_want_ptrs.updates, mm_got.updates, minimock.Diff(*mm_want_ptrs.updates, mm_got.updates))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateKnowledgeBaseWithMapTx.t.Errorf("RepositoryMock.UpdateKnowledgeBaseWithMapTx got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateKnowledgeBaseWithMapTx.UpdateKnowledgeBaseWithMapTxMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateKnowledgeBaseWithMapTx.UpdateKnowledgeBaseWithMapTxMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateKnowledgeBaseWithMapTx.t.Fatal("No results are set for the RepositoryMock.UpdateKnowledgeBaseWithMapTx")
		}
		return (*mm_results).err
	}
	if mmUpdateKnowledgeBaseWithMapTx.funcUpdateKnowledgeBaseWithMapTx != nil {
		return mmUpdateKnowledgeBaseWithMapTx.funcUpdateKnowledgeBaseWithMapTx(ctx, tx, id, owner, updates)
	}
	mmUpdateKnowledgeBaseWithMapTx.t.Fatalf("Unexpected call to RepositoryMock.UpdateKnowledgeBaseWithMapTx. %v %v %v %v %v", ctx, tx, id, owner, updates)
	return
}

// UpdateKnowledgeBaseWithMapTxAfterCounter returns a count of finished RepositoryMock.UpdateKnowledgeBaseWithMapTx invocations
func (mmUpdateKnowledgeBaseWithMapTx *RepositoryMock) UpdateKnowledgeBaseWithMapTxAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseWithMapTx.afterUpdateKnowledgeBaseWithMapTxCounter)
}

// UpdateKnowledgeBaseWithMapTxBeforeCounter returns a count of RepositoryMock.UpdateKnowledgeBaseWithMapTx invocations
func (mmUpdateKnowledgeBaseWithMapTx *RepositoryMock) UpdateKnowledgeBaseWithMapTxBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseWithMapTx.beforeUpdateKnowledgeBaseWithMapTxCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateKnowledgeBaseWithMapTx.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateKnowledgeBaseWithMapTx *mRepositoryMockUpdateKnowledgeBaseWithMapTx) Calls() []*RepositoryMockUpdateKnowledgeBaseWithMapTxParams {
	mmUpdateKnowledgeBaseWithMapTx.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateKnowledgeBaseWithMapTxParams, len(mmUpdateKnowledgeBaseWithMapTx.callArgs))
	copy(argCopy, mmUpdateKnowledgeBaseWithMapTx.callArgs)

	mmUpdateKnowledgeBaseWithMapTx.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateKnowledgeBaseWithMapTxDone returns true if the count of the UpdateKnowledgeBaseWithMapTx invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateKnowledgeBaseWithMapTxDone() bool {
	if m.UpdateKnowledgeBaseWithMapTxMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateKnowledgeBaseWithMapTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateKnowledgeBaseWithMapTxMock.invocationsDone()
}

// MinimockUpdateKnowledgeBaseWithMapTxInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateKnowledgeBaseWithMapTxInspect() {
	for _, e := range m.UpdateKnowledgeBaseWithMapTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseWithMapTx at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateKnowledgeBaseWithMapTxCounter := mm_atomic.LoadUint64(&m.afterUpdateKnowledgeBaseWithMapTxCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateKnowledgeBaseWithMapTxMock.defaultExpectation != nil && afterUpdateKnowledgeBaseWithMapTxCounter < 1 {
		if m.UpdateKnowledgeBaseWithMapTxMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseWithMapTx at\n%s", m.UpdateKnowledgeBaseWithMapTxMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseWithMapTx at\n%s with params: %#v", m.UpdateKnowledgeBaseWithMapTxMock.defaultExpectation.expectationOrigins.origin, *m.UpdateKnowledgeBaseWithMapTxMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateKnowledgeBaseWithMapTx != nil && afterUpdateKnowledgeBaseWithMapTxCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseWithMapTx at\n%s", m.funcUpdateKnowledgeBaseWithMapTxOrigin)
	}

	if !m.UpdateKnowledgeBaseWithMapTxMock.invocationsDone() && afterUpdateKnowledgeBaseWithMapTxCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateKnowledgeBaseWithMapTx at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateKnowledgeBaseWithMapTxMock.expectedInvocations), m.UpdateKnowledgeBaseWithMapTxMock.expectedInvocationsOrigin, afterUpdateKnowledgeBaseWithMapTxCounter)
	}
}

type mRepositoryMockUpdateKnowledgeFileMetadata struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateKnowledgeFileMetadataExpectation
	expectations       []*RepositoryMockUpdateKnowledgeFileMetadataExpectation

	callArgs []*RepositoryMockUpdateKnowledgeFileMetadataParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateKnowledgeFileMetadataExpectation specifies expectation struct of the Repository.UpdateKnowledgeFileMetadata
type RepositoryMockUpdateKnowledgeFileMetadataExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateKnowledgeFileMetadataParams
	paramPtrs          *RepositoryMockUpdateKnowledgeFileMetadataParamPtrs
	expectationOrigins RepositoryMockUpdateKnowledgeFileMetadataExpectationOrigins
	results            *RepositoryMockUpdateKnowledgeFileMetadataResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateKnowledgeFileMetadataParams contains parameters of the Repository.UpdateKnowledgeFileMetadata
type RepositoryMockUpdateKnowledgeFileMetadataParams struct {
	ctx     context.Context
	fileUID types.FileUIDType
	e1      mm_repository.ExtraMetaData
}

// RepositoryMockUpdateKnowledgeFileMetadataParamPtrs contains pointers to parameters of the Repository.UpdateKnowledgeFileMetadata
type RepositoryMockUpdateKnowledgeFileMetadataParamPtrs struct {
	ctx     *context.Context
	fileUID *types.FileUIDType
	e1      *mm_repository.ExtraMetaData
}

// RepositoryMockUpdateKnowledgeFileMetadataResults contains results of the Repository.UpdateKnowledgeFileMetadata
type RepositoryMockUpdateKnowledgeFileMetadataResults struct {
	err error
}

// RepositoryMockUpdateKnowledgeFileMetadataOrigins contains origins of expectations of the Repository.UpdateKnowledgeFileMetadata
type RepositoryMockUpdateKnowledgeFileMetadataExpectationOrigins struct {
	origin        string
	originCtx     string
	originFileUID string
	originE1      string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateKnowledgeFileMetadata *mRepositoryMockUpdateKnowledgeFileMetadata) Optional() *mRepositoryMockUpdateKnowledgeFileMetadata {
	mmUpdateKnowledgeFileMetadata.optional = true
	return mmUpdateKnowledgeFileMetadata
}

// Expect sets up expected params for Repository.UpdateKnowledgeFileMetadata
func (mmUpdateKnowledgeFileMetadata *mRepositoryMockUpdateKnowledgeFileMetadata) Expect(ctx context.Context, fileUID types.FileUIDType, e1 mm_repository.ExtraMetaData) *mRepositoryMockUpdateKnowledgeFileMetadata {
	if mmUpdateKnowledgeFileMetadata.mock.funcUpdateKnowledgeFileMetadata != nil {
		mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileMetadata mock is already set by Set")
	}

	if mmUpdateKnowledgeFileMetadata.defaultExpectation == nil {
		mmUpdateKnowledgeFileMetadata.defaultExpectation = &RepositoryMockUpdateKnowledgeFileMetadataExpectation{}
	}

	if mmUpdateKnowledgeFileMetadata.defaultExpectation.paramPtrs != nil {
		mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileMetadata mock is already set by ExpectParams functions")
	}

	mmUpdateKnowledgeFileMetadata.defaultExpectation.params = &RepositoryMockUpdateKnowledgeFileMetadataParams{ctx, fileUID, e1}
	mmUpdateKnowledgeFileMetadata.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateKnowledgeFileMetadata.expectations {
		if minimock.Equal(e.params, mmUpdateKnowledgeFileMetadata.defaultExpectation.params) {
			mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateKnowledgeFileMetadata.defaultExpectation.params)
		}
	}

	return mmUpdateKnowledgeFileMetadata
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateKnowledgeFileMetadata
func (mmUpdateKnowledgeFileMetadata *mRepositoryMockUpdateKnowledgeFileMetadata) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateKnowledgeFileMetadata {
	if mmUpdateKnowledgeFileMetadata.mock.funcUpdateKnowledgeFileMetadata != nil {
		mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileMetadata mock is already set by Set")
	}

	if mmUpdateKnowledgeFileMetadata.defaultExpectation == nil {
		mmUpdateKnowledgeFileMetadata.defaultExpectation = &RepositoryMockUpdateKnowledgeFileMetadataExpectation{}
	}

	if mmUpdateKnowledgeFileMetadata.defaultExpectation.params != nil {
		mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileMetadata mock is already set by Expect")
	}

	if mmUpdateKnowledgeFileMetadata.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeFileMetadata.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeFileMetadataParamPtrs{}
	}
	mmUpdateKnowledgeFileMetadata.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateKnowledgeFileMetadata.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateKnowledgeFileMetadata
}

// ExpectFileUIDParam2 sets up expected param fileUID for Repository.UpdateKnowledgeFileMetadata
func (mmUpdateKnowledgeFileMetadata *mRepositoryMockUpdateKnowledgeFileMetadata) ExpectFileUIDParam2(fileUID types.FileUIDType) *mRepositoryMockUpdateKnowledgeFileMetadata {
	if mmUpdateKnowledgeFileMetadata.mock.funcUpdateKnowledgeFileMetadata != nil {
		mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileMetadata mock is already set by Set")
	}

	if mmUpdateKnowledgeFileMetadata.defaultExpectation == nil {
		mmUpdateKnowledgeFileMetadata.defaultExpectation = &RepositoryMockUpdateKnowledgeFileMetadataExpectation{}
	}

	if mmUpdateKnowledgeFileMetadata.defaultExpectation.params != nil {
		mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileMetadata mock is already set by Expect")
	}

	if mmUpdateKnowledgeFileMetadata.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeFileMetadata.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeFileMetadataParamPtrs{}
	}
	mmUpdateKnowledgeFileMetadata.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmUpdateKnowledgeFileMetadata.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmUpdateKnowledgeFileMetadata
}

// ExpectE1Param3 sets up expected param e1 for Repository.UpdateKnowledgeFileMetadata
func (mmUpdateKnowledgeFileMetadata *mRepositoryMockUpdateKnowledgeFileMetadata) ExpectE1Param3(e1 mm_repository.ExtraMetaData) *mRepositoryMockUpdateKnowledgeFileMetadata {
	if mmUpdateKnowledgeFileMetadata.mock.funcUpdateKnowledgeFileMetadata != nil {
		mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileMetadata mock is already set by Set")
	}

	if mmUpdateKnowledgeFileMetadata.defaultExpectation == nil {
		mmUpdateKnowledgeFileMetadata.defaultExpectation = &RepositoryMockUpdateKnowledgeFileMetadataExpectation{}
	}

	if mmUpdateKnowledgeFileMetadata.defaultExpectation.params != nil {
		mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileMetadata mock is already set by Expect")
	}

	if mmUpdateKnowledgeFileMetadata.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeFileMetadata.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeFileMetadataParamPtrs{}
	}
	mmUpdateKnowledgeFileMetadata.defaultExpectation.paramPtrs.e1 = &e1
	mmUpdateKnowledgeFileMetadata.defaultExpectation.expectationOrigins.originE1 = minimock.CallerInfo(1)

	return mmUpdateKnowledgeFileMetadata
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateKnowledgeFileMetadata
func (mmUpdateKnowledgeFileMetadata *mRepositoryMockUpdateKnowledgeFileMetadata) Inspect(f func(ctx context.Context, fileUID types.FileUIDType, e1 mm_repository.ExtraMetaData)) *mRepositoryMockUpdateKnowledgeFileMetadata {
	if mmUpdateKnowledgeFileMetadata.mock.inspectFuncUpdateKnowledgeFileMetadata != nil {
		mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateKnowledgeFileMetadata")
	}

	mmUpdateKnowledgeFileMetadata.mock.inspectFuncUpdateKnowledgeFileMetadata = f

	return mmUpdateKnowledgeFileMetadata
}

// Return sets up results that will be returned by Repository.UpdateKnowledgeFileMetadata
func (mmUpdateKnowledgeFileMetadata *mRepositoryMockUpdateKnowledgeFileMetadata) Return(err error) *RepositoryMock {
	if mmUpdateKnowledgeFileMetadata.mock.funcUpdateKnowledgeFileMetadata != nil {
		mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileMetadata mock is already set by Set")
	}

	if mmUpdateKnowledgeFileMetadata.defaultExpectation == nil {
		mmUpdateKnowledgeFileMetadata.defaultExpectation = &RepositoryMockUpdateKnowledgeFileMetadataExpectation{mock: mmUpdateKnowledgeFileMetadata.mock}
	}
	mmUpdateKnowledgeFileMetadata.defaultExpectation.results = &RepositoryMockUpdateKnowledgeFileMetadataResults{err}
	mmUpdateKnowledgeFileMetadata.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeFileMetadata.mock
}

// Set uses given function f to mock the Repository.UpdateKnowledgeFileMetadata method
func (mmUpdateKnowledgeFileMetadata *mRepositoryMockUpdateKnowledgeFileMetadata) Set(f func(ctx context.Context, fileUID types.FileUIDType, e1 mm_repository.ExtraMetaData) (err error)) *RepositoryMock {
	if mmUpdateKnowledgeFileMetadata.defaultExpectation != nil {
		mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateKnowledgeFileMetadata method")
	}

	if len(mmUpdateKnowledgeFileMetadata.expectations) > 0 {
		mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateKnowledgeFileMetadata method")
	}

	mmUpdateKnowledgeFileMetadata.mock.funcUpdateKnowledgeFileMetadata = f
	mmUpdateKnowledgeFileMetadata.mock.funcUpdateKnowledgeFileMetadataOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeFileMetadata.mock
}

// When sets expectation for the Repository.UpdateKnowledgeFileMetadata which will trigger the result defined by the following
// Then helper
func (mmUpdateKnowledgeFileMetadata *mRepositoryMockUpdateKnowledgeFileMetadata) When(ctx context.Context, fileUID types.FileUIDType, e1 mm_repository.ExtraMetaData) *RepositoryMockUpdateKnowledgeFileMetadataExpectation {
	if mmUpdateKnowledgeFileMetadata.mock.funcUpdateKnowledgeFileMetadata != nil {
		mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileMetadata mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateKnowledgeFileMetadataExpectation{
		mock:               mmUpdateKnowledgeFileMetadata.mock,
		params:             &RepositoryMockUpdateKnowledgeFileMetadataParams{ctx, fileUID, e1},
		expectationOrigins: RepositoryMockUpdateKnowledgeFileMetadataExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateKnowledgeFileMetadata.expectations = append(mmUpdateKnowledgeFileMetadata.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateKnowledgeFileMetadata return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateKnowledgeFileMetadataExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateKnowledgeFileMetadataResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateKnowledgeFileMetadata should be invoked
func (mmUpdateKnowledgeFileMetadata *mRepositoryMockUpdateKnowledgeFileMetadata) Times(n uint64) *mRepositoryMockUpdateKnowledgeFileMetadata {
	if n == 0 {
		mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("Times of RepositoryMock.UpdateKnowledgeFileMetadata mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateKnowledgeFileMetadata.expectedInvocations, n)
	mmUpdateKnowledgeFileMetadata.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeFileMetadata
}

func (mmUpdateKnowledgeFileMetadata *mRepositoryMockUpdateKnowledgeFileMetadata) invocationsDone() bool {
	if len(mmUpdateKnowledgeFileMetadata.expectations) == 0 && mmUpdateKnowledgeFileMetadata.defaultExpectation == nil && mmUpdateKnowledgeFileMetadata.mock.funcUpdateKnowledgeFileMetadata == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeFileMetadata.mock.afterUpdateKnowledgeFileMetadataCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeFileMetadata.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateKnowledgeFileMetadata implements mm_repository.Repository
func (mmUpdateKnowledgeFileMetadata *RepositoryMock) UpdateKnowledgeFileMetadata(ctx context.Context, fileUID types.FileUIDType, e1 mm_repository.ExtraMetaData) (err error) {
	mm_atomic.AddUint64(&mmUpdateKnowledgeFileMetadata.beforeUpdateKnowledgeFileMetadataCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateKnowledgeFileMetadata.afterUpdateKnowledgeFileMetadataCounter, 1)

	mmUpdateKnowledgeFileMetadata.t.Helper()

	if mmUpdateKnowledgeFileMetadata.inspectFuncUpdateKnowledgeFileMetadata != nil {
		mmUpdateKnowledgeFileMetadata.inspectFuncUpdateKnowledgeFileMetadata(ctx, fileUID, e1)
	}

	mm_params := RepositoryMockUpdateKnowledgeFileMetadataParams{ctx, fileUID, e1}

	// Record call args
	mmUpdateKnowledgeFileMetadata.UpdateKnowledgeFileMetadataMock.mutex.Lock()
	mmUpdateKnowledgeFileMetadata.UpdateKnowledgeFileMetadataMock.callArgs = append(mmUpdateKnowledgeFileMetadata.UpdateKnowledgeFileMetadataMock.callArgs, &mm_params)
	mmUpdateKnowledgeFileMetadata.UpdateKnowledgeFileMetadataMock.mutex.Unlock()

	for _, e := range mmUpdateKnowledgeFileMetadata.UpdateKnowledgeFileMetadataMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateKnowledgeFileMetadata.UpdateKnowledgeFileMetadataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateKnowledgeFileMetadata.UpdateKnowledgeFileMetadataMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateKnowledgeFileMetadata.UpdateKnowledgeFileMetadataMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateKnowledgeFileMetadata.UpdateKnowledgeFileMetadataMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateKnowledgeFileMetadataParams{ctx, fileUID, e1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateKnowledgeFileMetadata.t.Errorf("RepositoryMock.UpdateKnowledgeFileMetadata got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeFileMetadata.UpdateKnowledgeFileMetadataMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmUpdateKnowledgeFileMetadata.t.Errorf("RepositoryMock.UpdateKnowledgeFileMetadata got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeFileMetadata.UpdateKnowledgeFileMetadataMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

			if mm_want_ptrs.e1 != nil && !minimock.Equal(*mm_want_ptrs.e1, mm_got.e1) {
				mmUpdateKnowledgeFileMetadata.t.Errorf("RepositoryMock.UpdateKnowledgeFileMetadata got unexpected parameter e1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeFileMetadata.UpdateKnowledgeFileMetadataMock.defaultExpectation.expectationOrigins.originE1, *mm_want_ptrs.e1, mm_got.e1, minimock.Diff(*mm_want_ptrs.e1, mm_got.e1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateKnowledgeFileMetadata.t.Errorf("RepositoryMock.UpdateKnowledgeFileMetadata got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateKnowledgeFileMetadata.UpdateKnowledgeFileMetadataMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateKnowledgeFileMetadata.UpdateKnowledgeFileMetadataMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateKnowledgeFileMetadata.t.Fatal("No results are set for the RepositoryMock.UpdateKnowledgeFileMetadata")
		}
		return (*mm_results).err
	}
	if mmUpdateKnowledgeFileMetadata.funcUpdateKnowledgeFileMetadata != nil {
		return mmUpdateKnowledgeFileMetadata.funcUpdateKnowledgeFileMetadata(ctx, fileUID, e1)
	}
	mmUpdateKnowledgeFileMetadata.t.Fatalf("Unexpected call to RepositoryMock.UpdateKnowledgeFileMetadata. %v %v %v", ctx, fileUID, e1)
	return
}

// UpdateKnowledgeFileMetadataAfterCounter returns a count of finished RepositoryMock.UpdateKnowledgeFileMetadata invocations
func (mmUpdateKnowledgeFileMetadata *RepositoryMock) UpdateKnowledgeFileMetadataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeFileMetadata.afterUpdateKnowledgeFileMetadataCounter)
}

// UpdateKnowledgeFileMetadataBeforeCounter returns a count of RepositoryMock.UpdateKnowledgeFileMetadata invocations
func (mmUpdateKnowledgeFileMetadata *RepositoryMock) UpdateKnowledgeFileMetadataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeFileMetadata.beforeUpdateKnowledgeFileMetadataCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateKnowledgeFileMetadata.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateKnowledgeFileMetadata *mRepositoryMockUpdateKnowledgeFileMetadata) Calls() []*RepositoryMockUpdateKnowledgeFileMetadataParams {
	mmUpdateKnowledgeFileMetadata.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateKnowledgeFileMetadataParams, len(mmUpdateKnowledgeFileMetadata.callArgs))
	copy(argCopy, mmUpdateKnowledgeFileMetadata.callArgs)

	mmUpdateKnowledgeFileMetadata.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateKnowledgeFileMetadataDone returns true if the count of the UpdateKnowledgeFileMetadata invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateKnowledgeFileMetadataDone() bool {
	if m.UpdateKnowledgeFileMetadataMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateKnowledgeFileMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateKnowledgeFileMetadataMock.invocationsDone()
}

// MinimockUpdateKnowledgeFileMetadataInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateKnowledgeFileMetadataInspect() {
	for _, e := range m.UpdateKnowledgeFileMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeFileMetadata at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateKnowledgeFileMetadataCounter := mm_atomic.LoadUint64(&m.afterUpdateKnowledgeFileMetadataCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateKnowledgeFileMetadataMock.defaultExpectation != nil && afterUpdateKnowledgeFileMetadataCounter < 1 {
		if m.UpdateKnowledgeFileMetadataMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeFileMetadata at\n%s", m.UpdateKnowledgeFileMetadataMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeFileMetadata at\n%s with params: %#v", m.UpdateKnowledgeFileMetadataMock.defaultExpectation.expectationOrigins.origin, *m.UpdateKnowledgeFileMetadataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateKnowledgeFileMetadata != nil && afterUpdateKnowledgeFileMetadataCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeFileMetadata at\n%s", m.funcUpdateKnowledgeFileMetadataOrigin)
	}

	if !m.UpdateKnowledgeFileMetadataMock.invocationsDone() && afterUpdateKnowledgeFileMetadataCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateKnowledgeFileMetadata at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateKnowledgeFileMetadataMock.expectedInvocations), m.UpdateKnowledgeFileMetadataMock.expectedInvocationsOrigin, afterUpdateKnowledgeFileMetadataCounter)
	}
}

type mRepositoryMockUpdateKnowledgeFileUsageMetadata struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateKnowledgeFileUsageMetadataExpectation
	expectations       []*RepositoryMockUpdateKnowledgeFileUsageMetadataExpectation

	callArgs []*RepositoryMockUpdateKnowledgeFileUsageMetadataParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateKnowledgeFileUsageMetadataExpectation specifies expectation struct of the Repository.UpdateKnowledgeFileUsageMetadata
type RepositoryMockUpdateKnowledgeFileUsageMetadataExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateKnowledgeFileUsageMetadataParams
	paramPtrs          *RepositoryMockUpdateKnowledgeFileUsageMetadataParamPtrs
	expectationOrigins RepositoryMockUpdateKnowledgeFileUsageMetadataExpectationOrigins
	results            *RepositoryMockUpdateKnowledgeFileUsageMetadataResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateKnowledgeFileUsageMetadataParams contains parameters of the Repository.UpdateKnowledgeFileUsageMetadata
type RepositoryMockUpdateKnowledgeFileUsageMetadataParams struct {
	ctx     context.Context
	fileUID types.FileUIDType
	u1      mm_repository.UsageMetadata
}

// RepositoryMockUpdateKnowledgeFileUsageMetadataParamPtrs contains pointers to parameters of the Repository.UpdateKnowledgeFileUsageMetadata
type RepositoryMockUpdateKnowledgeFileUsageMetadataParamPtrs struct {
	ctx     *context.Context
	fileUID *types.FileUIDType
	u1      *mm_repository.UsageMetadata
}

// RepositoryMockUpdateKnowledgeFileUsageMetadataResults contains results of the Repository.UpdateKnowledgeFileUsageMetadata
type RepositoryMockUpdateKnowledgeFileUsageMetadataResults struct {
	err error
}

// RepositoryMockUpdateKnowledgeFileUsageMetadataOrigins contains origins of expectations of the Repository.UpdateKnowledgeFileUsageMetadata
type RepositoryMockUpdateKnowledgeFileUsageMetadataExpectationOrigins struct {
	origin        string
	originCtx     string
	originFileUID string
	originU1      string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateKnowledgeFileUsageMetadata *mRepositoryMockUpdateKnowledgeFileUsageMetadata) Optional() *mRepositoryMockUpdateKnowledgeFileUsageMetadata {
	mmUpdateKnowledgeFileUsageMetadata.optional = true
	return mmUpdateKnowledgeFileUsageMetadata
}

// Expect sets up expected params for Repository.UpdateKnowledgeFileUsageMetadata
func (mmUpdateKnowledgeFileUsageMetadata *mRepositoryMockUpdateKnowledgeFileUsageMetadata) Expect(ctx context.Context, fileUID types.FileUIDType, u1 mm_repository.UsageMetadata) *mRepositoryMockUpdateKnowledgeFileUsageMetadata {
	if mmUpdateKnowledgeFileUsageMetadata.mock.funcUpdateKnowledgeFileUsageMetadata != nil {
		mmUpdateKnowledgeFileUsageMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileUsageMetadata mock is already set by Set")
	}

	if mmUpdateKnowledgeFileUsageMetadata.defaultExpectation == nil {
		mmUpdateKnowledgeFileUsageMetadata.defaultExpectation = &RepositoryMockUpdateKnowledgeFileUsageMetadataExpectation{}
	}

	if mmUpdateKnowledgeFileUsageMetadata.defaultExpectation.paramPtrs != nil {
		mmUpdateKnowledgeFileUsageMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileUsageMetadata mock is already set by ExpectParams functions")
	}

	mmUpdateKnowledgeFileUsageMetadata.defaultExpectation.params = &RepositoryMockUpdateKnowledgeFileUsageMetadataParams{ctx, fileUID, u1}
	mmUpdateKnowledgeFileUsageMetadata.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateKnowledgeFileUsageMetadata.expectations {
		if minimock.Equal(e.params, mmUpdateKnowledgeFileUsageMetadata.defaultExpectation.params) {
			mmUpdateKnowledgeFileUsageMetadata.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateKnowledgeFileUsageMetadata.defaultExpectation.params)
		}
	}

	return mmUpdateKnowledgeFileUsageMetadata
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateKnowledgeFileUsageMetadata
func (mmUpdateKnowledgeFileUsageMetadata *mRepositoryMockUpdateKnowledgeFileUsageMetadata) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateKnowledgeFileUsageMetadata {
	if mmUpdateKnowledgeFileUsageMetadata.mock.funcUpdateKnowledgeFileUsageMetadata != nil {
		mmUpdateKnowledgeFileUsageMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileUsageMetadata mock is already set by Set")
	}

	if mmUpdateKnowledgeFileUsageMetadata.defaultExpectation == nil {
		mmUpdateKnowledgeFileUsageMetadata.defaultExpectation = &RepositoryMockUpdateKnowledgeFileUsageMetadataExpectation{}
	}

	if mmUpdateKnowledgeFileUsageMetadata.defaultExpectation.params != nil {
		mmUpdateKnowledgeFileUsageMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileUsageMetadata mock is already set by Expect")
	}

	if mmUpdateKnowledgeFileUsageMetadata.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeFileUsageMetadata.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeFileUsageMetadataParamPtrs{}
	}
	mmUpdateKnowledgeFileUsageMetadata.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateKnowledgeFileUsageMetadata.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateKnowledgeFileUsageMetadata
}

// ExpectFileUIDParam2 sets up expected param fileUID for Repository.UpdateKnowledgeFileUsageMetadata
func (mmUpdateKnowledgeFileUsageMetadata *mRepositoryMockUpdateKnowledgeFileUsageMetadata) ExpectFileUIDParam2(fileUID types.FileUIDType) *mRepositoryMockUpdateKnowledgeFileUsageMetadata {
	if mmUpdateKnowledgeFileUsageMetadata.mock.funcUpdateKnowledgeFileUsageMetadata != nil {
		mmUpdateKnowledgeFileUsageMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileUsageMetadata mock is already set by Set")
	}

	if mmUpdateKnowledgeFileUsageMetadata.defaultExpectation == nil {
		mmUpdateKnowledgeFileUsageMetadata.defaultExpectation = &RepositoryMockUpdateKnowledgeFileUsageMetadataExpectation{}
	}

	if mmUpdateKnowledgeFileUsageMetadata.defaultExpectation.params != nil {
		mmUpdateKnowledgeFileUsageMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileUsageMetadata mock is already set by Expect")
	}

	if mmUpdateKnowledgeFileUsageMetadata.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeFileUsageMetadata.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeFileUsageMetadataParamPtrs{}
	}
	mmUpdateKnowledgeFileUsageMetadata.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmUpdateKnowledgeFileUsageMetadata.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmUpdateKnowledgeFileUsageMetadata
}

// ExpectU1Param3 sets up expected param u1 for Repository.UpdateKnowledgeFileUsageMetadata
func (mmUpdateKnowledgeFileUsageMetadata *mRepositoryMockUpdateKnowledgeFileUsageMetadata) ExpectU1Param3(u1 mm_repository.UsageMetadata) *mRepositoryMockUpdateKnowledgeFileUsageMetadata {
	if mmUpdateKnowledgeFileUsageMetadata.mock.funcUpdateKnowledgeFileUsageMetadata != nil {
		mmUpdateKnowledgeFileUsageMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileUsageMetadata mock is already set by Set")
	}

	if mmUpdateKnowledgeFileUsageMetadata.defaultExpectation == nil {
		mmUpdateKnowledgeFileUsageMetadata.defaultExpectation = &RepositoryMockUpdateKnowledgeFileUsageMetadataExpectation{}
	}

	if mmUpdateKnowledgeFileUsageMetadata.defaultExpectation.params != nil {
		mmUpdateKnowledgeFileUsageMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileUsageMetadata mock is already set by Expect")
	}

	if mmUpdateKnowledgeFileUsageMetadata.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeFileUsageMetadata.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeFileUsageMetadataParamPtrs{}
	}
	mmUpdateKnowledgeFileUsageMetadata.defaultExpectation.paramPtrs.u1 = &u1
	mmUpdateKnowledgeFileUsageMetadata.defaultExpectation.expectationOrigins.originU1 = minimock.CallerInfo(1)

	return mmUpdateKnowledgeFileUsageMetadata
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateKnowledgeFileUsageMetadata
func (mmUpdateKnowledgeFileUsageMetadata *mRepositoryMockUpdateKnowledgeFileUsageMetadata) Inspect(f func(ctx context.Context, fileUID types.FileUIDType, u1 mm_repository.UsageMetadata)) *mRepositoryMockUpdateKnowledgeFileUsageMetadata {
	if mmUpdateKnowledgeFileUsageMetadata.mock.inspectFuncUpdateKnowledgeFileUsageMetadata != nil {
		mmUpdateKnowledgeFileUsageMetadata.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateKnowledgeFileUsageMetadata")
	}

	mmUpdateKnowledgeFileUsageMetadata.mock.inspectFuncUpdateKnowledgeFileUsageMetadata = f

	return mmUpdateKnowledgeFileUsageMetadata
}

// Return sets up results that will be returned by Repository.UpdateKnowledgeFileUsageMetadata
func (mmUpdateKnowledgeFileUsageMetadata *mRepositoryMockUpdateKnowledgeFileUsageMetadata) Return(err error) *RepositoryMock {
	if mmUpdateKnowledgeFileUsageMetadata.mock.funcUpdateKnowledgeFileUsageMetadata != nil {
		mmUpdateKnowledgeFileUsageMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileUsageMetadata mock is already set by Set")
	}

	if mmUpdateKnowledgeFileUsageMetadata.defaultExpectation == nil {
		mmUpdateKnowledgeFileUsageMetadata.defaultExpectation = &RepositoryMockUpdateKnowledgeFileUsageMetadataExpectation{mock: mmUpdateKnowledgeFileUsageMetadata.mock}
	}
	mmUpdateKnowledgeFileUsageMetadata.defaultExpectation.results = &RepositoryMockUpdateKnowledgeFileUsageMetadataResults{err}
	mmUpdateKnowledgeFileUsageMetadata.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeFileUsageMetadata.mock
}

// Set uses given function f to mock the Repository.UpdateKnowledgeFileUsageMetadata method
func (mmUpdateKnowledgeFileUsageMetadata *mRepositoryMockUpdateKnowledgeFileUsageMetadata) Set(f func(ctx context.Context, fileUID types.FileUIDType, u1 mm_repository.UsageMetadata) (err error)) *RepositoryMock {
	if mmUpdateKnowledgeFileUsageMetadata.defaultExpectation != nil {
		mmUpdateKnowledgeFileUsageMetadata.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateKnowledgeFileUsageMetadata method")
	}

	if len(mmUpdateKnowledgeFileUsageMetadata.expectations) > 0 {
		mmUpdateKnowledgeFileUsageMetadata.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateKnowledgeFileUsageMetadata method")
	}

	mmUpdateKnowledgeFileUsageMetadata.mock.funcUpdateKnowledgeFileUsageMetadata = f
	mmUpdateKnowledgeFileUsageMetadata.mock.funcUpdateKnowledgeFileUsageMetadataOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeFileUsageMetadata.mock
}

// When sets expectation for the Repository.UpdateKnowledgeFileUsageMetadata which will trigger the result defined by the following
// Then helper
func (mmUpdateKnowledgeFileUsageMetadata *mRepositoryMockUpdateKnowledgeFileUsageMetadata) When(ctx context.Context, fileUID types.FileUIDType, u1 mm_repository.UsageMetadata) *RepositoryMockUpdateKnowledgeFileUsageMetadataExpectation {
	if mmUpdateKnowledgeFileUsageMetadata.mock.funcUpdateKnowledgeFileUsageMetadata != nil {
		mmUpdateKnowledgeFileUsageMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileUsageMetadata mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateKnowledgeFileUsageMetadataExpectation{
		mock:               mmUpdateKnowledgeFileUsageMetadata.mock,
		params:             &RepositoryMockUpdateKnowledgeFileUsageMetadataParams{ctx, fileUID, u1},
		expectationOrigins: RepositoryMockUpdateKnowledgeFileUsageMetadataExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateKnowledgeFileUsageMetadata.expectations = append(mmUpdateKnowledgeFileUsageMetadata.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateKnowledgeFileUsageMetadata return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateKnowledgeFileUsageMetadataExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateKnowledgeFileUsageMetadataResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateKnowledgeFileUsageMetadata should be invoked
func (mmUpdateKnowledgeFileUsageMetadata *mRepositoryMockUpdateKnowledgeFileUsageMetadata) Times(n uint64) *mRepositoryMockUpdateKnowledgeFileUsageMetadata {
	if n == 0 {
		mmUpdateKnowledgeFileUsageMetadata.mock.t.Fatalf("Times of RepositoryMock.UpdateKnowledgeFileUsageMetadata mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateKnowledgeFileUsageMetadata.expectedInvocations, n)
	mmUpdateKnowledgeFileUsageMetadata.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeFileUsageMetadata
}

func (mmUpdateKnowledgeFileUsageMetadata *mRepositoryMockUpdateKnowledgeFileUsageMetadata) invocationsDone() bool {
	if len(mmUpdateKnowledgeFileUsageMetadata.expectations) == 0 && mmUpdateKnowledgeFileUsageMetadata.defaultExpectation == nil && mmUpdateKnowledgeFileUsageMetadata.mock.funcUpdateKnowledgeFileUsageMetadata == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeFileUsageMetadata.mock.afterUpdateKnowledgeFileUsageMetadataCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeFileUsageMetadata.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateKnowledgeFileUsageMetadata implements mm_repository.Repository
func (mmUpdateKnowledgeFileUsageMetadata *RepositoryMock) UpdateKnowledgeFileUsageMetadata(ctx context.Context, fileUID types.FileUIDType, u1 mm_repository.UsageMetadata) (err error) {
	mm_atomic.AddUint64(&mmUpdateKnowledgeFileUsageMetadata.beforeUpdateKnowledgeFileUsageMetadataCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateKnowledgeFileUsageMetadata.afterUpdateKnowledgeFileUsageMetadataCounter, 1)

	mmUpdateKnowledgeFileUsageMetadata.t.Helper()

	if mmUpdateKnowledgeFileUsageMetadata.inspectFuncUpdateKnowledgeFileUsageMetadata != nil {
		mmUpdateKnowledgeFileUsageMetadata.inspectFuncUpdateKnowledgeFileUsageMetadata(ctx, fileUID, u1)
	}

	mm_params := RepositoryMockUpdateKnowledgeFileUsageMetadataParams{ctx, fileUID, u1}

	// Record call args
	mmUpdateKnowledgeFileUsageMetadata.UpdateKnowledgeFileUsageMetadataMock.mutex.Lock()
	mmUpdateKnowledgeFileUsageMetadata.UpdateKnowledgeFileUsageMetadataMock.callArgs = append(mmUpdateKnowledgeFileUsageMetadata.UpdateKnowledgeFileUsageMetadataMock.callArgs, &mm_params)
	mmUpdateKnowledgeFileUsageMetadata.UpdateKnowledgeFileUsageMetadataMock.mutex.Unlock()

	for _, e := range mmUpdateKnowledgeFileUsageMetadata.UpdateKnowledgeFileUsageMetadataMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateKnowledgeFileUsageMetadata.UpdateKnowledgeFileUsageMetadataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateKnowledgeFileUsageMetadata.UpdateKnowledgeFileUsageMetadataMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateKnowledgeFileUsageMetadata.UpdateKnowledgeFileUsageMetadataMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateKnowledgeFileUsageMetadata.UpdateKnowledgeFileUsageMetadataMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateKnowledgeFileUsageMetadataParams{ctx, fileUID, u1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateKnowledgeFileUsageMetadata.t.Errorf("RepositoryMock.UpdateKnowledgeFileUsageMetadata got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeFileUsageMetadata.UpdateKnowledgeFileUsageMetadataMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmUpdateKnowledgeFileUsageMetadata.t.Errorf("RepositoryMock.UpdateKnowledgeFileUsageMetadata got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeFileUsageMetadata.UpdateKnowledgeFileUsageMetadataMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmUpdateKnowledgeFileUsageMetadata.t.Errorf("RepositoryMock.UpdateKnowledgeFileUsageMetadata got unexpected parameter u1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeFileUsageMetadata.UpdateKnowledgeFileUsageMetadataMock.defaultExpectation.expectationOrigins.originU1, *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateKnowledgeFileUsageMetadata.t.Errorf("RepositoryMock.UpdateKnowledgeFileUsageMetadata got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateKnowledgeFileUsageMetadata.UpdateKnowledgeFileUsageMetadataMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateKnowledgeFileUsageMetadata.UpdateKnowledgeFileUsageMetadataMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateKnowledgeFileUsageMetadata.t.Fatal("No results are set for the RepositoryMock.UpdateKnowledgeFileUsageMetadata")
		}
		return (*mm_results).err
	}
	if mmUpdateKnowledgeFileUsageMetadata.funcUpdateKnowledgeFileUsageMetadata != nil {
		return mmUpdateKnowledgeFileUsageMetadata.funcUpdateKnowledgeFileUsageMetadata(ctx, fileUID, u1)
	}
	mmUpdateKnowledgeFileUsageMetadata.t.Fatalf("Unexpected call to RepositoryMock.UpdateKnowledgeFileUsageMetadata. %v %v %v", ctx, fileUID, u1)
	return
}

// UpdateKnowledgeFileUsageMetadataAfterCounter returns a count of finished RepositoryMock.UpdateKnowledgeFileUsageMetadata invocations
func (mmUpdateKnowledgeFileUsageMetadata *RepositoryMock) UpdateKnowledgeFileUsageMetadataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeFileUsageMetadata.afterUpdateKnowledgeFileUsageMetadataCounter)
}

// UpdateKnowledgeFileUsageMetadataBeforeCounter returns a count of RepositoryMock.UpdateKnowledgeFileUsageMetadata invocations
func (mmUpdateKnowledgeFileUsageMetadata *RepositoryMock) UpdateKnowledgeFileUsageMetadataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeFileUsageMetadata.beforeUpdateKnowledgeFileUsageMetadataCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateKnowledgeFileUsageMetadata.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateKnowledgeFileUsageMetadata *mRepositoryMockUpdateKnowledgeFileUsageMetadata) Calls() []*RepositoryMockUpdateKnowledgeFileUsageMetadataParams {
	mmUpdateKnowledgeFileUsageMetadata.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateKnowledgeFileUsageMetadataParams, len(mmUpdateKnowledgeFileUsageMetadata.callArgs))
	copy(argCopy, mmUpdateKnowledgeFileUsageMetadata.callArgs)

	mmUpdateKnowledgeFileUsageMetadata.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateKnowledgeFileUsageMetadataDone returns true if the count of the UpdateKnowledgeFileUsageMetadata invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateKnowledgeFileUsageMetadataDone() bool {
	if m.UpdateKnowledgeFileUsageMetadataMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateKnowledgeFileUsageMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateKnowledgeFileUsageMetadataMock.invocationsDone()
}

// MinimockUpdateKnowledgeFileUsageMetadataInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateKnowledgeFileUsageMetadataInspect() {
	for _, e := range m.UpdateKnowledgeFileUsageMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeFileUsageMetadata at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateKnowledgeFileUsageMetadataCounter := mm_atomic.LoadUint64(&m.afterUpdateKnowledgeFileUsageMetadataCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateKnowledgeFileUsageMetadataMock.defaultExpectation != nil && afterUpdateKnowledgeFileUsageMetadataCounter < 1 {
		if m.UpdateKnowledgeFileUsageMetadataMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeFileUsageMetadata at\n%s", m.UpdateKnowledgeFileUsageMetadataMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeFileUsageMetadata at\n%s with params: %#v", m.UpdateKnowledgeFileUsageMetadataMock.defaultExpectation.expectationOrigins.origin, *m.UpdateKnowledgeFileUsageMetadataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateKnowledgeFileUsageMetadata != nil && afterUpdateKnowledgeFileUsageMetadataCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeFileUsageMetadata at\n%s", m.funcUpdateKnowledgeFileUsageMetadataOrigin)
	}

	if !m.UpdateKnowledgeFileUsageMetadataMock.invocationsDone() && afterUpdateKnowledgeFileUsageMetadataCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateKnowledgeFileUsageMetadata at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateKnowledgeFileUsageMetadataMock.expectedInvocations), m.UpdateKnowledgeFileUsageMetadataMock.expectedInvocationsOrigin, afterUpdateKnowledgeFileUsageMetadataCounter)
	}
}

type mRepositoryMockUpdateObject struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateObjectExpectation
	expectations       []*RepositoryMockUpdateObjectExpectation

	callArgs []*RepositoryMockUpdateObjectParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateObjectExpectation specifies expectation struct of the Repository.UpdateObject
type RepositoryMockUpdateObjectExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateObjectParams
	paramPtrs          *RepositoryMockUpdateObjectParamPtrs
	expectationOrigins RepositoryMockUpdateObjectExpectationOrigins
	results            *RepositoryMockUpdateObjectResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateObjectParams contains parameters of the Repository.UpdateObject
type RepositoryMockUpdateObjectParams struct {
	ctx context.Context
	obj mm_repository.ObjectModel
}

// RepositoryMockUpdateObjectParamPtrs contains pointers to parameters of the Repository.UpdateObject
type RepositoryMockUpdateObjectParamPtrs struct {
	ctx *context.Context
	obj *mm_repository.ObjectModel
}

// RepositoryMockUpdateObjectResults contains results of the Repository.UpdateObject
type RepositoryMockUpdateObjectResults struct {
	op1 *mm_repository.ObjectModel
	err error
}

// RepositoryMockUpdateObjectOrigins contains origins of expectations of the Repository.UpdateObject
type RepositoryMockUpdateObjectExpectationOrigins struct {
	origin    string
	originCtx string
	originObj string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateObject *mRepositoryMockUpdateObject) Optional() *mRepositoryMockUpdateObject {
	mmUpdateObject.optional = true
	return mmUpdateObject
}

// Expect sets up expected params for Repository.UpdateObject
func (mmUpdateObject *mRepositoryMockUpdateObject) Expect(ctx context.Context, obj mm_repository.ObjectModel) *mRepositoryMockUpdateObject {
	if mmUpdateObject.mock.funcUpdateObject != nil {
		mmUpdateObject.mock.t.Fatalf("RepositoryMock.UpdateObject mock is already set by Set")
	}

	if mmUpdateObject.defaultExpectation == nil {
		mmUpdateObject.defaultExpectation = &RepositoryMockUpdateObjectExpectation{}
	}

	if mmUpdateObject.defaultExpectation.paramPtrs != nil {
		mmUpdateObject.mock.t.Fatalf("RepositoryMock.UpdateObject mock is already set by ExpectParams functions")
	}

	mmUpdateObject.defaultExpectation.params = &RepositoryMockUpdateObjectParams{ctx, obj}
	mmUpdateObject.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateObject.expectations {
		if minimock.Equal(e.params, mmUpdateObject.defaultExpectation.params) {
			mmUpdateObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateObject.defaultExpectation.params)
		}
	}

	return mmUpdateObject
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateObject
func (mmUpdateObject *mRepositoryMockUpdateObject) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateObject {
	if mmUpdateObject.mock.funcUpdateObject != nil {
		mmUpdateObject.mock.t.Fatalf("RepositoryMock.UpdateObject mock is already set by Set")
	}

	if mmUpdateObject.defaultExpectation == nil {
		mmUpdateObject.defaultExpectation = &RepositoryMockUpdateObjectExpectation{}
	}

	if mmUpdateObject.defaultExpectation.params != nil {
		mmUpdateObject.mock.t.Fatalf("RepositoryMock.UpdateObject mock is already set by Expect")
	}

	if mmUpdateObject.defaultExpectation.paramPtrs == nil {
		mmUpdateObject.defaultExpectation.paramPtrs = &RepositoryMockUpdateObjectParamPtrs{}
	}
	mmUpdateObject.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateObject.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateObject
}

// ExpectObjParam2 sets up expected param obj for Repository.UpdateObject
func (mmUpdateObject *mRepositoryMockUpdateObject) ExpectObjParam2(obj mm_repository.ObjectModel) *mRepositoryMockUpdateObject {
	if mmUpdateObject.mock.funcUpdateObject != nil {
		mmUpdateObject.mock.t.Fatalf("RepositoryMock.UpdateObject mock is already set by Set")
	}

	if mmUpdateObject.defaultExpectation == nil {
		mmUpdateObject.defaultExpectation = &RepositoryMockUpdateObjectExpectation{}
	}

	if mmUpdateObject.defaultExpectation.params != nil {
		mmUpdateObject.mock.t.Fatalf("RepositoryMock.UpdateObject mock is already set by Expect")
	}

	if mmUpdateObject.defaultExpectation.paramPtrs == nil {
		mmUpdateObject.defaultExpectation.paramPtrs = &RepositoryMockUpdateObjectParamPtrs{}
	}
	mmUpdateObject.defaultExpectation.paramPtrs.obj = &obj
	mmUpdateObject.defaultExpectation.expectationOrigins.originObj = minimock.CallerInfo(1)

	return mmUpdateObject
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateObject
func (mmUpdateObject *mRepositoryMockUpdateObject) Inspect(f func(ctx context.Context, obj mm_repository.ObjectModel)) *mRepositoryMockUpdateObject {
	if mmUpdateObject.mock.inspectFuncUpdateObject != nil {
		mmUpdateObject.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateObject")
	}

	mmUpdateObject.mock.inspectFuncUpdateObject = f

	return mmUpdateObject
}

// Return sets up results that will be returned by Repository.UpdateObject
func (mmUpdateObject *mRepositoryMockUpdateObject) Return(op1 *mm_repository.ObjectModel, err error) *RepositoryMock {
	if mmUpdateObject.mock.funcUpdateObject != nil {
		mmUpdateObject.mock.t.Fatalf("RepositoryMock.UpdateObject mock is already set by Set")
	}

	if mmUpdateObject.defaultExpectation == nil {
		mmUpdateObject.defaultExpectation = &RepositoryMockUpdateObjectExpectation{mock: mmUpdateObject.mock}
	}
	mmUpdateObject.defaultExpectation.results = &RepositoryMockUpdateObjectResults{op1, err}
	mmUpdateObject.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateObject.mock
}

// Set uses given function f to mock the Repository.UpdateObject method
func (mmUpdateObject *mRepositoryMockUpdateObject) Set(f func(ctx context.Context, obj mm_repository.ObjectModel) (op1 *mm_repository.ObjectModel, err error)) *RepositoryMock {
	if mmUpdateObject.defaultExpectation != nil {
		mmUpdateObject.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateObject method")
	}

	if len(mmUpdateObject.expectations) > 0 {
		mmUpdateObject.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateObject method")
	}

	mmUpdateObject.mock.funcUpdateObject = f
	mmUpdateObject.mock.funcUpdateObjectOrigin = minimock.CallerInfo(1)
	return mmUpdateObject.mock
}

// When sets expectation for the Repository.UpdateObject which will trigger the result defined by the following
// Then helper
func (mmUpdateObject *mRepositoryMockUpdateObject) When(ctx context.Context, obj mm_repository.ObjectModel) *RepositoryMockUpdateObjectExpectation {
	if mmUpdateObject.mock.funcUpdateObject != nil {
		mmUpdateObject.mock.t.Fatalf("RepositoryMock.UpdateObject mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateObjectExpectation{
		mock:               mmUpdateObject.mock,
		params:             &RepositoryMockUpdateObjectParams{ctx, obj},
		expectationOrigins: RepositoryMockUpdateObjectExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateObject.expectations = append(mmUpdateObject.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateObject return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateObjectExpectation) Then(op1 *mm_repository.ObjectModel, err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateObjectResults{op1, err}
	return e.mock
}

// Times sets number of times Repository.UpdateObject should be invoked
func (mmUpdateObject *mRepositoryMockUpdateObject) Times(n uint64) *mRepositoryMockUpdateObject {
	if n == 0 {
		mmUpdateObject.mock.t.Fatalf("Times of RepositoryMock.UpdateObject mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateObject.expectedInvocations, n)
	mmUpdateObject.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateObject
}

func (mmUpdateObject *mRepositoryMockUpdateObject) invocationsDone() bool {
	if len(mmUpdateObject.expectations) == 0 && mmUpdateObject.defaultExpectation == nil && mmUpdateObject.mock.funcUpdateObject == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateObject.mock.afterUpdateObjectCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateObject.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateObject implements mm_repository.Repository
func (mmUpdateObject *RepositoryMock) UpdateObject(ctx context.Context, obj mm_repository.ObjectModel) (op1 *mm_repository.ObjectModel, err error) {
	mm_atomic.AddUint64(&mmUpdateObject.beforeUpdateObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateObject.afterUpdateObjectCounter, 1)

	mmUpdateObject.t.Helper()

	if mmUpdateObject.inspectFuncUpdateObject != nil {
		mmUpdateObject.inspectFuncUpdateObject(ctx, obj)
	}

	mm_params := RepositoryMockUpdateObjectParams{ctx, obj}

	// Record call args
	mmUpdateObject.UpdateObjectMock.mutex.Lock()
	mmUpdateObject.UpdateObjectMock.callArgs = append(mmUpdateObject.UpdateObjectMock.callArgs, &mm_params)
	mmUpdateObject.UpdateObjectMock.mutex.Unlock()

	for _, e := range mmUpdateObject.UpdateObjectMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmUpdateObject.UpdateObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateObject.UpdateObjectMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateObject.UpdateObjectMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateObject.UpdateObjectMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateObjectParams{ctx, obj}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateObject.t.Errorf("RepositoryMock.UpdateObject got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateObject.UpdateObjectMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.obj != nil && !minimock.Equal(*mm_want_ptrs.obj, mm_got.obj) {
				mmUpdateObject.t.Errorf("RepositoryMock.UpdateObject got unexpected parameter obj, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateObject.UpdateObjectMock.defaultExpectation.expectationOrigins.originObj, *mm_want_ptrs.obj, mm_got.obj, minimock.Diff(*mm_want_ptrs.obj, mm_got.obj))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateObject.t.Errorf("RepositoryMock.UpdateObject got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateObject.UpdateObjectMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateObject.UpdateObjectMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateObject.t.Fatal("No results are set for the RepositoryMock.UpdateObject")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmUpdateObject.funcUpdateObject != nil {
		return mmUpdateObject.funcUpdateObject(ctx, obj)
	}
	mmUpdateObject.t.Fatalf("Unexpected call to RepositoryMock.UpdateObject. %v %v", ctx, obj)
	return
}

// UpdateObjectAfterCounter returns a count of finished RepositoryMock.UpdateObject invocations
func (mmUpdateObject *RepositoryMock) UpdateObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateObject.afterUpdateObjectCounter)
}

// UpdateObjectBeforeCounter returns a count of RepositoryMock.UpdateObject invocations
func (mmUpdateObject *RepositoryMock) UpdateObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateObject.beforeUpdateObjectCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateObject *mRepositoryMockUpdateObject) Calls() []*RepositoryMockUpdateObjectParams {
	mmUpdateObject.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateObjectParams, len(mmUpdateObject.callArgs))
	copy(argCopy, mmUpdateObject.callArgs)

	mmUpdateObject.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateObjectDone returns true if the count of the UpdateObject invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateObjectDone() bool {
	if m.UpdateObjectMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateObjectMock.invocationsDone()
}

// MinimockUpdateObjectInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateObjectInspect() {
	for _, e := range m.UpdateObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateObject at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateObjectCounter := mm_atomic.LoadUint64(&m.afterUpdateObjectCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateObjectMock.defaultExpectation != nil && afterUpdateObjectCounter < 1 {
		if m.UpdateObjectMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateObject at\n%s", m.UpdateObjectMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateObject at\n%s with params: %#v", m.UpdateObjectMock.defaultExpectation.expectationOrigins.origin, *m.UpdateObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateObject != nil && afterUpdateObjectCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateObject at\n%s", m.funcUpdateObjectOrigin)
	}

	if !m.UpdateObjectMock.invocationsDone() && afterUpdateObjectCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateObject at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateObjectMock.expectedInvocations), m.UpdateObjectMock.expectedInvocationsOrigin, afterUpdateObjectCounter)
	}
}

type mRepositoryMockUpdateObjectByUpdateMap struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateObjectByUpdateMapExpectation
	expectations       []*RepositoryMockUpdateObjectByUpdateMapExpectation

	callArgs []*RepositoryMockUpdateObjectByUpdateMapParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateObjectByUpdateMapExpectation specifies expectation struct of the Repository.UpdateObjectByUpdateMap
type RepositoryMockUpdateObjectByUpdateMapExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateObjectByUpdateMapParams
	paramPtrs          *RepositoryMockUpdateObjectByUpdateMapParamPtrs
	expectationOrigins RepositoryMockUpdateObjectByUpdateMapExpectationOrigins
	results            *RepositoryMockUpdateObjectByUpdateMapResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateObjectByUpdateMapParams contains parameters of the Repository.UpdateObjectByUpdateMap
type RepositoryMockUpdateObjectByUpdateMapParams struct {
	ctx       context.Context
	objUID    types.ObjectUIDType
	updateMap map[string]any
}

// RepositoryMockUpdateObjectByUpdateMapParamPtrs contains pointers to parameters of the Repository.UpdateObjectByUpdateMap
type RepositoryMockUpdateObjectByUpdateMapParamPtrs struct {
	ctx       *context.Context
	objUID    *types.ObjectUIDType
	updateMap *map[string]any
}

// RepositoryMockUpdateObjectByUpdateMapResults contains results of the Repository.UpdateObjectByUpdateMap
type RepositoryMockUpdateObjectByUpdateMapResults struct {
	op1 *mm_repository.ObjectModel
	err error
}

// RepositoryMockUpdateObjectByUpdateMapOrigins contains origins of expectations of the Repository.UpdateObjectByUpdateMap
type RepositoryMockUpdateObjectByUpdateMapExpectationOrigins struct {
	origin          string
	originCtx       string
	originObjUID    string
	originUpdateMap string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateObjectByUpdateMap *mRepositoryMockUpdateObjectByUpdateMap) Optional() *mRepositoryMockUpdateObjectByUpdateMap {
	mmUpdateObjectByUpdateMap.optional = true
	return mmUpdateObjectByUpdateMap
}

// Expect sets up expected params for Repository.UpdateObjectByUpdateMap
func (mmUpdateObjectByUpdateMap *mRepositoryMockUpdateObjectByUpdateMap) Expect(ctx context.Context, objUID types.ObjectUIDType, updateMap map[string]any) *mRepositoryMockUpdateObjectByUpdateMap {
	if mmUpdateObjectByUpdateMap.mock.funcUpdateObjectByUpdateMap != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateObjectByUpdateMap mock is already set by Set")
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation == nil {
		mmUpdateObjectByUpdateMap.defaultExpectation = &RepositoryMockUpdateObjectByUpdateMapExpectation{}
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateObjectByUpdateMap mock is already set by ExpectParams functions")
	}

	mmUpdateObjectByUpdateMap.defaultExpectation.params = &RepositoryMockUpdateObjectByUpdateMapParams{ctx, objUID, updateMap}
	mmUpdateObjectByUpdateMap.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateObjectByUpdateMap.expectations {
		if minimock.Equal(e.params, mmUpdateObjectByUpdateMap.defaultExpectation.params) {
			mmUpdateObjectByUpdateMap.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateObjectByUpdateMap.defaultExpectation.params)
		}
	}

	return mmUpdateObjectByUpdateMap
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateObjectByUpdateMap
func (mmUpdateObjectByUpdateMap *mRepositoryMockUpdateObjectByUpdateMap) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateObjectByUpdateMap {
	if mmUpdateObjectByUpdateMap.mock.funcUpdateObjectByUpdateMap != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateObjectByUpdateMap mock is already set by Set")
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation == nil {
		mmUpdateObjectByUpdateMap.defaultExpectation = &RepositoryMockUpdateObjectByUpdateMapExpectation{}
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation.params != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateObjectByUpdateMap mock is already set by Expect")
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs == nil {
		mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs = &RepositoryMockUpdateObjectByUpdateMapParamPtrs{}
	}
	mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateObjectByUpdateMap.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateObjectByUpdateMap
}

// ExpectObjUIDParam2 sets up expected param objUID for Repository.UpdateObjectByUpdateMap
func (mmUpdateObjectByUpdateMap *mRepositoryMockUpdateObjectByUpdateMap) ExpectObjUIDParam2(objUID types.ObjectUIDType) *mRepositoryMockUpdateObjectByUpdateMap {
	if mmUpdateObjectByUpdateMap.mock.funcUpdateObjectByUpdateMap != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateObjectByUpdateMap mock is already set by Set")
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation == nil {
		mmUpdateObjectByUpdateMap.defaultExpectation = &RepositoryMockUpdateObjectByUpdateMapExpectation{}
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation.params != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateObjectByUpdateMap mock is already set by Expect")
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs == nil {
		mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs = &RepositoryMockUpdateObjectByUpdateMapParamPtrs{}
	}
	mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs.objUID = &objUID
	mmUpdateObjectByUpdateMap.defaultExpectation.expectationOrigins.originObjUID = minimock.CallerInfo(1)

	return mmUpdateObjectByUpdateMap
}

// ExpectUpdateMapParam3 sets up expected param updateMap for Repository.UpdateObjectByUpdateMap
func (mmUpdateObjectByUpdateMap *mRepositoryMockUpdateObjectByUpdateMap) ExpectUpdateMapParam3(updateMap map[string]any) *mRepositoryMockUpdateObjectByUpdateMap {
	if mmUpdateObjectByUpdateMap.mock.funcUpdateObjectByUpdateMap != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateObjectByUpdateMap mock is already set by Set")
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation == nil {
		mmUpdateObjectByUpdateMap.defaultExpectation = &RepositoryMockUpdateObjectByUpdateMapExpectation{}
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation.params != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateObjectByUpdateMap mock is already set by Expect")
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs == nil {
		mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs = &RepositoryMockUpdateObjectByUpdateMapParamPtrs{}
	}
	mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs.updateMap = &updateMap
	mmUpdateObjectByUpdateMap.defaultExpectation.expectationOrigins.originUpdateMap = minimock.CallerInfo(1)

	return mmUpdateObjectByUpdateMap
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateObjectByUpdateMap
func (mmUpdateObjectByUpdateMap *mRepositoryMockUpdateObjectByUpdateMap) Inspect(f func(ctx context.Context, objUID types.ObjectUIDType, updateMap map[string]any)) *mRepositoryMockUpdateObjectByUpdateMap {
	if mmUpdateObjectByUpdateMap.mock.inspectFuncUpdateObjectByUpdateMap != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateObjectByUpdateMap")
	}

	mmUpdateObjectByUpdateMap.mock.inspectFuncUpdateObjectByUpdateMap = f

	return mmUpdateObjectByUpdateMap
}

// Return sets up results that will be returned by Repository.UpdateObjectByUpdateMap
func (mmUpdateObjectByUpdateMap *mRepositoryMockUpdateObjectByUpdateMap) Return(op1 *mm_repository.ObjectModel, err error) *RepositoryMock {
	if mmUpdateObjectByUpdateMap.mock.funcUpdateObjectByUpdateMap != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateObjectByUpdateMap mock is already set by Set")
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation == nil {
		mmUpdateObjectByUpdateMap.defaultExpectation = &RepositoryMockUpdateObjectByUpdateMapExpectation{mock: mmUpdateObjectByUpdateMap.mock}
	}
	mmUpdateObjectByUpdateMap.defaultExpectation.results = &RepositoryMockUpdateObjectByUpdateMapResults{op1, err}
	mmUpdateObjectByUpdateMap.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateObjectByUpdateMap.mock
}

// Set uses given function f to mock the Repository.UpdateObjectByUpdateMap method
func (mmUpdateObjectByUpdateMap *mRepositoryMockUpdateObjectByUpdateMap) Set(f func(ctx context.Context, objUID types.ObjectUIDType, updateMap map[string]any) (op1 *mm_repository.ObjectModel, err error)) *RepositoryMock {
	if mmUpdateObjectByUpdateMap.defaultExpectation != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateObjectByUpdateMap method")
	}

	if len(mmUpdateObjectByUpdateMap.expectations) > 0 {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateObjectByUpdateMap method")
	}

	mmUpdateObjectByUpdateMap.mock.funcUpdateObjectByUpdateMap = f
	mmUpdateObjectByUpdateMap.mock.funcUpdateObjectByUpdateMapOrigin = minimock.CallerInfo(1)
	return mmUpdateObjectByUpdateMap.mock
}

// When sets expectation for the Repository.UpdateObjectByUpdateMap which will trigger the result defined by the following
// Then helper
func (mmUpdateObjectByUpdateMap *mRepositoryMockUpdateObjectByUpdateMap) When(ctx context.Context, objUID types.ObjectUIDType, updateMap map[string]any) *RepositoryMockUpdateObjectByUpdateMapExpectation {
	if mmUpdateObjectByUpdateMap.mock.funcUpdateObjectByUpdateMap != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateObjectByUpdateMap mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateObjectByUpdateMapExpectation{
		mock:               mmUpdateObjectByUpdateMap.mock,
		params:             &RepositoryMockUpdateObjectByUpdateMapParams{ctx, objUID, updateMap},
		expectationOrigins: RepositoryMockUpdateObjectByUpdateMapExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateObjectByUpdateMap.expectations = append(mmUpdateObjectByUpdateMap.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateObjectByUpdateMap return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateObjectByUpdateMapExpectation) Then(op1 *mm_repository.ObjectModel, err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateObjectByUpdateMapResults{op1, err}
	return e.mock
}

// Times sets number of times Repository.UpdateObjectByUpdateMap should be invoked
func (mmUpdateObjectByUpdateMap *mRepositoryMockUpdateObjectByUpdateMap) Times(n uint64) *mRepositoryMockUpdateObjectByUpdateMap {
	if n == 0 {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("Times of RepositoryMock.UpdateObjectByUpdateMap mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateObjectByUpdateMap.expectedInvocations, n)
	mmUpdateObjectByUpdateMap.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateObjectByUpdateMap
}

func (mmUpdateObjectByUpdateMap *mRepositoryMockUpdateObjectByUpdateMap) invocationsDone() bool {
	if len(mmUpdateObjectByUpdateMap.expectations) == 0 && mmUpdateObjectByUpdateMap.defaultExpectation == nil && mmUpdateObjectByUpdateMap.mock.funcUpdateObjectByUpdateMap == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateObjectByUpdateMap.mock.afterUpdateObjectByUpdateMapCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateObjectByUpdateMap.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateObjectByUpdateMap implements mm_repository.Repository
func (mmUpdateObjectByUpdateMap *RepositoryMock) UpdateObjectByUpdateMap(ctx context.Context, objUID types.ObjectUIDType, updateMap map[string]any) (op1 *mm_repository.ObjectModel, err error) {
	mm_atomic.AddUint64(&mmUpdateObjectByUpdateMap.beforeUpdateObjectByUpdateMapCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateObjectByUpdateMap.afterUpdateObjectByUpdateMapCounter, 1)

	mmUpdateObjectByUpdateMap.t.Helper()

	if mmUpdateObjectByUpdateMap.inspectFuncUpdateObjectByUpdateMap != nil {
		mmUpdateObjectByUpdateMap.inspectFuncUpdateObjectByUpdateMap(ctx, objUID, updateMap)
	}

	mm_params := RepositoryMockUpdateObjectByUpdateMapParams{ctx, objUID, updateMap}

	// Record call args
	mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.mutex.Lock()
	mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.callArgs = append(mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.callArgs, &mm_params)
	mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.mutex.Unlock()

	for _, e := range mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateObjectByUpdateMapParams{ctx, objUID, updateMap}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateObjectByUpdateMap.t.Errorf("RepositoryMock.UpdateObjectByUpdateMap got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objUID != nil && !minimock.Equal(*mm_want_ptrs.objUID, mm_got.objUID) {
				mmUpdateObjectByUpdateMap.t.Errorf("RepositoryMock.UpdateObjectByUpdateMap got unexpected parameter objUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.defaultExpectation.expectationOrigins.originObjUID, *mm_want_ptrs.objUID, mm_got.objUID, minimock.Diff(*mm_want_ptrs.objUID, mm_got.objUID))
			}

			if mm_want_ptrs.updateMap != nil && !minimock.Equal(*mm_want_ptrs.updateMap, mm_got.updateMap) {
				mmUpdateObjectByUpdateMap.t.Errorf("RepositoryMock.UpdateObjectByUpdateMap got unexpected parameter updateMap, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.defaultExpectation.expectationOrigins.originUpdateMap, *mm_want_ptrs.updateMap, mm_got.updateMap, minimock.Diff(*mm_want_ptrs.updateMap, mm_got.updateMap))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateObjectByUpdateMap.t.Errorf("RepositoryMock.UpdateObjectByUpdateMap got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateObjectByUpdateMap.t.Fatal("No results are set for the RepositoryMock.UpdateObjectByUpdateMap")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmUpdateObjectByUpdateMap.funcUpdateObjectByUpdateMap != nil {
		return mmUpdateObjectByUpdateMap.funcUpdateObjectByUpdateMap(ctx, objUID, updateMap)
	}
	mmUpdateObjectByUpdateMap.t.Fatalf("Unexpected call to RepositoryMock.UpdateObjectByUpdateMap. %v %v %v", ctx, objUID, updateMap)
	return
}

// UpdateObjectByUpdateMapAfterCounter returns a count of finished RepositoryMock.UpdateObjectByUpdateMap invocations
func (mmUpdateObjectByUpdateMap *RepositoryMock) UpdateObjectByUpdateMapAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateObjectByUpdateMap.afterUpdateObjectByUpdateMapCounter)
}

// UpdateObjectByUpdateMapBeforeCounter returns a count of RepositoryMock.UpdateObjectByUpdateMap invocations
func (mmUpdateObjectByUpdateMap *RepositoryMock) UpdateObjectByUpdateMapBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateObjectByUpdateMap.beforeUpdateObjectByUpdateMapCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateObjectByUpdateMap.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateObjectByUpdateMap *mRepositoryMockUpdateObjectByUpdateMap) Calls() []*RepositoryMockUpdateObjectByUpdateMapParams {
	mmUpdateObjectByUpdateMap.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateObjectByUpdateMapParams, len(mmUpdateObjectByUpdateMap.callArgs))
	copy(argCopy, mmUpdateObjectByUpdateMap.callArgs)

	mmUpdateObjectByUpdateMap.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateObjectByUpdateMapDone returns true if the count of the UpdateObjectByUpdateMap invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateObjectByUpdateMapDone() bool {
	if m.UpdateObjectByUpdateMapMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateObjectByUpdateMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateObjectByUpdateMapMock.invocationsDone()
}

// MinimockUpdateObjectByUpdateMapInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateObjectByUpdateMapInspect() {
	for _, e := range m.UpdateObjectByUpdateMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateObjectByUpdateMap at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateObjectByUpdateMapCounter := mm_atomic.LoadUint64(&m.afterUpdateObjectByUpdateMapCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateObjectByUpdateMapMock.defaultExpectation != nil && afterUpdateObjectByUpdateMapCounter < 1 {
		if m.UpdateObjectByUpdateMapMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateObjectByUpdateMap at\n%s", m.UpdateObjectByUpdateMapMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateObjectByUpdateMap at\n%s with params: %#v", m.UpdateObjectByUpdateMapMock.defaultExpectation.expectationOrigins.origin, *m.UpdateObjectByUpdateMapMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateObjectByUpdateMap != nil && afterUpdateObjectByUpdateMapCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateObjectByUpdateMap at\n%s", m.funcUpdateObjectByUpdateMapOrigin)
	}

	if !m.UpdateObjectByUpdateMapMock.invocationsDone() && afterUpdateObjectByUpdateMapCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateObjectByUpdateMap at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateObjectByUpdateMapMock.expectedInvocations), m.UpdateObjectByUpdateMapMock.expectedInvocationsOrigin, afterUpdateObjectByUpdateMapCounter)
	}
}

type mRepositoryMockUpdateSystem struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateSystemExpectation
	expectations       []*RepositoryMockUpdateSystemExpectation

	callArgs []*RepositoryMockUpdateSystemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateSystemExpectation specifies expectation struct of the Repository.UpdateSystem
type RepositoryMockUpdateSystemExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateSystemParams
	paramPtrs          *RepositoryMockUpdateSystemParamPtrs
	expectationOrigins RepositoryMockUpdateSystemExpectationOrigins
	results            *RepositoryMockUpdateSystemResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateSystemParams contains parameters of the Repository.UpdateSystem
type RepositoryMockUpdateSystemParams struct {
	ctx         context.Context
	id          string
	config      map[string]any
	description string
}

// RepositoryMockUpdateSystemParamPtrs contains pointers to parameters of the Repository.UpdateSystem
type RepositoryMockUpdateSystemParamPtrs struct {
	ctx         *context.Context
	id          *string
	config      *map[string]any
	description *string
}

// RepositoryMockUpdateSystemResults contains results of the Repository.UpdateSystem
type RepositoryMockUpdateSystemResults struct {
	err error
}

// RepositoryMockUpdateSystemOrigins contains origins of expectations of the Repository.UpdateSystem
type RepositoryMockUpdateSystemExpectationOrigins struct {
	origin            string
	originCtx         string
	originId          string
	originConfig      string
	originDescription string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateSystem *mRepositoryMockUpdateSystem) Optional() *mRepositoryMockUpdateSystem {
	mmUpdateSystem.optional = true
	return mmUpdateSystem
}

// Expect sets up expected params for Repository.UpdateSystem
func (mmUpdateSystem *mRepositoryMockUpdateSystem) Expect(ctx context.Context, id string, config map[string]any, description string) *mRepositoryMockUpdateSystem {
	if mmUpdateSystem.mock.funcUpdateSystem != nil {
		mmUpdateSystem.mock.t.Fatalf("RepositoryMock.UpdateSystem mock is already set by Set")
	}

	if mmUpdateSystem.defaultExpectation == nil {
		mmUpdateSystem.defaultExpectation = &RepositoryMockUpdateSystemExpectation{}
	}

	if mmUpdateSystem.defaultExpectation.paramPtrs != nil {
		mmUpdateSystem.mock.t.Fatalf("RepositoryMock.UpdateSystem mock is already set by ExpectParams functions")
	}

	mmUpdateSystem.defaultExpectation.params = &RepositoryMockUpdateSystemParams{ctx, id, config, description}
	mmUpdateSystem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateSystem.expectations {
		if minimock.Equal(e.params, mmUpdateSystem.defaultExpectation.params) {
			mmUpdateSystem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateSystem.defaultExpectation.params)
		}
	}

	return mmUpdateSystem
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateSystem
func (mmUpdateSystem *mRepositoryMockUpdateSystem) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateSystem {
	if mmUpdateSystem.mock.funcUpdateSystem != nil {
		mmUpdateSystem.mock.t.Fatalf("RepositoryMock.UpdateSystem mock is already set by Set")
	}

	if mmUpdateSystem.defaultExpectation == nil {
		mmUpdateSystem.defaultExpectation = &RepositoryMockUpdateSystemExpectation{}
	}

	if mmUpdateSystem.defaultExpectation.params != nil {
		mmUpdateSystem.mock.t.Fatalf("RepositoryMock.UpdateSystem mock is already set by Expect")
	}

	if mmUpdateSystem.defaultExpectation.paramPtrs == nil {
		mmUpdateSystem.defaultExpectation.paramPtrs = &RepositoryMockUpdateSystemParamPtrs{}
	}
	mmUpdateSystem.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateSystem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateSystem
}

// ExpectIdParam2 sets up expected param id for Repository.UpdateSystem
func (mmUpdateSystem *mRepositoryMockUpdateSystem) ExpectIdParam2(id string) *mRepositoryMockUpdateSystem {
	if mmUpdateSystem.mock.funcUpdateSystem != nil {
		mmUpdateSystem.mock.t.Fatalf("RepositoryMock.UpdateSystem mock is already set by Set")
	}

	if mmUpdateSystem.defaultExpectation == nil {
		mmUpdateSystem.defaultExpectation = &RepositoryMockUpdateSystemExpectation{}
	}

	if mmUpdateSystem.defaultExpectation.params != nil {
		mmUpdateSystem.mock.t.Fatalf("RepositoryMock.UpdateSystem mock is already set by Expect")
	}

	if mmUpdateSystem.defaultExpectation.paramPtrs == nil {
		mmUpdateSystem.defaultExpectation.paramPtrs = &RepositoryMockUpdateSystemParamPtrs{}
	}
	mmUpdateSystem.defaultExpectation.paramPtrs.id = &id
	mmUpdateSystem.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdateSystem
}

// ExpectConfigParam3 sets up expected param config for Repository.UpdateSystem
func (mmUpdateSystem *mRepositoryMockUpdateSystem) ExpectConfigParam3(config map[string]any) *mRepositoryMockUpdateSystem {
	if mmUpdateSystem.mock.funcUpdateSystem != nil {
		mmUpdateSystem.mock.t.Fatalf("RepositoryMock.UpdateSystem mock is already set by Set")
	}

	if mmUpdateSystem.defaultExpectation == nil {
		mmUpdateSystem.defaultExpectation = &RepositoryMockUpdateSystemExpectation{}
	}

	if mmUpdateSystem.defaultExpectation.params != nil {
		mmUpdateSystem.mock.t.Fatalf("RepositoryMock.UpdateSystem mock is already set by Expect")
	}

	if mmUpdateSystem.defaultExpectation.paramPtrs == nil {
		mmUpdateSystem.defaultExpectation.paramPtrs = &RepositoryMockUpdateSystemParamPtrs{}
	}
	mmUpdateSystem.defaultExpectation.paramPtrs.config = &config
	mmUpdateSystem.defaultExpectation.expectationOrigins.originConfig = minimock.CallerInfo(1)

	return mmUpdateSystem
}

// ExpectDescriptionParam4 sets up expected param description for Repository.UpdateSystem
func (mmUpdateSystem *mRepositoryMockUpdateSystem) ExpectDescriptionParam4(description string) *mRepositoryMockUpdateSystem {
	if mmUpdateSystem.mock.funcUpdateSystem != nil {
		mmUpdateSystem.mock.t.Fatalf("RepositoryMock.UpdateSystem mock is already set by Set")
	}

	if mmUpdateSystem.defaultExpectation == nil {
		mmUpdateSystem.defaultExpectation = &RepositoryMockUpdateSystemExpectation{}
	}

	if mmUpdateSystem.defaultExpectation.params != nil {
		mmUpdateSystem.mock.t.Fatalf("RepositoryMock.UpdateSystem mock is already set by Expect")
	}

	if mmUpdateSystem.defaultExpectation.paramPtrs == nil {
		mmUpdateSystem.defaultExpectation.paramPtrs = &RepositoryMockUpdateSystemParamPtrs{}
	}
	mmUpdateSystem.defaultExpectation.paramPtrs.description = &description
	mmUpdateSystem.defaultExpectation.expectationOrigins.originDescription = minimock.CallerInfo(1)

	return mmUpdateSystem
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateSystem
func (mmUpdateSystem *mRepositoryMockUpdateSystem) Inspect(f func(ctx context.Context, id string, config map[string]any, description string)) *mRepositoryMockUpdateSystem {
	if mmUpdateSystem.mock.inspectFuncUpdateSystem != nil {
		mmUpdateSystem.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateSystem")
	}

	mmUpdateSystem.mock.inspectFuncUpdateSystem = f

	return mmUpdateSystem
}

// Return sets up results that will be returned by Repository.UpdateSystem
func (mmUpdateSystem *mRepositoryMockUpdateSystem) Return(err error) *RepositoryMock {
	if mmUpdateSystem.mock.funcUpdateSystem != nil {
		mmUpdateSystem.mock.t.Fatalf("RepositoryMock.UpdateSystem mock is already set by Set")
	}

	if mmUpdateSystem.defaultExpectation == nil {
		mmUpdateSystem.defaultExpectation = &RepositoryMockUpdateSystemExpectation{mock: mmUpdateSystem.mock}
	}
	mmUpdateSystem.defaultExpectation.results = &RepositoryMockUpdateSystemResults{err}
	mmUpdateSystem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateSystem.mock
}

// Set uses given function f to mock the Repository.UpdateSystem method
func (mmUpdateSystem *mRepositoryMockUpdateSystem) Set(f func(ctx context.Context, id string, config map[string]any, description string) (err error)) *RepositoryMock {
	if mmUpdateSystem.defaultExpectation != nil {
		mmUpdateSystem.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateSystem method")
	}

	if len(mmUpdateSystem.expectations) > 0 {
		mmUpdateSystem.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateSystem method")
	}

	mmUpdateSystem.mock.funcUpdateSystem = f
	mmUpdateSystem.mock.funcUpdateSystemOrigin = minimock.CallerInfo(1)
	return mmUpdateSystem.mock
}

// When sets expectation for the Repository.UpdateSystem which will trigger the result defined by the following
// Then helper
func (mmUpdateSystem *mRepositoryMockUpdateSystem) When(ctx context.Context, id string, config map[string]any, description string) *RepositoryMockUpdateSystemExpectation {
	if mmUpdateSystem.mock.funcUpdateSystem != nil {
		mmUpdateSystem.mock.t.Fatalf("RepositoryMock.UpdateSystem mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateSystemExpectation{
		mock:               mmUpdateSystem.mock,
		params:             &RepositoryMockUpdateSystemParams{ctx, id, config, description},
		expectationOrigins: RepositoryMockUpdateSystemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateSystem.expectations = append(mmUpdateSystem.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateSystem return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateSystemExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateSystemResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateSystem should be invoked
func (mmUpdateSystem *mRepositoryMockUpdateSystem) Times(n uint64) *mRepositoryMockUpdateSystem {
	if n == 0 {
		mmUpdateSystem.mock.t.Fatalf("Times of RepositoryMock.UpdateSystem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateSystem.expectedInvocations, n)
	mmUpdateSystem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateSystem
}

func (mmUpdateSystem *mRepositoryMockUpdateSystem) invocationsDone() bool {
	if len(mmUpdateSystem.expectations) == 0 && mmUpdateSystem.defaultExpectation == nil && mmUpdateSystem.mock.funcUpdateSystem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateSystem.mock.afterUpdateSystemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateSystem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateSystem implements mm_repository.Repository
func (mmUpdateSystem *RepositoryMock) UpdateSystem(ctx context.Context, id string, config map[string]any, description string) (err error) {
	mm_atomic.AddUint64(&mmUpdateSystem.beforeUpdateSystemCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateSystem.afterUpdateSystemCounter, 1)

	mmUpdateSystem.t.Helper()

	if mmUpdateSystem.inspectFuncUpdateSystem != nil {
		mmUpdateSystem.inspectFuncUpdateSystem(ctx, id, config, description)
	}

	mm_params := RepositoryMockUpdateSystemParams{ctx, id, config, description}

	// Record call args
	mmUpdateSystem.UpdateSystemMock.mutex.Lock()
	mmUpdateSystem.UpdateSystemMock.callArgs = append(mmUpdateSystem.UpdateSystemMock.callArgs, &mm_params)
	mmUpdateSystem.UpdateSystemMock.mutex.Unlock()

	for _, e := range mmUpdateSystem.UpdateSystemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateSystem.UpdateSystemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateSystem.UpdateSystemMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateSystem.UpdateSystemMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateSystem.UpdateSystemMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateSystemParams{ctx, id, config, description}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateSystem.t.Errorf("RepositoryMock.UpdateSystem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateSystem.UpdateSystemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateSystem.t.Errorf("RepositoryMock.UpdateSystem got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateSystem.UpdateSystemMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.config != nil && !minimock.Equal(*mm_want_ptrs.config, mm_got.config) {
				mmUpdateSystem.t.Errorf("RepositoryMock.UpdateSystem got unexpected parameter config, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateSystem.UpdateSystemMock.defaultExpectation.expectationOrigins.originConfig, *mm_want_ptrs.config, mm_got.config, minimock.Diff(*mm_want_ptrs.config, mm_got.config))
			}

			if mm_want_ptrs.description != nil && !minimock.Equal(*mm_want_ptrs.description, mm_got.description) {
				mmUpdateSystem.t.Errorf("RepositoryMock.UpdateSystem got unexpected parameter description, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateSystem.UpdateSystemMock.defaultExpectation.expectationOrigins.originDescription, *mm_want_ptrs.description, mm_got.description, minimock.Diff(*mm_want_ptrs.description, mm_got.description))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateSystem.t.Errorf("RepositoryMock.UpdateSystem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateSystem.UpdateSystemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateSystem.UpdateSystemMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateSystem.t.Fatal("No results are set for the RepositoryMock.UpdateSystem")
		}
		return (*mm_results).err
	}
	if mmUpdateSystem.funcUpdateSystem != nil {
		return mmUpdateSystem.funcUpdateSystem(ctx, id, config, description)
	}
	mmUpdateSystem.t.Fatalf("Unexpected call to RepositoryMock.UpdateSystem. %v %v %v %v", ctx, id, config, description)
	return
}

// UpdateSystemAfterCounter returns a count of finished RepositoryMock.UpdateSystem invocations
func (mmUpdateSystem *RepositoryMock) UpdateSystemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateSystem.afterUpdateSystemCounter)
}

// UpdateSystemBeforeCounter returns a count of RepositoryMock.UpdateSystem invocations
func (mmUpdateSystem *RepositoryMock) UpdateSystemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateSystem.beforeUpdateSystemCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateSystem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateSystem *mRepositoryMockUpdateSystem) Calls() []*RepositoryMockUpdateSystemParams {
	mmUpdateSystem.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateSystemParams, len(mmUpdateSystem.callArgs))
	copy(argCopy, mmUpdateSystem.callArgs)

	mmUpdateSystem.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateSystemDone returns true if the count of the UpdateSystem invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateSystemDone() bool {
	if m.UpdateSystemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateSystemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateSystemMock.invocationsDone()
}

// MinimockUpdateSystemInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateSystemInspect() {
	for _, e := range m.UpdateSystemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateSystem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateSystemCounter := mm_atomic.LoadUint64(&m.afterUpdateSystemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateSystemMock.defaultExpectation != nil && afterUpdateSystemCounter < 1 {
		if m.UpdateSystemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateSystem at\n%s", m.UpdateSystemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateSystem at\n%s with params: %#v", m.UpdateSystemMock.defaultExpectation.expectationOrigins.origin, *m.UpdateSystemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateSystem != nil && afterUpdateSystemCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateSystem at\n%s", m.funcUpdateSystemOrigin)
	}

	if !m.UpdateSystemMock.invocationsDone() && afterUpdateSystemCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateSystem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateSystemMock.expectedInvocations), m.UpdateSystemMock.expectedInvocationsOrigin, afterUpdateSystemCounter)
	}
}

type mRepositoryMockUpdateSystemByUpdateMap struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateSystemByUpdateMapExpectation
	expectations       []*RepositoryMockUpdateSystemByUpdateMapExpectation

	callArgs []*RepositoryMockUpdateSystemByUpdateMapParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateSystemByUpdateMapExpectation specifies expectation struct of the Repository.UpdateSystemByUpdateMap
type RepositoryMockUpdateSystemByUpdateMapExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateSystemByUpdateMapParams
	paramPtrs          *RepositoryMockUpdateSystemByUpdateMapParamPtrs
	expectationOrigins RepositoryMockUpdateSystemByUpdateMapExpectationOrigins
	results            *RepositoryMockUpdateSystemByUpdateMapResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateSystemByUpdateMapParams contains parameters of the Repository.UpdateSystemByUpdateMap
type RepositoryMockUpdateSystemByUpdateMapParams struct {
	ctx          context.Context
	id           string
	updateFields map[string]interface{}
}

// RepositoryMockUpdateSystemByUpdateMapParamPtrs contains pointers to parameters of the Repository.UpdateSystemByUpdateMap
type RepositoryMockUpdateSystemByUpdateMapParamPtrs struct {
	ctx          *context.Context
	id           *string
	updateFields *map[string]interface{}
}

// RepositoryMockUpdateSystemByUpdateMapResults contains results of the Repository.UpdateSystemByUpdateMap
type RepositoryMockUpdateSystemByUpdateMapResults struct {
	err error
}

// RepositoryMockUpdateSystemByUpdateMapOrigins contains origins of expectations of the Repository.UpdateSystemByUpdateMap
type RepositoryMockUpdateSystemByUpdateMapExpectationOrigins struct {
	origin             string
	originCtx          string
	originId           string
	originUpdateFields string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateSystemByUpdateMap *mRepositoryMockUpdateSystemByUpdateMap) Optional() *mRepositoryMockUpdateSystemByUpdateMap {
	mmUpdateSystemByUpdateMap.optional = true
	return mmUpdateSystemByUpdateMap
}

// Expect sets up expected params for Repository.UpdateSystemByUpdateMap
func (mmUpdateSystemByUpdateMap *mRepositoryMockUpdateSystemByUpdateMap) Expect(ctx context.Context, id string, updateFields map[string]interface{}) *mRepositoryMockUpdateSystemByUpdateMap {
	if mmUpdateSystemByUpdateMap.mock.funcUpdateSystemByUpdateMap != nil {
		mmUpdateSystemByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateSystemByUpdateMap mock is already set by Set")
	}

	if mmUpdateSystemByUpdateMap.defaultExpectation == nil {
		mmUpdateSystemByUpdateMap.defaultExpectation = &RepositoryMockUpdateSystemByUpdateMapExpectation{}
	}

	if mmUpdateSystemByUpdateMap.defaultExpectation.paramPtrs != nil {
		mmUpdateSystemByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateSystemByUpdateMap mock is already set by ExpectParams functions")
	}

	mmUpdateSystemByUpdateMap.defaultExpectation.params = &RepositoryMockUpdateSystemByUpdateMapParams{ctx, id, updateFields}
	mmUpdateSystemByUpdateMap.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateSystemByUpdateMap.expectations {
		if minimock.Equal(e.params, mmUpdateSystemByUpdateMap.defaultExpectation.params) {
			mmUpdateSystemByUpdateMap.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateSystemByUpdateMap.defaultExpectation.params)
		}
	}

	return mmUpdateSystemByUpdateMap
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateSystemByUpdateMap
func (mmUpdateSystemByUpdateMap *mRepositoryMockUpdateSystemByUpdateMap) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateSystemByUpdateMap {
	if mmUpdateSystemByUpdateMap.mock.funcUpdateSystemByUpdateMap != nil {
		mmUpdateSystemByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateSystemByUpdateMap mock is already set by Set")
	}

	if mmUpdateSystemByUpdateMap.defaultExpectation == nil {
		mmUpdateSystemByUpdateMap.defaultExpectation = &RepositoryMockUpdateSystemByUpdateMapExpectation{}
	}

	if mmUpdateSystemByUpdateMap.defaultExpectation.params != nil {
		mmUpdateSystemByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateSystemByUpdateMap mock is already set by Expect")
	}

	if mmUpdateSystemByUpdateMap.defaultExpectation.paramPtrs == nil {
		mmUpdateSystemByUpdateMap.defaultExpectation.paramPtrs = &RepositoryMockUpdateSystemByUpdateMapParamPtrs{}
	}
	mmUpdateSystemByUpdateMap.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateSystemByUpdateMap.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateSystemByUpdateMap
}

// ExpectIdParam2 sets up expected param id for Repository.UpdateSystemByUpdateMap
func (mmUpdateSystemByUpdateMap *mRepositoryMockUpdateSystemByUpdateMap) ExpectIdParam2(id string) *mRepositoryMockUpdateSystemByUpdateMap {
	if mmUpdateSystemByUpdateMap.mock.funcUpdateSystemByUpdateMap != nil {
		mmUpdateSystemByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateSystemByUpdateMap mock is already set by Set")
	}

	if mmUpdateSystemByUpdateMap.defaultExpectation == nil {
		mmUpdateSystemByUpdateMap.defaultExpectation = &RepositoryMockUpdateSystemByUpdateMapExpectation{}
	}

	if mmUpdateSystemByUpdateMap.defaultExpectation.params != nil {
		mmUpdateSystemByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateSystemByUpdateMap mock is already set by Expect")
	}

	if mmUpdateSystemByUpdateMap.defaultExpectation.paramPtrs == nil {
		mmUpdateSystemByUpdateMap.defaultExpectation.paramPtrs = &RepositoryMockUpdateSystemByUpdateMapParamPtrs{}
	}
	mmUpdateSystemByUpdateMap.defaultExpectation.paramPtrs.id = &id
	mmUpdateSystemByUpdateMap.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdateSystemByUpdateMap
}

// ExpectUpdateFieldsParam3 sets up expected param updateFields for Repository.UpdateSystemByUpdateMap
func (mmUpdateSystemByUpdateMap *mRepositoryMockUpdateSystemByUpdateMap) ExpectUpdateFieldsParam3(updateFields map[string]interface{}) *mRepositoryMockUpdateSystemByUpdateMap {
	if mmUpdateSystemByUpdateMap.mock.funcUpdateSystemByUpdateMap != nil {
		mmUpdateSystemByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateSystemByUpdateMap mock is already set by Set")
	}

	if mmUpdateSystemByUpdateMap.defaultExpectation == nil {
		mmUpdateSystemByUpdateMap.defaultExpectation = &RepositoryMockUpdateSystemByUpdateMapExpectation{}
	}

	if mmUpdateSystemByUpdateMap.defaultExpectation.params != nil {
		mmUpdateSystemByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateSystemByUpdateMap mock is already set by Expect")
	}

	if mmUpdateSystemByUpdateMap.defaultExpectation.paramPtrs == nil {
		mmUpdateSystemByUpdateMap.defaultExpectation.paramPtrs = &RepositoryMockUpdateSystemByUpdateMapParamPtrs{}
	}
	mmUpdateSystemByUpdateMap.defaultExpectation.paramPtrs.updateFields = &updateFields
	mmUpdateSystemByUpdateMap.defaultExpectation.expectationOrigins.originUpdateFields = minimock.CallerInfo(1)

	return mmUpdateSystemByUpdateMap
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateSystemByUpdateMap
func (mmUpdateSystemByUpdateMap *mRepositoryMockUpdateSystemByUpdateMap) Inspect(f func(ctx context.Context, id string, updateFields map[string]interface{})) *mRepositoryMockUpdateSystemByUpdateMap {
	if mmUpdateSystemByUpdateMap.mock.inspectFuncUpdateSystemByUpdateMap != nil {
		mmUpdateSystemByUpdateMap.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateSystemByUpdateMap")
	}

	mmUpdateSystemByUpdateMap.mock.inspectFuncUpdateSystemByUpdateMap = f

	return mmUpdateSystemByUpdateMap
}

// Return sets up results that will be returned by Repository.UpdateSystemByUpdateMap
func (mmUpdateSystemByUpdateMap *mRepositoryMockUpdateSystemByUpdateMap) Return(err error) *RepositoryMock {
	if mmUpdateSystemByUpdateMap.mock.funcUpdateSystemByUpdateMap != nil {
		mmUpdateSystemByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateSystemByUpdateMap mock is already set by Set")
	}

	if mmUpdateSystemByUpdateMap.defaultExpectation == nil {
		mmUpdateSystemByUpdateMap.defaultExpectation = &RepositoryMockUpdateSystemByUpdateMapExpectation{mock: mmUpdateSystemByUpdateMap.mock}
	}
	mmUpdateSystemByUpdateMap.defaultExpectation.results = &RepositoryMockUpdateSystemByUpdateMapResults{err}
	mmUpdateSystemByUpdateMap.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateSystemByUpdateMap.mock
}

// Set uses given function f to mock the Repository.UpdateSystemByUpdateMap method
func (mmUpdateSystemByUpdateMap *mRepositoryMockUpdateSystemByUpdateMap) Set(f func(ctx context.Context, id string, updateFields map[string]interface{}) (err error)) *RepositoryMock {
	if mmUpdateSystemByUpdateMap.defaultExpectation != nil {
		mmUpdateSystemByUpdateMap.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateSystemByUpdateMap method")
	}

	if len(mmUpdateSystemByUpdateMap.expectations) > 0 {
		mmUpdateSystemByUpdateMap.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateSystemByUpdateMap method")
	}

	mmUpdateSystemByUpdateMap.mock.funcUpdateSystemByUpdateMap = f
	mmUpdateSystemByUpdateMap.mock.funcUpdateSystemByUpdateMapOrigin = minimock.CallerInfo(1)
	return mmUpdateSystemByUpdateMap.mock
}

// When sets expectation for the Repository.UpdateSystemByUpdateMap which will trigger the result defined by the following
// Then helper
func (mmUpdateSystemByUpdateMap *mRepositoryMockUpdateSystemByUpdateMap) When(ctx context.Context, id string, updateFields map[string]interface{}) *RepositoryMockUpdateSystemByUpdateMapExpectation {
	if mmUpdateSystemByUpdateMap.mock.funcUpdateSystemByUpdateMap != nil {
		mmUpdateSystemByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateSystemByUpdateMap mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateSystemByUpdateMapExpectation{
		mock:               mmUpdateSystemByUpdateMap.mock,
		params:             &RepositoryMockUpdateSystemByUpdateMapParams{ctx, id, updateFields},
		expectationOrigins: RepositoryMockUpdateSystemByUpdateMapExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateSystemByUpdateMap.expectations = append(mmUpdateSystemByUpdateMap.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateSystemByUpdateMap return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateSystemByUpdateMapExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateSystemByUpdateMapResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateSystemByUpdateMap should be invoked
func (mmUpdateSystemByUpdateMap *mRepositoryMockUpdateSystemByUpdateMap) Times(n uint64) *mRepositoryMockUpdateSystemByUpdateMap {
	if n == 0 {
		mmUpdateSystemByUpdateMap.mock.t.Fatalf("Times of RepositoryMock.UpdateSystemByUpdateMap mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateSystemByUpdateMap.expectedInvocations, n)
	mmUpdateSystemByUpdateMap.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateSystemByUpdateMap
}

func (mmUpdateSystemByUpdateMap *mRepositoryMockUpdateSystemByUpdateMap) invocationsDone() bool {
	if len(mmUpdateSystemByUpdateMap.expectations) == 0 && mmUpdateSystemByUpdateMap.defaultExpectation == nil && mmUpdateSystemByUpdateMap.mock.funcUpdateSystemByUpdateMap == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateSystemByUpdateMap.mock.afterUpdateSystemByUpdateMapCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateSystemByUpdateMap.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateSystemByUpdateMap implements mm_repository.Repository
func (mmUpdateSystemByUpdateMap *RepositoryMock) UpdateSystemByUpdateMap(ctx context.Context, id string, updateFields map[string]interface{}) (err error) {
	mm_atomic.AddUint64(&mmUpdateSystemByUpdateMap.beforeUpdateSystemByUpdateMapCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateSystemByUpdateMap.afterUpdateSystemByUpdateMapCounter, 1)

	mmUpdateSystemByUpdateMap.t.Helper()

	if mmUpdateSystemByUpdateMap.inspectFuncUpdateSystemByUpdateMap != nil {
		mmUpdateSystemByUpdateMap.inspectFuncUpdateSystemByUpdateMap(ctx, id, updateFields)
	}

	mm_params := RepositoryMockUpdateSystemByUpdateMapParams{ctx, id, updateFields}

	// Record call args
	mmUpdateSystemByUpdateMap.UpdateSystemByUpdateMapMock.mutex.Lock()
	mmUpdateSystemByUpdateMap.UpdateSystemByUpdateMapMock.callArgs = append(mmUpdateSystemByUpdateMap.UpdateSystemByUpdateMapMock.callArgs, &mm_params)
	mmUpdateSystemByUpdateMap.UpdateSystemByUpdateMapMock.mutex.Unlock()

	for _, e := range mmUpdateSystemByUpdateMap.UpdateSystemByUpdateMapMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateSystemByUpdateMap.UpdateSystemByUpdateMapMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateSystemByUpdateMap.UpdateSystemByUpdateMapMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateSystemByUpdateMap.UpdateSystemByUpdateMapMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateSystemByUpdateMap.UpdateSystemByUpdateMapMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateSystemByUpdateMapParams{ctx, id, updateFields}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateSystemByUpdateMap.t.Errorf("RepositoryMock.UpdateSystemByUpdateMap got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateSystemByUpdateMap.UpdateSystemByUpdateMapMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateSystemByUpdateMap.t.Errorf("RepositoryMock.UpdateSystemByUpdateMap got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateSystemByUpdateMap.UpdateSystemByUpdateMapMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.updateFields != nil && !minimock.Equal(*mm_want_ptrs.updateFields, mm_got.updateFields) {
				mmUpdateSystemByUpdateMap.t.Errorf("RepositoryMock.UpdateSystemByUpdateMap got unexpected parameter updateFields, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateSystemByUpdateMap.UpdateSystemByUpdateMapMock.defaultExpectation.expectationOrigins.originUpdateFields, *mm_want_ptrs.updateFields, mm_got.updateFields, minimock.Diff(*mm_want_ptrs.updateFields, mm_got.updateFields))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateSystemByUpdateMap.t.Errorf("RepositoryMock.UpdateSystemByUpdateMap got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateSystemByUpdateMap.UpdateSystemByUpdateMapMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateSystemByUpdateMap.UpdateSystemByUpdateMapMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateSystemByUpdateMap.t.Fatal("No results are set for the RepositoryMock.UpdateSystemByUpdateMap")
		}
		return (*mm_results).err
	}
	if mmUpdateSystemByUpdateMap.funcUpdateSystemByUpdateMap != nil {
		return mmUpdateSystemByUpdateMap.funcUpdateSystemByUpdateMap(ctx, id, updateFields)
	}
	mmUpdateSystemByUpdateMap.t.Fatalf("Unexpected call to RepositoryMock.UpdateSystemByUpdateMap. %v %v %v", ctx, id, updateFields)
	return
}

// UpdateSystemByUpdateMapAfterCounter returns a count of finished RepositoryMock.UpdateSystemByUpdateMap invocations
func (mmUpdateSystemByUpdateMap *RepositoryMock) UpdateSystemByUpdateMapAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateSystemByUpdateMap.afterUpdateSystemByUpdateMapCounter)
}

// UpdateSystemByUpdateMapBeforeCounter returns a count of RepositoryMock.UpdateSystemByUpdateMap invocations
func (mmUpdateSystemByUpdateMap *RepositoryMock) UpdateSystemByUpdateMapBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateSystemByUpdateMap.beforeUpdateSystemByUpdateMapCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateSystemByUpdateMap.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateSystemByUpdateMap *mRepositoryMockUpdateSystemByUpdateMap) Calls() []*RepositoryMockUpdateSystemByUpdateMapParams {
	mmUpdateSystemByUpdateMap.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateSystemByUpdateMapParams, len(mmUpdateSystemByUpdateMap.callArgs))
	copy(argCopy, mmUpdateSystemByUpdateMap.callArgs)

	mmUpdateSystemByUpdateMap.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateSystemByUpdateMapDone returns true if the count of the UpdateSystemByUpdateMap invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateSystemByUpdateMapDone() bool {
	if m.UpdateSystemByUpdateMapMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateSystemByUpdateMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateSystemByUpdateMapMock.invocationsDone()
}

// MinimockUpdateSystemByUpdateMapInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateSystemByUpdateMapInspect() {
	for _, e := range m.UpdateSystemByUpdateMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateSystemByUpdateMap at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateSystemByUpdateMapCounter := mm_atomic.LoadUint64(&m.afterUpdateSystemByUpdateMapCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateSystemByUpdateMapMock.defaultExpectation != nil && afterUpdateSystemByUpdateMapCounter < 1 {
		if m.UpdateSystemByUpdateMapMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateSystemByUpdateMap at\n%s", m.UpdateSystemByUpdateMapMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateSystemByUpdateMap at\n%s with params: %#v", m.UpdateSystemByUpdateMapMock.defaultExpectation.expectationOrigins.origin, *m.UpdateSystemByUpdateMapMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateSystemByUpdateMap != nil && afterUpdateSystemByUpdateMapCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateSystemByUpdateMap at\n%s", m.funcUpdateSystemByUpdateMapOrigin)
	}

	if !m.UpdateSystemByUpdateMapMock.invocationsDone() && afterUpdateSystemByUpdateMapCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateSystemByUpdateMap at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateSystemByUpdateMapMock.expectedInvocations), m.UpdateSystemByUpdateMapMock.expectedInvocationsOrigin, afterUpdateSystemByUpdateMapCounter)
	}
}

type mRepositoryMockUpdateTextChunk struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateTextChunkExpectation
	expectations       []*RepositoryMockUpdateTextChunkExpectation

	callArgs []*RepositoryMockUpdateTextChunkParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateTextChunkExpectation specifies expectation struct of the Repository.UpdateTextChunk
type RepositoryMockUpdateTextChunkExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateTextChunkParams
	paramPtrs          *RepositoryMockUpdateTextChunkParamPtrs
	expectationOrigins RepositoryMockUpdateTextChunkExpectationOrigins
	results            *RepositoryMockUpdateTextChunkResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateTextChunkParams contains parameters of the Repository.UpdateTextChunk
type RepositoryMockUpdateTextChunkParams struct {
	ctx      context.Context
	chunkUID string
	updates  map[string]any
}

// RepositoryMockUpdateTextChunkParamPtrs contains pointers to parameters of the Repository.UpdateTextChunk
type RepositoryMockUpdateTextChunkParamPtrs struct {
	ctx      *context.Context
	chunkUID *string
	updates  *map[string]any
}

// RepositoryMockUpdateTextChunkResults contains results of the Repository.UpdateTextChunk
type RepositoryMockUpdateTextChunkResults struct {
	tp1 *mm_repository.TextChunkModel
	err error
}

// RepositoryMockUpdateTextChunkOrigins contains origins of expectations of the Repository.UpdateTextChunk
type RepositoryMockUpdateTextChunkExpectationOrigins struct {
	origin         string
	originCtx      string
	originChunkUID string
	originUpdates  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateTextChunk *mRepositoryMockUpdateTextChunk) Optional() *mRepositoryMockUpdateTextChunk {
	mmUpdateTextChunk.optional = true
	return mmUpdateTextChunk
}

// Expect sets up expected params for Repository.UpdateTextChunk
func (mmUpdateTextChunk *mRepositoryMockUpdateTextChunk) Expect(ctx context.Context, chunkUID string, updates map[string]any) *mRepositoryMockUpdateTextChunk {
	if mmUpdateTextChunk.mock.funcUpdateTextChunk != nil {
		mmUpdateTextChunk.mock.t.Fatalf("RepositoryMock.UpdateTextChunk mock is already set by Set")
	}

	if mmUpdateTextChunk.defaultExpectation == nil {
		mmUpdateTextChunk.defaultExpectation = &RepositoryMockUpdateTextChunkExpectation{}
	}

	if mmUpdateTextChunk.defaultExpectation.paramPtrs != nil {
		mmUpdateTextChunk.mock.t.Fatalf("RepositoryMock.UpdateTextChunk mock is already set by ExpectParams functions")
	}

	mmUpdateTextChunk.defaultExpectation.params = &RepositoryMockUpdateTextChunkParams{ctx, chunkUID, updates}
	mmUpdateTextChunk.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateTextChunk.expectations {
		if minimock.Equal(e.params, mmUpdateTextChunk.defaultExpectation.params) {
			mmUpdateTextChunk.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateTextChunk.defaultExpectation.params)
		}
	}

	return mmUpdateTextChunk
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateTextChunk
func (mmUpdateTextChunk *mRepositoryMockUpdateTextChunk) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateTextChunk {
	if mmUpdateTextChunk.mock.funcUpdateTextChunk != nil {
		mmUpdateTextChunk.mock.t.Fatalf("RepositoryMock.UpdateTextChunk mock is already set by Set")
	}

	if mmUpdateTextChunk.defaultExpectation == nil {
		mmUpdateTextChunk.defaultExpectation = &RepositoryMockUpdateTextChunkExpectation{}
	}

	if mmUpdateTextChunk.defaultExpectation.params != nil {
		mmUpdateTextChunk.mock.t.Fatalf("RepositoryMock.UpdateTextChunk mock is already set by Expect")
	}

	if mmUpdateTextChunk.defaultExpectation.paramPtrs == nil {
		mmUpdateTextChunk.defaultExpectation.paramPtrs = &RepositoryMockUpdateTextChunkParamPtrs{}
	}
	mmUpdateTextChunk.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateTextChunk.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateTextChunk
}

// ExpectChunkUIDParam2 sets up expected param chunkUID for Repository.UpdateTextChunk
func (mmUpdateTextChunk *mRepositoryMockUpdateTextChunk) ExpectChunkUIDParam2(chunkUID string) *mRepositoryMockUpdateTextChunk {
	if mmUpdateTextChunk.mock.funcUpdateTextChunk != nil {
		mmUpdateTextChunk.mock.t.Fatalf("RepositoryMock.UpdateTextChunk mock is already set by Set")
	}

	if mmUpdateTextChunk.defaultExpectation == nil {
		mmUpdateTextChunk.defaultExpectation = &RepositoryMockUpdateTextChunkExpectation{}
	}

	if mmUpdateTextChunk.defaultExpectation.params != nil {
		mmUpdateTextChunk.mock.t.Fatalf("RepositoryMock.UpdateTextChunk mock is already set by Expect")
	}

	if mmUpdateTextChunk.defaultExpectation.paramPtrs == nil {
		mmUpdateTextChunk.defaultExpectation.paramPtrs = &RepositoryMockUpdateTextChunkParamPtrs{}
	}
	mmUpdateTextChunk.defaultExpectation.paramPtrs.chunkUID = &chunkUID
	mmUpdateTextChunk.defaultExpectation.expectationOrigins.originChunkUID = minimock.CallerInfo(1)

	return mmUpdateTextChunk
}

// ExpectUpdatesParam3 sets up expected param updates for Repository.UpdateTextChunk
func (mmUpdateTextChunk *mRepositoryMockUpdateTextChunk) ExpectUpdatesParam3(updates map[string]any) *mRepositoryMockUpdateTextChunk {
	if mmUpdateTextChunk.mock.funcUpdateTextChunk != nil {
		mmUpdateTextChunk.mock.t.Fatalf("RepositoryMock.UpdateTextChunk mock is already set by Set")
	}

	if mmUpdateTextChunk.defaultExpectation == nil {
		mmUpdateTextChunk.defaultExpectation = &RepositoryMockUpdateTextChunkExpectation{}
	}

	if mmUpdateTextChunk.defaultExpectation.params != nil {
		mmUpdateTextChunk.mock.t.Fatalf("RepositoryMock.UpdateTextChunk mock is already set by Expect")
	}

	if mmUpdateTextChunk.defaultExpectation.paramPtrs == nil {
		mmUpdateTextChunk.defaultExpectation.paramPtrs = &RepositoryMockUpdateTextChunkParamPtrs{}
	}
	mmUpdateTextChunk.defaultExpectation.paramPtrs.updates = &updates
	mmUpdateTextChunk.defaultExpectation.expectationOrigins.originUpdates = minimock.CallerInfo(1)

	return mmUpdateTextChunk
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateTextChunk
func (mmUpdateTextChunk *mRepositoryMockUpdateTextChunk) Inspect(f func(ctx context.Context, chunkUID string, updates map[string]any)) *mRepositoryMockUpdateTextChunk {
	if mmUpdateTextChunk.mock.inspectFuncUpdateTextChunk != nil {
		mmUpdateTextChunk.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateTextChunk")
	}

	mmUpdateTextChunk.mock.inspectFuncUpdateTextChunk = f

	return mmUpdateTextChunk
}

// Return sets up results that will be returned by Repository.UpdateTextChunk
func (mmUpdateTextChunk *mRepositoryMockUpdateTextChunk) Return(tp1 *mm_repository.TextChunkModel, err error) *RepositoryMock {
	if mmUpdateTextChunk.mock.funcUpdateTextChunk != nil {
		mmUpdateTextChunk.mock.t.Fatalf("RepositoryMock.UpdateTextChunk mock is already set by Set")
	}

	if mmUpdateTextChunk.defaultExpectation == nil {
		mmUpdateTextChunk.defaultExpectation = &RepositoryMockUpdateTextChunkExpectation{mock: mmUpdateTextChunk.mock}
	}
	mmUpdateTextChunk.defaultExpectation.results = &RepositoryMockUpdateTextChunkResults{tp1, err}
	mmUpdateTextChunk.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateTextChunk.mock
}

// Set uses given function f to mock the Repository.UpdateTextChunk method
func (mmUpdateTextChunk *mRepositoryMockUpdateTextChunk) Set(f func(ctx context.Context, chunkUID string, updates map[string]any) (tp1 *mm_repository.TextChunkModel, err error)) *RepositoryMock {
	if mmUpdateTextChunk.defaultExpectation != nil {
		mmUpdateTextChunk.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateTextChunk method")
	}

	if len(mmUpdateTextChunk.expectations) > 0 {
		mmUpdateTextChunk.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateTextChunk method")
	}

	mmUpdateTextChunk.mock.funcUpdateTextChunk = f
	mmUpdateTextChunk.mock.funcUpdateTextChunkOrigin = minimock.CallerInfo(1)
	return mmUpdateTextChunk.mock
}

// When sets expectation for the Repository.UpdateTextChunk which will trigger the result defined by the following
// Then helper
func (mmUpdateTextChunk *mRepositoryMockUpdateTextChunk) When(ctx context.Context, chunkUID string, updates map[string]any) *RepositoryMockUpdateTextChunkExpectation {
	if mmUpdateTextChunk.mock.funcUpdateTextChunk != nil {
		mmUpdateTextChunk.mock.t.Fatalf("RepositoryMock.UpdateTextChunk mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateTextChunkExpectation{
		mock:               mmUpdateTextChunk.mock,
		params:             &RepositoryMockUpdateTextChunkParams{ctx, chunkUID, updates},
		expectationOrigins: RepositoryMockUpdateTextChunkExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateTextChunk.expectations = append(mmUpdateTextChunk.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateTextChunk return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateTextChunkExpectation) Then(tp1 *mm_repository.TextChunkModel, err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateTextChunkResults{tp1, err}
	return e.mock
}

// Times sets number of times Repository.UpdateTextChunk should be invoked
func (mmUpdateTextChunk *mRepositoryMockUpdateTextChunk) Times(n uint64) *mRepositoryMockUpdateTextChunk {
	if n == 0 {
		mmUpdateTextChunk.mock.t.Fatalf("Times of RepositoryMock.UpdateTextChunk mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateTextChunk.expectedInvocations, n)
	mmUpdateTextChunk.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateTextChunk
}

func (mmUpdateTextChunk *mRepositoryMockUpdateTextChunk) invocationsDone() bool {
	if len(mmUpdateTextChunk.expectations) == 0 && mmUpdateTextChunk.defaultExpectation == nil && mmUpdateTextChunk.mock.funcUpdateTextChunk == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateTextChunk.mock.afterUpdateTextChunkCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateTextChunk.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateTextChunk implements mm_repository.Repository
func (mmUpdateTextChunk *RepositoryMock) UpdateTextChunk(ctx context.Context, chunkUID string, updates map[string]any) (tp1 *mm_repository.TextChunkModel, err error) {
	mm_atomic.AddUint64(&mmUpdateTextChunk.beforeUpdateTextChunkCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateTextChunk.afterUpdateTextChunkCounter, 1)

	mmUpdateTextChunk.t.Helper()

	if mmUpdateTextChunk.inspectFuncUpdateTextChunk != nil {
		mmUpdateTextChunk.inspectFuncUpdateTextChunk(ctx, chunkUID, updates)
	}

	mm_params := RepositoryMockUpdateTextChunkParams{ctx, chunkUID, updates}

	// Record call args
	mmUpdateTextChunk.UpdateTextChunkMock.mutex.Lock()
	mmUpdateTextChunk.UpdateTextChunkMock.callArgs = append(mmUpdateTextChunk.UpdateTextChunkMock.callArgs, &mm_params)
	mmUpdateTextChunk.UpdateTextChunkMock.mutex.Unlock()

	for _, e := range mmUpdateTextChunk.UpdateTextChunkMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp1, e.results.err
		}
	}

	if mmUpdateTextChunk.UpdateTextChunkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateTextChunk.UpdateTextChunkMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateTextChunk.UpdateTextChunkMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateTextChunk.UpdateTextChunkMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateTextChunkParams{ctx, chunkUID, updates}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateTextChunk.t.Errorf("RepositoryMock.UpdateTextChunk got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateTextChunk.UpdateTextChunkMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chunkUID != nil && !minimock.Equal(*mm_want_ptrs.chunkUID, mm_got.chunkUID) {
				mmUpdateTextChunk.t.Errorf("RepositoryMock.UpdateTextChunk got unexpected parameter chunkUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateTextChunk.UpdateTextChunkMock.defaultExpectation.expectationOrigins.originChunkUID, *mm_want_ptrs.chunkUID, mm_got.chunkUID, minimock.Diff(*mm_want_ptrs.chunkUID, mm_got.chunkUID))
			}

			if mm_want_ptrs.updates != nil && !minimock.Equal(*mm_want_ptrs.updates, mm_got.updates) {
				mmUpdateTextChunk.t.Errorf("RepositoryMock.UpdateTextChunk got unexpected parameter updates, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateTextChunk.UpdateTextChunkMock.defaultExpectation.expectationOrigins.originUpdates, *mm_want_ptrs.updates, mm_got.updates, minimock.Diff(*mm_want_ptrs.updates, mm_got.updates))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateTextChunk.t.Errorf("RepositoryMock.UpdateTextChunk got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateTextChunk.UpdateTextChunkMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateTextChunk.UpdateTextChunkMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateTextChunk.t.Fatal("No results are set for the RepositoryMock.UpdateTextChunk")
		}
		return (*mm_results).tp1, (*mm_results).err
	}
	if mmUpdateTextChunk.funcUpdateTextChunk != nil {
		return mmUpdateTextChunk.funcUpdateTextChunk(ctx, chunkUID, updates)
	}
	mmUpdateTextChunk.t.Fatalf("Unexpected call to RepositoryMock.UpdateTextChunk. %v %v %v", ctx, chunkUID, updates)
	return
}

// UpdateTextChunkAfterCounter returns a count of finished RepositoryMock.UpdateTextChunk invocations
func (mmUpdateTextChunk *RepositoryMock) UpdateTextChunkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateTextChunk.afterUpdateTextChunkCounter)
}

// UpdateTextChunkBeforeCounter returns a count of RepositoryMock.UpdateTextChunk invocations
func (mmUpdateTextChunk *RepositoryMock) UpdateTextChunkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateTextChunk.beforeUpdateTextChunkCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateTextChunk.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateTextChunk *mRepositoryMockUpdateTextChunk) Calls() []*RepositoryMockUpdateTextChunkParams {
	mmUpdateTextChunk.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateTextChunkParams, len(mmUpdateTextChunk.callArgs))
	copy(argCopy, mmUpdateTextChunk.callArgs)

	mmUpdateTextChunk.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateTextChunkDone returns true if the count of the UpdateTextChunk invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateTextChunkDone() bool {
	if m.UpdateTextChunkMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateTextChunkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateTextChunkMock.invocationsDone()
}

// MinimockUpdateTextChunkInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateTextChunkInspect() {
	for _, e := range m.UpdateTextChunkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateTextChunk at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateTextChunkCounter := mm_atomic.LoadUint64(&m.afterUpdateTextChunkCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateTextChunkMock.defaultExpectation != nil && afterUpdateTextChunkCounter < 1 {
		if m.UpdateTextChunkMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateTextChunk at\n%s", m.UpdateTextChunkMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateTextChunk at\n%s with params: %#v", m.UpdateTextChunkMock.defaultExpectation.expectationOrigins.origin, *m.UpdateTextChunkMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateTextChunk != nil && afterUpdateTextChunkCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateTextChunk at\n%s", m.funcUpdateTextChunkOrigin)
	}

	if !m.UpdateTextChunkMock.invocationsDone() && afterUpdateTextChunkCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateTextChunk at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateTextChunkMock.expectedInvocations), m.UpdateTextChunkMock.expectedInvocationsOrigin, afterUpdateTextChunkCounter)
	}
}

type mRepositoryMockUpdateTextChunkDestinations struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateTextChunkDestinationsExpectation
	expectations       []*RepositoryMockUpdateTextChunkDestinationsExpectation

	callArgs []*RepositoryMockUpdateTextChunkDestinationsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateTextChunkDestinationsExpectation specifies expectation struct of the Repository.UpdateTextChunkDestinations
type RepositoryMockUpdateTextChunkDestinationsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateTextChunkDestinationsParams
	paramPtrs          *RepositoryMockUpdateTextChunkDestinationsParamPtrs
	expectationOrigins RepositoryMockUpdateTextChunkDestinationsExpectationOrigins
	results            *RepositoryMockUpdateTextChunkDestinationsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateTextChunkDestinationsParams contains parameters of the Repository.UpdateTextChunkDestinations
type RepositoryMockUpdateTextChunkDestinationsParams struct {
	ctx          context.Context
	destinations map[string]string
}

// RepositoryMockUpdateTextChunkDestinationsParamPtrs contains pointers to parameters of the Repository.UpdateTextChunkDestinations
type RepositoryMockUpdateTextChunkDestinationsParamPtrs struct {
	ctx          *context.Context
	destinations *map[string]string
}

// RepositoryMockUpdateTextChunkDestinationsResults contains results of the Repository.UpdateTextChunkDestinations
type RepositoryMockUpdateTextChunkDestinationsResults struct {
	err error
}

// RepositoryMockUpdateTextChunkDestinationsOrigins contains origins of expectations of the Repository.UpdateTextChunkDestinations
type RepositoryMockUpdateTextChunkDestinationsExpectationOrigins struct {
	origin             string
	originCtx          string
	originDestinations string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateTextChunkDestinations *mRepositoryMockUpdateTextChunkDestinations) Optional() *mRepositoryMockUpdateTextChunkDestinations {
	mmUpdateTextChunkDestinations.optional = true
	return mmUpdateTextChunkDestinations
}

// Expect sets up expected params for Repository.UpdateTextChunkDestinations
func (mmUpdateTextChunkDestinations *mRepositoryMockUpdateTextChunkDestinations) Expect(ctx context.Context, destinations map[string]string) *mRepositoryMockUpdateTextChunkDestinations {
	if mmUpdateTextChunkDestinations.mock.funcUpdateTextChunkDestinations != nil {
		mmUpdateTextChunkDestinations.mock.t.Fatalf("RepositoryMock.UpdateTextChunkDestinations mock is already set by Set")
	}

	if mmUpdateTextChunkDestinations.defaultExpectation == nil {
		mmUpdateTextChunkDestinations.defaultExpectation = &RepositoryMockUpdateTextChunkDestinationsExpectation{}
	}

	if mmUpdateTextChunkDestinations.defaultExpectation.paramPtrs != nil {
		mmUpdateTextChunkDestinations.mock.t.Fatalf("RepositoryMock.UpdateTextChunkDestinations mock is already set by ExpectParams functions")
	}

	mmUpdateTextChunkDestinations.defaultExpectation.params = &RepositoryMockUpdateTextChunkDestinationsParams{ctx, destinations}
	mmUpdateTextChunkDestinations.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateTextChunkDestinations.expectations {
		if minimock.Equal(e.params, mmUpdateTextChunkDestinations.defaultExpectation.params) {
			mmUpdateTextChunkDestinations.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateTextChunkDestinations.defaultExpectation.params)
		}
	}

	return mmUpdateTextChunkDestinations
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateTextChunkDestinations
func (mmUpdateTextChunkDestinations *mRepositoryMockUpdateTextChunkDestinations) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateTextChunkDestinations {
	if mmUpdateTextChunkDestinations.mock.funcUpdateTextChunkDestinations != nil {
		mmUpdateTextChunkDestinations.mock.t.Fatalf("RepositoryMock.UpdateTextChunkDestinations mock is already set by Set")
	}

	if mmUpdateTextChunkDestinations.defaultExpectation == nil {
		mmUpdateTextChunkDestinations.defaultExpectation = &RepositoryMockUpdateTextChunkDestinationsExpectation{}
	}

	if mmUpdateTextChunkDestinations.defaultExpectation.params != nil {
		mmUpdateTextChunkDestinations.mock.t.Fatalf("RepositoryMock.UpdateTextChunkDestinations mock is already set by Expect")
	}

	if mmUpdateTextChunkDestinations.defaultExpectation.paramPtrs == nil {
		mmUpdateTextChunkDestinations.defaultExpectation.paramPtrs = &RepositoryMockUpdateTextChunkDestinationsParamPtrs{}
	}
	mmUpdateTextChunkDestinations.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateTextChunkDestinations.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateTextChunkDestinations
}

// ExpectDestinationsParam2 sets up expected param destinations for Repository.UpdateTextChunkDestinations
func (mmUpdateTextChunkDestinations *mRepositoryMockUpdateTextChunkDestinations) ExpectDestinationsParam2(destinations map[string]string) *mRepositoryMockUpdateTextChunkDestinations {
	if mmUpdateTextChunkDestinations.mock.funcUpdateTextChunkDestinations != nil {
		mmUpdateTextChunkDestinations.mock.t.Fatalf("RepositoryMock.UpdateTextChunkDestinations mock is already set by Set")
	}

	if mmUpdateTextChunkDestinations.defaultExpectation == nil {
		mmUpdateTextChunkDestinations.defaultExpectation = &RepositoryMockUpdateTextChunkDestinationsExpectation{}
	}

	if mmUpdateTextChunkDestinations.defaultExpectation.params != nil {
		mmUpdateTextChunkDestinations.mock.t.Fatalf("RepositoryMock.UpdateTextChunkDestinations mock is already set by Expect")
	}

	if mmUpdateTextChunkDestinations.defaultExpectation.paramPtrs == nil {
		mmUpdateTextChunkDestinations.defaultExpectation.paramPtrs = &RepositoryMockUpdateTextChunkDestinationsParamPtrs{}
	}
	mmUpdateTextChunkDestinations.defaultExpectation.paramPtrs.destinations = &destinations
	mmUpdateTextChunkDestinations.defaultExpectation.expectationOrigins.originDestinations = minimock.CallerInfo(1)

	return mmUpdateTextChunkDestinations
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateTextChunkDestinations
func (mmUpdateTextChunkDestinations *mRepositoryMockUpdateTextChunkDestinations) Inspect(f func(ctx context.Context, destinations map[string]string)) *mRepositoryMockUpdateTextChunkDestinations {
	if mmUpdateTextChunkDestinations.mock.inspectFuncUpdateTextChunkDestinations != nil {
		mmUpdateTextChunkDestinations.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateTextChunkDestinations")
	}

	mmUpdateTextChunkDestinations.mock.inspectFuncUpdateTextChunkDestinations = f

	return mmUpdateTextChunkDestinations
}

// Return sets up results that will be returned by Repository.UpdateTextChunkDestinations
func (mmUpdateTextChunkDestinations *mRepositoryMockUpdateTextChunkDestinations) Return(err error) *RepositoryMock {
	if mmUpdateTextChunkDestinations.mock.funcUpdateTextChunkDestinations != nil {
		mmUpdateTextChunkDestinations.mock.t.Fatalf("RepositoryMock.UpdateTextChunkDestinations mock is already set by Set")
	}

	if mmUpdateTextChunkDestinations.defaultExpectation == nil {
		mmUpdateTextChunkDestinations.defaultExpectation = &RepositoryMockUpdateTextChunkDestinationsExpectation{mock: mmUpdateTextChunkDestinations.mock}
	}
	mmUpdateTextChunkDestinations.defaultExpectation.results = &RepositoryMockUpdateTextChunkDestinationsResults{err}
	mmUpdateTextChunkDestinations.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateTextChunkDestinations.mock
}

// Set uses given function f to mock the Repository.UpdateTextChunkDestinations method
func (mmUpdateTextChunkDestinations *mRepositoryMockUpdateTextChunkDestinations) Set(f func(ctx context.Context, destinations map[string]string) (err error)) *RepositoryMock {
	if mmUpdateTextChunkDestinations.defaultExpectation != nil {
		mmUpdateTextChunkDestinations.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateTextChunkDestinations method")
	}

	if len(mmUpdateTextChunkDestinations.expectations) > 0 {
		mmUpdateTextChunkDestinations.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateTextChunkDestinations method")
	}

	mmUpdateTextChunkDestinations.mock.funcUpdateTextChunkDestinations = f
	mmUpdateTextChunkDestinations.mock.funcUpdateTextChunkDestinationsOrigin = minimock.CallerInfo(1)
	return mmUpdateTextChunkDestinations.mock
}

// When sets expectation for the Repository.UpdateTextChunkDestinations which will trigger the result defined by the following
// Then helper
func (mmUpdateTextChunkDestinations *mRepositoryMockUpdateTextChunkDestinations) When(ctx context.Context, destinations map[string]string) *RepositoryMockUpdateTextChunkDestinationsExpectation {
	if mmUpdateTextChunkDestinations.mock.funcUpdateTextChunkDestinations != nil {
		mmUpdateTextChunkDestinations.mock.t.Fatalf("RepositoryMock.UpdateTextChunkDestinations mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateTextChunkDestinationsExpectation{
		mock:               mmUpdateTextChunkDestinations.mock,
		params:             &RepositoryMockUpdateTextChunkDestinationsParams{ctx, destinations},
		expectationOrigins: RepositoryMockUpdateTextChunkDestinationsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateTextChunkDestinations.expectations = append(mmUpdateTextChunkDestinations.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateTextChunkDestinations return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateTextChunkDestinationsExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateTextChunkDestinationsResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateTextChunkDestinations should be invoked
func (mmUpdateTextChunkDestinations *mRepositoryMockUpdateTextChunkDestinations) Times(n uint64) *mRepositoryMockUpdateTextChunkDestinations {
	if n == 0 {
		mmUpdateTextChunkDestinations.mock.t.Fatalf("Times of RepositoryMock.UpdateTextChunkDestinations mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateTextChunkDestinations.expectedInvocations, n)
	mmUpdateTextChunkDestinations.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateTextChunkDestinations
}

func (mmUpdateTextChunkDestinations *mRepositoryMockUpdateTextChunkDestinations) invocationsDone() bool {
	if len(mmUpdateTextChunkDestinations.expectations) == 0 && mmUpdateTextChunkDestinations.defaultExpectation == nil && mmUpdateTextChunkDestinations.mock.funcUpdateTextChunkDestinations == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateTextChunkDestinations.mock.afterUpdateTextChunkDestinationsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateTextChunkDestinations.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateTextChunkDestinations implements mm_repository.Repository
func (mmUpdateTextChunkDestinations *RepositoryMock) UpdateTextChunkDestinations(ctx context.Context, destinations map[string]string) (err error) {
	mm_atomic.AddUint64(&mmUpdateTextChunkDestinations.beforeUpdateTextChunkDestinationsCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateTextChunkDestinations.afterUpdateTextChunkDestinationsCounter, 1)

	mmUpdateTextChunkDestinations.t.Helper()

	if mmUpdateTextChunkDestinations.inspectFuncUpdateTextChunkDestinations != nil {
		mmUpdateTextChunkDestinations.inspectFuncUpdateTextChunkDestinations(ctx, destinations)
	}

	mm_params := RepositoryMockUpdateTextChunkDestinationsParams{ctx, destinations}

	// Record call args
	mmUpdateTextChunkDestinations.UpdateTextChunkDestinationsMock.mutex.Lock()
	mmUpdateTextChunkDestinations.UpdateTextChunkDestinationsMock.callArgs = append(mmUpdateTextChunkDestinations.UpdateTextChunkDestinationsMock.callArgs, &mm_params)
	mmUpdateTextChunkDestinations.UpdateTextChunkDestinationsMock.mutex.Unlock()

	for _, e := range mmUpdateTextChunkDestinations.UpdateTextChunkDestinationsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateTextChunkDestinations.UpdateTextChunkDestinationsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateTextChunkDestinations.UpdateTextChunkDestinationsMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateTextChunkDestinations.UpdateTextChunkDestinationsMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateTextChunkDestinations.UpdateTextChunkDestinationsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateTextChunkDestinationsParams{ctx, destinations}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateTextChunkDestinations.t.Errorf("RepositoryMock.UpdateTextChunkDestinations got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateTextChunkDestinations.UpdateTextChunkDestinationsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.destinations != nil && !minimock.Equal(*mm_want_ptrs.destinations, mm_got.destinations) {
				mmUpdateTextChunkDestinations.t.Errorf("RepositoryMock.UpdateTextChunkDestinations got unexpected parameter destinations, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateTextChunkDestinations.UpdateTextChunkDestinationsMock.defaultExpectation.expectationOrigins.originDestinations, *mm_want_ptrs.destinations, mm_got.destinations, minimock.Diff(*mm_want_ptrs.destinations, mm_got.destinations))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateTextChunkDestinations.t.Errorf("RepositoryMock.UpdateTextChunkDestinations got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateTextChunkDestinations.UpdateTextChunkDestinationsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateTextChunkDestinations.UpdateTextChunkDestinationsMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateTextChunkDestinations.t.Fatal("No results are set for the RepositoryMock.UpdateTextChunkDestinations")
		}
		return (*mm_results).err
	}
	if mmUpdateTextChunkDestinations.funcUpdateTextChunkDestinations != nil {
		return mmUpdateTextChunkDestinations.funcUpdateTextChunkDestinations(ctx, destinations)
	}
	mmUpdateTextChunkDestinations.t.Fatalf("Unexpected call to RepositoryMock.UpdateTextChunkDestinations. %v %v", ctx, destinations)
	return
}

// UpdateTextChunkDestinationsAfterCounter returns a count of finished RepositoryMock.UpdateTextChunkDestinations invocations
func (mmUpdateTextChunkDestinations *RepositoryMock) UpdateTextChunkDestinationsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateTextChunkDestinations.afterUpdateTextChunkDestinationsCounter)
}

// UpdateTextChunkDestinationsBeforeCounter returns a count of RepositoryMock.UpdateTextChunkDestinations invocations
func (mmUpdateTextChunkDestinations *RepositoryMock) UpdateTextChunkDestinationsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateTextChunkDestinations.beforeUpdateTextChunkDestinationsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateTextChunkDestinations.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateTextChunkDestinations *mRepositoryMockUpdateTextChunkDestinations) Calls() []*RepositoryMockUpdateTextChunkDestinationsParams {
	mmUpdateTextChunkDestinations.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateTextChunkDestinationsParams, len(mmUpdateTextChunkDestinations.callArgs))
	copy(argCopy, mmUpdateTextChunkDestinations.callArgs)

	mmUpdateTextChunkDestinations.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateTextChunkDestinationsDone returns true if the count of the UpdateTextChunkDestinations invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateTextChunkDestinationsDone() bool {
	if m.UpdateTextChunkDestinationsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateTextChunkDestinationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateTextChunkDestinationsMock.invocationsDone()
}

// MinimockUpdateTextChunkDestinationsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateTextChunkDestinationsInspect() {
	for _, e := range m.UpdateTextChunkDestinationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateTextChunkDestinations at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateTextChunkDestinationsCounter := mm_atomic.LoadUint64(&m.afterUpdateTextChunkDestinationsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateTextChunkDestinationsMock.defaultExpectation != nil && afterUpdateTextChunkDestinationsCounter < 1 {
		if m.UpdateTextChunkDestinationsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateTextChunkDestinations at\n%s", m.UpdateTextChunkDestinationsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateTextChunkDestinations at\n%s with params: %#v", m.UpdateTextChunkDestinationsMock.defaultExpectation.expectationOrigins.origin, *m.UpdateTextChunkDestinationsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateTextChunkDestinations != nil && afterUpdateTextChunkDestinationsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateTextChunkDestinations at\n%s", m.funcUpdateTextChunkDestinationsOrigin)
	}

	if !m.UpdateTextChunkDestinationsMock.invocationsDone() && afterUpdateTextChunkDestinationsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateTextChunkDestinations at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateTextChunkDestinationsMock.expectedInvocations), m.UpdateTextChunkDestinationsMock.expectedInvocationsOrigin, afterUpdateTextChunkDestinationsCounter)
	}
}

type mRepositoryMockUpsertRepositoryTag struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpsertRepositoryTagExpectation
	expectations       []*RepositoryMockUpsertRepositoryTagExpectation

	callArgs []*RepositoryMockUpsertRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpsertRepositoryTagExpectation specifies expectation struct of the Repository.UpsertRepositoryTag
type RepositoryMockUpsertRepositoryTagExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpsertRepositoryTagParams
	paramPtrs          *RepositoryMockUpsertRepositoryTagParamPtrs
	expectationOrigins RepositoryMockUpsertRepositoryTagExpectationOrigins
	results            *RepositoryMockUpsertRepositoryTagResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpsertRepositoryTagParams contains parameters of the Repository.UpsertRepositoryTag
type RepositoryMockUpsertRepositoryTagParams struct {
	ctx context.Context
	tp1 *types.Tag
}

// RepositoryMockUpsertRepositoryTagParamPtrs contains pointers to parameters of the Repository.UpsertRepositoryTag
type RepositoryMockUpsertRepositoryTagParamPtrs struct {
	ctx *context.Context
	tp1 **types.Tag
}

// RepositoryMockUpsertRepositoryTagResults contains results of the Repository.UpsertRepositoryTag
type RepositoryMockUpsertRepositoryTagResults struct {
	tp2 *types.Tag
	err error
}

// RepositoryMockUpsertRepositoryTagOrigins contains origins of expectations of the Repository.UpsertRepositoryTag
type RepositoryMockUpsertRepositoryTagExpectationOrigins struct {
	origin    string
	originCtx string
	originTp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) Optional() *mRepositoryMockUpsertRepositoryTag {
	mmUpsertRepositoryTag.optional = true
	return mmUpsertRepositoryTag
}

// Expect sets up expected params for Repository.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) Expect(ctx context.Context, tp1 *types.Tag) *mRepositoryMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryMockUpsertRepositoryTagExpectation{}
	}

	if mmUpsertRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by ExpectParams functions")
	}

	mmUpsertRepositoryTag.defaultExpectation.params = &RepositoryMockUpsertRepositoryTagParams{ctx, tp1}
	mmUpsertRepositoryTag.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpsertRepositoryTag.expectations {
		if minimock.Equal(e.params, mmUpsertRepositoryTag.defaultExpectation.params) {
			mmUpsertRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertRepositoryTag.defaultExpectation.params)
		}
	}

	return mmUpsertRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryMockUpsertRepositoryTagExpectation{}
	}

	if mmUpsertRepositoryTag.defaultExpectation.params != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by Expect")
	}

	if mmUpsertRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmUpsertRepositoryTag.defaultExpectation.paramPtrs = &RepositoryMockUpsertRepositoryTagParamPtrs{}
	}
	mmUpsertRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpsertRepositoryTag.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpsertRepositoryTag
}

// ExpectTp1Param2 sets up expected param tp1 for Repository.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) ExpectTp1Param2(tp1 *types.Tag) *mRepositoryMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryMockUpsertRepositoryTagExpectation{}
	}

	if mmUpsertRepositoryTag.defaultExpectation.params != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by Expect")
	}

	if mmUpsertRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmUpsertRepositoryTag.defaultExpectation.paramPtrs = &RepositoryMockUpsertRepositoryTagParamPtrs{}
	}
	mmUpsertRepositoryTag.defaultExpectation.paramPtrs.tp1 = &tp1
	mmUpsertRepositoryTag.defaultExpectation.expectationOrigins.originTp1 = minimock.CallerInfo(1)

	return mmUpsertRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) Inspect(f func(ctx context.Context, tp1 *types.Tag)) *mRepositoryMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.inspectFuncUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpsertRepositoryTag")
	}

	mmUpsertRepositoryTag.mock.inspectFuncUpsertRepositoryTag = f

	return mmUpsertRepositoryTag
}

// Return sets up results that will be returned by Repository.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) Return(tp2 *types.Tag, err error) *RepositoryMock {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryMockUpsertRepositoryTagExpectation{mock: mmUpsertRepositoryTag.mock}
	}
	mmUpsertRepositoryTag.defaultExpectation.results = &RepositoryMockUpsertRepositoryTagResults{tp2, err}
	mmUpsertRepositoryTag.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpsertRepositoryTag.mock
}

// Set uses given function f to mock the Repository.UpsertRepositoryTag method
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) Set(f func(ctx context.Context, tp1 *types.Tag) (tp2 *types.Tag, err error)) *RepositoryMock {
	if mmUpsertRepositoryTag.defaultExpectation != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("Default expectation is already set for the Repository.UpsertRepositoryTag method")
	}

	if len(mmUpsertRepositoryTag.expectations) > 0 {
		mmUpsertRepositoryTag.mock.t.Fatalf("Some expectations are already set for the Repository.UpsertRepositoryTag method")
	}

	mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag = f
	mmUpsertRepositoryTag.mock.funcUpsertRepositoryTagOrigin = minimock.CallerInfo(1)
	return mmUpsertRepositoryTag.mock
}

// When sets expectation for the Repository.UpsertRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) When(ctx context.Context, tp1 *types.Tag) *RepositoryMockUpsertRepositoryTagExpectation {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by Set")
	}

	expectation := &RepositoryMockUpsertRepositoryTagExpectation{
		mock:               mmUpsertRepositoryTag.mock,
		params:             &RepositoryMockUpsertRepositoryTagParams{ctx, tp1},
		expectationOrigins: RepositoryMockUpsertRepositoryTagExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpsertRepositoryTag.expectations = append(mmUpsertRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpsertRepositoryTag return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpsertRepositoryTagExpectation) Then(tp2 *types.Tag, err error) *RepositoryMock {
	e.results = &RepositoryMockUpsertRepositoryTagResults{tp2, err}
	return e.mock
}

// Times sets number of times Repository.UpsertRepositoryTag should be invoked
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) Times(n uint64) *mRepositoryMockUpsertRepositoryTag {
	if n == 0 {
		mmUpsertRepositoryTag.mock.t.Fatalf("Times of RepositoryMock.UpsertRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpsertRepositoryTag.expectedInvocations, n)
	mmUpsertRepositoryTag.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpsertRepositoryTag
}

func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) invocationsDone() bool {
	if len(mmUpsertRepositoryTag.expectations) == 0 && mmUpsertRepositoryTag.defaultExpectation == nil && mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpsertRepositoryTag.mock.afterUpsertRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpsertRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpsertRepositoryTag implements mm_repository.Repository
func (mmUpsertRepositoryTag *RepositoryMock) UpsertRepositoryTag(ctx context.Context, tp1 *types.Tag) (tp2 *types.Tag, err error) {
	mm_atomic.AddUint64(&mmUpsertRepositoryTag.beforeUpsertRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertRepositoryTag.afterUpsertRepositoryTagCounter, 1)

	mmUpsertRepositoryTag.t.Helper()

	if mmUpsertRepositoryTag.inspectFuncUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.inspectFuncUpsertRepositoryTag(ctx, tp1)
	}

	mm_params := RepositoryMockUpsertRepositoryTagParams{ctx, tp1}

	// Record call args
	mmUpsertRepositoryTag.UpsertRepositoryTagMock.mutex.Lock()
	mmUpsertRepositoryTag.UpsertRepositoryTagMock.callArgs = append(mmUpsertRepositoryTag.UpsertRepositoryTagMock.callArgs, &mm_params)
	mmUpsertRepositoryTag.UpsertRepositoryTagMock.mutex.Unlock()

	for _, e := range mmUpsertRepositoryTag.UpsertRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp2, e.results.err
		}
	}

	if mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpsertRepositoryTagParams{ctx, tp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpsertRepositoryTag.t.Errorf("RepositoryMock.UpsertRepositoryTag got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tp1 != nil && !minimock.Equal(*mm_want_ptrs.tp1, mm_got.tp1) {
				mmUpsertRepositoryTag.t.Errorf("RepositoryMock.UpsertRepositoryTag got unexpected parameter tp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.expectationOrigins.originTp1, *mm_want_ptrs.tp1, mm_got.tp1, minimock.Diff(*mm_want_ptrs.tp1, mm_got.tp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsertRepositoryTag.t.Errorf("RepositoryMock.UpsertRepositoryTag got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsertRepositoryTag.t.Fatal("No results are set for the RepositoryMock.UpsertRepositoryTag")
		}
		return (*mm_results).tp2, (*mm_results).err
	}
	if mmUpsertRepositoryTag.funcUpsertRepositoryTag != nil {
		return mmUpsertRepositoryTag.funcUpsertRepositoryTag(ctx, tp1)
	}
	mmUpsertRepositoryTag.t.Fatalf("Unexpected call to RepositoryMock.UpsertRepositoryTag. %v %v", ctx, tp1)
	return
}

// UpsertRepositoryTagAfterCounter returns a count of finished RepositoryMock.UpsertRepositoryTag invocations
func (mmUpsertRepositoryTag *RepositoryMock) UpsertRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertRepositoryTag.afterUpsertRepositoryTagCounter)
}

// UpsertRepositoryTagBeforeCounter returns a count of RepositoryMock.UpsertRepositoryTag invocations
func (mmUpsertRepositoryTag *RepositoryMock) UpsertRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertRepositoryTag.beforeUpsertRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpsertRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) Calls() []*RepositoryMockUpsertRepositoryTagParams {
	mmUpsertRepositoryTag.mutex.RLock()

	argCopy := make([]*RepositoryMockUpsertRepositoryTagParams, len(mmUpsertRepositoryTag.callArgs))
	copy(argCopy, mmUpsertRepositoryTag.callArgs)

	mmUpsertRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertRepositoryTagDone returns true if the count of the UpsertRepositoryTag invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpsertRepositoryTagDone() bool {
	if m.UpsertRepositoryTagMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpsertRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpsertRepositoryTagMock.invocationsDone()
}

// MinimockUpsertRepositoryTagInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpsertRepositoryTagInspect() {
	for _, e := range m.UpsertRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpsertRepositoryTag at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpsertRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterUpsertRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertRepositoryTagMock.defaultExpectation != nil && afterUpsertRepositoryTagCounter < 1 {
		if m.UpsertRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpsertRepositoryTag at\n%s", m.UpsertRepositoryTagMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpsertRepositoryTag at\n%s with params: %#v", m.UpsertRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *m.UpsertRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertRepositoryTag != nil && afterUpsertRepositoryTagCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpsertRepositoryTag at\n%s", m.funcUpsertRepositoryTagOrigin)
	}

	if !m.UpsertRepositoryTagMock.invocationsDone() && afterUpsertRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpsertRepositoryTag at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpsertRepositoryTagMock.expectedInvocations), m.UpsertRepositoryTagMock.expectedInvocationsOrigin, afterUpsertRepositoryTagCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCheckFileUIDMetadataInspect()

			m.MinimockCheckGCSFileExistsInspect()

			m.MinimockCollectionExistsInspect()

			m.MinimockCreateCollectionInspect()

			m.MinimockCreateConvertedFileWithDestinationInspect()

			m.MinimockCreateEmbeddingsInspect()

			m.MinimockCreateKnowledgeBaseInspect()

			m.MinimockCreateKnowledgeBaseFileInspect()

			m.MinimockCreateObjectInspect()

			m.MinimockCreateStagingKnowledgeBaseInspect()

			m.MinimockCreateSystemInspect()

			m.MinimockCreateTextChunksInspect()

			m.MinimockDeleteAllConvertedFilesInKbInspect()

			m.MinimockDeleteAllKnowledgeBaseFilesInspect()

			m.MinimockDeleteAndCreateEmbeddingsInspect()

			m.MinimockDeleteAndCreateTextChunksInspect()

			m.MinimockDeleteCacheMetadataInspect()

			m.MinimockDeleteConvertedFileInspect()

			m.MinimockDeleteEmbeddingsByKBFileUIDInspect()

			m.MinimockDeleteEmbeddingsWithFileUIDInspect()

			m.MinimockDeleteGCSFileCacheInspect()

			m.MinimockDeleteKnowledgeBaseInspect()

			m.MinimockDeleteKnowledgeBaseFileInspect()

			m.MinimockDeleteKnowledgeBaseFileAndDecreaseUsageInspect()

			m.MinimockDeleteKnowledgeBaseTxInspect()

			m.MinimockDeleteObjectInspect()

			m.MinimockDeleteObjectByDestinationInspect()

			m.MinimockDeleteRepositoryTagInspect()

			m.MinimockDeleteSystemInspect()

			m.MinimockDropCollectionInspect()

			m.MinimockFlushCollectionInspect()

			m.MinimockGetActiveCollectionUIDInspect()

			m.MinimockGetAllConvertedFilesByFileUIDInspect()

			m.MinimockGetCacheMetadataInspect()

			m.MinimockGetChunkCountByKBUIDInspect()

			m.MinimockGetConfigByIDInspect()

			m.MinimockGetContentByFileUIDsInspect()

			m.MinimockGetConvertedFileByFileUIDInspect()

			m.MinimockGetConvertedFileByFileUIDAndTypeInspect()

			m.MinimockGetConvertedFileCountByKBUIDInspect()

			m.MinimockGetDBInspect()

			m.MinimockGetDefaultSystemInspect()

			m.MinimockGetDualProcessingTargetInspect()

			m.MinimockGetEmbeddingCountByKBUIDInspect()

			m.MinimockGetFileByIDOrAliasInspect()

			m.MinimockGetFileCountByKnowledgeBaseUIDInspect()

			m.MinimockGetFileCountByKnowledgeBaseUIDIncludingDeletedInspect()

			m.MinimockGetFilesTotalTokensInspect()

			m.MinimockGetGCSFileInfoInspect()

			m.MinimockGetGCSStorageInspect()

			m.MinimockGetKnowledgeBaseByIDInspect()

			m.MinimockGetKnowledgeBaseByIDOrAliasInspect()

			m.MinimockGetKnowledgeBaseByOwnerAndKbIDInspect()

			m.MinimockGetKnowledgeBaseByUIDInspect()

			m.MinimockGetKnowledgeBaseByUIDIncludingDeletedInspect()

			m.MinimockGetKnowledgeBaseByUIDWithConfigInspect()

			m.MinimockGetKnowledgeBaseCountByOwnerInspect()

			m.MinimockGetKnowledgeBaseFilesByFileIDsInspect()

			m.MinimockGetKnowledgeBaseFilesByFileUIDsInspect()

			m.MinimockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedInspect()

			m.MinimockGetKnowledgeBaseFilesByNameInspect()

			m.MinimockGetKnowledgeBasesByUIDsInspect()

			m.MinimockGetKnowledgeBasesByUIDsWithConfigInspect()

			m.MinimockGetKnowledgebaseFileByKBUIDAndFileIDInspect()

			m.MinimockGetMinIOStorageInspect()

			m.MinimockGetNotStartedFileCountInspect()

			m.MinimockGetNotStartedFileCountExcludingInspect()

			m.MinimockGetObjectByUIDInspect()

			m.MinimockGetRepositoryTagInspect()

			m.MinimockGetRollbackKBForProductionInspect()

			m.MinimockGetSourceByFileUIDInspect()

			m.MinimockGetStagingKBForProductionInspect()

			m.MinimockGetSystemInspect()

			m.MinimockGetSystemByUIDInspect()

			m.MinimockGetTextChunksBySourceInspect()

			m.MinimockGetTextChunksByUIDsInspect()

			m.MinimockGetTotalTextChunksBySourcesInspect()

			m.MinimockGetTotalTokensByListKBUIDsInspect()

			m.MinimockHardDeleteConvertedFileByFileUIDInspect()

			m.MinimockHardDeleteEmbeddingsByKBFileUIDInspect()

			m.MinimockHardDeleteEmbeddingsByKBUIDInspect()

			m.MinimockHardDeleteTextChunksByKBFileUIDInspect()

			m.MinimockHardDeleteTextChunksByKBUIDInspect()

			m.MinimockIncreaseKnowledgeBaseUsageInspect()

			m.MinimockInsertVectorsInCollectionInspect()

			m.MinimockIsCollectionInUseInspect()

			m.MinimockIsKBUpdatingInspect()

			m.MinimockListAllKnowledgeBasesAdminInspect()

			m.MinimockListAllObjectsInspect()

			m.MinimockListEmbeddingsByKBFileUIDInspect()

			m.MinimockListKnowledgeBaseFilesInspect()

			m.MinimockListKnowledgeBasesInspect()

			m.MinimockListKnowledgeBasesByTypeInspect()

			m.MinimockListKnowledgeBasesByTypeWithConfigInspect()

			m.MinimockListKnowledgeBasesByUpdateStatusInspect()

			m.MinimockListKnowledgeBasesForUpdateInspect()

			m.MinimockListSystemsInspect()

			m.MinimockListTextChunksByKBFileUIDInspect()

			m.MinimockProcessKnowledgeBaseFilesInspect()

			m.MinimockRenameSystemByIDInspect()

			m.MinimockRenewCacheMetadataTTLInspect()

			m.MinimockScanGCSFilesForCleanupInspect()

			m.MinimockSearchVectorsInCollectionInspect()

			m.MinimockSetCacheMetadataInspect()

			m.MinimockSetDefaultSystemInspect()

			m.MinimockSetGCSFileInfoInspect()

			m.MinimockUpdateConfigByIDInspect()

			m.MinimockUpdateConvertedFileInspect()

			m.MinimockUpdateEmbeddingTagsInspect()

			m.MinimockUpdateEmbeddingTagsForFileInspect()

			m.MinimockUpdateKnowledgeBaseInspect()

			m.MinimockUpdateKnowledgeBaseAbortedInspect()

			m.MinimockUpdateKnowledgeBaseFileInspect()

			m.MinimockUpdateKnowledgeBaseResourcesInspect()

			m.MinimockUpdateKnowledgeBaseResourcesTxInspect()

			m.MinimockUpdateKnowledgeBaseUpdateStatusInspect()

			m.MinimockUpdateKnowledgeBaseWithMapInspect()

			m.MinimockUpdateKnowledgeBaseWithMapTxInspect()

			m.MinimockUpdateKnowledgeFileMetadataInspect()

			m.MinimockUpdateKnowledgeFileUsageMetadataInspect()

			m.MinimockUpdateObjectInspect()

			m.MinimockUpdateObjectByUpdateMapInspect()

			m.MinimockUpdateSystemInspect()

			m.MinimockUpdateSystemByUpdateMapInspect()

			m.MinimockUpdateTextChunkInspect()

			m.MinimockUpdateTextChunkDestinationsInspect()

			m.MinimockUpsertRepositoryTagInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckFileUIDMetadataDone() &&
		m.MinimockCheckGCSFileExistsDone() &&
		m.MinimockCollectionExistsDone() &&
		m.MinimockCreateCollectionDone() &&
		m.MinimockCreateConvertedFileWithDestinationDone() &&
		m.MinimockCreateEmbeddingsDone() &&
		m.MinimockCreateKnowledgeBaseDone() &&
		m.MinimockCreateKnowledgeBaseFileDone() &&
		m.MinimockCreateObjectDone() &&
		m.MinimockCreateStagingKnowledgeBaseDone() &&
		m.MinimockCreateSystemDone() &&
		m.MinimockCreateTextChunksDone() &&
		m.MinimockDeleteAllConvertedFilesInKbDone() &&
		m.MinimockDeleteAllKnowledgeBaseFilesDone() &&
		m.MinimockDeleteAndCreateEmbeddingsDone() &&
		m.MinimockDeleteAndCreateTextChunksDone() &&
		m.MinimockDeleteCacheMetadataDone() &&
		m.MinimockDeleteConvertedFileDone() &&
		m.MinimockDeleteEmbeddingsByKBFileUIDDone() &&
		m.MinimockDeleteEmbeddingsWithFileUIDDone() &&
		m.MinimockDeleteGCSFileCacheDone() &&
		m.MinimockDeleteKnowledgeBaseDone() &&
		m.MinimockDeleteKnowledgeBaseFileDone() &&
		m.MinimockDeleteKnowledgeBaseFileAndDecreaseUsageDone() &&
		m.MinimockDeleteKnowledgeBaseTxDone() &&
		m.MinimockDeleteObjectDone() &&
		m.MinimockDeleteObjectByDestinationDone() &&
		m.MinimockDeleteRepositoryTagDone() &&
		m.MinimockDeleteSystemDone() &&
		m.MinimockDropCollectionDone() &&
		m.MinimockFlushCollectionDone() &&
		m.MinimockGetActiveCollectionUIDDone() &&
		m.MinimockGetAllConvertedFilesByFileUIDDone() &&
		m.MinimockGetCacheMetadataDone() &&
		m.MinimockGetChunkCountByKBUIDDone() &&
		m.MinimockGetConfigByIDDone() &&
		m.MinimockGetContentByFileUIDsDone() &&
		m.MinimockGetConvertedFileByFileUIDDone() &&
		m.MinimockGetConvertedFileByFileUIDAndTypeDone() &&
		m.MinimockGetConvertedFileCountByKBUIDDone() &&
		m.MinimockGetDBDone() &&
		m.MinimockGetDefaultSystemDone() &&
		m.MinimockGetDualProcessingTargetDone() &&
		m.MinimockGetEmbeddingCountByKBUIDDone() &&
		m.MinimockGetFileByIDOrAliasDone() &&
		m.MinimockGetFileCountByKnowledgeBaseUIDDone() &&
		m.MinimockGetFileCountByKnowledgeBaseUIDIncludingDeletedDone() &&
		m.MinimockGetFilesTotalTokensDone() &&
		m.MinimockGetGCSFileInfoDone() &&
		m.MinimockGetGCSStorageDone() &&
		m.MinimockGetKnowledgeBaseByIDDone() &&
		m.MinimockGetKnowledgeBaseByIDOrAliasDone() &&
		m.MinimockGetKnowledgeBaseByOwnerAndKbIDDone() &&
		m.MinimockGetKnowledgeBaseByUIDDone() &&
		m.MinimockGetKnowledgeBaseByUIDIncludingDeletedDone() &&
		m.MinimockGetKnowledgeBaseByUIDWithConfigDone() &&
		m.MinimockGetKnowledgeBaseCountByOwnerDone() &&
		m.MinimockGetKnowledgeBaseFilesByFileIDsDone() &&
		m.MinimockGetKnowledgeBaseFilesByFileUIDsDone() &&
		m.MinimockGetKnowledgeBaseFilesByFileUIDsIncludingDeletedDone() &&
		m.MinimockGetKnowledgeBaseFilesByNameDone() &&
		m.MinimockGetKnowledgeBasesByUIDsDone() &&
		m.MinimockGetKnowledgeBasesByUIDsWithConfigDone() &&
		m.MinimockGetKnowledgebaseFileByKBUIDAndFileIDDone() &&
		m.MinimockGetMinIOStorageDone() &&
		m.MinimockGetNotStartedFileCountDone() &&
		m.MinimockGetNotStartedFileCountExcludingDone() &&
		m.MinimockGetObjectByUIDDone() &&
		m.MinimockGetRepositoryTagDone() &&
		m.MinimockGetRollbackKBForProductionDone() &&
		m.MinimockGetSourceByFileUIDDone() &&
		m.MinimockGetStagingKBForProductionDone() &&
		m.MinimockGetSystemDone() &&
		m.MinimockGetSystemByUIDDone() &&
		m.MinimockGetTextChunksBySourceDone() &&
		m.MinimockGetTextChunksByUIDsDone() &&
		m.MinimockGetTotalTextChunksBySourcesDone() &&
		m.MinimockGetTotalTokensByListKBUIDsDone() &&
		m.MinimockHardDeleteConvertedFileByFileUIDDone() &&
		m.MinimockHardDeleteEmbeddingsByKBFileUIDDone() &&
		m.MinimockHardDeleteEmbeddingsByKBUIDDone() &&
		m.MinimockHardDeleteTextChunksByKBFileUIDDone() &&
		m.MinimockHardDeleteTextChunksByKBUIDDone() &&
		m.MinimockIncreaseKnowledgeBaseUsageDone() &&
		m.MinimockInsertVectorsInCollectionDone() &&
		m.MinimockIsCollectionInUseDone() &&
		m.MinimockIsKBUpdatingDone() &&
		m.MinimockListAllKnowledgeBasesAdminDone() &&
		m.MinimockListAllObjectsDone() &&
		m.MinimockListEmbeddingsByKBFileUIDDone() &&
		m.MinimockListKnowledgeBaseFilesDone() &&
		m.MinimockListKnowledgeBasesDone() &&
		m.MinimockListKnowledgeBasesByTypeDone() &&
		m.MinimockListKnowledgeBasesByTypeWithConfigDone() &&
		m.MinimockListKnowledgeBasesByUpdateStatusDone() &&
		m.MinimockListKnowledgeBasesForUpdateDone() &&
		m.MinimockListSystemsDone() &&
		m.MinimockListTextChunksByKBFileUIDDone() &&
		m.MinimockProcessKnowledgeBaseFilesDone() &&
		m.MinimockRenameSystemByIDDone() &&
		m.MinimockRenewCacheMetadataTTLDone() &&
		m.MinimockScanGCSFilesForCleanupDone() &&
		m.MinimockSearchVectorsInCollectionDone() &&
		m.MinimockSetCacheMetadataDone() &&
		m.MinimockSetDefaultSystemDone() &&
		m.MinimockSetGCSFileInfoDone() &&
		m.MinimockUpdateConfigByIDDone() &&
		m.MinimockUpdateConvertedFileDone() &&
		m.MinimockUpdateEmbeddingTagsDone() &&
		m.MinimockUpdateEmbeddingTagsForFileDone() &&
		m.MinimockUpdateKnowledgeBaseDone() &&
		m.MinimockUpdateKnowledgeBaseAbortedDone() &&
		m.MinimockUpdateKnowledgeBaseFileDone() &&
		m.MinimockUpdateKnowledgeBaseResourcesDone() &&
		m.MinimockUpdateKnowledgeBaseResourcesTxDone() &&
		m.MinimockUpdateKnowledgeBaseUpdateStatusDone() &&
		m.MinimockUpdateKnowledgeBaseWithMapDone() &&
		m.MinimockUpdateKnowledgeBaseWithMapTxDone() &&
		m.MinimockUpdateKnowledgeFileMetadataDone() &&
		m.MinimockUpdateKnowledgeFileUsageMetadataDone() &&
		m.MinimockUpdateObjectDone() &&
		m.MinimockUpdateObjectByUpdateMapDone() &&
		m.MinimockUpdateSystemDone() &&
		m.MinimockUpdateSystemByUpdateMapDone() &&
		m.MinimockUpdateTextChunkDone() &&
		m.MinimockUpdateTextChunkDestinationsDone() &&
		m.MinimockUpsertRepositoryTagDone()
}
