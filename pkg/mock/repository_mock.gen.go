// Code generated by http://github.com/gojuno/minimock (v3.3.9). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_service "github.com/instill-ai/artifact-backend/pkg/service"
	pb "github.com/instill-ai/protogen-go/artifact/artifact/v1alpha"
)

// RepositoryMock implements service.Repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateKnowledgeBase          func(ctx context.Context, kb mm_service.KnowledgeBase) (kp1 *mm_service.KnowledgeBase, err error)
	inspectFuncCreateKnowledgeBase   func(ctx context.Context, kb mm_service.KnowledgeBase)
	afterCreateKnowledgeBaseCounter  uint64
	beforeCreateKnowledgeBaseCounter uint64
	CreateKnowledgeBaseMock          mRepositoryMockCreateKnowledgeBase

	funcDeleteKnowledgeBase          func(ctx context.Context, kb mm_service.KnowledgeBase) (err error)
	inspectFuncDeleteKnowledgeBase   func(ctx context.Context, kb mm_service.KnowledgeBase)
	afterDeleteKnowledgeBaseCounter  uint64
	beforeDeleteKnowledgeBaseCounter uint64
	DeleteKnowledgeBaseMock          mRepositoryMockDeleteKnowledgeBase

	funcGetKnowledgeBase          func(ctx context.Context) (ka1 []mm_service.KnowledgeBase, err error)
	inspectFuncGetKnowledgeBase   func(ctx context.Context)
	afterGetKnowledgeBaseCounter  uint64
	beforeGetKnowledgeBaseCounter uint64
	GetKnowledgeBaseMock          mRepositoryMockGetKnowledgeBase

	funcGetRepositoryTag          func(ctx context.Context, r1 mm_service.RepositoryTagName) (rp1 *pb.RepositoryTag, err error)
	inspectFuncGetRepositoryTag   func(ctx context.Context, r1 mm_service.RepositoryTagName)
	afterGetRepositoryTagCounter  uint64
	beforeGetRepositoryTagCounter uint64
	GetRepositoryTagMock          mRepositoryMockGetRepositoryTag

	funcUpdateKnowledgeBase          func(ctx context.Context, kb mm_service.KnowledgeBase) (kp1 *mm_service.KnowledgeBase, err error)
	inspectFuncUpdateKnowledgeBase   func(ctx context.Context, kb mm_service.KnowledgeBase)
	afterUpdateKnowledgeBaseCounter  uint64
	beforeUpdateKnowledgeBaseCounter uint64
	UpdateKnowledgeBaseMock          mRepositoryMockUpdateKnowledgeBase

	funcUpsertRepositoryTag          func(ctx context.Context, rp1 *pb.RepositoryTag) (rp2 *pb.RepositoryTag, err error)
	inspectFuncUpsertRepositoryTag   func(ctx context.Context, rp1 *pb.RepositoryTag)
	afterUpsertRepositoryTagCounter  uint64
	beforeUpsertRepositoryTagCounter uint64
	UpsertRepositoryTagMock          mRepositoryMockUpsertRepositoryTag
}

// NewRepositoryMock returns a mock for service.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateKnowledgeBaseMock = mRepositoryMockCreateKnowledgeBase{mock: m}
	m.CreateKnowledgeBaseMock.callArgs = []*RepositoryMockCreateKnowledgeBaseParams{}

	m.DeleteKnowledgeBaseMock = mRepositoryMockDeleteKnowledgeBase{mock: m}
	m.DeleteKnowledgeBaseMock.callArgs = []*RepositoryMockDeleteKnowledgeBaseParams{}

	m.GetKnowledgeBaseMock = mRepositoryMockGetKnowledgeBase{mock: m}
	m.GetKnowledgeBaseMock.callArgs = []*RepositoryMockGetKnowledgeBaseParams{}

	m.GetRepositoryTagMock = mRepositoryMockGetRepositoryTag{mock: m}
	m.GetRepositoryTagMock.callArgs = []*RepositoryMockGetRepositoryTagParams{}

	m.UpdateKnowledgeBaseMock = mRepositoryMockUpdateKnowledgeBase{mock: m}
	m.UpdateKnowledgeBaseMock.callArgs = []*RepositoryMockUpdateKnowledgeBaseParams{}

	m.UpsertRepositoryTagMock = mRepositoryMockUpsertRepositoryTag{mock: m}
	m.UpsertRepositoryTagMock.callArgs = []*RepositoryMockUpsertRepositoryTagParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockCreateKnowledgeBase struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateKnowledgeBaseExpectation
	expectations       []*RepositoryMockCreateKnowledgeBaseExpectation

	callArgs []*RepositoryMockCreateKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockCreateKnowledgeBaseExpectation specifies expectation struct of the Repository.CreateKnowledgeBase
type RepositoryMockCreateKnowledgeBaseExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockCreateKnowledgeBaseParams
	paramPtrs *RepositoryMockCreateKnowledgeBaseParamPtrs
	results   *RepositoryMockCreateKnowledgeBaseResults
	Counter   uint64
}

// RepositoryMockCreateKnowledgeBaseParams contains parameters of the Repository.CreateKnowledgeBase
type RepositoryMockCreateKnowledgeBaseParams struct {
	ctx context.Context
	kb  mm_service.KnowledgeBase
}

// RepositoryMockCreateKnowledgeBaseParamPtrs contains pointers to parameters of the Repository.CreateKnowledgeBase
type RepositoryMockCreateKnowledgeBaseParamPtrs struct {
	ctx *context.Context
	kb  *mm_service.KnowledgeBase
}

// RepositoryMockCreateKnowledgeBaseResults contains results of the Repository.CreateKnowledgeBase
type RepositoryMockCreateKnowledgeBaseResults struct {
	kp1 *mm_service.KnowledgeBase
	err error
}

// Expect sets up expected params for Repository.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) Expect(ctx context.Context, kb mm_service.KnowledgeBase) *mRepositoryMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmCreateKnowledgeBase.defaultExpectation.params = &RepositoryMockCreateKnowledgeBaseParams{ctx, kb}
	for _, e := range mmCreateKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmCreateKnowledgeBase.defaultExpectation.params) {
			mmCreateKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmCreateKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.params != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBase mock is already set by Expect")
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockCreateKnowledgeBaseParamPtrs{}
	}
	mmCreateKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateKnowledgeBase
}

// ExpectKbParam2 sets up expected param kb for Repository.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) ExpectKbParam2(kb mm_service.KnowledgeBase) *mRepositoryMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.params != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBase mock is already set by Expect")
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockCreateKnowledgeBaseParamPtrs{}
	}
	mmCreateKnowledgeBase.defaultExpectation.paramPtrs.kb = &kb

	return mmCreateKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) Inspect(f func(ctx context.Context, kb mm_service.KnowledgeBase)) *mRepositoryMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.inspectFuncCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateKnowledgeBase")
	}

	mmCreateKnowledgeBase.mock.inspectFuncCreateKnowledgeBase = f

	return mmCreateKnowledgeBase
}

// Return sets up results that will be returned by Repository.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) Return(kp1 *mm_service.KnowledgeBase, err error) *RepositoryMock {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryMockCreateKnowledgeBaseExpectation{mock: mmCreateKnowledgeBase.mock}
	}
	mmCreateKnowledgeBase.defaultExpectation.results = &RepositoryMockCreateKnowledgeBaseResults{kp1, err}
	return mmCreateKnowledgeBase.mock
}

// Set uses given function f to mock the Repository.CreateKnowledgeBase method
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) Set(f func(ctx context.Context, kb mm_service.KnowledgeBase) (kp1 *mm_service.KnowledgeBase, err error)) *RepositoryMock {
	if mmCreateKnowledgeBase.defaultExpectation != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the Repository.CreateKnowledgeBase method")
	}

	if len(mmCreateKnowledgeBase.expectations) > 0 {
		mmCreateKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the Repository.CreateKnowledgeBase method")
	}

	mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase = f
	return mmCreateKnowledgeBase.mock
}

// When sets expectation for the Repository.CreateKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) When(ctx context.Context, kb mm_service.KnowledgeBase) *RepositoryMockCreateKnowledgeBaseExpectation {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBase mock is already set by Set")
	}

	expectation := &RepositoryMockCreateKnowledgeBaseExpectation{
		mock:   mmCreateKnowledgeBase.mock,
		params: &RepositoryMockCreateKnowledgeBaseParams{ctx, kb},
	}
	mmCreateKnowledgeBase.expectations = append(mmCreateKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateKnowledgeBaseExpectation) Then(kp1 *mm_service.KnowledgeBase, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateKnowledgeBaseResults{kp1, err}
	return e.mock
}

// Times sets number of times Repository.CreateKnowledgeBase should be invoked
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) Times(n uint64) *mRepositoryMockCreateKnowledgeBase {
	if n == 0 {
		mmCreateKnowledgeBase.mock.t.Fatalf("Times of RepositoryMock.CreateKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateKnowledgeBase.expectedInvocations, n)
	return mmCreateKnowledgeBase
}

func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) invocationsDone() bool {
	if len(mmCreateKnowledgeBase.expectations) == 0 && mmCreateKnowledgeBase.defaultExpectation == nil && mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateKnowledgeBase.mock.afterCreateKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateKnowledgeBase implements service.Repository
func (mmCreateKnowledgeBase *RepositoryMock) CreateKnowledgeBase(ctx context.Context, kb mm_service.KnowledgeBase) (kp1 *mm_service.KnowledgeBase, err error) {
	mm_atomic.AddUint64(&mmCreateKnowledgeBase.beforeCreateKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateKnowledgeBase.afterCreateKnowledgeBaseCounter, 1)

	if mmCreateKnowledgeBase.inspectFuncCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.inspectFuncCreateKnowledgeBase(ctx, kb)
	}

	mm_params := RepositoryMockCreateKnowledgeBaseParams{ctx, kb}

	// Record call args
	mmCreateKnowledgeBase.CreateKnowledgeBaseMock.mutex.Lock()
	mmCreateKnowledgeBase.CreateKnowledgeBaseMock.callArgs = append(mmCreateKnowledgeBase.CreateKnowledgeBaseMock.callArgs, &mm_params)
	mmCreateKnowledgeBase.CreateKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmCreateKnowledgeBase.CreateKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateKnowledgeBaseParams{ctx, kb}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateKnowledgeBase.t.Errorf("RepositoryMock.CreateKnowledgeBase got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kb != nil && !minimock.Equal(*mm_want_ptrs.kb, mm_got.kb) {
				mmCreateKnowledgeBase.t.Errorf("RepositoryMock.CreateKnowledgeBase got unexpected parameter kb, want: %#v, got: %#v%s\n", *mm_want_ptrs.kb, mm_got.kb, minimock.Diff(*mm_want_ptrs.kb, mm_got.kb))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateKnowledgeBase.t.Errorf("RepositoryMock.CreateKnowledgeBase got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateKnowledgeBase.t.Fatal("No results are set for the RepositoryMock.CreateKnowledgeBase")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmCreateKnowledgeBase.funcCreateKnowledgeBase != nil {
		return mmCreateKnowledgeBase.funcCreateKnowledgeBase(ctx, kb)
	}
	mmCreateKnowledgeBase.t.Fatalf("Unexpected call to RepositoryMock.CreateKnowledgeBase. %v %v", ctx, kb)
	return
}

// CreateKnowledgeBaseAfterCounter returns a count of finished RepositoryMock.CreateKnowledgeBase invocations
func (mmCreateKnowledgeBase *RepositoryMock) CreateKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateKnowledgeBase.afterCreateKnowledgeBaseCounter)
}

// CreateKnowledgeBaseBeforeCounter returns a count of RepositoryMock.CreateKnowledgeBase invocations
func (mmCreateKnowledgeBase *RepositoryMock) CreateKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateKnowledgeBase.beforeCreateKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) Calls() []*RepositoryMockCreateKnowledgeBaseParams {
	mmCreateKnowledgeBase.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateKnowledgeBaseParams, len(mmCreateKnowledgeBase.callArgs))
	copy(argCopy, mmCreateKnowledgeBase.callArgs)

	mmCreateKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockCreateKnowledgeBaseDone returns true if the count of the CreateKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateKnowledgeBaseDone() bool {
	for _, e := range m.CreateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateKnowledgeBaseMock.invocationsDone()
}

// MinimockCreateKnowledgeBaseInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateKnowledgeBaseInspect() {
	for _, e := range m.CreateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateKnowledgeBase with params: %#v", *e.params)
		}
	}

	afterCreateKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterCreateKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateKnowledgeBaseMock.defaultExpectation != nil && afterCreateKnowledgeBaseCounter < 1 {
		if m.CreateKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateKnowledgeBase")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateKnowledgeBase with params: %#v", *m.CreateKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateKnowledgeBase != nil && afterCreateKnowledgeBaseCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateKnowledgeBase")
	}

	if !m.CreateKnowledgeBaseMock.invocationsDone() && afterCreateKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateKnowledgeBase but found %d calls",
			mm_atomic.LoadUint64(&m.CreateKnowledgeBaseMock.expectedInvocations), afterCreateKnowledgeBaseCounter)
	}
}

type mRepositoryMockDeleteKnowledgeBase struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteKnowledgeBaseExpectation
	expectations       []*RepositoryMockDeleteKnowledgeBaseExpectation

	callArgs []*RepositoryMockDeleteKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockDeleteKnowledgeBaseExpectation specifies expectation struct of the Repository.DeleteKnowledgeBase
type RepositoryMockDeleteKnowledgeBaseExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockDeleteKnowledgeBaseParams
	paramPtrs *RepositoryMockDeleteKnowledgeBaseParamPtrs
	results   *RepositoryMockDeleteKnowledgeBaseResults
	Counter   uint64
}

// RepositoryMockDeleteKnowledgeBaseParams contains parameters of the Repository.DeleteKnowledgeBase
type RepositoryMockDeleteKnowledgeBaseParams struct {
	ctx context.Context
	kb  mm_service.KnowledgeBase
}

// RepositoryMockDeleteKnowledgeBaseParamPtrs contains pointers to parameters of the Repository.DeleteKnowledgeBase
type RepositoryMockDeleteKnowledgeBaseParamPtrs struct {
	ctx *context.Context
	kb  *mm_service.KnowledgeBase
}

// RepositoryMockDeleteKnowledgeBaseResults contains results of the Repository.DeleteKnowledgeBase
type RepositoryMockDeleteKnowledgeBaseResults struct {
	err error
}

// Expect sets up expected params for Repository.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) Expect(ctx context.Context, kb mm_service.KnowledgeBase) *mRepositoryMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmDeleteKnowledgeBase.defaultExpectation.params = &RepositoryMockDeleteKnowledgeBaseParams{ctx, kb}
	for _, e := range mmDeleteKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmDeleteKnowledgeBase.defaultExpectation.params) {
			mmDeleteKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmDeleteKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.params != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBase mock is already set by Expect")
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockDeleteKnowledgeBaseParamPtrs{}
	}
	mmDeleteKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteKnowledgeBase
}

// ExpectKbParam2 sets up expected param kb for Repository.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) ExpectKbParam2(kb mm_service.KnowledgeBase) *mRepositoryMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.params != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBase mock is already set by Expect")
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockDeleteKnowledgeBaseParamPtrs{}
	}
	mmDeleteKnowledgeBase.defaultExpectation.paramPtrs.kb = &kb

	return mmDeleteKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) Inspect(f func(ctx context.Context, kb mm_service.KnowledgeBase)) *mRepositoryMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.inspectFuncDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteKnowledgeBase")
	}

	mmDeleteKnowledgeBase.mock.inspectFuncDeleteKnowledgeBase = f

	return mmDeleteKnowledgeBase
}

// Return sets up results that will be returned by Repository.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) Return(err error) *RepositoryMock {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseExpectation{mock: mmDeleteKnowledgeBase.mock}
	}
	mmDeleteKnowledgeBase.defaultExpectation.results = &RepositoryMockDeleteKnowledgeBaseResults{err}
	return mmDeleteKnowledgeBase.mock
}

// Set uses given function f to mock the Repository.DeleteKnowledgeBase method
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) Set(f func(ctx context.Context, kb mm_service.KnowledgeBase) (err error)) *RepositoryMock {
	if mmDeleteKnowledgeBase.defaultExpectation != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteKnowledgeBase method")
	}

	if len(mmDeleteKnowledgeBase.expectations) > 0 {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteKnowledgeBase method")
	}

	mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase = f
	return mmDeleteKnowledgeBase.mock
}

// When sets expectation for the Repository.DeleteKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) When(ctx context.Context, kb mm_service.KnowledgeBase) *RepositoryMockDeleteKnowledgeBaseExpectation {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBase mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteKnowledgeBaseExpectation{
		mock:   mmDeleteKnowledgeBase.mock,
		params: &RepositoryMockDeleteKnowledgeBaseParams{ctx, kb},
	}
	mmDeleteKnowledgeBase.expectations = append(mmDeleteKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteKnowledgeBaseExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteKnowledgeBaseResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteKnowledgeBase should be invoked
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) Times(n uint64) *mRepositoryMockDeleteKnowledgeBase {
	if n == 0 {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Times of RepositoryMock.DeleteKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteKnowledgeBase.expectedInvocations, n)
	return mmDeleteKnowledgeBase
}

func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) invocationsDone() bool {
	if len(mmDeleteKnowledgeBase.expectations) == 0 && mmDeleteKnowledgeBase.defaultExpectation == nil && mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.mock.afterDeleteKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteKnowledgeBase implements service.Repository
func (mmDeleteKnowledgeBase *RepositoryMock) DeleteKnowledgeBase(ctx context.Context, kb mm_service.KnowledgeBase) (err error) {
	mm_atomic.AddUint64(&mmDeleteKnowledgeBase.beforeDeleteKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteKnowledgeBase.afterDeleteKnowledgeBaseCounter, 1)

	if mmDeleteKnowledgeBase.inspectFuncDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.inspectFuncDeleteKnowledgeBase(ctx, kb)
	}

	mm_params := RepositoryMockDeleteKnowledgeBaseParams{ctx, kb}

	// Record call args
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.mutex.Lock()
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.callArgs = append(mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.callArgs, &mm_params)
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteKnowledgeBaseParams{ctx, kb}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteKnowledgeBase.t.Errorf("RepositoryMock.DeleteKnowledgeBase got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kb != nil && !minimock.Equal(*mm_want_ptrs.kb, mm_got.kb) {
				mmDeleteKnowledgeBase.t.Errorf("RepositoryMock.DeleteKnowledgeBase got unexpected parameter kb, want: %#v, got: %#v%s\n", *mm_want_ptrs.kb, mm_got.kb, minimock.Diff(*mm_want_ptrs.kb, mm_got.kb))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteKnowledgeBase.t.Errorf("RepositoryMock.DeleteKnowledgeBase got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteKnowledgeBase.t.Fatal("No results are set for the RepositoryMock.DeleteKnowledgeBase")
		}
		return (*mm_results).err
	}
	if mmDeleteKnowledgeBase.funcDeleteKnowledgeBase != nil {
		return mmDeleteKnowledgeBase.funcDeleteKnowledgeBase(ctx, kb)
	}
	mmDeleteKnowledgeBase.t.Fatalf("Unexpected call to RepositoryMock.DeleteKnowledgeBase. %v %v", ctx, kb)
	return
}

// DeleteKnowledgeBaseAfterCounter returns a count of finished RepositoryMock.DeleteKnowledgeBase invocations
func (mmDeleteKnowledgeBase *RepositoryMock) DeleteKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.afterDeleteKnowledgeBaseCounter)
}

// DeleteKnowledgeBaseBeforeCounter returns a count of RepositoryMock.DeleteKnowledgeBase invocations
func (mmDeleteKnowledgeBase *RepositoryMock) DeleteKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.beforeDeleteKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) Calls() []*RepositoryMockDeleteKnowledgeBaseParams {
	mmDeleteKnowledgeBase.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteKnowledgeBaseParams, len(mmDeleteKnowledgeBase.callArgs))
	copy(argCopy, mmDeleteKnowledgeBase.callArgs)

	mmDeleteKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteKnowledgeBaseDone returns true if the count of the DeleteKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteKnowledgeBaseDone() bool {
	for _, e := range m.DeleteKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteKnowledgeBaseMock.invocationsDone()
}

// MinimockDeleteKnowledgeBaseInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteKnowledgeBaseInspect() {
	for _, e := range m.DeleteKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBase with params: %#v", *e.params)
		}
	}

	afterDeleteKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterDeleteKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteKnowledgeBaseMock.defaultExpectation != nil && afterDeleteKnowledgeBaseCounter < 1 {
		if m.DeleteKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.DeleteKnowledgeBase")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBase with params: %#v", *m.DeleteKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteKnowledgeBase != nil && afterDeleteKnowledgeBaseCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.DeleteKnowledgeBase")
	}

	if !m.DeleteKnowledgeBaseMock.invocationsDone() && afterDeleteKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteKnowledgeBase but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteKnowledgeBaseMock.expectedInvocations), afterDeleteKnowledgeBaseCounter)
	}
}

type mRepositoryMockGetKnowledgeBase struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetKnowledgeBaseExpectation
	expectations       []*RepositoryMockGetKnowledgeBaseExpectation

	callArgs []*RepositoryMockGetKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockGetKnowledgeBaseExpectation specifies expectation struct of the Repository.GetKnowledgeBase
type RepositoryMockGetKnowledgeBaseExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockGetKnowledgeBaseParams
	paramPtrs *RepositoryMockGetKnowledgeBaseParamPtrs
	results   *RepositoryMockGetKnowledgeBaseResults
	Counter   uint64
}

// RepositoryMockGetKnowledgeBaseParams contains parameters of the Repository.GetKnowledgeBase
type RepositoryMockGetKnowledgeBaseParams struct {
	ctx context.Context
}

// RepositoryMockGetKnowledgeBaseParamPtrs contains pointers to parameters of the Repository.GetKnowledgeBase
type RepositoryMockGetKnowledgeBaseParamPtrs struct {
	ctx *context.Context
}

// RepositoryMockGetKnowledgeBaseResults contains results of the Repository.GetKnowledgeBase
type RepositoryMockGetKnowledgeBaseResults struct {
	ka1 []mm_service.KnowledgeBase
	err error
}

// Expect sets up expected params for Repository.GetKnowledgeBase
func (mmGetKnowledgeBase *mRepositoryMockGetKnowledgeBase) Expect(ctx context.Context) *mRepositoryMockGetKnowledgeBase {
	if mmGetKnowledgeBase.mock.funcGetKnowledgeBase != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("RepositoryMock.GetKnowledgeBase mock is already set by Set")
	}

	if mmGetKnowledgeBase.defaultExpectation == nil {
		mmGetKnowledgeBase.defaultExpectation = &RepositoryMockGetKnowledgeBaseExpectation{}
	}

	if mmGetKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("RepositoryMock.GetKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBase.defaultExpectation.params = &RepositoryMockGetKnowledgeBaseParams{ctx}
	for _, e := range mmGetKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBase.defaultExpectation.params) {
			mmGetKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetKnowledgeBase
func (mmGetKnowledgeBase *mRepositoryMockGetKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetKnowledgeBase {
	if mmGetKnowledgeBase.mock.funcGetKnowledgeBase != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("RepositoryMock.GetKnowledgeBase mock is already set by Set")
	}

	if mmGetKnowledgeBase.defaultExpectation == nil {
		mmGetKnowledgeBase.defaultExpectation = &RepositoryMockGetKnowledgeBaseExpectation{}
	}

	if mmGetKnowledgeBase.defaultExpectation.params != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("RepositoryMock.GetKnowledgeBase mock is already set by Expect")
	}

	if mmGetKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseParamPtrs{}
	}
	mmGetKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetKnowledgeBase
func (mmGetKnowledgeBase *mRepositoryMockGetKnowledgeBase) Inspect(f func(ctx context.Context)) *mRepositoryMockGetKnowledgeBase {
	if mmGetKnowledgeBase.mock.inspectFuncGetKnowledgeBase != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetKnowledgeBase")
	}

	mmGetKnowledgeBase.mock.inspectFuncGetKnowledgeBase = f

	return mmGetKnowledgeBase
}

// Return sets up results that will be returned by Repository.GetKnowledgeBase
func (mmGetKnowledgeBase *mRepositoryMockGetKnowledgeBase) Return(ka1 []mm_service.KnowledgeBase, err error) *RepositoryMock {
	if mmGetKnowledgeBase.mock.funcGetKnowledgeBase != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("RepositoryMock.GetKnowledgeBase mock is already set by Set")
	}

	if mmGetKnowledgeBase.defaultExpectation == nil {
		mmGetKnowledgeBase.defaultExpectation = &RepositoryMockGetKnowledgeBaseExpectation{mock: mmGetKnowledgeBase.mock}
	}
	mmGetKnowledgeBase.defaultExpectation.results = &RepositoryMockGetKnowledgeBaseResults{ka1, err}
	return mmGetKnowledgeBase.mock
}

// Set uses given function f to mock the Repository.GetKnowledgeBase method
func (mmGetKnowledgeBase *mRepositoryMockGetKnowledgeBase) Set(f func(ctx context.Context) (ka1 []mm_service.KnowledgeBase, err error)) *RepositoryMock {
	if mmGetKnowledgeBase.defaultExpectation != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the Repository.GetKnowledgeBase method")
	}

	if len(mmGetKnowledgeBase.expectations) > 0 {
		mmGetKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the Repository.GetKnowledgeBase method")
	}

	mmGetKnowledgeBase.mock.funcGetKnowledgeBase = f
	return mmGetKnowledgeBase.mock
}

// When sets expectation for the Repository.GetKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBase *mRepositoryMockGetKnowledgeBase) When(ctx context.Context) *RepositoryMockGetKnowledgeBaseExpectation {
	if mmGetKnowledgeBase.mock.funcGetKnowledgeBase != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("RepositoryMock.GetKnowledgeBase mock is already set by Set")
	}

	expectation := &RepositoryMockGetKnowledgeBaseExpectation{
		mock:   mmGetKnowledgeBase.mock,
		params: &RepositoryMockGetKnowledgeBaseParams{ctx},
	}
	mmGetKnowledgeBase.expectations = append(mmGetKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetKnowledgeBaseExpectation) Then(ka1 []mm_service.KnowledgeBase, err error) *RepositoryMock {
	e.results = &RepositoryMockGetKnowledgeBaseResults{ka1, err}
	return e.mock
}

// Times sets number of times Repository.GetKnowledgeBase should be invoked
func (mmGetKnowledgeBase *mRepositoryMockGetKnowledgeBase) Times(n uint64) *mRepositoryMockGetKnowledgeBase {
	if n == 0 {
		mmGetKnowledgeBase.mock.t.Fatalf("Times of RepositoryMock.GetKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBase.expectedInvocations, n)
	return mmGetKnowledgeBase
}

func (mmGetKnowledgeBase *mRepositoryMockGetKnowledgeBase) invocationsDone() bool {
	if len(mmGetKnowledgeBase.expectations) == 0 && mmGetKnowledgeBase.defaultExpectation == nil && mmGetKnowledgeBase.mock.funcGetKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBase.mock.afterGetKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBase implements service.Repository
func (mmGetKnowledgeBase *RepositoryMock) GetKnowledgeBase(ctx context.Context) (ka1 []mm_service.KnowledgeBase, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBase.beforeGetKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBase.afterGetKnowledgeBaseCounter, 1)

	if mmGetKnowledgeBase.inspectFuncGetKnowledgeBase != nil {
		mmGetKnowledgeBase.inspectFuncGetKnowledgeBase(ctx)
	}

	mm_params := RepositoryMockGetKnowledgeBaseParams{ctx}

	// Record call args
	mmGetKnowledgeBase.GetKnowledgeBaseMock.mutex.Lock()
	mmGetKnowledgeBase.GetKnowledgeBaseMock.callArgs = append(mmGetKnowledgeBase.GetKnowledgeBaseMock.callArgs, &mm_params)
	mmGetKnowledgeBase.GetKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBase.GetKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmGetKnowledgeBase.GetKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBase.GetKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBase.GetKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBase.GetKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetKnowledgeBaseParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBase.t.Errorf("RepositoryMock.GetKnowledgeBase got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBase.t.Errorf("RepositoryMock.GetKnowledgeBase got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBase.GetKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBase.t.Fatal("No results are set for the RepositoryMock.GetKnowledgeBase")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmGetKnowledgeBase.funcGetKnowledgeBase != nil {
		return mmGetKnowledgeBase.funcGetKnowledgeBase(ctx)
	}
	mmGetKnowledgeBase.t.Fatalf("Unexpected call to RepositoryMock.GetKnowledgeBase. %v", ctx)
	return
}

// GetKnowledgeBaseAfterCounter returns a count of finished RepositoryMock.GetKnowledgeBase invocations
func (mmGetKnowledgeBase *RepositoryMock) GetKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBase.afterGetKnowledgeBaseCounter)
}

// GetKnowledgeBaseBeforeCounter returns a count of RepositoryMock.GetKnowledgeBase invocations
func (mmGetKnowledgeBase *RepositoryMock) GetKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBase.beforeGetKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBase *mRepositoryMockGetKnowledgeBase) Calls() []*RepositoryMockGetKnowledgeBaseParams {
	mmGetKnowledgeBase.mutex.RLock()

	argCopy := make([]*RepositoryMockGetKnowledgeBaseParams, len(mmGetKnowledgeBase.callArgs))
	copy(argCopy, mmGetKnowledgeBase.callArgs)

	mmGetKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBaseDone returns true if the count of the GetKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetKnowledgeBaseDone() bool {
	for _, e := range m.GetKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBaseMock.invocationsDone()
}

// MinimockGetKnowledgeBaseInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetKnowledgeBaseInspect() {
	for _, e := range m.GetKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBase with params: %#v", *e.params)
		}
	}

	afterGetKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBaseMock.defaultExpectation != nil && afterGetKnowledgeBaseCounter < 1 {
		if m.GetKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetKnowledgeBase")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBase with params: %#v", *m.GetKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBase != nil && afterGetKnowledgeBaseCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.GetKnowledgeBase")
	}

	if !m.GetKnowledgeBaseMock.invocationsDone() && afterGetKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetKnowledgeBase but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBaseMock.expectedInvocations), afterGetKnowledgeBaseCounter)
	}
}

type mRepositoryMockGetRepositoryTag struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetRepositoryTagExpectation
	expectations       []*RepositoryMockGetRepositoryTagExpectation

	callArgs []*RepositoryMockGetRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockGetRepositoryTagExpectation specifies expectation struct of the Repository.GetRepositoryTag
type RepositoryMockGetRepositoryTagExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockGetRepositoryTagParams
	paramPtrs *RepositoryMockGetRepositoryTagParamPtrs
	results   *RepositoryMockGetRepositoryTagResults
	Counter   uint64
}

// RepositoryMockGetRepositoryTagParams contains parameters of the Repository.GetRepositoryTag
type RepositoryMockGetRepositoryTagParams struct {
	ctx context.Context
	r1  mm_service.RepositoryTagName
}

// RepositoryMockGetRepositoryTagParamPtrs contains pointers to parameters of the Repository.GetRepositoryTag
type RepositoryMockGetRepositoryTagParamPtrs struct {
	ctx *context.Context
	r1  *mm_service.RepositoryTagName
}

// RepositoryMockGetRepositoryTagResults contains results of the Repository.GetRepositoryTag
type RepositoryMockGetRepositoryTagResults struct {
	rp1 *pb.RepositoryTag
	err error
}

// Expect sets up expected params for Repository.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) Expect(ctx context.Context, r1 mm_service.RepositoryTagName) *mRepositoryMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by ExpectParams functions")
	}

	mmGetRepositoryTag.defaultExpectation.params = &RepositoryMockGetRepositoryTagParams{ctx, r1}
	for _, e := range mmGetRepositoryTag.expectations {
		if minimock.Equal(e.params, mmGetRepositoryTag.defaultExpectation.params) {
			mmGetRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRepositoryTag.defaultExpectation.params)
		}
	}

	return mmGetRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.params != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by Expect")
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmGetRepositoryTag.defaultExpectation.paramPtrs = &RepositoryMockGetRepositoryTagParamPtrs{}
	}
	mmGetRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetRepositoryTag
}

// ExpectR1Param2 sets up expected param r1 for Repository.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) ExpectR1Param2(r1 mm_service.RepositoryTagName) *mRepositoryMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.params != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by Expect")
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmGetRepositoryTag.defaultExpectation.paramPtrs = &RepositoryMockGetRepositoryTagParamPtrs{}
	}
	mmGetRepositoryTag.defaultExpectation.paramPtrs.r1 = &r1

	return mmGetRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) Inspect(f func(ctx context.Context, r1 mm_service.RepositoryTagName)) *mRepositoryMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.inspectFuncGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetRepositoryTag")
	}

	mmGetRepositoryTag.mock.inspectFuncGetRepositoryTag = f

	return mmGetRepositoryTag
}

// Return sets up results that will be returned by Repository.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) Return(rp1 *pb.RepositoryTag, err error) *RepositoryMock {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryMockGetRepositoryTagExpectation{mock: mmGetRepositoryTag.mock}
	}
	mmGetRepositoryTag.defaultExpectation.results = &RepositoryMockGetRepositoryTagResults{rp1, err}
	return mmGetRepositoryTag.mock
}

// Set uses given function f to mock the Repository.GetRepositoryTag method
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) Set(f func(ctx context.Context, r1 mm_service.RepositoryTagName) (rp1 *pb.RepositoryTag, err error)) *RepositoryMock {
	if mmGetRepositoryTag.defaultExpectation != nil {
		mmGetRepositoryTag.mock.t.Fatalf("Default expectation is already set for the Repository.GetRepositoryTag method")
	}

	if len(mmGetRepositoryTag.expectations) > 0 {
		mmGetRepositoryTag.mock.t.Fatalf("Some expectations are already set for the Repository.GetRepositoryTag method")
	}

	mmGetRepositoryTag.mock.funcGetRepositoryTag = f
	return mmGetRepositoryTag.mock
}

// When sets expectation for the Repository.GetRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) When(ctx context.Context, r1 mm_service.RepositoryTagName) *RepositoryMockGetRepositoryTagExpectation {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by Set")
	}

	expectation := &RepositoryMockGetRepositoryTagExpectation{
		mock:   mmGetRepositoryTag.mock,
		params: &RepositoryMockGetRepositoryTagParams{ctx, r1},
	}
	mmGetRepositoryTag.expectations = append(mmGetRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetRepositoryTag return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetRepositoryTagExpectation) Then(rp1 *pb.RepositoryTag, err error) *RepositoryMock {
	e.results = &RepositoryMockGetRepositoryTagResults{rp1, err}
	return e.mock
}

// Times sets number of times Repository.GetRepositoryTag should be invoked
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) Times(n uint64) *mRepositoryMockGetRepositoryTag {
	if n == 0 {
		mmGetRepositoryTag.mock.t.Fatalf("Times of RepositoryMock.GetRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRepositoryTag.expectedInvocations, n)
	return mmGetRepositoryTag
}

func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) invocationsDone() bool {
	if len(mmGetRepositoryTag.expectations) == 0 && mmGetRepositoryTag.defaultExpectation == nil && mmGetRepositoryTag.mock.funcGetRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRepositoryTag.mock.afterGetRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRepositoryTag implements service.Repository
func (mmGetRepositoryTag *RepositoryMock) GetRepositoryTag(ctx context.Context, r1 mm_service.RepositoryTagName) (rp1 *pb.RepositoryTag, err error) {
	mm_atomic.AddUint64(&mmGetRepositoryTag.beforeGetRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRepositoryTag.afterGetRepositoryTagCounter, 1)

	if mmGetRepositoryTag.inspectFuncGetRepositoryTag != nil {
		mmGetRepositoryTag.inspectFuncGetRepositoryTag(ctx, r1)
	}

	mm_params := RepositoryMockGetRepositoryTagParams{ctx, r1}

	// Record call args
	mmGetRepositoryTag.GetRepositoryTagMock.mutex.Lock()
	mmGetRepositoryTag.GetRepositoryTagMock.callArgs = append(mmGetRepositoryTag.GetRepositoryTagMock.callArgs, &mm_params)
	mmGetRepositoryTag.GetRepositoryTagMock.mutex.Unlock()

	for _, e := range mmGetRepositoryTag.GetRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetRepositoryTagParams{ctx, r1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetRepositoryTag.t.Errorf("RepositoryMock.GetRepositoryTag got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.r1 != nil && !minimock.Equal(*mm_want_ptrs.r1, mm_got.r1) {
				mmGetRepositoryTag.t.Errorf("RepositoryMock.GetRepositoryTag got unexpected parameter r1, want: %#v, got: %#v%s\n", *mm_want_ptrs.r1, mm_got.r1, minimock.Diff(*mm_want_ptrs.r1, mm_got.r1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRepositoryTag.t.Errorf("RepositoryMock.GetRepositoryTag got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRepositoryTag.t.Fatal("No results are set for the RepositoryMock.GetRepositoryTag")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmGetRepositoryTag.funcGetRepositoryTag != nil {
		return mmGetRepositoryTag.funcGetRepositoryTag(ctx, r1)
	}
	mmGetRepositoryTag.t.Fatalf("Unexpected call to RepositoryMock.GetRepositoryTag. %v %v", ctx, r1)
	return
}

// GetRepositoryTagAfterCounter returns a count of finished RepositoryMock.GetRepositoryTag invocations
func (mmGetRepositoryTag *RepositoryMock) GetRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRepositoryTag.afterGetRepositoryTagCounter)
}

// GetRepositoryTagBeforeCounter returns a count of RepositoryMock.GetRepositoryTag invocations
func (mmGetRepositoryTag *RepositoryMock) GetRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRepositoryTag.beforeGetRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) Calls() []*RepositoryMockGetRepositoryTagParams {
	mmGetRepositoryTag.mutex.RLock()

	argCopy := make([]*RepositoryMockGetRepositoryTagParams, len(mmGetRepositoryTag.callArgs))
	copy(argCopy, mmGetRepositoryTag.callArgs)

	mmGetRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockGetRepositoryTagDone returns true if the count of the GetRepositoryTag invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetRepositoryTagDone() bool {
	for _, e := range m.GetRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRepositoryTagMock.invocationsDone()
}

// MinimockGetRepositoryTagInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetRepositoryTagInspect() {
	for _, e := range m.GetRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetRepositoryTag with params: %#v", *e.params)
		}
	}

	afterGetRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterGetRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRepositoryTagMock.defaultExpectation != nil && afterGetRepositoryTagCounter < 1 {
		if m.GetRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetRepositoryTag")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetRepositoryTag with params: %#v", *m.GetRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRepositoryTag != nil && afterGetRepositoryTagCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.GetRepositoryTag")
	}

	if !m.GetRepositoryTagMock.invocationsDone() && afterGetRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetRepositoryTag but found %d calls",
			mm_atomic.LoadUint64(&m.GetRepositoryTagMock.expectedInvocations), afterGetRepositoryTagCounter)
	}
}

type mRepositoryMockUpdateKnowledgeBase struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateKnowledgeBaseExpectation
	expectations       []*RepositoryMockUpdateKnowledgeBaseExpectation

	callArgs []*RepositoryMockUpdateKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockUpdateKnowledgeBaseExpectation specifies expectation struct of the Repository.UpdateKnowledgeBase
type RepositoryMockUpdateKnowledgeBaseExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockUpdateKnowledgeBaseParams
	paramPtrs *RepositoryMockUpdateKnowledgeBaseParamPtrs
	results   *RepositoryMockUpdateKnowledgeBaseResults
	Counter   uint64
}

// RepositoryMockUpdateKnowledgeBaseParams contains parameters of the Repository.UpdateKnowledgeBase
type RepositoryMockUpdateKnowledgeBaseParams struct {
	ctx context.Context
	kb  mm_service.KnowledgeBase
}

// RepositoryMockUpdateKnowledgeBaseParamPtrs contains pointers to parameters of the Repository.UpdateKnowledgeBase
type RepositoryMockUpdateKnowledgeBaseParamPtrs struct {
	ctx *context.Context
	kb  *mm_service.KnowledgeBase
}

// RepositoryMockUpdateKnowledgeBaseResults contains results of the Repository.UpdateKnowledgeBase
type RepositoryMockUpdateKnowledgeBaseResults struct {
	kp1 *mm_service.KnowledgeBase
	err error
}

// Expect sets up expected params for Repository.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) Expect(ctx context.Context, kb mm_service.KnowledgeBase) *mRepositoryMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmUpdateKnowledgeBase.defaultExpectation.params = &RepositoryMockUpdateKnowledgeBaseParams{ctx, kb}
	for _, e := range mmUpdateKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmUpdateKnowledgeBase.defaultExpectation.params) {
			mmUpdateKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmUpdateKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.params != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by Expect")
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseParamPtrs{}
	}
	mmUpdateKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateKnowledgeBase
}

// ExpectKbParam2 sets up expected param kb for Repository.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) ExpectKbParam2(kb mm_service.KnowledgeBase) *mRepositoryMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.params != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by Expect")
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseParamPtrs{}
	}
	mmUpdateKnowledgeBase.defaultExpectation.paramPtrs.kb = &kb

	return mmUpdateKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) Inspect(f func(ctx context.Context, kb mm_service.KnowledgeBase)) *mRepositoryMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.inspectFuncUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateKnowledgeBase")
	}

	mmUpdateKnowledgeBase.mock.inspectFuncUpdateKnowledgeBase = f

	return mmUpdateKnowledgeBase
}

// Return sets up results that will be returned by Repository.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) Return(kp1 *mm_service.KnowledgeBase, err error) *RepositoryMock {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseExpectation{mock: mmUpdateKnowledgeBase.mock}
	}
	mmUpdateKnowledgeBase.defaultExpectation.results = &RepositoryMockUpdateKnowledgeBaseResults{kp1, err}
	return mmUpdateKnowledgeBase.mock
}

// Set uses given function f to mock the Repository.UpdateKnowledgeBase method
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) Set(f func(ctx context.Context, kb mm_service.KnowledgeBase) (kp1 *mm_service.KnowledgeBase, err error)) *RepositoryMock {
	if mmUpdateKnowledgeBase.defaultExpectation != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateKnowledgeBase method")
	}

	if len(mmUpdateKnowledgeBase.expectations) > 0 {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateKnowledgeBase method")
	}

	mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase = f
	return mmUpdateKnowledgeBase.mock
}

// When sets expectation for the Repository.UpdateKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) When(ctx context.Context, kb mm_service.KnowledgeBase) *RepositoryMockUpdateKnowledgeBaseExpectation {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateKnowledgeBaseExpectation{
		mock:   mmUpdateKnowledgeBase.mock,
		params: &RepositoryMockUpdateKnowledgeBaseParams{ctx, kb},
	}
	mmUpdateKnowledgeBase.expectations = append(mmUpdateKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateKnowledgeBaseExpectation) Then(kp1 *mm_service.KnowledgeBase, err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateKnowledgeBaseResults{kp1, err}
	return e.mock
}

// Times sets number of times Repository.UpdateKnowledgeBase should be invoked
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) Times(n uint64) *mRepositoryMockUpdateKnowledgeBase {
	if n == 0 {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Times of RepositoryMock.UpdateKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateKnowledgeBase.expectedInvocations, n)
	return mmUpdateKnowledgeBase
}

func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) invocationsDone() bool {
	if len(mmUpdateKnowledgeBase.expectations) == 0 && mmUpdateKnowledgeBase.defaultExpectation == nil && mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.mock.afterUpdateKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateKnowledgeBase implements service.Repository
func (mmUpdateKnowledgeBase *RepositoryMock) UpdateKnowledgeBase(ctx context.Context, kb mm_service.KnowledgeBase) (kp1 *mm_service.KnowledgeBase, err error) {
	mm_atomic.AddUint64(&mmUpdateKnowledgeBase.beforeUpdateKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateKnowledgeBase.afterUpdateKnowledgeBaseCounter, 1)

	if mmUpdateKnowledgeBase.inspectFuncUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.inspectFuncUpdateKnowledgeBase(ctx, kb)
	}

	mm_params := RepositoryMockUpdateKnowledgeBaseParams{ctx, kb}

	// Record call args
	mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.mutex.Lock()
	mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.callArgs = append(mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.callArgs, &mm_params)
	mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateKnowledgeBaseParams{ctx, kb}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateKnowledgeBase.t.Errorf("RepositoryMock.UpdateKnowledgeBase got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kb != nil && !minimock.Equal(*mm_want_ptrs.kb, mm_got.kb) {
				mmUpdateKnowledgeBase.t.Errorf("RepositoryMock.UpdateKnowledgeBase got unexpected parameter kb, want: %#v, got: %#v%s\n", *mm_want_ptrs.kb, mm_got.kb, minimock.Diff(*mm_want_ptrs.kb, mm_got.kb))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateKnowledgeBase.t.Errorf("RepositoryMock.UpdateKnowledgeBase got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateKnowledgeBase.t.Fatal("No results are set for the RepositoryMock.UpdateKnowledgeBase")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmUpdateKnowledgeBase.funcUpdateKnowledgeBase != nil {
		return mmUpdateKnowledgeBase.funcUpdateKnowledgeBase(ctx, kb)
	}
	mmUpdateKnowledgeBase.t.Fatalf("Unexpected call to RepositoryMock.UpdateKnowledgeBase. %v %v", ctx, kb)
	return
}

// UpdateKnowledgeBaseAfterCounter returns a count of finished RepositoryMock.UpdateKnowledgeBase invocations
func (mmUpdateKnowledgeBase *RepositoryMock) UpdateKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.afterUpdateKnowledgeBaseCounter)
}

// UpdateKnowledgeBaseBeforeCounter returns a count of RepositoryMock.UpdateKnowledgeBase invocations
func (mmUpdateKnowledgeBase *RepositoryMock) UpdateKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.beforeUpdateKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) Calls() []*RepositoryMockUpdateKnowledgeBaseParams {
	mmUpdateKnowledgeBase.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateKnowledgeBaseParams, len(mmUpdateKnowledgeBase.callArgs))
	copy(argCopy, mmUpdateKnowledgeBase.callArgs)

	mmUpdateKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateKnowledgeBaseDone returns true if the count of the UpdateKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateKnowledgeBaseDone() bool {
	for _, e := range m.UpdateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateKnowledgeBaseMock.invocationsDone()
}

// MinimockUpdateKnowledgeBaseInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateKnowledgeBaseInspect() {
	for _, e := range m.UpdateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBase with params: %#v", *e.params)
		}
	}

	afterUpdateKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterUpdateKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateKnowledgeBaseMock.defaultExpectation != nil && afterUpdateKnowledgeBaseCounter < 1 {
		if m.UpdateKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.UpdateKnowledgeBase")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBase with params: %#v", *m.UpdateKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateKnowledgeBase != nil && afterUpdateKnowledgeBaseCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.UpdateKnowledgeBase")
	}

	if !m.UpdateKnowledgeBaseMock.invocationsDone() && afterUpdateKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateKnowledgeBase but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateKnowledgeBaseMock.expectedInvocations), afterUpdateKnowledgeBaseCounter)
	}
}

type mRepositoryMockUpsertRepositoryTag struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpsertRepositoryTagExpectation
	expectations       []*RepositoryMockUpsertRepositoryTagExpectation

	callArgs []*RepositoryMockUpsertRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockUpsertRepositoryTagExpectation specifies expectation struct of the Repository.UpsertRepositoryTag
type RepositoryMockUpsertRepositoryTagExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockUpsertRepositoryTagParams
	paramPtrs *RepositoryMockUpsertRepositoryTagParamPtrs
	results   *RepositoryMockUpsertRepositoryTagResults
	Counter   uint64
}

// RepositoryMockUpsertRepositoryTagParams contains parameters of the Repository.UpsertRepositoryTag
type RepositoryMockUpsertRepositoryTagParams struct {
	ctx context.Context
	rp1 *pb.RepositoryTag
}

// RepositoryMockUpsertRepositoryTagParamPtrs contains pointers to parameters of the Repository.UpsertRepositoryTag
type RepositoryMockUpsertRepositoryTagParamPtrs struct {
	ctx *context.Context
	rp1 **pb.RepositoryTag
}

// RepositoryMockUpsertRepositoryTagResults contains results of the Repository.UpsertRepositoryTag
type RepositoryMockUpsertRepositoryTagResults struct {
	rp2 *pb.RepositoryTag
	err error
}

// Expect sets up expected params for Repository.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) Expect(ctx context.Context, rp1 *pb.RepositoryTag) *mRepositoryMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryMockUpsertRepositoryTagExpectation{}
	}

	if mmUpsertRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by ExpectParams functions")
	}

	mmUpsertRepositoryTag.defaultExpectation.params = &RepositoryMockUpsertRepositoryTagParams{ctx, rp1}
	for _, e := range mmUpsertRepositoryTag.expectations {
		if minimock.Equal(e.params, mmUpsertRepositoryTag.defaultExpectation.params) {
			mmUpsertRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertRepositoryTag.defaultExpectation.params)
		}
	}

	return mmUpsertRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryMockUpsertRepositoryTagExpectation{}
	}

	if mmUpsertRepositoryTag.defaultExpectation.params != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by Expect")
	}

	if mmUpsertRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmUpsertRepositoryTag.defaultExpectation.paramPtrs = &RepositoryMockUpsertRepositoryTagParamPtrs{}
	}
	mmUpsertRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpsertRepositoryTag
}

// ExpectRp1Param2 sets up expected param rp1 for Repository.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) ExpectRp1Param2(rp1 *pb.RepositoryTag) *mRepositoryMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryMockUpsertRepositoryTagExpectation{}
	}

	if mmUpsertRepositoryTag.defaultExpectation.params != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by Expect")
	}

	if mmUpsertRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmUpsertRepositoryTag.defaultExpectation.paramPtrs = &RepositoryMockUpsertRepositoryTagParamPtrs{}
	}
	mmUpsertRepositoryTag.defaultExpectation.paramPtrs.rp1 = &rp1

	return mmUpsertRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) Inspect(f func(ctx context.Context, rp1 *pb.RepositoryTag)) *mRepositoryMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.inspectFuncUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpsertRepositoryTag")
	}

	mmUpsertRepositoryTag.mock.inspectFuncUpsertRepositoryTag = f

	return mmUpsertRepositoryTag
}

// Return sets up results that will be returned by Repository.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) Return(rp2 *pb.RepositoryTag, err error) *RepositoryMock {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryMockUpsertRepositoryTagExpectation{mock: mmUpsertRepositoryTag.mock}
	}
	mmUpsertRepositoryTag.defaultExpectation.results = &RepositoryMockUpsertRepositoryTagResults{rp2, err}
	return mmUpsertRepositoryTag.mock
}

// Set uses given function f to mock the Repository.UpsertRepositoryTag method
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) Set(f func(ctx context.Context, rp1 *pb.RepositoryTag) (rp2 *pb.RepositoryTag, err error)) *RepositoryMock {
	if mmUpsertRepositoryTag.defaultExpectation != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("Default expectation is already set for the Repository.UpsertRepositoryTag method")
	}

	if len(mmUpsertRepositoryTag.expectations) > 0 {
		mmUpsertRepositoryTag.mock.t.Fatalf("Some expectations are already set for the Repository.UpsertRepositoryTag method")
	}

	mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag = f
	return mmUpsertRepositoryTag.mock
}

// When sets expectation for the Repository.UpsertRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) When(ctx context.Context, rp1 *pb.RepositoryTag) *RepositoryMockUpsertRepositoryTagExpectation {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by Set")
	}

	expectation := &RepositoryMockUpsertRepositoryTagExpectation{
		mock:   mmUpsertRepositoryTag.mock,
		params: &RepositoryMockUpsertRepositoryTagParams{ctx, rp1},
	}
	mmUpsertRepositoryTag.expectations = append(mmUpsertRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpsertRepositoryTag return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpsertRepositoryTagExpectation) Then(rp2 *pb.RepositoryTag, err error) *RepositoryMock {
	e.results = &RepositoryMockUpsertRepositoryTagResults{rp2, err}
	return e.mock
}

// Times sets number of times Repository.UpsertRepositoryTag should be invoked
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) Times(n uint64) *mRepositoryMockUpsertRepositoryTag {
	if n == 0 {
		mmUpsertRepositoryTag.mock.t.Fatalf("Times of RepositoryMock.UpsertRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpsertRepositoryTag.expectedInvocations, n)
	return mmUpsertRepositoryTag
}

func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) invocationsDone() bool {
	if len(mmUpsertRepositoryTag.expectations) == 0 && mmUpsertRepositoryTag.defaultExpectation == nil && mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpsertRepositoryTag.mock.afterUpsertRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpsertRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpsertRepositoryTag implements service.Repository
func (mmUpsertRepositoryTag *RepositoryMock) UpsertRepositoryTag(ctx context.Context, rp1 *pb.RepositoryTag) (rp2 *pb.RepositoryTag, err error) {
	mm_atomic.AddUint64(&mmUpsertRepositoryTag.beforeUpsertRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertRepositoryTag.afterUpsertRepositoryTagCounter, 1)

	if mmUpsertRepositoryTag.inspectFuncUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.inspectFuncUpsertRepositoryTag(ctx, rp1)
	}

	mm_params := RepositoryMockUpsertRepositoryTagParams{ctx, rp1}

	// Record call args
	mmUpsertRepositoryTag.UpsertRepositoryTagMock.mutex.Lock()
	mmUpsertRepositoryTag.UpsertRepositoryTagMock.callArgs = append(mmUpsertRepositoryTag.UpsertRepositoryTagMock.callArgs, &mm_params)
	mmUpsertRepositoryTag.UpsertRepositoryTagMock.mutex.Unlock()

	for _, e := range mmUpsertRepositoryTag.UpsertRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp2, e.results.err
		}
	}

	if mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpsertRepositoryTagParams{ctx, rp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpsertRepositoryTag.t.Errorf("RepositoryMock.UpsertRepositoryTag got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.rp1 != nil && !minimock.Equal(*mm_want_ptrs.rp1, mm_got.rp1) {
				mmUpsertRepositoryTag.t.Errorf("RepositoryMock.UpsertRepositoryTag got unexpected parameter rp1, want: %#v, got: %#v%s\n", *mm_want_ptrs.rp1, mm_got.rp1, minimock.Diff(*mm_want_ptrs.rp1, mm_got.rp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsertRepositoryTag.t.Errorf("RepositoryMock.UpsertRepositoryTag got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsertRepositoryTag.t.Fatal("No results are set for the RepositoryMock.UpsertRepositoryTag")
		}
		return (*mm_results).rp2, (*mm_results).err
	}
	if mmUpsertRepositoryTag.funcUpsertRepositoryTag != nil {
		return mmUpsertRepositoryTag.funcUpsertRepositoryTag(ctx, rp1)
	}
	mmUpsertRepositoryTag.t.Fatalf("Unexpected call to RepositoryMock.UpsertRepositoryTag. %v %v", ctx, rp1)
	return
}

// UpsertRepositoryTagAfterCounter returns a count of finished RepositoryMock.UpsertRepositoryTag invocations
func (mmUpsertRepositoryTag *RepositoryMock) UpsertRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertRepositoryTag.afterUpsertRepositoryTagCounter)
}

// UpsertRepositoryTagBeforeCounter returns a count of RepositoryMock.UpsertRepositoryTag invocations
func (mmUpsertRepositoryTag *RepositoryMock) UpsertRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertRepositoryTag.beforeUpsertRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpsertRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) Calls() []*RepositoryMockUpsertRepositoryTagParams {
	mmUpsertRepositoryTag.mutex.RLock()

	argCopy := make([]*RepositoryMockUpsertRepositoryTagParams, len(mmUpsertRepositoryTag.callArgs))
	copy(argCopy, mmUpsertRepositoryTag.callArgs)

	mmUpsertRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertRepositoryTagDone returns true if the count of the UpsertRepositoryTag invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpsertRepositoryTagDone() bool {
	for _, e := range m.UpsertRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpsertRepositoryTagMock.invocationsDone()
}

// MinimockUpsertRepositoryTagInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpsertRepositoryTagInspect() {
	for _, e := range m.UpsertRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpsertRepositoryTag with params: %#v", *e.params)
		}
	}

	afterUpsertRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterUpsertRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertRepositoryTagMock.defaultExpectation != nil && afterUpsertRepositoryTagCounter < 1 {
		if m.UpsertRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.UpsertRepositoryTag")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpsertRepositoryTag with params: %#v", *m.UpsertRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertRepositoryTag != nil && afterUpsertRepositoryTagCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.UpsertRepositoryTag")
	}

	if !m.UpsertRepositoryTagMock.invocationsDone() && afterUpsertRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpsertRepositoryTag but found %d calls",
			mm_atomic.LoadUint64(&m.UpsertRepositoryTagMock.expectedInvocations), afterUpsertRepositoryTagCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateKnowledgeBaseInspect()

			m.MinimockDeleteKnowledgeBaseInspect()

			m.MinimockGetKnowledgeBaseInspect()

			m.MinimockGetRepositoryTagInspect()

			m.MinimockUpdateKnowledgeBaseInspect()

			m.MinimockUpsertRepositoryTagInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateKnowledgeBaseDone() &&
		m.MinimockDeleteKnowledgeBaseDone() &&
		m.MinimockGetKnowledgeBaseDone() &&
		m.MinimockGetRepositoryTagDone() &&
		m.MinimockUpdateKnowledgeBaseDone() &&
		m.MinimockUpsertRepositoryTagDone()
}
