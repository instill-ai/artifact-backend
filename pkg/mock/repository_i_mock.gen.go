// Code generated by http://github.com/gojuno/minimock (v3.3.9). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gofrs/uuid"
	"github.com/gojuno/minimock/v3"
	mm_repository "github.com/instill-ai/artifact-backend/pkg/repository"
	"github.com/instill-ai/artifact-backend/pkg/utils"
	"gorm.io/gorm"
	pb "github.com/instill-ai/protogen-go/artifact/artifact/v1alpha"
)

// RepositoryIMock implements repository.RepositoryI
type RepositoryIMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcConversationTableName          func() (s1 string)
	inspectFuncConversationTableName   func()
	afterConversationTableNameCounter  uint64
	beforeConversationTableNameCounter uint64
	ConversationTableNameMock          mRepositoryIMockConversationTableName

	funcConvertedFileTableName          func() (s1 string)
	inspectFuncConvertedFileTableName   func()
	afterConvertedFileTableNameCounter  uint64
	beforeConvertedFileTableNameCounter uint64
	ConvertedFileTableNameMock          mRepositoryIMockConvertedFileTableName

	funcCreateConversation          func(ctx context.Context, conv mm_repository.Conversation) (cp1 *mm_repository.Conversation, err error)
	inspectFuncCreateConversation   func(ctx context.Context, conv mm_repository.Conversation)
	afterCreateConversationCounter  uint64
	beforeCreateConversationCounter uint64
	CreateConversationMock          mRepositoryIMockCreateConversation

	funcCreateConvertedFile          func(ctx context.Context, cf mm_repository.ConvertedFile, callExternalService func(convertedFileUID uuid.UUID) (map[string]any, error)) (cp1 *mm_repository.ConvertedFile, err error)
	inspectFuncCreateConvertedFile   func(ctx context.Context, cf mm_repository.ConvertedFile, callExternalService func(convertedFileUID uuid.UUID) (map[string]any, error))
	afterCreateConvertedFileCounter  uint64
	beforeCreateConvertedFileCounter uint64
	CreateConvertedFileMock          mRepositoryIMockCreateConvertedFile

	funcCreateKnowledgeBase          func(ctx context.Context, kb mm_repository.KnowledgeBase, externalService func(kbUID string) error) (kp1 *mm_repository.KnowledgeBase, err error)
	inspectFuncCreateKnowledgeBase   func(ctx context.Context, kb mm_repository.KnowledgeBase, externalService func(kbUID string) error)
	afterCreateKnowledgeBaseCounter  uint64
	beforeCreateKnowledgeBaseCounter uint64
	CreateKnowledgeBaseMock          mRepositoryIMockCreateKnowledgeBase

	funcCreateKnowledgeBaseFile          func(ctx context.Context, kb mm_repository.KnowledgeBaseFile, externalServiceCall func(FileUID string) error) (kp1 *mm_repository.KnowledgeBaseFile, err error)
	inspectFuncCreateKnowledgeBaseFile   func(ctx context.Context, kb mm_repository.KnowledgeBaseFile, externalServiceCall func(FileUID string) error)
	afterCreateKnowledgeBaseFileCounter  uint64
	beforeCreateKnowledgeBaseFileCounter uint64
	CreateKnowledgeBaseFileMock          mRepositoryIMockCreateKnowledgeBaseFile

	funcCreateMessage          func(ctx context.Context, msg mm_repository.Message) (mp1 *mm_repository.Message, err error)
	inspectFuncCreateMessage   func(ctx context.Context, msg mm_repository.Message)
	afterCreateMessageCounter  uint64
	beforeCreateMessageCounter uint64
	CreateMessageMock          mRepositoryIMockCreateMessage

	funcDeleteAllConvertedFilesInKb          func(ctx context.Context, kbUID uuid.UUID) (err error)
	inspectFuncDeleteAllConvertedFilesInKb   func(ctx context.Context, kbUID uuid.UUID)
	afterDeleteAllConvertedFilesInKbCounter  uint64
	beforeDeleteAllConvertedFilesInKbCounter uint64
	DeleteAllConvertedFilesInKbMock          mRepositoryIMockDeleteAllConvertedFilesInKb

	funcDeleteAllKnowledgeBaseFiles          func(ctx context.Context, kbUID string) (err error)
	inspectFuncDeleteAllKnowledgeBaseFiles   func(ctx context.Context, kbUID string)
	afterDeleteAllKnowledgeBaseFilesCounter  uint64
	beforeDeleteAllKnowledgeBaseFilesCounter uint64
	DeleteAllKnowledgeBaseFilesMock          mRepositoryIMockDeleteAllKnowledgeBaseFiles

	funcDeleteAndCreateChunks          func(ctx context.Context, sourceTable string, sourceUID uuid.UUID, chunks []*mm_repository.TextChunk, externalServiceCall func(chunkUIDs []string) (map[string]any, error)) (tpa1 []*mm_repository.TextChunk, err error)
	inspectFuncDeleteAndCreateChunks   func(ctx context.Context, sourceTable string, sourceUID uuid.UUID, chunks []*mm_repository.TextChunk, externalServiceCall func(chunkUIDs []string) (map[string]any, error))
	afterDeleteAndCreateChunksCounter  uint64
	beforeDeleteAndCreateChunksCounter uint64
	DeleteAndCreateChunksMock          mRepositoryIMockDeleteAndCreateChunks

	funcDeleteChunksBySource          func(ctx context.Context, sourceTable string, sourceUID uuid.UUID) (err error)
	inspectFuncDeleteChunksBySource   func(ctx context.Context, sourceTable string, sourceUID uuid.UUID)
	afterDeleteChunksBySourceCounter  uint64
	beforeDeleteChunksBySourceCounter uint64
	DeleteChunksBySourceMock          mRepositoryIMockDeleteChunksBySource

	funcDeleteChunksByUIDs          func(ctx context.Context, chunkUIDs []uuid.UUID) (err error)
	inspectFuncDeleteChunksByUIDs   func(ctx context.Context, chunkUIDs []uuid.UUID)
	afterDeleteChunksByUIDsCounter  uint64
	beforeDeleteChunksByUIDsCounter uint64
	DeleteChunksByUIDsMock          mRepositoryIMockDeleteChunksByUIDs

	funcDeleteConvertedFile          func(ctx context.Context, uid uuid.UUID) (err error)
	inspectFuncDeleteConvertedFile   func(ctx context.Context, uid uuid.UUID)
	afterDeleteConvertedFileCounter  uint64
	beforeDeleteConvertedFileCounter uint64
	DeleteConvertedFileMock          mRepositoryIMockDeleteConvertedFile

	funcDeleteEmbeddingsBySource          func(ctx context.Context, sourceTable string, sourceUID uuid.UUID) (err error)
	inspectFuncDeleteEmbeddingsBySource   func(ctx context.Context, sourceTable string, sourceUID uuid.UUID)
	afterDeleteEmbeddingsBySourceCounter  uint64
	beforeDeleteEmbeddingsBySourceCounter uint64
	DeleteEmbeddingsBySourceMock          mRepositoryIMockDeleteEmbeddingsBySource

	funcDeleteEmbeddingsByUIDs          func(ctx context.Context, embUIDs []uuid.UUID) (err error)
	inspectFuncDeleteEmbeddingsByUIDs   func(ctx context.Context, embUIDs []uuid.UUID)
	afterDeleteEmbeddingsByUIDsCounter  uint64
	beforeDeleteEmbeddingsByUIDsCounter uint64
	DeleteEmbeddingsByUIDsMock          mRepositoryIMockDeleteEmbeddingsByUIDs

	funcDeleteKnowledgeBase          func(ctx context.Context, ownerUID string, kbID string) (kp1 *mm_repository.KnowledgeBase, err error)
	inspectFuncDeleteKnowledgeBase   func(ctx context.Context, ownerUID string, kbID string)
	afterDeleteKnowledgeBaseCounter  uint64
	beforeDeleteKnowledgeBaseCounter uint64
	DeleteKnowledgeBaseMock          mRepositoryIMockDeleteKnowledgeBase

	funcDeleteKnowledgeBaseFile          func(ctx context.Context, fileUID string) (err error)
	inspectFuncDeleteKnowledgeBaseFile   func(ctx context.Context, fileUID string)
	afterDeleteKnowledgeBaseFileCounter  uint64
	beforeDeleteKnowledgeBaseFileCounter uint64
	DeleteKnowledgeBaseFileMock          mRepositoryIMockDeleteKnowledgeBaseFile

	funcDeleteKnowledgeBaseFileAndDecreaseUsage          func(ctx context.Context, fileUID uuid.UUID) (err error)
	inspectFuncDeleteKnowledgeBaseFileAndDecreaseUsage   func(ctx context.Context, fileUID uuid.UUID)
	afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter  uint64
	beforeDeleteKnowledgeBaseFileAndDecreaseUsageCounter uint64
	DeleteKnowledgeBaseFileAndDecreaseUsageMock          mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage

	funcDeleteMessage          func(ctx context.Context, messageUID uuid.UUID) (err error)
	inspectFuncDeleteMessage   func(ctx context.Context, messageUID uuid.UUID)
	afterDeleteMessageCounter  uint64
	beforeDeleteMessageCounter uint64
	DeleteMessageMock          mRepositoryIMockDeleteMessage

	funcDeleteRepositoryTag          func(ctx context.Context, s1 string) (err error)
	inspectFuncDeleteRepositoryTag   func(ctx context.Context, s1 string)
	afterDeleteRepositoryTagCounter  uint64
	beforeDeleteRepositoryTagCounter uint64
	DeleteRepositoryTagMock          mRepositoryIMockDeleteRepositoryTag

	funcGetChunksByUIDs          func(ctx context.Context, chunkUIDs []uuid.UUID) (ta1 []mm_repository.TextChunk, err error)
	inspectFuncGetChunksByUIDs   func(ctx context.Context, chunkUIDs []uuid.UUID)
	afterGetChunksByUIDsCounter  uint64
	beforeGetChunksByUIDsCounter uint64
	GetChunksByUIDsMock          mRepositoryIMockGetChunksByUIDs

	funcGetConversationByID          func(ctx context.Context, namespaceUID uuid.UUID, catalogUID uuid.UUID, conversationID string) (cp1 *mm_repository.Conversation, err error)
	inspectFuncGetConversationByID   func(ctx context.Context, namespaceUID uuid.UUID, catalogUID uuid.UUID, conversationID string)
	afterGetConversationByIDCounter  uint64
	beforeGetConversationByIDCounter uint64
	GetConversationByIDMock          mRepositoryIMockGetConversationByID

	funcGetConversationByUID          func(ctx context.Context, convUID uuid.UUID) (cp1 *mm_repository.Conversation, err error)
	inspectFuncGetConversationByUID   func(ctx context.Context, convUID uuid.UUID)
	afterGetConversationByUIDCounter  uint64
	beforeGetConversationByUIDCounter uint64
	GetConversationByUIDMock          mRepositoryIMockGetConversationByUID

	funcGetConvertedFileByFileUID          func(ctx context.Context, fileUID uuid.UUID) (cp1 *mm_repository.ConvertedFile, err error)
	inspectFuncGetConvertedFileByFileUID   func(ctx context.Context, fileUID uuid.UUID)
	afterGetConvertedFileByFileUIDCounter  uint64
	beforeGetConvertedFileByFileUIDCounter uint64
	GetConvertedFileByFileUIDMock          mRepositoryIMockGetConvertedFileByFileUID

	funcGetCountFilesByListKnowledgeBaseUID          func(ctx context.Context, kbUIDs []mm_repository.KbUID) (m1 map[mm_repository.KbUID]int64, err error)
	inspectFuncGetCountFilesByListKnowledgeBaseUID   func(ctx context.Context, kbUIDs []mm_repository.KbUID)
	afterGetCountFilesByListKnowledgeBaseUIDCounter  uint64
	beforeGetCountFilesByListKnowledgeBaseUIDCounter uint64
	GetCountFilesByListKnowledgeBaseUIDMock          mRepositoryIMockGetCountFilesByListKnowledgeBaseUID

	funcGetEmbeddingByUIDs          func(ctx context.Context, embUIDs []uuid.UUID) (ea1 []mm_repository.Embedding, err error)
	inspectFuncGetEmbeddingByUIDs   func(ctx context.Context, embUIDs []uuid.UUID)
	afterGetEmbeddingByUIDsCounter  uint64
	beforeGetEmbeddingByUIDsCounter uint64
	GetEmbeddingByUIDsMock          mRepositoryIMockGetEmbeddingByUIDs

	funcGetFilesTotalTokens func(ctx context.Context, sources map[mm_repository.FileUID]struct {
		SourceTable mm_repository.SourceTable
		SourceUID   mm_repository.SourceUID
	}) (m1 map[mm_repository.FileUID]int, err error)
	inspectFuncGetFilesTotalTokens func(ctx context.Context, sources map[mm_repository.FileUID]struct {
		SourceTable mm_repository.SourceTable
		SourceUID   mm_repository.SourceUID
	})
	afterGetFilesTotalTokensCounter  uint64
	beforeGetFilesTotalTokensCounter uint64
	GetFilesTotalTokensMock          mRepositoryIMockGetFilesTotalTokens

	funcGetKnowledgeBaseByOwnerAndKbID          func(ctx context.Context, ownerUID uuid.UUID, kbID string) (kp1 *mm_repository.KnowledgeBase, err error)
	inspectFuncGetKnowledgeBaseByOwnerAndKbID   func(ctx context.Context, ownerUID uuid.UUID, kbID string)
	afterGetKnowledgeBaseByOwnerAndKbIDCounter  uint64
	beforeGetKnowledgeBaseByOwnerAndKbIDCounter uint64
	GetKnowledgeBaseByOwnerAndKbIDMock          mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID

	funcGetKnowledgeBaseCountByOwner          func(ctx context.Context, ownerUID string) (i1 int64, err error)
	inspectFuncGetKnowledgeBaseCountByOwner   func(ctx context.Context, ownerUID string)
	afterGetKnowledgeBaseCountByOwnerCounter  uint64
	beforeGetKnowledgeBaseCountByOwnerCounter uint64
	GetKnowledgeBaseCountByOwnerMock          mRepositoryIMockGetKnowledgeBaseCountByOwner

	funcGetKnowledgeBaseFilesByFileUIDs          func(ctx context.Context, fileUIDs []uuid.UUID, columns ...string) (ka1 []mm_repository.KnowledgeBaseFile, err error)
	inspectFuncGetKnowledgeBaseFilesByFileUIDs   func(ctx context.Context, fileUIDs []uuid.UUID, columns ...string)
	afterGetKnowledgeBaseFilesByFileUIDsCounter  uint64
	beforeGetKnowledgeBaseFilesByFileUIDsCounter uint64
	GetKnowledgeBaseFilesByFileUIDsMock          mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs

	funcGetKnowledgebaseFileByKbUIDAndFileID          func(ctx context.Context, kbUID uuid.UUID, fileID string) (kp1 *mm_repository.KnowledgeBaseFile, err error)
	inspectFuncGetKnowledgebaseFileByKbUIDAndFileID   func(ctx context.Context, kbUID uuid.UUID, fileID string)
	afterGetKnowledgebaseFileByKbUIDAndFileIDCounter  uint64
	beforeGetKnowledgebaseFileByKbUIDAndFileIDCounter uint64
	GetKnowledgebaseFileByKbUIDAndFileIDMock          mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID

	funcGetMessageByUID          func(ctx context.Context, messageUID uuid.UUID) (mp1 *mm_repository.Message, err error)
	inspectFuncGetMessageByUID   func(ctx context.Context, messageUID uuid.UUID)
	afterGetMessageByUIDCounter  uint64
	beforeGetMessageByUIDCounter uint64
	GetMessageByUIDMock          mRepositoryIMockGetMessageByUID

	funcGetNeedProcessFiles          func(ctx context.Context) (ka1 []mm_repository.KnowledgeBaseFile)
	inspectFuncGetNeedProcessFiles   func(ctx context.Context)
	afterGetNeedProcessFilesCounter  uint64
	beforeGetNeedProcessFilesCounter uint64
	GetNeedProcessFilesMock          mRepositoryIMockGetNeedProcessFiles

	funcGetRepositoryTag          func(ctx context.Context, r1 utils.RepositoryTagName) (rp1 *pb.RepositoryTag, err error)
	inspectFuncGetRepositoryTag   func(ctx context.Context, r1 utils.RepositoryTagName)
	afterGetRepositoryTagCounter  uint64
	beforeGetRepositoryTagCounter uint64
	GetRepositoryTagMock          mRepositoryIMockGetRepositoryTag

	funcGetSourceTableAndUIDByFileUIDs func(ctx context.Context, files []mm_repository.KnowledgeBaseFile) (m1 map[mm_repository.FileUID]struct {
		SourceTable string
		SourceUID   uuid.UUID
	}, err error)
	inspectFuncGetSourceTableAndUIDByFileUIDs   func(ctx context.Context, files []mm_repository.KnowledgeBaseFile)
	afterGetSourceTableAndUIDByFileUIDsCounter  uint64
	beforeGetSourceTableAndUIDByFileUIDsCounter uint64
	GetSourceTableAndUIDByFileUIDsMock          mRepositoryIMockGetSourceTableAndUIDByFileUIDs

	funcGetTextChunksBySource          func(ctx context.Context, sourceTable string, sourceUID uuid.UUID) (ta1 []mm_repository.TextChunk, err error)
	inspectFuncGetTextChunksBySource   func(ctx context.Context, sourceTable string, sourceUID uuid.UUID)
	afterGetTextChunksBySourceCounter  uint64
	beforeGetTextChunksBySourceCounter uint64
	GetTextChunksBySourceMock          mRepositoryIMockGetTextChunksBySource

	funcGetTotalChunksBySources func(ctx context.Context, sources map[mm_repository.FileUID]struct {
		SourceTable mm_repository.SourceTable
		SourceUID   mm_repository.SourceUID
	}) (m1 map[mm_repository.FileUID]int, err error)
	inspectFuncGetTotalChunksBySources func(ctx context.Context, sources map[mm_repository.FileUID]struct {
		SourceTable mm_repository.SourceTable
		SourceUID   mm_repository.SourceUID
	})
	afterGetTotalChunksBySourcesCounter  uint64
	beforeGetTotalChunksBySourcesCounter uint64
	GetTotalChunksBySourcesMock          mRepositoryIMockGetTotalChunksBySources

	funcGetTotalTokensByListKBUIDs          func(ctx context.Context, kbUIDs []uuid.UUID) (m1 map[uuid.UUID]int, err error)
	inspectFuncGetTotalTokensByListKBUIDs   func(ctx context.Context, kbUIDs []uuid.UUID)
	afterGetTotalTokensByListKBUIDsCounter  uint64
	beforeGetTotalTokensByListKBUIDsCounter uint64
	GetTotalTokensByListKBUIDsMock          mRepositoryIMockGetTotalTokensByListKBUIDs

	funcGetTruthSourceByFileUID          func(ctx context.Context, fileUID uuid.UUID) (sp1 *mm_repository.SourceMeta, err error)
	inspectFuncGetTruthSourceByFileUID   func(ctx context.Context, fileUID uuid.UUID)
	afterGetTruthSourceByFileUIDCounter  uint64
	beforeGetTruthSourceByFileUIDCounter uint64
	GetTruthSourceByFileUIDMock          mRepositoryIMockGetTruthSourceByFileUID

	funcHardDeleteChunksByKbFileUID          func(ctx context.Context, kbFileUID uuid.UUID) (err error)
	inspectFuncHardDeleteChunksByKbFileUID   func(ctx context.Context, kbFileUID uuid.UUID)
	afterHardDeleteChunksByKbFileUIDCounter  uint64
	beforeHardDeleteChunksByKbFileUIDCounter uint64
	HardDeleteChunksByKbFileUIDMock          mRepositoryIMockHardDeleteChunksByKbFileUID

	funcHardDeleteChunksByKbUID          func(ctx context.Context, kbUID uuid.UUID) (err error)
	inspectFuncHardDeleteChunksByKbUID   func(ctx context.Context, kbUID uuid.UUID)
	afterHardDeleteChunksByKbUIDCounter  uint64
	beforeHardDeleteChunksByKbUIDCounter uint64
	HardDeleteChunksByKbUIDMock          mRepositoryIMockHardDeleteChunksByKbUID

	funcHardDeleteConvertedFileByFileUID          func(ctx context.Context, fileUID uuid.UUID) (err error)
	inspectFuncHardDeleteConvertedFileByFileUID   func(ctx context.Context, fileUID uuid.UUID)
	afterHardDeleteConvertedFileByFileUIDCounter  uint64
	beforeHardDeleteConvertedFileByFileUIDCounter uint64
	HardDeleteConvertedFileByFileUIDMock          mRepositoryIMockHardDeleteConvertedFileByFileUID

	funcHardDeleteEmbeddingsByKbFileUID          func(ctx context.Context, kbFileUID uuid.UUID) (err error)
	inspectFuncHardDeleteEmbeddingsByKbFileUID   func(ctx context.Context, kbFileUID uuid.UUID)
	afterHardDeleteEmbeddingsByKbFileUIDCounter  uint64
	beforeHardDeleteEmbeddingsByKbFileUIDCounter uint64
	HardDeleteEmbeddingsByKbFileUIDMock          mRepositoryIMockHardDeleteEmbeddingsByKbFileUID

	funcHardDeleteEmbeddingsByKbUID          func(ctx context.Context, kbUID uuid.UUID) (err error)
	inspectFuncHardDeleteEmbeddingsByKbUID   func(ctx context.Context, kbUID uuid.UUID)
	afterHardDeleteEmbeddingsByKbUIDCounter  uint64
	beforeHardDeleteEmbeddingsByKbUIDCounter uint64
	HardDeleteEmbeddingsByKbUIDMock          mRepositoryIMockHardDeleteEmbeddingsByKbUID

	funcIncreaseKnowledgeBaseUsage          func(ctx context.Context, tx *gorm.DB, kbUID string, amount int) (err error)
	inspectFuncIncreaseKnowledgeBaseUsage   func(ctx context.Context, tx *gorm.DB, kbUID string, amount int)
	afterIncreaseKnowledgeBaseUsageCounter  uint64
	beforeIncreaseKnowledgeBaseUsageCounter uint64
	IncreaseKnowledgeBaseUsageMock          mRepositoryIMockIncreaseKnowledgeBaseUsage

	funcKnowledgeBaseFileTableName          func() (s1 string)
	inspectFuncKnowledgeBaseFileTableName   func()
	afterKnowledgeBaseFileTableNameCounter  uint64
	beforeKnowledgeBaseFileTableNameCounter uint64
	KnowledgeBaseFileTableNameMock          mRepositoryIMockKnowledgeBaseFileTableName

	funcListChunksByKbFileUID          func(ctx context.Context, kbFileUID uuid.UUID) (ta1 []mm_repository.TextChunk, err error)
	inspectFuncListChunksByKbFileUID   func(ctx context.Context, kbFileUID uuid.UUID)
	afterListChunksByKbFileUIDCounter  uint64
	beforeListChunksByKbFileUIDCounter uint64
	ListChunksByKbFileUIDMock          mRepositoryIMockListChunksByKbFileUID

	funcListConversations          func(ctx context.Context, namespaceUID uuid.UUID, catalogUID uuid.UUID, pageSize int32, nextPageToken string) (cpa1 []*mm_repository.Conversation, i1 int, s1 string, err error)
	inspectFuncListConversations   func(ctx context.Context, namespaceUID uuid.UUID, catalogUID uuid.UUID, pageSize int32, nextPageToken string)
	afterListConversationsCounter  uint64
	beforeListConversationsCounter uint64
	ListConversationsMock          mRepositoryIMockListConversations

	funcListEmbeddingsByKbFileUID          func(ctx context.Context, kbFileUID uuid.UUID) (ea1 []mm_repository.Embedding, err error)
	inspectFuncListEmbeddingsByKbFileUID   func(ctx context.Context, kbFileUID uuid.UUID)
	afterListEmbeddingsByKbFileUIDCounter  uint64
	beforeListEmbeddingsByKbFileUIDCounter uint64
	ListEmbeddingsByKbFileUIDMock          mRepositoryIMockListEmbeddingsByKbFileUID

	funcListKnowledgeBaseFiles          func(ctx context.Context, uid string, ownerUID string, kbUID string, pageSize int32, nextPageToken string, filesUID []string) (ka1 []mm_repository.KnowledgeBaseFile, i1 int, s1 string, err error)
	inspectFuncListKnowledgeBaseFiles   func(ctx context.Context, uid string, ownerUID string, kbUID string, pageSize int32, nextPageToken string, filesUID []string)
	afterListKnowledgeBaseFilesCounter  uint64
	beforeListKnowledgeBaseFilesCounter uint64
	ListKnowledgeBaseFilesMock          mRepositoryIMockListKnowledgeBaseFiles

	funcListKnowledgeBases          func(ctx context.Context, ownerUID string) (ka1 []mm_repository.KnowledgeBase, err error)
	inspectFuncListKnowledgeBases   func(ctx context.Context, ownerUID string)
	afterListKnowledgeBasesCounter  uint64
	beforeListKnowledgeBasesCounter uint64
	ListKnowledgeBasesMock          mRepositoryIMockListKnowledgeBases

	funcListMessages          func(ctx context.Context, namespaceUID uuid.UUID, catalogUID uuid.UUID, conversationUID uuid.UUID, latestK int32, pageSize int32, pageToken string, includeSystemMessages bool) (mpa1 []*mm_repository.Message, s1 string, i1 int64, err error)
	inspectFuncListMessages   func(ctx context.Context, namespaceUID uuid.UUID, catalogUID uuid.UUID, conversationUID uuid.UUID, latestK int32, pageSize int32, pageToken string, includeSystemMessages bool)
	afterListMessagesCounter  uint64
	beforeListMessagesCounter uint64
	ListMessagesMock          mRepositoryIMockListMessages

	funcMessageTableName          func() (s1 string)
	inspectFuncMessageTableName   func()
	afterMessageTableNameCounter  uint64
	beforeMessageTableNameCounter uint64
	MessageTableNameMock          mRepositoryIMockMessageTableName

	funcProcessKnowledgeBaseFiles          func(ctx context.Context, fileUIDs []string, requester uuid.UUID) (ka1 []mm_repository.KnowledgeBaseFile, err error)
	inspectFuncProcessKnowledgeBaseFiles   func(ctx context.Context, fileUIDs []string, requester uuid.UUID)
	afterProcessKnowledgeBaseFilesCounter  uint64
	beforeProcessKnowledgeBaseFilesCounter uint64
	ProcessKnowledgeBaseFilesMock          mRepositoryIMockProcessKnowledgeBaseFiles

	funcSoftDeleteConversation          func(ctx context.Context, namespaceUID uuid.UUID, catalogUID uuid.UUID, conversationID string) (err error)
	inspectFuncSoftDeleteConversation   func(ctx context.Context, namespaceUID uuid.UUID, catalogUID uuid.UUID, conversationID string)
	afterSoftDeleteConversationCounter  uint64
	beforeSoftDeleteConversationCounter uint64
	SoftDeleteConversationMock          mRepositoryIMockSoftDeleteConversation

	funcTextChunkTableName          func() (s1 string)
	inspectFuncTextChunkTableName   func()
	afterTextChunkTableNameCounter  uint64
	beforeTextChunkTableNameCounter uint64
	TextChunkTableNameMock          mRepositoryIMockTextChunkTableName

	funcUpdateChunk          func(ctx context.Context, chunkUID string, updates map[string]interface{}) (tp1 *mm_repository.TextChunk, err error)
	inspectFuncUpdateChunk   func(ctx context.Context, chunkUID string, updates map[string]interface{})
	afterUpdateChunkCounter  uint64
	beforeUpdateChunkCounter uint64
	UpdateChunkMock          mRepositoryIMockUpdateChunk

	funcUpdateConversationByUpdateMap          func(ctx context.Context, convUID uuid.UUID, updateMap map[string]interface{}) (cp1 *mm_repository.Conversation, err error)
	inspectFuncUpdateConversationByUpdateMap   func(ctx context.Context, convUID uuid.UUID, updateMap map[string]interface{})
	afterUpdateConversationByUpdateMapCounter  uint64
	beforeUpdateConversationByUpdateMapCounter uint64
	UpdateConversationByUpdateMapMock          mRepositoryIMockUpdateConversationByUpdateMap

	funcUpdateKbFileExtraMetaData          func(ctx context.Context, fileUID uuid.UUID, failureReason string, convertingPipe string, chunkingPipe string, embeddingPipe string, processingTime *int64, convertingTime *int64, chunkingTime *int64, embeddingTime *int64) (err error)
	inspectFuncUpdateKbFileExtraMetaData   func(ctx context.Context, fileUID uuid.UUID, failureReason string, convertingPipe string, chunkingPipe string, embeddingPipe string, processingTime *int64, convertingTime *int64, chunkingTime *int64, embeddingTime *int64)
	afterUpdateKbFileExtraMetaDataCounter  uint64
	beforeUpdateKbFileExtraMetaDataCounter uint64
	UpdateKbFileExtraMetaDataMock          mRepositoryIMockUpdateKbFileExtraMetaData

	funcUpdateKnowledgeBase          func(ctx context.Context, ownerUID string, kb mm_repository.KnowledgeBase) (kp1 *mm_repository.KnowledgeBase, err error)
	inspectFuncUpdateKnowledgeBase   func(ctx context.Context, ownerUID string, kb mm_repository.KnowledgeBase)
	afterUpdateKnowledgeBaseCounter  uint64
	beforeUpdateKnowledgeBaseCounter uint64
	UpdateKnowledgeBaseMock          mRepositoryIMockUpdateKnowledgeBase

	funcUpdateKnowledgeBaseFile          func(ctx context.Context, fileUID string, updateMap map[string]interface{}) (kp1 *mm_repository.KnowledgeBaseFile, err error)
	inspectFuncUpdateKnowledgeBaseFile   func(ctx context.Context, fileUID string, updateMap map[string]interface{})
	afterUpdateKnowledgeBaseFileCounter  uint64
	beforeUpdateKnowledgeBaseFileCounter uint64
	UpdateKnowledgeBaseFileMock          mRepositoryIMockUpdateKnowledgeBaseFile

	funcUpdateMessage          func(ctx context.Context, msg mm_repository.Message) (mp1 *mm_repository.Message, err error)
	inspectFuncUpdateMessage   func(ctx context.Context, msg mm_repository.Message)
	afterUpdateMessageCounter  uint64
	beforeUpdateMessageCounter uint64
	UpdateMessageMock          mRepositoryIMockUpdateMessage

	funcUpdateMessageByUpdateMap          func(ctx context.Context, messageUID uuid.UUID, updateMap map[string]interface{}) (mp1 *mm_repository.Message, err error)
	inspectFuncUpdateMessageByUpdateMap   func(ctx context.Context, messageUID uuid.UUID, updateMap map[string]interface{})
	afterUpdateMessageByUpdateMapCounter  uint64
	beforeUpdateMessageByUpdateMapCounter uint64
	UpdateMessageByUpdateMapMock          mRepositoryIMockUpdateMessageByUpdateMap

	funcUpsertEmbeddings          func(ctx context.Context, embeddings []mm_repository.Embedding, externalServiceCall func(embUIDs []string) error) (ea1 []mm_repository.Embedding, err error)
	inspectFuncUpsertEmbeddings   func(ctx context.Context, embeddings []mm_repository.Embedding, externalServiceCall func(embUIDs []string) error)
	afterUpsertEmbeddingsCounter  uint64
	beforeUpsertEmbeddingsCounter uint64
	UpsertEmbeddingsMock          mRepositoryIMockUpsertEmbeddings

	funcUpsertRepositoryTag          func(ctx context.Context, rp1 *pb.RepositoryTag) (rp2 *pb.RepositoryTag, err error)
	inspectFuncUpsertRepositoryTag   func(ctx context.Context, rp1 *pb.RepositoryTag)
	afterUpsertRepositoryTagCounter  uint64
	beforeUpsertRepositoryTagCounter uint64
	UpsertRepositoryTagMock          mRepositoryIMockUpsertRepositoryTag
}

// NewRepositoryIMock returns a mock for repository.RepositoryI
func NewRepositoryIMock(t minimock.Tester) *RepositoryIMock {
	m := &RepositoryIMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ConversationTableNameMock = mRepositoryIMockConversationTableName{mock: m}

	m.ConvertedFileTableNameMock = mRepositoryIMockConvertedFileTableName{mock: m}

	m.CreateConversationMock = mRepositoryIMockCreateConversation{mock: m}
	m.CreateConversationMock.callArgs = []*RepositoryIMockCreateConversationParams{}

	m.CreateConvertedFileMock = mRepositoryIMockCreateConvertedFile{mock: m}
	m.CreateConvertedFileMock.callArgs = []*RepositoryIMockCreateConvertedFileParams{}

	m.CreateKnowledgeBaseMock = mRepositoryIMockCreateKnowledgeBase{mock: m}
	m.CreateKnowledgeBaseMock.callArgs = []*RepositoryIMockCreateKnowledgeBaseParams{}

	m.CreateKnowledgeBaseFileMock = mRepositoryIMockCreateKnowledgeBaseFile{mock: m}
	m.CreateKnowledgeBaseFileMock.callArgs = []*RepositoryIMockCreateKnowledgeBaseFileParams{}

	m.CreateMessageMock = mRepositoryIMockCreateMessage{mock: m}
	m.CreateMessageMock.callArgs = []*RepositoryIMockCreateMessageParams{}

	m.DeleteAllConvertedFilesInKbMock = mRepositoryIMockDeleteAllConvertedFilesInKb{mock: m}
	m.DeleteAllConvertedFilesInKbMock.callArgs = []*RepositoryIMockDeleteAllConvertedFilesInKbParams{}

	m.DeleteAllKnowledgeBaseFilesMock = mRepositoryIMockDeleteAllKnowledgeBaseFiles{mock: m}
	m.DeleteAllKnowledgeBaseFilesMock.callArgs = []*RepositoryIMockDeleteAllKnowledgeBaseFilesParams{}

	m.DeleteAndCreateChunksMock = mRepositoryIMockDeleteAndCreateChunks{mock: m}
	m.DeleteAndCreateChunksMock.callArgs = []*RepositoryIMockDeleteAndCreateChunksParams{}

	m.DeleteChunksBySourceMock = mRepositoryIMockDeleteChunksBySource{mock: m}
	m.DeleteChunksBySourceMock.callArgs = []*RepositoryIMockDeleteChunksBySourceParams{}

	m.DeleteChunksByUIDsMock = mRepositoryIMockDeleteChunksByUIDs{mock: m}
	m.DeleteChunksByUIDsMock.callArgs = []*RepositoryIMockDeleteChunksByUIDsParams{}

	m.DeleteConvertedFileMock = mRepositoryIMockDeleteConvertedFile{mock: m}
	m.DeleteConvertedFileMock.callArgs = []*RepositoryIMockDeleteConvertedFileParams{}

	m.DeleteEmbeddingsBySourceMock = mRepositoryIMockDeleteEmbeddingsBySource{mock: m}
	m.DeleteEmbeddingsBySourceMock.callArgs = []*RepositoryIMockDeleteEmbeddingsBySourceParams{}

	m.DeleteEmbeddingsByUIDsMock = mRepositoryIMockDeleteEmbeddingsByUIDs{mock: m}
	m.DeleteEmbeddingsByUIDsMock.callArgs = []*RepositoryIMockDeleteEmbeddingsByUIDsParams{}

	m.DeleteKnowledgeBaseMock = mRepositoryIMockDeleteKnowledgeBase{mock: m}
	m.DeleteKnowledgeBaseMock.callArgs = []*RepositoryIMockDeleteKnowledgeBaseParams{}

	m.DeleteKnowledgeBaseFileMock = mRepositoryIMockDeleteKnowledgeBaseFile{mock: m}
	m.DeleteKnowledgeBaseFileMock.callArgs = []*RepositoryIMockDeleteKnowledgeBaseFileParams{}

	m.DeleteKnowledgeBaseFileAndDecreaseUsageMock = mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage{mock: m}
	m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.callArgs = []*RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParams{}

	m.DeleteMessageMock = mRepositoryIMockDeleteMessage{mock: m}
	m.DeleteMessageMock.callArgs = []*RepositoryIMockDeleteMessageParams{}

	m.DeleteRepositoryTagMock = mRepositoryIMockDeleteRepositoryTag{mock: m}
	m.DeleteRepositoryTagMock.callArgs = []*RepositoryIMockDeleteRepositoryTagParams{}

	m.GetChunksByUIDsMock = mRepositoryIMockGetChunksByUIDs{mock: m}
	m.GetChunksByUIDsMock.callArgs = []*RepositoryIMockGetChunksByUIDsParams{}

	m.GetConversationByIDMock = mRepositoryIMockGetConversationByID{mock: m}
	m.GetConversationByIDMock.callArgs = []*RepositoryIMockGetConversationByIDParams{}

	m.GetConversationByUIDMock = mRepositoryIMockGetConversationByUID{mock: m}
	m.GetConversationByUIDMock.callArgs = []*RepositoryIMockGetConversationByUIDParams{}

	m.GetConvertedFileByFileUIDMock = mRepositoryIMockGetConvertedFileByFileUID{mock: m}
	m.GetConvertedFileByFileUIDMock.callArgs = []*RepositoryIMockGetConvertedFileByFileUIDParams{}

	m.GetCountFilesByListKnowledgeBaseUIDMock = mRepositoryIMockGetCountFilesByListKnowledgeBaseUID{mock: m}
	m.GetCountFilesByListKnowledgeBaseUIDMock.callArgs = []*RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParams{}

	m.GetEmbeddingByUIDsMock = mRepositoryIMockGetEmbeddingByUIDs{mock: m}
	m.GetEmbeddingByUIDsMock.callArgs = []*RepositoryIMockGetEmbeddingByUIDsParams{}

	m.GetFilesTotalTokensMock = mRepositoryIMockGetFilesTotalTokens{mock: m}
	m.GetFilesTotalTokensMock.callArgs = []*RepositoryIMockGetFilesTotalTokensParams{}

	m.GetKnowledgeBaseByOwnerAndKbIDMock = mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID{mock: m}
	m.GetKnowledgeBaseByOwnerAndKbIDMock.callArgs = []*RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParams{}

	m.GetKnowledgeBaseCountByOwnerMock = mRepositoryIMockGetKnowledgeBaseCountByOwner{mock: m}
	m.GetKnowledgeBaseCountByOwnerMock.callArgs = []*RepositoryIMockGetKnowledgeBaseCountByOwnerParams{}

	m.GetKnowledgeBaseFilesByFileUIDsMock = mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs{mock: m}
	m.GetKnowledgeBaseFilesByFileUIDsMock.callArgs = []*RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParams{}

	m.GetKnowledgebaseFileByKbUIDAndFileIDMock = mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID{mock: m}
	m.GetKnowledgebaseFileByKbUIDAndFileIDMock.callArgs = []*RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParams{}

	m.GetMessageByUIDMock = mRepositoryIMockGetMessageByUID{mock: m}
	m.GetMessageByUIDMock.callArgs = []*RepositoryIMockGetMessageByUIDParams{}

	m.GetNeedProcessFilesMock = mRepositoryIMockGetNeedProcessFiles{mock: m}
	m.GetNeedProcessFilesMock.callArgs = []*RepositoryIMockGetNeedProcessFilesParams{}

	m.GetRepositoryTagMock = mRepositoryIMockGetRepositoryTag{mock: m}
	m.GetRepositoryTagMock.callArgs = []*RepositoryIMockGetRepositoryTagParams{}

	m.GetSourceTableAndUIDByFileUIDsMock = mRepositoryIMockGetSourceTableAndUIDByFileUIDs{mock: m}
	m.GetSourceTableAndUIDByFileUIDsMock.callArgs = []*RepositoryIMockGetSourceTableAndUIDByFileUIDsParams{}

	m.GetTextChunksBySourceMock = mRepositoryIMockGetTextChunksBySource{mock: m}
	m.GetTextChunksBySourceMock.callArgs = []*RepositoryIMockGetTextChunksBySourceParams{}

	m.GetTotalChunksBySourcesMock = mRepositoryIMockGetTotalChunksBySources{mock: m}
	m.GetTotalChunksBySourcesMock.callArgs = []*RepositoryIMockGetTotalChunksBySourcesParams{}

	m.GetTotalTokensByListKBUIDsMock = mRepositoryIMockGetTotalTokensByListKBUIDs{mock: m}
	m.GetTotalTokensByListKBUIDsMock.callArgs = []*RepositoryIMockGetTotalTokensByListKBUIDsParams{}

	m.GetTruthSourceByFileUIDMock = mRepositoryIMockGetTruthSourceByFileUID{mock: m}
	m.GetTruthSourceByFileUIDMock.callArgs = []*RepositoryIMockGetTruthSourceByFileUIDParams{}

	m.HardDeleteChunksByKbFileUIDMock = mRepositoryIMockHardDeleteChunksByKbFileUID{mock: m}
	m.HardDeleteChunksByKbFileUIDMock.callArgs = []*RepositoryIMockHardDeleteChunksByKbFileUIDParams{}

	m.HardDeleteChunksByKbUIDMock = mRepositoryIMockHardDeleteChunksByKbUID{mock: m}
	m.HardDeleteChunksByKbUIDMock.callArgs = []*RepositoryIMockHardDeleteChunksByKbUIDParams{}

	m.HardDeleteConvertedFileByFileUIDMock = mRepositoryIMockHardDeleteConvertedFileByFileUID{mock: m}
	m.HardDeleteConvertedFileByFileUIDMock.callArgs = []*RepositoryIMockHardDeleteConvertedFileByFileUIDParams{}

	m.HardDeleteEmbeddingsByKbFileUIDMock = mRepositoryIMockHardDeleteEmbeddingsByKbFileUID{mock: m}
	m.HardDeleteEmbeddingsByKbFileUIDMock.callArgs = []*RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParams{}

	m.HardDeleteEmbeddingsByKbUIDMock = mRepositoryIMockHardDeleteEmbeddingsByKbUID{mock: m}
	m.HardDeleteEmbeddingsByKbUIDMock.callArgs = []*RepositoryIMockHardDeleteEmbeddingsByKbUIDParams{}

	m.IncreaseKnowledgeBaseUsageMock = mRepositoryIMockIncreaseKnowledgeBaseUsage{mock: m}
	m.IncreaseKnowledgeBaseUsageMock.callArgs = []*RepositoryIMockIncreaseKnowledgeBaseUsageParams{}

	m.KnowledgeBaseFileTableNameMock = mRepositoryIMockKnowledgeBaseFileTableName{mock: m}

	m.ListChunksByKbFileUIDMock = mRepositoryIMockListChunksByKbFileUID{mock: m}
	m.ListChunksByKbFileUIDMock.callArgs = []*RepositoryIMockListChunksByKbFileUIDParams{}

	m.ListConversationsMock = mRepositoryIMockListConversations{mock: m}
	m.ListConversationsMock.callArgs = []*RepositoryIMockListConversationsParams{}

	m.ListEmbeddingsByKbFileUIDMock = mRepositoryIMockListEmbeddingsByKbFileUID{mock: m}
	m.ListEmbeddingsByKbFileUIDMock.callArgs = []*RepositoryIMockListEmbeddingsByKbFileUIDParams{}

	m.ListKnowledgeBaseFilesMock = mRepositoryIMockListKnowledgeBaseFiles{mock: m}
	m.ListKnowledgeBaseFilesMock.callArgs = []*RepositoryIMockListKnowledgeBaseFilesParams{}

	m.ListKnowledgeBasesMock = mRepositoryIMockListKnowledgeBases{mock: m}
	m.ListKnowledgeBasesMock.callArgs = []*RepositoryIMockListKnowledgeBasesParams{}

	m.ListMessagesMock = mRepositoryIMockListMessages{mock: m}
	m.ListMessagesMock.callArgs = []*RepositoryIMockListMessagesParams{}

	m.MessageTableNameMock = mRepositoryIMockMessageTableName{mock: m}

	m.ProcessKnowledgeBaseFilesMock = mRepositoryIMockProcessKnowledgeBaseFiles{mock: m}
	m.ProcessKnowledgeBaseFilesMock.callArgs = []*RepositoryIMockProcessKnowledgeBaseFilesParams{}

	m.SoftDeleteConversationMock = mRepositoryIMockSoftDeleteConversation{mock: m}
	m.SoftDeleteConversationMock.callArgs = []*RepositoryIMockSoftDeleteConversationParams{}

	m.TextChunkTableNameMock = mRepositoryIMockTextChunkTableName{mock: m}

	m.UpdateChunkMock = mRepositoryIMockUpdateChunk{mock: m}
	m.UpdateChunkMock.callArgs = []*RepositoryIMockUpdateChunkParams{}

	m.UpdateConversationByUpdateMapMock = mRepositoryIMockUpdateConversationByUpdateMap{mock: m}
	m.UpdateConversationByUpdateMapMock.callArgs = []*RepositoryIMockUpdateConversationByUpdateMapParams{}

	m.UpdateKbFileExtraMetaDataMock = mRepositoryIMockUpdateKbFileExtraMetaData{mock: m}
	m.UpdateKbFileExtraMetaDataMock.callArgs = []*RepositoryIMockUpdateKbFileExtraMetaDataParams{}

	m.UpdateKnowledgeBaseMock = mRepositoryIMockUpdateKnowledgeBase{mock: m}
	m.UpdateKnowledgeBaseMock.callArgs = []*RepositoryIMockUpdateKnowledgeBaseParams{}

	m.UpdateKnowledgeBaseFileMock = mRepositoryIMockUpdateKnowledgeBaseFile{mock: m}
	m.UpdateKnowledgeBaseFileMock.callArgs = []*RepositoryIMockUpdateKnowledgeBaseFileParams{}

	m.UpdateMessageMock = mRepositoryIMockUpdateMessage{mock: m}
	m.UpdateMessageMock.callArgs = []*RepositoryIMockUpdateMessageParams{}

	m.UpdateMessageByUpdateMapMock = mRepositoryIMockUpdateMessageByUpdateMap{mock: m}
	m.UpdateMessageByUpdateMapMock.callArgs = []*RepositoryIMockUpdateMessageByUpdateMapParams{}

	m.UpsertEmbeddingsMock = mRepositoryIMockUpsertEmbeddings{mock: m}
	m.UpsertEmbeddingsMock.callArgs = []*RepositoryIMockUpsertEmbeddingsParams{}

	m.UpsertRepositoryTagMock = mRepositoryIMockUpsertRepositoryTag{mock: m}
	m.UpsertRepositoryTagMock.callArgs = []*RepositoryIMockUpsertRepositoryTagParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryIMockConversationTableName struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockConversationTableNameExpectation
	expectations       []*RepositoryIMockConversationTableNameExpectation

	expectedInvocations uint64
}

// RepositoryIMockConversationTableNameExpectation specifies expectation struct of the RepositoryI.ConversationTableName
type RepositoryIMockConversationTableNameExpectation struct {
	mock *RepositoryIMock

	results *RepositoryIMockConversationTableNameResults
	Counter uint64
}

// RepositoryIMockConversationTableNameResults contains results of the RepositoryI.ConversationTableName
type RepositoryIMockConversationTableNameResults struct {
	s1 string
}

// Expect sets up expected params for RepositoryI.ConversationTableName
func (mmConversationTableName *mRepositoryIMockConversationTableName) Expect() *mRepositoryIMockConversationTableName {
	if mmConversationTableName.mock.funcConversationTableName != nil {
		mmConversationTableName.mock.t.Fatalf("RepositoryIMock.ConversationTableName mock is already set by Set")
	}

	if mmConversationTableName.defaultExpectation == nil {
		mmConversationTableName.defaultExpectation = &RepositoryIMockConversationTableNameExpectation{}
	}

	return mmConversationTableName
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.ConversationTableName
func (mmConversationTableName *mRepositoryIMockConversationTableName) Inspect(f func()) *mRepositoryIMockConversationTableName {
	if mmConversationTableName.mock.inspectFuncConversationTableName != nil {
		mmConversationTableName.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.ConversationTableName")
	}

	mmConversationTableName.mock.inspectFuncConversationTableName = f

	return mmConversationTableName
}

// Return sets up results that will be returned by RepositoryI.ConversationTableName
func (mmConversationTableName *mRepositoryIMockConversationTableName) Return(s1 string) *RepositoryIMock {
	if mmConversationTableName.mock.funcConversationTableName != nil {
		mmConversationTableName.mock.t.Fatalf("RepositoryIMock.ConversationTableName mock is already set by Set")
	}

	if mmConversationTableName.defaultExpectation == nil {
		mmConversationTableName.defaultExpectation = &RepositoryIMockConversationTableNameExpectation{mock: mmConversationTableName.mock}
	}
	mmConversationTableName.defaultExpectation.results = &RepositoryIMockConversationTableNameResults{s1}
	return mmConversationTableName.mock
}

// Set uses given function f to mock the RepositoryI.ConversationTableName method
func (mmConversationTableName *mRepositoryIMockConversationTableName) Set(f func() (s1 string)) *RepositoryIMock {
	if mmConversationTableName.defaultExpectation != nil {
		mmConversationTableName.mock.t.Fatalf("Default expectation is already set for the RepositoryI.ConversationTableName method")
	}

	if len(mmConversationTableName.expectations) > 0 {
		mmConversationTableName.mock.t.Fatalf("Some expectations are already set for the RepositoryI.ConversationTableName method")
	}

	mmConversationTableName.mock.funcConversationTableName = f
	return mmConversationTableName.mock
}

// Times sets number of times RepositoryI.ConversationTableName should be invoked
func (mmConversationTableName *mRepositoryIMockConversationTableName) Times(n uint64) *mRepositoryIMockConversationTableName {
	if n == 0 {
		mmConversationTableName.mock.t.Fatalf("Times of RepositoryIMock.ConversationTableName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConversationTableName.expectedInvocations, n)
	return mmConversationTableName
}

func (mmConversationTableName *mRepositoryIMockConversationTableName) invocationsDone() bool {
	if len(mmConversationTableName.expectations) == 0 && mmConversationTableName.defaultExpectation == nil && mmConversationTableName.mock.funcConversationTableName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConversationTableName.mock.afterConversationTableNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConversationTableName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConversationTableName implements repository.RepositoryI
func (mmConversationTableName *RepositoryIMock) ConversationTableName() (s1 string) {
	mm_atomic.AddUint64(&mmConversationTableName.beforeConversationTableNameCounter, 1)
	defer mm_atomic.AddUint64(&mmConversationTableName.afterConversationTableNameCounter, 1)

	if mmConversationTableName.inspectFuncConversationTableName != nil {
		mmConversationTableName.inspectFuncConversationTableName()
	}

	if mmConversationTableName.ConversationTableNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConversationTableName.ConversationTableNameMock.defaultExpectation.Counter, 1)

		mm_results := mmConversationTableName.ConversationTableNameMock.defaultExpectation.results
		if mm_results == nil {
			mmConversationTableName.t.Fatal("No results are set for the RepositoryIMock.ConversationTableName")
		}
		return (*mm_results).s1
	}
	if mmConversationTableName.funcConversationTableName != nil {
		return mmConversationTableName.funcConversationTableName()
	}
	mmConversationTableName.t.Fatalf("Unexpected call to RepositoryIMock.ConversationTableName.")
	return
}

// ConversationTableNameAfterCounter returns a count of finished RepositoryIMock.ConversationTableName invocations
func (mmConversationTableName *RepositoryIMock) ConversationTableNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConversationTableName.afterConversationTableNameCounter)
}

// ConversationTableNameBeforeCounter returns a count of RepositoryIMock.ConversationTableName invocations
func (mmConversationTableName *RepositoryIMock) ConversationTableNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConversationTableName.beforeConversationTableNameCounter)
}

// MinimockConversationTableNameDone returns true if the count of the ConversationTableName invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockConversationTableNameDone() bool {
	for _, e := range m.ConversationTableNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConversationTableNameMock.invocationsDone()
}

// MinimockConversationTableNameInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockConversationTableNameInspect() {
	for _, e := range m.ConversationTableNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryIMock.ConversationTableName")
		}
	}

	afterConversationTableNameCounter := mm_atomic.LoadUint64(&m.afterConversationTableNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConversationTableNameMock.defaultExpectation != nil && afterConversationTableNameCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.ConversationTableName")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConversationTableName != nil && afterConversationTableNameCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.ConversationTableName")
	}

	if !m.ConversationTableNameMock.invocationsDone() && afterConversationTableNameCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.ConversationTableName but found %d calls",
			mm_atomic.LoadUint64(&m.ConversationTableNameMock.expectedInvocations), afterConversationTableNameCounter)
	}
}

type mRepositoryIMockConvertedFileTableName struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockConvertedFileTableNameExpectation
	expectations       []*RepositoryIMockConvertedFileTableNameExpectation

	expectedInvocations uint64
}

// RepositoryIMockConvertedFileTableNameExpectation specifies expectation struct of the RepositoryI.ConvertedFileTableName
type RepositoryIMockConvertedFileTableNameExpectation struct {
	mock *RepositoryIMock

	results *RepositoryIMockConvertedFileTableNameResults
	Counter uint64
}

// RepositoryIMockConvertedFileTableNameResults contains results of the RepositoryI.ConvertedFileTableName
type RepositoryIMockConvertedFileTableNameResults struct {
	s1 string
}

// Expect sets up expected params for RepositoryI.ConvertedFileTableName
func (mmConvertedFileTableName *mRepositoryIMockConvertedFileTableName) Expect() *mRepositoryIMockConvertedFileTableName {
	if mmConvertedFileTableName.mock.funcConvertedFileTableName != nil {
		mmConvertedFileTableName.mock.t.Fatalf("RepositoryIMock.ConvertedFileTableName mock is already set by Set")
	}

	if mmConvertedFileTableName.defaultExpectation == nil {
		mmConvertedFileTableName.defaultExpectation = &RepositoryIMockConvertedFileTableNameExpectation{}
	}

	return mmConvertedFileTableName
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.ConvertedFileTableName
func (mmConvertedFileTableName *mRepositoryIMockConvertedFileTableName) Inspect(f func()) *mRepositoryIMockConvertedFileTableName {
	if mmConvertedFileTableName.mock.inspectFuncConvertedFileTableName != nil {
		mmConvertedFileTableName.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.ConvertedFileTableName")
	}

	mmConvertedFileTableName.mock.inspectFuncConvertedFileTableName = f

	return mmConvertedFileTableName
}

// Return sets up results that will be returned by RepositoryI.ConvertedFileTableName
func (mmConvertedFileTableName *mRepositoryIMockConvertedFileTableName) Return(s1 string) *RepositoryIMock {
	if mmConvertedFileTableName.mock.funcConvertedFileTableName != nil {
		mmConvertedFileTableName.mock.t.Fatalf("RepositoryIMock.ConvertedFileTableName mock is already set by Set")
	}

	if mmConvertedFileTableName.defaultExpectation == nil {
		mmConvertedFileTableName.defaultExpectation = &RepositoryIMockConvertedFileTableNameExpectation{mock: mmConvertedFileTableName.mock}
	}
	mmConvertedFileTableName.defaultExpectation.results = &RepositoryIMockConvertedFileTableNameResults{s1}
	return mmConvertedFileTableName.mock
}

// Set uses given function f to mock the RepositoryI.ConvertedFileTableName method
func (mmConvertedFileTableName *mRepositoryIMockConvertedFileTableName) Set(f func() (s1 string)) *RepositoryIMock {
	if mmConvertedFileTableName.defaultExpectation != nil {
		mmConvertedFileTableName.mock.t.Fatalf("Default expectation is already set for the RepositoryI.ConvertedFileTableName method")
	}

	if len(mmConvertedFileTableName.expectations) > 0 {
		mmConvertedFileTableName.mock.t.Fatalf("Some expectations are already set for the RepositoryI.ConvertedFileTableName method")
	}

	mmConvertedFileTableName.mock.funcConvertedFileTableName = f
	return mmConvertedFileTableName.mock
}

// Times sets number of times RepositoryI.ConvertedFileTableName should be invoked
func (mmConvertedFileTableName *mRepositoryIMockConvertedFileTableName) Times(n uint64) *mRepositoryIMockConvertedFileTableName {
	if n == 0 {
		mmConvertedFileTableName.mock.t.Fatalf("Times of RepositoryIMock.ConvertedFileTableName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertedFileTableName.expectedInvocations, n)
	return mmConvertedFileTableName
}

func (mmConvertedFileTableName *mRepositoryIMockConvertedFileTableName) invocationsDone() bool {
	if len(mmConvertedFileTableName.expectations) == 0 && mmConvertedFileTableName.defaultExpectation == nil && mmConvertedFileTableName.mock.funcConvertedFileTableName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertedFileTableName.mock.afterConvertedFileTableNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertedFileTableName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertedFileTableName implements repository.RepositoryI
func (mmConvertedFileTableName *RepositoryIMock) ConvertedFileTableName() (s1 string) {
	mm_atomic.AddUint64(&mmConvertedFileTableName.beforeConvertedFileTableNameCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertedFileTableName.afterConvertedFileTableNameCounter, 1)

	if mmConvertedFileTableName.inspectFuncConvertedFileTableName != nil {
		mmConvertedFileTableName.inspectFuncConvertedFileTableName()
	}

	if mmConvertedFileTableName.ConvertedFileTableNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertedFileTableName.ConvertedFileTableNameMock.defaultExpectation.Counter, 1)

		mm_results := mmConvertedFileTableName.ConvertedFileTableNameMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertedFileTableName.t.Fatal("No results are set for the RepositoryIMock.ConvertedFileTableName")
		}
		return (*mm_results).s1
	}
	if mmConvertedFileTableName.funcConvertedFileTableName != nil {
		return mmConvertedFileTableName.funcConvertedFileTableName()
	}
	mmConvertedFileTableName.t.Fatalf("Unexpected call to RepositoryIMock.ConvertedFileTableName.")
	return
}

// ConvertedFileTableNameAfterCounter returns a count of finished RepositoryIMock.ConvertedFileTableName invocations
func (mmConvertedFileTableName *RepositoryIMock) ConvertedFileTableNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertedFileTableName.afterConvertedFileTableNameCounter)
}

// ConvertedFileTableNameBeforeCounter returns a count of RepositoryIMock.ConvertedFileTableName invocations
func (mmConvertedFileTableName *RepositoryIMock) ConvertedFileTableNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertedFileTableName.beforeConvertedFileTableNameCounter)
}

// MinimockConvertedFileTableNameDone returns true if the count of the ConvertedFileTableName invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockConvertedFileTableNameDone() bool {
	for _, e := range m.ConvertedFileTableNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertedFileTableNameMock.invocationsDone()
}

// MinimockConvertedFileTableNameInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockConvertedFileTableNameInspect() {
	for _, e := range m.ConvertedFileTableNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryIMock.ConvertedFileTableName")
		}
	}

	afterConvertedFileTableNameCounter := mm_atomic.LoadUint64(&m.afterConvertedFileTableNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertedFileTableNameMock.defaultExpectation != nil && afterConvertedFileTableNameCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.ConvertedFileTableName")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertedFileTableName != nil && afterConvertedFileTableNameCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.ConvertedFileTableName")
	}

	if !m.ConvertedFileTableNameMock.invocationsDone() && afterConvertedFileTableNameCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.ConvertedFileTableName but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertedFileTableNameMock.expectedInvocations), afterConvertedFileTableNameCounter)
	}
}

type mRepositoryIMockCreateConversation struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockCreateConversationExpectation
	expectations       []*RepositoryIMockCreateConversationExpectation

	callArgs []*RepositoryIMockCreateConversationParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockCreateConversationExpectation specifies expectation struct of the RepositoryI.CreateConversation
type RepositoryIMockCreateConversationExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockCreateConversationParams
	paramPtrs *RepositoryIMockCreateConversationParamPtrs
	results   *RepositoryIMockCreateConversationResults
	Counter   uint64
}

// RepositoryIMockCreateConversationParams contains parameters of the RepositoryI.CreateConversation
type RepositoryIMockCreateConversationParams struct {
	ctx  context.Context
	conv mm_repository.Conversation
}

// RepositoryIMockCreateConversationParamPtrs contains pointers to parameters of the RepositoryI.CreateConversation
type RepositoryIMockCreateConversationParamPtrs struct {
	ctx  *context.Context
	conv *mm_repository.Conversation
}

// RepositoryIMockCreateConversationResults contains results of the RepositoryI.CreateConversation
type RepositoryIMockCreateConversationResults struct {
	cp1 *mm_repository.Conversation
	err error
}

// Expect sets up expected params for RepositoryI.CreateConversation
func (mmCreateConversation *mRepositoryIMockCreateConversation) Expect(ctx context.Context, conv mm_repository.Conversation) *mRepositoryIMockCreateConversation {
	if mmCreateConversation.mock.funcCreateConversation != nil {
		mmCreateConversation.mock.t.Fatalf("RepositoryIMock.CreateConversation mock is already set by Set")
	}

	if mmCreateConversation.defaultExpectation == nil {
		mmCreateConversation.defaultExpectation = &RepositoryIMockCreateConversationExpectation{}
	}

	if mmCreateConversation.defaultExpectation.paramPtrs != nil {
		mmCreateConversation.mock.t.Fatalf("RepositoryIMock.CreateConversation mock is already set by ExpectParams functions")
	}

	mmCreateConversation.defaultExpectation.params = &RepositoryIMockCreateConversationParams{ctx, conv}
	for _, e := range mmCreateConversation.expectations {
		if minimock.Equal(e.params, mmCreateConversation.defaultExpectation.params) {
			mmCreateConversation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateConversation.defaultExpectation.params)
		}
	}

	return mmCreateConversation
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.CreateConversation
func (mmCreateConversation *mRepositoryIMockCreateConversation) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockCreateConversation {
	if mmCreateConversation.mock.funcCreateConversation != nil {
		mmCreateConversation.mock.t.Fatalf("RepositoryIMock.CreateConversation mock is already set by Set")
	}

	if mmCreateConversation.defaultExpectation == nil {
		mmCreateConversation.defaultExpectation = &RepositoryIMockCreateConversationExpectation{}
	}

	if mmCreateConversation.defaultExpectation.params != nil {
		mmCreateConversation.mock.t.Fatalf("RepositoryIMock.CreateConversation mock is already set by Expect")
	}

	if mmCreateConversation.defaultExpectation.paramPtrs == nil {
		mmCreateConversation.defaultExpectation.paramPtrs = &RepositoryIMockCreateConversationParamPtrs{}
	}
	mmCreateConversation.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateConversation
}

// ExpectConvParam2 sets up expected param conv for RepositoryI.CreateConversation
func (mmCreateConversation *mRepositoryIMockCreateConversation) ExpectConvParam2(conv mm_repository.Conversation) *mRepositoryIMockCreateConversation {
	if mmCreateConversation.mock.funcCreateConversation != nil {
		mmCreateConversation.mock.t.Fatalf("RepositoryIMock.CreateConversation mock is already set by Set")
	}

	if mmCreateConversation.defaultExpectation == nil {
		mmCreateConversation.defaultExpectation = &RepositoryIMockCreateConversationExpectation{}
	}

	if mmCreateConversation.defaultExpectation.params != nil {
		mmCreateConversation.mock.t.Fatalf("RepositoryIMock.CreateConversation mock is already set by Expect")
	}

	if mmCreateConversation.defaultExpectation.paramPtrs == nil {
		mmCreateConversation.defaultExpectation.paramPtrs = &RepositoryIMockCreateConversationParamPtrs{}
	}
	mmCreateConversation.defaultExpectation.paramPtrs.conv = &conv

	return mmCreateConversation
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.CreateConversation
func (mmCreateConversation *mRepositoryIMockCreateConversation) Inspect(f func(ctx context.Context, conv mm_repository.Conversation)) *mRepositoryIMockCreateConversation {
	if mmCreateConversation.mock.inspectFuncCreateConversation != nil {
		mmCreateConversation.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.CreateConversation")
	}

	mmCreateConversation.mock.inspectFuncCreateConversation = f

	return mmCreateConversation
}

// Return sets up results that will be returned by RepositoryI.CreateConversation
func (mmCreateConversation *mRepositoryIMockCreateConversation) Return(cp1 *mm_repository.Conversation, err error) *RepositoryIMock {
	if mmCreateConversation.mock.funcCreateConversation != nil {
		mmCreateConversation.mock.t.Fatalf("RepositoryIMock.CreateConversation mock is already set by Set")
	}

	if mmCreateConversation.defaultExpectation == nil {
		mmCreateConversation.defaultExpectation = &RepositoryIMockCreateConversationExpectation{mock: mmCreateConversation.mock}
	}
	mmCreateConversation.defaultExpectation.results = &RepositoryIMockCreateConversationResults{cp1, err}
	return mmCreateConversation.mock
}

// Set uses given function f to mock the RepositoryI.CreateConversation method
func (mmCreateConversation *mRepositoryIMockCreateConversation) Set(f func(ctx context.Context, conv mm_repository.Conversation) (cp1 *mm_repository.Conversation, err error)) *RepositoryIMock {
	if mmCreateConversation.defaultExpectation != nil {
		mmCreateConversation.mock.t.Fatalf("Default expectation is already set for the RepositoryI.CreateConversation method")
	}

	if len(mmCreateConversation.expectations) > 0 {
		mmCreateConversation.mock.t.Fatalf("Some expectations are already set for the RepositoryI.CreateConversation method")
	}

	mmCreateConversation.mock.funcCreateConversation = f
	return mmCreateConversation.mock
}

// When sets expectation for the RepositoryI.CreateConversation which will trigger the result defined by the following
// Then helper
func (mmCreateConversation *mRepositoryIMockCreateConversation) When(ctx context.Context, conv mm_repository.Conversation) *RepositoryIMockCreateConversationExpectation {
	if mmCreateConversation.mock.funcCreateConversation != nil {
		mmCreateConversation.mock.t.Fatalf("RepositoryIMock.CreateConversation mock is already set by Set")
	}

	expectation := &RepositoryIMockCreateConversationExpectation{
		mock:   mmCreateConversation.mock,
		params: &RepositoryIMockCreateConversationParams{ctx, conv},
	}
	mmCreateConversation.expectations = append(mmCreateConversation.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.CreateConversation return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockCreateConversationExpectation) Then(cp1 *mm_repository.Conversation, err error) *RepositoryIMock {
	e.results = &RepositoryIMockCreateConversationResults{cp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.CreateConversation should be invoked
func (mmCreateConversation *mRepositoryIMockCreateConversation) Times(n uint64) *mRepositoryIMockCreateConversation {
	if n == 0 {
		mmCreateConversation.mock.t.Fatalf("Times of RepositoryIMock.CreateConversation mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateConversation.expectedInvocations, n)
	return mmCreateConversation
}

func (mmCreateConversation *mRepositoryIMockCreateConversation) invocationsDone() bool {
	if len(mmCreateConversation.expectations) == 0 && mmCreateConversation.defaultExpectation == nil && mmCreateConversation.mock.funcCreateConversation == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateConversation.mock.afterCreateConversationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateConversation.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateConversation implements repository.RepositoryI
func (mmCreateConversation *RepositoryIMock) CreateConversation(ctx context.Context, conv mm_repository.Conversation) (cp1 *mm_repository.Conversation, err error) {
	mm_atomic.AddUint64(&mmCreateConversation.beforeCreateConversationCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateConversation.afterCreateConversationCounter, 1)

	if mmCreateConversation.inspectFuncCreateConversation != nil {
		mmCreateConversation.inspectFuncCreateConversation(ctx, conv)
	}

	mm_params := RepositoryIMockCreateConversationParams{ctx, conv}

	// Record call args
	mmCreateConversation.CreateConversationMock.mutex.Lock()
	mmCreateConversation.CreateConversationMock.callArgs = append(mmCreateConversation.CreateConversationMock.callArgs, &mm_params)
	mmCreateConversation.CreateConversationMock.mutex.Unlock()

	for _, e := range mmCreateConversation.CreateConversationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCreateConversation.CreateConversationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateConversation.CreateConversationMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateConversation.CreateConversationMock.defaultExpectation.params
		mm_want_ptrs := mmCreateConversation.CreateConversationMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockCreateConversationParams{ctx, conv}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateConversation.t.Errorf("RepositoryIMock.CreateConversation got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.conv != nil && !minimock.Equal(*mm_want_ptrs.conv, mm_got.conv) {
				mmCreateConversation.t.Errorf("RepositoryIMock.CreateConversation got unexpected parameter conv, want: %#v, got: %#v%s\n", *mm_want_ptrs.conv, mm_got.conv, minimock.Diff(*mm_want_ptrs.conv, mm_got.conv))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateConversation.t.Errorf("RepositoryIMock.CreateConversation got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateConversation.CreateConversationMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateConversation.t.Fatal("No results are set for the RepositoryIMock.CreateConversation")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCreateConversation.funcCreateConversation != nil {
		return mmCreateConversation.funcCreateConversation(ctx, conv)
	}
	mmCreateConversation.t.Fatalf("Unexpected call to RepositoryIMock.CreateConversation. %v %v", ctx, conv)
	return
}

// CreateConversationAfterCounter returns a count of finished RepositoryIMock.CreateConversation invocations
func (mmCreateConversation *RepositoryIMock) CreateConversationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateConversation.afterCreateConversationCounter)
}

// CreateConversationBeforeCounter returns a count of RepositoryIMock.CreateConversation invocations
func (mmCreateConversation *RepositoryIMock) CreateConversationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateConversation.beforeCreateConversationCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.CreateConversation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateConversation *mRepositoryIMockCreateConversation) Calls() []*RepositoryIMockCreateConversationParams {
	mmCreateConversation.mutex.RLock()

	argCopy := make([]*RepositoryIMockCreateConversationParams, len(mmCreateConversation.callArgs))
	copy(argCopy, mmCreateConversation.callArgs)

	mmCreateConversation.mutex.RUnlock()

	return argCopy
}

// MinimockCreateConversationDone returns true if the count of the CreateConversation invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockCreateConversationDone() bool {
	for _, e := range m.CreateConversationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateConversationMock.invocationsDone()
}

// MinimockCreateConversationInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockCreateConversationInspect() {
	for _, e := range m.CreateConversationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.CreateConversation with params: %#v", *e.params)
		}
	}

	afterCreateConversationCounter := mm_atomic.LoadUint64(&m.afterCreateConversationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateConversationMock.defaultExpectation != nil && afterCreateConversationCounter < 1 {
		if m.CreateConversationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.CreateConversation")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.CreateConversation with params: %#v", *m.CreateConversationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateConversation != nil && afterCreateConversationCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.CreateConversation")
	}

	if !m.CreateConversationMock.invocationsDone() && afterCreateConversationCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.CreateConversation but found %d calls",
			mm_atomic.LoadUint64(&m.CreateConversationMock.expectedInvocations), afterCreateConversationCounter)
	}
}

type mRepositoryIMockCreateConvertedFile struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockCreateConvertedFileExpectation
	expectations       []*RepositoryIMockCreateConvertedFileExpectation

	callArgs []*RepositoryIMockCreateConvertedFileParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockCreateConvertedFileExpectation specifies expectation struct of the RepositoryI.CreateConvertedFile
type RepositoryIMockCreateConvertedFileExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockCreateConvertedFileParams
	paramPtrs *RepositoryIMockCreateConvertedFileParamPtrs
	results   *RepositoryIMockCreateConvertedFileResults
	Counter   uint64
}

// RepositoryIMockCreateConvertedFileParams contains parameters of the RepositoryI.CreateConvertedFile
type RepositoryIMockCreateConvertedFileParams struct {
	ctx                 context.Context
	cf                  mm_repository.ConvertedFile
	callExternalService func(convertedFileUID uuid.UUID) (map[string]any, error)
}

// RepositoryIMockCreateConvertedFileParamPtrs contains pointers to parameters of the RepositoryI.CreateConvertedFile
type RepositoryIMockCreateConvertedFileParamPtrs struct {
	ctx                 *context.Context
	cf                  *mm_repository.ConvertedFile
	callExternalService *func(convertedFileUID uuid.UUID) (map[string]any, error)
}

// RepositoryIMockCreateConvertedFileResults contains results of the RepositoryI.CreateConvertedFile
type RepositoryIMockCreateConvertedFileResults struct {
	cp1 *mm_repository.ConvertedFile
	err error
}

// Expect sets up expected params for RepositoryI.CreateConvertedFile
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) Expect(ctx context.Context, cf mm_repository.ConvertedFile, callExternalService func(convertedFileUID uuid.UUID) (map[string]any, error)) *mRepositoryIMockCreateConvertedFile {
	if mmCreateConvertedFile.mock.funcCreateConvertedFile != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by Set")
	}

	if mmCreateConvertedFile.defaultExpectation == nil {
		mmCreateConvertedFile.defaultExpectation = &RepositoryIMockCreateConvertedFileExpectation{}
	}

	if mmCreateConvertedFile.defaultExpectation.paramPtrs != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by ExpectParams functions")
	}

	mmCreateConvertedFile.defaultExpectation.params = &RepositoryIMockCreateConvertedFileParams{ctx, cf, callExternalService}
	for _, e := range mmCreateConvertedFile.expectations {
		if minimock.Equal(e.params, mmCreateConvertedFile.defaultExpectation.params) {
			mmCreateConvertedFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateConvertedFile.defaultExpectation.params)
		}
	}

	return mmCreateConvertedFile
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.CreateConvertedFile
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockCreateConvertedFile {
	if mmCreateConvertedFile.mock.funcCreateConvertedFile != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by Set")
	}

	if mmCreateConvertedFile.defaultExpectation == nil {
		mmCreateConvertedFile.defaultExpectation = &RepositoryIMockCreateConvertedFileExpectation{}
	}

	if mmCreateConvertedFile.defaultExpectation.params != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by Expect")
	}

	if mmCreateConvertedFile.defaultExpectation.paramPtrs == nil {
		mmCreateConvertedFile.defaultExpectation.paramPtrs = &RepositoryIMockCreateConvertedFileParamPtrs{}
	}
	mmCreateConvertedFile.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateConvertedFile
}

// ExpectCfParam2 sets up expected param cf for RepositoryI.CreateConvertedFile
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) ExpectCfParam2(cf mm_repository.ConvertedFile) *mRepositoryIMockCreateConvertedFile {
	if mmCreateConvertedFile.mock.funcCreateConvertedFile != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by Set")
	}

	if mmCreateConvertedFile.defaultExpectation == nil {
		mmCreateConvertedFile.defaultExpectation = &RepositoryIMockCreateConvertedFileExpectation{}
	}

	if mmCreateConvertedFile.defaultExpectation.params != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by Expect")
	}

	if mmCreateConvertedFile.defaultExpectation.paramPtrs == nil {
		mmCreateConvertedFile.defaultExpectation.paramPtrs = &RepositoryIMockCreateConvertedFileParamPtrs{}
	}
	mmCreateConvertedFile.defaultExpectation.paramPtrs.cf = &cf

	return mmCreateConvertedFile
}

// ExpectCallExternalServiceParam3 sets up expected param callExternalService for RepositoryI.CreateConvertedFile
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) ExpectCallExternalServiceParam3(callExternalService func(convertedFileUID uuid.UUID) (map[string]any, error)) *mRepositoryIMockCreateConvertedFile {
	if mmCreateConvertedFile.mock.funcCreateConvertedFile != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by Set")
	}

	if mmCreateConvertedFile.defaultExpectation == nil {
		mmCreateConvertedFile.defaultExpectation = &RepositoryIMockCreateConvertedFileExpectation{}
	}

	if mmCreateConvertedFile.defaultExpectation.params != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by Expect")
	}

	if mmCreateConvertedFile.defaultExpectation.paramPtrs == nil {
		mmCreateConvertedFile.defaultExpectation.paramPtrs = &RepositoryIMockCreateConvertedFileParamPtrs{}
	}
	mmCreateConvertedFile.defaultExpectation.paramPtrs.callExternalService = &callExternalService

	return mmCreateConvertedFile
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.CreateConvertedFile
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) Inspect(f func(ctx context.Context, cf mm_repository.ConvertedFile, callExternalService func(convertedFileUID uuid.UUID) (map[string]any, error))) *mRepositoryIMockCreateConvertedFile {
	if mmCreateConvertedFile.mock.inspectFuncCreateConvertedFile != nil {
		mmCreateConvertedFile.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.CreateConvertedFile")
	}

	mmCreateConvertedFile.mock.inspectFuncCreateConvertedFile = f

	return mmCreateConvertedFile
}

// Return sets up results that will be returned by RepositoryI.CreateConvertedFile
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) Return(cp1 *mm_repository.ConvertedFile, err error) *RepositoryIMock {
	if mmCreateConvertedFile.mock.funcCreateConvertedFile != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by Set")
	}

	if mmCreateConvertedFile.defaultExpectation == nil {
		mmCreateConvertedFile.defaultExpectation = &RepositoryIMockCreateConvertedFileExpectation{mock: mmCreateConvertedFile.mock}
	}
	mmCreateConvertedFile.defaultExpectation.results = &RepositoryIMockCreateConvertedFileResults{cp1, err}
	return mmCreateConvertedFile.mock
}

// Set uses given function f to mock the RepositoryI.CreateConvertedFile method
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) Set(f func(ctx context.Context, cf mm_repository.ConvertedFile, callExternalService func(convertedFileUID uuid.UUID) (map[string]any, error)) (cp1 *mm_repository.ConvertedFile, err error)) *RepositoryIMock {
	if mmCreateConvertedFile.defaultExpectation != nil {
		mmCreateConvertedFile.mock.t.Fatalf("Default expectation is already set for the RepositoryI.CreateConvertedFile method")
	}

	if len(mmCreateConvertedFile.expectations) > 0 {
		mmCreateConvertedFile.mock.t.Fatalf("Some expectations are already set for the RepositoryI.CreateConvertedFile method")
	}

	mmCreateConvertedFile.mock.funcCreateConvertedFile = f
	return mmCreateConvertedFile.mock
}

// When sets expectation for the RepositoryI.CreateConvertedFile which will trigger the result defined by the following
// Then helper
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) When(ctx context.Context, cf mm_repository.ConvertedFile, callExternalService func(convertedFileUID uuid.UUID) (map[string]any, error)) *RepositoryIMockCreateConvertedFileExpectation {
	if mmCreateConvertedFile.mock.funcCreateConvertedFile != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by Set")
	}

	expectation := &RepositoryIMockCreateConvertedFileExpectation{
		mock:   mmCreateConvertedFile.mock,
		params: &RepositoryIMockCreateConvertedFileParams{ctx, cf, callExternalService},
	}
	mmCreateConvertedFile.expectations = append(mmCreateConvertedFile.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.CreateConvertedFile return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockCreateConvertedFileExpectation) Then(cp1 *mm_repository.ConvertedFile, err error) *RepositoryIMock {
	e.results = &RepositoryIMockCreateConvertedFileResults{cp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.CreateConvertedFile should be invoked
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) Times(n uint64) *mRepositoryIMockCreateConvertedFile {
	if n == 0 {
		mmCreateConvertedFile.mock.t.Fatalf("Times of RepositoryIMock.CreateConvertedFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateConvertedFile.expectedInvocations, n)
	return mmCreateConvertedFile
}

func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) invocationsDone() bool {
	if len(mmCreateConvertedFile.expectations) == 0 && mmCreateConvertedFile.defaultExpectation == nil && mmCreateConvertedFile.mock.funcCreateConvertedFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateConvertedFile.mock.afterCreateConvertedFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateConvertedFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateConvertedFile implements repository.RepositoryI
func (mmCreateConvertedFile *RepositoryIMock) CreateConvertedFile(ctx context.Context, cf mm_repository.ConvertedFile, callExternalService func(convertedFileUID uuid.UUID) (map[string]any, error)) (cp1 *mm_repository.ConvertedFile, err error) {
	mm_atomic.AddUint64(&mmCreateConvertedFile.beforeCreateConvertedFileCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateConvertedFile.afterCreateConvertedFileCounter, 1)

	if mmCreateConvertedFile.inspectFuncCreateConvertedFile != nil {
		mmCreateConvertedFile.inspectFuncCreateConvertedFile(ctx, cf, callExternalService)
	}

	mm_params := RepositoryIMockCreateConvertedFileParams{ctx, cf, callExternalService}

	// Record call args
	mmCreateConvertedFile.CreateConvertedFileMock.mutex.Lock()
	mmCreateConvertedFile.CreateConvertedFileMock.callArgs = append(mmCreateConvertedFile.CreateConvertedFileMock.callArgs, &mm_params)
	mmCreateConvertedFile.CreateConvertedFileMock.mutex.Unlock()

	for _, e := range mmCreateConvertedFile.CreateConvertedFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCreateConvertedFile.CreateConvertedFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateConvertedFile.CreateConvertedFileMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateConvertedFile.CreateConvertedFileMock.defaultExpectation.params
		mm_want_ptrs := mmCreateConvertedFile.CreateConvertedFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockCreateConvertedFileParams{ctx, cf, callExternalService}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateConvertedFile.t.Errorf("RepositoryIMock.CreateConvertedFile got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cf != nil && !minimock.Equal(*mm_want_ptrs.cf, mm_got.cf) {
				mmCreateConvertedFile.t.Errorf("RepositoryIMock.CreateConvertedFile got unexpected parameter cf, want: %#v, got: %#v%s\n", *mm_want_ptrs.cf, mm_got.cf, minimock.Diff(*mm_want_ptrs.cf, mm_got.cf))
			}

			if mm_want_ptrs.callExternalService != nil && !minimock.Equal(*mm_want_ptrs.callExternalService, mm_got.callExternalService) {
				mmCreateConvertedFile.t.Errorf("RepositoryIMock.CreateConvertedFile got unexpected parameter callExternalService, want: %#v, got: %#v%s\n", *mm_want_ptrs.callExternalService, mm_got.callExternalService, minimock.Diff(*mm_want_ptrs.callExternalService, mm_got.callExternalService))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateConvertedFile.t.Errorf("RepositoryIMock.CreateConvertedFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateConvertedFile.CreateConvertedFileMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateConvertedFile.t.Fatal("No results are set for the RepositoryIMock.CreateConvertedFile")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCreateConvertedFile.funcCreateConvertedFile != nil {
		return mmCreateConvertedFile.funcCreateConvertedFile(ctx, cf, callExternalService)
	}
	mmCreateConvertedFile.t.Fatalf("Unexpected call to RepositoryIMock.CreateConvertedFile. %v %v %v", ctx, cf, callExternalService)
	return
}

// CreateConvertedFileAfterCounter returns a count of finished RepositoryIMock.CreateConvertedFile invocations
func (mmCreateConvertedFile *RepositoryIMock) CreateConvertedFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateConvertedFile.afterCreateConvertedFileCounter)
}

// CreateConvertedFileBeforeCounter returns a count of RepositoryIMock.CreateConvertedFile invocations
func (mmCreateConvertedFile *RepositoryIMock) CreateConvertedFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateConvertedFile.beforeCreateConvertedFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.CreateConvertedFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) Calls() []*RepositoryIMockCreateConvertedFileParams {
	mmCreateConvertedFile.mutex.RLock()

	argCopy := make([]*RepositoryIMockCreateConvertedFileParams, len(mmCreateConvertedFile.callArgs))
	copy(argCopy, mmCreateConvertedFile.callArgs)

	mmCreateConvertedFile.mutex.RUnlock()

	return argCopy
}

// MinimockCreateConvertedFileDone returns true if the count of the CreateConvertedFile invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockCreateConvertedFileDone() bool {
	for _, e := range m.CreateConvertedFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateConvertedFileMock.invocationsDone()
}

// MinimockCreateConvertedFileInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockCreateConvertedFileInspect() {
	for _, e := range m.CreateConvertedFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.CreateConvertedFile with params: %#v", *e.params)
		}
	}

	afterCreateConvertedFileCounter := mm_atomic.LoadUint64(&m.afterCreateConvertedFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateConvertedFileMock.defaultExpectation != nil && afterCreateConvertedFileCounter < 1 {
		if m.CreateConvertedFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.CreateConvertedFile")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.CreateConvertedFile with params: %#v", *m.CreateConvertedFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateConvertedFile != nil && afterCreateConvertedFileCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.CreateConvertedFile")
	}

	if !m.CreateConvertedFileMock.invocationsDone() && afterCreateConvertedFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.CreateConvertedFile but found %d calls",
			mm_atomic.LoadUint64(&m.CreateConvertedFileMock.expectedInvocations), afterCreateConvertedFileCounter)
	}
}

type mRepositoryIMockCreateKnowledgeBase struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockCreateKnowledgeBaseExpectation
	expectations       []*RepositoryIMockCreateKnowledgeBaseExpectation

	callArgs []*RepositoryIMockCreateKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockCreateKnowledgeBaseExpectation specifies expectation struct of the RepositoryI.CreateKnowledgeBase
type RepositoryIMockCreateKnowledgeBaseExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockCreateKnowledgeBaseParams
	paramPtrs *RepositoryIMockCreateKnowledgeBaseParamPtrs
	results   *RepositoryIMockCreateKnowledgeBaseResults
	Counter   uint64
}

// RepositoryIMockCreateKnowledgeBaseParams contains parameters of the RepositoryI.CreateKnowledgeBase
type RepositoryIMockCreateKnowledgeBaseParams struct {
	ctx             context.Context
	kb              mm_repository.KnowledgeBase
	externalService func(kbUID string) error
}

// RepositoryIMockCreateKnowledgeBaseParamPtrs contains pointers to parameters of the RepositoryI.CreateKnowledgeBase
type RepositoryIMockCreateKnowledgeBaseParamPtrs struct {
	ctx             *context.Context
	kb              *mm_repository.KnowledgeBase
	externalService *func(kbUID string) error
}

// RepositoryIMockCreateKnowledgeBaseResults contains results of the RepositoryI.CreateKnowledgeBase
type RepositoryIMockCreateKnowledgeBaseResults struct {
	kp1 *mm_repository.KnowledgeBase
	err error
}

// Expect sets up expected params for RepositoryI.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) Expect(ctx context.Context, kb mm_repository.KnowledgeBase, externalService func(kbUID string) error) *mRepositoryIMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmCreateKnowledgeBase.defaultExpectation.params = &RepositoryIMockCreateKnowledgeBaseParams{ctx, kb, externalService}
	for _, e := range mmCreateKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmCreateKnowledgeBase.defaultExpectation.params) {
			mmCreateKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmCreateKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.params != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Expect")
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockCreateKnowledgeBaseParamPtrs{}
	}
	mmCreateKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateKnowledgeBase
}

// ExpectKbParam2 sets up expected param kb for RepositoryI.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) ExpectKbParam2(kb mm_repository.KnowledgeBase) *mRepositoryIMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.params != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Expect")
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockCreateKnowledgeBaseParamPtrs{}
	}
	mmCreateKnowledgeBase.defaultExpectation.paramPtrs.kb = &kb

	return mmCreateKnowledgeBase
}

// ExpectExternalServiceParam3 sets up expected param externalService for RepositoryI.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) ExpectExternalServiceParam3(externalService func(kbUID string) error) *mRepositoryIMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.params != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Expect")
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockCreateKnowledgeBaseParamPtrs{}
	}
	mmCreateKnowledgeBase.defaultExpectation.paramPtrs.externalService = &externalService

	return mmCreateKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) Inspect(f func(ctx context.Context, kb mm_repository.KnowledgeBase, externalService func(kbUID string) error)) *mRepositoryIMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.inspectFuncCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.CreateKnowledgeBase")
	}

	mmCreateKnowledgeBase.mock.inspectFuncCreateKnowledgeBase = f

	return mmCreateKnowledgeBase
}

// Return sets up results that will be returned by RepositoryI.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) Return(kp1 *mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseExpectation{mock: mmCreateKnowledgeBase.mock}
	}
	mmCreateKnowledgeBase.defaultExpectation.results = &RepositoryIMockCreateKnowledgeBaseResults{kp1, err}
	return mmCreateKnowledgeBase.mock
}

// Set uses given function f to mock the RepositoryI.CreateKnowledgeBase method
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) Set(f func(ctx context.Context, kb mm_repository.KnowledgeBase, externalService func(kbUID string) error) (kp1 *mm_repository.KnowledgeBase, err error)) *RepositoryIMock {
	if mmCreateKnowledgeBase.defaultExpectation != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the RepositoryI.CreateKnowledgeBase method")
	}

	if len(mmCreateKnowledgeBase.expectations) > 0 {
		mmCreateKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the RepositoryI.CreateKnowledgeBase method")
	}

	mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase = f
	return mmCreateKnowledgeBase.mock
}

// When sets expectation for the RepositoryI.CreateKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) When(ctx context.Context, kb mm_repository.KnowledgeBase, externalService func(kbUID string) error) *RepositoryIMockCreateKnowledgeBaseExpectation {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Set")
	}

	expectation := &RepositoryIMockCreateKnowledgeBaseExpectation{
		mock:   mmCreateKnowledgeBase.mock,
		params: &RepositoryIMockCreateKnowledgeBaseParams{ctx, kb, externalService},
	}
	mmCreateKnowledgeBase.expectations = append(mmCreateKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.CreateKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockCreateKnowledgeBaseExpectation) Then(kp1 *mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	e.results = &RepositoryIMockCreateKnowledgeBaseResults{kp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.CreateKnowledgeBase should be invoked
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) Times(n uint64) *mRepositoryIMockCreateKnowledgeBase {
	if n == 0 {
		mmCreateKnowledgeBase.mock.t.Fatalf("Times of RepositoryIMock.CreateKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateKnowledgeBase.expectedInvocations, n)
	return mmCreateKnowledgeBase
}

func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) invocationsDone() bool {
	if len(mmCreateKnowledgeBase.expectations) == 0 && mmCreateKnowledgeBase.defaultExpectation == nil && mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateKnowledgeBase.mock.afterCreateKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateKnowledgeBase implements repository.RepositoryI
func (mmCreateKnowledgeBase *RepositoryIMock) CreateKnowledgeBase(ctx context.Context, kb mm_repository.KnowledgeBase, externalService func(kbUID string) error) (kp1 *mm_repository.KnowledgeBase, err error) {
	mm_atomic.AddUint64(&mmCreateKnowledgeBase.beforeCreateKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateKnowledgeBase.afterCreateKnowledgeBaseCounter, 1)

	if mmCreateKnowledgeBase.inspectFuncCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.inspectFuncCreateKnowledgeBase(ctx, kb, externalService)
	}

	mm_params := RepositoryIMockCreateKnowledgeBaseParams{ctx, kb, externalService}

	// Record call args
	mmCreateKnowledgeBase.CreateKnowledgeBaseMock.mutex.Lock()
	mmCreateKnowledgeBase.CreateKnowledgeBaseMock.callArgs = append(mmCreateKnowledgeBase.CreateKnowledgeBaseMock.callArgs, &mm_params)
	mmCreateKnowledgeBase.CreateKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmCreateKnowledgeBase.CreateKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockCreateKnowledgeBaseParams{ctx, kb, externalService}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateKnowledgeBase.t.Errorf("RepositoryIMock.CreateKnowledgeBase got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kb != nil && !minimock.Equal(*mm_want_ptrs.kb, mm_got.kb) {
				mmCreateKnowledgeBase.t.Errorf("RepositoryIMock.CreateKnowledgeBase got unexpected parameter kb, want: %#v, got: %#v%s\n", *mm_want_ptrs.kb, mm_got.kb, minimock.Diff(*mm_want_ptrs.kb, mm_got.kb))
			}

			if mm_want_ptrs.externalService != nil && !minimock.Equal(*mm_want_ptrs.externalService, mm_got.externalService) {
				mmCreateKnowledgeBase.t.Errorf("RepositoryIMock.CreateKnowledgeBase got unexpected parameter externalService, want: %#v, got: %#v%s\n", *mm_want_ptrs.externalService, mm_got.externalService, minimock.Diff(*mm_want_ptrs.externalService, mm_got.externalService))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateKnowledgeBase.t.Errorf("RepositoryIMock.CreateKnowledgeBase got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateKnowledgeBase.t.Fatal("No results are set for the RepositoryIMock.CreateKnowledgeBase")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmCreateKnowledgeBase.funcCreateKnowledgeBase != nil {
		return mmCreateKnowledgeBase.funcCreateKnowledgeBase(ctx, kb, externalService)
	}
	mmCreateKnowledgeBase.t.Fatalf("Unexpected call to RepositoryIMock.CreateKnowledgeBase. %v %v %v", ctx, kb, externalService)
	return
}

// CreateKnowledgeBaseAfterCounter returns a count of finished RepositoryIMock.CreateKnowledgeBase invocations
func (mmCreateKnowledgeBase *RepositoryIMock) CreateKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateKnowledgeBase.afterCreateKnowledgeBaseCounter)
}

// CreateKnowledgeBaseBeforeCounter returns a count of RepositoryIMock.CreateKnowledgeBase invocations
func (mmCreateKnowledgeBase *RepositoryIMock) CreateKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateKnowledgeBase.beforeCreateKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.CreateKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) Calls() []*RepositoryIMockCreateKnowledgeBaseParams {
	mmCreateKnowledgeBase.mutex.RLock()

	argCopy := make([]*RepositoryIMockCreateKnowledgeBaseParams, len(mmCreateKnowledgeBase.callArgs))
	copy(argCopy, mmCreateKnowledgeBase.callArgs)

	mmCreateKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockCreateKnowledgeBaseDone returns true if the count of the CreateKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockCreateKnowledgeBaseDone() bool {
	for _, e := range m.CreateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateKnowledgeBaseMock.invocationsDone()
}

// MinimockCreateKnowledgeBaseInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockCreateKnowledgeBaseInspect() {
	for _, e := range m.CreateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.CreateKnowledgeBase with params: %#v", *e.params)
		}
	}

	afterCreateKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterCreateKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateKnowledgeBaseMock.defaultExpectation != nil && afterCreateKnowledgeBaseCounter < 1 {
		if m.CreateKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.CreateKnowledgeBase")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.CreateKnowledgeBase with params: %#v", *m.CreateKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateKnowledgeBase != nil && afterCreateKnowledgeBaseCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.CreateKnowledgeBase")
	}

	if !m.CreateKnowledgeBaseMock.invocationsDone() && afterCreateKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.CreateKnowledgeBase but found %d calls",
			mm_atomic.LoadUint64(&m.CreateKnowledgeBaseMock.expectedInvocations), afterCreateKnowledgeBaseCounter)
	}
}

type mRepositoryIMockCreateKnowledgeBaseFile struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockCreateKnowledgeBaseFileExpectation
	expectations       []*RepositoryIMockCreateKnowledgeBaseFileExpectation

	callArgs []*RepositoryIMockCreateKnowledgeBaseFileParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockCreateKnowledgeBaseFileExpectation specifies expectation struct of the RepositoryI.CreateKnowledgeBaseFile
type RepositoryIMockCreateKnowledgeBaseFileExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockCreateKnowledgeBaseFileParams
	paramPtrs *RepositoryIMockCreateKnowledgeBaseFileParamPtrs
	results   *RepositoryIMockCreateKnowledgeBaseFileResults
	Counter   uint64
}

// RepositoryIMockCreateKnowledgeBaseFileParams contains parameters of the RepositoryI.CreateKnowledgeBaseFile
type RepositoryIMockCreateKnowledgeBaseFileParams struct {
	ctx                 context.Context
	kb                  mm_repository.KnowledgeBaseFile
	externalServiceCall func(FileUID string) error
}

// RepositoryIMockCreateKnowledgeBaseFileParamPtrs contains pointers to parameters of the RepositoryI.CreateKnowledgeBaseFile
type RepositoryIMockCreateKnowledgeBaseFileParamPtrs struct {
	ctx                 *context.Context
	kb                  *mm_repository.KnowledgeBaseFile
	externalServiceCall *func(FileUID string) error
}

// RepositoryIMockCreateKnowledgeBaseFileResults contains results of the RepositoryI.CreateKnowledgeBaseFile
type RepositoryIMockCreateKnowledgeBaseFileResults struct {
	kp1 *mm_repository.KnowledgeBaseFile
	err error
}

// Expect sets up expected params for RepositoryI.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) Expect(ctx context.Context, kb mm_repository.KnowledgeBaseFile, externalServiceCall func(FileUID string) error) *mRepositoryIMockCreateKnowledgeBaseFile {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseFileExpectation{}
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by ExpectParams functions")
	}

	mmCreateKnowledgeBaseFile.defaultExpectation.params = &RepositoryIMockCreateKnowledgeBaseFileParams{ctx, kb, externalServiceCall}
	for _, e := range mmCreateKnowledgeBaseFile.expectations {
		if minimock.Equal(e.params, mmCreateKnowledgeBaseFile.defaultExpectation.params) {
			mmCreateKnowledgeBaseFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateKnowledgeBaseFile.defaultExpectation.params)
		}
	}

	return mmCreateKnowledgeBaseFile
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockCreateKnowledgeBaseFile {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseFileExpectation{}
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryIMockCreateKnowledgeBaseFileParamPtrs{}
	}
	mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateKnowledgeBaseFile
}

// ExpectKbParam2 sets up expected param kb for RepositoryI.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) ExpectKbParam2(kb mm_repository.KnowledgeBaseFile) *mRepositoryIMockCreateKnowledgeBaseFile {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseFileExpectation{}
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryIMockCreateKnowledgeBaseFileParamPtrs{}
	}
	mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs.kb = &kb

	return mmCreateKnowledgeBaseFile
}

// ExpectExternalServiceCallParam3 sets up expected param externalServiceCall for RepositoryI.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) ExpectExternalServiceCallParam3(externalServiceCall func(FileUID string) error) *mRepositoryIMockCreateKnowledgeBaseFile {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseFileExpectation{}
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryIMockCreateKnowledgeBaseFileParamPtrs{}
	}
	mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs.externalServiceCall = &externalServiceCall

	return mmCreateKnowledgeBaseFile
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) Inspect(f func(ctx context.Context, kb mm_repository.KnowledgeBaseFile, externalServiceCall func(FileUID string) error)) *mRepositoryIMockCreateKnowledgeBaseFile {
	if mmCreateKnowledgeBaseFile.mock.inspectFuncCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.CreateKnowledgeBaseFile")
	}

	mmCreateKnowledgeBaseFile.mock.inspectFuncCreateKnowledgeBaseFile = f

	return mmCreateKnowledgeBaseFile
}

// Return sets up results that will be returned by RepositoryI.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) Return(kp1 *mm_repository.KnowledgeBaseFile, err error) *RepositoryIMock {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseFileExpectation{mock: mmCreateKnowledgeBaseFile.mock}
	}
	mmCreateKnowledgeBaseFile.defaultExpectation.results = &RepositoryIMockCreateKnowledgeBaseFileResults{kp1, err}
	return mmCreateKnowledgeBaseFile.mock
}

// Set uses given function f to mock the RepositoryI.CreateKnowledgeBaseFile method
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) Set(f func(ctx context.Context, kb mm_repository.KnowledgeBaseFile, externalServiceCall func(FileUID string) error) (kp1 *mm_repository.KnowledgeBaseFile, err error)) *RepositoryIMock {
	if mmCreateKnowledgeBaseFile.defaultExpectation != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("Default expectation is already set for the RepositoryI.CreateKnowledgeBaseFile method")
	}

	if len(mmCreateKnowledgeBaseFile.expectations) > 0 {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("Some expectations are already set for the RepositoryI.CreateKnowledgeBaseFile method")
	}

	mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile = f
	return mmCreateKnowledgeBaseFile.mock
}

// When sets expectation for the RepositoryI.CreateKnowledgeBaseFile which will trigger the result defined by the following
// Then helper
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) When(ctx context.Context, kb mm_repository.KnowledgeBaseFile, externalServiceCall func(FileUID string) error) *RepositoryIMockCreateKnowledgeBaseFileExpectation {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	expectation := &RepositoryIMockCreateKnowledgeBaseFileExpectation{
		mock:   mmCreateKnowledgeBaseFile.mock,
		params: &RepositoryIMockCreateKnowledgeBaseFileParams{ctx, kb, externalServiceCall},
	}
	mmCreateKnowledgeBaseFile.expectations = append(mmCreateKnowledgeBaseFile.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.CreateKnowledgeBaseFile return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockCreateKnowledgeBaseFileExpectation) Then(kp1 *mm_repository.KnowledgeBaseFile, err error) *RepositoryIMock {
	e.results = &RepositoryIMockCreateKnowledgeBaseFileResults{kp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.CreateKnowledgeBaseFile should be invoked
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) Times(n uint64) *mRepositoryIMockCreateKnowledgeBaseFile {
	if n == 0 {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("Times of RepositoryIMock.CreateKnowledgeBaseFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateKnowledgeBaseFile.expectedInvocations, n)
	return mmCreateKnowledgeBaseFile
}

func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) invocationsDone() bool {
	if len(mmCreateKnowledgeBaseFile.expectations) == 0 && mmCreateKnowledgeBaseFile.defaultExpectation == nil && mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateKnowledgeBaseFile.mock.afterCreateKnowledgeBaseFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateKnowledgeBaseFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateKnowledgeBaseFile implements repository.RepositoryI
func (mmCreateKnowledgeBaseFile *RepositoryIMock) CreateKnowledgeBaseFile(ctx context.Context, kb mm_repository.KnowledgeBaseFile, externalServiceCall func(FileUID string) error) (kp1 *mm_repository.KnowledgeBaseFile, err error) {
	mm_atomic.AddUint64(&mmCreateKnowledgeBaseFile.beforeCreateKnowledgeBaseFileCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateKnowledgeBaseFile.afterCreateKnowledgeBaseFileCounter, 1)

	if mmCreateKnowledgeBaseFile.inspectFuncCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.inspectFuncCreateKnowledgeBaseFile(ctx, kb, externalServiceCall)
	}

	mm_params := RepositoryIMockCreateKnowledgeBaseFileParams{ctx, kb, externalServiceCall}

	// Record call args
	mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.mutex.Lock()
	mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.callArgs = append(mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.callArgs, &mm_params)
	mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.mutex.Unlock()

	for _, e := range mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation.params
		mm_want_ptrs := mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockCreateKnowledgeBaseFileParams{ctx, kb, externalServiceCall}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateKnowledgeBaseFile.t.Errorf("RepositoryIMock.CreateKnowledgeBaseFile got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kb != nil && !minimock.Equal(*mm_want_ptrs.kb, mm_got.kb) {
				mmCreateKnowledgeBaseFile.t.Errorf("RepositoryIMock.CreateKnowledgeBaseFile got unexpected parameter kb, want: %#v, got: %#v%s\n", *mm_want_ptrs.kb, mm_got.kb, minimock.Diff(*mm_want_ptrs.kb, mm_got.kb))
			}

			if mm_want_ptrs.externalServiceCall != nil && !minimock.Equal(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall) {
				mmCreateKnowledgeBaseFile.t.Errorf("RepositoryIMock.CreateKnowledgeBaseFile got unexpected parameter externalServiceCall, want: %#v, got: %#v%s\n", *mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall, minimock.Diff(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateKnowledgeBaseFile.t.Errorf("RepositoryIMock.CreateKnowledgeBaseFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateKnowledgeBaseFile.t.Fatal("No results are set for the RepositoryIMock.CreateKnowledgeBaseFile")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmCreateKnowledgeBaseFile.funcCreateKnowledgeBaseFile != nil {
		return mmCreateKnowledgeBaseFile.funcCreateKnowledgeBaseFile(ctx, kb, externalServiceCall)
	}
	mmCreateKnowledgeBaseFile.t.Fatalf("Unexpected call to RepositoryIMock.CreateKnowledgeBaseFile. %v %v %v", ctx, kb, externalServiceCall)
	return
}

// CreateKnowledgeBaseFileAfterCounter returns a count of finished RepositoryIMock.CreateKnowledgeBaseFile invocations
func (mmCreateKnowledgeBaseFile *RepositoryIMock) CreateKnowledgeBaseFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateKnowledgeBaseFile.afterCreateKnowledgeBaseFileCounter)
}

// CreateKnowledgeBaseFileBeforeCounter returns a count of RepositoryIMock.CreateKnowledgeBaseFile invocations
func (mmCreateKnowledgeBaseFile *RepositoryIMock) CreateKnowledgeBaseFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateKnowledgeBaseFile.beforeCreateKnowledgeBaseFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.CreateKnowledgeBaseFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) Calls() []*RepositoryIMockCreateKnowledgeBaseFileParams {
	mmCreateKnowledgeBaseFile.mutex.RLock()

	argCopy := make([]*RepositoryIMockCreateKnowledgeBaseFileParams, len(mmCreateKnowledgeBaseFile.callArgs))
	copy(argCopy, mmCreateKnowledgeBaseFile.callArgs)

	mmCreateKnowledgeBaseFile.mutex.RUnlock()

	return argCopy
}

// MinimockCreateKnowledgeBaseFileDone returns true if the count of the CreateKnowledgeBaseFile invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockCreateKnowledgeBaseFileDone() bool {
	for _, e := range m.CreateKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateKnowledgeBaseFileMock.invocationsDone()
}

// MinimockCreateKnowledgeBaseFileInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockCreateKnowledgeBaseFileInspect() {
	for _, e := range m.CreateKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.CreateKnowledgeBaseFile with params: %#v", *e.params)
		}
	}

	afterCreateKnowledgeBaseFileCounter := mm_atomic.LoadUint64(&m.afterCreateKnowledgeBaseFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateKnowledgeBaseFileMock.defaultExpectation != nil && afterCreateKnowledgeBaseFileCounter < 1 {
		if m.CreateKnowledgeBaseFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.CreateKnowledgeBaseFile")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.CreateKnowledgeBaseFile with params: %#v", *m.CreateKnowledgeBaseFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateKnowledgeBaseFile != nil && afterCreateKnowledgeBaseFileCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.CreateKnowledgeBaseFile")
	}

	if !m.CreateKnowledgeBaseFileMock.invocationsDone() && afterCreateKnowledgeBaseFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.CreateKnowledgeBaseFile but found %d calls",
			mm_atomic.LoadUint64(&m.CreateKnowledgeBaseFileMock.expectedInvocations), afterCreateKnowledgeBaseFileCounter)
	}
}

type mRepositoryIMockCreateMessage struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockCreateMessageExpectation
	expectations       []*RepositoryIMockCreateMessageExpectation

	callArgs []*RepositoryIMockCreateMessageParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockCreateMessageExpectation specifies expectation struct of the RepositoryI.CreateMessage
type RepositoryIMockCreateMessageExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockCreateMessageParams
	paramPtrs *RepositoryIMockCreateMessageParamPtrs
	results   *RepositoryIMockCreateMessageResults
	Counter   uint64
}

// RepositoryIMockCreateMessageParams contains parameters of the RepositoryI.CreateMessage
type RepositoryIMockCreateMessageParams struct {
	ctx context.Context
	msg mm_repository.Message
}

// RepositoryIMockCreateMessageParamPtrs contains pointers to parameters of the RepositoryI.CreateMessage
type RepositoryIMockCreateMessageParamPtrs struct {
	ctx *context.Context
	msg *mm_repository.Message
}

// RepositoryIMockCreateMessageResults contains results of the RepositoryI.CreateMessage
type RepositoryIMockCreateMessageResults struct {
	mp1 *mm_repository.Message
	err error
}

// Expect sets up expected params for RepositoryI.CreateMessage
func (mmCreateMessage *mRepositoryIMockCreateMessage) Expect(ctx context.Context, msg mm_repository.Message) *mRepositoryIMockCreateMessage {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("RepositoryIMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &RepositoryIMockCreateMessageExpectation{}
	}

	if mmCreateMessage.defaultExpectation.paramPtrs != nil {
		mmCreateMessage.mock.t.Fatalf("RepositoryIMock.CreateMessage mock is already set by ExpectParams functions")
	}

	mmCreateMessage.defaultExpectation.params = &RepositoryIMockCreateMessageParams{ctx, msg}
	for _, e := range mmCreateMessage.expectations {
		if minimock.Equal(e.params, mmCreateMessage.defaultExpectation.params) {
			mmCreateMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateMessage.defaultExpectation.params)
		}
	}

	return mmCreateMessage
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.CreateMessage
func (mmCreateMessage *mRepositoryIMockCreateMessage) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockCreateMessage {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("RepositoryIMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &RepositoryIMockCreateMessageExpectation{}
	}

	if mmCreateMessage.defaultExpectation.params != nil {
		mmCreateMessage.mock.t.Fatalf("RepositoryIMock.CreateMessage mock is already set by Expect")
	}

	if mmCreateMessage.defaultExpectation.paramPtrs == nil {
		mmCreateMessage.defaultExpectation.paramPtrs = &RepositoryIMockCreateMessageParamPtrs{}
	}
	mmCreateMessage.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateMessage
}

// ExpectMsgParam2 sets up expected param msg for RepositoryI.CreateMessage
func (mmCreateMessage *mRepositoryIMockCreateMessage) ExpectMsgParam2(msg mm_repository.Message) *mRepositoryIMockCreateMessage {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("RepositoryIMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &RepositoryIMockCreateMessageExpectation{}
	}

	if mmCreateMessage.defaultExpectation.params != nil {
		mmCreateMessage.mock.t.Fatalf("RepositoryIMock.CreateMessage mock is already set by Expect")
	}

	if mmCreateMessage.defaultExpectation.paramPtrs == nil {
		mmCreateMessage.defaultExpectation.paramPtrs = &RepositoryIMockCreateMessageParamPtrs{}
	}
	mmCreateMessage.defaultExpectation.paramPtrs.msg = &msg

	return mmCreateMessage
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.CreateMessage
func (mmCreateMessage *mRepositoryIMockCreateMessage) Inspect(f func(ctx context.Context, msg mm_repository.Message)) *mRepositoryIMockCreateMessage {
	if mmCreateMessage.mock.inspectFuncCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.CreateMessage")
	}

	mmCreateMessage.mock.inspectFuncCreateMessage = f

	return mmCreateMessage
}

// Return sets up results that will be returned by RepositoryI.CreateMessage
func (mmCreateMessage *mRepositoryIMockCreateMessage) Return(mp1 *mm_repository.Message, err error) *RepositoryIMock {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("RepositoryIMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &RepositoryIMockCreateMessageExpectation{mock: mmCreateMessage.mock}
	}
	mmCreateMessage.defaultExpectation.results = &RepositoryIMockCreateMessageResults{mp1, err}
	return mmCreateMessage.mock
}

// Set uses given function f to mock the RepositoryI.CreateMessage method
func (mmCreateMessage *mRepositoryIMockCreateMessage) Set(f func(ctx context.Context, msg mm_repository.Message) (mp1 *mm_repository.Message, err error)) *RepositoryIMock {
	if mmCreateMessage.defaultExpectation != nil {
		mmCreateMessage.mock.t.Fatalf("Default expectation is already set for the RepositoryI.CreateMessage method")
	}

	if len(mmCreateMessage.expectations) > 0 {
		mmCreateMessage.mock.t.Fatalf("Some expectations are already set for the RepositoryI.CreateMessage method")
	}

	mmCreateMessage.mock.funcCreateMessage = f
	return mmCreateMessage.mock
}

// When sets expectation for the RepositoryI.CreateMessage which will trigger the result defined by the following
// Then helper
func (mmCreateMessage *mRepositoryIMockCreateMessage) When(ctx context.Context, msg mm_repository.Message) *RepositoryIMockCreateMessageExpectation {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("RepositoryIMock.CreateMessage mock is already set by Set")
	}

	expectation := &RepositoryIMockCreateMessageExpectation{
		mock:   mmCreateMessage.mock,
		params: &RepositoryIMockCreateMessageParams{ctx, msg},
	}
	mmCreateMessage.expectations = append(mmCreateMessage.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.CreateMessage return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockCreateMessageExpectation) Then(mp1 *mm_repository.Message, err error) *RepositoryIMock {
	e.results = &RepositoryIMockCreateMessageResults{mp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.CreateMessage should be invoked
func (mmCreateMessage *mRepositoryIMockCreateMessage) Times(n uint64) *mRepositoryIMockCreateMessage {
	if n == 0 {
		mmCreateMessage.mock.t.Fatalf("Times of RepositoryIMock.CreateMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateMessage.expectedInvocations, n)
	return mmCreateMessage
}

func (mmCreateMessage *mRepositoryIMockCreateMessage) invocationsDone() bool {
	if len(mmCreateMessage.expectations) == 0 && mmCreateMessage.defaultExpectation == nil && mmCreateMessage.mock.funcCreateMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateMessage.mock.afterCreateMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateMessage implements repository.RepositoryI
func (mmCreateMessage *RepositoryIMock) CreateMessage(ctx context.Context, msg mm_repository.Message) (mp1 *mm_repository.Message, err error) {
	mm_atomic.AddUint64(&mmCreateMessage.beforeCreateMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateMessage.afterCreateMessageCounter, 1)

	if mmCreateMessage.inspectFuncCreateMessage != nil {
		mmCreateMessage.inspectFuncCreateMessage(ctx, msg)
	}

	mm_params := RepositoryIMockCreateMessageParams{ctx, msg}

	// Record call args
	mmCreateMessage.CreateMessageMock.mutex.Lock()
	mmCreateMessage.CreateMessageMock.callArgs = append(mmCreateMessage.CreateMessageMock.callArgs, &mm_params)
	mmCreateMessage.CreateMessageMock.mutex.Unlock()

	for _, e := range mmCreateMessage.CreateMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmCreateMessage.CreateMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateMessage.CreateMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateMessage.CreateMessageMock.defaultExpectation.params
		mm_want_ptrs := mmCreateMessage.CreateMessageMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockCreateMessageParams{ctx, msg}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateMessage.t.Errorf("RepositoryIMock.CreateMessage got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmCreateMessage.t.Errorf("RepositoryIMock.CreateMessage got unexpected parameter msg, want: %#v, got: %#v%s\n", *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateMessage.t.Errorf("RepositoryIMock.CreateMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateMessage.CreateMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateMessage.t.Fatal("No results are set for the RepositoryIMock.CreateMessage")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmCreateMessage.funcCreateMessage != nil {
		return mmCreateMessage.funcCreateMessage(ctx, msg)
	}
	mmCreateMessage.t.Fatalf("Unexpected call to RepositoryIMock.CreateMessage. %v %v", ctx, msg)
	return
}

// CreateMessageAfterCounter returns a count of finished RepositoryIMock.CreateMessage invocations
func (mmCreateMessage *RepositoryIMock) CreateMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateMessage.afterCreateMessageCounter)
}

// CreateMessageBeforeCounter returns a count of RepositoryIMock.CreateMessage invocations
func (mmCreateMessage *RepositoryIMock) CreateMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateMessage.beforeCreateMessageCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.CreateMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateMessage *mRepositoryIMockCreateMessage) Calls() []*RepositoryIMockCreateMessageParams {
	mmCreateMessage.mutex.RLock()

	argCopy := make([]*RepositoryIMockCreateMessageParams, len(mmCreateMessage.callArgs))
	copy(argCopy, mmCreateMessage.callArgs)

	mmCreateMessage.mutex.RUnlock()

	return argCopy
}

// MinimockCreateMessageDone returns true if the count of the CreateMessage invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockCreateMessageDone() bool {
	for _, e := range m.CreateMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMessageMock.invocationsDone()
}

// MinimockCreateMessageInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockCreateMessageInspect() {
	for _, e := range m.CreateMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.CreateMessage with params: %#v", *e.params)
		}
	}

	afterCreateMessageCounter := mm_atomic.LoadUint64(&m.afterCreateMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMessageMock.defaultExpectation != nil && afterCreateMessageCounter < 1 {
		if m.CreateMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.CreateMessage")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.CreateMessage with params: %#v", *m.CreateMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateMessage != nil && afterCreateMessageCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.CreateMessage")
	}

	if !m.CreateMessageMock.invocationsDone() && afterCreateMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.CreateMessage but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMessageMock.expectedInvocations), afterCreateMessageCounter)
	}
}

type mRepositoryIMockDeleteAllConvertedFilesInKb struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteAllConvertedFilesInKbExpectation
	expectations       []*RepositoryIMockDeleteAllConvertedFilesInKbExpectation

	callArgs []*RepositoryIMockDeleteAllConvertedFilesInKbParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteAllConvertedFilesInKbExpectation specifies expectation struct of the RepositoryI.DeleteAllConvertedFilesInKb
type RepositoryIMockDeleteAllConvertedFilesInKbExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteAllConvertedFilesInKbParams
	paramPtrs *RepositoryIMockDeleteAllConvertedFilesInKbParamPtrs
	results   *RepositoryIMockDeleteAllConvertedFilesInKbResults
	Counter   uint64
}

// RepositoryIMockDeleteAllConvertedFilesInKbParams contains parameters of the RepositoryI.DeleteAllConvertedFilesInKb
type RepositoryIMockDeleteAllConvertedFilesInKbParams struct {
	ctx   context.Context
	kbUID uuid.UUID
}

// RepositoryIMockDeleteAllConvertedFilesInKbParamPtrs contains pointers to parameters of the RepositoryI.DeleteAllConvertedFilesInKb
type RepositoryIMockDeleteAllConvertedFilesInKbParamPtrs struct {
	ctx   *context.Context
	kbUID *uuid.UUID
}

// RepositoryIMockDeleteAllConvertedFilesInKbResults contains results of the RepositoryI.DeleteAllConvertedFilesInKb
type RepositoryIMockDeleteAllConvertedFilesInKbResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteAllConvertedFilesInKb
func (mmDeleteAllConvertedFilesInKb *mRepositoryIMockDeleteAllConvertedFilesInKb) Expect(ctx context.Context, kbUID uuid.UUID) *mRepositoryIMockDeleteAllConvertedFilesInKb {
	if mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKb != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryIMock.DeleteAllConvertedFilesInKb mock is already set by Set")
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation == nil {
		mmDeleteAllConvertedFilesInKb.defaultExpectation = &RepositoryIMockDeleteAllConvertedFilesInKbExpectation{}
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation.paramPtrs != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryIMock.DeleteAllConvertedFilesInKb mock is already set by ExpectParams functions")
	}

	mmDeleteAllConvertedFilesInKb.defaultExpectation.params = &RepositoryIMockDeleteAllConvertedFilesInKbParams{ctx, kbUID}
	for _, e := range mmDeleteAllConvertedFilesInKb.expectations {
		if minimock.Equal(e.params, mmDeleteAllConvertedFilesInKb.defaultExpectation.params) {
			mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteAllConvertedFilesInKb.defaultExpectation.params)
		}
	}

	return mmDeleteAllConvertedFilesInKb
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteAllConvertedFilesInKb
func (mmDeleteAllConvertedFilesInKb *mRepositoryIMockDeleteAllConvertedFilesInKb) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteAllConvertedFilesInKb {
	if mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKb != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryIMock.DeleteAllConvertedFilesInKb mock is already set by Set")
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation == nil {
		mmDeleteAllConvertedFilesInKb.defaultExpectation = &RepositoryIMockDeleteAllConvertedFilesInKbExpectation{}
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation.params != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryIMock.DeleteAllConvertedFilesInKb mock is already set by Expect")
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation.paramPtrs == nil {
		mmDeleteAllConvertedFilesInKb.defaultExpectation.paramPtrs = &RepositoryIMockDeleteAllConvertedFilesInKbParamPtrs{}
	}
	mmDeleteAllConvertedFilesInKb.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteAllConvertedFilesInKb
}

// ExpectKbUIDParam2 sets up expected param kbUID for RepositoryI.DeleteAllConvertedFilesInKb
func (mmDeleteAllConvertedFilesInKb *mRepositoryIMockDeleteAllConvertedFilesInKb) ExpectKbUIDParam2(kbUID uuid.UUID) *mRepositoryIMockDeleteAllConvertedFilesInKb {
	if mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKb != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryIMock.DeleteAllConvertedFilesInKb mock is already set by Set")
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation == nil {
		mmDeleteAllConvertedFilesInKb.defaultExpectation = &RepositoryIMockDeleteAllConvertedFilesInKbExpectation{}
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation.params != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryIMock.DeleteAllConvertedFilesInKb mock is already set by Expect")
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation.paramPtrs == nil {
		mmDeleteAllConvertedFilesInKb.defaultExpectation.paramPtrs = &RepositoryIMockDeleteAllConvertedFilesInKbParamPtrs{}
	}
	mmDeleteAllConvertedFilesInKb.defaultExpectation.paramPtrs.kbUID = &kbUID

	return mmDeleteAllConvertedFilesInKb
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteAllConvertedFilesInKb
func (mmDeleteAllConvertedFilesInKb *mRepositoryIMockDeleteAllConvertedFilesInKb) Inspect(f func(ctx context.Context, kbUID uuid.UUID)) *mRepositoryIMockDeleteAllConvertedFilesInKb {
	if mmDeleteAllConvertedFilesInKb.mock.inspectFuncDeleteAllConvertedFilesInKb != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteAllConvertedFilesInKb")
	}

	mmDeleteAllConvertedFilesInKb.mock.inspectFuncDeleteAllConvertedFilesInKb = f

	return mmDeleteAllConvertedFilesInKb
}

// Return sets up results that will be returned by RepositoryI.DeleteAllConvertedFilesInKb
func (mmDeleteAllConvertedFilesInKb *mRepositoryIMockDeleteAllConvertedFilesInKb) Return(err error) *RepositoryIMock {
	if mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKb != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryIMock.DeleteAllConvertedFilesInKb mock is already set by Set")
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation == nil {
		mmDeleteAllConvertedFilesInKb.defaultExpectation = &RepositoryIMockDeleteAllConvertedFilesInKbExpectation{mock: mmDeleteAllConvertedFilesInKb.mock}
	}
	mmDeleteAllConvertedFilesInKb.defaultExpectation.results = &RepositoryIMockDeleteAllConvertedFilesInKbResults{err}
	return mmDeleteAllConvertedFilesInKb.mock
}

// Set uses given function f to mock the RepositoryI.DeleteAllConvertedFilesInKb method
func (mmDeleteAllConvertedFilesInKb *mRepositoryIMockDeleteAllConvertedFilesInKb) Set(f func(ctx context.Context, kbUID uuid.UUID) (err error)) *RepositoryIMock {
	if mmDeleteAllConvertedFilesInKb.defaultExpectation != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteAllConvertedFilesInKb method")
	}

	if len(mmDeleteAllConvertedFilesInKb.expectations) > 0 {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteAllConvertedFilesInKb method")
	}

	mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKb = f
	return mmDeleteAllConvertedFilesInKb.mock
}

// When sets expectation for the RepositoryI.DeleteAllConvertedFilesInKb which will trigger the result defined by the following
// Then helper
func (mmDeleteAllConvertedFilesInKb *mRepositoryIMockDeleteAllConvertedFilesInKb) When(ctx context.Context, kbUID uuid.UUID) *RepositoryIMockDeleteAllConvertedFilesInKbExpectation {
	if mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKb != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryIMock.DeleteAllConvertedFilesInKb mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteAllConvertedFilesInKbExpectation{
		mock:   mmDeleteAllConvertedFilesInKb.mock,
		params: &RepositoryIMockDeleteAllConvertedFilesInKbParams{ctx, kbUID},
	}
	mmDeleteAllConvertedFilesInKb.expectations = append(mmDeleteAllConvertedFilesInKb.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteAllConvertedFilesInKb return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteAllConvertedFilesInKbExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteAllConvertedFilesInKbResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteAllConvertedFilesInKb should be invoked
func (mmDeleteAllConvertedFilesInKb *mRepositoryIMockDeleteAllConvertedFilesInKb) Times(n uint64) *mRepositoryIMockDeleteAllConvertedFilesInKb {
	if n == 0 {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("Times of RepositoryIMock.DeleteAllConvertedFilesInKb mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteAllConvertedFilesInKb.expectedInvocations, n)
	return mmDeleteAllConvertedFilesInKb
}

func (mmDeleteAllConvertedFilesInKb *mRepositoryIMockDeleteAllConvertedFilesInKb) invocationsDone() bool {
	if len(mmDeleteAllConvertedFilesInKb.expectations) == 0 && mmDeleteAllConvertedFilesInKb.defaultExpectation == nil && mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKb == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteAllConvertedFilesInKb.mock.afterDeleteAllConvertedFilesInKbCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteAllConvertedFilesInKb.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteAllConvertedFilesInKb implements repository.RepositoryI
func (mmDeleteAllConvertedFilesInKb *RepositoryIMock) DeleteAllConvertedFilesInKb(ctx context.Context, kbUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteAllConvertedFilesInKb.beforeDeleteAllConvertedFilesInKbCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteAllConvertedFilesInKb.afterDeleteAllConvertedFilesInKbCounter, 1)

	if mmDeleteAllConvertedFilesInKb.inspectFuncDeleteAllConvertedFilesInKb != nil {
		mmDeleteAllConvertedFilesInKb.inspectFuncDeleteAllConvertedFilesInKb(ctx, kbUID)
	}

	mm_params := RepositoryIMockDeleteAllConvertedFilesInKbParams{ctx, kbUID}

	// Record call args
	mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.mutex.Lock()
	mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.callArgs = append(mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.callArgs, &mm_params)
	mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.mutex.Unlock()

	for _, e := range mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteAllConvertedFilesInKbParams{ctx, kbUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteAllConvertedFilesInKb.t.Errorf("RepositoryIMock.DeleteAllConvertedFilesInKb got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmDeleteAllConvertedFilesInKb.t.Errorf("RepositoryIMock.DeleteAllConvertedFilesInKb got unexpected parameter kbUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteAllConvertedFilesInKb.t.Errorf("RepositoryIMock.DeleteAllConvertedFilesInKb got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteAllConvertedFilesInKb.t.Fatal("No results are set for the RepositoryIMock.DeleteAllConvertedFilesInKb")
		}
		return (*mm_results).err
	}
	if mmDeleteAllConvertedFilesInKb.funcDeleteAllConvertedFilesInKb != nil {
		return mmDeleteAllConvertedFilesInKb.funcDeleteAllConvertedFilesInKb(ctx, kbUID)
	}
	mmDeleteAllConvertedFilesInKb.t.Fatalf("Unexpected call to RepositoryIMock.DeleteAllConvertedFilesInKb. %v %v", ctx, kbUID)
	return
}

// DeleteAllConvertedFilesInKbAfterCounter returns a count of finished RepositoryIMock.DeleteAllConvertedFilesInKb invocations
func (mmDeleteAllConvertedFilesInKb *RepositoryIMock) DeleteAllConvertedFilesInKbAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAllConvertedFilesInKb.afterDeleteAllConvertedFilesInKbCounter)
}

// DeleteAllConvertedFilesInKbBeforeCounter returns a count of RepositoryIMock.DeleteAllConvertedFilesInKb invocations
func (mmDeleteAllConvertedFilesInKb *RepositoryIMock) DeleteAllConvertedFilesInKbBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAllConvertedFilesInKb.beforeDeleteAllConvertedFilesInKbCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteAllConvertedFilesInKb.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteAllConvertedFilesInKb *mRepositoryIMockDeleteAllConvertedFilesInKb) Calls() []*RepositoryIMockDeleteAllConvertedFilesInKbParams {
	mmDeleteAllConvertedFilesInKb.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteAllConvertedFilesInKbParams, len(mmDeleteAllConvertedFilesInKb.callArgs))
	copy(argCopy, mmDeleteAllConvertedFilesInKb.callArgs)

	mmDeleteAllConvertedFilesInKb.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteAllConvertedFilesInKbDone returns true if the count of the DeleteAllConvertedFilesInKb invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteAllConvertedFilesInKbDone() bool {
	for _, e := range m.DeleteAllConvertedFilesInKbMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteAllConvertedFilesInKbMock.invocationsDone()
}

// MinimockDeleteAllConvertedFilesInKbInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteAllConvertedFilesInKbInspect() {
	for _, e := range m.DeleteAllConvertedFilesInKbMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteAllConvertedFilesInKb with params: %#v", *e.params)
		}
	}

	afterDeleteAllConvertedFilesInKbCounter := mm_atomic.LoadUint64(&m.afterDeleteAllConvertedFilesInKbCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteAllConvertedFilesInKbMock.defaultExpectation != nil && afterDeleteAllConvertedFilesInKbCounter < 1 {
		if m.DeleteAllConvertedFilesInKbMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteAllConvertedFilesInKb")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteAllConvertedFilesInKb with params: %#v", *m.DeleteAllConvertedFilesInKbMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteAllConvertedFilesInKb != nil && afterDeleteAllConvertedFilesInKbCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteAllConvertedFilesInKb")
	}

	if !m.DeleteAllConvertedFilesInKbMock.invocationsDone() && afterDeleteAllConvertedFilesInKbCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteAllConvertedFilesInKb but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteAllConvertedFilesInKbMock.expectedInvocations), afterDeleteAllConvertedFilesInKbCounter)
	}
}

type mRepositoryIMockDeleteAllKnowledgeBaseFiles struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteAllKnowledgeBaseFilesExpectation
	expectations       []*RepositoryIMockDeleteAllKnowledgeBaseFilesExpectation

	callArgs []*RepositoryIMockDeleteAllKnowledgeBaseFilesParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteAllKnowledgeBaseFilesExpectation specifies expectation struct of the RepositoryI.DeleteAllKnowledgeBaseFiles
type RepositoryIMockDeleteAllKnowledgeBaseFilesExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteAllKnowledgeBaseFilesParams
	paramPtrs *RepositoryIMockDeleteAllKnowledgeBaseFilesParamPtrs
	results   *RepositoryIMockDeleteAllKnowledgeBaseFilesResults
	Counter   uint64
}

// RepositoryIMockDeleteAllKnowledgeBaseFilesParams contains parameters of the RepositoryI.DeleteAllKnowledgeBaseFiles
type RepositoryIMockDeleteAllKnowledgeBaseFilesParams struct {
	ctx   context.Context
	kbUID string
}

// RepositoryIMockDeleteAllKnowledgeBaseFilesParamPtrs contains pointers to parameters of the RepositoryI.DeleteAllKnowledgeBaseFiles
type RepositoryIMockDeleteAllKnowledgeBaseFilesParamPtrs struct {
	ctx   *context.Context
	kbUID *string
}

// RepositoryIMockDeleteAllKnowledgeBaseFilesResults contains results of the RepositoryI.DeleteAllKnowledgeBaseFiles
type RepositoryIMockDeleteAllKnowledgeBaseFilesResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteAllKnowledgeBaseFiles
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryIMockDeleteAllKnowledgeBaseFiles) Expect(ctx context.Context, kbUID string) *mRepositoryIMockDeleteAllKnowledgeBaseFiles {
	if mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFiles != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.DeleteAllKnowledgeBaseFiles mock is already set by Set")
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation == nil {
		mmDeleteAllKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockDeleteAllKnowledgeBaseFilesExpectation{}
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation.paramPtrs != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.DeleteAllKnowledgeBaseFiles mock is already set by ExpectParams functions")
	}

	mmDeleteAllKnowledgeBaseFiles.defaultExpectation.params = &RepositoryIMockDeleteAllKnowledgeBaseFilesParams{ctx, kbUID}
	for _, e := range mmDeleteAllKnowledgeBaseFiles.expectations {
		if minimock.Equal(e.params, mmDeleteAllKnowledgeBaseFiles.defaultExpectation.params) {
			mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteAllKnowledgeBaseFiles.defaultExpectation.params)
		}
	}

	return mmDeleteAllKnowledgeBaseFiles
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteAllKnowledgeBaseFiles
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryIMockDeleteAllKnowledgeBaseFiles) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteAllKnowledgeBaseFiles {
	if mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFiles != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.DeleteAllKnowledgeBaseFiles mock is already set by Set")
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation == nil {
		mmDeleteAllKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockDeleteAllKnowledgeBaseFilesExpectation{}
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.DeleteAllKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmDeleteAllKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockDeleteAllKnowledgeBaseFilesParamPtrs{}
	}
	mmDeleteAllKnowledgeBaseFiles.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteAllKnowledgeBaseFiles
}

// ExpectKbUIDParam2 sets up expected param kbUID for RepositoryI.DeleteAllKnowledgeBaseFiles
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryIMockDeleteAllKnowledgeBaseFiles) ExpectKbUIDParam2(kbUID string) *mRepositoryIMockDeleteAllKnowledgeBaseFiles {
	if mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFiles != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.DeleteAllKnowledgeBaseFiles mock is already set by Set")
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation == nil {
		mmDeleteAllKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockDeleteAllKnowledgeBaseFilesExpectation{}
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.DeleteAllKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmDeleteAllKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockDeleteAllKnowledgeBaseFilesParamPtrs{}
	}
	mmDeleteAllKnowledgeBaseFiles.defaultExpectation.paramPtrs.kbUID = &kbUID

	return mmDeleteAllKnowledgeBaseFiles
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteAllKnowledgeBaseFiles
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryIMockDeleteAllKnowledgeBaseFiles) Inspect(f func(ctx context.Context, kbUID string)) *mRepositoryIMockDeleteAllKnowledgeBaseFiles {
	if mmDeleteAllKnowledgeBaseFiles.mock.inspectFuncDeleteAllKnowledgeBaseFiles != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteAllKnowledgeBaseFiles")
	}

	mmDeleteAllKnowledgeBaseFiles.mock.inspectFuncDeleteAllKnowledgeBaseFiles = f

	return mmDeleteAllKnowledgeBaseFiles
}

// Return sets up results that will be returned by RepositoryI.DeleteAllKnowledgeBaseFiles
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryIMockDeleteAllKnowledgeBaseFiles) Return(err error) *RepositoryIMock {
	if mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFiles != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.DeleteAllKnowledgeBaseFiles mock is already set by Set")
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation == nil {
		mmDeleteAllKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockDeleteAllKnowledgeBaseFilesExpectation{mock: mmDeleteAllKnowledgeBaseFiles.mock}
	}
	mmDeleteAllKnowledgeBaseFiles.defaultExpectation.results = &RepositoryIMockDeleteAllKnowledgeBaseFilesResults{err}
	return mmDeleteAllKnowledgeBaseFiles.mock
}

// Set uses given function f to mock the RepositoryI.DeleteAllKnowledgeBaseFiles method
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryIMockDeleteAllKnowledgeBaseFiles) Set(f func(ctx context.Context, kbUID string) (err error)) *RepositoryIMock {
	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteAllKnowledgeBaseFiles method")
	}

	if len(mmDeleteAllKnowledgeBaseFiles.expectations) > 0 {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteAllKnowledgeBaseFiles method")
	}

	mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFiles = f
	return mmDeleteAllKnowledgeBaseFiles.mock
}

// When sets expectation for the RepositoryI.DeleteAllKnowledgeBaseFiles which will trigger the result defined by the following
// Then helper
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryIMockDeleteAllKnowledgeBaseFiles) When(ctx context.Context, kbUID string) *RepositoryIMockDeleteAllKnowledgeBaseFilesExpectation {
	if mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFiles != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.DeleteAllKnowledgeBaseFiles mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteAllKnowledgeBaseFilesExpectation{
		mock:   mmDeleteAllKnowledgeBaseFiles.mock,
		params: &RepositoryIMockDeleteAllKnowledgeBaseFilesParams{ctx, kbUID},
	}
	mmDeleteAllKnowledgeBaseFiles.expectations = append(mmDeleteAllKnowledgeBaseFiles.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteAllKnowledgeBaseFiles return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteAllKnowledgeBaseFilesExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteAllKnowledgeBaseFilesResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteAllKnowledgeBaseFiles should be invoked
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryIMockDeleteAllKnowledgeBaseFiles) Times(n uint64) *mRepositoryIMockDeleteAllKnowledgeBaseFiles {
	if n == 0 {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("Times of RepositoryIMock.DeleteAllKnowledgeBaseFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteAllKnowledgeBaseFiles.expectedInvocations, n)
	return mmDeleteAllKnowledgeBaseFiles
}

func (mmDeleteAllKnowledgeBaseFiles *mRepositoryIMockDeleteAllKnowledgeBaseFiles) invocationsDone() bool {
	if len(mmDeleteAllKnowledgeBaseFiles.expectations) == 0 && mmDeleteAllKnowledgeBaseFiles.defaultExpectation == nil && mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteAllKnowledgeBaseFiles.mock.afterDeleteAllKnowledgeBaseFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteAllKnowledgeBaseFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteAllKnowledgeBaseFiles implements repository.RepositoryI
func (mmDeleteAllKnowledgeBaseFiles *RepositoryIMock) DeleteAllKnowledgeBaseFiles(ctx context.Context, kbUID string) (err error) {
	mm_atomic.AddUint64(&mmDeleteAllKnowledgeBaseFiles.beforeDeleteAllKnowledgeBaseFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteAllKnowledgeBaseFiles.afterDeleteAllKnowledgeBaseFilesCounter, 1)

	if mmDeleteAllKnowledgeBaseFiles.inspectFuncDeleteAllKnowledgeBaseFiles != nil {
		mmDeleteAllKnowledgeBaseFiles.inspectFuncDeleteAllKnowledgeBaseFiles(ctx, kbUID)
	}

	mm_params := RepositoryIMockDeleteAllKnowledgeBaseFilesParams{ctx, kbUID}

	// Record call args
	mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.mutex.Lock()
	mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.callArgs = append(mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.callArgs, &mm_params)
	mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.mutex.Unlock()

	for _, e := range mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteAllKnowledgeBaseFilesParams{ctx, kbUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteAllKnowledgeBaseFiles.t.Errorf("RepositoryIMock.DeleteAllKnowledgeBaseFiles got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmDeleteAllKnowledgeBaseFiles.t.Errorf("RepositoryIMock.DeleteAllKnowledgeBaseFiles got unexpected parameter kbUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteAllKnowledgeBaseFiles.t.Errorf("RepositoryIMock.DeleteAllKnowledgeBaseFiles got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteAllKnowledgeBaseFiles.t.Fatal("No results are set for the RepositoryIMock.DeleteAllKnowledgeBaseFiles")
		}
		return (*mm_results).err
	}
	if mmDeleteAllKnowledgeBaseFiles.funcDeleteAllKnowledgeBaseFiles != nil {
		return mmDeleteAllKnowledgeBaseFiles.funcDeleteAllKnowledgeBaseFiles(ctx, kbUID)
	}
	mmDeleteAllKnowledgeBaseFiles.t.Fatalf("Unexpected call to RepositoryIMock.DeleteAllKnowledgeBaseFiles. %v %v", ctx, kbUID)
	return
}

// DeleteAllKnowledgeBaseFilesAfterCounter returns a count of finished RepositoryIMock.DeleteAllKnowledgeBaseFiles invocations
func (mmDeleteAllKnowledgeBaseFiles *RepositoryIMock) DeleteAllKnowledgeBaseFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAllKnowledgeBaseFiles.afterDeleteAllKnowledgeBaseFilesCounter)
}

// DeleteAllKnowledgeBaseFilesBeforeCounter returns a count of RepositoryIMock.DeleteAllKnowledgeBaseFiles invocations
func (mmDeleteAllKnowledgeBaseFiles *RepositoryIMock) DeleteAllKnowledgeBaseFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAllKnowledgeBaseFiles.beforeDeleteAllKnowledgeBaseFilesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteAllKnowledgeBaseFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryIMockDeleteAllKnowledgeBaseFiles) Calls() []*RepositoryIMockDeleteAllKnowledgeBaseFilesParams {
	mmDeleteAllKnowledgeBaseFiles.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteAllKnowledgeBaseFilesParams, len(mmDeleteAllKnowledgeBaseFiles.callArgs))
	copy(argCopy, mmDeleteAllKnowledgeBaseFiles.callArgs)

	mmDeleteAllKnowledgeBaseFiles.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteAllKnowledgeBaseFilesDone returns true if the count of the DeleteAllKnowledgeBaseFiles invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteAllKnowledgeBaseFilesDone() bool {
	for _, e := range m.DeleteAllKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteAllKnowledgeBaseFilesMock.invocationsDone()
}

// MinimockDeleteAllKnowledgeBaseFilesInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteAllKnowledgeBaseFilesInspect() {
	for _, e := range m.DeleteAllKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteAllKnowledgeBaseFiles with params: %#v", *e.params)
		}
	}

	afterDeleteAllKnowledgeBaseFilesCounter := mm_atomic.LoadUint64(&m.afterDeleteAllKnowledgeBaseFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteAllKnowledgeBaseFilesMock.defaultExpectation != nil && afterDeleteAllKnowledgeBaseFilesCounter < 1 {
		if m.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteAllKnowledgeBaseFiles")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteAllKnowledgeBaseFiles with params: %#v", *m.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteAllKnowledgeBaseFiles != nil && afterDeleteAllKnowledgeBaseFilesCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteAllKnowledgeBaseFiles")
	}

	if !m.DeleteAllKnowledgeBaseFilesMock.invocationsDone() && afterDeleteAllKnowledgeBaseFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteAllKnowledgeBaseFiles but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteAllKnowledgeBaseFilesMock.expectedInvocations), afterDeleteAllKnowledgeBaseFilesCounter)
	}
}

type mRepositoryIMockDeleteAndCreateChunks struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteAndCreateChunksExpectation
	expectations       []*RepositoryIMockDeleteAndCreateChunksExpectation

	callArgs []*RepositoryIMockDeleteAndCreateChunksParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteAndCreateChunksExpectation specifies expectation struct of the RepositoryI.DeleteAndCreateChunks
type RepositoryIMockDeleteAndCreateChunksExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteAndCreateChunksParams
	paramPtrs *RepositoryIMockDeleteAndCreateChunksParamPtrs
	results   *RepositoryIMockDeleteAndCreateChunksResults
	Counter   uint64
}

// RepositoryIMockDeleteAndCreateChunksParams contains parameters of the RepositoryI.DeleteAndCreateChunks
type RepositoryIMockDeleteAndCreateChunksParams struct {
	ctx                 context.Context
	sourceTable         string
	sourceUID           uuid.UUID
	chunks              []*mm_repository.TextChunk
	externalServiceCall func(chunkUIDs []string) (map[string]any, error)
}

// RepositoryIMockDeleteAndCreateChunksParamPtrs contains pointers to parameters of the RepositoryI.DeleteAndCreateChunks
type RepositoryIMockDeleteAndCreateChunksParamPtrs struct {
	ctx                 *context.Context
	sourceTable         *string
	sourceUID           *uuid.UUID
	chunks              *[]*mm_repository.TextChunk
	externalServiceCall *func(chunkUIDs []string) (map[string]any, error)
}

// RepositoryIMockDeleteAndCreateChunksResults contains results of the RepositoryI.DeleteAndCreateChunks
type RepositoryIMockDeleteAndCreateChunksResults struct {
	tpa1 []*mm_repository.TextChunk
	err  error
}

// Expect sets up expected params for RepositoryI.DeleteAndCreateChunks
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) Expect(ctx context.Context, sourceTable string, sourceUID uuid.UUID, chunks []*mm_repository.TextChunk, externalServiceCall func(chunkUIDs []string) (map[string]any, error)) *mRepositoryIMockDeleteAndCreateChunks {
	if mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Set")
	}

	if mmDeleteAndCreateChunks.defaultExpectation == nil {
		mmDeleteAndCreateChunks.defaultExpectation = &RepositoryIMockDeleteAndCreateChunksExpectation{}
	}

	if mmDeleteAndCreateChunks.defaultExpectation.paramPtrs != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by ExpectParams functions")
	}

	mmDeleteAndCreateChunks.defaultExpectation.params = &RepositoryIMockDeleteAndCreateChunksParams{ctx, sourceTable, sourceUID, chunks, externalServiceCall}
	for _, e := range mmDeleteAndCreateChunks.expectations {
		if minimock.Equal(e.params, mmDeleteAndCreateChunks.defaultExpectation.params) {
			mmDeleteAndCreateChunks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteAndCreateChunks.defaultExpectation.params)
		}
	}

	return mmDeleteAndCreateChunks
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteAndCreateChunks
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteAndCreateChunks {
	if mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Set")
	}

	if mmDeleteAndCreateChunks.defaultExpectation == nil {
		mmDeleteAndCreateChunks.defaultExpectation = &RepositoryIMockDeleteAndCreateChunksExpectation{}
	}

	if mmDeleteAndCreateChunks.defaultExpectation.params != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Expect")
	}

	if mmDeleteAndCreateChunks.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateChunks.defaultExpectation.paramPtrs = &RepositoryIMockDeleteAndCreateChunksParamPtrs{}
	}
	mmDeleteAndCreateChunks.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteAndCreateChunks
}

// ExpectSourceTableParam2 sets up expected param sourceTable for RepositoryI.DeleteAndCreateChunks
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) ExpectSourceTableParam2(sourceTable string) *mRepositoryIMockDeleteAndCreateChunks {
	if mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Set")
	}

	if mmDeleteAndCreateChunks.defaultExpectation == nil {
		mmDeleteAndCreateChunks.defaultExpectation = &RepositoryIMockDeleteAndCreateChunksExpectation{}
	}

	if mmDeleteAndCreateChunks.defaultExpectation.params != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Expect")
	}

	if mmDeleteAndCreateChunks.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateChunks.defaultExpectation.paramPtrs = &RepositoryIMockDeleteAndCreateChunksParamPtrs{}
	}
	mmDeleteAndCreateChunks.defaultExpectation.paramPtrs.sourceTable = &sourceTable

	return mmDeleteAndCreateChunks
}

// ExpectSourceUIDParam3 sets up expected param sourceUID for RepositoryI.DeleteAndCreateChunks
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) ExpectSourceUIDParam3(sourceUID uuid.UUID) *mRepositoryIMockDeleteAndCreateChunks {
	if mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Set")
	}

	if mmDeleteAndCreateChunks.defaultExpectation == nil {
		mmDeleteAndCreateChunks.defaultExpectation = &RepositoryIMockDeleteAndCreateChunksExpectation{}
	}

	if mmDeleteAndCreateChunks.defaultExpectation.params != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Expect")
	}

	if mmDeleteAndCreateChunks.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateChunks.defaultExpectation.paramPtrs = &RepositoryIMockDeleteAndCreateChunksParamPtrs{}
	}
	mmDeleteAndCreateChunks.defaultExpectation.paramPtrs.sourceUID = &sourceUID

	return mmDeleteAndCreateChunks
}

// ExpectChunksParam4 sets up expected param chunks for RepositoryI.DeleteAndCreateChunks
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) ExpectChunksParam4(chunks []*mm_repository.TextChunk) *mRepositoryIMockDeleteAndCreateChunks {
	if mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Set")
	}

	if mmDeleteAndCreateChunks.defaultExpectation == nil {
		mmDeleteAndCreateChunks.defaultExpectation = &RepositoryIMockDeleteAndCreateChunksExpectation{}
	}

	if mmDeleteAndCreateChunks.defaultExpectation.params != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Expect")
	}

	if mmDeleteAndCreateChunks.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateChunks.defaultExpectation.paramPtrs = &RepositoryIMockDeleteAndCreateChunksParamPtrs{}
	}
	mmDeleteAndCreateChunks.defaultExpectation.paramPtrs.chunks = &chunks

	return mmDeleteAndCreateChunks
}

// ExpectExternalServiceCallParam5 sets up expected param externalServiceCall for RepositoryI.DeleteAndCreateChunks
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) ExpectExternalServiceCallParam5(externalServiceCall func(chunkUIDs []string) (map[string]any, error)) *mRepositoryIMockDeleteAndCreateChunks {
	if mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Set")
	}

	if mmDeleteAndCreateChunks.defaultExpectation == nil {
		mmDeleteAndCreateChunks.defaultExpectation = &RepositoryIMockDeleteAndCreateChunksExpectation{}
	}

	if mmDeleteAndCreateChunks.defaultExpectation.params != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Expect")
	}

	if mmDeleteAndCreateChunks.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateChunks.defaultExpectation.paramPtrs = &RepositoryIMockDeleteAndCreateChunksParamPtrs{}
	}
	mmDeleteAndCreateChunks.defaultExpectation.paramPtrs.externalServiceCall = &externalServiceCall

	return mmDeleteAndCreateChunks
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteAndCreateChunks
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) Inspect(f func(ctx context.Context, sourceTable string, sourceUID uuid.UUID, chunks []*mm_repository.TextChunk, externalServiceCall func(chunkUIDs []string) (map[string]any, error))) *mRepositoryIMockDeleteAndCreateChunks {
	if mmDeleteAndCreateChunks.mock.inspectFuncDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteAndCreateChunks")
	}

	mmDeleteAndCreateChunks.mock.inspectFuncDeleteAndCreateChunks = f

	return mmDeleteAndCreateChunks
}

// Return sets up results that will be returned by RepositoryI.DeleteAndCreateChunks
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) Return(tpa1 []*mm_repository.TextChunk, err error) *RepositoryIMock {
	if mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Set")
	}

	if mmDeleteAndCreateChunks.defaultExpectation == nil {
		mmDeleteAndCreateChunks.defaultExpectation = &RepositoryIMockDeleteAndCreateChunksExpectation{mock: mmDeleteAndCreateChunks.mock}
	}
	mmDeleteAndCreateChunks.defaultExpectation.results = &RepositoryIMockDeleteAndCreateChunksResults{tpa1, err}
	return mmDeleteAndCreateChunks.mock
}

// Set uses given function f to mock the RepositoryI.DeleteAndCreateChunks method
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) Set(f func(ctx context.Context, sourceTable string, sourceUID uuid.UUID, chunks []*mm_repository.TextChunk, externalServiceCall func(chunkUIDs []string) (map[string]any, error)) (tpa1 []*mm_repository.TextChunk, err error)) *RepositoryIMock {
	if mmDeleteAndCreateChunks.defaultExpectation != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteAndCreateChunks method")
	}

	if len(mmDeleteAndCreateChunks.expectations) > 0 {
		mmDeleteAndCreateChunks.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteAndCreateChunks method")
	}

	mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks = f
	return mmDeleteAndCreateChunks.mock
}

// When sets expectation for the RepositoryI.DeleteAndCreateChunks which will trigger the result defined by the following
// Then helper
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) When(ctx context.Context, sourceTable string, sourceUID uuid.UUID, chunks []*mm_repository.TextChunk, externalServiceCall func(chunkUIDs []string) (map[string]any, error)) *RepositoryIMockDeleteAndCreateChunksExpectation {
	if mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteAndCreateChunksExpectation{
		mock:   mmDeleteAndCreateChunks.mock,
		params: &RepositoryIMockDeleteAndCreateChunksParams{ctx, sourceTable, sourceUID, chunks, externalServiceCall},
	}
	mmDeleteAndCreateChunks.expectations = append(mmDeleteAndCreateChunks.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteAndCreateChunks return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteAndCreateChunksExpectation) Then(tpa1 []*mm_repository.TextChunk, err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteAndCreateChunksResults{tpa1, err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteAndCreateChunks should be invoked
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) Times(n uint64) *mRepositoryIMockDeleteAndCreateChunks {
	if n == 0 {
		mmDeleteAndCreateChunks.mock.t.Fatalf("Times of RepositoryIMock.DeleteAndCreateChunks mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteAndCreateChunks.expectedInvocations, n)
	return mmDeleteAndCreateChunks
}

func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) invocationsDone() bool {
	if len(mmDeleteAndCreateChunks.expectations) == 0 && mmDeleteAndCreateChunks.defaultExpectation == nil && mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteAndCreateChunks.mock.afterDeleteAndCreateChunksCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteAndCreateChunks.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteAndCreateChunks implements repository.RepositoryI
func (mmDeleteAndCreateChunks *RepositoryIMock) DeleteAndCreateChunks(ctx context.Context, sourceTable string, sourceUID uuid.UUID, chunks []*mm_repository.TextChunk, externalServiceCall func(chunkUIDs []string) (map[string]any, error)) (tpa1 []*mm_repository.TextChunk, err error) {
	mm_atomic.AddUint64(&mmDeleteAndCreateChunks.beforeDeleteAndCreateChunksCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteAndCreateChunks.afterDeleteAndCreateChunksCounter, 1)

	if mmDeleteAndCreateChunks.inspectFuncDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.inspectFuncDeleteAndCreateChunks(ctx, sourceTable, sourceUID, chunks, externalServiceCall)
	}

	mm_params := RepositoryIMockDeleteAndCreateChunksParams{ctx, sourceTable, sourceUID, chunks, externalServiceCall}

	// Record call args
	mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.mutex.Lock()
	mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.callArgs = append(mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.callArgs, &mm_params)
	mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.mutex.Unlock()

	for _, e := range mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tpa1, e.results.err
		}
	}

	if mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteAndCreateChunksParams{ctx, sourceTable, sourceUID, chunks, externalServiceCall}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteAndCreateChunks.t.Errorf("RepositoryIMock.DeleteAndCreateChunks got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sourceTable != nil && !minimock.Equal(*mm_want_ptrs.sourceTable, mm_got.sourceTable) {
				mmDeleteAndCreateChunks.t.Errorf("RepositoryIMock.DeleteAndCreateChunks got unexpected parameter sourceTable, want: %#v, got: %#v%s\n", *mm_want_ptrs.sourceTable, mm_got.sourceTable, minimock.Diff(*mm_want_ptrs.sourceTable, mm_got.sourceTable))
			}

			if mm_want_ptrs.sourceUID != nil && !minimock.Equal(*mm_want_ptrs.sourceUID, mm_got.sourceUID) {
				mmDeleteAndCreateChunks.t.Errorf("RepositoryIMock.DeleteAndCreateChunks got unexpected parameter sourceUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.sourceUID, mm_got.sourceUID, minimock.Diff(*mm_want_ptrs.sourceUID, mm_got.sourceUID))
			}

			if mm_want_ptrs.chunks != nil && !minimock.Equal(*mm_want_ptrs.chunks, mm_got.chunks) {
				mmDeleteAndCreateChunks.t.Errorf("RepositoryIMock.DeleteAndCreateChunks got unexpected parameter chunks, want: %#v, got: %#v%s\n", *mm_want_ptrs.chunks, mm_got.chunks, minimock.Diff(*mm_want_ptrs.chunks, mm_got.chunks))
			}

			if mm_want_ptrs.externalServiceCall != nil && !minimock.Equal(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall) {
				mmDeleteAndCreateChunks.t.Errorf("RepositoryIMock.DeleteAndCreateChunks got unexpected parameter externalServiceCall, want: %#v, got: %#v%s\n", *mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall, minimock.Diff(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteAndCreateChunks.t.Errorf("RepositoryIMock.DeleteAndCreateChunks got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteAndCreateChunks.t.Fatal("No results are set for the RepositoryIMock.DeleteAndCreateChunks")
		}
		return (*mm_results).tpa1, (*mm_results).err
	}
	if mmDeleteAndCreateChunks.funcDeleteAndCreateChunks != nil {
		return mmDeleteAndCreateChunks.funcDeleteAndCreateChunks(ctx, sourceTable, sourceUID, chunks, externalServiceCall)
	}
	mmDeleteAndCreateChunks.t.Fatalf("Unexpected call to RepositoryIMock.DeleteAndCreateChunks. %v %v %v %v %v", ctx, sourceTable, sourceUID, chunks, externalServiceCall)
	return
}

// DeleteAndCreateChunksAfterCounter returns a count of finished RepositoryIMock.DeleteAndCreateChunks invocations
func (mmDeleteAndCreateChunks *RepositoryIMock) DeleteAndCreateChunksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAndCreateChunks.afterDeleteAndCreateChunksCounter)
}

// DeleteAndCreateChunksBeforeCounter returns a count of RepositoryIMock.DeleteAndCreateChunks invocations
func (mmDeleteAndCreateChunks *RepositoryIMock) DeleteAndCreateChunksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAndCreateChunks.beforeDeleteAndCreateChunksCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteAndCreateChunks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) Calls() []*RepositoryIMockDeleteAndCreateChunksParams {
	mmDeleteAndCreateChunks.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteAndCreateChunksParams, len(mmDeleteAndCreateChunks.callArgs))
	copy(argCopy, mmDeleteAndCreateChunks.callArgs)

	mmDeleteAndCreateChunks.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteAndCreateChunksDone returns true if the count of the DeleteAndCreateChunks invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteAndCreateChunksDone() bool {
	for _, e := range m.DeleteAndCreateChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteAndCreateChunksMock.invocationsDone()
}

// MinimockDeleteAndCreateChunksInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteAndCreateChunksInspect() {
	for _, e := range m.DeleteAndCreateChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteAndCreateChunks with params: %#v", *e.params)
		}
	}

	afterDeleteAndCreateChunksCounter := mm_atomic.LoadUint64(&m.afterDeleteAndCreateChunksCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteAndCreateChunksMock.defaultExpectation != nil && afterDeleteAndCreateChunksCounter < 1 {
		if m.DeleteAndCreateChunksMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteAndCreateChunks")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteAndCreateChunks with params: %#v", *m.DeleteAndCreateChunksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteAndCreateChunks != nil && afterDeleteAndCreateChunksCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteAndCreateChunks")
	}

	if !m.DeleteAndCreateChunksMock.invocationsDone() && afterDeleteAndCreateChunksCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteAndCreateChunks but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteAndCreateChunksMock.expectedInvocations), afterDeleteAndCreateChunksCounter)
	}
}

type mRepositoryIMockDeleteChunksBySource struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteChunksBySourceExpectation
	expectations       []*RepositoryIMockDeleteChunksBySourceExpectation

	callArgs []*RepositoryIMockDeleteChunksBySourceParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteChunksBySourceExpectation specifies expectation struct of the RepositoryI.DeleteChunksBySource
type RepositoryIMockDeleteChunksBySourceExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteChunksBySourceParams
	paramPtrs *RepositoryIMockDeleteChunksBySourceParamPtrs
	results   *RepositoryIMockDeleteChunksBySourceResults
	Counter   uint64
}

// RepositoryIMockDeleteChunksBySourceParams contains parameters of the RepositoryI.DeleteChunksBySource
type RepositoryIMockDeleteChunksBySourceParams struct {
	ctx         context.Context
	sourceTable string
	sourceUID   uuid.UUID
}

// RepositoryIMockDeleteChunksBySourceParamPtrs contains pointers to parameters of the RepositoryI.DeleteChunksBySource
type RepositoryIMockDeleteChunksBySourceParamPtrs struct {
	ctx         *context.Context
	sourceTable *string
	sourceUID   *uuid.UUID
}

// RepositoryIMockDeleteChunksBySourceResults contains results of the RepositoryI.DeleteChunksBySource
type RepositoryIMockDeleteChunksBySourceResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteChunksBySource
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) Expect(ctx context.Context, sourceTable string, sourceUID uuid.UUID) *mRepositoryIMockDeleteChunksBySource {
	if mmDeleteChunksBySource.mock.funcDeleteChunksBySource != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by Set")
	}

	if mmDeleteChunksBySource.defaultExpectation == nil {
		mmDeleteChunksBySource.defaultExpectation = &RepositoryIMockDeleteChunksBySourceExpectation{}
	}

	if mmDeleteChunksBySource.defaultExpectation.paramPtrs != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by ExpectParams functions")
	}

	mmDeleteChunksBySource.defaultExpectation.params = &RepositoryIMockDeleteChunksBySourceParams{ctx, sourceTable, sourceUID}
	for _, e := range mmDeleteChunksBySource.expectations {
		if minimock.Equal(e.params, mmDeleteChunksBySource.defaultExpectation.params) {
			mmDeleteChunksBySource.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChunksBySource.defaultExpectation.params)
		}
	}

	return mmDeleteChunksBySource
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteChunksBySource
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteChunksBySource {
	if mmDeleteChunksBySource.mock.funcDeleteChunksBySource != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by Set")
	}

	if mmDeleteChunksBySource.defaultExpectation == nil {
		mmDeleteChunksBySource.defaultExpectation = &RepositoryIMockDeleteChunksBySourceExpectation{}
	}

	if mmDeleteChunksBySource.defaultExpectation.params != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by Expect")
	}

	if mmDeleteChunksBySource.defaultExpectation.paramPtrs == nil {
		mmDeleteChunksBySource.defaultExpectation.paramPtrs = &RepositoryIMockDeleteChunksBySourceParamPtrs{}
	}
	mmDeleteChunksBySource.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteChunksBySource
}

// ExpectSourceTableParam2 sets up expected param sourceTable for RepositoryI.DeleteChunksBySource
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) ExpectSourceTableParam2(sourceTable string) *mRepositoryIMockDeleteChunksBySource {
	if mmDeleteChunksBySource.mock.funcDeleteChunksBySource != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by Set")
	}

	if mmDeleteChunksBySource.defaultExpectation == nil {
		mmDeleteChunksBySource.defaultExpectation = &RepositoryIMockDeleteChunksBySourceExpectation{}
	}

	if mmDeleteChunksBySource.defaultExpectation.params != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by Expect")
	}

	if mmDeleteChunksBySource.defaultExpectation.paramPtrs == nil {
		mmDeleteChunksBySource.defaultExpectation.paramPtrs = &RepositoryIMockDeleteChunksBySourceParamPtrs{}
	}
	mmDeleteChunksBySource.defaultExpectation.paramPtrs.sourceTable = &sourceTable

	return mmDeleteChunksBySource
}

// ExpectSourceUIDParam3 sets up expected param sourceUID for RepositoryI.DeleteChunksBySource
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) ExpectSourceUIDParam3(sourceUID uuid.UUID) *mRepositoryIMockDeleteChunksBySource {
	if mmDeleteChunksBySource.mock.funcDeleteChunksBySource != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by Set")
	}

	if mmDeleteChunksBySource.defaultExpectation == nil {
		mmDeleteChunksBySource.defaultExpectation = &RepositoryIMockDeleteChunksBySourceExpectation{}
	}

	if mmDeleteChunksBySource.defaultExpectation.params != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by Expect")
	}

	if mmDeleteChunksBySource.defaultExpectation.paramPtrs == nil {
		mmDeleteChunksBySource.defaultExpectation.paramPtrs = &RepositoryIMockDeleteChunksBySourceParamPtrs{}
	}
	mmDeleteChunksBySource.defaultExpectation.paramPtrs.sourceUID = &sourceUID

	return mmDeleteChunksBySource
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteChunksBySource
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) Inspect(f func(ctx context.Context, sourceTable string, sourceUID uuid.UUID)) *mRepositoryIMockDeleteChunksBySource {
	if mmDeleteChunksBySource.mock.inspectFuncDeleteChunksBySource != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteChunksBySource")
	}

	mmDeleteChunksBySource.mock.inspectFuncDeleteChunksBySource = f

	return mmDeleteChunksBySource
}

// Return sets up results that will be returned by RepositoryI.DeleteChunksBySource
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) Return(err error) *RepositoryIMock {
	if mmDeleteChunksBySource.mock.funcDeleteChunksBySource != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by Set")
	}

	if mmDeleteChunksBySource.defaultExpectation == nil {
		mmDeleteChunksBySource.defaultExpectation = &RepositoryIMockDeleteChunksBySourceExpectation{mock: mmDeleteChunksBySource.mock}
	}
	mmDeleteChunksBySource.defaultExpectation.results = &RepositoryIMockDeleteChunksBySourceResults{err}
	return mmDeleteChunksBySource.mock
}

// Set uses given function f to mock the RepositoryI.DeleteChunksBySource method
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) Set(f func(ctx context.Context, sourceTable string, sourceUID uuid.UUID) (err error)) *RepositoryIMock {
	if mmDeleteChunksBySource.defaultExpectation != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteChunksBySource method")
	}

	if len(mmDeleteChunksBySource.expectations) > 0 {
		mmDeleteChunksBySource.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteChunksBySource method")
	}

	mmDeleteChunksBySource.mock.funcDeleteChunksBySource = f
	return mmDeleteChunksBySource.mock
}

// When sets expectation for the RepositoryI.DeleteChunksBySource which will trigger the result defined by the following
// Then helper
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) When(ctx context.Context, sourceTable string, sourceUID uuid.UUID) *RepositoryIMockDeleteChunksBySourceExpectation {
	if mmDeleteChunksBySource.mock.funcDeleteChunksBySource != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteChunksBySourceExpectation{
		mock:   mmDeleteChunksBySource.mock,
		params: &RepositoryIMockDeleteChunksBySourceParams{ctx, sourceTable, sourceUID},
	}
	mmDeleteChunksBySource.expectations = append(mmDeleteChunksBySource.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteChunksBySource return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteChunksBySourceExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteChunksBySourceResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteChunksBySource should be invoked
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) Times(n uint64) *mRepositoryIMockDeleteChunksBySource {
	if n == 0 {
		mmDeleteChunksBySource.mock.t.Fatalf("Times of RepositoryIMock.DeleteChunksBySource mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteChunksBySource.expectedInvocations, n)
	return mmDeleteChunksBySource
}

func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) invocationsDone() bool {
	if len(mmDeleteChunksBySource.expectations) == 0 && mmDeleteChunksBySource.defaultExpectation == nil && mmDeleteChunksBySource.mock.funcDeleteChunksBySource == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteChunksBySource.mock.afterDeleteChunksBySourceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteChunksBySource.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteChunksBySource implements repository.RepositoryI
func (mmDeleteChunksBySource *RepositoryIMock) DeleteChunksBySource(ctx context.Context, sourceTable string, sourceUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteChunksBySource.beforeDeleteChunksBySourceCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChunksBySource.afterDeleteChunksBySourceCounter, 1)

	if mmDeleteChunksBySource.inspectFuncDeleteChunksBySource != nil {
		mmDeleteChunksBySource.inspectFuncDeleteChunksBySource(ctx, sourceTable, sourceUID)
	}

	mm_params := RepositoryIMockDeleteChunksBySourceParams{ctx, sourceTable, sourceUID}

	// Record call args
	mmDeleteChunksBySource.DeleteChunksBySourceMock.mutex.Lock()
	mmDeleteChunksBySource.DeleteChunksBySourceMock.callArgs = append(mmDeleteChunksBySource.DeleteChunksBySourceMock.callArgs, &mm_params)
	mmDeleteChunksBySource.DeleteChunksBySourceMock.mutex.Unlock()

	for _, e := range mmDeleteChunksBySource.DeleteChunksBySourceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChunksBySource.DeleteChunksBySourceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChunksBySource.DeleteChunksBySourceMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChunksBySource.DeleteChunksBySourceMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteChunksBySource.DeleteChunksBySourceMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteChunksBySourceParams{ctx, sourceTable, sourceUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteChunksBySource.t.Errorf("RepositoryIMock.DeleteChunksBySource got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sourceTable != nil && !minimock.Equal(*mm_want_ptrs.sourceTable, mm_got.sourceTable) {
				mmDeleteChunksBySource.t.Errorf("RepositoryIMock.DeleteChunksBySource got unexpected parameter sourceTable, want: %#v, got: %#v%s\n", *mm_want_ptrs.sourceTable, mm_got.sourceTable, minimock.Diff(*mm_want_ptrs.sourceTable, mm_got.sourceTable))
			}

			if mm_want_ptrs.sourceUID != nil && !minimock.Equal(*mm_want_ptrs.sourceUID, mm_got.sourceUID) {
				mmDeleteChunksBySource.t.Errorf("RepositoryIMock.DeleteChunksBySource got unexpected parameter sourceUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.sourceUID, mm_got.sourceUID, minimock.Diff(*mm_want_ptrs.sourceUID, mm_got.sourceUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChunksBySource.t.Errorf("RepositoryIMock.DeleteChunksBySource got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChunksBySource.DeleteChunksBySourceMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChunksBySource.t.Fatal("No results are set for the RepositoryIMock.DeleteChunksBySource")
		}
		return (*mm_results).err
	}
	if mmDeleteChunksBySource.funcDeleteChunksBySource != nil {
		return mmDeleteChunksBySource.funcDeleteChunksBySource(ctx, sourceTable, sourceUID)
	}
	mmDeleteChunksBySource.t.Fatalf("Unexpected call to RepositoryIMock.DeleteChunksBySource. %v %v %v", ctx, sourceTable, sourceUID)
	return
}

// DeleteChunksBySourceAfterCounter returns a count of finished RepositoryIMock.DeleteChunksBySource invocations
func (mmDeleteChunksBySource *RepositoryIMock) DeleteChunksBySourceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChunksBySource.afterDeleteChunksBySourceCounter)
}

// DeleteChunksBySourceBeforeCounter returns a count of RepositoryIMock.DeleteChunksBySource invocations
func (mmDeleteChunksBySource *RepositoryIMock) DeleteChunksBySourceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChunksBySource.beforeDeleteChunksBySourceCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteChunksBySource.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) Calls() []*RepositoryIMockDeleteChunksBySourceParams {
	mmDeleteChunksBySource.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteChunksBySourceParams, len(mmDeleteChunksBySource.callArgs))
	copy(argCopy, mmDeleteChunksBySource.callArgs)

	mmDeleteChunksBySource.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChunksBySourceDone returns true if the count of the DeleteChunksBySource invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteChunksBySourceDone() bool {
	for _, e := range m.DeleteChunksBySourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteChunksBySourceMock.invocationsDone()
}

// MinimockDeleteChunksBySourceInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteChunksBySourceInspect() {
	for _, e := range m.DeleteChunksBySourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteChunksBySource with params: %#v", *e.params)
		}
	}

	afterDeleteChunksBySourceCounter := mm_atomic.LoadUint64(&m.afterDeleteChunksBySourceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChunksBySourceMock.defaultExpectation != nil && afterDeleteChunksBySourceCounter < 1 {
		if m.DeleteChunksBySourceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteChunksBySource")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteChunksBySource with params: %#v", *m.DeleteChunksBySourceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChunksBySource != nil && afterDeleteChunksBySourceCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteChunksBySource")
	}

	if !m.DeleteChunksBySourceMock.invocationsDone() && afterDeleteChunksBySourceCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteChunksBySource but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteChunksBySourceMock.expectedInvocations), afterDeleteChunksBySourceCounter)
	}
}

type mRepositoryIMockDeleteChunksByUIDs struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteChunksByUIDsExpectation
	expectations       []*RepositoryIMockDeleteChunksByUIDsExpectation

	callArgs []*RepositoryIMockDeleteChunksByUIDsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteChunksByUIDsExpectation specifies expectation struct of the RepositoryI.DeleteChunksByUIDs
type RepositoryIMockDeleteChunksByUIDsExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteChunksByUIDsParams
	paramPtrs *RepositoryIMockDeleteChunksByUIDsParamPtrs
	results   *RepositoryIMockDeleteChunksByUIDsResults
	Counter   uint64
}

// RepositoryIMockDeleteChunksByUIDsParams contains parameters of the RepositoryI.DeleteChunksByUIDs
type RepositoryIMockDeleteChunksByUIDsParams struct {
	ctx       context.Context
	chunkUIDs []uuid.UUID
}

// RepositoryIMockDeleteChunksByUIDsParamPtrs contains pointers to parameters of the RepositoryI.DeleteChunksByUIDs
type RepositoryIMockDeleteChunksByUIDsParamPtrs struct {
	ctx       *context.Context
	chunkUIDs *[]uuid.UUID
}

// RepositoryIMockDeleteChunksByUIDsResults contains results of the RepositoryI.DeleteChunksByUIDs
type RepositoryIMockDeleteChunksByUIDsResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteChunksByUIDs
func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) Expect(ctx context.Context, chunkUIDs []uuid.UUID) *mRepositoryIMockDeleteChunksByUIDs {
	if mmDeleteChunksByUIDs.mock.funcDeleteChunksByUIDs != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteChunksByUIDs mock is already set by Set")
	}

	if mmDeleteChunksByUIDs.defaultExpectation == nil {
		mmDeleteChunksByUIDs.defaultExpectation = &RepositoryIMockDeleteChunksByUIDsExpectation{}
	}

	if mmDeleteChunksByUIDs.defaultExpectation.paramPtrs != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteChunksByUIDs mock is already set by ExpectParams functions")
	}

	mmDeleteChunksByUIDs.defaultExpectation.params = &RepositoryIMockDeleteChunksByUIDsParams{ctx, chunkUIDs}
	for _, e := range mmDeleteChunksByUIDs.expectations {
		if minimock.Equal(e.params, mmDeleteChunksByUIDs.defaultExpectation.params) {
			mmDeleteChunksByUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChunksByUIDs.defaultExpectation.params)
		}
	}

	return mmDeleteChunksByUIDs
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteChunksByUIDs
func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteChunksByUIDs {
	if mmDeleteChunksByUIDs.mock.funcDeleteChunksByUIDs != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteChunksByUIDs mock is already set by Set")
	}

	if mmDeleteChunksByUIDs.defaultExpectation == nil {
		mmDeleteChunksByUIDs.defaultExpectation = &RepositoryIMockDeleteChunksByUIDsExpectation{}
	}

	if mmDeleteChunksByUIDs.defaultExpectation.params != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteChunksByUIDs mock is already set by Expect")
	}

	if mmDeleteChunksByUIDs.defaultExpectation.paramPtrs == nil {
		mmDeleteChunksByUIDs.defaultExpectation.paramPtrs = &RepositoryIMockDeleteChunksByUIDsParamPtrs{}
	}
	mmDeleteChunksByUIDs.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteChunksByUIDs
}

// ExpectChunkUIDsParam2 sets up expected param chunkUIDs for RepositoryI.DeleteChunksByUIDs
func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) ExpectChunkUIDsParam2(chunkUIDs []uuid.UUID) *mRepositoryIMockDeleteChunksByUIDs {
	if mmDeleteChunksByUIDs.mock.funcDeleteChunksByUIDs != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteChunksByUIDs mock is already set by Set")
	}

	if mmDeleteChunksByUIDs.defaultExpectation == nil {
		mmDeleteChunksByUIDs.defaultExpectation = &RepositoryIMockDeleteChunksByUIDsExpectation{}
	}

	if mmDeleteChunksByUIDs.defaultExpectation.params != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteChunksByUIDs mock is already set by Expect")
	}

	if mmDeleteChunksByUIDs.defaultExpectation.paramPtrs == nil {
		mmDeleteChunksByUIDs.defaultExpectation.paramPtrs = &RepositoryIMockDeleteChunksByUIDsParamPtrs{}
	}
	mmDeleteChunksByUIDs.defaultExpectation.paramPtrs.chunkUIDs = &chunkUIDs

	return mmDeleteChunksByUIDs
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteChunksByUIDs
func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) Inspect(f func(ctx context.Context, chunkUIDs []uuid.UUID)) *mRepositoryIMockDeleteChunksByUIDs {
	if mmDeleteChunksByUIDs.mock.inspectFuncDeleteChunksByUIDs != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteChunksByUIDs")
	}

	mmDeleteChunksByUIDs.mock.inspectFuncDeleteChunksByUIDs = f

	return mmDeleteChunksByUIDs
}

// Return sets up results that will be returned by RepositoryI.DeleteChunksByUIDs
func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) Return(err error) *RepositoryIMock {
	if mmDeleteChunksByUIDs.mock.funcDeleteChunksByUIDs != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteChunksByUIDs mock is already set by Set")
	}

	if mmDeleteChunksByUIDs.defaultExpectation == nil {
		mmDeleteChunksByUIDs.defaultExpectation = &RepositoryIMockDeleteChunksByUIDsExpectation{mock: mmDeleteChunksByUIDs.mock}
	}
	mmDeleteChunksByUIDs.defaultExpectation.results = &RepositoryIMockDeleteChunksByUIDsResults{err}
	return mmDeleteChunksByUIDs.mock
}

// Set uses given function f to mock the RepositoryI.DeleteChunksByUIDs method
func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) Set(f func(ctx context.Context, chunkUIDs []uuid.UUID) (err error)) *RepositoryIMock {
	if mmDeleteChunksByUIDs.defaultExpectation != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteChunksByUIDs method")
	}

	if len(mmDeleteChunksByUIDs.expectations) > 0 {
		mmDeleteChunksByUIDs.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteChunksByUIDs method")
	}

	mmDeleteChunksByUIDs.mock.funcDeleteChunksByUIDs = f
	return mmDeleteChunksByUIDs.mock
}

// When sets expectation for the RepositoryI.DeleteChunksByUIDs which will trigger the result defined by the following
// Then helper
func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) When(ctx context.Context, chunkUIDs []uuid.UUID) *RepositoryIMockDeleteChunksByUIDsExpectation {
	if mmDeleteChunksByUIDs.mock.funcDeleteChunksByUIDs != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteChunksByUIDs mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteChunksByUIDsExpectation{
		mock:   mmDeleteChunksByUIDs.mock,
		params: &RepositoryIMockDeleteChunksByUIDsParams{ctx, chunkUIDs},
	}
	mmDeleteChunksByUIDs.expectations = append(mmDeleteChunksByUIDs.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteChunksByUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteChunksByUIDsExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteChunksByUIDsResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteChunksByUIDs should be invoked
func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) Times(n uint64) *mRepositoryIMockDeleteChunksByUIDs {
	if n == 0 {
		mmDeleteChunksByUIDs.mock.t.Fatalf("Times of RepositoryIMock.DeleteChunksByUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteChunksByUIDs.expectedInvocations, n)
	return mmDeleteChunksByUIDs
}

func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) invocationsDone() bool {
	if len(mmDeleteChunksByUIDs.expectations) == 0 && mmDeleteChunksByUIDs.defaultExpectation == nil && mmDeleteChunksByUIDs.mock.funcDeleteChunksByUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteChunksByUIDs.mock.afterDeleteChunksByUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteChunksByUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteChunksByUIDs implements repository.RepositoryI
func (mmDeleteChunksByUIDs *RepositoryIMock) DeleteChunksByUIDs(ctx context.Context, chunkUIDs []uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteChunksByUIDs.beforeDeleteChunksByUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChunksByUIDs.afterDeleteChunksByUIDsCounter, 1)

	if mmDeleteChunksByUIDs.inspectFuncDeleteChunksByUIDs != nil {
		mmDeleteChunksByUIDs.inspectFuncDeleteChunksByUIDs(ctx, chunkUIDs)
	}

	mm_params := RepositoryIMockDeleteChunksByUIDsParams{ctx, chunkUIDs}

	// Record call args
	mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.mutex.Lock()
	mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.callArgs = append(mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.callArgs, &mm_params)
	mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.mutex.Unlock()

	for _, e := range mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteChunksByUIDsParams{ctx, chunkUIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteChunksByUIDs.t.Errorf("RepositoryIMock.DeleteChunksByUIDs got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chunkUIDs != nil && !minimock.Equal(*mm_want_ptrs.chunkUIDs, mm_got.chunkUIDs) {
				mmDeleteChunksByUIDs.t.Errorf("RepositoryIMock.DeleteChunksByUIDs got unexpected parameter chunkUIDs, want: %#v, got: %#v%s\n", *mm_want_ptrs.chunkUIDs, mm_got.chunkUIDs, minimock.Diff(*mm_want_ptrs.chunkUIDs, mm_got.chunkUIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChunksByUIDs.t.Errorf("RepositoryIMock.DeleteChunksByUIDs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChunksByUIDs.t.Fatal("No results are set for the RepositoryIMock.DeleteChunksByUIDs")
		}
		return (*mm_results).err
	}
	if mmDeleteChunksByUIDs.funcDeleteChunksByUIDs != nil {
		return mmDeleteChunksByUIDs.funcDeleteChunksByUIDs(ctx, chunkUIDs)
	}
	mmDeleteChunksByUIDs.t.Fatalf("Unexpected call to RepositoryIMock.DeleteChunksByUIDs. %v %v", ctx, chunkUIDs)
	return
}

// DeleteChunksByUIDsAfterCounter returns a count of finished RepositoryIMock.DeleteChunksByUIDs invocations
func (mmDeleteChunksByUIDs *RepositoryIMock) DeleteChunksByUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChunksByUIDs.afterDeleteChunksByUIDsCounter)
}

// DeleteChunksByUIDsBeforeCounter returns a count of RepositoryIMock.DeleteChunksByUIDs invocations
func (mmDeleteChunksByUIDs *RepositoryIMock) DeleteChunksByUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChunksByUIDs.beforeDeleteChunksByUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteChunksByUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) Calls() []*RepositoryIMockDeleteChunksByUIDsParams {
	mmDeleteChunksByUIDs.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteChunksByUIDsParams, len(mmDeleteChunksByUIDs.callArgs))
	copy(argCopy, mmDeleteChunksByUIDs.callArgs)

	mmDeleteChunksByUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChunksByUIDsDone returns true if the count of the DeleteChunksByUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteChunksByUIDsDone() bool {
	for _, e := range m.DeleteChunksByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteChunksByUIDsMock.invocationsDone()
}

// MinimockDeleteChunksByUIDsInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteChunksByUIDsInspect() {
	for _, e := range m.DeleteChunksByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteChunksByUIDs with params: %#v", *e.params)
		}
	}

	afterDeleteChunksByUIDsCounter := mm_atomic.LoadUint64(&m.afterDeleteChunksByUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChunksByUIDsMock.defaultExpectation != nil && afterDeleteChunksByUIDsCounter < 1 {
		if m.DeleteChunksByUIDsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteChunksByUIDs")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteChunksByUIDs with params: %#v", *m.DeleteChunksByUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChunksByUIDs != nil && afterDeleteChunksByUIDsCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteChunksByUIDs")
	}

	if !m.DeleteChunksByUIDsMock.invocationsDone() && afterDeleteChunksByUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteChunksByUIDs but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteChunksByUIDsMock.expectedInvocations), afterDeleteChunksByUIDsCounter)
	}
}

type mRepositoryIMockDeleteConvertedFile struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteConvertedFileExpectation
	expectations       []*RepositoryIMockDeleteConvertedFileExpectation

	callArgs []*RepositoryIMockDeleteConvertedFileParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteConvertedFileExpectation specifies expectation struct of the RepositoryI.DeleteConvertedFile
type RepositoryIMockDeleteConvertedFileExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteConvertedFileParams
	paramPtrs *RepositoryIMockDeleteConvertedFileParamPtrs
	results   *RepositoryIMockDeleteConvertedFileResults
	Counter   uint64
}

// RepositoryIMockDeleteConvertedFileParams contains parameters of the RepositoryI.DeleteConvertedFile
type RepositoryIMockDeleteConvertedFileParams struct {
	ctx context.Context
	uid uuid.UUID
}

// RepositoryIMockDeleteConvertedFileParamPtrs contains pointers to parameters of the RepositoryI.DeleteConvertedFile
type RepositoryIMockDeleteConvertedFileParamPtrs struct {
	ctx *context.Context
	uid *uuid.UUID
}

// RepositoryIMockDeleteConvertedFileResults contains results of the RepositoryI.DeleteConvertedFile
type RepositoryIMockDeleteConvertedFileResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteConvertedFile
func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) Expect(ctx context.Context, uid uuid.UUID) *mRepositoryIMockDeleteConvertedFile {
	if mmDeleteConvertedFile.mock.funcDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryIMock.DeleteConvertedFile mock is already set by Set")
	}

	if mmDeleteConvertedFile.defaultExpectation == nil {
		mmDeleteConvertedFile.defaultExpectation = &RepositoryIMockDeleteConvertedFileExpectation{}
	}

	if mmDeleteConvertedFile.defaultExpectation.paramPtrs != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryIMock.DeleteConvertedFile mock is already set by ExpectParams functions")
	}

	mmDeleteConvertedFile.defaultExpectation.params = &RepositoryIMockDeleteConvertedFileParams{ctx, uid}
	for _, e := range mmDeleteConvertedFile.expectations {
		if minimock.Equal(e.params, mmDeleteConvertedFile.defaultExpectation.params) {
			mmDeleteConvertedFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteConvertedFile.defaultExpectation.params)
		}
	}

	return mmDeleteConvertedFile
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteConvertedFile
func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteConvertedFile {
	if mmDeleteConvertedFile.mock.funcDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryIMock.DeleteConvertedFile mock is already set by Set")
	}

	if mmDeleteConvertedFile.defaultExpectation == nil {
		mmDeleteConvertedFile.defaultExpectation = &RepositoryIMockDeleteConvertedFileExpectation{}
	}

	if mmDeleteConvertedFile.defaultExpectation.params != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryIMock.DeleteConvertedFile mock is already set by Expect")
	}

	if mmDeleteConvertedFile.defaultExpectation.paramPtrs == nil {
		mmDeleteConvertedFile.defaultExpectation.paramPtrs = &RepositoryIMockDeleteConvertedFileParamPtrs{}
	}
	mmDeleteConvertedFile.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteConvertedFile
}

// ExpectUidParam2 sets up expected param uid for RepositoryI.DeleteConvertedFile
func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) ExpectUidParam2(uid uuid.UUID) *mRepositoryIMockDeleteConvertedFile {
	if mmDeleteConvertedFile.mock.funcDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryIMock.DeleteConvertedFile mock is already set by Set")
	}

	if mmDeleteConvertedFile.defaultExpectation == nil {
		mmDeleteConvertedFile.defaultExpectation = &RepositoryIMockDeleteConvertedFileExpectation{}
	}

	if mmDeleteConvertedFile.defaultExpectation.params != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryIMock.DeleteConvertedFile mock is already set by Expect")
	}

	if mmDeleteConvertedFile.defaultExpectation.paramPtrs == nil {
		mmDeleteConvertedFile.defaultExpectation.paramPtrs = &RepositoryIMockDeleteConvertedFileParamPtrs{}
	}
	mmDeleteConvertedFile.defaultExpectation.paramPtrs.uid = &uid

	return mmDeleteConvertedFile
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteConvertedFile
func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) Inspect(f func(ctx context.Context, uid uuid.UUID)) *mRepositoryIMockDeleteConvertedFile {
	if mmDeleteConvertedFile.mock.inspectFuncDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteConvertedFile")
	}

	mmDeleteConvertedFile.mock.inspectFuncDeleteConvertedFile = f

	return mmDeleteConvertedFile
}

// Return sets up results that will be returned by RepositoryI.DeleteConvertedFile
func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) Return(err error) *RepositoryIMock {
	if mmDeleteConvertedFile.mock.funcDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryIMock.DeleteConvertedFile mock is already set by Set")
	}

	if mmDeleteConvertedFile.defaultExpectation == nil {
		mmDeleteConvertedFile.defaultExpectation = &RepositoryIMockDeleteConvertedFileExpectation{mock: mmDeleteConvertedFile.mock}
	}
	mmDeleteConvertedFile.defaultExpectation.results = &RepositoryIMockDeleteConvertedFileResults{err}
	return mmDeleteConvertedFile.mock
}

// Set uses given function f to mock the RepositoryI.DeleteConvertedFile method
func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) Set(f func(ctx context.Context, uid uuid.UUID) (err error)) *RepositoryIMock {
	if mmDeleteConvertedFile.defaultExpectation != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteConvertedFile method")
	}

	if len(mmDeleteConvertedFile.expectations) > 0 {
		mmDeleteConvertedFile.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteConvertedFile method")
	}

	mmDeleteConvertedFile.mock.funcDeleteConvertedFile = f
	return mmDeleteConvertedFile.mock
}

// When sets expectation for the RepositoryI.DeleteConvertedFile which will trigger the result defined by the following
// Then helper
func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) When(ctx context.Context, uid uuid.UUID) *RepositoryIMockDeleteConvertedFileExpectation {
	if mmDeleteConvertedFile.mock.funcDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryIMock.DeleteConvertedFile mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteConvertedFileExpectation{
		mock:   mmDeleteConvertedFile.mock,
		params: &RepositoryIMockDeleteConvertedFileParams{ctx, uid},
	}
	mmDeleteConvertedFile.expectations = append(mmDeleteConvertedFile.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteConvertedFile return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteConvertedFileExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteConvertedFileResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteConvertedFile should be invoked
func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) Times(n uint64) *mRepositoryIMockDeleteConvertedFile {
	if n == 0 {
		mmDeleteConvertedFile.mock.t.Fatalf("Times of RepositoryIMock.DeleteConvertedFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteConvertedFile.expectedInvocations, n)
	return mmDeleteConvertedFile
}

func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) invocationsDone() bool {
	if len(mmDeleteConvertedFile.expectations) == 0 && mmDeleteConvertedFile.defaultExpectation == nil && mmDeleteConvertedFile.mock.funcDeleteConvertedFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteConvertedFile.mock.afterDeleteConvertedFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteConvertedFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteConvertedFile implements repository.RepositoryI
func (mmDeleteConvertedFile *RepositoryIMock) DeleteConvertedFile(ctx context.Context, uid uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteConvertedFile.beforeDeleteConvertedFileCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteConvertedFile.afterDeleteConvertedFileCounter, 1)

	if mmDeleteConvertedFile.inspectFuncDeleteConvertedFile != nil {
		mmDeleteConvertedFile.inspectFuncDeleteConvertedFile(ctx, uid)
	}

	mm_params := RepositoryIMockDeleteConvertedFileParams{ctx, uid}

	// Record call args
	mmDeleteConvertedFile.DeleteConvertedFileMock.mutex.Lock()
	mmDeleteConvertedFile.DeleteConvertedFileMock.callArgs = append(mmDeleteConvertedFile.DeleteConvertedFileMock.callArgs, &mm_params)
	mmDeleteConvertedFile.DeleteConvertedFileMock.mutex.Unlock()

	for _, e := range mmDeleteConvertedFile.DeleteConvertedFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteConvertedFileParams{ctx, uid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteConvertedFile.t.Errorf("RepositoryIMock.DeleteConvertedFile got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmDeleteConvertedFile.t.Errorf("RepositoryIMock.DeleteConvertedFile got unexpected parameter uid, want: %#v, got: %#v%s\n", *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteConvertedFile.t.Errorf("RepositoryIMock.DeleteConvertedFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteConvertedFile.t.Fatal("No results are set for the RepositoryIMock.DeleteConvertedFile")
		}
		return (*mm_results).err
	}
	if mmDeleteConvertedFile.funcDeleteConvertedFile != nil {
		return mmDeleteConvertedFile.funcDeleteConvertedFile(ctx, uid)
	}
	mmDeleteConvertedFile.t.Fatalf("Unexpected call to RepositoryIMock.DeleteConvertedFile. %v %v", ctx, uid)
	return
}

// DeleteConvertedFileAfterCounter returns a count of finished RepositoryIMock.DeleteConvertedFile invocations
func (mmDeleteConvertedFile *RepositoryIMock) DeleteConvertedFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteConvertedFile.afterDeleteConvertedFileCounter)
}

// DeleteConvertedFileBeforeCounter returns a count of RepositoryIMock.DeleteConvertedFile invocations
func (mmDeleteConvertedFile *RepositoryIMock) DeleteConvertedFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteConvertedFile.beforeDeleteConvertedFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteConvertedFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) Calls() []*RepositoryIMockDeleteConvertedFileParams {
	mmDeleteConvertedFile.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteConvertedFileParams, len(mmDeleteConvertedFile.callArgs))
	copy(argCopy, mmDeleteConvertedFile.callArgs)

	mmDeleteConvertedFile.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteConvertedFileDone returns true if the count of the DeleteConvertedFile invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteConvertedFileDone() bool {
	for _, e := range m.DeleteConvertedFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteConvertedFileMock.invocationsDone()
}

// MinimockDeleteConvertedFileInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteConvertedFileInspect() {
	for _, e := range m.DeleteConvertedFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteConvertedFile with params: %#v", *e.params)
		}
	}

	afterDeleteConvertedFileCounter := mm_atomic.LoadUint64(&m.afterDeleteConvertedFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteConvertedFileMock.defaultExpectation != nil && afterDeleteConvertedFileCounter < 1 {
		if m.DeleteConvertedFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteConvertedFile")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteConvertedFile with params: %#v", *m.DeleteConvertedFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteConvertedFile != nil && afterDeleteConvertedFileCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteConvertedFile")
	}

	if !m.DeleteConvertedFileMock.invocationsDone() && afterDeleteConvertedFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteConvertedFile but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteConvertedFileMock.expectedInvocations), afterDeleteConvertedFileCounter)
	}
}

type mRepositoryIMockDeleteEmbeddingsBySource struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteEmbeddingsBySourceExpectation
	expectations       []*RepositoryIMockDeleteEmbeddingsBySourceExpectation

	callArgs []*RepositoryIMockDeleteEmbeddingsBySourceParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteEmbeddingsBySourceExpectation specifies expectation struct of the RepositoryI.DeleteEmbeddingsBySource
type RepositoryIMockDeleteEmbeddingsBySourceExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteEmbeddingsBySourceParams
	paramPtrs *RepositoryIMockDeleteEmbeddingsBySourceParamPtrs
	results   *RepositoryIMockDeleteEmbeddingsBySourceResults
	Counter   uint64
}

// RepositoryIMockDeleteEmbeddingsBySourceParams contains parameters of the RepositoryI.DeleteEmbeddingsBySource
type RepositoryIMockDeleteEmbeddingsBySourceParams struct {
	ctx         context.Context
	sourceTable string
	sourceUID   uuid.UUID
}

// RepositoryIMockDeleteEmbeddingsBySourceParamPtrs contains pointers to parameters of the RepositoryI.DeleteEmbeddingsBySource
type RepositoryIMockDeleteEmbeddingsBySourceParamPtrs struct {
	ctx         *context.Context
	sourceTable *string
	sourceUID   *uuid.UUID
}

// RepositoryIMockDeleteEmbeddingsBySourceResults contains results of the RepositoryI.DeleteEmbeddingsBySource
type RepositoryIMockDeleteEmbeddingsBySourceResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteEmbeddingsBySource
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) Expect(ctx context.Context, sourceTable string, sourceUID uuid.UUID) *mRepositoryIMockDeleteEmbeddingsBySource {
	if mmDeleteEmbeddingsBySource.mock.funcDeleteEmbeddingsBySource != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by Set")
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation == nil {
		mmDeleteEmbeddingsBySource.defaultExpectation = &RepositoryIMockDeleteEmbeddingsBySourceExpectation{}
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by ExpectParams functions")
	}

	mmDeleteEmbeddingsBySource.defaultExpectation.params = &RepositoryIMockDeleteEmbeddingsBySourceParams{ctx, sourceTable, sourceUID}
	for _, e := range mmDeleteEmbeddingsBySource.expectations {
		if minimock.Equal(e.params, mmDeleteEmbeddingsBySource.defaultExpectation.params) {
			mmDeleteEmbeddingsBySource.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteEmbeddingsBySource.defaultExpectation.params)
		}
	}

	return mmDeleteEmbeddingsBySource
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteEmbeddingsBySource
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteEmbeddingsBySource {
	if mmDeleteEmbeddingsBySource.mock.funcDeleteEmbeddingsBySource != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by Set")
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation == nil {
		mmDeleteEmbeddingsBySource.defaultExpectation = &RepositoryIMockDeleteEmbeddingsBySourceExpectation{}
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation.params != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by Expect")
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs == nil {
		mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs = &RepositoryIMockDeleteEmbeddingsBySourceParamPtrs{}
	}
	mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteEmbeddingsBySource
}

// ExpectSourceTableParam2 sets up expected param sourceTable for RepositoryI.DeleteEmbeddingsBySource
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) ExpectSourceTableParam2(sourceTable string) *mRepositoryIMockDeleteEmbeddingsBySource {
	if mmDeleteEmbeddingsBySource.mock.funcDeleteEmbeddingsBySource != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by Set")
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation == nil {
		mmDeleteEmbeddingsBySource.defaultExpectation = &RepositoryIMockDeleteEmbeddingsBySourceExpectation{}
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation.params != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by Expect")
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs == nil {
		mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs = &RepositoryIMockDeleteEmbeddingsBySourceParamPtrs{}
	}
	mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs.sourceTable = &sourceTable

	return mmDeleteEmbeddingsBySource
}

// ExpectSourceUIDParam3 sets up expected param sourceUID for RepositoryI.DeleteEmbeddingsBySource
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) ExpectSourceUIDParam3(sourceUID uuid.UUID) *mRepositoryIMockDeleteEmbeddingsBySource {
	if mmDeleteEmbeddingsBySource.mock.funcDeleteEmbeddingsBySource != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by Set")
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation == nil {
		mmDeleteEmbeddingsBySource.defaultExpectation = &RepositoryIMockDeleteEmbeddingsBySourceExpectation{}
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation.params != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by Expect")
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs == nil {
		mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs = &RepositoryIMockDeleteEmbeddingsBySourceParamPtrs{}
	}
	mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs.sourceUID = &sourceUID

	return mmDeleteEmbeddingsBySource
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteEmbeddingsBySource
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) Inspect(f func(ctx context.Context, sourceTable string, sourceUID uuid.UUID)) *mRepositoryIMockDeleteEmbeddingsBySource {
	if mmDeleteEmbeddingsBySource.mock.inspectFuncDeleteEmbeddingsBySource != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteEmbeddingsBySource")
	}

	mmDeleteEmbeddingsBySource.mock.inspectFuncDeleteEmbeddingsBySource = f

	return mmDeleteEmbeddingsBySource
}

// Return sets up results that will be returned by RepositoryI.DeleteEmbeddingsBySource
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) Return(err error) *RepositoryIMock {
	if mmDeleteEmbeddingsBySource.mock.funcDeleteEmbeddingsBySource != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by Set")
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation == nil {
		mmDeleteEmbeddingsBySource.defaultExpectation = &RepositoryIMockDeleteEmbeddingsBySourceExpectation{mock: mmDeleteEmbeddingsBySource.mock}
	}
	mmDeleteEmbeddingsBySource.defaultExpectation.results = &RepositoryIMockDeleteEmbeddingsBySourceResults{err}
	return mmDeleteEmbeddingsBySource.mock
}

// Set uses given function f to mock the RepositoryI.DeleteEmbeddingsBySource method
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) Set(f func(ctx context.Context, sourceTable string, sourceUID uuid.UUID) (err error)) *RepositoryIMock {
	if mmDeleteEmbeddingsBySource.defaultExpectation != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteEmbeddingsBySource method")
	}

	if len(mmDeleteEmbeddingsBySource.expectations) > 0 {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteEmbeddingsBySource method")
	}

	mmDeleteEmbeddingsBySource.mock.funcDeleteEmbeddingsBySource = f
	return mmDeleteEmbeddingsBySource.mock
}

// When sets expectation for the RepositoryI.DeleteEmbeddingsBySource which will trigger the result defined by the following
// Then helper
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) When(ctx context.Context, sourceTable string, sourceUID uuid.UUID) *RepositoryIMockDeleteEmbeddingsBySourceExpectation {
	if mmDeleteEmbeddingsBySource.mock.funcDeleteEmbeddingsBySource != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteEmbeddingsBySourceExpectation{
		mock:   mmDeleteEmbeddingsBySource.mock,
		params: &RepositoryIMockDeleteEmbeddingsBySourceParams{ctx, sourceTable, sourceUID},
	}
	mmDeleteEmbeddingsBySource.expectations = append(mmDeleteEmbeddingsBySource.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteEmbeddingsBySource return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteEmbeddingsBySourceExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteEmbeddingsBySourceResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteEmbeddingsBySource should be invoked
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) Times(n uint64) *mRepositoryIMockDeleteEmbeddingsBySource {
	if n == 0 {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("Times of RepositoryIMock.DeleteEmbeddingsBySource mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteEmbeddingsBySource.expectedInvocations, n)
	return mmDeleteEmbeddingsBySource
}

func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) invocationsDone() bool {
	if len(mmDeleteEmbeddingsBySource.expectations) == 0 && mmDeleteEmbeddingsBySource.defaultExpectation == nil && mmDeleteEmbeddingsBySource.mock.funcDeleteEmbeddingsBySource == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteEmbeddingsBySource.mock.afterDeleteEmbeddingsBySourceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteEmbeddingsBySource.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteEmbeddingsBySource implements repository.RepositoryI
func (mmDeleteEmbeddingsBySource *RepositoryIMock) DeleteEmbeddingsBySource(ctx context.Context, sourceTable string, sourceUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteEmbeddingsBySource.beforeDeleteEmbeddingsBySourceCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteEmbeddingsBySource.afterDeleteEmbeddingsBySourceCounter, 1)

	if mmDeleteEmbeddingsBySource.inspectFuncDeleteEmbeddingsBySource != nil {
		mmDeleteEmbeddingsBySource.inspectFuncDeleteEmbeddingsBySource(ctx, sourceTable, sourceUID)
	}

	mm_params := RepositoryIMockDeleteEmbeddingsBySourceParams{ctx, sourceTable, sourceUID}

	// Record call args
	mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.mutex.Lock()
	mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.callArgs = append(mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.callArgs, &mm_params)
	mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.mutex.Unlock()

	for _, e := range mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteEmbeddingsBySourceParams{ctx, sourceTable, sourceUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteEmbeddingsBySource.t.Errorf("RepositoryIMock.DeleteEmbeddingsBySource got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sourceTable != nil && !minimock.Equal(*mm_want_ptrs.sourceTable, mm_got.sourceTable) {
				mmDeleteEmbeddingsBySource.t.Errorf("RepositoryIMock.DeleteEmbeddingsBySource got unexpected parameter sourceTable, want: %#v, got: %#v%s\n", *mm_want_ptrs.sourceTable, mm_got.sourceTable, minimock.Diff(*mm_want_ptrs.sourceTable, mm_got.sourceTable))
			}

			if mm_want_ptrs.sourceUID != nil && !minimock.Equal(*mm_want_ptrs.sourceUID, mm_got.sourceUID) {
				mmDeleteEmbeddingsBySource.t.Errorf("RepositoryIMock.DeleteEmbeddingsBySource got unexpected parameter sourceUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.sourceUID, mm_got.sourceUID, minimock.Diff(*mm_want_ptrs.sourceUID, mm_got.sourceUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteEmbeddingsBySource.t.Errorf("RepositoryIMock.DeleteEmbeddingsBySource got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteEmbeddingsBySource.t.Fatal("No results are set for the RepositoryIMock.DeleteEmbeddingsBySource")
		}
		return (*mm_results).err
	}
	if mmDeleteEmbeddingsBySource.funcDeleteEmbeddingsBySource != nil {
		return mmDeleteEmbeddingsBySource.funcDeleteEmbeddingsBySource(ctx, sourceTable, sourceUID)
	}
	mmDeleteEmbeddingsBySource.t.Fatalf("Unexpected call to RepositoryIMock.DeleteEmbeddingsBySource. %v %v %v", ctx, sourceTable, sourceUID)
	return
}

// DeleteEmbeddingsBySourceAfterCounter returns a count of finished RepositoryIMock.DeleteEmbeddingsBySource invocations
func (mmDeleteEmbeddingsBySource *RepositoryIMock) DeleteEmbeddingsBySourceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEmbeddingsBySource.afterDeleteEmbeddingsBySourceCounter)
}

// DeleteEmbeddingsBySourceBeforeCounter returns a count of RepositoryIMock.DeleteEmbeddingsBySource invocations
func (mmDeleteEmbeddingsBySource *RepositoryIMock) DeleteEmbeddingsBySourceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEmbeddingsBySource.beforeDeleteEmbeddingsBySourceCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteEmbeddingsBySource.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) Calls() []*RepositoryIMockDeleteEmbeddingsBySourceParams {
	mmDeleteEmbeddingsBySource.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteEmbeddingsBySourceParams, len(mmDeleteEmbeddingsBySource.callArgs))
	copy(argCopy, mmDeleteEmbeddingsBySource.callArgs)

	mmDeleteEmbeddingsBySource.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteEmbeddingsBySourceDone returns true if the count of the DeleteEmbeddingsBySource invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteEmbeddingsBySourceDone() bool {
	for _, e := range m.DeleteEmbeddingsBySourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteEmbeddingsBySourceMock.invocationsDone()
}

// MinimockDeleteEmbeddingsBySourceInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteEmbeddingsBySourceInspect() {
	for _, e := range m.DeleteEmbeddingsBySourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteEmbeddingsBySource with params: %#v", *e.params)
		}
	}

	afterDeleteEmbeddingsBySourceCounter := mm_atomic.LoadUint64(&m.afterDeleteEmbeddingsBySourceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteEmbeddingsBySourceMock.defaultExpectation != nil && afterDeleteEmbeddingsBySourceCounter < 1 {
		if m.DeleteEmbeddingsBySourceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteEmbeddingsBySource")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteEmbeddingsBySource with params: %#v", *m.DeleteEmbeddingsBySourceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteEmbeddingsBySource != nil && afterDeleteEmbeddingsBySourceCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteEmbeddingsBySource")
	}

	if !m.DeleteEmbeddingsBySourceMock.invocationsDone() && afterDeleteEmbeddingsBySourceCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteEmbeddingsBySource but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteEmbeddingsBySourceMock.expectedInvocations), afterDeleteEmbeddingsBySourceCounter)
	}
}

type mRepositoryIMockDeleteEmbeddingsByUIDs struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteEmbeddingsByUIDsExpectation
	expectations       []*RepositoryIMockDeleteEmbeddingsByUIDsExpectation

	callArgs []*RepositoryIMockDeleteEmbeddingsByUIDsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteEmbeddingsByUIDsExpectation specifies expectation struct of the RepositoryI.DeleteEmbeddingsByUIDs
type RepositoryIMockDeleteEmbeddingsByUIDsExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteEmbeddingsByUIDsParams
	paramPtrs *RepositoryIMockDeleteEmbeddingsByUIDsParamPtrs
	results   *RepositoryIMockDeleteEmbeddingsByUIDsResults
	Counter   uint64
}

// RepositoryIMockDeleteEmbeddingsByUIDsParams contains parameters of the RepositoryI.DeleteEmbeddingsByUIDs
type RepositoryIMockDeleteEmbeddingsByUIDsParams struct {
	ctx     context.Context
	embUIDs []uuid.UUID
}

// RepositoryIMockDeleteEmbeddingsByUIDsParamPtrs contains pointers to parameters of the RepositoryI.DeleteEmbeddingsByUIDs
type RepositoryIMockDeleteEmbeddingsByUIDsParamPtrs struct {
	ctx     *context.Context
	embUIDs *[]uuid.UUID
}

// RepositoryIMockDeleteEmbeddingsByUIDsResults contains results of the RepositoryI.DeleteEmbeddingsByUIDs
type RepositoryIMockDeleteEmbeddingsByUIDsResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteEmbeddingsByUIDs
func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) Expect(ctx context.Context, embUIDs []uuid.UUID) *mRepositoryIMockDeleteEmbeddingsByUIDs {
	if mmDeleteEmbeddingsByUIDs.mock.funcDeleteEmbeddingsByUIDs != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsByUIDs mock is already set by Set")
	}

	if mmDeleteEmbeddingsByUIDs.defaultExpectation == nil {
		mmDeleteEmbeddingsByUIDs.defaultExpectation = &RepositoryIMockDeleteEmbeddingsByUIDsExpectation{}
	}

	if mmDeleteEmbeddingsByUIDs.defaultExpectation.paramPtrs != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsByUIDs mock is already set by ExpectParams functions")
	}

	mmDeleteEmbeddingsByUIDs.defaultExpectation.params = &RepositoryIMockDeleteEmbeddingsByUIDsParams{ctx, embUIDs}
	for _, e := range mmDeleteEmbeddingsByUIDs.expectations {
		if minimock.Equal(e.params, mmDeleteEmbeddingsByUIDs.defaultExpectation.params) {
			mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteEmbeddingsByUIDs.defaultExpectation.params)
		}
	}

	return mmDeleteEmbeddingsByUIDs
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteEmbeddingsByUIDs
func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteEmbeddingsByUIDs {
	if mmDeleteEmbeddingsByUIDs.mock.funcDeleteEmbeddingsByUIDs != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsByUIDs mock is already set by Set")
	}

	if mmDeleteEmbeddingsByUIDs.defaultExpectation == nil {
		mmDeleteEmbeddingsByUIDs.defaultExpectation = &RepositoryIMockDeleteEmbeddingsByUIDsExpectation{}
	}

	if mmDeleteEmbeddingsByUIDs.defaultExpectation.params != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsByUIDs mock is already set by Expect")
	}

	if mmDeleteEmbeddingsByUIDs.defaultExpectation.paramPtrs == nil {
		mmDeleteEmbeddingsByUIDs.defaultExpectation.paramPtrs = &RepositoryIMockDeleteEmbeddingsByUIDsParamPtrs{}
	}
	mmDeleteEmbeddingsByUIDs.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteEmbeddingsByUIDs
}

// ExpectEmbUIDsParam2 sets up expected param embUIDs for RepositoryI.DeleteEmbeddingsByUIDs
func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) ExpectEmbUIDsParam2(embUIDs []uuid.UUID) *mRepositoryIMockDeleteEmbeddingsByUIDs {
	if mmDeleteEmbeddingsByUIDs.mock.funcDeleteEmbeddingsByUIDs != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsByUIDs mock is already set by Set")
	}

	if mmDeleteEmbeddingsByUIDs.defaultExpectation == nil {
		mmDeleteEmbeddingsByUIDs.defaultExpectation = &RepositoryIMockDeleteEmbeddingsByUIDsExpectation{}
	}

	if mmDeleteEmbeddingsByUIDs.defaultExpectation.params != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsByUIDs mock is already set by Expect")
	}

	if mmDeleteEmbeddingsByUIDs.defaultExpectation.paramPtrs == nil {
		mmDeleteEmbeddingsByUIDs.defaultExpectation.paramPtrs = &RepositoryIMockDeleteEmbeddingsByUIDsParamPtrs{}
	}
	mmDeleteEmbeddingsByUIDs.defaultExpectation.paramPtrs.embUIDs = &embUIDs

	return mmDeleteEmbeddingsByUIDs
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteEmbeddingsByUIDs
func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) Inspect(f func(ctx context.Context, embUIDs []uuid.UUID)) *mRepositoryIMockDeleteEmbeddingsByUIDs {
	if mmDeleteEmbeddingsByUIDs.mock.inspectFuncDeleteEmbeddingsByUIDs != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteEmbeddingsByUIDs")
	}

	mmDeleteEmbeddingsByUIDs.mock.inspectFuncDeleteEmbeddingsByUIDs = f

	return mmDeleteEmbeddingsByUIDs
}

// Return sets up results that will be returned by RepositoryI.DeleteEmbeddingsByUIDs
func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) Return(err error) *RepositoryIMock {
	if mmDeleteEmbeddingsByUIDs.mock.funcDeleteEmbeddingsByUIDs != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsByUIDs mock is already set by Set")
	}

	if mmDeleteEmbeddingsByUIDs.defaultExpectation == nil {
		mmDeleteEmbeddingsByUIDs.defaultExpectation = &RepositoryIMockDeleteEmbeddingsByUIDsExpectation{mock: mmDeleteEmbeddingsByUIDs.mock}
	}
	mmDeleteEmbeddingsByUIDs.defaultExpectation.results = &RepositoryIMockDeleteEmbeddingsByUIDsResults{err}
	return mmDeleteEmbeddingsByUIDs.mock
}

// Set uses given function f to mock the RepositoryI.DeleteEmbeddingsByUIDs method
func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) Set(f func(ctx context.Context, embUIDs []uuid.UUID) (err error)) *RepositoryIMock {
	if mmDeleteEmbeddingsByUIDs.defaultExpectation != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteEmbeddingsByUIDs method")
	}

	if len(mmDeleteEmbeddingsByUIDs.expectations) > 0 {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteEmbeddingsByUIDs method")
	}

	mmDeleteEmbeddingsByUIDs.mock.funcDeleteEmbeddingsByUIDs = f
	return mmDeleteEmbeddingsByUIDs.mock
}

// When sets expectation for the RepositoryI.DeleteEmbeddingsByUIDs which will trigger the result defined by the following
// Then helper
func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) When(ctx context.Context, embUIDs []uuid.UUID) *RepositoryIMockDeleteEmbeddingsByUIDsExpectation {
	if mmDeleteEmbeddingsByUIDs.mock.funcDeleteEmbeddingsByUIDs != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsByUIDs mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteEmbeddingsByUIDsExpectation{
		mock:   mmDeleteEmbeddingsByUIDs.mock,
		params: &RepositoryIMockDeleteEmbeddingsByUIDsParams{ctx, embUIDs},
	}
	mmDeleteEmbeddingsByUIDs.expectations = append(mmDeleteEmbeddingsByUIDs.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteEmbeddingsByUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteEmbeddingsByUIDsExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteEmbeddingsByUIDsResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteEmbeddingsByUIDs should be invoked
func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) Times(n uint64) *mRepositoryIMockDeleteEmbeddingsByUIDs {
	if n == 0 {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("Times of RepositoryIMock.DeleteEmbeddingsByUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteEmbeddingsByUIDs.expectedInvocations, n)
	return mmDeleteEmbeddingsByUIDs
}

func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) invocationsDone() bool {
	if len(mmDeleteEmbeddingsByUIDs.expectations) == 0 && mmDeleteEmbeddingsByUIDs.defaultExpectation == nil && mmDeleteEmbeddingsByUIDs.mock.funcDeleteEmbeddingsByUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteEmbeddingsByUIDs.mock.afterDeleteEmbeddingsByUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteEmbeddingsByUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteEmbeddingsByUIDs implements repository.RepositoryI
func (mmDeleteEmbeddingsByUIDs *RepositoryIMock) DeleteEmbeddingsByUIDs(ctx context.Context, embUIDs []uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteEmbeddingsByUIDs.beforeDeleteEmbeddingsByUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteEmbeddingsByUIDs.afterDeleteEmbeddingsByUIDsCounter, 1)

	if mmDeleteEmbeddingsByUIDs.inspectFuncDeleteEmbeddingsByUIDs != nil {
		mmDeleteEmbeddingsByUIDs.inspectFuncDeleteEmbeddingsByUIDs(ctx, embUIDs)
	}

	mm_params := RepositoryIMockDeleteEmbeddingsByUIDsParams{ctx, embUIDs}

	// Record call args
	mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.mutex.Lock()
	mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.callArgs = append(mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.callArgs, &mm_params)
	mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.mutex.Unlock()

	for _, e := range mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteEmbeddingsByUIDsParams{ctx, embUIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteEmbeddingsByUIDs.t.Errorf("RepositoryIMock.DeleteEmbeddingsByUIDs got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.embUIDs != nil && !minimock.Equal(*mm_want_ptrs.embUIDs, mm_got.embUIDs) {
				mmDeleteEmbeddingsByUIDs.t.Errorf("RepositoryIMock.DeleteEmbeddingsByUIDs got unexpected parameter embUIDs, want: %#v, got: %#v%s\n", *mm_want_ptrs.embUIDs, mm_got.embUIDs, minimock.Diff(*mm_want_ptrs.embUIDs, mm_got.embUIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteEmbeddingsByUIDs.t.Errorf("RepositoryIMock.DeleteEmbeddingsByUIDs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteEmbeddingsByUIDs.t.Fatal("No results are set for the RepositoryIMock.DeleteEmbeddingsByUIDs")
		}
		return (*mm_results).err
	}
	if mmDeleteEmbeddingsByUIDs.funcDeleteEmbeddingsByUIDs != nil {
		return mmDeleteEmbeddingsByUIDs.funcDeleteEmbeddingsByUIDs(ctx, embUIDs)
	}
	mmDeleteEmbeddingsByUIDs.t.Fatalf("Unexpected call to RepositoryIMock.DeleteEmbeddingsByUIDs. %v %v", ctx, embUIDs)
	return
}

// DeleteEmbeddingsByUIDsAfterCounter returns a count of finished RepositoryIMock.DeleteEmbeddingsByUIDs invocations
func (mmDeleteEmbeddingsByUIDs *RepositoryIMock) DeleteEmbeddingsByUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEmbeddingsByUIDs.afterDeleteEmbeddingsByUIDsCounter)
}

// DeleteEmbeddingsByUIDsBeforeCounter returns a count of RepositoryIMock.DeleteEmbeddingsByUIDs invocations
func (mmDeleteEmbeddingsByUIDs *RepositoryIMock) DeleteEmbeddingsByUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEmbeddingsByUIDs.beforeDeleteEmbeddingsByUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteEmbeddingsByUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) Calls() []*RepositoryIMockDeleteEmbeddingsByUIDsParams {
	mmDeleteEmbeddingsByUIDs.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteEmbeddingsByUIDsParams, len(mmDeleteEmbeddingsByUIDs.callArgs))
	copy(argCopy, mmDeleteEmbeddingsByUIDs.callArgs)

	mmDeleteEmbeddingsByUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteEmbeddingsByUIDsDone returns true if the count of the DeleteEmbeddingsByUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteEmbeddingsByUIDsDone() bool {
	for _, e := range m.DeleteEmbeddingsByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteEmbeddingsByUIDsMock.invocationsDone()
}

// MinimockDeleteEmbeddingsByUIDsInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteEmbeddingsByUIDsInspect() {
	for _, e := range m.DeleteEmbeddingsByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteEmbeddingsByUIDs with params: %#v", *e.params)
		}
	}

	afterDeleteEmbeddingsByUIDsCounter := mm_atomic.LoadUint64(&m.afterDeleteEmbeddingsByUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteEmbeddingsByUIDsMock.defaultExpectation != nil && afterDeleteEmbeddingsByUIDsCounter < 1 {
		if m.DeleteEmbeddingsByUIDsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteEmbeddingsByUIDs")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteEmbeddingsByUIDs with params: %#v", *m.DeleteEmbeddingsByUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteEmbeddingsByUIDs != nil && afterDeleteEmbeddingsByUIDsCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteEmbeddingsByUIDs")
	}

	if !m.DeleteEmbeddingsByUIDsMock.invocationsDone() && afterDeleteEmbeddingsByUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteEmbeddingsByUIDs but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteEmbeddingsByUIDsMock.expectedInvocations), afterDeleteEmbeddingsByUIDsCounter)
	}
}

type mRepositoryIMockDeleteKnowledgeBase struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteKnowledgeBaseExpectation
	expectations       []*RepositoryIMockDeleteKnowledgeBaseExpectation

	callArgs []*RepositoryIMockDeleteKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteKnowledgeBaseExpectation specifies expectation struct of the RepositoryI.DeleteKnowledgeBase
type RepositoryIMockDeleteKnowledgeBaseExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteKnowledgeBaseParams
	paramPtrs *RepositoryIMockDeleteKnowledgeBaseParamPtrs
	results   *RepositoryIMockDeleteKnowledgeBaseResults
	Counter   uint64
}

// RepositoryIMockDeleteKnowledgeBaseParams contains parameters of the RepositoryI.DeleteKnowledgeBase
type RepositoryIMockDeleteKnowledgeBaseParams struct {
	ctx      context.Context
	ownerUID string
	kbID     string
}

// RepositoryIMockDeleteKnowledgeBaseParamPtrs contains pointers to parameters of the RepositoryI.DeleteKnowledgeBase
type RepositoryIMockDeleteKnowledgeBaseParamPtrs struct {
	ctx      *context.Context
	ownerUID *string
	kbID     *string
}

// RepositoryIMockDeleteKnowledgeBaseResults contains results of the RepositoryI.DeleteKnowledgeBase
type RepositoryIMockDeleteKnowledgeBaseResults struct {
	kp1 *mm_repository.KnowledgeBase
	err error
}

// Expect sets up expected params for RepositoryI.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) Expect(ctx context.Context, ownerUID string, kbID string) *mRepositoryIMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmDeleteKnowledgeBase.defaultExpectation.params = &RepositoryIMockDeleteKnowledgeBaseParams{ctx, ownerUID, kbID}
	for _, e := range mmDeleteKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmDeleteKnowledgeBase.defaultExpectation.params) {
			mmDeleteKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmDeleteKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.params != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Expect")
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockDeleteKnowledgeBaseParamPtrs{}
	}
	mmDeleteKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteKnowledgeBase
}

// ExpectOwnerUIDParam2 sets up expected param ownerUID for RepositoryI.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) ExpectOwnerUIDParam2(ownerUID string) *mRepositoryIMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.params != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Expect")
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockDeleteKnowledgeBaseParamPtrs{}
	}
	mmDeleteKnowledgeBase.defaultExpectation.paramPtrs.ownerUID = &ownerUID

	return mmDeleteKnowledgeBase
}

// ExpectKbIDParam3 sets up expected param kbID for RepositoryI.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) ExpectKbIDParam3(kbID string) *mRepositoryIMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.params != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Expect")
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockDeleteKnowledgeBaseParamPtrs{}
	}
	mmDeleteKnowledgeBase.defaultExpectation.paramPtrs.kbID = &kbID

	return mmDeleteKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) Inspect(f func(ctx context.Context, ownerUID string, kbID string)) *mRepositoryIMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.inspectFuncDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteKnowledgeBase")
	}

	mmDeleteKnowledgeBase.mock.inspectFuncDeleteKnowledgeBase = f

	return mmDeleteKnowledgeBase
}

// Return sets up results that will be returned by RepositoryI.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) Return(kp1 *mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseExpectation{mock: mmDeleteKnowledgeBase.mock}
	}
	mmDeleteKnowledgeBase.defaultExpectation.results = &RepositoryIMockDeleteKnowledgeBaseResults{kp1, err}
	return mmDeleteKnowledgeBase.mock
}

// Set uses given function f to mock the RepositoryI.DeleteKnowledgeBase method
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) Set(f func(ctx context.Context, ownerUID string, kbID string) (kp1 *mm_repository.KnowledgeBase, err error)) *RepositoryIMock {
	if mmDeleteKnowledgeBase.defaultExpectation != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteKnowledgeBase method")
	}

	if len(mmDeleteKnowledgeBase.expectations) > 0 {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteKnowledgeBase method")
	}

	mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase = f
	return mmDeleteKnowledgeBase.mock
}

// When sets expectation for the RepositoryI.DeleteKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) When(ctx context.Context, ownerUID string, kbID string) *RepositoryIMockDeleteKnowledgeBaseExpectation {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteKnowledgeBaseExpectation{
		mock:   mmDeleteKnowledgeBase.mock,
		params: &RepositoryIMockDeleteKnowledgeBaseParams{ctx, ownerUID, kbID},
	}
	mmDeleteKnowledgeBase.expectations = append(mmDeleteKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteKnowledgeBaseExpectation) Then(kp1 *mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteKnowledgeBaseResults{kp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteKnowledgeBase should be invoked
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) Times(n uint64) *mRepositoryIMockDeleteKnowledgeBase {
	if n == 0 {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Times of RepositoryIMock.DeleteKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteKnowledgeBase.expectedInvocations, n)
	return mmDeleteKnowledgeBase
}

func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) invocationsDone() bool {
	if len(mmDeleteKnowledgeBase.expectations) == 0 && mmDeleteKnowledgeBase.defaultExpectation == nil && mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.mock.afterDeleteKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteKnowledgeBase implements repository.RepositoryI
func (mmDeleteKnowledgeBase *RepositoryIMock) DeleteKnowledgeBase(ctx context.Context, ownerUID string, kbID string) (kp1 *mm_repository.KnowledgeBase, err error) {
	mm_atomic.AddUint64(&mmDeleteKnowledgeBase.beforeDeleteKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteKnowledgeBase.afterDeleteKnowledgeBaseCounter, 1)

	if mmDeleteKnowledgeBase.inspectFuncDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.inspectFuncDeleteKnowledgeBase(ctx, ownerUID, kbID)
	}

	mm_params := RepositoryIMockDeleteKnowledgeBaseParams{ctx, ownerUID, kbID}

	// Record call args
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.mutex.Lock()
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.callArgs = append(mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.callArgs, &mm_params)
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteKnowledgeBaseParams{ctx, ownerUID, kbID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteKnowledgeBase.t.Errorf("RepositoryIMock.DeleteKnowledgeBase got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmDeleteKnowledgeBase.t.Errorf("RepositoryIMock.DeleteKnowledgeBase got unexpected parameter ownerUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

			if mm_want_ptrs.kbID != nil && !minimock.Equal(*mm_want_ptrs.kbID, mm_got.kbID) {
				mmDeleteKnowledgeBase.t.Errorf("RepositoryIMock.DeleteKnowledgeBase got unexpected parameter kbID, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbID, mm_got.kbID, minimock.Diff(*mm_want_ptrs.kbID, mm_got.kbID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteKnowledgeBase.t.Errorf("RepositoryIMock.DeleteKnowledgeBase got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteKnowledgeBase.t.Fatal("No results are set for the RepositoryIMock.DeleteKnowledgeBase")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmDeleteKnowledgeBase.funcDeleteKnowledgeBase != nil {
		return mmDeleteKnowledgeBase.funcDeleteKnowledgeBase(ctx, ownerUID, kbID)
	}
	mmDeleteKnowledgeBase.t.Fatalf("Unexpected call to RepositoryIMock.DeleteKnowledgeBase. %v %v %v", ctx, ownerUID, kbID)
	return
}

// DeleteKnowledgeBaseAfterCounter returns a count of finished RepositoryIMock.DeleteKnowledgeBase invocations
func (mmDeleteKnowledgeBase *RepositoryIMock) DeleteKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.afterDeleteKnowledgeBaseCounter)
}

// DeleteKnowledgeBaseBeforeCounter returns a count of RepositoryIMock.DeleteKnowledgeBase invocations
func (mmDeleteKnowledgeBase *RepositoryIMock) DeleteKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.beforeDeleteKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) Calls() []*RepositoryIMockDeleteKnowledgeBaseParams {
	mmDeleteKnowledgeBase.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteKnowledgeBaseParams, len(mmDeleteKnowledgeBase.callArgs))
	copy(argCopy, mmDeleteKnowledgeBase.callArgs)

	mmDeleteKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteKnowledgeBaseDone returns true if the count of the DeleteKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteKnowledgeBaseDone() bool {
	for _, e := range m.DeleteKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteKnowledgeBaseMock.invocationsDone()
}

// MinimockDeleteKnowledgeBaseInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteKnowledgeBaseInspect() {
	for _, e := range m.DeleteKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteKnowledgeBase with params: %#v", *e.params)
		}
	}

	afterDeleteKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterDeleteKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteKnowledgeBaseMock.defaultExpectation != nil && afterDeleteKnowledgeBaseCounter < 1 {
		if m.DeleteKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteKnowledgeBase")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteKnowledgeBase with params: %#v", *m.DeleteKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteKnowledgeBase != nil && afterDeleteKnowledgeBaseCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteKnowledgeBase")
	}

	if !m.DeleteKnowledgeBaseMock.invocationsDone() && afterDeleteKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteKnowledgeBase but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteKnowledgeBaseMock.expectedInvocations), afterDeleteKnowledgeBaseCounter)
	}
}

type mRepositoryIMockDeleteKnowledgeBaseFile struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteKnowledgeBaseFileExpectation
	expectations       []*RepositoryIMockDeleteKnowledgeBaseFileExpectation

	callArgs []*RepositoryIMockDeleteKnowledgeBaseFileParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteKnowledgeBaseFileExpectation specifies expectation struct of the RepositoryI.DeleteKnowledgeBaseFile
type RepositoryIMockDeleteKnowledgeBaseFileExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteKnowledgeBaseFileParams
	paramPtrs *RepositoryIMockDeleteKnowledgeBaseFileParamPtrs
	results   *RepositoryIMockDeleteKnowledgeBaseFileResults
	Counter   uint64
}

// RepositoryIMockDeleteKnowledgeBaseFileParams contains parameters of the RepositoryI.DeleteKnowledgeBaseFile
type RepositoryIMockDeleteKnowledgeBaseFileParams struct {
	ctx     context.Context
	fileUID string
}

// RepositoryIMockDeleteKnowledgeBaseFileParamPtrs contains pointers to parameters of the RepositoryI.DeleteKnowledgeBaseFile
type RepositoryIMockDeleteKnowledgeBaseFileParamPtrs struct {
	ctx     *context.Context
	fileUID *string
}

// RepositoryIMockDeleteKnowledgeBaseFileResults contains results of the RepositoryI.DeleteKnowledgeBaseFile
type RepositoryIMockDeleteKnowledgeBaseFileResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteKnowledgeBaseFile
func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) Expect(ctx context.Context, fileUID string) *mRepositoryIMockDeleteKnowledgeBaseFile {
	if mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFile mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseFileExpectation{}
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFile mock is already set by ExpectParams functions")
	}

	mmDeleteKnowledgeBaseFile.defaultExpectation.params = &RepositoryIMockDeleteKnowledgeBaseFileParams{ctx, fileUID}
	for _, e := range mmDeleteKnowledgeBaseFile.expectations {
		if minimock.Equal(e.params, mmDeleteKnowledgeBaseFile.defaultExpectation.params) {
			mmDeleteKnowledgeBaseFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteKnowledgeBaseFile.defaultExpectation.params)
		}
	}

	return mmDeleteKnowledgeBaseFile
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteKnowledgeBaseFile
func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteKnowledgeBaseFile {
	if mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFile mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseFileExpectation{}
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation.params != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFile mock is already set by Expect")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryIMockDeleteKnowledgeBaseFileParamPtrs{}
	}
	mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteKnowledgeBaseFile
}

// ExpectFileUIDParam2 sets up expected param fileUID for RepositoryI.DeleteKnowledgeBaseFile
func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) ExpectFileUIDParam2(fileUID string) *mRepositoryIMockDeleteKnowledgeBaseFile {
	if mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFile mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseFileExpectation{}
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation.params != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFile mock is already set by Expect")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryIMockDeleteKnowledgeBaseFileParamPtrs{}
	}
	mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs.fileUID = &fileUID

	return mmDeleteKnowledgeBaseFile
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteKnowledgeBaseFile
func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) Inspect(f func(ctx context.Context, fileUID string)) *mRepositoryIMockDeleteKnowledgeBaseFile {
	if mmDeleteKnowledgeBaseFile.mock.inspectFuncDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteKnowledgeBaseFile")
	}

	mmDeleteKnowledgeBaseFile.mock.inspectFuncDeleteKnowledgeBaseFile = f

	return mmDeleteKnowledgeBaseFile
}

// Return sets up results that will be returned by RepositoryI.DeleteKnowledgeBaseFile
func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) Return(err error) *RepositoryIMock {
	if mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFile mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseFileExpectation{mock: mmDeleteKnowledgeBaseFile.mock}
	}
	mmDeleteKnowledgeBaseFile.defaultExpectation.results = &RepositoryIMockDeleteKnowledgeBaseFileResults{err}
	return mmDeleteKnowledgeBaseFile.mock
}

// Set uses given function f to mock the RepositoryI.DeleteKnowledgeBaseFile method
func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) Set(f func(ctx context.Context, fileUID string) (err error)) *RepositoryIMock {
	if mmDeleteKnowledgeBaseFile.defaultExpectation != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteKnowledgeBaseFile method")
	}

	if len(mmDeleteKnowledgeBaseFile.expectations) > 0 {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteKnowledgeBaseFile method")
	}

	mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile = f
	return mmDeleteKnowledgeBaseFile.mock
}

// When sets expectation for the RepositoryI.DeleteKnowledgeBaseFile which will trigger the result defined by the following
// Then helper
func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) When(ctx context.Context, fileUID string) *RepositoryIMockDeleteKnowledgeBaseFileExpectation {
	if mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFile mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteKnowledgeBaseFileExpectation{
		mock:   mmDeleteKnowledgeBaseFile.mock,
		params: &RepositoryIMockDeleteKnowledgeBaseFileParams{ctx, fileUID},
	}
	mmDeleteKnowledgeBaseFile.expectations = append(mmDeleteKnowledgeBaseFile.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteKnowledgeBaseFile return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteKnowledgeBaseFileExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteKnowledgeBaseFileResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteKnowledgeBaseFile should be invoked
func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) Times(n uint64) *mRepositoryIMockDeleteKnowledgeBaseFile {
	if n == 0 {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("Times of RepositoryIMock.DeleteKnowledgeBaseFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteKnowledgeBaseFile.expectedInvocations, n)
	return mmDeleteKnowledgeBaseFile
}

func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) invocationsDone() bool {
	if len(mmDeleteKnowledgeBaseFile.expectations) == 0 && mmDeleteKnowledgeBaseFile.defaultExpectation == nil && mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFile.mock.afterDeleteKnowledgeBaseFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteKnowledgeBaseFile implements repository.RepositoryI
func (mmDeleteKnowledgeBaseFile *RepositoryIMock) DeleteKnowledgeBaseFile(ctx context.Context, fileUID string) (err error) {
	mm_atomic.AddUint64(&mmDeleteKnowledgeBaseFile.beforeDeleteKnowledgeBaseFileCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteKnowledgeBaseFile.afterDeleteKnowledgeBaseFileCounter, 1)

	if mmDeleteKnowledgeBaseFile.inspectFuncDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.inspectFuncDeleteKnowledgeBaseFile(ctx, fileUID)
	}

	mm_params := RepositoryIMockDeleteKnowledgeBaseFileParams{ctx, fileUID}

	// Record call args
	mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.mutex.Lock()
	mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.callArgs = append(mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.callArgs, &mm_params)
	mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.mutex.Unlock()

	for _, e := range mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteKnowledgeBaseFileParams{ctx, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteKnowledgeBaseFile.t.Errorf("RepositoryIMock.DeleteKnowledgeBaseFile got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmDeleteKnowledgeBaseFile.t.Errorf("RepositoryIMock.DeleteKnowledgeBaseFile got unexpected parameter fileUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteKnowledgeBaseFile.t.Errorf("RepositoryIMock.DeleteKnowledgeBaseFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteKnowledgeBaseFile.t.Fatal("No results are set for the RepositoryIMock.DeleteKnowledgeBaseFile")
		}
		return (*mm_results).err
	}
	if mmDeleteKnowledgeBaseFile.funcDeleteKnowledgeBaseFile != nil {
		return mmDeleteKnowledgeBaseFile.funcDeleteKnowledgeBaseFile(ctx, fileUID)
	}
	mmDeleteKnowledgeBaseFile.t.Fatalf("Unexpected call to RepositoryIMock.DeleteKnowledgeBaseFile. %v %v", ctx, fileUID)
	return
}

// DeleteKnowledgeBaseFileAfterCounter returns a count of finished RepositoryIMock.DeleteKnowledgeBaseFile invocations
func (mmDeleteKnowledgeBaseFile *RepositoryIMock) DeleteKnowledgeBaseFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFile.afterDeleteKnowledgeBaseFileCounter)
}

// DeleteKnowledgeBaseFileBeforeCounter returns a count of RepositoryIMock.DeleteKnowledgeBaseFile invocations
func (mmDeleteKnowledgeBaseFile *RepositoryIMock) DeleteKnowledgeBaseFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFile.beforeDeleteKnowledgeBaseFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteKnowledgeBaseFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) Calls() []*RepositoryIMockDeleteKnowledgeBaseFileParams {
	mmDeleteKnowledgeBaseFile.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteKnowledgeBaseFileParams, len(mmDeleteKnowledgeBaseFile.callArgs))
	copy(argCopy, mmDeleteKnowledgeBaseFile.callArgs)

	mmDeleteKnowledgeBaseFile.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteKnowledgeBaseFileDone returns true if the count of the DeleteKnowledgeBaseFile invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteKnowledgeBaseFileDone() bool {
	for _, e := range m.DeleteKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteKnowledgeBaseFileMock.invocationsDone()
}

// MinimockDeleteKnowledgeBaseFileInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteKnowledgeBaseFileInspect() {
	for _, e := range m.DeleteKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteKnowledgeBaseFile with params: %#v", *e.params)
		}
	}

	afterDeleteKnowledgeBaseFileCounter := mm_atomic.LoadUint64(&m.afterDeleteKnowledgeBaseFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteKnowledgeBaseFileMock.defaultExpectation != nil && afterDeleteKnowledgeBaseFileCounter < 1 {
		if m.DeleteKnowledgeBaseFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteKnowledgeBaseFile")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteKnowledgeBaseFile with params: %#v", *m.DeleteKnowledgeBaseFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteKnowledgeBaseFile != nil && afterDeleteKnowledgeBaseFileCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteKnowledgeBaseFile")
	}

	if !m.DeleteKnowledgeBaseFileMock.invocationsDone() && afterDeleteKnowledgeBaseFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteKnowledgeBaseFile but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteKnowledgeBaseFileMock.expectedInvocations), afterDeleteKnowledgeBaseFileCounter)
	}
}

type mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation
	expectations       []*RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation

	callArgs []*RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation specifies expectation struct of the RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage
type RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParams
	paramPtrs *RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParamPtrs
	results   *RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageResults
	Counter   uint64
}

// RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParams contains parameters of the RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage
type RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParams struct {
	ctx     context.Context
	fileUID uuid.UUID
}

// RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParamPtrs contains pointers to parameters of the RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage
type RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParamPtrs struct {
	ctx     *context.Context
	fileUID *uuid.UUID
}

// RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageResults contains results of the RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage
type RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage) Expect(ctx context.Context, fileUID uuid.UUID) *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage {
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation{}
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.paramPtrs != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by ExpectParams functions")
	}

	mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.params = &RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParams{ctx, fileUID}
	for _, e := range mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectations {
		if minimock.Equal(e.params, mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.params) {
			mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.params)
		}
	}

	return mmDeleteKnowledgeBaseFileAndDecreaseUsage
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage {
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation{}
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.params != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by Expect")
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.paramPtrs = &RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParamPtrs{}
	}
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteKnowledgeBaseFileAndDecreaseUsage
}

// ExpectFileUIDParam2 sets up expected param fileUID for RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage) ExpectFileUIDParam2(fileUID uuid.UUID) *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage {
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation{}
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.params != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by Expect")
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.paramPtrs = &RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParamPtrs{}
	}
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.paramPtrs.fileUID = &fileUID

	return mmDeleteKnowledgeBaseFileAndDecreaseUsage
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage) Inspect(f func(ctx context.Context, fileUID uuid.UUID)) *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage {
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.inspectFuncDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage")
	}

	mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.inspectFuncDeleteKnowledgeBaseFileAndDecreaseUsage = f

	return mmDeleteKnowledgeBaseFileAndDecreaseUsage
}

// Return sets up results that will be returned by RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage) Return(err error) *RepositoryIMock {
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation{mock: mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock}
	}
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.results = &RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageResults{err}
	return mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock
}

// Set uses given function f to mock the RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage method
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage) Set(f func(ctx context.Context, fileUID uuid.UUID) (err error)) *RepositoryIMock {
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage method")
	}

	if len(mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectations) > 0 {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage method")
	}

	mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsage = f
	return mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock
}

// When sets expectation for the RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage which will trigger the result defined by the following
// Then helper
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage) When(ctx context.Context, fileUID uuid.UUID) *RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation {
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation{
		mock:   mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock,
		params: &RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParams{ctx, fileUID},
	}
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectations = append(mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage should be invoked
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage) Times(n uint64) *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage {
	if n == 0 {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("Times of RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectedInvocations, n)
	return mmDeleteKnowledgeBaseFileAndDecreaseUsage
}

func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage) invocationsDone() bool {
	if len(mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectations) == 0 && mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation == nil && mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteKnowledgeBaseFileAndDecreaseUsage implements repository.RepositoryI
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *RepositoryIMock) DeleteKnowledgeBaseFileAndDecreaseUsage(ctx context.Context, fileUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.beforeDeleteKnowledgeBaseFileAndDecreaseUsageCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter, 1)

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.inspectFuncDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.inspectFuncDeleteKnowledgeBaseFileAndDecreaseUsage(ctx, fileUID)
	}

	mm_params := RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParams{ctx, fileUID}

	// Record call args
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.mutex.Lock()
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.callArgs = append(mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.callArgs, &mm_params)
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.mutex.Unlock()

	for _, e := range mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParams{ctx, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteKnowledgeBaseFileAndDecreaseUsage.t.Errorf("RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmDeleteKnowledgeBaseFileAndDecreaseUsage.t.Errorf("RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage got unexpected parameter fileUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteKnowledgeBaseFileAndDecreaseUsage.t.Errorf("RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteKnowledgeBaseFileAndDecreaseUsage.t.Fatal("No results are set for the RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage")
		}
		return (*mm_results).err
	}
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.funcDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		return mmDeleteKnowledgeBaseFileAndDecreaseUsage.funcDeleteKnowledgeBaseFileAndDecreaseUsage(ctx, fileUID)
	}
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.t.Fatalf("Unexpected call to RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage. %v %v", ctx, fileUID)
	return
}

// DeleteKnowledgeBaseFileAndDecreaseUsageAfterCounter returns a count of finished RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage invocations
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *RepositoryIMock) DeleteKnowledgeBaseFileAndDecreaseUsageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter)
}

// DeleteKnowledgeBaseFileAndDecreaseUsageBeforeCounter returns a count of RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage invocations
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *RepositoryIMock) DeleteKnowledgeBaseFileAndDecreaseUsageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.beforeDeleteKnowledgeBaseFileAndDecreaseUsageCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage) Calls() []*RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParams {
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParams, len(mmDeleteKnowledgeBaseFileAndDecreaseUsage.callArgs))
	copy(argCopy, mmDeleteKnowledgeBaseFileAndDecreaseUsage.callArgs)

	mmDeleteKnowledgeBaseFileAndDecreaseUsage.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteKnowledgeBaseFileAndDecreaseUsageDone returns true if the count of the DeleteKnowledgeBaseFileAndDecreaseUsage invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteKnowledgeBaseFileAndDecreaseUsageDone() bool {
	for _, e := range m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.invocationsDone()
}

// MinimockDeleteKnowledgeBaseFileAndDecreaseUsageInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteKnowledgeBaseFileAndDecreaseUsageInspect() {
	for _, e := range m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage with params: %#v", *e.params)
		}
	}

	afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter := mm_atomic.LoadUint64(&m.afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation != nil && afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter < 1 {
		if m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage with params: %#v", *m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteKnowledgeBaseFileAndDecreaseUsage != nil && afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage")
	}

	if !m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.invocationsDone() && afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.expectedInvocations), afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter)
	}
}

type mRepositoryIMockDeleteMessage struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteMessageExpectation
	expectations       []*RepositoryIMockDeleteMessageExpectation

	callArgs []*RepositoryIMockDeleteMessageParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteMessageExpectation specifies expectation struct of the RepositoryI.DeleteMessage
type RepositoryIMockDeleteMessageExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteMessageParams
	paramPtrs *RepositoryIMockDeleteMessageParamPtrs
	results   *RepositoryIMockDeleteMessageResults
	Counter   uint64
}

// RepositoryIMockDeleteMessageParams contains parameters of the RepositoryI.DeleteMessage
type RepositoryIMockDeleteMessageParams struct {
	ctx        context.Context
	messageUID uuid.UUID
}

// RepositoryIMockDeleteMessageParamPtrs contains pointers to parameters of the RepositoryI.DeleteMessage
type RepositoryIMockDeleteMessageParamPtrs struct {
	ctx        *context.Context
	messageUID *uuid.UUID
}

// RepositoryIMockDeleteMessageResults contains results of the RepositoryI.DeleteMessage
type RepositoryIMockDeleteMessageResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteMessage
func (mmDeleteMessage *mRepositoryIMockDeleteMessage) Expect(ctx context.Context, messageUID uuid.UUID) *mRepositoryIMockDeleteMessage {
	if mmDeleteMessage.mock.funcDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("RepositoryIMock.DeleteMessage mock is already set by Set")
	}

	if mmDeleteMessage.defaultExpectation == nil {
		mmDeleteMessage.defaultExpectation = &RepositoryIMockDeleteMessageExpectation{}
	}

	if mmDeleteMessage.defaultExpectation.paramPtrs != nil {
		mmDeleteMessage.mock.t.Fatalf("RepositoryIMock.DeleteMessage mock is already set by ExpectParams functions")
	}

	mmDeleteMessage.defaultExpectation.params = &RepositoryIMockDeleteMessageParams{ctx, messageUID}
	for _, e := range mmDeleteMessage.expectations {
		if minimock.Equal(e.params, mmDeleteMessage.defaultExpectation.params) {
			mmDeleteMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteMessage.defaultExpectation.params)
		}
	}

	return mmDeleteMessage
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteMessage
func (mmDeleteMessage *mRepositoryIMockDeleteMessage) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteMessage {
	if mmDeleteMessage.mock.funcDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("RepositoryIMock.DeleteMessage mock is already set by Set")
	}

	if mmDeleteMessage.defaultExpectation == nil {
		mmDeleteMessage.defaultExpectation = &RepositoryIMockDeleteMessageExpectation{}
	}

	if mmDeleteMessage.defaultExpectation.params != nil {
		mmDeleteMessage.mock.t.Fatalf("RepositoryIMock.DeleteMessage mock is already set by Expect")
	}

	if mmDeleteMessage.defaultExpectation.paramPtrs == nil {
		mmDeleteMessage.defaultExpectation.paramPtrs = &RepositoryIMockDeleteMessageParamPtrs{}
	}
	mmDeleteMessage.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteMessage
}

// ExpectMessageUIDParam2 sets up expected param messageUID for RepositoryI.DeleteMessage
func (mmDeleteMessage *mRepositoryIMockDeleteMessage) ExpectMessageUIDParam2(messageUID uuid.UUID) *mRepositoryIMockDeleteMessage {
	if mmDeleteMessage.mock.funcDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("RepositoryIMock.DeleteMessage mock is already set by Set")
	}

	if mmDeleteMessage.defaultExpectation == nil {
		mmDeleteMessage.defaultExpectation = &RepositoryIMockDeleteMessageExpectation{}
	}

	if mmDeleteMessage.defaultExpectation.params != nil {
		mmDeleteMessage.mock.t.Fatalf("RepositoryIMock.DeleteMessage mock is already set by Expect")
	}

	if mmDeleteMessage.defaultExpectation.paramPtrs == nil {
		mmDeleteMessage.defaultExpectation.paramPtrs = &RepositoryIMockDeleteMessageParamPtrs{}
	}
	mmDeleteMessage.defaultExpectation.paramPtrs.messageUID = &messageUID

	return mmDeleteMessage
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteMessage
func (mmDeleteMessage *mRepositoryIMockDeleteMessage) Inspect(f func(ctx context.Context, messageUID uuid.UUID)) *mRepositoryIMockDeleteMessage {
	if mmDeleteMessage.mock.inspectFuncDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteMessage")
	}

	mmDeleteMessage.mock.inspectFuncDeleteMessage = f

	return mmDeleteMessage
}

// Return sets up results that will be returned by RepositoryI.DeleteMessage
func (mmDeleteMessage *mRepositoryIMockDeleteMessage) Return(err error) *RepositoryIMock {
	if mmDeleteMessage.mock.funcDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("RepositoryIMock.DeleteMessage mock is already set by Set")
	}

	if mmDeleteMessage.defaultExpectation == nil {
		mmDeleteMessage.defaultExpectation = &RepositoryIMockDeleteMessageExpectation{mock: mmDeleteMessage.mock}
	}
	mmDeleteMessage.defaultExpectation.results = &RepositoryIMockDeleteMessageResults{err}
	return mmDeleteMessage.mock
}

// Set uses given function f to mock the RepositoryI.DeleteMessage method
func (mmDeleteMessage *mRepositoryIMockDeleteMessage) Set(f func(ctx context.Context, messageUID uuid.UUID) (err error)) *RepositoryIMock {
	if mmDeleteMessage.defaultExpectation != nil {
		mmDeleteMessage.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteMessage method")
	}

	if len(mmDeleteMessage.expectations) > 0 {
		mmDeleteMessage.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteMessage method")
	}

	mmDeleteMessage.mock.funcDeleteMessage = f
	return mmDeleteMessage.mock
}

// When sets expectation for the RepositoryI.DeleteMessage which will trigger the result defined by the following
// Then helper
func (mmDeleteMessage *mRepositoryIMockDeleteMessage) When(ctx context.Context, messageUID uuid.UUID) *RepositoryIMockDeleteMessageExpectation {
	if mmDeleteMessage.mock.funcDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("RepositoryIMock.DeleteMessage mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteMessageExpectation{
		mock:   mmDeleteMessage.mock,
		params: &RepositoryIMockDeleteMessageParams{ctx, messageUID},
	}
	mmDeleteMessage.expectations = append(mmDeleteMessage.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteMessage return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteMessageExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteMessageResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteMessage should be invoked
func (mmDeleteMessage *mRepositoryIMockDeleteMessage) Times(n uint64) *mRepositoryIMockDeleteMessage {
	if n == 0 {
		mmDeleteMessage.mock.t.Fatalf("Times of RepositoryIMock.DeleteMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteMessage.expectedInvocations, n)
	return mmDeleteMessage
}

func (mmDeleteMessage *mRepositoryIMockDeleteMessage) invocationsDone() bool {
	if len(mmDeleteMessage.expectations) == 0 && mmDeleteMessage.defaultExpectation == nil && mmDeleteMessage.mock.funcDeleteMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteMessage.mock.afterDeleteMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteMessage implements repository.RepositoryI
func (mmDeleteMessage *RepositoryIMock) DeleteMessage(ctx context.Context, messageUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteMessage.beforeDeleteMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteMessage.afterDeleteMessageCounter, 1)

	if mmDeleteMessage.inspectFuncDeleteMessage != nil {
		mmDeleteMessage.inspectFuncDeleteMessage(ctx, messageUID)
	}

	mm_params := RepositoryIMockDeleteMessageParams{ctx, messageUID}

	// Record call args
	mmDeleteMessage.DeleteMessageMock.mutex.Lock()
	mmDeleteMessage.DeleteMessageMock.callArgs = append(mmDeleteMessage.DeleteMessageMock.callArgs, &mm_params)
	mmDeleteMessage.DeleteMessageMock.mutex.Unlock()

	for _, e := range mmDeleteMessage.DeleteMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteMessage.DeleteMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteMessage.DeleteMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteMessage.DeleteMessageMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteMessage.DeleteMessageMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteMessageParams{ctx, messageUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteMessage.t.Errorf("RepositoryIMock.DeleteMessage got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.messageUID != nil && !minimock.Equal(*mm_want_ptrs.messageUID, mm_got.messageUID) {
				mmDeleteMessage.t.Errorf("RepositoryIMock.DeleteMessage got unexpected parameter messageUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.messageUID, mm_got.messageUID, minimock.Diff(*mm_want_ptrs.messageUID, mm_got.messageUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteMessage.t.Errorf("RepositoryIMock.DeleteMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteMessage.DeleteMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteMessage.t.Fatal("No results are set for the RepositoryIMock.DeleteMessage")
		}
		return (*mm_results).err
	}
	if mmDeleteMessage.funcDeleteMessage != nil {
		return mmDeleteMessage.funcDeleteMessage(ctx, messageUID)
	}
	mmDeleteMessage.t.Fatalf("Unexpected call to RepositoryIMock.DeleteMessage. %v %v", ctx, messageUID)
	return
}

// DeleteMessageAfterCounter returns a count of finished RepositoryIMock.DeleteMessage invocations
func (mmDeleteMessage *RepositoryIMock) DeleteMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteMessage.afterDeleteMessageCounter)
}

// DeleteMessageBeforeCounter returns a count of RepositoryIMock.DeleteMessage invocations
func (mmDeleteMessage *RepositoryIMock) DeleteMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteMessage.beforeDeleteMessageCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteMessage *mRepositoryIMockDeleteMessage) Calls() []*RepositoryIMockDeleteMessageParams {
	mmDeleteMessage.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteMessageParams, len(mmDeleteMessage.callArgs))
	copy(argCopy, mmDeleteMessage.callArgs)

	mmDeleteMessage.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteMessageDone returns true if the count of the DeleteMessage invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteMessageDone() bool {
	for _, e := range m.DeleteMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMessageMock.invocationsDone()
}

// MinimockDeleteMessageInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteMessageInspect() {
	for _, e := range m.DeleteMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteMessage with params: %#v", *e.params)
		}
	}

	afterDeleteMessageCounter := mm_atomic.LoadUint64(&m.afterDeleteMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMessageMock.defaultExpectation != nil && afterDeleteMessageCounter < 1 {
		if m.DeleteMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteMessage")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteMessage with params: %#v", *m.DeleteMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteMessage != nil && afterDeleteMessageCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteMessage")
	}

	if !m.DeleteMessageMock.invocationsDone() && afterDeleteMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteMessage but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMessageMock.expectedInvocations), afterDeleteMessageCounter)
	}
}

type mRepositoryIMockDeleteRepositoryTag struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteRepositoryTagExpectation
	expectations       []*RepositoryIMockDeleteRepositoryTagExpectation

	callArgs []*RepositoryIMockDeleteRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteRepositoryTagExpectation specifies expectation struct of the RepositoryI.DeleteRepositoryTag
type RepositoryIMockDeleteRepositoryTagExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteRepositoryTagParams
	paramPtrs *RepositoryIMockDeleteRepositoryTagParamPtrs
	results   *RepositoryIMockDeleteRepositoryTagResults
	Counter   uint64
}

// RepositoryIMockDeleteRepositoryTagParams contains parameters of the RepositoryI.DeleteRepositoryTag
type RepositoryIMockDeleteRepositoryTagParams struct {
	ctx context.Context
	s1  string
}

// RepositoryIMockDeleteRepositoryTagParamPtrs contains pointers to parameters of the RepositoryI.DeleteRepositoryTag
type RepositoryIMockDeleteRepositoryTagParamPtrs struct {
	ctx *context.Context
	s1  *string
}

// RepositoryIMockDeleteRepositoryTagResults contains results of the RepositoryI.DeleteRepositoryTag
type RepositoryIMockDeleteRepositoryTagResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) Expect(ctx context.Context, s1 string) *mRepositoryIMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryIMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &RepositoryIMockDeleteRepositoryTagExpectation{}
	}

	if mmDeleteRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryIMock.DeleteRepositoryTag mock is already set by ExpectParams functions")
	}

	mmDeleteRepositoryTag.defaultExpectation.params = &RepositoryIMockDeleteRepositoryTagParams{ctx, s1}
	for _, e := range mmDeleteRepositoryTag.expectations {
		if minimock.Equal(e.params, mmDeleteRepositoryTag.defaultExpectation.params) {
			mmDeleteRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteRepositoryTag.defaultExpectation.params)
		}
	}

	return mmDeleteRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryIMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &RepositoryIMockDeleteRepositoryTagExpectation{}
	}

	if mmDeleteRepositoryTag.defaultExpectation.params != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryIMock.DeleteRepositoryTag mock is already set by Expect")
	}

	if mmDeleteRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmDeleteRepositoryTag.defaultExpectation.paramPtrs = &RepositoryIMockDeleteRepositoryTagParamPtrs{}
	}
	mmDeleteRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteRepositoryTag
}

// ExpectS1Param2 sets up expected param s1 for RepositoryI.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) ExpectS1Param2(s1 string) *mRepositoryIMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryIMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &RepositoryIMockDeleteRepositoryTagExpectation{}
	}

	if mmDeleteRepositoryTag.defaultExpectation.params != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryIMock.DeleteRepositoryTag mock is already set by Expect")
	}

	if mmDeleteRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmDeleteRepositoryTag.defaultExpectation.paramPtrs = &RepositoryIMockDeleteRepositoryTagParamPtrs{}
	}
	mmDeleteRepositoryTag.defaultExpectation.paramPtrs.s1 = &s1

	return mmDeleteRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) Inspect(f func(ctx context.Context, s1 string)) *mRepositoryIMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.inspectFuncDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteRepositoryTag")
	}

	mmDeleteRepositoryTag.mock.inspectFuncDeleteRepositoryTag = f

	return mmDeleteRepositoryTag
}

// Return sets up results that will be returned by RepositoryI.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) Return(err error) *RepositoryIMock {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryIMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &RepositoryIMockDeleteRepositoryTagExpectation{mock: mmDeleteRepositoryTag.mock}
	}
	mmDeleteRepositoryTag.defaultExpectation.results = &RepositoryIMockDeleteRepositoryTagResults{err}
	return mmDeleteRepositoryTag.mock
}

// Set uses given function f to mock the RepositoryI.DeleteRepositoryTag method
func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) Set(f func(ctx context.Context, s1 string) (err error)) *RepositoryIMock {
	if mmDeleteRepositoryTag.defaultExpectation != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteRepositoryTag method")
	}

	if len(mmDeleteRepositoryTag.expectations) > 0 {
		mmDeleteRepositoryTag.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteRepositoryTag method")
	}

	mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag = f
	return mmDeleteRepositoryTag.mock
}

// When sets expectation for the RepositoryI.DeleteRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) When(ctx context.Context, s1 string) *RepositoryIMockDeleteRepositoryTagExpectation {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryIMock.DeleteRepositoryTag mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteRepositoryTagExpectation{
		mock:   mmDeleteRepositoryTag.mock,
		params: &RepositoryIMockDeleteRepositoryTagParams{ctx, s1},
	}
	mmDeleteRepositoryTag.expectations = append(mmDeleteRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteRepositoryTag return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteRepositoryTagExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteRepositoryTagResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteRepositoryTag should be invoked
func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) Times(n uint64) *mRepositoryIMockDeleteRepositoryTag {
	if n == 0 {
		mmDeleteRepositoryTag.mock.t.Fatalf("Times of RepositoryIMock.DeleteRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteRepositoryTag.expectedInvocations, n)
	return mmDeleteRepositoryTag
}

func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) invocationsDone() bool {
	if len(mmDeleteRepositoryTag.expectations) == 0 && mmDeleteRepositoryTag.defaultExpectation == nil && mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteRepositoryTag.mock.afterDeleteRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteRepositoryTag implements repository.RepositoryI
func (mmDeleteRepositoryTag *RepositoryIMock) DeleteRepositoryTag(ctx context.Context, s1 string) (err error) {
	mm_atomic.AddUint64(&mmDeleteRepositoryTag.beforeDeleteRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteRepositoryTag.afterDeleteRepositoryTagCounter, 1)

	if mmDeleteRepositoryTag.inspectFuncDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.inspectFuncDeleteRepositoryTag(ctx, s1)
	}

	mm_params := RepositoryIMockDeleteRepositoryTagParams{ctx, s1}

	// Record call args
	mmDeleteRepositoryTag.DeleteRepositoryTagMock.mutex.Lock()
	mmDeleteRepositoryTag.DeleteRepositoryTagMock.callArgs = append(mmDeleteRepositoryTag.DeleteRepositoryTagMock.callArgs, &mm_params)
	mmDeleteRepositoryTag.DeleteRepositoryTagMock.mutex.Unlock()

	for _, e := range mmDeleteRepositoryTag.DeleteRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteRepositoryTagParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteRepositoryTag.t.Errorf("RepositoryIMock.DeleteRepositoryTag got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmDeleteRepositoryTag.t.Errorf("RepositoryIMock.DeleteRepositoryTag got unexpected parameter s1, want: %#v, got: %#v%s\n", *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteRepositoryTag.t.Errorf("RepositoryIMock.DeleteRepositoryTag got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteRepositoryTag.t.Fatal("No results are set for the RepositoryIMock.DeleteRepositoryTag")
		}
		return (*mm_results).err
	}
	if mmDeleteRepositoryTag.funcDeleteRepositoryTag != nil {
		return mmDeleteRepositoryTag.funcDeleteRepositoryTag(ctx, s1)
	}
	mmDeleteRepositoryTag.t.Fatalf("Unexpected call to RepositoryIMock.DeleteRepositoryTag. %v %v", ctx, s1)
	return
}

// DeleteRepositoryTagAfterCounter returns a count of finished RepositoryIMock.DeleteRepositoryTag invocations
func (mmDeleteRepositoryTag *RepositoryIMock) DeleteRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRepositoryTag.afterDeleteRepositoryTagCounter)
}

// DeleteRepositoryTagBeforeCounter returns a count of RepositoryIMock.DeleteRepositoryTag invocations
func (mmDeleteRepositoryTag *RepositoryIMock) DeleteRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRepositoryTag.beforeDeleteRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) Calls() []*RepositoryIMockDeleteRepositoryTagParams {
	mmDeleteRepositoryTag.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteRepositoryTagParams, len(mmDeleteRepositoryTag.callArgs))
	copy(argCopy, mmDeleteRepositoryTag.callArgs)

	mmDeleteRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteRepositoryTagDone returns true if the count of the DeleteRepositoryTag invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteRepositoryTagDone() bool {
	for _, e := range m.DeleteRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteRepositoryTagMock.invocationsDone()
}

// MinimockDeleteRepositoryTagInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteRepositoryTagInspect() {
	for _, e := range m.DeleteRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteRepositoryTag with params: %#v", *e.params)
		}
	}

	afterDeleteRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterDeleteRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteRepositoryTagMock.defaultExpectation != nil && afterDeleteRepositoryTagCounter < 1 {
		if m.DeleteRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteRepositoryTag")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteRepositoryTag with params: %#v", *m.DeleteRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteRepositoryTag != nil && afterDeleteRepositoryTagCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteRepositoryTag")
	}

	if !m.DeleteRepositoryTagMock.invocationsDone() && afterDeleteRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteRepositoryTag but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteRepositoryTagMock.expectedInvocations), afterDeleteRepositoryTagCounter)
	}
}

type mRepositoryIMockGetChunksByUIDs struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetChunksByUIDsExpectation
	expectations       []*RepositoryIMockGetChunksByUIDsExpectation

	callArgs []*RepositoryIMockGetChunksByUIDsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetChunksByUIDsExpectation specifies expectation struct of the RepositoryI.GetChunksByUIDs
type RepositoryIMockGetChunksByUIDsExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetChunksByUIDsParams
	paramPtrs *RepositoryIMockGetChunksByUIDsParamPtrs
	results   *RepositoryIMockGetChunksByUIDsResults
	Counter   uint64
}

// RepositoryIMockGetChunksByUIDsParams contains parameters of the RepositoryI.GetChunksByUIDs
type RepositoryIMockGetChunksByUIDsParams struct {
	ctx       context.Context
	chunkUIDs []uuid.UUID
}

// RepositoryIMockGetChunksByUIDsParamPtrs contains pointers to parameters of the RepositoryI.GetChunksByUIDs
type RepositoryIMockGetChunksByUIDsParamPtrs struct {
	ctx       *context.Context
	chunkUIDs *[]uuid.UUID
}

// RepositoryIMockGetChunksByUIDsResults contains results of the RepositoryI.GetChunksByUIDs
type RepositoryIMockGetChunksByUIDsResults struct {
	ta1 []mm_repository.TextChunk
	err error
}

// Expect sets up expected params for RepositoryI.GetChunksByUIDs
func (mmGetChunksByUIDs *mRepositoryIMockGetChunksByUIDs) Expect(ctx context.Context, chunkUIDs []uuid.UUID) *mRepositoryIMockGetChunksByUIDs {
	if mmGetChunksByUIDs.mock.funcGetChunksByUIDs != nil {
		mmGetChunksByUIDs.mock.t.Fatalf("RepositoryIMock.GetChunksByUIDs mock is already set by Set")
	}

	if mmGetChunksByUIDs.defaultExpectation == nil {
		mmGetChunksByUIDs.defaultExpectation = &RepositoryIMockGetChunksByUIDsExpectation{}
	}

	if mmGetChunksByUIDs.defaultExpectation.paramPtrs != nil {
		mmGetChunksByUIDs.mock.t.Fatalf("RepositoryIMock.GetChunksByUIDs mock is already set by ExpectParams functions")
	}

	mmGetChunksByUIDs.defaultExpectation.params = &RepositoryIMockGetChunksByUIDsParams{ctx, chunkUIDs}
	for _, e := range mmGetChunksByUIDs.expectations {
		if minimock.Equal(e.params, mmGetChunksByUIDs.defaultExpectation.params) {
			mmGetChunksByUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChunksByUIDs.defaultExpectation.params)
		}
	}

	return mmGetChunksByUIDs
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetChunksByUIDs
func (mmGetChunksByUIDs *mRepositoryIMockGetChunksByUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetChunksByUIDs {
	if mmGetChunksByUIDs.mock.funcGetChunksByUIDs != nil {
		mmGetChunksByUIDs.mock.t.Fatalf("RepositoryIMock.GetChunksByUIDs mock is already set by Set")
	}

	if mmGetChunksByUIDs.defaultExpectation == nil {
		mmGetChunksByUIDs.defaultExpectation = &RepositoryIMockGetChunksByUIDsExpectation{}
	}

	if mmGetChunksByUIDs.defaultExpectation.params != nil {
		mmGetChunksByUIDs.mock.t.Fatalf("RepositoryIMock.GetChunksByUIDs mock is already set by Expect")
	}

	if mmGetChunksByUIDs.defaultExpectation.paramPtrs == nil {
		mmGetChunksByUIDs.defaultExpectation.paramPtrs = &RepositoryIMockGetChunksByUIDsParamPtrs{}
	}
	mmGetChunksByUIDs.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetChunksByUIDs
}

// ExpectChunkUIDsParam2 sets up expected param chunkUIDs for RepositoryI.GetChunksByUIDs
func (mmGetChunksByUIDs *mRepositoryIMockGetChunksByUIDs) ExpectChunkUIDsParam2(chunkUIDs []uuid.UUID) *mRepositoryIMockGetChunksByUIDs {
	if mmGetChunksByUIDs.mock.funcGetChunksByUIDs != nil {
		mmGetChunksByUIDs.mock.t.Fatalf("RepositoryIMock.GetChunksByUIDs mock is already set by Set")
	}

	if mmGetChunksByUIDs.defaultExpectation == nil {
		mmGetChunksByUIDs.defaultExpectation = &RepositoryIMockGetChunksByUIDsExpectation{}
	}

	if mmGetChunksByUIDs.defaultExpectation.params != nil {
		mmGetChunksByUIDs.mock.t.Fatalf("RepositoryIMock.GetChunksByUIDs mock is already set by Expect")
	}

	if mmGetChunksByUIDs.defaultExpectation.paramPtrs == nil {
		mmGetChunksByUIDs.defaultExpectation.paramPtrs = &RepositoryIMockGetChunksByUIDsParamPtrs{}
	}
	mmGetChunksByUIDs.defaultExpectation.paramPtrs.chunkUIDs = &chunkUIDs

	return mmGetChunksByUIDs
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetChunksByUIDs
func (mmGetChunksByUIDs *mRepositoryIMockGetChunksByUIDs) Inspect(f func(ctx context.Context, chunkUIDs []uuid.UUID)) *mRepositoryIMockGetChunksByUIDs {
	if mmGetChunksByUIDs.mock.inspectFuncGetChunksByUIDs != nil {
		mmGetChunksByUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetChunksByUIDs")
	}

	mmGetChunksByUIDs.mock.inspectFuncGetChunksByUIDs = f

	return mmGetChunksByUIDs
}

// Return sets up results that will be returned by RepositoryI.GetChunksByUIDs
func (mmGetChunksByUIDs *mRepositoryIMockGetChunksByUIDs) Return(ta1 []mm_repository.TextChunk, err error) *RepositoryIMock {
	if mmGetChunksByUIDs.mock.funcGetChunksByUIDs != nil {
		mmGetChunksByUIDs.mock.t.Fatalf("RepositoryIMock.GetChunksByUIDs mock is already set by Set")
	}

	if mmGetChunksByUIDs.defaultExpectation == nil {
		mmGetChunksByUIDs.defaultExpectation = &RepositoryIMockGetChunksByUIDsExpectation{mock: mmGetChunksByUIDs.mock}
	}
	mmGetChunksByUIDs.defaultExpectation.results = &RepositoryIMockGetChunksByUIDsResults{ta1, err}
	return mmGetChunksByUIDs.mock
}

// Set uses given function f to mock the RepositoryI.GetChunksByUIDs method
func (mmGetChunksByUIDs *mRepositoryIMockGetChunksByUIDs) Set(f func(ctx context.Context, chunkUIDs []uuid.UUID) (ta1 []mm_repository.TextChunk, err error)) *RepositoryIMock {
	if mmGetChunksByUIDs.defaultExpectation != nil {
		mmGetChunksByUIDs.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetChunksByUIDs method")
	}

	if len(mmGetChunksByUIDs.expectations) > 0 {
		mmGetChunksByUIDs.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetChunksByUIDs method")
	}

	mmGetChunksByUIDs.mock.funcGetChunksByUIDs = f
	return mmGetChunksByUIDs.mock
}

// When sets expectation for the RepositoryI.GetChunksByUIDs which will trigger the result defined by the following
// Then helper
func (mmGetChunksByUIDs *mRepositoryIMockGetChunksByUIDs) When(ctx context.Context, chunkUIDs []uuid.UUID) *RepositoryIMockGetChunksByUIDsExpectation {
	if mmGetChunksByUIDs.mock.funcGetChunksByUIDs != nil {
		mmGetChunksByUIDs.mock.t.Fatalf("RepositoryIMock.GetChunksByUIDs mock is already set by Set")
	}

	expectation := &RepositoryIMockGetChunksByUIDsExpectation{
		mock:   mmGetChunksByUIDs.mock,
		params: &RepositoryIMockGetChunksByUIDsParams{ctx, chunkUIDs},
	}
	mmGetChunksByUIDs.expectations = append(mmGetChunksByUIDs.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetChunksByUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetChunksByUIDsExpectation) Then(ta1 []mm_repository.TextChunk, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetChunksByUIDsResults{ta1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetChunksByUIDs should be invoked
func (mmGetChunksByUIDs *mRepositoryIMockGetChunksByUIDs) Times(n uint64) *mRepositoryIMockGetChunksByUIDs {
	if n == 0 {
		mmGetChunksByUIDs.mock.t.Fatalf("Times of RepositoryIMock.GetChunksByUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetChunksByUIDs.expectedInvocations, n)
	return mmGetChunksByUIDs
}

func (mmGetChunksByUIDs *mRepositoryIMockGetChunksByUIDs) invocationsDone() bool {
	if len(mmGetChunksByUIDs.expectations) == 0 && mmGetChunksByUIDs.defaultExpectation == nil && mmGetChunksByUIDs.mock.funcGetChunksByUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetChunksByUIDs.mock.afterGetChunksByUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetChunksByUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetChunksByUIDs implements repository.RepositoryI
func (mmGetChunksByUIDs *RepositoryIMock) GetChunksByUIDs(ctx context.Context, chunkUIDs []uuid.UUID) (ta1 []mm_repository.TextChunk, err error) {
	mm_atomic.AddUint64(&mmGetChunksByUIDs.beforeGetChunksByUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChunksByUIDs.afterGetChunksByUIDsCounter, 1)

	if mmGetChunksByUIDs.inspectFuncGetChunksByUIDs != nil {
		mmGetChunksByUIDs.inspectFuncGetChunksByUIDs(ctx, chunkUIDs)
	}

	mm_params := RepositoryIMockGetChunksByUIDsParams{ctx, chunkUIDs}

	// Record call args
	mmGetChunksByUIDs.GetChunksByUIDsMock.mutex.Lock()
	mmGetChunksByUIDs.GetChunksByUIDsMock.callArgs = append(mmGetChunksByUIDs.GetChunksByUIDsMock.callArgs, &mm_params)
	mmGetChunksByUIDs.GetChunksByUIDsMock.mutex.Unlock()

	for _, e := range mmGetChunksByUIDs.GetChunksByUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ta1, e.results.err
		}
	}

	if mmGetChunksByUIDs.GetChunksByUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChunksByUIDs.GetChunksByUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChunksByUIDs.GetChunksByUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmGetChunksByUIDs.GetChunksByUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetChunksByUIDsParams{ctx, chunkUIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetChunksByUIDs.t.Errorf("RepositoryIMock.GetChunksByUIDs got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chunkUIDs != nil && !minimock.Equal(*mm_want_ptrs.chunkUIDs, mm_got.chunkUIDs) {
				mmGetChunksByUIDs.t.Errorf("RepositoryIMock.GetChunksByUIDs got unexpected parameter chunkUIDs, want: %#v, got: %#v%s\n", *mm_want_ptrs.chunkUIDs, mm_got.chunkUIDs, minimock.Diff(*mm_want_ptrs.chunkUIDs, mm_got.chunkUIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChunksByUIDs.t.Errorf("RepositoryIMock.GetChunksByUIDs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChunksByUIDs.GetChunksByUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChunksByUIDs.t.Fatal("No results are set for the RepositoryIMock.GetChunksByUIDs")
		}
		return (*mm_results).ta1, (*mm_results).err
	}
	if mmGetChunksByUIDs.funcGetChunksByUIDs != nil {
		return mmGetChunksByUIDs.funcGetChunksByUIDs(ctx, chunkUIDs)
	}
	mmGetChunksByUIDs.t.Fatalf("Unexpected call to RepositoryIMock.GetChunksByUIDs. %v %v", ctx, chunkUIDs)
	return
}

// GetChunksByUIDsAfterCounter returns a count of finished RepositoryIMock.GetChunksByUIDs invocations
func (mmGetChunksByUIDs *RepositoryIMock) GetChunksByUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChunksByUIDs.afterGetChunksByUIDsCounter)
}

// GetChunksByUIDsBeforeCounter returns a count of RepositoryIMock.GetChunksByUIDs invocations
func (mmGetChunksByUIDs *RepositoryIMock) GetChunksByUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChunksByUIDs.beforeGetChunksByUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetChunksByUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChunksByUIDs *mRepositoryIMockGetChunksByUIDs) Calls() []*RepositoryIMockGetChunksByUIDsParams {
	mmGetChunksByUIDs.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetChunksByUIDsParams, len(mmGetChunksByUIDs.callArgs))
	copy(argCopy, mmGetChunksByUIDs.callArgs)

	mmGetChunksByUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockGetChunksByUIDsDone returns true if the count of the GetChunksByUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetChunksByUIDsDone() bool {
	for _, e := range m.GetChunksByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetChunksByUIDsMock.invocationsDone()
}

// MinimockGetChunksByUIDsInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetChunksByUIDsInspect() {
	for _, e := range m.GetChunksByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetChunksByUIDs with params: %#v", *e.params)
		}
	}

	afterGetChunksByUIDsCounter := mm_atomic.LoadUint64(&m.afterGetChunksByUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetChunksByUIDsMock.defaultExpectation != nil && afterGetChunksByUIDsCounter < 1 {
		if m.GetChunksByUIDsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetChunksByUIDs")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetChunksByUIDs with params: %#v", *m.GetChunksByUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChunksByUIDs != nil && afterGetChunksByUIDsCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetChunksByUIDs")
	}

	if !m.GetChunksByUIDsMock.invocationsDone() && afterGetChunksByUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetChunksByUIDs but found %d calls",
			mm_atomic.LoadUint64(&m.GetChunksByUIDsMock.expectedInvocations), afterGetChunksByUIDsCounter)
	}
}

type mRepositoryIMockGetConversationByID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetConversationByIDExpectation
	expectations       []*RepositoryIMockGetConversationByIDExpectation

	callArgs []*RepositoryIMockGetConversationByIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetConversationByIDExpectation specifies expectation struct of the RepositoryI.GetConversationByID
type RepositoryIMockGetConversationByIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetConversationByIDParams
	paramPtrs *RepositoryIMockGetConversationByIDParamPtrs
	results   *RepositoryIMockGetConversationByIDResults
	Counter   uint64
}

// RepositoryIMockGetConversationByIDParams contains parameters of the RepositoryI.GetConversationByID
type RepositoryIMockGetConversationByIDParams struct {
	ctx            context.Context
	namespaceUID   uuid.UUID
	catalogUID     uuid.UUID
	conversationID string
}

// RepositoryIMockGetConversationByIDParamPtrs contains pointers to parameters of the RepositoryI.GetConversationByID
type RepositoryIMockGetConversationByIDParamPtrs struct {
	ctx            *context.Context
	namespaceUID   *uuid.UUID
	catalogUID     *uuid.UUID
	conversationID *string
}

// RepositoryIMockGetConversationByIDResults contains results of the RepositoryI.GetConversationByID
type RepositoryIMockGetConversationByIDResults struct {
	cp1 *mm_repository.Conversation
	err error
}

// Expect sets up expected params for RepositoryI.GetConversationByID
func (mmGetConversationByID *mRepositoryIMockGetConversationByID) Expect(ctx context.Context, namespaceUID uuid.UUID, catalogUID uuid.UUID, conversationID string) *mRepositoryIMockGetConversationByID {
	if mmGetConversationByID.mock.funcGetConversationByID != nil {
		mmGetConversationByID.mock.t.Fatalf("RepositoryIMock.GetConversationByID mock is already set by Set")
	}

	if mmGetConversationByID.defaultExpectation == nil {
		mmGetConversationByID.defaultExpectation = &RepositoryIMockGetConversationByIDExpectation{}
	}

	if mmGetConversationByID.defaultExpectation.paramPtrs != nil {
		mmGetConversationByID.mock.t.Fatalf("RepositoryIMock.GetConversationByID mock is already set by ExpectParams functions")
	}

	mmGetConversationByID.defaultExpectation.params = &RepositoryIMockGetConversationByIDParams{ctx, namespaceUID, catalogUID, conversationID}
	for _, e := range mmGetConversationByID.expectations {
		if minimock.Equal(e.params, mmGetConversationByID.defaultExpectation.params) {
			mmGetConversationByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetConversationByID.defaultExpectation.params)
		}
	}

	return mmGetConversationByID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetConversationByID
func (mmGetConversationByID *mRepositoryIMockGetConversationByID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetConversationByID {
	if mmGetConversationByID.mock.funcGetConversationByID != nil {
		mmGetConversationByID.mock.t.Fatalf("RepositoryIMock.GetConversationByID mock is already set by Set")
	}

	if mmGetConversationByID.defaultExpectation == nil {
		mmGetConversationByID.defaultExpectation = &RepositoryIMockGetConversationByIDExpectation{}
	}

	if mmGetConversationByID.defaultExpectation.params != nil {
		mmGetConversationByID.mock.t.Fatalf("RepositoryIMock.GetConversationByID mock is already set by Expect")
	}

	if mmGetConversationByID.defaultExpectation.paramPtrs == nil {
		mmGetConversationByID.defaultExpectation.paramPtrs = &RepositoryIMockGetConversationByIDParamPtrs{}
	}
	mmGetConversationByID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetConversationByID
}

// ExpectNamespaceUIDParam2 sets up expected param namespaceUID for RepositoryI.GetConversationByID
func (mmGetConversationByID *mRepositoryIMockGetConversationByID) ExpectNamespaceUIDParam2(namespaceUID uuid.UUID) *mRepositoryIMockGetConversationByID {
	if mmGetConversationByID.mock.funcGetConversationByID != nil {
		mmGetConversationByID.mock.t.Fatalf("RepositoryIMock.GetConversationByID mock is already set by Set")
	}

	if mmGetConversationByID.defaultExpectation == nil {
		mmGetConversationByID.defaultExpectation = &RepositoryIMockGetConversationByIDExpectation{}
	}

	if mmGetConversationByID.defaultExpectation.params != nil {
		mmGetConversationByID.mock.t.Fatalf("RepositoryIMock.GetConversationByID mock is already set by Expect")
	}

	if mmGetConversationByID.defaultExpectation.paramPtrs == nil {
		mmGetConversationByID.defaultExpectation.paramPtrs = &RepositoryIMockGetConversationByIDParamPtrs{}
	}
	mmGetConversationByID.defaultExpectation.paramPtrs.namespaceUID = &namespaceUID

	return mmGetConversationByID
}

// ExpectCatalogUIDParam3 sets up expected param catalogUID for RepositoryI.GetConversationByID
func (mmGetConversationByID *mRepositoryIMockGetConversationByID) ExpectCatalogUIDParam3(catalogUID uuid.UUID) *mRepositoryIMockGetConversationByID {
	if mmGetConversationByID.mock.funcGetConversationByID != nil {
		mmGetConversationByID.mock.t.Fatalf("RepositoryIMock.GetConversationByID mock is already set by Set")
	}

	if mmGetConversationByID.defaultExpectation == nil {
		mmGetConversationByID.defaultExpectation = &RepositoryIMockGetConversationByIDExpectation{}
	}

	if mmGetConversationByID.defaultExpectation.params != nil {
		mmGetConversationByID.mock.t.Fatalf("RepositoryIMock.GetConversationByID mock is already set by Expect")
	}

	if mmGetConversationByID.defaultExpectation.paramPtrs == nil {
		mmGetConversationByID.defaultExpectation.paramPtrs = &RepositoryIMockGetConversationByIDParamPtrs{}
	}
	mmGetConversationByID.defaultExpectation.paramPtrs.catalogUID = &catalogUID

	return mmGetConversationByID
}

// ExpectConversationIDParam4 sets up expected param conversationID for RepositoryI.GetConversationByID
func (mmGetConversationByID *mRepositoryIMockGetConversationByID) ExpectConversationIDParam4(conversationID string) *mRepositoryIMockGetConversationByID {
	if mmGetConversationByID.mock.funcGetConversationByID != nil {
		mmGetConversationByID.mock.t.Fatalf("RepositoryIMock.GetConversationByID mock is already set by Set")
	}

	if mmGetConversationByID.defaultExpectation == nil {
		mmGetConversationByID.defaultExpectation = &RepositoryIMockGetConversationByIDExpectation{}
	}

	if mmGetConversationByID.defaultExpectation.params != nil {
		mmGetConversationByID.mock.t.Fatalf("RepositoryIMock.GetConversationByID mock is already set by Expect")
	}

	if mmGetConversationByID.defaultExpectation.paramPtrs == nil {
		mmGetConversationByID.defaultExpectation.paramPtrs = &RepositoryIMockGetConversationByIDParamPtrs{}
	}
	mmGetConversationByID.defaultExpectation.paramPtrs.conversationID = &conversationID

	return mmGetConversationByID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetConversationByID
func (mmGetConversationByID *mRepositoryIMockGetConversationByID) Inspect(f func(ctx context.Context, namespaceUID uuid.UUID, catalogUID uuid.UUID, conversationID string)) *mRepositoryIMockGetConversationByID {
	if mmGetConversationByID.mock.inspectFuncGetConversationByID != nil {
		mmGetConversationByID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetConversationByID")
	}

	mmGetConversationByID.mock.inspectFuncGetConversationByID = f

	return mmGetConversationByID
}

// Return sets up results that will be returned by RepositoryI.GetConversationByID
func (mmGetConversationByID *mRepositoryIMockGetConversationByID) Return(cp1 *mm_repository.Conversation, err error) *RepositoryIMock {
	if mmGetConversationByID.mock.funcGetConversationByID != nil {
		mmGetConversationByID.mock.t.Fatalf("RepositoryIMock.GetConversationByID mock is already set by Set")
	}

	if mmGetConversationByID.defaultExpectation == nil {
		mmGetConversationByID.defaultExpectation = &RepositoryIMockGetConversationByIDExpectation{mock: mmGetConversationByID.mock}
	}
	mmGetConversationByID.defaultExpectation.results = &RepositoryIMockGetConversationByIDResults{cp1, err}
	return mmGetConversationByID.mock
}

// Set uses given function f to mock the RepositoryI.GetConversationByID method
func (mmGetConversationByID *mRepositoryIMockGetConversationByID) Set(f func(ctx context.Context, namespaceUID uuid.UUID, catalogUID uuid.UUID, conversationID string) (cp1 *mm_repository.Conversation, err error)) *RepositoryIMock {
	if mmGetConversationByID.defaultExpectation != nil {
		mmGetConversationByID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetConversationByID method")
	}

	if len(mmGetConversationByID.expectations) > 0 {
		mmGetConversationByID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetConversationByID method")
	}

	mmGetConversationByID.mock.funcGetConversationByID = f
	return mmGetConversationByID.mock
}

// When sets expectation for the RepositoryI.GetConversationByID which will trigger the result defined by the following
// Then helper
func (mmGetConversationByID *mRepositoryIMockGetConversationByID) When(ctx context.Context, namespaceUID uuid.UUID, catalogUID uuid.UUID, conversationID string) *RepositoryIMockGetConversationByIDExpectation {
	if mmGetConversationByID.mock.funcGetConversationByID != nil {
		mmGetConversationByID.mock.t.Fatalf("RepositoryIMock.GetConversationByID mock is already set by Set")
	}

	expectation := &RepositoryIMockGetConversationByIDExpectation{
		mock:   mmGetConversationByID.mock,
		params: &RepositoryIMockGetConversationByIDParams{ctx, namespaceUID, catalogUID, conversationID},
	}
	mmGetConversationByID.expectations = append(mmGetConversationByID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetConversationByID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetConversationByIDExpectation) Then(cp1 *mm_repository.Conversation, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetConversationByIDResults{cp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetConversationByID should be invoked
func (mmGetConversationByID *mRepositoryIMockGetConversationByID) Times(n uint64) *mRepositoryIMockGetConversationByID {
	if n == 0 {
		mmGetConversationByID.mock.t.Fatalf("Times of RepositoryIMock.GetConversationByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetConversationByID.expectedInvocations, n)
	return mmGetConversationByID
}

func (mmGetConversationByID *mRepositoryIMockGetConversationByID) invocationsDone() bool {
	if len(mmGetConversationByID.expectations) == 0 && mmGetConversationByID.defaultExpectation == nil && mmGetConversationByID.mock.funcGetConversationByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetConversationByID.mock.afterGetConversationByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetConversationByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetConversationByID implements repository.RepositoryI
func (mmGetConversationByID *RepositoryIMock) GetConversationByID(ctx context.Context, namespaceUID uuid.UUID, catalogUID uuid.UUID, conversationID string) (cp1 *mm_repository.Conversation, err error) {
	mm_atomic.AddUint64(&mmGetConversationByID.beforeGetConversationByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetConversationByID.afterGetConversationByIDCounter, 1)

	if mmGetConversationByID.inspectFuncGetConversationByID != nil {
		mmGetConversationByID.inspectFuncGetConversationByID(ctx, namespaceUID, catalogUID, conversationID)
	}

	mm_params := RepositoryIMockGetConversationByIDParams{ctx, namespaceUID, catalogUID, conversationID}

	// Record call args
	mmGetConversationByID.GetConversationByIDMock.mutex.Lock()
	mmGetConversationByID.GetConversationByIDMock.callArgs = append(mmGetConversationByID.GetConversationByIDMock.callArgs, &mm_params)
	mmGetConversationByID.GetConversationByIDMock.mutex.Unlock()

	for _, e := range mmGetConversationByID.GetConversationByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetConversationByID.GetConversationByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetConversationByID.GetConversationByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetConversationByID.GetConversationByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetConversationByID.GetConversationByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetConversationByIDParams{ctx, namespaceUID, catalogUID, conversationID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetConversationByID.t.Errorf("RepositoryIMock.GetConversationByID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.namespaceUID != nil && !minimock.Equal(*mm_want_ptrs.namespaceUID, mm_got.namespaceUID) {
				mmGetConversationByID.t.Errorf("RepositoryIMock.GetConversationByID got unexpected parameter namespaceUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.namespaceUID, mm_got.namespaceUID, minimock.Diff(*mm_want_ptrs.namespaceUID, mm_got.namespaceUID))
			}

			if mm_want_ptrs.catalogUID != nil && !minimock.Equal(*mm_want_ptrs.catalogUID, mm_got.catalogUID) {
				mmGetConversationByID.t.Errorf("RepositoryIMock.GetConversationByID got unexpected parameter catalogUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.catalogUID, mm_got.catalogUID, minimock.Diff(*mm_want_ptrs.catalogUID, mm_got.catalogUID))
			}

			if mm_want_ptrs.conversationID != nil && !minimock.Equal(*mm_want_ptrs.conversationID, mm_got.conversationID) {
				mmGetConversationByID.t.Errorf("RepositoryIMock.GetConversationByID got unexpected parameter conversationID, want: %#v, got: %#v%s\n", *mm_want_ptrs.conversationID, mm_got.conversationID, minimock.Diff(*mm_want_ptrs.conversationID, mm_got.conversationID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetConversationByID.t.Errorf("RepositoryIMock.GetConversationByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetConversationByID.GetConversationByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetConversationByID.t.Fatal("No results are set for the RepositoryIMock.GetConversationByID")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetConversationByID.funcGetConversationByID != nil {
		return mmGetConversationByID.funcGetConversationByID(ctx, namespaceUID, catalogUID, conversationID)
	}
	mmGetConversationByID.t.Fatalf("Unexpected call to RepositoryIMock.GetConversationByID. %v %v %v %v", ctx, namespaceUID, catalogUID, conversationID)
	return
}

// GetConversationByIDAfterCounter returns a count of finished RepositoryIMock.GetConversationByID invocations
func (mmGetConversationByID *RepositoryIMock) GetConversationByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConversationByID.afterGetConversationByIDCounter)
}

// GetConversationByIDBeforeCounter returns a count of RepositoryIMock.GetConversationByID invocations
func (mmGetConversationByID *RepositoryIMock) GetConversationByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConversationByID.beforeGetConversationByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetConversationByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetConversationByID *mRepositoryIMockGetConversationByID) Calls() []*RepositoryIMockGetConversationByIDParams {
	mmGetConversationByID.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetConversationByIDParams, len(mmGetConversationByID.callArgs))
	copy(argCopy, mmGetConversationByID.callArgs)

	mmGetConversationByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetConversationByIDDone returns true if the count of the GetConversationByID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetConversationByIDDone() bool {
	for _, e := range m.GetConversationByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetConversationByIDMock.invocationsDone()
}

// MinimockGetConversationByIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetConversationByIDInspect() {
	for _, e := range m.GetConversationByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetConversationByID with params: %#v", *e.params)
		}
	}

	afterGetConversationByIDCounter := mm_atomic.LoadUint64(&m.afterGetConversationByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetConversationByIDMock.defaultExpectation != nil && afterGetConversationByIDCounter < 1 {
		if m.GetConversationByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetConversationByID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetConversationByID with params: %#v", *m.GetConversationByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetConversationByID != nil && afterGetConversationByIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetConversationByID")
	}

	if !m.GetConversationByIDMock.invocationsDone() && afterGetConversationByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetConversationByID but found %d calls",
			mm_atomic.LoadUint64(&m.GetConversationByIDMock.expectedInvocations), afterGetConversationByIDCounter)
	}
}

type mRepositoryIMockGetConversationByUID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetConversationByUIDExpectation
	expectations       []*RepositoryIMockGetConversationByUIDExpectation

	callArgs []*RepositoryIMockGetConversationByUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetConversationByUIDExpectation specifies expectation struct of the RepositoryI.GetConversationByUID
type RepositoryIMockGetConversationByUIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetConversationByUIDParams
	paramPtrs *RepositoryIMockGetConversationByUIDParamPtrs
	results   *RepositoryIMockGetConversationByUIDResults
	Counter   uint64
}

// RepositoryIMockGetConversationByUIDParams contains parameters of the RepositoryI.GetConversationByUID
type RepositoryIMockGetConversationByUIDParams struct {
	ctx     context.Context
	convUID uuid.UUID
}

// RepositoryIMockGetConversationByUIDParamPtrs contains pointers to parameters of the RepositoryI.GetConversationByUID
type RepositoryIMockGetConversationByUIDParamPtrs struct {
	ctx     *context.Context
	convUID *uuid.UUID
}

// RepositoryIMockGetConversationByUIDResults contains results of the RepositoryI.GetConversationByUID
type RepositoryIMockGetConversationByUIDResults struct {
	cp1 *mm_repository.Conversation
	err error
}

// Expect sets up expected params for RepositoryI.GetConversationByUID
func (mmGetConversationByUID *mRepositoryIMockGetConversationByUID) Expect(ctx context.Context, convUID uuid.UUID) *mRepositoryIMockGetConversationByUID {
	if mmGetConversationByUID.mock.funcGetConversationByUID != nil {
		mmGetConversationByUID.mock.t.Fatalf("RepositoryIMock.GetConversationByUID mock is already set by Set")
	}

	if mmGetConversationByUID.defaultExpectation == nil {
		mmGetConversationByUID.defaultExpectation = &RepositoryIMockGetConversationByUIDExpectation{}
	}

	if mmGetConversationByUID.defaultExpectation.paramPtrs != nil {
		mmGetConversationByUID.mock.t.Fatalf("RepositoryIMock.GetConversationByUID mock is already set by ExpectParams functions")
	}

	mmGetConversationByUID.defaultExpectation.params = &RepositoryIMockGetConversationByUIDParams{ctx, convUID}
	for _, e := range mmGetConversationByUID.expectations {
		if minimock.Equal(e.params, mmGetConversationByUID.defaultExpectation.params) {
			mmGetConversationByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetConversationByUID.defaultExpectation.params)
		}
	}

	return mmGetConversationByUID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetConversationByUID
func (mmGetConversationByUID *mRepositoryIMockGetConversationByUID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetConversationByUID {
	if mmGetConversationByUID.mock.funcGetConversationByUID != nil {
		mmGetConversationByUID.mock.t.Fatalf("RepositoryIMock.GetConversationByUID mock is already set by Set")
	}

	if mmGetConversationByUID.defaultExpectation == nil {
		mmGetConversationByUID.defaultExpectation = &RepositoryIMockGetConversationByUIDExpectation{}
	}

	if mmGetConversationByUID.defaultExpectation.params != nil {
		mmGetConversationByUID.mock.t.Fatalf("RepositoryIMock.GetConversationByUID mock is already set by Expect")
	}

	if mmGetConversationByUID.defaultExpectation.paramPtrs == nil {
		mmGetConversationByUID.defaultExpectation.paramPtrs = &RepositoryIMockGetConversationByUIDParamPtrs{}
	}
	mmGetConversationByUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetConversationByUID
}

// ExpectConvUIDParam2 sets up expected param convUID for RepositoryI.GetConversationByUID
func (mmGetConversationByUID *mRepositoryIMockGetConversationByUID) ExpectConvUIDParam2(convUID uuid.UUID) *mRepositoryIMockGetConversationByUID {
	if mmGetConversationByUID.mock.funcGetConversationByUID != nil {
		mmGetConversationByUID.mock.t.Fatalf("RepositoryIMock.GetConversationByUID mock is already set by Set")
	}

	if mmGetConversationByUID.defaultExpectation == nil {
		mmGetConversationByUID.defaultExpectation = &RepositoryIMockGetConversationByUIDExpectation{}
	}

	if mmGetConversationByUID.defaultExpectation.params != nil {
		mmGetConversationByUID.mock.t.Fatalf("RepositoryIMock.GetConversationByUID mock is already set by Expect")
	}

	if mmGetConversationByUID.defaultExpectation.paramPtrs == nil {
		mmGetConversationByUID.defaultExpectation.paramPtrs = &RepositoryIMockGetConversationByUIDParamPtrs{}
	}
	mmGetConversationByUID.defaultExpectation.paramPtrs.convUID = &convUID

	return mmGetConversationByUID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetConversationByUID
func (mmGetConversationByUID *mRepositoryIMockGetConversationByUID) Inspect(f func(ctx context.Context, convUID uuid.UUID)) *mRepositoryIMockGetConversationByUID {
	if mmGetConversationByUID.mock.inspectFuncGetConversationByUID != nil {
		mmGetConversationByUID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetConversationByUID")
	}

	mmGetConversationByUID.mock.inspectFuncGetConversationByUID = f

	return mmGetConversationByUID
}

// Return sets up results that will be returned by RepositoryI.GetConversationByUID
func (mmGetConversationByUID *mRepositoryIMockGetConversationByUID) Return(cp1 *mm_repository.Conversation, err error) *RepositoryIMock {
	if mmGetConversationByUID.mock.funcGetConversationByUID != nil {
		mmGetConversationByUID.mock.t.Fatalf("RepositoryIMock.GetConversationByUID mock is already set by Set")
	}

	if mmGetConversationByUID.defaultExpectation == nil {
		mmGetConversationByUID.defaultExpectation = &RepositoryIMockGetConversationByUIDExpectation{mock: mmGetConversationByUID.mock}
	}
	mmGetConversationByUID.defaultExpectation.results = &RepositoryIMockGetConversationByUIDResults{cp1, err}
	return mmGetConversationByUID.mock
}

// Set uses given function f to mock the RepositoryI.GetConversationByUID method
func (mmGetConversationByUID *mRepositoryIMockGetConversationByUID) Set(f func(ctx context.Context, convUID uuid.UUID) (cp1 *mm_repository.Conversation, err error)) *RepositoryIMock {
	if mmGetConversationByUID.defaultExpectation != nil {
		mmGetConversationByUID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetConversationByUID method")
	}

	if len(mmGetConversationByUID.expectations) > 0 {
		mmGetConversationByUID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetConversationByUID method")
	}

	mmGetConversationByUID.mock.funcGetConversationByUID = f
	return mmGetConversationByUID.mock
}

// When sets expectation for the RepositoryI.GetConversationByUID which will trigger the result defined by the following
// Then helper
func (mmGetConversationByUID *mRepositoryIMockGetConversationByUID) When(ctx context.Context, convUID uuid.UUID) *RepositoryIMockGetConversationByUIDExpectation {
	if mmGetConversationByUID.mock.funcGetConversationByUID != nil {
		mmGetConversationByUID.mock.t.Fatalf("RepositoryIMock.GetConversationByUID mock is already set by Set")
	}

	expectation := &RepositoryIMockGetConversationByUIDExpectation{
		mock:   mmGetConversationByUID.mock,
		params: &RepositoryIMockGetConversationByUIDParams{ctx, convUID},
	}
	mmGetConversationByUID.expectations = append(mmGetConversationByUID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetConversationByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetConversationByUIDExpectation) Then(cp1 *mm_repository.Conversation, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetConversationByUIDResults{cp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetConversationByUID should be invoked
func (mmGetConversationByUID *mRepositoryIMockGetConversationByUID) Times(n uint64) *mRepositoryIMockGetConversationByUID {
	if n == 0 {
		mmGetConversationByUID.mock.t.Fatalf("Times of RepositoryIMock.GetConversationByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetConversationByUID.expectedInvocations, n)
	return mmGetConversationByUID
}

func (mmGetConversationByUID *mRepositoryIMockGetConversationByUID) invocationsDone() bool {
	if len(mmGetConversationByUID.expectations) == 0 && mmGetConversationByUID.defaultExpectation == nil && mmGetConversationByUID.mock.funcGetConversationByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetConversationByUID.mock.afterGetConversationByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetConversationByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetConversationByUID implements repository.RepositoryI
func (mmGetConversationByUID *RepositoryIMock) GetConversationByUID(ctx context.Context, convUID uuid.UUID) (cp1 *mm_repository.Conversation, err error) {
	mm_atomic.AddUint64(&mmGetConversationByUID.beforeGetConversationByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetConversationByUID.afterGetConversationByUIDCounter, 1)

	if mmGetConversationByUID.inspectFuncGetConversationByUID != nil {
		mmGetConversationByUID.inspectFuncGetConversationByUID(ctx, convUID)
	}

	mm_params := RepositoryIMockGetConversationByUIDParams{ctx, convUID}

	// Record call args
	mmGetConversationByUID.GetConversationByUIDMock.mutex.Lock()
	mmGetConversationByUID.GetConversationByUIDMock.callArgs = append(mmGetConversationByUID.GetConversationByUIDMock.callArgs, &mm_params)
	mmGetConversationByUID.GetConversationByUIDMock.mutex.Unlock()

	for _, e := range mmGetConversationByUID.GetConversationByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetConversationByUID.GetConversationByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetConversationByUID.GetConversationByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetConversationByUID.GetConversationByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetConversationByUID.GetConversationByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetConversationByUIDParams{ctx, convUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetConversationByUID.t.Errorf("RepositoryIMock.GetConversationByUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.convUID != nil && !minimock.Equal(*mm_want_ptrs.convUID, mm_got.convUID) {
				mmGetConversationByUID.t.Errorf("RepositoryIMock.GetConversationByUID got unexpected parameter convUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.convUID, mm_got.convUID, minimock.Diff(*mm_want_ptrs.convUID, mm_got.convUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetConversationByUID.t.Errorf("RepositoryIMock.GetConversationByUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetConversationByUID.GetConversationByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetConversationByUID.t.Fatal("No results are set for the RepositoryIMock.GetConversationByUID")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetConversationByUID.funcGetConversationByUID != nil {
		return mmGetConversationByUID.funcGetConversationByUID(ctx, convUID)
	}
	mmGetConversationByUID.t.Fatalf("Unexpected call to RepositoryIMock.GetConversationByUID. %v %v", ctx, convUID)
	return
}

// GetConversationByUIDAfterCounter returns a count of finished RepositoryIMock.GetConversationByUID invocations
func (mmGetConversationByUID *RepositoryIMock) GetConversationByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConversationByUID.afterGetConversationByUIDCounter)
}

// GetConversationByUIDBeforeCounter returns a count of RepositoryIMock.GetConversationByUID invocations
func (mmGetConversationByUID *RepositoryIMock) GetConversationByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConversationByUID.beforeGetConversationByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetConversationByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetConversationByUID *mRepositoryIMockGetConversationByUID) Calls() []*RepositoryIMockGetConversationByUIDParams {
	mmGetConversationByUID.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetConversationByUIDParams, len(mmGetConversationByUID.callArgs))
	copy(argCopy, mmGetConversationByUID.callArgs)

	mmGetConversationByUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetConversationByUIDDone returns true if the count of the GetConversationByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetConversationByUIDDone() bool {
	for _, e := range m.GetConversationByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetConversationByUIDMock.invocationsDone()
}

// MinimockGetConversationByUIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetConversationByUIDInspect() {
	for _, e := range m.GetConversationByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetConversationByUID with params: %#v", *e.params)
		}
	}

	afterGetConversationByUIDCounter := mm_atomic.LoadUint64(&m.afterGetConversationByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetConversationByUIDMock.defaultExpectation != nil && afterGetConversationByUIDCounter < 1 {
		if m.GetConversationByUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetConversationByUID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetConversationByUID with params: %#v", *m.GetConversationByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetConversationByUID != nil && afterGetConversationByUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetConversationByUID")
	}

	if !m.GetConversationByUIDMock.invocationsDone() && afterGetConversationByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetConversationByUID but found %d calls",
			mm_atomic.LoadUint64(&m.GetConversationByUIDMock.expectedInvocations), afterGetConversationByUIDCounter)
	}
}

type mRepositoryIMockGetConvertedFileByFileUID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetConvertedFileByFileUIDExpectation
	expectations       []*RepositoryIMockGetConvertedFileByFileUIDExpectation

	callArgs []*RepositoryIMockGetConvertedFileByFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetConvertedFileByFileUIDExpectation specifies expectation struct of the RepositoryI.GetConvertedFileByFileUID
type RepositoryIMockGetConvertedFileByFileUIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetConvertedFileByFileUIDParams
	paramPtrs *RepositoryIMockGetConvertedFileByFileUIDParamPtrs
	results   *RepositoryIMockGetConvertedFileByFileUIDResults
	Counter   uint64
}

// RepositoryIMockGetConvertedFileByFileUIDParams contains parameters of the RepositoryI.GetConvertedFileByFileUID
type RepositoryIMockGetConvertedFileByFileUIDParams struct {
	ctx     context.Context
	fileUID uuid.UUID
}

// RepositoryIMockGetConvertedFileByFileUIDParamPtrs contains pointers to parameters of the RepositoryI.GetConvertedFileByFileUID
type RepositoryIMockGetConvertedFileByFileUIDParamPtrs struct {
	ctx     *context.Context
	fileUID *uuid.UUID
}

// RepositoryIMockGetConvertedFileByFileUIDResults contains results of the RepositoryI.GetConvertedFileByFileUID
type RepositoryIMockGetConvertedFileByFileUIDResults struct {
	cp1 *mm_repository.ConvertedFile
	err error
}

// Expect sets up expected params for RepositoryI.GetConvertedFileByFileUID
func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) Expect(ctx context.Context, fileUID uuid.UUID) *mRepositoryIMockGetConvertedFileByFileUID {
	if mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.GetConvertedFileByFileUID mock is already set by Set")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation == nil {
		mmGetConvertedFileByFileUID.defaultExpectation = &RepositoryIMockGetConvertedFileByFileUIDExpectation{}
	}

	if mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.GetConvertedFileByFileUID mock is already set by ExpectParams functions")
	}

	mmGetConvertedFileByFileUID.defaultExpectation.params = &RepositoryIMockGetConvertedFileByFileUIDParams{ctx, fileUID}
	for _, e := range mmGetConvertedFileByFileUID.expectations {
		if minimock.Equal(e.params, mmGetConvertedFileByFileUID.defaultExpectation.params) {
			mmGetConvertedFileByFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetConvertedFileByFileUID.defaultExpectation.params)
		}
	}

	return mmGetConvertedFileByFileUID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetConvertedFileByFileUID
func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetConvertedFileByFileUID {
	if mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.GetConvertedFileByFileUID mock is already set by Set")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation == nil {
		mmGetConvertedFileByFileUID.defaultExpectation = &RepositoryIMockGetConvertedFileByFileUIDExpectation{}
	}

	if mmGetConvertedFileByFileUID.defaultExpectation.params != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.GetConvertedFileByFileUID mock is already set by Expect")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs = &RepositoryIMockGetConvertedFileByFileUIDParamPtrs{}
	}
	mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetConvertedFileByFileUID
}

// ExpectFileUIDParam2 sets up expected param fileUID for RepositoryI.GetConvertedFileByFileUID
func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) ExpectFileUIDParam2(fileUID uuid.UUID) *mRepositoryIMockGetConvertedFileByFileUID {
	if mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.GetConvertedFileByFileUID mock is already set by Set")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation == nil {
		mmGetConvertedFileByFileUID.defaultExpectation = &RepositoryIMockGetConvertedFileByFileUIDExpectation{}
	}

	if mmGetConvertedFileByFileUID.defaultExpectation.params != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.GetConvertedFileByFileUID mock is already set by Expect")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs = &RepositoryIMockGetConvertedFileByFileUIDParamPtrs{}
	}
	mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs.fileUID = &fileUID

	return mmGetConvertedFileByFileUID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetConvertedFileByFileUID
func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) Inspect(f func(ctx context.Context, fileUID uuid.UUID)) *mRepositoryIMockGetConvertedFileByFileUID {
	if mmGetConvertedFileByFileUID.mock.inspectFuncGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetConvertedFileByFileUID")
	}

	mmGetConvertedFileByFileUID.mock.inspectFuncGetConvertedFileByFileUID = f

	return mmGetConvertedFileByFileUID
}

// Return sets up results that will be returned by RepositoryI.GetConvertedFileByFileUID
func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) Return(cp1 *mm_repository.ConvertedFile, err error) *RepositoryIMock {
	if mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.GetConvertedFileByFileUID mock is already set by Set")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation == nil {
		mmGetConvertedFileByFileUID.defaultExpectation = &RepositoryIMockGetConvertedFileByFileUIDExpectation{mock: mmGetConvertedFileByFileUID.mock}
	}
	mmGetConvertedFileByFileUID.defaultExpectation.results = &RepositoryIMockGetConvertedFileByFileUIDResults{cp1, err}
	return mmGetConvertedFileByFileUID.mock
}

// Set uses given function f to mock the RepositoryI.GetConvertedFileByFileUID method
func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) Set(f func(ctx context.Context, fileUID uuid.UUID) (cp1 *mm_repository.ConvertedFile, err error)) *RepositoryIMock {
	if mmGetConvertedFileByFileUID.defaultExpectation != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetConvertedFileByFileUID method")
	}

	if len(mmGetConvertedFileByFileUID.expectations) > 0 {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetConvertedFileByFileUID method")
	}

	mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID = f
	return mmGetConvertedFileByFileUID.mock
}

// When sets expectation for the RepositoryI.GetConvertedFileByFileUID which will trigger the result defined by the following
// Then helper
func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) When(ctx context.Context, fileUID uuid.UUID) *RepositoryIMockGetConvertedFileByFileUIDExpectation {
	if mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.GetConvertedFileByFileUID mock is already set by Set")
	}

	expectation := &RepositoryIMockGetConvertedFileByFileUIDExpectation{
		mock:   mmGetConvertedFileByFileUID.mock,
		params: &RepositoryIMockGetConvertedFileByFileUIDParams{ctx, fileUID},
	}
	mmGetConvertedFileByFileUID.expectations = append(mmGetConvertedFileByFileUID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetConvertedFileByFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetConvertedFileByFileUIDExpectation) Then(cp1 *mm_repository.ConvertedFile, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetConvertedFileByFileUIDResults{cp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetConvertedFileByFileUID should be invoked
func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) Times(n uint64) *mRepositoryIMockGetConvertedFileByFileUID {
	if n == 0 {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("Times of RepositoryIMock.GetConvertedFileByFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetConvertedFileByFileUID.expectedInvocations, n)
	return mmGetConvertedFileByFileUID
}

func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) invocationsDone() bool {
	if len(mmGetConvertedFileByFileUID.expectations) == 0 && mmGetConvertedFileByFileUID.defaultExpectation == nil && mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetConvertedFileByFileUID.mock.afterGetConvertedFileByFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetConvertedFileByFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetConvertedFileByFileUID implements repository.RepositoryI
func (mmGetConvertedFileByFileUID *RepositoryIMock) GetConvertedFileByFileUID(ctx context.Context, fileUID uuid.UUID) (cp1 *mm_repository.ConvertedFile, err error) {
	mm_atomic.AddUint64(&mmGetConvertedFileByFileUID.beforeGetConvertedFileByFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetConvertedFileByFileUID.afterGetConvertedFileByFileUIDCounter, 1)

	if mmGetConvertedFileByFileUID.inspectFuncGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.inspectFuncGetConvertedFileByFileUID(ctx, fileUID)
	}

	mm_params := RepositoryIMockGetConvertedFileByFileUIDParams{ctx, fileUID}

	// Record call args
	mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.mutex.Lock()
	mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.callArgs = append(mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.callArgs, &mm_params)
	mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.mutex.Unlock()

	for _, e := range mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetConvertedFileByFileUIDParams{ctx, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetConvertedFileByFileUID.t.Errorf("RepositoryIMock.GetConvertedFileByFileUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmGetConvertedFileByFileUID.t.Errorf("RepositoryIMock.GetConvertedFileByFileUID got unexpected parameter fileUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetConvertedFileByFileUID.t.Errorf("RepositoryIMock.GetConvertedFileByFileUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetConvertedFileByFileUID.t.Fatal("No results are set for the RepositoryIMock.GetConvertedFileByFileUID")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetConvertedFileByFileUID.funcGetConvertedFileByFileUID != nil {
		return mmGetConvertedFileByFileUID.funcGetConvertedFileByFileUID(ctx, fileUID)
	}
	mmGetConvertedFileByFileUID.t.Fatalf("Unexpected call to RepositoryIMock.GetConvertedFileByFileUID. %v %v", ctx, fileUID)
	return
}

// GetConvertedFileByFileUIDAfterCounter returns a count of finished RepositoryIMock.GetConvertedFileByFileUID invocations
func (mmGetConvertedFileByFileUID *RepositoryIMock) GetConvertedFileByFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConvertedFileByFileUID.afterGetConvertedFileByFileUIDCounter)
}

// GetConvertedFileByFileUIDBeforeCounter returns a count of RepositoryIMock.GetConvertedFileByFileUID invocations
func (mmGetConvertedFileByFileUID *RepositoryIMock) GetConvertedFileByFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConvertedFileByFileUID.beforeGetConvertedFileByFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetConvertedFileByFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) Calls() []*RepositoryIMockGetConvertedFileByFileUIDParams {
	mmGetConvertedFileByFileUID.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetConvertedFileByFileUIDParams, len(mmGetConvertedFileByFileUID.callArgs))
	copy(argCopy, mmGetConvertedFileByFileUID.callArgs)

	mmGetConvertedFileByFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetConvertedFileByFileUIDDone returns true if the count of the GetConvertedFileByFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetConvertedFileByFileUIDDone() bool {
	for _, e := range m.GetConvertedFileByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetConvertedFileByFileUIDMock.invocationsDone()
}

// MinimockGetConvertedFileByFileUIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetConvertedFileByFileUIDInspect() {
	for _, e := range m.GetConvertedFileByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetConvertedFileByFileUID with params: %#v", *e.params)
		}
	}

	afterGetConvertedFileByFileUIDCounter := mm_atomic.LoadUint64(&m.afterGetConvertedFileByFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetConvertedFileByFileUIDMock.defaultExpectation != nil && afterGetConvertedFileByFileUIDCounter < 1 {
		if m.GetConvertedFileByFileUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetConvertedFileByFileUID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetConvertedFileByFileUID with params: %#v", *m.GetConvertedFileByFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetConvertedFileByFileUID != nil && afterGetConvertedFileByFileUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetConvertedFileByFileUID")
	}

	if !m.GetConvertedFileByFileUIDMock.invocationsDone() && afterGetConvertedFileByFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetConvertedFileByFileUID but found %d calls",
			mm_atomic.LoadUint64(&m.GetConvertedFileByFileUIDMock.expectedInvocations), afterGetConvertedFileByFileUIDCounter)
	}
}

type mRepositoryIMockGetCountFilesByListKnowledgeBaseUID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetCountFilesByListKnowledgeBaseUIDExpectation
	expectations       []*RepositoryIMockGetCountFilesByListKnowledgeBaseUIDExpectation

	callArgs []*RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetCountFilesByListKnowledgeBaseUIDExpectation specifies expectation struct of the RepositoryI.GetCountFilesByListKnowledgeBaseUID
type RepositoryIMockGetCountFilesByListKnowledgeBaseUIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParams
	paramPtrs *RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParamPtrs
	results   *RepositoryIMockGetCountFilesByListKnowledgeBaseUIDResults
	Counter   uint64
}

// RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParams contains parameters of the RepositoryI.GetCountFilesByListKnowledgeBaseUID
type RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParams struct {
	ctx    context.Context
	kbUIDs []mm_repository.KbUID
}

// RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParamPtrs contains pointers to parameters of the RepositoryI.GetCountFilesByListKnowledgeBaseUID
type RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParamPtrs struct {
	ctx    *context.Context
	kbUIDs *[]mm_repository.KbUID
}

// RepositoryIMockGetCountFilesByListKnowledgeBaseUIDResults contains results of the RepositoryI.GetCountFilesByListKnowledgeBaseUID
type RepositoryIMockGetCountFilesByListKnowledgeBaseUIDResults struct {
	m1  map[mm_repository.KbUID]int64
	err error
}

// Expect sets up expected params for RepositoryI.GetCountFilesByListKnowledgeBaseUID
func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID) Expect(ctx context.Context, kbUIDs []mm_repository.KbUID) *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID {
	if mmGetCountFilesByListKnowledgeBaseUID.mock.funcGetCountFilesByListKnowledgeBaseUID != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("RepositoryIMock.GetCountFilesByListKnowledgeBaseUID mock is already set by Set")
	}

	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation == nil {
		mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation = &RepositoryIMockGetCountFilesByListKnowledgeBaseUIDExpectation{}
	}

	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.paramPtrs != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("RepositoryIMock.GetCountFilesByListKnowledgeBaseUID mock is already set by ExpectParams functions")
	}

	mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.params = &RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParams{ctx, kbUIDs}
	for _, e := range mmGetCountFilesByListKnowledgeBaseUID.expectations {
		if minimock.Equal(e.params, mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.params) {
			mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.params)
		}
	}

	return mmGetCountFilesByListKnowledgeBaseUID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetCountFilesByListKnowledgeBaseUID
func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID {
	if mmGetCountFilesByListKnowledgeBaseUID.mock.funcGetCountFilesByListKnowledgeBaseUID != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("RepositoryIMock.GetCountFilesByListKnowledgeBaseUID mock is already set by Set")
	}

	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation == nil {
		mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation = &RepositoryIMockGetCountFilesByListKnowledgeBaseUIDExpectation{}
	}

	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.params != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("RepositoryIMock.GetCountFilesByListKnowledgeBaseUID mock is already set by Expect")
	}

	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.paramPtrs == nil {
		mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.paramPtrs = &RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParamPtrs{}
	}
	mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetCountFilesByListKnowledgeBaseUID
}

// ExpectKbUIDsParam2 sets up expected param kbUIDs for RepositoryI.GetCountFilesByListKnowledgeBaseUID
func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID) ExpectKbUIDsParam2(kbUIDs []mm_repository.KbUID) *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID {
	if mmGetCountFilesByListKnowledgeBaseUID.mock.funcGetCountFilesByListKnowledgeBaseUID != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("RepositoryIMock.GetCountFilesByListKnowledgeBaseUID mock is already set by Set")
	}

	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation == nil {
		mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation = &RepositoryIMockGetCountFilesByListKnowledgeBaseUIDExpectation{}
	}

	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.params != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("RepositoryIMock.GetCountFilesByListKnowledgeBaseUID mock is already set by Expect")
	}

	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.paramPtrs == nil {
		mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.paramPtrs = &RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParamPtrs{}
	}
	mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.paramPtrs.kbUIDs = &kbUIDs

	return mmGetCountFilesByListKnowledgeBaseUID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetCountFilesByListKnowledgeBaseUID
func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID) Inspect(f func(ctx context.Context, kbUIDs []mm_repository.KbUID)) *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID {
	if mmGetCountFilesByListKnowledgeBaseUID.mock.inspectFuncGetCountFilesByListKnowledgeBaseUID != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetCountFilesByListKnowledgeBaseUID")
	}

	mmGetCountFilesByListKnowledgeBaseUID.mock.inspectFuncGetCountFilesByListKnowledgeBaseUID = f

	return mmGetCountFilesByListKnowledgeBaseUID
}

// Return sets up results that will be returned by RepositoryI.GetCountFilesByListKnowledgeBaseUID
func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID) Return(m1 map[mm_repository.KbUID]int64, err error) *RepositoryIMock {
	if mmGetCountFilesByListKnowledgeBaseUID.mock.funcGetCountFilesByListKnowledgeBaseUID != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("RepositoryIMock.GetCountFilesByListKnowledgeBaseUID mock is already set by Set")
	}

	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation == nil {
		mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation = &RepositoryIMockGetCountFilesByListKnowledgeBaseUIDExpectation{mock: mmGetCountFilesByListKnowledgeBaseUID.mock}
	}
	mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.results = &RepositoryIMockGetCountFilesByListKnowledgeBaseUIDResults{m1, err}
	return mmGetCountFilesByListKnowledgeBaseUID.mock
}

// Set uses given function f to mock the RepositoryI.GetCountFilesByListKnowledgeBaseUID method
func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID) Set(f func(ctx context.Context, kbUIDs []mm_repository.KbUID) (m1 map[mm_repository.KbUID]int64, err error)) *RepositoryIMock {
	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetCountFilesByListKnowledgeBaseUID method")
	}

	if len(mmGetCountFilesByListKnowledgeBaseUID.expectations) > 0 {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetCountFilesByListKnowledgeBaseUID method")
	}

	mmGetCountFilesByListKnowledgeBaseUID.mock.funcGetCountFilesByListKnowledgeBaseUID = f
	return mmGetCountFilesByListKnowledgeBaseUID.mock
}

// When sets expectation for the RepositoryI.GetCountFilesByListKnowledgeBaseUID which will trigger the result defined by the following
// Then helper
func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID) When(ctx context.Context, kbUIDs []mm_repository.KbUID) *RepositoryIMockGetCountFilesByListKnowledgeBaseUIDExpectation {
	if mmGetCountFilesByListKnowledgeBaseUID.mock.funcGetCountFilesByListKnowledgeBaseUID != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("RepositoryIMock.GetCountFilesByListKnowledgeBaseUID mock is already set by Set")
	}

	expectation := &RepositoryIMockGetCountFilesByListKnowledgeBaseUIDExpectation{
		mock:   mmGetCountFilesByListKnowledgeBaseUID.mock,
		params: &RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParams{ctx, kbUIDs},
	}
	mmGetCountFilesByListKnowledgeBaseUID.expectations = append(mmGetCountFilesByListKnowledgeBaseUID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetCountFilesByListKnowledgeBaseUID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetCountFilesByListKnowledgeBaseUIDExpectation) Then(m1 map[mm_repository.KbUID]int64, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetCountFilesByListKnowledgeBaseUIDResults{m1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetCountFilesByListKnowledgeBaseUID should be invoked
func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID) Times(n uint64) *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID {
	if n == 0 {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("Times of RepositoryIMock.GetCountFilesByListKnowledgeBaseUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCountFilesByListKnowledgeBaseUID.expectedInvocations, n)
	return mmGetCountFilesByListKnowledgeBaseUID
}

func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID) invocationsDone() bool {
	if len(mmGetCountFilesByListKnowledgeBaseUID.expectations) == 0 && mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation == nil && mmGetCountFilesByListKnowledgeBaseUID.mock.funcGetCountFilesByListKnowledgeBaseUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCountFilesByListKnowledgeBaseUID.mock.afterGetCountFilesByListKnowledgeBaseUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCountFilesByListKnowledgeBaseUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCountFilesByListKnowledgeBaseUID implements repository.RepositoryI
func (mmGetCountFilesByListKnowledgeBaseUID *RepositoryIMock) GetCountFilesByListKnowledgeBaseUID(ctx context.Context, kbUIDs []mm_repository.KbUID) (m1 map[mm_repository.KbUID]int64, err error) {
	mm_atomic.AddUint64(&mmGetCountFilesByListKnowledgeBaseUID.beforeGetCountFilesByListKnowledgeBaseUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCountFilesByListKnowledgeBaseUID.afterGetCountFilesByListKnowledgeBaseUIDCounter, 1)

	if mmGetCountFilesByListKnowledgeBaseUID.inspectFuncGetCountFilesByListKnowledgeBaseUID != nil {
		mmGetCountFilesByListKnowledgeBaseUID.inspectFuncGetCountFilesByListKnowledgeBaseUID(ctx, kbUIDs)
	}

	mm_params := RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParams{ctx, kbUIDs}

	// Record call args
	mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.mutex.Lock()
	mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.callArgs = append(mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.callArgs, &mm_params)
	mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.mutex.Unlock()

	for _, e := range mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParams{ctx, kbUIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCountFilesByListKnowledgeBaseUID.t.Errorf("RepositoryIMock.GetCountFilesByListKnowledgeBaseUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUIDs != nil && !minimock.Equal(*mm_want_ptrs.kbUIDs, mm_got.kbUIDs) {
				mmGetCountFilesByListKnowledgeBaseUID.t.Errorf("RepositoryIMock.GetCountFilesByListKnowledgeBaseUID got unexpected parameter kbUIDs, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbUIDs, mm_got.kbUIDs, minimock.Diff(*mm_want_ptrs.kbUIDs, mm_got.kbUIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCountFilesByListKnowledgeBaseUID.t.Errorf("RepositoryIMock.GetCountFilesByListKnowledgeBaseUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCountFilesByListKnowledgeBaseUID.t.Fatal("No results are set for the RepositoryIMock.GetCountFilesByListKnowledgeBaseUID")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetCountFilesByListKnowledgeBaseUID.funcGetCountFilesByListKnowledgeBaseUID != nil {
		return mmGetCountFilesByListKnowledgeBaseUID.funcGetCountFilesByListKnowledgeBaseUID(ctx, kbUIDs)
	}
	mmGetCountFilesByListKnowledgeBaseUID.t.Fatalf("Unexpected call to RepositoryIMock.GetCountFilesByListKnowledgeBaseUID. %v %v", ctx, kbUIDs)
	return
}

// GetCountFilesByListKnowledgeBaseUIDAfterCounter returns a count of finished RepositoryIMock.GetCountFilesByListKnowledgeBaseUID invocations
func (mmGetCountFilesByListKnowledgeBaseUID *RepositoryIMock) GetCountFilesByListKnowledgeBaseUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCountFilesByListKnowledgeBaseUID.afterGetCountFilesByListKnowledgeBaseUIDCounter)
}

// GetCountFilesByListKnowledgeBaseUIDBeforeCounter returns a count of RepositoryIMock.GetCountFilesByListKnowledgeBaseUID invocations
func (mmGetCountFilesByListKnowledgeBaseUID *RepositoryIMock) GetCountFilesByListKnowledgeBaseUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCountFilesByListKnowledgeBaseUID.beforeGetCountFilesByListKnowledgeBaseUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetCountFilesByListKnowledgeBaseUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID) Calls() []*RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParams {
	mmGetCountFilesByListKnowledgeBaseUID.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParams, len(mmGetCountFilesByListKnowledgeBaseUID.callArgs))
	copy(argCopy, mmGetCountFilesByListKnowledgeBaseUID.callArgs)

	mmGetCountFilesByListKnowledgeBaseUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetCountFilesByListKnowledgeBaseUIDDone returns true if the count of the GetCountFilesByListKnowledgeBaseUID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetCountFilesByListKnowledgeBaseUIDDone() bool {
	for _, e := range m.GetCountFilesByListKnowledgeBaseUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCountFilesByListKnowledgeBaseUIDMock.invocationsDone()
}

// MinimockGetCountFilesByListKnowledgeBaseUIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetCountFilesByListKnowledgeBaseUIDInspect() {
	for _, e := range m.GetCountFilesByListKnowledgeBaseUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetCountFilesByListKnowledgeBaseUID with params: %#v", *e.params)
		}
	}

	afterGetCountFilesByListKnowledgeBaseUIDCounter := mm_atomic.LoadUint64(&m.afterGetCountFilesByListKnowledgeBaseUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCountFilesByListKnowledgeBaseUIDMock.defaultExpectation != nil && afterGetCountFilesByListKnowledgeBaseUIDCounter < 1 {
		if m.GetCountFilesByListKnowledgeBaseUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetCountFilesByListKnowledgeBaseUID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetCountFilesByListKnowledgeBaseUID with params: %#v", *m.GetCountFilesByListKnowledgeBaseUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCountFilesByListKnowledgeBaseUID != nil && afterGetCountFilesByListKnowledgeBaseUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetCountFilesByListKnowledgeBaseUID")
	}

	if !m.GetCountFilesByListKnowledgeBaseUIDMock.invocationsDone() && afterGetCountFilesByListKnowledgeBaseUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetCountFilesByListKnowledgeBaseUID but found %d calls",
			mm_atomic.LoadUint64(&m.GetCountFilesByListKnowledgeBaseUIDMock.expectedInvocations), afterGetCountFilesByListKnowledgeBaseUIDCounter)
	}
}

type mRepositoryIMockGetEmbeddingByUIDs struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetEmbeddingByUIDsExpectation
	expectations       []*RepositoryIMockGetEmbeddingByUIDsExpectation

	callArgs []*RepositoryIMockGetEmbeddingByUIDsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetEmbeddingByUIDsExpectation specifies expectation struct of the RepositoryI.GetEmbeddingByUIDs
type RepositoryIMockGetEmbeddingByUIDsExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetEmbeddingByUIDsParams
	paramPtrs *RepositoryIMockGetEmbeddingByUIDsParamPtrs
	results   *RepositoryIMockGetEmbeddingByUIDsResults
	Counter   uint64
}

// RepositoryIMockGetEmbeddingByUIDsParams contains parameters of the RepositoryI.GetEmbeddingByUIDs
type RepositoryIMockGetEmbeddingByUIDsParams struct {
	ctx     context.Context
	embUIDs []uuid.UUID
}

// RepositoryIMockGetEmbeddingByUIDsParamPtrs contains pointers to parameters of the RepositoryI.GetEmbeddingByUIDs
type RepositoryIMockGetEmbeddingByUIDsParamPtrs struct {
	ctx     *context.Context
	embUIDs *[]uuid.UUID
}

// RepositoryIMockGetEmbeddingByUIDsResults contains results of the RepositoryI.GetEmbeddingByUIDs
type RepositoryIMockGetEmbeddingByUIDsResults struct {
	ea1 []mm_repository.Embedding
	err error
}

// Expect sets up expected params for RepositoryI.GetEmbeddingByUIDs
func (mmGetEmbeddingByUIDs *mRepositoryIMockGetEmbeddingByUIDs) Expect(ctx context.Context, embUIDs []uuid.UUID) *mRepositoryIMockGetEmbeddingByUIDs {
	if mmGetEmbeddingByUIDs.mock.funcGetEmbeddingByUIDs != nil {
		mmGetEmbeddingByUIDs.mock.t.Fatalf("RepositoryIMock.GetEmbeddingByUIDs mock is already set by Set")
	}

	if mmGetEmbeddingByUIDs.defaultExpectation == nil {
		mmGetEmbeddingByUIDs.defaultExpectation = &RepositoryIMockGetEmbeddingByUIDsExpectation{}
	}

	if mmGetEmbeddingByUIDs.defaultExpectation.paramPtrs != nil {
		mmGetEmbeddingByUIDs.mock.t.Fatalf("RepositoryIMock.GetEmbeddingByUIDs mock is already set by ExpectParams functions")
	}

	mmGetEmbeddingByUIDs.defaultExpectation.params = &RepositoryIMockGetEmbeddingByUIDsParams{ctx, embUIDs}
	for _, e := range mmGetEmbeddingByUIDs.expectations {
		if minimock.Equal(e.params, mmGetEmbeddingByUIDs.defaultExpectation.params) {
			mmGetEmbeddingByUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetEmbeddingByUIDs.defaultExpectation.params)
		}
	}

	return mmGetEmbeddingByUIDs
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetEmbeddingByUIDs
func (mmGetEmbeddingByUIDs *mRepositoryIMockGetEmbeddingByUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetEmbeddingByUIDs {
	if mmGetEmbeddingByUIDs.mock.funcGetEmbeddingByUIDs != nil {
		mmGetEmbeddingByUIDs.mock.t.Fatalf("RepositoryIMock.GetEmbeddingByUIDs mock is already set by Set")
	}

	if mmGetEmbeddingByUIDs.defaultExpectation == nil {
		mmGetEmbeddingByUIDs.defaultExpectation = &RepositoryIMockGetEmbeddingByUIDsExpectation{}
	}

	if mmGetEmbeddingByUIDs.defaultExpectation.params != nil {
		mmGetEmbeddingByUIDs.mock.t.Fatalf("RepositoryIMock.GetEmbeddingByUIDs mock is already set by Expect")
	}

	if mmGetEmbeddingByUIDs.defaultExpectation.paramPtrs == nil {
		mmGetEmbeddingByUIDs.defaultExpectation.paramPtrs = &RepositoryIMockGetEmbeddingByUIDsParamPtrs{}
	}
	mmGetEmbeddingByUIDs.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetEmbeddingByUIDs
}

// ExpectEmbUIDsParam2 sets up expected param embUIDs for RepositoryI.GetEmbeddingByUIDs
func (mmGetEmbeddingByUIDs *mRepositoryIMockGetEmbeddingByUIDs) ExpectEmbUIDsParam2(embUIDs []uuid.UUID) *mRepositoryIMockGetEmbeddingByUIDs {
	if mmGetEmbeddingByUIDs.mock.funcGetEmbeddingByUIDs != nil {
		mmGetEmbeddingByUIDs.mock.t.Fatalf("RepositoryIMock.GetEmbeddingByUIDs mock is already set by Set")
	}

	if mmGetEmbeddingByUIDs.defaultExpectation == nil {
		mmGetEmbeddingByUIDs.defaultExpectation = &RepositoryIMockGetEmbeddingByUIDsExpectation{}
	}

	if mmGetEmbeddingByUIDs.defaultExpectation.params != nil {
		mmGetEmbeddingByUIDs.mock.t.Fatalf("RepositoryIMock.GetEmbeddingByUIDs mock is already set by Expect")
	}

	if mmGetEmbeddingByUIDs.defaultExpectation.paramPtrs == nil {
		mmGetEmbeddingByUIDs.defaultExpectation.paramPtrs = &RepositoryIMockGetEmbeddingByUIDsParamPtrs{}
	}
	mmGetEmbeddingByUIDs.defaultExpectation.paramPtrs.embUIDs = &embUIDs

	return mmGetEmbeddingByUIDs
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetEmbeddingByUIDs
func (mmGetEmbeddingByUIDs *mRepositoryIMockGetEmbeddingByUIDs) Inspect(f func(ctx context.Context, embUIDs []uuid.UUID)) *mRepositoryIMockGetEmbeddingByUIDs {
	if mmGetEmbeddingByUIDs.mock.inspectFuncGetEmbeddingByUIDs != nil {
		mmGetEmbeddingByUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetEmbeddingByUIDs")
	}

	mmGetEmbeddingByUIDs.mock.inspectFuncGetEmbeddingByUIDs = f

	return mmGetEmbeddingByUIDs
}

// Return sets up results that will be returned by RepositoryI.GetEmbeddingByUIDs
func (mmGetEmbeddingByUIDs *mRepositoryIMockGetEmbeddingByUIDs) Return(ea1 []mm_repository.Embedding, err error) *RepositoryIMock {
	if mmGetEmbeddingByUIDs.mock.funcGetEmbeddingByUIDs != nil {
		mmGetEmbeddingByUIDs.mock.t.Fatalf("RepositoryIMock.GetEmbeddingByUIDs mock is already set by Set")
	}

	if mmGetEmbeddingByUIDs.defaultExpectation == nil {
		mmGetEmbeddingByUIDs.defaultExpectation = &RepositoryIMockGetEmbeddingByUIDsExpectation{mock: mmGetEmbeddingByUIDs.mock}
	}
	mmGetEmbeddingByUIDs.defaultExpectation.results = &RepositoryIMockGetEmbeddingByUIDsResults{ea1, err}
	return mmGetEmbeddingByUIDs.mock
}

// Set uses given function f to mock the RepositoryI.GetEmbeddingByUIDs method
func (mmGetEmbeddingByUIDs *mRepositoryIMockGetEmbeddingByUIDs) Set(f func(ctx context.Context, embUIDs []uuid.UUID) (ea1 []mm_repository.Embedding, err error)) *RepositoryIMock {
	if mmGetEmbeddingByUIDs.defaultExpectation != nil {
		mmGetEmbeddingByUIDs.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetEmbeddingByUIDs method")
	}

	if len(mmGetEmbeddingByUIDs.expectations) > 0 {
		mmGetEmbeddingByUIDs.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetEmbeddingByUIDs method")
	}

	mmGetEmbeddingByUIDs.mock.funcGetEmbeddingByUIDs = f
	return mmGetEmbeddingByUIDs.mock
}

// When sets expectation for the RepositoryI.GetEmbeddingByUIDs which will trigger the result defined by the following
// Then helper
func (mmGetEmbeddingByUIDs *mRepositoryIMockGetEmbeddingByUIDs) When(ctx context.Context, embUIDs []uuid.UUID) *RepositoryIMockGetEmbeddingByUIDsExpectation {
	if mmGetEmbeddingByUIDs.mock.funcGetEmbeddingByUIDs != nil {
		mmGetEmbeddingByUIDs.mock.t.Fatalf("RepositoryIMock.GetEmbeddingByUIDs mock is already set by Set")
	}

	expectation := &RepositoryIMockGetEmbeddingByUIDsExpectation{
		mock:   mmGetEmbeddingByUIDs.mock,
		params: &RepositoryIMockGetEmbeddingByUIDsParams{ctx, embUIDs},
	}
	mmGetEmbeddingByUIDs.expectations = append(mmGetEmbeddingByUIDs.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetEmbeddingByUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetEmbeddingByUIDsExpectation) Then(ea1 []mm_repository.Embedding, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetEmbeddingByUIDsResults{ea1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetEmbeddingByUIDs should be invoked
func (mmGetEmbeddingByUIDs *mRepositoryIMockGetEmbeddingByUIDs) Times(n uint64) *mRepositoryIMockGetEmbeddingByUIDs {
	if n == 0 {
		mmGetEmbeddingByUIDs.mock.t.Fatalf("Times of RepositoryIMock.GetEmbeddingByUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetEmbeddingByUIDs.expectedInvocations, n)
	return mmGetEmbeddingByUIDs
}

func (mmGetEmbeddingByUIDs *mRepositoryIMockGetEmbeddingByUIDs) invocationsDone() bool {
	if len(mmGetEmbeddingByUIDs.expectations) == 0 && mmGetEmbeddingByUIDs.defaultExpectation == nil && mmGetEmbeddingByUIDs.mock.funcGetEmbeddingByUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetEmbeddingByUIDs.mock.afterGetEmbeddingByUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetEmbeddingByUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetEmbeddingByUIDs implements repository.RepositoryI
func (mmGetEmbeddingByUIDs *RepositoryIMock) GetEmbeddingByUIDs(ctx context.Context, embUIDs []uuid.UUID) (ea1 []mm_repository.Embedding, err error) {
	mm_atomic.AddUint64(&mmGetEmbeddingByUIDs.beforeGetEmbeddingByUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetEmbeddingByUIDs.afterGetEmbeddingByUIDsCounter, 1)

	if mmGetEmbeddingByUIDs.inspectFuncGetEmbeddingByUIDs != nil {
		mmGetEmbeddingByUIDs.inspectFuncGetEmbeddingByUIDs(ctx, embUIDs)
	}

	mm_params := RepositoryIMockGetEmbeddingByUIDsParams{ctx, embUIDs}

	// Record call args
	mmGetEmbeddingByUIDs.GetEmbeddingByUIDsMock.mutex.Lock()
	mmGetEmbeddingByUIDs.GetEmbeddingByUIDsMock.callArgs = append(mmGetEmbeddingByUIDs.GetEmbeddingByUIDsMock.callArgs, &mm_params)
	mmGetEmbeddingByUIDs.GetEmbeddingByUIDsMock.mutex.Unlock()

	for _, e := range mmGetEmbeddingByUIDs.GetEmbeddingByUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1, e.results.err
		}
	}

	if mmGetEmbeddingByUIDs.GetEmbeddingByUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetEmbeddingByUIDs.GetEmbeddingByUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetEmbeddingByUIDs.GetEmbeddingByUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmGetEmbeddingByUIDs.GetEmbeddingByUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetEmbeddingByUIDsParams{ctx, embUIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetEmbeddingByUIDs.t.Errorf("RepositoryIMock.GetEmbeddingByUIDs got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.embUIDs != nil && !minimock.Equal(*mm_want_ptrs.embUIDs, mm_got.embUIDs) {
				mmGetEmbeddingByUIDs.t.Errorf("RepositoryIMock.GetEmbeddingByUIDs got unexpected parameter embUIDs, want: %#v, got: %#v%s\n", *mm_want_ptrs.embUIDs, mm_got.embUIDs, minimock.Diff(*mm_want_ptrs.embUIDs, mm_got.embUIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetEmbeddingByUIDs.t.Errorf("RepositoryIMock.GetEmbeddingByUIDs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetEmbeddingByUIDs.GetEmbeddingByUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetEmbeddingByUIDs.t.Fatal("No results are set for the RepositoryIMock.GetEmbeddingByUIDs")
		}
		return (*mm_results).ea1, (*mm_results).err
	}
	if mmGetEmbeddingByUIDs.funcGetEmbeddingByUIDs != nil {
		return mmGetEmbeddingByUIDs.funcGetEmbeddingByUIDs(ctx, embUIDs)
	}
	mmGetEmbeddingByUIDs.t.Fatalf("Unexpected call to RepositoryIMock.GetEmbeddingByUIDs. %v %v", ctx, embUIDs)
	return
}

// GetEmbeddingByUIDsAfterCounter returns a count of finished RepositoryIMock.GetEmbeddingByUIDs invocations
func (mmGetEmbeddingByUIDs *RepositoryIMock) GetEmbeddingByUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEmbeddingByUIDs.afterGetEmbeddingByUIDsCounter)
}

// GetEmbeddingByUIDsBeforeCounter returns a count of RepositoryIMock.GetEmbeddingByUIDs invocations
func (mmGetEmbeddingByUIDs *RepositoryIMock) GetEmbeddingByUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEmbeddingByUIDs.beforeGetEmbeddingByUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetEmbeddingByUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetEmbeddingByUIDs *mRepositoryIMockGetEmbeddingByUIDs) Calls() []*RepositoryIMockGetEmbeddingByUIDsParams {
	mmGetEmbeddingByUIDs.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetEmbeddingByUIDsParams, len(mmGetEmbeddingByUIDs.callArgs))
	copy(argCopy, mmGetEmbeddingByUIDs.callArgs)

	mmGetEmbeddingByUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockGetEmbeddingByUIDsDone returns true if the count of the GetEmbeddingByUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetEmbeddingByUIDsDone() bool {
	for _, e := range m.GetEmbeddingByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetEmbeddingByUIDsMock.invocationsDone()
}

// MinimockGetEmbeddingByUIDsInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetEmbeddingByUIDsInspect() {
	for _, e := range m.GetEmbeddingByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetEmbeddingByUIDs with params: %#v", *e.params)
		}
	}

	afterGetEmbeddingByUIDsCounter := mm_atomic.LoadUint64(&m.afterGetEmbeddingByUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetEmbeddingByUIDsMock.defaultExpectation != nil && afterGetEmbeddingByUIDsCounter < 1 {
		if m.GetEmbeddingByUIDsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetEmbeddingByUIDs")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetEmbeddingByUIDs with params: %#v", *m.GetEmbeddingByUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetEmbeddingByUIDs != nil && afterGetEmbeddingByUIDsCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetEmbeddingByUIDs")
	}

	if !m.GetEmbeddingByUIDsMock.invocationsDone() && afterGetEmbeddingByUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetEmbeddingByUIDs but found %d calls",
			mm_atomic.LoadUint64(&m.GetEmbeddingByUIDsMock.expectedInvocations), afterGetEmbeddingByUIDsCounter)
	}
}

type mRepositoryIMockGetFilesTotalTokens struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetFilesTotalTokensExpectation
	expectations       []*RepositoryIMockGetFilesTotalTokensExpectation

	callArgs []*RepositoryIMockGetFilesTotalTokensParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetFilesTotalTokensExpectation specifies expectation struct of the RepositoryI.GetFilesTotalTokens
type RepositoryIMockGetFilesTotalTokensExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetFilesTotalTokensParams
	paramPtrs *RepositoryIMockGetFilesTotalTokensParamPtrs
	results   *RepositoryIMockGetFilesTotalTokensResults
	Counter   uint64
}

// RepositoryIMockGetFilesTotalTokensParams contains parameters of the RepositoryI.GetFilesTotalTokens
type RepositoryIMockGetFilesTotalTokensParams struct {
	ctx     context.Context
	sources map[mm_repository.FileUID]struct {
		SourceTable mm_repository.SourceTable
		SourceUID   mm_repository.SourceUID
	}
}

// RepositoryIMockGetFilesTotalTokensParamPtrs contains pointers to parameters of the RepositoryI.GetFilesTotalTokens
type RepositoryIMockGetFilesTotalTokensParamPtrs struct {
	ctx     *context.Context
	sources *map[mm_repository.FileUID]struct {
		SourceTable mm_repository.SourceTable
		SourceUID   mm_repository.SourceUID
	}
}

// RepositoryIMockGetFilesTotalTokensResults contains results of the RepositoryI.GetFilesTotalTokens
type RepositoryIMockGetFilesTotalTokensResults struct {
	m1  map[mm_repository.FileUID]int
	err error
}

// Expect sets up expected params for RepositoryI.GetFilesTotalTokens
func (mmGetFilesTotalTokens *mRepositoryIMockGetFilesTotalTokens) Expect(ctx context.Context, sources map[mm_repository.FileUID]struct {
	SourceTable mm_repository.SourceTable
	SourceUID   mm_repository.SourceUID
}) *mRepositoryIMockGetFilesTotalTokens {
	if mmGetFilesTotalTokens.mock.funcGetFilesTotalTokens != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryIMock.GetFilesTotalTokens mock is already set by Set")
	}

	if mmGetFilesTotalTokens.defaultExpectation == nil {
		mmGetFilesTotalTokens.defaultExpectation = &RepositoryIMockGetFilesTotalTokensExpectation{}
	}

	if mmGetFilesTotalTokens.defaultExpectation.paramPtrs != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryIMock.GetFilesTotalTokens mock is already set by ExpectParams functions")
	}

	mmGetFilesTotalTokens.defaultExpectation.params = &RepositoryIMockGetFilesTotalTokensParams{ctx, sources}
	for _, e := range mmGetFilesTotalTokens.expectations {
		if minimock.Equal(e.params, mmGetFilesTotalTokens.defaultExpectation.params) {
			mmGetFilesTotalTokens.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFilesTotalTokens.defaultExpectation.params)
		}
	}

	return mmGetFilesTotalTokens
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetFilesTotalTokens
func (mmGetFilesTotalTokens *mRepositoryIMockGetFilesTotalTokens) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetFilesTotalTokens {
	if mmGetFilesTotalTokens.mock.funcGetFilesTotalTokens != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryIMock.GetFilesTotalTokens mock is already set by Set")
	}

	if mmGetFilesTotalTokens.defaultExpectation == nil {
		mmGetFilesTotalTokens.defaultExpectation = &RepositoryIMockGetFilesTotalTokensExpectation{}
	}

	if mmGetFilesTotalTokens.defaultExpectation.params != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryIMock.GetFilesTotalTokens mock is already set by Expect")
	}

	if mmGetFilesTotalTokens.defaultExpectation.paramPtrs == nil {
		mmGetFilesTotalTokens.defaultExpectation.paramPtrs = &RepositoryIMockGetFilesTotalTokensParamPtrs{}
	}
	mmGetFilesTotalTokens.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetFilesTotalTokens
}

// ExpectSourcesParam2 sets up expected param sources for RepositoryI.GetFilesTotalTokens
func (mmGetFilesTotalTokens *mRepositoryIMockGetFilesTotalTokens) ExpectSourcesParam2(sources map[mm_repository.FileUID]struct {
	SourceTable mm_repository.SourceTable
	SourceUID   mm_repository.SourceUID
}) *mRepositoryIMockGetFilesTotalTokens {
	if mmGetFilesTotalTokens.mock.funcGetFilesTotalTokens != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryIMock.GetFilesTotalTokens mock is already set by Set")
	}

	if mmGetFilesTotalTokens.defaultExpectation == nil {
		mmGetFilesTotalTokens.defaultExpectation = &RepositoryIMockGetFilesTotalTokensExpectation{}
	}

	if mmGetFilesTotalTokens.defaultExpectation.params != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryIMock.GetFilesTotalTokens mock is already set by Expect")
	}

	if mmGetFilesTotalTokens.defaultExpectation.paramPtrs == nil {
		mmGetFilesTotalTokens.defaultExpectation.paramPtrs = &RepositoryIMockGetFilesTotalTokensParamPtrs{}
	}
	mmGetFilesTotalTokens.defaultExpectation.paramPtrs.sources = &sources

	return mmGetFilesTotalTokens
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetFilesTotalTokens
func (mmGetFilesTotalTokens *mRepositoryIMockGetFilesTotalTokens) Inspect(f func(ctx context.Context, sources map[mm_repository.FileUID]struct {
	SourceTable mm_repository.SourceTable
	SourceUID   mm_repository.SourceUID
})) *mRepositoryIMockGetFilesTotalTokens {
	if mmGetFilesTotalTokens.mock.inspectFuncGetFilesTotalTokens != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetFilesTotalTokens")
	}

	mmGetFilesTotalTokens.mock.inspectFuncGetFilesTotalTokens = f

	return mmGetFilesTotalTokens
}

// Return sets up results that will be returned by RepositoryI.GetFilesTotalTokens
func (mmGetFilesTotalTokens *mRepositoryIMockGetFilesTotalTokens) Return(m1 map[mm_repository.FileUID]int, err error) *RepositoryIMock {
	if mmGetFilesTotalTokens.mock.funcGetFilesTotalTokens != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryIMock.GetFilesTotalTokens mock is already set by Set")
	}

	if mmGetFilesTotalTokens.defaultExpectation == nil {
		mmGetFilesTotalTokens.defaultExpectation = &RepositoryIMockGetFilesTotalTokensExpectation{mock: mmGetFilesTotalTokens.mock}
	}
	mmGetFilesTotalTokens.defaultExpectation.results = &RepositoryIMockGetFilesTotalTokensResults{m1, err}
	return mmGetFilesTotalTokens.mock
}

// Set uses given function f to mock the RepositoryI.GetFilesTotalTokens method
func (mmGetFilesTotalTokens *mRepositoryIMockGetFilesTotalTokens) Set(f func(ctx context.Context, sources map[mm_repository.FileUID]struct {
	SourceTable mm_repository.SourceTable
	SourceUID   mm_repository.SourceUID
}) (m1 map[mm_repository.FileUID]int, err error)) *RepositoryIMock {
	if mmGetFilesTotalTokens.defaultExpectation != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetFilesTotalTokens method")
	}

	if len(mmGetFilesTotalTokens.expectations) > 0 {
		mmGetFilesTotalTokens.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetFilesTotalTokens method")
	}

	mmGetFilesTotalTokens.mock.funcGetFilesTotalTokens = f
	return mmGetFilesTotalTokens.mock
}

// When sets expectation for the RepositoryI.GetFilesTotalTokens which will trigger the result defined by the following
// Then helper
func (mmGetFilesTotalTokens *mRepositoryIMockGetFilesTotalTokens) When(ctx context.Context, sources map[mm_repository.FileUID]struct {
	SourceTable mm_repository.SourceTable
	SourceUID   mm_repository.SourceUID
}) *RepositoryIMockGetFilesTotalTokensExpectation {
	if mmGetFilesTotalTokens.mock.funcGetFilesTotalTokens != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryIMock.GetFilesTotalTokens mock is already set by Set")
	}

	expectation := &RepositoryIMockGetFilesTotalTokensExpectation{
		mock:   mmGetFilesTotalTokens.mock,
		params: &RepositoryIMockGetFilesTotalTokensParams{ctx, sources},
	}
	mmGetFilesTotalTokens.expectations = append(mmGetFilesTotalTokens.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetFilesTotalTokens return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetFilesTotalTokensExpectation) Then(m1 map[mm_repository.FileUID]int, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetFilesTotalTokensResults{m1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetFilesTotalTokens should be invoked
func (mmGetFilesTotalTokens *mRepositoryIMockGetFilesTotalTokens) Times(n uint64) *mRepositoryIMockGetFilesTotalTokens {
	if n == 0 {
		mmGetFilesTotalTokens.mock.t.Fatalf("Times of RepositoryIMock.GetFilesTotalTokens mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFilesTotalTokens.expectedInvocations, n)
	return mmGetFilesTotalTokens
}

func (mmGetFilesTotalTokens *mRepositoryIMockGetFilesTotalTokens) invocationsDone() bool {
	if len(mmGetFilesTotalTokens.expectations) == 0 && mmGetFilesTotalTokens.defaultExpectation == nil && mmGetFilesTotalTokens.mock.funcGetFilesTotalTokens == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFilesTotalTokens.mock.afterGetFilesTotalTokensCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFilesTotalTokens.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFilesTotalTokens implements repository.RepositoryI
func (mmGetFilesTotalTokens *RepositoryIMock) GetFilesTotalTokens(ctx context.Context, sources map[mm_repository.FileUID]struct {
	SourceTable mm_repository.SourceTable
	SourceUID   mm_repository.SourceUID
}) (m1 map[mm_repository.FileUID]int, err error) {
	mm_atomic.AddUint64(&mmGetFilesTotalTokens.beforeGetFilesTotalTokensCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFilesTotalTokens.afterGetFilesTotalTokensCounter, 1)

	if mmGetFilesTotalTokens.inspectFuncGetFilesTotalTokens != nil {
		mmGetFilesTotalTokens.inspectFuncGetFilesTotalTokens(ctx, sources)
	}

	mm_params := RepositoryIMockGetFilesTotalTokensParams{ctx, sources}

	// Record call args
	mmGetFilesTotalTokens.GetFilesTotalTokensMock.mutex.Lock()
	mmGetFilesTotalTokens.GetFilesTotalTokensMock.callArgs = append(mmGetFilesTotalTokens.GetFilesTotalTokensMock.callArgs, &mm_params)
	mmGetFilesTotalTokens.GetFilesTotalTokensMock.mutex.Unlock()

	for _, e := range mmGetFilesTotalTokens.GetFilesTotalTokensMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetFilesTotalTokens.GetFilesTotalTokensMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFilesTotalTokens.GetFilesTotalTokensMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFilesTotalTokens.GetFilesTotalTokensMock.defaultExpectation.params
		mm_want_ptrs := mmGetFilesTotalTokens.GetFilesTotalTokensMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetFilesTotalTokensParams{ctx, sources}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFilesTotalTokens.t.Errorf("RepositoryIMock.GetFilesTotalTokens got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sources != nil && !minimock.Equal(*mm_want_ptrs.sources, mm_got.sources) {
				mmGetFilesTotalTokens.t.Errorf("RepositoryIMock.GetFilesTotalTokens got unexpected parameter sources, want: %#v, got: %#v%s\n", *mm_want_ptrs.sources, mm_got.sources, minimock.Diff(*mm_want_ptrs.sources, mm_got.sources))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFilesTotalTokens.t.Errorf("RepositoryIMock.GetFilesTotalTokens got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFilesTotalTokens.GetFilesTotalTokensMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFilesTotalTokens.t.Fatal("No results are set for the RepositoryIMock.GetFilesTotalTokens")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetFilesTotalTokens.funcGetFilesTotalTokens != nil {
		return mmGetFilesTotalTokens.funcGetFilesTotalTokens(ctx, sources)
	}
	mmGetFilesTotalTokens.t.Fatalf("Unexpected call to RepositoryIMock.GetFilesTotalTokens. %v %v", ctx, sources)
	return
}

// GetFilesTotalTokensAfterCounter returns a count of finished RepositoryIMock.GetFilesTotalTokens invocations
func (mmGetFilesTotalTokens *RepositoryIMock) GetFilesTotalTokensAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFilesTotalTokens.afterGetFilesTotalTokensCounter)
}

// GetFilesTotalTokensBeforeCounter returns a count of RepositoryIMock.GetFilesTotalTokens invocations
func (mmGetFilesTotalTokens *RepositoryIMock) GetFilesTotalTokensBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFilesTotalTokens.beforeGetFilesTotalTokensCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetFilesTotalTokens.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFilesTotalTokens *mRepositoryIMockGetFilesTotalTokens) Calls() []*RepositoryIMockGetFilesTotalTokensParams {
	mmGetFilesTotalTokens.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetFilesTotalTokensParams, len(mmGetFilesTotalTokens.callArgs))
	copy(argCopy, mmGetFilesTotalTokens.callArgs)

	mmGetFilesTotalTokens.mutex.RUnlock()

	return argCopy
}

// MinimockGetFilesTotalTokensDone returns true if the count of the GetFilesTotalTokens invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetFilesTotalTokensDone() bool {
	for _, e := range m.GetFilesTotalTokensMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFilesTotalTokensMock.invocationsDone()
}

// MinimockGetFilesTotalTokensInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetFilesTotalTokensInspect() {
	for _, e := range m.GetFilesTotalTokensMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetFilesTotalTokens with params: %#v", *e.params)
		}
	}

	afterGetFilesTotalTokensCounter := mm_atomic.LoadUint64(&m.afterGetFilesTotalTokensCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFilesTotalTokensMock.defaultExpectation != nil && afterGetFilesTotalTokensCounter < 1 {
		if m.GetFilesTotalTokensMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetFilesTotalTokens")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetFilesTotalTokens with params: %#v", *m.GetFilesTotalTokensMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFilesTotalTokens != nil && afterGetFilesTotalTokensCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetFilesTotalTokens")
	}

	if !m.GetFilesTotalTokensMock.invocationsDone() && afterGetFilesTotalTokensCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetFilesTotalTokens but found %d calls",
			mm_atomic.LoadUint64(&m.GetFilesTotalTokensMock.expectedInvocations), afterGetFilesTotalTokensCounter)
	}
}

type mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDExpectation
	expectations       []*RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDExpectation

	callArgs []*RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDExpectation specifies expectation struct of the RepositoryI.GetKnowledgeBaseByOwnerAndKbID
type RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParams
	paramPtrs *RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParamPtrs
	results   *RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDResults
	Counter   uint64
}

// RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParams contains parameters of the RepositoryI.GetKnowledgeBaseByOwnerAndKbID
type RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParams struct {
	ctx      context.Context
	ownerUID uuid.UUID
	kbID     string
}

// RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParamPtrs contains pointers to parameters of the RepositoryI.GetKnowledgeBaseByOwnerAndKbID
type RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParamPtrs struct {
	ctx      *context.Context
	ownerUID *uuid.UUID
	kbID     *string
}

// RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDResults contains results of the RepositoryI.GetKnowledgeBaseByOwnerAndKbID
type RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDResults struct {
	kp1 *mm_repository.KnowledgeBase
	err error
}

// Expect sets up expected params for RepositoryI.GetKnowledgeBaseByOwnerAndKbID
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID) Expect(ctx context.Context, ownerUID uuid.UUID, kbID string) *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID {
	if mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation = &RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDExpectation{}
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.params = &RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParams{ctx, ownerUID, kbID}
	for _, e := range mmGetKnowledgeBaseByOwnerAndKbID.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.params) {
			mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBaseByOwnerAndKbID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetKnowledgeBaseByOwnerAndKbID
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID {
	if mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation = &RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDExpectation{}
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.params != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Expect")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs = &RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParamPtrs{}
	}
	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetKnowledgeBaseByOwnerAndKbID
}

// ExpectOwnerUIDParam2 sets up expected param ownerUID for RepositoryI.GetKnowledgeBaseByOwnerAndKbID
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID) ExpectOwnerUIDParam2(ownerUID uuid.UUID) *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID {
	if mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation = &RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDExpectation{}
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.params != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Expect")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs = &RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParamPtrs{}
	}
	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs.ownerUID = &ownerUID

	return mmGetKnowledgeBaseByOwnerAndKbID
}

// ExpectKbIDParam3 sets up expected param kbID for RepositoryI.GetKnowledgeBaseByOwnerAndKbID
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID) ExpectKbIDParam3(kbID string) *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID {
	if mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation = &RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDExpectation{}
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.params != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Expect")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs = &RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParamPtrs{}
	}
	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs.kbID = &kbID

	return mmGetKnowledgeBaseByOwnerAndKbID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetKnowledgeBaseByOwnerAndKbID
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID) Inspect(f func(ctx context.Context, ownerUID uuid.UUID, kbID string)) *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID {
	if mmGetKnowledgeBaseByOwnerAndKbID.mock.inspectFuncGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID")
	}

	mmGetKnowledgeBaseByOwnerAndKbID.mock.inspectFuncGetKnowledgeBaseByOwnerAndKbID = f

	return mmGetKnowledgeBaseByOwnerAndKbID
}

// Return sets up results that will be returned by RepositoryI.GetKnowledgeBaseByOwnerAndKbID
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID) Return(kp1 *mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	if mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation = &RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDExpectation{mock: mmGetKnowledgeBaseByOwnerAndKbID.mock}
	}
	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.results = &RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDResults{kp1, err}
	return mmGetKnowledgeBaseByOwnerAndKbID.mock
}

// Set uses given function f to mock the RepositoryI.GetKnowledgeBaseByOwnerAndKbID method
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID) Set(f func(ctx context.Context, ownerUID uuid.UUID, kbID string) (kp1 *mm_repository.KnowledgeBase, err error)) *RepositoryIMock {
	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetKnowledgeBaseByOwnerAndKbID method")
	}

	if len(mmGetKnowledgeBaseByOwnerAndKbID.expectations) > 0 {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetKnowledgeBaseByOwnerAndKbID method")
	}

	mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID = f
	return mmGetKnowledgeBaseByOwnerAndKbID.mock
}

// When sets expectation for the RepositoryI.GetKnowledgeBaseByOwnerAndKbID which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID) When(ctx context.Context, ownerUID uuid.UUID, kbID string) *RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDExpectation {
	if mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Set")
	}

	expectation := &RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDExpectation{
		mock:   mmGetKnowledgeBaseByOwnerAndKbID.mock,
		params: &RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParams{ctx, ownerUID, kbID},
	}
	mmGetKnowledgeBaseByOwnerAndKbID.expectations = append(mmGetKnowledgeBaseByOwnerAndKbID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetKnowledgeBaseByOwnerAndKbID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDExpectation) Then(kp1 *mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDResults{kp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetKnowledgeBaseByOwnerAndKbID should be invoked
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID) Times(n uint64) *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID {
	if n == 0 {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("Times of RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBaseByOwnerAndKbID.expectedInvocations, n)
	return mmGetKnowledgeBaseByOwnerAndKbID
}

func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID) invocationsDone() bool {
	if len(mmGetKnowledgeBaseByOwnerAndKbID.expectations) == 0 && mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation == nil && mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseByOwnerAndKbID.mock.afterGetKnowledgeBaseByOwnerAndKbIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseByOwnerAndKbID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBaseByOwnerAndKbID implements repository.RepositoryI
func (mmGetKnowledgeBaseByOwnerAndKbID *RepositoryIMock) GetKnowledgeBaseByOwnerAndKbID(ctx context.Context, ownerUID uuid.UUID, kbID string) (kp1 *mm_repository.KnowledgeBase, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBaseByOwnerAndKbID.beforeGetKnowledgeBaseByOwnerAndKbIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBaseByOwnerAndKbID.afterGetKnowledgeBaseByOwnerAndKbIDCounter, 1)

	if mmGetKnowledgeBaseByOwnerAndKbID.inspectFuncGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.inspectFuncGetKnowledgeBaseByOwnerAndKbID(ctx, ownerUID, kbID)
	}

	mm_params := RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParams{ctx, ownerUID, kbID}

	// Record call args
	mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.mutex.Lock()
	mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.callArgs = append(mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.callArgs, &mm_params)
	mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParams{ctx, ownerUID, kbID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBaseByOwnerAndKbID.t.Errorf("RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmGetKnowledgeBaseByOwnerAndKbID.t.Errorf("RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID got unexpected parameter ownerUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

			if mm_want_ptrs.kbID != nil && !minimock.Equal(*mm_want_ptrs.kbID, mm_got.kbID) {
				mmGetKnowledgeBaseByOwnerAndKbID.t.Errorf("RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID got unexpected parameter kbID, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbID, mm_got.kbID, minimock.Diff(*mm_want_ptrs.kbID, mm_got.kbID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBaseByOwnerAndKbID.t.Errorf("RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBaseByOwnerAndKbID.t.Fatal("No results are set for the RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmGetKnowledgeBaseByOwnerAndKbID.funcGetKnowledgeBaseByOwnerAndKbID != nil {
		return mmGetKnowledgeBaseByOwnerAndKbID.funcGetKnowledgeBaseByOwnerAndKbID(ctx, ownerUID, kbID)
	}
	mmGetKnowledgeBaseByOwnerAndKbID.t.Fatalf("Unexpected call to RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID. %v %v %v", ctx, ownerUID, kbID)
	return
}

// GetKnowledgeBaseByOwnerAndKbIDAfterCounter returns a count of finished RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID invocations
func (mmGetKnowledgeBaseByOwnerAndKbID *RepositoryIMock) GetKnowledgeBaseByOwnerAndKbIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseByOwnerAndKbID.afterGetKnowledgeBaseByOwnerAndKbIDCounter)
}

// GetKnowledgeBaseByOwnerAndKbIDBeforeCounter returns a count of RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID invocations
func (mmGetKnowledgeBaseByOwnerAndKbID *RepositoryIMock) GetKnowledgeBaseByOwnerAndKbIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseByOwnerAndKbID.beforeGetKnowledgeBaseByOwnerAndKbIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID) Calls() []*RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParams {
	mmGetKnowledgeBaseByOwnerAndKbID.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParams, len(mmGetKnowledgeBaseByOwnerAndKbID.callArgs))
	copy(argCopy, mmGetKnowledgeBaseByOwnerAndKbID.callArgs)

	mmGetKnowledgeBaseByOwnerAndKbID.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBaseByOwnerAndKbIDDone returns true if the count of the GetKnowledgeBaseByOwnerAndKbID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetKnowledgeBaseByOwnerAndKbIDDone() bool {
	for _, e := range m.GetKnowledgeBaseByOwnerAndKbIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBaseByOwnerAndKbIDMock.invocationsDone()
}

// MinimockGetKnowledgeBaseByOwnerAndKbIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetKnowledgeBaseByOwnerAndKbIDInspect() {
	for _, e := range m.GetKnowledgeBaseByOwnerAndKbIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID with params: %#v", *e.params)
		}
	}

	afterGetKnowledgeBaseByOwnerAndKbIDCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBaseByOwnerAndKbIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation != nil && afterGetKnowledgeBaseByOwnerAndKbIDCounter < 1 {
		if m.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID with params: %#v", *m.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBaseByOwnerAndKbID != nil && afterGetKnowledgeBaseByOwnerAndKbIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID")
	}

	if !m.GetKnowledgeBaseByOwnerAndKbIDMock.invocationsDone() && afterGetKnowledgeBaseByOwnerAndKbIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBaseByOwnerAndKbIDMock.expectedInvocations), afterGetKnowledgeBaseByOwnerAndKbIDCounter)
	}
}

type mRepositoryIMockGetKnowledgeBaseCountByOwner struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetKnowledgeBaseCountByOwnerExpectation
	expectations       []*RepositoryIMockGetKnowledgeBaseCountByOwnerExpectation

	callArgs []*RepositoryIMockGetKnowledgeBaseCountByOwnerParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetKnowledgeBaseCountByOwnerExpectation specifies expectation struct of the RepositoryI.GetKnowledgeBaseCountByOwner
type RepositoryIMockGetKnowledgeBaseCountByOwnerExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetKnowledgeBaseCountByOwnerParams
	paramPtrs *RepositoryIMockGetKnowledgeBaseCountByOwnerParamPtrs
	results   *RepositoryIMockGetKnowledgeBaseCountByOwnerResults
	Counter   uint64
}

// RepositoryIMockGetKnowledgeBaseCountByOwnerParams contains parameters of the RepositoryI.GetKnowledgeBaseCountByOwner
type RepositoryIMockGetKnowledgeBaseCountByOwnerParams struct {
	ctx      context.Context
	ownerUID string
}

// RepositoryIMockGetKnowledgeBaseCountByOwnerParamPtrs contains pointers to parameters of the RepositoryI.GetKnowledgeBaseCountByOwner
type RepositoryIMockGetKnowledgeBaseCountByOwnerParamPtrs struct {
	ctx      *context.Context
	ownerUID *string
}

// RepositoryIMockGetKnowledgeBaseCountByOwnerResults contains results of the RepositoryI.GetKnowledgeBaseCountByOwner
type RepositoryIMockGetKnowledgeBaseCountByOwnerResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for RepositoryI.GetKnowledgeBaseCountByOwner
func (mmGetKnowledgeBaseCountByOwner *mRepositoryIMockGetKnowledgeBaseCountByOwner) Expect(ctx context.Context, ownerUID string) *mRepositoryIMockGetKnowledgeBaseCountByOwner {
	if mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseCountByOwner mock is already set by Set")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation = &RepositoryIMockGetKnowledgeBaseCountByOwnerExpectation{}
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseCountByOwner mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBaseCountByOwner.defaultExpectation.params = &RepositoryIMockGetKnowledgeBaseCountByOwnerParams{ctx, ownerUID}
	for _, e := range mmGetKnowledgeBaseCountByOwner.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBaseCountByOwner.defaultExpectation.params) {
			mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBaseCountByOwner.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBaseCountByOwner
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetKnowledgeBaseCountByOwner
func (mmGetKnowledgeBaseCountByOwner *mRepositoryIMockGetKnowledgeBaseCountByOwner) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetKnowledgeBaseCountByOwner {
	if mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseCountByOwner mock is already set by Set")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation = &RepositoryIMockGetKnowledgeBaseCountByOwnerExpectation{}
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation.params != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseCountByOwner mock is already set by Expect")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs = &RepositoryIMockGetKnowledgeBaseCountByOwnerParamPtrs{}
	}
	mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetKnowledgeBaseCountByOwner
}

// ExpectOwnerUIDParam2 sets up expected param ownerUID for RepositoryI.GetKnowledgeBaseCountByOwner
func (mmGetKnowledgeBaseCountByOwner *mRepositoryIMockGetKnowledgeBaseCountByOwner) ExpectOwnerUIDParam2(ownerUID string) *mRepositoryIMockGetKnowledgeBaseCountByOwner {
	if mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseCountByOwner mock is already set by Set")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation = &RepositoryIMockGetKnowledgeBaseCountByOwnerExpectation{}
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation.params != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseCountByOwner mock is already set by Expect")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs = &RepositoryIMockGetKnowledgeBaseCountByOwnerParamPtrs{}
	}
	mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs.ownerUID = &ownerUID

	return mmGetKnowledgeBaseCountByOwner
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetKnowledgeBaseCountByOwner
func (mmGetKnowledgeBaseCountByOwner *mRepositoryIMockGetKnowledgeBaseCountByOwner) Inspect(f func(ctx context.Context, ownerUID string)) *mRepositoryIMockGetKnowledgeBaseCountByOwner {
	if mmGetKnowledgeBaseCountByOwner.mock.inspectFuncGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetKnowledgeBaseCountByOwner")
	}

	mmGetKnowledgeBaseCountByOwner.mock.inspectFuncGetKnowledgeBaseCountByOwner = f

	return mmGetKnowledgeBaseCountByOwner
}

// Return sets up results that will be returned by RepositoryI.GetKnowledgeBaseCountByOwner
func (mmGetKnowledgeBaseCountByOwner *mRepositoryIMockGetKnowledgeBaseCountByOwner) Return(i1 int64, err error) *RepositoryIMock {
	if mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseCountByOwner mock is already set by Set")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation = &RepositoryIMockGetKnowledgeBaseCountByOwnerExpectation{mock: mmGetKnowledgeBaseCountByOwner.mock}
	}
	mmGetKnowledgeBaseCountByOwner.defaultExpectation.results = &RepositoryIMockGetKnowledgeBaseCountByOwnerResults{i1, err}
	return mmGetKnowledgeBaseCountByOwner.mock
}

// Set uses given function f to mock the RepositoryI.GetKnowledgeBaseCountByOwner method
func (mmGetKnowledgeBaseCountByOwner *mRepositoryIMockGetKnowledgeBaseCountByOwner) Set(f func(ctx context.Context, ownerUID string) (i1 int64, err error)) *RepositoryIMock {
	if mmGetKnowledgeBaseCountByOwner.defaultExpectation != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetKnowledgeBaseCountByOwner method")
	}

	if len(mmGetKnowledgeBaseCountByOwner.expectations) > 0 {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetKnowledgeBaseCountByOwner method")
	}

	mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner = f
	return mmGetKnowledgeBaseCountByOwner.mock
}

// When sets expectation for the RepositoryI.GetKnowledgeBaseCountByOwner which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBaseCountByOwner *mRepositoryIMockGetKnowledgeBaseCountByOwner) When(ctx context.Context, ownerUID string) *RepositoryIMockGetKnowledgeBaseCountByOwnerExpectation {
	if mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseCountByOwner mock is already set by Set")
	}

	expectation := &RepositoryIMockGetKnowledgeBaseCountByOwnerExpectation{
		mock:   mmGetKnowledgeBaseCountByOwner.mock,
		params: &RepositoryIMockGetKnowledgeBaseCountByOwnerParams{ctx, ownerUID},
	}
	mmGetKnowledgeBaseCountByOwner.expectations = append(mmGetKnowledgeBaseCountByOwner.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetKnowledgeBaseCountByOwner return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetKnowledgeBaseCountByOwnerExpectation) Then(i1 int64, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetKnowledgeBaseCountByOwnerResults{i1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetKnowledgeBaseCountByOwner should be invoked
func (mmGetKnowledgeBaseCountByOwner *mRepositoryIMockGetKnowledgeBaseCountByOwner) Times(n uint64) *mRepositoryIMockGetKnowledgeBaseCountByOwner {
	if n == 0 {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("Times of RepositoryIMock.GetKnowledgeBaseCountByOwner mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBaseCountByOwner.expectedInvocations, n)
	return mmGetKnowledgeBaseCountByOwner
}

func (mmGetKnowledgeBaseCountByOwner *mRepositoryIMockGetKnowledgeBaseCountByOwner) invocationsDone() bool {
	if len(mmGetKnowledgeBaseCountByOwner.expectations) == 0 && mmGetKnowledgeBaseCountByOwner.defaultExpectation == nil && mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseCountByOwner.mock.afterGetKnowledgeBaseCountByOwnerCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseCountByOwner.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBaseCountByOwner implements repository.RepositoryI
func (mmGetKnowledgeBaseCountByOwner *RepositoryIMock) GetKnowledgeBaseCountByOwner(ctx context.Context, ownerUID string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBaseCountByOwner.beforeGetKnowledgeBaseCountByOwnerCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBaseCountByOwner.afterGetKnowledgeBaseCountByOwnerCounter, 1)

	if mmGetKnowledgeBaseCountByOwner.inspectFuncGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.inspectFuncGetKnowledgeBaseCountByOwner(ctx, ownerUID)
	}

	mm_params := RepositoryIMockGetKnowledgeBaseCountByOwnerParams{ctx, ownerUID}

	// Record call args
	mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.mutex.Lock()
	mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.callArgs = append(mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.callArgs, &mm_params)
	mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetKnowledgeBaseCountByOwnerParams{ctx, ownerUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBaseCountByOwner.t.Errorf("RepositoryIMock.GetKnowledgeBaseCountByOwner got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmGetKnowledgeBaseCountByOwner.t.Errorf("RepositoryIMock.GetKnowledgeBaseCountByOwner got unexpected parameter ownerUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBaseCountByOwner.t.Errorf("RepositoryIMock.GetKnowledgeBaseCountByOwner got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBaseCountByOwner.t.Fatal("No results are set for the RepositoryIMock.GetKnowledgeBaseCountByOwner")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetKnowledgeBaseCountByOwner.funcGetKnowledgeBaseCountByOwner != nil {
		return mmGetKnowledgeBaseCountByOwner.funcGetKnowledgeBaseCountByOwner(ctx, ownerUID)
	}
	mmGetKnowledgeBaseCountByOwner.t.Fatalf("Unexpected call to RepositoryIMock.GetKnowledgeBaseCountByOwner. %v %v", ctx, ownerUID)
	return
}

// GetKnowledgeBaseCountByOwnerAfterCounter returns a count of finished RepositoryIMock.GetKnowledgeBaseCountByOwner invocations
func (mmGetKnowledgeBaseCountByOwner *RepositoryIMock) GetKnowledgeBaseCountByOwnerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseCountByOwner.afterGetKnowledgeBaseCountByOwnerCounter)
}

// GetKnowledgeBaseCountByOwnerBeforeCounter returns a count of RepositoryIMock.GetKnowledgeBaseCountByOwner invocations
func (mmGetKnowledgeBaseCountByOwner *RepositoryIMock) GetKnowledgeBaseCountByOwnerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseCountByOwner.beforeGetKnowledgeBaseCountByOwnerCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetKnowledgeBaseCountByOwner.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBaseCountByOwner *mRepositoryIMockGetKnowledgeBaseCountByOwner) Calls() []*RepositoryIMockGetKnowledgeBaseCountByOwnerParams {
	mmGetKnowledgeBaseCountByOwner.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetKnowledgeBaseCountByOwnerParams, len(mmGetKnowledgeBaseCountByOwner.callArgs))
	copy(argCopy, mmGetKnowledgeBaseCountByOwner.callArgs)

	mmGetKnowledgeBaseCountByOwner.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBaseCountByOwnerDone returns true if the count of the GetKnowledgeBaseCountByOwner invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetKnowledgeBaseCountByOwnerDone() bool {
	for _, e := range m.GetKnowledgeBaseCountByOwnerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBaseCountByOwnerMock.invocationsDone()
}

// MinimockGetKnowledgeBaseCountByOwnerInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetKnowledgeBaseCountByOwnerInspect() {
	for _, e := range m.GetKnowledgeBaseCountByOwnerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetKnowledgeBaseCountByOwner with params: %#v", *e.params)
		}
	}

	afterGetKnowledgeBaseCountByOwnerCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBaseCountByOwnerCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBaseCountByOwnerMock.defaultExpectation != nil && afterGetKnowledgeBaseCountByOwnerCounter < 1 {
		if m.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetKnowledgeBaseCountByOwner")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetKnowledgeBaseCountByOwner with params: %#v", *m.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBaseCountByOwner != nil && afterGetKnowledgeBaseCountByOwnerCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetKnowledgeBaseCountByOwner")
	}

	if !m.GetKnowledgeBaseCountByOwnerMock.invocationsDone() && afterGetKnowledgeBaseCountByOwnerCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetKnowledgeBaseCountByOwner but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBaseCountByOwnerMock.expectedInvocations), afterGetKnowledgeBaseCountByOwnerCounter)
	}
}

type mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetKnowledgeBaseFilesByFileUIDsExpectation
	expectations       []*RepositoryIMockGetKnowledgeBaseFilesByFileUIDsExpectation

	callArgs []*RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetKnowledgeBaseFilesByFileUIDsExpectation specifies expectation struct of the RepositoryI.GetKnowledgeBaseFilesByFileUIDs
type RepositoryIMockGetKnowledgeBaseFilesByFileUIDsExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParams
	paramPtrs *RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParamPtrs
	results   *RepositoryIMockGetKnowledgeBaseFilesByFileUIDsResults
	Counter   uint64
}

// RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParams contains parameters of the RepositoryI.GetKnowledgeBaseFilesByFileUIDs
type RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParams struct {
	ctx      context.Context
	fileUIDs []uuid.UUID
	columns  []string
}

// RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParamPtrs contains pointers to parameters of the RepositoryI.GetKnowledgeBaseFilesByFileUIDs
type RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParamPtrs struct {
	ctx      *context.Context
	fileUIDs *[]uuid.UUID
	columns  *[]string
}

// RepositoryIMockGetKnowledgeBaseFilesByFileUIDsResults contains results of the RepositoryI.GetKnowledgeBaseFilesByFileUIDs
type RepositoryIMockGetKnowledgeBaseFilesByFileUIDsResults struct {
	ka1 []mm_repository.KnowledgeBaseFile
	err error
}

// Expect sets up expected params for RepositoryI.GetKnowledgeBaseFilesByFileUIDs
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs) Expect(ctx context.Context, fileUIDs []uuid.UUID, columns ...string) *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs {
	if mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation = &RepositoryIMockGetKnowledgeBaseFilesByFileUIDsExpectation{}
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.params = &RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParams{ctx, fileUIDs, columns}
	for _, e := range mmGetKnowledgeBaseFilesByFileUIDs.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.params) {
			mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBaseFilesByFileUIDs
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetKnowledgeBaseFilesByFileUIDs
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs {
	if mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation = &RepositoryIMockGetKnowledgeBaseFilesByFileUIDsExpectation{}
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.params != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Expect")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs = &RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParamPtrs{}
	}
	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetKnowledgeBaseFilesByFileUIDs
}

// ExpectFileUIDsParam2 sets up expected param fileUIDs for RepositoryI.GetKnowledgeBaseFilesByFileUIDs
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs) ExpectFileUIDsParam2(fileUIDs []uuid.UUID) *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs {
	if mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation = &RepositoryIMockGetKnowledgeBaseFilesByFileUIDsExpectation{}
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.params != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Expect")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs = &RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParamPtrs{}
	}
	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs.fileUIDs = &fileUIDs

	return mmGetKnowledgeBaseFilesByFileUIDs
}

// ExpectColumnsParam3 sets up expected param columns for RepositoryI.GetKnowledgeBaseFilesByFileUIDs
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs) ExpectColumnsParam3(columns ...string) *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs {
	if mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation = &RepositoryIMockGetKnowledgeBaseFilesByFileUIDsExpectation{}
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.params != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Expect")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs = &RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParamPtrs{}
	}
	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs.columns = &columns

	return mmGetKnowledgeBaseFilesByFileUIDs
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetKnowledgeBaseFilesByFileUIDs
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs) Inspect(f func(ctx context.Context, fileUIDs []uuid.UUID, columns ...string)) *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs {
	if mmGetKnowledgeBaseFilesByFileUIDs.mock.inspectFuncGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs")
	}

	mmGetKnowledgeBaseFilesByFileUIDs.mock.inspectFuncGetKnowledgeBaseFilesByFileUIDs = f

	return mmGetKnowledgeBaseFilesByFileUIDs
}

// Return sets up results that will be returned by RepositoryI.GetKnowledgeBaseFilesByFileUIDs
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs) Return(ka1 []mm_repository.KnowledgeBaseFile, err error) *RepositoryIMock {
	if mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation = &RepositoryIMockGetKnowledgeBaseFilesByFileUIDsExpectation{mock: mmGetKnowledgeBaseFilesByFileUIDs.mock}
	}
	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.results = &RepositoryIMockGetKnowledgeBaseFilesByFileUIDsResults{ka1, err}
	return mmGetKnowledgeBaseFilesByFileUIDs.mock
}

// Set uses given function f to mock the RepositoryI.GetKnowledgeBaseFilesByFileUIDs method
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs) Set(f func(ctx context.Context, fileUIDs []uuid.UUID, columns ...string) (ka1 []mm_repository.KnowledgeBaseFile, err error)) *RepositoryIMock {
	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetKnowledgeBaseFilesByFileUIDs method")
	}

	if len(mmGetKnowledgeBaseFilesByFileUIDs.expectations) > 0 {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetKnowledgeBaseFilesByFileUIDs method")
	}

	mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs = f
	return mmGetKnowledgeBaseFilesByFileUIDs.mock
}

// When sets expectation for the RepositoryI.GetKnowledgeBaseFilesByFileUIDs which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs) When(ctx context.Context, fileUIDs []uuid.UUID, columns ...string) *RepositoryIMockGetKnowledgeBaseFilesByFileUIDsExpectation {
	if mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Set")
	}

	expectation := &RepositoryIMockGetKnowledgeBaseFilesByFileUIDsExpectation{
		mock:   mmGetKnowledgeBaseFilesByFileUIDs.mock,
		params: &RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParams{ctx, fileUIDs, columns},
	}
	mmGetKnowledgeBaseFilesByFileUIDs.expectations = append(mmGetKnowledgeBaseFilesByFileUIDs.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetKnowledgeBaseFilesByFileUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetKnowledgeBaseFilesByFileUIDsExpectation) Then(ka1 []mm_repository.KnowledgeBaseFile, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetKnowledgeBaseFilesByFileUIDsResults{ka1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetKnowledgeBaseFilesByFileUIDs should be invoked
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs) Times(n uint64) *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs {
	if n == 0 {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("Times of RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBaseFilesByFileUIDs.expectedInvocations, n)
	return mmGetKnowledgeBaseFilesByFileUIDs
}

func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs) invocationsDone() bool {
	if len(mmGetKnowledgeBaseFilesByFileUIDs.expectations) == 0 && mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation == nil && mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseFilesByFileUIDs.mock.afterGetKnowledgeBaseFilesByFileUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseFilesByFileUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBaseFilesByFileUIDs implements repository.RepositoryI
func (mmGetKnowledgeBaseFilesByFileUIDs *RepositoryIMock) GetKnowledgeBaseFilesByFileUIDs(ctx context.Context, fileUIDs []uuid.UUID, columns ...string) (ka1 []mm_repository.KnowledgeBaseFile, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBaseFilesByFileUIDs.beforeGetKnowledgeBaseFilesByFileUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBaseFilesByFileUIDs.afterGetKnowledgeBaseFilesByFileUIDsCounter, 1)

	if mmGetKnowledgeBaseFilesByFileUIDs.inspectFuncGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.inspectFuncGetKnowledgeBaseFilesByFileUIDs(ctx, fileUIDs, columns...)
	}

	mm_params := RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParams{ctx, fileUIDs, columns}

	// Record call args
	mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.mutex.Lock()
	mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.callArgs = append(mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.callArgs, &mm_params)
	mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParams{ctx, fileUIDs, columns}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBaseFilesByFileUIDs.t.Errorf("RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUIDs != nil && !minimock.Equal(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs) {
				mmGetKnowledgeBaseFilesByFileUIDs.t.Errorf("RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs got unexpected parameter fileUIDs, want: %#v, got: %#v%s\n", *mm_want_ptrs.fileUIDs, mm_got.fileUIDs, minimock.Diff(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs))
			}

			if mm_want_ptrs.columns != nil && !minimock.Equal(*mm_want_ptrs.columns, mm_got.columns) {
				mmGetKnowledgeBaseFilesByFileUIDs.t.Errorf("RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs got unexpected parameter columns, want: %#v, got: %#v%s\n", *mm_want_ptrs.columns, mm_got.columns, minimock.Diff(*mm_want_ptrs.columns, mm_got.columns))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBaseFilesByFileUIDs.t.Errorf("RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBaseFilesByFileUIDs.t.Fatal("No results are set for the RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmGetKnowledgeBaseFilesByFileUIDs.funcGetKnowledgeBaseFilesByFileUIDs != nil {
		return mmGetKnowledgeBaseFilesByFileUIDs.funcGetKnowledgeBaseFilesByFileUIDs(ctx, fileUIDs, columns...)
	}
	mmGetKnowledgeBaseFilesByFileUIDs.t.Fatalf("Unexpected call to RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs. %v %v %v", ctx, fileUIDs, columns)
	return
}

// GetKnowledgeBaseFilesByFileUIDsAfterCounter returns a count of finished RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs invocations
func (mmGetKnowledgeBaseFilesByFileUIDs *RepositoryIMock) GetKnowledgeBaseFilesByFileUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseFilesByFileUIDs.afterGetKnowledgeBaseFilesByFileUIDsCounter)
}

// GetKnowledgeBaseFilesByFileUIDsBeforeCounter returns a count of RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs invocations
func (mmGetKnowledgeBaseFilesByFileUIDs *RepositoryIMock) GetKnowledgeBaseFilesByFileUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseFilesByFileUIDs.beforeGetKnowledgeBaseFilesByFileUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs) Calls() []*RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParams {
	mmGetKnowledgeBaseFilesByFileUIDs.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParams, len(mmGetKnowledgeBaseFilesByFileUIDs.callArgs))
	copy(argCopy, mmGetKnowledgeBaseFilesByFileUIDs.callArgs)

	mmGetKnowledgeBaseFilesByFileUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBaseFilesByFileUIDsDone returns true if the count of the GetKnowledgeBaseFilesByFileUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetKnowledgeBaseFilesByFileUIDsDone() bool {
	for _, e := range m.GetKnowledgeBaseFilesByFileUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBaseFilesByFileUIDsMock.invocationsDone()
}

// MinimockGetKnowledgeBaseFilesByFileUIDsInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetKnowledgeBaseFilesByFileUIDsInspect() {
	for _, e := range m.GetKnowledgeBaseFilesByFileUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs with params: %#v", *e.params)
		}
	}

	afterGetKnowledgeBaseFilesByFileUIDsCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBaseFilesByFileUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation != nil && afterGetKnowledgeBaseFilesByFileUIDsCounter < 1 {
		if m.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs with params: %#v", *m.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBaseFilesByFileUIDs != nil && afterGetKnowledgeBaseFilesByFileUIDsCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs")
	}

	if !m.GetKnowledgeBaseFilesByFileUIDsMock.invocationsDone() && afterGetKnowledgeBaseFilesByFileUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBaseFilesByFileUIDsMock.expectedInvocations), afterGetKnowledgeBaseFilesByFileUIDsCounter)
	}
}

type mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDExpectation
	expectations       []*RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDExpectation

	callArgs []*RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDExpectation specifies expectation struct of the RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID
type RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParams
	paramPtrs *RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParamPtrs
	results   *RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDResults
	Counter   uint64
}

// RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParams contains parameters of the RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID
type RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParams struct {
	ctx    context.Context
	kbUID  uuid.UUID
	fileID string
}

// RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParamPtrs contains pointers to parameters of the RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID
type RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParamPtrs struct {
	ctx    *context.Context
	kbUID  *uuid.UUID
	fileID *string
}

// RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDResults contains results of the RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID
type RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDResults struct {
	kp1 *mm_repository.KnowledgeBaseFile
	err error
}

// Expect sets up expected params for RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID
func (mmGetKnowledgebaseFileByKbUIDAndFileID *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID) Expect(ctx context.Context, kbUID uuid.UUID, fileID string) *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID {
	if mmGetKnowledgebaseFileByKbUIDAndFileID.mock.funcGetKnowledgebaseFileByKbUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID mock is already set by Set")
	}

	if mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation == nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation = &RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDExpectation{}
	}

	if mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID mock is already set by ExpectParams functions")
	}

	mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.params = &RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParams{ctx, kbUID, fileID}
	for _, e := range mmGetKnowledgebaseFileByKbUIDAndFileID.expectations {
		if minimock.Equal(e.params, mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.params) {
			mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.params)
		}
	}

	return mmGetKnowledgebaseFileByKbUIDAndFileID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID
func (mmGetKnowledgebaseFileByKbUIDAndFileID *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID {
	if mmGetKnowledgebaseFileByKbUIDAndFileID.mock.funcGetKnowledgebaseFileByKbUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID mock is already set by Set")
	}

	if mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation == nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation = &RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDExpectation{}
	}

	if mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.params != nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID mock is already set by Expect")
	}

	if mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.paramPtrs = &RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParamPtrs{}
	}
	mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetKnowledgebaseFileByKbUIDAndFileID
}

// ExpectKbUIDParam2 sets up expected param kbUID for RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID
func (mmGetKnowledgebaseFileByKbUIDAndFileID *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID) ExpectKbUIDParam2(kbUID uuid.UUID) *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID {
	if mmGetKnowledgebaseFileByKbUIDAndFileID.mock.funcGetKnowledgebaseFileByKbUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID mock is already set by Set")
	}

	if mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation == nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation = &RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDExpectation{}
	}

	if mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.params != nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID mock is already set by Expect")
	}

	if mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.paramPtrs = &RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParamPtrs{}
	}
	mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.paramPtrs.kbUID = &kbUID

	return mmGetKnowledgebaseFileByKbUIDAndFileID
}

// ExpectFileIDParam3 sets up expected param fileID for RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID
func (mmGetKnowledgebaseFileByKbUIDAndFileID *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID) ExpectFileIDParam3(fileID string) *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID {
	if mmGetKnowledgebaseFileByKbUIDAndFileID.mock.funcGetKnowledgebaseFileByKbUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID mock is already set by Set")
	}

	if mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation == nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation = &RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDExpectation{}
	}

	if mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.params != nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID mock is already set by Expect")
	}

	if mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.paramPtrs = &RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParamPtrs{}
	}
	mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.paramPtrs.fileID = &fileID

	return mmGetKnowledgebaseFileByKbUIDAndFileID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID
func (mmGetKnowledgebaseFileByKbUIDAndFileID *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID) Inspect(f func(ctx context.Context, kbUID uuid.UUID, fileID string)) *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID {
	if mmGetKnowledgebaseFileByKbUIDAndFileID.mock.inspectFuncGetKnowledgebaseFileByKbUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID")
	}

	mmGetKnowledgebaseFileByKbUIDAndFileID.mock.inspectFuncGetKnowledgebaseFileByKbUIDAndFileID = f

	return mmGetKnowledgebaseFileByKbUIDAndFileID
}

// Return sets up results that will be returned by RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID
func (mmGetKnowledgebaseFileByKbUIDAndFileID *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID) Return(kp1 *mm_repository.KnowledgeBaseFile, err error) *RepositoryIMock {
	if mmGetKnowledgebaseFileByKbUIDAndFileID.mock.funcGetKnowledgebaseFileByKbUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID mock is already set by Set")
	}

	if mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation == nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation = &RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDExpectation{mock: mmGetKnowledgebaseFileByKbUIDAndFileID.mock}
	}
	mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.results = &RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDResults{kp1, err}
	return mmGetKnowledgebaseFileByKbUIDAndFileID.mock
}

// Set uses given function f to mock the RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID method
func (mmGetKnowledgebaseFileByKbUIDAndFileID *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID) Set(f func(ctx context.Context, kbUID uuid.UUID, fileID string) (kp1 *mm_repository.KnowledgeBaseFile, err error)) *RepositoryIMock {
	if mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation != nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID method")
	}

	if len(mmGetKnowledgebaseFileByKbUIDAndFileID.expectations) > 0 {
		mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID method")
	}

	mmGetKnowledgebaseFileByKbUIDAndFileID.mock.funcGetKnowledgebaseFileByKbUIDAndFileID = f
	return mmGetKnowledgebaseFileByKbUIDAndFileID.mock
}

// When sets expectation for the RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgebaseFileByKbUIDAndFileID *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID) When(ctx context.Context, kbUID uuid.UUID, fileID string) *RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDExpectation {
	if mmGetKnowledgebaseFileByKbUIDAndFileID.mock.funcGetKnowledgebaseFileByKbUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID mock is already set by Set")
	}

	expectation := &RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDExpectation{
		mock:   mmGetKnowledgebaseFileByKbUIDAndFileID.mock,
		params: &RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParams{ctx, kbUID, fileID},
	}
	mmGetKnowledgebaseFileByKbUIDAndFileID.expectations = append(mmGetKnowledgebaseFileByKbUIDAndFileID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDExpectation) Then(kp1 *mm_repository.KnowledgeBaseFile, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDResults{kp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID should be invoked
func (mmGetKnowledgebaseFileByKbUIDAndFileID *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID) Times(n uint64) *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID {
	if n == 0 {
		mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("Times of RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgebaseFileByKbUIDAndFileID.expectedInvocations, n)
	return mmGetKnowledgebaseFileByKbUIDAndFileID
}

func (mmGetKnowledgebaseFileByKbUIDAndFileID *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID) invocationsDone() bool {
	if len(mmGetKnowledgebaseFileByKbUIDAndFileID.expectations) == 0 && mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation == nil && mmGetKnowledgebaseFileByKbUIDAndFileID.mock.funcGetKnowledgebaseFileByKbUIDAndFileID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgebaseFileByKbUIDAndFileID.mock.afterGetKnowledgebaseFileByKbUIDAndFileIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgebaseFileByKbUIDAndFileID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgebaseFileByKbUIDAndFileID implements repository.RepositoryI
func (mmGetKnowledgebaseFileByKbUIDAndFileID *RepositoryIMock) GetKnowledgebaseFileByKbUIDAndFileID(ctx context.Context, kbUID uuid.UUID, fileID string) (kp1 *mm_repository.KnowledgeBaseFile, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgebaseFileByKbUIDAndFileID.beforeGetKnowledgebaseFileByKbUIDAndFileIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgebaseFileByKbUIDAndFileID.afterGetKnowledgebaseFileByKbUIDAndFileIDCounter, 1)

	if mmGetKnowledgebaseFileByKbUIDAndFileID.inspectFuncGetKnowledgebaseFileByKbUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.inspectFuncGetKnowledgebaseFileByKbUIDAndFileID(ctx, kbUID, fileID)
	}

	mm_params := RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParams{ctx, kbUID, fileID}

	// Record call args
	mmGetKnowledgebaseFileByKbUIDAndFileID.GetKnowledgebaseFileByKbUIDAndFileIDMock.mutex.Lock()
	mmGetKnowledgebaseFileByKbUIDAndFileID.GetKnowledgebaseFileByKbUIDAndFileIDMock.callArgs = append(mmGetKnowledgebaseFileByKbUIDAndFileID.GetKnowledgebaseFileByKbUIDAndFileIDMock.callArgs, &mm_params)
	mmGetKnowledgebaseFileByKbUIDAndFileID.GetKnowledgebaseFileByKbUIDAndFileIDMock.mutex.Unlock()

	for _, e := range mmGetKnowledgebaseFileByKbUIDAndFileID.GetKnowledgebaseFileByKbUIDAndFileIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmGetKnowledgebaseFileByKbUIDAndFileID.GetKnowledgebaseFileByKbUIDAndFileIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgebaseFileByKbUIDAndFileID.GetKnowledgebaseFileByKbUIDAndFileIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgebaseFileByKbUIDAndFileID.GetKnowledgebaseFileByKbUIDAndFileIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgebaseFileByKbUIDAndFileID.GetKnowledgebaseFileByKbUIDAndFileIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParams{ctx, kbUID, fileID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgebaseFileByKbUIDAndFileID.t.Errorf("RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmGetKnowledgebaseFileByKbUIDAndFileID.t.Errorf("RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID got unexpected parameter kbUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.fileID != nil && !minimock.Equal(*mm_want_ptrs.fileID, mm_got.fileID) {
				mmGetKnowledgebaseFileByKbUIDAndFileID.t.Errorf("RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID got unexpected parameter fileID, want: %#v, got: %#v%s\n", *mm_want_ptrs.fileID, mm_got.fileID, minimock.Diff(*mm_want_ptrs.fileID, mm_got.fileID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgebaseFileByKbUIDAndFileID.t.Errorf("RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgebaseFileByKbUIDAndFileID.GetKnowledgebaseFileByKbUIDAndFileIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgebaseFileByKbUIDAndFileID.t.Fatal("No results are set for the RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmGetKnowledgebaseFileByKbUIDAndFileID.funcGetKnowledgebaseFileByKbUIDAndFileID != nil {
		return mmGetKnowledgebaseFileByKbUIDAndFileID.funcGetKnowledgebaseFileByKbUIDAndFileID(ctx, kbUID, fileID)
	}
	mmGetKnowledgebaseFileByKbUIDAndFileID.t.Fatalf("Unexpected call to RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID. %v %v %v", ctx, kbUID, fileID)
	return
}

// GetKnowledgebaseFileByKbUIDAndFileIDAfterCounter returns a count of finished RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID invocations
func (mmGetKnowledgebaseFileByKbUIDAndFileID *RepositoryIMock) GetKnowledgebaseFileByKbUIDAndFileIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgebaseFileByKbUIDAndFileID.afterGetKnowledgebaseFileByKbUIDAndFileIDCounter)
}

// GetKnowledgebaseFileByKbUIDAndFileIDBeforeCounter returns a count of RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID invocations
func (mmGetKnowledgebaseFileByKbUIDAndFileID *RepositoryIMock) GetKnowledgebaseFileByKbUIDAndFileIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgebaseFileByKbUIDAndFileID.beforeGetKnowledgebaseFileByKbUIDAndFileIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgebaseFileByKbUIDAndFileID *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID) Calls() []*RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParams {
	mmGetKnowledgebaseFileByKbUIDAndFileID.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParams, len(mmGetKnowledgebaseFileByKbUIDAndFileID.callArgs))
	copy(argCopy, mmGetKnowledgebaseFileByKbUIDAndFileID.callArgs)

	mmGetKnowledgebaseFileByKbUIDAndFileID.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgebaseFileByKbUIDAndFileIDDone returns true if the count of the GetKnowledgebaseFileByKbUIDAndFileID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetKnowledgebaseFileByKbUIDAndFileIDDone() bool {
	for _, e := range m.GetKnowledgebaseFileByKbUIDAndFileIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgebaseFileByKbUIDAndFileIDMock.invocationsDone()
}

// MinimockGetKnowledgebaseFileByKbUIDAndFileIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetKnowledgebaseFileByKbUIDAndFileIDInspect() {
	for _, e := range m.GetKnowledgebaseFileByKbUIDAndFileIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID with params: %#v", *e.params)
		}
	}

	afterGetKnowledgebaseFileByKbUIDAndFileIDCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgebaseFileByKbUIDAndFileIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgebaseFileByKbUIDAndFileIDMock.defaultExpectation != nil && afterGetKnowledgebaseFileByKbUIDAndFileIDCounter < 1 {
		if m.GetKnowledgebaseFileByKbUIDAndFileIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID with params: %#v", *m.GetKnowledgebaseFileByKbUIDAndFileIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgebaseFileByKbUIDAndFileID != nil && afterGetKnowledgebaseFileByKbUIDAndFileIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID")
	}

	if !m.GetKnowledgebaseFileByKbUIDAndFileIDMock.invocationsDone() && afterGetKnowledgebaseFileByKbUIDAndFileIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgebaseFileByKbUIDAndFileIDMock.expectedInvocations), afterGetKnowledgebaseFileByKbUIDAndFileIDCounter)
	}
}

type mRepositoryIMockGetMessageByUID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetMessageByUIDExpectation
	expectations       []*RepositoryIMockGetMessageByUIDExpectation

	callArgs []*RepositoryIMockGetMessageByUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetMessageByUIDExpectation specifies expectation struct of the RepositoryI.GetMessageByUID
type RepositoryIMockGetMessageByUIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetMessageByUIDParams
	paramPtrs *RepositoryIMockGetMessageByUIDParamPtrs
	results   *RepositoryIMockGetMessageByUIDResults
	Counter   uint64
}

// RepositoryIMockGetMessageByUIDParams contains parameters of the RepositoryI.GetMessageByUID
type RepositoryIMockGetMessageByUIDParams struct {
	ctx        context.Context
	messageUID uuid.UUID
}

// RepositoryIMockGetMessageByUIDParamPtrs contains pointers to parameters of the RepositoryI.GetMessageByUID
type RepositoryIMockGetMessageByUIDParamPtrs struct {
	ctx        *context.Context
	messageUID *uuid.UUID
}

// RepositoryIMockGetMessageByUIDResults contains results of the RepositoryI.GetMessageByUID
type RepositoryIMockGetMessageByUIDResults struct {
	mp1 *mm_repository.Message
	err error
}

// Expect sets up expected params for RepositoryI.GetMessageByUID
func (mmGetMessageByUID *mRepositoryIMockGetMessageByUID) Expect(ctx context.Context, messageUID uuid.UUID) *mRepositoryIMockGetMessageByUID {
	if mmGetMessageByUID.mock.funcGetMessageByUID != nil {
		mmGetMessageByUID.mock.t.Fatalf("RepositoryIMock.GetMessageByUID mock is already set by Set")
	}

	if mmGetMessageByUID.defaultExpectation == nil {
		mmGetMessageByUID.defaultExpectation = &RepositoryIMockGetMessageByUIDExpectation{}
	}

	if mmGetMessageByUID.defaultExpectation.paramPtrs != nil {
		mmGetMessageByUID.mock.t.Fatalf("RepositoryIMock.GetMessageByUID mock is already set by ExpectParams functions")
	}

	mmGetMessageByUID.defaultExpectation.params = &RepositoryIMockGetMessageByUIDParams{ctx, messageUID}
	for _, e := range mmGetMessageByUID.expectations {
		if minimock.Equal(e.params, mmGetMessageByUID.defaultExpectation.params) {
			mmGetMessageByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetMessageByUID.defaultExpectation.params)
		}
	}

	return mmGetMessageByUID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetMessageByUID
func (mmGetMessageByUID *mRepositoryIMockGetMessageByUID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetMessageByUID {
	if mmGetMessageByUID.mock.funcGetMessageByUID != nil {
		mmGetMessageByUID.mock.t.Fatalf("RepositoryIMock.GetMessageByUID mock is already set by Set")
	}

	if mmGetMessageByUID.defaultExpectation == nil {
		mmGetMessageByUID.defaultExpectation = &RepositoryIMockGetMessageByUIDExpectation{}
	}

	if mmGetMessageByUID.defaultExpectation.params != nil {
		mmGetMessageByUID.mock.t.Fatalf("RepositoryIMock.GetMessageByUID mock is already set by Expect")
	}

	if mmGetMessageByUID.defaultExpectation.paramPtrs == nil {
		mmGetMessageByUID.defaultExpectation.paramPtrs = &RepositoryIMockGetMessageByUIDParamPtrs{}
	}
	mmGetMessageByUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetMessageByUID
}

// ExpectMessageUIDParam2 sets up expected param messageUID for RepositoryI.GetMessageByUID
func (mmGetMessageByUID *mRepositoryIMockGetMessageByUID) ExpectMessageUIDParam2(messageUID uuid.UUID) *mRepositoryIMockGetMessageByUID {
	if mmGetMessageByUID.mock.funcGetMessageByUID != nil {
		mmGetMessageByUID.mock.t.Fatalf("RepositoryIMock.GetMessageByUID mock is already set by Set")
	}

	if mmGetMessageByUID.defaultExpectation == nil {
		mmGetMessageByUID.defaultExpectation = &RepositoryIMockGetMessageByUIDExpectation{}
	}

	if mmGetMessageByUID.defaultExpectation.params != nil {
		mmGetMessageByUID.mock.t.Fatalf("RepositoryIMock.GetMessageByUID mock is already set by Expect")
	}

	if mmGetMessageByUID.defaultExpectation.paramPtrs == nil {
		mmGetMessageByUID.defaultExpectation.paramPtrs = &RepositoryIMockGetMessageByUIDParamPtrs{}
	}
	mmGetMessageByUID.defaultExpectation.paramPtrs.messageUID = &messageUID

	return mmGetMessageByUID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetMessageByUID
func (mmGetMessageByUID *mRepositoryIMockGetMessageByUID) Inspect(f func(ctx context.Context, messageUID uuid.UUID)) *mRepositoryIMockGetMessageByUID {
	if mmGetMessageByUID.mock.inspectFuncGetMessageByUID != nil {
		mmGetMessageByUID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetMessageByUID")
	}

	mmGetMessageByUID.mock.inspectFuncGetMessageByUID = f

	return mmGetMessageByUID
}

// Return sets up results that will be returned by RepositoryI.GetMessageByUID
func (mmGetMessageByUID *mRepositoryIMockGetMessageByUID) Return(mp1 *mm_repository.Message, err error) *RepositoryIMock {
	if mmGetMessageByUID.mock.funcGetMessageByUID != nil {
		mmGetMessageByUID.mock.t.Fatalf("RepositoryIMock.GetMessageByUID mock is already set by Set")
	}

	if mmGetMessageByUID.defaultExpectation == nil {
		mmGetMessageByUID.defaultExpectation = &RepositoryIMockGetMessageByUIDExpectation{mock: mmGetMessageByUID.mock}
	}
	mmGetMessageByUID.defaultExpectation.results = &RepositoryIMockGetMessageByUIDResults{mp1, err}
	return mmGetMessageByUID.mock
}

// Set uses given function f to mock the RepositoryI.GetMessageByUID method
func (mmGetMessageByUID *mRepositoryIMockGetMessageByUID) Set(f func(ctx context.Context, messageUID uuid.UUID) (mp1 *mm_repository.Message, err error)) *RepositoryIMock {
	if mmGetMessageByUID.defaultExpectation != nil {
		mmGetMessageByUID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetMessageByUID method")
	}

	if len(mmGetMessageByUID.expectations) > 0 {
		mmGetMessageByUID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetMessageByUID method")
	}

	mmGetMessageByUID.mock.funcGetMessageByUID = f
	return mmGetMessageByUID.mock
}

// When sets expectation for the RepositoryI.GetMessageByUID which will trigger the result defined by the following
// Then helper
func (mmGetMessageByUID *mRepositoryIMockGetMessageByUID) When(ctx context.Context, messageUID uuid.UUID) *RepositoryIMockGetMessageByUIDExpectation {
	if mmGetMessageByUID.mock.funcGetMessageByUID != nil {
		mmGetMessageByUID.mock.t.Fatalf("RepositoryIMock.GetMessageByUID mock is already set by Set")
	}

	expectation := &RepositoryIMockGetMessageByUIDExpectation{
		mock:   mmGetMessageByUID.mock,
		params: &RepositoryIMockGetMessageByUIDParams{ctx, messageUID},
	}
	mmGetMessageByUID.expectations = append(mmGetMessageByUID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetMessageByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetMessageByUIDExpectation) Then(mp1 *mm_repository.Message, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetMessageByUIDResults{mp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetMessageByUID should be invoked
func (mmGetMessageByUID *mRepositoryIMockGetMessageByUID) Times(n uint64) *mRepositoryIMockGetMessageByUID {
	if n == 0 {
		mmGetMessageByUID.mock.t.Fatalf("Times of RepositoryIMock.GetMessageByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetMessageByUID.expectedInvocations, n)
	return mmGetMessageByUID
}

func (mmGetMessageByUID *mRepositoryIMockGetMessageByUID) invocationsDone() bool {
	if len(mmGetMessageByUID.expectations) == 0 && mmGetMessageByUID.defaultExpectation == nil && mmGetMessageByUID.mock.funcGetMessageByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetMessageByUID.mock.afterGetMessageByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetMessageByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetMessageByUID implements repository.RepositoryI
func (mmGetMessageByUID *RepositoryIMock) GetMessageByUID(ctx context.Context, messageUID uuid.UUID) (mp1 *mm_repository.Message, err error) {
	mm_atomic.AddUint64(&mmGetMessageByUID.beforeGetMessageByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetMessageByUID.afterGetMessageByUIDCounter, 1)

	if mmGetMessageByUID.inspectFuncGetMessageByUID != nil {
		mmGetMessageByUID.inspectFuncGetMessageByUID(ctx, messageUID)
	}

	mm_params := RepositoryIMockGetMessageByUIDParams{ctx, messageUID}

	// Record call args
	mmGetMessageByUID.GetMessageByUIDMock.mutex.Lock()
	mmGetMessageByUID.GetMessageByUIDMock.callArgs = append(mmGetMessageByUID.GetMessageByUIDMock.callArgs, &mm_params)
	mmGetMessageByUID.GetMessageByUIDMock.mutex.Unlock()

	for _, e := range mmGetMessageByUID.GetMessageByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmGetMessageByUID.GetMessageByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetMessageByUID.GetMessageByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetMessageByUID.GetMessageByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetMessageByUID.GetMessageByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetMessageByUIDParams{ctx, messageUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetMessageByUID.t.Errorf("RepositoryIMock.GetMessageByUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.messageUID != nil && !minimock.Equal(*mm_want_ptrs.messageUID, mm_got.messageUID) {
				mmGetMessageByUID.t.Errorf("RepositoryIMock.GetMessageByUID got unexpected parameter messageUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.messageUID, mm_got.messageUID, minimock.Diff(*mm_want_ptrs.messageUID, mm_got.messageUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetMessageByUID.t.Errorf("RepositoryIMock.GetMessageByUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetMessageByUID.GetMessageByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetMessageByUID.t.Fatal("No results are set for the RepositoryIMock.GetMessageByUID")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmGetMessageByUID.funcGetMessageByUID != nil {
		return mmGetMessageByUID.funcGetMessageByUID(ctx, messageUID)
	}
	mmGetMessageByUID.t.Fatalf("Unexpected call to RepositoryIMock.GetMessageByUID. %v %v", ctx, messageUID)
	return
}

// GetMessageByUIDAfterCounter returns a count of finished RepositoryIMock.GetMessageByUID invocations
func (mmGetMessageByUID *RepositoryIMock) GetMessageByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMessageByUID.afterGetMessageByUIDCounter)
}

// GetMessageByUIDBeforeCounter returns a count of RepositoryIMock.GetMessageByUID invocations
func (mmGetMessageByUID *RepositoryIMock) GetMessageByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMessageByUID.beforeGetMessageByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetMessageByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetMessageByUID *mRepositoryIMockGetMessageByUID) Calls() []*RepositoryIMockGetMessageByUIDParams {
	mmGetMessageByUID.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetMessageByUIDParams, len(mmGetMessageByUID.callArgs))
	copy(argCopy, mmGetMessageByUID.callArgs)

	mmGetMessageByUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetMessageByUIDDone returns true if the count of the GetMessageByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetMessageByUIDDone() bool {
	for _, e := range m.GetMessageByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMessageByUIDMock.invocationsDone()
}

// MinimockGetMessageByUIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetMessageByUIDInspect() {
	for _, e := range m.GetMessageByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetMessageByUID with params: %#v", *e.params)
		}
	}

	afterGetMessageByUIDCounter := mm_atomic.LoadUint64(&m.afterGetMessageByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMessageByUIDMock.defaultExpectation != nil && afterGetMessageByUIDCounter < 1 {
		if m.GetMessageByUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetMessageByUID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetMessageByUID with params: %#v", *m.GetMessageByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMessageByUID != nil && afterGetMessageByUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetMessageByUID")
	}

	if !m.GetMessageByUIDMock.invocationsDone() && afterGetMessageByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetMessageByUID but found %d calls",
			mm_atomic.LoadUint64(&m.GetMessageByUIDMock.expectedInvocations), afterGetMessageByUIDCounter)
	}
}

type mRepositoryIMockGetNeedProcessFiles struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetNeedProcessFilesExpectation
	expectations       []*RepositoryIMockGetNeedProcessFilesExpectation

	callArgs []*RepositoryIMockGetNeedProcessFilesParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetNeedProcessFilesExpectation specifies expectation struct of the RepositoryI.GetNeedProcessFiles
type RepositoryIMockGetNeedProcessFilesExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetNeedProcessFilesParams
	paramPtrs *RepositoryIMockGetNeedProcessFilesParamPtrs
	results   *RepositoryIMockGetNeedProcessFilesResults
	Counter   uint64
}

// RepositoryIMockGetNeedProcessFilesParams contains parameters of the RepositoryI.GetNeedProcessFiles
type RepositoryIMockGetNeedProcessFilesParams struct {
	ctx context.Context
}

// RepositoryIMockGetNeedProcessFilesParamPtrs contains pointers to parameters of the RepositoryI.GetNeedProcessFiles
type RepositoryIMockGetNeedProcessFilesParamPtrs struct {
	ctx *context.Context
}

// RepositoryIMockGetNeedProcessFilesResults contains results of the RepositoryI.GetNeedProcessFiles
type RepositoryIMockGetNeedProcessFilesResults struct {
	ka1 []mm_repository.KnowledgeBaseFile
}

// Expect sets up expected params for RepositoryI.GetNeedProcessFiles
func (mmGetNeedProcessFiles *mRepositoryIMockGetNeedProcessFiles) Expect(ctx context.Context) *mRepositoryIMockGetNeedProcessFiles {
	if mmGetNeedProcessFiles.mock.funcGetNeedProcessFiles != nil {
		mmGetNeedProcessFiles.mock.t.Fatalf("RepositoryIMock.GetNeedProcessFiles mock is already set by Set")
	}

	if mmGetNeedProcessFiles.defaultExpectation == nil {
		mmGetNeedProcessFiles.defaultExpectation = &RepositoryIMockGetNeedProcessFilesExpectation{}
	}

	if mmGetNeedProcessFiles.defaultExpectation.paramPtrs != nil {
		mmGetNeedProcessFiles.mock.t.Fatalf("RepositoryIMock.GetNeedProcessFiles mock is already set by ExpectParams functions")
	}

	mmGetNeedProcessFiles.defaultExpectation.params = &RepositoryIMockGetNeedProcessFilesParams{ctx}
	for _, e := range mmGetNeedProcessFiles.expectations {
		if minimock.Equal(e.params, mmGetNeedProcessFiles.defaultExpectation.params) {
			mmGetNeedProcessFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetNeedProcessFiles.defaultExpectation.params)
		}
	}

	return mmGetNeedProcessFiles
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetNeedProcessFiles
func (mmGetNeedProcessFiles *mRepositoryIMockGetNeedProcessFiles) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetNeedProcessFiles {
	if mmGetNeedProcessFiles.mock.funcGetNeedProcessFiles != nil {
		mmGetNeedProcessFiles.mock.t.Fatalf("RepositoryIMock.GetNeedProcessFiles mock is already set by Set")
	}

	if mmGetNeedProcessFiles.defaultExpectation == nil {
		mmGetNeedProcessFiles.defaultExpectation = &RepositoryIMockGetNeedProcessFilesExpectation{}
	}

	if mmGetNeedProcessFiles.defaultExpectation.params != nil {
		mmGetNeedProcessFiles.mock.t.Fatalf("RepositoryIMock.GetNeedProcessFiles mock is already set by Expect")
	}

	if mmGetNeedProcessFiles.defaultExpectation.paramPtrs == nil {
		mmGetNeedProcessFiles.defaultExpectation.paramPtrs = &RepositoryIMockGetNeedProcessFilesParamPtrs{}
	}
	mmGetNeedProcessFiles.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetNeedProcessFiles
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetNeedProcessFiles
func (mmGetNeedProcessFiles *mRepositoryIMockGetNeedProcessFiles) Inspect(f func(ctx context.Context)) *mRepositoryIMockGetNeedProcessFiles {
	if mmGetNeedProcessFiles.mock.inspectFuncGetNeedProcessFiles != nil {
		mmGetNeedProcessFiles.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetNeedProcessFiles")
	}

	mmGetNeedProcessFiles.mock.inspectFuncGetNeedProcessFiles = f

	return mmGetNeedProcessFiles
}

// Return sets up results that will be returned by RepositoryI.GetNeedProcessFiles
func (mmGetNeedProcessFiles *mRepositoryIMockGetNeedProcessFiles) Return(ka1 []mm_repository.KnowledgeBaseFile) *RepositoryIMock {
	if mmGetNeedProcessFiles.mock.funcGetNeedProcessFiles != nil {
		mmGetNeedProcessFiles.mock.t.Fatalf("RepositoryIMock.GetNeedProcessFiles mock is already set by Set")
	}

	if mmGetNeedProcessFiles.defaultExpectation == nil {
		mmGetNeedProcessFiles.defaultExpectation = &RepositoryIMockGetNeedProcessFilesExpectation{mock: mmGetNeedProcessFiles.mock}
	}
	mmGetNeedProcessFiles.defaultExpectation.results = &RepositoryIMockGetNeedProcessFilesResults{ka1}
	return mmGetNeedProcessFiles.mock
}

// Set uses given function f to mock the RepositoryI.GetNeedProcessFiles method
func (mmGetNeedProcessFiles *mRepositoryIMockGetNeedProcessFiles) Set(f func(ctx context.Context) (ka1 []mm_repository.KnowledgeBaseFile)) *RepositoryIMock {
	if mmGetNeedProcessFiles.defaultExpectation != nil {
		mmGetNeedProcessFiles.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetNeedProcessFiles method")
	}

	if len(mmGetNeedProcessFiles.expectations) > 0 {
		mmGetNeedProcessFiles.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetNeedProcessFiles method")
	}

	mmGetNeedProcessFiles.mock.funcGetNeedProcessFiles = f
	return mmGetNeedProcessFiles.mock
}

// When sets expectation for the RepositoryI.GetNeedProcessFiles which will trigger the result defined by the following
// Then helper
func (mmGetNeedProcessFiles *mRepositoryIMockGetNeedProcessFiles) When(ctx context.Context) *RepositoryIMockGetNeedProcessFilesExpectation {
	if mmGetNeedProcessFiles.mock.funcGetNeedProcessFiles != nil {
		mmGetNeedProcessFiles.mock.t.Fatalf("RepositoryIMock.GetNeedProcessFiles mock is already set by Set")
	}

	expectation := &RepositoryIMockGetNeedProcessFilesExpectation{
		mock:   mmGetNeedProcessFiles.mock,
		params: &RepositoryIMockGetNeedProcessFilesParams{ctx},
	}
	mmGetNeedProcessFiles.expectations = append(mmGetNeedProcessFiles.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetNeedProcessFiles return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetNeedProcessFilesExpectation) Then(ka1 []mm_repository.KnowledgeBaseFile) *RepositoryIMock {
	e.results = &RepositoryIMockGetNeedProcessFilesResults{ka1}
	return e.mock
}

// Times sets number of times RepositoryI.GetNeedProcessFiles should be invoked
func (mmGetNeedProcessFiles *mRepositoryIMockGetNeedProcessFiles) Times(n uint64) *mRepositoryIMockGetNeedProcessFiles {
	if n == 0 {
		mmGetNeedProcessFiles.mock.t.Fatalf("Times of RepositoryIMock.GetNeedProcessFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetNeedProcessFiles.expectedInvocations, n)
	return mmGetNeedProcessFiles
}

func (mmGetNeedProcessFiles *mRepositoryIMockGetNeedProcessFiles) invocationsDone() bool {
	if len(mmGetNeedProcessFiles.expectations) == 0 && mmGetNeedProcessFiles.defaultExpectation == nil && mmGetNeedProcessFiles.mock.funcGetNeedProcessFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetNeedProcessFiles.mock.afterGetNeedProcessFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetNeedProcessFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetNeedProcessFiles implements repository.RepositoryI
func (mmGetNeedProcessFiles *RepositoryIMock) GetNeedProcessFiles(ctx context.Context) (ka1 []mm_repository.KnowledgeBaseFile) {
	mm_atomic.AddUint64(&mmGetNeedProcessFiles.beforeGetNeedProcessFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNeedProcessFiles.afterGetNeedProcessFilesCounter, 1)

	if mmGetNeedProcessFiles.inspectFuncGetNeedProcessFiles != nil {
		mmGetNeedProcessFiles.inspectFuncGetNeedProcessFiles(ctx)
	}

	mm_params := RepositoryIMockGetNeedProcessFilesParams{ctx}

	// Record call args
	mmGetNeedProcessFiles.GetNeedProcessFilesMock.mutex.Lock()
	mmGetNeedProcessFiles.GetNeedProcessFilesMock.callArgs = append(mmGetNeedProcessFiles.GetNeedProcessFilesMock.callArgs, &mm_params)
	mmGetNeedProcessFiles.GetNeedProcessFilesMock.mutex.Unlock()

	for _, e := range mmGetNeedProcessFiles.GetNeedProcessFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1
		}
	}

	if mmGetNeedProcessFiles.GetNeedProcessFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNeedProcessFiles.GetNeedProcessFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmGetNeedProcessFiles.GetNeedProcessFilesMock.defaultExpectation.params
		mm_want_ptrs := mmGetNeedProcessFiles.GetNeedProcessFilesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetNeedProcessFilesParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetNeedProcessFiles.t.Errorf("RepositoryIMock.GetNeedProcessFiles got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetNeedProcessFiles.t.Errorf("RepositoryIMock.GetNeedProcessFiles got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetNeedProcessFiles.GetNeedProcessFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNeedProcessFiles.t.Fatal("No results are set for the RepositoryIMock.GetNeedProcessFiles")
		}
		return (*mm_results).ka1
	}
	if mmGetNeedProcessFiles.funcGetNeedProcessFiles != nil {
		return mmGetNeedProcessFiles.funcGetNeedProcessFiles(ctx)
	}
	mmGetNeedProcessFiles.t.Fatalf("Unexpected call to RepositoryIMock.GetNeedProcessFiles. %v", ctx)
	return
}

// GetNeedProcessFilesAfterCounter returns a count of finished RepositoryIMock.GetNeedProcessFiles invocations
func (mmGetNeedProcessFiles *RepositoryIMock) GetNeedProcessFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNeedProcessFiles.afterGetNeedProcessFilesCounter)
}

// GetNeedProcessFilesBeforeCounter returns a count of RepositoryIMock.GetNeedProcessFiles invocations
func (mmGetNeedProcessFiles *RepositoryIMock) GetNeedProcessFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNeedProcessFiles.beforeGetNeedProcessFilesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetNeedProcessFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetNeedProcessFiles *mRepositoryIMockGetNeedProcessFiles) Calls() []*RepositoryIMockGetNeedProcessFilesParams {
	mmGetNeedProcessFiles.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetNeedProcessFilesParams, len(mmGetNeedProcessFiles.callArgs))
	copy(argCopy, mmGetNeedProcessFiles.callArgs)

	mmGetNeedProcessFiles.mutex.RUnlock()

	return argCopy
}

// MinimockGetNeedProcessFilesDone returns true if the count of the GetNeedProcessFiles invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetNeedProcessFilesDone() bool {
	for _, e := range m.GetNeedProcessFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetNeedProcessFilesMock.invocationsDone()
}

// MinimockGetNeedProcessFilesInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetNeedProcessFilesInspect() {
	for _, e := range m.GetNeedProcessFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetNeedProcessFiles with params: %#v", *e.params)
		}
	}

	afterGetNeedProcessFilesCounter := mm_atomic.LoadUint64(&m.afterGetNeedProcessFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetNeedProcessFilesMock.defaultExpectation != nil && afterGetNeedProcessFilesCounter < 1 {
		if m.GetNeedProcessFilesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetNeedProcessFiles")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetNeedProcessFiles with params: %#v", *m.GetNeedProcessFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNeedProcessFiles != nil && afterGetNeedProcessFilesCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetNeedProcessFiles")
	}

	if !m.GetNeedProcessFilesMock.invocationsDone() && afterGetNeedProcessFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetNeedProcessFiles but found %d calls",
			mm_atomic.LoadUint64(&m.GetNeedProcessFilesMock.expectedInvocations), afterGetNeedProcessFilesCounter)
	}
}

type mRepositoryIMockGetRepositoryTag struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetRepositoryTagExpectation
	expectations       []*RepositoryIMockGetRepositoryTagExpectation

	callArgs []*RepositoryIMockGetRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetRepositoryTagExpectation specifies expectation struct of the RepositoryI.GetRepositoryTag
type RepositoryIMockGetRepositoryTagExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetRepositoryTagParams
	paramPtrs *RepositoryIMockGetRepositoryTagParamPtrs
	results   *RepositoryIMockGetRepositoryTagResults
	Counter   uint64
}

// RepositoryIMockGetRepositoryTagParams contains parameters of the RepositoryI.GetRepositoryTag
type RepositoryIMockGetRepositoryTagParams struct {
	ctx context.Context
	r1  utils.RepositoryTagName
}

// RepositoryIMockGetRepositoryTagParamPtrs contains pointers to parameters of the RepositoryI.GetRepositoryTag
type RepositoryIMockGetRepositoryTagParamPtrs struct {
	ctx *context.Context
	r1  *utils.RepositoryTagName
}

// RepositoryIMockGetRepositoryTagResults contains results of the RepositoryI.GetRepositoryTag
type RepositoryIMockGetRepositoryTagResults struct {
	rp1 *pb.RepositoryTag
	err error
}

// Expect sets up expected params for RepositoryI.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) Expect(ctx context.Context, r1 utils.RepositoryTagName) *mRepositoryIMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryIMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by ExpectParams functions")
	}

	mmGetRepositoryTag.defaultExpectation.params = &RepositoryIMockGetRepositoryTagParams{ctx, r1}
	for _, e := range mmGetRepositoryTag.expectations {
		if minimock.Equal(e.params, mmGetRepositoryTag.defaultExpectation.params) {
			mmGetRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRepositoryTag.defaultExpectation.params)
		}
	}

	return mmGetRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryIMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.params != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by Expect")
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmGetRepositoryTag.defaultExpectation.paramPtrs = &RepositoryIMockGetRepositoryTagParamPtrs{}
	}
	mmGetRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetRepositoryTag
}

// ExpectR1Param2 sets up expected param r1 for RepositoryI.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) ExpectR1Param2(r1 utils.RepositoryTagName) *mRepositoryIMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryIMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.params != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by Expect")
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmGetRepositoryTag.defaultExpectation.paramPtrs = &RepositoryIMockGetRepositoryTagParamPtrs{}
	}
	mmGetRepositoryTag.defaultExpectation.paramPtrs.r1 = &r1

	return mmGetRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) Inspect(f func(ctx context.Context, r1 utils.RepositoryTagName)) *mRepositoryIMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.inspectFuncGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetRepositoryTag")
	}

	mmGetRepositoryTag.mock.inspectFuncGetRepositoryTag = f

	return mmGetRepositoryTag
}

// Return sets up results that will be returned by RepositoryI.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) Return(rp1 *pb.RepositoryTag, err error) *RepositoryIMock {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryIMockGetRepositoryTagExpectation{mock: mmGetRepositoryTag.mock}
	}
	mmGetRepositoryTag.defaultExpectation.results = &RepositoryIMockGetRepositoryTagResults{rp1, err}
	return mmGetRepositoryTag.mock
}

// Set uses given function f to mock the RepositoryI.GetRepositoryTag method
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) Set(f func(ctx context.Context, r1 utils.RepositoryTagName) (rp1 *pb.RepositoryTag, err error)) *RepositoryIMock {
	if mmGetRepositoryTag.defaultExpectation != nil {
		mmGetRepositoryTag.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetRepositoryTag method")
	}

	if len(mmGetRepositoryTag.expectations) > 0 {
		mmGetRepositoryTag.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetRepositoryTag method")
	}

	mmGetRepositoryTag.mock.funcGetRepositoryTag = f
	return mmGetRepositoryTag.mock
}

// When sets expectation for the RepositoryI.GetRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) When(ctx context.Context, r1 utils.RepositoryTagName) *RepositoryIMockGetRepositoryTagExpectation {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by Set")
	}

	expectation := &RepositoryIMockGetRepositoryTagExpectation{
		mock:   mmGetRepositoryTag.mock,
		params: &RepositoryIMockGetRepositoryTagParams{ctx, r1},
	}
	mmGetRepositoryTag.expectations = append(mmGetRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetRepositoryTag return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetRepositoryTagExpectation) Then(rp1 *pb.RepositoryTag, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetRepositoryTagResults{rp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetRepositoryTag should be invoked
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) Times(n uint64) *mRepositoryIMockGetRepositoryTag {
	if n == 0 {
		mmGetRepositoryTag.mock.t.Fatalf("Times of RepositoryIMock.GetRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRepositoryTag.expectedInvocations, n)
	return mmGetRepositoryTag
}

func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) invocationsDone() bool {
	if len(mmGetRepositoryTag.expectations) == 0 && mmGetRepositoryTag.defaultExpectation == nil && mmGetRepositoryTag.mock.funcGetRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRepositoryTag.mock.afterGetRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRepositoryTag implements repository.RepositoryI
func (mmGetRepositoryTag *RepositoryIMock) GetRepositoryTag(ctx context.Context, r1 utils.RepositoryTagName) (rp1 *pb.RepositoryTag, err error) {
	mm_atomic.AddUint64(&mmGetRepositoryTag.beforeGetRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRepositoryTag.afterGetRepositoryTagCounter, 1)

	if mmGetRepositoryTag.inspectFuncGetRepositoryTag != nil {
		mmGetRepositoryTag.inspectFuncGetRepositoryTag(ctx, r1)
	}

	mm_params := RepositoryIMockGetRepositoryTagParams{ctx, r1}

	// Record call args
	mmGetRepositoryTag.GetRepositoryTagMock.mutex.Lock()
	mmGetRepositoryTag.GetRepositoryTagMock.callArgs = append(mmGetRepositoryTag.GetRepositoryTagMock.callArgs, &mm_params)
	mmGetRepositoryTag.GetRepositoryTagMock.mutex.Unlock()

	for _, e := range mmGetRepositoryTag.GetRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetRepositoryTagParams{ctx, r1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetRepositoryTag.t.Errorf("RepositoryIMock.GetRepositoryTag got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.r1 != nil && !minimock.Equal(*mm_want_ptrs.r1, mm_got.r1) {
				mmGetRepositoryTag.t.Errorf("RepositoryIMock.GetRepositoryTag got unexpected parameter r1, want: %#v, got: %#v%s\n", *mm_want_ptrs.r1, mm_got.r1, minimock.Diff(*mm_want_ptrs.r1, mm_got.r1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRepositoryTag.t.Errorf("RepositoryIMock.GetRepositoryTag got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRepositoryTag.t.Fatal("No results are set for the RepositoryIMock.GetRepositoryTag")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmGetRepositoryTag.funcGetRepositoryTag != nil {
		return mmGetRepositoryTag.funcGetRepositoryTag(ctx, r1)
	}
	mmGetRepositoryTag.t.Fatalf("Unexpected call to RepositoryIMock.GetRepositoryTag. %v %v", ctx, r1)
	return
}

// GetRepositoryTagAfterCounter returns a count of finished RepositoryIMock.GetRepositoryTag invocations
func (mmGetRepositoryTag *RepositoryIMock) GetRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRepositoryTag.afterGetRepositoryTagCounter)
}

// GetRepositoryTagBeforeCounter returns a count of RepositoryIMock.GetRepositoryTag invocations
func (mmGetRepositoryTag *RepositoryIMock) GetRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRepositoryTag.beforeGetRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) Calls() []*RepositoryIMockGetRepositoryTagParams {
	mmGetRepositoryTag.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetRepositoryTagParams, len(mmGetRepositoryTag.callArgs))
	copy(argCopy, mmGetRepositoryTag.callArgs)

	mmGetRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockGetRepositoryTagDone returns true if the count of the GetRepositoryTag invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetRepositoryTagDone() bool {
	for _, e := range m.GetRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRepositoryTagMock.invocationsDone()
}

// MinimockGetRepositoryTagInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetRepositoryTagInspect() {
	for _, e := range m.GetRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetRepositoryTag with params: %#v", *e.params)
		}
	}

	afterGetRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterGetRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRepositoryTagMock.defaultExpectation != nil && afterGetRepositoryTagCounter < 1 {
		if m.GetRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetRepositoryTag")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetRepositoryTag with params: %#v", *m.GetRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRepositoryTag != nil && afterGetRepositoryTagCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetRepositoryTag")
	}

	if !m.GetRepositoryTagMock.invocationsDone() && afterGetRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetRepositoryTag but found %d calls",
			mm_atomic.LoadUint64(&m.GetRepositoryTagMock.expectedInvocations), afterGetRepositoryTagCounter)
	}
}

type mRepositoryIMockGetSourceTableAndUIDByFileUIDs struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetSourceTableAndUIDByFileUIDsExpectation
	expectations       []*RepositoryIMockGetSourceTableAndUIDByFileUIDsExpectation

	callArgs []*RepositoryIMockGetSourceTableAndUIDByFileUIDsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetSourceTableAndUIDByFileUIDsExpectation specifies expectation struct of the RepositoryI.GetSourceTableAndUIDByFileUIDs
type RepositoryIMockGetSourceTableAndUIDByFileUIDsExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetSourceTableAndUIDByFileUIDsParams
	paramPtrs *RepositoryIMockGetSourceTableAndUIDByFileUIDsParamPtrs
	results   *RepositoryIMockGetSourceTableAndUIDByFileUIDsResults
	Counter   uint64
}

// RepositoryIMockGetSourceTableAndUIDByFileUIDsParams contains parameters of the RepositoryI.GetSourceTableAndUIDByFileUIDs
type RepositoryIMockGetSourceTableAndUIDByFileUIDsParams struct {
	ctx   context.Context
	files []mm_repository.KnowledgeBaseFile
}

// RepositoryIMockGetSourceTableAndUIDByFileUIDsParamPtrs contains pointers to parameters of the RepositoryI.GetSourceTableAndUIDByFileUIDs
type RepositoryIMockGetSourceTableAndUIDByFileUIDsParamPtrs struct {
	ctx   *context.Context
	files *[]mm_repository.KnowledgeBaseFile
}

// RepositoryIMockGetSourceTableAndUIDByFileUIDsResults contains results of the RepositoryI.GetSourceTableAndUIDByFileUIDs
type RepositoryIMockGetSourceTableAndUIDByFileUIDsResults struct {
	m1 map[mm_repository.FileUID]struct {
		SourceTable string
		SourceUID   uuid.UUID
	}
	err error
}

// Expect sets up expected params for RepositoryI.GetSourceTableAndUIDByFileUIDs
func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryIMockGetSourceTableAndUIDByFileUIDs) Expect(ctx context.Context, files []mm_repository.KnowledgeBaseFile) *mRepositoryIMockGetSourceTableAndUIDByFileUIDs {
	if mmGetSourceTableAndUIDByFileUIDs.mock.funcGetSourceTableAndUIDByFileUIDs != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetSourceTableAndUIDByFileUIDs mock is already set by Set")
	}

	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation == nil {
		mmGetSourceTableAndUIDByFileUIDs.defaultExpectation = &RepositoryIMockGetSourceTableAndUIDByFileUIDsExpectation{}
	}

	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.paramPtrs != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetSourceTableAndUIDByFileUIDs mock is already set by ExpectParams functions")
	}

	mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.params = &RepositoryIMockGetSourceTableAndUIDByFileUIDsParams{ctx, files}
	for _, e := range mmGetSourceTableAndUIDByFileUIDs.expectations {
		if minimock.Equal(e.params, mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.params) {
			mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.params)
		}
	}

	return mmGetSourceTableAndUIDByFileUIDs
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetSourceTableAndUIDByFileUIDs
func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryIMockGetSourceTableAndUIDByFileUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetSourceTableAndUIDByFileUIDs {
	if mmGetSourceTableAndUIDByFileUIDs.mock.funcGetSourceTableAndUIDByFileUIDs != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetSourceTableAndUIDByFileUIDs mock is already set by Set")
	}

	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation == nil {
		mmGetSourceTableAndUIDByFileUIDs.defaultExpectation = &RepositoryIMockGetSourceTableAndUIDByFileUIDsExpectation{}
	}

	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.params != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetSourceTableAndUIDByFileUIDs mock is already set by Expect")
	}

	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.paramPtrs == nil {
		mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.paramPtrs = &RepositoryIMockGetSourceTableAndUIDByFileUIDsParamPtrs{}
	}
	mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetSourceTableAndUIDByFileUIDs
}

// ExpectFilesParam2 sets up expected param files for RepositoryI.GetSourceTableAndUIDByFileUIDs
func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryIMockGetSourceTableAndUIDByFileUIDs) ExpectFilesParam2(files []mm_repository.KnowledgeBaseFile) *mRepositoryIMockGetSourceTableAndUIDByFileUIDs {
	if mmGetSourceTableAndUIDByFileUIDs.mock.funcGetSourceTableAndUIDByFileUIDs != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetSourceTableAndUIDByFileUIDs mock is already set by Set")
	}

	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation == nil {
		mmGetSourceTableAndUIDByFileUIDs.defaultExpectation = &RepositoryIMockGetSourceTableAndUIDByFileUIDsExpectation{}
	}

	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.params != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetSourceTableAndUIDByFileUIDs mock is already set by Expect")
	}

	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.paramPtrs == nil {
		mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.paramPtrs = &RepositoryIMockGetSourceTableAndUIDByFileUIDsParamPtrs{}
	}
	mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.paramPtrs.files = &files

	return mmGetSourceTableAndUIDByFileUIDs
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetSourceTableAndUIDByFileUIDs
func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryIMockGetSourceTableAndUIDByFileUIDs) Inspect(f func(ctx context.Context, files []mm_repository.KnowledgeBaseFile)) *mRepositoryIMockGetSourceTableAndUIDByFileUIDs {
	if mmGetSourceTableAndUIDByFileUIDs.mock.inspectFuncGetSourceTableAndUIDByFileUIDs != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetSourceTableAndUIDByFileUIDs")
	}

	mmGetSourceTableAndUIDByFileUIDs.mock.inspectFuncGetSourceTableAndUIDByFileUIDs = f

	return mmGetSourceTableAndUIDByFileUIDs
}

// Return sets up results that will be returned by RepositoryI.GetSourceTableAndUIDByFileUIDs
func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryIMockGetSourceTableAndUIDByFileUIDs) Return(m1 map[mm_repository.FileUID]struct {
	SourceTable string
	SourceUID   uuid.UUID
}, err error) *RepositoryIMock {
	if mmGetSourceTableAndUIDByFileUIDs.mock.funcGetSourceTableAndUIDByFileUIDs != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetSourceTableAndUIDByFileUIDs mock is already set by Set")
	}

	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation == nil {
		mmGetSourceTableAndUIDByFileUIDs.defaultExpectation = &RepositoryIMockGetSourceTableAndUIDByFileUIDsExpectation{mock: mmGetSourceTableAndUIDByFileUIDs.mock}
	}
	mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.results = &RepositoryIMockGetSourceTableAndUIDByFileUIDsResults{m1, err}
	return mmGetSourceTableAndUIDByFileUIDs.mock
}

// Set uses given function f to mock the RepositoryI.GetSourceTableAndUIDByFileUIDs method
func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryIMockGetSourceTableAndUIDByFileUIDs) Set(f func(ctx context.Context, files []mm_repository.KnowledgeBaseFile) (m1 map[mm_repository.FileUID]struct {
	SourceTable string
	SourceUID   uuid.UUID
}, err error)) *RepositoryIMock {
	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetSourceTableAndUIDByFileUIDs method")
	}

	if len(mmGetSourceTableAndUIDByFileUIDs.expectations) > 0 {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetSourceTableAndUIDByFileUIDs method")
	}

	mmGetSourceTableAndUIDByFileUIDs.mock.funcGetSourceTableAndUIDByFileUIDs = f
	return mmGetSourceTableAndUIDByFileUIDs.mock
}

// When sets expectation for the RepositoryI.GetSourceTableAndUIDByFileUIDs which will trigger the result defined by the following
// Then helper
func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryIMockGetSourceTableAndUIDByFileUIDs) When(ctx context.Context, files []mm_repository.KnowledgeBaseFile) *RepositoryIMockGetSourceTableAndUIDByFileUIDsExpectation {
	if mmGetSourceTableAndUIDByFileUIDs.mock.funcGetSourceTableAndUIDByFileUIDs != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetSourceTableAndUIDByFileUIDs mock is already set by Set")
	}

	expectation := &RepositoryIMockGetSourceTableAndUIDByFileUIDsExpectation{
		mock:   mmGetSourceTableAndUIDByFileUIDs.mock,
		params: &RepositoryIMockGetSourceTableAndUIDByFileUIDsParams{ctx, files},
	}
	mmGetSourceTableAndUIDByFileUIDs.expectations = append(mmGetSourceTableAndUIDByFileUIDs.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetSourceTableAndUIDByFileUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetSourceTableAndUIDByFileUIDsExpectation) Then(m1 map[mm_repository.FileUID]struct {
	SourceTable string
	SourceUID   uuid.UUID
}, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetSourceTableAndUIDByFileUIDsResults{m1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetSourceTableAndUIDByFileUIDs should be invoked
func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryIMockGetSourceTableAndUIDByFileUIDs) Times(n uint64) *mRepositoryIMockGetSourceTableAndUIDByFileUIDs {
	if n == 0 {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("Times of RepositoryIMock.GetSourceTableAndUIDByFileUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetSourceTableAndUIDByFileUIDs.expectedInvocations, n)
	return mmGetSourceTableAndUIDByFileUIDs
}

func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryIMockGetSourceTableAndUIDByFileUIDs) invocationsDone() bool {
	if len(mmGetSourceTableAndUIDByFileUIDs.expectations) == 0 && mmGetSourceTableAndUIDByFileUIDs.defaultExpectation == nil && mmGetSourceTableAndUIDByFileUIDs.mock.funcGetSourceTableAndUIDByFileUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetSourceTableAndUIDByFileUIDs.mock.afterGetSourceTableAndUIDByFileUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetSourceTableAndUIDByFileUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetSourceTableAndUIDByFileUIDs implements repository.RepositoryI
func (mmGetSourceTableAndUIDByFileUIDs *RepositoryIMock) GetSourceTableAndUIDByFileUIDs(ctx context.Context, files []mm_repository.KnowledgeBaseFile) (m1 map[mm_repository.FileUID]struct {
	SourceTable string
	SourceUID   uuid.UUID
}, err error) {
	mm_atomic.AddUint64(&mmGetSourceTableAndUIDByFileUIDs.beforeGetSourceTableAndUIDByFileUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSourceTableAndUIDByFileUIDs.afterGetSourceTableAndUIDByFileUIDsCounter, 1)

	if mmGetSourceTableAndUIDByFileUIDs.inspectFuncGetSourceTableAndUIDByFileUIDs != nil {
		mmGetSourceTableAndUIDByFileUIDs.inspectFuncGetSourceTableAndUIDByFileUIDs(ctx, files)
	}

	mm_params := RepositoryIMockGetSourceTableAndUIDByFileUIDsParams{ctx, files}

	// Record call args
	mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.mutex.Lock()
	mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.callArgs = append(mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.callArgs, &mm_params)
	mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.mutex.Unlock()

	for _, e := range mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetSourceTableAndUIDByFileUIDsParams{ctx, files}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetSourceTableAndUIDByFileUIDs.t.Errorf("RepositoryIMock.GetSourceTableAndUIDByFileUIDs got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.files != nil && !minimock.Equal(*mm_want_ptrs.files, mm_got.files) {
				mmGetSourceTableAndUIDByFileUIDs.t.Errorf("RepositoryIMock.GetSourceTableAndUIDByFileUIDs got unexpected parameter files, want: %#v, got: %#v%s\n", *mm_want_ptrs.files, mm_got.files, minimock.Diff(*mm_want_ptrs.files, mm_got.files))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSourceTableAndUIDByFileUIDs.t.Errorf("RepositoryIMock.GetSourceTableAndUIDByFileUIDs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSourceTableAndUIDByFileUIDs.t.Fatal("No results are set for the RepositoryIMock.GetSourceTableAndUIDByFileUIDs")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetSourceTableAndUIDByFileUIDs.funcGetSourceTableAndUIDByFileUIDs != nil {
		return mmGetSourceTableAndUIDByFileUIDs.funcGetSourceTableAndUIDByFileUIDs(ctx, files)
	}
	mmGetSourceTableAndUIDByFileUIDs.t.Fatalf("Unexpected call to RepositoryIMock.GetSourceTableAndUIDByFileUIDs. %v %v", ctx, files)
	return
}

// GetSourceTableAndUIDByFileUIDsAfterCounter returns a count of finished RepositoryIMock.GetSourceTableAndUIDByFileUIDs invocations
func (mmGetSourceTableAndUIDByFileUIDs *RepositoryIMock) GetSourceTableAndUIDByFileUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSourceTableAndUIDByFileUIDs.afterGetSourceTableAndUIDByFileUIDsCounter)
}

// GetSourceTableAndUIDByFileUIDsBeforeCounter returns a count of RepositoryIMock.GetSourceTableAndUIDByFileUIDs invocations
func (mmGetSourceTableAndUIDByFileUIDs *RepositoryIMock) GetSourceTableAndUIDByFileUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSourceTableAndUIDByFileUIDs.beforeGetSourceTableAndUIDByFileUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetSourceTableAndUIDByFileUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryIMockGetSourceTableAndUIDByFileUIDs) Calls() []*RepositoryIMockGetSourceTableAndUIDByFileUIDsParams {
	mmGetSourceTableAndUIDByFileUIDs.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetSourceTableAndUIDByFileUIDsParams, len(mmGetSourceTableAndUIDByFileUIDs.callArgs))
	copy(argCopy, mmGetSourceTableAndUIDByFileUIDs.callArgs)

	mmGetSourceTableAndUIDByFileUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockGetSourceTableAndUIDByFileUIDsDone returns true if the count of the GetSourceTableAndUIDByFileUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetSourceTableAndUIDByFileUIDsDone() bool {
	for _, e := range m.GetSourceTableAndUIDByFileUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetSourceTableAndUIDByFileUIDsMock.invocationsDone()
}

// MinimockGetSourceTableAndUIDByFileUIDsInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetSourceTableAndUIDByFileUIDsInspect() {
	for _, e := range m.GetSourceTableAndUIDByFileUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetSourceTableAndUIDByFileUIDs with params: %#v", *e.params)
		}
	}

	afterGetSourceTableAndUIDByFileUIDsCounter := mm_atomic.LoadUint64(&m.afterGetSourceTableAndUIDByFileUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetSourceTableAndUIDByFileUIDsMock.defaultExpectation != nil && afterGetSourceTableAndUIDByFileUIDsCounter < 1 {
		if m.GetSourceTableAndUIDByFileUIDsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetSourceTableAndUIDByFileUIDs")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetSourceTableAndUIDByFileUIDs with params: %#v", *m.GetSourceTableAndUIDByFileUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSourceTableAndUIDByFileUIDs != nil && afterGetSourceTableAndUIDByFileUIDsCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetSourceTableAndUIDByFileUIDs")
	}

	if !m.GetSourceTableAndUIDByFileUIDsMock.invocationsDone() && afterGetSourceTableAndUIDByFileUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetSourceTableAndUIDByFileUIDs but found %d calls",
			mm_atomic.LoadUint64(&m.GetSourceTableAndUIDByFileUIDsMock.expectedInvocations), afterGetSourceTableAndUIDByFileUIDsCounter)
	}
}

type mRepositoryIMockGetTextChunksBySource struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetTextChunksBySourceExpectation
	expectations       []*RepositoryIMockGetTextChunksBySourceExpectation

	callArgs []*RepositoryIMockGetTextChunksBySourceParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetTextChunksBySourceExpectation specifies expectation struct of the RepositoryI.GetTextChunksBySource
type RepositoryIMockGetTextChunksBySourceExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetTextChunksBySourceParams
	paramPtrs *RepositoryIMockGetTextChunksBySourceParamPtrs
	results   *RepositoryIMockGetTextChunksBySourceResults
	Counter   uint64
}

// RepositoryIMockGetTextChunksBySourceParams contains parameters of the RepositoryI.GetTextChunksBySource
type RepositoryIMockGetTextChunksBySourceParams struct {
	ctx         context.Context
	sourceTable string
	sourceUID   uuid.UUID
}

// RepositoryIMockGetTextChunksBySourceParamPtrs contains pointers to parameters of the RepositoryI.GetTextChunksBySource
type RepositoryIMockGetTextChunksBySourceParamPtrs struct {
	ctx         *context.Context
	sourceTable *string
	sourceUID   *uuid.UUID
}

// RepositoryIMockGetTextChunksBySourceResults contains results of the RepositoryI.GetTextChunksBySource
type RepositoryIMockGetTextChunksBySourceResults struct {
	ta1 []mm_repository.TextChunk
	err error
}

// Expect sets up expected params for RepositoryI.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) Expect(ctx context.Context, sourceTable string, sourceUID uuid.UUID) *mRepositoryIMockGetTextChunksBySource {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by Set")
	}

	if mmGetTextChunksBySource.defaultExpectation == nil {
		mmGetTextChunksBySource.defaultExpectation = &RepositoryIMockGetTextChunksBySourceExpectation{}
	}

	if mmGetTextChunksBySource.defaultExpectation.paramPtrs != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by ExpectParams functions")
	}

	mmGetTextChunksBySource.defaultExpectation.params = &RepositoryIMockGetTextChunksBySourceParams{ctx, sourceTable, sourceUID}
	for _, e := range mmGetTextChunksBySource.expectations {
		if minimock.Equal(e.params, mmGetTextChunksBySource.defaultExpectation.params) {
			mmGetTextChunksBySource.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTextChunksBySource.defaultExpectation.params)
		}
	}

	return mmGetTextChunksBySource
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetTextChunksBySource {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by Set")
	}

	if mmGetTextChunksBySource.defaultExpectation == nil {
		mmGetTextChunksBySource.defaultExpectation = &RepositoryIMockGetTextChunksBySourceExpectation{}
	}

	if mmGetTextChunksBySource.defaultExpectation.params != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by Expect")
	}

	if mmGetTextChunksBySource.defaultExpectation.paramPtrs == nil {
		mmGetTextChunksBySource.defaultExpectation.paramPtrs = &RepositoryIMockGetTextChunksBySourceParamPtrs{}
	}
	mmGetTextChunksBySource.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetTextChunksBySource
}

// ExpectSourceTableParam2 sets up expected param sourceTable for RepositoryI.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) ExpectSourceTableParam2(sourceTable string) *mRepositoryIMockGetTextChunksBySource {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by Set")
	}

	if mmGetTextChunksBySource.defaultExpectation == nil {
		mmGetTextChunksBySource.defaultExpectation = &RepositoryIMockGetTextChunksBySourceExpectation{}
	}

	if mmGetTextChunksBySource.defaultExpectation.params != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by Expect")
	}

	if mmGetTextChunksBySource.defaultExpectation.paramPtrs == nil {
		mmGetTextChunksBySource.defaultExpectation.paramPtrs = &RepositoryIMockGetTextChunksBySourceParamPtrs{}
	}
	mmGetTextChunksBySource.defaultExpectation.paramPtrs.sourceTable = &sourceTable

	return mmGetTextChunksBySource
}

// ExpectSourceUIDParam3 sets up expected param sourceUID for RepositoryI.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) ExpectSourceUIDParam3(sourceUID uuid.UUID) *mRepositoryIMockGetTextChunksBySource {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by Set")
	}

	if mmGetTextChunksBySource.defaultExpectation == nil {
		mmGetTextChunksBySource.defaultExpectation = &RepositoryIMockGetTextChunksBySourceExpectation{}
	}

	if mmGetTextChunksBySource.defaultExpectation.params != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by Expect")
	}

	if mmGetTextChunksBySource.defaultExpectation.paramPtrs == nil {
		mmGetTextChunksBySource.defaultExpectation.paramPtrs = &RepositoryIMockGetTextChunksBySourceParamPtrs{}
	}
	mmGetTextChunksBySource.defaultExpectation.paramPtrs.sourceUID = &sourceUID

	return mmGetTextChunksBySource
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) Inspect(f func(ctx context.Context, sourceTable string, sourceUID uuid.UUID)) *mRepositoryIMockGetTextChunksBySource {
	if mmGetTextChunksBySource.mock.inspectFuncGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetTextChunksBySource")
	}

	mmGetTextChunksBySource.mock.inspectFuncGetTextChunksBySource = f

	return mmGetTextChunksBySource
}

// Return sets up results that will be returned by RepositoryI.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) Return(ta1 []mm_repository.TextChunk, err error) *RepositoryIMock {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by Set")
	}

	if mmGetTextChunksBySource.defaultExpectation == nil {
		mmGetTextChunksBySource.defaultExpectation = &RepositoryIMockGetTextChunksBySourceExpectation{mock: mmGetTextChunksBySource.mock}
	}
	mmGetTextChunksBySource.defaultExpectation.results = &RepositoryIMockGetTextChunksBySourceResults{ta1, err}
	return mmGetTextChunksBySource.mock
}

// Set uses given function f to mock the RepositoryI.GetTextChunksBySource method
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) Set(f func(ctx context.Context, sourceTable string, sourceUID uuid.UUID) (ta1 []mm_repository.TextChunk, err error)) *RepositoryIMock {
	if mmGetTextChunksBySource.defaultExpectation != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetTextChunksBySource method")
	}

	if len(mmGetTextChunksBySource.expectations) > 0 {
		mmGetTextChunksBySource.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetTextChunksBySource method")
	}

	mmGetTextChunksBySource.mock.funcGetTextChunksBySource = f
	return mmGetTextChunksBySource.mock
}

// When sets expectation for the RepositoryI.GetTextChunksBySource which will trigger the result defined by the following
// Then helper
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) When(ctx context.Context, sourceTable string, sourceUID uuid.UUID) *RepositoryIMockGetTextChunksBySourceExpectation {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by Set")
	}

	expectation := &RepositoryIMockGetTextChunksBySourceExpectation{
		mock:   mmGetTextChunksBySource.mock,
		params: &RepositoryIMockGetTextChunksBySourceParams{ctx, sourceTable, sourceUID},
	}
	mmGetTextChunksBySource.expectations = append(mmGetTextChunksBySource.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetTextChunksBySource return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetTextChunksBySourceExpectation) Then(ta1 []mm_repository.TextChunk, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetTextChunksBySourceResults{ta1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetTextChunksBySource should be invoked
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) Times(n uint64) *mRepositoryIMockGetTextChunksBySource {
	if n == 0 {
		mmGetTextChunksBySource.mock.t.Fatalf("Times of RepositoryIMock.GetTextChunksBySource mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTextChunksBySource.expectedInvocations, n)
	return mmGetTextChunksBySource
}

func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) invocationsDone() bool {
	if len(mmGetTextChunksBySource.expectations) == 0 && mmGetTextChunksBySource.defaultExpectation == nil && mmGetTextChunksBySource.mock.funcGetTextChunksBySource == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTextChunksBySource.mock.afterGetTextChunksBySourceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTextChunksBySource.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTextChunksBySource implements repository.RepositoryI
func (mmGetTextChunksBySource *RepositoryIMock) GetTextChunksBySource(ctx context.Context, sourceTable string, sourceUID uuid.UUID) (ta1 []mm_repository.TextChunk, err error) {
	mm_atomic.AddUint64(&mmGetTextChunksBySource.beforeGetTextChunksBySourceCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTextChunksBySource.afterGetTextChunksBySourceCounter, 1)

	if mmGetTextChunksBySource.inspectFuncGetTextChunksBySource != nil {
		mmGetTextChunksBySource.inspectFuncGetTextChunksBySource(ctx, sourceTable, sourceUID)
	}

	mm_params := RepositoryIMockGetTextChunksBySourceParams{ctx, sourceTable, sourceUID}

	// Record call args
	mmGetTextChunksBySource.GetTextChunksBySourceMock.mutex.Lock()
	mmGetTextChunksBySource.GetTextChunksBySourceMock.callArgs = append(mmGetTextChunksBySource.GetTextChunksBySourceMock.callArgs, &mm_params)
	mmGetTextChunksBySource.GetTextChunksBySourceMock.mutex.Unlock()

	for _, e := range mmGetTextChunksBySource.GetTextChunksBySourceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ta1, e.results.err
		}
	}

	if mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation.params
		mm_want_ptrs := mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetTextChunksBySourceParams{ctx, sourceTable, sourceUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTextChunksBySource.t.Errorf("RepositoryIMock.GetTextChunksBySource got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sourceTable != nil && !minimock.Equal(*mm_want_ptrs.sourceTable, mm_got.sourceTable) {
				mmGetTextChunksBySource.t.Errorf("RepositoryIMock.GetTextChunksBySource got unexpected parameter sourceTable, want: %#v, got: %#v%s\n", *mm_want_ptrs.sourceTable, mm_got.sourceTable, minimock.Diff(*mm_want_ptrs.sourceTable, mm_got.sourceTable))
			}

			if mm_want_ptrs.sourceUID != nil && !minimock.Equal(*mm_want_ptrs.sourceUID, mm_got.sourceUID) {
				mmGetTextChunksBySource.t.Errorf("RepositoryIMock.GetTextChunksBySource got unexpected parameter sourceUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.sourceUID, mm_got.sourceUID, minimock.Diff(*mm_want_ptrs.sourceUID, mm_got.sourceUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTextChunksBySource.t.Errorf("RepositoryIMock.GetTextChunksBySource got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTextChunksBySource.t.Fatal("No results are set for the RepositoryIMock.GetTextChunksBySource")
		}
		return (*mm_results).ta1, (*mm_results).err
	}
	if mmGetTextChunksBySource.funcGetTextChunksBySource != nil {
		return mmGetTextChunksBySource.funcGetTextChunksBySource(ctx, sourceTable, sourceUID)
	}
	mmGetTextChunksBySource.t.Fatalf("Unexpected call to RepositoryIMock.GetTextChunksBySource. %v %v %v", ctx, sourceTable, sourceUID)
	return
}

// GetTextChunksBySourceAfterCounter returns a count of finished RepositoryIMock.GetTextChunksBySource invocations
func (mmGetTextChunksBySource *RepositoryIMock) GetTextChunksBySourceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTextChunksBySource.afterGetTextChunksBySourceCounter)
}

// GetTextChunksBySourceBeforeCounter returns a count of RepositoryIMock.GetTextChunksBySource invocations
func (mmGetTextChunksBySource *RepositoryIMock) GetTextChunksBySourceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTextChunksBySource.beforeGetTextChunksBySourceCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetTextChunksBySource.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) Calls() []*RepositoryIMockGetTextChunksBySourceParams {
	mmGetTextChunksBySource.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetTextChunksBySourceParams, len(mmGetTextChunksBySource.callArgs))
	copy(argCopy, mmGetTextChunksBySource.callArgs)

	mmGetTextChunksBySource.mutex.RUnlock()

	return argCopy
}

// MinimockGetTextChunksBySourceDone returns true if the count of the GetTextChunksBySource invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetTextChunksBySourceDone() bool {
	for _, e := range m.GetTextChunksBySourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTextChunksBySourceMock.invocationsDone()
}

// MinimockGetTextChunksBySourceInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetTextChunksBySourceInspect() {
	for _, e := range m.GetTextChunksBySourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetTextChunksBySource with params: %#v", *e.params)
		}
	}

	afterGetTextChunksBySourceCounter := mm_atomic.LoadUint64(&m.afterGetTextChunksBySourceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTextChunksBySourceMock.defaultExpectation != nil && afterGetTextChunksBySourceCounter < 1 {
		if m.GetTextChunksBySourceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetTextChunksBySource")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetTextChunksBySource with params: %#v", *m.GetTextChunksBySourceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTextChunksBySource != nil && afterGetTextChunksBySourceCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetTextChunksBySource")
	}

	if !m.GetTextChunksBySourceMock.invocationsDone() && afterGetTextChunksBySourceCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetTextChunksBySource but found %d calls",
			mm_atomic.LoadUint64(&m.GetTextChunksBySourceMock.expectedInvocations), afterGetTextChunksBySourceCounter)
	}
}

type mRepositoryIMockGetTotalChunksBySources struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetTotalChunksBySourcesExpectation
	expectations       []*RepositoryIMockGetTotalChunksBySourcesExpectation

	callArgs []*RepositoryIMockGetTotalChunksBySourcesParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetTotalChunksBySourcesExpectation specifies expectation struct of the RepositoryI.GetTotalChunksBySources
type RepositoryIMockGetTotalChunksBySourcesExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetTotalChunksBySourcesParams
	paramPtrs *RepositoryIMockGetTotalChunksBySourcesParamPtrs
	results   *RepositoryIMockGetTotalChunksBySourcesResults
	Counter   uint64
}

// RepositoryIMockGetTotalChunksBySourcesParams contains parameters of the RepositoryI.GetTotalChunksBySources
type RepositoryIMockGetTotalChunksBySourcesParams struct {
	ctx     context.Context
	sources map[mm_repository.FileUID]struct {
		SourceTable mm_repository.SourceTable
		SourceUID   mm_repository.SourceUID
	}
}

// RepositoryIMockGetTotalChunksBySourcesParamPtrs contains pointers to parameters of the RepositoryI.GetTotalChunksBySources
type RepositoryIMockGetTotalChunksBySourcesParamPtrs struct {
	ctx     *context.Context
	sources *map[mm_repository.FileUID]struct {
		SourceTable mm_repository.SourceTable
		SourceUID   mm_repository.SourceUID
	}
}

// RepositoryIMockGetTotalChunksBySourcesResults contains results of the RepositoryI.GetTotalChunksBySources
type RepositoryIMockGetTotalChunksBySourcesResults struct {
	m1  map[mm_repository.FileUID]int
	err error
}

// Expect sets up expected params for RepositoryI.GetTotalChunksBySources
func (mmGetTotalChunksBySources *mRepositoryIMockGetTotalChunksBySources) Expect(ctx context.Context, sources map[mm_repository.FileUID]struct {
	SourceTable mm_repository.SourceTable
	SourceUID   mm_repository.SourceUID
}) *mRepositoryIMockGetTotalChunksBySources {
	if mmGetTotalChunksBySources.mock.funcGetTotalChunksBySources != nil {
		mmGetTotalChunksBySources.mock.t.Fatalf("RepositoryIMock.GetTotalChunksBySources mock is already set by Set")
	}

	if mmGetTotalChunksBySources.defaultExpectation == nil {
		mmGetTotalChunksBySources.defaultExpectation = &RepositoryIMockGetTotalChunksBySourcesExpectation{}
	}

	if mmGetTotalChunksBySources.defaultExpectation.paramPtrs != nil {
		mmGetTotalChunksBySources.mock.t.Fatalf("RepositoryIMock.GetTotalChunksBySources mock is already set by ExpectParams functions")
	}

	mmGetTotalChunksBySources.defaultExpectation.params = &RepositoryIMockGetTotalChunksBySourcesParams{ctx, sources}
	for _, e := range mmGetTotalChunksBySources.expectations {
		if minimock.Equal(e.params, mmGetTotalChunksBySources.defaultExpectation.params) {
			mmGetTotalChunksBySources.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTotalChunksBySources.defaultExpectation.params)
		}
	}

	return mmGetTotalChunksBySources
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetTotalChunksBySources
func (mmGetTotalChunksBySources *mRepositoryIMockGetTotalChunksBySources) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetTotalChunksBySources {
	if mmGetTotalChunksBySources.mock.funcGetTotalChunksBySources != nil {
		mmGetTotalChunksBySources.mock.t.Fatalf("RepositoryIMock.GetTotalChunksBySources mock is already set by Set")
	}

	if mmGetTotalChunksBySources.defaultExpectation == nil {
		mmGetTotalChunksBySources.defaultExpectation = &RepositoryIMockGetTotalChunksBySourcesExpectation{}
	}

	if mmGetTotalChunksBySources.defaultExpectation.params != nil {
		mmGetTotalChunksBySources.mock.t.Fatalf("RepositoryIMock.GetTotalChunksBySources mock is already set by Expect")
	}

	if mmGetTotalChunksBySources.defaultExpectation.paramPtrs == nil {
		mmGetTotalChunksBySources.defaultExpectation.paramPtrs = &RepositoryIMockGetTotalChunksBySourcesParamPtrs{}
	}
	mmGetTotalChunksBySources.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetTotalChunksBySources
}

// ExpectSourcesParam2 sets up expected param sources for RepositoryI.GetTotalChunksBySources
func (mmGetTotalChunksBySources *mRepositoryIMockGetTotalChunksBySources) ExpectSourcesParam2(sources map[mm_repository.FileUID]struct {
	SourceTable mm_repository.SourceTable
	SourceUID   mm_repository.SourceUID
}) *mRepositoryIMockGetTotalChunksBySources {
	if mmGetTotalChunksBySources.mock.funcGetTotalChunksBySources != nil {
		mmGetTotalChunksBySources.mock.t.Fatalf("RepositoryIMock.GetTotalChunksBySources mock is already set by Set")
	}

	if mmGetTotalChunksBySources.defaultExpectation == nil {
		mmGetTotalChunksBySources.defaultExpectation = &RepositoryIMockGetTotalChunksBySourcesExpectation{}
	}

	if mmGetTotalChunksBySources.defaultExpectation.params != nil {
		mmGetTotalChunksBySources.mock.t.Fatalf("RepositoryIMock.GetTotalChunksBySources mock is already set by Expect")
	}

	if mmGetTotalChunksBySources.defaultExpectation.paramPtrs == nil {
		mmGetTotalChunksBySources.defaultExpectation.paramPtrs = &RepositoryIMockGetTotalChunksBySourcesParamPtrs{}
	}
	mmGetTotalChunksBySources.defaultExpectation.paramPtrs.sources = &sources

	return mmGetTotalChunksBySources
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetTotalChunksBySources
func (mmGetTotalChunksBySources *mRepositoryIMockGetTotalChunksBySources) Inspect(f func(ctx context.Context, sources map[mm_repository.FileUID]struct {
	SourceTable mm_repository.SourceTable
	SourceUID   mm_repository.SourceUID
})) *mRepositoryIMockGetTotalChunksBySources {
	if mmGetTotalChunksBySources.mock.inspectFuncGetTotalChunksBySources != nil {
		mmGetTotalChunksBySources.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetTotalChunksBySources")
	}

	mmGetTotalChunksBySources.mock.inspectFuncGetTotalChunksBySources = f

	return mmGetTotalChunksBySources
}

// Return sets up results that will be returned by RepositoryI.GetTotalChunksBySources
func (mmGetTotalChunksBySources *mRepositoryIMockGetTotalChunksBySources) Return(m1 map[mm_repository.FileUID]int, err error) *RepositoryIMock {
	if mmGetTotalChunksBySources.mock.funcGetTotalChunksBySources != nil {
		mmGetTotalChunksBySources.mock.t.Fatalf("RepositoryIMock.GetTotalChunksBySources mock is already set by Set")
	}

	if mmGetTotalChunksBySources.defaultExpectation == nil {
		mmGetTotalChunksBySources.defaultExpectation = &RepositoryIMockGetTotalChunksBySourcesExpectation{mock: mmGetTotalChunksBySources.mock}
	}
	mmGetTotalChunksBySources.defaultExpectation.results = &RepositoryIMockGetTotalChunksBySourcesResults{m1, err}
	return mmGetTotalChunksBySources.mock
}

// Set uses given function f to mock the RepositoryI.GetTotalChunksBySources method
func (mmGetTotalChunksBySources *mRepositoryIMockGetTotalChunksBySources) Set(f func(ctx context.Context, sources map[mm_repository.FileUID]struct {
	SourceTable mm_repository.SourceTable
	SourceUID   mm_repository.SourceUID
}) (m1 map[mm_repository.FileUID]int, err error)) *RepositoryIMock {
	if mmGetTotalChunksBySources.defaultExpectation != nil {
		mmGetTotalChunksBySources.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetTotalChunksBySources method")
	}

	if len(mmGetTotalChunksBySources.expectations) > 0 {
		mmGetTotalChunksBySources.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetTotalChunksBySources method")
	}

	mmGetTotalChunksBySources.mock.funcGetTotalChunksBySources = f
	return mmGetTotalChunksBySources.mock
}

// When sets expectation for the RepositoryI.GetTotalChunksBySources which will trigger the result defined by the following
// Then helper
func (mmGetTotalChunksBySources *mRepositoryIMockGetTotalChunksBySources) When(ctx context.Context, sources map[mm_repository.FileUID]struct {
	SourceTable mm_repository.SourceTable
	SourceUID   mm_repository.SourceUID
}) *RepositoryIMockGetTotalChunksBySourcesExpectation {
	if mmGetTotalChunksBySources.mock.funcGetTotalChunksBySources != nil {
		mmGetTotalChunksBySources.mock.t.Fatalf("RepositoryIMock.GetTotalChunksBySources mock is already set by Set")
	}

	expectation := &RepositoryIMockGetTotalChunksBySourcesExpectation{
		mock:   mmGetTotalChunksBySources.mock,
		params: &RepositoryIMockGetTotalChunksBySourcesParams{ctx, sources},
	}
	mmGetTotalChunksBySources.expectations = append(mmGetTotalChunksBySources.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetTotalChunksBySources return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetTotalChunksBySourcesExpectation) Then(m1 map[mm_repository.FileUID]int, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetTotalChunksBySourcesResults{m1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetTotalChunksBySources should be invoked
func (mmGetTotalChunksBySources *mRepositoryIMockGetTotalChunksBySources) Times(n uint64) *mRepositoryIMockGetTotalChunksBySources {
	if n == 0 {
		mmGetTotalChunksBySources.mock.t.Fatalf("Times of RepositoryIMock.GetTotalChunksBySources mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTotalChunksBySources.expectedInvocations, n)
	return mmGetTotalChunksBySources
}

func (mmGetTotalChunksBySources *mRepositoryIMockGetTotalChunksBySources) invocationsDone() bool {
	if len(mmGetTotalChunksBySources.expectations) == 0 && mmGetTotalChunksBySources.defaultExpectation == nil && mmGetTotalChunksBySources.mock.funcGetTotalChunksBySources == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTotalChunksBySources.mock.afterGetTotalChunksBySourcesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTotalChunksBySources.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTotalChunksBySources implements repository.RepositoryI
func (mmGetTotalChunksBySources *RepositoryIMock) GetTotalChunksBySources(ctx context.Context, sources map[mm_repository.FileUID]struct {
	SourceTable mm_repository.SourceTable
	SourceUID   mm_repository.SourceUID
}) (m1 map[mm_repository.FileUID]int, err error) {
	mm_atomic.AddUint64(&mmGetTotalChunksBySources.beforeGetTotalChunksBySourcesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTotalChunksBySources.afterGetTotalChunksBySourcesCounter, 1)

	if mmGetTotalChunksBySources.inspectFuncGetTotalChunksBySources != nil {
		mmGetTotalChunksBySources.inspectFuncGetTotalChunksBySources(ctx, sources)
	}

	mm_params := RepositoryIMockGetTotalChunksBySourcesParams{ctx, sources}

	// Record call args
	mmGetTotalChunksBySources.GetTotalChunksBySourcesMock.mutex.Lock()
	mmGetTotalChunksBySources.GetTotalChunksBySourcesMock.callArgs = append(mmGetTotalChunksBySources.GetTotalChunksBySourcesMock.callArgs, &mm_params)
	mmGetTotalChunksBySources.GetTotalChunksBySourcesMock.mutex.Unlock()

	for _, e := range mmGetTotalChunksBySources.GetTotalChunksBySourcesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetTotalChunksBySources.GetTotalChunksBySourcesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTotalChunksBySources.GetTotalChunksBySourcesMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTotalChunksBySources.GetTotalChunksBySourcesMock.defaultExpectation.params
		mm_want_ptrs := mmGetTotalChunksBySources.GetTotalChunksBySourcesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetTotalChunksBySourcesParams{ctx, sources}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTotalChunksBySources.t.Errorf("RepositoryIMock.GetTotalChunksBySources got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sources != nil && !minimock.Equal(*mm_want_ptrs.sources, mm_got.sources) {
				mmGetTotalChunksBySources.t.Errorf("RepositoryIMock.GetTotalChunksBySources got unexpected parameter sources, want: %#v, got: %#v%s\n", *mm_want_ptrs.sources, mm_got.sources, minimock.Diff(*mm_want_ptrs.sources, mm_got.sources))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTotalChunksBySources.t.Errorf("RepositoryIMock.GetTotalChunksBySources got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTotalChunksBySources.GetTotalChunksBySourcesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTotalChunksBySources.t.Fatal("No results are set for the RepositoryIMock.GetTotalChunksBySources")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetTotalChunksBySources.funcGetTotalChunksBySources != nil {
		return mmGetTotalChunksBySources.funcGetTotalChunksBySources(ctx, sources)
	}
	mmGetTotalChunksBySources.t.Fatalf("Unexpected call to RepositoryIMock.GetTotalChunksBySources. %v %v", ctx, sources)
	return
}

// GetTotalChunksBySourcesAfterCounter returns a count of finished RepositoryIMock.GetTotalChunksBySources invocations
func (mmGetTotalChunksBySources *RepositoryIMock) GetTotalChunksBySourcesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotalChunksBySources.afterGetTotalChunksBySourcesCounter)
}

// GetTotalChunksBySourcesBeforeCounter returns a count of RepositoryIMock.GetTotalChunksBySources invocations
func (mmGetTotalChunksBySources *RepositoryIMock) GetTotalChunksBySourcesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotalChunksBySources.beforeGetTotalChunksBySourcesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetTotalChunksBySources.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTotalChunksBySources *mRepositoryIMockGetTotalChunksBySources) Calls() []*RepositoryIMockGetTotalChunksBySourcesParams {
	mmGetTotalChunksBySources.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetTotalChunksBySourcesParams, len(mmGetTotalChunksBySources.callArgs))
	copy(argCopy, mmGetTotalChunksBySources.callArgs)

	mmGetTotalChunksBySources.mutex.RUnlock()

	return argCopy
}

// MinimockGetTotalChunksBySourcesDone returns true if the count of the GetTotalChunksBySources invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetTotalChunksBySourcesDone() bool {
	for _, e := range m.GetTotalChunksBySourcesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTotalChunksBySourcesMock.invocationsDone()
}

// MinimockGetTotalChunksBySourcesInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetTotalChunksBySourcesInspect() {
	for _, e := range m.GetTotalChunksBySourcesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetTotalChunksBySources with params: %#v", *e.params)
		}
	}

	afterGetTotalChunksBySourcesCounter := mm_atomic.LoadUint64(&m.afterGetTotalChunksBySourcesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTotalChunksBySourcesMock.defaultExpectation != nil && afterGetTotalChunksBySourcesCounter < 1 {
		if m.GetTotalChunksBySourcesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetTotalChunksBySources")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetTotalChunksBySources with params: %#v", *m.GetTotalChunksBySourcesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTotalChunksBySources != nil && afterGetTotalChunksBySourcesCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetTotalChunksBySources")
	}

	if !m.GetTotalChunksBySourcesMock.invocationsDone() && afterGetTotalChunksBySourcesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetTotalChunksBySources but found %d calls",
			mm_atomic.LoadUint64(&m.GetTotalChunksBySourcesMock.expectedInvocations), afterGetTotalChunksBySourcesCounter)
	}
}

type mRepositoryIMockGetTotalTokensByListKBUIDs struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetTotalTokensByListKBUIDsExpectation
	expectations       []*RepositoryIMockGetTotalTokensByListKBUIDsExpectation

	callArgs []*RepositoryIMockGetTotalTokensByListKBUIDsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetTotalTokensByListKBUIDsExpectation specifies expectation struct of the RepositoryI.GetTotalTokensByListKBUIDs
type RepositoryIMockGetTotalTokensByListKBUIDsExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetTotalTokensByListKBUIDsParams
	paramPtrs *RepositoryIMockGetTotalTokensByListKBUIDsParamPtrs
	results   *RepositoryIMockGetTotalTokensByListKBUIDsResults
	Counter   uint64
}

// RepositoryIMockGetTotalTokensByListKBUIDsParams contains parameters of the RepositoryI.GetTotalTokensByListKBUIDs
type RepositoryIMockGetTotalTokensByListKBUIDsParams struct {
	ctx    context.Context
	kbUIDs []uuid.UUID
}

// RepositoryIMockGetTotalTokensByListKBUIDsParamPtrs contains pointers to parameters of the RepositoryI.GetTotalTokensByListKBUIDs
type RepositoryIMockGetTotalTokensByListKBUIDsParamPtrs struct {
	ctx    *context.Context
	kbUIDs *[]uuid.UUID
}

// RepositoryIMockGetTotalTokensByListKBUIDsResults contains results of the RepositoryI.GetTotalTokensByListKBUIDs
type RepositoryIMockGetTotalTokensByListKBUIDsResults struct {
	m1  map[uuid.UUID]int
	err error
}

// Expect sets up expected params for RepositoryI.GetTotalTokensByListKBUIDs
func (mmGetTotalTokensByListKBUIDs *mRepositoryIMockGetTotalTokensByListKBUIDs) Expect(ctx context.Context, kbUIDs []uuid.UUID) *mRepositoryIMockGetTotalTokensByListKBUIDs {
	if mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDs != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryIMock.GetTotalTokensByListKBUIDs mock is already set by Set")
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation == nil {
		mmGetTotalTokensByListKBUIDs.defaultExpectation = &RepositoryIMockGetTotalTokensByListKBUIDsExpectation{}
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation.paramPtrs != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryIMock.GetTotalTokensByListKBUIDs mock is already set by ExpectParams functions")
	}

	mmGetTotalTokensByListKBUIDs.defaultExpectation.params = &RepositoryIMockGetTotalTokensByListKBUIDsParams{ctx, kbUIDs}
	for _, e := range mmGetTotalTokensByListKBUIDs.expectations {
		if minimock.Equal(e.params, mmGetTotalTokensByListKBUIDs.defaultExpectation.params) {
			mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTotalTokensByListKBUIDs.defaultExpectation.params)
		}
	}

	return mmGetTotalTokensByListKBUIDs
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetTotalTokensByListKBUIDs
func (mmGetTotalTokensByListKBUIDs *mRepositoryIMockGetTotalTokensByListKBUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetTotalTokensByListKBUIDs {
	if mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDs != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryIMock.GetTotalTokensByListKBUIDs mock is already set by Set")
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation == nil {
		mmGetTotalTokensByListKBUIDs.defaultExpectation = &RepositoryIMockGetTotalTokensByListKBUIDsExpectation{}
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation.params != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryIMock.GetTotalTokensByListKBUIDs mock is already set by Expect")
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation.paramPtrs == nil {
		mmGetTotalTokensByListKBUIDs.defaultExpectation.paramPtrs = &RepositoryIMockGetTotalTokensByListKBUIDsParamPtrs{}
	}
	mmGetTotalTokensByListKBUIDs.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetTotalTokensByListKBUIDs
}

// ExpectKbUIDsParam2 sets up expected param kbUIDs for RepositoryI.GetTotalTokensByListKBUIDs
func (mmGetTotalTokensByListKBUIDs *mRepositoryIMockGetTotalTokensByListKBUIDs) ExpectKbUIDsParam2(kbUIDs []uuid.UUID) *mRepositoryIMockGetTotalTokensByListKBUIDs {
	if mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDs != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryIMock.GetTotalTokensByListKBUIDs mock is already set by Set")
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation == nil {
		mmGetTotalTokensByListKBUIDs.defaultExpectation = &RepositoryIMockGetTotalTokensByListKBUIDsExpectation{}
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation.params != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryIMock.GetTotalTokensByListKBUIDs mock is already set by Expect")
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation.paramPtrs == nil {
		mmGetTotalTokensByListKBUIDs.defaultExpectation.paramPtrs = &RepositoryIMockGetTotalTokensByListKBUIDsParamPtrs{}
	}
	mmGetTotalTokensByListKBUIDs.defaultExpectation.paramPtrs.kbUIDs = &kbUIDs

	return mmGetTotalTokensByListKBUIDs
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetTotalTokensByListKBUIDs
func (mmGetTotalTokensByListKBUIDs *mRepositoryIMockGetTotalTokensByListKBUIDs) Inspect(f func(ctx context.Context, kbUIDs []uuid.UUID)) *mRepositoryIMockGetTotalTokensByListKBUIDs {
	if mmGetTotalTokensByListKBUIDs.mock.inspectFuncGetTotalTokensByListKBUIDs != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetTotalTokensByListKBUIDs")
	}

	mmGetTotalTokensByListKBUIDs.mock.inspectFuncGetTotalTokensByListKBUIDs = f

	return mmGetTotalTokensByListKBUIDs
}

// Return sets up results that will be returned by RepositoryI.GetTotalTokensByListKBUIDs
func (mmGetTotalTokensByListKBUIDs *mRepositoryIMockGetTotalTokensByListKBUIDs) Return(m1 map[uuid.UUID]int, err error) *RepositoryIMock {
	if mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDs != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryIMock.GetTotalTokensByListKBUIDs mock is already set by Set")
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation == nil {
		mmGetTotalTokensByListKBUIDs.defaultExpectation = &RepositoryIMockGetTotalTokensByListKBUIDsExpectation{mock: mmGetTotalTokensByListKBUIDs.mock}
	}
	mmGetTotalTokensByListKBUIDs.defaultExpectation.results = &RepositoryIMockGetTotalTokensByListKBUIDsResults{m1, err}
	return mmGetTotalTokensByListKBUIDs.mock
}

// Set uses given function f to mock the RepositoryI.GetTotalTokensByListKBUIDs method
func (mmGetTotalTokensByListKBUIDs *mRepositoryIMockGetTotalTokensByListKBUIDs) Set(f func(ctx context.Context, kbUIDs []uuid.UUID) (m1 map[uuid.UUID]int, err error)) *RepositoryIMock {
	if mmGetTotalTokensByListKBUIDs.defaultExpectation != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetTotalTokensByListKBUIDs method")
	}

	if len(mmGetTotalTokensByListKBUIDs.expectations) > 0 {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetTotalTokensByListKBUIDs method")
	}

	mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDs = f
	return mmGetTotalTokensByListKBUIDs.mock
}

// When sets expectation for the RepositoryI.GetTotalTokensByListKBUIDs which will trigger the result defined by the following
// Then helper
func (mmGetTotalTokensByListKBUIDs *mRepositoryIMockGetTotalTokensByListKBUIDs) When(ctx context.Context, kbUIDs []uuid.UUID) *RepositoryIMockGetTotalTokensByListKBUIDsExpectation {
	if mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDs != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryIMock.GetTotalTokensByListKBUIDs mock is already set by Set")
	}

	expectation := &RepositoryIMockGetTotalTokensByListKBUIDsExpectation{
		mock:   mmGetTotalTokensByListKBUIDs.mock,
		params: &RepositoryIMockGetTotalTokensByListKBUIDsParams{ctx, kbUIDs},
	}
	mmGetTotalTokensByListKBUIDs.expectations = append(mmGetTotalTokensByListKBUIDs.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetTotalTokensByListKBUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetTotalTokensByListKBUIDsExpectation) Then(m1 map[uuid.UUID]int, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetTotalTokensByListKBUIDsResults{m1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetTotalTokensByListKBUIDs should be invoked
func (mmGetTotalTokensByListKBUIDs *mRepositoryIMockGetTotalTokensByListKBUIDs) Times(n uint64) *mRepositoryIMockGetTotalTokensByListKBUIDs {
	if n == 0 {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("Times of RepositoryIMock.GetTotalTokensByListKBUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTotalTokensByListKBUIDs.expectedInvocations, n)
	return mmGetTotalTokensByListKBUIDs
}

func (mmGetTotalTokensByListKBUIDs *mRepositoryIMockGetTotalTokensByListKBUIDs) invocationsDone() bool {
	if len(mmGetTotalTokensByListKBUIDs.expectations) == 0 && mmGetTotalTokensByListKBUIDs.defaultExpectation == nil && mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTotalTokensByListKBUIDs.mock.afterGetTotalTokensByListKBUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTotalTokensByListKBUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTotalTokensByListKBUIDs implements repository.RepositoryI
func (mmGetTotalTokensByListKBUIDs *RepositoryIMock) GetTotalTokensByListKBUIDs(ctx context.Context, kbUIDs []uuid.UUID) (m1 map[uuid.UUID]int, err error) {
	mm_atomic.AddUint64(&mmGetTotalTokensByListKBUIDs.beforeGetTotalTokensByListKBUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTotalTokensByListKBUIDs.afterGetTotalTokensByListKBUIDsCounter, 1)

	if mmGetTotalTokensByListKBUIDs.inspectFuncGetTotalTokensByListKBUIDs != nil {
		mmGetTotalTokensByListKBUIDs.inspectFuncGetTotalTokensByListKBUIDs(ctx, kbUIDs)
	}

	mm_params := RepositoryIMockGetTotalTokensByListKBUIDsParams{ctx, kbUIDs}

	// Record call args
	mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.mutex.Lock()
	mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.callArgs = append(mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.callArgs, &mm_params)
	mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.mutex.Unlock()

	for _, e := range mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetTotalTokensByListKBUIDsParams{ctx, kbUIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTotalTokensByListKBUIDs.t.Errorf("RepositoryIMock.GetTotalTokensByListKBUIDs got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUIDs != nil && !minimock.Equal(*mm_want_ptrs.kbUIDs, mm_got.kbUIDs) {
				mmGetTotalTokensByListKBUIDs.t.Errorf("RepositoryIMock.GetTotalTokensByListKBUIDs got unexpected parameter kbUIDs, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbUIDs, mm_got.kbUIDs, minimock.Diff(*mm_want_ptrs.kbUIDs, mm_got.kbUIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTotalTokensByListKBUIDs.t.Errorf("RepositoryIMock.GetTotalTokensByListKBUIDs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTotalTokensByListKBUIDs.t.Fatal("No results are set for the RepositoryIMock.GetTotalTokensByListKBUIDs")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetTotalTokensByListKBUIDs.funcGetTotalTokensByListKBUIDs != nil {
		return mmGetTotalTokensByListKBUIDs.funcGetTotalTokensByListKBUIDs(ctx, kbUIDs)
	}
	mmGetTotalTokensByListKBUIDs.t.Fatalf("Unexpected call to RepositoryIMock.GetTotalTokensByListKBUIDs. %v %v", ctx, kbUIDs)
	return
}

// GetTotalTokensByListKBUIDsAfterCounter returns a count of finished RepositoryIMock.GetTotalTokensByListKBUIDs invocations
func (mmGetTotalTokensByListKBUIDs *RepositoryIMock) GetTotalTokensByListKBUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotalTokensByListKBUIDs.afterGetTotalTokensByListKBUIDsCounter)
}

// GetTotalTokensByListKBUIDsBeforeCounter returns a count of RepositoryIMock.GetTotalTokensByListKBUIDs invocations
func (mmGetTotalTokensByListKBUIDs *RepositoryIMock) GetTotalTokensByListKBUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotalTokensByListKBUIDs.beforeGetTotalTokensByListKBUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetTotalTokensByListKBUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTotalTokensByListKBUIDs *mRepositoryIMockGetTotalTokensByListKBUIDs) Calls() []*RepositoryIMockGetTotalTokensByListKBUIDsParams {
	mmGetTotalTokensByListKBUIDs.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetTotalTokensByListKBUIDsParams, len(mmGetTotalTokensByListKBUIDs.callArgs))
	copy(argCopy, mmGetTotalTokensByListKBUIDs.callArgs)

	mmGetTotalTokensByListKBUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockGetTotalTokensByListKBUIDsDone returns true if the count of the GetTotalTokensByListKBUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetTotalTokensByListKBUIDsDone() bool {
	for _, e := range m.GetTotalTokensByListKBUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTotalTokensByListKBUIDsMock.invocationsDone()
}

// MinimockGetTotalTokensByListKBUIDsInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetTotalTokensByListKBUIDsInspect() {
	for _, e := range m.GetTotalTokensByListKBUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetTotalTokensByListKBUIDs with params: %#v", *e.params)
		}
	}

	afterGetTotalTokensByListKBUIDsCounter := mm_atomic.LoadUint64(&m.afterGetTotalTokensByListKBUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTotalTokensByListKBUIDsMock.defaultExpectation != nil && afterGetTotalTokensByListKBUIDsCounter < 1 {
		if m.GetTotalTokensByListKBUIDsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetTotalTokensByListKBUIDs")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetTotalTokensByListKBUIDs with params: %#v", *m.GetTotalTokensByListKBUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTotalTokensByListKBUIDs != nil && afterGetTotalTokensByListKBUIDsCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetTotalTokensByListKBUIDs")
	}

	if !m.GetTotalTokensByListKBUIDsMock.invocationsDone() && afterGetTotalTokensByListKBUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetTotalTokensByListKBUIDs but found %d calls",
			mm_atomic.LoadUint64(&m.GetTotalTokensByListKBUIDsMock.expectedInvocations), afterGetTotalTokensByListKBUIDsCounter)
	}
}

type mRepositoryIMockGetTruthSourceByFileUID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetTruthSourceByFileUIDExpectation
	expectations       []*RepositoryIMockGetTruthSourceByFileUIDExpectation

	callArgs []*RepositoryIMockGetTruthSourceByFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetTruthSourceByFileUIDExpectation specifies expectation struct of the RepositoryI.GetTruthSourceByFileUID
type RepositoryIMockGetTruthSourceByFileUIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetTruthSourceByFileUIDParams
	paramPtrs *RepositoryIMockGetTruthSourceByFileUIDParamPtrs
	results   *RepositoryIMockGetTruthSourceByFileUIDResults
	Counter   uint64
}

// RepositoryIMockGetTruthSourceByFileUIDParams contains parameters of the RepositoryI.GetTruthSourceByFileUID
type RepositoryIMockGetTruthSourceByFileUIDParams struct {
	ctx     context.Context
	fileUID uuid.UUID
}

// RepositoryIMockGetTruthSourceByFileUIDParamPtrs contains pointers to parameters of the RepositoryI.GetTruthSourceByFileUID
type RepositoryIMockGetTruthSourceByFileUIDParamPtrs struct {
	ctx     *context.Context
	fileUID *uuid.UUID
}

// RepositoryIMockGetTruthSourceByFileUIDResults contains results of the RepositoryI.GetTruthSourceByFileUID
type RepositoryIMockGetTruthSourceByFileUIDResults struct {
	sp1 *mm_repository.SourceMeta
	err error
}

// Expect sets up expected params for RepositoryI.GetTruthSourceByFileUID
func (mmGetTruthSourceByFileUID *mRepositoryIMockGetTruthSourceByFileUID) Expect(ctx context.Context, fileUID uuid.UUID) *mRepositoryIMockGetTruthSourceByFileUID {
	if mmGetTruthSourceByFileUID.mock.funcGetTruthSourceByFileUID != nil {
		mmGetTruthSourceByFileUID.mock.t.Fatalf("RepositoryIMock.GetTruthSourceByFileUID mock is already set by Set")
	}

	if mmGetTruthSourceByFileUID.defaultExpectation == nil {
		mmGetTruthSourceByFileUID.defaultExpectation = &RepositoryIMockGetTruthSourceByFileUIDExpectation{}
	}

	if mmGetTruthSourceByFileUID.defaultExpectation.paramPtrs != nil {
		mmGetTruthSourceByFileUID.mock.t.Fatalf("RepositoryIMock.GetTruthSourceByFileUID mock is already set by ExpectParams functions")
	}

	mmGetTruthSourceByFileUID.defaultExpectation.params = &RepositoryIMockGetTruthSourceByFileUIDParams{ctx, fileUID}
	for _, e := range mmGetTruthSourceByFileUID.expectations {
		if minimock.Equal(e.params, mmGetTruthSourceByFileUID.defaultExpectation.params) {
			mmGetTruthSourceByFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTruthSourceByFileUID.defaultExpectation.params)
		}
	}

	return mmGetTruthSourceByFileUID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetTruthSourceByFileUID
func (mmGetTruthSourceByFileUID *mRepositoryIMockGetTruthSourceByFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetTruthSourceByFileUID {
	if mmGetTruthSourceByFileUID.mock.funcGetTruthSourceByFileUID != nil {
		mmGetTruthSourceByFileUID.mock.t.Fatalf("RepositoryIMock.GetTruthSourceByFileUID mock is already set by Set")
	}

	if mmGetTruthSourceByFileUID.defaultExpectation == nil {
		mmGetTruthSourceByFileUID.defaultExpectation = &RepositoryIMockGetTruthSourceByFileUIDExpectation{}
	}

	if mmGetTruthSourceByFileUID.defaultExpectation.params != nil {
		mmGetTruthSourceByFileUID.mock.t.Fatalf("RepositoryIMock.GetTruthSourceByFileUID mock is already set by Expect")
	}

	if mmGetTruthSourceByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetTruthSourceByFileUID.defaultExpectation.paramPtrs = &RepositoryIMockGetTruthSourceByFileUIDParamPtrs{}
	}
	mmGetTruthSourceByFileUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetTruthSourceByFileUID
}

// ExpectFileUIDParam2 sets up expected param fileUID for RepositoryI.GetTruthSourceByFileUID
func (mmGetTruthSourceByFileUID *mRepositoryIMockGetTruthSourceByFileUID) ExpectFileUIDParam2(fileUID uuid.UUID) *mRepositoryIMockGetTruthSourceByFileUID {
	if mmGetTruthSourceByFileUID.mock.funcGetTruthSourceByFileUID != nil {
		mmGetTruthSourceByFileUID.mock.t.Fatalf("RepositoryIMock.GetTruthSourceByFileUID mock is already set by Set")
	}

	if mmGetTruthSourceByFileUID.defaultExpectation == nil {
		mmGetTruthSourceByFileUID.defaultExpectation = &RepositoryIMockGetTruthSourceByFileUIDExpectation{}
	}

	if mmGetTruthSourceByFileUID.defaultExpectation.params != nil {
		mmGetTruthSourceByFileUID.mock.t.Fatalf("RepositoryIMock.GetTruthSourceByFileUID mock is already set by Expect")
	}

	if mmGetTruthSourceByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetTruthSourceByFileUID.defaultExpectation.paramPtrs = &RepositoryIMockGetTruthSourceByFileUIDParamPtrs{}
	}
	mmGetTruthSourceByFileUID.defaultExpectation.paramPtrs.fileUID = &fileUID

	return mmGetTruthSourceByFileUID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetTruthSourceByFileUID
func (mmGetTruthSourceByFileUID *mRepositoryIMockGetTruthSourceByFileUID) Inspect(f func(ctx context.Context, fileUID uuid.UUID)) *mRepositoryIMockGetTruthSourceByFileUID {
	if mmGetTruthSourceByFileUID.mock.inspectFuncGetTruthSourceByFileUID != nil {
		mmGetTruthSourceByFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetTruthSourceByFileUID")
	}

	mmGetTruthSourceByFileUID.mock.inspectFuncGetTruthSourceByFileUID = f

	return mmGetTruthSourceByFileUID
}

// Return sets up results that will be returned by RepositoryI.GetTruthSourceByFileUID
func (mmGetTruthSourceByFileUID *mRepositoryIMockGetTruthSourceByFileUID) Return(sp1 *mm_repository.SourceMeta, err error) *RepositoryIMock {
	if mmGetTruthSourceByFileUID.mock.funcGetTruthSourceByFileUID != nil {
		mmGetTruthSourceByFileUID.mock.t.Fatalf("RepositoryIMock.GetTruthSourceByFileUID mock is already set by Set")
	}

	if mmGetTruthSourceByFileUID.defaultExpectation == nil {
		mmGetTruthSourceByFileUID.defaultExpectation = &RepositoryIMockGetTruthSourceByFileUIDExpectation{mock: mmGetTruthSourceByFileUID.mock}
	}
	mmGetTruthSourceByFileUID.defaultExpectation.results = &RepositoryIMockGetTruthSourceByFileUIDResults{sp1, err}
	return mmGetTruthSourceByFileUID.mock
}

// Set uses given function f to mock the RepositoryI.GetTruthSourceByFileUID method
func (mmGetTruthSourceByFileUID *mRepositoryIMockGetTruthSourceByFileUID) Set(f func(ctx context.Context, fileUID uuid.UUID) (sp1 *mm_repository.SourceMeta, err error)) *RepositoryIMock {
	if mmGetTruthSourceByFileUID.defaultExpectation != nil {
		mmGetTruthSourceByFileUID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetTruthSourceByFileUID method")
	}

	if len(mmGetTruthSourceByFileUID.expectations) > 0 {
		mmGetTruthSourceByFileUID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetTruthSourceByFileUID method")
	}

	mmGetTruthSourceByFileUID.mock.funcGetTruthSourceByFileUID = f
	return mmGetTruthSourceByFileUID.mock
}

// When sets expectation for the RepositoryI.GetTruthSourceByFileUID which will trigger the result defined by the following
// Then helper
func (mmGetTruthSourceByFileUID *mRepositoryIMockGetTruthSourceByFileUID) When(ctx context.Context, fileUID uuid.UUID) *RepositoryIMockGetTruthSourceByFileUIDExpectation {
	if mmGetTruthSourceByFileUID.mock.funcGetTruthSourceByFileUID != nil {
		mmGetTruthSourceByFileUID.mock.t.Fatalf("RepositoryIMock.GetTruthSourceByFileUID mock is already set by Set")
	}

	expectation := &RepositoryIMockGetTruthSourceByFileUIDExpectation{
		mock:   mmGetTruthSourceByFileUID.mock,
		params: &RepositoryIMockGetTruthSourceByFileUIDParams{ctx, fileUID},
	}
	mmGetTruthSourceByFileUID.expectations = append(mmGetTruthSourceByFileUID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetTruthSourceByFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetTruthSourceByFileUIDExpectation) Then(sp1 *mm_repository.SourceMeta, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetTruthSourceByFileUIDResults{sp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetTruthSourceByFileUID should be invoked
func (mmGetTruthSourceByFileUID *mRepositoryIMockGetTruthSourceByFileUID) Times(n uint64) *mRepositoryIMockGetTruthSourceByFileUID {
	if n == 0 {
		mmGetTruthSourceByFileUID.mock.t.Fatalf("Times of RepositoryIMock.GetTruthSourceByFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTruthSourceByFileUID.expectedInvocations, n)
	return mmGetTruthSourceByFileUID
}

func (mmGetTruthSourceByFileUID *mRepositoryIMockGetTruthSourceByFileUID) invocationsDone() bool {
	if len(mmGetTruthSourceByFileUID.expectations) == 0 && mmGetTruthSourceByFileUID.defaultExpectation == nil && mmGetTruthSourceByFileUID.mock.funcGetTruthSourceByFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTruthSourceByFileUID.mock.afterGetTruthSourceByFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTruthSourceByFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTruthSourceByFileUID implements repository.RepositoryI
func (mmGetTruthSourceByFileUID *RepositoryIMock) GetTruthSourceByFileUID(ctx context.Context, fileUID uuid.UUID) (sp1 *mm_repository.SourceMeta, err error) {
	mm_atomic.AddUint64(&mmGetTruthSourceByFileUID.beforeGetTruthSourceByFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTruthSourceByFileUID.afterGetTruthSourceByFileUIDCounter, 1)

	if mmGetTruthSourceByFileUID.inspectFuncGetTruthSourceByFileUID != nil {
		mmGetTruthSourceByFileUID.inspectFuncGetTruthSourceByFileUID(ctx, fileUID)
	}

	mm_params := RepositoryIMockGetTruthSourceByFileUIDParams{ctx, fileUID}

	// Record call args
	mmGetTruthSourceByFileUID.GetTruthSourceByFileUIDMock.mutex.Lock()
	mmGetTruthSourceByFileUID.GetTruthSourceByFileUIDMock.callArgs = append(mmGetTruthSourceByFileUID.GetTruthSourceByFileUIDMock.callArgs, &mm_params)
	mmGetTruthSourceByFileUID.GetTruthSourceByFileUIDMock.mutex.Unlock()

	for _, e := range mmGetTruthSourceByFileUID.GetTruthSourceByFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGetTruthSourceByFileUID.GetTruthSourceByFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTruthSourceByFileUID.GetTruthSourceByFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTruthSourceByFileUID.GetTruthSourceByFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetTruthSourceByFileUID.GetTruthSourceByFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetTruthSourceByFileUIDParams{ctx, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTruthSourceByFileUID.t.Errorf("RepositoryIMock.GetTruthSourceByFileUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmGetTruthSourceByFileUID.t.Errorf("RepositoryIMock.GetTruthSourceByFileUID got unexpected parameter fileUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTruthSourceByFileUID.t.Errorf("RepositoryIMock.GetTruthSourceByFileUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTruthSourceByFileUID.GetTruthSourceByFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTruthSourceByFileUID.t.Fatal("No results are set for the RepositoryIMock.GetTruthSourceByFileUID")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGetTruthSourceByFileUID.funcGetTruthSourceByFileUID != nil {
		return mmGetTruthSourceByFileUID.funcGetTruthSourceByFileUID(ctx, fileUID)
	}
	mmGetTruthSourceByFileUID.t.Fatalf("Unexpected call to RepositoryIMock.GetTruthSourceByFileUID. %v %v", ctx, fileUID)
	return
}

// GetTruthSourceByFileUIDAfterCounter returns a count of finished RepositoryIMock.GetTruthSourceByFileUID invocations
func (mmGetTruthSourceByFileUID *RepositoryIMock) GetTruthSourceByFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTruthSourceByFileUID.afterGetTruthSourceByFileUIDCounter)
}

// GetTruthSourceByFileUIDBeforeCounter returns a count of RepositoryIMock.GetTruthSourceByFileUID invocations
func (mmGetTruthSourceByFileUID *RepositoryIMock) GetTruthSourceByFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTruthSourceByFileUID.beforeGetTruthSourceByFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetTruthSourceByFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTruthSourceByFileUID *mRepositoryIMockGetTruthSourceByFileUID) Calls() []*RepositoryIMockGetTruthSourceByFileUIDParams {
	mmGetTruthSourceByFileUID.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetTruthSourceByFileUIDParams, len(mmGetTruthSourceByFileUID.callArgs))
	copy(argCopy, mmGetTruthSourceByFileUID.callArgs)

	mmGetTruthSourceByFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetTruthSourceByFileUIDDone returns true if the count of the GetTruthSourceByFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetTruthSourceByFileUIDDone() bool {
	for _, e := range m.GetTruthSourceByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTruthSourceByFileUIDMock.invocationsDone()
}

// MinimockGetTruthSourceByFileUIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetTruthSourceByFileUIDInspect() {
	for _, e := range m.GetTruthSourceByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetTruthSourceByFileUID with params: %#v", *e.params)
		}
	}

	afterGetTruthSourceByFileUIDCounter := mm_atomic.LoadUint64(&m.afterGetTruthSourceByFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTruthSourceByFileUIDMock.defaultExpectation != nil && afterGetTruthSourceByFileUIDCounter < 1 {
		if m.GetTruthSourceByFileUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetTruthSourceByFileUID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetTruthSourceByFileUID with params: %#v", *m.GetTruthSourceByFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTruthSourceByFileUID != nil && afterGetTruthSourceByFileUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetTruthSourceByFileUID")
	}

	if !m.GetTruthSourceByFileUIDMock.invocationsDone() && afterGetTruthSourceByFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetTruthSourceByFileUID but found %d calls",
			mm_atomic.LoadUint64(&m.GetTruthSourceByFileUIDMock.expectedInvocations), afterGetTruthSourceByFileUIDCounter)
	}
}

type mRepositoryIMockHardDeleteChunksByKbFileUID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockHardDeleteChunksByKbFileUIDExpectation
	expectations       []*RepositoryIMockHardDeleteChunksByKbFileUIDExpectation

	callArgs []*RepositoryIMockHardDeleteChunksByKbFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockHardDeleteChunksByKbFileUIDExpectation specifies expectation struct of the RepositoryI.HardDeleteChunksByKbFileUID
type RepositoryIMockHardDeleteChunksByKbFileUIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockHardDeleteChunksByKbFileUIDParams
	paramPtrs *RepositoryIMockHardDeleteChunksByKbFileUIDParamPtrs
	results   *RepositoryIMockHardDeleteChunksByKbFileUIDResults
	Counter   uint64
}

// RepositoryIMockHardDeleteChunksByKbFileUIDParams contains parameters of the RepositoryI.HardDeleteChunksByKbFileUID
type RepositoryIMockHardDeleteChunksByKbFileUIDParams struct {
	ctx       context.Context
	kbFileUID uuid.UUID
}

// RepositoryIMockHardDeleteChunksByKbFileUIDParamPtrs contains pointers to parameters of the RepositoryI.HardDeleteChunksByKbFileUID
type RepositoryIMockHardDeleteChunksByKbFileUIDParamPtrs struct {
	ctx       *context.Context
	kbFileUID *uuid.UUID
}

// RepositoryIMockHardDeleteChunksByKbFileUIDResults contains results of the RepositoryI.HardDeleteChunksByKbFileUID
type RepositoryIMockHardDeleteChunksByKbFileUIDResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.HardDeleteChunksByKbFileUID
func (mmHardDeleteChunksByKbFileUID *mRepositoryIMockHardDeleteChunksByKbFileUID) Expect(ctx context.Context, kbFileUID uuid.UUID) *mRepositoryIMockHardDeleteChunksByKbFileUID {
	if mmHardDeleteChunksByKbFileUID.mock.funcHardDeleteChunksByKbFileUID != nil {
		mmHardDeleteChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbFileUID mock is already set by Set")
	}

	if mmHardDeleteChunksByKbFileUID.defaultExpectation == nil {
		mmHardDeleteChunksByKbFileUID.defaultExpectation = &RepositoryIMockHardDeleteChunksByKbFileUIDExpectation{}
	}

	if mmHardDeleteChunksByKbFileUID.defaultExpectation.paramPtrs != nil {
		mmHardDeleteChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbFileUID mock is already set by ExpectParams functions")
	}

	mmHardDeleteChunksByKbFileUID.defaultExpectation.params = &RepositoryIMockHardDeleteChunksByKbFileUIDParams{ctx, kbFileUID}
	for _, e := range mmHardDeleteChunksByKbFileUID.expectations {
		if minimock.Equal(e.params, mmHardDeleteChunksByKbFileUID.defaultExpectation.params) {
			mmHardDeleteChunksByKbFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHardDeleteChunksByKbFileUID.defaultExpectation.params)
		}
	}

	return mmHardDeleteChunksByKbFileUID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.HardDeleteChunksByKbFileUID
func (mmHardDeleteChunksByKbFileUID *mRepositoryIMockHardDeleteChunksByKbFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockHardDeleteChunksByKbFileUID {
	if mmHardDeleteChunksByKbFileUID.mock.funcHardDeleteChunksByKbFileUID != nil {
		mmHardDeleteChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbFileUID mock is already set by Set")
	}

	if mmHardDeleteChunksByKbFileUID.defaultExpectation == nil {
		mmHardDeleteChunksByKbFileUID.defaultExpectation = &RepositoryIMockHardDeleteChunksByKbFileUIDExpectation{}
	}

	if mmHardDeleteChunksByKbFileUID.defaultExpectation.params != nil {
		mmHardDeleteChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbFileUID mock is already set by Expect")
	}

	if mmHardDeleteChunksByKbFileUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteChunksByKbFileUID.defaultExpectation.paramPtrs = &RepositoryIMockHardDeleteChunksByKbFileUIDParamPtrs{}
	}
	mmHardDeleteChunksByKbFileUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmHardDeleteChunksByKbFileUID
}

// ExpectKbFileUIDParam2 sets up expected param kbFileUID for RepositoryI.HardDeleteChunksByKbFileUID
func (mmHardDeleteChunksByKbFileUID *mRepositoryIMockHardDeleteChunksByKbFileUID) ExpectKbFileUIDParam2(kbFileUID uuid.UUID) *mRepositoryIMockHardDeleteChunksByKbFileUID {
	if mmHardDeleteChunksByKbFileUID.mock.funcHardDeleteChunksByKbFileUID != nil {
		mmHardDeleteChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbFileUID mock is already set by Set")
	}

	if mmHardDeleteChunksByKbFileUID.defaultExpectation == nil {
		mmHardDeleteChunksByKbFileUID.defaultExpectation = &RepositoryIMockHardDeleteChunksByKbFileUIDExpectation{}
	}

	if mmHardDeleteChunksByKbFileUID.defaultExpectation.params != nil {
		mmHardDeleteChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbFileUID mock is already set by Expect")
	}

	if mmHardDeleteChunksByKbFileUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteChunksByKbFileUID.defaultExpectation.paramPtrs = &RepositoryIMockHardDeleteChunksByKbFileUIDParamPtrs{}
	}
	mmHardDeleteChunksByKbFileUID.defaultExpectation.paramPtrs.kbFileUID = &kbFileUID

	return mmHardDeleteChunksByKbFileUID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.HardDeleteChunksByKbFileUID
func (mmHardDeleteChunksByKbFileUID *mRepositoryIMockHardDeleteChunksByKbFileUID) Inspect(f func(ctx context.Context, kbFileUID uuid.UUID)) *mRepositoryIMockHardDeleteChunksByKbFileUID {
	if mmHardDeleteChunksByKbFileUID.mock.inspectFuncHardDeleteChunksByKbFileUID != nil {
		mmHardDeleteChunksByKbFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.HardDeleteChunksByKbFileUID")
	}

	mmHardDeleteChunksByKbFileUID.mock.inspectFuncHardDeleteChunksByKbFileUID = f

	return mmHardDeleteChunksByKbFileUID
}

// Return sets up results that will be returned by RepositoryI.HardDeleteChunksByKbFileUID
func (mmHardDeleteChunksByKbFileUID *mRepositoryIMockHardDeleteChunksByKbFileUID) Return(err error) *RepositoryIMock {
	if mmHardDeleteChunksByKbFileUID.mock.funcHardDeleteChunksByKbFileUID != nil {
		mmHardDeleteChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbFileUID mock is already set by Set")
	}

	if mmHardDeleteChunksByKbFileUID.defaultExpectation == nil {
		mmHardDeleteChunksByKbFileUID.defaultExpectation = &RepositoryIMockHardDeleteChunksByKbFileUIDExpectation{mock: mmHardDeleteChunksByKbFileUID.mock}
	}
	mmHardDeleteChunksByKbFileUID.defaultExpectation.results = &RepositoryIMockHardDeleteChunksByKbFileUIDResults{err}
	return mmHardDeleteChunksByKbFileUID.mock
}

// Set uses given function f to mock the RepositoryI.HardDeleteChunksByKbFileUID method
func (mmHardDeleteChunksByKbFileUID *mRepositoryIMockHardDeleteChunksByKbFileUID) Set(f func(ctx context.Context, kbFileUID uuid.UUID) (err error)) *RepositoryIMock {
	if mmHardDeleteChunksByKbFileUID.defaultExpectation != nil {
		mmHardDeleteChunksByKbFileUID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.HardDeleteChunksByKbFileUID method")
	}

	if len(mmHardDeleteChunksByKbFileUID.expectations) > 0 {
		mmHardDeleteChunksByKbFileUID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.HardDeleteChunksByKbFileUID method")
	}

	mmHardDeleteChunksByKbFileUID.mock.funcHardDeleteChunksByKbFileUID = f
	return mmHardDeleteChunksByKbFileUID.mock
}

// When sets expectation for the RepositoryI.HardDeleteChunksByKbFileUID which will trigger the result defined by the following
// Then helper
func (mmHardDeleteChunksByKbFileUID *mRepositoryIMockHardDeleteChunksByKbFileUID) When(ctx context.Context, kbFileUID uuid.UUID) *RepositoryIMockHardDeleteChunksByKbFileUIDExpectation {
	if mmHardDeleteChunksByKbFileUID.mock.funcHardDeleteChunksByKbFileUID != nil {
		mmHardDeleteChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbFileUID mock is already set by Set")
	}

	expectation := &RepositoryIMockHardDeleteChunksByKbFileUIDExpectation{
		mock:   mmHardDeleteChunksByKbFileUID.mock,
		params: &RepositoryIMockHardDeleteChunksByKbFileUIDParams{ctx, kbFileUID},
	}
	mmHardDeleteChunksByKbFileUID.expectations = append(mmHardDeleteChunksByKbFileUID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.HardDeleteChunksByKbFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockHardDeleteChunksByKbFileUIDExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockHardDeleteChunksByKbFileUIDResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.HardDeleteChunksByKbFileUID should be invoked
func (mmHardDeleteChunksByKbFileUID *mRepositoryIMockHardDeleteChunksByKbFileUID) Times(n uint64) *mRepositoryIMockHardDeleteChunksByKbFileUID {
	if n == 0 {
		mmHardDeleteChunksByKbFileUID.mock.t.Fatalf("Times of RepositoryIMock.HardDeleteChunksByKbFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHardDeleteChunksByKbFileUID.expectedInvocations, n)
	return mmHardDeleteChunksByKbFileUID
}

func (mmHardDeleteChunksByKbFileUID *mRepositoryIMockHardDeleteChunksByKbFileUID) invocationsDone() bool {
	if len(mmHardDeleteChunksByKbFileUID.expectations) == 0 && mmHardDeleteChunksByKbFileUID.defaultExpectation == nil && mmHardDeleteChunksByKbFileUID.mock.funcHardDeleteChunksByKbFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHardDeleteChunksByKbFileUID.mock.afterHardDeleteChunksByKbFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHardDeleteChunksByKbFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HardDeleteChunksByKbFileUID implements repository.RepositoryI
func (mmHardDeleteChunksByKbFileUID *RepositoryIMock) HardDeleteChunksByKbFileUID(ctx context.Context, kbFileUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmHardDeleteChunksByKbFileUID.beforeHardDeleteChunksByKbFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmHardDeleteChunksByKbFileUID.afterHardDeleteChunksByKbFileUIDCounter, 1)

	if mmHardDeleteChunksByKbFileUID.inspectFuncHardDeleteChunksByKbFileUID != nil {
		mmHardDeleteChunksByKbFileUID.inspectFuncHardDeleteChunksByKbFileUID(ctx, kbFileUID)
	}

	mm_params := RepositoryIMockHardDeleteChunksByKbFileUIDParams{ctx, kbFileUID}

	// Record call args
	mmHardDeleteChunksByKbFileUID.HardDeleteChunksByKbFileUIDMock.mutex.Lock()
	mmHardDeleteChunksByKbFileUID.HardDeleteChunksByKbFileUIDMock.callArgs = append(mmHardDeleteChunksByKbFileUID.HardDeleteChunksByKbFileUIDMock.callArgs, &mm_params)
	mmHardDeleteChunksByKbFileUID.HardDeleteChunksByKbFileUIDMock.mutex.Unlock()

	for _, e := range mmHardDeleteChunksByKbFileUID.HardDeleteChunksByKbFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHardDeleteChunksByKbFileUID.HardDeleteChunksByKbFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHardDeleteChunksByKbFileUID.HardDeleteChunksByKbFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmHardDeleteChunksByKbFileUID.HardDeleteChunksByKbFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmHardDeleteChunksByKbFileUID.HardDeleteChunksByKbFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockHardDeleteChunksByKbFileUIDParams{ctx, kbFileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHardDeleteChunksByKbFileUID.t.Errorf("RepositoryIMock.HardDeleteChunksByKbFileUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbFileUID != nil && !minimock.Equal(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID) {
				mmHardDeleteChunksByKbFileUID.t.Errorf("RepositoryIMock.HardDeleteChunksByKbFileUID got unexpected parameter kbFileUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbFileUID, mm_got.kbFileUID, minimock.Diff(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHardDeleteChunksByKbFileUID.t.Errorf("RepositoryIMock.HardDeleteChunksByKbFileUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHardDeleteChunksByKbFileUID.HardDeleteChunksByKbFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmHardDeleteChunksByKbFileUID.t.Fatal("No results are set for the RepositoryIMock.HardDeleteChunksByKbFileUID")
		}
		return (*mm_results).err
	}
	if mmHardDeleteChunksByKbFileUID.funcHardDeleteChunksByKbFileUID != nil {
		return mmHardDeleteChunksByKbFileUID.funcHardDeleteChunksByKbFileUID(ctx, kbFileUID)
	}
	mmHardDeleteChunksByKbFileUID.t.Fatalf("Unexpected call to RepositoryIMock.HardDeleteChunksByKbFileUID. %v %v", ctx, kbFileUID)
	return
}

// HardDeleteChunksByKbFileUIDAfterCounter returns a count of finished RepositoryIMock.HardDeleteChunksByKbFileUID invocations
func (mmHardDeleteChunksByKbFileUID *RepositoryIMock) HardDeleteChunksByKbFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteChunksByKbFileUID.afterHardDeleteChunksByKbFileUIDCounter)
}

// HardDeleteChunksByKbFileUIDBeforeCounter returns a count of RepositoryIMock.HardDeleteChunksByKbFileUID invocations
func (mmHardDeleteChunksByKbFileUID *RepositoryIMock) HardDeleteChunksByKbFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteChunksByKbFileUID.beforeHardDeleteChunksByKbFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.HardDeleteChunksByKbFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHardDeleteChunksByKbFileUID *mRepositoryIMockHardDeleteChunksByKbFileUID) Calls() []*RepositoryIMockHardDeleteChunksByKbFileUIDParams {
	mmHardDeleteChunksByKbFileUID.mutex.RLock()

	argCopy := make([]*RepositoryIMockHardDeleteChunksByKbFileUIDParams, len(mmHardDeleteChunksByKbFileUID.callArgs))
	copy(argCopy, mmHardDeleteChunksByKbFileUID.callArgs)

	mmHardDeleteChunksByKbFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockHardDeleteChunksByKbFileUIDDone returns true if the count of the HardDeleteChunksByKbFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockHardDeleteChunksByKbFileUIDDone() bool {
	for _, e := range m.HardDeleteChunksByKbFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HardDeleteChunksByKbFileUIDMock.invocationsDone()
}

// MinimockHardDeleteChunksByKbFileUIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockHardDeleteChunksByKbFileUIDInspect() {
	for _, e := range m.HardDeleteChunksByKbFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.HardDeleteChunksByKbFileUID with params: %#v", *e.params)
		}
	}

	afterHardDeleteChunksByKbFileUIDCounter := mm_atomic.LoadUint64(&m.afterHardDeleteChunksByKbFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HardDeleteChunksByKbFileUIDMock.defaultExpectation != nil && afterHardDeleteChunksByKbFileUIDCounter < 1 {
		if m.HardDeleteChunksByKbFileUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.HardDeleteChunksByKbFileUID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.HardDeleteChunksByKbFileUID with params: %#v", *m.HardDeleteChunksByKbFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHardDeleteChunksByKbFileUID != nil && afterHardDeleteChunksByKbFileUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.HardDeleteChunksByKbFileUID")
	}

	if !m.HardDeleteChunksByKbFileUIDMock.invocationsDone() && afterHardDeleteChunksByKbFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.HardDeleteChunksByKbFileUID but found %d calls",
			mm_atomic.LoadUint64(&m.HardDeleteChunksByKbFileUIDMock.expectedInvocations), afterHardDeleteChunksByKbFileUIDCounter)
	}
}

type mRepositoryIMockHardDeleteChunksByKbUID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockHardDeleteChunksByKbUIDExpectation
	expectations       []*RepositoryIMockHardDeleteChunksByKbUIDExpectation

	callArgs []*RepositoryIMockHardDeleteChunksByKbUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockHardDeleteChunksByKbUIDExpectation specifies expectation struct of the RepositoryI.HardDeleteChunksByKbUID
type RepositoryIMockHardDeleteChunksByKbUIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockHardDeleteChunksByKbUIDParams
	paramPtrs *RepositoryIMockHardDeleteChunksByKbUIDParamPtrs
	results   *RepositoryIMockHardDeleteChunksByKbUIDResults
	Counter   uint64
}

// RepositoryIMockHardDeleteChunksByKbUIDParams contains parameters of the RepositoryI.HardDeleteChunksByKbUID
type RepositoryIMockHardDeleteChunksByKbUIDParams struct {
	ctx   context.Context
	kbUID uuid.UUID
}

// RepositoryIMockHardDeleteChunksByKbUIDParamPtrs contains pointers to parameters of the RepositoryI.HardDeleteChunksByKbUID
type RepositoryIMockHardDeleteChunksByKbUIDParamPtrs struct {
	ctx   *context.Context
	kbUID *uuid.UUID
}

// RepositoryIMockHardDeleteChunksByKbUIDResults contains results of the RepositoryI.HardDeleteChunksByKbUID
type RepositoryIMockHardDeleteChunksByKbUIDResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.HardDeleteChunksByKbUID
func (mmHardDeleteChunksByKbUID *mRepositoryIMockHardDeleteChunksByKbUID) Expect(ctx context.Context, kbUID uuid.UUID) *mRepositoryIMockHardDeleteChunksByKbUID {
	if mmHardDeleteChunksByKbUID.mock.funcHardDeleteChunksByKbUID != nil {
		mmHardDeleteChunksByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbUID mock is already set by Set")
	}

	if mmHardDeleteChunksByKbUID.defaultExpectation == nil {
		mmHardDeleteChunksByKbUID.defaultExpectation = &RepositoryIMockHardDeleteChunksByKbUIDExpectation{}
	}

	if mmHardDeleteChunksByKbUID.defaultExpectation.paramPtrs != nil {
		mmHardDeleteChunksByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbUID mock is already set by ExpectParams functions")
	}

	mmHardDeleteChunksByKbUID.defaultExpectation.params = &RepositoryIMockHardDeleteChunksByKbUIDParams{ctx, kbUID}
	for _, e := range mmHardDeleteChunksByKbUID.expectations {
		if minimock.Equal(e.params, mmHardDeleteChunksByKbUID.defaultExpectation.params) {
			mmHardDeleteChunksByKbUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHardDeleteChunksByKbUID.defaultExpectation.params)
		}
	}

	return mmHardDeleteChunksByKbUID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.HardDeleteChunksByKbUID
func (mmHardDeleteChunksByKbUID *mRepositoryIMockHardDeleteChunksByKbUID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockHardDeleteChunksByKbUID {
	if mmHardDeleteChunksByKbUID.mock.funcHardDeleteChunksByKbUID != nil {
		mmHardDeleteChunksByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbUID mock is already set by Set")
	}

	if mmHardDeleteChunksByKbUID.defaultExpectation == nil {
		mmHardDeleteChunksByKbUID.defaultExpectation = &RepositoryIMockHardDeleteChunksByKbUIDExpectation{}
	}

	if mmHardDeleteChunksByKbUID.defaultExpectation.params != nil {
		mmHardDeleteChunksByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbUID mock is already set by Expect")
	}

	if mmHardDeleteChunksByKbUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteChunksByKbUID.defaultExpectation.paramPtrs = &RepositoryIMockHardDeleteChunksByKbUIDParamPtrs{}
	}
	mmHardDeleteChunksByKbUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmHardDeleteChunksByKbUID
}

// ExpectKbUIDParam2 sets up expected param kbUID for RepositoryI.HardDeleteChunksByKbUID
func (mmHardDeleteChunksByKbUID *mRepositoryIMockHardDeleteChunksByKbUID) ExpectKbUIDParam2(kbUID uuid.UUID) *mRepositoryIMockHardDeleteChunksByKbUID {
	if mmHardDeleteChunksByKbUID.mock.funcHardDeleteChunksByKbUID != nil {
		mmHardDeleteChunksByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbUID mock is already set by Set")
	}

	if mmHardDeleteChunksByKbUID.defaultExpectation == nil {
		mmHardDeleteChunksByKbUID.defaultExpectation = &RepositoryIMockHardDeleteChunksByKbUIDExpectation{}
	}

	if mmHardDeleteChunksByKbUID.defaultExpectation.params != nil {
		mmHardDeleteChunksByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbUID mock is already set by Expect")
	}

	if mmHardDeleteChunksByKbUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteChunksByKbUID.defaultExpectation.paramPtrs = &RepositoryIMockHardDeleteChunksByKbUIDParamPtrs{}
	}
	mmHardDeleteChunksByKbUID.defaultExpectation.paramPtrs.kbUID = &kbUID

	return mmHardDeleteChunksByKbUID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.HardDeleteChunksByKbUID
func (mmHardDeleteChunksByKbUID *mRepositoryIMockHardDeleteChunksByKbUID) Inspect(f func(ctx context.Context, kbUID uuid.UUID)) *mRepositoryIMockHardDeleteChunksByKbUID {
	if mmHardDeleteChunksByKbUID.mock.inspectFuncHardDeleteChunksByKbUID != nil {
		mmHardDeleteChunksByKbUID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.HardDeleteChunksByKbUID")
	}

	mmHardDeleteChunksByKbUID.mock.inspectFuncHardDeleteChunksByKbUID = f

	return mmHardDeleteChunksByKbUID
}

// Return sets up results that will be returned by RepositoryI.HardDeleteChunksByKbUID
func (mmHardDeleteChunksByKbUID *mRepositoryIMockHardDeleteChunksByKbUID) Return(err error) *RepositoryIMock {
	if mmHardDeleteChunksByKbUID.mock.funcHardDeleteChunksByKbUID != nil {
		mmHardDeleteChunksByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbUID mock is already set by Set")
	}

	if mmHardDeleteChunksByKbUID.defaultExpectation == nil {
		mmHardDeleteChunksByKbUID.defaultExpectation = &RepositoryIMockHardDeleteChunksByKbUIDExpectation{mock: mmHardDeleteChunksByKbUID.mock}
	}
	mmHardDeleteChunksByKbUID.defaultExpectation.results = &RepositoryIMockHardDeleteChunksByKbUIDResults{err}
	return mmHardDeleteChunksByKbUID.mock
}

// Set uses given function f to mock the RepositoryI.HardDeleteChunksByKbUID method
func (mmHardDeleteChunksByKbUID *mRepositoryIMockHardDeleteChunksByKbUID) Set(f func(ctx context.Context, kbUID uuid.UUID) (err error)) *RepositoryIMock {
	if mmHardDeleteChunksByKbUID.defaultExpectation != nil {
		mmHardDeleteChunksByKbUID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.HardDeleteChunksByKbUID method")
	}

	if len(mmHardDeleteChunksByKbUID.expectations) > 0 {
		mmHardDeleteChunksByKbUID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.HardDeleteChunksByKbUID method")
	}

	mmHardDeleteChunksByKbUID.mock.funcHardDeleteChunksByKbUID = f
	return mmHardDeleteChunksByKbUID.mock
}

// When sets expectation for the RepositoryI.HardDeleteChunksByKbUID which will trigger the result defined by the following
// Then helper
func (mmHardDeleteChunksByKbUID *mRepositoryIMockHardDeleteChunksByKbUID) When(ctx context.Context, kbUID uuid.UUID) *RepositoryIMockHardDeleteChunksByKbUIDExpectation {
	if mmHardDeleteChunksByKbUID.mock.funcHardDeleteChunksByKbUID != nil {
		mmHardDeleteChunksByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbUID mock is already set by Set")
	}

	expectation := &RepositoryIMockHardDeleteChunksByKbUIDExpectation{
		mock:   mmHardDeleteChunksByKbUID.mock,
		params: &RepositoryIMockHardDeleteChunksByKbUIDParams{ctx, kbUID},
	}
	mmHardDeleteChunksByKbUID.expectations = append(mmHardDeleteChunksByKbUID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.HardDeleteChunksByKbUID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockHardDeleteChunksByKbUIDExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockHardDeleteChunksByKbUIDResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.HardDeleteChunksByKbUID should be invoked
func (mmHardDeleteChunksByKbUID *mRepositoryIMockHardDeleteChunksByKbUID) Times(n uint64) *mRepositoryIMockHardDeleteChunksByKbUID {
	if n == 0 {
		mmHardDeleteChunksByKbUID.mock.t.Fatalf("Times of RepositoryIMock.HardDeleteChunksByKbUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHardDeleteChunksByKbUID.expectedInvocations, n)
	return mmHardDeleteChunksByKbUID
}

func (mmHardDeleteChunksByKbUID *mRepositoryIMockHardDeleteChunksByKbUID) invocationsDone() bool {
	if len(mmHardDeleteChunksByKbUID.expectations) == 0 && mmHardDeleteChunksByKbUID.defaultExpectation == nil && mmHardDeleteChunksByKbUID.mock.funcHardDeleteChunksByKbUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHardDeleteChunksByKbUID.mock.afterHardDeleteChunksByKbUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHardDeleteChunksByKbUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HardDeleteChunksByKbUID implements repository.RepositoryI
func (mmHardDeleteChunksByKbUID *RepositoryIMock) HardDeleteChunksByKbUID(ctx context.Context, kbUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmHardDeleteChunksByKbUID.beforeHardDeleteChunksByKbUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmHardDeleteChunksByKbUID.afterHardDeleteChunksByKbUIDCounter, 1)

	if mmHardDeleteChunksByKbUID.inspectFuncHardDeleteChunksByKbUID != nil {
		mmHardDeleteChunksByKbUID.inspectFuncHardDeleteChunksByKbUID(ctx, kbUID)
	}

	mm_params := RepositoryIMockHardDeleteChunksByKbUIDParams{ctx, kbUID}

	// Record call args
	mmHardDeleteChunksByKbUID.HardDeleteChunksByKbUIDMock.mutex.Lock()
	mmHardDeleteChunksByKbUID.HardDeleteChunksByKbUIDMock.callArgs = append(mmHardDeleteChunksByKbUID.HardDeleteChunksByKbUIDMock.callArgs, &mm_params)
	mmHardDeleteChunksByKbUID.HardDeleteChunksByKbUIDMock.mutex.Unlock()

	for _, e := range mmHardDeleteChunksByKbUID.HardDeleteChunksByKbUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHardDeleteChunksByKbUID.HardDeleteChunksByKbUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHardDeleteChunksByKbUID.HardDeleteChunksByKbUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmHardDeleteChunksByKbUID.HardDeleteChunksByKbUIDMock.defaultExpectation.params
		mm_want_ptrs := mmHardDeleteChunksByKbUID.HardDeleteChunksByKbUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockHardDeleteChunksByKbUIDParams{ctx, kbUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHardDeleteChunksByKbUID.t.Errorf("RepositoryIMock.HardDeleteChunksByKbUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmHardDeleteChunksByKbUID.t.Errorf("RepositoryIMock.HardDeleteChunksByKbUID got unexpected parameter kbUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHardDeleteChunksByKbUID.t.Errorf("RepositoryIMock.HardDeleteChunksByKbUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHardDeleteChunksByKbUID.HardDeleteChunksByKbUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmHardDeleteChunksByKbUID.t.Fatal("No results are set for the RepositoryIMock.HardDeleteChunksByKbUID")
		}
		return (*mm_results).err
	}
	if mmHardDeleteChunksByKbUID.funcHardDeleteChunksByKbUID != nil {
		return mmHardDeleteChunksByKbUID.funcHardDeleteChunksByKbUID(ctx, kbUID)
	}
	mmHardDeleteChunksByKbUID.t.Fatalf("Unexpected call to RepositoryIMock.HardDeleteChunksByKbUID. %v %v", ctx, kbUID)
	return
}

// HardDeleteChunksByKbUIDAfterCounter returns a count of finished RepositoryIMock.HardDeleteChunksByKbUID invocations
func (mmHardDeleteChunksByKbUID *RepositoryIMock) HardDeleteChunksByKbUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteChunksByKbUID.afterHardDeleteChunksByKbUIDCounter)
}

// HardDeleteChunksByKbUIDBeforeCounter returns a count of RepositoryIMock.HardDeleteChunksByKbUID invocations
func (mmHardDeleteChunksByKbUID *RepositoryIMock) HardDeleteChunksByKbUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteChunksByKbUID.beforeHardDeleteChunksByKbUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.HardDeleteChunksByKbUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHardDeleteChunksByKbUID *mRepositoryIMockHardDeleteChunksByKbUID) Calls() []*RepositoryIMockHardDeleteChunksByKbUIDParams {
	mmHardDeleteChunksByKbUID.mutex.RLock()

	argCopy := make([]*RepositoryIMockHardDeleteChunksByKbUIDParams, len(mmHardDeleteChunksByKbUID.callArgs))
	copy(argCopy, mmHardDeleteChunksByKbUID.callArgs)

	mmHardDeleteChunksByKbUID.mutex.RUnlock()

	return argCopy
}

// MinimockHardDeleteChunksByKbUIDDone returns true if the count of the HardDeleteChunksByKbUID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockHardDeleteChunksByKbUIDDone() bool {
	for _, e := range m.HardDeleteChunksByKbUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HardDeleteChunksByKbUIDMock.invocationsDone()
}

// MinimockHardDeleteChunksByKbUIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockHardDeleteChunksByKbUIDInspect() {
	for _, e := range m.HardDeleteChunksByKbUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.HardDeleteChunksByKbUID with params: %#v", *e.params)
		}
	}

	afterHardDeleteChunksByKbUIDCounter := mm_atomic.LoadUint64(&m.afterHardDeleteChunksByKbUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HardDeleteChunksByKbUIDMock.defaultExpectation != nil && afterHardDeleteChunksByKbUIDCounter < 1 {
		if m.HardDeleteChunksByKbUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.HardDeleteChunksByKbUID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.HardDeleteChunksByKbUID with params: %#v", *m.HardDeleteChunksByKbUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHardDeleteChunksByKbUID != nil && afterHardDeleteChunksByKbUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.HardDeleteChunksByKbUID")
	}

	if !m.HardDeleteChunksByKbUIDMock.invocationsDone() && afterHardDeleteChunksByKbUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.HardDeleteChunksByKbUID but found %d calls",
			mm_atomic.LoadUint64(&m.HardDeleteChunksByKbUIDMock.expectedInvocations), afterHardDeleteChunksByKbUIDCounter)
	}
}

type mRepositoryIMockHardDeleteConvertedFileByFileUID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockHardDeleteConvertedFileByFileUIDExpectation
	expectations       []*RepositoryIMockHardDeleteConvertedFileByFileUIDExpectation

	callArgs []*RepositoryIMockHardDeleteConvertedFileByFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockHardDeleteConvertedFileByFileUIDExpectation specifies expectation struct of the RepositoryI.HardDeleteConvertedFileByFileUID
type RepositoryIMockHardDeleteConvertedFileByFileUIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockHardDeleteConvertedFileByFileUIDParams
	paramPtrs *RepositoryIMockHardDeleteConvertedFileByFileUIDParamPtrs
	results   *RepositoryIMockHardDeleteConvertedFileByFileUIDResults
	Counter   uint64
}

// RepositoryIMockHardDeleteConvertedFileByFileUIDParams contains parameters of the RepositoryI.HardDeleteConvertedFileByFileUID
type RepositoryIMockHardDeleteConvertedFileByFileUIDParams struct {
	ctx     context.Context
	fileUID uuid.UUID
}

// RepositoryIMockHardDeleteConvertedFileByFileUIDParamPtrs contains pointers to parameters of the RepositoryI.HardDeleteConvertedFileByFileUID
type RepositoryIMockHardDeleteConvertedFileByFileUIDParamPtrs struct {
	ctx     *context.Context
	fileUID *uuid.UUID
}

// RepositoryIMockHardDeleteConvertedFileByFileUIDResults contains results of the RepositoryI.HardDeleteConvertedFileByFileUID
type RepositoryIMockHardDeleteConvertedFileByFileUIDResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.HardDeleteConvertedFileByFileUID
func (mmHardDeleteConvertedFileByFileUID *mRepositoryIMockHardDeleteConvertedFileByFileUID) Expect(ctx context.Context, fileUID uuid.UUID) *mRepositoryIMockHardDeleteConvertedFileByFileUID {
	if mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUID != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteConvertedFileByFileUID mock is already set by Set")
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation == nil {
		mmHardDeleteConvertedFileByFileUID.defaultExpectation = &RepositoryIMockHardDeleteConvertedFileByFileUIDExpectation{}
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteConvertedFileByFileUID mock is already set by ExpectParams functions")
	}

	mmHardDeleteConvertedFileByFileUID.defaultExpectation.params = &RepositoryIMockHardDeleteConvertedFileByFileUIDParams{ctx, fileUID}
	for _, e := range mmHardDeleteConvertedFileByFileUID.expectations {
		if minimock.Equal(e.params, mmHardDeleteConvertedFileByFileUID.defaultExpectation.params) {
			mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHardDeleteConvertedFileByFileUID.defaultExpectation.params)
		}
	}

	return mmHardDeleteConvertedFileByFileUID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.HardDeleteConvertedFileByFileUID
func (mmHardDeleteConvertedFileByFileUID *mRepositoryIMockHardDeleteConvertedFileByFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockHardDeleteConvertedFileByFileUID {
	if mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUID != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteConvertedFileByFileUID mock is already set by Set")
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation == nil {
		mmHardDeleteConvertedFileByFileUID.defaultExpectation = &RepositoryIMockHardDeleteConvertedFileByFileUIDExpectation{}
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation.params != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteConvertedFileByFileUID mock is already set by Expect")
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs = &RepositoryIMockHardDeleteConvertedFileByFileUIDParamPtrs{}
	}
	mmHardDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmHardDeleteConvertedFileByFileUID
}

// ExpectFileUIDParam2 sets up expected param fileUID for RepositoryI.HardDeleteConvertedFileByFileUID
func (mmHardDeleteConvertedFileByFileUID *mRepositoryIMockHardDeleteConvertedFileByFileUID) ExpectFileUIDParam2(fileUID uuid.UUID) *mRepositoryIMockHardDeleteConvertedFileByFileUID {
	if mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUID != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteConvertedFileByFileUID mock is already set by Set")
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation == nil {
		mmHardDeleteConvertedFileByFileUID.defaultExpectation = &RepositoryIMockHardDeleteConvertedFileByFileUIDExpectation{}
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation.params != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteConvertedFileByFileUID mock is already set by Expect")
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs = &RepositoryIMockHardDeleteConvertedFileByFileUIDParamPtrs{}
	}
	mmHardDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs.fileUID = &fileUID

	return mmHardDeleteConvertedFileByFileUID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.HardDeleteConvertedFileByFileUID
func (mmHardDeleteConvertedFileByFileUID *mRepositoryIMockHardDeleteConvertedFileByFileUID) Inspect(f func(ctx context.Context, fileUID uuid.UUID)) *mRepositoryIMockHardDeleteConvertedFileByFileUID {
	if mmHardDeleteConvertedFileByFileUID.mock.inspectFuncHardDeleteConvertedFileByFileUID != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.HardDeleteConvertedFileByFileUID")
	}

	mmHardDeleteConvertedFileByFileUID.mock.inspectFuncHardDeleteConvertedFileByFileUID = f

	return mmHardDeleteConvertedFileByFileUID
}

// Return sets up results that will be returned by RepositoryI.HardDeleteConvertedFileByFileUID
func (mmHardDeleteConvertedFileByFileUID *mRepositoryIMockHardDeleteConvertedFileByFileUID) Return(err error) *RepositoryIMock {
	if mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUID != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteConvertedFileByFileUID mock is already set by Set")
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation == nil {
		mmHardDeleteConvertedFileByFileUID.defaultExpectation = &RepositoryIMockHardDeleteConvertedFileByFileUIDExpectation{mock: mmHardDeleteConvertedFileByFileUID.mock}
	}
	mmHardDeleteConvertedFileByFileUID.defaultExpectation.results = &RepositoryIMockHardDeleteConvertedFileByFileUIDResults{err}
	return mmHardDeleteConvertedFileByFileUID.mock
}

// Set uses given function f to mock the RepositoryI.HardDeleteConvertedFileByFileUID method
func (mmHardDeleteConvertedFileByFileUID *mRepositoryIMockHardDeleteConvertedFileByFileUID) Set(f func(ctx context.Context, fileUID uuid.UUID) (err error)) *RepositoryIMock {
	if mmHardDeleteConvertedFileByFileUID.defaultExpectation != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.HardDeleteConvertedFileByFileUID method")
	}

	if len(mmHardDeleteConvertedFileByFileUID.expectations) > 0 {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.HardDeleteConvertedFileByFileUID method")
	}

	mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUID = f
	return mmHardDeleteConvertedFileByFileUID.mock
}

// When sets expectation for the RepositoryI.HardDeleteConvertedFileByFileUID which will trigger the result defined by the following
// Then helper
func (mmHardDeleteConvertedFileByFileUID *mRepositoryIMockHardDeleteConvertedFileByFileUID) When(ctx context.Context, fileUID uuid.UUID) *RepositoryIMockHardDeleteConvertedFileByFileUIDExpectation {
	if mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUID != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteConvertedFileByFileUID mock is already set by Set")
	}

	expectation := &RepositoryIMockHardDeleteConvertedFileByFileUIDExpectation{
		mock:   mmHardDeleteConvertedFileByFileUID.mock,
		params: &RepositoryIMockHardDeleteConvertedFileByFileUIDParams{ctx, fileUID},
	}
	mmHardDeleteConvertedFileByFileUID.expectations = append(mmHardDeleteConvertedFileByFileUID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.HardDeleteConvertedFileByFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockHardDeleteConvertedFileByFileUIDExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockHardDeleteConvertedFileByFileUIDResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.HardDeleteConvertedFileByFileUID should be invoked
func (mmHardDeleteConvertedFileByFileUID *mRepositoryIMockHardDeleteConvertedFileByFileUID) Times(n uint64) *mRepositoryIMockHardDeleteConvertedFileByFileUID {
	if n == 0 {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("Times of RepositoryIMock.HardDeleteConvertedFileByFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHardDeleteConvertedFileByFileUID.expectedInvocations, n)
	return mmHardDeleteConvertedFileByFileUID
}

func (mmHardDeleteConvertedFileByFileUID *mRepositoryIMockHardDeleteConvertedFileByFileUID) invocationsDone() bool {
	if len(mmHardDeleteConvertedFileByFileUID.expectations) == 0 && mmHardDeleteConvertedFileByFileUID.defaultExpectation == nil && mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHardDeleteConvertedFileByFileUID.mock.afterHardDeleteConvertedFileByFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHardDeleteConvertedFileByFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HardDeleteConvertedFileByFileUID implements repository.RepositoryI
func (mmHardDeleteConvertedFileByFileUID *RepositoryIMock) HardDeleteConvertedFileByFileUID(ctx context.Context, fileUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmHardDeleteConvertedFileByFileUID.beforeHardDeleteConvertedFileByFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmHardDeleteConvertedFileByFileUID.afterHardDeleteConvertedFileByFileUIDCounter, 1)

	if mmHardDeleteConvertedFileByFileUID.inspectFuncHardDeleteConvertedFileByFileUID != nil {
		mmHardDeleteConvertedFileByFileUID.inspectFuncHardDeleteConvertedFileByFileUID(ctx, fileUID)
	}

	mm_params := RepositoryIMockHardDeleteConvertedFileByFileUIDParams{ctx, fileUID}

	// Record call args
	mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.mutex.Lock()
	mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.callArgs = append(mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.callArgs, &mm_params)
	mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.mutex.Unlock()

	for _, e := range mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockHardDeleteConvertedFileByFileUIDParams{ctx, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHardDeleteConvertedFileByFileUID.t.Errorf("RepositoryIMock.HardDeleteConvertedFileByFileUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmHardDeleteConvertedFileByFileUID.t.Errorf("RepositoryIMock.HardDeleteConvertedFileByFileUID got unexpected parameter fileUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHardDeleteConvertedFileByFileUID.t.Errorf("RepositoryIMock.HardDeleteConvertedFileByFileUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmHardDeleteConvertedFileByFileUID.t.Fatal("No results are set for the RepositoryIMock.HardDeleteConvertedFileByFileUID")
		}
		return (*mm_results).err
	}
	if mmHardDeleteConvertedFileByFileUID.funcHardDeleteConvertedFileByFileUID != nil {
		return mmHardDeleteConvertedFileByFileUID.funcHardDeleteConvertedFileByFileUID(ctx, fileUID)
	}
	mmHardDeleteConvertedFileByFileUID.t.Fatalf("Unexpected call to RepositoryIMock.HardDeleteConvertedFileByFileUID. %v %v", ctx, fileUID)
	return
}

// HardDeleteConvertedFileByFileUIDAfterCounter returns a count of finished RepositoryIMock.HardDeleteConvertedFileByFileUID invocations
func (mmHardDeleteConvertedFileByFileUID *RepositoryIMock) HardDeleteConvertedFileByFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteConvertedFileByFileUID.afterHardDeleteConvertedFileByFileUIDCounter)
}

// HardDeleteConvertedFileByFileUIDBeforeCounter returns a count of RepositoryIMock.HardDeleteConvertedFileByFileUID invocations
func (mmHardDeleteConvertedFileByFileUID *RepositoryIMock) HardDeleteConvertedFileByFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteConvertedFileByFileUID.beforeHardDeleteConvertedFileByFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.HardDeleteConvertedFileByFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHardDeleteConvertedFileByFileUID *mRepositoryIMockHardDeleteConvertedFileByFileUID) Calls() []*RepositoryIMockHardDeleteConvertedFileByFileUIDParams {
	mmHardDeleteConvertedFileByFileUID.mutex.RLock()

	argCopy := make([]*RepositoryIMockHardDeleteConvertedFileByFileUIDParams, len(mmHardDeleteConvertedFileByFileUID.callArgs))
	copy(argCopy, mmHardDeleteConvertedFileByFileUID.callArgs)

	mmHardDeleteConvertedFileByFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockHardDeleteConvertedFileByFileUIDDone returns true if the count of the HardDeleteConvertedFileByFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockHardDeleteConvertedFileByFileUIDDone() bool {
	for _, e := range m.HardDeleteConvertedFileByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HardDeleteConvertedFileByFileUIDMock.invocationsDone()
}

// MinimockHardDeleteConvertedFileByFileUIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockHardDeleteConvertedFileByFileUIDInspect() {
	for _, e := range m.HardDeleteConvertedFileByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.HardDeleteConvertedFileByFileUID with params: %#v", *e.params)
		}
	}

	afterHardDeleteConvertedFileByFileUIDCounter := mm_atomic.LoadUint64(&m.afterHardDeleteConvertedFileByFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HardDeleteConvertedFileByFileUIDMock.defaultExpectation != nil && afterHardDeleteConvertedFileByFileUIDCounter < 1 {
		if m.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.HardDeleteConvertedFileByFileUID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.HardDeleteConvertedFileByFileUID with params: %#v", *m.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHardDeleteConvertedFileByFileUID != nil && afterHardDeleteConvertedFileByFileUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.HardDeleteConvertedFileByFileUID")
	}

	if !m.HardDeleteConvertedFileByFileUIDMock.invocationsDone() && afterHardDeleteConvertedFileByFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.HardDeleteConvertedFileByFileUID but found %d calls",
			mm_atomic.LoadUint64(&m.HardDeleteConvertedFileByFileUIDMock.expectedInvocations), afterHardDeleteConvertedFileByFileUIDCounter)
	}
}

type mRepositoryIMockHardDeleteEmbeddingsByKbFileUID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockHardDeleteEmbeddingsByKbFileUIDExpectation
	expectations       []*RepositoryIMockHardDeleteEmbeddingsByKbFileUIDExpectation

	callArgs []*RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockHardDeleteEmbeddingsByKbFileUIDExpectation specifies expectation struct of the RepositoryI.HardDeleteEmbeddingsByKbFileUID
type RepositoryIMockHardDeleteEmbeddingsByKbFileUIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParams
	paramPtrs *RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParamPtrs
	results   *RepositoryIMockHardDeleteEmbeddingsByKbFileUIDResults
	Counter   uint64
}

// RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParams contains parameters of the RepositoryI.HardDeleteEmbeddingsByKbFileUID
type RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParams struct {
	ctx       context.Context
	kbFileUID uuid.UUID
}

// RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParamPtrs contains pointers to parameters of the RepositoryI.HardDeleteEmbeddingsByKbFileUID
type RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParamPtrs struct {
	ctx       *context.Context
	kbFileUID *uuid.UUID
}

// RepositoryIMockHardDeleteEmbeddingsByKbFileUIDResults contains results of the RepositoryI.HardDeleteEmbeddingsByKbFileUID
type RepositoryIMockHardDeleteEmbeddingsByKbFileUIDResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.HardDeleteEmbeddingsByKbFileUID
func (mmHardDeleteEmbeddingsByKbFileUID *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID) Expect(ctx context.Context, kbFileUID uuid.UUID) *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID {
	if mmHardDeleteEmbeddingsByKbFileUID.mock.funcHardDeleteEmbeddingsByKbFileUID != nil {
		mmHardDeleteEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbFileUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation = &RepositoryIMockHardDeleteEmbeddingsByKbFileUIDExpectation{}
	}

	if mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation.paramPtrs != nil {
		mmHardDeleteEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbFileUID mock is already set by ExpectParams functions")
	}

	mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation.params = &RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParams{ctx, kbFileUID}
	for _, e := range mmHardDeleteEmbeddingsByKbFileUID.expectations {
		if minimock.Equal(e.params, mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation.params) {
			mmHardDeleteEmbeddingsByKbFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation.params)
		}
	}

	return mmHardDeleteEmbeddingsByKbFileUID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.HardDeleteEmbeddingsByKbFileUID
func (mmHardDeleteEmbeddingsByKbFileUID *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID {
	if mmHardDeleteEmbeddingsByKbFileUID.mock.funcHardDeleteEmbeddingsByKbFileUID != nil {
		mmHardDeleteEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbFileUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation = &RepositoryIMockHardDeleteEmbeddingsByKbFileUIDExpectation{}
	}

	if mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation.params != nil {
		mmHardDeleteEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbFileUID mock is already set by Expect")
	}

	if mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation.paramPtrs = &RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParamPtrs{}
	}
	mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmHardDeleteEmbeddingsByKbFileUID
}

// ExpectKbFileUIDParam2 sets up expected param kbFileUID for RepositoryI.HardDeleteEmbeddingsByKbFileUID
func (mmHardDeleteEmbeddingsByKbFileUID *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID) ExpectKbFileUIDParam2(kbFileUID uuid.UUID) *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID {
	if mmHardDeleteEmbeddingsByKbFileUID.mock.funcHardDeleteEmbeddingsByKbFileUID != nil {
		mmHardDeleteEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbFileUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation = &RepositoryIMockHardDeleteEmbeddingsByKbFileUIDExpectation{}
	}

	if mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation.params != nil {
		mmHardDeleteEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbFileUID mock is already set by Expect")
	}

	if mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation.paramPtrs = &RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParamPtrs{}
	}
	mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation.paramPtrs.kbFileUID = &kbFileUID

	return mmHardDeleteEmbeddingsByKbFileUID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.HardDeleteEmbeddingsByKbFileUID
func (mmHardDeleteEmbeddingsByKbFileUID *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID) Inspect(f func(ctx context.Context, kbFileUID uuid.UUID)) *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID {
	if mmHardDeleteEmbeddingsByKbFileUID.mock.inspectFuncHardDeleteEmbeddingsByKbFileUID != nil {
		mmHardDeleteEmbeddingsByKbFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.HardDeleteEmbeddingsByKbFileUID")
	}

	mmHardDeleteEmbeddingsByKbFileUID.mock.inspectFuncHardDeleteEmbeddingsByKbFileUID = f

	return mmHardDeleteEmbeddingsByKbFileUID
}

// Return sets up results that will be returned by RepositoryI.HardDeleteEmbeddingsByKbFileUID
func (mmHardDeleteEmbeddingsByKbFileUID *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID) Return(err error) *RepositoryIMock {
	if mmHardDeleteEmbeddingsByKbFileUID.mock.funcHardDeleteEmbeddingsByKbFileUID != nil {
		mmHardDeleteEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbFileUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation = &RepositoryIMockHardDeleteEmbeddingsByKbFileUIDExpectation{mock: mmHardDeleteEmbeddingsByKbFileUID.mock}
	}
	mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation.results = &RepositoryIMockHardDeleteEmbeddingsByKbFileUIDResults{err}
	return mmHardDeleteEmbeddingsByKbFileUID.mock
}

// Set uses given function f to mock the RepositoryI.HardDeleteEmbeddingsByKbFileUID method
func (mmHardDeleteEmbeddingsByKbFileUID *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID) Set(f func(ctx context.Context, kbFileUID uuid.UUID) (err error)) *RepositoryIMock {
	if mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation != nil {
		mmHardDeleteEmbeddingsByKbFileUID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.HardDeleteEmbeddingsByKbFileUID method")
	}

	if len(mmHardDeleteEmbeddingsByKbFileUID.expectations) > 0 {
		mmHardDeleteEmbeddingsByKbFileUID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.HardDeleteEmbeddingsByKbFileUID method")
	}

	mmHardDeleteEmbeddingsByKbFileUID.mock.funcHardDeleteEmbeddingsByKbFileUID = f
	return mmHardDeleteEmbeddingsByKbFileUID.mock
}

// When sets expectation for the RepositoryI.HardDeleteEmbeddingsByKbFileUID which will trigger the result defined by the following
// Then helper
func (mmHardDeleteEmbeddingsByKbFileUID *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID) When(ctx context.Context, kbFileUID uuid.UUID) *RepositoryIMockHardDeleteEmbeddingsByKbFileUIDExpectation {
	if mmHardDeleteEmbeddingsByKbFileUID.mock.funcHardDeleteEmbeddingsByKbFileUID != nil {
		mmHardDeleteEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbFileUID mock is already set by Set")
	}

	expectation := &RepositoryIMockHardDeleteEmbeddingsByKbFileUIDExpectation{
		mock:   mmHardDeleteEmbeddingsByKbFileUID.mock,
		params: &RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParams{ctx, kbFileUID},
	}
	mmHardDeleteEmbeddingsByKbFileUID.expectations = append(mmHardDeleteEmbeddingsByKbFileUID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.HardDeleteEmbeddingsByKbFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockHardDeleteEmbeddingsByKbFileUIDExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockHardDeleteEmbeddingsByKbFileUIDResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.HardDeleteEmbeddingsByKbFileUID should be invoked
func (mmHardDeleteEmbeddingsByKbFileUID *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID) Times(n uint64) *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID {
	if n == 0 {
		mmHardDeleteEmbeddingsByKbFileUID.mock.t.Fatalf("Times of RepositoryIMock.HardDeleteEmbeddingsByKbFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHardDeleteEmbeddingsByKbFileUID.expectedInvocations, n)
	return mmHardDeleteEmbeddingsByKbFileUID
}

func (mmHardDeleteEmbeddingsByKbFileUID *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID) invocationsDone() bool {
	if len(mmHardDeleteEmbeddingsByKbFileUID.expectations) == 0 && mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation == nil && mmHardDeleteEmbeddingsByKbFileUID.mock.funcHardDeleteEmbeddingsByKbFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKbFileUID.mock.afterHardDeleteEmbeddingsByKbFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKbFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HardDeleteEmbeddingsByKbFileUID implements repository.RepositoryI
func (mmHardDeleteEmbeddingsByKbFileUID *RepositoryIMock) HardDeleteEmbeddingsByKbFileUID(ctx context.Context, kbFileUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmHardDeleteEmbeddingsByKbFileUID.beforeHardDeleteEmbeddingsByKbFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmHardDeleteEmbeddingsByKbFileUID.afterHardDeleteEmbeddingsByKbFileUIDCounter, 1)

	if mmHardDeleteEmbeddingsByKbFileUID.inspectFuncHardDeleteEmbeddingsByKbFileUID != nil {
		mmHardDeleteEmbeddingsByKbFileUID.inspectFuncHardDeleteEmbeddingsByKbFileUID(ctx, kbFileUID)
	}

	mm_params := RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParams{ctx, kbFileUID}

	// Record call args
	mmHardDeleteEmbeddingsByKbFileUID.HardDeleteEmbeddingsByKbFileUIDMock.mutex.Lock()
	mmHardDeleteEmbeddingsByKbFileUID.HardDeleteEmbeddingsByKbFileUIDMock.callArgs = append(mmHardDeleteEmbeddingsByKbFileUID.HardDeleteEmbeddingsByKbFileUIDMock.callArgs, &mm_params)
	mmHardDeleteEmbeddingsByKbFileUID.HardDeleteEmbeddingsByKbFileUIDMock.mutex.Unlock()

	for _, e := range mmHardDeleteEmbeddingsByKbFileUID.HardDeleteEmbeddingsByKbFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHardDeleteEmbeddingsByKbFileUID.HardDeleteEmbeddingsByKbFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHardDeleteEmbeddingsByKbFileUID.HardDeleteEmbeddingsByKbFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmHardDeleteEmbeddingsByKbFileUID.HardDeleteEmbeddingsByKbFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmHardDeleteEmbeddingsByKbFileUID.HardDeleteEmbeddingsByKbFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParams{ctx, kbFileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHardDeleteEmbeddingsByKbFileUID.t.Errorf("RepositoryIMock.HardDeleteEmbeddingsByKbFileUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbFileUID != nil && !minimock.Equal(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID) {
				mmHardDeleteEmbeddingsByKbFileUID.t.Errorf("RepositoryIMock.HardDeleteEmbeddingsByKbFileUID got unexpected parameter kbFileUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbFileUID, mm_got.kbFileUID, minimock.Diff(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHardDeleteEmbeddingsByKbFileUID.t.Errorf("RepositoryIMock.HardDeleteEmbeddingsByKbFileUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHardDeleteEmbeddingsByKbFileUID.HardDeleteEmbeddingsByKbFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmHardDeleteEmbeddingsByKbFileUID.t.Fatal("No results are set for the RepositoryIMock.HardDeleteEmbeddingsByKbFileUID")
		}
		return (*mm_results).err
	}
	if mmHardDeleteEmbeddingsByKbFileUID.funcHardDeleteEmbeddingsByKbFileUID != nil {
		return mmHardDeleteEmbeddingsByKbFileUID.funcHardDeleteEmbeddingsByKbFileUID(ctx, kbFileUID)
	}
	mmHardDeleteEmbeddingsByKbFileUID.t.Fatalf("Unexpected call to RepositoryIMock.HardDeleteEmbeddingsByKbFileUID. %v %v", ctx, kbFileUID)
	return
}

// HardDeleteEmbeddingsByKbFileUIDAfterCounter returns a count of finished RepositoryIMock.HardDeleteEmbeddingsByKbFileUID invocations
func (mmHardDeleteEmbeddingsByKbFileUID *RepositoryIMock) HardDeleteEmbeddingsByKbFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKbFileUID.afterHardDeleteEmbeddingsByKbFileUIDCounter)
}

// HardDeleteEmbeddingsByKbFileUIDBeforeCounter returns a count of RepositoryIMock.HardDeleteEmbeddingsByKbFileUID invocations
func (mmHardDeleteEmbeddingsByKbFileUID *RepositoryIMock) HardDeleteEmbeddingsByKbFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKbFileUID.beforeHardDeleteEmbeddingsByKbFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.HardDeleteEmbeddingsByKbFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHardDeleteEmbeddingsByKbFileUID *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID) Calls() []*RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParams {
	mmHardDeleteEmbeddingsByKbFileUID.mutex.RLock()

	argCopy := make([]*RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParams, len(mmHardDeleteEmbeddingsByKbFileUID.callArgs))
	copy(argCopy, mmHardDeleteEmbeddingsByKbFileUID.callArgs)

	mmHardDeleteEmbeddingsByKbFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockHardDeleteEmbeddingsByKbFileUIDDone returns true if the count of the HardDeleteEmbeddingsByKbFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockHardDeleteEmbeddingsByKbFileUIDDone() bool {
	for _, e := range m.HardDeleteEmbeddingsByKbFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HardDeleteEmbeddingsByKbFileUIDMock.invocationsDone()
}

// MinimockHardDeleteEmbeddingsByKbFileUIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockHardDeleteEmbeddingsByKbFileUIDInspect() {
	for _, e := range m.HardDeleteEmbeddingsByKbFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.HardDeleteEmbeddingsByKbFileUID with params: %#v", *e.params)
		}
	}

	afterHardDeleteEmbeddingsByKbFileUIDCounter := mm_atomic.LoadUint64(&m.afterHardDeleteEmbeddingsByKbFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HardDeleteEmbeddingsByKbFileUIDMock.defaultExpectation != nil && afterHardDeleteEmbeddingsByKbFileUIDCounter < 1 {
		if m.HardDeleteEmbeddingsByKbFileUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.HardDeleteEmbeddingsByKbFileUID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.HardDeleteEmbeddingsByKbFileUID with params: %#v", *m.HardDeleteEmbeddingsByKbFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHardDeleteEmbeddingsByKbFileUID != nil && afterHardDeleteEmbeddingsByKbFileUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.HardDeleteEmbeddingsByKbFileUID")
	}

	if !m.HardDeleteEmbeddingsByKbFileUIDMock.invocationsDone() && afterHardDeleteEmbeddingsByKbFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.HardDeleteEmbeddingsByKbFileUID but found %d calls",
			mm_atomic.LoadUint64(&m.HardDeleteEmbeddingsByKbFileUIDMock.expectedInvocations), afterHardDeleteEmbeddingsByKbFileUIDCounter)
	}
}

type mRepositoryIMockHardDeleteEmbeddingsByKbUID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockHardDeleteEmbeddingsByKbUIDExpectation
	expectations       []*RepositoryIMockHardDeleteEmbeddingsByKbUIDExpectation

	callArgs []*RepositoryIMockHardDeleteEmbeddingsByKbUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockHardDeleteEmbeddingsByKbUIDExpectation specifies expectation struct of the RepositoryI.HardDeleteEmbeddingsByKbUID
type RepositoryIMockHardDeleteEmbeddingsByKbUIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockHardDeleteEmbeddingsByKbUIDParams
	paramPtrs *RepositoryIMockHardDeleteEmbeddingsByKbUIDParamPtrs
	results   *RepositoryIMockHardDeleteEmbeddingsByKbUIDResults
	Counter   uint64
}

// RepositoryIMockHardDeleteEmbeddingsByKbUIDParams contains parameters of the RepositoryI.HardDeleteEmbeddingsByKbUID
type RepositoryIMockHardDeleteEmbeddingsByKbUIDParams struct {
	ctx   context.Context
	kbUID uuid.UUID
}

// RepositoryIMockHardDeleteEmbeddingsByKbUIDParamPtrs contains pointers to parameters of the RepositoryI.HardDeleteEmbeddingsByKbUID
type RepositoryIMockHardDeleteEmbeddingsByKbUIDParamPtrs struct {
	ctx   *context.Context
	kbUID *uuid.UUID
}

// RepositoryIMockHardDeleteEmbeddingsByKbUIDResults contains results of the RepositoryI.HardDeleteEmbeddingsByKbUID
type RepositoryIMockHardDeleteEmbeddingsByKbUIDResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.HardDeleteEmbeddingsByKbUID
func (mmHardDeleteEmbeddingsByKbUID *mRepositoryIMockHardDeleteEmbeddingsByKbUID) Expect(ctx context.Context, kbUID uuid.UUID) *mRepositoryIMockHardDeleteEmbeddingsByKbUID {
	if mmHardDeleteEmbeddingsByKbUID.mock.funcHardDeleteEmbeddingsByKbUID != nil {
		mmHardDeleteEmbeddingsByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKbUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKbUID.defaultExpectation = &RepositoryIMockHardDeleteEmbeddingsByKbUIDExpectation{}
	}

	if mmHardDeleteEmbeddingsByKbUID.defaultExpectation.paramPtrs != nil {
		mmHardDeleteEmbeddingsByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbUID mock is already set by ExpectParams functions")
	}

	mmHardDeleteEmbeddingsByKbUID.defaultExpectation.params = &RepositoryIMockHardDeleteEmbeddingsByKbUIDParams{ctx, kbUID}
	for _, e := range mmHardDeleteEmbeddingsByKbUID.expectations {
		if minimock.Equal(e.params, mmHardDeleteEmbeddingsByKbUID.defaultExpectation.params) {
			mmHardDeleteEmbeddingsByKbUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHardDeleteEmbeddingsByKbUID.defaultExpectation.params)
		}
	}

	return mmHardDeleteEmbeddingsByKbUID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.HardDeleteEmbeddingsByKbUID
func (mmHardDeleteEmbeddingsByKbUID *mRepositoryIMockHardDeleteEmbeddingsByKbUID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockHardDeleteEmbeddingsByKbUID {
	if mmHardDeleteEmbeddingsByKbUID.mock.funcHardDeleteEmbeddingsByKbUID != nil {
		mmHardDeleteEmbeddingsByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKbUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKbUID.defaultExpectation = &RepositoryIMockHardDeleteEmbeddingsByKbUIDExpectation{}
	}

	if mmHardDeleteEmbeddingsByKbUID.defaultExpectation.params != nil {
		mmHardDeleteEmbeddingsByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbUID mock is already set by Expect")
	}

	if mmHardDeleteEmbeddingsByKbUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteEmbeddingsByKbUID.defaultExpectation.paramPtrs = &RepositoryIMockHardDeleteEmbeddingsByKbUIDParamPtrs{}
	}
	mmHardDeleteEmbeddingsByKbUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmHardDeleteEmbeddingsByKbUID
}

// ExpectKbUIDParam2 sets up expected param kbUID for RepositoryI.HardDeleteEmbeddingsByKbUID
func (mmHardDeleteEmbeddingsByKbUID *mRepositoryIMockHardDeleteEmbeddingsByKbUID) ExpectKbUIDParam2(kbUID uuid.UUID) *mRepositoryIMockHardDeleteEmbeddingsByKbUID {
	if mmHardDeleteEmbeddingsByKbUID.mock.funcHardDeleteEmbeddingsByKbUID != nil {
		mmHardDeleteEmbeddingsByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKbUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKbUID.defaultExpectation = &RepositoryIMockHardDeleteEmbeddingsByKbUIDExpectation{}
	}

	if mmHardDeleteEmbeddingsByKbUID.defaultExpectation.params != nil {
		mmHardDeleteEmbeddingsByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbUID mock is already set by Expect")
	}

	if mmHardDeleteEmbeddingsByKbUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteEmbeddingsByKbUID.defaultExpectation.paramPtrs = &RepositoryIMockHardDeleteEmbeddingsByKbUIDParamPtrs{}
	}
	mmHardDeleteEmbeddingsByKbUID.defaultExpectation.paramPtrs.kbUID = &kbUID

	return mmHardDeleteEmbeddingsByKbUID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.HardDeleteEmbeddingsByKbUID
func (mmHardDeleteEmbeddingsByKbUID *mRepositoryIMockHardDeleteEmbeddingsByKbUID) Inspect(f func(ctx context.Context, kbUID uuid.UUID)) *mRepositoryIMockHardDeleteEmbeddingsByKbUID {
	if mmHardDeleteEmbeddingsByKbUID.mock.inspectFuncHardDeleteEmbeddingsByKbUID != nil {
		mmHardDeleteEmbeddingsByKbUID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.HardDeleteEmbeddingsByKbUID")
	}

	mmHardDeleteEmbeddingsByKbUID.mock.inspectFuncHardDeleteEmbeddingsByKbUID = f

	return mmHardDeleteEmbeddingsByKbUID
}

// Return sets up results that will be returned by RepositoryI.HardDeleteEmbeddingsByKbUID
func (mmHardDeleteEmbeddingsByKbUID *mRepositoryIMockHardDeleteEmbeddingsByKbUID) Return(err error) *RepositoryIMock {
	if mmHardDeleteEmbeddingsByKbUID.mock.funcHardDeleteEmbeddingsByKbUID != nil {
		mmHardDeleteEmbeddingsByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKbUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKbUID.defaultExpectation = &RepositoryIMockHardDeleteEmbeddingsByKbUIDExpectation{mock: mmHardDeleteEmbeddingsByKbUID.mock}
	}
	mmHardDeleteEmbeddingsByKbUID.defaultExpectation.results = &RepositoryIMockHardDeleteEmbeddingsByKbUIDResults{err}
	return mmHardDeleteEmbeddingsByKbUID.mock
}

// Set uses given function f to mock the RepositoryI.HardDeleteEmbeddingsByKbUID method
func (mmHardDeleteEmbeddingsByKbUID *mRepositoryIMockHardDeleteEmbeddingsByKbUID) Set(f func(ctx context.Context, kbUID uuid.UUID) (err error)) *RepositoryIMock {
	if mmHardDeleteEmbeddingsByKbUID.defaultExpectation != nil {
		mmHardDeleteEmbeddingsByKbUID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.HardDeleteEmbeddingsByKbUID method")
	}

	if len(mmHardDeleteEmbeddingsByKbUID.expectations) > 0 {
		mmHardDeleteEmbeddingsByKbUID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.HardDeleteEmbeddingsByKbUID method")
	}

	mmHardDeleteEmbeddingsByKbUID.mock.funcHardDeleteEmbeddingsByKbUID = f
	return mmHardDeleteEmbeddingsByKbUID.mock
}

// When sets expectation for the RepositoryI.HardDeleteEmbeddingsByKbUID which will trigger the result defined by the following
// Then helper
func (mmHardDeleteEmbeddingsByKbUID *mRepositoryIMockHardDeleteEmbeddingsByKbUID) When(ctx context.Context, kbUID uuid.UUID) *RepositoryIMockHardDeleteEmbeddingsByKbUIDExpectation {
	if mmHardDeleteEmbeddingsByKbUID.mock.funcHardDeleteEmbeddingsByKbUID != nil {
		mmHardDeleteEmbeddingsByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbUID mock is already set by Set")
	}

	expectation := &RepositoryIMockHardDeleteEmbeddingsByKbUIDExpectation{
		mock:   mmHardDeleteEmbeddingsByKbUID.mock,
		params: &RepositoryIMockHardDeleteEmbeddingsByKbUIDParams{ctx, kbUID},
	}
	mmHardDeleteEmbeddingsByKbUID.expectations = append(mmHardDeleteEmbeddingsByKbUID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.HardDeleteEmbeddingsByKbUID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockHardDeleteEmbeddingsByKbUIDExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockHardDeleteEmbeddingsByKbUIDResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.HardDeleteEmbeddingsByKbUID should be invoked
func (mmHardDeleteEmbeddingsByKbUID *mRepositoryIMockHardDeleteEmbeddingsByKbUID) Times(n uint64) *mRepositoryIMockHardDeleteEmbeddingsByKbUID {
	if n == 0 {
		mmHardDeleteEmbeddingsByKbUID.mock.t.Fatalf("Times of RepositoryIMock.HardDeleteEmbeddingsByKbUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHardDeleteEmbeddingsByKbUID.expectedInvocations, n)
	return mmHardDeleteEmbeddingsByKbUID
}

func (mmHardDeleteEmbeddingsByKbUID *mRepositoryIMockHardDeleteEmbeddingsByKbUID) invocationsDone() bool {
	if len(mmHardDeleteEmbeddingsByKbUID.expectations) == 0 && mmHardDeleteEmbeddingsByKbUID.defaultExpectation == nil && mmHardDeleteEmbeddingsByKbUID.mock.funcHardDeleteEmbeddingsByKbUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKbUID.mock.afterHardDeleteEmbeddingsByKbUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKbUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HardDeleteEmbeddingsByKbUID implements repository.RepositoryI
func (mmHardDeleteEmbeddingsByKbUID *RepositoryIMock) HardDeleteEmbeddingsByKbUID(ctx context.Context, kbUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmHardDeleteEmbeddingsByKbUID.beforeHardDeleteEmbeddingsByKbUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmHardDeleteEmbeddingsByKbUID.afterHardDeleteEmbeddingsByKbUIDCounter, 1)

	if mmHardDeleteEmbeddingsByKbUID.inspectFuncHardDeleteEmbeddingsByKbUID != nil {
		mmHardDeleteEmbeddingsByKbUID.inspectFuncHardDeleteEmbeddingsByKbUID(ctx, kbUID)
	}

	mm_params := RepositoryIMockHardDeleteEmbeddingsByKbUIDParams{ctx, kbUID}

	// Record call args
	mmHardDeleteEmbeddingsByKbUID.HardDeleteEmbeddingsByKbUIDMock.mutex.Lock()
	mmHardDeleteEmbeddingsByKbUID.HardDeleteEmbeddingsByKbUIDMock.callArgs = append(mmHardDeleteEmbeddingsByKbUID.HardDeleteEmbeddingsByKbUIDMock.callArgs, &mm_params)
	mmHardDeleteEmbeddingsByKbUID.HardDeleteEmbeddingsByKbUIDMock.mutex.Unlock()

	for _, e := range mmHardDeleteEmbeddingsByKbUID.HardDeleteEmbeddingsByKbUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHardDeleteEmbeddingsByKbUID.HardDeleteEmbeddingsByKbUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHardDeleteEmbeddingsByKbUID.HardDeleteEmbeddingsByKbUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmHardDeleteEmbeddingsByKbUID.HardDeleteEmbeddingsByKbUIDMock.defaultExpectation.params
		mm_want_ptrs := mmHardDeleteEmbeddingsByKbUID.HardDeleteEmbeddingsByKbUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockHardDeleteEmbeddingsByKbUIDParams{ctx, kbUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHardDeleteEmbeddingsByKbUID.t.Errorf("RepositoryIMock.HardDeleteEmbeddingsByKbUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmHardDeleteEmbeddingsByKbUID.t.Errorf("RepositoryIMock.HardDeleteEmbeddingsByKbUID got unexpected parameter kbUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHardDeleteEmbeddingsByKbUID.t.Errorf("RepositoryIMock.HardDeleteEmbeddingsByKbUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHardDeleteEmbeddingsByKbUID.HardDeleteEmbeddingsByKbUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmHardDeleteEmbeddingsByKbUID.t.Fatal("No results are set for the RepositoryIMock.HardDeleteEmbeddingsByKbUID")
		}
		return (*mm_results).err
	}
	if mmHardDeleteEmbeddingsByKbUID.funcHardDeleteEmbeddingsByKbUID != nil {
		return mmHardDeleteEmbeddingsByKbUID.funcHardDeleteEmbeddingsByKbUID(ctx, kbUID)
	}
	mmHardDeleteEmbeddingsByKbUID.t.Fatalf("Unexpected call to RepositoryIMock.HardDeleteEmbeddingsByKbUID. %v %v", ctx, kbUID)
	return
}

// HardDeleteEmbeddingsByKbUIDAfterCounter returns a count of finished RepositoryIMock.HardDeleteEmbeddingsByKbUID invocations
func (mmHardDeleteEmbeddingsByKbUID *RepositoryIMock) HardDeleteEmbeddingsByKbUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKbUID.afterHardDeleteEmbeddingsByKbUIDCounter)
}

// HardDeleteEmbeddingsByKbUIDBeforeCounter returns a count of RepositoryIMock.HardDeleteEmbeddingsByKbUID invocations
func (mmHardDeleteEmbeddingsByKbUID *RepositoryIMock) HardDeleteEmbeddingsByKbUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKbUID.beforeHardDeleteEmbeddingsByKbUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.HardDeleteEmbeddingsByKbUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHardDeleteEmbeddingsByKbUID *mRepositoryIMockHardDeleteEmbeddingsByKbUID) Calls() []*RepositoryIMockHardDeleteEmbeddingsByKbUIDParams {
	mmHardDeleteEmbeddingsByKbUID.mutex.RLock()

	argCopy := make([]*RepositoryIMockHardDeleteEmbeddingsByKbUIDParams, len(mmHardDeleteEmbeddingsByKbUID.callArgs))
	copy(argCopy, mmHardDeleteEmbeddingsByKbUID.callArgs)

	mmHardDeleteEmbeddingsByKbUID.mutex.RUnlock()

	return argCopy
}

// MinimockHardDeleteEmbeddingsByKbUIDDone returns true if the count of the HardDeleteEmbeddingsByKbUID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockHardDeleteEmbeddingsByKbUIDDone() bool {
	for _, e := range m.HardDeleteEmbeddingsByKbUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HardDeleteEmbeddingsByKbUIDMock.invocationsDone()
}

// MinimockHardDeleteEmbeddingsByKbUIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockHardDeleteEmbeddingsByKbUIDInspect() {
	for _, e := range m.HardDeleteEmbeddingsByKbUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.HardDeleteEmbeddingsByKbUID with params: %#v", *e.params)
		}
	}

	afterHardDeleteEmbeddingsByKbUIDCounter := mm_atomic.LoadUint64(&m.afterHardDeleteEmbeddingsByKbUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HardDeleteEmbeddingsByKbUIDMock.defaultExpectation != nil && afterHardDeleteEmbeddingsByKbUIDCounter < 1 {
		if m.HardDeleteEmbeddingsByKbUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.HardDeleteEmbeddingsByKbUID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.HardDeleteEmbeddingsByKbUID with params: %#v", *m.HardDeleteEmbeddingsByKbUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHardDeleteEmbeddingsByKbUID != nil && afterHardDeleteEmbeddingsByKbUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.HardDeleteEmbeddingsByKbUID")
	}

	if !m.HardDeleteEmbeddingsByKbUIDMock.invocationsDone() && afterHardDeleteEmbeddingsByKbUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.HardDeleteEmbeddingsByKbUID but found %d calls",
			mm_atomic.LoadUint64(&m.HardDeleteEmbeddingsByKbUIDMock.expectedInvocations), afterHardDeleteEmbeddingsByKbUIDCounter)
	}
}

type mRepositoryIMockIncreaseKnowledgeBaseUsage struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockIncreaseKnowledgeBaseUsageExpectation
	expectations       []*RepositoryIMockIncreaseKnowledgeBaseUsageExpectation

	callArgs []*RepositoryIMockIncreaseKnowledgeBaseUsageParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockIncreaseKnowledgeBaseUsageExpectation specifies expectation struct of the RepositoryI.IncreaseKnowledgeBaseUsage
type RepositoryIMockIncreaseKnowledgeBaseUsageExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockIncreaseKnowledgeBaseUsageParams
	paramPtrs *RepositoryIMockIncreaseKnowledgeBaseUsageParamPtrs
	results   *RepositoryIMockIncreaseKnowledgeBaseUsageResults
	Counter   uint64
}

// RepositoryIMockIncreaseKnowledgeBaseUsageParams contains parameters of the RepositoryI.IncreaseKnowledgeBaseUsage
type RepositoryIMockIncreaseKnowledgeBaseUsageParams struct {
	ctx    context.Context
	tx     *gorm.DB
	kbUID  string
	amount int
}

// RepositoryIMockIncreaseKnowledgeBaseUsageParamPtrs contains pointers to parameters of the RepositoryI.IncreaseKnowledgeBaseUsage
type RepositoryIMockIncreaseKnowledgeBaseUsageParamPtrs struct {
	ctx    *context.Context
	tx     **gorm.DB
	kbUID  *string
	amount *int
}

// RepositoryIMockIncreaseKnowledgeBaseUsageResults contains results of the RepositoryI.IncreaseKnowledgeBaseUsage
type RepositoryIMockIncreaseKnowledgeBaseUsageResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.IncreaseKnowledgeBaseUsage
func (mmIncreaseKnowledgeBaseUsage *mRepositoryIMockIncreaseKnowledgeBaseUsage) Expect(ctx context.Context, tx *gorm.DB, kbUID string, amount int) *mRepositoryIMockIncreaseKnowledgeBaseUsage {
	if mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryIMock.IncreaseKnowledgeBaseUsage mock is already set by Set")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation = &RepositoryIMockIncreaseKnowledgeBaseUsageExpectation{}
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryIMock.IncreaseKnowledgeBaseUsage mock is already set by ExpectParams functions")
	}

	mmIncreaseKnowledgeBaseUsage.defaultExpectation.params = &RepositoryIMockIncreaseKnowledgeBaseUsageParams{ctx, tx, kbUID, amount}
	for _, e := range mmIncreaseKnowledgeBaseUsage.expectations {
		if minimock.Equal(e.params, mmIncreaseKnowledgeBaseUsage.defaultExpectation.params) {
			mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIncreaseKnowledgeBaseUsage.defaultExpectation.params)
		}
	}

	return mmIncreaseKnowledgeBaseUsage
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.IncreaseKnowledgeBaseUsage
func (mmIncreaseKnowledgeBaseUsage *mRepositoryIMockIncreaseKnowledgeBaseUsage) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockIncreaseKnowledgeBaseUsage {
	if mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryIMock.IncreaseKnowledgeBaseUsage mock is already set by Set")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation = &RepositoryIMockIncreaseKnowledgeBaseUsageExpectation{}
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.params != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryIMock.IncreaseKnowledgeBaseUsage mock is already set by Expect")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs = &RepositoryIMockIncreaseKnowledgeBaseUsageParamPtrs{}
	}
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs.ctx = &ctx

	return mmIncreaseKnowledgeBaseUsage
}

// ExpectTxParam2 sets up expected param tx for RepositoryI.IncreaseKnowledgeBaseUsage
func (mmIncreaseKnowledgeBaseUsage *mRepositoryIMockIncreaseKnowledgeBaseUsage) ExpectTxParam2(tx *gorm.DB) *mRepositoryIMockIncreaseKnowledgeBaseUsage {
	if mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryIMock.IncreaseKnowledgeBaseUsage mock is already set by Set")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation = &RepositoryIMockIncreaseKnowledgeBaseUsageExpectation{}
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.params != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryIMock.IncreaseKnowledgeBaseUsage mock is already set by Expect")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs = &RepositoryIMockIncreaseKnowledgeBaseUsageParamPtrs{}
	}
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs.tx = &tx

	return mmIncreaseKnowledgeBaseUsage
}

// ExpectKbUIDParam3 sets up expected param kbUID for RepositoryI.IncreaseKnowledgeBaseUsage
func (mmIncreaseKnowledgeBaseUsage *mRepositoryIMockIncreaseKnowledgeBaseUsage) ExpectKbUIDParam3(kbUID string) *mRepositoryIMockIncreaseKnowledgeBaseUsage {
	if mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryIMock.IncreaseKnowledgeBaseUsage mock is already set by Set")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation = &RepositoryIMockIncreaseKnowledgeBaseUsageExpectation{}
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.params != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryIMock.IncreaseKnowledgeBaseUsage mock is already set by Expect")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs = &RepositoryIMockIncreaseKnowledgeBaseUsageParamPtrs{}
	}
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs.kbUID = &kbUID

	return mmIncreaseKnowledgeBaseUsage
}

// ExpectAmountParam4 sets up expected param amount for RepositoryI.IncreaseKnowledgeBaseUsage
func (mmIncreaseKnowledgeBaseUsage *mRepositoryIMockIncreaseKnowledgeBaseUsage) ExpectAmountParam4(amount int) *mRepositoryIMockIncreaseKnowledgeBaseUsage {
	if mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryIMock.IncreaseKnowledgeBaseUsage mock is already set by Set")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation = &RepositoryIMockIncreaseKnowledgeBaseUsageExpectation{}
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.params != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryIMock.IncreaseKnowledgeBaseUsage mock is already set by Expect")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs = &RepositoryIMockIncreaseKnowledgeBaseUsageParamPtrs{}
	}
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs.amount = &amount

	return mmIncreaseKnowledgeBaseUsage
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.IncreaseKnowledgeBaseUsage
func (mmIncreaseKnowledgeBaseUsage *mRepositoryIMockIncreaseKnowledgeBaseUsage) Inspect(f func(ctx context.Context, tx *gorm.DB, kbUID string, amount int)) *mRepositoryIMockIncreaseKnowledgeBaseUsage {
	if mmIncreaseKnowledgeBaseUsage.mock.inspectFuncIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.IncreaseKnowledgeBaseUsage")
	}

	mmIncreaseKnowledgeBaseUsage.mock.inspectFuncIncreaseKnowledgeBaseUsage = f

	return mmIncreaseKnowledgeBaseUsage
}

// Return sets up results that will be returned by RepositoryI.IncreaseKnowledgeBaseUsage
func (mmIncreaseKnowledgeBaseUsage *mRepositoryIMockIncreaseKnowledgeBaseUsage) Return(err error) *RepositoryIMock {
	if mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryIMock.IncreaseKnowledgeBaseUsage mock is already set by Set")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation = &RepositoryIMockIncreaseKnowledgeBaseUsageExpectation{mock: mmIncreaseKnowledgeBaseUsage.mock}
	}
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.results = &RepositoryIMockIncreaseKnowledgeBaseUsageResults{err}
	return mmIncreaseKnowledgeBaseUsage.mock
}

// Set uses given function f to mock the RepositoryI.IncreaseKnowledgeBaseUsage method
func (mmIncreaseKnowledgeBaseUsage *mRepositoryIMockIncreaseKnowledgeBaseUsage) Set(f func(ctx context.Context, tx *gorm.DB, kbUID string, amount int) (err error)) *RepositoryIMock {
	if mmIncreaseKnowledgeBaseUsage.defaultExpectation != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("Default expectation is already set for the RepositoryI.IncreaseKnowledgeBaseUsage method")
	}

	if len(mmIncreaseKnowledgeBaseUsage.expectations) > 0 {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("Some expectations are already set for the RepositoryI.IncreaseKnowledgeBaseUsage method")
	}

	mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage = f
	return mmIncreaseKnowledgeBaseUsage.mock
}

// When sets expectation for the RepositoryI.IncreaseKnowledgeBaseUsage which will trigger the result defined by the following
// Then helper
func (mmIncreaseKnowledgeBaseUsage *mRepositoryIMockIncreaseKnowledgeBaseUsage) When(ctx context.Context, tx *gorm.DB, kbUID string, amount int) *RepositoryIMockIncreaseKnowledgeBaseUsageExpectation {
	if mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryIMock.IncreaseKnowledgeBaseUsage mock is already set by Set")
	}

	expectation := &RepositoryIMockIncreaseKnowledgeBaseUsageExpectation{
		mock:   mmIncreaseKnowledgeBaseUsage.mock,
		params: &RepositoryIMockIncreaseKnowledgeBaseUsageParams{ctx, tx, kbUID, amount},
	}
	mmIncreaseKnowledgeBaseUsage.expectations = append(mmIncreaseKnowledgeBaseUsage.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.IncreaseKnowledgeBaseUsage return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockIncreaseKnowledgeBaseUsageExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockIncreaseKnowledgeBaseUsageResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.IncreaseKnowledgeBaseUsage should be invoked
func (mmIncreaseKnowledgeBaseUsage *mRepositoryIMockIncreaseKnowledgeBaseUsage) Times(n uint64) *mRepositoryIMockIncreaseKnowledgeBaseUsage {
	if n == 0 {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("Times of RepositoryIMock.IncreaseKnowledgeBaseUsage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIncreaseKnowledgeBaseUsage.expectedInvocations, n)
	return mmIncreaseKnowledgeBaseUsage
}

func (mmIncreaseKnowledgeBaseUsage *mRepositoryIMockIncreaseKnowledgeBaseUsage) invocationsDone() bool {
	if len(mmIncreaseKnowledgeBaseUsage.expectations) == 0 && mmIncreaseKnowledgeBaseUsage.defaultExpectation == nil && mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIncreaseKnowledgeBaseUsage.mock.afterIncreaseKnowledgeBaseUsageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIncreaseKnowledgeBaseUsage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IncreaseKnowledgeBaseUsage implements repository.RepositoryI
func (mmIncreaseKnowledgeBaseUsage *RepositoryIMock) IncreaseKnowledgeBaseUsage(ctx context.Context, tx *gorm.DB, kbUID string, amount int) (err error) {
	mm_atomic.AddUint64(&mmIncreaseKnowledgeBaseUsage.beforeIncreaseKnowledgeBaseUsageCounter, 1)
	defer mm_atomic.AddUint64(&mmIncreaseKnowledgeBaseUsage.afterIncreaseKnowledgeBaseUsageCounter, 1)

	if mmIncreaseKnowledgeBaseUsage.inspectFuncIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.inspectFuncIncreaseKnowledgeBaseUsage(ctx, tx, kbUID, amount)
	}

	mm_params := RepositoryIMockIncreaseKnowledgeBaseUsageParams{ctx, tx, kbUID, amount}

	// Record call args
	mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.mutex.Lock()
	mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.callArgs = append(mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.callArgs, &mm_params)
	mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.mutex.Unlock()

	for _, e := range mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation.Counter, 1)
		mm_want := mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation.params
		mm_want_ptrs := mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockIncreaseKnowledgeBaseUsageParams{ctx, tx, kbUID, amount}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmIncreaseKnowledgeBaseUsage.t.Errorf("RepositoryIMock.IncreaseKnowledgeBaseUsage got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tx != nil && !minimock.Equal(*mm_want_ptrs.tx, mm_got.tx) {
				mmIncreaseKnowledgeBaseUsage.t.Errorf("RepositoryIMock.IncreaseKnowledgeBaseUsage got unexpected parameter tx, want: %#v, got: %#v%s\n", *mm_want_ptrs.tx, mm_got.tx, minimock.Diff(*mm_want_ptrs.tx, mm_got.tx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmIncreaseKnowledgeBaseUsage.t.Errorf("RepositoryIMock.IncreaseKnowledgeBaseUsage got unexpected parameter kbUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.amount != nil && !minimock.Equal(*mm_want_ptrs.amount, mm_got.amount) {
				mmIncreaseKnowledgeBaseUsage.t.Errorf("RepositoryIMock.IncreaseKnowledgeBaseUsage got unexpected parameter amount, want: %#v, got: %#v%s\n", *mm_want_ptrs.amount, mm_got.amount, minimock.Diff(*mm_want_ptrs.amount, mm_got.amount))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIncreaseKnowledgeBaseUsage.t.Errorf("RepositoryIMock.IncreaseKnowledgeBaseUsage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation.results
		if mm_results == nil {
			mmIncreaseKnowledgeBaseUsage.t.Fatal("No results are set for the RepositoryIMock.IncreaseKnowledgeBaseUsage")
		}
		return (*mm_results).err
	}
	if mmIncreaseKnowledgeBaseUsage.funcIncreaseKnowledgeBaseUsage != nil {
		return mmIncreaseKnowledgeBaseUsage.funcIncreaseKnowledgeBaseUsage(ctx, tx, kbUID, amount)
	}
	mmIncreaseKnowledgeBaseUsage.t.Fatalf("Unexpected call to RepositoryIMock.IncreaseKnowledgeBaseUsage. %v %v %v %v", ctx, tx, kbUID, amount)
	return
}

// IncreaseKnowledgeBaseUsageAfterCounter returns a count of finished RepositoryIMock.IncreaseKnowledgeBaseUsage invocations
func (mmIncreaseKnowledgeBaseUsage *RepositoryIMock) IncreaseKnowledgeBaseUsageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIncreaseKnowledgeBaseUsage.afterIncreaseKnowledgeBaseUsageCounter)
}

// IncreaseKnowledgeBaseUsageBeforeCounter returns a count of RepositoryIMock.IncreaseKnowledgeBaseUsage invocations
func (mmIncreaseKnowledgeBaseUsage *RepositoryIMock) IncreaseKnowledgeBaseUsageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIncreaseKnowledgeBaseUsage.beforeIncreaseKnowledgeBaseUsageCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.IncreaseKnowledgeBaseUsage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIncreaseKnowledgeBaseUsage *mRepositoryIMockIncreaseKnowledgeBaseUsage) Calls() []*RepositoryIMockIncreaseKnowledgeBaseUsageParams {
	mmIncreaseKnowledgeBaseUsage.mutex.RLock()

	argCopy := make([]*RepositoryIMockIncreaseKnowledgeBaseUsageParams, len(mmIncreaseKnowledgeBaseUsage.callArgs))
	copy(argCopy, mmIncreaseKnowledgeBaseUsage.callArgs)

	mmIncreaseKnowledgeBaseUsage.mutex.RUnlock()

	return argCopy
}

// MinimockIncreaseKnowledgeBaseUsageDone returns true if the count of the IncreaseKnowledgeBaseUsage invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockIncreaseKnowledgeBaseUsageDone() bool {
	for _, e := range m.IncreaseKnowledgeBaseUsageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IncreaseKnowledgeBaseUsageMock.invocationsDone()
}

// MinimockIncreaseKnowledgeBaseUsageInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockIncreaseKnowledgeBaseUsageInspect() {
	for _, e := range m.IncreaseKnowledgeBaseUsageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.IncreaseKnowledgeBaseUsage with params: %#v", *e.params)
		}
	}

	afterIncreaseKnowledgeBaseUsageCounter := mm_atomic.LoadUint64(&m.afterIncreaseKnowledgeBaseUsageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IncreaseKnowledgeBaseUsageMock.defaultExpectation != nil && afterIncreaseKnowledgeBaseUsageCounter < 1 {
		if m.IncreaseKnowledgeBaseUsageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.IncreaseKnowledgeBaseUsage")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.IncreaseKnowledgeBaseUsage with params: %#v", *m.IncreaseKnowledgeBaseUsageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIncreaseKnowledgeBaseUsage != nil && afterIncreaseKnowledgeBaseUsageCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.IncreaseKnowledgeBaseUsage")
	}

	if !m.IncreaseKnowledgeBaseUsageMock.invocationsDone() && afterIncreaseKnowledgeBaseUsageCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.IncreaseKnowledgeBaseUsage but found %d calls",
			mm_atomic.LoadUint64(&m.IncreaseKnowledgeBaseUsageMock.expectedInvocations), afterIncreaseKnowledgeBaseUsageCounter)
	}
}

type mRepositoryIMockKnowledgeBaseFileTableName struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockKnowledgeBaseFileTableNameExpectation
	expectations       []*RepositoryIMockKnowledgeBaseFileTableNameExpectation

	expectedInvocations uint64
}

// RepositoryIMockKnowledgeBaseFileTableNameExpectation specifies expectation struct of the RepositoryI.KnowledgeBaseFileTableName
type RepositoryIMockKnowledgeBaseFileTableNameExpectation struct {
	mock *RepositoryIMock

	results *RepositoryIMockKnowledgeBaseFileTableNameResults
	Counter uint64
}

// RepositoryIMockKnowledgeBaseFileTableNameResults contains results of the RepositoryI.KnowledgeBaseFileTableName
type RepositoryIMockKnowledgeBaseFileTableNameResults struct {
	s1 string
}

// Expect sets up expected params for RepositoryI.KnowledgeBaseFileTableName
func (mmKnowledgeBaseFileTableName *mRepositoryIMockKnowledgeBaseFileTableName) Expect() *mRepositoryIMockKnowledgeBaseFileTableName {
	if mmKnowledgeBaseFileTableName.mock.funcKnowledgeBaseFileTableName != nil {
		mmKnowledgeBaseFileTableName.mock.t.Fatalf("RepositoryIMock.KnowledgeBaseFileTableName mock is already set by Set")
	}

	if mmKnowledgeBaseFileTableName.defaultExpectation == nil {
		mmKnowledgeBaseFileTableName.defaultExpectation = &RepositoryIMockKnowledgeBaseFileTableNameExpectation{}
	}

	return mmKnowledgeBaseFileTableName
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.KnowledgeBaseFileTableName
func (mmKnowledgeBaseFileTableName *mRepositoryIMockKnowledgeBaseFileTableName) Inspect(f func()) *mRepositoryIMockKnowledgeBaseFileTableName {
	if mmKnowledgeBaseFileTableName.mock.inspectFuncKnowledgeBaseFileTableName != nil {
		mmKnowledgeBaseFileTableName.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.KnowledgeBaseFileTableName")
	}

	mmKnowledgeBaseFileTableName.mock.inspectFuncKnowledgeBaseFileTableName = f

	return mmKnowledgeBaseFileTableName
}

// Return sets up results that will be returned by RepositoryI.KnowledgeBaseFileTableName
func (mmKnowledgeBaseFileTableName *mRepositoryIMockKnowledgeBaseFileTableName) Return(s1 string) *RepositoryIMock {
	if mmKnowledgeBaseFileTableName.mock.funcKnowledgeBaseFileTableName != nil {
		mmKnowledgeBaseFileTableName.mock.t.Fatalf("RepositoryIMock.KnowledgeBaseFileTableName mock is already set by Set")
	}

	if mmKnowledgeBaseFileTableName.defaultExpectation == nil {
		mmKnowledgeBaseFileTableName.defaultExpectation = &RepositoryIMockKnowledgeBaseFileTableNameExpectation{mock: mmKnowledgeBaseFileTableName.mock}
	}
	mmKnowledgeBaseFileTableName.defaultExpectation.results = &RepositoryIMockKnowledgeBaseFileTableNameResults{s1}
	return mmKnowledgeBaseFileTableName.mock
}

// Set uses given function f to mock the RepositoryI.KnowledgeBaseFileTableName method
func (mmKnowledgeBaseFileTableName *mRepositoryIMockKnowledgeBaseFileTableName) Set(f func() (s1 string)) *RepositoryIMock {
	if mmKnowledgeBaseFileTableName.defaultExpectation != nil {
		mmKnowledgeBaseFileTableName.mock.t.Fatalf("Default expectation is already set for the RepositoryI.KnowledgeBaseFileTableName method")
	}

	if len(mmKnowledgeBaseFileTableName.expectations) > 0 {
		mmKnowledgeBaseFileTableName.mock.t.Fatalf("Some expectations are already set for the RepositoryI.KnowledgeBaseFileTableName method")
	}

	mmKnowledgeBaseFileTableName.mock.funcKnowledgeBaseFileTableName = f
	return mmKnowledgeBaseFileTableName.mock
}

// Times sets number of times RepositoryI.KnowledgeBaseFileTableName should be invoked
func (mmKnowledgeBaseFileTableName *mRepositoryIMockKnowledgeBaseFileTableName) Times(n uint64) *mRepositoryIMockKnowledgeBaseFileTableName {
	if n == 0 {
		mmKnowledgeBaseFileTableName.mock.t.Fatalf("Times of RepositoryIMock.KnowledgeBaseFileTableName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmKnowledgeBaseFileTableName.expectedInvocations, n)
	return mmKnowledgeBaseFileTableName
}

func (mmKnowledgeBaseFileTableName *mRepositoryIMockKnowledgeBaseFileTableName) invocationsDone() bool {
	if len(mmKnowledgeBaseFileTableName.expectations) == 0 && mmKnowledgeBaseFileTableName.defaultExpectation == nil && mmKnowledgeBaseFileTableName.mock.funcKnowledgeBaseFileTableName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmKnowledgeBaseFileTableName.mock.afterKnowledgeBaseFileTableNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmKnowledgeBaseFileTableName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// KnowledgeBaseFileTableName implements repository.RepositoryI
func (mmKnowledgeBaseFileTableName *RepositoryIMock) KnowledgeBaseFileTableName() (s1 string) {
	mm_atomic.AddUint64(&mmKnowledgeBaseFileTableName.beforeKnowledgeBaseFileTableNameCounter, 1)
	defer mm_atomic.AddUint64(&mmKnowledgeBaseFileTableName.afterKnowledgeBaseFileTableNameCounter, 1)

	if mmKnowledgeBaseFileTableName.inspectFuncKnowledgeBaseFileTableName != nil {
		mmKnowledgeBaseFileTableName.inspectFuncKnowledgeBaseFileTableName()
	}

	if mmKnowledgeBaseFileTableName.KnowledgeBaseFileTableNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmKnowledgeBaseFileTableName.KnowledgeBaseFileTableNameMock.defaultExpectation.Counter, 1)

		mm_results := mmKnowledgeBaseFileTableName.KnowledgeBaseFileTableNameMock.defaultExpectation.results
		if mm_results == nil {
			mmKnowledgeBaseFileTableName.t.Fatal("No results are set for the RepositoryIMock.KnowledgeBaseFileTableName")
		}
		return (*mm_results).s1
	}
	if mmKnowledgeBaseFileTableName.funcKnowledgeBaseFileTableName != nil {
		return mmKnowledgeBaseFileTableName.funcKnowledgeBaseFileTableName()
	}
	mmKnowledgeBaseFileTableName.t.Fatalf("Unexpected call to RepositoryIMock.KnowledgeBaseFileTableName.")
	return
}

// KnowledgeBaseFileTableNameAfterCounter returns a count of finished RepositoryIMock.KnowledgeBaseFileTableName invocations
func (mmKnowledgeBaseFileTableName *RepositoryIMock) KnowledgeBaseFileTableNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmKnowledgeBaseFileTableName.afterKnowledgeBaseFileTableNameCounter)
}

// KnowledgeBaseFileTableNameBeforeCounter returns a count of RepositoryIMock.KnowledgeBaseFileTableName invocations
func (mmKnowledgeBaseFileTableName *RepositoryIMock) KnowledgeBaseFileTableNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmKnowledgeBaseFileTableName.beforeKnowledgeBaseFileTableNameCounter)
}

// MinimockKnowledgeBaseFileTableNameDone returns true if the count of the KnowledgeBaseFileTableName invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockKnowledgeBaseFileTableNameDone() bool {
	for _, e := range m.KnowledgeBaseFileTableNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.KnowledgeBaseFileTableNameMock.invocationsDone()
}

// MinimockKnowledgeBaseFileTableNameInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockKnowledgeBaseFileTableNameInspect() {
	for _, e := range m.KnowledgeBaseFileTableNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryIMock.KnowledgeBaseFileTableName")
		}
	}

	afterKnowledgeBaseFileTableNameCounter := mm_atomic.LoadUint64(&m.afterKnowledgeBaseFileTableNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.KnowledgeBaseFileTableNameMock.defaultExpectation != nil && afterKnowledgeBaseFileTableNameCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.KnowledgeBaseFileTableName")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcKnowledgeBaseFileTableName != nil && afterKnowledgeBaseFileTableNameCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.KnowledgeBaseFileTableName")
	}

	if !m.KnowledgeBaseFileTableNameMock.invocationsDone() && afterKnowledgeBaseFileTableNameCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.KnowledgeBaseFileTableName but found %d calls",
			mm_atomic.LoadUint64(&m.KnowledgeBaseFileTableNameMock.expectedInvocations), afterKnowledgeBaseFileTableNameCounter)
	}
}

type mRepositoryIMockListChunksByKbFileUID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockListChunksByKbFileUIDExpectation
	expectations       []*RepositoryIMockListChunksByKbFileUIDExpectation

	callArgs []*RepositoryIMockListChunksByKbFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockListChunksByKbFileUIDExpectation specifies expectation struct of the RepositoryI.ListChunksByKbFileUID
type RepositoryIMockListChunksByKbFileUIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockListChunksByKbFileUIDParams
	paramPtrs *RepositoryIMockListChunksByKbFileUIDParamPtrs
	results   *RepositoryIMockListChunksByKbFileUIDResults
	Counter   uint64
}

// RepositoryIMockListChunksByKbFileUIDParams contains parameters of the RepositoryI.ListChunksByKbFileUID
type RepositoryIMockListChunksByKbFileUIDParams struct {
	ctx       context.Context
	kbFileUID uuid.UUID
}

// RepositoryIMockListChunksByKbFileUIDParamPtrs contains pointers to parameters of the RepositoryI.ListChunksByKbFileUID
type RepositoryIMockListChunksByKbFileUIDParamPtrs struct {
	ctx       *context.Context
	kbFileUID *uuid.UUID
}

// RepositoryIMockListChunksByKbFileUIDResults contains results of the RepositoryI.ListChunksByKbFileUID
type RepositoryIMockListChunksByKbFileUIDResults struct {
	ta1 []mm_repository.TextChunk
	err error
}

// Expect sets up expected params for RepositoryI.ListChunksByKbFileUID
func (mmListChunksByKbFileUID *mRepositoryIMockListChunksByKbFileUID) Expect(ctx context.Context, kbFileUID uuid.UUID) *mRepositoryIMockListChunksByKbFileUID {
	if mmListChunksByKbFileUID.mock.funcListChunksByKbFileUID != nil {
		mmListChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListChunksByKbFileUID mock is already set by Set")
	}

	if mmListChunksByKbFileUID.defaultExpectation == nil {
		mmListChunksByKbFileUID.defaultExpectation = &RepositoryIMockListChunksByKbFileUIDExpectation{}
	}

	if mmListChunksByKbFileUID.defaultExpectation.paramPtrs != nil {
		mmListChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListChunksByKbFileUID mock is already set by ExpectParams functions")
	}

	mmListChunksByKbFileUID.defaultExpectation.params = &RepositoryIMockListChunksByKbFileUIDParams{ctx, kbFileUID}
	for _, e := range mmListChunksByKbFileUID.expectations {
		if minimock.Equal(e.params, mmListChunksByKbFileUID.defaultExpectation.params) {
			mmListChunksByKbFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListChunksByKbFileUID.defaultExpectation.params)
		}
	}

	return mmListChunksByKbFileUID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.ListChunksByKbFileUID
func (mmListChunksByKbFileUID *mRepositoryIMockListChunksByKbFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockListChunksByKbFileUID {
	if mmListChunksByKbFileUID.mock.funcListChunksByKbFileUID != nil {
		mmListChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListChunksByKbFileUID mock is already set by Set")
	}

	if mmListChunksByKbFileUID.defaultExpectation == nil {
		mmListChunksByKbFileUID.defaultExpectation = &RepositoryIMockListChunksByKbFileUIDExpectation{}
	}

	if mmListChunksByKbFileUID.defaultExpectation.params != nil {
		mmListChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListChunksByKbFileUID mock is already set by Expect")
	}

	if mmListChunksByKbFileUID.defaultExpectation.paramPtrs == nil {
		mmListChunksByKbFileUID.defaultExpectation.paramPtrs = &RepositoryIMockListChunksByKbFileUIDParamPtrs{}
	}
	mmListChunksByKbFileUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListChunksByKbFileUID
}

// ExpectKbFileUIDParam2 sets up expected param kbFileUID for RepositoryI.ListChunksByKbFileUID
func (mmListChunksByKbFileUID *mRepositoryIMockListChunksByKbFileUID) ExpectKbFileUIDParam2(kbFileUID uuid.UUID) *mRepositoryIMockListChunksByKbFileUID {
	if mmListChunksByKbFileUID.mock.funcListChunksByKbFileUID != nil {
		mmListChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListChunksByKbFileUID mock is already set by Set")
	}

	if mmListChunksByKbFileUID.defaultExpectation == nil {
		mmListChunksByKbFileUID.defaultExpectation = &RepositoryIMockListChunksByKbFileUIDExpectation{}
	}

	if mmListChunksByKbFileUID.defaultExpectation.params != nil {
		mmListChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListChunksByKbFileUID mock is already set by Expect")
	}

	if mmListChunksByKbFileUID.defaultExpectation.paramPtrs == nil {
		mmListChunksByKbFileUID.defaultExpectation.paramPtrs = &RepositoryIMockListChunksByKbFileUIDParamPtrs{}
	}
	mmListChunksByKbFileUID.defaultExpectation.paramPtrs.kbFileUID = &kbFileUID

	return mmListChunksByKbFileUID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.ListChunksByKbFileUID
func (mmListChunksByKbFileUID *mRepositoryIMockListChunksByKbFileUID) Inspect(f func(ctx context.Context, kbFileUID uuid.UUID)) *mRepositoryIMockListChunksByKbFileUID {
	if mmListChunksByKbFileUID.mock.inspectFuncListChunksByKbFileUID != nil {
		mmListChunksByKbFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.ListChunksByKbFileUID")
	}

	mmListChunksByKbFileUID.mock.inspectFuncListChunksByKbFileUID = f

	return mmListChunksByKbFileUID
}

// Return sets up results that will be returned by RepositoryI.ListChunksByKbFileUID
func (mmListChunksByKbFileUID *mRepositoryIMockListChunksByKbFileUID) Return(ta1 []mm_repository.TextChunk, err error) *RepositoryIMock {
	if mmListChunksByKbFileUID.mock.funcListChunksByKbFileUID != nil {
		mmListChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListChunksByKbFileUID mock is already set by Set")
	}

	if mmListChunksByKbFileUID.defaultExpectation == nil {
		mmListChunksByKbFileUID.defaultExpectation = &RepositoryIMockListChunksByKbFileUIDExpectation{mock: mmListChunksByKbFileUID.mock}
	}
	mmListChunksByKbFileUID.defaultExpectation.results = &RepositoryIMockListChunksByKbFileUIDResults{ta1, err}
	return mmListChunksByKbFileUID.mock
}

// Set uses given function f to mock the RepositoryI.ListChunksByKbFileUID method
func (mmListChunksByKbFileUID *mRepositoryIMockListChunksByKbFileUID) Set(f func(ctx context.Context, kbFileUID uuid.UUID) (ta1 []mm_repository.TextChunk, err error)) *RepositoryIMock {
	if mmListChunksByKbFileUID.defaultExpectation != nil {
		mmListChunksByKbFileUID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.ListChunksByKbFileUID method")
	}

	if len(mmListChunksByKbFileUID.expectations) > 0 {
		mmListChunksByKbFileUID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.ListChunksByKbFileUID method")
	}

	mmListChunksByKbFileUID.mock.funcListChunksByKbFileUID = f
	return mmListChunksByKbFileUID.mock
}

// When sets expectation for the RepositoryI.ListChunksByKbFileUID which will trigger the result defined by the following
// Then helper
func (mmListChunksByKbFileUID *mRepositoryIMockListChunksByKbFileUID) When(ctx context.Context, kbFileUID uuid.UUID) *RepositoryIMockListChunksByKbFileUIDExpectation {
	if mmListChunksByKbFileUID.mock.funcListChunksByKbFileUID != nil {
		mmListChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListChunksByKbFileUID mock is already set by Set")
	}

	expectation := &RepositoryIMockListChunksByKbFileUIDExpectation{
		mock:   mmListChunksByKbFileUID.mock,
		params: &RepositoryIMockListChunksByKbFileUIDParams{ctx, kbFileUID},
	}
	mmListChunksByKbFileUID.expectations = append(mmListChunksByKbFileUID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.ListChunksByKbFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockListChunksByKbFileUIDExpectation) Then(ta1 []mm_repository.TextChunk, err error) *RepositoryIMock {
	e.results = &RepositoryIMockListChunksByKbFileUIDResults{ta1, err}
	return e.mock
}

// Times sets number of times RepositoryI.ListChunksByKbFileUID should be invoked
func (mmListChunksByKbFileUID *mRepositoryIMockListChunksByKbFileUID) Times(n uint64) *mRepositoryIMockListChunksByKbFileUID {
	if n == 0 {
		mmListChunksByKbFileUID.mock.t.Fatalf("Times of RepositoryIMock.ListChunksByKbFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListChunksByKbFileUID.expectedInvocations, n)
	return mmListChunksByKbFileUID
}

func (mmListChunksByKbFileUID *mRepositoryIMockListChunksByKbFileUID) invocationsDone() bool {
	if len(mmListChunksByKbFileUID.expectations) == 0 && mmListChunksByKbFileUID.defaultExpectation == nil && mmListChunksByKbFileUID.mock.funcListChunksByKbFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListChunksByKbFileUID.mock.afterListChunksByKbFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListChunksByKbFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListChunksByKbFileUID implements repository.RepositoryI
func (mmListChunksByKbFileUID *RepositoryIMock) ListChunksByKbFileUID(ctx context.Context, kbFileUID uuid.UUID) (ta1 []mm_repository.TextChunk, err error) {
	mm_atomic.AddUint64(&mmListChunksByKbFileUID.beforeListChunksByKbFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmListChunksByKbFileUID.afterListChunksByKbFileUIDCounter, 1)

	if mmListChunksByKbFileUID.inspectFuncListChunksByKbFileUID != nil {
		mmListChunksByKbFileUID.inspectFuncListChunksByKbFileUID(ctx, kbFileUID)
	}

	mm_params := RepositoryIMockListChunksByKbFileUIDParams{ctx, kbFileUID}

	// Record call args
	mmListChunksByKbFileUID.ListChunksByKbFileUIDMock.mutex.Lock()
	mmListChunksByKbFileUID.ListChunksByKbFileUIDMock.callArgs = append(mmListChunksByKbFileUID.ListChunksByKbFileUIDMock.callArgs, &mm_params)
	mmListChunksByKbFileUID.ListChunksByKbFileUIDMock.mutex.Unlock()

	for _, e := range mmListChunksByKbFileUID.ListChunksByKbFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ta1, e.results.err
		}
	}

	if mmListChunksByKbFileUID.ListChunksByKbFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListChunksByKbFileUID.ListChunksByKbFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmListChunksByKbFileUID.ListChunksByKbFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmListChunksByKbFileUID.ListChunksByKbFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockListChunksByKbFileUIDParams{ctx, kbFileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListChunksByKbFileUID.t.Errorf("RepositoryIMock.ListChunksByKbFileUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbFileUID != nil && !minimock.Equal(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID) {
				mmListChunksByKbFileUID.t.Errorf("RepositoryIMock.ListChunksByKbFileUID got unexpected parameter kbFileUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbFileUID, mm_got.kbFileUID, minimock.Diff(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListChunksByKbFileUID.t.Errorf("RepositoryIMock.ListChunksByKbFileUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListChunksByKbFileUID.ListChunksByKbFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmListChunksByKbFileUID.t.Fatal("No results are set for the RepositoryIMock.ListChunksByKbFileUID")
		}
		return (*mm_results).ta1, (*mm_results).err
	}
	if mmListChunksByKbFileUID.funcListChunksByKbFileUID != nil {
		return mmListChunksByKbFileUID.funcListChunksByKbFileUID(ctx, kbFileUID)
	}
	mmListChunksByKbFileUID.t.Fatalf("Unexpected call to RepositoryIMock.ListChunksByKbFileUID. %v %v", ctx, kbFileUID)
	return
}

// ListChunksByKbFileUIDAfterCounter returns a count of finished RepositoryIMock.ListChunksByKbFileUID invocations
func (mmListChunksByKbFileUID *RepositoryIMock) ListChunksByKbFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListChunksByKbFileUID.afterListChunksByKbFileUIDCounter)
}

// ListChunksByKbFileUIDBeforeCounter returns a count of RepositoryIMock.ListChunksByKbFileUID invocations
func (mmListChunksByKbFileUID *RepositoryIMock) ListChunksByKbFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListChunksByKbFileUID.beforeListChunksByKbFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.ListChunksByKbFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListChunksByKbFileUID *mRepositoryIMockListChunksByKbFileUID) Calls() []*RepositoryIMockListChunksByKbFileUIDParams {
	mmListChunksByKbFileUID.mutex.RLock()

	argCopy := make([]*RepositoryIMockListChunksByKbFileUIDParams, len(mmListChunksByKbFileUID.callArgs))
	copy(argCopy, mmListChunksByKbFileUID.callArgs)

	mmListChunksByKbFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockListChunksByKbFileUIDDone returns true if the count of the ListChunksByKbFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockListChunksByKbFileUIDDone() bool {
	for _, e := range m.ListChunksByKbFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListChunksByKbFileUIDMock.invocationsDone()
}

// MinimockListChunksByKbFileUIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockListChunksByKbFileUIDInspect() {
	for _, e := range m.ListChunksByKbFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.ListChunksByKbFileUID with params: %#v", *e.params)
		}
	}

	afterListChunksByKbFileUIDCounter := mm_atomic.LoadUint64(&m.afterListChunksByKbFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListChunksByKbFileUIDMock.defaultExpectation != nil && afterListChunksByKbFileUIDCounter < 1 {
		if m.ListChunksByKbFileUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.ListChunksByKbFileUID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.ListChunksByKbFileUID with params: %#v", *m.ListChunksByKbFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListChunksByKbFileUID != nil && afterListChunksByKbFileUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.ListChunksByKbFileUID")
	}

	if !m.ListChunksByKbFileUIDMock.invocationsDone() && afterListChunksByKbFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.ListChunksByKbFileUID but found %d calls",
			mm_atomic.LoadUint64(&m.ListChunksByKbFileUIDMock.expectedInvocations), afterListChunksByKbFileUIDCounter)
	}
}

type mRepositoryIMockListConversations struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockListConversationsExpectation
	expectations       []*RepositoryIMockListConversationsExpectation

	callArgs []*RepositoryIMockListConversationsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockListConversationsExpectation specifies expectation struct of the RepositoryI.ListConversations
type RepositoryIMockListConversationsExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockListConversationsParams
	paramPtrs *RepositoryIMockListConversationsParamPtrs
	results   *RepositoryIMockListConversationsResults
	Counter   uint64
}

// RepositoryIMockListConversationsParams contains parameters of the RepositoryI.ListConversations
type RepositoryIMockListConversationsParams struct {
	ctx           context.Context
	namespaceUID  uuid.UUID
	catalogUID    uuid.UUID
	pageSize      int32
	nextPageToken string
}

// RepositoryIMockListConversationsParamPtrs contains pointers to parameters of the RepositoryI.ListConversations
type RepositoryIMockListConversationsParamPtrs struct {
	ctx           *context.Context
	namespaceUID  *uuid.UUID
	catalogUID    *uuid.UUID
	pageSize      *int32
	nextPageToken *string
}

// RepositoryIMockListConversationsResults contains results of the RepositoryI.ListConversations
type RepositoryIMockListConversationsResults struct {
	cpa1 []*mm_repository.Conversation
	i1   int
	s1   string
	err  error
}

// Expect sets up expected params for RepositoryI.ListConversations
func (mmListConversations *mRepositoryIMockListConversations) Expect(ctx context.Context, namespaceUID uuid.UUID, catalogUID uuid.UUID, pageSize int32, nextPageToken string) *mRepositoryIMockListConversations {
	if mmListConversations.mock.funcListConversations != nil {
		mmListConversations.mock.t.Fatalf("RepositoryIMock.ListConversations mock is already set by Set")
	}

	if mmListConversations.defaultExpectation == nil {
		mmListConversations.defaultExpectation = &RepositoryIMockListConversationsExpectation{}
	}

	if mmListConversations.defaultExpectation.paramPtrs != nil {
		mmListConversations.mock.t.Fatalf("RepositoryIMock.ListConversations mock is already set by ExpectParams functions")
	}

	mmListConversations.defaultExpectation.params = &RepositoryIMockListConversationsParams{ctx, namespaceUID, catalogUID, pageSize, nextPageToken}
	for _, e := range mmListConversations.expectations {
		if minimock.Equal(e.params, mmListConversations.defaultExpectation.params) {
			mmListConversations.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListConversations.defaultExpectation.params)
		}
	}

	return mmListConversations
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.ListConversations
func (mmListConversations *mRepositoryIMockListConversations) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockListConversations {
	if mmListConversations.mock.funcListConversations != nil {
		mmListConversations.mock.t.Fatalf("RepositoryIMock.ListConversations mock is already set by Set")
	}

	if mmListConversations.defaultExpectation == nil {
		mmListConversations.defaultExpectation = &RepositoryIMockListConversationsExpectation{}
	}

	if mmListConversations.defaultExpectation.params != nil {
		mmListConversations.mock.t.Fatalf("RepositoryIMock.ListConversations mock is already set by Expect")
	}

	if mmListConversations.defaultExpectation.paramPtrs == nil {
		mmListConversations.defaultExpectation.paramPtrs = &RepositoryIMockListConversationsParamPtrs{}
	}
	mmListConversations.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListConversations
}

// ExpectNamespaceUIDParam2 sets up expected param namespaceUID for RepositoryI.ListConversations
func (mmListConversations *mRepositoryIMockListConversations) ExpectNamespaceUIDParam2(namespaceUID uuid.UUID) *mRepositoryIMockListConversations {
	if mmListConversations.mock.funcListConversations != nil {
		mmListConversations.mock.t.Fatalf("RepositoryIMock.ListConversations mock is already set by Set")
	}

	if mmListConversations.defaultExpectation == nil {
		mmListConversations.defaultExpectation = &RepositoryIMockListConversationsExpectation{}
	}

	if mmListConversations.defaultExpectation.params != nil {
		mmListConversations.mock.t.Fatalf("RepositoryIMock.ListConversations mock is already set by Expect")
	}

	if mmListConversations.defaultExpectation.paramPtrs == nil {
		mmListConversations.defaultExpectation.paramPtrs = &RepositoryIMockListConversationsParamPtrs{}
	}
	mmListConversations.defaultExpectation.paramPtrs.namespaceUID = &namespaceUID

	return mmListConversations
}

// ExpectCatalogUIDParam3 sets up expected param catalogUID for RepositoryI.ListConversations
func (mmListConversations *mRepositoryIMockListConversations) ExpectCatalogUIDParam3(catalogUID uuid.UUID) *mRepositoryIMockListConversations {
	if mmListConversations.mock.funcListConversations != nil {
		mmListConversations.mock.t.Fatalf("RepositoryIMock.ListConversations mock is already set by Set")
	}

	if mmListConversations.defaultExpectation == nil {
		mmListConversations.defaultExpectation = &RepositoryIMockListConversationsExpectation{}
	}

	if mmListConversations.defaultExpectation.params != nil {
		mmListConversations.mock.t.Fatalf("RepositoryIMock.ListConversations mock is already set by Expect")
	}

	if mmListConversations.defaultExpectation.paramPtrs == nil {
		mmListConversations.defaultExpectation.paramPtrs = &RepositoryIMockListConversationsParamPtrs{}
	}
	mmListConversations.defaultExpectation.paramPtrs.catalogUID = &catalogUID

	return mmListConversations
}

// ExpectPageSizeParam4 sets up expected param pageSize for RepositoryI.ListConversations
func (mmListConversations *mRepositoryIMockListConversations) ExpectPageSizeParam4(pageSize int32) *mRepositoryIMockListConversations {
	if mmListConversations.mock.funcListConversations != nil {
		mmListConversations.mock.t.Fatalf("RepositoryIMock.ListConversations mock is already set by Set")
	}

	if mmListConversations.defaultExpectation == nil {
		mmListConversations.defaultExpectation = &RepositoryIMockListConversationsExpectation{}
	}

	if mmListConversations.defaultExpectation.params != nil {
		mmListConversations.mock.t.Fatalf("RepositoryIMock.ListConversations mock is already set by Expect")
	}

	if mmListConversations.defaultExpectation.paramPtrs == nil {
		mmListConversations.defaultExpectation.paramPtrs = &RepositoryIMockListConversationsParamPtrs{}
	}
	mmListConversations.defaultExpectation.paramPtrs.pageSize = &pageSize

	return mmListConversations
}

// ExpectNextPageTokenParam5 sets up expected param nextPageToken for RepositoryI.ListConversations
func (mmListConversations *mRepositoryIMockListConversations) ExpectNextPageTokenParam5(nextPageToken string) *mRepositoryIMockListConversations {
	if mmListConversations.mock.funcListConversations != nil {
		mmListConversations.mock.t.Fatalf("RepositoryIMock.ListConversations mock is already set by Set")
	}

	if mmListConversations.defaultExpectation == nil {
		mmListConversations.defaultExpectation = &RepositoryIMockListConversationsExpectation{}
	}

	if mmListConversations.defaultExpectation.params != nil {
		mmListConversations.mock.t.Fatalf("RepositoryIMock.ListConversations mock is already set by Expect")
	}

	if mmListConversations.defaultExpectation.paramPtrs == nil {
		mmListConversations.defaultExpectation.paramPtrs = &RepositoryIMockListConversationsParamPtrs{}
	}
	mmListConversations.defaultExpectation.paramPtrs.nextPageToken = &nextPageToken

	return mmListConversations
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.ListConversations
func (mmListConversations *mRepositoryIMockListConversations) Inspect(f func(ctx context.Context, namespaceUID uuid.UUID, catalogUID uuid.UUID, pageSize int32, nextPageToken string)) *mRepositoryIMockListConversations {
	if mmListConversations.mock.inspectFuncListConversations != nil {
		mmListConversations.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.ListConversations")
	}

	mmListConversations.mock.inspectFuncListConversations = f

	return mmListConversations
}

// Return sets up results that will be returned by RepositoryI.ListConversations
func (mmListConversations *mRepositoryIMockListConversations) Return(cpa1 []*mm_repository.Conversation, i1 int, s1 string, err error) *RepositoryIMock {
	if mmListConversations.mock.funcListConversations != nil {
		mmListConversations.mock.t.Fatalf("RepositoryIMock.ListConversations mock is already set by Set")
	}

	if mmListConversations.defaultExpectation == nil {
		mmListConversations.defaultExpectation = &RepositoryIMockListConversationsExpectation{mock: mmListConversations.mock}
	}
	mmListConversations.defaultExpectation.results = &RepositoryIMockListConversationsResults{cpa1, i1, s1, err}
	return mmListConversations.mock
}

// Set uses given function f to mock the RepositoryI.ListConversations method
func (mmListConversations *mRepositoryIMockListConversations) Set(f func(ctx context.Context, namespaceUID uuid.UUID, catalogUID uuid.UUID, pageSize int32, nextPageToken string) (cpa1 []*mm_repository.Conversation, i1 int, s1 string, err error)) *RepositoryIMock {
	if mmListConversations.defaultExpectation != nil {
		mmListConversations.mock.t.Fatalf("Default expectation is already set for the RepositoryI.ListConversations method")
	}

	if len(mmListConversations.expectations) > 0 {
		mmListConversations.mock.t.Fatalf("Some expectations are already set for the RepositoryI.ListConversations method")
	}

	mmListConversations.mock.funcListConversations = f
	return mmListConversations.mock
}

// When sets expectation for the RepositoryI.ListConversations which will trigger the result defined by the following
// Then helper
func (mmListConversations *mRepositoryIMockListConversations) When(ctx context.Context, namespaceUID uuid.UUID, catalogUID uuid.UUID, pageSize int32, nextPageToken string) *RepositoryIMockListConversationsExpectation {
	if mmListConversations.mock.funcListConversations != nil {
		mmListConversations.mock.t.Fatalf("RepositoryIMock.ListConversations mock is already set by Set")
	}

	expectation := &RepositoryIMockListConversationsExpectation{
		mock:   mmListConversations.mock,
		params: &RepositoryIMockListConversationsParams{ctx, namespaceUID, catalogUID, pageSize, nextPageToken},
	}
	mmListConversations.expectations = append(mmListConversations.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.ListConversations return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockListConversationsExpectation) Then(cpa1 []*mm_repository.Conversation, i1 int, s1 string, err error) *RepositoryIMock {
	e.results = &RepositoryIMockListConversationsResults{cpa1, i1, s1, err}
	return e.mock
}

// Times sets number of times RepositoryI.ListConversations should be invoked
func (mmListConversations *mRepositoryIMockListConversations) Times(n uint64) *mRepositoryIMockListConversations {
	if n == 0 {
		mmListConversations.mock.t.Fatalf("Times of RepositoryIMock.ListConversations mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListConversations.expectedInvocations, n)
	return mmListConversations
}

func (mmListConversations *mRepositoryIMockListConversations) invocationsDone() bool {
	if len(mmListConversations.expectations) == 0 && mmListConversations.defaultExpectation == nil && mmListConversations.mock.funcListConversations == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListConversations.mock.afterListConversationsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListConversations.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListConversations implements repository.RepositoryI
func (mmListConversations *RepositoryIMock) ListConversations(ctx context.Context, namespaceUID uuid.UUID, catalogUID uuid.UUID, pageSize int32, nextPageToken string) (cpa1 []*mm_repository.Conversation, i1 int, s1 string, err error) {
	mm_atomic.AddUint64(&mmListConversations.beforeListConversationsCounter, 1)
	defer mm_atomic.AddUint64(&mmListConversations.afterListConversationsCounter, 1)

	if mmListConversations.inspectFuncListConversations != nil {
		mmListConversations.inspectFuncListConversations(ctx, namespaceUID, catalogUID, pageSize, nextPageToken)
	}

	mm_params := RepositoryIMockListConversationsParams{ctx, namespaceUID, catalogUID, pageSize, nextPageToken}

	// Record call args
	mmListConversations.ListConversationsMock.mutex.Lock()
	mmListConversations.ListConversationsMock.callArgs = append(mmListConversations.ListConversationsMock.callArgs, &mm_params)
	mmListConversations.ListConversationsMock.mutex.Unlock()

	for _, e := range mmListConversations.ListConversationsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cpa1, e.results.i1, e.results.s1, e.results.err
		}
	}

	if mmListConversations.ListConversationsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListConversations.ListConversationsMock.defaultExpectation.Counter, 1)
		mm_want := mmListConversations.ListConversationsMock.defaultExpectation.params
		mm_want_ptrs := mmListConversations.ListConversationsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockListConversationsParams{ctx, namespaceUID, catalogUID, pageSize, nextPageToken}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListConversations.t.Errorf("RepositoryIMock.ListConversations got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.namespaceUID != nil && !minimock.Equal(*mm_want_ptrs.namespaceUID, mm_got.namespaceUID) {
				mmListConversations.t.Errorf("RepositoryIMock.ListConversations got unexpected parameter namespaceUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.namespaceUID, mm_got.namespaceUID, minimock.Diff(*mm_want_ptrs.namespaceUID, mm_got.namespaceUID))
			}

			if mm_want_ptrs.catalogUID != nil && !minimock.Equal(*mm_want_ptrs.catalogUID, mm_got.catalogUID) {
				mmListConversations.t.Errorf("RepositoryIMock.ListConversations got unexpected parameter catalogUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.catalogUID, mm_got.catalogUID, minimock.Diff(*mm_want_ptrs.catalogUID, mm_got.catalogUID))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListConversations.t.Errorf("RepositoryIMock.ListConversations got unexpected parameter pageSize, want: %#v, got: %#v%s\n", *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.nextPageToken != nil && !minimock.Equal(*mm_want_ptrs.nextPageToken, mm_got.nextPageToken) {
				mmListConversations.t.Errorf("RepositoryIMock.ListConversations got unexpected parameter nextPageToken, want: %#v, got: %#v%s\n", *mm_want_ptrs.nextPageToken, mm_got.nextPageToken, minimock.Diff(*mm_want_ptrs.nextPageToken, mm_got.nextPageToken))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListConversations.t.Errorf("RepositoryIMock.ListConversations got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListConversations.ListConversationsMock.defaultExpectation.results
		if mm_results == nil {
			mmListConversations.t.Fatal("No results are set for the RepositoryIMock.ListConversations")
		}
		return (*mm_results).cpa1, (*mm_results).i1, (*mm_results).s1, (*mm_results).err
	}
	if mmListConversations.funcListConversations != nil {
		return mmListConversations.funcListConversations(ctx, namespaceUID, catalogUID, pageSize, nextPageToken)
	}
	mmListConversations.t.Fatalf("Unexpected call to RepositoryIMock.ListConversations. %v %v %v %v %v", ctx, namespaceUID, catalogUID, pageSize, nextPageToken)
	return
}

// ListConversationsAfterCounter returns a count of finished RepositoryIMock.ListConversations invocations
func (mmListConversations *RepositoryIMock) ListConversationsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListConversations.afterListConversationsCounter)
}

// ListConversationsBeforeCounter returns a count of RepositoryIMock.ListConversations invocations
func (mmListConversations *RepositoryIMock) ListConversationsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListConversations.beforeListConversationsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.ListConversations.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListConversations *mRepositoryIMockListConversations) Calls() []*RepositoryIMockListConversationsParams {
	mmListConversations.mutex.RLock()

	argCopy := make([]*RepositoryIMockListConversationsParams, len(mmListConversations.callArgs))
	copy(argCopy, mmListConversations.callArgs)

	mmListConversations.mutex.RUnlock()

	return argCopy
}

// MinimockListConversationsDone returns true if the count of the ListConversations invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockListConversationsDone() bool {
	for _, e := range m.ListConversationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListConversationsMock.invocationsDone()
}

// MinimockListConversationsInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockListConversationsInspect() {
	for _, e := range m.ListConversationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.ListConversations with params: %#v", *e.params)
		}
	}

	afterListConversationsCounter := mm_atomic.LoadUint64(&m.afterListConversationsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListConversationsMock.defaultExpectation != nil && afterListConversationsCounter < 1 {
		if m.ListConversationsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.ListConversations")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.ListConversations with params: %#v", *m.ListConversationsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListConversations != nil && afterListConversationsCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.ListConversations")
	}

	if !m.ListConversationsMock.invocationsDone() && afterListConversationsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.ListConversations but found %d calls",
			mm_atomic.LoadUint64(&m.ListConversationsMock.expectedInvocations), afterListConversationsCounter)
	}
}

type mRepositoryIMockListEmbeddingsByKbFileUID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockListEmbeddingsByKbFileUIDExpectation
	expectations       []*RepositoryIMockListEmbeddingsByKbFileUIDExpectation

	callArgs []*RepositoryIMockListEmbeddingsByKbFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockListEmbeddingsByKbFileUIDExpectation specifies expectation struct of the RepositoryI.ListEmbeddingsByKbFileUID
type RepositoryIMockListEmbeddingsByKbFileUIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockListEmbeddingsByKbFileUIDParams
	paramPtrs *RepositoryIMockListEmbeddingsByKbFileUIDParamPtrs
	results   *RepositoryIMockListEmbeddingsByKbFileUIDResults
	Counter   uint64
}

// RepositoryIMockListEmbeddingsByKbFileUIDParams contains parameters of the RepositoryI.ListEmbeddingsByKbFileUID
type RepositoryIMockListEmbeddingsByKbFileUIDParams struct {
	ctx       context.Context
	kbFileUID uuid.UUID
}

// RepositoryIMockListEmbeddingsByKbFileUIDParamPtrs contains pointers to parameters of the RepositoryI.ListEmbeddingsByKbFileUID
type RepositoryIMockListEmbeddingsByKbFileUIDParamPtrs struct {
	ctx       *context.Context
	kbFileUID *uuid.UUID
}

// RepositoryIMockListEmbeddingsByKbFileUIDResults contains results of the RepositoryI.ListEmbeddingsByKbFileUID
type RepositoryIMockListEmbeddingsByKbFileUIDResults struct {
	ea1 []mm_repository.Embedding
	err error
}

// Expect sets up expected params for RepositoryI.ListEmbeddingsByKbFileUID
func (mmListEmbeddingsByKbFileUID *mRepositoryIMockListEmbeddingsByKbFileUID) Expect(ctx context.Context, kbFileUID uuid.UUID) *mRepositoryIMockListEmbeddingsByKbFileUID {
	if mmListEmbeddingsByKbFileUID.mock.funcListEmbeddingsByKbFileUID != nil {
		mmListEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListEmbeddingsByKbFileUID mock is already set by Set")
	}

	if mmListEmbeddingsByKbFileUID.defaultExpectation == nil {
		mmListEmbeddingsByKbFileUID.defaultExpectation = &RepositoryIMockListEmbeddingsByKbFileUIDExpectation{}
	}

	if mmListEmbeddingsByKbFileUID.defaultExpectation.paramPtrs != nil {
		mmListEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListEmbeddingsByKbFileUID mock is already set by ExpectParams functions")
	}

	mmListEmbeddingsByKbFileUID.defaultExpectation.params = &RepositoryIMockListEmbeddingsByKbFileUIDParams{ctx, kbFileUID}
	for _, e := range mmListEmbeddingsByKbFileUID.expectations {
		if minimock.Equal(e.params, mmListEmbeddingsByKbFileUID.defaultExpectation.params) {
			mmListEmbeddingsByKbFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListEmbeddingsByKbFileUID.defaultExpectation.params)
		}
	}

	return mmListEmbeddingsByKbFileUID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.ListEmbeddingsByKbFileUID
func (mmListEmbeddingsByKbFileUID *mRepositoryIMockListEmbeddingsByKbFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockListEmbeddingsByKbFileUID {
	if mmListEmbeddingsByKbFileUID.mock.funcListEmbeddingsByKbFileUID != nil {
		mmListEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListEmbeddingsByKbFileUID mock is already set by Set")
	}

	if mmListEmbeddingsByKbFileUID.defaultExpectation == nil {
		mmListEmbeddingsByKbFileUID.defaultExpectation = &RepositoryIMockListEmbeddingsByKbFileUIDExpectation{}
	}

	if mmListEmbeddingsByKbFileUID.defaultExpectation.params != nil {
		mmListEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListEmbeddingsByKbFileUID mock is already set by Expect")
	}

	if mmListEmbeddingsByKbFileUID.defaultExpectation.paramPtrs == nil {
		mmListEmbeddingsByKbFileUID.defaultExpectation.paramPtrs = &RepositoryIMockListEmbeddingsByKbFileUIDParamPtrs{}
	}
	mmListEmbeddingsByKbFileUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListEmbeddingsByKbFileUID
}

// ExpectKbFileUIDParam2 sets up expected param kbFileUID for RepositoryI.ListEmbeddingsByKbFileUID
func (mmListEmbeddingsByKbFileUID *mRepositoryIMockListEmbeddingsByKbFileUID) ExpectKbFileUIDParam2(kbFileUID uuid.UUID) *mRepositoryIMockListEmbeddingsByKbFileUID {
	if mmListEmbeddingsByKbFileUID.mock.funcListEmbeddingsByKbFileUID != nil {
		mmListEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListEmbeddingsByKbFileUID mock is already set by Set")
	}

	if mmListEmbeddingsByKbFileUID.defaultExpectation == nil {
		mmListEmbeddingsByKbFileUID.defaultExpectation = &RepositoryIMockListEmbeddingsByKbFileUIDExpectation{}
	}

	if mmListEmbeddingsByKbFileUID.defaultExpectation.params != nil {
		mmListEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListEmbeddingsByKbFileUID mock is already set by Expect")
	}

	if mmListEmbeddingsByKbFileUID.defaultExpectation.paramPtrs == nil {
		mmListEmbeddingsByKbFileUID.defaultExpectation.paramPtrs = &RepositoryIMockListEmbeddingsByKbFileUIDParamPtrs{}
	}
	mmListEmbeddingsByKbFileUID.defaultExpectation.paramPtrs.kbFileUID = &kbFileUID

	return mmListEmbeddingsByKbFileUID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.ListEmbeddingsByKbFileUID
func (mmListEmbeddingsByKbFileUID *mRepositoryIMockListEmbeddingsByKbFileUID) Inspect(f func(ctx context.Context, kbFileUID uuid.UUID)) *mRepositoryIMockListEmbeddingsByKbFileUID {
	if mmListEmbeddingsByKbFileUID.mock.inspectFuncListEmbeddingsByKbFileUID != nil {
		mmListEmbeddingsByKbFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.ListEmbeddingsByKbFileUID")
	}

	mmListEmbeddingsByKbFileUID.mock.inspectFuncListEmbeddingsByKbFileUID = f

	return mmListEmbeddingsByKbFileUID
}

// Return sets up results that will be returned by RepositoryI.ListEmbeddingsByKbFileUID
func (mmListEmbeddingsByKbFileUID *mRepositoryIMockListEmbeddingsByKbFileUID) Return(ea1 []mm_repository.Embedding, err error) *RepositoryIMock {
	if mmListEmbeddingsByKbFileUID.mock.funcListEmbeddingsByKbFileUID != nil {
		mmListEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListEmbeddingsByKbFileUID mock is already set by Set")
	}

	if mmListEmbeddingsByKbFileUID.defaultExpectation == nil {
		mmListEmbeddingsByKbFileUID.defaultExpectation = &RepositoryIMockListEmbeddingsByKbFileUIDExpectation{mock: mmListEmbeddingsByKbFileUID.mock}
	}
	mmListEmbeddingsByKbFileUID.defaultExpectation.results = &RepositoryIMockListEmbeddingsByKbFileUIDResults{ea1, err}
	return mmListEmbeddingsByKbFileUID.mock
}

// Set uses given function f to mock the RepositoryI.ListEmbeddingsByKbFileUID method
func (mmListEmbeddingsByKbFileUID *mRepositoryIMockListEmbeddingsByKbFileUID) Set(f func(ctx context.Context, kbFileUID uuid.UUID) (ea1 []mm_repository.Embedding, err error)) *RepositoryIMock {
	if mmListEmbeddingsByKbFileUID.defaultExpectation != nil {
		mmListEmbeddingsByKbFileUID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.ListEmbeddingsByKbFileUID method")
	}

	if len(mmListEmbeddingsByKbFileUID.expectations) > 0 {
		mmListEmbeddingsByKbFileUID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.ListEmbeddingsByKbFileUID method")
	}

	mmListEmbeddingsByKbFileUID.mock.funcListEmbeddingsByKbFileUID = f
	return mmListEmbeddingsByKbFileUID.mock
}

// When sets expectation for the RepositoryI.ListEmbeddingsByKbFileUID which will trigger the result defined by the following
// Then helper
func (mmListEmbeddingsByKbFileUID *mRepositoryIMockListEmbeddingsByKbFileUID) When(ctx context.Context, kbFileUID uuid.UUID) *RepositoryIMockListEmbeddingsByKbFileUIDExpectation {
	if mmListEmbeddingsByKbFileUID.mock.funcListEmbeddingsByKbFileUID != nil {
		mmListEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListEmbeddingsByKbFileUID mock is already set by Set")
	}

	expectation := &RepositoryIMockListEmbeddingsByKbFileUIDExpectation{
		mock:   mmListEmbeddingsByKbFileUID.mock,
		params: &RepositoryIMockListEmbeddingsByKbFileUIDParams{ctx, kbFileUID},
	}
	mmListEmbeddingsByKbFileUID.expectations = append(mmListEmbeddingsByKbFileUID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.ListEmbeddingsByKbFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockListEmbeddingsByKbFileUIDExpectation) Then(ea1 []mm_repository.Embedding, err error) *RepositoryIMock {
	e.results = &RepositoryIMockListEmbeddingsByKbFileUIDResults{ea1, err}
	return e.mock
}

// Times sets number of times RepositoryI.ListEmbeddingsByKbFileUID should be invoked
func (mmListEmbeddingsByKbFileUID *mRepositoryIMockListEmbeddingsByKbFileUID) Times(n uint64) *mRepositoryIMockListEmbeddingsByKbFileUID {
	if n == 0 {
		mmListEmbeddingsByKbFileUID.mock.t.Fatalf("Times of RepositoryIMock.ListEmbeddingsByKbFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListEmbeddingsByKbFileUID.expectedInvocations, n)
	return mmListEmbeddingsByKbFileUID
}

func (mmListEmbeddingsByKbFileUID *mRepositoryIMockListEmbeddingsByKbFileUID) invocationsDone() bool {
	if len(mmListEmbeddingsByKbFileUID.expectations) == 0 && mmListEmbeddingsByKbFileUID.defaultExpectation == nil && mmListEmbeddingsByKbFileUID.mock.funcListEmbeddingsByKbFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListEmbeddingsByKbFileUID.mock.afterListEmbeddingsByKbFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListEmbeddingsByKbFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListEmbeddingsByKbFileUID implements repository.RepositoryI
func (mmListEmbeddingsByKbFileUID *RepositoryIMock) ListEmbeddingsByKbFileUID(ctx context.Context, kbFileUID uuid.UUID) (ea1 []mm_repository.Embedding, err error) {
	mm_atomic.AddUint64(&mmListEmbeddingsByKbFileUID.beforeListEmbeddingsByKbFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmListEmbeddingsByKbFileUID.afterListEmbeddingsByKbFileUIDCounter, 1)

	if mmListEmbeddingsByKbFileUID.inspectFuncListEmbeddingsByKbFileUID != nil {
		mmListEmbeddingsByKbFileUID.inspectFuncListEmbeddingsByKbFileUID(ctx, kbFileUID)
	}

	mm_params := RepositoryIMockListEmbeddingsByKbFileUIDParams{ctx, kbFileUID}

	// Record call args
	mmListEmbeddingsByKbFileUID.ListEmbeddingsByKbFileUIDMock.mutex.Lock()
	mmListEmbeddingsByKbFileUID.ListEmbeddingsByKbFileUIDMock.callArgs = append(mmListEmbeddingsByKbFileUID.ListEmbeddingsByKbFileUIDMock.callArgs, &mm_params)
	mmListEmbeddingsByKbFileUID.ListEmbeddingsByKbFileUIDMock.mutex.Unlock()

	for _, e := range mmListEmbeddingsByKbFileUID.ListEmbeddingsByKbFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1, e.results.err
		}
	}

	if mmListEmbeddingsByKbFileUID.ListEmbeddingsByKbFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListEmbeddingsByKbFileUID.ListEmbeddingsByKbFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmListEmbeddingsByKbFileUID.ListEmbeddingsByKbFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmListEmbeddingsByKbFileUID.ListEmbeddingsByKbFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockListEmbeddingsByKbFileUIDParams{ctx, kbFileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListEmbeddingsByKbFileUID.t.Errorf("RepositoryIMock.ListEmbeddingsByKbFileUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbFileUID != nil && !minimock.Equal(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID) {
				mmListEmbeddingsByKbFileUID.t.Errorf("RepositoryIMock.ListEmbeddingsByKbFileUID got unexpected parameter kbFileUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbFileUID, mm_got.kbFileUID, minimock.Diff(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListEmbeddingsByKbFileUID.t.Errorf("RepositoryIMock.ListEmbeddingsByKbFileUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListEmbeddingsByKbFileUID.ListEmbeddingsByKbFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmListEmbeddingsByKbFileUID.t.Fatal("No results are set for the RepositoryIMock.ListEmbeddingsByKbFileUID")
		}
		return (*mm_results).ea1, (*mm_results).err
	}
	if mmListEmbeddingsByKbFileUID.funcListEmbeddingsByKbFileUID != nil {
		return mmListEmbeddingsByKbFileUID.funcListEmbeddingsByKbFileUID(ctx, kbFileUID)
	}
	mmListEmbeddingsByKbFileUID.t.Fatalf("Unexpected call to RepositoryIMock.ListEmbeddingsByKbFileUID. %v %v", ctx, kbFileUID)
	return
}

// ListEmbeddingsByKbFileUIDAfterCounter returns a count of finished RepositoryIMock.ListEmbeddingsByKbFileUID invocations
func (mmListEmbeddingsByKbFileUID *RepositoryIMock) ListEmbeddingsByKbFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListEmbeddingsByKbFileUID.afterListEmbeddingsByKbFileUIDCounter)
}

// ListEmbeddingsByKbFileUIDBeforeCounter returns a count of RepositoryIMock.ListEmbeddingsByKbFileUID invocations
func (mmListEmbeddingsByKbFileUID *RepositoryIMock) ListEmbeddingsByKbFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListEmbeddingsByKbFileUID.beforeListEmbeddingsByKbFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.ListEmbeddingsByKbFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListEmbeddingsByKbFileUID *mRepositoryIMockListEmbeddingsByKbFileUID) Calls() []*RepositoryIMockListEmbeddingsByKbFileUIDParams {
	mmListEmbeddingsByKbFileUID.mutex.RLock()

	argCopy := make([]*RepositoryIMockListEmbeddingsByKbFileUIDParams, len(mmListEmbeddingsByKbFileUID.callArgs))
	copy(argCopy, mmListEmbeddingsByKbFileUID.callArgs)

	mmListEmbeddingsByKbFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockListEmbeddingsByKbFileUIDDone returns true if the count of the ListEmbeddingsByKbFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockListEmbeddingsByKbFileUIDDone() bool {
	for _, e := range m.ListEmbeddingsByKbFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListEmbeddingsByKbFileUIDMock.invocationsDone()
}

// MinimockListEmbeddingsByKbFileUIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockListEmbeddingsByKbFileUIDInspect() {
	for _, e := range m.ListEmbeddingsByKbFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.ListEmbeddingsByKbFileUID with params: %#v", *e.params)
		}
	}

	afterListEmbeddingsByKbFileUIDCounter := mm_atomic.LoadUint64(&m.afterListEmbeddingsByKbFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListEmbeddingsByKbFileUIDMock.defaultExpectation != nil && afterListEmbeddingsByKbFileUIDCounter < 1 {
		if m.ListEmbeddingsByKbFileUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.ListEmbeddingsByKbFileUID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.ListEmbeddingsByKbFileUID with params: %#v", *m.ListEmbeddingsByKbFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListEmbeddingsByKbFileUID != nil && afterListEmbeddingsByKbFileUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.ListEmbeddingsByKbFileUID")
	}

	if !m.ListEmbeddingsByKbFileUIDMock.invocationsDone() && afterListEmbeddingsByKbFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.ListEmbeddingsByKbFileUID but found %d calls",
			mm_atomic.LoadUint64(&m.ListEmbeddingsByKbFileUIDMock.expectedInvocations), afterListEmbeddingsByKbFileUIDCounter)
	}
}

type mRepositoryIMockListKnowledgeBaseFiles struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockListKnowledgeBaseFilesExpectation
	expectations       []*RepositoryIMockListKnowledgeBaseFilesExpectation

	callArgs []*RepositoryIMockListKnowledgeBaseFilesParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockListKnowledgeBaseFilesExpectation specifies expectation struct of the RepositoryI.ListKnowledgeBaseFiles
type RepositoryIMockListKnowledgeBaseFilesExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockListKnowledgeBaseFilesParams
	paramPtrs *RepositoryIMockListKnowledgeBaseFilesParamPtrs
	results   *RepositoryIMockListKnowledgeBaseFilesResults
	Counter   uint64
}

// RepositoryIMockListKnowledgeBaseFilesParams contains parameters of the RepositoryI.ListKnowledgeBaseFiles
type RepositoryIMockListKnowledgeBaseFilesParams struct {
	ctx           context.Context
	uid           string
	ownerUID      string
	kbUID         string
	pageSize      int32
	nextPageToken string
	filesUID      []string
}

// RepositoryIMockListKnowledgeBaseFilesParamPtrs contains pointers to parameters of the RepositoryI.ListKnowledgeBaseFiles
type RepositoryIMockListKnowledgeBaseFilesParamPtrs struct {
	ctx           *context.Context
	uid           *string
	ownerUID      *string
	kbUID         *string
	pageSize      *int32
	nextPageToken *string
	filesUID      *[]string
}

// RepositoryIMockListKnowledgeBaseFilesResults contains results of the RepositoryI.ListKnowledgeBaseFiles
type RepositoryIMockListKnowledgeBaseFilesResults struct {
	ka1 []mm_repository.KnowledgeBaseFile
	i1  int
	s1  string
	err error
}

// Expect sets up expected params for RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) Expect(ctx context.Context, uid string, ownerUID string, kbUID string, pageSize int32, nextPageToken string, filesUID []string) *mRepositoryIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by ExpectParams functions")
	}

	mmListKnowledgeBaseFiles.defaultExpectation.params = &RepositoryIMockListKnowledgeBaseFilesParams{ctx, uid, ownerUID, kbUID, pageSize, nextPageToken, filesUID}
	for _, e := range mmListKnowledgeBaseFiles.expectations {
		if minimock.Equal(e.params, mmListKnowledgeBaseFiles.defaultExpectation.params) {
			mmListKnowledgeBaseFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListKnowledgeBaseFiles.defaultExpectation.params)
		}
	}

	return mmListKnowledgeBaseFiles
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBaseFilesParamPtrs{}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListKnowledgeBaseFiles
}

// ExpectUidParam2 sets up expected param uid for RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) ExpectUidParam2(uid string) *mRepositoryIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBaseFilesParamPtrs{}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs.uid = &uid

	return mmListKnowledgeBaseFiles
}

// ExpectOwnerUIDParam3 sets up expected param ownerUID for RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) ExpectOwnerUIDParam3(ownerUID string) *mRepositoryIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBaseFilesParamPtrs{}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs.ownerUID = &ownerUID

	return mmListKnowledgeBaseFiles
}

// ExpectKbUIDParam4 sets up expected param kbUID for RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) ExpectKbUIDParam4(kbUID string) *mRepositoryIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBaseFilesParamPtrs{}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs.kbUID = &kbUID

	return mmListKnowledgeBaseFiles
}

// ExpectPageSizeParam5 sets up expected param pageSize for RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) ExpectPageSizeParam5(pageSize int32) *mRepositoryIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBaseFilesParamPtrs{}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs.pageSize = &pageSize

	return mmListKnowledgeBaseFiles
}

// ExpectNextPageTokenParam6 sets up expected param nextPageToken for RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) ExpectNextPageTokenParam6(nextPageToken string) *mRepositoryIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBaseFilesParamPtrs{}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs.nextPageToken = &nextPageToken

	return mmListKnowledgeBaseFiles
}

// ExpectFilesUIDParam7 sets up expected param filesUID for RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) ExpectFilesUIDParam7(filesUID []string) *mRepositoryIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBaseFilesParamPtrs{}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs.filesUID = &filesUID

	return mmListKnowledgeBaseFiles
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) Inspect(f func(ctx context.Context, uid string, ownerUID string, kbUID string, pageSize int32, nextPageToken string, filesUID []string)) *mRepositoryIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.inspectFuncListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.ListKnowledgeBaseFiles")
	}

	mmListKnowledgeBaseFiles.mock.inspectFuncListKnowledgeBaseFiles = f

	return mmListKnowledgeBaseFiles
}

// Return sets up results that will be returned by RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) Return(ka1 []mm_repository.KnowledgeBaseFile, i1 int, s1 string, err error) *RepositoryIMock {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockListKnowledgeBaseFilesExpectation{mock: mmListKnowledgeBaseFiles.mock}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.results = &RepositoryIMockListKnowledgeBaseFilesResults{ka1, i1, s1, err}
	return mmListKnowledgeBaseFiles.mock
}

// Set uses given function f to mock the RepositoryI.ListKnowledgeBaseFiles method
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) Set(f func(ctx context.Context, uid string, ownerUID string, kbUID string, pageSize int32, nextPageToken string, filesUID []string) (ka1 []mm_repository.KnowledgeBaseFile, i1 int, s1 string, err error)) *RepositoryIMock {
	if mmListKnowledgeBaseFiles.defaultExpectation != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("Default expectation is already set for the RepositoryI.ListKnowledgeBaseFiles method")
	}

	if len(mmListKnowledgeBaseFiles.expectations) > 0 {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("Some expectations are already set for the RepositoryI.ListKnowledgeBaseFiles method")
	}

	mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles = f
	return mmListKnowledgeBaseFiles.mock
}

// When sets expectation for the RepositoryI.ListKnowledgeBaseFiles which will trigger the result defined by the following
// Then helper
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) When(ctx context.Context, uid string, ownerUID string, kbUID string, pageSize int32, nextPageToken string, filesUID []string) *RepositoryIMockListKnowledgeBaseFilesExpectation {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	expectation := &RepositoryIMockListKnowledgeBaseFilesExpectation{
		mock:   mmListKnowledgeBaseFiles.mock,
		params: &RepositoryIMockListKnowledgeBaseFilesParams{ctx, uid, ownerUID, kbUID, pageSize, nextPageToken, filesUID},
	}
	mmListKnowledgeBaseFiles.expectations = append(mmListKnowledgeBaseFiles.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.ListKnowledgeBaseFiles return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockListKnowledgeBaseFilesExpectation) Then(ka1 []mm_repository.KnowledgeBaseFile, i1 int, s1 string, err error) *RepositoryIMock {
	e.results = &RepositoryIMockListKnowledgeBaseFilesResults{ka1, i1, s1, err}
	return e.mock
}

// Times sets number of times RepositoryI.ListKnowledgeBaseFiles should be invoked
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) Times(n uint64) *mRepositoryIMockListKnowledgeBaseFiles {
	if n == 0 {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("Times of RepositoryIMock.ListKnowledgeBaseFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListKnowledgeBaseFiles.expectedInvocations, n)
	return mmListKnowledgeBaseFiles
}

func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) invocationsDone() bool {
	if len(mmListKnowledgeBaseFiles.expectations) == 0 && mmListKnowledgeBaseFiles.defaultExpectation == nil && mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBaseFiles.mock.afterListKnowledgeBaseFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBaseFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListKnowledgeBaseFiles implements repository.RepositoryI
func (mmListKnowledgeBaseFiles *RepositoryIMock) ListKnowledgeBaseFiles(ctx context.Context, uid string, ownerUID string, kbUID string, pageSize int32, nextPageToken string, filesUID []string) (ka1 []mm_repository.KnowledgeBaseFile, i1 int, s1 string, err error) {
	mm_atomic.AddUint64(&mmListKnowledgeBaseFiles.beforeListKnowledgeBaseFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmListKnowledgeBaseFiles.afterListKnowledgeBaseFilesCounter, 1)

	if mmListKnowledgeBaseFiles.inspectFuncListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.inspectFuncListKnowledgeBaseFiles(ctx, uid, ownerUID, kbUID, pageSize, nextPageToken, filesUID)
	}

	mm_params := RepositoryIMockListKnowledgeBaseFilesParams{ctx, uid, ownerUID, kbUID, pageSize, nextPageToken, filesUID}

	// Record call args
	mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.mutex.Lock()
	mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.callArgs = append(mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.callArgs, &mm_params)
	mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.mutex.Unlock()

	for _, e := range mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.i1, e.results.s1, e.results.err
		}
	}

	if mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.params
		mm_want_ptrs := mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockListKnowledgeBaseFilesParams{ctx, uid, ownerUID, kbUID, pageSize, nextPageToken, filesUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ListKnowledgeBaseFiles got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmListKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ListKnowledgeBaseFiles got unexpected parameter uid, want: %#v, got: %#v%s\n", *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmListKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ListKnowledgeBaseFiles got unexpected parameter ownerUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmListKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ListKnowledgeBaseFiles got unexpected parameter kbUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ListKnowledgeBaseFiles got unexpected parameter pageSize, want: %#v, got: %#v%s\n", *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.nextPageToken != nil && !minimock.Equal(*mm_want_ptrs.nextPageToken, mm_got.nextPageToken) {
				mmListKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ListKnowledgeBaseFiles got unexpected parameter nextPageToken, want: %#v, got: %#v%s\n", *mm_want_ptrs.nextPageToken, mm_got.nextPageToken, minimock.Diff(*mm_want_ptrs.nextPageToken, mm_got.nextPageToken))
			}

			if mm_want_ptrs.filesUID != nil && !minimock.Equal(*mm_want_ptrs.filesUID, mm_got.filesUID) {
				mmListKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ListKnowledgeBaseFiles got unexpected parameter filesUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.filesUID, mm_got.filesUID, minimock.Diff(*mm_want_ptrs.filesUID, mm_got.filesUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ListKnowledgeBaseFiles got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmListKnowledgeBaseFiles.t.Fatal("No results are set for the RepositoryIMock.ListKnowledgeBaseFiles")
		}
		return (*mm_results).ka1, (*mm_results).i1, (*mm_results).s1, (*mm_results).err
	}
	if mmListKnowledgeBaseFiles.funcListKnowledgeBaseFiles != nil {
		return mmListKnowledgeBaseFiles.funcListKnowledgeBaseFiles(ctx, uid, ownerUID, kbUID, pageSize, nextPageToken, filesUID)
	}
	mmListKnowledgeBaseFiles.t.Fatalf("Unexpected call to RepositoryIMock.ListKnowledgeBaseFiles. %v %v %v %v %v %v %v", ctx, uid, ownerUID, kbUID, pageSize, nextPageToken, filesUID)
	return
}

// ListKnowledgeBaseFilesAfterCounter returns a count of finished RepositoryIMock.ListKnowledgeBaseFiles invocations
func (mmListKnowledgeBaseFiles *RepositoryIMock) ListKnowledgeBaseFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBaseFiles.afterListKnowledgeBaseFilesCounter)
}

// ListKnowledgeBaseFilesBeforeCounter returns a count of RepositoryIMock.ListKnowledgeBaseFiles invocations
func (mmListKnowledgeBaseFiles *RepositoryIMock) ListKnowledgeBaseFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBaseFiles.beforeListKnowledgeBaseFilesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.ListKnowledgeBaseFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) Calls() []*RepositoryIMockListKnowledgeBaseFilesParams {
	mmListKnowledgeBaseFiles.mutex.RLock()

	argCopy := make([]*RepositoryIMockListKnowledgeBaseFilesParams, len(mmListKnowledgeBaseFiles.callArgs))
	copy(argCopy, mmListKnowledgeBaseFiles.callArgs)

	mmListKnowledgeBaseFiles.mutex.RUnlock()

	return argCopy
}

// MinimockListKnowledgeBaseFilesDone returns true if the count of the ListKnowledgeBaseFiles invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockListKnowledgeBaseFilesDone() bool {
	for _, e := range m.ListKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListKnowledgeBaseFilesMock.invocationsDone()
}

// MinimockListKnowledgeBaseFilesInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockListKnowledgeBaseFilesInspect() {
	for _, e := range m.ListKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.ListKnowledgeBaseFiles with params: %#v", *e.params)
		}
	}

	afterListKnowledgeBaseFilesCounter := mm_atomic.LoadUint64(&m.afterListKnowledgeBaseFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListKnowledgeBaseFilesMock.defaultExpectation != nil && afterListKnowledgeBaseFilesCounter < 1 {
		if m.ListKnowledgeBaseFilesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.ListKnowledgeBaseFiles")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.ListKnowledgeBaseFiles with params: %#v", *m.ListKnowledgeBaseFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListKnowledgeBaseFiles != nil && afterListKnowledgeBaseFilesCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.ListKnowledgeBaseFiles")
	}

	if !m.ListKnowledgeBaseFilesMock.invocationsDone() && afterListKnowledgeBaseFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.ListKnowledgeBaseFiles but found %d calls",
			mm_atomic.LoadUint64(&m.ListKnowledgeBaseFilesMock.expectedInvocations), afterListKnowledgeBaseFilesCounter)
	}
}

type mRepositoryIMockListKnowledgeBases struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockListKnowledgeBasesExpectation
	expectations       []*RepositoryIMockListKnowledgeBasesExpectation

	callArgs []*RepositoryIMockListKnowledgeBasesParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockListKnowledgeBasesExpectation specifies expectation struct of the RepositoryI.ListKnowledgeBases
type RepositoryIMockListKnowledgeBasesExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockListKnowledgeBasesParams
	paramPtrs *RepositoryIMockListKnowledgeBasesParamPtrs
	results   *RepositoryIMockListKnowledgeBasesResults
	Counter   uint64
}

// RepositoryIMockListKnowledgeBasesParams contains parameters of the RepositoryI.ListKnowledgeBases
type RepositoryIMockListKnowledgeBasesParams struct {
	ctx      context.Context
	ownerUID string
}

// RepositoryIMockListKnowledgeBasesParamPtrs contains pointers to parameters of the RepositoryI.ListKnowledgeBases
type RepositoryIMockListKnowledgeBasesParamPtrs struct {
	ctx      *context.Context
	ownerUID *string
}

// RepositoryIMockListKnowledgeBasesResults contains results of the RepositoryI.ListKnowledgeBases
type RepositoryIMockListKnowledgeBasesResults struct {
	ka1 []mm_repository.KnowledgeBase
	err error
}

// Expect sets up expected params for RepositoryI.ListKnowledgeBases
func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) Expect(ctx context.Context, ownerUID string) *mRepositoryIMockListKnowledgeBases {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBases mock is already set by Set")
	}

	if mmListKnowledgeBases.defaultExpectation == nil {
		mmListKnowledgeBases.defaultExpectation = &RepositoryIMockListKnowledgeBasesExpectation{}
	}

	if mmListKnowledgeBases.defaultExpectation.paramPtrs != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBases mock is already set by ExpectParams functions")
	}

	mmListKnowledgeBases.defaultExpectation.params = &RepositoryIMockListKnowledgeBasesParams{ctx, ownerUID}
	for _, e := range mmListKnowledgeBases.expectations {
		if minimock.Equal(e.params, mmListKnowledgeBases.defaultExpectation.params) {
			mmListKnowledgeBases.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListKnowledgeBases.defaultExpectation.params)
		}
	}

	return mmListKnowledgeBases
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.ListKnowledgeBases
func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockListKnowledgeBases {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBases mock is already set by Set")
	}

	if mmListKnowledgeBases.defaultExpectation == nil {
		mmListKnowledgeBases.defaultExpectation = &RepositoryIMockListKnowledgeBasesExpectation{}
	}

	if mmListKnowledgeBases.defaultExpectation.params != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBases mock is already set by Expect")
	}

	if mmListKnowledgeBases.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBases.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBasesParamPtrs{}
	}
	mmListKnowledgeBases.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListKnowledgeBases
}

// ExpectOwnerUIDParam2 sets up expected param ownerUID for RepositoryI.ListKnowledgeBases
func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) ExpectOwnerUIDParam2(ownerUID string) *mRepositoryIMockListKnowledgeBases {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBases mock is already set by Set")
	}

	if mmListKnowledgeBases.defaultExpectation == nil {
		mmListKnowledgeBases.defaultExpectation = &RepositoryIMockListKnowledgeBasesExpectation{}
	}

	if mmListKnowledgeBases.defaultExpectation.params != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBases mock is already set by Expect")
	}

	if mmListKnowledgeBases.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBases.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBasesParamPtrs{}
	}
	mmListKnowledgeBases.defaultExpectation.paramPtrs.ownerUID = &ownerUID

	return mmListKnowledgeBases
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.ListKnowledgeBases
func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) Inspect(f func(ctx context.Context, ownerUID string)) *mRepositoryIMockListKnowledgeBases {
	if mmListKnowledgeBases.mock.inspectFuncListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.ListKnowledgeBases")
	}

	mmListKnowledgeBases.mock.inspectFuncListKnowledgeBases = f

	return mmListKnowledgeBases
}

// Return sets up results that will be returned by RepositoryI.ListKnowledgeBases
func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) Return(ka1 []mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBases mock is already set by Set")
	}

	if mmListKnowledgeBases.defaultExpectation == nil {
		mmListKnowledgeBases.defaultExpectation = &RepositoryIMockListKnowledgeBasesExpectation{mock: mmListKnowledgeBases.mock}
	}
	mmListKnowledgeBases.defaultExpectation.results = &RepositoryIMockListKnowledgeBasesResults{ka1, err}
	return mmListKnowledgeBases.mock
}

// Set uses given function f to mock the RepositoryI.ListKnowledgeBases method
func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) Set(f func(ctx context.Context, ownerUID string) (ka1 []mm_repository.KnowledgeBase, err error)) *RepositoryIMock {
	if mmListKnowledgeBases.defaultExpectation != nil {
		mmListKnowledgeBases.mock.t.Fatalf("Default expectation is already set for the RepositoryI.ListKnowledgeBases method")
	}

	if len(mmListKnowledgeBases.expectations) > 0 {
		mmListKnowledgeBases.mock.t.Fatalf("Some expectations are already set for the RepositoryI.ListKnowledgeBases method")
	}

	mmListKnowledgeBases.mock.funcListKnowledgeBases = f
	return mmListKnowledgeBases.mock
}

// When sets expectation for the RepositoryI.ListKnowledgeBases which will trigger the result defined by the following
// Then helper
func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) When(ctx context.Context, ownerUID string) *RepositoryIMockListKnowledgeBasesExpectation {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBases mock is already set by Set")
	}

	expectation := &RepositoryIMockListKnowledgeBasesExpectation{
		mock:   mmListKnowledgeBases.mock,
		params: &RepositoryIMockListKnowledgeBasesParams{ctx, ownerUID},
	}
	mmListKnowledgeBases.expectations = append(mmListKnowledgeBases.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.ListKnowledgeBases return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockListKnowledgeBasesExpectation) Then(ka1 []mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	e.results = &RepositoryIMockListKnowledgeBasesResults{ka1, err}
	return e.mock
}

// Times sets number of times RepositoryI.ListKnowledgeBases should be invoked
func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) Times(n uint64) *mRepositoryIMockListKnowledgeBases {
	if n == 0 {
		mmListKnowledgeBases.mock.t.Fatalf("Times of RepositoryIMock.ListKnowledgeBases mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListKnowledgeBases.expectedInvocations, n)
	return mmListKnowledgeBases
}

func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) invocationsDone() bool {
	if len(mmListKnowledgeBases.expectations) == 0 && mmListKnowledgeBases.defaultExpectation == nil && mmListKnowledgeBases.mock.funcListKnowledgeBases == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBases.mock.afterListKnowledgeBasesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBases.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListKnowledgeBases implements repository.RepositoryI
func (mmListKnowledgeBases *RepositoryIMock) ListKnowledgeBases(ctx context.Context, ownerUID string) (ka1 []mm_repository.KnowledgeBase, err error) {
	mm_atomic.AddUint64(&mmListKnowledgeBases.beforeListKnowledgeBasesCounter, 1)
	defer mm_atomic.AddUint64(&mmListKnowledgeBases.afterListKnowledgeBasesCounter, 1)

	if mmListKnowledgeBases.inspectFuncListKnowledgeBases != nil {
		mmListKnowledgeBases.inspectFuncListKnowledgeBases(ctx, ownerUID)
	}

	mm_params := RepositoryIMockListKnowledgeBasesParams{ctx, ownerUID}

	// Record call args
	mmListKnowledgeBases.ListKnowledgeBasesMock.mutex.Lock()
	mmListKnowledgeBases.ListKnowledgeBasesMock.callArgs = append(mmListKnowledgeBases.ListKnowledgeBasesMock.callArgs, &mm_params)
	mmListKnowledgeBases.ListKnowledgeBasesMock.mutex.Unlock()

	for _, e := range mmListKnowledgeBases.ListKnowledgeBasesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.Counter, 1)
		mm_want := mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.params
		mm_want_ptrs := mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockListKnowledgeBasesParams{ctx, ownerUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListKnowledgeBases.t.Errorf("RepositoryIMock.ListKnowledgeBases got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmListKnowledgeBases.t.Errorf("RepositoryIMock.ListKnowledgeBases got unexpected parameter ownerUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListKnowledgeBases.t.Errorf("RepositoryIMock.ListKnowledgeBases got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.results
		if mm_results == nil {
			mmListKnowledgeBases.t.Fatal("No results are set for the RepositoryIMock.ListKnowledgeBases")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmListKnowledgeBases.funcListKnowledgeBases != nil {
		return mmListKnowledgeBases.funcListKnowledgeBases(ctx, ownerUID)
	}
	mmListKnowledgeBases.t.Fatalf("Unexpected call to RepositoryIMock.ListKnowledgeBases. %v %v", ctx, ownerUID)
	return
}

// ListKnowledgeBasesAfterCounter returns a count of finished RepositoryIMock.ListKnowledgeBases invocations
func (mmListKnowledgeBases *RepositoryIMock) ListKnowledgeBasesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBases.afterListKnowledgeBasesCounter)
}

// ListKnowledgeBasesBeforeCounter returns a count of RepositoryIMock.ListKnowledgeBases invocations
func (mmListKnowledgeBases *RepositoryIMock) ListKnowledgeBasesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBases.beforeListKnowledgeBasesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.ListKnowledgeBases.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) Calls() []*RepositoryIMockListKnowledgeBasesParams {
	mmListKnowledgeBases.mutex.RLock()

	argCopy := make([]*RepositoryIMockListKnowledgeBasesParams, len(mmListKnowledgeBases.callArgs))
	copy(argCopy, mmListKnowledgeBases.callArgs)

	mmListKnowledgeBases.mutex.RUnlock()

	return argCopy
}

// MinimockListKnowledgeBasesDone returns true if the count of the ListKnowledgeBases invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockListKnowledgeBasesDone() bool {
	for _, e := range m.ListKnowledgeBasesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListKnowledgeBasesMock.invocationsDone()
}

// MinimockListKnowledgeBasesInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockListKnowledgeBasesInspect() {
	for _, e := range m.ListKnowledgeBasesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.ListKnowledgeBases with params: %#v", *e.params)
		}
	}

	afterListKnowledgeBasesCounter := mm_atomic.LoadUint64(&m.afterListKnowledgeBasesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListKnowledgeBasesMock.defaultExpectation != nil && afterListKnowledgeBasesCounter < 1 {
		if m.ListKnowledgeBasesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.ListKnowledgeBases")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.ListKnowledgeBases with params: %#v", *m.ListKnowledgeBasesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListKnowledgeBases != nil && afterListKnowledgeBasesCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.ListKnowledgeBases")
	}

	if !m.ListKnowledgeBasesMock.invocationsDone() && afterListKnowledgeBasesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.ListKnowledgeBases but found %d calls",
			mm_atomic.LoadUint64(&m.ListKnowledgeBasesMock.expectedInvocations), afterListKnowledgeBasesCounter)
	}
}

type mRepositoryIMockListMessages struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockListMessagesExpectation
	expectations       []*RepositoryIMockListMessagesExpectation

	callArgs []*RepositoryIMockListMessagesParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockListMessagesExpectation specifies expectation struct of the RepositoryI.ListMessages
type RepositoryIMockListMessagesExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockListMessagesParams
	paramPtrs *RepositoryIMockListMessagesParamPtrs
	results   *RepositoryIMockListMessagesResults
	Counter   uint64
}

// RepositoryIMockListMessagesParams contains parameters of the RepositoryI.ListMessages
type RepositoryIMockListMessagesParams struct {
	ctx                   context.Context
	namespaceUID          uuid.UUID
	catalogUID            uuid.UUID
	conversationUID       uuid.UUID
	latestK               int32
	pageSize              int32
	pageToken             string
	includeSystemMessages bool
}

// RepositoryIMockListMessagesParamPtrs contains pointers to parameters of the RepositoryI.ListMessages
type RepositoryIMockListMessagesParamPtrs struct {
	ctx                   *context.Context
	namespaceUID          *uuid.UUID
	catalogUID            *uuid.UUID
	conversationUID       *uuid.UUID
	latestK               *int32
	pageSize              *int32
	pageToken             *string
	includeSystemMessages *bool
}

// RepositoryIMockListMessagesResults contains results of the RepositoryI.ListMessages
type RepositoryIMockListMessagesResults struct {
	mpa1 []*mm_repository.Message
	s1   string
	i1   int64
	err  error
}

// Expect sets up expected params for RepositoryI.ListMessages
func (mmListMessages *mRepositoryIMockListMessages) Expect(ctx context.Context, namespaceUID uuid.UUID, catalogUID uuid.UUID, conversationUID uuid.UUID, latestK int32, pageSize int32, pageToken string, includeSystemMessages bool) *mRepositoryIMockListMessages {
	if mmListMessages.mock.funcListMessages != nil {
		mmListMessages.mock.t.Fatalf("RepositoryIMock.ListMessages mock is already set by Set")
	}

	if mmListMessages.defaultExpectation == nil {
		mmListMessages.defaultExpectation = &RepositoryIMockListMessagesExpectation{}
	}

	if mmListMessages.defaultExpectation.paramPtrs != nil {
		mmListMessages.mock.t.Fatalf("RepositoryIMock.ListMessages mock is already set by ExpectParams functions")
	}

	mmListMessages.defaultExpectation.params = &RepositoryIMockListMessagesParams{ctx, namespaceUID, catalogUID, conversationUID, latestK, pageSize, pageToken, includeSystemMessages}
	for _, e := range mmListMessages.expectations {
		if minimock.Equal(e.params, mmListMessages.defaultExpectation.params) {
			mmListMessages.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListMessages.defaultExpectation.params)
		}
	}

	return mmListMessages
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.ListMessages
func (mmListMessages *mRepositoryIMockListMessages) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockListMessages {
	if mmListMessages.mock.funcListMessages != nil {
		mmListMessages.mock.t.Fatalf("RepositoryIMock.ListMessages mock is already set by Set")
	}

	if mmListMessages.defaultExpectation == nil {
		mmListMessages.defaultExpectation = &RepositoryIMockListMessagesExpectation{}
	}

	if mmListMessages.defaultExpectation.params != nil {
		mmListMessages.mock.t.Fatalf("RepositoryIMock.ListMessages mock is already set by Expect")
	}

	if mmListMessages.defaultExpectation.paramPtrs == nil {
		mmListMessages.defaultExpectation.paramPtrs = &RepositoryIMockListMessagesParamPtrs{}
	}
	mmListMessages.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListMessages
}

// ExpectNamespaceUIDParam2 sets up expected param namespaceUID for RepositoryI.ListMessages
func (mmListMessages *mRepositoryIMockListMessages) ExpectNamespaceUIDParam2(namespaceUID uuid.UUID) *mRepositoryIMockListMessages {
	if mmListMessages.mock.funcListMessages != nil {
		mmListMessages.mock.t.Fatalf("RepositoryIMock.ListMessages mock is already set by Set")
	}

	if mmListMessages.defaultExpectation == nil {
		mmListMessages.defaultExpectation = &RepositoryIMockListMessagesExpectation{}
	}

	if mmListMessages.defaultExpectation.params != nil {
		mmListMessages.mock.t.Fatalf("RepositoryIMock.ListMessages mock is already set by Expect")
	}

	if mmListMessages.defaultExpectation.paramPtrs == nil {
		mmListMessages.defaultExpectation.paramPtrs = &RepositoryIMockListMessagesParamPtrs{}
	}
	mmListMessages.defaultExpectation.paramPtrs.namespaceUID = &namespaceUID

	return mmListMessages
}

// ExpectCatalogUIDParam3 sets up expected param catalogUID for RepositoryI.ListMessages
func (mmListMessages *mRepositoryIMockListMessages) ExpectCatalogUIDParam3(catalogUID uuid.UUID) *mRepositoryIMockListMessages {
	if mmListMessages.mock.funcListMessages != nil {
		mmListMessages.mock.t.Fatalf("RepositoryIMock.ListMessages mock is already set by Set")
	}

	if mmListMessages.defaultExpectation == nil {
		mmListMessages.defaultExpectation = &RepositoryIMockListMessagesExpectation{}
	}

	if mmListMessages.defaultExpectation.params != nil {
		mmListMessages.mock.t.Fatalf("RepositoryIMock.ListMessages mock is already set by Expect")
	}

	if mmListMessages.defaultExpectation.paramPtrs == nil {
		mmListMessages.defaultExpectation.paramPtrs = &RepositoryIMockListMessagesParamPtrs{}
	}
	mmListMessages.defaultExpectation.paramPtrs.catalogUID = &catalogUID

	return mmListMessages
}

// ExpectConversationUIDParam4 sets up expected param conversationUID for RepositoryI.ListMessages
func (mmListMessages *mRepositoryIMockListMessages) ExpectConversationUIDParam4(conversationUID uuid.UUID) *mRepositoryIMockListMessages {
	if mmListMessages.mock.funcListMessages != nil {
		mmListMessages.mock.t.Fatalf("RepositoryIMock.ListMessages mock is already set by Set")
	}

	if mmListMessages.defaultExpectation == nil {
		mmListMessages.defaultExpectation = &RepositoryIMockListMessagesExpectation{}
	}

	if mmListMessages.defaultExpectation.params != nil {
		mmListMessages.mock.t.Fatalf("RepositoryIMock.ListMessages mock is already set by Expect")
	}

	if mmListMessages.defaultExpectation.paramPtrs == nil {
		mmListMessages.defaultExpectation.paramPtrs = &RepositoryIMockListMessagesParamPtrs{}
	}
	mmListMessages.defaultExpectation.paramPtrs.conversationUID = &conversationUID

	return mmListMessages
}

// ExpectLatestKParam5 sets up expected param latestK for RepositoryI.ListMessages
func (mmListMessages *mRepositoryIMockListMessages) ExpectLatestKParam5(latestK int32) *mRepositoryIMockListMessages {
	if mmListMessages.mock.funcListMessages != nil {
		mmListMessages.mock.t.Fatalf("RepositoryIMock.ListMessages mock is already set by Set")
	}

	if mmListMessages.defaultExpectation == nil {
		mmListMessages.defaultExpectation = &RepositoryIMockListMessagesExpectation{}
	}

	if mmListMessages.defaultExpectation.params != nil {
		mmListMessages.mock.t.Fatalf("RepositoryIMock.ListMessages mock is already set by Expect")
	}

	if mmListMessages.defaultExpectation.paramPtrs == nil {
		mmListMessages.defaultExpectation.paramPtrs = &RepositoryIMockListMessagesParamPtrs{}
	}
	mmListMessages.defaultExpectation.paramPtrs.latestK = &latestK

	return mmListMessages
}

// ExpectPageSizeParam6 sets up expected param pageSize for RepositoryI.ListMessages
func (mmListMessages *mRepositoryIMockListMessages) ExpectPageSizeParam6(pageSize int32) *mRepositoryIMockListMessages {
	if mmListMessages.mock.funcListMessages != nil {
		mmListMessages.mock.t.Fatalf("RepositoryIMock.ListMessages mock is already set by Set")
	}

	if mmListMessages.defaultExpectation == nil {
		mmListMessages.defaultExpectation = &RepositoryIMockListMessagesExpectation{}
	}

	if mmListMessages.defaultExpectation.params != nil {
		mmListMessages.mock.t.Fatalf("RepositoryIMock.ListMessages mock is already set by Expect")
	}

	if mmListMessages.defaultExpectation.paramPtrs == nil {
		mmListMessages.defaultExpectation.paramPtrs = &RepositoryIMockListMessagesParamPtrs{}
	}
	mmListMessages.defaultExpectation.paramPtrs.pageSize = &pageSize

	return mmListMessages
}

// ExpectPageTokenParam7 sets up expected param pageToken for RepositoryI.ListMessages
func (mmListMessages *mRepositoryIMockListMessages) ExpectPageTokenParam7(pageToken string) *mRepositoryIMockListMessages {
	if mmListMessages.mock.funcListMessages != nil {
		mmListMessages.mock.t.Fatalf("RepositoryIMock.ListMessages mock is already set by Set")
	}

	if mmListMessages.defaultExpectation == nil {
		mmListMessages.defaultExpectation = &RepositoryIMockListMessagesExpectation{}
	}

	if mmListMessages.defaultExpectation.params != nil {
		mmListMessages.mock.t.Fatalf("RepositoryIMock.ListMessages mock is already set by Expect")
	}

	if mmListMessages.defaultExpectation.paramPtrs == nil {
		mmListMessages.defaultExpectation.paramPtrs = &RepositoryIMockListMessagesParamPtrs{}
	}
	mmListMessages.defaultExpectation.paramPtrs.pageToken = &pageToken

	return mmListMessages
}

// ExpectIncludeSystemMessagesParam8 sets up expected param includeSystemMessages for RepositoryI.ListMessages
func (mmListMessages *mRepositoryIMockListMessages) ExpectIncludeSystemMessagesParam8(includeSystemMessages bool) *mRepositoryIMockListMessages {
	if mmListMessages.mock.funcListMessages != nil {
		mmListMessages.mock.t.Fatalf("RepositoryIMock.ListMessages mock is already set by Set")
	}

	if mmListMessages.defaultExpectation == nil {
		mmListMessages.defaultExpectation = &RepositoryIMockListMessagesExpectation{}
	}

	if mmListMessages.defaultExpectation.params != nil {
		mmListMessages.mock.t.Fatalf("RepositoryIMock.ListMessages mock is already set by Expect")
	}

	if mmListMessages.defaultExpectation.paramPtrs == nil {
		mmListMessages.defaultExpectation.paramPtrs = &RepositoryIMockListMessagesParamPtrs{}
	}
	mmListMessages.defaultExpectation.paramPtrs.includeSystemMessages = &includeSystemMessages

	return mmListMessages
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.ListMessages
func (mmListMessages *mRepositoryIMockListMessages) Inspect(f func(ctx context.Context, namespaceUID uuid.UUID, catalogUID uuid.UUID, conversationUID uuid.UUID, latestK int32, pageSize int32, pageToken string, includeSystemMessages bool)) *mRepositoryIMockListMessages {
	if mmListMessages.mock.inspectFuncListMessages != nil {
		mmListMessages.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.ListMessages")
	}

	mmListMessages.mock.inspectFuncListMessages = f

	return mmListMessages
}

// Return sets up results that will be returned by RepositoryI.ListMessages
func (mmListMessages *mRepositoryIMockListMessages) Return(mpa1 []*mm_repository.Message, s1 string, i1 int64, err error) *RepositoryIMock {
	if mmListMessages.mock.funcListMessages != nil {
		mmListMessages.mock.t.Fatalf("RepositoryIMock.ListMessages mock is already set by Set")
	}

	if mmListMessages.defaultExpectation == nil {
		mmListMessages.defaultExpectation = &RepositoryIMockListMessagesExpectation{mock: mmListMessages.mock}
	}
	mmListMessages.defaultExpectation.results = &RepositoryIMockListMessagesResults{mpa1, s1, i1, err}
	return mmListMessages.mock
}

// Set uses given function f to mock the RepositoryI.ListMessages method
func (mmListMessages *mRepositoryIMockListMessages) Set(f func(ctx context.Context, namespaceUID uuid.UUID, catalogUID uuid.UUID, conversationUID uuid.UUID, latestK int32, pageSize int32, pageToken string, includeSystemMessages bool) (mpa1 []*mm_repository.Message, s1 string, i1 int64, err error)) *RepositoryIMock {
	if mmListMessages.defaultExpectation != nil {
		mmListMessages.mock.t.Fatalf("Default expectation is already set for the RepositoryI.ListMessages method")
	}

	if len(mmListMessages.expectations) > 0 {
		mmListMessages.mock.t.Fatalf("Some expectations are already set for the RepositoryI.ListMessages method")
	}

	mmListMessages.mock.funcListMessages = f
	return mmListMessages.mock
}

// When sets expectation for the RepositoryI.ListMessages which will trigger the result defined by the following
// Then helper
func (mmListMessages *mRepositoryIMockListMessages) When(ctx context.Context, namespaceUID uuid.UUID, catalogUID uuid.UUID, conversationUID uuid.UUID, latestK int32, pageSize int32, pageToken string, includeSystemMessages bool) *RepositoryIMockListMessagesExpectation {
	if mmListMessages.mock.funcListMessages != nil {
		mmListMessages.mock.t.Fatalf("RepositoryIMock.ListMessages mock is already set by Set")
	}

	expectation := &RepositoryIMockListMessagesExpectation{
		mock:   mmListMessages.mock,
		params: &RepositoryIMockListMessagesParams{ctx, namespaceUID, catalogUID, conversationUID, latestK, pageSize, pageToken, includeSystemMessages},
	}
	mmListMessages.expectations = append(mmListMessages.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.ListMessages return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockListMessagesExpectation) Then(mpa1 []*mm_repository.Message, s1 string, i1 int64, err error) *RepositoryIMock {
	e.results = &RepositoryIMockListMessagesResults{mpa1, s1, i1, err}
	return e.mock
}

// Times sets number of times RepositoryI.ListMessages should be invoked
func (mmListMessages *mRepositoryIMockListMessages) Times(n uint64) *mRepositoryIMockListMessages {
	if n == 0 {
		mmListMessages.mock.t.Fatalf("Times of RepositoryIMock.ListMessages mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListMessages.expectedInvocations, n)
	return mmListMessages
}

func (mmListMessages *mRepositoryIMockListMessages) invocationsDone() bool {
	if len(mmListMessages.expectations) == 0 && mmListMessages.defaultExpectation == nil && mmListMessages.mock.funcListMessages == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListMessages.mock.afterListMessagesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListMessages.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListMessages implements repository.RepositoryI
func (mmListMessages *RepositoryIMock) ListMessages(ctx context.Context, namespaceUID uuid.UUID, catalogUID uuid.UUID, conversationUID uuid.UUID, latestK int32, pageSize int32, pageToken string, includeSystemMessages bool) (mpa1 []*mm_repository.Message, s1 string, i1 int64, err error) {
	mm_atomic.AddUint64(&mmListMessages.beforeListMessagesCounter, 1)
	defer mm_atomic.AddUint64(&mmListMessages.afterListMessagesCounter, 1)

	if mmListMessages.inspectFuncListMessages != nil {
		mmListMessages.inspectFuncListMessages(ctx, namespaceUID, catalogUID, conversationUID, latestK, pageSize, pageToken, includeSystemMessages)
	}

	mm_params := RepositoryIMockListMessagesParams{ctx, namespaceUID, catalogUID, conversationUID, latestK, pageSize, pageToken, includeSystemMessages}

	// Record call args
	mmListMessages.ListMessagesMock.mutex.Lock()
	mmListMessages.ListMessagesMock.callArgs = append(mmListMessages.ListMessagesMock.callArgs, &mm_params)
	mmListMessages.ListMessagesMock.mutex.Unlock()

	for _, e := range mmListMessages.ListMessagesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mpa1, e.results.s1, e.results.i1, e.results.err
		}
	}

	if mmListMessages.ListMessagesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListMessages.ListMessagesMock.defaultExpectation.Counter, 1)
		mm_want := mmListMessages.ListMessagesMock.defaultExpectation.params
		mm_want_ptrs := mmListMessages.ListMessagesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockListMessagesParams{ctx, namespaceUID, catalogUID, conversationUID, latestK, pageSize, pageToken, includeSystemMessages}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListMessages.t.Errorf("RepositoryIMock.ListMessages got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.namespaceUID != nil && !minimock.Equal(*mm_want_ptrs.namespaceUID, mm_got.namespaceUID) {
				mmListMessages.t.Errorf("RepositoryIMock.ListMessages got unexpected parameter namespaceUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.namespaceUID, mm_got.namespaceUID, minimock.Diff(*mm_want_ptrs.namespaceUID, mm_got.namespaceUID))
			}

			if mm_want_ptrs.catalogUID != nil && !minimock.Equal(*mm_want_ptrs.catalogUID, mm_got.catalogUID) {
				mmListMessages.t.Errorf("RepositoryIMock.ListMessages got unexpected parameter catalogUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.catalogUID, mm_got.catalogUID, minimock.Diff(*mm_want_ptrs.catalogUID, mm_got.catalogUID))
			}

			if mm_want_ptrs.conversationUID != nil && !minimock.Equal(*mm_want_ptrs.conversationUID, mm_got.conversationUID) {
				mmListMessages.t.Errorf("RepositoryIMock.ListMessages got unexpected parameter conversationUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.conversationUID, mm_got.conversationUID, minimock.Diff(*mm_want_ptrs.conversationUID, mm_got.conversationUID))
			}

			if mm_want_ptrs.latestK != nil && !minimock.Equal(*mm_want_ptrs.latestK, mm_got.latestK) {
				mmListMessages.t.Errorf("RepositoryIMock.ListMessages got unexpected parameter latestK, want: %#v, got: %#v%s\n", *mm_want_ptrs.latestK, mm_got.latestK, minimock.Diff(*mm_want_ptrs.latestK, mm_got.latestK))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListMessages.t.Errorf("RepositoryIMock.ListMessages got unexpected parameter pageSize, want: %#v, got: %#v%s\n", *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.pageToken != nil && !minimock.Equal(*mm_want_ptrs.pageToken, mm_got.pageToken) {
				mmListMessages.t.Errorf("RepositoryIMock.ListMessages got unexpected parameter pageToken, want: %#v, got: %#v%s\n", *mm_want_ptrs.pageToken, mm_got.pageToken, minimock.Diff(*mm_want_ptrs.pageToken, mm_got.pageToken))
			}

			if mm_want_ptrs.includeSystemMessages != nil && !minimock.Equal(*mm_want_ptrs.includeSystemMessages, mm_got.includeSystemMessages) {
				mmListMessages.t.Errorf("RepositoryIMock.ListMessages got unexpected parameter includeSystemMessages, want: %#v, got: %#v%s\n", *mm_want_ptrs.includeSystemMessages, mm_got.includeSystemMessages, minimock.Diff(*mm_want_ptrs.includeSystemMessages, mm_got.includeSystemMessages))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListMessages.t.Errorf("RepositoryIMock.ListMessages got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListMessages.ListMessagesMock.defaultExpectation.results
		if mm_results == nil {
			mmListMessages.t.Fatal("No results are set for the RepositoryIMock.ListMessages")
		}
		return (*mm_results).mpa1, (*mm_results).s1, (*mm_results).i1, (*mm_results).err
	}
	if mmListMessages.funcListMessages != nil {
		return mmListMessages.funcListMessages(ctx, namespaceUID, catalogUID, conversationUID, latestK, pageSize, pageToken, includeSystemMessages)
	}
	mmListMessages.t.Fatalf("Unexpected call to RepositoryIMock.ListMessages. %v %v %v %v %v %v %v %v", ctx, namespaceUID, catalogUID, conversationUID, latestK, pageSize, pageToken, includeSystemMessages)
	return
}

// ListMessagesAfterCounter returns a count of finished RepositoryIMock.ListMessages invocations
func (mmListMessages *RepositoryIMock) ListMessagesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListMessages.afterListMessagesCounter)
}

// ListMessagesBeforeCounter returns a count of RepositoryIMock.ListMessages invocations
func (mmListMessages *RepositoryIMock) ListMessagesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListMessages.beforeListMessagesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.ListMessages.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListMessages *mRepositoryIMockListMessages) Calls() []*RepositoryIMockListMessagesParams {
	mmListMessages.mutex.RLock()

	argCopy := make([]*RepositoryIMockListMessagesParams, len(mmListMessages.callArgs))
	copy(argCopy, mmListMessages.callArgs)

	mmListMessages.mutex.RUnlock()

	return argCopy
}

// MinimockListMessagesDone returns true if the count of the ListMessages invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockListMessagesDone() bool {
	for _, e := range m.ListMessagesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListMessagesMock.invocationsDone()
}

// MinimockListMessagesInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockListMessagesInspect() {
	for _, e := range m.ListMessagesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.ListMessages with params: %#v", *e.params)
		}
	}

	afterListMessagesCounter := mm_atomic.LoadUint64(&m.afterListMessagesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListMessagesMock.defaultExpectation != nil && afterListMessagesCounter < 1 {
		if m.ListMessagesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.ListMessages")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.ListMessages with params: %#v", *m.ListMessagesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListMessages != nil && afterListMessagesCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.ListMessages")
	}

	if !m.ListMessagesMock.invocationsDone() && afterListMessagesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.ListMessages but found %d calls",
			mm_atomic.LoadUint64(&m.ListMessagesMock.expectedInvocations), afterListMessagesCounter)
	}
}

type mRepositoryIMockMessageTableName struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockMessageTableNameExpectation
	expectations       []*RepositoryIMockMessageTableNameExpectation

	expectedInvocations uint64
}

// RepositoryIMockMessageTableNameExpectation specifies expectation struct of the RepositoryI.MessageTableName
type RepositoryIMockMessageTableNameExpectation struct {
	mock *RepositoryIMock

	results *RepositoryIMockMessageTableNameResults
	Counter uint64
}

// RepositoryIMockMessageTableNameResults contains results of the RepositoryI.MessageTableName
type RepositoryIMockMessageTableNameResults struct {
	s1 string
}

// Expect sets up expected params for RepositoryI.MessageTableName
func (mmMessageTableName *mRepositoryIMockMessageTableName) Expect() *mRepositoryIMockMessageTableName {
	if mmMessageTableName.mock.funcMessageTableName != nil {
		mmMessageTableName.mock.t.Fatalf("RepositoryIMock.MessageTableName mock is already set by Set")
	}

	if mmMessageTableName.defaultExpectation == nil {
		mmMessageTableName.defaultExpectation = &RepositoryIMockMessageTableNameExpectation{}
	}

	return mmMessageTableName
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.MessageTableName
func (mmMessageTableName *mRepositoryIMockMessageTableName) Inspect(f func()) *mRepositoryIMockMessageTableName {
	if mmMessageTableName.mock.inspectFuncMessageTableName != nil {
		mmMessageTableName.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.MessageTableName")
	}

	mmMessageTableName.mock.inspectFuncMessageTableName = f

	return mmMessageTableName
}

// Return sets up results that will be returned by RepositoryI.MessageTableName
func (mmMessageTableName *mRepositoryIMockMessageTableName) Return(s1 string) *RepositoryIMock {
	if mmMessageTableName.mock.funcMessageTableName != nil {
		mmMessageTableName.mock.t.Fatalf("RepositoryIMock.MessageTableName mock is already set by Set")
	}

	if mmMessageTableName.defaultExpectation == nil {
		mmMessageTableName.defaultExpectation = &RepositoryIMockMessageTableNameExpectation{mock: mmMessageTableName.mock}
	}
	mmMessageTableName.defaultExpectation.results = &RepositoryIMockMessageTableNameResults{s1}
	return mmMessageTableName.mock
}

// Set uses given function f to mock the RepositoryI.MessageTableName method
func (mmMessageTableName *mRepositoryIMockMessageTableName) Set(f func() (s1 string)) *RepositoryIMock {
	if mmMessageTableName.defaultExpectation != nil {
		mmMessageTableName.mock.t.Fatalf("Default expectation is already set for the RepositoryI.MessageTableName method")
	}

	if len(mmMessageTableName.expectations) > 0 {
		mmMessageTableName.mock.t.Fatalf("Some expectations are already set for the RepositoryI.MessageTableName method")
	}

	mmMessageTableName.mock.funcMessageTableName = f
	return mmMessageTableName.mock
}

// Times sets number of times RepositoryI.MessageTableName should be invoked
func (mmMessageTableName *mRepositoryIMockMessageTableName) Times(n uint64) *mRepositoryIMockMessageTableName {
	if n == 0 {
		mmMessageTableName.mock.t.Fatalf("Times of RepositoryIMock.MessageTableName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmMessageTableName.expectedInvocations, n)
	return mmMessageTableName
}

func (mmMessageTableName *mRepositoryIMockMessageTableName) invocationsDone() bool {
	if len(mmMessageTableName.expectations) == 0 && mmMessageTableName.defaultExpectation == nil && mmMessageTableName.mock.funcMessageTableName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmMessageTableName.mock.afterMessageTableNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmMessageTableName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// MessageTableName implements repository.RepositoryI
func (mmMessageTableName *RepositoryIMock) MessageTableName() (s1 string) {
	mm_atomic.AddUint64(&mmMessageTableName.beforeMessageTableNameCounter, 1)
	defer mm_atomic.AddUint64(&mmMessageTableName.afterMessageTableNameCounter, 1)

	if mmMessageTableName.inspectFuncMessageTableName != nil {
		mmMessageTableName.inspectFuncMessageTableName()
	}

	if mmMessageTableName.MessageTableNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMessageTableName.MessageTableNameMock.defaultExpectation.Counter, 1)

		mm_results := mmMessageTableName.MessageTableNameMock.defaultExpectation.results
		if mm_results == nil {
			mmMessageTableName.t.Fatal("No results are set for the RepositoryIMock.MessageTableName")
		}
		return (*mm_results).s1
	}
	if mmMessageTableName.funcMessageTableName != nil {
		return mmMessageTableName.funcMessageTableName()
	}
	mmMessageTableName.t.Fatalf("Unexpected call to RepositoryIMock.MessageTableName.")
	return
}

// MessageTableNameAfterCounter returns a count of finished RepositoryIMock.MessageTableName invocations
func (mmMessageTableName *RepositoryIMock) MessageTableNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMessageTableName.afterMessageTableNameCounter)
}

// MessageTableNameBeforeCounter returns a count of RepositoryIMock.MessageTableName invocations
func (mmMessageTableName *RepositoryIMock) MessageTableNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMessageTableName.beforeMessageTableNameCounter)
}

// MinimockMessageTableNameDone returns true if the count of the MessageTableName invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockMessageTableNameDone() bool {
	for _, e := range m.MessageTableNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.MessageTableNameMock.invocationsDone()
}

// MinimockMessageTableNameInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockMessageTableNameInspect() {
	for _, e := range m.MessageTableNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryIMock.MessageTableName")
		}
	}

	afterMessageTableNameCounter := mm_atomic.LoadUint64(&m.afterMessageTableNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.MessageTableNameMock.defaultExpectation != nil && afterMessageTableNameCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.MessageTableName")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMessageTableName != nil && afterMessageTableNameCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.MessageTableName")
	}

	if !m.MessageTableNameMock.invocationsDone() && afterMessageTableNameCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.MessageTableName but found %d calls",
			mm_atomic.LoadUint64(&m.MessageTableNameMock.expectedInvocations), afterMessageTableNameCounter)
	}
}

type mRepositoryIMockProcessKnowledgeBaseFiles struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockProcessKnowledgeBaseFilesExpectation
	expectations       []*RepositoryIMockProcessKnowledgeBaseFilesExpectation

	callArgs []*RepositoryIMockProcessKnowledgeBaseFilesParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockProcessKnowledgeBaseFilesExpectation specifies expectation struct of the RepositoryI.ProcessKnowledgeBaseFiles
type RepositoryIMockProcessKnowledgeBaseFilesExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockProcessKnowledgeBaseFilesParams
	paramPtrs *RepositoryIMockProcessKnowledgeBaseFilesParamPtrs
	results   *RepositoryIMockProcessKnowledgeBaseFilesResults
	Counter   uint64
}

// RepositoryIMockProcessKnowledgeBaseFilesParams contains parameters of the RepositoryI.ProcessKnowledgeBaseFiles
type RepositoryIMockProcessKnowledgeBaseFilesParams struct {
	ctx       context.Context
	fileUIDs  []string
	requester uuid.UUID
}

// RepositoryIMockProcessKnowledgeBaseFilesParamPtrs contains pointers to parameters of the RepositoryI.ProcessKnowledgeBaseFiles
type RepositoryIMockProcessKnowledgeBaseFilesParamPtrs struct {
	ctx       *context.Context
	fileUIDs  *[]string
	requester *uuid.UUID
}

// RepositoryIMockProcessKnowledgeBaseFilesResults contains results of the RepositoryI.ProcessKnowledgeBaseFiles
type RepositoryIMockProcessKnowledgeBaseFilesResults struct {
	ka1 []mm_repository.KnowledgeBaseFile
	err error
}

// Expect sets up expected params for RepositoryI.ProcessKnowledgeBaseFiles
func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) Expect(ctx context.Context, fileUIDs []string, requester uuid.UUID) *mRepositoryIMockProcessKnowledgeBaseFiles {
	if mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ProcessKnowledgeBaseFiles mock is already set by Set")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockProcessKnowledgeBaseFilesExpectation{}
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ProcessKnowledgeBaseFiles mock is already set by ExpectParams functions")
	}

	mmProcessKnowledgeBaseFiles.defaultExpectation.params = &RepositoryIMockProcessKnowledgeBaseFilesParams{ctx, fileUIDs, requester}
	for _, e := range mmProcessKnowledgeBaseFiles.expectations {
		if minimock.Equal(e.params, mmProcessKnowledgeBaseFiles.defaultExpectation.params) {
			mmProcessKnowledgeBaseFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmProcessKnowledgeBaseFiles.defaultExpectation.params)
		}
	}

	return mmProcessKnowledgeBaseFiles
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.ProcessKnowledgeBaseFiles
func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockProcessKnowledgeBaseFiles {
	if mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ProcessKnowledgeBaseFiles mock is already set by Set")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockProcessKnowledgeBaseFilesExpectation{}
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ProcessKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockProcessKnowledgeBaseFilesParamPtrs{}
	}
	mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs.ctx = &ctx

	return mmProcessKnowledgeBaseFiles
}

// ExpectFileUIDsParam2 sets up expected param fileUIDs for RepositoryI.ProcessKnowledgeBaseFiles
func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) ExpectFileUIDsParam2(fileUIDs []string) *mRepositoryIMockProcessKnowledgeBaseFiles {
	if mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ProcessKnowledgeBaseFiles mock is already set by Set")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockProcessKnowledgeBaseFilesExpectation{}
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ProcessKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockProcessKnowledgeBaseFilesParamPtrs{}
	}
	mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs.fileUIDs = &fileUIDs

	return mmProcessKnowledgeBaseFiles
}

// ExpectRequesterParam3 sets up expected param requester for RepositoryI.ProcessKnowledgeBaseFiles
func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) ExpectRequesterParam3(requester uuid.UUID) *mRepositoryIMockProcessKnowledgeBaseFiles {
	if mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ProcessKnowledgeBaseFiles mock is already set by Set")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockProcessKnowledgeBaseFilesExpectation{}
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ProcessKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockProcessKnowledgeBaseFilesParamPtrs{}
	}
	mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs.requester = &requester

	return mmProcessKnowledgeBaseFiles
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.ProcessKnowledgeBaseFiles
func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) Inspect(f func(ctx context.Context, fileUIDs []string, requester uuid.UUID)) *mRepositoryIMockProcessKnowledgeBaseFiles {
	if mmProcessKnowledgeBaseFiles.mock.inspectFuncProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.ProcessKnowledgeBaseFiles")
	}

	mmProcessKnowledgeBaseFiles.mock.inspectFuncProcessKnowledgeBaseFiles = f

	return mmProcessKnowledgeBaseFiles
}

// Return sets up results that will be returned by RepositoryI.ProcessKnowledgeBaseFiles
func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) Return(ka1 []mm_repository.KnowledgeBaseFile, err error) *RepositoryIMock {
	if mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ProcessKnowledgeBaseFiles mock is already set by Set")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockProcessKnowledgeBaseFilesExpectation{mock: mmProcessKnowledgeBaseFiles.mock}
	}
	mmProcessKnowledgeBaseFiles.defaultExpectation.results = &RepositoryIMockProcessKnowledgeBaseFilesResults{ka1, err}
	return mmProcessKnowledgeBaseFiles.mock
}

// Set uses given function f to mock the RepositoryI.ProcessKnowledgeBaseFiles method
func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) Set(f func(ctx context.Context, fileUIDs []string, requester uuid.UUID) (ka1 []mm_repository.KnowledgeBaseFile, err error)) *RepositoryIMock {
	if mmProcessKnowledgeBaseFiles.defaultExpectation != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("Default expectation is already set for the RepositoryI.ProcessKnowledgeBaseFiles method")
	}

	if len(mmProcessKnowledgeBaseFiles.expectations) > 0 {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("Some expectations are already set for the RepositoryI.ProcessKnowledgeBaseFiles method")
	}

	mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles = f
	return mmProcessKnowledgeBaseFiles.mock
}

// When sets expectation for the RepositoryI.ProcessKnowledgeBaseFiles which will trigger the result defined by the following
// Then helper
func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) When(ctx context.Context, fileUIDs []string, requester uuid.UUID) *RepositoryIMockProcessKnowledgeBaseFilesExpectation {
	if mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ProcessKnowledgeBaseFiles mock is already set by Set")
	}

	expectation := &RepositoryIMockProcessKnowledgeBaseFilesExpectation{
		mock:   mmProcessKnowledgeBaseFiles.mock,
		params: &RepositoryIMockProcessKnowledgeBaseFilesParams{ctx, fileUIDs, requester},
	}
	mmProcessKnowledgeBaseFiles.expectations = append(mmProcessKnowledgeBaseFiles.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.ProcessKnowledgeBaseFiles return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockProcessKnowledgeBaseFilesExpectation) Then(ka1 []mm_repository.KnowledgeBaseFile, err error) *RepositoryIMock {
	e.results = &RepositoryIMockProcessKnowledgeBaseFilesResults{ka1, err}
	return e.mock
}

// Times sets number of times RepositoryI.ProcessKnowledgeBaseFiles should be invoked
func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) Times(n uint64) *mRepositoryIMockProcessKnowledgeBaseFiles {
	if n == 0 {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("Times of RepositoryIMock.ProcessKnowledgeBaseFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmProcessKnowledgeBaseFiles.expectedInvocations, n)
	return mmProcessKnowledgeBaseFiles
}

func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) invocationsDone() bool {
	if len(mmProcessKnowledgeBaseFiles.expectations) == 0 && mmProcessKnowledgeBaseFiles.defaultExpectation == nil && mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmProcessKnowledgeBaseFiles.mock.afterProcessKnowledgeBaseFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmProcessKnowledgeBaseFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ProcessKnowledgeBaseFiles implements repository.RepositoryI
func (mmProcessKnowledgeBaseFiles *RepositoryIMock) ProcessKnowledgeBaseFiles(ctx context.Context, fileUIDs []string, requester uuid.UUID) (ka1 []mm_repository.KnowledgeBaseFile, err error) {
	mm_atomic.AddUint64(&mmProcessKnowledgeBaseFiles.beforeProcessKnowledgeBaseFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmProcessKnowledgeBaseFiles.afterProcessKnowledgeBaseFilesCounter, 1)

	if mmProcessKnowledgeBaseFiles.inspectFuncProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.inspectFuncProcessKnowledgeBaseFiles(ctx, fileUIDs, requester)
	}

	mm_params := RepositoryIMockProcessKnowledgeBaseFilesParams{ctx, fileUIDs, requester}

	// Record call args
	mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.mutex.Lock()
	mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.callArgs = append(mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.callArgs, &mm_params)
	mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.mutex.Unlock()

	for _, e := range mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation.params
		mm_want_ptrs := mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockProcessKnowledgeBaseFilesParams{ctx, fileUIDs, requester}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmProcessKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ProcessKnowledgeBaseFiles got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUIDs != nil && !minimock.Equal(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs) {
				mmProcessKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ProcessKnowledgeBaseFiles got unexpected parameter fileUIDs, want: %#v, got: %#v%s\n", *mm_want_ptrs.fileUIDs, mm_got.fileUIDs, minimock.Diff(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs))
			}

			if mm_want_ptrs.requester != nil && !minimock.Equal(*mm_want_ptrs.requester, mm_got.requester) {
				mmProcessKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ProcessKnowledgeBaseFiles got unexpected parameter requester, want: %#v, got: %#v%s\n", *mm_want_ptrs.requester, mm_got.requester, minimock.Diff(*mm_want_ptrs.requester, mm_got.requester))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmProcessKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ProcessKnowledgeBaseFiles got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmProcessKnowledgeBaseFiles.t.Fatal("No results are set for the RepositoryIMock.ProcessKnowledgeBaseFiles")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmProcessKnowledgeBaseFiles.funcProcessKnowledgeBaseFiles != nil {
		return mmProcessKnowledgeBaseFiles.funcProcessKnowledgeBaseFiles(ctx, fileUIDs, requester)
	}
	mmProcessKnowledgeBaseFiles.t.Fatalf("Unexpected call to RepositoryIMock.ProcessKnowledgeBaseFiles. %v %v %v", ctx, fileUIDs, requester)
	return
}

// ProcessKnowledgeBaseFilesAfterCounter returns a count of finished RepositoryIMock.ProcessKnowledgeBaseFiles invocations
func (mmProcessKnowledgeBaseFiles *RepositoryIMock) ProcessKnowledgeBaseFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessKnowledgeBaseFiles.afterProcessKnowledgeBaseFilesCounter)
}

// ProcessKnowledgeBaseFilesBeforeCounter returns a count of RepositoryIMock.ProcessKnowledgeBaseFiles invocations
func (mmProcessKnowledgeBaseFiles *RepositoryIMock) ProcessKnowledgeBaseFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessKnowledgeBaseFiles.beforeProcessKnowledgeBaseFilesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.ProcessKnowledgeBaseFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) Calls() []*RepositoryIMockProcessKnowledgeBaseFilesParams {
	mmProcessKnowledgeBaseFiles.mutex.RLock()

	argCopy := make([]*RepositoryIMockProcessKnowledgeBaseFilesParams, len(mmProcessKnowledgeBaseFiles.callArgs))
	copy(argCopy, mmProcessKnowledgeBaseFiles.callArgs)

	mmProcessKnowledgeBaseFiles.mutex.RUnlock()

	return argCopy
}

// MinimockProcessKnowledgeBaseFilesDone returns true if the count of the ProcessKnowledgeBaseFiles invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockProcessKnowledgeBaseFilesDone() bool {
	for _, e := range m.ProcessKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ProcessKnowledgeBaseFilesMock.invocationsDone()
}

// MinimockProcessKnowledgeBaseFilesInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockProcessKnowledgeBaseFilesInspect() {
	for _, e := range m.ProcessKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.ProcessKnowledgeBaseFiles with params: %#v", *e.params)
		}
	}

	afterProcessKnowledgeBaseFilesCounter := mm_atomic.LoadUint64(&m.afterProcessKnowledgeBaseFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ProcessKnowledgeBaseFilesMock.defaultExpectation != nil && afterProcessKnowledgeBaseFilesCounter < 1 {
		if m.ProcessKnowledgeBaseFilesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.ProcessKnowledgeBaseFiles")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.ProcessKnowledgeBaseFiles with params: %#v", *m.ProcessKnowledgeBaseFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProcessKnowledgeBaseFiles != nil && afterProcessKnowledgeBaseFilesCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.ProcessKnowledgeBaseFiles")
	}

	if !m.ProcessKnowledgeBaseFilesMock.invocationsDone() && afterProcessKnowledgeBaseFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.ProcessKnowledgeBaseFiles but found %d calls",
			mm_atomic.LoadUint64(&m.ProcessKnowledgeBaseFilesMock.expectedInvocations), afterProcessKnowledgeBaseFilesCounter)
	}
}

type mRepositoryIMockSoftDeleteConversation struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockSoftDeleteConversationExpectation
	expectations       []*RepositoryIMockSoftDeleteConversationExpectation

	callArgs []*RepositoryIMockSoftDeleteConversationParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockSoftDeleteConversationExpectation specifies expectation struct of the RepositoryI.SoftDeleteConversation
type RepositoryIMockSoftDeleteConversationExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockSoftDeleteConversationParams
	paramPtrs *RepositoryIMockSoftDeleteConversationParamPtrs
	results   *RepositoryIMockSoftDeleteConversationResults
	Counter   uint64
}

// RepositoryIMockSoftDeleteConversationParams contains parameters of the RepositoryI.SoftDeleteConversation
type RepositoryIMockSoftDeleteConversationParams struct {
	ctx            context.Context
	namespaceUID   uuid.UUID
	catalogUID     uuid.UUID
	conversationID string
}

// RepositoryIMockSoftDeleteConversationParamPtrs contains pointers to parameters of the RepositoryI.SoftDeleteConversation
type RepositoryIMockSoftDeleteConversationParamPtrs struct {
	ctx            *context.Context
	namespaceUID   *uuid.UUID
	catalogUID     *uuid.UUID
	conversationID *string
}

// RepositoryIMockSoftDeleteConversationResults contains results of the RepositoryI.SoftDeleteConversation
type RepositoryIMockSoftDeleteConversationResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.SoftDeleteConversation
func (mmSoftDeleteConversation *mRepositoryIMockSoftDeleteConversation) Expect(ctx context.Context, namespaceUID uuid.UUID, catalogUID uuid.UUID, conversationID string) *mRepositoryIMockSoftDeleteConversation {
	if mmSoftDeleteConversation.mock.funcSoftDeleteConversation != nil {
		mmSoftDeleteConversation.mock.t.Fatalf("RepositoryIMock.SoftDeleteConversation mock is already set by Set")
	}

	if mmSoftDeleteConversation.defaultExpectation == nil {
		mmSoftDeleteConversation.defaultExpectation = &RepositoryIMockSoftDeleteConversationExpectation{}
	}

	if mmSoftDeleteConversation.defaultExpectation.paramPtrs != nil {
		mmSoftDeleteConversation.mock.t.Fatalf("RepositoryIMock.SoftDeleteConversation mock is already set by ExpectParams functions")
	}

	mmSoftDeleteConversation.defaultExpectation.params = &RepositoryIMockSoftDeleteConversationParams{ctx, namespaceUID, catalogUID, conversationID}
	for _, e := range mmSoftDeleteConversation.expectations {
		if minimock.Equal(e.params, mmSoftDeleteConversation.defaultExpectation.params) {
			mmSoftDeleteConversation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSoftDeleteConversation.defaultExpectation.params)
		}
	}

	return mmSoftDeleteConversation
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.SoftDeleteConversation
func (mmSoftDeleteConversation *mRepositoryIMockSoftDeleteConversation) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockSoftDeleteConversation {
	if mmSoftDeleteConversation.mock.funcSoftDeleteConversation != nil {
		mmSoftDeleteConversation.mock.t.Fatalf("RepositoryIMock.SoftDeleteConversation mock is already set by Set")
	}

	if mmSoftDeleteConversation.defaultExpectation == nil {
		mmSoftDeleteConversation.defaultExpectation = &RepositoryIMockSoftDeleteConversationExpectation{}
	}

	if mmSoftDeleteConversation.defaultExpectation.params != nil {
		mmSoftDeleteConversation.mock.t.Fatalf("RepositoryIMock.SoftDeleteConversation mock is already set by Expect")
	}

	if mmSoftDeleteConversation.defaultExpectation.paramPtrs == nil {
		mmSoftDeleteConversation.defaultExpectation.paramPtrs = &RepositoryIMockSoftDeleteConversationParamPtrs{}
	}
	mmSoftDeleteConversation.defaultExpectation.paramPtrs.ctx = &ctx

	return mmSoftDeleteConversation
}

// ExpectNamespaceUIDParam2 sets up expected param namespaceUID for RepositoryI.SoftDeleteConversation
func (mmSoftDeleteConversation *mRepositoryIMockSoftDeleteConversation) ExpectNamespaceUIDParam2(namespaceUID uuid.UUID) *mRepositoryIMockSoftDeleteConversation {
	if mmSoftDeleteConversation.mock.funcSoftDeleteConversation != nil {
		mmSoftDeleteConversation.mock.t.Fatalf("RepositoryIMock.SoftDeleteConversation mock is already set by Set")
	}

	if mmSoftDeleteConversation.defaultExpectation == nil {
		mmSoftDeleteConversation.defaultExpectation = &RepositoryIMockSoftDeleteConversationExpectation{}
	}

	if mmSoftDeleteConversation.defaultExpectation.params != nil {
		mmSoftDeleteConversation.mock.t.Fatalf("RepositoryIMock.SoftDeleteConversation mock is already set by Expect")
	}

	if mmSoftDeleteConversation.defaultExpectation.paramPtrs == nil {
		mmSoftDeleteConversation.defaultExpectation.paramPtrs = &RepositoryIMockSoftDeleteConversationParamPtrs{}
	}
	mmSoftDeleteConversation.defaultExpectation.paramPtrs.namespaceUID = &namespaceUID

	return mmSoftDeleteConversation
}

// ExpectCatalogUIDParam3 sets up expected param catalogUID for RepositoryI.SoftDeleteConversation
func (mmSoftDeleteConversation *mRepositoryIMockSoftDeleteConversation) ExpectCatalogUIDParam3(catalogUID uuid.UUID) *mRepositoryIMockSoftDeleteConversation {
	if mmSoftDeleteConversation.mock.funcSoftDeleteConversation != nil {
		mmSoftDeleteConversation.mock.t.Fatalf("RepositoryIMock.SoftDeleteConversation mock is already set by Set")
	}

	if mmSoftDeleteConversation.defaultExpectation == nil {
		mmSoftDeleteConversation.defaultExpectation = &RepositoryIMockSoftDeleteConversationExpectation{}
	}

	if mmSoftDeleteConversation.defaultExpectation.params != nil {
		mmSoftDeleteConversation.mock.t.Fatalf("RepositoryIMock.SoftDeleteConversation mock is already set by Expect")
	}

	if mmSoftDeleteConversation.defaultExpectation.paramPtrs == nil {
		mmSoftDeleteConversation.defaultExpectation.paramPtrs = &RepositoryIMockSoftDeleteConversationParamPtrs{}
	}
	mmSoftDeleteConversation.defaultExpectation.paramPtrs.catalogUID = &catalogUID

	return mmSoftDeleteConversation
}

// ExpectConversationIDParam4 sets up expected param conversationID for RepositoryI.SoftDeleteConversation
func (mmSoftDeleteConversation *mRepositoryIMockSoftDeleteConversation) ExpectConversationIDParam4(conversationID string) *mRepositoryIMockSoftDeleteConversation {
	if mmSoftDeleteConversation.mock.funcSoftDeleteConversation != nil {
		mmSoftDeleteConversation.mock.t.Fatalf("RepositoryIMock.SoftDeleteConversation mock is already set by Set")
	}

	if mmSoftDeleteConversation.defaultExpectation == nil {
		mmSoftDeleteConversation.defaultExpectation = &RepositoryIMockSoftDeleteConversationExpectation{}
	}

	if mmSoftDeleteConversation.defaultExpectation.params != nil {
		mmSoftDeleteConversation.mock.t.Fatalf("RepositoryIMock.SoftDeleteConversation mock is already set by Expect")
	}

	if mmSoftDeleteConversation.defaultExpectation.paramPtrs == nil {
		mmSoftDeleteConversation.defaultExpectation.paramPtrs = &RepositoryIMockSoftDeleteConversationParamPtrs{}
	}
	mmSoftDeleteConversation.defaultExpectation.paramPtrs.conversationID = &conversationID

	return mmSoftDeleteConversation
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.SoftDeleteConversation
func (mmSoftDeleteConversation *mRepositoryIMockSoftDeleteConversation) Inspect(f func(ctx context.Context, namespaceUID uuid.UUID, catalogUID uuid.UUID, conversationID string)) *mRepositoryIMockSoftDeleteConversation {
	if mmSoftDeleteConversation.mock.inspectFuncSoftDeleteConversation != nil {
		mmSoftDeleteConversation.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.SoftDeleteConversation")
	}

	mmSoftDeleteConversation.mock.inspectFuncSoftDeleteConversation = f

	return mmSoftDeleteConversation
}

// Return sets up results that will be returned by RepositoryI.SoftDeleteConversation
func (mmSoftDeleteConversation *mRepositoryIMockSoftDeleteConversation) Return(err error) *RepositoryIMock {
	if mmSoftDeleteConversation.mock.funcSoftDeleteConversation != nil {
		mmSoftDeleteConversation.mock.t.Fatalf("RepositoryIMock.SoftDeleteConversation mock is already set by Set")
	}

	if mmSoftDeleteConversation.defaultExpectation == nil {
		mmSoftDeleteConversation.defaultExpectation = &RepositoryIMockSoftDeleteConversationExpectation{mock: mmSoftDeleteConversation.mock}
	}
	mmSoftDeleteConversation.defaultExpectation.results = &RepositoryIMockSoftDeleteConversationResults{err}
	return mmSoftDeleteConversation.mock
}

// Set uses given function f to mock the RepositoryI.SoftDeleteConversation method
func (mmSoftDeleteConversation *mRepositoryIMockSoftDeleteConversation) Set(f func(ctx context.Context, namespaceUID uuid.UUID, catalogUID uuid.UUID, conversationID string) (err error)) *RepositoryIMock {
	if mmSoftDeleteConversation.defaultExpectation != nil {
		mmSoftDeleteConversation.mock.t.Fatalf("Default expectation is already set for the RepositoryI.SoftDeleteConversation method")
	}

	if len(mmSoftDeleteConversation.expectations) > 0 {
		mmSoftDeleteConversation.mock.t.Fatalf("Some expectations are already set for the RepositoryI.SoftDeleteConversation method")
	}

	mmSoftDeleteConversation.mock.funcSoftDeleteConversation = f
	return mmSoftDeleteConversation.mock
}

// When sets expectation for the RepositoryI.SoftDeleteConversation which will trigger the result defined by the following
// Then helper
func (mmSoftDeleteConversation *mRepositoryIMockSoftDeleteConversation) When(ctx context.Context, namespaceUID uuid.UUID, catalogUID uuid.UUID, conversationID string) *RepositoryIMockSoftDeleteConversationExpectation {
	if mmSoftDeleteConversation.mock.funcSoftDeleteConversation != nil {
		mmSoftDeleteConversation.mock.t.Fatalf("RepositoryIMock.SoftDeleteConversation mock is already set by Set")
	}

	expectation := &RepositoryIMockSoftDeleteConversationExpectation{
		mock:   mmSoftDeleteConversation.mock,
		params: &RepositoryIMockSoftDeleteConversationParams{ctx, namespaceUID, catalogUID, conversationID},
	}
	mmSoftDeleteConversation.expectations = append(mmSoftDeleteConversation.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.SoftDeleteConversation return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockSoftDeleteConversationExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockSoftDeleteConversationResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.SoftDeleteConversation should be invoked
func (mmSoftDeleteConversation *mRepositoryIMockSoftDeleteConversation) Times(n uint64) *mRepositoryIMockSoftDeleteConversation {
	if n == 0 {
		mmSoftDeleteConversation.mock.t.Fatalf("Times of RepositoryIMock.SoftDeleteConversation mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSoftDeleteConversation.expectedInvocations, n)
	return mmSoftDeleteConversation
}

func (mmSoftDeleteConversation *mRepositoryIMockSoftDeleteConversation) invocationsDone() bool {
	if len(mmSoftDeleteConversation.expectations) == 0 && mmSoftDeleteConversation.defaultExpectation == nil && mmSoftDeleteConversation.mock.funcSoftDeleteConversation == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSoftDeleteConversation.mock.afterSoftDeleteConversationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSoftDeleteConversation.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SoftDeleteConversation implements repository.RepositoryI
func (mmSoftDeleteConversation *RepositoryIMock) SoftDeleteConversation(ctx context.Context, namespaceUID uuid.UUID, catalogUID uuid.UUID, conversationID string) (err error) {
	mm_atomic.AddUint64(&mmSoftDeleteConversation.beforeSoftDeleteConversationCounter, 1)
	defer mm_atomic.AddUint64(&mmSoftDeleteConversation.afterSoftDeleteConversationCounter, 1)

	if mmSoftDeleteConversation.inspectFuncSoftDeleteConversation != nil {
		mmSoftDeleteConversation.inspectFuncSoftDeleteConversation(ctx, namespaceUID, catalogUID, conversationID)
	}

	mm_params := RepositoryIMockSoftDeleteConversationParams{ctx, namespaceUID, catalogUID, conversationID}

	// Record call args
	mmSoftDeleteConversation.SoftDeleteConversationMock.mutex.Lock()
	mmSoftDeleteConversation.SoftDeleteConversationMock.callArgs = append(mmSoftDeleteConversation.SoftDeleteConversationMock.callArgs, &mm_params)
	mmSoftDeleteConversation.SoftDeleteConversationMock.mutex.Unlock()

	for _, e := range mmSoftDeleteConversation.SoftDeleteConversationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSoftDeleteConversation.SoftDeleteConversationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSoftDeleteConversation.SoftDeleteConversationMock.defaultExpectation.Counter, 1)
		mm_want := mmSoftDeleteConversation.SoftDeleteConversationMock.defaultExpectation.params
		mm_want_ptrs := mmSoftDeleteConversation.SoftDeleteConversationMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockSoftDeleteConversationParams{ctx, namespaceUID, catalogUID, conversationID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSoftDeleteConversation.t.Errorf("RepositoryIMock.SoftDeleteConversation got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.namespaceUID != nil && !minimock.Equal(*mm_want_ptrs.namespaceUID, mm_got.namespaceUID) {
				mmSoftDeleteConversation.t.Errorf("RepositoryIMock.SoftDeleteConversation got unexpected parameter namespaceUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.namespaceUID, mm_got.namespaceUID, minimock.Diff(*mm_want_ptrs.namespaceUID, mm_got.namespaceUID))
			}

			if mm_want_ptrs.catalogUID != nil && !minimock.Equal(*mm_want_ptrs.catalogUID, mm_got.catalogUID) {
				mmSoftDeleteConversation.t.Errorf("RepositoryIMock.SoftDeleteConversation got unexpected parameter catalogUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.catalogUID, mm_got.catalogUID, minimock.Diff(*mm_want_ptrs.catalogUID, mm_got.catalogUID))
			}

			if mm_want_ptrs.conversationID != nil && !minimock.Equal(*mm_want_ptrs.conversationID, mm_got.conversationID) {
				mmSoftDeleteConversation.t.Errorf("RepositoryIMock.SoftDeleteConversation got unexpected parameter conversationID, want: %#v, got: %#v%s\n", *mm_want_ptrs.conversationID, mm_got.conversationID, minimock.Diff(*mm_want_ptrs.conversationID, mm_got.conversationID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSoftDeleteConversation.t.Errorf("RepositoryIMock.SoftDeleteConversation got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSoftDeleteConversation.SoftDeleteConversationMock.defaultExpectation.results
		if mm_results == nil {
			mmSoftDeleteConversation.t.Fatal("No results are set for the RepositoryIMock.SoftDeleteConversation")
		}
		return (*mm_results).err
	}
	if mmSoftDeleteConversation.funcSoftDeleteConversation != nil {
		return mmSoftDeleteConversation.funcSoftDeleteConversation(ctx, namespaceUID, catalogUID, conversationID)
	}
	mmSoftDeleteConversation.t.Fatalf("Unexpected call to RepositoryIMock.SoftDeleteConversation. %v %v %v %v", ctx, namespaceUID, catalogUID, conversationID)
	return
}

// SoftDeleteConversationAfterCounter returns a count of finished RepositoryIMock.SoftDeleteConversation invocations
func (mmSoftDeleteConversation *RepositoryIMock) SoftDeleteConversationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSoftDeleteConversation.afterSoftDeleteConversationCounter)
}

// SoftDeleteConversationBeforeCounter returns a count of RepositoryIMock.SoftDeleteConversation invocations
func (mmSoftDeleteConversation *RepositoryIMock) SoftDeleteConversationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSoftDeleteConversation.beforeSoftDeleteConversationCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.SoftDeleteConversation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSoftDeleteConversation *mRepositoryIMockSoftDeleteConversation) Calls() []*RepositoryIMockSoftDeleteConversationParams {
	mmSoftDeleteConversation.mutex.RLock()

	argCopy := make([]*RepositoryIMockSoftDeleteConversationParams, len(mmSoftDeleteConversation.callArgs))
	copy(argCopy, mmSoftDeleteConversation.callArgs)

	mmSoftDeleteConversation.mutex.RUnlock()

	return argCopy
}

// MinimockSoftDeleteConversationDone returns true if the count of the SoftDeleteConversation invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockSoftDeleteConversationDone() bool {
	for _, e := range m.SoftDeleteConversationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SoftDeleteConversationMock.invocationsDone()
}

// MinimockSoftDeleteConversationInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockSoftDeleteConversationInspect() {
	for _, e := range m.SoftDeleteConversationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.SoftDeleteConversation with params: %#v", *e.params)
		}
	}

	afterSoftDeleteConversationCounter := mm_atomic.LoadUint64(&m.afterSoftDeleteConversationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SoftDeleteConversationMock.defaultExpectation != nil && afterSoftDeleteConversationCounter < 1 {
		if m.SoftDeleteConversationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.SoftDeleteConversation")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.SoftDeleteConversation with params: %#v", *m.SoftDeleteConversationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSoftDeleteConversation != nil && afterSoftDeleteConversationCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.SoftDeleteConversation")
	}

	if !m.SoftDeleteConversationMock.invocationsDone() && afterSoftDeleteConversationCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.SoftDeleteConversation but found %d calls",
			mm_atomic.LoadUint64(&m.SoftDeleteConversationMock.expectedInvocations), afterSoftDeleteConversationCounter)
	}
}

type mRepositoryIMockTextChunkTableName struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockTextChunkTableNameExpectation
	expectations       []*RepositoryIMockTextChunkTableNameExpectation

	expectedInvocations uint64
}

// RepositoryIMockTextChunkTableNameExpectation specifies expectation struct of the RepositoryI.TextChunkTableName
type RepositoryIMockTextChunkTableNameExpectation struct {
	mock *RepositoryIMock

	results *RepositoryIMockTextChunkTableNameResults
	Counter uint64
}

// RepositoryIMockTextChunkTableNameResults contains results of the RepositoryI.TextChunkTableName
type RepositoryIMockTextChunkTableNameResults struct {
	s1 string
}

// Expect sets up expected params for RepositoryI.TextChunkTableName
func (mmTextChunkTableName *mRepositoryIMockTextChunkTableName) Expect() *mRepositoryIMockTextChunkTableName {
	if mmTextChunkTableName.mock.funcTextChunkTableName != nil {
		mmTextChunkTableName.mock.t.Fatalf("RepositoryIMock.TextChunkTableName mock is already set by Set")
	}

	if mmTextChunkTableName.defaultExpectation == nil {
		mmTextChunkTableName.defaultExpectation = &RepositoryIMockTextChunkTableNameExpectation{}
	}

	return mmTextChunkTableName
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.TextChunkTableName
func (mmTextChunkTableName *mRepositoryIMockTextChunkTableName) Inspect(f func()) *mRepositoryIMockTextChunkTableName {
	if mmTextChunkTableName.mock.inspectFuncTextChunkTableName != nil {
		mmTextChunkTableName.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.TextChunkTableName")
	}

	mmTextChunkTableName.mock.inspectFuncTextChunkTableName = f

	return mmTextChunkTableName
}

// Return sets up results that will be returned by RepositoryI.TextChunkTableName
func (mmTextChunkTableName *mRepositoryIMockTextChunkTableName) Return(s1 string) *RepositoryIMock {
	if mmTextChunkTableName.mock.funcTextChunkTableName != nil {
		mmTextChunkTableName.mock.t.Fatalf("RepositoryIMock.TextChunkTableName mock is already set by Set")
	}

	if mmTextChunkTableName.defaultExpectation == nil {
		mmTextChunkTableName.defaultExpectation = &RepositoryIMockTextChunkTableNameExpectation{mock: mmTextChunkTableName.mock}
	}
	mmTextChunkTableName.defaultExpectation.results = &RepositoryIMockTextChunkTableNameResults{s1}
	return mmTextChunkTableName.mock
}

// Set uses given function f to mock the RepositoryI.TextChunkTableName method
func (mmTextChunkTableName *mRepositoryIMockTextChunkTableName) Set(f func() (s1 string)) *RepositoryIMock {
	if mmTextChunkTableName.defaultExpectation != nil {
		mmTextChunkTableName.mock.t.Fatalf("Default expectation is already set for the RepositoryI.TextChunkTableName method")
	}

	if len(mmTextChunkTableName.expectations) > 0 {
		mmTextChunkTableName.mock.t.Fatalf("Some expectations are already set for the RepositoryI.TextChunkTableName method")
	}

	mmTextChunkTableName.mock.funcTextChunkTableName = f
	return mmTextChunkTableName.mock
}

// Times sets number of times RepositoryI.TextChunkTableName should be invoked
func (mmTextChunkTableName *mRepositoryIMockTextChunkTableName) Times(n uint64) *mRepositoryIMockTextChunkTableName {
	if n == 0 {
		mmTextChunkTableName.mock.t.Fatalf("Times of RepositoryIMock.TextChunkTableName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTextChunkTableName.expectedInvocations, n)
	return mmTextChunkTableName
}

func (mmTextChunkTableName *mRepositoryIMockTextChunkTableName) invocationsDone() bool {
	if len(mmTextChunkTableName.expectations) == 0 && mmTextChunkTableName.defaultExpectation == nil && mmTextChunkTableName.mock.funcTextChunkTableName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTextChunkTableName.mock.afterTextChunkTableNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTextChunkTableName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TextChunkTableName implements repository.RepositoryI
func (mmTextChunkTableName *RepositoryIMock) TextChunkTableName() (s1 string) {
	mm_atomic.AddUint64(&mmTextChunkTableName.beforeTextChunkTableNameCounter, 1)
	defer mm_atomic.AddUint64(&mmTextChunkTableName.afterTextChunkTableNameCounter, 1)

	if mmTextChunkTableName.inspectFuncTextChunkTableName != nil {
		mmTextChunkTableName.inspectFuncTextChunkTableName()
	}

	if mmTextChunkTableName.TextChunkTableNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTextChunkTableName.TextChunkTableNameMock.defaultExpectation.Counter, 1)

		mm_results := mmTextChunkTableName.TextChunkTableNameMock.defaultExpectation.results
		if mm_results == nil {
			mmTextChunkTableName.t.Fatal("No results are set for the RepositoryIMock.TextChunkTableName")
		}
		return (*mm_results).s1
	}
	if mmTextChunkTableName.funcTextChunkTableName != nil {
		return mmTextChunkTableName.funcTextChunkTableName()
	}
	mmTextChunkTableName.t.Fatalf("Unexpected call to RepositoryIMock.TextChunkTableName.")
	return
}

// TextChunkTableNameAfterCounter returns a count of finished RepositoryIMock.TextChunkTableName invocations
func (mmTextChunkTableName *RepositoryIMock) TextChunkTableNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTextChunkTableName.afterTextChunkTableNameCounter)
}

// TextChunkTableNameBeforeCounter returns a count of RepositoryIMock.TextChunkTableName invocations
func (mmTextChunkTableName *RepositoryIMock) TextChunkTableNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTextChunkTableName.beforeTextChunkTableNameCounter)
}

// MinimockTextChunkTableNameDone returns true if the count of the TextChunkTableName invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockTextChunkTableNameDone() bool {
	for _, e := range m.TextChunkTableNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TextChunkTableNameMock.invocationsDone()
}

// MinimockTextChunkTableNameInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockTextChunkTableNameInspect() {
	for _, e := range m.TextChunkTableNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryIMock.TextChunkTableName")
		}
	}

	afterTextChunkTableNameCounter := mm_atomic.LoadUint64(&m.afterTextChunkTableNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TextChunkTableNameMock.defaultExpectation != nil && afterTextChunkTableNameCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.TextChunkTableName")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTextChunkTableName != nil && afterTextChunkTableNameCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.TextChunkTableName")
	}

	if !m.TextChunkTableNameMock.invocationsDone() && afterTextChunkTableNameCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.TextChunkTableName but found %d calls",
			mm_atomic.LoadUint64(&m.TextChunkTableNameMock.expectedInvocations), afterTextChunkTableNameCounter)
	}
}

type mRepositoryIMockUpdateChunk struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockUpdateChunkExpectation
	expectations       []*RepositoryIMockUpdateChunkExpectation

	callArgs []*RepositoryIMockUpdateChunkParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockUpdateChunkExpectation specifies expectation struct of the RepositoryI.UpdateChunk
type RepositoryIMockUpdateChunkExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockUpdateChunkParams
	paramPtrs *RepositoryIMockUpdateChunkParamPtrs
	results   *RepositoryIMockUpdateChunkResults
	Counter   uint64
}

// RepositoryIMockUpdateChunkParams contains parameters of the RepositoryI.UpdateChunk
type RepositoryIMockUpdateChunkParams struct {
	ctx      context.Context
	chunkUID string
	updates  map[string]interface{}
}

// RepositoryIMockUpdateChunkParamPtrs contains pointers to parameters of the RepositoryI.UpdateChunk
type RepositoryIMockUpdateChunkParamPtrs struct {
	ctx      *context.Context
	chunkUID *string
	updates  *map[string]interface{}
}

// RepositoryIMockUpdateChunkResults contains results of the RepositoryI.UpdateChunk
type RepositoryIMockUpdateChunkResults struct {
	tp1 *mm_repository.TextChunk
	err error
}

// Expect sets up expected params for RepositoryI.UpdateChunk
func (mmUpdateChunk *mRepositoryIMockUpdateChunk) Expect(ctx context.Context, chunkUID string, updates map[string]interface{}) *mRepositoryIMockUpdateChunk {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("RepositoryIMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &RepositoryIMockUpdateChunkExpectation{}
	}

	if mmUpdateChunk.defaultExpectation.paramPtrs != nil {
		mmUpdateChunk.mock.t.Fatalf("RepositoryIMock.UpdateChunk mock is already set by ExpectParams functions")
	}

	mmUpdateChunk.defaultExpectation.params = &RepositoryIMockUpdateChunkParams{ctx, chunkUID, updates}
	for _, e := range mmUpdateChunk.expectations {
		if minimock.Equal(e.params, mmUpdateChunk.defaultExpectation.params) {
			mmUpdateChunk.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateChunk.defaultExpectation.params)
		}
	}

	return mmUpdateChunk
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.UpdateChunk
func (mmUpdateChunk *mRepositoryIMockUpdateChunk) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockUpdateChunk {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("RepositoryIMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &RepositoryIMockUpdateChunkExpectation{}
	}

	if mmUpdateChunk.defaultExpectation.params != nil {
		mmUpdateChunk.mock.t.Fatalf("RepositoryIMock.UpdateChunk mock is already set by Expect")
	}

	if mmUpdateChunk.defaultExpectation.paramPtrs == nil {
		mmUpdateChunk.defaultExpectation.paramPtrs = &RepositoryIMockUpdateChunkParamPtrs{}
	}
	mmUpdateChunk.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateChunk
}

// ExpectChunkUIDParam2 sets up expected param chunkUID for RepositoryI.UpdateChunk
func (mmUpdateChunk *mRepositoryIMockUpdateChunk) ExpectChunkUIDParam2(chunkUID string) *mRepositoryIMockUpdateChunk {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("RepositoryIMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &RepositoryIMockUpdateChunkExpectation{}
	}

	if mmUpdateChunk.defaultExpectation.params != nil {
		mmUpdateChunk.mock.t.Fatalf("RepositoryIMock.UpdateChunk mock is already set by Expect")
	}

	if mmUpdateChunk.defaultExpectation.paramPtrs == nil {
		mmUpdateChunk.defaultExpectation.paramPtrs = &RepositoryIMockUpdateChunkParamPtrs{}
	}
	mmUpdateChunk.defaultExpectation.paramPtrs.chunkUID = &chunkUID

	return mmUpdateChunk
}

// ExpectUpdatesParam3 sets up expected param updates for RepositoryI.UpdateChunk
func (mmUpdateChunk *mRepositoryIMockUpdateChunk) ExpectUpdatesParam3(updates map[string]interface{}) *mRepositoryIMockUpdateChunk {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("RepositoryIMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &RepositoryIMockUpdateChunkExpectation{}
	}

	if mmUpdateChunk.defaultExpectation.params != nil {
		mmUpdateChunk.mock.t.Fatalf("RepositoryIMock.UpdateChunk mock is already set by Expect")
	}

	if mmUpdateChunk.defaultExpectation.paramPtrs == nil {
		mmUpdateChunk.defaultExpectation.paramPtrs = &RepositoryIMockUpdateChunkParamPtrs{}
	}
	mmUpdateChunk.defaultExpectation.paramPtrs.updates = &updates

	return mmUpdateChunk
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.UpdateChunk
func (mmUpdateChunk *mRepositoryIMockUpdateChunk) Inspect(f func(ctx context.Context, chunkUID string, updates map[string]interface{})) *mRepositoryIMockUpdateChunk {
	if mmUpdateChunk.mock.inspectFuncUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.UpdateChunk")
	}

	mmUpdateChunk.mock.inspectFuncUpdateChunk = f

	return mmUpdateChunk
}

// Return sets up results that will be returned by RepositoryI.UpdateChunk
func (mmUpdateChunk *mRepositoryIMockUpdateChunk) Return(tp1 *mm_repository.TextChunk, err error) *RepositoryIMock {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("RepositoryIMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &RepositoryIMockUpdateChunkExpectation{mock: mmUpdateChunk.mock}
	}
	mmUpdateChunk.defaultExpectation.results = &RepositoryIMockUpdateChunkResults{tp1, err}
	return mmUpdateChunk.mock
}

// Set uses given function f to mock the RepositoryI.UpdateChunk method
func (mmUpdateChunk *mRepositoryIMockUpdateChunk) Set(f func(ctx context.Context, chunkUID string, updates map[string]interface{}) (tp1 *mm_repository.TextChunk, err error)) *RepositoryIMock {
	if mmUpdateChunk.defaultExpectation != nil {
		mmUpdateChunk.mock.t.Fatalf("Default expectation is already set for the RepositoryI.UpdateChunk method")
	}

	if len(mmUpdateChunk.expectations) > 0 {
		mmUpdateChunk.mock.t.Fatalf("Some expectations are already set for the RepositoryI.UpdateChunk method")
	}

	mmUpdateChunk.mock.funcUpdateChunk = f
	return mmUpdateChunk.mock
}

// When sets expectation for the RepositoryI.UpdateChunk which will trigger the result defined by the following
// Then helper
func (mmUpdateChunk *mRepositoryIMockUpdateChunk) When(ctx context.Context, chunkUID string, updates map[string]interface{}) *RepositoryIMockUpdateChunkExpectation {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("RepositoryIMock.UpdateChunk mock is already set by Set")
	}

	expectation := &RepositoryIMockUpdateChunkExpectation{
		mock:   mmUpdateChunk.mock,
		params: &RepositoryIMockUpdateChunkParams{ctx, chunkUID, updates},
	}
	mmUpdateChunk.expectations = append(mmUpdateChunk.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.UpdateChunk return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockUpdateChunkExpectation) Then(tp1 *mm_repository.TextChunk, err error) *RepositoryIMock {
	e.results = &RepositoryIMockUpdateChunkResults{tp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.UpdateChunk should be invoked
func (mmUpdateChunk *mRepositoryIMockUpdateChunk) Times(n uint64) *mRepositoryIMockUpdateChunk {
	if n == 0 {
		mmUpdateChunk.mock.t.Fatalf("Times of RepositoryIMock.UpdateChunk mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateChunk.expectedInvocations, n)
	return mmUpdateChunk
}

func (mmUpdateChunk *mRepositoryIMockUpdateChunk) invocationsDone() bool {
	if len(mmUpdateChunk.expectations) == 0 && mmUpdateChunk.defaultExpectation == nil && mmUpdateChunk.mock.funcUpdateChunk == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateChunk.mock.afterUpdateChunkCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateChunk.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateChunk implements repository.RepositoryI
func (mmUpdateChunk *RepositoryIMock) UpdateChunk(ctx context.Context, chunkUID string, updates map[string]interface{}) (tp1 *mm_repository.TextChunk, err error) {
	mm_atomic.AddUint64(&mmUpdateChunk.beforeUpdateChunkCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateChunk.afterUpdateChunkCounter, 1)

	if mmUpdateChunk.inspectFuncUpdateChunk != nil {
		mmUpdateChunk.inspectFuncUpdateChunk(ctx, chunkUID, updates)
	}

	mm_params := RepositoryIMockUpdateChunkParams{ctx, chunkUID, updates}

	// Record call args
	mmUpdateChunk.UpdateChunkMock.mutex.Lock()
	mmUpdateChunk.UpdateChunkMock.callArgs = append(mmUpdateChunk.UpdateChunkMock.callArgs, &mm_params)
	mmUpdateChunk.UpdateChunkMock.mutex.Unlock()

	for _, e := range mmUpdateChunk.UpdateChunkMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp1, e.results.err
		}
	}

	if mmUpdateChunk.UpdateChunkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateChunk.UpdateChunkMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateChunk.UpdateChunkMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateChunk.UpdateChunkMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockUpdateChunkParams{ctx, chunkUID, updates}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateChunk.t.Errorf("RepositoryIMock.UpdateChunk got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chunkUID != nil && !minimock.Equal(*mm_want_ptrs.chunkUID, mm_got.chunkUID) {
				mmUpdateChunk.t.Errorf("RepositoryIMock.UpdateChunk got unexpected parameter chunkUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.chunkUID, mm_got.chunkUID, minimock.Diff(*mm_want_ptrs.chunkUID, mm_got.chunkUID))
			}

			if mm_want_ptrs.updates != nil && !minimock.Equal(*mm_want_ptrs.updates, mm_got.updates) {
				mmUpdateChunk.t.Errorf("RepositoryIMock.UpdateChunk got unexpected parameter updates, want: %#v, got: %#v%s\n", *mm_want_ptrs.updates, mm_got.updates, minimock.Diff(*mm_want_ptrs.updates, mm_got.updates))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateChunk.t.Errorf("RepositoryIMock.UpdateChunk got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateChunk.UpdateChunkMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateChunk.t.Fatal("No results are set for the RepositoryIMock.UpdateChunk")
		}
		return (*mm_results).tp1, (*mm_results).err
	}
	if mmUpdateChunk.funcUpdateChunk != nil {
		return mmUpdateChunk.funcUpdateChunk(ctx, chunkUID, updates)
	}
	mmUpdateChunk.t.Fatalf("Unexpected call to RepositoryIMock.UpdateChunk. %v %v %v", ctx, chunkUID, updates)
	return
}

// UpdateChunkAfterCounter returns a count of finished RepositoryIMock.UpdateChunk invocations
func (mmUpdateChunk *RepositoryIMock) UpdateChunkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateChunk.afterUpdateChunkCounter)
}

// UpdateChunkBeforeCounter returns a count of RepositoryIMock.UpdateChunk invocations
func (mmUpdateChunk *RepositoryIMock) UpdateChunkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateChunk.beforeUpdateChunkCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.UpdateChunk.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateChunk *mRepositoryIMockUpdateChunk) Calls() []*RepositoryIMockUpdateChunkParams {
	mmUpdateChunk.mutex.RLock()

	argCopy := make([]*RepositoryIMockUpdateChunkParams, len(mmUpdateChunk.callArgs))
	copy(argCopy, mmUpdateChunk.callArgs)

	mmUpdateChunk.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateChunkDone returns true if the count of the UpdateChunk invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockUpdateChunkDone() bool {
	for _, e := range m.UpdateChunkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateChunkMock.invocationsDone()
}

// MinimockUpdateChunkInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockUpdateChunkInspect() {
	for _, e := range m.UpdateChunkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateChunk with params: %#v", *e.params)
		}
	}

	afterUpdateChunkCounter := mm_atomic.LoadUint64(&m.afterUpdateChunkCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateChunkMock.defaultExpectation != nil && afterUpdateChunkCounter < 1 {
		if m.UpdateChunkMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.UpdateChunk")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateChunk with params: %#v", *m.UpdateChunkMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateChunk != nil && afterUpdateChunkCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.UpdateChunk")
	}

	if !m.UpdateChunkMock.invocationsDone() && afterUpdateChunkCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.UpdateChunk but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateChunkMock.expectedInvocations), afterUpdateChunkCounter)
	}
}

type mRepositoryIMockUpdateConversationByUpdateMap struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockUpdateConversationByUpdateMapExpectation
	expectations       []*RepositoryIMockUpdateConversationByUpdateMapExpectation

	callArgs []*RepositoryIMockUpdateConversationByUpdateMapParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockUpdateConversationByUpdateMapExpectation specifies expectation struct of the RepositoryI.UpdateConversationByUpdateMap
type RepositoryIMockUpdateConversationByUpdateMapExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockUpdateConversationByUpdateMapParams
	paramPtrs *RepositoryIMockUpdateConversationByUpdateMapParamPtrs
	results   *RepositoryIMockUpdateConversationByUpdateMapResults
	Counter   uint64
}

// RepositoryIMockUpdateConversationByUpdateMapParams contains parameters of the RepositoryI.UpdateConversationByUpdateMap
type RepositoryIMockUpdateConversationByUpdateMapParams struct {
	ctx       context.Context
	convUID   uuid.UUID
	updateMap map[string]interface{}
}

// RepositoryIMockUpdateConversationByUpdateMapParamPtrs contains pointers to parameters of the RepositoryI.UpdateConversationByUpdateMap
type RepositoryIMockUpdateConversationByUpdateMapParamPtrs struct {
	ctx       *context.Context
	convUID   *uuid.UUID
	updateMap *map[string]interface{}
}

// RepositoryIMockUpdateConversationByUpdateMapResults contains results of the RepositoryI.UpdateConversationByUpdateMap
type RepositoryIMockUpdateConversationByUpdateMapResults struct {
	cp1 *mm_repository.Conversation
	err error
}

// Expect sets up expected params for RepositoryI.UpdateConversationByUpdateMap
func (mmUpdateConversationByUpdateMap *mRepositoryIMockUpdateConversationByUpdateMap) Expect(ctx context.Context, convUID uuid.UUID, updateMap map[string]interface{}) *mRepositoryIMockUpdateConversationByUpdateMap {
	if mmUpdateConversationByUpdateMap.mock.funcUpdateConversationByUpdateMap != nil {
		mmUpdateConversationByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateConversationByUpdateMap mock is already set by Set")
	}

	if mmUpdateConversationByUpdateMap.defaultExpectation == nil {
		mmUpdateConversationByUpdateMap.defaultExpectation = &RepositoryIMockUpdateConversationByUpdateMapExpectation{}
	}

	if mmUpdateConversationByUpdateMap.defaultExpectation.paramPtrs != nil {
		mmUpdateConversationByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateConversationByUpdateMap mock is already set by ExpectParams functions")
	}

	mmUpdateConversationByUpdateMap.defaultExpectation.params = &RepositoryIMockUpdateConversationByUpdateMapParams{ctx, convUID, updateMap}
	for _, e := range mmUpdateConversationByUpdateMap.expectations {
		if minimock.Equal(e.params, mmUpdateConversationByUpdateMap.defaultExpectation.params) {
			mmUpdateConversationByUpdateMap.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateConversationByUpdateMap.defaultExpectation.params)
		}
	}

	return mmUpdateConversationByUpdateMap
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.UpdateConversationByUpdateMap
func (mmUpdateConversationByUpdateMap *mRepositoryIMockUpdateConversationByUpdateMap) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockUpdateConversationByUpdateMap {
	if mmUpdateConversationByUpdateMap.mock.funcUpdateConversationByUpdateMap != nil {
		mmUpdateConversationByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateConversationByUpdateMap mock is already set by Set")
	}

	if mmUpdateConversationByUpdateMap.defaultExpectation == nil {
		mmUpdateConversationByUpdateMap.defaultExpectation = &RepositoryIMockUpdateConversationByUpdateMapExpectation{}
	}

	if mmUpdateConversationByUpdateMap.defaultExpectation.params != nil {
		mmUpdateConversationByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateConversationByUpdateMap mock is already set by Expect")
	}

	if mmUpdateConversationByUpdateMap.defaultExpectation.paramPtrs == nil {
		mmUpdateConversationByUpdateMap.defaultExpectation.paramPtrs = &RepositoryIMockUpdateConversationByUpdateMapParamPtrs{}
	}
	mmUpdateConversationByUpdateMap.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateConversationByUpdateMap
}

// ExpectConvUIDParam2 sets up expected param convUID for RepositoryI.UpdateConversationByUpdateMap
func (mmUpdateConversationByUpdateMap *mRepositoryIMockUpdateConversationByUpdateMap) ExpectConvUIDParam2(convUID uuid.UUID) *mRepositoryIMockUpdateConversationByUpdateMap {
	if mmUpdateConversationByUpdateMap.mock.funcUpdateConversationByUpdateMap != nil {
		mmUpdateConversationByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateConversationByUpdateMap mock is already set by Set")
	}

	if mmUpdateConversationByUpdateMap.defaultExpectation == nil {
		mmUpdateConversationByUpdateMap.defaultExpectation = &RepositoryIMockUpdateConversationByUpdateMapExpectation{}
	}

	if mmUpdateConversationByUpdateMap.defaultExpectation.params != nil {
		mmUpdateConversationByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateConversationByUpdateMap mock is already set by Expect")
	}

	if mmUpdateConversationByUpdateMap.defaultExpectation.paramPtrs == nil {
		mmUpdateConversationByUpdateMap.defaultExpectation.paramPtrs = &RepositoryIMockUpdateConversationByUpdateMapParamPtrs{}
	}
	mmUpdateConversationByUpdateMap.defaultExpectation.paramPtrs.convUID = &convUID

	return mmUpdateConversationByUpdateMap
}

// ExpectUpdateMapParam3 sets up expected param updateMap for RepositoryI.UpdateConversationByUpdateMap
func (mmUpdateConversationByUpdateMap *mRepositoryIMockUpdateConversationByUpdateMap) ExpectUpdateMapParam3(updateMap map[string]interface{}) *mRepositoryIMockUpdateConversationByUpdateMap {
	if mmUpdateConversationByUpdateMap.mock.funcUpdateConversationByUpdateMap != nil {
		mmUpdateConversationByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateConversationByUpdateMap mock is already set by Set")
	}

	if mmUpdateConversationByUpdateMap.defaultExpectation == nil {
		mmUpdateConversationByUpdateMap.defaultExpectation = &RepositoryIMockUpdateConversationByUpdateMapExpectation{}
	}

	if mmUpdateConversationByUpdateMap.defaultExpectation.params != nil {
		mmUpdateConversationByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateConversationByUpdateMap mock is already set by Expect")
	}

	if mmUpdateConversationByUpdateMap.defaultExpectation.paramPtrs == nil {
		mmUpdateConversationByUpdateMap.defaultExpectation.paramPtrs = &RepositoryIMockUpdateConversationByUpdateMapParamPtrs{}
	}
	mmUpdateConversationByUpdateMap.defaultExpectation.paramPtrs.updateMap = &updateMap

	return mmUpdateConversationByUpdateMap
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.UpdateConversationByUpdateMap
func (mmUpdateConversationByUpdateMap *mRepositoryIMockUpdateConversationByUpdateMap) Inspect(f func(ctx context.Context, convUID uuid.UUID, updateMap map[string]interface{})) *mRepositoryIMockUpdateConversationByUpdateMap {
	if mmUpdateConversationByUpdateMap.mock.inspectFuncUpdateConversationByUpdateMap != nil {
		mmUpdateConversationByUpdateMap.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.UpdateConversationByUpdateMap")
	}

	mmUpdateConversationByUpdateMap.mock.inspectFuncUpdateConversationByUpdateMap = f

	return mmUpdateConversationByUpdateMap
}

// Return sets up results that will be returned by RepositoryI.UpdateConversationByUpdateMap
func (mmUpdateConversationByUpdateMap *mRepositoryIMockUpdateConversationByUpdateMap) Return(cp1 *mm_repository.Conversation, err error) *RepositoryIMock {
	if mmUpdateConversationByUpdateMap.mock.funcUpdateConversationByUpdateMap != nil {
		mmUpdateConversationByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateConversationByUpdateMap mock is already set by Set")
	}

	if mmUpdateConversationByUpdateMap.defaultExpectation == nil {
		mmUpdateConversationByUpdateMap.defaultExpectation = &RepositoryIMockUpdateConversationByUpdateMapExpectation{mock: mmUpdateConversationByUpdateMap.mock}
	}
	mmUpdateConversationByUpdateMap.defaultExpectation.results = &RepositoryIMockUpdateConversationByUpdateMapResults{cp1, err}
	return mmUpdateConversationByUpdateMap.mock
}

// Set uses given function f to mock the RepositoryI.UpdateConversationByUpdateMap method
func (mmUpdateConversationByUpdateMap *mRepositoryIMockUpdateConversationByUpdateMap) Set(f func(ctx context.Context, convUID uuid.UUID, updateMap map[string]interface{}) (cp1 *mm_repository.Conversation, err error)) *RepositoryIMock {
	if mmUpdateConversationByUpdateMap.defaultExpectation != nil {
		mmUpdateConversationByUpdateMap.mock.t.Fatalf("Default expectation is already set for the RepositoryI.UpdateConversationByUpdateMap method")
	}

	if len(mmUpdateConversationByUpdateMap.expectations) > 0 {
		mmUpdateConversationByUpdateMap.mock.t.Fatalf("Some expectations are already set for the RepositoryI.UpdateConversationByUpdateMap method")
	}

	mmUpdateConversationByUpdateMap.mock.funcUpdateConversationByUpdateMap = f
	return mmUpdateConversationByUpdateMap.mock
}

// When sets expectation for the RepositoryI.UpdateConversationByUpdateMap which will trigger the result defined by the following
// Then helper
func (mmUpdateConversationByUpdateMap *mRepositoryIMockUpdateConversationByUpdateMap) When(ctx context.Context, convUID uuid.UUID, updateMap map[string]interface{}) *RepositoryIMockUpdateConversationByUpdateMapExpectation {
	if mmUpdateConversationByUpdateMap.mock.funcUpdateConversationByUpdateMap != nil {
		mmUpdateConversationByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateConversationByUpdateMap mock is already set by Set")
	}

	expectation := &RepositoryIMockUpdateConversationByUpdateMapExpectation{
		mock:   mmUpdateConversationByUpdateMap.mock,
		params: &RepositoryIMockUpdateConversationByUpdateMapParams{ctx, convUID, updateMap},
	}
	mmUpdateConversationByUpdateMap.expectations = append(mmUpdateConversationByUpdateMap.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.UpdateConversationByUpdateMap return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockUpdateConversationByUpdateMapExpectation) Then(cp1 *mm_repository.Conversation, err error) *RepositoryIMock {
	e.results = &RepositoryIMockUpdateConversationByUpdateMapResults{cp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.UpdateConversationByUpdateMap should be invoked
func (mmUpdateConversationByUpdateMap *mRepositoryIMockUpdateConversationByUpdateMap) Times(n uint64) *mRepositoryIMockUpdateConversationByUpdateMap {
	if n == 0 {
		mmUpdateConversationByUpdateMap.mock.t.Fatalf("Times of RepositoryIMock.UpdateConversationByUpdateMap mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateConversationByUpdateMap.expectedInvocations, n)
	return mmUpdateConversationByUpdateMap
}

func (mmUpdateConversationByUpdateMap *mRepositoryIMockUpdateConversationByUpdateMap) invocationsDone() bool {
	if len(mmUpdateConversationByUpdateMap.expectations) == 0 && mmUpdateConversationByUpdateMap.defaultExpectation == nil && mmUpdateConversationByUpdateMap.mock.funcUpdateConversationByUpdateMap == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateConversationByUpdateMap.mock.afterUpdateConversationByUpdateMapCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateConversationByUpdateMap.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateConversationByUpdateMap implements repository.RepositoryI
func (mmUpdateConversationByUpdateMap *RepositoryIMock) UpdateConversationByUpdateMap(ctx context.Context, convUID uuid.UUID, updateMap map[string]interface{}) (cp1 *mm_repository.Conversation, err error) {
	mm_atomic.AddUint64(&mmUpdateConversationByUpdateMap.beforeUpdateConversationByUpdateMapCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateConversationByUpdateMap.afterUpdateConversationByUpdateMapCounter, 1)

	if mmUpdateConversationByUpdateMap.inspectFuncUpdateConversationByUpdateMap != nil {
		mmUpdateConversationByUpdateMap.inspectFuncUpdateConversationByUpdateMap(ctx, convUID, updateMap)
	}

	mm_params := RepositoryIMockUpdateConversationByUpdateMapParams{ctx, convUID, updateMap}

	// Record call args
	mmUpdateConversationByUpdateMap.UpdateConversationByUpdateMapMock.mutex.Lock()
	mmUpdateConversationByUpdateMap.UpdateConversationByUpdateMapMock.callArgs = append(mmUpdateConversationByUpdateMap.UpdateConversationByUpdateMapMock.callArgs, &mm_params)
	mmUpdateConversationByUpdateMap.UpdateConversationByUpdateMapMock.mutex.Unlock()

	for _, e := range mmUpdateConversationByUpdateMap.UpdateConversationByUpdateMapMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmUpdateConversationByUpdateMap.UpdateConversationByUpdateMapMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateConversationByUpdateMap.UpdateConversationByUpdateMapMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateConversationByUpdateMap.UpdateConversationByUpdateMapMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateConversationByUpdateMap.UpdateConversationByUpdateMapMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockUpdateConversationByUpdateMapParams{ctx, convUID, updateMap}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateConversationByUpdateMap.t.Errorf("RepositoryIMock.UpdateConversationByUpdateMap got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.convUID != nil && !minimock.Equal(*mm_want_ptrs.convUID, mm_got.convUID) {
				mmUpdateConversationByUpdateMap.t.Errorf("RepositoryIMock.UpdateConversationByUpdateMap got unexpected parameter convUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.convUID, mm_got.convUID, minimock.Diff(*mm_want_ptrs.convUID, mm_got.convUID))
			}

			if mm_want_ptrs.updateMap != nil && !minimock.Equal(*mm_want_ptrs.updateMap, mm_got.updateMap) {
				mmUpdateConversationByUpdateMap.t.Errorf("RepositoryIMock.UpdateConversationByUpdateMap got unexpected parameter updateMap, want: %#v, got: %#v%s\n", *mm_want_ptrs.updateMap, mm_got.updateMap, minimock.Diff(*mm_want_ptrs.updateMap, mm_got.updateMap))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateConversationByUpdateMap.t.Errorf("RepositoryIMock.UpdateConversationByUpdateMap got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateConversationByUpdateMap.UpdateConversationByUpdateMapMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateConversationByUpdateMap.t.Fatal("No results are set for the RepositoryIMock.UpdateConversationByUpdateMap")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmUpdateConversationByUpdateMap.funcUpdateConversationByUpdateMap != nil {
		return mmUpdateConversationByUpdateMap.funcUpdateConversationByUpdateMap(ctx, convUID, updateMap)
	}
	mmUpdateConversationByUpdateMap.t.Fatalf("Unexpected call to RepositoryIMock.UpdateConversationByUpdateMap. %v %v %v", ctx, convUID, updateMap)
	return
}

// UpdateConversationByUpdateMapAfterCounter returns a count of finished RepositoryIMock.UpdateConversationByUpdateMap invocations
func (mmUpdateConversationByUpdateMap *RepositoryIMock) UpdateConversationByUpdateMapAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateConversationByUpdateMap.afterUpdateConversationByUpdateMapCounter)
}

// UpdateConversationByUpdateMapBeforeCounter returns a count of RepositoryIMock.UpdateConversationByUpdateMap invocations
func (mmUpdateConversationByUpdateMap *RepositoryIMock) UpdateConversationByUpdateMapBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateConversationByUpdateMap.beforeUpdateConversationByUpdateMapCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.UpdateConversationByUpdateMap.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateConversationByUpdateMap *mRepositoryIMockUpdateConversationByUpdateMap) Calls() []*RepositoryIMockUpdateConversationByUpdateMapParams {
	mmUpdateConversationByUpdateMap.mutex.RLock()

	argCopy := make([]*RepositoryIMockUpdateConversationByUpdateMapParams, len(mmUpdateConversationByUpdateMap.callArgs))
	copy(argCopy, mmUpdateConversationByUpdateMap.callArgs)

	mmUpdateConversationByUpdateMap.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateConversationByUpdateMapDone returns true if the count of the UpdateConversationByUpdateMap invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockUpdateConversationByUpdateMapDone() bool {
	for _, e := range m.UpdateConversationByUpdateMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateConversationByUpdateMapMock.invocationsDone()
}

// MinimockUpdateConversationByUpdateMapInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockUpdateConversationByUpdateMapInspect() {
	for _, e := range m.UpdateConversationByUpdateMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateConversationByUpdateMap with params: %#v", *e.params)
		}
	}

	afterUpdateConversationByUpdateMapCounter := mm_atomic.LoadUint64(&m.afterUpdateConversationByUpdateMapCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateConversationByUpdateMapMock.defaultExpectation != nil && afterUpdateConversationByUpdateMapCounter < 1 {
		if m.UpdateConversationByUpdateMapMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.UpdateConversationByUpdateMap")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateConversationByUpdateMap with params: %#v", *m.UpdateConversationByUpdateMapMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateConversationByUpdateMap != nil && afterUpdateConversationByUpdateMapCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.UpdateConversationByUpdateMap")
	}

	if !m.UpdateConversationByUpdateMapMock.invocationsDone() && afterUpdateConversationByUpdateMapCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.UpdateConversationByUpdateMap but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateConversationByUpdateMapMock.expectedInvocations), afterUpdateConversationByUpdateMapCounter)
	}
}

type mRepositoryIMockUpdateKbFileExtraMetaData struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockUpdateKbFileExtraMetaDataExpectation
	expectations       []*RepositoryIMockUpdateKbFileExtraMetaDataExpectation

	callArgs []*RepositoryIMockUpdateKbFileExtraMetaDataParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockUpdateKbFileExtraMetaDataExpectation specifies expectation struct of the RepositoryI.UpdateKbFileExtraMetaData
type RepositoryIMockUpdateKbFileExtraMetaDataExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockUpdateKbFileExtraMetaDataParams
	paramPtrs *RepositoryIMockUpdateKbFileExtraMetaDataParamPtrs
	results   *RepositoryIMockUpdateKbFileExtraMetaDataResults
	Counter   uint64
}

// RepositoryIMockUpdateKbFileExtraMetaDataParams contains parameters of the RepositoryI.UpdateKbFileExtraMetaData
type RepositoryIMockUpdateKbFileExtraMetaDataParams struct {
	ctx            context.Context
	fileUID        uuid.UUID
	failureReason  string
	convertingPipe string
	chunkingPipe   string
	embeddingPipe  string
	processingTime *int64
	convertingTime *int64
	chunkingTime   *int64
	embeddingTime  *int64
}

// RepositoryIMockUpdateKbFileExtraMetaDataParamPtrs contains pointers to parameters of the RepositoryI.UpdateKbFileExtraMetaData
type RepositoryIMockUpdateKbFileExtraMetaDataParamPtrs struct {
	ctx            *context.Context
	fileUID        *uuid.UUID
	failureReason  *string
	convertingPipe *string
	chunkingPipe   *string
	embeddingPipe  *string
	processingTime **int64
	convertingTime **int64
	chunkingTime   **int64
	embeddingTime  **int64
}

// RepositoryIMockUpdateKbFileExtraMetaDataResults contains results of the RepositoryI.UpdateKbFileExtraMetaData
type RepositoryIMockUpdateKbFileExtraMetaDataResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.UpdateKbFileExtraMetaData
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) Expect(ctx context.Context, fileUID uuid.UUID, failureReason string, convertingPipe string, chunkingPipe string, embeddingPipe string, processingTime *int64, convertingTime *int64, chunkingTime *int64, embeddingTime *int64) *mRepositoryIMockUpdateKbFileExtraMetaData {
	if mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Set")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation = &RepositoryIMockUpdateKbFileExtraMetaDataExpectation{}
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by ExpectParams functions")
	}

	mmUpdateKbFileExtraMetaData.defaultExpectation.params = &RepositoryIMockUpdateKbFileExtraMetaDataParams{ctx, fileUID, failureReason, convertingPipe, chunkingPipe, embeddingPipe, processingTime, convertingTime, chunkingTime, embeddingTime}
	for _, e := range mmUpdateKbFileExtraMetaData.expectations {
		if minimock.Equal(e.params, mmUpdateKbFileExtraMetaData.defaultExpectation.params) {
			mmUpdateKbFileExtraMetaData.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateKbFileExtraMetaData.defaultExpectation.params)
		}
	}

	return mmUpdateKbFileExtraMetaData
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.UpdateKbFileExtraMetaData
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockUpdateKbFileExtraMetaData {
	if mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Set")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation = &RepositoryIMockUpdateKbFileExtraMetaDataExpectation{}
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.params != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Expect")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKbFileExtraMetaDataParamPtrs{}
	}
	mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateKbFileExtraMetaData
}

// ExpectFileUIDParam2 sets up expected param fileUID for RepositoryI.UpdateKbFileExtraMetaData
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) ExpectFileUIDParam2(fileUID uuid.UUID) *mRepositoryIMockUpdateKbFileExtraMetaData {
	if mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Set")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation = &RepositoryIMockUpdateKbFileExtraMetaDataExpectation{}
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.params != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Expect")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKbFileExtraMetaDataParamPtrs{}
	}
	mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs.fileUID = &fileUID

	return mmUpdateKbFileExtraMetaData
}

// ExpectFailureReasonParam3 sets up expected param failureReason for RepositoryI.UpdateKbFileExtraMetaData
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) ExpectFailureReasonParam3(failureReason string) *mRepositoryIMockUpdateKbFileExtraMetaData {
	if mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Set")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation = &RepositoryIMockUpdateKbFileExtraMetaDataExpectation{}
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.params != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Expect")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKbFileExtraMetaDataParamPtrs{}
	}
	mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs.failureReason = &failureReason

	return mmUpdateKbFileExtraMetaData
}

// ExpectConvertingPipeParam4 sets up expected param convertingPipe for RepositoryI.UpdateKbFileExtraMetaData
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) ExpectConvertingPipeParam4(convertingPipe string) *mRepositoryIMockUpdateKbFileExtraMetaData {
	if mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Set")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation = &RepositoryIMockUpdateKbFileExtraMetaDataExpectation{}
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.params != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Expect")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKbFileExtraMetaDataParamPtrs{}
	}
	mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs.convertingPipe = &convertingPipe

	return mmUpdateKbFileExtraMetaData
}

// ExpectChunkingPipeParam5 sets up expected param chunkingPipe for RepositoryI.UpdateKbFileExtraMetaData
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) ExpectChunkingPipeParam5(chunkingPipe string) *mRepositoryIMockUpdateKbFileExtraMetaData {
	if mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Set")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation = &RepositoryIMockUpdateKbFileExtraMetaDataExpectation{}
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.params != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Expect")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKbFileExtraMetaDataParamPtrs{}
	}
	mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs.chunkingPipe = &chunkingPipe

	return mmUpdateKbFileExtraMetaData
}

// ExpectEmbeddingPipeParam6 sets up expected param embeddingPipe for RepositoryI.UpdateKbFileExtraMetaData
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) ExpectEmbeddingPipeParam6(embeddingPipe string) *mRepositoryIMockUpdateKbFileExtraMetaData {
	if mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Set")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation = &RepositoryIMockUpdateKbFileExtraMetaDataExpectation{}
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.params != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Expect")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKbFileExtraMetaDataParamPtrs{}
	}
	mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs.embeddingPipe = &embeddingPipe

	return mmUpdateKbFileExtraMetaData
}

// ExpectProcessingTimeParam7 sets up expected param processingTime for RepositoryI.UpdateKbFileExtraMetaData
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) ExpectProcessingTimeParam7(processingTime *int64) *mRepositoryIMockUpdateKbFileExtraMetaData {
	if mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Set")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation = &RepositoryIMockUpdateKbFileExtraMetaDataExpectation{}
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.params != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Expect")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKbFileExtraMetaDataParamPtrs{}
	}
	mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs.processingTime = &processingTime

	return mmUpdateKbFileExtraMetaData
}

// ExpectConvertingTimeParam8 sets up expected param convertingTime for RepositoryI.UpdateKbFileExtraMetaData
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) ExpectConvertingTimeParam8(convertingTime *int64) *mRepositoryIMockUpdateKbFileExtraMetaData {
	if mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Set")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation = &RepositoryIMockUpdateKbFileExtraMetaDataExpectation{}
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.params != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Expect")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKbFileExtraMetaDataParamPtrs{}
	}
	mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs.convertingTime = &convertingTime

	return mmUpdateKbFileExtraMetaData
}

// ExpectChunkingTimeParam9 sets up expected param chunkingTime for RepositoryI.UpdateKbFileExtraMetaData
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) ExpectChunkingTimeParam9(chunkingTime *int64) *mRepositoryIMockUpdateKbFileExtraMetaData {
	if mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Set")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation = &RepositoryIMockUpdateKbFileExtraMetaDataExpectation{}
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.params != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Expect")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKbFileExtraMetaDataParamPtrs{}
	}
	mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs.chunkingTime = &chunkingTime

	return mmUpdateKbFileExtraMetaData
}

// ExpectEmbeddingTimeParam10 sets up expected param embeddingTime for RepositoryI.UpdateKbFileExtraMetaData
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) ExpectEmbeddingTimeParam10(embeddingTime *int64) *mRepositoryIMockUpdateKbFileExtraMetaData {
	if mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Set")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation = &RepositoryIMockUpdateKbFileExtraMetaDataExpectation{}
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.params != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Expect")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKbFileExtraMetaDataParamPtrs{}
	}
	mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs.embeddingTime = &embeddingTime

	return mmUpdateKbFileExtraMetaData
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.UpdateKbFileExtraMetaData
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) Inspect(f func(ctx context.Context, fileUID uuid.UUID, failureReason string, convertingPipe string, chunkingPipe string, embeddingPipe string, processingTime *int64, convertingTime *int64, chunkingTime *int64, embeddingTime *int64)) *mRepositoryIMockUpdateKbFileExtraMetaData {
	if mmUpdateKbFileExtraMetaData.mock.inspectFuncUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.UpdateKbFileExtraMetaData")
	}

	mmUpdateKbFileExtraMetaData.mock.inspectFuncUpdateKbFileExtraMetaData = f

	return mmUpdateKbFileExtraMetaData
}

// Return sets up results that will be returned by RepositoryI.UpdateKbFileExtraMetaData
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) Return(err error) *RepositoryIMock {
	if mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Set")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation = &RepositoryIMockUpdateKbFileExtraMetaDataExpectation{mock: mmUpdateKbFileExtraMetaData.mock}
	}
	mmUpdateKbFileExtraMetaData.defaultExpectation.results = &RepositoryIMockUpdateKbFileExtraMetaDataResults{err}
	return mmUpdateKbFileExtraMetaData.mock
}

// Set uses given function f to mock the RepositoryI.UpdateKbFileExtraMetaData method
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) Set(f func(ctx context.Context, fileUID uuid.UUID, failureReason string, convertingPipe string, chunkingPipe string, embeddingPipe string, processingTime *int64, convertingTime *int64, chunkingTime *int64, embeddingTime *int64) (err error)) *RepositoryIMock {
	if mmUpdateKbFileExtraMetaData.defaultExpectation != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("Default expectation is already set for the RepositoryI.UpdateKbFileExtraMetaData method")
	}

	if len(mmUpdateKbFileExtraMetaData.expectations) > 0 {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("Some expectations are already set for the RepositoryI.UpdateKbFileExtraMetaData method")
	}

	mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData = f
	return mmUpdateKbFileExtraMetaData.mock
}

// When sets expectation for the RepositoryI.UpdateKbFileExtraMetaData which will trigger the result defined by the following
// Then helper
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) When(ctx context.Context, fileUID uuid.UUID, failureReason string, convertingPipe string, chunkingPipe string, embeddingPipe string, processingTime *int64, convertingTime *int64, chunkingTime *int64, embeddingTime *int64) *RepositoryIMockUpdateKbFileExtraMetaDataExpectation {
	if mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Set")
	}

	expectation := &RepositoryIMockUpdateKbFileExtraMetaDataExpectation{
		mock:   mmUpdateKbFileExtraMetaData.mock,
		params: &RepositoryIMockUpdateKbFileExtraMetaDataParams{ctx, fileUID, failureReason, convertingPipe, chunkingPipe, embeddingPipe, processingTime, convertingTime, chunkingTime, embeddingTime},
	}
	mmUpdateKbFileExtraMetaData.expectations = append(mmUpdateKbFileExtraMetaData.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.UpdateKbFileExtraMetaData return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockUpdateKbFileExtraMetaDataExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockUpdateKbFileExtraMetaDataResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.UpdateKbFileExtraMetaData should be invoked
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) Times(n uint64) *mRepositoryIMockUpdateKbFileExtraMetaData {
	if n == 0 {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("Times of RepositoryIMock.UpdateKbFileExtraMetaData mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateKbFileExtraMetaData.expectedInvocations, n)
	return mmUpdateKbFileExtraMetaData
}

func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) invocationsDone() bool {
	if len(mmUpdateKbFileExtraMetaData.expectations) == 0 && mmUpdateKbFileExtraMetaData.defaultExpectation == nil && mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateKbFileExtraMetaData.mock.afterUpdateKbFileExtraMetaDataCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateKbFileExtraMetaData.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateKbFileExtraMetaData implements repository.RepositoryI
func (mmUpdateKbFileExtraMetaData *RepositoryIMock) UpdateKbFileExtraMetaData(ctx context.Context, fileUID uuid.UUID, failureReason string, convertingPipe string, chunkingPipe string, embeddingPipe string, processingTime *int64, convertingTime *int64, chunkingTime *int64, embeddingTime *int64) (err error) {
	mm_atomic.AddUint64(&mmUpdateKbFileExtraMetaData.beforeUpdateKbFileExtraMetaDataCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateKbFileExtraMetaData.afterUpdateKbFileExtraMetaDataCounter, 1)

	if mmUpdateKbFileExtraMetaData.inspectFuncUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.inspectFuncUpdateKbFileExtraMetaData(ctx, fileUID, failureReason, convertingPipe, chunkingPipe, embeddingPipe, processingTime, convertingTime, chunkingTime, embeddingTime)
	}

	mm_params := RepositoryIMockUpdateKbFileExtraMetaDataParams{ctx, fileUID, failureReason, convertingPipe, chunkingPipe, embeddingPipe, processingTime, convertingTime, chunkingTime, embeddingTime}

	// Record call args
	mmUpdateKbFileExtraMetaData.UpdateKbFileExtraMetaDataMock.mutex.Lock()
	mmUpdateKbFileExtraMetaData.UpdateKbFileExtraMetaDataMock.callArgs = append(mmUpdateKbFileExtraMetaData.UpdateKbFileExtraMetaDataMock.callArgs, &mm_params)
	mmUpdateKbFileExtraMetaData.UpdateKbFileExtraMetaDataMock.mutex.Unlock()

	for _, e := range mmUpdateKbFileExtraMetaData.UpdateKbFileExtraMetaDataMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateKbFileExtraMetaData.UpdateKbFileExtraMetaDataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateKbFileExtraMetaData.UpdateKbFileExtraMetaDataMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateKbFileExtraMetaData.UpdateKbFileExtraMetaDataMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateKbFileExtraMetaData.UpdateKbFileExtraMetaDataMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockUpdateKbFileExtraMetaDataParams{ctx, fileUID, failureReason, convertingPipe, chunkingPipe, embeddingPipe, processingTime, convertingTime, chunkingTime, embeddingTime}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateKbFileExtraMetaData.t.Errorf("RepositoryIMock.UpdateKbFileExtraMetaData got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmUpdateKbFileExtraMetaData.t.Errorf("RepositoryIMock.UpdateKbFileExtraMetaData got unexpected parameter fileUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

			if mm_want_ptrs.failureReason != nil && !minimock.Equal(*mm_want_ptrs.failureReason, mm_got.failureReason) {
				mmUpdateKbFileExtraMetaData.t.Errorf("RepositoryIMock.UpdateKbFileExtraMetaData got unexpected parameter failureReason, want: %#v, got: %#v%s\n", *mm_want_ptrs.failureReason, mm_got.failureReason, minimock.Diff(*mm_want_ptrs.failureReason, mm_got.failureReason))
			}

			if mm_want_ptrs.convertingPipe != nil && !minimock.Equal(*mm_want_ptrs.convertingPipe, mm_got.convertingPipe) {
				mmUpdateKbFileExtraMetaData.t.Errorf("RepositoryIMock.UpdateKbFileExtraMetaData got unexpected parameter convertingPipe, want: %#v, got: %#v%s\n", *mm_want_ptrs.convertingPipe, mm_got.convertingPipe, minimock.Diff(*mm_want_ptrs.convertingPipe, mm_got.convertingPipe))
			}

			if mm_want_ptrs.chunkingPipe != nil && !minimock.Equal(*mm_want_ptrs.chunkingPipe, mm_got.chunkingPipe) {
				mmUpdateKbFileExtraMetaData.t.Errorf("RepositoryIMock.UpdateKbFileExtraMetaData got unexpected parameter chunkingPipe, want: %#v, got: %#v%s\n", *mm_want_ptrs.chunkingPipe, mm_got.chunkingPipe, minimock.Diff(*mm_want_ptrs.chunkingPipe, mm_got.chunkingPipe))
			}

			if mm_want_ptrs.embeddingPipe != nil && !minimock.Equal(*mm_want_ptrs.embeddingPipe, mm_got.embeddingPipe) {
				mmUpdateKbFileExtraMetaData.t.Errorf("RepositoryIMock.UpdateKbFileExtraMetaData got unexpected parameter embeddingPipe, want: %#v, got: %#v%s\n", *mm_want_ptrs.embeddingPipe, mm_got.embeddingPipe, minimock.Diff(*mm_want_ptrs.embeddingPipe, mm_got.embeddingPipe))
			}

			if mm_want_ptrs.processingTime != nil && !minimock.Equal(*mm_want_ptrs.processingTime, mm_got.processingTime) {
				mmUpdateKbFileExtraMetaData.t.Errorf("RepositoryIMock.UpdateKbFileExtraMetaData got unexpected parameter processingTime, want: %#v, got: %#v%s\n", *mm_want_ptrs.processingTime, mm_got.processingTime, minimock.Diff(*mm_want_ptrs.processingTime, mm_got.processingTime))
			}

			if mm_want_ptrs.convertingTime != nil && !minimock.Equal(*mm_want_ptrs.convertingTime, mm_got.convertingTime) {
				mmUpdateKbFileExtraMetaData.t.Errorf("RepositoryIMock.UpdateKbFileExtraMetaData got unexpected parameter convertingTime, want: %#v, got: %#v%s\n", *mm_want_ptrs.convertingTime, mm_got.convertingTime, minimock.Diff(*mm_want_ptrs.convertingTime, mm_got.convertingTime))
			}

			if mm_want_ptrs.chunkingTime != nil && !minimock.Equal(*mm_want_ptrs.chunkingTime, mm_got.chunkingTime) {
				mmUpdateKbFileExtraMetaData.t.Errorf("RepositoryIMock.UpdateKbFileExtraMetaData got unexpected parameter chunkingTime, want: %#v, got: %#v%s\n", *mm_want_ptrs.chunkingTime, mm_got.chunkingTime, minimock.Diff(*mm_want_ptrs.chunkingTime, mm_got.chunkingTime))
			}

			if mm_want_ptrs.embeddingTime != nil && !minimock.Equal(*mm_want_ptrs.embeddingTime, mm_got.embeddingTime) {
				mmUpdateKbFileExtraMetaData.t.Errorf("RepositoryIMock.UpdateKbFileExtraMetaData got unexpected parameter embeddingTime, want: %#v, got: %#v%s\n", *mm_want_ptrs.embeddingTime, mm_got.embeddingTime, minimock.Diff(*mm_want_ptrs.embeddingTime, mm_got.embeddingTime))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateKbFileExtraMetaData.t.Errorf("RepositoryIMock.UpdateKbFileExtraMetaData got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateKbFileExtraMetaData.UpdateKbFileExtraMetaDataMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateKbFileExtraMetaData.t.Fatal("No results are set for the RepositoryIMock.UpdateKbFileExtraMetaData")
		}
		return (*mm_results).err
	}
	if mmUpdateKbFileExtraMetaData.funcUpdateKbFileExtraMetaData != nil {
		return mmUpdateKbFileExtraMetaData.funcUpdateKbFileExtraMetaData(ctx, fileUID, failureReason, convertingPipe, chunkingPipe, embeddingPipe, processingTime, convertingTime, chunkingTime, embeddingTime)
	}
	mmUpdateKbFileExtraMetaData.t.Fatalf("Unexpected call to RepositoryIMock.UpdateKbFileExtraMetaData. %v %v %v %v %v %v %v %v %v %v", ctx, fileUID, failureReason, convertingPipe, chunkingPipe, embeddingPipe, processingTime, convertingTime, chunkingTime, embeddingTime)
	return
}

// UpdateKbFileExtraMetaDataAfterCounter returns a count of finished RepositoryIMock.UpdateKbFileExtraMetaData invocations
func (mmUpdateKbFileExtraMetaData *RepositoryIMock) UpdateKbFileExtraMetaDataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKbFileExtraMetaData.afterUpdateKbFileExtraMetaDataCounter)
}

// UpdateKbFileExtraMetaDataBeforeCounter returns a count of RepositoryIMock.UpdateKbFileExtraMetaData invocations
func (mmUpdateKbFileExtraMetaData *RepositoryIMock) UpdateKbFileExtraMetaDataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKbFileExtraMetaData.beforeUpdateKbFileExtraMetaDataCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.UpdateKbFileExtraMetaData.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) Calls() []*RepositoryIMockUpdateKbFileExtraMetaDataParams {
	mmUpdateKbFileExtraMetaData.mutex.RLock()

	argCopy := make([]*RepositoryIMockUpdateKbFileExtraMetaDataParams, len(mmUpdateKbFileExtraMetaData.callArgs))
	copy(argCopy, mmUpdateKbFileExtraMetaData.callArgs)

	mmUpdateKbFileExtraMetaData.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateKbFileExtraMetaDataDone returns true if the count of the UpdateKbFileExtraMetaData invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockUpdateKbFileExtraMetaDataDone() bool {
	for _, e := range m.UpdateKbFileExtraMetaDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateKbFileExtraMetaDataMock.invocationsDone()
}

// MinimockUpdateKbFileExtraMetaDataInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockUpdateKbFileExtraMetaDataInspect() {
	for _, e := range m.UpdateKbFileExtraMetaDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateKbFileExtraMetaData with params: %#v", *e.params)
		}
	}

	afterUpdateKbFileExtraMetaDataCounter := mm_atomic.LoadUint64(&m.afterUpdateKbFileExtraMetaDataCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateKbFileExtraMetaDataMock.defaultExpectation != nil && afterUpdateKbFileExtraMetaDataCounter < 1 {
		if m.UpdateKbFileExtraMetaDataMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.UpdateKbFileExtraMetaData")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateKbFileExtraMetaData with params: %#v", *m.UpdateKbFileExtraMetaDataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateKbFileExtraMetaData != nil && afterUpdateKbFileExtraMetaDataCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.UpdateKbFileExtraMetaData")
	}

	if !m.UpdateKbFileExtraMetaDataMock.invocationsDone() && afterUpdateKbFileExtraMetaDataCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.UpdateKbFileExtraMetaData but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateKbFileExtraMetaDataMock.expectedInvocations), afterUpdateKbFileExtraMetaDataCounter)
	}
}

type mRepositoryIMockUpdateKnowledgeBase struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockUpdateKnowledgeBaseExpectation
	expectations       []*RepositoryIMockUpdateKnowledgeBaseExpectation

	callArgs []*RepositoryIMockUpdateKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockUpdateKnowledgeBaseExpectation specifies expectation struct of the RepositoryI.UpdateKnowledgeBase
type RepositoryIMockUpdateKnowledgeBaseExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockUpdateKnowledgeBaseParams
	paramPtrs *RepositoryIMockUpdateKnowledgeBaseParamPtrs
	results   *RepositoryIMockUpdateKnowledgeBaseResults
	Counter   uint64
}

// RepositoryIMockUpdateKnowledgeBaseParams contains parameters of the RepositoryI.UpdateKnowledgeBase
type RepositoryIMockUpdateKnowledgeBaseParams struct {
	ctx      context.Context
	ownerUID string
	kb       mm_repository.KnowledgeBase
}

// RepositoryIMockUpdateKnowledgeBaseParamPtrs contains pointers to parameters of the RepositoryI.UpdateKnowledgeBase
type RepositoryIMockUpdateKnowledgeBaseParamPtrs struct {
	ctx      *context.Context
	ownerUID *string
	kb       *mm_repository.KnowledgeBase
}

// RepositoryIMockUpdateKnowledgeBaseResults contains results of the RepositoryI.UpdateKnowledgeBase
type RepositoryIMockUpdateKnowledgeBaseResults struct {
	kp1 *mm_repository.KnowledgeBase
	err error
}

// Expect sets up expected params for RepositoryI.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) Expect(ctx context.Context, ownerUID string, kb mm_repository.KnowledgeBase) *mRepositoryIMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmUpdateKnowledgeBase.defaultExpectation.params = &RepositoryIMockUpdateKnowledgeBaseParams{ctx, ownerUID, kb}
	for _, e := range mmUpdateKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmUpdateKnowledgeBase.defaultExpectation.params) {
			mmUpdateKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmUpdateKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.params != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Expect")
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKnowledgeBaseParamPtrs{}
	}
	mmUpdateKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateKnowledgeBase
}

// ExpectOwnerUIDParam2 sets up expected param ownerUID for RepositoryI.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) ExpectOwnerUIDParam2(ownerUID string) *mRepositoryIMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.params != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Expect")
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKnowledgeBaseParamPtrs{}
	}
	mmUpdateKnowledgeBase.defaultExpectation.paramPtrs.ownerUID = &ownerUID

	return mmUpdateKnowledgeBase
}

// ExpectKbParam3 sets up expected param kb for RepositoryI.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) ExpectKbParam3(kb mm_repository.KnowledgeBase) *mRepositoryIMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.params != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Expect")
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKnowledgeBaseParamPtrs{}
	}
	mmUpdateKnowledgeBase.defaultExpectation.paramPtrs.kb = &kb

	return mmUpdateKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) Inspect(f func(ctx context.Context, ownerUID string, kb mm_repository.KnowledgeBase)) *mRepositoryIMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.inspectFuncUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.UpdateKnowledgeBase")
	}

	mmUpdateKnowledgeBase.mock.inspectFuncUpdateKnowledgeBase = f

	return mmUpdateKnowledgeBase
}

// Return sets up results that will be returned by RepositoryI.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) Return(kp1 *mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseExpectation{mock: mmUpdateKnowledgeBase.mock}
	}
	mmUpdateKnowledgeBase.defaultExpectation.results = &RepositoryIMockUpdateKnowledgeBaseResults{kp1, err}
	return mmUpdateKnowledgeBase.mock
}

// Set uses given function f to mock the RepositoryI.UpdateKnowledgeBase method
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) Set(f func(ctx context.Context, ownerUID string, kb mm_repository.KnowledgeBase) (kp1 *mm_repository.KnowledgeBase, err error)) *RepositoryIMock {
	if mmUpdateKnowledgeBase.defaultExpectation != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the RepositoryI.UpdateKnowledgeBase method")
	}

	if len(mmUpdateKnowledgeBase.expectations) > 0 {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the RepositoryI.UpdateKnowledgeBase method")
	}

	mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase = f
	return mmUpdateKnowledgeBase.mock
}

// When sets expectation for the RepositoryI.UpdateKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) When(ctx context.Context, ownerUID string, kb mm_repository.KnowledgeBase) *RepositoryIMockUpdateKnowledgeBaseExpectation {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Set")
	}

	expectation := &RepositoryIMockUpdateKnowledgeBaseExpectation{
		mock:   mmUpdateKnowledgeBase.mock,
		params: &RepositoryIMockUpdateKnowledgeBaseParams{ctx, ownerUID, kb},
	}
	mmUpdateKnowledgeBase.expectations = append(mmUpdateKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.UpdateKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockUpdateKnowledgeBaseExpectation) Then(kp1 *mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	e.results = &RepositoryIMockUpdateKnowledgeBaseResults{kp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.UpdateKnowledgeBase should be invoked
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) Times(n uint64) *mRepositoryIMockUpdateKnowledgeBase {
	if n == 0 {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Times of RepositoryIMock.UpdateKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateKnowledgeBase.expectedInvocations, n)
	return mmUpdateKnowledgeBase
}

func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) invocationsDone() bool {
	if len(mmUpdateKnowledgeBase.expectations) == 0 && mmUpdateKnowledgeBase.defaultExpectation == nil && mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.mock.afterUpdateKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateKnowledgeBase implements repository.RepositoryI
func (mmUpdateKnowledgeBase *RepositoryIMock) UpdateKnowledgeBase(ctx context.Context, ownerUID string, kb mm_repository.KnowledgeBase) (kp1 *mm_repository.KnowledgeBase, err error) {
	mm_atomic.AddUint64(&mmUpdateKnowledgeBase.beforeUpdateKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateKnowledgeBase.afterUpdateKnowledgeBaseCounter, 1)

	if mmUpdateKnowledgeBase.inspectFuncUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.inspectFuncUpdateKnowledgeBase(ctx, ownerUID, kb)
	}

	mm_params := RepositoryIMockUpdateKnowledgeBaseParams{ctx, ownerUID, kb}

	// Record call args
	mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.mutex.Lock()
	mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.callArgs = append(mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.callArgs, &mm_params)
	mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockUpdateKnowledgeBaseParams{ctx, ownerUID, kb}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateKnowledgeBase.t.Errorf("RepositoryIMock.UpdateKnowledgeBase got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmUpdateKnowledgeBase.t.Errorf("RepositoryIMock.UpdateKnowledgeBase got unexpected parameter ownerUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

			if mm_want_ptrs.kb != nil && !minimock.Equal(*mm_want_ptrs.kb, mm_got.kb) {
				mmUpdateKnowledgeBase.t.Errorf("RepositoryIMock.UpdateKnowledgeBase got unexpected parameter kb, want: %#v, got: %#v%s\n", *mm_want_ptrs.kb, mm_got.kb, minimock.Diff(*mm_want_ptrs.kb, mm_got.kb))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateKnowledgeBase.t.Errorf("RepositoryIMock.UpdateKnowledgeBase got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateKnowledgeBase.t.Fatal("No results are set for the RepositoryIMock.UpdateKnowledgeBase")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmUpdateKnowledgeBase.funcUpdateKnowledgeBase != nil {
		return mmUpdateKnowledgeBase.funcUpdateKnowledgeBase(ctx, ownerUID, kb)
	}
	mmUpdateKnowledgeBase.t.Fatalf("Unexpected call to RepositoryIMock.UpdateKnowledgeBase. %v %v %v", ctx, ownerUID, kb)
	return
}

// UpdateKnowledgeBaseAfterCounter returns a count of finished RepositoryIMock.UpdateKnowledgeBase invocations
func (mmUpdateKnowledgeBase *RepositoryIMock) UpdateKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.afterUpdateKnowledgeBaseCounter)
}

// UpdateKnowledgeBaseBeforeCounter returns a count of RepositoryIMock.UpdateKnowledgeBase invocations
func (mmUpdateKnowledgeBase *RepositoryIMock) UpdateKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.beforeUpdateKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.UpdateKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) Calls() []*RepositoryIMockUpdateKnowledgeBaseParams {
	mmUpdateKnowledgeBase.mutex.RLock()

	argCopy := make([]*RepositoryIMockUpdateKnowledgeBaseParams, len(mmUpdateKnowledgeBase.callArgs))
	copy(argCopy, mmUpdateKnowledgeBase.callArgs)

	mmUpdateKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateKnowledgeBaseDone returns true if the count of the UpdateKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockUpdateKnowledgeBaseDone() bool {
	for _, e := range m.UpdateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateKnowledgeBaseMock.invocationsDone()
}

// MinimockUpdateKnowledgeBaseInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockUpdateKnowledgeBaseInspect() {
	for _, e := range m.UpdateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateKnowledgeBase with params: %#v", *e.params)
		}
	}

	afterUpdateKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterUpdateKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateKnowledgeBaseMock.defaultExpectation != nil && afterUpdateKnowledgeBaseCounter < 1 {
		if m.UpdateKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.UpdateKnowledgeBase")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateKnowledgeBase with params: %#v", *m.UpdateKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateKnowledgeBase != nil && afterUpdateKnowledgeBaseCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.UpdateKnowledgeBase")
	}

	if !m.UpdateKnowledgeBaseMock.invocationsDone() && afterUpdateKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.UpdateKnowledgeBase but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateKnowledgeBaseMock.expectedInvocations), afterUpdateKnowledgeBaseCounter)
	}
}

type mRepositoryIMockUpdateKnowledgeBaseFile struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockUpdateKnowledgeBaseFileExpectation
	expectations       []*RepositoryIMockUpdateKnowledgeBaseFileExpectation

	callArgs []*RepositoryIMockUpdateKnowledgeBaseFileParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockUpdateKnowledgeBaseFileExpectation specifies expectation struct of the RepositoryI.UpdateKnowledgeBaseFile
type RepositoryIMockUpdateKnowledgeBaseFileExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockUpdateKnowledgeBaseFileParams
	paramPtrs *RepositoryIMockUpdateKnowledgeBaseFileParamPtrs
	results   *RepositoryIMockUpdateKnowledgeBaseFileResults
	Counter   uint64
}

// RepositoryIMockUpdateKnowledgeBaseFileParams contains parameters of the RepositoryI.UpdateKnowledgeBaseFile
type RepositoryIMockUpdateKnowledgeBaseFileParams struct {
	ctx       context.Context
	fileUID   string
	updateMap map[string]interface{}
}

// RepositoryIMockUpdateKnowledgeBaseFileParamPtrs contains pointers to parameters of the RepositoryI.UpdateKnowledgeBaseFile
type RepositoryIMockUpdateKnowledgeBaseFileParamPtrs struct {
	ctx       *context.Context
	fileUID   *string
	updateMap *map[string]interface{}
}

// RepositoryIMockUpdateKnowledgeBaseFileResults contains results of the RepositoryI.UpdateKnowledgeBaseFile
type RepositoryIMockUpdateKnowledgeBaseFileResults struct {
	kp1 *mm_repository.KnowledgeBaseFile
	err error
}

// Expect sets up expected params for RepositoryI.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) Expect(ctx context.Context, fileUID string, updateMap map[string]interface{}) *mRepositoryIMockUpdateKnowledgeBaseFile {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseFileExpectation{}
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by ExpectParams functions")
	}

	mmUpdateKnowledgeBaseFile.defaultExpectation.params = &RepositoryIMockUpdateKnowledgeBaseFileParams{ctx, fileUID, updateMap}
	for _, e := range mmUpdateKnowledgeBaseFile.expectations {
		if minimock.Equal(e.params, mmUpdateKnowledgeBaseFile.defaultExpectation.params) {
			mmUpdateKnowledgeBaseFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateKnowledgeBaseFile.defaultExpectation.params)
		}
	}

	return mmUpdateKnowledgeBaseFile
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockUpdateKnowledgeBaseFile {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseFileExpectation{}
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKnowledgeBaseFileParamPtrs{}
	}
	mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateKnowledgeBaseFile
}

// ExpectFileUIDParam2 sets up expected param fileUID for RepositoryI.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) ExpectFileUIDParam2(fileUID string) *mRepositoryIMockUpdateKnowledgeBaseFile {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseFileExpectation{}
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKnowledgeBaseFileParamPtrs{}
	}
	mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs.fileUID = &fileUID

	return mmUpdateKnowledgeBaseFile
}

// ExpectUpdateMapParam3 sets up expected param updateMap for RepositoryI.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) ExpectUpdateMapParam3(updateMap map[string]interface{}) *mRepositoryIMockUpdateKnowledgeBaseFile {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseFileExpectation{}
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKnowledgeBaseFileParamPtrs{}
	}
	mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs.updateMap = &updateMap

	return mmUpdateKnowledgeBaseFile
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) Inspect(f func(ctx context.Context, fileUID string, updateMap map[string]interface{})) *mRepositoryIMockUpdateKnowledgeBaseFile {
	if mmUpdateKnowledgeBaseFile.mock.inspectFuncUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.UpdateKnowledgeBaseFile")
	}

	mmUpdateKnowledgeBaseFile.mock.inspectFuncUpdateKnowledgeBaseFile = f

	return mmUpdateKnowledgeBaseFile
}

// Return sets up results that will be returned by RepositoryI.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) Return(kp1 *mm_repository.KnowledgeBaseFile, err error) *RepositoryIMock {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseFileExpectation{mock: mmUpdateKnowledgeBaseFile.mock}
	}
	mmUpdateKnowledgeBaseFile.defaultExpectation.results = &RepositoryIMockUpdateKnowledgeBaseFileResults{kp1, err}
	return mmUpdateKnowledgeBaseFile.mock
}

// Set uses given function f to mock the RepositoryI.UpdateKnowledgeBaseFile method
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) Set(f func(ctx context.Context, fileUID string, updateMap map[string]interface{}) (kp1 *mm_repository.KnowledgeBaseFile, err error)) *RepositoryIMock {
	if mmUpdateKnowledgeBaseFile.defaultExpectation != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("Default expectation is already set for the RepositoryI.UpdateKnowledgeBaseFile method")
	}

	if len(mmUpdateKnowledgeBaseFile.expectations) > 0 {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("Some expectations are already set for the RepositoryI.UpdateKnowledgeBaseFile method")
	}

	mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile = f
	return mmUpdateKnowledgeBaseFile.mock
}

// When sets expectation for the RepositoryI.UpdateKnowledgeBaseFile which will trigger the result defined by the following
// Then helper
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) When(ctx context.Context, fileUID string, updateMap map[string]interface{}) *RepositoryIMockUpdateKnowledgeBaseFileExpectation {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	expectation := &RepositoryIMockUpdateKnowledgeBaseFileExpectation{
		mock:   mmUpdateKnowledgeBaseFile.mock,
		params: &RepositoryIMockUpdateKnowledgeBaseFileParams{ctx, fileUID, updateMap},
	}
	mmUpdateKnowledgeBaseFile.expectations = append(mmUpdateKnowledgeBaseFile.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.UpdateKnowledgeBaseFile return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockUpdateKnowledgeBaseFileExpectation) Then(kp1 *mm_repository.KnowledgeBaseFile, err error) *RepositoryIMock {
	e.results = &RepositoryIMockUpdateKnowledgeBaseFileResults{kp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.UpdateKnowledgeBaseFile should be invoked
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) Times(n uint64) *mRepositoryIMockUpdateKnowledgeBaseFile {
	if n == 0 {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("Times of RepositoryIMock.UpdateKnowledgeBaseFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateKnowledgeBaseFile.expectedInvocations, n)
	return mmUpdateKnowledgeBaseFile
}

func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) invocationsDone() bool {
	if len(mmUpdateKnowledgeBaseFile.expectations) == 0 && mmUpdateKnowledgeBaseFile.defaultExpectation == nil && mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseFile.mock.afterUpdateKnowledgeBaseFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateKnowledgeBaseFile implements repository.RepositoryI
func (mmUpdateKnowledgeBaseFile *RepositoryIMock) UpdateKnowledgeBaseFile(ctx context.Context, fileUID string, updateMap map[string]interface{}) (kp1 *mm_repository.KnowledgeBaseFile, err error) {
	mm_atomic.AddUint64(&mmUpdateKnowledgeBaseFile.beforeUpdateKnowledgeBaseFileCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateKnowledgeBaseFile.afterUpdateKnowledgeBaseFileCounter, 1)

	if mmUpdateKnowledgeBaseFile.inspectFuncUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.inspectFuncUpdateKnowledgeBaseFile(ctx, fileUID, updateMap)
	}

	mm_params := RepositoryIMockUpdateKnowledgeBaseFileParams{ctx, fileUID, updateMap}

	// Record call args
	mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.mutex.Lock()
	mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.callArgs = append(mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.callArgs, &mm_params)
	mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.mutex.Unlock()

	for _, e := range mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockUpdateKnowledgeBaseFileParams{ctx, fileUID, updateMap}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateKnowledgeBaseFile.t.Errorf("RepositoryIMock.UpdateKnowledgeBaseFile got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmUpdateKnowledgeBaseFile.t.Errorf("RepositoryIMock.UpdateKnowledgeBaseFile got unexpected parameter fileUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

			if mm_want_ptrs.updateMap != nil && !minimock.Equal(*mm_want_ptrs.updateMap, mm_got.updateMap) {
				mmUpdateKnowledgeBaseFile.t.Errorf("RepositoryIMock.UpdateKnowledgeBaseFile got unexpected parameter updateMap, want: %#v, got: %#v%s\n", *mm_want_ptrs.updateMap, mm_got.updateMap, minimock.Diff(*mm_want_ptrs.updateMap, mm_got.updateMap))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateKnowledgeBaseFile.t.Errorf("RepositoryIMock.UpdateKnowledgeBaseFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateKnowledgeBaseFile.t.Fatal("No results are set for the RepositoryIMock.UpdateKnowledgeBaseFile")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmUpdateKnowledgeBaseFile.funcUpdateKnowledgeBaseFile != nil {
		return mmUpdateKnowledgeBaseFile.funcUpdateKnowledgeBaseFile(ctx, fileUID, updateMap)
	}
	mmUpdateKnowledgeBaseFile.t.Fatalf("Unexpected call to RepositoryIMock.UpdateKnowledgeBaseFile. %v %v %v", ctx, fileUID, updateMap)
	return
}

// UpdateKnowledgeBaseFileAfterCounter returns a count of finished RepositoryIMock.UpdateKnowledgeBaseFile invocations
func (mmUpdateKnowledgeBaseFile *RepositoryIMock) UpdateKnowledgeBaseFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseFile.afterUpdateKnowledgeBaseFileCounter)
}

// UpdateKnowledgeBaseFileBeforeCounter returns a count of RepositoryIMock.UpdateKnowledgeBaseFile invocations
func (mmUpdateKnowledgeBaseFile *RepositoryIMock) UpdateKnowledgeBaseFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseFile.beforeUpdateKnowledgeBaseFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.UpdateKnowledgeBaseFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) Calls() []*RepositoryIMockUpdateKnowledgeBaseFileParams {
	mmUpdateKnowledgeBaseFile.mutex.RLock()

	argCopy := make([]*RepositoryIMockUpdateKnowledgeBaseFileParams, len(mmUpdateKnowledgeBaseFile.callArgs))
	copy(argCopy, mmUpdateKnowledgeBaseFile.callArgs)

	mmUpdateKnowledgeBaseFile.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateKnowledgeBaseFileDone returns true if the count of the UpdateKnowledgeBaseFile invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockUpdateKnowledgeBaseFileDone() bool {
	for _, e := range m.UpdateKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateKnowledgeBaseFileMock.invocationsDone()
}

// MinimockUpdateKnowledgeBaseFileInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockUpdateKnowledgeBaseFileInspect() {
	for _, e := range m.UpdateKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateKnowledgeBaseFile with params: %#v", *e.params)
		}
	}

	afterUpdateKnowledgeBaseFileCounter := mm_atomic.LoadUint64(&m.afterUpdateKnowledgeBaseFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateKnowledgeBaseFileMock.defaultExpectation != nil && afterUpdateKnowledgeBaseFileCounter < 1 {
		if m.UpdateKnowledgeBaseFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.UpdateKnowledgeBaseFile")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateKnowledgeBaseFile with params: %#v", *m.UpdateKnowledgeBaseFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateKnowledgeBaseFile != nil && afterUpdateKnowledgeBaseFileCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.UpdateKnowledgeBaseFile")
	}

	if !m.UpdateKnowledgeBaseFileMock.invocationsDone() && afterUpdateKnowledgeBaseFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.UpdateKnowledgeBaseFile but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateKnowledgeBaseFileMock.expectedInvocations), afterUpdateKnowledgeBaseFileCounter)
	}
}

type mRepositoryIMockUpdateMessage struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockUpdateMessageExpectation
	expectations       []*RepositoryIMockUpdateMessageExpectation

	callArgs []*RepositoryIMockUpdateMessageParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockUpdateMessageExpectation specifies expectation struct of the RepositoryI.UpdateMessage
type RepositoryIMockUpdateMessageExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockUpdateMessageParams
	paramPtrs *RepositoryIMockUpdateMessageParamPtrs
	results   *RepositoryIMockUpdateMessageResults
	Counter   uint64
}

// RepositoryIMockUpdateMessageParams contains parameters of the RepositoryI.UpdateMessage
type RepositoryIMockUpdateMessageParams struct {
	ctx context.Context
	msg mm_repository.Message
}

// RepositoryIMockUpdateMessageParamPtrs contains pointers to parameters of the RepositoryI.UpdateMessage
type RepositoryIMockUpdateMessageParamPtrs struct {
	ctx *context.Context
	msg *mm_repository.Message
}

// RepositoryIMockUpdateMessageResults contains results of the RepositoryI.UpdateMessage
type RepositoryIMockUpdateMessageResults struct {
	mp1 *mm_repository.Message
	err error
}

// Expect sets up expected params for RepositoryI.UpdateMessage
func (mmUpdateMessage *mRepositoryIMockUpdateMessage) Expect(ctx context.Context, msg mm_repository.Message) *mRepositoryIMockUpdateMessage {
	if mmUpdateMessage.mock.funcUpdateMessage != nil {
		mmUpdateMessage.mock.t.Fatalf("RepositoryIMock.UpdateMessage mock is already set by Set")
	}

	if mmUpdateMessage.defaultExpectation == nil {
		mmUpdateMessage.defaultExpectation = &RepositoryIMockUpdateMessageExpectation{}
	}

	if mmUpdateMessage.defaultExpectation.paramPtrs != nil {
		mmUpdateMessage.mock.t.Fatalf("RepositoryIMock.UpdateMessage mock is already set by ExpectParams functions")
	}

	mmUpdateMessage.defaultExpectation.params = &RepositoryIMockUpdateMessageParams{ctx, msg}
	for _, e := range mmUpdateMessage.expectations {
		if minimock.Equal(e.params, mmUpdateMessage.defaultExpectation.params) {
			mmUpdateMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateMessage.defaultExpectation.params)
		}
	}

	return mmUpdateMessage
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.UpdateMessage
func (mmUpdateMessage *mRepositoryIMockUpdateMessage) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockUpdateMessage {
	if mmUpdateMessage.mock.funcUpdateMessage != nil {
		mmUpdateMessage.mock.t.Fatalf("RepositoryIMock.UpdateMessage mock is already set by Set")
	}

	if mmUpdateMessage.defaultExpectation == nil {
		mmUpdateMessage.defaultExpectation = &RepositoryIMockUpdateMessageExpectation{}
	}

	if mmUpdateMessage.defaultExpectation.params != nil {
		mmUpdateMessage.mock.t.Fatalf("RepositoryIMock.UpdateMessage mock is already set by Expect")
	}

	if mmUpdateMessage.defaultExpectation.paramPtrs == nil {
		mmUpdateMessage.defaultExpectation.paramPtrs = &RepositoryIMockUpdateMessageParamPtrs{}
	}
	mmUpdateMessage.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateMessage
}

// ExpectMsgParam2 sets up expected param msg for RepositoryI.UpdateMessage
func (mmUpdateMessage *mRepositoryIMockUpdateMessage) ExpectMsgParam2(msg mm_repository.Message) *mRepositoryIMockUpdateMessage {
	if mmUpdateMessage.mock.funcUpdateMessage != nil {
		mmUpdateMessage.mock.t.Fatalf("RepositoryIMock.UpdateMessage mock is already set by Set")
	}

	if mmUpdateMessage.defaultExpectation == nil {
		mmUpdateMessage.defaultExpectation = &RepositoryIMockUpdateMessageExpectation{}
	}

	if mmUpdateMessage.defaultExpectation.params != nil {
		mmUpdateMessage.mock.t.Fatalf("RepositoryIMock.UpdateMessage mock is already set by Expect")
	}

	if mmUpdateMessage.defaultExpectation.paramPtrs == nil {
		mmUpdateMessage.defaultExpectation.paramPtrs = &RepositoryIMockUpdateMessageParamPtrs{}
	}
	mmUpdateMessage.defaultExpectation.paramPtrs.msg = &msg

	return mmUpdateMessage
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.UpdateMessage
func (mmUpdateMessage *mRepositoryIMockUpdateMessage) Inspect(f func(ctx context.Context, msg mm_repository.Message)) *mRepositoryIMockUpdateMessage {
	if mmUpdateMessage.mock.inspectFuncUpdateMessage != nil {
		mmUpdateMessage.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.UpdateMessage")
	}

	mmUpdateMessage.mock.inspectFuncUpdateMessage = f

	return mmUpdateMessage
}

// Return sets up results that will be returned by RepositoryI.UpdateMessage
func (mmUpdateMessage *mRepositoryIMockUpdateMessage) Return(mp1 *mm_repository.Message, err error) *RepositoryIMock {
	if mmUpdateMessage.mock.funcUpdateMessage != nil {
		mmUpdateMessage.mock.t.Fatalf("RepositoryIMock.UpdateMessage mock is already set by Set")
	}

	if mmUpdateMessage.defaultExpectation == nil {
		mmUpdateMessage.defaultExpectation = &RepositoryIMockUpdateMessageExpectation{mock: mmUpdateMessage.mock}
	}
	mmUpdateMessage.defaultExpectation.results = &RepositoryIMockUpdateMessageResults{mp1, err}
	return mmUpdateMessage.mock
}

// Set uses given function f to mock the RepositoryI.UpdateMessage method
func (mmUpdateMessage *mRepositoryIMockUpdateMessage) Set(f func(ctx context.Context, msg mm_repository.Message) (mp1 *mm_repository.Message, err error)) *RepositoryIMock {
	if mmUpdateMessage.defaultExpectation != nil {
		mmUpdateMessage.mock.t.Fatalf("Default expectation is already set for the RepositoryI.UpdateMessage method")
	}

	if len(mmUpdateMessage.expectations) > 0 {
		mmUpdateMessage.mock.t.Fatalf("Some expectations are already set for the RepositoryI.UpdateMessage method")
	}

	mmUpdateMessage.mock.funcUpdateMessage = f
	return mmUpdateMessage.mock
}

// When sets expectation for the RepositoryI.UpdateMessage which will trigger the result defined by the following
// Then helper
func (mmUpdateMessage *mRepositoryIMockUpdateMessage) When(ctx context.Context, msg mm_repository.Message) *RepositoryIMockUpdateMessageExpectation {
	if mmUpdateMessage.mock.funcUpdateMessage != nil {
		mmUpdateMessage.mock.t.Fatalf("RepositoryIMock.UpdateMessage mock is already set by Set")
	}

	expectation := &RepositoryIMockUpdateMessageExpectation{
		mock:   mmUpdateMessage.mock,
		params: &RepositoryIMockUpdateMessageParams{ctx, msg},
	}
	mmUpdateMessage.expectations = append(mmUpdateMessage.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.UpdateMessage return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockUpdateMessageExpectation) Then(mp1 *mm_repository.Message, err error) *RepositoryIMock {
	e.results = &RepositoryIMockUpdateMessageResults{mp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.UpdateMessage should be invoked
func (mmUpdateMessage *mRepositoryIMockUpdateMessage) Times(n uint64) *mRepositoryIMockUpdateMessage {
	if n == 0 {
		mmUpdateMessage.mock.t.Fatalf("Times of RepositoryIMock.UpdateMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateMessage.expectedInvocations, n)
	return mmUpdateMessage
}

func (mmUpdateMessage *mRepositoryIMockUpdateMessage) invocationsDone() bool {
	if len(mmUpdateMessage.expectations) == 0 && mmUpdateMessage.defaultExpectation == nil && mmUpdateMessage.mock.funcUpdateMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateMessage.mock.afterUpdateMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateMessage implements repository.RepositoryI
func (mmUpdateMessage *RepositoryIMock) UpdateMessage(ctx context.Context, msg mm_repository.Message) (mp1 *mm_repository.Message, err error) {
	mm_atomic.AddUint64(&mmUpdateMessage.beforeUpdateMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateMessage.afterUpdateMessageCounter, 1)

	if mmUpdateMessage.inspectFuncUpdateMessage != nil {
		mmUpdateMessage.inspectFuncUpdateMessage(ctx, msg)
	}

	mm_params := RepositoryIMockUpdateMessageParams{ctx, msg}

	// Record call args
	mmUpdateMessage.UpdateMessageMock.mutex.Lock()
	mmUpdateMessage.UpdateMessageMock.callArgs = append(mmUpdateMessage.UpdateMessageMock.callArgs, &mm_params)
	mmUpdateMessage.UpdateMessageMock.mutex.Unlock()

	for _, e := range mmUpdateMessage.UpdateMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmUpdateMessage.UpdateMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateMessage.UpdateMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateMessage.UpdateMessageMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateMessage.UpdateMessageMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockUpdateMessageParams{ctx, msg}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateMessage.t.Errorf("RepositoryIMock.UpdateMessage got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmUpdateMessage.t.Errorf("RepositoryIMock.UpdateMessage got unexpected parameter msg, want: %#v, got: %#v%s\n", *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateMessage.t.Errorf("RepositoryIMock.UpdateMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateMessage.UpdateMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateMessage.t.Fatal("No results are set for the RepositoryIMock.UpdateMessage")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmUpdateMessage.funcUpdateMessage != nil {
		return mmUpdateMessage.funcUpdateMessage(ctx, msg)
	}
	mmUpdateMessage.t.Fatalf("Unexpected call to RepositoryIMock.UpdateMessage. %v %v", ctx, msg)
	return
}

// UpdateMessageAfterCounter returns a count of finished RepositoryIMock.UpdateMessage invocations
func (mmUpdateMessage *RepositoryIMock) UpdateMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateMessage.afterUpdateMessageCounter)
}

// UpdateMessageBeforeCounter returns a count of RepositoryIMock.UpdateMessage invocations
func (mmUpdateMessage *RepositoryIMock) UpdateMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateMessage.beforeUpdateMessageCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.UpdateMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateMessage *mRepositoryIMockUpdateMessage) Calls() []*RepositoryIMockUpdateMessageParams {
	mmUpdateMessage.mutex.RLock()

	argCopy := make([]*RepositoryIMockUpdateMessageParams, len(mmUpdateMessage.callArgs))
	copy(argCopy, mmUpdateMessage.callArgs)

	mmUpdateMessage.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateMessageDone returns true if the count of the UpdateMessage invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockUpdateMessageDone() bool {
	for _, e := range m.UpdateMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMessageMock.invocationsDone()
}

// MinimockUpdateMessageInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockUpdateMessageInspect() {
	for _, e := range m.UpdateMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateMessage with params: %#v", *e.params)
		}
	}

	afterUpdateMessageCounter := mm_atomic.LoadUint64(&m.afterUpdateMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMessageMock.defaultExpectation != nil && afterUpdateMessageCounter < 1 {
		if m.UpdateMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.UpdateMessage")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateMessage with params: %#v", *m.UpdateMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateMessage != nil && afterUpdateMessageCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.UpdateMessage")
	}

	if !m.UpdateMessageMock.invocationsDone() && afterUpdateMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.UpdateMessage but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMessageMock.expectedInvocations), afterUpdateMessageCounter)
	}
}

type mRepositoryIMockUpdateMessageByUpdateMap struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockUpdateMessageByUpdateMapExpectation
	expectations       []*RepositoryIMockUpdateMessageByUpdateMapExpectation

	callArgs []*RepositoryIMockUpdateMessageByUpdateMapParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockUpdateMessageByUpdateMapExpectation specifies expectation struct of the RepositoryI.UpdateMessageByUpdateMap
type RepositoryIMockUpdateMessageByUpdateMapExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockUpdateMessageByUpdateMapParams
	paramPtrs *RepositoryIMockUpdateMessageByUpdateMapParamPtrs
	results   *RepositoryIMockUpdateMessageByUpdateMapResults
	Counter   uint64
}

// RepositoryIMockUpdateMessageByUpdateMapParams contains parameters of the RepositoryI.UpdateMessageByUpdateMap
type RepositoryIMockUpdateMessageByUpdateMapParams struct {
	ctx        context.Context
	messageUID uuid.UUID
	updateMap  map[string]interface{}
}

// RepositoryIMockUpdateMessageByUpdateMapParamPtrs contains pointers to parameters of the RepositoryI.UpdateMessageByUpdateMap
type RepositoryIMockUpdateMessageByUpdateMapParamPtrs struct {
	ctx        *context.Context
	messageUID *uuid.UUID
	updateMap  *map[string]interface{}
}

// RepositoryIMockUpdateMessageByUpdateMapResults contains results of the RepositoryI.UpdateMessageByUpdateMap
type RepositoryIMockUpdateMessageByUpdateMapResults struct {
	mp1 *mm_repository.Message
	err error
}

// Expect sets up expected params for RepositoryI.UpdateMessageByUpdateMap
func (mmUpdateMessageByUpdateMap *mRepositoryIMockUpdateMessageByUpdateMap) Expect(ctx context.Context, messageUID uuid.UUID, updateMap map[string]interface{}) *mRepositoryIMockUpdateMessageByUpdateMap {
	if mmUpdateMessageByUpdateMap.mock.funcUpdateMessageByUpdateMap != nil {
		mmUpdateMessageByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateMessageByUpdateMap mock is already set by Set")
	}

	if mmUpdateMessageByUpdateMap.defaultExpectation == nil {
		mmUpdateMessageByUpdateMap.defaultExpectation = &RepositoryIMockUpdateMessageByUpdateMapExpectation{}
	}

	if mmUpdateMessageByUpdateMap.defaultExpectation.paramPtrs != nil {
		mmUpdateMessageByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateMessageByUpdateMap mock is already set by ExpectParams functions")
	}

	mmUpdateMessageByUpdateMap.defaultExpectation.params = &RepositoryIMockUpdateMessageByUpdateMapParams{ctx, messageUID, updateMap}
	for _, e := range mmUpdateMessageByUpdateMap.expectations {
		if minimock.Equal(e.params, mmUpdateMessageByUpdateMap.defaultExpectation.params) {
			mmUpdateMessageByUpdateMap.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateMessageByUpdateMap.defaultExpectation.params)
		}
	}

	return mmUpdateMessageByUpdateMap
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.UpdateMessageByUpdateMap
func (mmUpdateMessageByUpdateMap *mRepositoryIMockUpdateMessageByUpdateMap) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockUpdateMessageByUpdateMap {
	if mmUpdateMessageByUpdateMap.mock.funcUpdateMessageByUpdateMap != nil {
		mmUpdateMessageByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateMessageByUpdateMap mock is already set by Set")
	}

	if mmUpdateMessageByUpdateMap.defaultExpectation == nil {
		mmUpdateMessageByUpdateMap.defaultExpectation = &RepositoryIMockUpdateMessageByUpdateMapExpectation{}
	}

	if mmUpdateMessageByUpdateMap.defaultExpectation.params != nil {
		mmUpdateMessageByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateMessageByUpdateMap mock is already set by Expect")
	}

	if mmUpdateMessageByUpdateMap.defaultExpectation.paramPtrs == nil {
		mmUpdateMessageByUpdateMap.defaultExpectation.paramPtrs = &RepositoryIMockUpdateMessageByUpdateMapParamPtrs{}
	}
	mmUpdateMessageByUpdateMap.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateMessageByUpdateMap
}

// ExpectMessageUIDParam2 sets up expected param messageUID for RepositoryI.UpdateMessageByUpdateMap
func (mmUpdateMessageByUpdateMap *mRepositoryIMockUpdateMessageByUpdateMap) ExpectMessageUIDParam2(messageUID uuid.UUID) *mRepositoryIMockUpdateMessageByUpdateMap {
	if mmUpdateMessageByUpdateMap.mock.funcUpdateMessageByUpdateMap != nil {
		mmUpdateMessageByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateMessageByUpdateMap mock is already set by Set")
	}

	if mmUpdateMessageByUpdateMap.defaultExpectation == nil {
		mmUpdateMessageByUpdateMap.defaultExpectation = &RepositoryIMockUpdateMessageByUpdateMapExpectation{}
	}

	if mmUpdateMessageByUpdateMap.defaultExpectation.params != nil {
		mmUpdateMessageByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateMessageByUpdateMap mock is already set by Expect")
	}

	if mmUpdateMessageByUpdateMap.defaultExpectation.paramPtrs == nil {
		mmUpdateMessageByUpdateMap.defaultExpectation.paramPtrs = &RepositoryIMockUpdateMessageByUpdateMapParamPtrs{}
	}
	mmUpdateMessageByUpdateMap.defaultExpectation.paramPtrs.messageUID = &messageUID

	return mmUpdateMessageByUpdateMap
}

// ExpectUpdateMapParam3 sets up expected param updateMap for RepositoryI.UpdateMessageByUpdateMap
func (mmUpdateMessageByUpdateMap *mRepositoryIMockUpdateMessageByUpdateMap) ExpectUpdateMapParam3(updateMap map[string]interface{}) *mRepositoryIMockUpdateMessageByUpdateMap {
	if mmUpdateMessageByUpdateMap.mock.funcUpdateMessageByUpdateMap != nil {
		mmUpdateMessageByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateMessageByUpdateMap mock is already set by Set")
	}

	if mmUpdateMessageByUpdateMap.defaultExpectation == nil {
		mmUpdateMessageByUpdateMap.defaultExpectation = &RepositoryIMockUpdateMessageByUpdateMapExpectation{}
	}

	if mmUpdateMessageByUpdateMap.defaultExpectation.params != nil {
		mmUpdateMessageByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateMessageByUpdateMap mock is already set by Expect")
	}

	if mmUpdateMessageByUpdateMap.defaultExpectation.paramPtrs == nil {
		mmUpdateMessageByUpdateMap.defaultExpectation.paramPtrs = &RepositoryIMockUpdateMessageByUpdateMapParamPtrs{}
	}
	mmUpdateMessageByUpdateMap.defaultExpectation.paramPtrs.updateMap = &updateMap

	return mmUpdateMessageByUpdateMap
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.UpdateMessageByUpdateMap
func (mmUpdateMessageByUpdateMap *mRepositoryIMockUpdateMessageByUpdateMap) Inspect(f func(ctx context.Context, messageUID uuid.UUID, updateMap map[string]interface{})) *mRepositoryIMockUpdateMessageByUpdateMap {
	if mmUpdateMessageByUpdateMap.mock.inspectFuncUpdateMessageByUpdateMap != nil {
		mmUpdateMessageByUpdateMap.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.UpdateMessageByUpdateMap")
	}

	mmUpdateMessageByUpdateMap.mock.inspectFuncUpdateMessageByUpdateMap = f

	return mmUpdateMessageByUpdateMap
}

// Return sets up results that will be returned by RepositoryI.UpdateMessageByUpdateMap
func (mmUpdateMessageByUpdateMap *mRepositoryIMockUpdateMessageByUpdateMap) Return(mp1 *mm_repository.Message, err error) *RepositoryIMock {
	if mmUpdateMessageByUpdateMap.mock.funcUpdateMessageByUpdateMap != nil {
		mmUpdateMessageByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateMessageByUpdateMap mock is already set by Set")
	}

	if mmUpdateMessageByUpdateMap.defaultExpectation == nil {
		mmUpdateMessageByUpdateMap.defaultExpectation = &RepositoryIMockUpdateMessageByUpdateMapExpectation{mock: mmUpdateMessageByUpdateMap.mock}
	}
	mmUpdateMessageByUpdateMap.defaultExpectation.results = &RepositoryIMockUpdateMessageByUpdateMapResults{mp1, err}
	return mmUpdateMessageByUpdateMap.mock
}

// Set uses given function f to mock the RepositoryI.UpdateMessageByUpdateMap method
func (mmUpdateMessageByUpdateMap *mRepositoryIMockUpdateMessageByUpdateMap) Set(f func(ctx context.Context, messageUID uuid.UUID, updateMap map[string]interface{}) (mp1 *mm_repository.Message, err error)) *RepositoryIMock {
	if mmUpdateMessageByUpdateMap.defaultExpectation != nil {
		mmUpdateMessageByUpdateMap.mock.t.Fatalf("Default expectation is already set for the RepositoryI.UpdateMessageByUpdateMap method")
	}

	if len(mmUpdateMessageByUpdateMap.expectations) > 0 {
		mmUpdateMessageByUpdateMap.mock.t.Fatalf("Some expectations are already set for the RepositoryI.UpdateMessageByUpdateMap method")
	}

	mmUpdateMessageByUpdateMap.mock.funcUpdateMessageByUpdateMap = f
	return mmUpdateMessageByUpdateMap.mock
}

// When sets expectation for the RepositoryI.UpdateMessageByUpdateMap which will trigger the result defined by the following
// Then helper
func (mmUpdateMessageByUpdateMap *mRepositoryIMockUpdateMessageByUpdateMap) When(ctx context.Context, messageUID uuid.UUID, updateMap map[string]interface{}) *RepositoryIMockUpdateMessageByUpdateMapExpectation {
	if mmUpdateMessageByUpdateMap.mock.funcUpdateMessageByUpdateMap != nil {
		mmUpdateMessageByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateMessageByUpdateMap mock is already set by Set")
	}

	expectation := &RepositoryIMockUpdateMessageByUpdateMapExpectation{
		mock:   mmUpdateMessageByUpdateMap.mock,
		params: &RepositoryIMockUpdateMessageByUpdateMapParams{ctx, messageUID, updateMap},
	}
	mmUpdateMessageByUpdateMap.expectations = append(mmUpdateMessageByUpdateMap.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.UpdateMessageByUpdateMap return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockUpdateMessageByUpdateMapExpectation) Then(mp1 *mm_repository.Message, err error) *RepositoryIMock {
	e.results = &RepositoryIMockUpdateMessageByUpdateMapResults{mp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.UpdateMessageByUpdateMap should be invoked
func (mmUpdateMessageByUpdateMap *mRepositoryIMockUpdateMessageByUpdateMap) Times(n uint64) *mRepositoryIMockUpdateMessageByUpdateMap {
	if n == 0 {
		mmUpdateMessageByUpdateMap.mock.t.Fatalf("Times of RepositoryIMock.UpdateMessageByUpdateMap mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateMessageByUpdateMap.expectedInvocations, n)
	return mmUpdateMessageByUpdateMap
}

func (mmUpdateMessageByUpdateMap *mRepositoryIMockUpdateMessageByUpdateMap) invocationsDone() bool {
	if len(mmUpdateMessageByUpdateMap.expectations) == 0 && mmUpdateMessageByUpdateMap.defaultExpectation == nil && mmUpdateMessageByUpdateMap.mock.funcUpdateMessageByUpdateMap == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateMessageByUpdateMap.mock.afterUpdateMessageByUpdateMapCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateMessageByUpdateMap.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateMessageByUpdateMap implements repository.RepositoryI
func (mmUpdateMessageByUpdateMap *RepositoryIMock) UpdateMessageByUpdateMap(ctx context.Context, messageUID uuid.UUID, updateMap map[string]interface{}) (mp1 *mm_repository.Message, err error) {
	mm_atomic.AddUint64(&mmUpdateMessageByUpdateMap.beforeUpdateMessageByUpdateMapCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateMessageByUpdateMap.afterUpdateMessageByUpdateMapCounter, 1)

	if mmUpdateMessageByUpdateMap.inspectFuncUpdateMessageByUpdateMap != nil {
		mmUpdateMessageByUpdateMap.inspectFuncUpdateMessageByUpdateMap(ctx, messageUID, updateMap)
	}

	mm_params := RepositoryIMockUpdateMessageByUpdateMapParams{ctx, messageUID, updateMap}

	// Record call args
	mmUpdateMessageByUpdateMap.UpdateMessageByUpdateMapMock.mutex.Lock()
	mmUpdateMessageByUpdateMap.UpdateMessageByUpdateMapMock.callArgs = append(mmUpdateMessageByUpdateMap.UpdateMessageByUpdateMapMock.callArgs, &mm_params)
	mmUpdateMessageByUpdateMap.UpdateMessageByUpdateMapMock.mutex.Unlock()

	for _, e := range mmUpdateMessageByUpdateMap.UpdateMessageByUpdateMapMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmUpdateMessageByUpdateMap.UpdateMessageByUpdateMapMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateMessageByUpdateMap.UpdateMessageByUpdateMapMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateMessageByUpdateMap.UpdateMessageByUpdateMapMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateMessageByUpdateMap.UpdateMessageByUpdateMapMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockUpdateMessageByUpdateMapParams{ctx, messageUID, updateMap}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateMessageByUpdateMap.t.Errorf("RepositoryIMock.UpdateMessageByUpdateMap got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.messageUID != nil && !minimock.Equal(*mm_want_ptrs.messageUID, mm_got.messageUID) {
				mmUpdateMessageByUpdateMap.t.Errorf("RepositoryIMock.UpdateMessageByUpdateMap got unexpected parameter messageUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.messageUID, mm_got.messageUID, minimock.Diff(*mm_want_ptrs.messageUID, mm_got.messageUID))
			}

			if mm_want_ptrs.updateMap != nil && !minimock.Equal(*mm_want_ptrs.updateMap, mm_got.updateMap) {
				mmUpdateMessageByUpdateMap.t.Errorf("RepositoryIMock.UpdateMessageByUpdateMap got unexpected parameter updateMap, want: %#v, got: %#v%s\n", *mm_want_ptrs.updateMap, mm_got.updateMap, minimock.Diff(*mm_want_ptrs.updateMap, mm_got.updateMap))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateMessageByUpdateMap.t.Errorf("RepositoryIMock.UpdateMessageByUpdateMap got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateMessageByUpdateMap.UpdateMessageByUpdateMapMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateMessageByUpdateMap.t.Fatal("No results are set for the RepositoryIMock.UpdateMessageByUpdateMap")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmUpdateMessageByUpdateMap.funcUpdateMessageByUpdateMap != nil {
		return mmUpdateMessageByUpdateMap.funcUpdateMessageByUpdateMap(ctx, messageUID, updateMap)
	}
	mmUpdateMessageByUpdateMap.t.Fatalf("Unexpected call to RepositoryIMock.UpdateMessageByUpdateMap. %v %v %v", ctx, messageUID, updateMap)
	return
}

// UpdateMessageByUpdateMapAfterCounter returns a count of finished RepositoryIMock.UpdateMessageByUpdateMap invocations
func (mmUpdateMessageByUpdateMap *RepositoryIMock) UpdateMessageByUpdateMapAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateMessageByUpdateMap.afterUpdateMessageByUpdateMapCounter)
}

// UpdateMessageByUpdateMapBeforeCounter returns a count of RepositoryIMock.UpdateMessageByUpdateMap invocations
func (mmUpdateMessageByUpdateMap *RepositoryIMock) UpdateMessageByUpdateMapBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateMessageByUpdateMap.beforeUpdateMessageByUpdateMapCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.UpdateMessageByUpdateMap.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateMessageByUpdateMap *mRepositoryIMockUpdateMessageByUpdateMap) Calls() []*RepositoryIMockUpdateMessageByUpdateMapParams {
	mmUpdateMessageByUpdateMap.mutex.RLock()

	argCopy := make([]*RepositoryIMockUpdateMessageByUpdateMapParams, len(mmUpdateMessageByUpdateMap.callArgs))
	copy(argCopy, mmUpdateMessageByUpdateMap.callArgs)

	mmUpdateMessageByUpdateMap.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateMessageByUpdateMapDone returns true if the count of the UpdateMessageByUpdateMap invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockUpdateMessageByUpdateMapDone() bool {
	for _, e := range m.UpdateMessageByUpdateMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMessageByUpdateMapMock.invocationsDone()
}

// MinimockUpdateMessageByUpdateMapInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockUpdateMessageByUpdateMapInspect() {
	for _, e := range m.UpdateMessageByUpdateMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateMessageByUpdateMap with params: %#v", *e.params)
		}
	}

	afterUpdateMessageByUpdateMapCounter := mm_atomic.LoadUint64(&m.afterUpdateMessageByUpdateMapCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMessageByUpdateMapMock.defaultExpectation != nil && afterUpdateMessageByUpdateMapCounter < 1 {
		if m.UpdateMessageByUpdateMapMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.UpdateMessageByUpdateMap")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateMessageByUpdateMap with params: %#v", *m.UpdateMessageByUpdateMapMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateMessageByUpdateMap != nil && afterUpdateMessageByUpdateMapCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.UpdateMessageByUpdateMap")
	}

	if !m.UpdateMessageByUpdateMapMock.invocationsDone() && afterUpdateMessageByUpdateMapCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.UpdateMessageByUpdateMap but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMessageByUpdateMapMock.expectedInvocations), afterUpdateMessageByUpdateMapCounter)
	}
}

type mRepositoryIMockUpsertEmbeddings struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockUpsertEmbeddingsExpectation
	expectations       []*RepositoryIMockUpsertEmbeddingsExpectation

	callArgs []*RepositoryIMockUpsertEmbeddingsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockUpsertEmbeddingsExpectation specifies expectation struct of the RepositoryI.UpsertEmbeddings
type RepositoryIMockUpsertEmbeddingsExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockUpsertEmbeddingsParams
	paramPtrs *RepositoryIMockUpsertEmbeddingsParamPtrs
	results   *RepositoryIMockUpsertEmbeddingsResults
	Counter   uint64
}

// RepositoryIMockUpsertEmbeddingsParams contains parameters of the RepositoryI.UpsertEmbeddings
type RepositoryIMockUpsertEmbeddingsParams struct {
	ctx                 context.Context
	embeddings          []mm_repository.Embedding
	externalServiceCall func(embUIDs []string) error
}

// RepositoryIMockUpsertEmbeddingsParamPtrs contains pointers to parameters of the RepositoryI.UpsertEmbeddings
type RepositoryIMockUpsertEmbeddingsParamPtrs struct {
	ctx                 *context.Context
	embeddings          *[]mm_repository.Embedding
	externalServiceCall *func(embUIDs []string) error
}

// RepositoryIMockUpsertEmbeddingsResults contains results of the RepositoryI.UpsertEmbeddings
type RepositoryIMockUpsertEmbeddingsResults struct {
	ea1 []mm_repository.Embedding
	err error
}

// Expect sets up expected params for RepositoryI.UpsertEmbeddings
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) Expect(ctx context.Context, embeddings []mm_repository.Embedding, externalServiceCall func(embUIDs []string) error) *mRepositoryIMockUpsertEmbeddings {
	if mmUpsertEmbeddings.mock.funcUpsertEmbeddings != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by Set")
	}

	if mmUpsertEmbeddings.defaultExpectation == nil {
		mmUpsertEmbeddings.defaultExpectation = &RepositoryIMockUpsertEmbeddingsExpectation{}
	}

	if mmUpsertEmbeddings.defaultExpectation.paramPtrs != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by ExpectParams functions")
	}

	mmUpsertEmbeddings.defaultExpectation.params = &RepositoryIMockUpsertEmbeddingsParams{ctx, embeddings, externalServiceCall}
	for _, e := range mmUpsertEmbeddings.expectations {
		if minimock.Equal(e.params, mmUpsertEmbeddings.defaultExpectation.params) {
			mmUpsertEmbeddings.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertEmbeddings.defaultExpectation.params)
		}
	}

	return mmUpsertEmbeddings
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.UpsertEmbeddings
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockUpsertEmbeddings {
	if mmUpsertEmbeddings.mock.funcUpsertEmbeddings != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by Set")
	}

	if mmUpsertEmbeddings.defaultExpectation == nil {
		mmUpsertEmbeddings.defaultExpectation = &RepositoryIMockUpsertEmbeddingsExpectation{}
	}

	if mmUpsertEmbeddings.defaultExpectation.params != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by Expect")
	}

	if mmUpsertEmbeddings.defaultExpectation.paramPtrs == nil {
		mmUpsertEmbeddings.defaultExpectation.paramPtrs = &RepositoryIMockUpsertEmbeddingsParamPtrs{}
	}
	mmUpsertEmbeddings.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpsertEmbeddings
}

// ExpectEmbeddingsParam2 sets up expected param embeddings for RepositoryI.UpsertEmbeddings
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) ExpectEmbeddingsParam2(embeddings []mm_repository.Embedding) *mRepositoryIMockUpsertEmbeddings {
	if mmUpsertEmbeddings.mock.funcUpsertEmbeddings != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by Set")
	}

	if mmUpsertEmbeddings.defaultExpectation == nil {
		mmUpsertEmbeddings.defaultExpectation = &RepositoryIMockUpsertEmbeddingsExpectation{}
	}

	if mmUpsertEmbeddings.defaultExpectation.params != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by Expect")
	}

	if mmUpsertEmbeddings.defaultExpectation.paramPtrs == nil {
		mmUpsertEmbeddings.defaultExpectation.paramPtrs = &RepositoryIMockUpsertEmbeddingsParamPtrs{}
	}
	mmUpsertEmbeddings.defaultExpectation.paramPtrs.embeddings = &embeddings

	return mmUpsertEmbeddings
}

// ExpectExternalServiceCallParam3 sets up expected param externalServiceCall for RepositoryI.UpsertEmbeddings
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) ExpectExternalServiceCallParam3(externalServiceCall func(embUIDs []string) error) *mRepositoryIMockUpsertEmbeddings {
	if mmUpsertEmbeddings.mock.funcUpsertEmbeddings != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by Set")
	}

	if mmUpsertEmbeddings.defaultExpectation == nil {
		mmUpsertEmbeddings.defaultExpectation = &RepositoryIMockUpsertEmbeddingsExpectation{}
	}

	if mmUpsertEmbeddings.defaultExpectation.params != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by Expect")
	}

	if mmUpsertEmbeddings.defaultExpectation.paramPtrs == nil {
		mmUpsertEmbeddings.defaultExpectation.paramPtrs = &RepositoryIMockUpsertEmbeddingsParamPtrs{}
	}
	mmUpsertEmbeddings.defaultExpectation.paramPtrs.externalServiceCall = &externalServiceCall

	return mmUpsertEmbeddings
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.UpsertEmbeddings
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) Inspect(f func(ctx context.Context, embeddings []mm_repository.Embedding, externalServiceCall func(embUIDs []string) error)) *mRepositoryIMockUpsertEmbeddings {
	if mmUpsertEmbeddings.mock.inspectFuncUpsertEmbeddings != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.UpsertEmbeddings")
	}

	mmUpsertEmbeddings.mock.inspectFuncUpsertEmbeddings = f

	return mmUpsertEmbeddings
}

// Return sets up results that will be returned by RepositoryI.UpsertEmbeddings
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) Return(ea1 []mm_repository.Embedding, err error) *RepositoryIMock {
	if mmUpsertEmbeddings.mock.funcUpsertEmbeddings != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by Set")
	}

	if mmUpsertEmbeddings.defaultExpectation == nil {
		mmUpsertEmbeddings.defaultExpectation = &RepositoryIMockUpsertEmbeddingsExpectation{mock: mmUpsertEmbeddings.mock}
	}
	mmUpsertEmbeddings.defaultExpectation.results = &RepositoryIMockUpsertEmbeddingsResults{ea1, err}
	return mmUpsertEmbeddings.mock
}

// Set uses given function f to mock the RepositoryI.UpsertEmbeddings method
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) Set(f func(ctx context.Context, embeddings []mm_repository.Embedding, externalServiceCall func(embUIDs []string) error) (ea1 []mm_repository.Embedding, err error)) *RepositoryIMock {
	if mmUpsertEmbeddings.defaultExpectation != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("Default expectation is already set for the RepositoryI.UpsertEmbeddings method")
	}

	if len(mmUpsertEmbeddings.expectations) > 0 {
		mmUpsertEmbeddings.mock.t.Fatalf("Some expectations are already set for the RepositoryI.UpsertEmbeddings method")
	}

	mmUpsertEmbeddings.mock.funcUpsertEmbeddings = f
	return mmUpsertEmbeddings.mock
}

// When sets expectation for the RepositoryI.UpsertEmbeddings which will trigger the result defined by the following
// Then helper
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) When(ctx context.Context, embeddings []mm_repository.Embedding, externalServiceCall func(embUIDs []string) error) *RepositoryIMockUpsertEmbeddingsExpectation {
	if mmUpsertEmbeddings.mock.funcUpsertEmbeddings != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by Set")
	}

	expectation := &RepositoryIMockUpsertEmbeddingsExpectation{
		mock:   mmUpsertEmbeddings.mock,
		params: &RepositoryIMockUpsertEmbeddingsParams{ctx, embeddings, externalServiceCall},
	}
	mmUpsertEmbeddings.expectations = append(mmUpsertEmbeddings.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.UpsertEmbeddings return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockUpsertEmbeddingsExpectation) Then(ea1 []mm_repository.Embedding, err error) *RepositoryIMock {
	e.results = &RepositoryIMockUpsertEmbeddingsResults{ea1, err}
	return e.mock
}

// Times sets number of times RepositoryI.UpsertEmbeddings should be invoked
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) Times(n uint64) *mRepositoryIMockUpsertEmbeddings {
	if n == 0 {
		mmUpsertEmbeddings.mock.t.Fatalf("Times of RepositoryIMock.UpsertEmbeddings mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpsertEmbeddings.expectedInvocations, n)
	return mmUpsertEmbeddings
}

func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) invocationsDone() bool {
	if len(mmUpsertEmbeddings.expectations) == 0 && mmUpsertEmbeddings.defaultExpectation == nil && mmUpsertEmbeddings.mock.funcUpsertEmbeddings == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpsertEmbeddings.mock.afterUpsertEmbeddingsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpsertEmbeddings.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpsertEmbeddings implements repository.RepositoryI
func (mmUpsertEmbeddings *RepositoryIMock) UpsertEmbeddings(ctx context.Context, embeddings []mm_repository.Embedding, externalServiceCall func(embUIDs []string) error) (ea1 []mm_repository.Embedding, err error) {
	mm_atomic.AddUint64(&mmUpsertEmbeddings.beforeUpsertEmbeddingsCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertEmbeddings.afterUpsertEmbeddingsCounter, 1)

	if mmUpsertEmbeddings.inspectFuncUpsertEmbeddings != nil {
		mmUpsertEmbeddings.inspectFuncUpsertEmbeddings(ctx, embeddings, externalServiceCall)
	}

	mm_params := RepositoryIMockUpsertEmbeddingsParams{ctx, embeddings, externalServiceCall}

	// Record call args
	mmUpsertEmbeddings.UpsertEmbeddingsMock.mutex.Lock()
	mmUpsertEmbeddings.UpsertEmbeddingsMock.callArgs = append(mmUpsertEmbeddings.UpsertEmbeddingsMock.callArgs, &mm_params)
	mmUpsertEmbeddings.UpsertEmbeddingsMock.mutex.Unlock()

	for _, e := range mmUpsertEmbeddings.UpsertEmbeddingsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1, e.results.err
		}
	}

	if mmUpsertEmbeddings.UpsertEmbeddingsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertEmbeddings.UpsertEmbeddingsMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsertEmbeddings.UpsertEmbeddingsMock.defaultExpectation.params
		mm_want_ptrs := mmUpsertEmbeddings.UpsertEmbeddingsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockUpsertEmbeddingsParams{ctx, embeddings, externalServiceCall}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpsertEmbeddings.t.Errorf("RepositoryIMock.UpsertEmbeddings got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.embeddings != nil && !minimock.Equal(*mm_want_ptrs.embeddings, mm_got.embeddings) {
				mmUpsertEmbeddings.t.Errorf("RepositoryIMock.UpsertEmbeddings got unexpected parameter embeddings, want: %#v, got: %#v%s\n", *mm_want_ptrs.embeddings, mm_got.embeddings, minimock.Diff(*mm_want_ptrs.embeddings, mm_got.embeddings))
			}

			if mm_want_ptrs.externalServiceCall != nil && !minimock.Equal(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall) {
				mmUpsertEmbeddings.t.Errorf("RepositoryIMock.UpsertEmbeddings got unexpected parameter externalServiceCall, want: %#v, got: %#v%s\n", *mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall, minimock.Diff(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsertEmbeddings.t.Errorf("RepositoryIMock.UpsertEmbeddings got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsertEmbeddings.UpsertEmbeddingsMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsertEmbeddings.t.Fatal("No results are set for the RepositoryIMock.UpsertEmbeddings")
		}
		return (*mm_results).ea1, (*mm_results).err
	}
	if mmUpsertEmbeddings.funcUpsertEmbeddings != nil {
		return mmUpsertEmbeddings.funcUpsertEmbeddings(ctx, embeddings, externalServiceCall)
	}
	mmUpsertEmbeddings.t.Fatalf("Unexpected call to RepositoryIMock.UpsertEmbeddings. %v %v %v", ctx, embeddings, externalServiceCall)
	return
}

// UpsertEmbeddingsAfterCounter returns a count of finished RepositoryIMock.UpsertEmbeddings invocations
func (mmUpsertEmbeddings *RepositoryIMock) UpsertEmbeddingsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertEmbeddings.afterUpsertEmbeddingsCounter)
}

// UpsertEmbeddingsBeforeCounter returns a count of RepositoryIMock.UpsertEmbeddings invocations
func (mmUpsertEmbeddings *RepositoryIMock) UpsertEmbeddingsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertEmbeddings.beforeUpsertEmbeddingsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.UpsertEmbeddings.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) Calls() []*RepositoryIMockUpsertEmbeddingsParams {
	mmUpsertEmbeddings.mutex.RLock()

	argCopy := make([]*RepositoryIMockUpsertEmbeddingsParams, len(mmUpsertEmbeddings.callArgs))
	copy(argCopy, mmUpsertEmbeddings.callArgs)

	mmUpsertEmbeddings.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertEmbeddingsDone returns true if the count of the UpsertEmbeddings invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockUpsertEmbeddingsDone() bool {
	for _, e := range m.UpsertEmbeddingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpsertEmbeddingsMock.invocationsDone()
}

// MinimockUpsertEmbeddingsInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockUpsertEmbeddingsInspect() {
	for _, e := range m.UpsertEmbeddingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.UpsertEmbeddings with params: %#v", *e.params)
		}
	}

	afterUpsertEmbeddingsCounter := mm_atomic.LoadUint64(&m.afterUpsertEmbeddingsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertEmbeddingsMock.defaultExpectation != nil && afterUpsertEmbeddingsCounter < 1 {
		if m.UpsertEmbeddingsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.UpsertEmbeddings")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.UpsertEmbeddings with params: %#v", *m.UpsertEmbeddingsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertEmbeddings != nil && afterUpsertEmbeddingsCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.UpsertEmbeddings")
	}

	if !m.UpsertEmbeddingsMock.invocationsDone() && afterUpsertEmbeddingsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.UpsertEmbeddings but found %d calls",
			mm_atomic.LoadUint64(&m.UpsertEmbeddingsMock.expectedInvocations), afterUpsertEmbeddingsCounter)
	}
}

type mRepositoryIMockUpsertRepositoryTag struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockUpsertRepositoryTagExpectation
	expectations       []*RepositoryIMockUpsertRepositoryTagExpectation

	callArgs []*RepositoryIMockUpsertRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockUpsertRepositoryTagExpectation specifies expectation struct of the RepositoryI.UpsertRepositoryTag
type RepositoryIMockUpsertRepositoryTagExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockUpsertRepositoryTagParams
	paramPtrs *RepositoryIMockUpsertRepositoryTagParamPtrs
	results   *RepositoryIMockUpsertRepositoryTagResults
	Counter   uint64
}

// RepositoryIMockUpsertRepositoryTagParams contains parameters of the RepositoryI.UpsertRepositoryTag
type RepositoryIMockUpsertRepositoryTagParams struct {
	ctx context.Context
	rp1 *pb.RepositoryTag
}

// RepositoryIMockUpsertRepositoryTagParamPtrs contains pointers to parameters of the RepositoryI.UpsertRepositoryTag
type RepositoryIMockUpsertRepositoryTagParamPtrs struct {
	ctx *context.Context
	rp1 **pb.RepositoryTag
}

// RepositoryIMockUpsertRepositoryTagResults contains results of the RepositoryI.UpsertRepositoryTag
type RepositoryIMockUpsertRepositoryTagResults struct {
	rp2 *pb.RepositoryTag
	err error
}

// Expect sets up expected params for RepositoryI.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) Expect(ctx context.Context, rp1 *pb.RepositoryTag) *mRepositoryIMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryIMockUpsertRepositoryTagExpectation{}
	}

	if mmUpsertRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by ExpectParams functions")
	}

	mmUpsertRepositoryTag.defaultExpectation.params = &RepositoryIMockUpsertRepositoryTagParams{ctx, rp1}
	for _, e := range mmUpsertRepositoryTag.expectations {
		if minimock.Equal(e.params, mmUpsertRepositoryTag.defaultExpectation.params) {
			mmUpsertRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertRepositoryTag.defaultExpectation.params)
		}
	}

	return mmUpsertRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryIMockUpsertRepositoryTagExpectation{}
	}

	if mmUpsertRepositoryTag.defaultExpectation.params != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by Expect")
	}

	if mmUpsertRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmUpsertRepositoryTag.defaultExpectation.paramPtrs = &RepositoryIMockUpsertRepositoryTagParamPtrs{}
	}
	mmUpsertRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpsertRepositoryTag
}

// ExpectRp1Param2 sets up expected param rp1 for RepositoryI.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) ExpectRp1Param2(rp1 *pb.RepositoryTag) *mRepositoryIMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryIMockUpsertRepositoryTagExpectation{}
	}

	if mmUpsertRepositoryTag.defaultExpectation.params != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by Expect")
	}

	if mmUpsertRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmUpsertRepositoryTag.defaultExpectation.paramPtrs = &RepositoryIMockUpsertRepositoryTagParamPtrs{}
	}
	mmUpsertRepositoryTag.defaultExpectation.paramPtrs.rp1 = &rp1

	return mmUpsertRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) Inspect(f func(ctx context.Context, rp1 *pb.RepositoryTag)) *mRepositoryIMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.inspectFuncUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.UpsertRepositoryTag")
	}

	mmUpsertRepositoryTag.mock.inspectFuncUpsertRepositoryTag = f

	return mmUpsertRepositoryTag
}

// Return sets up results that will be returned by RepositoryI.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) Return(rp2 *pb.RepositoryTag, err error) *RepositoryIMock {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryIMockUpsertRepositoryTagExpectation{mock: mmUpsertRepositoryTag.mock}
	}
	mmUpsertRepositoryTag.defaultExpectation.results = &RepositoryIMockUpsertRepositoryTagResults{rp2, err}
	return mmUpsertRepositoryTag.mock
}

// Set uses given function f to mock the RepositoryI.UpsertRepositoryTag method
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) Set(f func(ctx context.Context, rp1 *pb.RepositoryTag) (rp2 *pb.RepositoryTag, err error)) *RepositoryIMock {
	if mmUpsertRepositoryTag.defaultExpectation != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("Default expectation is already set for the RepositoryI.UpsertRepositoryTag method")
	}

	if len(mmUpsertRepositoryTag.expectations) > 0 {
		mmUpsertRepositoryTag.mock.t.Fatalf("Some expectations are already set for the RepositoryI.UpsertRepositoryTag method")
	}

	mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag = f
	return mmUpsertRepositoryTag.mock
}

// When sets expectation for the RepositoryI.UpsertRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) When(ctx context.Context, rp1 *pb.RepositoryTag) *RepositoryIMockUpsertRepositoryTagExpectation {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by Set")
	}

	expectation := &RepositoryIMockUpsertRepositoryTagExpectation{
		mock:   mmUpsertRepositoryTag.mock,
		params: &RepositoryIMockUpsertRepositoryTagParams{ctx, rp1},
	}
	mmUpsertRepositoryTag.expectations = append(mmUpsertRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.UpsertRepositoryTag return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockUpsertRepositoryTagExpectation) Then(rp2 *pb.RepositoryTag, err error) *RepositoryIMock {
	e.results = &RepositoryIMockUpsertRepositoryTagResults{rp2, err}
	return e.mock
}

// Times sets number of times RepositoryI.UpsertRepositoryTag should be invoked
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) Times(n uint64) *mRepositoryIMockUpsertRepositoryTag {
	if n == 0 {
		mmUpsertRepositoryTag.mock.t.Fatalf("Times of RepositoryIMock.UpsertRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpsertRepositoryTag.expectedInvocations, n)
	return mmUpsertRepositoryTag
}

func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) invocationsDone() bool {
	if len(mmUpsertRepositoryTag.expectations) == 0 && mmUpsertRepositoryTag.defaultExpectation == nil && mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpsertRepositoryTag.mock.afterUpsertRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpsertRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpsertRepositoryTag implements repository.RepositoryI
func (mmUpsertRepositoryTag *RepositoryIMock) UpsertRepositoryTag(ctx context.Context, rp1 *pb.RepositoryTag) (rp2 *pb.RepositoryTag, err error) {
	mm_atomic.AddUint64(&mmUpsertRepositoryTag.beforeUpsertRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertRepositoryTag.afterUpsertRepositoryTagCounter, 1)

	if mmUpsertRepositoryTag.inspectFuncUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.inspectFuncUpsertRepositoryTag(ctx, rp1)
	}

	mm_params := RepositoryIMockUpsertRepositoryTagParams{ctx, rp1}

	// Record call args
	mmUpsertRepositoryTag.UpsertRepositoryTagMock.mutex.Lock()
	mmUpsertRepositoryTag.UpsertRepositoryTagMock.callArgs = append(mmUpsertRepositoryTag.UpsertRepositoryTagMock.callArgs, &mm_params)
	mmUpsertRepositoryTag.UpsertRepositoryTagMock.mutex.Unlock()

	for _, e := range mmUpsertRepositoryTag.UpsertRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp2, e.results.err
		}
	}

	if mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockUpsertRepositoryTagParams{ctx, rp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpsertRepositoryTag.t.Errorf("RepositoryIMock.UpsertRepositoryTag got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.rp1 != nil && !minimock.Equal(*mm_want_ptrs.rp1, mm_got.rp1) {
				mmUpsertRepositoryTag.t.Errorf("RepositoryIMock.UpsertRepositoryTag got unexpected parameter rp1, want: %#v, got: %#v%s\n", *mm_want_ptrs.rp1, mm_got.rp1, minimock.Diff(*mm_want_ptrs.rp1, mm_got.rp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsertRepositoryTag.t.Errorf("RepositoryIMock.UpsertRepositoryTag got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsertRepositoryTag.t.Fatal("No results are set for the RepositoryIMock.UpsertRepositoryTag")
		}
		return (*mm_results).rp2, (*mm_results).err
	}
	if mmUpsertRepositoryTag.funcUpsertRepositoryTag != nil {
		return mmUpsertRepositoryTag.funcUpsertRepositoryTag(ctx, rp1)
	}
	mmUpsertRepositoryTag.t.Fatalf("Unexpected call to RepositoryIMock.UpsertRepositoryTag. %v %v", ctx, rp1)
	return
}

// UpsertRepositoryTagAfterCounter returns a count of finished RepositoryIMock.UpsertRepositoryTag invocations
func (mmUpsertRepositoryTag *RepositoryIMock) UpsertRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertRepositoryTag.afterUpsertRepositoryTagCounter)
}

// UpsertRepositoryTagBeforeCounter returns a count of RepositoryIMock.UpsertRepositoryTag invocations
func (mmUpsertRepositoryTag *RepositoryIMock) UpsertRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertRepositoryTag.beforeUpsertRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.UpsertRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) Calls() []*RepositoryIMockUpsertRepositoryTagParams {
	mmUpsertRepositoryTag.mutex.RLock()

	argCopy := make([]*RepositoryIMockUpsertRepositoryTagParams, len(mmUpsertRepositoryTag.callArgs))
	copy(argCopy, mmUpsertRepositoryTag.callArgs)

	mmUpsertRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertRepositoryTagDone returns true if the count of the UpsertRepositoryTag invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockUpsertRepositoryTagDone() bool {
	for _, e := range m.UpsertRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpsertRepositoryTagMock.invocationsDone()
}

// MinimockUpsertRepositoryTagInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockUpsertRepositoryTagInspect() {
	for _, e := range m.UpsertRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.UpsertRepositoryTag with params: %#v", *e.params)
		}
	}

	afterUpsertRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterUpsertRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertRepositoryTagMock.defaultExpectation != nil && afterUpsertRepositoryTagCounter < 1 {
		if m.UpsertRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.UpsertRepositoryTag")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.UpsertRepositoryTag with params: %#v", *m.UpsertRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertRepositoryTag != nil && afterUpsertRepositoryTagCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.UpsertRepositoryTag")
	}

	if !m.UpsertRepositoryTagMock.invocationsDone() && afterUpsertRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.UpsertRepositoryTag but found %d calls",
			mm_atomic.LoadUint64(&m.UpsertRepositoryTagMock.expectedInvocations), afterUpsertRepositoryTagCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryIMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockConversationTableNameInspect()

			m.MinimockConvertedFileTableNameInspect()

			m.MinimockCreateConversationInspect()

			m.MinimockCreateConvertedFileInspect()

			m.MinimockCreateKnowledgeBaseInspect()

			m.MinimockCreateKnowledgeBaseFileInspect()

			m.MinimockCreateMessageInspect()

			m.MinimockDeleteAllConvertedFilesInKbInspect()

			m.MinimockDeleteAllKnowledgeBaseFilesInspect()

			m.MinimockDeleteAndCreateChunksInspect()

			m.MinimockDeleteChunksBySourceInspect()

			m.MinimockDeleteChunksByUIDsInspect()

			m.MinimockDeleteConvertedFileInspect()

			m.MinimockDeleteEmbeddingsBySourceInspect()

			m.MinimockDeleteEmbeddingsByUIDsInspect()

			m.MinimockDeleteKnowledgeBaseInspect()

			m.MinimockDeleteKnowledgeBaseFileInspect()

			m.MinimockDeleteKnowledgeBaseFileAndDecreaseUsageInspect()

			m.MinimockDeleteMessageInspect()

			m.MinimockDeleteRepositoryTagInspect()

			m.MinimockGetChunksByUIDsInspect()

			m.MinimockGetConversationByIDInspect()

			m.MinimockGetConversationByUIDInspect()

			m.MinimockGetConvertedFileByFileUIDInspect()

			m.MinimockGetCountFilesByListKnowledgeBaseUIDInspect()

			m.MinimockGetEmbeddingByUIDsInspect()

			m.MinimockGetFilesTotalTokensInspect()

			m.MinimockGetKnowledgeBaseByOwnerAndKbIDInspect()

			m.MinimockGetKnowledgeBaseCountByOwnerInspect()

			m.MinimockGetKnowledgeBaseFilesByFileUIDsInspect()

			m.MinimockGetKnowledgebaseFileByKbUIDAndFileIDInspect()

			m.MinimockGetMessageByUIDInspect()

			m.MinimockGetNeedProcessFilesInspect()

			m.MinimockGetRepositoryTagInspect()

			m.MinimockGetSourceTableAndUIDByFileUIDsInspect()

			m.MinimockGetTextChunksBySourceInspect()

			m.MinimockGetTotalChunksBySourcesInspect()

			m.MinimockGetTotalTokensByListKBUIDsInspect()

			m.MinimockGetTruthSourceByFileUIDInspect()

			m.MinimockHardDeleteChunksByKbFileUIDInspect()

			m.MinimockHardDeleteChunksByKbUIDInspect()

			m.MinimockHardDeleteConvertedFileByFileUIDInspect()

			m.MinimockHardDeleteEmbeddingsByKbFileUIDInspect()

			m.MinimockHardDeleteEmbeddingsByKbUIDInspect()

			m.MinimockIncreaseKnowledgeBaseUsageInspect()

			m.MinimockKnowledgeBaseFileTableNameInspect()

			m.MinimockListChunksByKbFileUIDInspect()

			m.MinimockListConversationsInspect()

			m.MinimockListEmbeddingsByKbFileUIDInspect()

			m.MinimockListKnowledgeBaseFilesInspect()

			m.MinimockListKnowledgeBasesInspect()

			m.MinimockListMessagesInspect()

			m.MinimockMessageTableNameInspect()

			m.MinimockProcessKnowledgeBaseFilesInspect()

			m.MinimockSoftDeleteConversationInspect()

			m.MinimockTextChunkTableNameInspect()

			m.MinimockUpdateChunkInspect()

			m.MinimockUpdateConversationByUpdateMapInspect()

			m.MinimockUpdateKbFileExtraMetaDataInspect()

			m.MinimockUpdateKnowledgeBaseInspect()

			m.MinimockUpdateKnowledgeBaseFileInspect()

			m.MinimockUpdateMessageInspect()

			m.MinimockUpdateMessageByUpdateMapInspect()

			m.MinimockUpsertEmbeddingsInspect()

			m.MinimockUpsertRepositoryTagInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryIMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryIMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockConversationTableNameDone() &&
		m.MinimockConvertedFileTableNameDone() &&
		m.MinimockCreateConversationDone() &&
		m.MinimockCreateConvertedFileDone() &&
		m.MinimockCreateKnowledgeBaseDone() &&
		m.MinimockCreateKnowledgeBaseFileDone() &&
		m.MinimockCreateMessageDone() &&
		m.MinimockDeleteAllConvertedFilesInKbDone() &&
		m.MinimockDeleteAllKnowledgeBaseFilesDone() &&
		m.MinimockDeleteAndCreateChunksDone() &&
		m.MinimockDeleteChunksBySourceDone() &&
		m.MinimockDeleteChunksByUIDsDone() &&
		m.MinimockDeleteConvertedFileDone() &&
		m.MinimockDeleteEmbeddingsBySourceDone() &&
		m.MinimockDeleteEmbeddingsByUIDsDone() &&
		m.MinimockDeleteKnowledgeBaseDone() &&
		m.MinimockDeleteKnowledgeBaseFileDone() &&
		m.MinimockDeleteKnowledgeBaseFileAndDecreaseUsageDone() &&
		m.MinimockDeleteMessageDone() &&
		m.MinimockDeleteRepositoryTagDone() &&
		m.MinimockGetChunksByUIDsDone() &&
		m.MinimockGetConversationByIDDone() &&
		m.MinimockGetConversationByUIDDone() &&
		m.MinimockGetConvertedFileByFileUIDDone() &&
		m.MinimockGetCountFilesByListKnowledgeBaseUIDDone() &&
		m.MinimockGetEmbeddingByUIDsDone() &&
		m.MinimockGetFilesTotalTokensDone() &&
		m.MinimockGetKnowledgeBaseByOwnerAndKbIDDone() &&
		m.MinimockGetKnowledgeBaseCountByOwnerDone() &&
		m.MinimockGetKnowledgeBaseFilesByFileUIDsDone() &&
		m.MinimockGetKnowledgebaseFileByKbUIDAndFileIDDone() &&
		m.MinimockGetMessageByUIDDone() &&
		m.MinimockGetNeedProcessFilesDone() &&
		m.MinimockGetRepositoryTagDone() &&
		m.MinimockGetSourceTableAndUIDByFileUIDsDone() &&
		m.MinimockGetTextChunksBySourceDone() &&
		m.MinimockGetTotalChunksBySourcesDone() &&
		m.MinimockGetTotalTokensByListKBUIDsDone() &&
		m.MinimockGetTruthSourceByFileUIDDone() &&
		m.MinimockHardDeleteChunksByKbFileUIDDone() &&
		m.MinimockHardDeleteChunksByKbUIDDone() &&
		m.MinimockHardDeleteConvertedFileByFileUIDDone() &&
		m.MinimockHardDeleteEmbeddingsByKbFileUIDDone() &&
		m.MinimockHardDeleteEmbeddingsByKbUIDDone() &&
		m.MinimockIncreaseKnowledgeBaseUsageDone() &&
		m.MinimockKnowledgeBaseFileTableNameDone() &&
		m.MinimockListChunksByKbFileUIDDone() &&
		m.MinimockListConversationsDone() &&
		m.MinimockListEmbeddingsByKbFileUIDDone() &&
		m.MinimockListKnowledgeBaseFilesDone() &&
		m.MinimockListKnowledgeBasesDone() &&
		m.MinimockListMessagesDone() &&
		m.MinimockMessageTableNameDone() &&
		m.MinimockProcessKnowledgeBaseFilesDone() &&
		m.MinimockSoftDeleteConversationDone() &&
		m.MinimockTextChunkTableNameDone() &&
		m.MinimockUpdateChunkDone() &&
		m.MinimockUpdateConversationByUpdateMapDone() &&
		m.MinimockUpdateKbFileExtraMetaDataDone() &&
		m.MinimockUpdateKnowledgeBaseDone() &&
		m.MinimockUpdateKnowledgeBaseFileDone() &&
		m.MinimockUpdateMessageDone() &&
		m.MinimockUpdateMessageByUpdateMapDone() &&
		m.MinimockUpsertEmbeddingsDone() &&
		m.MinimockUpsertRepositoryTagDone()
}
