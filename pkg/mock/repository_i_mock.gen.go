// Code generated by http://github.com/gojuno/minimock (v3.3.9). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_repository "github.com/instill-ai/artifact-backend/pkg/repository"
	"github.com/instill-ai/artifact-backend/pkg/utils"
	artifactpb "github.com/instill-ai/protogen-go/artifact/artifact/v1alpha"
)

// RepositoryIMock implements repository.RepositoryI
type RepositoryIMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateKnowledgeBase          func(ctx context.Context, kb mm_repository.KnowledgeBase) (kp1 *mm_repository.KnowledgeBase, err error)
	inspectFuncCreateKnowledgeBase   func(ctx context.Context, kb mm_repository.KnowledgeBase)
	afterCreateKnowledgeBaseCounter  uint64
	beforeCreateKnowledgeBaseCounter uint64
	CreateKnowledgeBaseMock          mRepositoryIMockCreateKnowledgeBase

	funcDeleteKnowledgeBase          func(ctx context.Context, kb mm_repository.KnowledgeBase) (err error)
	inspectFuncDeleteKnowledgeBase   func(ctx context.Context, kb mm_repository.KnowledgeBase)
	afterDeleteKnowledgeBaseCounter  uint64
	beforeDeleteKnowledgeBaseCounter uint64
	DeleteKnowledgeBaseMock          mRepositoryIMockDeleteKnowledgeBase

	funcGetKnowledgeBase          func(ctx context.Context) (ka1 []mm_repository.KnowledgeBase, err error)
	inspectFuncGetKnowledgeBase   func(ctx context.Context)
	afterGetKnowledgeBaseCounter  uint64
	beforeGetKnowledgeBaseCounter uint64
	GetKnowledgeBaseMock          mRepositoryIMockGetKnowledgeBase

	funcGetRepositoryTag          func(ctx context.Context, r1 utils.RepositoryTagName) (rp1 *artifactpb.RepositoryTag, err error)
	inspectFuncGetRepositoryTag   func(ctx context.Context, r1 utils.RepositoryTagName)
	afterGetRepositoryTagCounter  uint64
	beforeGetRepositoryTagCounter uint64
	GetRepositoryTagMock          mRepositoryIMockGetRepositoryTag

	funcUpdateKnowledgeBase          func(ctx context.Context, kb mm_repository.KnowledgeBase) (kp1 *mm_repository.KnowledgeBase, err error)
	inspectFuncUpdateKnowledgeBase   func(ctx context.Context, kb mm_repository.KnowledgeBase)
	afterUpdateKnowledgeBaseCounter  uint64
	beforeUpdateKnowledgeBaseCounter uint64
	UpdateKnowledgeBaseMock          mRepositoryIMockUpdateKnowledgeBase

	funcUpsertRepositoryTag          func(ctx context.Context, rp1 *artifactpb.RepositoryTag) (rp2 *artifactpb.RepositoryTag, err error)
	inspectFuncUpsertRepositoryTag   func(ctx context.Context, rp1 *artifactpb.RepositoryTag)
	afterUpsertRepositoryTagCounter  uint64
	beforeUpsertRepositoryTagCounter uint64
	UpsertRepositoryTagMock          mRepositoryIMockUpsertRepositoryTag
}

// NewRepositoryIMock returns a mock for repository.RepositoryI
func NewRepositoryIMock(t minimock.Tester) *RepositoryIMock {
	m := &RepositoryIMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateKnowledgeBaseMock = mRepositoryIMockCreateKnowledgeBase{mock: m}
	m.CreateKnowledgeBaseMock.callArgs = []*RepositoryIMockCreateKnowledgeBaseParams{}

	m.DeleteKnowledgeBaseMock = mRepositoryIMockDeleteKnowledgeBase{mock: m}
	m.DeleteKnowledgeBaseMock.callArgs = []*RepositoryIMockDeleteKnowledgeBaseParams{}

	m.GetKnowledgeBaseMock = mRepositoryIMockGetKnowledgeBase{mock: m}
	m.GetKnowledgeBaseMock.callArgs = []*RepositoryIMockGetKnowledgeBaseParams{}

	m.GetRepositoryTagMock = mRepositoryIMockGetRepositoryTag{mock: m}
	m.GetRepositoryTagMock.callArgs = []*RepositoryIMockGetRepositoryTagParams{}

	m.UpdateKnowledgeBaseMock = mRepositoryIMockUpdateKnowledgeBase{mock: m}
	m.UpdateKnowledgeBaseMock.callArgs = []*RepositoryIMockUpdateKnowledgeBaseParams{}

	m.UpsertRepositoryTagMock = mRepositoryIMockUpsertRepositoryTag{mock: m}
	m.UpsertRepositoryTagMock.callArgs = []*RepositoryIMockUpsertRepositoryTagParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryIMockCreateKnowledgeBase struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockCreateKnowledgeBaseExpectation
	expectations       []*RepositoryIMockCreateKnowledgeBaseExpectation

	callArgs []*RepositoryIMockCreateKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockCreateKnowledgeBaseExpectation specifies expectation struct of the RepositoryI.CreateKnowledgeBase
type RepositoryIMockCreateKnowledgeBaseExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockCreateKnowledgeBaseParams
	paramPtrs *RepositoryIMockCreateKnowledgeBaseParamPtrs
	results   *RepositoryIMockCreateKnowledgeBaseResults
	Counter   uint64
}

// RepositoryIMockCreateKnowledgeBaseParams contains parameters of the RepositoryI.CreateKnowledgeBase
type RepositoryIMockCreateKnowledgeBaseParams struct {
	ctx context.Context
	kb  mm_repository.KnowledgeBase
}

// RepositoryIMockCreateKnowledgeBaseParamPtrs contains pointers to parameters of the RepositoryI.CreateKnowledgeBase
type RepositoryIMockCreateKnowledgeBaseParamPtrs struct {
	ctx *context.Context
	kb  *mm_repository.KnowledgeBase
}

// RepositoryIMockCreateKnowledgeBaseResults contains results of the RepositoryI.CreateKnowledgeBase
type RepositoryIMockCreateKnowledgeBaseResults struct {
	kp1 *mm_repository.KnowledgeBase
	err error
}

// Expect sets up expected params for RepositoryI.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) Expect(ctx context.Context, kb mm_repository.KnowledgeBase) *mRepositoryIMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmCreateKnowledgeBase.defaultExpectation.params = &RepositoryIMockCreateKnowledgeBaseParams{ctx, kb}
	for _, e := range mmCreateKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmCreateKnowledgeBase.defaultExpectation.params) {
			mmCreateKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmCreateKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.params != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Expect")
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockCreateKnowledgeBaseParamPtrs{}
	}
	mmCreateKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateKnowledgeBase
}

// ExpectKbParam2 sets up expected param kb for RepositoryI.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) ExpectKbParam2(kb mm_repository.KnowledgeBase) *mRepositoryIMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.params != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Expect")
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockCreateKnowledgeBaseParamPtrs{}
	}
	mmCreateKnowledgeBase.defaultExpectation.paramPtrs.kb = &kb

	return mmCreateKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) Inspect(f func(ctx context.Context, kb mm_repository.KnowledgeBase)) *mRepositoryIMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.inspectFuncCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.CreateKnowledgeBase")
	}

	mmCreateKnowledgeBase.mock.inspectFuncCreateKnowledgeBase = f

	return mmCreateKnowledgeBase
}

// Return sets up results that will be returned by RepositoryI.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) Return(kp1 *mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseExpectation{mock: mmCreateKnowledgeBase.mock}
	}
	mmCreateKnowledgeBase.defaultExpectation.results = &RepositoryIMockCreateKnowledgeBaseResults{kp1, err}
	return mmCreateKnowledgeBase.mock
}

// Set uses given function f to mock the RepositoryI.CreateKnowledgeBase method
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) Set(f func(ctx context.Context, kb mm_repository.KnowledgeBase) (kp1 *mm_repository.KnowledgeBase, err error)) *RepositoryIMock {
	if mmCreateKnowledgeBase.defaultExpectation != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the RepositoryI.CreateKnowledgeBase method")
	}

	if len(mmCreateKnowledgeBase.expectations) > 0 {
		mmCreateKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the RepositoryI.CreateKnowledgeBase method")
	}

	mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase = f
	return mmCreateKnowledgeBase.mock
}

// When sets expectation for the RepositoryI.CreateKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) When(ctx context.Context, kb mm_repository.KnowledgeBase) *RepositoryIMockCreateKnowledgeBaseExpectation {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Set")
	}

	expectation := &RepositoryIMockCreateKnowledgeBaseExpectation{
		mock:   mmCreateKnowledgeBase.mock,
		params: &RepositoryIMockCreateKnowledgeBaseParams{ctx, kb},
	}
	mmCreateKnowledgeBase.expectations = append(mmCreateKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.CreateKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockCreateKnowledgeBaseExpectation) Then(kp1 *mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	e.results = &RepositoryIMockCreateKnowledgeBaseResults{kp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.CreateKnowledgeBase should be invoked
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) Times(n uint64) *mRepositoryIMockCreateKnowledgeBase {
	if n == 0 {
		mmCreateKnowledgeBase.mock.t.Fatalf("Times of RepositoryIMock.CreateKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateKnowledgeBase.expectedInvocations, n)
	return mmCreateKnowledgeBase
}

func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) invocationsDone() bool {
	if len(mmCreateKnowledgeBase.expectations) == 0 && mmCreateKnowledgeBase.defaultExpectation == nil && mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateKnowledgeBase.mock.afterCreateKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateKnowledgeBase implements repository.RepositoryI
func (mmCreateKnowledgeBase *RepositoryIMock) CreateKnowledgeBase(ctx context.Context, kb mm_repository.KnowledgeBase) (kp1 *mm_repository.KnowledgeBase, err error) {
	mm_atomic.AddUint64(&mmCreateKnowledgeBase.beforeCreateKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateKnowledgeBase.afterCreateKnowledgeBaseCounter, 1)

	if mmCreateKnowledgeBase.inspectFuncCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.inspectFuncCreateKnowledgeBase(ctx, kb)
	}

	mm_params := RepositoryIMockCreateKnowledgeBaseParams{ctx, kb}

	// Record call args
	mmCreateKnowledgeBase.CreateKnowledgeBaseMock.mutex.Lock()
	mmCreateKnowledgeBase.CreateKnowledgeBaseMock.callArgs = append(mmCreateKnowledgeBase.CreateKnowledgeBaseMock.callArgs, &mm_params)
	mmCreateKnowledgeBase.CreateKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmCreateKnowledgeBase.CreateKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockCreateKnowledgeBaseParams{ctx, kb}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateKnowledgeBase.t.Errorf("RepositoryIMock.CreateKnowledgeBase got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kb != nil && !minimock.Equal(*mm_want_ptrs.kb, mm_got.kb) {
				mmCreateKnowledgeBase.t.Errorf("RepositoryIMock.CreateKnowledgeBase got unexpected parameter kb, want: %#v, got: %#v%s\n", *mm_want_ptrs.kb, mm_got.kb, minimock.Diff(*mm_want_ptrs.kb, mm_got.kb))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateKnowledgeBase.t.Errorf("RepositoryIMock.CreateKnowledgeBase got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateKnowledgeBase.t.Fatal("No results are set for the RepositoryIMock.CreateKnowledgeBase")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmCreateKnowledgeBase.funcCreateKnowledgeBase != nil {
		return mmCreateKnowledgeBase.funcCreateKnowledgeBase(ctx, kb)
	}
	mmCreateKnowledgeBase.t.Fatalf("Unexpected call to RepositoryIMock.CreateKnowledgeBase. %v %v", ctx, kb)
	return
}

// CreateKnowledgeBaseAfterCounter returns a count of finished RepositoryIMock.CreateKnowledgeBase invocations
func (mmCreateKnowledgeBase *RepositoryIMock) CreateKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateKnowledgeBase.afterCreateKnowledgeBaseCounter)
}

// CreateKnowledgeBaseBeforeCounter returns a count of RepositoryIMock.CreateKnowledgeBase invocations
func (mmCreateKnowledgeBase *RepositoryIMock) CreateKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateKnowledgeBase.beforeCreateKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.CreateKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) Calls() []*RepositoryIMockCreateKnowledgeBaseParams {
	mmCreateKnowledgeBase.mutex.RLock()

	argCopy := make([]*RepositoryIMockCreateKnowledgeBaseParams, len(mmCreateKnowledgeBase.callArgs))
	copy(argCopy, mmCreateKnowledgeBase.callArgs)

	mmCreateKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockCreateKnowledgeBaseDone returns true if the count of the CreateKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockCreateKnowledgeBaseDone() bool {
	for _, e := range m.CreateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateKnowledgeBaseMock.invocationsDone()
}

// MinimockCreateKnowledgeBaseInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockCreateKnowledgeBaseInspect() {
	for _, e := range m.CreateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.CreateKnowledgeBase with params: %#v", *e.params)
		}
	}

	afterCreateKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterCreateKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateKnowledgeBaseMock.defaultExpectation != nil && afterCreateKnowledgeBaseCounter < 1 {
		if m.CreateKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.CreateKnowledgeBase")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.CreateKnowledgeBase with params: %#v", *m.CreateKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateKnowledgeBase != nil && afterCreateKnowledgeBaseCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.CreateKnowledgeBase")
	}

	if !m.CreateKnowledgeBaseMock.invocationsDone() && afterCreateKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.CreateKnowledgeBase but found %d calls",
			mm_atomic.LoadUint64(&m.CreateKnowledgeBaseMock.expectedInvocations), afterCreateKnowledgeBaseCounter)
	}
}

type mRepositoryIMockDeleteKnowledgeBase struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteKnowledgeBaseExpectation
	expectations       []*RepositoryIMockDeleteKnowledgeBaseExpectation

	callArgs []*RepositoryIMockDeleteKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteKnowledgeBaseExpectation specifies expectation struct of the RepositoryI.DeleteKnowledgeBase
type RepositoryIMockDeleteKnowledgeBaseExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteKnowledgeBaseParams
	paramPtrs *RepositoryIMockDeleteKnowledgeBaseParamPtrs
	results   *RepositoryIMockDeleteKnowledgeBaseResults
	Counter   uint64
}

// RepositoryIMockDeleteKnowledgeBaseParams contains parameters of the RepositoryI.DeleteKnowledgeBase
type RepositoryIMockDeleteKnowledgeBaseParams struct {
	ctx context.Context
	kb  mm_repository.KnowledgeBase
}

// RepositoryIMockDeleteKnowledgeBaseParamPtrs contains pointers to parameters of the RepositoryI.DeleteKnowledgeBase
type RepositoryIMockDeleteKnowledgeBaseParamPtrs struct {
	ctx *context.Context
	kb  *mm_repository.KnowledgeBase
}

// RepositoryIMockDeleteKnowledgeBaseResults contains results of the RepositoryI.DeleteKnowledgeBase
type RepositoryIMockDeleteKnowledgeBaseResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) Expect(ctx context.Context, kb mm_repository.KnowledgeBase) *mRepositoryIMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmDeleteKnowledgeBase.defaultExpectation.params = &RepositoryIMockDeleteKnowledgeBaseParams{ctx, kb}
	for _, e := range mmDeleteKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmDeleteKnowledgeBase.defaultExpectation.params) {
			mmDeleteKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmDeleteKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.params != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Expect")
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockDeleteKnowledgeBaseParamPtrs{}
	}
	mmDeleteKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteKnowledgeBase
}

// ExpectKbParam2 sets up expected param kb for RepositoryI.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) ExpectKbParam2(kb mm_repository.KnowledgeBase) *mRepositoryIMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.params != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Expect")
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockDeleteKnowledgeBaseParamPtrs{}
	}
	mmDeleteKnowledgeBase.defaultExpectation.paramPtrs.kb = &kb

	return mmDeleteKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) Inspect(f func(ctx context.Context, kb mm_repository.KnowledgeBase)) *mRepositoryIMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.inspectFuncDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteKnowledgeBase")
	}

	mmDeleteKnowledgeBase.mock.inspectFuncDeleteKnowledgeBase = f

	return mmDeleteKnowledgeBase
}

// Return sets up results that will be returned by RepositoryI.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) Return(err error) *RepositoryIMock {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseExpectation{mock: mmDeleteKnowledgeBase.mock}
	}
	mmDeleteKnowledgeBase.defaultExpectation.results = &RepositoryIMockDeleteKnowledgeBaseResults{err}
	return mmDeleteKnowledgeBase.mock
}

// Set uses given function f to mock the RepositoryI.DeleteKnowledgeBase method
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) Set(f func(ctx context.Context, kb mm_repository.KnowledgeBase) (err error)) *RepositoryIMock {
	if mmDeleteKnowledgeBase.defaultExpectation != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteKnowledgeBase method")
	}

	if len(mmDeleteKnowledgeBase.expectations) > 0 {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteKnowledgeBase method")
	}

	mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase = f
	return mmDeleteKnowledgeBase.mock
}

// When sets expectation for the RepositoryI.DeleteKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) When(ctx context.Context, kb mm_repository.KnowledgeBase) *RepositoryIMockDeleteKnowledgeBaseExpectation {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteKnowledgeBaseExpectation{
		mock:   mmDeleteKnowledgeBase.mock,
		params: &RepositoryIMockDeleteKnowledgeBaseParams{ctx, kb},
	}
	mmDeleteKnowledgeBase.expectations = append(mmDeleteKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteKnowledgeBaseExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteKnowledgeBaseResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteKnowledgeBase should be invoked
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) Times(n uint64) *mRepositoryIMockDeleteKnowledgeBase {
	if n == 0 {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Times of RepositoryIMock.DeleteKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteKnowledgeBase.expectedInvocations, n)
	return mmDeleteKnowledgeBase
}

func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) invocationsDone() bool {
	if len(mmDeleteKnowledgeBase.expectations) == 0 && mmDeleteKnowledgeBase.defaultExpectation == nil && mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.mock.afterDeleteKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteKnowledgeBase implements repository.RepositoryI
func (mmDeleteKnowledgeBase *RepositoryIMock) DeleteKnowledgeBase(ctx context.Context, kb mm_repository.KnowledgeBase) (err error) {
	mm_atomic.AddUint64(&mmDeleteKnowledgeBase.beforeDeleteKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteKnowledgeBase.afterDeleteKnowledgeBaseCounter, 1)

	if mmDeleteKnowledgeBase.inspectFuncDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.inspectFuncDeleteKnowledgeBase(ctx, kb)
	}

	mm_params := RepositoryIMockDeleteKnowledgeBaseParams{ctx, kb}

	// Record call args
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.mutex.Lock()
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.callArgs = append(mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.callArgs, &mm_params)
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteKnowledgeBaseParams{ctx, kb}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteKnowledgeBase.t.Errorf("RepositoryIMock.DeleteKnowledgeBase got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kb != nil && !minimock.Equal(*mm_want_ptrs.kb, mm_got.kb) {
				mmDeleteKnowledgeBase.t.Errorf("RepositoryIMock.DeleteKnowledgeBase got unexpected parameter kb, want: %#v, got: %#v%s\n", *mm_want_ptrs.kb, mm_got.kb, minimock.Diff(*mm_want_ptrs.kb, mm_got.kb))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteKnowledgeBase.t.Errorf("RepositoryIMock.DeleteKnowledgeBase got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteKnowledgeBase.t.Fatal("No results are set for the RepositoryIMock.DeleteKnowledgeBase")
		}
		return (*mm_results).err
	}
	if mmDeleteKnowledgeBase.funcDeleteKnowledgeBase != nil {
		return mmDeleteKnowledgeBase.funcDeleteKnowledgeBase(ctx, kb)
	}
	mmDeleteKnowledgeBase.t.Fatalf("Unexpected call to RepositoryIMock.DeleteKnowledgeBase. %v %v", ctx, kb)
	return
}

// DeleteKnowledgeBaseAfterCounter returns a count of finished RepositoryIMock.DeleteKnowledgeBase invocations
func (mmDeleteKnowledgeBase *RepositoryIMock) DeleteKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.afterDeleteKnowledgeBaseCounter)
}

// DeleteKnowledgeBaseBeforeCounter returns a count of RepositoryIMock.DeleteKnowledgeBase invocations
func (mmDeleteKnowledgeBase *RepositoryIMock) DeleteKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.beforeDeleteKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) Calls() []*RepositoryIMockDeleteKnowledgeBaseParams {
	mmDeleteKnowledgeBase.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteKnowledgeBaseParams, len(mmDeleteKnowledgeBase.callArgs))
	copy(argCopy, mmDeleteKnowledgeBase.callArgs)

	mmDeleteKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteKnowledgeBaseDone returns true if the count of the DeleteKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteKnowledgeBaseDone() bool {
	for _, e := range m.DeleteKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteKnowledgeBaseMock.invocationsDone()
}

// MinimockDeleteKnowledgeBaseInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteKnowledgeBaseInspect() {
	for _, e := range m.DeleteKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteKnowledgeBase with params: %#v", *e.params)
		}
	}

	afterDeleteKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterDeleteKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteKnowledgeBaseMock.defaultExpectation != nil && afterDeleteKnowledgeBaseCounter < 1 {
		if m.DeleteKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteKnowledgeBase")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteKnowledgeBase with params: %#v", *m.DeleteKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteKnowledgeBase != nil && afterDeleteKnowledgeBaseCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteKnowledgeBase")
	}

	if !m.DeleteKnowledgeBaseMock.invocationsDone() && afterDeleteKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteKnowledgeBase but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteKnowledgeBaseMock.expectedInvocations), afterDeleteKnowledgeBaseCounter)
	}
}

type mRepositoryIMockGetKnowledgeBase struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetKnowledgeBaseExpectation
	expectations       []*RepositoryIMockGetKnowledgeBaseExpectation

	callArgs []*RepositoryIMockGetKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetKnowledgeBaseExpectation specifies expectation struct of the RepositoryI.GetKnowledgeBase
type RepositoryIMockGetKnowledgeBaseExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetKnowledgeBaseParams
	paramPtrs *RepositoryIMockGetKnowledgeBaseParamPtrs
	results   *RepositoryIMockGetKnowledgeBaseResults
	Counter   uint64
}

// RepositoryIMockGetKnowledgeBaseParams contains parameters of the RepositoryI.GetKnowledgeBase
type RepositoryIMockGetKnowledgeBaseParams struct {
	ctx context.Context
}

// RepositoryIMockGetKnowledgeBaseParamPtrs contains pointers to parameters of the RepositoryI.GetKnowledgeBase
type RepositoryIMockGetKnowledgeBaseParamPtrs struct {
	ctx *context.Context
}

// RepositoryIMockGetKnowledgeBaseResults contains results of the RepositoryI.GetKnowledgeBase
type RepositoryIMockGetKnowledgeBaseResults struct {
	ka1 []mm_repository.KnowledgeBase
	err error
}

// Expect sets up expected params for RepositoryI.GetKnowledgeBase
func (mmGetKnowledgeBase *mRepositoryIMockGetKnowledgeBase) Expect(ctx context.Context) *mRepositoryIMockGetKnowledgeBase {
	if mmGetKnowledgeBase.mock.funcGetKnowledgeBase != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBase mock is already set by Set")
	}

	if mmGetKnowledgeBase.defaultExpectation == nil {
		mmGetKnowledgeBase.defaultExpectation = &RepositoryIMockGetKnowledgeBaseExpectation{}
	}

	if mmGetKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBase.defaultExpectation.params = &RepositoryIMockGetKnowledgeBaseParams{ctx}
	for _, e := range mmGetKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBase.defaultExpectation.params) {
			mmGetKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetKnowledgeBase
func (mmGetKnowledgeBase *mRepositoryIMockGetKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetKnowledgeBase {
	if mmGetKnowledgeBase.mock.funcGetKnowledgeBase != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBase mock is already set by Set")
	}

	if mmGetKnowledgeBase.defaultExpectation == nil {
		mmGetKnowledgeBase.defaultExpectation = &RepositoryIMockGetKnowledgeBaseExpectation{}
	}

	if mmGetKnowledgeBase.defaultExpectation.params != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBase mock is already set by Expect")
	}

	if mmGetKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockGetKnowledgeBaseParamPtrs{}
	}
	mmGetKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetKnowledgeBase
func (mmGetKnowledgeBase *mRepositoryIMockGetKnowledgeBase) Inspect(f func(ctx context.Context)) *mRepositoryIMockGetKnowledgeBase {
	if mmGetKnowledgeBase.mock.inspectFuncGetKnowledgeBase != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetKnowledgeBase")
	}

	mmGetKnowledgeBase.mock.inspectFuncGetKnowledgeBase = f

	return mmGetKnowledgeBase
}

// Return sets up results that will be returned by RepositoryI.GetKnowledgeBase
func (mmGetKnowledgeBase *mRepositoryIMockGetKnowledgeBase) Return(ka1 []mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	if mmGetKnowledgeBase.mock.funcGetKnowledgeBase != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBase mock is already set by Set")
	}

	if mmGetKnowledgeBase.defaultExpectation == nil {
		mmGetKnowledgeBase.defaultExpectation = &RepositoryIMockGetKnowledgeBaseExpectation{mock: mmGetKnowledgeBase.mock}
	}
	mmGetKnowledgeBase.defaultExpectation.results = &RepositoryIMockGetKnowledgeBaseResults{ka1, err}
	return mmGetKnowledgeBase.mock
}

// Set uses given function f to mock the RepositoryI.GetKnowledgeBase method
func (mmGetKnowledgeBase *mRepositoryIMockGetKnowledgeBase) Set(f func(ctx context.Context) (ka1 []mm_repository.KnowledgeBase, err error)) *RepositoryIMock {
	if mmGetKnowledgeBase.defaultExpectation != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetKnowledgeBase method")
	}

	if len(mmGetKnowledgeBase.expectations) > 0 {
		mmGetKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetKnowledgeBase method")
	}

	mmGetKnowledgeBase.mock.funcGetKnowledgeBase = f
	return mmGetKnowledgeBase.mock
}

// When sets expectation for the RepositoryI.GetKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBase *mRepositoryIMockGetKnowledgeBase) When(ctx context.Context) *RepositoryIMockGetKnowledgeBaseExpectation {
	if mmGetKnowledgeBase.mock.funcGetKnowledgeBase != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBase mock is already set by Set")
	}

	expectation := &RepositoryIMockGetKnowledgeBaseExpectation{
		mock:   mmGetKnowledgeBase.mock,
		params: &RepositoryIMockGetKnowledgeBaseParams{ctx},
	}
	mmGetKnowledgeBase.expectations = append(mmGetKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetKnowledgeBaseExpectation) Then(ka1 []mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetKnowledgeBaseResults{ka1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetKnowledgeBase should be invoked
func (mmGetKnowledgeBase *mRepositoryIMockGetKnowledgeBase) Times(n uint64) *mRepositoryIMockGetKnowledgeBase {
	if n == 0 {
		mmGetKnowledgeBase.mock.t.Fatalf("Times of RepositoryIMock.GetKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBase.expectedInvocations, n)
	return mmGetKnowledgeBase
}

func (mmGetKnowledgeBase *mRepositoryIMockGetKnowledgeBase) invocationsDone() bool {
	if len(mmGetKnowledgeBase.expectations) == 0 && mmGetKnowledgeBase.defaultExpectation == nil && mmGetKnowledgeBase.mock.funcGetKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBase.mock.afterGetKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBase implements repository.RepositoryI
func (mmGetKnowledgeBase *RepositoryIMock) GetKnowledgeBase(ctx context.Context) (ka1 []mm_repository.KnowledgeBase, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBase.beforeGetKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBase.afterGetKnowledgeBaseCounter, 1)

	if mmGetKnowledgeBase.inspectFuncGetKnowledgeBase != nil {
		mmGetKnowledgeBase.inspectFuncGetKnowledgeBase(ctx)
	}

	mm_params := RepositoryIMockGetKnowledgeBaseParams{ctx}

	// Record call args
	mmGetKnowledgeBase.GetKnowledgeBaseMock.mutex.Lock()
	mmGetKnowledgeBase.GetKnowledgeBaseMock.callArgs = append(mmGetKnowledgeBase.GetKnowledgeBaseMock.callArgs, &mm_params)
	mmGetKnowledgeBase.GetKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBase.GetKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmGetKnowledgeBase.GetKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBase.GetKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBase.GetKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBase.GetKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetKnowledgeBaseParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBase.t.Errorf("RepositoryIMock.GetKnowledgeBase got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBase.t.Errorf("RepositoryIMock.GetKnowledgeBase got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBase.GetKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBase.t.Fatal("No results are set for the RepositoryIMock.GetKnowledgeBase")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmGetKnowledgeBase.funcGetKnowledgeBase != nil {
		return mmGetKnowledgeBase.funcGetKnowledgeBase(ctx)
	}
	mmGetKnowledgeBase.t.Fatalf("Unexpected call to RepositoryIMock.GetKnowledgeBase. %v", ctx)
	return
}

// GetKnowledgeBaseAfterCounter returns a count of finished RepositoryIMock.GetKnowledgeBase invocations
func (mmGetKnowledgeBase *RepositoryIMock) GetKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBase.afterGetKnowledgeBaseCounter)
}

// GetKnowledgeBaseBeforeCounter returns a count of RepositoryIMock.GetKnowledgeBase invocations
func (mmGetKnowledgeBase *RepositoryIMock) GetKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBase.beforeGetKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBase *mRepositoryIMockGetKnowledgeBase) Calls() []*RepositoryIMockGetKnowledgeBaseParams {
	mmGetKnowledgeBase.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetKnowledgeBaseParams, len(mmGetKnowledgeBase.callArgs))
	copy(argCopy, mmGetKnowledgeBase.callArgs)

	mmGetKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBaseDone returns true if the count of the GetKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetKnowledgeBaseDone() bool {
	for _, e := range m.GetKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBaseMock.invocationsDone()
}

// MinimockGetKnowledgeBaseInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetKnowledgeBaseInspect() {
	for _, e := range m.GetKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetKnowledgeBase with params: %#v", *e.params)
		}
	}

	afterGetKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBaseMock.defaultExpectation != nil && afterGetKnowledgeBaseCounter < 1 {
		if m.GetKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetKnowledgeBase")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetKnowledgeBase with params: %#v", *m.GetKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBase != nil && afterGetKnowledgeBaseCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetKnowledgeBase")
	}

	if !m.GetKnowledgeBaseMock.invocationsDone() && afterGetKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetKnowledgeBase but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBaseMock.expectedInvocations), afterGetKnowledgeBaseCounter)
	}
}

type mRepositoryIMockGetRepositoryTag struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetRepositoryTagExpectation
	expectations       []*RepositoryIMockGetRepositoryTagExpectation

	callArgs []*RepositoryIMockGetRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetRepositoryTagExpectation specifies expectation struct of the RepositoryI.GetRepositoryTag
type RepositoryIMockGetRepositoryTagExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetRepositoryTagParams
	paramPtrs *RepositoryIMockGetRepositoryTagParamPtrs
	results   *RepositoryIMockGetRepositoryTagResults
	Counter   uint64
}

// RepositoryIMockGetRepositoryTagParams contains parameters of the RepositoryI.GetRepositoryTag
type RepositoryIMockGetRepositoryTagParams struct {
	ctx context.Context
	r1  utils.RepositoryTagName
}

// RepositoryIMockGetRepositoryTagParamPtrs contains pointers to parameters of the RepositoryI.GetRepositoryTag
type RepositoryIMockGetRepositoryTagParamPtrs struct {
	ctx *context.Context
	r1  *utils.RepositoryTagName
}

// RepositoryIMockGetRepositoryTagResults contains results of the RepositoryI.GetRepositoryTag
type RepositoryIMockGetRepositoryTagResults struct {
	rp1 *artifactpb.RepositoryTag
	err error
}

// Expect sets up expected params for RepositoryI.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) Expect(ctx context.Context, r1 utils.RepositoryTagName) *mRepositoryIMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryIMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by ExpectParams functions")
	}

	mmGetRepositoryTag.defaultExpectation.params = &RepositoryIMockGetRepositoryTagParams{ctx, r1}
	for _, e := range mmGetRepositoryTag.expectations {
		if minimock.Equal(e.params, mmGetRepositoryTag.defaultExpectation.params) {
			mmGetRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRepositoryTag.defaultExpectation.params)
		}
	}

	return mmGetRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryIMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.params != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by Expect")
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmGetRepositoryTag.defaultExpectation.paramPtrs = &RepositoryIMockGetRepositoryTagParamPtrs{}
	}
	mmGetRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetRepositoryTag
}

// ExpectR1Param2 sets up expected param r1 for RepositoryI.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) ExpectR1Param2(r1 utils.RepositoryTagName) *mRepositoryIMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryIMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.params != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by Expect")
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmGetRepositoryTag.defaultExpectation.paramPtrs = &RepositoryIMockGetRepositoryTagParamPtrs{}
	}
	mmGetRepositoryTag.defaultExpectation.paramPtrs.r1 = &r1

	return mmGetRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) Inspect(f func(ctx context.Context, r1 utils.RepositoryTagName)) *mRepositoryIMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.inspectFuncGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetRepositoryTag")
	}

	mmGetRepositoryTag.mock.inspectFuncGetRepositoryTag = f

	return mmGetRepositoryTag
}

// Return sets up results that will be returned by RepositoryI.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) Return(rp1 *artifactpb.RepositoryTag, err error) *RepositoryIMock {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryIMockGetRepositoryTagExpectation{mock: mmGetRepositoryTag.mock}
	}
	mmGetRepositoryTag.defaultExpectation.results = &RepositoryIMockGetRepositoryTagResults{rp1, err}
	return mmGetRepositoryTag.mock
}

// Set uses given function f to mock the RepositoryI.GetRepositoryTag method
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) Set(f func(ctx context.Context, r1 utils.RepositoryTagName) (rp1 *artifactpb.RepositoryTag, err error)) *RepositoryIMock {
	if mmGetRepositoryTag.defaultExpectation != nil {
		mmGetRepositoryTag.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetRepositoryTag method")
	}

	if len(mmGetRepositoryTag.expectations) > 0 {
		mmGetRepositoryTag.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetRepositoryTag method")
	}

	mmGetRepositoryTag.mock.funcGetRepositoryTag = f
	return mmGetRepositoryTag.mock
}

// When sets expectation for the RepositoryI.GetRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) When(ctx context.Context, r1 utils.RepositoryTagName) *RepositoryIMockGetRepositoryTagExpectation {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by Set")
	}

	expectation := &RepositoryIMockGetRepositoryTagExpectation{
		mock:   mmGetRepositoryTag.mock,
		params: &RepositoryIMockGetRepositoryTagParams{ctx, r1},
	}
	mmGetRepositoryTag.expectations = append(mmGetRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetRepositoryTag return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetRepositoryTagExpectation) Then(rp1 *artifactpb.RepositoryTag, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetRepositoryTagResults{rp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetRepositoryTag should be invoked
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) Times(n uint64) *mRepositoryIMockGetRepositoryTag {
	if n == 0 {
		mmGetRepositoryTag.mock.t.Fatalf("Times of RepositoryIMock.GetRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRepositoryTag.expectedInvocations, n)
	return mmGetRepositoryTag
}

func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) invocationsDone() bool {
	if len(mmGetRepositoryTag.expectations) == 0 && mmGetRepositoryTag.defaultExpectation == nil && mmGetRepositoryTag.mock.funcGetRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRepositoryTag.mock.afterGetRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRepositoryTag implements repository.RepositoryI
func (mmGetRepositoryTag *RepositoryIMock) GetRepositoryTag(ctx context.Context, r1 utils.RepositoryTagName) (rp1 *artifactpb.RepositoryTag, err error) {
	mm_atomic.AddUint64(&mmGetRepositoryTag.beforeGetRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRepositoryTag.afterGetRepositoryTagCounter, 1)

	if mmGetRepositoryTag.inspectFuncGetRepositoryTag != nil {
		mmGetRepositoryTag.inspectFuncGetRepositoryTag(ctx, r1)
	}

	mm_params := RepositoryIMockGetRepositoryTagParams{ctx, r1}

	// Record call args
	mmGetRepositoryTag.GetRepositoryTagMock.mutex.Lock()
	mmGetRepositoryTag.GetRepositoryTagMock.callArgs = append(mmGetRepositoryTag.GetRepositoryTagMock.callArgs, &mm_params)
	mmGetRepositoryTag.GetRepositoryTagMock.mutex.Unlock()

	for _, e := range mmGetRepositoryTag.GetRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetRepositoryTagParams{ctx, r1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetRepositoryTag.t.Errorf("RepositoryIMock.GetRepositoryTag got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.r1 != nil && !minimock.Equal(*mm_want_ptrs.r1, mm_got.r1) {
				mmGetRepositoryTag.t.Errorf("RepositoryIMock.GetRepositoryTag got unexpected parameter r1, want: %#v, got: %#v%s\n", *mm_want_ptrs.r1, mm_got.r1, minimock.Diff(*mm_want_ptrs.r1, mm_got.r1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRepositoryTag.t.Errorf("RepositoryIMock.GetRepositoryTag got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRepositoryTag.t.Fatal("No results are set for the RepositoryIMock.GetRepositoryTag")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmGetRepositoryTag.funcGetRepositoryTag != nil {
		return mmGetRepositoryTag.funcGetRepositoryTag(ctx, r1)
	}
	mmGetRepositoryTag.t.Fatalf("Unexpected call to RepositoryIMock.GetRepositoryTag. %v %v", ctx, r1)
	return
}

// GetRepositoryTagAfterCounter returns a count of finished RepositoryIMock.GetRepositoryTag invocations
func (mmGetRepositoryTag *RepositoryIMock) GetRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRepositoryTag.afterGetRepositoryTagCounter)
}

// GetRepositoryTagBeforeCounter returns a count of RepositoryIMock.GetRepositoryTag invocations
func (mmGetRepositoryTag *RepositoryIMock) GetRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRepositoryTag.beforeGetRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) Calls() []*RepositoryIMockGetRepositoryTagParams {
	mmGetRepositoryTag.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetRepositoryTagParams, len(mmGetRepositoryTag.callArgs))
	copy(argCopy, mmGetRepositoryTag.callArgs)

	mmGetRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockGetRepositoryTagDone returns true if the count of the GetRepositoryTag invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetRepositoryTagDone() bool {
	for _, e := range m.GetRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRepositoryTagMock.invocationsDone()
}

// MinimockGetRepositoryTagInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetRepositoryTagInspect() {
	for _, e := range m.GetRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetRepositoryTag with params: %#v", *e.params)
		}
	}

	afterGetRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterGetRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRepositoryTagMock.defaultExpectation != nil && afterGetRepositoryTagCounter < 1 {
		if m.GetRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetRepositoryTag")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetRepositoryTag with params: %#v", *m.GetRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRepositoryTag != nil && afterGetRepositoryTagCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetRepositoryTag")
	}

	if !m.GetRepositoryTagMock.invocationsDone() && afterGetRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetRepositoryTag but found %d calls",
			mm_atomic.LoadUint64(&m.GetRepositoryTagMock.expectedInvocations), afterGetRepositoryTagCounter)
	}
}

type mRepositoryIMockUpdateKnowledgeBase struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockUpdateKnowledgeBaseExpectation
	expectations       []*RepositoryIMockUpdateKnowledgeBaseExpectation

	callArgs []*RepositoryIMockUpdateKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockUpdateKnowledgeBaseExpectation specifies expectation struct of the RepositoryI.UpdateKnowledgeBase
type RepositoryIMockUpdateKnowledgeBaseExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockUpdateKnowledgeBaseParams
	paramPtrs *RepositoryIMockUpdateKnowledgeBaseParamPtrs
	results   *RepositoryIMockUpdateKnowledgeBaseResults
	Counter   uint64
}

// RepositoryIMockUpdateKnowledgeBaseParams contains parameters of the RepositoryI.UpdateKnowledgeBase
type RepositoryIMockUpdateKnowledgeBaseParams struct {
	ctx context.Context
	kb  mm_repository.KnowledgeBase
}

// RepositoryIMockUpdateKnowledgeBaseParamPtrs contains pointers to parameters of the RepositoryI.UpdateKnowledgeBase
type RepositoryIMockUpdateKnowledgeBaseParamPtrs struct {
	ctx *context.Context
	kb  *mm_repository.KnowledgeBase
}

// RepositoryIMockUpdateKnowledgeBaseResults contains results of the RepositoryI.UpdateKnowledgeBase
type RepositoryIMockUpdateKnowledgeBaseResults struct {
	kp1 *mm_repository.KnowledgeBase
	err error
}

// Expect sets up expected params for RepositoryI.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) Expect(ctx context.Context, kb mm_repository.KnowledgeBase) *mRepositoryIMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmUpdateKnowledgeBase.defaultExpectation.params = &RepositoryIMockUpdateKnowledgeBaseParams{ctx, kb}
	for _, e := range mmUpdateKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmUpdateKnowledgeBase.defaultExpectation.params) {
			mmUpdateKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmUpdateKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.params != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Expect")
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKnowledgeBaseParamPtrs{}
	}
	mmUpdateKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateKnowledgeBase
}

// ExpectKbParam2 sets up expected param kb for RepositoryI.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) ExpectKbParam2(kb mm_repository.KnowledgeBase) *mRepositoryIMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.params != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Expect")
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKnowledgeBaseParamPtrs{}
	}
	mmUpdateKnowledgeBase.defaultExpectation.paramPtrs.kb = &kb

	return mmUpdateKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) Inspect(f func(ctx context.Context, kb mm_repository.KnowledgeBase)) *mRepositoryIMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.inspectFuncUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.UpdateKnowledgeBase")
	}

	mmUpdateKnowledgeBase.mock.inspectFuncUpdateKnowledgeBase = f

	return mmUpdateKnowledgeBase
}

// Return sets up results that will be returned by RepositoryI.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) Return(kp1 *mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseExpectation{mock: mmUpdateKnowledgeBase.mock}
	}
	mmUpdateKnowledgeBase.defaultExpectation.results = &RepositoryIMockUpdateKnowledgeBaseResults{kp1, err}
	return mmUpdateKnowledgeBase.mock
}

// Set uses given function f to mock the RepositoryI.UpdateKnowledgeBase method
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) Set(f func(ctx context.Context, kb mm_repository.KnowledgeBase) (kp1 *mm_repository.KnowledgeBase, err error)) *RepositoryIMock {
	if mmUpdateKnowledgeBase.defaultExpectation != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the RepositoryI.UpdateKnowledgeBase method")
	}

	if len(mmUpdateKnowledgeBase.expectations) > 0 {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the RepositoryI.UpdateKnowledgeBase method")
	}

	mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase = f
	return mmUpdateKnowledgeBase.mock
}

// When sets expectation for the RepositoryI.UpdateKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) When(ctx context.Context, kb mm_repository.KnowledgeBase) *RepositoryIMockUpdateKnowledgeBaseExpectation {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Set")
	}

	expectation := &RepositoryIMockUpdateKnowledgeBaseExpectation{
		mock:   mmUpdateKnowledgeBase.mock,
		params: &RepositoryIMockUpdateKnowledgeBaseParams{ctx, kb},
	}
	mmUpdateKnowledgeBase.expectations = append(mmUpdateKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.UpdateKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockUpdateKnowledgeBaseExpectation) Then(kp1 *mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	e.results = &RepositoryIMockUpdateKnowledgeBaseResults{kp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.UpdateKnowledgeBase should be invoked
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) Times(n uint64) *mRepositoryIMockUpdateKnowledgeBase {
	if n == 0 {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Times of RepositoryIMock.UpdateKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateKnowledgeBase.expectedInvocations, n)
	return mmUpdateKnowledgeBase
}

func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) invocationsDone() bool {
	if len(mmUpdateKnowledgeBase.expectations) == 0 && mmUpdateKnowledgeBase.defaultExpectation == nil && mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.mock.afterUpdateKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateKnowledgeBase implements repository.RepositoryI
func (mmUpdateKnowledgeBase *RepositoryIMock) UpdateKnowledgeBase(ctx context.Context, kb mm_repository.KnowledgeBase) (kp1 *mm_repository.KnowledgeBase, err error) {
	mm_atomic.AddUint64(&mmUpdateKnowledgeBase.beforeUpdateKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateKnowledgeBase.afterUpdateKnowledgeBaseCounter, 1)

	if mmUpdateKnowledgeBase.inspectFuncUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.inspectFuncUpdateKnowledgeBase(ctx, kb)
	}

	mm_params := RepositoryIMockUpdateKnowledgeBaseParams{ctx, kb}

	// Record call args
	mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.mutex.Lock()
	mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.callArgs = append(mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.callArgs, &mm_params)
	mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockUpdateKnowledgeBaseParams{ctx, kb}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateKnowledgeBase.t.Errorf("RepositoryIMock.UpdateKnowledgeBase got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kb != nil && !minimock.Equal(*mm_want_ptrs.kb, mm_got.kb) {
				mmUpdateKnowledgeBase.t.Errorf("RepositoryIMock.UpdateKnowledgeBase got unexpected parameter kb, want: %#v, got: %#v%s\n", *mm_want_ptrs.kb, mm_got.kb, minimock.Diff(*mm_want_ptrs.kb, mm_got.kb))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateKnowledgeBase.t.Errorf("RepositoryIMock.UpdateKnowledgeBase got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateKnowledgeBase.t.Fatal("No results are set for the RepositoryIMock.UpdateKnowledgeBase")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmUpdateKnowledgeBase.funcUpdateKnowledgeBase != nil {
		return mmUpdateKnowledgeBase.funcUpdateKnowledgeBase(ctx, kb)
	}
	mmUpdateKnowledgeBase.t.Fatalf("Unexpected call to RepositoryIMock.UpdateKnowledgeBase. %v %v", ctx, kb)
	return
}

// UpdateKnowledgeBaseAfterCounter returns a count of finished RepositoryIMock.UpdateKnowledgeBase invocations
func (mmUpdateKnowledgeBase *RepositoryIMock) UpdateKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.afterUpdateKnowledgeBaseCounter)
}

// UpdateKnowledgeBaseBeforeCounter returns a count of RepositoryIMock.UpdateKnowledgeBase invocations
func (mmUpdateKnowledgeBase *RepositoryIMock) UpdateKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.beforeUpdateKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.UpdateKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) Calls() []*RepositoryIMockUpdateKnowledgeBaseParams {
	mmUpdateKnowledgeBase.mutex.RLock()

	argCopy := make([]*RepositoryIMockUpdateKnowledgeBaseParams, len(mmUpdateKnowledgeBase.callArgs))
	copy(argCopy, mmUpdateKnowledgeBase.callArgs)

	mmUpdateKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateKnowledgeBaseDone returns true if the count of the UpdateKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockUpdateKnowledgeBaseDone() bool {
	for _, e := range m.UpdateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateKnowledgeBaseMock.invocationsDone()
}

// MinimockUpdateKnowledgeBaseInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockUpdateKnowledgeBaseInspect() {
	for _, e := range m.UpdateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateKnowledgeBase with params: %#v", *e.params)
		}
	}

	afterUpdateKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterUpdateKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateKnowledgeBaseMock.defaultExpectation != nil && afterUpdateKnowledgeBaseCounter < 1 {
		if m.UpdateKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.UpdateKnowledgeBase")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateKnowledgeBase with params: %#v", *m.UpdateKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateKnowledgeBase != nil && afterUpdateKnowledgeBaseCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.UpdateKnowledgeBase")
	}

	if !m.UpdateKnowledgeBaseMock.invocationsDone() && afterUpdateKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.UpdateKnowledgeBase but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateKnowledgeBaseMock.expectedInvocations), afterUpdateKnowledgeBaseCounter)
	}
}

type mRepositoryIMockUpsertRepositoryTag struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockUpsertRepositoryTagExpectation
	expectations       []*RepositoryIMockUpsertRepositoryTagExpectation

	callArgs []*RepositoryIMockUpsertRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockUpsertRepositoryTagExpectation specifies expectation struct of the RepositoryI.UpsertRepositoryTag
type RepositoryIMockUpsertRepositoryTagExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockUpsertRepositoryTagParams
	paramPtrs *RepositoryIMockUpsertRepositoryTagParamPtrs
	results   *RepositoryIMockUpsertRepositoryTagResults
	Counter   uint64
}

// RepositoryIMockUpsertRepositoryTagParams contains parameters of the RepositoryI.UpsertRepositoryTag
type RepositoryIMockUpsertRepositoryTagParams struct {
	ctx context.Context
	rp1 *artifactpb.RepositoryTag
}

// RepositoryIMockUpsertRepositoryTagParamPtrs contains pointers to parameters of the RepositoryI.UpsertRepositoryTag
type RepositoryIMockUpsertRepositoryTagParamPtrs struct {
	ctx *context.Context
	rp1 **artifactpb.RepositoryTag
}

// RepositoryIMockUpsertRepositoryTagResults contains results of the RepositoryI.UpsertRepositoryTag
type RepositoryIMockUpsertRepositoryTagResults struct {
	rp2 *artifactpb.RepositoryTag
	err error
}

// Expect sets up expected params for RepositoryI.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) Expect(ctx context.Context, rp1 *artifactpb.RepositoryTag) *mRepositoryIMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryIMockUpsertRepositoryTagExpectation{}
	}

	if mmUpsertRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by ExpectParams functions")
	}

	mmUpsertRepositoryTag.defaultExpectation.params = &RepositoryIMockUpsertRepositoryTagParams{ctx, rp1}
	for _, e := range mmUpsertRepositoryTag.expectations {
		if minimock.Equal(e.params, mmUpsertRepositoryTag.defaultExpectation.params) {
			mmUpsertRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertRepositoryTag.defaultExpectation.params)
		}
	}

	return mmUpsertRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryIMockUpsertRepositoryTagExpectation{}
	}

	if mmUpsertRepositoryTag.defaultExpectation.params != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by Expect")
	}

	if mmUpsertRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmUpsertRepositoryTag.defaultExpectation.paramPtrs = &RepositoryIMockUpsertRepositoryTagParamPtrs{}
	}
	mmUpsertRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpsertRepositoryTag
}

// ExpectRp1Param2 sets up expected param rp1 for RepositoryI.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) ExpectRp1Param2(rp1 *artifactpb.RepositoryTag) *mRepositoryIMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryIMockUpsertRepositoryTagExpectation{}
	}

	if mmUpsertRepositoryTag.defaultExpectation.params != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by Expect")
	}

	if mmUpsertRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmUpsertRepositoryTag.defaultExpectation.paramPtrs = &RepositoryIMockUpsertRepositoryTagParamPtrs{}
	}
	mmUpsertRepositoryTag.defaultExpectation.paramPtrs.rp1 = &rp1

	return mmUpsertRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) Inspect(f func(ctx context.Context, rp1 *artifactpb.RepositoryTag)) *mRepositoryIMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.inspectFuncUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.UpsertRepositoryTag")
	}

	mmUpsertRepositoryTag.mock.inspectFuncUpsertRepositoryTag = f

	return mmUpsertRepositoryTag
}

// Return sets up results that will be returned by RepositoryI.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) Return(rp2 *artifactpb.RepositoryTag, err error) *RepositoryIMock {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryIMockUpsertRepositoryTagExpectation{mock: mmUpsertRepositoryTag.mock}
	}
	mmUpsertRepositoryTag.defaultExpectation.results = &RepositoryIMockUpsertRepositoryTagResults{rp2, err}
	return mmUpsertRepositoryTag.mock
}

// Set uses given function f to mock the RepositoryI.UpsertRepositoryTag method
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) Set(f func(ctx context.Context, rp1 *artifactpb.RepositoryTag) (rp2 *artifactpb.RepositoryTag, err error)) *RepositoryIMock {
	if mmUpsertRepositoryTag.defaultExpectation != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("Default expectation is already set for the RepositoryI.UpsertRepositoryTag method")
	}

	if len(mmUpsertRepositoryTag.expectations) > 0 {
		mmUpsertRepositoryTag.mock.t.Fatalf("Some expectations are already set for the RepositoryI.UpsertRepositoryTag method")
	}

	mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag = f
	return mmUpsertRepositoryTag.mock
}

// When sets expectation for the RepositoryI.UpsertRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) When(ctx context.Context, rp1 *artifactpb.RepositoryTag) *RepositoryIMockUpsertRepositoryTagExpectation {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by Set")
	}

	expectation := &RepositoryIMockUpsertRepositoryTagExpectation{
		mock:   mmUpsertRepositoryTag.mock,
		params: &RepositoryIMockUpsertRepositoryTagParams{ctx, rp1},
	}
	mmUpsertRepositoryTag.expectations = append(mmUpsertRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.UpsertRepositoryTag return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockUpsertRepositoryTagExpectation) Then(rp2 *artifactpb.RepositoryTag, err error) *RepositoryIMock {
	e.results = &RepositoryIMockUpsertRepositoryTagResults{rp2, err}
	return e.mock
}

// Times sets number of times RepositoryI.UpsertRepositoryTag should be invoked
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) Times(n uint64) *mRepositoryIMockUpsertRepositoryTag {
	if n == 0 {
		mmUpsertRepositoryTag.mock.t.Fatalf("Times of RepositoryIMock.UpsertRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpsertRepositoryTag.expectedInvocations, n)
	return mmUpsertRepositoryTag
}

func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) invocationsDone() bool {
	if len(mmUpsertRepositoryTag.expectations) == 0 && mmUpsertRepositoryTag.defaultExpectation == nil && mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpsertRepositoryTag.mock.afterUpsertRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpsertRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpsertRepositoryTag implements repository.RepositoryI
func (mmUpsertRepositoryTag *RepositoryIMock) UpsertRepositoryTag(ctx context.Context, rp1 *artifactpb.RepositoryTag) (rp2 *artifactpb.RepositoryTag, err error) {
	mm_atomic.AddUint64(&mmUpsertRepositoryTag.beforeUpsertRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertRepositoryTag.afterUpsertRepositoryTagCounter, 1)

	if mmUpsertRepositoryTag.inspectFuncUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.inspectFuncUpsertRepositoryTag(ctx, rp1)
	}

	mm_params := RepositoryIMockUpsertRepositoryTagParams{ctx, rp1}

	// Record call args
	mmUpsertRepositoryTag.UpsertRepositoryTagMock.mutex.Lock()
	mmUpsertRepositoryTag.UpsertRepositoryTagMock.callArgs = append(mmUpsertRepositoryTag.UpsertRepositoryTagMock.callArgs, &mm_params)
	mmUpsertRepositoryTag.UpsertRepositoryTagMock.mutex.Unlock()

	for _, e := range mmUpsertRepositoryTag.UpsertRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp2, e.results.err
		}
	}

	if mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockUpsertRepositoryTagParams{ctx, rp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpsertRepositoryTag.t.Errorf("RepositoryIMock.UpsertRepositoryTag got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.rp1 != nil && !minimock.Equal(*mm_want_ptrs.rp1, mm_got.rp1) {
				mmUpsertRepositoryTag.t.Errorf("RepositoryIMock.UpsertRepositoryTag got unexpected parameter rp1, want: %#v, got: %#v%s\n", *mm_want_ptrs.rp1, mm_got.rp1, minimock.Diff(*mm_want_ptrs.rp1, mm_got.rp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsertRepositoryTag.t.Errorf("RepositoryIMock.UpsertRepositoryTag got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsertRepositoryTag.t.Fatal("No results are set for the RepositoryIMock.UpsertRepositoryTag")
		}
		return (*mm_results).rp2, (*mm_results).err
	}
	if mmUpsertRepositoryTag.funcUpsertRepositoryTag != nil {
		return mmUpsertRepositoryTag.funcUpsertRepositoryTag(ctx, rp1)
	}
	mmUpsertRepositoryTag.t.Fatalf("Unexpected call to RepositoryIMock.UpsertRepositoryTag. %v %v", ctx, rp1)
	return
}

// UpsertRepositoryTagAfterCounter returns a count of finished RepositoryIMock.UpsertRepositoryTag invocations
func (mmUpsertRepositoryTag *RepositoryIMock) UpsertRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertRepositoryTag.afterUpsertRepositoryTagCounter)
}

// UpsertRepositoryTagBeforeCounter returns a count of RepositoryIMock.UpsertRepositoryTag invocations
func (mmUpsertRepositoryTag *RepositoryIMock) UpsertRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertRepositoryTag.beforeUpsertRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.UpsertRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) Calls() []*RepositoryIMockUpsertRepositoryTagParams {
	mmUpsertRepositoryTag.mutex.RLock()

	argCopy := make([]*RepositoryIMockUpsertRepositoryTagParams, len(mmUpsertRepositoryTag.callArgs))
	copy(argCopy, mmUpsertRepositoryTag.callArgs)

	mmUpsertRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertRepositoryTagDone returns true if the count of the UpsertRepositoryTag invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockUpsertRepositoryTagDone() bool {
	for _, e := range m.UpsertRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpsertRepositoryTagMock.invocationsDone()
}

// MinimockUpsertRepositoryTagInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockUpsertRepositoryTagInspect() {
	for _, e := range m.UpsertRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.UpsertRepositoryTag with params: %#v", *e.params)
		}
	}

	afterUpsertRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterUpsertRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertRepositoryTagMock.defaultExpectation != nil && afterUpsertRepositoryTagCounter < 1 {
		if m.UpsertRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.UpsertRepositoryTag")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.UpsertRepositoryTag with params: %#v", *m.UpsertRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertRepositoryTag != nil && afterUpsertRepositoryTagCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.UpsertRepositoryTag")
	}

	if !m.UpsertRepositoryTagMock.invocationsDone() && afterUpsertRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.UpsertRepositoryTag but found %d calls",
			mm_atomic.LoadUint64(&m.UpsertRepositoryTagMock.expectedInvocations), afterUpsertRepositoryTagCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryIMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateKnowledgeBaseInspect()

			m.MinimockDeleteKnowledgeBaseInspect()

			m.MinimockGetKnowledgeBaseInspect()

			m.MinimockGetRepositoryTagInspect()

			m.MinimockUpdateKnowledgeBaseInspect()

			m.MinimockUpsertRepositoryTagInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryIMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryIMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateKnowledgeBaseDone() &&
		m.MinimockDeleteKnowledgeBaseDone() &&
		m.MinimockGetKnowledgeBaseDone() &&
		m.MinimockGetRepositoryTagDone() &&
		m.MinimockUpdateKnowledgeBaseDone() &&
		m.MinimockUpsertRepositoryTagDone()
}
