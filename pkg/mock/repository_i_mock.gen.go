// Code generated by http://github.com/gojuno/minimock (v3.3.9). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gofrs/uuid"
	"github.com/gojuno/minimock/v3"
	mm_repository "github.com/instill-ai/artifact-backend/pkg/repository"
	"github.com/instill-ai/artifact-backend/pkg/utils"
	"gorm.io/gorm"
	artifactpb "github.com/instill-ai/protogen-go/artifact/artifact/v1alpha"
	pb "github.com/instill-ai/protogen-go/artifact/artifact/v1alpha"
)

// RepositoryIMock implements repository.RepositoryI
type RepositoryIMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcConvertedFileTableName          func() (s1 string)
	inspectFuncConvertedFileTableName   func()
	afterConvertedFileTableNameCounter  uint64
	beforeConvertedFileTableNameCounter uint64
	ConvertedFileTableNameMock          mRepositoryIMockConvertedFileTableName

	funcCreateConvertedFile          func(ctx context.Context, cf mm_repository.ConvertedFile, callExternalService func(convertedFileUID uuid.UUID) (map[string]any, error)) (cp1 *mm_repository.ConvertedFile, err error)
	inspectFuncCreateConvertedFile   func(ctx context.Context, cf mm_repository.ConvertedFile, callExternalService func(convertedFileUID uuid.UUID) (map[string]any, error))
	afterCreateConvertedFileCounter  uint64
	beforeCreateConvertedFileCounter uint64
	CreateConvertedFileMock          mRepositoryIMockCreateConvertedFile

	funcCreateKnowledgeBase          func(ctx context.Context, kb mm_repository.KnowledgeBase, externalService func(kbUID string) error) (kp1 *mm_repository.KnowledgeBase, err error)
	inspectFuncCreateKnowledgeBase   func(ctx context.Context, kb mm_repository.KnowledgeBase, externalService func(kbUID string) error)
	afterCreateKnowledgeBaseCounter  uint64
	beforeCreateKnowledgeBaseCounter uint64
	CreateKnowledgeBaseMock          mRepositoryIMockCreateKnowledgeBase

	funcCreateKnowledgeBaseFile          func(ctx context.Context, kb mm_repository.KnowledgeBaseFile, externalServiceCall func(FileUID string) error) (kp1 *mm_repository.KnowledgeBaseFile, err error)
	inspectFuncCreateKnowledgeBaseFile   func(ctx context.Context, kb mm_repository.KnowledgeBaseFile, externalServiceCall func(FileUID string) error)
	afterCreateKnowledgeBaseFileCounter  uint64
	beforeCreateKnowledgeBaseFileCounter uint64
	CreateKnowledgeBaseFileMock          mRepositoryIMockCreateKnowledgeBaseFile

	funcCreateObject          func(ctx context.Context, obj mm_repository.Object) (op1 *mm_repository.Object, err error)
	inspectFuncCreateObject   func(ctx context.Context, obj mm_repository.Object)
	afterCreateObjectCounter  uint64
	beforeCreateObjectCounter uint64
	CreateObjectMock          mRepositoryIMockCreateObject

	funcCreateObjectURL          func(ctx context.Context, objectURL mm_repository.ObjectURL) (op1 *mm_repository.ObjectURL, err error)
	inspectFuncCreateObjectURL   func(ctx context.Context, objectURL mm_repository.ObjectURL)
	afterCreateObjectURLCounter  uint64
	beforeCreateObjectURLCounter uint64
	CreateObjectURLMock          mRepositoryIMockCreateObjectURL

	funcDeleteAllConvertedFilesInKb          func(ctx context.Context, kbUID uuid.UUID) (err error)
	inspectFuncDeleteAllConvertedFilesInKb   func(ctx context.Context, kbUID uuid.UUID)
	afterDeleteAllConvertedFilesInKbCounter  uint64
	beforeDeleteAllConvertedFilesInKbCounter uint64
	DeleteAllConvertedFilesInKbMock          mRepositoryIMockDeleteAllConvertedFilesInKb

	funcDeleteAllKnowledgeBaseFiles          func(ctx context.Context, kbUID string) (err error)
	inspectFuncDeleteAllKnowledgeBaseFiles   func(ctx context.Context, kbUID string)
	afterDeleteAllKnowledgeBaseFilesCounter  uint64
	beforeDeleteAllKnowledgeBaseFilesCounter uint64
	DeleteAllKnowledgeBaseFilesMock          mRepositoryIMockDeleteAllKnowledgeBaseFiles

	funcDeleteAndCreateChunks          func(ctx context.Context, sourceTable string, sourceUID uuid.UUID, chunks []*mm_repository.TextChunk, externalServiceCall func(chunkUIDs []string) (map[string]any, error)) (tpa1 []*mm_repository.TextChunk, err error)
	inspectFuncDeleteAndCreateChunks   func(ctx context.Context, sourceTable string, sourceUID uuid.UUID, chunks []*mm_repository.TextChunk, externalServiceCall func(chunkUIDs []string) (map[string]any, error))
	afterDeleteAndCreateChunksCounter  uint64
	beforeDeleteAndCreateChunksCounter uint64
	DeleteAndCreateChunksMock          mRepositoryIMockDeleteAndCreateChunks

	funcDeleteChunksBySource          func(ctx context.Context, sourceTable string, sourceUID uuid.UUID) (err error)
	inspectFuncDeleteChunksBySource   func(ctx context.Context, sourceTable string, sourceUID uuid.UUID)
	afterDeleteChunksBySourceCounter  uint64
	beforeDeleteChunksBySourceCounter uint64
	DeleteChunksBySourceMock          mRepositoryIMockDeleteChunksBySource

	funcDeleteChunksByUIDs          func(ctx context.Context, chunkUIDs []uuid.UUID) (err error)
	inspectFuncDeleteChunksByUIDs   func(ctx context.Context, chunkUIDs []uuid.UUID)
	afterDeleteChunksByUIDsCounter  uint64
	beforeDeleteChunksByUIDsCounter uint64
	DeleteChunksByUIDsMock          mRepositoryIMockDeleteChunksByUIDs

	funcDeleteConvertedFile          func(ctx context.Context, uid uuid.UUID) (err error)
	inspectFuncDeleteConvertedFile   func(ctx context.Context, uid uuid.UUID)
	afterDeleteConvertedFileCounter  uint64
	beforeDeleteConvertedFileCounter uint64
	DeleteConvertedFileMock          mRepositoryIMockDeleteConvertedFile

	funcDeleteEmbeddingsBySource          func(ctx context.Context, sourceTable string, sourceUID uuid.UUID) (err error)
	inspectFuncDeleteEmbeddingsBySource   func(ctx context.Context, sourceTable string, sourceUID uuid.UUID)
	afterDeleteEmbeddingsBySourceCounter  uint64
	beforeDeleteEmbeddingsBySourceCounter uint64
	DeleteEmbeddingsBySourceMock          mRepositoryIMockDeleteEmbeddingsBySource

	funcDeleteEmbeddingsByUIDs          func(ctx context.Context, embUIDs []uuid.UUID) (err error)
	inspectFuncDeleteEmbeddingsByUIDs   func(ctx context.Context, embUIDs []uuid.UUID)
	afterDeleteEmbeddingsByUIDsCounter  uint64
	beforeDeleteEmbeddingsByUIDsCounter uint64
	DeleteEmbeddingsByUIDsMock          mRepositoryIMockDeleteEmbeddingsByUIDs

	funcDeleteKnowledgeBase          func(ctx context.Context, ownerUID string, kbID string) (kp1 *mm_repository.KnowledgeBase, err error)
	inspectFuncDeleteKnowledgeBase   func(ctx context.Context, ownerUID string, kbID string)
	afterDeleteKnowledgeBaseCounter  uint64
	beforeDeleteKnowledgeBaseCounter uint64
	DeleteKnowledgeBaseMock          mRepositoryIMockDeleteKnowledgeBase

	funcDeleteKnowledgeBaseFile          func(ctx context.Context, fileUID string) (err error)
	inspectFuncDeleteKnowledgeBaseFile   func(ctx context.Context, fileUID string)
	afterDeleteKnowledgeBaseFileCounter  uint64
	beforeDeleteKnowledgeBaseFileCounter uint64
	DeleteKnowledgeBaseFileMock          mRepositoryIMockDeleteKnowledgeBaseFile

	funcDeleteKnowledgeBaseFileAndDecreaseUsage          func(ctx context.Context, fileUID uuid.UUID) (err error)
	inspectFuncDeleteKnowledgeBaseFileAndDecreaseUsage   func(ctx context.Context, fileUID uuid.UUID)
	afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter  uint64
	beforeDeleteKnowledgeBaseFileAndDecreaseUsageCounter uint64
	DeleteKnowledgeBaseFileAndDecreaseUsageMock          mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage

	funcDeleteObject          func(ctx context.Context, uid uuid.UUID) (err error)
	inspectFuncDeleteObject   func(ctx context.Context, uid uuid.UUID)
	afterDeleteObjectCounter  uint64
	beforeDeleteObjectCounter uint64
	DeleteObjectMock          mRepositoryIMockDeleteObject

	funcDeleteObjectURL          func(ctx context.Context, uid uuid.UUID) (err error)
	inspectFuncDeleteObjectURL   func(ctx context.Context, uid uuid.UUID)
	afterDeleteObjectURLCounter  uint64
	beforeDeleteObjectURLCounter uint64
	DeleteObjectURLMock          mRepositoryIMockDeleteObjectURL

	funcDeleteRepositoryTag          func(ctx context.Context, s1 string) (err error)
	inspectFuncDeleteRepositoryTag   func(ctx context.Context, s1 string)
	afterDeleteRepositoryTagCounter  uint64
	beforeDeleteRepositoryTagCounter uint64
	DeleteRepositoryTagMock          mRepositoryIMockDeleteRepositoryTag

	funcGetChunksByUIDs          func(ctx context.Context, chunkUIDs []uuid.UUID) (ta1 []mm_repository.TextChunk, err error)
	inspectFuncGetChunksByUIDs   func(ctx context.Context, chunkUIDs []uuid.UUID)
	afterGetChunksByUIDsCounter  uint64
	beforeGetChunksByUIDsCounter uint64
	GetChunksByUIDsMock          mRepositoryIMockGetChunksByUIDs

	funcGetConvertedFileByFileUID          func(ctx context.Context, fileUID uuid.UUID) (cp1 *mm_repository.ConvertedFile, err error)
	inspectFuncGetConvertedFileByFileUID   func(ctx context.Context, fileUID uuid.UUID)
	afterGetConvertedFileByFileUIDCounter  uint64
	beforeGetConvertedFileByFileUIDCounter uint64
	GetConvertedFileByFileUIDMock          mRepositoryIMockGetConvertedFileByFileUID

	funcGetCountFilesByListKnowledgeBaseUID          func(ctx context.Context, kbUIDs []mm_repository.KbUID) (m1 map[mm_repository.KbUID]int64, err error)
	inspectFuncGetCountFilesByListKnowledgeBaseUID   func(ctx context.Context, kbUIDs []mm_repository.KbUID)
	afterGetCountFilesByListKnowledgeBaseUIDCounter  uint64
	beforeGetCountFilesByListKnowledgeBaseUIDCounter uint64
	GetCountFilesByListKnowledgeBaseUIDMock          mRepositoryIMockGetCountFilesByListKnowledgeBaseUID

	funcGetEmbeddingByUIDs          func(ctx context.Context, embUIDs []uuid.UUID) (ea1 []mm_repository.Embedding, err error)
	inspectFuncGetEmbeddingByUIDs   func(ctx context.Context, embUIDs []uuid.UUID)
	afterGetEmbeddingByUIDsCounter  uint64
	beforeGetEmbeddingByUIDsCounter uint64
	GetEmbeddingByUIDsMock          mRepositoryIMockGetEmbeddingByUIDs

	funcGetFilesTotalTokens func(ctx context.Context, sources map[mm_repository.FileUID]struct {
		SourceTable mm_repository.SourceTable
		SourceUID   mm_repository.SourceUID
	}) (m1 map[mm_repository.FileUID]int, err error)
	inspectFuncGetFilesTotalTokens func(ctx context.Context, sources map[mm_repository.FileUID]struct {
		SourceTable mm_repository.SourceTable
		SourceUID   mm_repository.SourceUID
	})
	afterGetFilesTotalTokensCounter  uint64
	beforeGetFilesTotalTokensCounter uint64
	GetFilesTotalTokensMock          mRepositoryIMockGetFilesTotalTokens

	funcGetKnowledgeBaseByOwnerAndKbID          func(ctx context.Context, ownerUID uuid.UUID, kbID string) (kp1 *mm_repository.KnowledgeBase, err error)
	inspectFuncGetKnowledgeBaseByOwnerAndKbID   func(ctx context.Context, ownerUID uuid.UUID, kbID string)
	afterGetKnowledgeBaseByOwnerAndKbIDCounter  uint64
	beforeGetKnowledgeBaseByOwnerAndKbIDCounter uint64
	GetKnowledgeBaseByOwnerAndKbIDMock          mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID

	funcGetKnowledgeBaseCountByOwner          func(ctx context.Context, ownerUID string, catalogType artifactpb.CatalogType) (i1 int64, err error)
	inspectFuncGetKnowledgeBaseCountByOwner   func(ctx context.Context, ownerUID string, catalogType artifactpb.CatalogType)
	afterGetKnowledgeBaseCountByOwnerCounter  uint64
	beforeGetKnowledgeBaseCountByOwnerCounter uint64
	GetKnowledgeBaseCountByOwnerMock          mRepositoryIMockGetKnowledgeBaseCountByOwner

	funcGetKnowledgeBaseFilesByFileUIDs          func(ctx context.Context, fileUIDs []uuid.UUID, columns ...string) (ka1 []mm_repository.KnowledgeBaseFile, err error)
	inspectFuncGetKnowledgeBaseFilesByFileUIDs   func(ctx context.Context, fileUIDs []uuid.UUID, columns ...string)
	afterGetKnowledgeBaseFilesByFileUIDsCounter  uint64
	beforeGetKnowledgeBaseFilesByFileUIDsCounter uint64
	GetKnowledgeBaseFilesByFileUIDsMock          mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs

	funcGetKnowledgeBasesByUIDs          func(ctx context.Context, kbUIDs []uuid.UUID) (ka1 []mm_repository.KnowledgeBase, err error)
	inspectFuncGetKnowledgeBasesByUIDs   func(ctx context.Context, kbUIDs []uuid.UUID)
	afterGetKnowledgeBasesByUIDsCounter  uint64
	beforeGetKnowledgeBasesByUIDsCounter uint64
	GetKnowledgeBasesByUIDsMock          mRepositoryIMockGetKnowledgeBasesByUIDs

	funcGetKnowledgebaseFileByKbUIDAndFileID          func(ctx context.Context, kbUID uuid.UUID, fileID string) (kp1 *mm_repository.KnowledgeBaseFile, err error)
	inspectFuncGetKnowledgebaseFileByKbUIDAndFileID   func(ctx context.Context, kbUID uuid.UUID, fileID string)
	afterGetKnowledgebaseFileByKbUIDAndFileIDCounter  uint64
	beforeGetKnowledgebaseFileByKbUIDAndFileIDCounter uint64
	GetKnowledgebaseFileByKbUIDAndFileIDMock          mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID

	funcGetNeedProcessFiles          func(ctx context.Context) (ka1 []mm_repository.KnowledgeBaseFile)
	inspectFuncGetNeedProcessFiles   func(ctx context.Context)
	afterGetNeedProcessFilesCounter  uint64
	beforeGetNeedProcessFilesCounter uint64
	GetNeedProcessFilesMock          mRepositoryIMockGetNeedProcessFiles

	funcGetObjectByUID          func(ctx context.Context, uid uuid.UUID) (op1 *mm_repository.Object, err error)
	inspectFuncGetObjectByUID   func(ctx context.Context, uid uuid.UUID)
	afterGetObjectByUIDCounter  uint64
	beforeGetObjectByUIDCounter uint64
	GetObjectByUIDMock          mRepositoryIMockGetObjectByUID

	funcGetObjectDownloadURL          func(ctx context.Context, objectUID uuid.UUID) (op1 *mm_repository.ObjectURL, err error)
	inspectFuncGetObjectDownloadURL   func(ctx context.Context, objectUID uuid.UUID)
	afterGetObjectDownloadURLCounter  uint64
	beforeGetObjectDownloadURLCounter uint64
	GetObjectDownloadURLMock          mRepositoryIMockGetObjectDownloadURL

	funcGetObjectURLByEncodedURLPath          func(ctx context.Context, encodedURLPath string) (op1 *mm_repository.ObjectURL, err error)
	inspectFuncGetObjectURLByEncodedURLPath   func(ctx context.Context, encodedURLPath string)
	afterGetObjectURLByEncodedURLPathCounter  uint64
	beforeGetObjectURLByEncodedURLPathCounter uint64
	GetObjectURLByEncodedURLPathMock          mRepositoryIMockGetObjectURLByEncodedURLPath

	funcGetObjectURLByUID          func(ctx context.Context, uid uuid.UUID) (op1 *mm_repository.ObjectURL, err error)
	inspectFuncGetObjectURLByUID   func(ctx context.Context, uid uuid.UUID)
	afterGetObjectURLByUIDCounter  uint64
	beforeGetObjectURLByUIDCounter uint64
	GetObjectURLByUIDMock          mRepositoryIMockGetObjectURLByUID

	funcGetObjectURLCountByObject          func(ctx context.Context, objectUID uuid.UUID) (i1 int64, err error)
	inspectFuncGetObjectURLCountByObject   func(ctx context.Context, objectUID uuid.UUID)
	afterGetObjectURLCountByObjectCounter  uint64
	beforeGetObjectURLCountByObjectCounter uint64
	GetObjectURLCountByObjectMock          mRepositoryIMockGetObjectURLCountByObject

	funcGetObjectUploadURL          func(ctx context.Context, objectUID uuid.UUID) (op1 *mm_repository.ObjectURL, err error)
	inspectFuncGetObjectUploadURL   func(ctx context.Context, objectUID uuid.UUID)
	afterGetObjectUploadURLCounter  uint64
	beforeGetObjectUploadURLCounter uint64
	GetObjectUploadURLMock          mRepositoryIMockGetObjectUploadURL

	funcGetRepositoryTag          func(ctx context.Context, r1 utils.RepositoryTagName) (rp1 *pb.RepositoryTag, err error)
	inspectFuncGetRepositoryTag   func(ctx context.Context, r1 utils.RepositoryTagName)
	afterGetRepositoryTagCounter  uint64
	beforeGetRepositoryTagCounter uint64
	GetRepositoryTagMock          mRepositoryIMockGetRepositoryTag

	funcGetSourceTableAndUIDByFileUIDs func(ctx context.Context, files []mm_repository.KnowledgeBaseFile) (m1 map[mm_repository.FileUID]struct {
		SourceTable string
		SourceUID   uuid.UUID
	}, err error)
	inspectFuncGetSourceTableAndUIDByFileUIDs   func(ctx context.Context, files []mm_repository.KnowledgeBaseFile)
	afterGetSourceTableAndUIDByFileUIDsCounter  uint64
	beforeGetSourceTableAndUIDByFileUIDsCounter uint64
	GetSourceTableAndUIDByFileUIDsMock          mRepositoryIMockGetSourceTableAndUIDByFileUIDs

	funcGetTextChunksBySource          func(ctx context.Context, sourceTable string, sourceUID uuid.UUID) (ta1 []mm_repository.TextChunk, err error)
	inspectFuncGetTextChunksBySource   func(ctx context.Context, sourceTable string, sourceUID uuid.UUID)
	afterGetTextChunksBySourceCounter  uint64
	beforeGetTextChunksBySourceCounter uint64
	GetTextChunksBySourceMock          mRepositoryIMockGetTextChunksBySource

	funcGetTotalChunksBySources func(ctx context.Context, sources map[mm_repository.FileUID]struct {
		SourceTable mm_repository.SourceTable
		SourceUID   mm_repository.SourceUID
	}) (m1 map[mm_repository.FileUID]int, err error)
	inspectFuncGetTotalChunksBySources func(ctx context.Context, sources map[mm_repository.FileUID]struct {
		SourceTable mm_repository.SourceTable
		SourceUID   mm_repository.SourceUID
	})
	afterGetTotalChunksBySourcesCounter  uint64
	beforeGetTotalChunksBySourcesCounter uint64
	GetTotalChunksBySourcesMock          mRepositoryIMockGetTotalChunksBySources

	funcGetTotalTokensByListKBUIDs          func(ctx context.Context, kbUIDs []uuid.UUID) (m1 map[uuid.UUID]int, err error)
	inspectFuncGetTotalTokensByListKBUIDs   func(ctx context.Context, kbUIDs []uuid.UUID)
	afterGetTotalTokensByListKBUIDsCounter  uint64
	beforeGetTotalTokensByListKBUIDsCounter uint64
	GetTotalTokensByListKBUIDsMock          mRepositoryIMockGetTotalTokensByListKBUIDs

	funcGetTruthSourceByFileUID          func(ctx context.Context, fileUID uuid.UUID) (sp1 *mm_repository.SourceMeta, err error)
	inspectFuncGetTruthSourceByFileUID   func(ctx context.Context, fileUID uuid.UUID)
	afterGetTruthSourceByFileUIDCounter  uint64
	beforeGetTruthSourceByFileUIDCounter uint64
	GetTruthSourceByFileUIDMock          mRepositoryIMockGetTruthSourceByFileUID

	funcHardDeleteChunksByKbFileUID          func(ctx context.Context, kbFileUID uuid.UUID) (err error)
	inspectFuncHardDeleteChunksByKbFileUID   func(ctx context.Context, kbFileUID uuid.UUID)
	afterHardDeleteChunksByKbFileUIDCounter  uint64
	beforeHardDeleteChunksByKbFileUIDCounter uint64
	HardDeleteChunksByKbFileUIDMock          mRepositoryIMockHardDeleteChunksByKbFileUID

	funcHardDeleteChunksByKbUID          func(ctx context.Context, kbUID uuid.UUID) (err error)
	inspectFuncHardDeleteChunksByKbUID   func(ctx context.Context, kbUID uuid.UUID)
	afterHardDeleteChunksByKbUIDCounter  uint64
	beforeHardDeleteChunksByKbUIDCounter uint64
	HardDeleteChunksByKbUIDMock          mRepositoryIMockHardDeleteChunksByKbUID

	funcHardDeleteConvertedFileByFileUID          func(ctx context.Context, fileUID uuid.UUID) (err error)
	inspectFuncHardDeleteConvertedFileByFileUID   func(ctx context.Context, fileUID uuid.UUID)
	afterHardDeleteConvertedFileByFileUIDCounter  uint64
	beforeHardDeleteConvertedFileByFileUIDCounter uint64
	HardDeleteConvertedFileByFileUIDMock          mRepositoryIMockHardDeleteConvertedFileByFileUID

	funcHardDeleteEmbeddingsByKbFileUID          func(ctx context.Context, kbFileUID uuid.UUID) (err error)
	inspectFuncHardDeleteEmbeddingsByKbFileUID   func(ctx context.Context, kbFileUID uuid.UUID)
	afterHardDeleteEmbeddingsByKbFileUIDCounter  uint64
	beforeHardDeleteEmbeddingsByKbFileUIDCounter uint64
	HardDeleteEmbeddingsByKbFileUIDMock          mRepositoryIMockHardDeleteEmbeddingsByKbFileUID

	funcHardDeleteEmbeddingsByKbUID          func(ctx context.Context, kbUID uuid.UUID) (err error)
	inspectFuncHardDeleteEmbeddingsByKbUID   func(ctx context.Context, kbUID uuid.UUID)
	afterHardDeleteEmbeddingsByKbUIDCounter  uint64
	beforeHardDeleteEmbeddingsByKbUIDCounter uint64
	HardDeleteEmbeddingsByKbUIDMock          mRepositoryIMockHardDeleteEmbeddingsByKbUID

	funcIncreaseKnowledgeBaseUsage          func(ctx context.Context, tx *gorm.DB, kbUID string, amount int) (err error)
	inspectFuncIncreaseKnowledgeBaseUsage   func(ctx context.Context, tx *gorm.DB, kbUID string, amount int)
	afterIncreaseKnowledgeBaseUsageCounter  uint64
	beforeIncreaseKnowledgeBaseUsageCounter uint64
	IncreaseKnowledgeBaseUsageMock          mRepositoryIMockIncreaseKnowledgeBaseUsage

	funcKnowledgeBaseFileTableName          func() (s1 string)
	inspectFuncKnowledgeBaseFileTableName   func()
	afterKnowledgeBaseFileTableNameCounter  uint64
	beforeKnowledgeBaseFileTableNameCounter uint64
	KnowledgeBaseFileTableNameMock          mRepositoryIMockKnowledgeBaseFileTableName

	funcListAllObjectURLs          func(ctx context.Context, namespaceUID uuid.UUID, objectUID uuid.UUID) (oa1 []mm_repository.ObjectURL, err error)
	inspectFuncListAllObjectURLs   func(ctx context.Context, namespaceUID uuid.UUID, objectUID uuid.UUID)
	afterListAllObjectURLsCounter  uint64
	beforeListAllObjectURLsCounter uint64
	ListAllObjectURLsMock          mRepositoryIMockListAllObjectURLs

	funcListAllObjects          func(ctx context.Context, namespaceUID uuid.UUID, creatorUID uuid.UUID) (oa1 []mm_repository.Object, err error)
	inspectFuncListAllObjects   func(ctx context.Context, namespaceUID uuid.UUID, creatorUID uuid.UUID)
	afterListAllObjectsCounter  uint64
	beforeListAllObjectsCounter uint64
	ListAllObjectsMock          mRepositoryIMockListAllObjects

	funcListChunksByKbFileUID          func(ctx context.Context, kbFileUID uuid.UUID) (ta1 []mm_repository.TextChunk, err error)
	inspectFuncListChunksByKbFileUID   func(ctx context.Context, kbFileUID uuid.UUID)
	afterListChunksByKbFileUIDCounter  uint64
	beforeListChunksByKbFileUIDCounter uint64
	ListChunksByKbFileUIDMock          mRepositoryIMockListChunksByKbFileUID

	funcListEmbeddingsByKbFileUID          func(ctx context.Context, kbFileUID uuid.UUID) (ea1 []mm_repository.Embedding, err error)
	inspectFuncListEmbeddingsByKbFileUID   func(ctx context.Context, kbFileUID uuid.UUID)
	afterListEmbeddingsByKbFileUIDCounter  uint64
	beforeListEmbeddingsByKbFileUIDCounter uint64
	ListEmbeddingsByKbFileUIDMock          mRepositoryIMockListEmbeddingsByKbFileUID

	funcListKnowledgeBaseFiles          func(ctx context.Context, uid string, ownerUID string, kbUID string, pageSize int32, nextPageToken string, filesUID []string) (ka1 []mm_repository.KnowledgeBaseFile, i1 int, s1 string, err error)
	inspectFuncListKnowledgeBaseFiles   func(ctx context.Context, uid string, ownerUID string, kbUID string, pageSize int32, nextPageToken string, filesUID []string)
	afterListKnowledgeBaseFilesCounter  uint64
	beforeListKnowledgeBaseFilesCounter uint64
	ListKnowledgeBaseFilesMock          mRepositoryIMockListKnowledgeBaseFiles

	funcListKnowledgeBases          func(ctx context.Context, ownerUID string) (ka1 []mm_repository.KnowledgeBase, err error)
	inspectFuncListKnowledgeBases   func(ctx context.Context, ownerUID string)
	afterListKnowledgeBasesCounter  uint64
	beforeListKnowledgeBasesCounter uint64
	ListKnowledgeBasesMock          mRepositoryIMockListKnowledgeBases

	funcListKnowledgeBasesByCatalogType          func(ctx context.Context, ownerUID string, catalogType artifactpb.CatalogType) (ka1 []mm_repository.KnowledgeBase, err error)
	inspectFuncListKnowledgeBasesByCatalogType   func(ctx context.Context, ownerUID string, catalogType artifactpb.CatalogType)
	afterListKnowledgeBasesByCatalogTypeCounter  uint64
	beforeListKnowledgeBasesByCatalogTypeCounter uint64
	ListKnowledgeBasesByCatalogTypeMock          mRepositoryIMockListKnowledgeBasesByCatalogType

	funcProcessKnowledgeBaseFiles          func(ctx context.Context, fileUIDs []string, requester uuid.UUID) (ka1 []mm_repository.KnowledgeBaseFile, err error)
	inspectFuncProcessKnowledgeBaseFiles   func(ctx context.Context, fileUIDs []string, requester uuid.UUID)
	afterProcessKnowledgeBaseFilesCounter  uint64
	beforeProcessKnowledgeBaseFilesCounter uint64
	ProcessKnowledgeBaseFilesMock          mRepositoryIMockProcessKnowledgeBaseFiles

	funcTextChunkTableName          func() (s1 string)
	inspectFuncTextChunkTableName   func()
	afterTextChunkTableNameCounter  uint64
	beforeTextChunkTableNameCounter uint64
	TextChunkTableNameMock          mRepositoryIMockTextChunkTableName

	funcUpdateChunk          func(ctx context.Context, chunkUID string, updates map[string]interface{}) (tp1 *mm_repository.TextChunk, err error)
	inspectFuncUpdateChunk   func(ctx context.Context, chunkUID string, updates map[string]interface{})
	afterUpdateChunkCounter  uint64
	beforeUpdateChunkCounter uint64
	UpdateChunkMock          mRepositoryIMockUpdateChunk

	funcUpdateKbFileExtraMetaData          func(ctx context.Context, fileUID uuid.UUID, failureReason string, convertingPipe string, chunkingPipe string, embeddingPipe string, processingTime *int64, convertingTime *int64, chunkingTime *int64, embeddingTime *int64) (err error)
	inspectFuncUpdateKbFileExtraMetaData   func(ctx context.Context, fileUID uuid.UUID, failureReason string, convertingPipe string, chunkingPipe string, embeddingPipe string, processingTime *int64, convertingTime *int64, chunkingTime *int64, embeddingTime *int64)
	afterUpdateKbFileExtraMetaDataCounter  uint64
	beforeUpdateKbFileExtraMetaDataCounter uint64
	UpdateKbFileExtraMetaDataMock          mRepositoryIMockUpdateKbFileExtraMetaData

	funcUpdateKnowledgeBase          func(ctx context.Context, ownerUID string, kb mm_repository.KnowledgeBase) (kp1 *mm_repository.KnowledgeBase, err error)
	inspectFuncUpdateKnowledgeBase   func(ctx context.Context, ownerUID string, kb mm_repository.KnowledgeBase)
	afterUpdateKnowledgeBaseCounter  uint64
	beforeUpdateKnowledgeBaseCounter uint64
	UpdateKnowledgeBaseMock          mRepositoryIMockUpdateKnowledgeBase

	funcUpdateKnowledgeBaseFile          func(ctx context.Context, fileUID string, updateMap map[string]interface{}) (kp1 *mm_repository.KnowledgeBaseFile, err error)
	inspectFuncUpdateKnowledgeBaseFile   func(ctx context.Context, fileUID string, updateMap map[string]interface{})
	afterUpdateKnowledgeBaseFileCounter  uint64
	beforeUpdateKnowledgeBaseFileCounter uint64
	UpdateKnowledgeBaseFileMock          mRepositoryIMockUpdateKnowledgeBaseFile

	funcUpdateObject          func(ctx context.Context, obj mm_repository.Object) (op1 *mm_repository.Object, err error)
	inspectFuncUpdateObject   func(ctx context.Context, obj mm_repository.Object)
	afterUpdateObjectCounter  uint64
	beforeUpdateObjectCounter uint64
	UpdateObjectMock          mRepositoryIMockUpdateObject

	funcUpdateObjectByUpdateMap          func(ctx context.Context, objUID uuid.UUID, updateMap map[string]any) (op1 *mm_repository.Object, err error)
	inspectFuncUpdateObjectByUpdateMap   func(ctx context.Context, objUID uuid.UUID, updateMap map[string]any)
	afterUpdateObjectByUpdateMapCounter  uint64
	beforeUpdateObjectByUpdateMapCounter uint64
	UpdateObjectByUpdateMapMock          mRepositoryIMockUpdateObjectByUpdateMap

	funcUpdateObjectURL          func(ctx context.Context, objectURL mm_repository.ObjectURL) (op1 *mm_repository.ObjectURL, err error)
	inspectFuncUpdateObjectURL   func(ctx context.Context, objectURL mm_repository.ObjectURL)
	afterUpdateObjectURLCounter  uint64
	beforeUpdateObjectURLCounter uint64
	UpdateObjectURLMock          mRepositoryIMockUpdateObjectURL

	funcUpsertEmbeddings          func(ctx context.Context, embeddings []mm_repository.Embedding, externalServiceCall func(embUIDs []string) error) (ea1 []mm_repository.Embedding, err error)
	inspectFuncUpsertEmbeddings   func(ctx context.Context, embeddings []mm_repository.Embedding, externalServiceCall func(embUIDs []string) error)
	afterUpsertEmbeddingsCounter  uint64
	beforeUpsertEmbeddingsCounter uint64
	UpsertEmbeddingsMock          mRepositoryIMockUpsertEmbeddings

	funcUpsertRepositoryTag          func(ctx context.Context, rp1 *pb.RepositoryTag) (rp2 *pb.RepositoryTag, err error)
	inspectFuncUpsertRepositoryTag   func(ctx context.Context, rp1 *pb.RepositoryTag)
	afterUpsertRepositoryTagCounter  uint64
	beforeUpsertRepositoryTagCounter uint64
	UpsertRepositoryTagMock          mRepositoryIMockUpsertRepositoryTag
}

// NewRepositoryIMock returns a mock for repository.RepositoryI
func NewRepositoryIMock(t minimock.Tester) *RepositoryIMock {
	m := &RepositoryIMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ConvertedFileTableNameMock = mRepositoryIMockConvertedFileTableName{mock: m}

	m.CreateConvertedFileMock = mRepositoryIMockCreateConvertedFile{mock: m}
	m.CreateConvertedFileMock.callArgs = []*RepositoryIMockCreateConvertedFileParams{}

	m.CreateKnowledgeBaseMock = mRepositoryIMockCreateKnowledgeBase{mock: m}
	m.CreateKnowledgeBaseMock.callArgs = []*RepositoryIMockCreateKnowledgeBaseParams{}

	m.CreateKnowledgeBaseFileMock = mRepositoryIMockCreateKnowledgeBaseFile{mock: m}
	m.CreateKnowledgeBaseFileMock.callArgs = []*RepositoryIMockCreateKnowledgeBaseFileParams{}

	m.CreateObjectMock = mRepositoryIMockCreateObject{mock: m}
	m.CreateObjectMock.callArgs = []*RepositoryIMockCreateObjectParams{}

	m.CreateObjectURLMock = mRepositoryIMockCreateObjectURL{mock: m}
	m.CreateObjectURLMock.callArgs = []*RepositoryIMockCreateObjectURLParams{}

	m.DeleteAllConvertedFilesInKbMock = mRepositoryIMockDeleteAllConvertedFilesInKb{mock: m}
	m.DeleteAllConvertedFilesInKbMock.callArgs = []*RepositoryIMockDeleteAllConvertedFilesInKbParams{}

	m.DeleteAllKnowledgeBaseFilesMock = mRepositoryIMockDeleteAllKnowledgeBaseFiles{mock: m}
	m.DeleteAllKnowledgeBaseFilesMock.callArgs = []*RepositoryIMockDeleteAllKnowledgeBaseFilesParams{}

	m.DeleteAndCreateChunksMock = mRepositoryIMockDeleteAndCreateChunks{mock: m}
	m.DeleteAndCreateChunksMock.callArgs = []*RepositoryIMockDeleteAndCreateChunksParams{}

	m.DeleteChunksBySourceMock = mRepositoryIMockDeleteChunksBySource{mock: m}
	m.DeleteChunksBySourceMock.callArgs = []*RepositoryIMockDeleteChunksBySourceParams{}

	m.DeleteChunksByUIDsMock = mRepositoryIMockDeleteChunksByUIDs{mock: m}
	m.DeleteChunksByUIDsMock.callArgs = []*RepositoryIMockDeleteChunksByUIDsParams{}

	m.DeleteConvertedFileMock = mRepositoryIMockDeleteConvertedFile{mock: m}
	m.DeleteConvertedFileMock.callArgs = []*RepositoryIMockDeleteConvertedFileParams{}

	m.DeleteEmbeddingsBySourceMock = mRepositoryIMockDeleteEmbeddingsBySource{mock: m}
	m.DeleteEmbeddingsBySourceMock.callArgs = []*RepositoryIMockDeleteEmbeddingsBySourceParams{}

	m.DeleteEmbeddingsByUIDsMock = mRepositoryIMockDeleteEmbeddingsByUIDs{mock: m}
	m.DeleteEmbeddingsByUIDsMock.callArgs = []*RepositoryIMockDeleteEmbeddingsByUIDsParams{}

	m.DeleteKnowledgeBaseMock = mRepositoryIMockDeleteKnowledgeBase{mock: m}
	m.DeleteKnowledgeBaseMock.callArgs = []*RepositoryIMockDeleteKnowledgeBaseParams{}

	m.DeleteKnowledgeBaseFileMock = mRepositoryIMockDeleteKnowledgeBaseFile{mock: m}
	m.DeleteKnowledgeBaseFileMock.callArgs = []*RepositoryIMockDeleteKnowledgeBaseFileParams{}

	m.DeleteKnowledgeBaseFileAndDecreaseUsageMock = mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage{mock: m}
	m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.callArgs = []*RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParams{}

	m.DeleteObjectMock = mRepositoryIMockDeleteObject{mock: m}
	m.DeleteObjectMock.callArgs = []*RepositoryIMockDeleteObjectParams{}

	m.DeleteObjectURLMock = mRepositoryIMockDeleteObjectURL{mock: m}
	m.DeleteObjectURLMock.callArgs = []*RepositoryIMockDeleteObjectURLParams{}

	m.DeleteRepositoryTagMock = mRepositoryIMockDeleteRepositoryTag{mock: m}
	m.DeleteRepositoryTagMock.callArgs = []*RepositoryIMockDeleteRepositoryTagParams{}

	m.GetChunksByUIDsMock = mRepositoryIMockGetChunksByUIDs{mock: m}
	m.GetChunksByUIDsMock.callArgs = []*RepositoryIMockGetChunksByUIDsParams{}

	m.GetConvertedFileByFileUIDMock = mRepositoryIMockGetConvertedFileByFileUID{mock: m}
	m.GetConvertedFileByFileUIDMock.callArgs = []*RepositoryIMockGetConvertedFileByFileUIDParams{}

	m.GetCountFilesByListKnowledgeBaseUIDMock = mRepositoryIMockGetCountFilesByListKnowledgeBaseUID{mock: m}
	m.GetCountFilesByListKnowledgeBaseUIDMock.callArgs = []*RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParams{}

	m.GetEmbeddingByUIDsMock = mRepositoryIMockGetEmbeddingByUIDs{mock: m}
	m.GetEmbeddingByUIDsMock.callArgs = []*RepositoryIMockGetEmbeddingByUIDsParams{}

	m.GetFilesTotalTokensMock = mRepositoryIMockGetFilesTotalTokens{mock: m}
	m.GetFilesTotalTokensMock.callArgs = []*RepositoryIMockGetFilesTotalTokensParams{}

	m.GetKnowledgeBaseByOwnerAndKbIDMock = mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID{mock: m}
	m.GetKnowledgeBaseByOwnerAndKbIDMock.callArgs = []*RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParams{}

	m.GetKnowledgeBaseCountByOwnerMock = mRepositoryIMockGetKnowledgeBaseCountByOwner{mock: m}
	m.GetKnowledgeBaseCountByOwnerMock.callArgs = []*RepositoryIMockGetKnowledgeBaseCountByOwnerParams{}

	m.GetKnowledgeBaseFilesByFileUIDsMock = mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs{mock: m}
	m.GetKnowledgeBaseFilesByFileUIDsMock.callArgs = []*RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParams{}

	m.GetKnowledgeBasesByUIDsMock = mRepositoryIMockGetKnowledgeBasesByUIDs{mock: m}
	m.GetKnowledgeBasesByUIDsMock.callArgs = []*RepositoryIMockGetKnowledgeBasesByUIDsParams{}

	m.GetKnowledgebaseFileByKbUIDAndFileIDMock = mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID{mock: m}
	m.GetKnowledgebaseFileByKbUIDAndFileIDMock.callArgs = []*RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParams{}

	m.GetNeedProcessFilesMock = mRepositoryIMockGetNeedProcessFiles{mock: m}
	m.GetNeedProcessFilesMock.callArgs = []*RepositoryIMockGetNeedProcessFilesParams{}

	m.GetObjectByUIDMock = mRepositoryIMockGetObjectByUID{mock: m}
	m.GetObjectByUIDMock.callArgs = []*RepositoryIMockGetObjectByUIDParams{}

	m.GetObjectDownloadURLMock = mRepositoryIMockGetObjectDownloadURL{mock: m}
	m.GetObjectDownloadURLMock.callArgs = []*RepositoryIMockGetObjectDownloadURLParams{}

	m.GetObjectURLByEncodedURLPathMock = mRepositoryIMockGetObjectURLByEncodedURLPath{mock: m}
	m.GetObjectURLByEncodedURLPathMock.callArgs = []*RepositoryIMockGetObjectURLByEncodedURLPathParams{}

	m.GetObjectURLByUIDMock = mRepositoryIMockGetObjectURLByUID{mock: m}
	m.GetObjectURLByUIDMock.callArgs = []*RepositoryIMockGetObjectURLByUIDParams{}

	m.GetObjectURLCountByObjectMock = mRepositoryIMockGetObjectURLCountByObject{mock: m}
	m.GetObjectURLCountByObjectMock.callArgs = []*RepositoryIMockGetObjectURLCountByObjectParams{}

	m.GetObjectUploadURLMock = mRepositoryIMockGetObjectUploadURL{mock: m}
	m.GetObjectUploadURLMock.callArgs = []*RepositoryIMockGetObjectUploadURLParams{}

	m.GetRepositoryTagMock = mRepositoryIMockGetRepositoryTag{mock: m}
	m.GetRepositoryTagMock.callArgs = []*RepositoryIMockGetRepositoryTagParams{}

	m.GetSourceTableAndUIDByFileUIDsMock = mRepositoryIMockGetSourceTableAndUIDByFileUIDs{mock: m}
	m.GetSourceTableAndUIDByFileUIDsMock.callArgs = []*RepositoryIMockGetSourceTableAndUIDByFileUIDsParams{}

	m.GetTextChunksBySourceMock = mRepositoryIMockGetTextChunksBySource{mock: m}
	m.GetTextChunksBySourceMock.callArgs = []*RepositoryIMockGetTextChunksBySourceParams{}

	m.GetTotalChunksBySourcesMock = mRepositoryIMockGetTotalChunksBySources{mock: m}
	m.GetTotalChunksBySourcesMock.callArgs = []*RepositoryIMockGetTotalChunksBySourcesParams{}

	m.GetTotalTokensByListKBUIDsMock = mRepositoryIMockGetTotalTokensByListKBUIDs{mock: m}
	m.GetTotalTokensByListKBUIDsMock.callArgs = []*RepositoryIMockGetTotalTokensByListKBUIDsParams{}

	m.GetTruthSourceByFileUIDMock = mRepositoryIMockGetTruthSourceByFileUID{mock: m}
	m.GetTruthSourceByFileUIDMock.callArgs = []*RepositoryIMockGetTruthSourceByFileUIDParams{}

	m.HardDeleteChunksByKbFileUIDMock = mRepositoryIMockHardDeleteChunksByKbFileUID{mock: m}
	m.HardDeleteChunksByKbFileUIDMock.callArgs = []*RepositoryIMockHardDeleteChunksByKbFileUIDParams{}

	m.HardDeleteChunksByKbUIDMock = mRepositoryIMockHardDeleteChunksByKbUID{mock: m}
	m.HardDeleteChunksByKbUIDMock.callArgs = []*RepositoryIMockHardDeleteChunksByKbUIDParams{}

	m.HardDeleteConvertedFileByFileUIDMock = mRepositoryIMockHardDeleteConvertedFileByFileUID{mock: m}
	m.HardDeleteConvertedFileByFileUIDMock.callArgs = []*RepositoryIMockHardDeleteConvertedFileByFileUIDParams{}

	m.HardDeleteEmbeddingsByKbFileUIDMock = mRepositoryIMockHardDeleteEmbeddingsByKbFileUID{mock: m}
	m.HardDeleteEmbeddingsByKbFileUIDMock.callArgs = []*RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParams{}

	m.HardDeleteEmbeddingsByKbUIDMock = mRepositoryIMockHardDeleteEmbeddingsByKbUID{mock: m}
	m.HardDeleteEmbeddingsByKbUIDMock.callArgs = []*RepositoryIMockHardDeleteEmbeddingsByKbUIDParams{}

	m.IncreaseKnowledgeBaseUsageMock = mRepositoryIMockIncreaseKnowledgeBaseUsage{mock: m}
	m.IncreaseKnowledgeBaseUsageMock.callArgs = []*RepositoryIMockIncreaseKnowledgeBaseUsageParams{}

	m.KnowledgeBaseFileTableNameMock = mRepositoryIMockKnowledgeBaseFileTableName{mock: m}

	m.ListAllObjectURLsMock = mRepositoryIMockListAllObjectURLs{mock: m}
	m.ListAllObjectURLsMock.callArgs = []*RepositoryIMockListAllObjectURLsParams{}

	m.ListAllObjectsMock = mRepositoryIMockListAllObjects{mock: m}
	m.ListAllObjectsMock.callArgs = []*RepositoryIMockListAllObjectsParams{}

	m.ListChunksByKbFileUIDMock = mRepositoryIMockListChunksByKbFileUID{mock: m}
	m.ListChunksByKbFileUIDMock.callArgs = []*RepositoryIMockListChunksByKbFileUIDParams{}

	m.ListEmbeddingsByKbFileUIDMock = mRepositoryIMockListEmbeddingsByKbFileUID{mock: m}
	m.ListEmbeddingsByKbFileUIDMock.callArgs = []*RepositoryIMockListEmbeddingsByKbFileUIDParams{}

	m.ListKnowledgeBaseFilesMock = mRepositoryIMockListKnowledgeBaseFiles{mock: m}
	m.ListKnowledgeBaseFilesMock.callArgs = []*RepositoryIMockListKnowledgeBaseFilesParams{}

	m.ListKnowledgeBasesMock = mRepositoryIMockListKnowledgeBases{mock: m}
	m.ListKnowledgeBasesMock.callArgs = []*RepositoryIMockListKnowledgeBasesParams{}

	m.ListKnowledgeBasesByCatalogTypeMock = mRepositoryIMockListKnowledgeBasesByCatalogType{mock: m}
	m.ListKnowledgeBasesByCatalogTypeMock.callArgs = []*RepositoryIMockListKnowledgeBasesByCatalogTypeParams{}

	m.ProcessKnowledgeBaseFilesMock = mRepositoryIMockProcessKnowledgeBaseFiles{mock: m}
	m.ProcessKnowledgeBaseFilesMock.callArgs = []*RepositoryIMockProcessKnowledgeBaseFilesParams{}

	m.TextChunkTableNameMock = mRepositoryIMockTextChunkTableName{mock: m}

	m.UpdateChunkMock = mRepositoryIMockUpdateChunk{mock: m}
	m.UpdateChunkMock.callArgs = []*RepositoryIMockUpdateChunkParams{}

	m.UpdateKbFileExtraMetaDataMock = mRepositoryIMockUpdateKbFileExtraMetaData{mock: m}
	m.UpdateKbFileExtraMetaDataMock.callArgs = []*RepositoryIMockUpdateKbFileExtraMetaDataParams{}

	m.UpdateKnowledgeBaseMock = mRepositoryIMockUpdateKnowledgeBase{mock: m}
	m.UpdateKnowledgeBaseMock.callArgs = []*RepositoryIMockUpdateKnowledgeBaseParams{}

	m.UpdateKnowledgeBaseFileMock = mRepositoryIMockUpdateKnowledgeBaseFile{mock: m}
	m.UpdateKnowledgeBaseFileMock.callArgs = []*RepositoryIMockUpdateKnowledgeBaseFileParams{}

	m.UpdateObjectMock = mRepositoryIMockUpdateObject{mock: m}
	m.UpdateObjectMock.callArgs = []*RepositoryIMockUpdateObjectParams{}

	m.UpdateObjectByUpdateMapMock = mRepositoryIMockUpdateObjectByUpdateMap{mock: m}
	m.UpdateObjectByUpdateMapMock.callArgs = []*RepositoryIMockUpdateObjectByUpdateMapParams{}

	m.UpdateObjectURLMock = mRepositoryIMockUpdateObjectURL{mock: m}
	m.UpdateObjectURLMock.callArgs = []*RepositoryIMockUpdateObjectURLParams{}

	m.UpsertEmbeddingsMock = mRepositoryIMockUpsertEmbeddings{mock: m}
	m.UpsertEmbeddingsMock.callArgs = []*RepositoryIMockUpsertEmbeddingsParams{}

	m.UpsertRepositoryTagMock = mRepositoryIMockUpsertRepositoryTag{mock: m}
	m.UpsertRepositoryTagMock.callArgs = []*RepositoryIMockUpsertRepositoryTagParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryIMockConvertedFileTableName struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockConvertedFileTableNameExpectation
	expectations       []*RepositoryIMockConvertedFileTableNameExpectation

	expectedInvocations uint64
}

// RepositoryIMockConvertedFileTableNameExpectation specifies expectation struct of the RepositoryI.ConvertedFileTableName
type RepositoryIMockConvertedFileTableNameExpectation struct {
	mock *RepositoryIMock

	results *RepositoryIMockConvertedFileTableNameResults
	Counter uint64
}

// RepositoryIMockConvertedFileTableNameResults contains results of the RepositoryI.ConvertedFileTableName
type RepositoryIMockConvertedFileTableNameResults struct {
	s1 string
}

// Expect sets up expected params for RepositoryI.ConvertedFileTableName
func (mmConvertedFileTableName *mRepositoryIMockConvertedFileTableName) Expect() *mRepositoryIMockConvertedFileTableName {
	if mmConvertedFileTableName.mock.funcConvertedFileTableName != nil {
		mmConvertedFileTableName.mock.t.Fatalf("RepositoryIMock.ConvertedFileTableName mock is already set by Set")
	}

	if mmConvertedFileTableName.defaultExpectation == nil {
		mmConvertedFileTableName.defaultExpectation = &RepositoryIMockConvertedFileTableNameExpectation{}
	}

	return mmConvertedFileTableName
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.ConvertedFileTableName
func (mmConvertedFileTableName *mRepositoryIMockConvertedFileTableName) Inspect(f func()) *mRepositoryIMockConvertedFileTableName {
	if mmConvertedFileTableName.mock.inspectFuncConvertedFileTableName != nil {
		mmConvertedFileTableName.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.ConvertedFileTableName")
	}

	mmConvertedFileTableName.mock.inspectFuncConvertedFileTableName = f

	return mmConvertedFileTableName
}

// Return sets up results that will be returned by RepositoryI.ConvertedFileTableName
func (mmConvertedFileTableName *mRepositoryIMockConvertedFileTableName) Return(s1 string) *RepositoryIMock {
	if mmConvertedFileTableName.mock.funcConvertedFileTableName != nil {
		mmConvertedFileTableName.mock.t.Fatalf("RepositoryIMock.ConvertedFileTableName mock is already set by Set")
	}

	if mmConvertedFileTableName.defaultExpectation == nil {
		mmConvertedFileTableName.defaultExpectation = &RepositoryIMockConvertedFileTableNameExpectation{mock: mmConvertedFileTableName.mock}
	}
	mmConvertedFileTableName.defaultExpectation.results = &RepositoryIMockConvertedFileTableNameResults{s1}
	return mmConvertedFileTableName.mock
}

// Set uses given function f to mock the RepositoryI.ConvertedFileTableName method
func (mmConvertedFileTableName *mRepositoryIMockConvertedFileTableName) Set(f func() (s1 string)) *RepositoryIMock {
	if mmConvertedFileTableName.defaultExpectation != nil {
		mmConvertedFileTableName.mock.t.Fatalf("Default expectation is already set for the RepositoryI.ConvertedFileTableName method")
	}

	if len(mmConvertedFileTableName.expectations) > 0 {
		mmConvertedFileTableName.mock.t.Fatalf("Some expectations are already set for the RepositoryI.ConvertedFileTableName method")
	}

	mmConvertedFileTableName.mock.funcConvertedFileTableName = f
	return mmConvertedFileTableName.mock
}

// Times sets number of times RepositoryI.ConvertedFileTableName should be invoked
func (mmConvertedFileTableName *mRepositoryIMockConvertedFileTableName) Times(n uint64) *mRepositoryIMockConvertedFileTableName {
	if n == 0 {
		mmConvertedFileTableName.mock.t.Fatalf("Times of RepositoryIMock.ConvertedFileTableName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertedFileTableName.expectedInvocations, n)
	return mmConvertedFileTableName
}

func (mmConvertedFileTableName *mRepositoryIMockConvertedFileTableName) invocationsDone() bool {
	if len(mmConvertedFileTableName.expectations) == 0 && mmConvertedFileTableName.defaultExpectation == nil && mmConvertedFileTableName.mock.funcConvertedFileTableName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertedFileTableName.mock.afterConvertedFileTableNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertedFileTableName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertedFileTableName implements repository.RepositoryI
func (mmConvertedFileTableName *RepositoryIMock) ConvertedFileTableName() (s1 string) {
	mm_atomic.AddUint64(&mmConvertedFileTableName.beforeConvertedFileTableNameCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertedFileTableName.afterConvertedFileTableNameCounter, 1)

	if mmConvertedFileTableName.inspectFuncConvertedFileTableName != nil {
		mmConvertedFileTableName.inspectFuncConvertedFileTableName()
	}

	if mmConvertedFileTableName.ConvertedFileTableNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertedFileTableName.ConvertedFileTableNameMock.defaultExpectation.Counter, 1)

		mm_results := mmConvertedFileTableName.ConvertedFileTableNameMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertedFileTableName.t.Fatal("No results are set for the RepositoryIMock.ConvertedFileTableName")
		}
		return (*mm_results).s1
	}
	if mmConvertedFileTableName.funcConvertedFileTableName != nil {
		return mmConvertedFileTableName.funcConvertedFileTableName()
	}
	mmConvertedFileTableName.t.Fatalf("Unexpected call to RepositoryIMock.ConvertedFileTableName.")
	return
}

// ConvertedFileTableNameAfterCounter returns a count of finished RepositoryIMock.ConvertedFileTableName invocations
func (mmConvertedFileTableName *RepositoryIMock) ConvertedFileTableNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertedFileTableName.afterConvertedFileTableNameCounter)
}

// ConvertedFileTableNameBeforeCounter returns a count of RepositoryIMock.ConvertedFileTableName invocations
func (mmConvertedFileTableName *RepositoryIMock) ConvertedFileTableNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertedFileTableName.beforeConvertedFileTableNameCounter)
}

// MinimockConvertedFileTableNameDone returns true if the count of the ConvertedFileTableName invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockConvertedFileTableNameDone() bool {
	for _, e := range m.ConvertedFileTableNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertedFileTableNameMock.invocationsDone()
}

// MinimockConvertedFileTableNameInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockConvertedFileTableNameInspect() {
	for _, e := range m.ConvertedFileTableNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryIMock.ConvertedFileTableName")
		}
	}

	afterConvertedFileTableNameCounter := mm_atomic.LoadUint64(&m.afterConvertedFileTableNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertedFileTableNameMock.defaultExpectation != nil && afterConvertedFileTableNameCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.ConvertedFileTableName")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertedFileTableName != nil && afterConvertedFileTableNameCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.ConvertedFileTableName")
	}

	if !m.ConvertedFileTableNameMock.invocationsDone() && afterConvertedFileTableNameCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.ConvertedFileTableName but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertedFileTableNameMock.expectedInvocations), afterConvertedFileTableNameCounter)
	}
}

type mRepositoryIMockCreateConvertedFile struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockCreateConvertedFileExpectation
	expectations       []*RepositoryIMockCreateConvertedFileExpectation

	callArgs []*RepositoryIMockCreateConvertedFileParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockCreateConvertedFileExpectation specifies expectation struct of the RepositoryI.CreateConvertedFile
type RepositoryIMockCreateConvertedFileExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockCreateConvertedFileParams
	paramPtrs *RepositoryIMockCreateConvertedFileParamPtrs
	results   *RepositoryIMockCreateConvertedFileResults
	Counter   uint64
}

// RepositoryIMockCreateConvertedFileParams contains parameters of the RepositoryI.CreateConvertedFile
type RepositoryIMockCreateConvertedFileParams struct {
	ctx                 context.Context
	cf                  mm_repository.ConvertedFile
	callExternalService func(convertedFileUID uuid.UUID) (map[string]any, error)
}

// RepositoryIMockCreateConvertedFileParamPtrs contains pointers to parameters of the RepositoryI.CreateConvertedFile
type RepositoryIMockCreateConvertedFileParamPtrs struct {
	ctx                 *context.Context
	cf                  *mm_repository.ConvertedFile
	callExternalService *func(convertedFileUID uuid.UUID) (map[string]any, error)
}

// RepositoryIMockCreateConvertedFileResults contains results of the RepositoryI.CreateConvertedFile
type RepositoryIMockCreateConvertedFileResults struct {
	cp1 *mm_repository.ConvertedFile
	err error
}

// Expect sets up expected params for RepositoryI.CreateConvertedFile
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) Expect(ctx context.Context, cf mm_repository.ConvertedFile, callExternalService func(convertedFileUID uuid.UUID) (map[string]any, error)) *mRepositoryIMockCreateConvertedFile {
	if mmCreateConvertedFile.mock.funcCreateConvertedFile != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by Set")
	}

	if mmCreateConvertedFile.defaultExpectation == nil {
		mmCreateConvertedFile.defaultExpectation = &RepositoryIMockCreateConvertedFileExpectation{}
	}

	if mmCreateConvertedFile.defaultExpectation.paramPtrs != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by ExpectParams functions")
	}

	mmCreateConvertedFile.defaultExpectation.params = &RepositoryIMockCreateConvertedFileParams{ctx, cf, callExternalService}
	for _, e := range mmCreateConvertedFile.expectations {
		if minimock.Equal(e.params, mmCreateConvertedFile.defaultExpectation.params) {
			mmCreateConvertedFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateConvertedFile.defaultExpectation.params)
		}
	}

	return mmCreateConvertedFile
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.CreateConvertedFile
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockCreateConvertedFile {
	if mmCreateConvertedFile.mock.funcCreateConvertedFile != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by Set")
	}

	if mmCreateConvertedFile.defaultExpectation == nil {
		mmCreateConvertedFile.defaultExpectation = &RepositoryIMockCreateConvertedFileExpectation{}
	}

	if mmCreateConvertedFile.defaultExpectation.params != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by Expect")
	}

	if mmCreateConvertedFile.defaultExpectation.paramPtrs == nil {
		mmCreateConvertedFile.defaultExpectation.paramPtrs = &RepositoryIMockCreateConvertedFileParamPtrs{}
	}
	mmCreateConvertedFile.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateConvertedFile
}

// ExpectCfParam2 sets up expected param cf for RepositoryI.CreateConvertedFile
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) ExpectCfParam2(cf mm_repository.ConvertedFile) *mRepositoryIMockCreateConvertedFile {
	if mmCreateConvertedFile.mock.funcCreateConvertedFile != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by Set")
	}

	if mmCreateConvertedFile.defaultExpectation == nil {
		mmCreateConvertedFile.defaultExpectation = &RepositoryIMockCreateConvertedFileExpectation{}
	}

	if mmCreateConvertedFile.defaultExpectation.params != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by Expect")
	}

	if mmCreateConvertedFile.defaultExpectation.paramPtrs == nil {
		mmCreateConvertedFile.defaultExpectation.paramPtrs = &RepositoryIMockCreateConvertedFileParamPtrs{}
	}
	mmCreateConvertedFile.defaultExpectation.paramPtrs.cf = &cf

	return mmCreateConvertedFile
}

// ExpectCallExternalServiceParam3 sets up expected param callExternalService for RepositoryI.CreateConvertedFile
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) ExpectCallExternalServiceParam3(callExternalService func(convertedFileUID uuid.UUID) (map[string]any, error)) *mRepositoryIMockCreateConvertedFile {
	if mmCreateConvertedFile.mock.funcCreateConvertedFile != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by Set")
	}

	if mmCreateConvertedFile.defaultExpectation == nil {
		mmCreateConvertedFile.defaultExpectation = &RepositoryIMockCreateConvertedFileExpectation{}
	}

	if mmCreateConvertedFile.defaultExpectation.params != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by Expect")
	}

	if mmCreateConvertedFile.defaultExpectation.paramPtrs == nil {
		mmCreateConvertedFile.defaultExpectation.paramPtrs = &RepositoryIMockCreateConvertedFileParamPtrs{}
	}
	mmCreateConvertedFile.defaultExpectation.paramPtrs.callExternalService = &callExternalService

	return mmCreateConvertedFile
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.CreateConvertedFile
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) Inspect(f func(ctx context.Context, cf mm_repository.ConvertedFile, callExternalService func(convertedFileUID uuid.UUID) (map[string]any, error))) *mRepositoryIMockCreateConvertedFile {
	if mmCreateConvertedFile.mock.inspectFuncCreateConvertedFile != nil {
		mmCreateConvertedFile.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.CreateConvertedFile")
	}

	mmCreateConvertedFile.mock.inspectFuncCreateConvertedFile = f

	return mmCreateConvertedFile
}

// Return sets up results that will be returned by RepositoryI.CreateConvertedFile
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) Return(cp1 *mm_repository.ConvertedFile, err error) *RepositoryIMock {
	if mmCreateConvertedFile.mock.funcCreateConvertedFile != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by Set")
	}

	if mmCreateConvertedFile.defaultExpectation == nil {
		mmCreateConvertedFile.defaultExpectation = &RepositoryIMockCreateConvertedFileExpectation{mock: mmCreateConvertedFile.mock}
	}
	mmCreateConvertedFile.defaultExpectation.results = &RepositoryIMockCreateConvertedFileResults{cp1, err}
	return mmCreateConvertedFile.mock
}

// Set uses given function f to mock the RepositoryI.CreateConvertedFile method
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) Set(f func(ctx context.Context, cf mm_repository.ConvertedFile, callExternalService func(convertedFileUID uuid.UUID) (map[string]any, error)) (cp1 *mm_repository.ConvertedFile, err error)) *RepositoryIMock {
	if mmCreateConvertedFile.defaultExpectation != nil {
		mmCreateConvertedFile.mock.t.Fatalf("Default expectation is already set for the RepositoryI.CreateConvertedFile method")
	}

	if len(mmCreateConvertedFile.expectations) > 0 {
		mmCreateConvertedFile.mock.t.Fatalf("Some expectations are already set for the RepositoryI.CreateConvertedFile method")
	}

	mmCreateConvertedFile.mock.funcCreateConvertedFile = f
	return mmCreateConvertedFile.mock
}

// When sets expectation for the RepositoryI.CreateConvertedFile which will trigger the result defined by the following
// Then helper
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) When(ctx context.Context, cf mm_repository.ConvertedFile, callExternalService func(convertedFileUID uuid.UUID) (map[string]any, error)) *RepositoryIMockCreateConvertedFileExpectation {
	if mmCreateConvertedFile.mock.funcCreateConvertedFile != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by Set")
	}

	expectation := &RepositoryIMockCreateConvertedFileExpectation{
		mock:   mmCreateConvertedFile.mock,
		params: &RepositoryIMockCreateConvertedFileParams{ctx, cf, callExternalService},
	}
	mmCreateConvertedFile.expectations = append(mmCreateConvertedFile.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.CreateConvertedFile return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockCreateConvertedFileExpectation) Then(cp1 *mm_repository.ConvertedFile, err error) *RepositoryIMock {
	e.results = &RepositoryIMockCreateConvertedFileResults{cp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.CreateConvertedFile should be invoked
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) Times(n uint64) *mRepositoryIMockCreateConvertedFile {
	if n == 0 {
		mmCreateConvertedFile.mock.t.Fatalf("Times of RepositoryIMock.CreateConvertedFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateConvertedFile.expectedInvocations, n)
	return mmCreateConvertedFile
}

func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) invocationsDone() bool {
	if len(mmCreateConvertedFile.expectations) == 0 && mmCreateConvertedFile.defaultExpectation == nil && mmCreateConvertedFile.mock.funcCreateConvertedFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateConvertedFile.mock.afterCreateConvertedFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateConvertedFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateConvertedFile implements repository.RepositoryI
func (mmCreateConvertedFile *RepositoryIMock) CreateConvertedFile(ctx context.Context, cf mm_repository.ConvertedFile, callExternalService func(convertedFileUID uuid.UUID) (map[string]any, error)) (cp1 *mm_repository.ConvertedFile, err error) {
	mm_atomic.AddUint64(&mmCreateConvertedFile.beforeCreateConvertedFileCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateConvertedFile.afterCreateConvertedFileCounter, 1)

	if mmCreateConvertedFile.inspectFuncCreateConvertedFile != nil {
		mmCreateConvertedFile.inspectFuncCreateConvertedFile(ctx, cf, callExternalService)
	}

	mm_params := RepositoryIMockCreateConvertedFileParams{ctx, cf, callExternalService}

	// Record call args
	mmCreateConvertedFile.CreateConvertedFileMock.mutex.Lock()
	mmCreateConvertedFile.CreateConvertedFileMock.callArgs = append(mmCreateConvertedFile.CreateConvertedFileMock.callArgs, &mm_params)
	mmCreateConvertedFile.CreateConvertedFileMock.mutex.Unlock()

	for _, e := range mmCreateConvertedFile.CreateConvertedFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCreateConvertedFile.CreateConvertedFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateConvertedFile.CreateConvertedFileMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateConvertedFile.CreateConvertedFileMock.defaultExpectation.params
		mm_want_ptrs := mmCreateConvertedFile.CreateConvertedFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockCreateConvertedFileParams{ctx, cf, callExternalService}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateConvertedFile.t.Errorf("RepositoryIMock.CreateConvertedFile got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cf != nil && !minimock.Equal(*mm_want_ptrs.cf, mm_got.cf) {
				mmCreateConvertedFile.t.Errorf("RepositoryIMock.CreateConvertedFile got unexpected parameter cf, want: %#v, got: %#v%s\n", *mm_want_ptrs.cf, mm_got.cf, minimock.Diff(*mm_want_ptrs.cf, mm_got.cf))
			}

			if mm_want_ptrs.callExternalService != nil && !minimock.Equal(*mm_want_ptrs.callExternalService, mm_got.callExternalService) {
				mmCreateConvertedFile.t.Errorf("RepositoryIMock.CreateConvertedFile got unexpected parameter callExternalService, want: %#v, got: %#v%s\n", *mm_want_ptrs.callExternalService, mm_got.callExternalService, minimock.Diff(*mm_want_ptrs.callExternalService, mm_got.callExternalService))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateConvertedFile.t.Errorf("RepositoryIMock.CreateConvertedFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateConvertedFile.CreateConvertedFileMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateConvertedFile.t.Fatal("No results are set for the RepositoryIMock.CreateConvertedFile")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCreateConvertedFile.funcCreateConvertedFile != nil {
		return mmCreateConvertedFile.funcCreateConvertedFile(ctx, cf, callExternalService)
	}
	mmCreateConvertedFile.t.Fatalf("Unexpected call to RepositoryIMock.CreateConvertedFile. %v %v %v", ctx, cf, callExternalService)
	return
}

// CreateConvertedFileAfterCounter returns a count of finished RepositoryIMock.CreateConvertedFile invocations
func (mmCreateConvertedFile *RepositoryIMock) CreateConvertedFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateConvertedFile.afterCreateConvertedFileCounter)
}

// CreateConvertedFileBeforeCounter returns a count of RepositoryIMock.CreateConvertedFile invocations
func (mmCreateConvertedFile *RepositoryIMock) CreateConvertedFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateConvertedFile.beforeCreateConvertedFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.CreateConvertedFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) Calls() []*RepositoryIMockCreateConvertedFileParams {
	mmCreateConvertedFile.mutex.RLock()

	argCopy := make([]*RepositoryIMockCreateConvertedFileParams, len(mmCreateConvertedFile.callArgs))
	copy(argCopy, mmCreateConvertedFile.callArgs)

	mmCreateConvertedFile.mutex.RUnlock()

	return argCopy
}

// MinimockCreateConvertedFileDone returns true if the count of the CreateConvertedFile invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockCreateConvertedFileDone() bool {
	for _, e := range m.CreateConvertedFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateConvertedFileMock.invocationsDone()
}

// MinimockCreateConvertedFileInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockCreateConvertedFileInspect() {
	for _, e := range m.CreateConvertedFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.CreateConvertedFile with params: %#v", *e.params)
		}
	}

	afterCreateConvertedFileCounter := mm_atomic.LoadUint64(&m.afterCreateConvertedFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateConvertedFileMock.defaultExpectation != nil && afterCreateConvertedFileCounter < 1 {
		if m.CreateConvertedFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.CreateConvertedFile")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.CreateConvertedFile with params: %#v", *m.CreateConvertedFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateConvertedFile != nil && afterCreateConvertedFileCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.CreateConvertedFile")
	}

	if !m.CreateConvertedFileMock.invocationsDone() && afterCreateConvertedFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.CreateConvertedFile but found %d calls",
			mm_atomic.LoadUint64(&m.CreateConvertedFileMock.expectedInvocations), afterCreateConvertedFileCounter)
	}
}

type mRepositoryIMockCreateKnowledgeBase struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockCreateKnowledgeBaseExpectation
	expectations       []*RepositoryIMockCreateKnowledgeBaseExpectation

	callArgs []*RepositoryIMockCreateKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockCreateKnowledgeBaseExpectation specifies expectation struct of the RepositoryI.CreateKnowledgeBase
type RepositoryIMockCreateKnowledgeBaseExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockCreateKnowledgeBaseParams
	paramPtrs *RepositoryIMockCreateKnowledgeBaseParamPtrs
	results   *RepositoryIMockCreateKnowledgeBaseResults
	Counter   uint64
}

// RepositoryIMockCreateKnowledgeBaseParams contains parameters of the RepositoryI.CreateKnowledgeBase
type RepositoryIMockCreateKnowledgeBaseParams struct {
	ctx             context.Context
	kb              mm_repository.KnowledgeBase
	externalService func(kbUID string) error
}

// RepositoryIMockCreateKnowledgeBaseParamPtrs contains pointers to parameters of the RepositoryI.CreateKnowledgeBase
type RepositoryIMockCreateKnowledgeBaseParamPtrs struct {
	ctx             *context.Context
	kb              *mm_repository.KnowledgeBase
	externalService *func(kbUID string) error
}

// RepositoryIMockCreateKnowledgeBaseResults contains results of the RepositoryI.CreateKnowledgeBase
type RepositoryIMockCreateKnowledgeBaseResults struct {
	kp1 *mm_repository.KnowledgeBase
	err error
}

// Expect sets up expected params for RepositoryI.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) Expect(ctx context.Context, kb mm_repository.KnowledgeBase, externalService func(kbUID string) error) *mRepositoryIMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmCreateKnowledgeBase.defaultExpectation.params = &RepositoryIMockCreateKnowledgeBaseParams{ctx, kb, externalService}
	for _, e := range mmCreateKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmCreateKnowledgeBase.defaultExpectation.params) {
			mmCreateKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmCreateKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.params != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Expect")
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockCreateKnowledgeBaseParamPtrs{}
	}
	mmCreateKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateKnowledgeBase
}

// ExpectKbParam2 sets up expected param kb for RepositoryI.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) ExpectKbParam2(kb mm_repository.KnowledgeBase) *mRepositoryIMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.params != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Expect")
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockCreateKnowledgeBaseParamPtrs{}
	}
	mmCreateKnowledgeBase.defaultExpectation.paramPtrs.kb = &kb

	return mmCreateKnowledgeBase
}

// ExpectExternalServiceParam3 sets up expected param externalService for RepositoryI.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) ExpectExternalServiceParam3(externalService func(kbUID string) error) *mRepositoryIMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.params != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Expect")
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockCreateKnowledgeBaseParamPtrs{}
	}
	mmCreateKnowledgeBase.defaultExpectation.paramPtrs.externalService = &externalService

	return mmCreateKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) Inspect(f func(ctx context.Context, kb mm_repository.KnowledgeBase, externalService func(kbUID string) error)) *mRepositoryIMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.inspectFuncCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.CreateKnowledgeBase")
	}

	mmCreateKnowledgeBase.mock.inspectFuncCreateKnowledgeBase = f

	return mmCreateKnowledgeBase
}

// Return sets up results that will be returned by RepositoryI.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) Return(kp1 *mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseExpectation{mock: mmCreateKnowledgeBase.mock}
	}
	mmCreateKnowledgeBase.defaultExpectation.results = &RepositoryIMockCreateKnowledgeBaseResults{kp1, err}
	return mmCreateKnowledgeBase.mock
}

// Set uses given function f to mock the RepositoryI.CreateKnowledgeBase method
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) Set(f func(ctx context.Context, kb mm_repository.KnowledgeBase, externalService func(kbUID string) error) (kp1 *mm_repository.KnowledgeBase, err error)) *RepositoryIMock {
	if mmCreateKnowledgeBase.defaultExpectation != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the RepositoryI.CreateKnowledgeBase method")
	}

	if len(mmCreateKnowledgeBase.expectations) > 0 {
		mmCreateKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the RepositoryI.CreateKnowledgeBase method")
	}

	mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase = f
	return mmCreateKnowledgeBase.mock
}

// When sets expectation for the RepositoryI.CreateKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) When(ctx context.Context, kb mm_repository.KnowledgeBase, externalService func(kbUID string) error) *RepositoryIMockCreateKnowledgeBaseExpectation {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Set")
	}

	expectation := &RepositoryIMockCreateKnowledgeBaseExpectation{
		mock:   mmCreateKnowledgeBase.mock,
		params: &RepositoryIMockCreateKnowledgeBaseParams{ctx, kb, externalService},
	}
	mmCreateKnowledgeBase.expectations = append(mmCreateKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.CreateKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockCreateKnowledgeBaseExpectation) Then(kp1 *mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	e.results = &RepositoryIMockCreateKnowledgeBaseResults{kp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.CreateKnowledgeBase should be invoked
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) Times(n uint64) *mRepositoryIMockCreateKnowledgeBase {
	if n == 0 {
		mmCreateKnowledgeBase.mock.t.Fatalf("Times of RepositoryIMock.CreateKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateKnowledgeBase.expectedInvocations, n)
	return mmCreateKnowledgeBase
}

func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) invocationsDone() bool {
	if len(mmCreateKnowledgeBase.expectations) == 0 && mmCreateKnowledgeBase.defaultExpectation == nil && mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateKnowledgeBase.mock.afterCreateKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateKnowledgeBase implements repository.RepositoryI
func (mmCreateKnowledgeBase *RepositoryIMock) CreateKnowledgeBase(ctx context.Context, kb mm_repository.KnowledgeBase, externalService func(kbUID string) error) (kp1 *mm_repository.KnowledgeBase, err error) {
	mm_atomic.AddUint64(&mmCreateKnowledgeBase.beforeCreateKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateKnowledgeBase.afterCreateKnowledgeBaseCounter, 1)

	if mmCreateKnowledgeBase.inspectFuncCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.inspectFuncCreateKnowledgeBase(ctx, kb, externalService)
	}

	mm_params := RepositoryIMockCreateKnowledgeBaseParams{ctx, kb, externalService}

	// Record call args
	mmCreateKnowledgeBase.CreateKnowledgeBaseMock.mutex.Lock()
	mmCreateKnowledgeBase.CreateKnowledgeBaseMock.callArgs = append(mmCreateKnowledgeBase.CreateKnowledgeBaseMock.callArgs, &mm_params)
	mmCreateKnowledgeBase.CreateKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmCreateKnowledgeBase.CreateKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockCreateKnowledgeBaseParams{ctx, kb, externalService}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateKnowledgeBase.t.Errorf("RepositoryIMock.CreateKnowledgeBase got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kb != nil && !minimock.Equal(*mm_want_ptrs.kb, mm_got.kb) {
				mmCreateKnowledgeBase.t.Errorf("RepositoryIMock.CreateKnowledgeBase got unexpected parameter kb, want: %#v, got: %#v%s\n", *mm_want_ptrs.kb, mm_got.kb, minimock.Diff(*mm_want_ptrs.kb, mm_got.kb))
			}

			if mm_want_ptrs.externalService != nil && !minimock.Equal(*mm_want_ptrs.externalService, mm_got.externalService) {
				mmCreateKnowledgeBase.t.Errorf("RepositoryIMock.CreateKnowledgeBase got unexpected parameter externalService, want: %#v, got: %#v%s\n", *mm_want_ptrs.externalService, mm_got.externalService, minimock.Diff(*mm_want_ptrs.externalService, mm_got.externalService))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateKnowledgeBase.t.Errorf("RepositoryIMock.CreateKnowledgeBase got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateKnowledgeBase.t.Fatal("No results are set for the RepositoryIMock.CreateKnowledgeBase")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmCreateKnowledgeBase.funcCreateKnowledgeBase != nil {
		return mmCreateKnowledgeBase.funcCreateKnowledgeBase(ctx, kb, externalService)
	}
	mmCreateKnowledgeBase.t.Fatalf("Unexpected call to RepositoryIMock.CreateKnowledgeBase. %v %v %v", ctx, kb, externalService)
	return
}

// CreateKnowledgeBaseAfterCounter returns a count of finished RepositoryIMock.CreateKnowledgeBase invocations
func (mmCreateKnowledgeBase *RepositoryIMock) CreateKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateKnowledgeBase.afterCreateKnowledgeBaseCounter)
}

// CreateKnowledgeBaseBeforeCounter returns a count of RepositoryIMock.CreateKnowledgeBase invocations
func (mmCreateKnowledgeBase *RepositoryIMock) CreateKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateKnowledgeBase.beforeCreateKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.CreateKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) Calls() []*RepositoryIMockCreateKnowledgeBaseParams {
	mmCreateKnowledgeBase.mutex.RLock()

	argCopy := make([]*RepositoryIMockCreateKnowledgeBaseParams, len(mmCreateKnowledgeBase.callArgs))
	copy(argCopy, mmCreateKnowledgeBase.callArgs)

	mmCreateKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockCreateKnowledgeBaseDone returns true if the count of the CreateKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockCreateKnowledgeBaseDone() bool {
	for _, e := range m.CreateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateKnowledgeBaseMock.invocationsDone()
}

// MinimockCreateKnowledgeBaseInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockCreateKnowledgeBaseInspect() {
	for _, e := range m.CreateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.CreateKnowledgeBase with params: %#v", *e.params)
		}
	}

	afterCreateKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterCreateKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateKnowledgeBaseMock.defaultExpectation != nil && afterCreateKnowledgeBaseCounter < 1 {
		if m.CreateKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.CreateKnowledgeBase")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.CreateKnowledgeBase with params: %#v", *m.CreateKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateKnowledgeBase != nil && afterCreateKnowledgeBaseCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.CreateKnowledgeBase")
	}

	if !m.CreateKnowledgeBaseMock.invocationsDone() && afterCreateKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.CreateKnowledgeBase but found %d calls",
			mm_atomic.LoadUint64(&m.CreateKnowledgeBaseMock.expectedInvocations), afterCreateKnowledgeBaseCounter)
	}
}

type mRepositoryIMockCreateKnowledgeBaseFile struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockCreateKnowledgeBaseFileExpectation
	expectations       []*RepositoryIMockCreateKnowledgeBaseFileExpectation

	callArgs []*RepositoryIMockCreateKnowledgeBaseFileParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockCreateKnowledgeBaseFileExpectation specifies expectation struct of the RepositoryI.CreateKnowledgeBaseFile
type RepositoryIMockCreateKnowledgeBaseFileExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockCreateKnowledgeBaseFileParams
	paramPtrs *RepositoryIMockCreateKnowledgeBaseFileParamPtrs
	results   *RepositoryIMockCreateKnowledgeBaseFileResults
	Counter   uint64
}

// RepositoryIMockCreateKnowledgeBaseFileParams contains parameters of the RepositoryI.CreateKnowledgeBaseFile
type RepositoryIMockCreateKnowledgeBaseFileParams struct {
	ctx                 context.Context
	kb                  mm_repository.KnowledgeBaseFile
	externalServiceCall func(FileUID string) error
}

// RepositoryIMockCreateKnowledgeBaseFileParamPtrs contains pointers to parameters of the RepositoryI.CreateKnowledgeBaseFile
type RepositoryIMockCreateKnowledgeBaseFileParamPtrs struct {
	ctx                 *context.Context
	kb                  *mm_repository.KnowledgeBaseFile
	externalServiceCall *func(FileUID string) error
}

// RepositoryIMockCreateKnowledgeBaseFileResults contains results of the RepositoryI.CreateKnowledgeBaseFile
type RepositoryIMockCreateKnowledgeBaseFileResults struct {
	kp1 *mm_repository.KnowledgeBaseFile
	err error
}

// Expect sets up expected params for RepositoryI.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) Expect(ctx context.Context, kb mm_repository.KnowledgeBaseFile, externalServiceCall func(FileUID string) error) *mRepositoryIMockCreateKnowledgeBaseFile {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseFileExpectation{}
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by ExpectParams functions")
	}

	mmCreateKnowledgeBaseFile.defaultExpectation.params = &RepositoryIMockCreateKnowledgeBaseFileParams{ctx, kb, externalServiceCall}
	for _, e := range mmCreateKnowledgeBaseFile.expectations {
		if minimock.Equal(e.params, mmCreateKnowledgeBaseFile.defaultExpectation.params) {
			mmCreateKnowledgeBaseFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateKnowledgeBaseFile.defaultExpectation.params)
		}
	}

	return mmCreateKnowledgeBaseFile
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockCreateKnowledgeBaseFile {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseFileExpectation{}
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryIMockCreateKnowledgeBaseFileParamPtrs{}
	}
	mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateKnowledgeBaseFile
}

// ExpectKbParam2 sets up expected param kb for RepositoryI.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) ExpectKbParam2(kb mm_repository.KnowledgeBaseFile) *mRepositoryIMockCreateKnowledgeBaseFile {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseFileExpectation{}
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryIMockCreateKnowledgeBaseFileParamPtrs{}
	}
	mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs.kb = &kb

	return mmCreateKnowledgeBaseFile
}

// ExpectExternalServiceCallParam3 sets up expected param externalServiceCall for RepositoryI.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) ExpectExternalServiceCallParam3(externalServiceCall func(FileUID string) error) *mRepositoryIMockCreateKnowledgeBaseFile {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseFileExpectation{}
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryIMockCreateKnowledgeBaseFileParamPtrs{}
	}
	mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs.externalServiceCall = &externalServiceCall

	return mmCreateKnowledgeBaseFile
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) Inspect(f func(ctx context.Context, kb mm_repository.KnowledgeBaseFile, externalServiceCall func(FileUID string) error)) *mRepositoryIMockCreateKnowledgeBaseFile {
	if mmCreateKnowledgeBaseFile.mock.inspectFuncCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.CreateKnowledgeBaseFile")
	}

	mmCreateKnowledgeBaseFile.mock.inspectFuncCreateKnowledgeBaseFile = f

	return mmCreateKnowledgeBaseFile
}

// Return sets up results that will be returned by RepositoryI.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) Return(kp1 *mm_repository.KnowledgeBaseFile, err error) *RepositoryIMock {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseFileExpectation{mock: mmCreateKnowledgeBaseFile.mock}
	}
	mmCreateKnowledgeBaseFile.defaultExpectation.results = &RepositoryIMockCreateKnowledgeBaseFileResults{kp1, err}
	return mmCreateKnowledgeBaseFile.mock
}

// Set uses given function f to mock the RepositoryI.CreateKnowledgeBaseFile method
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) Set(f func(ctx context.Context, kb mm_repository.KnowledgeBaseFile, externalServiceCall func(FileUID string) error) (kp1 *mm_repository.KnowledgeBaseFile, err error)) *RepositoryIMock {
	if mmCreateKnowledgeBaseFile.defaultExpectation != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("Default expectation is already set for the RepositoryI.CreateKnowledgeBaseFile method")
	}

	if len(mmCreateKnowledgeBaseFile.expectations) > 0 {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("Some expectations are already set for the RepositoryI.CreateKnowledgeBaseFile method")
	}

	mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile = f
	return mmCreateKnowledgeBaseFile.mock
}

// When sets expectation for the RepositoryI.CreateKnowledgeBaseFile which will trigger the result defined by the following
// Then helper
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) When(ctx context.Context, kb mm_repository.KnowledgeBaseFile, externalServiceCall func(FileUID string) error) *RepositoryIMockCreateKnowledgeBaseFileExpectation {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	expectation := &RepositoryIMockCreateKnowledgeBaseFileExpectation{
		mock:   mmCreateKnowledgeBaseFile.mock,
		params: &RepositoryIMockCreateKnowledgeBaseFileParams{ctx, kb, externalServiceCall},
	}
	mmCreateKnowledgeBaseFile.expectations = append(mmCreateKnowledgeBaseFile.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.CreateKnowledgeBaseFile return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockCreateKnowledgeBaseFileExpectation) Then(kp1 *mm_repository.KnowledgeBaseFile, err error) *RepositoryIMock {
	e.results = &RepositoryIMockCreateKnowledgeBaseFileResults{kp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.CreateKnowledgeBaseFile should be invoked
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) Times(n uint64) *mRepositoryIMockCreateKnowledgeBaseFile {
	if n == 0 {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("Times of RepositoryIMock.CreateKnowledgeBaseFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateKnowledgeBaseFile.expectedInvocations, n)
	return mmCreateKnowledgeBaseFile
}

func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) invocationsDone() bool {
	if len(mmCreateKnowledgeBaseFile.expectations) == 0 && mmCreateKnowledgeBaseFile.defaultExpectation == nil && mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateKnowledgeBaseFile.mock.afterCreateKnowledgeBaseFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateKnowledgeBaseFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateKnowledgeBaseFile implements repository.RepositoryI
func (mmCreateKnowledgeBaseFile *RepositoryIMock) CreateKnowledgeBaseFile(ctx context.Context, kb mm_repository.KnowledgeBaseFile, externalServiceCall func(FileUID string) error) (kp1 *mm_repository.KnowledgeBaseFile, err error) {
	mm_atomic.AddUint64(&mmCreateKnowledgeBaseFile.beforeCreateKnowledgeBaseFileCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateKnowledgeBaseFile.afterCreateKnowledgeBaseFileCounter, 1)

	if mmCreateKnowledgeBaseFile.inspectFuncCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.inspectFuncCreateKnowledgeBaseFile(ctx, kb, externalServiceCall)
	}

	mm_params := RepositoryIMockCreateKnowledgeBaseFileParams{ctx, kb, externalServiceCall}

	// Record call args
	mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.mutex.Lock()
	mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.callArgs = append(mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.callArgs, &mm_params)
	mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.mutex.Unlock()

	for _, e := range mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation.params
		mm_want_ptrs := mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockCreateKnowledgeBaseFileParams{ctx, kb, externalServiceCall}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateKnowledgeBaseFile.t.Errorf("RepositoryIMock.CreateKnowledgeBaseFile got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kb != nil && !minimock.Equal(*mm_want_ptrs.kb, mm_got.kb) {
				mmCreateKnowledgeBaseFile.t.Errorf("RepositoryIMock.CreateKnowledgeBaseFile got unexpected parameter kb, want: %#v, got: %#v%s\n", *mm_want_ptrs.kb, mm_got.kb, minimock.Diff(*mm_want_ptrs.kb, mm_got.kb))
			}

			if mm_want_ptrs.externalServiceCall != nil && !minimock.Equal(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall) {
				mmCreateKnowledgeBaseFile.t.Errorf("RepositoryIMock.CreateKnowledgeBaseFile got unexpected parameter externalServiceCall, want: %#v, got: %#v%s\n", *mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall, minimock.Diff(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateKnowledgeBaseFile.t.Errorf("RepositoryIMock.CreateKnowledgeBaseFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateKnowledgeBaseFile.t.Fatal("No results are set for the RepositoryIMock.CreateKnowledgeBaseFile")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmCreateKnowledgeBaseFile.funcCreateKnowledgeBaseFile != nil {
		return mmCreateKnowledgeBaseFile.funcCreateKnowledgeBaseFile(ctx, kb, externalServiceCall)
	}
	mmCreateKnowledgeBaseFile.t.Fatalf("Unexpected call to RepositoryIMock.CreateKnowledgeBaseFile. %v %v %v", ctx, kb, externalServiceCall)
	return
}

// CreateKnowledgeBaseFileAfterCounter returns a count of finished RepositoryIMock.CreateKnowledgeBaseFile invocations
func (mmCreateKnowledgeBaseFile *RepositoryIMock) CreateKnowledgeBaseFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateKnowledgeBaseFile.afterCreateKnowledgeBaseFileCounter)
}

// CreateKnowledgeBaseFileBeforeCounter returns a count of RepositoryIMock.CreateKnowledgeBaseFile invocations
func (mmCreateKnowledgeBaseFile *RepositoryIMock) CreateKnowledgeBaseFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateKnowledgeBaseFile.beforeCreateKnowledgeBaseFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.CreateKnowledgeBaseFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) Calls() []*RepositoryIMockCreateKnowledgeBaseFileParams {
	mmCreateKnowledgeBaseFile.mutex.RLock()

	argCopy := make([]*RepositoryIMockCreateKnowledgeBaseFileParams, len(mmCreateKnowledgeBaseFile.callArgs))
	copy(argCopy, mmCreateKnowledgeBaseFile.callArgs)

	mmCreateKnowledgeBaseFile.mutex.RUnlock()

	return argCopy
}

// MinimockCreateKnowledgeBaseFileDone returns true if the count of the CreateKnowledgeBaseFile invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockCreateKnowledgeBaseFileDone() bool {
	for _, e := range m.CreateKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateKnowledgeBaseFileMock.invocationsDone()
}

// MinimockCreateKnowledgeBaseFileInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockCreateKnowledgeBaseFileInspect() {
	for _, e := range m.CreateKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.CreateKnowledgeBaseFile with params: %#v", *e.params)
		}
	}

	afterCreateKnowledgeBaseFileCounter := mm_atomic.LoadUint64(&m.afterCreateKnowledgeBaseFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateKnowledgeBaseFileMock.defaultExpectation != nil && afterCreateKnowledgeBaseFileCounter < 1 {
		if m.CreateKnowledgeBaseFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.CreateKnowledgeBaseFile")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.CreateKnowledgeBaseFile with params: %#v", *m.CreateKnowledgeBaseFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateKnowledgeBaseFile != nil && afterCreateKnowledgeBaseFileCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.CreateKnowledgeBaseFile")
	}

	if !m.CreateKnowledgeBaseFileMock.invocationsDone() && afterCreateKnowledgeBaseFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.CreateKnowledgeBaseFile but found %d calls",
			mm_atomic.LoadUint64(&m.CreateKnowledgeBaseFileMock.expectedInvocations), afterCreateKnowledgeBaseFileCounter)
	}
}

type mRepositoryIMockCreateObject struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockCreateObjectExpectation
	expectations       []*RepositoryIMockCreateObjectExpectation

	callArgs []*RepositoryIMockCreateObjectParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockCreateObjectExpectation specifies expectation struct of the RepositoryI.CreateObject
type RepositoryIMockCreateObjectExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockCreateObjectParams
	paramPtrs *RepositoryIMockCreateObjectParamPtrs
	results   *RepositoryIMockCreateObjectResults
	Counter   uint64
}

// RepositoryIMockCreateObjectParams contains parameters of the RepositoryI.CreateObject
type RepositoryIMockCreateObjectParams struct {
	ctx context.Context
	obj mm_repository.Object
}

// RepositoryIMockCreateObjectParamPtrs contains pointers to parameters of the RepositoryI.CreateObject
type RepositoryIMockCreateObjectParamPtrs struct {
	ctx *context.Context
	obj *mm_repository.Object
}

// RepositoryIMockCreateObjectResults contains results of the RepositoryI.CreateObject
type RepositoryIMockCreateObjectResults struct {
	op1 *mm_repository.Object
	err error
}

// Expect sets up expected params for RepositoryI.CreateObject
func (mmCreateObject *mRepositoryIMockCreateObject) Expect(ctx context.Context, obj mm_repository.Object) *mRepositoryIMockCreateObject {
	if mmCreateObject.mock.funcCreateObject != nil {
		mmCreateObject.mock.t.Fatalf("RepositoryIMock.CreateObject mock is already set by Set")
	}

	if mmCreateObject.defaultExpectation == nil {
		mmCreateObject.defaultExpectation = &RepositoryIMockCreateObjectExpectation{}
	}

	if mmCreateObject.defaultExpectation.paramPtrs != nil {
		mmCreateObject.mock.t.Fatalf("RepositoryIMock.CreateObject mock is already set by ExpectParams functions")
	}

	mmCreateObject.defaultExpectation.params = &RepositoryIMockCreateObjectParams{ctx, obj}
	for _, e := range mmCreateObject.expectations {
		if minimock.Equal(e.params, mmCreateObject.defaultExpectation.params) {
			mmCreateObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateObject.defaultExpectation.params)
		}
	}

	return mmCreateObject
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.CreateObject
func (mmCreateObject *mRepositoryIMockCreateObject) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockCreateObject {
	if mmCreateObject.mock.funcCreateObject != nil {
		mmCreateObject.mock.t.Fatalf("RepositoryIMock.CreateObject mock is already set by Set")
	}

	if mmCreateObject.defaultExpectation == nil {
		mmCreateObject.defaultExpectation = &RepositoryIMockCreateObjectExpectation{}
	}

	if mmCreateObject.defaultExpectation.params != nil {
		mmCreateObject.mock.t.Fatalf("RepositoryIMock.CreateObject mock is already set by Expect")
	}

	if mmCreateObject.defaultExpectation.paramPtrs == nil {
		mmCreateObject.defaultExpectation.paramPtrs = &RepositoryIMockCreateObjectParamPtrs{}
	}
	mmCreateObject.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateObject
}

// ExpectObjParam2 sets up expected param obj for RepositoryI.CreateObject
func (mmCreateObject *mRepositoryIMockCreateObject) ExpectObjParam2(obj mm_repository.Object) *mRepositoryIMockCreateObject {
	if mmCreateObject.mock.funcCreateObject != nil {
		mmCreateObject.mock.t.Fatalf("RepositoryIMock.CreateObject mock is already set by Set")
	}

	if mmCreateObject.defaultExpectation == nil {
		mmCreateObject.defaultExpectation = &RepositoryIMockCreateObjectExpectation{}
	}

	if mmCreateObject.defaultExpectation.params != nil {
		mmCreateObject.mock.t.Fatalf("RepositoryIMock.CreateObject mock is already set by Expect")
	}

	if mmCreateObject.defaultExpectation.paramPtrs == nil {
		mmCreateObject.defaultExpectation.paramPtrs = &RepositoryIMockCreateObjectParamPtrs{}
	}
	mmCreateObject.defaultExpectation.paramPtrs.obj = &obj

	return mmCreateObject
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.CreateObject
func (mmCreateObject *mRepositoryIMockCreateObject) Inspect(f func(ctx context.Context, obj mm_repository.Object)) *mRepositoryIMockCreateObject {
	if mmCreateObject.mock.inspectFuncCreateObject != nil {
		mmCreateObject.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.CreateObject")
	}

	mmCreateObject.mock.inspectFuncCreateObject = f

	return mmCreateObject
}

// Return sets up results that will be returned by RepositoryI.CreateObject
func (mmCreateObject *mRepositoryIMockCreateObject) Return(op1 *mm_repository.Object, err error) *RepositoryIMock {
	if mmCreateObject.mock.funcCreateObject != nil {
		mmCreateObject.mock.t.Fatalf("RepositoryIMock.CreateObject mock is already set by Set")
	}

	if mmCreateObject.defaultExpectation == nil {
		mmCreateObject.defaultExpectation = &RepositoryIMockCreateObjectExpectation{mock: mmCreateObject.mock}
	}
	mmCreateObject.defaultExpectation.results = &RepositoryIMockCreateObjectResults{op1, err}
	return mmCreateObject.mock
}

// Set uses given function f to mock the RepositoryI.CreateObject method
func (mmCreateObject *mRepositoryIMockCreateObject) Set(f func(ctx context.Context, obj mm_repository.Object) (op1 *mm_repository.Object, err error)) *RepositoryIMock {
	if mmCreateObject.defaultExpectation != nil {
		mmCreateObject.mock.t.Fatalf("Default expectation is already set for the RepositoryI.CreateObject method")
	}

	if len(mmCreateObject.expectations) > 0 {
		mmCreateObject.mock.t.Fatalf("Some expectations are already set for the RepositoryI.CreateObject method")
	}

	mmCreateObject.mock.funcCreateObject = f
	return mmCreateObject.mock
}

// When sets expectation for the RepositoryI.CreateObject which will trigger the result defined by the following
// Then helper
func (mmCreateObject *mRepositoryIMockCreateObject) When(ctx context.Context, obj mm_repository.Object) *RepositoryIMockCreateObjectExpectation {
	if mmCreateObject.mock.funcCreateObject != nil {
		mmCreateObject.mock.t.Fatalf("RepositoryIMock.CreateObject mock is already set by Set")
	}

	expectation := &RepositoryIMockCreateObjectExpectation{
		mock:   mmCreateObject.mock,
		params: &RepositoryIMockCreateObjectParams{ctx, obj},
	}
	mmCreateObject.expectations = append(mmCreateObject.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.CreateObject return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockCreateObjectExpectation) Then(op1 *mm_repository.Object, err error) *RepositoryIMock {
	e.results = &RepositoryIMockCreateObjectResults{op1, err}
	return e.mock
}

// Times sets number of times RepositoryI.CreateObject should be invoked
func (mmCreateObject *mRepositoryIMockCreateObject) Times(n uint64) *mRepositoryIMockCreateObject {
	if n == 0 {
		mmCreateObject.mock.t.Fatalf("Times of RepositoryIMock.CreateObject mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateObject.expectedInvocations, n)
	return mmCreateObject
}

func (mmCreateObject *mRepositoryIMockCreateObject) invocationsDone() bool {
	if len(mmCreateObject.expectations) == 0 && mmCreateObject.defaultExpectation == nil && mmCreateObject.mock.funcCreateObject == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateObject.mock.afterCreateObjectCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateObject.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateObject implements repository.RepositoryI
func (mmCreateObject *RepositoryIMock) CreateObject(ctx context.Context, obj mm_repository.Object) (op1 *mm_repository.Object, err error) {
	mm_atomic.AddUint64(&mmCreateObject.beforeCreateObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateObject.afterCreateObjectCounter, 1)

	if mmCreateObject.inspectFuncCreateObject != nil {
		mmCreateObject.inspectFuncCreateObject(ctx, obj)
	}

	mm_params := RepositoryIMockCreateObjectParams{ctx, obj}

	// Record call args
	mmCreateObject.CreateObjectMock.mutex.Lock()
	mmCreateObject.CreateObjectMock.callArgs = append(mmCreateObject.CreateObjectMock.callArgs, &mm_params)
	mmCreateObject.CreateObjectMock.mutex.Unlock()

	for _, e := range mmCreateObject.CreateObjectMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmCreateObject.CreateObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateObject.CreateObjectMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateObject.CreateObjectMock.defaultExpectation.params
		mm_want_ptrs := mmCreateObject.CreateObjectMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockCreateObjectParams{ctx, obj}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateObject.t.Errorf("RepositoryIMock.CreateObject got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.obj != nil && !minimock.Equal(*mm_want_ptrs.obj, mm_got.obj) {
				mmCreateObject.t.Errorf("RepositoryIMock.CreateObject got unexpected parameter obj, want: %#v, got: %#v%s\n", *mm_want_ptrs.obj, mm_got.obj, minimock.Diff(*mm_want_ptrs.obj, mm_got.obj))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateObject.t.Errorf("RepositoryIMock.CreateObject got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateObject.CreateObjectMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateObject.t.Fatal("No results are set for the RepositoryIMock.CreateObject")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmCreateObject.funcCreateObject != nil {
		return mmCreateObject.funcCreateObject(ctx, obj)
	}
	mmCreateObject.t.Fatalf("Unexpected call to RepositoryIMock.CreateObject. %v %v", ctx, obj)
	return
}

// CreateObjectAfterCounter returns a count of finished RepositoryIMock.CreateObject invocations
func (mmCreateObject *RepositoryIMock) CreateObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateObject.afterCreateObjectCounter)
}

// CreateObjectBeforeCounter returns a count of RepositoryIMock.CreateObject invocations
func (mmCreateObject *RepositoryIMock) CreateObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateObject.beforeCreateObjectCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.CreateObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateObject *mRepositoryIMockCreateObject) Calls() []*RepositoryIMockCreateObjectParams {
	mmCreateObject.mutex.RLock()

	argCopy := make([]*RepositoryIMockCreateObjectParams, len(mmCreateObject.callArgs))
	copy(argCopy, mmCreateObject.callArgs)

	mmCreateObject.mutex.RUnlock()

	return argCopy
}

// MinimockCreateObjectDone returns true if the count of the CreateObject invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockCreateObjectDone() bool {
	for _, e := range m.CreateObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateObjectMock.invocationsDone()
}

// MinimockCreateObjectInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockCreateObjectInspect() {
	for _, e := range m.CreateObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.CreateObject with params: %#v", *e.params)
		}
	}

	afterCreateObjectCounter := mm_atomic.LoadUint64(&m.afterCreateObjectCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateObjectMock.defaultExpectation != nil && afterCreateObjectCounter < 1 {
		if m.CreateObjectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.CreateObject")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.CreateObject with params: %#v", *m.CreateObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateObject != nil && afterCreateObjectCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.CreateObject")
	}

	if !m.CreateObjectMock.invocationsDone() && afterCreateObjectCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.CreateObject but found %d calls",
			mm_atomic.LoadUint64(&m.CreateObjectMock.expectedInvocations), afterCreateObjectCounter)
	}
}

type mRepositoryIMockCreateObjectURL struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockCreateObjectURLExpectation
	expectations       []*RepositoryIMockCreateObjectURLExpectation

	callArgs []*RepositoryIMockCreateObjectURLParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockCreateObjectURLExpectation specifies expectation struct of the RepositoryI.CreateObjectURL
type RepositoryIMockCreateObjectURLExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockCreateObjectURLParams
	paramPtrs *RepositoryIMockCreateObjectURLParamPtrs
	results   *RepositoryIMockCreateObjectURLResults
	Counter   uint64
}

// RepositoryIMockCreateObjectURLParams contains parameters of the RepositoryI.CreateObjectURL
type RepositoryIMockCreateObjectURLParams struct {
	ctx       context.Context
	objectURL mm_repository.ObjectURL
}

// RepositoryIMockCreateObjectURLParamPtrs contains pointers to parameters of the RepositoryI.CreateObjectURL
type RepositoryIMockCreateObjectURLParamPtrs struct {
	ctx       *context.Context
	objectURL *mm_repository.ObjectURL
}

// RepositoryIMockCreateObjectURLResults contains results of the RepositoryI.CreateObjectURL
type RepositoryIMockCreateObjectURLResults struct {
	op1 *mm_repository.ObjectURL
	err error
}

// Expect sets up expected params for RepositoryI.CreateObjectURL
func (mmCreateObjectURL *mRepositoryIMockCreateObjectURL) Expect(ctx context.Context, objectURL mm_repository.ObjectURL) *mRepositoryIMockCreateObjectURL {
	if mmCreateObjectURL.mock.funcCreateObjectURL != nil {
		mmCreateObjectURL.mock.t.Fatalf("RepositoryIMock.CreateObjectURL mock is already set by Set")
	}

	if mmCreateObjectURL.defaultExpectation == nil {
		mmCreateObjectURL.defaultExpectation = &RepositoryIMockCreateObjectURLExpectation{}
	}

	if mmCreateObjectURL.defaultExpectation.paramPtrs != nil {
		mmCreateObjectURL.mock.t.Fatalf("RepositoryIMock.CreateObjectURL mock is already set by ExpectParams functions")
	}

	mmCreateObjectURL.defaultExpectation.params = &RepositoryIMockCreateObjectURLParams{ctx, objectURL}
	for _, e := range mmCreateObjectURL.expectations {
		if minimock.Equal(e.params, mmCreateObjectURL.defaultExpectation.params) {
			mmCreateObjectURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateObjectURL.defaultExpectation.params)
		}
	}

	return mmCreateObjectURL
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.CreateObjectURL
func (mmCreateObjectURL *mRepositoryIMockCreateObjectURL) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockCreateObjectURL {
	if mmCreateObjectURL.mock.funcCreateObjectURL != nil {
		mmCreateObjectURL.mock.t.Fatalf("RepositoryIMock.CreateObjectURL mock is already set by Set")
	}

	if mmCreateObjectURL.defaultExpectation == nil {
		mmCreateObjectURL.defaultExpectation = &RepositoryIMockCreateObjectURLExpectation{}
	}

	if mmCreateObjectURL.defaultExpectation.params != nil {
		mmCreateObjectURL.mock.t.Fatalf("RepositoryIMock.CreateObjectURL mock is already set by Expect")
	}

	if mmCreateObjectURL.defaultExpectation.paramPtrs == nil {
		mmCreateObjectURL.defaultExpectation.paramPtrs = &RepositoryIMockCreateObjectURLParamPtrs{}
	}
	mmCreateObjectURL.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateObjectURL
}

// ExpectObjectURLParam2 sets up expected param objectURL for RepositoryI.CreateObjectURL
func (mmCreateObjectURL *mRepositoryIMockCreateObjectURL) ExpectObjectURLParam2(objectURL mm_repository.ObjectURL) *mRepositoryIMockCreateObjectURL {
	if mmCreateObjectURL.mock.funcCreateObjectURL != nil {
		mmCreateObjectURL.mock.t.Fatalf("RepositoryIMock.CreateObjectURL mock is already set by Set")
	}

	if mmCreateObjectURL.defaultExpectation == nil {
		mmCreateObjectURL.defaultExpectation = &RepositoryIMockCreateObjectURLExpectation{}
	}

	if mmCreateObjectURL.defaultExpectation.params != nil {
		mmCreateObjectURL.mock.t.Fatalf("RepositoryIMock.CreateObjectURL mock is already set by Expect")
	}

	if mmCreateObjectURL.defaultExpectation.paramPtrs == nil {
		mmCreateObjectURL.defaultExpectation.paramPtrs = &RepositoryIMockCreateObjectURLParamPtrs{}
	}
	mmCreateObjectURL.defaultExpectation.paramPtrs.objectURL = &objectURL

	return mmCreateObjectURL
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.CreateObjectURL
func (mmCreateObjectURL *mRepositoryIMockCreateObjectURL) Inspect(f func(ctx context.Context, objectURL mm_repository.ObjectURL)) *mRepositoryIMockCreateObjectURL {
	if mmCreateObjectURL.mock.inspectFuncCreateObjectURL != nil {
		mmCreateObjectURL.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.CreateObjectURL")
	}

	mmCreateObjectURL.mock.inspectFuncCreateObjectURL = f

	return mmCreateObjectURL
}

// Return sets up results that will be returned by RepositoryI.CreateObjectURL
func (mmCreateObjectURL *mRepositoryIMockCreateObjectURL) Return(op1 *mm_repository.ObjectURL, err error) *RepositoryIMock {
	if mmCreateObjectURL.mock.funcCreateObjectURL != nil {
		mmCreateObjectURL.mock.t.Fatalf("RepositoryIMock.CreateObjectURL mock is already set by Set")
	}

	if mmCreateObjectURL.defaultExpectation == nil {
		mmCreateObjectURL.defaultExpectation = &RepositoryIMockCreateObjectURLExpectation{mock: mmCreateObjectURL.mock}
	}
	mmCreateObjectURL.defaultExpectation.results = &RepositoryIMockCreateObjectURLResults{op1, err}
	return mmCreateObjectURL.mock
}

// Set uses given function f to mock the RepositoryI.CreateObjectURL method
func (mmCreateObjectURL *mRepositoryIMockCreateObjectURL) Set(f func(ctx context.Context, objectURL mm_repository.ObjectURL) (op1 *mm_repository.ObjectURL, err error)) *RepositoryIMock {
	if mmCreateObjectURL.defaultExpectation != nil {
		mmCreateObjectURL.mock.t.Fatalf("Default expectation is already set for the RepositoryI.CreateObjectURL method")
	}

	if len(mmCreateObjectURL.expectations) > 0 {
		mmCreateObjectURL.mock.t.Fatalf("Some expectations are already set for the RepositoryI.CreateObjectURL method")
	}

	mmCreateObjectURL.mock.funcCreateObjectURL = f
	return mmCreateObjectURL.mock
}

// When sets expectation for the RepositoryI.CreateObjectURL which will trigger the result defined by the following
// Then helper
func (mmCreateObjectURL *mRepositoryIMockCreateObjectURL) When(ctx context.Context, objectURL mm_repository.ObjectURL) *RepositoryIMockCreateObjectURLExpectation {
	if mmCreateObjectURL.mock.funcCreateObjectURL != nil {
		mmCreateObjectURL.mock.t.Fatalf("RepositoryIMock.CreateObjectURL mock is already set by Set")
	}

	expectation := &RepositoryIMockCreateObjectURLExpectation{
		mock:   mmCreateObjectURL.mock,
		params: &RepositoryIMockCreateObjectURLParams{ctx, objectURL},
	}
	mmCreateObjectURL.expectations = append(mmCreateObjectURL.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.CreateObjectURL return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockCreateObjectURLExpectation) Then(op1 *mm_repository.ObjectURL, err error) *RepositoryIMock {
	e.results = &RepositoryIMockCreateObjectURLResults{op1, err}
	return e.mock
}

// Times sets number of times RepositoryI.CreateObjectURL should be invoked
func (mmCreateObjectURL *mRepositoryIMockCreateObjectURL) Times(n uint64) *mRepositoryIMockCreateObjectURL {
	if n == 0 {
		mmCreateObjectURL.mock.t.Fatalf("Times of RepositoryIMock.CreateObjectURL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateObjectURL.expectedInvocations, n)
	return mmCreateObjectURL
}

func (mmCreateObjectURL *mRepositoryIMockCreateObjectURL) invocationsDone() bool {
	if len(mmCreateObjectURL.expectations) == 0 && mmCreateObjectURL.defaultExpectation == nil && mmCreateObjectURL.mock.funcCreateObjectURL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateObjectURL.mock.afterCreateObjectURLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateObjectURL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateObjectURL implements repository.RepositoryI
func (mmCreateObjectURL *RepositoryIMock) CreateObjectURL(ctx context.Context, objectURL mm_repository.ObjectURL) (op1 *mm_repository.ObjectURL, err error) {
	mm_atomic.AddUint64(&mmCreateObjectURL.beforeCreateObjectURLCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateObjectURL.afterCreateObjectURLCounter, 1)

	if mmCreateObjectURL.inspectFuncCreateObjectURL != nil {
		mmCreateObjectURL.inspectFuncCreateObjectURL(ctx, objectURL)
	}

	mm_params := RepositoryIMockCreateObjectURLParams{ctx, objectURL}

	// Record call args
	mmCreateObjectURL.CreateObjectURLMock.mutex.Lock()
	mmCreateObjectURL.CreateObjectURLMock.callArgs = append(mmCreateObjectURL.CreateObjectURLMock.callArgs, &mm_params)
	mmCreateObjectURL.CreateObjectURLMock.mutex.Unlock()

	for _, e := range mmCreateObjectURL.CreateObjectURLMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmCreateObjectURL.CreateObjectURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateObjectURL.CreateObjectURLMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateObjectURL.CreateObjectURLMock.defaultExpectation.params
		mm_want_ptrs := mmCreateObjectURL.CreateObjectURLMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockCreateObjectURLParams{ctx, objectURL}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateObjectURL.t.Errorf("RepositoryIMock.CreateObjectURL got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectURL != nil && !minimock.Equal(*mm_want_ptrs.objectURL, mm_got.objectURL) {
				mmCreateObjectURL.t.Errorf("RepositoryIMock.CreateObjectURL got unexpected parameter objectURL, want: %#v, got: %#v%s\n", *mm_want_ptrs.objectURL, mm_got.objectURL, minimock.Diff(*mm_want_ptrs.objectURL, mm_got.objectURL))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateObjectURL.t.Errorf("RepositoryIMock.CreateObjectURL got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateObjectURL.CreateObjectURLMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateObjectURL.t.Fatal("No results are set for the RepositoryIMock.CreateObjectURL")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmCreateObjectURL.funcCreateObjectURL != nil {
		return mmCreateObjectURL.funcCreateObjectURL(ctx, objectURL)
	}
	mmCreateObjectURL.t.Fatalf("Unexpected call to RepositoryIMock.CreateObjectURL. %v %v", ctx, objectURL)
	return
}

// CreateObjectURLAfterCounter returns a count of finished RepositoryIMock.CreateObjectURL invocations
func (mmCreateObjectURL *RepositoryIMock) CreateObjectURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateObjectURL.afterCreateObjectURLCounter)
}

// CreateObjectURLBeforeCounter returns a count of RepositoryIMock.CreateObjectURL invocations
func (mmCreateObjectURL *RepositoryIMock) CreateObjectURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateObjectURL.beforeCreateObjectURLCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.CreateObjectURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateObjectURL *mRepositoryIMockCreateObjectURL) Calls() []*RepositoryIMockCreateObjectURLParams {
	mmCreateObjectURL.mutex.RLock()

	argCopy := make([]*RepositoryIMockCreateObjectURLParams, len(mmCreateObjectURL.callArgs))
	copy(argCopy, mmCreateObjectURL.callArgs)

	mmCreateObjectURL.mutex.RUnlock()

	return argCopy
}

// MinimockCreateObjectURLDone returns true if the count of the CreateObjectURL invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockCreateObjectURLDone() bool {
	for _, e := range m.CreateObjectURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateObjectURLMock.invocationsDone()
}

// MinimockCreateObjectURLInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockCreateObjectURLInspect() {
	for _, e := range m.CreateObjectURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.CreateObjectURL with params: %#v", *e.params)
		}
	}

	afterCreateObjectURLCounter := mm_atomic.LoadUint64(&m.afterCreateObjectURLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateObjectURLMock.defaultExpectation != nil && afterCreateObjectURLCounter < 1 {
		if m.CreateObjectURLMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.CreateObjectURL")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.CreateObjectURL with params: %#v", *m.CreateObjectURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateObjectURL != nil && afterCreateObjectURLCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.CreateObjectURL")
	}

	if !m.CreateObjectURLMock.invocationsDone() && afterCreateObjectURLCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.CreateObjectURL but found %d calls",
			mm_atomic.LoadUint64(&m.CreateObjectURLMock.expectedInvocations), afterCreateObjectURLCounter)
	}
}

type mRepositoryIMockDeleteAllConvertedFilesInKb struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteAllConvertedFilesInKbExpectation
	expectations       []*RepositoryIMockDeleteAllConvertedFilesInKbExpectation

	callArgs []*RepositoryIMockDeleteAllConvertedFilesInKbParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteAllConvertedFilesInKbExpectation specifies expectation struct of the RepositoryI.DeleteAllConvertedFilesInKb
type RepositoryIMockDeleteAllConvertedFilesInKbExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteAllConvertedFilesInKbParams
	paramPtrs *RepositoryIMockDeleteAllConvertedFilesInKbParamPtrs
	results   *RepositoryIMockDeleteAllConvertedFilesInKbResults
	Counter   uint64
}

// RepositoryIMockDeleteAllConvertedFilesInKbParams contains parameters of the RepositoryI.DeleteAllConvertedFilesInKb
type RepositoryIMockDeleteAllConvertedFilesInKbParams struct {
	ctx   context.Context
	kbUID uuid.UUID
}

// RepositoryIMockDeleteAllConvertedFilesInKbParamPtrs contains pointers to parameters of the RepositoryI.DeleteAllConvertedFilesInKb
type RepositoryIMockDeleteAllConvertedFilesInKbParamPtrs struct {
	ctx   *context.Context
	kbUID *uuid.UUID
}

// RepositoryIMockDeleteAllConvertedFilesInKbResults contains results of the RepositoryI.DeleteAllConvertedFilesInKb
type RepositoryIMockDeleteAllConvertedFilesInKbResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteAllConvertedFilesInKb
func (mmDeleteAllConvertedFilesInKb *mRepositoryIMockDeleteAllConvertedFilesInKb) Expect(ctx context.Context, kbUID uuid.UUID) *mRepositoryIMockDeleteAllConvertedFilesInKb {
	if mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKb != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryIMock.DeleteAllConvertedFilesInKb mock is already set by Set")
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation == nil {
		mmDeleteAllConvertedFilesInKb.defaultExpectation = &RepositoryIMockDeleteAllConvertedFilesInKbExpectation{}
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation.paramPtrs != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryIMock.DeleteAllConvertedFilesInKb mock is already set by ExpectParams functions")
	}

	mmDeleteAllConvertedFilesInKb.defaultExpectation.params = &RepositoryIMockDeleteAllConvertedFilesInKbParams{ctx, kbUID}
	for _, e := range mmDeleteAllConvertedFilesInKb.expectations {
		if minimock.Equal(e.params, mmDeleteAllConvertedFilesInKb.defaultExpectation.params) {
			mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteAllConvertedFilesInKb.defaultExpectation.params)
		}
	}

	return mmDeleteAllConvertedFilesInKb
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteAllConvertedFilesInKb
func (mmDeleteAllConvertedFilesInKb *mRepositoryIMockDeleteAllConvertedFilesInKb) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteAllConvertedFilesInKb {
	if mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKb != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryIMock.DeleteAllConvertedFilesInKb mock is already set by Set")
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation == nil {
		mmDeleteAllConvertedFilesInKb.defaultExpectation = &RepositoryIMockDeleteAllConvertedFilesInKbExpectation{}
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation.params != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryIMock.DeleteAllConvertedFilesInKb mock is already set by Expect")
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation.paramPtrs == nil {
		mmDeleteAllConvertedFilesInKb.defaultExpectation.paramPtrs = &RepositoryIMockDeleteAllConvertedFilesInKbParamPtrs{}
	}
	mmDeleteAllConvertedFilesInKb.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteAllConvertedFilesInKb
}

// ExpectKbUIDParam2 sets up expected param kbUID for RepositoryI.DeleteAllConvertedFilesInKb
func (mmDeleteAllConvertedFilesInKb *mRepositoryIMockDeleteAllConvertedFilesInKb) ExpectKbUIDParam2(kbUID uuid.UUID) *mRepositoryIMockDeleteAllConvertedFilesInKb {
	if mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKb != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryIMock.DeleteAllConvertedFilesInKb mock is already set by Set")
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation == nil {
		mmDeleteAllConvertedFilesInKb.defaultExpectation = &RepositoryIMockDeleteAllConvertedFilesInKbExpectation{}
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation.params != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryIMock.DeleteAllConvertedFilesInKb mock is already set by Expect")
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation.paramPtrs == nil {
		mmDeleteAllConvertedFilesInKb.defaultExpectation.paramPtrs = &RepositoryIMockDeleteAllConvertedFilesInKbParamPtrs{}
	}
	mmDeleteAllConvertedFilesInKb.defaultExpectation.paramPtrs.kbUID = &kbUID

	return mmDeleteAllConvertedFilesInKb
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteAllConvertedFilesInKb
func (mmDeleteAllConvertedFilesInKb *mRepositoryIMockDeleteAllConvertedFilesInKb) Inspect(f func(ctx context.Context, kbUID uuid.UUID)) *mRepositoryIMockDeleteAllConvertedFilesInKb {
	if mmDeleteAllConvertedFilesInKb.mock.inspectFuncDeleteAllConvertedFilesInKb != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteAllConvertedFilesInKb")
	}

	mmDeleteAllConvertedFilesInKb.mock.inspectFuncDeleteAllConvertedFilesInKb = f

	return mmDeleteAllConvertedFilesInKb
}

// Return sets up results that will be returned by RepositoryI.DeleteAllConvertedFilesInKb
func (mmDeleteAllConvertedFilesInKb *mRepositoryIMockDeleteAllConvertedFilesInKb) Return(err error) *RepositoryIMock {
	if mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKb != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryIMock.DeleteAllConvertedFilesInKb mock is already set by Set")
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation == nil {
		mmDeleteAllConvertedFilesInKb.defaultExpectation = &RepositoryIMockDeleteAllConvertedFilesInKbExpectation{mock: mmDeleteAllConvertedFilesInKb.mock}
	}
	mmDeleteAllConvertedFilesInKb.defaultExpectation.results = &RepositoryIMockDeleteAllConvertedFilesInKbResults{err}
	return mmDeleteAllConvertedFilesInKb.mock
}

// Set uses given function f to mock the RepositoryI.DeleteAllConvertedFilesInKb method
func (mmDeleteAllConvertedFilesInKb *mRepositoryIMockDeleteAllConvertedFilesInKb) Set(f func(ctx context.Context, kbUID uuid.UUID) (err error)) *RepositoryIMock {
	if mmDeleteAllConvertedFilesInKb.defaultExpectation != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteAllConvertedFilesInKb method")
	}

	if len(mmDeleteAllConvertedFilesInKb.expectations) > 0 {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteAllConvertedFilesInKb method")
	}

	mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKb = f
	return mmDeleteAllConvertedFilesInKb.mock
}

// When sets expectation for the RepositoryI.DeleteAllConvertedFilesInKb which will trigger the result defined by the following
// Then helper
func (mmDeleteAllConvertedFilesInKb *mRepositoryIMockDeleteAllConvertedFilesInKb) When(ctx context.Context, kbUID uuid.UUID) *RepositoryIMockDeleteAllConvertedFilesInKbExpectation {
	if mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKb != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryIMock.DeleteAllConvertedFilesInKb mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteAllConvertedFilesInKbExpectation{
		mock:   mmDeleteAllConvertedFilesInKb.mock,
		params: &RepositoryIMockDeleteAllConvertedFilesInKbParams{ctx, kbUID},
	}
	mmDeleteAllConvertedFilesInKb.expectations = append(mmDeleteAllConvertedFilesInKb.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteAllConvertedFilesInKb return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteAllConvertedFilesInKbExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteAllConvertedFilesInKbResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteAllConvertedFilesInKb should be invoked
func (mmDeleteAllConvertedFilesInKb *mRepositoryIMockDeleteAllConvertedFilesInKb) Times(n uint64) *mRepositoryIMockDeleteAllConvertedFilesInKb {
	if n == 0 {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("Times of RepositoryIMock.DeleteAllConvertedFilesInKb mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteAllConvertedFilesInKb.expectedInvocations, n)
	return mmDeleteAllConvertedFilesInKb
}

func (mmDeleteAllConvertedFilesInKb *mRepositoryIMockDeleteAllConvertedFilesInKb) invocationsDone() bool {
	if len(mmDeleteAllConvertedFilesInKb.expectations) == 0 && mmDeleteAllConvertedFilesInKb.defaultExpectation == nil && mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKb == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteAllConvertedFilesInKb.mock.afterDeleteAllConvertedFilesInKbCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteAllConvertedFilesInKb.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteAllConvertedFilesInKb implements repository.RepositoryI
func (mmDeleteAllConvertedFilesInKb *RepositoryIMock) DeleteAllConvertedFilesInKb(ctx context.Context, kbUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteAllConvertedFilesInKb.beforeDeleteAllConvertedFilesInKbCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteAllConvertedFilesInKb.afterDeleteAllConvertedFilesInKbCounter, 1)

	if mmDeleteAllConvertedFilesInKb.inspectFuncDeleteAllConvertedFilesInKb != nil {
		mmDeleteAllConvertedFilesInKb.inspectFuncDeleteAllConvertedFilesInKb(ctx, kbUID)
	}

	mm_params := RepositoryIMockDeleteAllConvertedFilesInKbParams{ctx, kbUID}

	// Record call args
	mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.mutex.Lock()
	mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.callArgs = append(mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.callArgs, &mm_params)
	mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.mutex.Unlock()

	for _, e := range mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteAllConvertedFilesInKbParams{ctx, kbUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteAllConvertedFilesInKb.t.Errorf("RepositoryIMock.DeleteAllConvertedFilesInKb got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmDeleteAllConvertedFilesInKb.t.Errorf("RepositoryIMock.DeleteAllConvertedFilesInKb got unexpected parameter kbUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteAllConvertedFilesInKb.t.Errorf("RepositoryIMock.DeleteAllConvertedFilesInKb got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteAllConvertedFilesInKb.t.Fatal("No results are set for the RepositoryIMock.DeleteAllConvertedFilesInKb")
		}
		return (*mm_results).err
	}
	if mmDeleteAllConvertedFilesInKb.funcDeleteAllConvertedFilesInKb != nil {
		return mmDeleteAllConvertedFilesInKb.funcDeleteAllConvertedFilesInKb(ctx, kbUID)
	}
	mmDeleteAllConvertedFilesInKb.t.Fatalf("Unexpected call to RepositoryIMock.DeleteAllConvertedFilesInKb. %v %v", ctx, kbUID)
	return
}

// DeleteAllConvertedFilesInKbAfterCounter returns a count of finished RepositoryIMock.DeleteAllConvertedFilesInKb invocations
func (mmDeleteAllConvertedFilesInKb *RepositoryIMock) DeleteAllConvertedFilesInKbAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAllConvertedFilesInKb.afterDeleteAllConvertedFilesInKbCounter)
}

// DeleteAllConvertedFilesInKbBeforeCounter returns a count of RepositoryIMock.DeleteAllConvertedFilesInKb invocations
func (mmDeleteAllConvertedFilesInKb *RepositoryIMock) DeleteAllConvertedFilesInKbBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAllConvertedFilesInKb.beforeDeleteAllConvertedFilesInKbCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteAllConvertedFilesInKb.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteAllConvertedFilesInKb *mRepositoryIMockDeleteAllConvertedFilesInKb) Calls() []*RepositoryIMockDeleteAllConvertedFilesInKbParams {
	mmDeleteAllConvertedFilesInKb.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteAllConvertedFilesInKbParams, len(mmDeleteAllConvertedFilesInKb.callArgs))
	copy(argCopy, mmDeleteAllConvertedFilesInKb.callArgs)

	mmDeleteAllConvertedFilesInKb.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteAllConvertedFilesInKbDone returns true if the count of the DeleteAllConvertedFilesInKb invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteAllConvertedFilesInKbDone() bool {
	for _, e := range m.DeleteAllConvertedFilesInKbMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteAllConvertedFilesInKbMock.invocationsDone()
}

// MinimockDeleteAllConvertedFilesInKbInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteAllConvertedFilesInKbInspect() {
	for _, e := range m.DeleteAllConvertedFilesInKbMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteAllConvertedFilesInKb with params: %#v", *e.params)
		}
	}

	afterDeleteAllConvertedFilesInKbCounter := mm_atomic.LoadUint64(&m.afterDeleteAllConvertedFilesInKbCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteAllConvertedFilesInKbMock.defaultExpectation != nil && afterDeleteAllConvertedFilesInKbCounter < 1 {
		if m.DeleteAllConvertedFilesInKbMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteAllConvertedFilesInKb")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteAllConvertedFilesInKb with params: %#v", *m.DeleteAllConvertedFilesInKbMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteAllConvertedFilesInKb != nil && afterDeleteAllConvertedFilesInKbCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteAllConvertedFilesInKb")
	}

	if !m.DeleteAllConvertedFilesInKbMock.invocationsDone() && afterDeleteAllConvertedFilesInKbCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteAllConvertedFilesInKb but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteAllConvertedFilesInKbMock.expectedInvocations), afterDeleteAllConvertedFilesInKbCounter)
	}
}

type mRepositoryIMockDeleteAllKnowledgeBaseFiles struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteAllKnowledgeBaseFilesExpectation
	expectations       []*RepositoryIMockDeleteAllKnowledgeBaseFilesExpectation

	callArgs []*RepositoryIMockDeleteAllKnowledgeBaseFilesParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteAllKnowledgeBaseFilesExpectation specifies expectation struct of the RepositoryI.DeleteAllKnowledgeBaseFiles
type RepositoryIMockDeleteAllKnowledgeBaseFilesExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteAllKnowledgeBaseFilesParams
	paramPtrs *RepositoryIMockDeleteAllKnowledgeBaseFilesParamPtrs
	results   *RepositoryIMockDeleteAllKnowledgeBaseFilesResults
	Counter   uint64
}

// RepositoryIMockDeleteAllKnowledgeBaseFilesParams contains parameters of the RepositoryI.DeleteAllKnowledgeBaseFiles
type RepositoryIMockDeleteAllKnowledgeBaseFilesParams struct {
	ctx   context.Context
	kbUID string
}

// RepositoryIMockDeleteAllKnowledgeBaseFilesParamPtrs contains pointers to parameters of the RepositoryI.DeleteAllKnowledgeBaseFiles
type RepositoryIMockDeleteAllKnowledgeBaseFilesParamPtrs struct {
	ctx   *context.Context
	kbUID *string
}

// RepositoryIMockDeleteAllKnowledgeBaseFilesResults contains results of the RepositoryI.DeleteAllKnowledgeBaseFiles
type RepositoryIMockDeleteAllKnowledgeBaseFilesResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteAllKnowledgeBaseFiles
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryIMockDeleteAllKnowledgeBaseFiles) Expect(ctx context.Context, kbUID string) *mRepositoryIMockDeleteAllKnowledgeBaseFiles {
	if mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFiles != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.DeleteAllKnowledgeBaseFiles mock is already set by Set")
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation == nil {
		mmDeleteAllKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockDeleteAllKnowledgeBaseFilesExpectation{}
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation.paramPtrs != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.DeleteAllKnowledgeBaseFiles mock is already set by ExpectParams functions")
	}

	mmDeleteAllKnowledgeBaseFiles.defaultExpectation.params = &RepositoryIMockDeleteAllKnowledgeBaseFilesParams{ctx, kbUID}
	for _, e := range mmDeleteAllKnowledgeBaseFiles.expectations {
		if minimock.Equal(e.params, mmDeleteAllKnowledgeBaseFiles.defaultExpectation.params) {
			mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteAllKnowledgeBaseFiles.defaultExpectation.params)
		}
	}

	return mmDeleteAllKnowledgeBaseFiles
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteAllKnowledgeBaseFiles
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryIMockDeleteAllKnowledgeBaseFiles) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteAllKnowledgeBaseFiles {
	if mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFiles != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.DeleteAllKnowledgeBaseFiles mock is already set by Set")
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation == nil {
		mmDeleteAllKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockDeleteAllKnowledgeBaseFilesExpectation{}
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.DeleteAllKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmDeleteAllKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockDeleteAllKnowledgeBaseFilesParamPtrs{}
	}
	mmDeleteAllKnowledgeBaseFiles.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteAllKnowledgeBaseFiles
}

// ExpectKbUIDParam2 sets up expected param kbUID for RepositoryI.DeleteAllKnowledgeBaseFiles
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryIMockDeleteAllKnowledgeBaseFiles) ExpectKbUIDParam2(kbUID string) *mRepositoryIMockDeleteAllKnowledgeBaseFiles {
	if mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFiles != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.DeleteAllKnowledgeBaseFiles mock is already set by Set")
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation == nil {
		mmDeleteAllKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockDeleteAllKnowledgeBaseFilesExpectation{}
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.DeleteAllKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmDeleteAllKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockDeleteAllKnowledgeBaseFilesParamPtrs{}
	}
	mmDeleteAllKnowledgeBaseFiles.defaultExpectation.paramPtrs.kbUID = &kbUID

	return mmDeleteAllKnowledgeBaseFiles
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteAllKnowledgeBaseFiles
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryIMockDeleteAllKnowledgeBaseFiles) Inspect(f func(ctx context.Context, kbUID string)) *mRepositoryIMockDeleteAllKnowledgeBaseFiles {
	if mmDeleteAllKnowledgeBaseFiles.mock.inspectFuncDeleteAllKnowledgeBaseFiles != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteAllKnowledgeBaseFiles")
	}

	mmDeleteAllKnowledgeBaseFiles.mock.inspectFuncDeleteAllKnowledgeBaseFiles = f

	return mmDeleteAllKnowledgeBaseFiles
}

// Return sets up results that will be returned by RepositoryI.DeleteAllKnowledgeBaseFiles
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryIMockDeleteAllKnowledgeBaseFiles) Return(err error) *RepositoryIMock {
	if mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFiles != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.DeleteAllKnowledgeBaseFiles mock is already set by Set")
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation == nil {
		mmDeleteAllKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockDeleteAllKnowledgeBaseFilesExpectation{mock: mmDeleteAllKnowledgeBaseFiles.mock}
	}
	mmDeleteAllKnowledgeBaseFiles.defaultExpectation.results = &RepositoryIMockDeleteAllKnowledgeBaseFilesResults{err}
	return mmDeleteAllKnowledgeBaseFiles.mock
}

// Set uses given function f to mock the RepositoryI.DeleteAllKnowledgeBaseFiles method
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryIMockDeleteAllKnowledgeBaseFiles) Set(f func(ctx context.Context, kbUID string) (err error)) *RepositoryIMock {
	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteAllKnowledgeBaseFiles method")
	}

	if len(mmDeleteAllKnowledgeBaseFiles.expectations) > 0 {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteAllKnowledgeBaseFiles method")
	}

	mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFiles = f
	return mmDeleteAllKnowledgeBaseFiles.mock
}

// When sets expectation for the RepositoryI.DeleteAllKnowledgeBaseFiles which will trigger the result defined by the following
// Then helper
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryIMockDeleteAllKnowledgeBaseFiles) When(ctx context.Context, kbUID string) *RepositoryIMockDeleteAllKnowledgeBaseFilesExpectation {
	if mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFiles != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.DeleteAllKnowledgeBaseFiles mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteAllKnowledgeBaseFilesExpectation{
		mock:   mmDeleteAllKnowledgeBaseFiles.mock,
		params: &RepositoryIMockDeleteAllKnowledgeBaseFilesParams{ctx, kbUID},
	}
	mmDeleteAllKnowledgeBaseFiles.expectations = append(mmDeleteAllKnowledgeBaseFiles.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteAllKnowledgeBaseFiles return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteAllKnowledgeBaseFilesExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteAllKnowledgeBaseFilesResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteAllKnowledgeBaseFiles should be invoked
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryIMockDeleteAllKnowledgeBaseFiles) Times(n uint64) *mRepositoryIMockDeleteAllKnowledgeBaseFiles {
	if n == 0 {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("Times of RepositoryIMock.DeleteAllKnowledgeBaseFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteAllKnowledgeBaseFiles.expectedInvocations, n)
	return mmDeleteAllKnowledgeBaseFiles
}

func (mmDeleteAllKnowledgeBaseFiles *mRepositoryIMockDeleteAllKnowledgeBaseFiles) invocationsDone() bool {
	if len(mmDeleteAllKnowledgeBaseFiles.expectations) == 0 && mmDeleteAllKnowledgeBaseFiles.defaultExpectation == nil && mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteAllKnowledgeBaseFiles.mock.afterDeleteAllKnowledgeBaseFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteAllKnowledgeBaseFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteAllKnowledgeBaseFiles implements repository.RepositoryI
func (mmDeleteAllKnowledgeBaseFiles *RepositoryIMock) DeleteAllKnowledgeBaseFiles(ctx context.Context, kbUID string) (err error) {
	mm_atomic.AddUint64(&mmDeleteAllKnowledgeBaseFiles.beforeDeleteAllKnowledgeBaseFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteAllKnowledgeBaseFiles.afterDeleteAllKnowledgeBaseFilesCounter, 1)

	if mmDeleteAllKnowledgeBaseFiles.inspectFuncDeleteAllKnowledgeBaseFiles != nil {
		mmDeleteAllKnowledgeBaseFiles.inspectFuncDeleteAllKnowledgeBaseFiles(ctx, kbUID)
	}

	mm_params := RepositoryIMockDeleteAllKnowledgeBaseFilesParams{ctx, kbUID}

	// Record call args
	mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.mutex.Lock()
	mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.callArgs = append(mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.callArgs, &mm_params)
	mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.mutex.Unlock()

	for _, e := range mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteAllKnowledgeBaseFilesParams{ctx, kbUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteAllKnowledgeBaseFiles.t.Errorf("RepositoryIMock.DeleteAllKnowledgeBaseFiles got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmDeleteAllKnowledgeBaseFiles.t.Errorf("RepositoryIMock.DeleteAllKnowledgeBaseFiles got unexpected parameter kbUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteAllKnowledgeBaseFiles.t.Errorf("RepositoryIMock.DeleteAllKnowledgeBaseFiles got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteAllKnowledgeBaseFiles.t.Fatal("No results are set for the RepositoryIMock.DeleteAllKnowledgeBaseFiles")
		}
		return (*mm_results).err
	}
	if mmDeleteAllKnowledgeBaseFiles.funcDeleteAllKnowledgeBaseFiles != nil {
		return mmDeleteAllKnowledgeBaseFiles.funcDeleteAllKnowledgeBaseFiles(ctx, kbUID)
	}
	mmDeleteAllKnowledgeBaseFiles.t.Fatalf("Unexpected call to RepositoryIMock.DeleteAllKnowledgeBaseFiles. %v %v", ctx, kbUID)
	return
}

// DeleteAllKnowledgeBaseFilesAfterCounter returns a count of finished RepositoryIMock.DeleteAllKnowledgeBaseFiles invocations
func (mmDeleteAllKnowledgeBaseFiles *RepositoryIMock) DeleteAllKnowledgeBaseFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAllKnowledgeBaseFiles.afterDeleteAllKnowledgeBaseFilesCounter)
}

// DeleteAllKnowledgeBaseFilesBeforeCounter returns a count of RepositoryIMock.DeleteAllKnowledgeBaseFiles invocations
func (mmDeleteAllKnowledgeBaseFiles *RepositoryIMock) DeleteAllKnowledgeBaseFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAllKnowledgeBaseFiles.beforeDeleteAllKnowledgeBaseFilesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteAllKnowledgeBaseFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryIMockDeleteAllKnowledgeBaseFiles) Calls() []*RepositoryIMockDeleteAllKnowledgeBaseFilesParams {
	mmDeleteAllKnowledgeBaseFiles.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteAllKnowledgeBaseFilesParams, len(mmDeleteAllKnowledgeBaseFiles.callArgs))
	copy(argCopy, mmDeleteAllKnowledgeBaseFiles.callArgs)

	mmDeleteAllKnowledgeBaseFiles.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteAllKnowledgeBaseFilesDone returns true if the count of the DeleteAllKnowledgeBaseFiles invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteAllKnowledgeBaseFilesDone() bool {
	for _, e := range m.DeleteAllKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteAllKnowledgeBaseFilesMock.invocationsDone()
}

// MinimockDeleteAllKnowledgeBaseFilesInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteAllKnowledgeBaseFilesInspect() {
	for _, e := range m.DeleteAllKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteAllKnowledgeBaseFiles with params: %#v", *e.params)
		}
	}

	afterDeleteAllKnowledgeBaseFilesCounter := mm_atomic.LoadUint64(&m.afterDeleteAllKnowledgeBaseFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteAllKnowledgeBaseFilesMock.defaultExpectation != nil && afterDeleteAllKnowledgeBaseFilesCounter < 1 {
		if m.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteAllKnowledgeBaseFiles")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteAllKnowledgeBaseFiles with params: %#v", *m.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteAllKnowledgeBaseFiles != nil && afterDeleteAllKnowledgeBaseFilesCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteAllKnowledgeBaseFiles")
	}

	if !m.DeleteAllKnowledgeBaseFilesMock.invocationsDone() && afterDeleteAllKnowledgeBaseFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteAllKnowledgeBaseFiles but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteAllKnowledgeBaseFilesMock.expectedInvocations), afterDeleteAllKnowledgeBaseFilesCounter)
	}
}

type mRepositoryIMockDeleteAndCreateChunks struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteAndCreateChunksExpectation
	expectations       []*RepositoryIMockDeleteAndCreateChunksExpectation

	callArgs []*RepositoryIMockDeleteAndCreateChunksParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteAndCreateChunksExpectation specifies expectation struct of the RepositoryI.DeleteAndCreateChunks
type RepositoryIMockDeleteAndCreateChunksExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteAndCreateChunksParams
	paramPtrs *RepositoryIMockDeleteAndCreateChunksParamPtrs
	results   *RepositoryIMockDeleteAndCreateChunksResults
	Counter   uint64
}

// RepositoryIMockDeleteAndCreateChunksParams contains parameters of the RepositoryI.DeleteAndCreateChunks
type RepositoryIMockDeleteAndCreateChunksParams struct {
	ctx                 context.Context
	sourceTable         string
	sourceUID           uuid.UUID
	chunks              []*mm_repository.TextChunk
	externalServiceCall func(chunkUIDs []string) (map[string]any, error)
}

// RepositoryIMockDeleteAndCreateChunksParamPtrs contains pointers to parameters of the RepositoryI.DeleteAndCreateChunks
type RepositoryIMockDeleteAndCreateChunksParamPtrs struct {
	ctx                 *context.Context
	sourceTable         *string
	sourceUID           *uuid.UUID
	chunks              *[]*mm_repository.TextChunk
	externalServiceCall *func(chunkUIDs []string) (map[string]any, error)
}

// RepositoryIMockDeleteAndCreateChunksResults contains results of the RepositoryI.DeleteAndCreateChunks
type RepositoryIMockDeleteAndCreateChunksResults struct {
	tpa1 []*mm_repository.TextChunk
	err  error
}

// Expect sets up expected params for RepositoryI.DeleteAndCreateChunks
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) Expect(ctx context.Context, sourceTable string, sourceUID uuid.UUID, chunks []*mm_repository.TextChunk, externalServiceCall func(chunkUIDs []string) (map[string]any, error)) *mRepositoryIMockDeleteAndCreateChunks {
	if mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Set")
	}

	if mmDeleteAndCreateChunks.defaultExpectation == nil {
		mmDeleteAndCreateChunks.defaultExpectation = &RepositoryIMockDeleteAndCreateChunksExpectation{}
	}

	if mmDeleteAndCreateChunks.defaultExpectation.paramPtrs != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by ExpectParams functions")
	}

	mmDeleteAndCreateChunks.defaultExpectation.params = &RepositoryIMockDeleteAndCreateChunksParams{ctx, sourceTable, sourceUID, chunks, externalServiceCall}
	for _, e := range mmDeleteAndCreateChunks.expectations {
		if minimock.Equal(e.params, mmDeleteAndCreateChunks.defaultExpectation.params) {
			mmDeleteAndCreateChunks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteAndCreateChunks.defaultExpectation.params)
		}
	}

	return mmDeleteAndCreateChunks
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteAndCreateChunks
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteAndCreateChunks {
	if mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Set")
	}

	if mmDeleteAndCreateChunks.defaultExpectation == nil {
		mmDeleteAndCreateChunks.defaultExpectation = &RepositoryIMockDeleteAndCreateChunksExpectation{}
	}

	if mmDeleteAndCreateChunks.defaultExpectation.params != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Expect")
	}

	if mmDeleteAndCreateChunks.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateChunks.defaultExpectation.paramPtrs = &RepositoryIMockDeleteAndCreateChunksParamPtrs{}
	}
	mmDeleteAndCreateChunks.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteAndCreateChunks
}

// ExpectSourceTableParam2 sets up expected param sourceTable for RepositoryI.DeleteAndCreateChunks
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) ExpectSourceTableParam2(sourceTable string) *mRepositoryIMockDeleteAndCreateChunks {
	if mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Set")
	}

	if mmDeleteAndCreateChunks.defaultExpectation == nil {
		mmDeleteAndCreateChunks.defaultExpectation = &RepositoryIMockDeleteAndCreateChunksExpectation{}
	}

	if mmDeleteAndCreateChunks.defaultExpectation.params != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Expect")
	}

	if mmDeleteAndCreateChunks.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateChunks.defaultExpectation.paramPtrs = &RepositoryIMockDeleteAndCreateChunksParamPtrs{}
	}
	mmDeleteAndCreateChunks.defaultExpectation.paramPtrs.sourceTable = &sourceTable

	return mmDeleteAndCreateChunks
}

// ExpectSourceUIDParam3 sets up expected param sourceUID for RepositoryI.DeleteAndCreateChunks
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) ExpectSourceUIDParam3(sourceUID uuid.UUID) *mRepositoryIMockDeleteAndCreateChunks {
	if mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Set")
	}

	if mmDeleteAndCreateChunks.defaultExpectation == nil {
		mmDeleteAndCreateChunks.defaultExpectation = &RepositoryIMockDeleteAndCreateChunksExpectation{}
	}

	if mmDeleteAndCreateChunks.defaultExpectation.params != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Expect")
	}

	if mmDeleteAndCreateChunks.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateChunks.defaultExpectation.paramPtrs = &RepositoryIMockDeleteAndCreateChunksParamPtrs{}
	}
	mmDeleteAndCreateChunks.defaultExpectation.paramPtrs.sourceUID = &sourceUID

	return mmDeleteAndCreateChunks
}

// ExpectChunksParam4 sets up expected param chunks for RepositoryI.DeleteAndCreateChunks
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) ExpectChunksParam4(chunks []*mm_repository.TextChunk) *mRepositoryIMockDeleteAndCreateChunks {
	if mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Set")
	}

	if mmDeleteAndCreateChunks.defaultExpectation == nil {
		mmDeleteAndCreateChunks.defaultExpectation = &RepositoryIMockDeleteAndCreateChunksExpectation{}
	}

	if mmDeleteAndCreateChunks.defaultExpectation.params != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Expect")
	}

	if mmDeleteAndCreateChunks.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateChunks.defaultExpectation.paramPtrs = &RepositoryIMockDeleteAndCreateChunksParamPtrs{}
	}
	mmDeleteAndCreateChunks.defaultExpectation.paramPtrs.chunks = &chunks

	return mmDeleteAndCreateChunks
}

// ExpectExternalServiceCallParam5 sets up expected param externalServiceCall for RepositoryI.DeleteAndCreateChunks
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) ExpectExternalServiceCallParam5(externalServiceCall func(chunkUIDs []string) (map[string]any, error)) *mRepositoryIMockDeleteAndCreateChunks {
	if mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Set")
	}

	if mmDeleteAndCreateChunks.defaultExpectation == nil {
		mmDeleteAndCreateChunks.defaultExpectation = &RepositoryIMockDeleteAndCreateChunksExpectation{}
	}

	if mmDeleteAndCreateChunks.defaultExpectation.params != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Expect")
	}

	if mmDeleteAndCreateChunks.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateChunks.defaultExpectation.paramPtrs = &RepositoryIMockDeleteAndCreateChunksParamPtrs{}
	}
	mmDeleteAndCreateChunks.defaultExpectation.paramPtrs.externalServiceCall = &externalServiceCall

	return mmDeleteAndCreateChunks
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteAndCreateChunks
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) Inspect(f func(ctx context.Context, sourceTable string, sourceUID uuid.UUID, chunks []*mm_repository.TextChunk, externalServiceCall func(chunkUIDs []string) (map[string]any, error))) *mRepositoryIMockDeleteAndCreateChunks {
	if mmDeleteAndCreateChunks.mock.inspectFuncDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteAndCreateChunks")
	}

	mmDeleteAndCreateChunks.mock.inspectFuncDeleteAndCreateChunks = f

	return mmDeleteAndCreateChunks
}

// Return sets up results that will be returned by RepositoryI.DeleteAndCreateChunks
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) Return(tpa1 []*mm_repository.TextChunk, err error) *RepositoryIMock {
	if mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Set")
	}

	if mmDeleteAndCreateChunks.defaultExpectation == nil {
		mmDeleteAndCreateChunks.defaultExpectation = &RepositoryIMockDeleteAndCreateChunksExpectation{mock: mmDeleteAndCreateChunks.mock}
	}
	mmDeleteAndCreateChunks.defaultExpectation.results = &RepositoryIMockDeleteAndCreateChunksResults{tpa1, err}
	return mmDeleteAndCreateChunks.mock
}

// Set uses given function f to mock the RepositoryI.DeleteAndCreateChunks method
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) Set(f func(ctx context.Context, sourceTable string, sourceUID uuid.UUID, chunks []*mm_repository.TextChunk, externalServiceCall func(chunkUIDs []string) (map[string]any, error)) (tpa1 []*mm_repository.TextChunk, err error)) *RepositoryIMock {
	if mmDeleteAndCreateChunks.defaultExpectation != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteAndCreateChunks method")
	}

	if len(mmDeleteAndCreateChunks.expectations) > 0 {
		mmDeleteAndCreateChunks.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteAndCreateChunks method")
	}

	mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks = f
	return mmDeleteAndCreateChunks.mock
}

// When sets expectation for the RepositoryI.DeleteAndCreateChunks which will trigger the result defined by the following
// Then helper
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) When(ctx context.Context, sourceTable string, sourceUID uuid.UUID, chunks []*mm_repository.TextChunk, externalServiceCall func(chunkUIDs []string) (map[string]any, error)) *RepositoryIMockDeleteAndCreateChunksExpectation {
	if mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteAndCreateChunksExpectation{
		mock:   mmDeleteAndCreateChunks.mock,
		params: &RepositoryIMockDeleteAndCreateChunksParams{ctx, sourceTable, sourceUID, chunks, externalServiceCall},
	}
	mmDeleteAndCreateChunks.expectations = append(mmDeleteAndCreateChunks.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteAndCreateChunks return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteAndCreateChunksExpectation) Then(tpa1 []*mm_repository.TextChunk, err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteAndCreateChunksResults{tpa1, err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteAndCreateChunks should be invoked
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) Times(n uint64) *mRepositoryIMockDeleteAndCreateChunks {
	if n == 0 {
		mmDeleteAndCreateChunks.mock.t.Fatalf("Times of RepositoryIMock.DeleteAndCreateChunks mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteAndCreateChunks.expectedInvocations, n)
	return mmDeleteAndCreateChunks
}

func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) invocationsDone() bool {
	if len(mmDeleteAndCreateChunks.expectations) == 0 && mmDeleteAndCreateChunks.defaultExpectation == nil && mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteAndCreateChunks.mock.afterDeleteAndCreateChunksCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteAndCreateChunks.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteAndCreateChunks implements repository.RepositoryI
func (mmDeleteAndCreateChunks *RepositoryIMock) DeleteAndCreateChunks(ctx context.Context, sourceTable string, sourceUID uuid.UUID, chunks []*mm_repository.TextChunk, externalServiceCall func(chunkUIDs []string) (map[string]any, error)) (tpa1 []*mm_repository.TextChunk, err error) {
	mm_atomic.AddUint64(&mmDeleteAndCreateChunks.beforeDeleteAndCreateChunksCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteAndCreateChunks.afterDeleteAndCreateChunksCounter, 1)

	if mmDeleteAndCreateChunks.inspectFuncDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.inspectFuncDeleteAndCreateChunks(ctx, sourceTable, sourceUID, chunks, externalServiceCall)
	}

	mm_params := RepositoryIMockDeleteAndCreateChunksParams{ctx, sourceTable, sourceUID, chunks, externalServiceCall}

	// Record call args
	mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.mutex.Lock()
	mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.callArgs = append(mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.callArgs, &mm_params)
	mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.mutex.Unlock()

	for _, e := range mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tpa1, e.results.err
		}
	}

	if mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteAndCreateChunksParams{ctx, sourceTable, sourceUID, chunks, externalServiceCall}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteAndCreateChunks.t.Errorf("RepositoryIMock.DeleteAndCreateChunks got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sourceTable != nil && !minimock.Equal(*mm_want_ptrs.sourceTable, mm_got.sourceTable) {
				mmDeleteAndCreateChunks.t.Errorf("RepositoryIMock.DeleteAndCreateChunks got unexpected parameter sourceTable, want: %#v, got: %#v%s\n", *mm_want_ptrs.sourceTable, mm_got.sourceTable, minimock.Diff(*mm_want_ptrs.sourceTable, mm_got.sourceTable))
			}

			if mm_want_ptrs.sourceUID != nil && !minimock.Equal(*mm_want_ptrs.sourceUID, mm_got.sourceUID) {
				mmDeleteAndCreateChunks.t.Errorf("RepositoryIMock.DeleteAndCreateChunks got unexpected parameter sourceUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.sourceUID, mm_got.sourceUID, minimock.Diff(*mm_want_ptrs.sourceUID, mm_got.sourceUID))
			}

			if mm_want_ptrs.chunks != nil && !minimock.Equal(*mm_want_ptrs.chunks, mm_got.chunks) {
				mmDeleteAndCreateChunks.t.Errorf("RepositoryIMock.DeleteAndCreateChunks got unexpected parameter chunks, want: %#v, got: %#v%s\n", *mm_want_ptrs.chunks, mm_got.chunks, minimock.Diff(*mm_want_ptrs.chunks, mm_got.chunks))
			}

			if mm_want_ptrs.externalServiceCall != nil && !minimock.Equal(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall) {
				mmDeleteAndCreateChunks.t.Errorf("RepositoryIMock.DeleteAndCreateChunks got unexpected parameter externalServiceCall, want: %#v, got: %#v%s\n", *mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall, minimock.Diff(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteAndCreateChunks.t.Errorf("RepositoryIMock.DeleteAndCreateChunks got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteAndCreateChunks.t.Fatal("No results are set for the RepositoryIMock.DeleteAndCreateChunks")
		}
		return (*mm_results).tpa1, (*mm_results).err
	}
	if mmDeleteAndCreateChunks.funcDeleteAndCreateChunks != nil {
		return mmDeleteAndCreateChunks.funcDeleteAndCreateChunks(ctx, sourceTable, sourceUID, chunks, externalServiceCall)
	}
	mmDeleteAndCreateChunks.t.Fatalf("Unexpected call to RepositoryIMock.DeleteAndCreateChunks. %v %v %v %v %v", ctx, sourceTable, sourceUID, chunks, externalServiceCall)
	return
}

// DeleteAndCreateChunksAfterCounter returns a count of finished RepositoryIMock.DeleteAndCreateChunks invocations
func (mmDeleteAndCreateChunks *RepositoryIMock) DeleteAndCreateChunksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAndCreateChunks.afterDeleteAndCreateChunksCounter)
}

// DeleteAndCreateChunksBeforeCounter returns a count of RepositoryIMock.DeleteAndCreateChunks invocations
func (mmDeleteAndCreateChunks *RepositoryIMock) DeleteAndCreateChunksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAndCreateChunks.beforeDeleteAndCreateChunksCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteAndCreateChunks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) Calls() []*RepositoryIMockDeleteAndCreateChunksParams {
	mmDeleteAndCreateChunks.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteAndCreateChunksParams, len(mmDeleteAndCreateChunks.callArgs))
	copy(argCopy, mmDeleteAndCreateChunks.callArgs)

	mmDeleteAndCreateChunks.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteAndCreateChunksDone returns true if the count of the DeleteAndCreateChunks invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteAndCreateChunksDone() bool {
	for _, e := range m.DeleteAndCreateChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteAndCreateChunksMock.invocationsDone()
}

// MinimockDeleteAndCreateChunksInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteAndCreateChunksInspect() {
	for _, e := range m.DeleteAndCreateChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteAndCreateChunks with params: %#v", *e.params)
		}
	}

	afterDeleteAndCreateChunksCounter := mm_atomic.LoadUint64(&m.afterDeleteAndCreateChunksCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteAndCreateChunksMock.defaultExpectation != nil && afterDeleteAndCreateChunksCounter < 1 {
		if m.DeleteAndCreateChunksMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteAndCreateChunks")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteAndCreateChunks with params: %#v", *m.DeleteAndCreateChunksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteAndCreateChunks != nil && afterDeleteAndCreateChunksCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteAndCreateChunks")
	}

	if !m.DeleteAndCreateChunksMock.invocationsDone() && afterDeleteAndCreateChunksCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteAndCreateChunks but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteAndCreateChunksMock.expectedInvocations), afterDeleteAndCreateChunksCounter)
	}
}

type mRepositoryIMockDeleteChunksBySource struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteChunksBySourceExpectation
	expectations       []*RepositoryIMockDeleteChunksBySourceExpectation

	callArgs []*RepositoryIMockDeleteChunksBySourceParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteChunksBySourceExpectation specifies expectation struct of the RepositoryI.DeleteChunksBySource
type RepositoryIMockDeleteChunksBySourceExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteChunksBySourceParams
	paramPtrs *RepositoryIMockDeleteChunksBySourceParamPtrs
	results   *RepositoryIMockDeleteChunksBySourceResults
	Counter   uint64
}

// RepositoryIMockDeleteChunksBySourceParams contains parameters of the RepositoryI.DeleteChunksBySource
type RepositoryIMockDeleteChunksBySourceParams struct {
	ctx         context.Context
	sourceTable string
	sourceUID   uuid.UUID
}

// RepositoryIMockDeleteChunksBySourceParamPtrs contains pointers to parameters of the RepositoryI.DeleteChunksBySource
type RepositoryIMockDeleteChunksBySourceParamPtrs struct {
	ctx         *context.Context
	sourceTable *string
	sourceUID   *uuid.UUID
}

// RepositoryIMockDeleteChunksBySourceResults contains results of the RepositoryI.DeleteChunksBySource
type RepositoryIMockDeleteChunksBySourceResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteChunksBySource
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) Expect(ctx context.Context, sourceTable string, sourceUID uuid.UUID) *mRepositoryIMockDeleteChunksBySource {
	if mmDeleteChunksBySource.mock.funcDeleteChunksBySource != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by Set")
	}

	if mmDeleteChunksBySource.defaultExpectation == nil {
		mmDeleteChunksBySource.defaultExpectation = &RepositoryIMockDeleteChunksBySourceExpectation{}
	}

	if mmDeleteChunksBySource.defaultExpectation.paramPtrs != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by ExpectParams functions")
	}

	mmDeleteChunksBySource.defaultExpectation.params = &RepositoryIMockDeleteChunksBySourceParams{ctx, sourceTable, sourceUID}
	for _, e := range mmDeleteChunksBySource.expectations {
		if minimock.Equal(e.params, mmDeleteChunksBySource.defaultExpectation.params) {
			mmDeleteChunksBySource.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChunksBySource.defaultExpectation.params)
		}
	}

	return mmDeleteChunksBySource
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteChunksBySource
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteChunksBySource {
	if mmDeleteChunksBySource.mock.funcDeleteChunksBySource != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by Set")
	}

	if mmDeleteChunksBySource.defaultExpectation == nil {
		mmDeleteChunksBySource.defaultExpectation = &RepositoryIMockDeleteChunksBySourceExpectation{}
	}

	if mmDeleteChunksBySource.defaultExpectation.params != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by Expect")
	}

	if mmDeleteChunksBySource.defaultExpectation.paramPtrs == nil {
		mmDeleteChunksBySource.defaultExpectation.paramPtrs = &RepositoryIMockDeleteChunksBySourceParamPtrs{}
	}
	mmDeleteChunksBySource.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteChunksBySource
}

// ExpectSourceTableParam2 sets up expected param sourceTable for RepositoryI.DeleteChunksBySource
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) ExpectSourceTableParam2(sourceTable string) *mRepositoryIMockDeleteChunksBySource {
	if mmDeleteChunksBySource.mock.funcDeleteChunksBySource != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by Set")
	}

	if mmDeleteChunksBySource.defaultExpectation == nil {
		mmDeleteChunksBySource.defaultExpectation = &RepositoryIMockDeleteChunksBySourceExpectation{}
	}

	if mmDeleteChunksBySource.defaultExpectation.params != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by Expect")
	}

	if mmDeleteChunksBySource.defaultExpectation.paramPtrs == nil {
		mmDeleteChunksBySource.defaultExpectation.paramPtrs = &RepositoryIMockDeleteChunksBySourceParamPtrs{}
	}
	mmDeleteChunksBySource.defaultExpectation.paramPtrs.sourceTable = &sourceTable

	return mmDeleteChunksBySource
}

// ExpectSourceUIDParam3 sets up expected param sourceUID for RepositoryI.DeleteChunksBySource
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) ExpectSourceUIDParam3(sourceUID uuid.UUID) *mRepositoryIMockDeleteChunksBySource {
	if mmDeleteChunksBySource.mock.funcDeleteChunksBySource != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by Set")
	}

	if mmDeleteChunksBySource.defaultExpectation == nil {
		mmDeleteChunksBySource.defaultExpectation = &RepositoryIMockDeleteChunksBySourceExpectation{}
	}

	if mmDeleteChunksBySource.defaultExpectation.params != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by Expect")
	}

	if mmDeleteChunksBySource.defaultExpectation.paramPtrs == nil {
		mmDeleteChunksBySource.defaultExpectation.paramPtrs = &RepositoryIMockDeleteChunksBySourceParamPtrs{}
	}
	mmDeleteChunksBySource.defaultExpectation.paramPtrs.sourceUID = &sourceUID

	return mmDeleteChunksBySource
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteChunksBySource
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) Inspect(f func(ctx context.Context, sourceTable string, sourceUID uuid.UUID)) *mRepositoryIMockDeleteChunksBySource {
	if mmDeleteChunksBySource.mock.inspectFuncDeleteChunksBySource != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteChunksBySource")
	}

	mmDeleteChunksBySource.mock.inspectFuncDeleteChunksBySource = f

	return mmDeleteChunksBySource
}

// Return sets up results that will be returned by RepositoryI.DeleteChunksBySource
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) Return(err error) *RepositoryIMock {
	if mmDeleteChunksBySource.mock.funcDeleteChunksBySource != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by Set")
	}

	if mmDeleteChunksBySource.defaultExpectation == nil {
		mmDeleteChunksBySource.defaultExpectation = &RepositoryIMockDeleteChunksBySourceExpectation{mock: mmDeleteChunksBySource.mock}
	}
	mmDeleteChunksBySource.defaultExpectation.results = &RepositoryIMockDeleteChunksBySourceResults{err}
	return mmDeleteChunksBySource.mock
}

// Set uses given function f to mock the RepositoryI.DeleteChunksBySource method
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) Set(f func(ctx context.Context, sourceTable string, sourceUID uuid.UUID) (err error)) *RepositoryIMock {
	if mmDeleteChunksBySource.defaultExpectation != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteChunksBySource method")
	}

	if len(mmDeleteChunksBySource.expectations) > 0 {
		mmDeleteChunksBySource.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteChunksBySource method")
	}

	mmDeleteChunksBySource.mock.funcDeleteChunksBySource = f
	return mmDeleteChunksBySource.mock
}

// When sets expectation for the RepositoryI.DeleteChunksBySource which will trigger the result defined by the following
// Then helper
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) When(ctx context.Context, sourceTable string, sourceUID uuid.UUID) *RepositoryIMockDeleteChunksBySourceExpectation {
	if mmDeleteChunksBySource.mock.funcDeleteChunksBySource != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteChunksBySourceExpectation{
		mock:   mmDeleteChunksBySource.mock,
		params: &RepositoryIMockDeleteChunksBySourceParams{ctx, sourceTable, sourceUID},
	}
	mmDeleteChunksBySource.expectations = append(mmDeleteChunksBySource.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteChunksBySource return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteChunksBySourceExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteChunksBySourceResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteChunksBySource should be invoked
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) Times(n uint64) *mRepositoryIMockDeleteChunksBySource {
	if n == 0 {
		mmDeleteChunksBySource.mock.t.Fatalf("Times of RepositoryIMock.DeleteChunksBySource mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteChunksBySource.expectedInvocations, n)
	return mmDeleteChunksBySource
}

func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) invocationsDone() bool {
	if len(mmDeleteChunksBySource.expectations) == 0 && mmDeleteChunksBySource.defaultExpectation == nil && mmDeleteChunksBySource.mock.funcDeleteChunksBySource == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteChunksBySource.mock.afterDeleteChunksBySourceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteChunksBySource.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteChunksBySource implements repository.RepositoryI
func (mmDeleteChunksBySource *RepositoryIMock) DeleteChunksBySource(ctx context.Context, sourceTable string, sourceUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteChunksBySource.beforeDeleteChunksBySourceCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChunksBySource.afterDeleteChunksBySourceCounter, 1)

	if mmDeleteChunksBySource.inspectFuncDeleteChunksBySource != nil {
		mmDeleteChunksBySource.inspectFuncDeleteChunksBySource(ctx, sourceTable, sourceUID)
	}

	mm_params := RepositoryIMockDeleteChunksBySourceParams{ctx, sourceTable, sourceUID}

	// Record call args
	mmDeleteChunksBySource.DeleteChunksBySourceMock.mutex.Lock()
	mmDeleteChunksBySource.DeleteChunksBySourceMock.callArgs = append(mmDeleteChunksBySource.DeleteChunksBySourceMock.callArgs, &mm_params)
	mmDeleteChunksBySource.DeleteChunksBySourceMock.mutex.Unlock()

	for _, e := range mmDeleteChunksBySource.DeleteChunksBySourceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChunksBySource.DeleteChunksBySourceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChunksBySource.DeleteChunksBySourceMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChunksBySource.DeleteChunksBySourceMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteChunksBySource.DeleteChunksBySourceMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteChunksBySourceParams{ctx, sourceTable, sourceUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteChunksBySource.t.Errorf("RepositoryIMock.DeleteChunksBySource got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sourceTable != nil && !minimock.Equal(*mm_want_ptrs.sourceTable, mm_got.sourceTable) {
				mmDeleteChunksBySource.t.Errorf("RepositoryIMock.DeleteChunksBySource got unexpected parameter sourceTable, want: %#v, got: %#v%s\n", *mm_want_ptrs.sourceTable, mm_got.sourceTable, minimock.Diff(*mm_want_ptrs.sourceTable, mm_got.sourceTable))
			}

			if mm_want_ptrs.sourceUID != nil && !minimock.Equal(*mm_want_ptrs.sourceUID, mm_got.sourceUID) {
				mmDeleteChunksBySource.t.Errorf("RepositoryIMock.DeleteChunksBySource got unexpected parameter sourceUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.sourceUID, mm_got.sourceUID, minimock.Diff(*mm_want_ptrs.sourceUID, mm_got.sourceUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChunksBySource.t.Errorf("RepositoryIMock.DeleteChunksBySource got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChunksBySource.DeleteChunksBySourceMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChunksBySource.t.Fatal("No results are set for the RepositoryIMock.DeleteChunksBySource")
		}
		return (*mm_results).err
	}
	if mmDeleteChunksBySource.funcDeleteChunksBySource != nil {
		return mmDeleteChunksBySource.funcDeleteChunksBySource(ctx, sourceTable, sourceUID)
	}
	mmDeleteChunksBySource.t.Fatalf("Unexpected call to RepositoryIMock.DeleteChunksBySource. %v %v %v", ctx, sourceTable, sourceUID)
	return
}

// DeleteChunksBySourceAfterCounter returns a count of finished RepositoryIMock.DeleteChunksBySource invocations
func (mmDeleteChunksBySource *RepositoryIMock) DeleteChunksBySourceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChunksBySource.afterDeleteChunksBySourceCounter)
}

// DeleteChunksBySourceBeforeCounter returns a count of RepositoryIMock.DeleteChunksBySource invocations
func (mmDeleteChunksBySource *RepositoryIMock) DeleteChunksBySourceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChunksBySource.beforeDeleteChunksBySourceCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteChunksBySource.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) Calls() []*RepositoryIMockDeleteChunksBySourceParams {
	mmDeleteChunksBySource.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteChunksBySourceParams, len(mmDeleteChunksBySource.callArgs))
	copy(argCopy, mmDeleteChunksBySource.callArgs)

	mmDeleteChunksBySource.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChunksBySourceDone returns true if the count of the DeleteChunksBySource invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteChunksBySourceDone() bool {
	for _, e := range m.DeleteChunksBySourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteChunksBySourceMock.invocationsDone()
}

// MinimockDeleteChunksBySourceInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteChunksBySourceInspect() {
	for _, e := range m.DeleteChunksBySourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteChunksBySource with params: %#v", *e.params)
		}
	}

	afterDeleteChunksBySourceCounter := mm_atomic.LoadUint64(&m.afterDeleteChunksBySourceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChunksBySourceMock.defaultExpectation != nil && afterDeleteChunksBySourceCounter < 1 {
		if m.DeleteChunksBySourceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteChunksBySource")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteChunksBySource with params: %#v", *m.DeleteChunksBySourceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChunksBySource != nil && afterDeleteChunksBySourceCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteChunksBySource")
	}

	if !m.DeleteChunksBySourceMock.invocationsDone() && afterDeleteChunksBySourceCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteChunksBySource but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteChunksBySourceMock.expectedInvocations), afterDeleteChunksBySourceCounter)
	}
}

type mRepositoryIMockDeleteChunksByUIDs struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteChunksByUIDsExpectation
	expectations       []*RepositoryIMockDeleteChunksByUIDsExpectation

	callArgs []*RepositoryIMockDeleteChunksByUIDsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteChunksByUIDsExpectation specifies expectation struct of the RepositoryI.DeleteChunksByUIDs
type RepositoryIMockDeleteChunksByUIDsExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteChunksByUIDsParams
	paramPtrs *RepositoryIMockDeleteChunksByUIDsParamPtrs
	results   *RepositoryIMockDeleteChunksByUIDsResults
	Counter   uint64
}

// RepositoryIMockDeleteChunksByUIDsParams contains parameters of the RepositoryI.DeleteChunksByUIDs
type RepositoryIMockDeleteChunksByUIDsParams struct {
	ctx       context.Context
	chunkUIDs []uuid.UUID
}

// RepositoryIMockDeleteChunksByUIDsParamPtrs contains pointers to parameters of the RepositoryI.DeleteChunksByUIDs
type RepositoryIMockDeleteChunksByUIDsParamPtrs struct {
	ctx       *context.Context
	chunkUIDs *[]uuid.UUID
}

// RepositoryIMockDeleteChunksByUIDsResults contains results of the RepositoryI.DeleteChunksByUIDs
type RepositoryIMockDeleteChunksByUIDsResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteChunksByUIDs
func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) Expect(ctx context.Context, chunkUIDs []uuid.UUID) *mRepositoryIMockDeleteChunksByUIDs {
	if mmDeleteChunksByUIDs.mock.funcDeleteChunksByUIDs != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteChunksByUIDs mock is already set by Set")
	}

	if mmDeleteChunksByUIDs.defaultExpectation == nil {
		mmDeleteChunksByUIDs.defaultExpectation = &RepositoryIMockDeleteChunksByUIDsExpectation{}
	}

	if mmDeleteChunksByUIDs.defaultExpectation.paramPtrs != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteChunksByUIDs mock is already set by ExpectParams functions")
	}

	mmDeleteChunksByUIDs.defaultExpectation.params = &RepositoryIMockDeleteChunksByUIDsParams{ctx, chunkUIDs}
	for _, e := range mmDeleteChunksByUIDs.expectations {
		if minimock.Equal(e.params, mmDeleteChunksByUIDs.defaultExpectation.params) {
			mmDeleteChunksByUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChunksByUIDs.defaultExpectation.params)
		}
	}

	return mmDeleteChunksByUIDs
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteChunksByUIDs
func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteChunksByUIDs {
	if mmDeleteChunksByUIDs.mock.funcDeleteChunksByUIDs != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteChunksByUIDs mock is already set by Set")
	}

	if mmDeleteChunksByUIDs.defaultExpectation == nil {
		mmDeleteChunksByUIDs.defaultExpectation = &RepositoryIMockDeleteChunksByUIDsExpectation{}
	}

	if mmDeleteChunksByUIDs.defaultExpectation.params != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteChunksByUIDs mock is already set by Expect")
	}

	if mmDeleteChunksByUIDs.defaultExpectation.paramPtrs == nil {
		mmDeleteChunksByUIDs.defaultExpectation.paramPtrs = &RepositoryIMockDeleteChunksByUIDsParamPtrs{}
	}
	mmDeleteChunksByUIDs.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteChunksByUIDs
}

// ExpectChunkUIDsParam2 sets up expected param chunkUIDs for RepositoryI.DeleteChunksByUIDs
func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) ExpectChunkUIDsParam2(chunkUIDs []uuid.UUID) *mRepositoryIMockDeleteChunksByUIDs {
	if mmDeleteChunksByUIDs.mock.funcDeleteChunksByUIDs != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteChunksByUIDs mock is already set by Set")
	}

	if mmDeleteChunksByUIDs.defaultExpectation == nil {
		mmDeleteChunksByUIDs.defaultExpectation = &RepositoryIMockDeleteChunksByUIDsExpectation{}
	}

	if mmDeleteChunksByUIDs.defaultExpectation.params != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteChunksByUIDs mock is already set by Expect")
	}

	if mmDeleteChunksByUIDs.defaultExpectation.paramPtrs == nil {
		mmDeleteChunksByUIDs.defaultExpectation.paramPtrs = &RepositoryIMockDeleteChunksByUIDsParamPtrs{}
	}
	mmDeleteChunksByUIDs.defaultExpectation.paramPtrs.chunkUIDs = &chunkUIDs

	return mmDeleteChunksByUIDs
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteChunksByUIDs
func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) Inspect(f func(ctx context.Context, chunkUIDs []uuid.UUID)) *mRepositoryIMockDeleteChunksByUIDs {
	if mmDeleteChunksByUIDs.mock.inspectFuncDeleteChunksByUIDs != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteChunksByUIDs")
	}

	mmDeleteChunksByUIDs.mock.inspectFuncDeleteChunksByUIDs = f

	return mmDeleteChunksByUIDs
}

// Return sets up results that will be returned by RepositoryI.DeleteChunksByUIDs
func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) Return(err error) *RepositoryIMock {
	if mmDeleteChunksByUIDs.mock.funcDeleteChunksByUIDs != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteChunksByUIDs mock is already set by Set")
	}

	if mmDeleteChunksByUIDs.defaultExpectation == nil {
		mmDeleteChunksByUIDs.defaultExpectation = &RepositoryIMockDeleteChunksByUIDsExpectation{mock: mmDeleteChunksByUIDs.mock}
	}
	mmDeleteChunksByUIDs.defaultExpectation.results = &RepositoryIMockDeleteChunksByUIDsResults{err}
	return mmDeleteChunksByUIDs.mock
}

// Set uses given function f to mock the RepositoryI.DeleteChunksByUIDs method
func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) Set(f func(ctx context.Context, chunkUIDs []uuid.UUID) (err error)) *RepositoryIMock {
	if mmDeleteChunksByUIDs.defaultExpectation != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteChunksByUIDs method")
	}

	if len(mmDeleteChunksByUIDs.expectations) > 0 {
		mmDeleteChunksByUIDs.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteChunksByUIDs method")
	}

	mmDeleteChunksByUIDs.mock.funcDeleteChunksByUIDs = f
	return mmDeleteChunksByUIDs.mock
}

// When sets expectation for the RepositoryI.DeleteChunksByUIDs which will trigger the result defined by the following
// Then helper
func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) When(ctx context.Context, chunkUIDs []uuid.UUID) *RepositoryIMockDeleteChunksByUIDsExpectation {
	if mmDeleteChunksByUIDs.mock.funcDeleteChunksByUIDs != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteChunksByUIDs mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteChunksByUIDsExpectation{
		mock:   mmDeleteChunksByUIDs.mock,
		params: &RepositoryIMockDeleteChunksByUIDsParams{ctx, chunkUIDs},
	}
	mmDeleteChunksByUIDs.expectations = append(mmDeleteChunksByUIDs.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteChunksByUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteChunksByUIDsExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteChunksByUIDsResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteChunksByUIDs should be invoked
func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) Times(n uint64) *mRepositoryIMockDeleteChunksByUIDs {
	if n == 0 {
		mmDeleteChunksByUIDs.mock.t.Fatalf("Times of RepositoryIMock.DeleteChunksByUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteChunksByUIDs.expectedInvocations, n)
	return mmDeleteChunksByUIDs
}

func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) invocationsDone() bool {
	if len(mmDeleteChunksByUIDs.expectations) == 0 && mmDeleteChunksByUIDs.defaultExpectation == nil && mmDeleteChunksByUIDs.mock.funcDeleteChunksByUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteChunksByUIDs.mock.afterDeleteChunksByUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteChunksByUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteChunksByUIDs implements repository.RepositoryI
func (mmDeleteChunksByUIDs *RepositoryIMock) DeleteChunksByUIDs(ctx context.Context, chunkUIDs []uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteChunksByUIDs.beforeDeleteChunksByUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChunksByUIDs.afterDeleteChunksByUIDsCounter, 1)

	if mmDeleteChunksByUIDs.inspectFuncDeleteChunksByUIDs != nil {
		mmDeleteChunksByUIDs.inspectFuncDeleteChunksByUIDs(ctx, chunkUIDs)
	}

	mm_params := RepositoryIMockDeleteChunksByUIDsParams{ctx, chunkUIDs}

	// Record call args
	mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.mutex.Lock()
	mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.callArgs = append(mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.callArgs, &mm_params)
	mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.mutex.Unlock()

	for _, e := range mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteChunksByUIDsParams{ctx, chunkUIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteChunksByUIDs.t.Errorf("RepositoryIMock.DeleteChunksByUIDs got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chunkUIDs != nil && !minimock.Equal(*mm_want_ptrs.chunkUIDs, mm_got.chunkUIDs) {
				mmDeleteChunksByUIDs.t.Errorf("RepositoryIMock.DeleteChunksByUIDs got unexpected parameter chunkUIDs, want: %#v, got: %#v%s\n", *mm_want_ptrs.chunkUIDs, mm_got.chunkUIDs, minimock.Diff(*mm_want_ptrs.chunkUIDs, mm_got.chunkUIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChunksByUIDs.t.Errorf("RepositoryIMock.DeleteChunksByUIDs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChunksByUIDs.t.Fatal("No results are set for the RepositoryIMock.DeleteChunksByUIDs")
		}
		return (*mm_results).err
	}
	if mmDeleteChunksByUIDs.funcDeleteChunksByUIDs != nil {
		return mmDeleteChunksByUIDs.funcDeleteChunksByUIDs(ctx, chunkUIDs)
	}
	mmDeleteChunksByUIDs.t.Fatalf("Unexpected call to RepositoryIMock.DeleteChunksByUIDs. %v %v", ctx, chunkUIDs)
	return
}

// DeleteChunksByUIDsAfterCounter returns a count of finished RepositoryIMock.DeleteChunksByUIDs invocations
func (mmDeleteChunksByUIDs *RepositoryIMock) DeleteChunksByUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChunksByUIDs.afterDeleteChunksByUIDsCounter)
}

// DeleteChunksByUIDsBeforeCounter returns a count of RepositoryIMock.DeleteChunksByUIDs invocations
func (mmDeleteChunksByUIDs *RepositoryIMock) DeleteChunksByUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChunksByUIDs.beforeDeleteChunksByUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteChunksByUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) Calls() []*RepositoryIMockDeleteChunksByUIDsParams {
	mmDeleteChunksByUIDs.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteChunksByUIDsParams, len(mmDeleteChunksByUIDs.callArgs))
	copy(argCopy, mmDeleteChunksByUIDs.callArgs)

	mmDeleteChunksByUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChunksByUIDsDone returns true if the count of the DeleteChunksByUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteChunksByUIDsDone() bool {
	for _, e := range m.DeleteChunksByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteChunksByUIDsMock.invocationsDone()
}

// MinimockDeleteChunksByUIDsInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteChunksByUIDsInspect() {
	for _, e := range m.DeleteChunksByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteChunksByUIDs with params: %#v", *e.params)
		}
	}

	afterDeleteChunksByUIDsCounter := mm_atomic.LoadUint64(&m.afterDeleteChunksByUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChunksByUIDsMock.defaultExpectation != nil && afterDeleteChunksByUIDsCounter < 1 {
		if m.DeleteChunksByUIDsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteChunksByUIDs")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteChunksByUIDs with params: %#v", *m.DeleteChunksByUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChunksByUIDs != nil && afterDeleteChunksByUIDsCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteChunksByUIDs")
	}

	if !m.DeleteChunksByUIDsMock.invocationsDone() && afterDeleteChunksByUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteChunksByUIDs but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteChunksByUIDsMock.expectedInvocations), afterDeleteChunksByUIDsCounter)
	}
}

type mRepositoryIMockDeleteConvertedFile struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteConvertedFileExpectation
	expectations       []*RepositoryIMockDeleteConvertedFileExpectation

	callArgs []*RepositoryIMockDeleteConvertedFileParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteConvertedFileExpectation specifies expectation struct of the RepositoryI.DeleteConvertedFile
type RepositoryIMockDeleteConvertedFileExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteConvertedFileParams
	paramPtrs *RepositoryIMockDeleteConvertedFileParamPtrs
	results   *RepositoryIMockDeleteConvertedFileResults
	Counter   uint64
}

// RepositoryIMockDeleteConvertedFileParams contains parameters of the RepositoryI.DeleteConvertedFile
type RepositoryIMockDeleteConvertedFileParams struct {
	ctx context.Context
	uid uuid.UUID
}

// RepositoryIMockDeleteConvertedFileParamPtrs contains pointers to parameters of the RepositoryI.DeleteConvertedFile
type RepositoryIMockDeleteConvertedFileParamPtrs struct {
	ctx *context.Context
	uid *uuid.UUID
}

// RepositoryIMockDeleteConvertedFileResults contains results of the RepositoryI.DeleteConvertedFile
type RepositoryIMockDeleteConvertedFileResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteConvertedFile
func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) Expect(ctx context.Context, uid uuid.UUID) *mRepositoryIMockDeleteConvertedFile {
	if mmDeleteConvertedFile.mock.funcDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryIMock.DeleteConvertedFile mock is already set by Set")
	}

	if mmDeleteConvertedFile.defaultExpectation == nil {
		mmDeleteConvertedFile.defaultExpectation = &RepositoryIMockDeleteConvertedFileExpectation{}
	}

	if mmDeleteConvertedFile.defaultExpectation.paramPtrs != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryIMock.DeleteConvertedFile mock is already set by ExpectParams functions")
	}

	mmDeleteConvertedFile.defaultExpectation.params = &RepositoryIMockDeleteConvertedFileParams{ctx, uid}
	for _, e := range mmDeleteConvertedFile.expectations {
		if minimock.Equal(e.params, mmDeleteConvertedFile.defaultExpectation.params) {
			mmDeleteConvertedFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteConvertedFile.defaultExpectation.params)
		}
	}

	return mmDeleteConvertedFile
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteConvertedFile
func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteConvertedFile {
	if mmDeleteConvertedFile.mock.funcDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryIMock.DeleteConvertedFile mock is already set by Set")
	}

	if mmDeleteConvertedFile.defaultExpectation == nil {
		mmDeleteConvertedFile.defaultExpectation = &RepositoryIMockDeleteConvertedFileExpectation{}
	}

	if mmDeleteConvertedFile.defaultExpectation.params != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryIMock.DeleteConvertedFile mock is already set by Expect")
	}

	if mmDeleteConvertedFile.defaultExpectation.paramPtrs == nil {
		mmDeleteConvertedFile.defaultExpectation.paramPtrs = &RepositoryIMockDeleteConvertedFileParamPtrs{}
	}
	mmDeleteConvertedFile.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteConvertedFile
}

// ExpectUidParam2 sets up expected param uid for RepositoryI.DeleteConvertedFile
func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) ExpectUidParam2(uid uuid.UUID) *mRepositoryIMockDeleteConvertedFile {
	if mmDeleteConvertedFile.mock.funcDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryIMock.DeleteConvertedFile mock is already set by Set")
	}

	if mmDeleteConvertedFile.defaultExpectation == nil {
		mmDeleteConvertedFile.defaultExpectation = &RepositoryIMockDeleteConvertedFileExpectation{}
	}

	if mmDeleteConvertedFile.defaultExpectation.params != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryIMock.DeleteConvertedFile mock is already set by Expect")
	}

	if mmDeleteConvertedFile.defaultExpectation.paramPtrs == nil {
		mmDeleteConvertedFile.defaultExpectation.paramPtrs = &RepositoryIMockDeleteConvertedFileParamPtrs{}
	}
	mmDeleteConvertedFile.defaultExpectation.paramPtrs.uid = &uid

	return mmDeleteConvertedFile
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteConvertedFile
func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) Inspect(f func(ctx context.Context, uid uuid.UUID)) *mRepositoryIMockDeleteConvertedFile {
	if mmDeleteConvertedFile.mock.inspectFuncDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteConvertedFile")
	}

	mmDeleteConvertedFile.mock.inspectFuncDeleteConvertedFile = f

	return mmDeleteConvertedFile
}

// Return sets up results that will be returned by RepositoryI.DeleteConvertedFile
func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) Return(err error) *RepositoryIMock {
	if mmDeleteConvertedFile.mock.funcDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryIMock.DeleteConvertedFile mock is already set by Set")
	}

	if mmDeleteConvertedFile.defaultExpectation == nil {
		mmDeleteConvertedFile.defaultExpectation = &RepositoryIMockDeleteConvertedFileExpectation{mock: mmDeleteConvertedFile.mock}
	}
	mmDeleteConvertedFile.defaultExpectation.results = &RepositoryIMockDeleteConvertedFileResults{err}
	return mmDeleteConvertedFile.mock
}

// Set uses given function f to mock the RepositoryI.DeleteConvertedFile method
func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) Set(f func(ctx context.Context, uid uuid.UUID) (err error)) *RepositoryIMock {
	if mmDeleteConvertedFile.defaultExpectation != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteConvertedFile method")
	}

	if len(mmDeleteConvertedFile.expectations) > 0 {
		mmDeleteConvertedFile.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteConvertedFile method")
	}

	mmDeleteConvertedFile.mock.funcDeleteConvertedFile = f
	return mmDeleteConvertedFile.mock
}

// When sets expectation for the RepositoryI.DeleteConvertedFile which will trigger the result defined by the following
// Then helper
func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) When(ctx context.Context, uid uuid.UUID) *RepositoryIMockDeleteConvertedFileExpectation {
	if mmDeleteConvertedFile.mock.funcDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryIMock.DeleteConvertedFile mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteConvertedFileExpectation{
		mock:   mmDeleteConvertedFile.mock,
		params: &RepositoryIMockDeleteConvertedFileParams{ctx, uid},
	}
	mmDeleteConvertedFile.expectations = append(mmDeleteConvertedFile.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteConvertedFile return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteConvertedFileExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteConvertedFileResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteConvertedFile should be invoked
func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) Times(n uint64) *mRepositoryIMockDeleteConvertedFile {
	if n == 0 {
		mmDeleteConvertedFile.mock.t.Fatalf("Times of RepositoryIMock.DeleteConvertedFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteConvertedFile.expectedInvocations, n)
	return mmDeleteConvertedFile
}

func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) invocationsDone() bool {
	if len(mmDeleteConvertedFile.expectations) == 0 && mmDeleteConvertedFile.defaultExpectation == nil && mmDeleteConvertedFile.mock.funcDeleteConvertedFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteConvertedFile.mock.afterDeleteConvertedFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteConvertedFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteConvertedFile implements repository.RepositoryI
func (mmDeleteConvertedFile *RepositoryIMock) DeleteConvertedFile(ctx context.Context, uid uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteConvertedFile.beforeDeleteConvertedFileCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteConvertedFile.afterDeleteConvertedFileCounter, 1)

	if mmDeleteConvertedFile.inspectFuncDeleteConvertedFile != nil {
		mmDeleteConvertedFile.inspectFuncDeleteConvertedFile(ctx, uid)
	}

	mm_params := RepositoryIMockDeleteConvertedFileParams{ctx, uid}

	// Record call args
	mmDeleteConvertedFile.DeleteConvertedFileMock.mutex.Lock()
	mmDeleteConvertedFile.DeleteConvertedFileMock.callArgs = append(mmDeleteConvertedFile.DeleteConvertedFileMock.callArgs, &mm_params)
	mmDeleteConvertedFile.DeleteConvertedFileMock.mutex.Unlock()

	for _, e := range mmDeleteConvertedFile.DeleteConvertedFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteConvertedFileParams{ctx, uid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteConvertedFile.t.Errorf("RepositoryIMock.DeleteConvertedFile got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmDeleteConvertedFile.t.Errorf("RepositoryIMock.DeleteConvertedFile got unexpected parameter uid, want: %#v, got: %#v%s\n", *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteConvertedFile.t.Errorf("RepositoryIMock.DeleteConvertedFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteConvertedFile.t.Fatal("No results are set for the RepositoryIMock.DeleteConvertedFile")
		}
		return (*mm_results).err
	}
	if mmDeleteConvertedFile.funcDeleteConvertedFile != nil {
		return mmDeleteConvertedFile.funcDeleteConvertedFile(ctx, uid)
	}
	mmDeleteConvertedFile.t.Fatalf("Unexpected call to RepositoryIMock.DeleteConvertedFile. %v %v", ctx, uid)
	return
}

// DeleteConvertedFileAfterCounter returns a count of finished RepositoryIMock.DeleteConvertedFile invocations
func (mmDeleteConvertedFile *RepositoryIMock) DeleteConvertedFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteConvertedFile.afterDeleteConvertedFileCounter)
}

// DeleteConvertedFileBeforeCounter returns a count of RepositoryIMock.DeleteConvertedFile invocations
func (mmDeleteConvertedFile *RepositoryIMock) DeleteConvertedFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteConvertedFile.beforeDeleteConvertedFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteConvertedFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) Calls() []*RepositoryIMockDeleteConvertedFileParams {
	mmDeleteConvertedFile.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteConvertedFileParams, len(mmDeleteConvertedFile.callArgs))
	copy(argCopy, mmDeleteConvertedFile.callArgs)

	mmDeleteConvertedFile.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteConvertedFileDone returns true if the count of the DeleteConvertedFile invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteConvertedFileDone() bool {
	for _, e := range m.DeleteConvertedFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteConvertedFileMock.invocationsDone()
}

// MinimockDeleteConvertedFileInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteConvertedFileInspect() {
	for _, e := range m.DeleteConvertedFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteConvertedFile with params: %#v", *e.params)
		}
	}

	afterDeleteConvertedFileCounter := mm_atomic.LoadUint64(&m.afterDeleteConvertedFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteConvertedFileMock.defaultExpectation != nil && afterDeleteConvertedFileCounter < 1 {
		if m.DeleteConvertedFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteConvertedFile")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteConvertedFile with params: %#v", *m.DeleteConvertedFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteConvertedFile != nil && afterDeleteConvertedFileCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteConvertedFile")
	}

	if !m.DeleteConvertedFileMock.invocationsDone() && afterDeleteConvertedFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteConvertedFile but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteConvertedFileMock.expectedInvocations), afterDeleteConvertedFileCounter)
	}
}

type mRepositoryIMockDeleteEmbeddingsBySource struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteEmbeddingsBySourceExpectation
	expectations       []*RepositoryIMockDeleteEmbeddingsBySourceExpectation

	callArgs []*RepositoryIMockDeleteEmbeddingsBySourceParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteEmbeddingsBySourceExpectation specifies expectation struct of the RepositoryI.DeleteEmbeddingsBySource
type RepositoryIMockDeleteEmbeddingsBySourceExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteEmbeddingsBySourceParams
	paramPtrs *RepositoryIMockDeleteEmbeddingsBySourceParamPtrs
	results   *RepositoryIMockDeleteEmbeddingsBySourceResults
	Counter   uint64
}

// RepositoryIMockDeleteEmbeddingsBySourceParams contains parameters of the RepositoryI.DeleteEmbeddingsBySource
type RepositoryIMockDeleteEmbeddingsBySourceParams struct {
	ctx         context.Context
	sourceTable string
	sourceUID   uuid.UUID
}

// RepositoryIMockDeleteEmbeddingsBySourceParamPtrs contains pointers to parameters of the RepositoryI.DeleteEmbeddingsBySource
type RepositoryIMockDeleteEmbeddingsBySourceParamPtrs struct {
	ctx         *context.Context
	sourceTable *string
	sourceUID   *uuid.UUID
}

// RepositoryIMockDeleteEmbeddingsBySourceResults contains results of the RepositoryI.DeleteEmbeddingsBySource
type RepositoryIMockDeleteEmbeddingsBySourceResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteEmbeddingsBySource
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) Expect(ctx context.Context, sourceTable string, sourceUID uuid.UUID) *mRepositoryIMockDeleteEmbeddingsBySource {
	if mmDeleteEmbeddingsBySource.mock.funcDeleteEmbeddingsBySource != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by Set")
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation == nil {
		mmDeleteEmbeddingsBySource.defaultExpectation = &RepositoryIMockDeleteEmbeddingsBySourceExpectation{}
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by ExpectParams functions")
	}

	mmDeleteEmbeddingsBySource.defaultExpectation.params = &RepositoryIMockDeleteEmbeddingsBySourceParams{ctx, sourceTable, sourceUID}
	for _, e := range mmDeleteEmbeddingsBySource.expectations {
		if minimock.Equal(e.params, mmDeleteEmbeddingsBySource.defaultExpectation.params) {
			mmDeleteEmbeddingsBySource.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteEmbeddingsBySource.defaultExpectation.params)
		}
	}

	return mmDeleteEmbeddingsBySource
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteEmbeddingsBySource
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteEmbeddingsBySource {
	if mmDeleteEmbeddingsBySource.mock.funcDeleteEmbeddingsBySource != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by Set")
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation == nil {
		mmDeleteEmbeddingsBySource.defaultExpectation = &RepositoryIMockDeleteEmbeddingsBySourceExpectation{}
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation.params != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by Expect")
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs == nil {
		mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs = &RepositoryIMockDeleteEmbeddingsBySourceParamPtrs{}
	}
	mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteEmbeddingsBySource
}

// ExpectSourceTableParam2 sets up expected param sourceTable for RepositoryI.DeleteEmbeddingsBySource
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) ExpectSourceTableParam2(sourceTable string) *mRepositoryIMockDeleteEmbeddingsBySource {
	if mmDeleteEmbeddingsBySource.mock.funcDeleteEmbeddingsBySource != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by Set")
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation == nil {
		mmDeleteEmbeddingsBySource.defaultExpectation = &RepositoryIMockDeleteEmbeddingsBySourceExpectation{}
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation.params != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by Expect")
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs == nil {
		mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs = &RepositoryIMockDeleteEmbeddingsBySourceParamPtrs{}
	}
	mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs.sourceTable = &sourceTable

	return mmDeleteEmbeddingsBySource
}

// ExpectSourceUIDParam3 sets up expected param sourceUID for RepositoryI.DeleteEmbeddingsBySource
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) ExpectSourceUIDParam3(sourceUID uuid.UUID) *mRepositoryIMockDeleteEmbeddingsBySource {
	if mmDeleteEmbeddingsBySource.mock.funcDeleteEmbeddingsBySource != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by Set")
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation == nil {
		mmDeleteEmbeddingsBySource.defaultExpectation = &RepositoryIMockDeleteEmbeddingsBySourceExpectation{}
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation.params != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by Expect")
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs == nil {
		mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs = &RepositoryIMockDeleteEmbeddingsBySourceParamPtrs{}
	}
	mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs.sourceUID = &sourceUID

	return mmDeleteEmbeddingsBySource
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteEmbeddingsBySource
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) Inspect(f func(ctx context.Context, sourceTable string, sourceUID uuid.UUID)) *mRepositoryIMockDeleteEmbeddingsBySource {
	if mmDeleteEmbeddingsBySource.mock.inspectFuncDeleteEmbeddingsBySource != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteEmbeddingsBySource")
	}

	mmDeleteEmbeddingsBySource.mock.inspectFuncDeleteEmbeddingsBySource = f

	return mmDeleteEmbeddingsBySource
}

// Return sets up results that will be returned by RepositoryI.DeleteEmbeddingsBySource
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) Return(err error) *RepositoryIMock {
	if mmDeleteEmbeddingsBySource.mock.funcDeleteEmbeddingsBySource != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by Set")
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation == nil {
		mmDeleteEmbeddingsBySource.defaultExpectation = &RepositoryIMockDeleteEmbeddingsBySourceExpectation{mock: mmDeleteEmbeddingsBySource.mock}
	}
	mmDeleteEmbeddingsBySource.defaultExpectation.results = &RepositoryIMockDeleteEmbeddingsBySourceResults{err}
	return mmDeleteEmbeddingsBySource.mock
}

// Set uses given function f to mock the RepositoryI.DeleteEmbeddingsBySource method
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) Set(f func(ctx context.Context, sourceTable string, sourceUID uuid.UUID) (err error)) *RepositoryIMock {
	if mmDeleteEmbeddingsBySource.defaultExpectation != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteEmbeddingsBySource method")
	}

	if len(mmDeleteEmbeddingsBySource.expectations) > 0 {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteEmbeddingsBySource method")
	}

	mmDeleteEmbeddingsBySource.mock.funcDeleteEmbeddingsBySource = f
	return mmDeleteEmbeddingsBySource.mock
}

// When sets expectation for the RepositoryI.DeleteEmbeddingsBySource which will trigger the result defined by the following
// Then helper
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) When(ctx context.Context, sourceTable string, sourceUID uuid.UUID) *RepositoryIMockDeleteEmbeddingsBySourceExpectation {
	if mmDeleteEmbeddingsBySource.mock.funcDeleteEmbeddingsBySource != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteEmbeddingsBySourceExpectation{
		mock:   mmDeleteEmbeddingsBySource.mock,
		params: &RepositoryIMockDeleteEmbeddingsBySourceParams{ctx, sourceTable, sourceUID},
	}
	mmDeleteEmbeddingsBySource.expectations = append(mmDeleteEmbeddingsBySource.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteEmbeddingsBySource return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteEmbeddingsBySourceExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteEmbeddingsBySourceResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteEmbeddingsBySource should be invoked
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) Times(n uint64) *mRepositoryIMockDeleteEmbeddingsBySource {
	if n == 0 {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("Times of RepositoryIMock.DeleteEmbeddingsBySource mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteEmbeddingsBySource.expectedInvocations, n)
	return mmDeleteEmbeddingsBySource
}

func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) invocationsDone() bool {
	if len(mmDeleteEmbeddingsBySource.expectations) == 0 && mmDeleteEmbeddingsBySource.defaultExpectation == nil && mmDeleteEmbeddingsBySource.mock.funcDeleteEmbeddingsBySource == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteEmbeddingsBySource.mock.afterDeleteEmbeddingsBySourceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteEmbeddingsBySource.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteEmbeddingsBySource implements repository.RepositoryI
func (mmDeleteEmbeddingsBySource *RepositoryIMock) DeleteEmbeddingsBySource(ctx context.Context, sourceTable string, sourceUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteEmbeddingsBySource.beforeDeleteEmbeddingsBySourceCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteEmbeddingsBySource.afterDeleteEmbeddingsBySourceCounter, 1)

	if mmDeleteEmbeddingsBySource.inspectFuncDeleteEmbeddingsBySource != nil {
		mmDeleteEmbeddingsBySource.inspectFuncDeleteEmbeddingsBySource(ctx, sourceTable, sourceUID)
	}

	mm_params := RepositoryIMockDeleteEmbeddingsBySourceParams{ctx, sourceTable, sourceUID}

	// Record call args
	mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.mutex.Lock()
	mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.callArgs = append(mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.callArgs, &mm_params)
	mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.mutex.Unlock()

	for _, e := range mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteEmbeddingsBySourceParams{ctx, sourceTable, sourceUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteEmbeddingsBySource.t.Errorf("RepositoryIMock.DeleteEmbeddingsBySource got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sourceTable != nil && !minimock.Equal(*mm_want_ptrs.sourceTable, mm_got.sourceTable) {
				mmDeleteEmbeddingsBySource.t.Errorf("RepositoryIMock.DeleteEmbeddingsBySource got unexpected parameter sourceTable, want: %#v, got: %#v%s\n", *mm_want_ptrs.sourceTable, mm_got.sourceTable, minimock.Diff(*mm_want_ptrs.sourceTable, mm_got.sourceTable))
			}

			if mm_want_ptrs.sourceUID != nil && !minimock.Equal(*mm_want_ptrs.sourceUID, mm_got.sourceUID) {
				mmDeleteEmbeddingsBySource.t.Errorf("RepositoryIMock.DeleteEmbeddingsBySource got unexpected parameter sourceUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.sourceUID, mm_got.sourceUID, minimock.Diff(*mm_want_ptrs.sourceUID, mm_got.sourceUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteEmbeddingsBySource.t.Errorf("RepositoryIMock.DeleteEmbeddingsBySource got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteEmbeddingsBySource.t.Fatal("No results are set for the RepositoryIMock.DeleteEmbeddingsBySource")
		}
		return (*mm_results).err
	}
	if mmDeleteEmbeddingsBySource.funcDeleteEmbeddingsBySource != nil {
		return mmDeleteEmbeddingsBySource.funcDeleteEmbeddingsBySource(ctx, sourceTable, sourceUID)
	}
	mmDeleteEmbeddingsBySource.t.Fatalf("Unexpected call to RepositoryIMock.DeleteEmbeddingsBySource. %v %v %v", ctx, sourceTable, sourceUID)
	return
}

// DeleteEmbeddingsBySourceAfterCounter returns a count of finished RepositoryIMock.DeleteEmbeddingsBySource invocations
func (mmDeleteEmbeddingsBySource *RepositoryIMock) DeleteEmbeddingsBySourceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEmbeddingsBySource.afterDeleteEmbeddingsBySourceCounter)
}

// DeleteEmbeddingsBySourceBeforeCounter returns a count of RepositoryIMock.DeleteEmbeddingsBySource invocations
func (mmDeleteEmbeddingsBySource *RepositoryIMock) DeleteEmbeddingsBySourceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEmbeddingsBySource.beforeDeleteEmbeddingsBySourceCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteEmbeddingsBySource.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) Calls() []*RepositoryIMockDeleteEmbeddingsBySourceParams {
	mmDeleteEmbeddingsBySource.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteEmbeddingsBySourceParams, len(mmDeleteEmbeddingsBySource.callArgs))
	copy(argCopy, mmDeleteEmbeddingsBySource.callArgs)

	mmDeleteEmbeddingsBySource.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteEmbeddingsBySourceDone returns true if the count of the DeleteEmbeddingsBySource invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteEmbeddingsBySourceDone() bool {
	for _, e := range m.DeleteEmbeddingsBySourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteEmbeddingsBySourceMock.invocationsDone()
}

// MinimockDeleteEmbeddingsBySourceInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteEmbeddingsBySourceInspect() {
	for _, e := range m.DeleteEmbeddingsBySourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteEmbeddingsBySource with params: %#v", *e.params)
		}
	}

	afterDeleteEmbeddingsBySourceCounter := mm_atomic.LoadUint64(&m.afterDeleteEmbeddingsBySourceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteEmbeddingsBySourceMock.defaultExpectation != nil && afterDeleteEmbeddingsBySourceCounter < 1 {
		if m.DeleteEmbeddingsBySourceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteEmbeddingsBySource")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteEmbeddingsBySource with params: %#v", *m.DeleteEmbeddingsBySourceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteEmbeddingsBySource != nil && afterDeleteEmbeddingsBySourceCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteEmbeddingsBySource")
	}

	if !m.DeleteEmbeddingsBySourceMock.invocationsDone() && afterDeleteEmbeddingsBySourceCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteEmbeddingsBySource but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteEmbeddingsBySourceMock.expectedInvocations), afterDeleteEmbeddingsBySourceCounter)
	}
}

type mRepositoryIMockDeleteEmbeddingsByUIDs struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteEmbeddingsByUIDsExpectation
	expectations       []*RepositoryIMockDeleteEmbeddingsByUIDsExpectation

	callArgs []*RepositoryIMockDeleteEmbeddingsByUIDsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteEmbeddingsByUIDsExpectation specifies expectation struct of the RepositoryI.DeleteEmbeddingsByUIDs
type RepositoryIMockDeleteEmbeddingsByUIDsExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteEmbeddingsByUIDsParams
	paramPtrs *RepositoryIMockDeleteEmbeddingsByUIDsParamPtrs
	results   *RepositoryIMockDeleteEmbeddingsByUIDsResults
	Counter   uint64
}

// RepositoryIMockDeleteEmbeddingsByUIDsParams contains parameters of the RepositoryI.DeleteEmbeddingsByUIDs
type RepositoryIMockDeleteEmbeddingsByUIDsParams struct {
	ctx     context.Context
	embUIDs []uuid.UUID
}

// RepositoryIMockDeleteEmbeddingsByUIDsParamPtrs contains pointers to parameters of the RepositoryI.DeleteEmbeddingsByUIDs
type RepositoryIMockDeleteEmbeddingsByUIDsParamPtrs struct {
	ctx     *context.Context
	embUIDs *[]uuid.UUID
}

// RepositoryIMockDeleteEmbeddingsByUIDsResults contains results of the RepositoryI.DeleteEmbeddingsByUIDs
type RepositoryIMockDeleteEmbeddingsByUIDsResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteEmbeddingsByUIDs
func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) Expect(ctx context.Context, embUIDs []uuid.UUID) *mRepositoryIMockDeleteEmbeddingsByUIDs {
	if mmDeleteEmbeddingsByUIDs.mock.funcDeleteEmbeddingsByUIDs != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsByUIDs mock is already set by Set")
	}

	if mmDeleteEmbeddingsByUIDs.defaultExpectation == nil {
		mmDeleteEmbeddingsByUIDs.defaultExpectation = &RepositoryIMockDeleteEmbeddingsByUIDsExpectation{}
	}

	if mmDeleteEmbeddingsByUIDs.defaultExpectation.paramPtrs != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsByUIDs mock is already set by ExpectParams functions")
	}

	mmDeleteEmbeddingsByUIDs.defaultExpectation.params = &RepositoryIMockDeleteEmbeddingsByUIDsParams{ctx, embUIDs}
	for _, e := range mmDeleteEmbeddingsByUIDs.expectations {
		if minimock.Equal(e.params, mmDeleteEmbeddingsByUIDs.defaultExpectation.params) {
			mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteEmbeddingsByUIDs.defaultExpectation.params)
		}
	}

	return mmDeleteEmbeddingsByUIDs
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteEmbeddingsByUIDs
func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteEmbeddingsByUIDs {
	if mmDeleteEmbeddingsByUIDs.mock.funcDeleteEmbeddingsByUIDs != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsByUIDs mock is already set by Set")
	}

	if mmDeleteEmbeddingsByUIDs.defaultExpectation == nil {
		mmDeleteEmbeddingsByUIDs.defaultExpectation = &RepositoryIMockDeleteEmbeddingsByUIDsExpectation{}
	}

	if mmDeleteEmbeddingsByUIDs.defaultExpectation.params != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsByUIDs mock is already set by Expect")
	}

	if mmDeleteEmbeddingsByUIDs.defaultExpectation.paramPtrs == nil {
		mmDeleteEmbeddingsByUIDs.defaultExpectation.paramPtrs = &RepositoryIMockDeleteEmbeddingsByUIDsParamPtrs{}
	}
	mmDeleteEmbeddingsByUIDs.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteEmbeddingsByUIDs
}

// ExpectEmbUIDsParam2 sets up expected param embUIDs for RepositoryI.DeleteEmbeddingsByUIDs
func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) ExpectEmbUIDsParam2(embUIDs []uuid.UUID) *mRepositoryIMockDeleteEmbeddingsByUIDs {
	if mmDeleteEmbeddingsByUIDs.mock.funcDeleteEmbeddingsByUIDs != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsByUIDs mock is already set by Set")
	}

	if mmDeleteEmbeddingsByUIDs.defaultExpectation == nil {
		mmDeleteEmbeddingsByUIDs.defaultExpectation = &RepositoryIMockDeleteEmbeddingsByUIDsExpectation{}
	}

	if mmDeleteEmbeddingsByUIDs.defaultExpectation.params != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsByUIDs mock is already set by Expect")
	}

	if mmDeleteEmbeddingsByUIDs.defaultExpectation.paramPtrs == nil {
		mmDeleteEmbeddingsByUIDs.defaultExpectation.paramPtrs = &RepositoryIMockDeleteEmbeddingsByUIDsParamPtrs{}
	}
	mmDeleteEmbeddingsByUIDs.defaultExpectation.paramPtrs.embUIDs = &embUIDs

	return mmDeleteEmbeddingsByUIDs
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteEmbeddingsByUIDs
func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) Inspect(f func(ctx context.Context, embUIDs []uuid.UUID)) *mRepositoryIMockDeleteEmbeddingsByUIDs {
	if mmDeleteEmbeddingsByUIDs.mock.inspectFuncDeleteEmbeddingsByUIDs != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteEmbeddingsByUIDs")
	}

	mmDeleteEmbeddingsByUIDs.mock.inspectFuncDeleteEmbeddingsByUIDs = f

	return mmDeleteEmbeddingsByUIDs
}

// Return sets up results that will be returned by RepositoryI.DeleteEmbeddingsByUIDs
func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) Return(err error) *RepositoryIMock {
	if mmDeleteEmbeddingsByUIDs.mock.funcDeleteEmbeddingsByUIDs != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsByUIDs mock is already set by Set")
	}

	if mmDeleteEmbeddingsByUIDs.defaultExpectation == nil {
		mmDeleteEmbeddingsByUIDs.defaultExpectation = &RepositoryIMockDeleteEmbeddingsByUIDsExpectation{mock: mmDeleteEmbeddingsByUIDs.mock}
	}
	mmDeleteEmbeddingsByUIDs.defaultExpectation.results = &RepositoryIMockDeleteEmbeddingsByUIDsResults{err}
	return mmDeleteEmbeddingsByUIDs.mock
}

// Set uses given function f to mock the RepositoryI.DeleteEmbeddingsByUIDs method
func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) Set(f func(ctx context.Context, embUIDs []uuid.UUID) (err error)) *RepositoryIMock {
	if mmDeleteEmbeddingsByUIDs.defaultExpectation != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteEmbeddingsByUIDs method")
	}

	if len(mmDeleteEmbeddingsByUIDs.expectations) > 0 {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteEmbeddingsByUIDs method")
	}

	mmDeleteEmbeddingsByUIDs.mock.funcDeleteEmbeddingsByUIDs = f
	return mmDeleteEmbeddingsByUIDs.mock
}

// When sets expectation for the RepositoryI.DeleteEmbeddingsByUIDs which will trigger the result defined by the following
// Then helper
func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) When(ctx context.Context, embUIDs []uuid.UUID) *RepositoryIMockDeleteEmbeddingsByUIDsExpectation {
	if mmDeleteEmbeddingsByUIDs.mock.funcDeleteEmbeddingsByUIDs != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsByUIDs mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteEmbeddingsByUIDsExpectation{
		mock:   mmDeleteEmbeddingsByUIDs.mock,
		params: &RepositoryIMockDeleteEmbeddingsByUIDsParams{ctx, embUIDs},
	}
	mmDeleteEmbeddingsByUIDs.expectations = append(mmDeleteEmbeddingsByUIDs.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteEmbeddingsByUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteEmbeddingsByUIDsExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteEmbeddingsByUIDsResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteEmbeddingsByUIDs should be invoked
func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) Times(n uint64) *mRepositoryIMockDeleteEmbeddingsByUIDs {
	if n == 0 {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("Times of RepositoryIMock.DeleteEmbeddingsByUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteEmbeddingsByUIDs.expectedInvocations, n)
	return mmDeleteEmbeddingsByUIDs
}

func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) invocationsDone() bool {
	if len(mmDeleteEmbeddingsByUIDs.expectations) == 0 && mmDeleteEmbeddingsByUIDs.defaultExpectation == nil && mmDeleteEmbeddingsByUIDs.mock.funcDeleteEmbeddingsByUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteEmbeddingsByUIDs.mock.afterDeleteEmbeddingsByUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteEmbeddingsByUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteEmbeddingsByUIDs implements repository.RepositoryI
func (mmDeleteEmbeddingsByUIDs *RepositoryIMock) DeleteEmbeddingsByUIDs(ctx context.Context, embUIDs []uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteEmbeddingsByUIDs.beforeDeleteEmbeddingsByUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteEmbeddingsByUIDs.afterDeleteEmbeddingsByUIDsCounter, 1)

	if mmDeleteEmbeddingsByUIDs.inspectFuncDeleteEmbeddingsByUIDs != nil {
		mmDeleteEmbeddingsByUIDs.inspectFuncDeleteEmbeddingsByUIDs(ctx, embUIDs)
	}

	mm_params := RepositoryIMockDeleteEmbeddingsByUIDsParams{ctx, embUIDs}

	// Record call args
	mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.mutex.Lock()
	mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.callArgs = append(mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.callArgs, &mm_params)
	mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.mutex.Unlock()

	for _, e := range mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteEmbeddingsByUIDsParams{ctx, embUIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteEmbeddingsByUIDs.t.Errorf("RepositoryIMock.DeleteEmbeddingsByUIDs got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.embUIDs != nil && !minimock.Equal(*mm_want_ptrs.embUIDs, mm_got.embUIDs) {
				mmDeleteEmbeddingsByUIDs.t.Errorf("RepositoryIMock.DeleteEmbeddingsByUIDs got unexpected parameter embUIDs, want: %#v, got: %#v%s\n", *mm_want_ptrs.embUIDs, mm_got.embUIDs, minimock.Diff(*mm_want_ptrs.embUIDs, mm_got.embUIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteEmbeddingsByUIDs.t.Errorf("RepositoryIMock.DeleteEmbeddingsByUIDs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteEmbeddingsByUIDs.t.Fatal("No results are set for the RepositoryIMock.DeleteEmbeddingsByUIDs")
		}
		return (*mm_results).err
	}
	if mmDeleteEmbeddingsByUIDs.funcDeleteEmbeddingsByUIDs != nil {
		return mmDeleteEmbeddingsByUIDs.funcDeleteEmbeddingsByUIDs(ctx, embUIDs)
	}
	mmDeleteEmbeddingsByUIDs.t.Fatalf("Unexpected call to RepositoryIMock.DeleteEmbeddingsByUIDs. %v %v", ctx, embUIDs)
	return
}

// DeleteEmbeddingsByUIDsAfterCounter returns a count of finished RepositoryIMock.DeleteEmbeddingsByUIDs invocations
func (mmDeleteEmbeddingsByUIDs *RepositoryIMock) DeleteEmbeddingsByUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEmbeddingsByUIDs.afterDeleteEmbeddingsByUIDsCounter)
}

// DeleteEmbeddingsByUIDsBeforeCounter returns a count of RepositoryIMock.DeleteEmbeddingsByUIDs invocations
func (mmDeleteEmbeddingsByUIDs *RepositoryIMock) DeleteEmbeddingsByUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEmbeddingsByUIDs.beforeDeleteEmbeddingsByUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteEmbeddingsByUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) Calls() []*RepositoryIMockDeleteEmbeddingsByUIDsParams {
	mmDeleteEmbeddingsByUIDs.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteEmbeddingsByUIDsParams, len(mmDeleteEmbeddingsByUIDs.callArgs))
	copy(argCopy, mmDeleteEmbeddingsByUIDs.callArgs)

	mmDeleteEmbeddingsByUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteEmbeddingsByUIDsDone returns true if the count of the DeleteEmbeddingsByUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteEmbeddingsByUIDsDone() bool {
	for _, e := range m.DeleteEmbeddingsByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteEmbeddingsByUIDsMock.invocationsDone()
}

// MinimockDeleteEmbeddingsByUIDsInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteEmbeddingsByUIDsInspect() {
	for _, e := range m.DeleteEmbeddingsByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteEmbeddingsByUIDs with params: %#v", *e.params)
		}
	}

	afterDeleteEmbeddingsByUIDsCounter := mm_atomic.LoadUint64(&m.afterDeleteEmbeddingsByUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteEmbeddingsByUIDsMock.defaultExpectation != nil && afterDeleteEmbeddingsByUIDsCounter < 1 {
		if m.DeleteEmbeddingsByUIDsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteEmbeddingsByUIDs")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteEmbeddingsByUIDs with params: %#v", *m.DeleteEmbeddingsByUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteEmbeddingsByUIDs != nil && afterDeleteEmbeddingsByUIDsCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteEmbeddingsByUIDs")
	}

	if !m.DeleteEmbeddingsByUIDsMock.invocationsDone() && afterDeleteEmbeddingsByUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteEmbeddingsByUIDs but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteEmbeddingsByUIDsMock.expectedInvocations), afterDeleteEmbeddingsByUIDsCounter)
	}
}

type mRepositoryIMockDeleteKnowledgeBase struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteKnowledgeBaseExpectation
	expectations       []*RepositoryIMockDeleteKnowledgeBaseExpectation

	callArgs []*RepositoryIMockDeleteKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteKnowledgeBaseExpectation specifies expectation struct of the RepositoryI.DeleteKnowledgeBase
type RepositoryIMockDeleteKnowledgeBaseExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteKnowledgeBaseParams
	paramPtrs *RepositoryIMockDeleteKnowledgeBaseParamPtrs
	results   *RepositoryIMockDeleteKnowledgeBaseResults
	Counter   uint64
}

// RepositoryIMockDeleteKnowledgeBaseParams contains parameters of the RepositoryI.DeleteKnowledgeBase
type RepositoryIMockDeleteKnowledgeBaseParams struct {
	ctx      context.Context
	ownerUID string
	kbID     string
}

// RepositoryIMockDeleteKnowledgeBaseParamPtrs contains pointers to parameters of the RepositoryI.DeleteKnowledgeBase
type RepositoryIMockDeleteKnowledgeBaseParamPtrs struct {
	ctx      *context.Context
	ownerUID *string
	kbID     *string
}

// RepositoryIMockDeleteKnowledgeBaseResults contains results of the RepositoryI.DeleteKnowledgeBase
type RepositoryIMockDeleteKnowledgeBaseResults struct {
	kp1 *mm_repository.KnowledgeBase
	err error
}

// Expect sets up expected params for RepositoryI.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) Expect(ctx context.Context, ownerUID string, kbID string) *mRepositoryIMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmDeleteKnowledgeBase.defaultExpectation.params = &RepositoryIMockDeleteKnowledgeBaseParams{ctx, ownerUID, kbID}
	for _, e := range mmDeleteKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmDeleteKnowledgeBase.defaultExpectation.params) {
			mmDeleteKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmDeleteKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.params != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Expect")
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockDeleteKnowledgeBaseParamPtrs{}
	}
	mmDeleteKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteKnowledgeBase
}

// ExpectOwnerUIDParam2 sets up expected param ownerUID for RepositoryI.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) ExpectOwnerUIDParam2(ownerUID string) *mRepositoryIMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.params != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Expect")
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockDeleteKnowledgeBaseParamPtrs{}
	}
	mmDeleteKnowledgeBase.defaultExpectation.paramPtrs.ownerUID = &ownerUID

	return mmDeleteKnowledgeBase
}

// ExpectKbIDParam3 sets up expected param kbID for RepositoryI.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) ExpectKbIDParam3(kbID string) *mRepositoryIMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.params != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Expect")
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockDeleteKnowledgeBaseParamPtrs{}
	}
	mmDeleteKnowledgeBase.defaultExpectation.paramPtrs.kbID = &kbID

	return mmDeleteKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) Inspect(f func(ctx context.Context, ownerUID string, kbID string)) *mRepositoryIMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.inspectFuncDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteKnowledgeBase")
	}

	mmDeleteKnowledgeBase.mock.inspectFuncDeleteKnowledgeBase = f

	return mmDeleteKnowledgeBase
}

// Return sets up results that will be returned by RepositoryI.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) Return(kp1 *mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseExpectation{mock: mmDeleteKnowledgeBase.mock}
	}
	mmDeleteKnowledgeBase.defaultExpectation.results = &RepositoryIMockDeleteKnowledgeBaseResults{kp1, err}
	return mmDeleteKnowledgeBase.mock
}

// Set uses given function f to mock the RepositoryI.DeleteKnowledgeBase method
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) Set(f func(ctx context.Context, ownerUID string, kbID string) (kp1 *mm_repository.KnowledgeBase, err error)) *RepositoryIMock {
	if mmDeleteKnowledgeBase.defaultExpectation != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteKnowledgeBase method")
	}

	if len(mmDeleteKnowledgeBase.expectations) > 0 {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteKnowledgeBase method")
	}

	mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase = f
	return mmDeleteKnowledgeBase.mock
}

// When sets expectation for the RepositoryI.DeleteKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) When(ctx context.Context, ownerUID string, kbID string) *RepositoryIMockDeleteKnowledgeBaseExpectation {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteKnowledgeBaseExpectation{
		mock:   mmDeleteKnowledgeBase.mock,
		params: &RepositoryIMockDeleteKnowledgeBaseParams{ctx, ownerUID, kbID},
	}
	mmDeleteKnowledgeBase.expectations = append(mmDeleteKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteKnowledgeBaseExpectation) Then(kp1 *mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteKnowledgeBaseResults{kp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteKnowledgeBase should be invoked
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) Times(n uint64) *mRepositoryIMockDeleteKnowledgeBase {
	if n == 0 {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Times of RepositoryIMock.DeleteKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteKnowledgeBase.expectedInvocations, n)
	return mmDeleteKnowledgeBase
}

func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) invocationsDone() bool {
	if len(mmDeleteKnowledgeBase.expectations) == 0 && mmDeleteKnowledgeBase.defaultExpectation == nil && mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.mock.afterDeleteKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteKnowledgeBase implements repository.RepositoryI
func (mmDeleteKnowledgeBase *RepositoryIMock) DeleteKnowledgeBase(ctx context.Context, ownerUID string, kbID string) (kp1 *mm_repository.KnowledgeBase, err error) {
	mm_atomic.AddUint64(&mmDeleteKnowledgeBase.beforeDeleteKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteKnowledgeBase.afterDeleteKnowledgeBaseCounter, 1)

	if mmDeleteKnowledgeBase.inspectFuncDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.inspectFuncDeleteKnowledgeBase(ctx, ownerUID, kbID)
	}

	mm_params := RepositoryIMockDeleteKnowledgeBaseParams{ctx, ownerUID, kbID}

	// Record call args
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.mutex.Lock()
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.callArgs = append(mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.callArgs, &mm_params)
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteKnowledgeBaseParams{ctx, ownerUID, kbID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteKnowledgeBase.t.Errorf("RepositoryIMock.DeleteKnowledgeBase got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmDeleteKnowledgeBase.t.Errorf("RepositoryIMock.DeleteKnowledgeBase got unexpected parameter ownerUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

			if mm_want_ptrs.kbID != nil && !minimock.Equal(*mm_want_ptrs.kbID, mm_got.kbID) {
				mmDeleteKnowledgeBase.t.Errorf("RepositoryIMock.DeleteKnowledgeBase got unexpected parameter kbID, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbID, mm_got.kbID, minimock.Diff(*mm_want_ptrs.kbID, mm_got.kbID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteKnowledgeBase.t.Errorf("RepositoryIMock.DeleteKnowledgeBase got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteKnowledgeBase.t.Fatal("No results are set for the RepositoryIMock.DeleteKnowledgeBase")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmDeleteKnowledgeBase.funcDeleteKnowledgeBase != nil {
		return mmDeleteKnowledgeBase.funcDeleteKnowledgeBase(ctx, ownerUID, kbID)
	}
	mmDeleteKnowledgeBase.t.Fatalf("Unexpected call to RepositoryIMock.DeleteKnowledgeBase. %v %v %v", ctx, ownerUID, kbID)
	return
}

// DeleteKnowledgeBaseAfterCounter returns a count of finished RepositoryIMock.DeleteKnowledgeBase invocations
func (mmDeleteKnowledgeBase *RepositoryIMock) DeleteKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.afterDeleteKnowledgeBaseCounter)
}

// DeleteKnowledgeBaseBeforeCounter returns a count of RepositoryIMock.DeleteKnowledgeBase invocations
func (mmDeleteKnowledgeBase *RepositoryIMock) DeleteKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.beforeDeleteKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) Calls() []*RepositoryIMockDeleteKnowledgeBaseParams {
	mmDeleteKnowledgeBase.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteKnowledgeBaseParams, len(mmDeleteKnowledgeBase.callArgs))
	copy(argCopy, mmDeleteKnowledgeBase.callArgs)

	mmDeleteKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteKnowledgeBaseDone returns true if the count of the DeleteKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteKnowledgeBaseDone() bool {
	for _, e := range m.DeleteKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteKnowledgeBaseMock.invocationsDone()
}

// MinimockDeleteKnowledgeBaseInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteKnowledgeBaseInspect() {
	for _, e := range m.DeleteKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteKnowledgeBase with params: %#v", *e.params)
		}
	}

	afterDeleteKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterDeleteKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteKnowledgeBaseMock.defaultExpectation != nil && afterDeleteKnowledgeBaseCounter < 1 {
		if m.DeleteKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteKnowledgeBase")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteKnowledgeBase with params: %#v", *m.DeleteKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteKnowledgeBase != nil && afterDeleteKnowledgeBaseCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteKnowledgeBase")
	}

	if !m.DeleteKnowledgeBaseMock.invocationsDone() && afterDeleteKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteKnowledgeBase but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteKnowledgeBaseMock.expectedInvocations), afterDeleteKnowledgeBaseCounter)
	}
}

type mRepositoryIMockDeleteKnowledgeBaseFile struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteKnowledgeBaseFileExpectation
	expectations       []*RepositoryIMockDeleteKnowledgeBaseFileExpectation

	callArgs []*RepositoryIMockDeleteKnowledgeBaseFileParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteKnowledgeBaseFileExpectation specifies expectation struct of the RepositoryI.DeleteKnowledgeBaseFile
type RepositoryIMockDeleteKnowledgeBaseFileExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteKnowledgeBaseFileParams
	paramPtrs *RepositoryIMockDeleteKnowledgeBaseFileParamPtrs
	results   *RepositoryIMockDeleteKnowledgeBaseFileResults
	Counter   uint64
}

// RepositoryIMockDeleteKnowledgeBaseFileParams contains parameters of the RepositoryI.DeleteKnowledgeBaseFile
type RepositoryIMockDeleteKnowledgeBaseFileParams struct {
	ctx     context.Context
	fileUID string
}

// RepositoryIMockDeleteKnowledgeBaseFileParamPtrs contains pointers to parameters of the RepositoryI.DeleteKnowledgeBaseFile
type RepositoryIMockDeleteKnowledgeBaseFileParamPtrs struct {
	ctx     *context.Context
	fileUID *string
}

// RepositoryIMockDeleteKnowledgeBaseFileResults contains results of the RepositoryI.DeleteKnowledgeBaseFile
type RepositoryIMockDeleteKnowledgeBaseFileResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteKnowledgeBaseFile
func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) Expect(ctx context.Context, fileUID string) *mRepositoryIMockDeleteKnowledgeBaseFile {
	if mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFile mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseFileExpectation{}
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFile mock is already set by ExpectParams functions")
	}

	mmDeleteKnowledgeBaseFile.defaultExpectation.params = &RepositoryIMockDeleteKnowledgeBaseFileParams{ctx, fileUID}
	for _, e := range mmDeleteKnowledgeBaseFile.expectations {
		if minimock.Equal(e.params, mmDeleteKnowledgeBaseFile.defaultExpectation.params) {
			mmDeleteKnowledgeBaseFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteKnowledgeBaseFile.defaultExpectation.params)
		}
	}

	return mmDeleteKnowledgeBaseFile
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteKnowledgeBaseFile
func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteKnowledgeBaseFile {
	if mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFile mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseFileExpectation{}
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation.params != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFile mock is already set by Expect")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryIMockDeleteKnowledgeBaseFileParamPtrs{}
	}
	mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteKnowledgeBaseFile
}

// ExpectFileUIDParam2 sets up expected param fileUID for RepositoryI.DeleteKnowledgeBaseFile
func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) ExpectFileUIDParam2(fileUID string) *mRepositoryIMockDeleteKnowledgeBaseFile {
	if mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFile mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseFileExpectation{}
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation.params != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFile mock is already set by Expect")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryIMockDeleteKnowledgeBaseFileParamPtrs{}
	}
	mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs.fileUID = &fileUID

	return mmDeleteKnowledgeBaseFile
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteKnowledgeBaseFile
func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) Inspect(f func(ctx context.Context, fileUID string)) *mRepositoryIMockDeleteKnowledgeBaseFile {
	if mmDeleteKnowledgeBaseFile.mock.inspectFuncDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteKnowledgeBaseFile")
	}

	mmDeleteKnowledgeBaseFile.mock.inspectFuncDeleteKnowledgeBaseFile = f

	return mmDeleteKnowledgeBaseFile
}

// Return sets up results that will be returned by RepositoryI.DeleteKnowledgeBaseFile
func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) Return(err error) *RepositoryIMock {
	if mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFile mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseFileExpectation{mock: mmDeleteKnowledgeBaseFile.mock}
	}
	mmDeleteKnowledgeBaseFile.defaultExpectation.results = &RepositoryIMockDeleteKnowledgeBaseFileResults{err}
	return mmDeleteKnowledgeBaseFile.mock
}

// Set uses given function f to mock the RepositoryI.DeleteKnowledgeBaseFile method
func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) Set(f func(ctx context.Context, fileUID string) (err error)) *RepositoryIMock {
	if mmDeleteKnowledgeBaseFile.defaultExpectation != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteKnowledgeBaseFile method")
	}

	if len(mmDeleteKnowledgeBaseFile.expectations) > 0 {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteKnowledgeBaseFile method")
	}

	mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile = f
	return mmDeleteKnowledgeBaseFile.mock
}

// When sets expectation for the RepositoryI.DeleteKnowledgeBaseFile which will trigger the result defined by the following
// Then helper
func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) When(ctx context.Context, fileUID string) *RepositoryIMockDeleteKnowledgeBaseFileExpectation {
	if mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFile mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteKnowledgeBaseFileExpectation{
		mock:   mmDeleteKnowledgeBaseFile.mock,
		params: &RepositoryIMockDeleteKnowledgeBaseFileParams{ctx, fileUID},
	}
	mmDeleteKnowledgeBaseFile.expectations = append(mmDeleteKnowledgeBaseFile.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteKnowledgeBaseFile return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteKnowledgeBaseFileExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteKnowledgeBaseFileResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteKnowledgeBaseFile should be invoked
func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) Times(n uint64) *mRepositoryIMockDeleteKnowledgeBaseFile {
	if n == 0 {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("Times of RepositoryIMock.DeleteKnowledgeBaseFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteKnowledgeBaseFile.expectedInvocations, n)
	return mmDeleteKnowledgeBaseFile
}

func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) invocationsDone() bool {
	if len(mmDeleteKnowledgeBaseFile.expectations) == 0 && mmDeleteKnowledgeBaseFile.defaultExpectation == nil && mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFile.mock.afterDeleteKnowledgeBaseFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteKnowledgeBaseFile implements repository.RepositoryI
func (mmDeleteKnowledgeBaseFile *RepositoryIMock) DeleteKnowledgeBaseFile(ctx context.Context, fileUID string) (err error) {
	mm_atomic.AddUint64(&mmDeleteKnowledgeBaseFile.beforeDeleteKnowledgeBaseFileCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteKnowledgeBaseFile.afterDeleteKnowledgeBaseFileCounter, 1)

	if mmDeleteKnowledgeBaseFile.inspectFuncDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.inspectFuncDeleteKnowledgeBaseFile(ctx, fileUID)
	}

	mm_params := RepositoryIMockDeleteKnowledgeBaseFileParams{ctx, fileUID}

	// Record call args
	mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.mutex.Lock()
	mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.callArgs = append(mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.callArgs, &mm_params)
	mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.mutex.Unlock()

	for _, e := range mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteKnowledgeBaseFileParams{ctx, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteKnowledgeBaseFile.t.Errorf("RepositoryIMock.DeleteKnowledgeBaseFile got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmDeleteKnowledgeBaseFile.t.Errorf("RepositoryIMock.DeleteKnowledgeBaseFile got unexpected parameter fileUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteKnowledgeBaseFile.t.Errorf("RepositoryIMock.DeleteKnowledgeBaseFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteKnowledgeBaseFile.t.Fatal("No results are set for the RepositoryIMock.DeleteKnowledgeBaseFile")
		}
		return (*mm_results).err
	}
	if mmDeleteKnowledgeBaseFile.funcDeleteKnowledgeBaseFile != nil {
		return mmDeleteKnowledgeBaseFile.funcDeleteKnowledgeBaseFile(ctx, fileUID)
	}
	mmDeleteKnowledgeBaseFile.t.Fatalf("Unexpected call to RepositoryIMock.DeleteKnowledgeBaseFile. %v %v", ctx, fileUID)
	return
}

// DeleteKnowledgeBaseFileAfterCounter returns a count of finished RepositoryIMock.DeleteKnowledgeBaseFile invocations
func (mmDeleteKnowledgeBaseFile *RepositoryIMock) DeleteKnowledgeBaseFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFile.afterDeleteKnowledgeBaseFileCounter)
}

// DeleteKnowledgeBaseFileBeforeCounter returns a count of RepositoryIMock.DeleteKnowledgeBaseFile invocations
func (mmDeleteKnowledgeBaseFile *RepositoryIMock) DeleteKnowledgeBaseFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFile.beforeDeleteKnowledgeBaseFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteKnowledgeBaseFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) Calls() []*RepositoryIMockDeleteKnowledgeBaseFileParams {
	mmDeleteKnowledgeBaseFile.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteKnowledgeBaseFileParams, len(mmDeleteKnowledgeBaseFile.callArgs))
	copy(argCopy, mmDeleteKnowledgeBaseFile.callArgs)

	mmDeleteKnowledgeBaseFile.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteKnowledgeBaseFileDone returns true if the count of the DeleteKnowledgeBaseFile invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteKnowledgeBaseFileDone() bool {
	for _, e := range m.DeleteKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteKnowledgeBaseFileMock.invocationsDone()
}

// MinimockDeleteKnowledgeBaseFileInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteKnowledgeBaseFileInspect() {
	for _, e := range m.DeleteKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteKnowledgeBaseFile with params: %#v", *e.params)
		}
	}

	afterDeleteKnowledgeBaseFileCounter := mm_atomic.LoadUint64(&m.afterDeleteKnowledgeBaseFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteKnowledgeBaseFileMock.defaultExpectation != nil && afterDeleteKnowledgeBaseFileCounter < 1 {
		if m.DeleteKnowledgeBaseFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteKnowledgeBaseFile")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteKnowledgeBaseFile with params: %#v", *m.DeleteKnowledgeBaseFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteKnowledgeBaseFile != nil && afterDeleteKnowledgeBaseFileCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteKnowledgeBaseFile")
	}

	if !m.DeleteKnowledgeBaseFileMock.invocationsDone() && afterDeleteKnowledgeBaseFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteKnowledgeBaseFile but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteKnowledgeBaseFileMock.expectedInvocations), afterDeleteKnowledgeBaseFileCounter)
	}
}

type mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation
	expectations       []*RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation

	callArgs []*RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation specifies expectation struct of the RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage
type RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParams
	paramPtrs *RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParamPtrs
	results   *RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageResults
	Counter   uint64
}

// RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParams contains parameters of the RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage
type RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParams struct {
	ctx     context.Context
	fileUID uuid.UUID
}

// RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParamPtrs contains pointers to parameters of the RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage
type RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParamPtrs struct {
	ctx     *context.Context
	fileUID *uuid.UUID
}

// RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageResults contains results of the RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage
type RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage) Expect(ctx context.Context, fileUID uuid.UUID) *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage {
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation{}
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.paramPtrs != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by ExpectParams functions")
	}

	mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.params = &RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParams{ctx, fileUID}
	for _, e := range mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectations {
		if minimock.Equal(e.params, mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.params) {
			mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.params)
		}
	}

	return mmDeleteKnowledgeBaseFileAndDecreaseUsage
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage {
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation{}
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.params != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by Expect")
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.paramPtrs = &RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParamPtrs{}
	}
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteKnowledgeBaseFileAndDecreaseUsage
}

// ExpectFileUIDParam2 sets up expected param fileUID for RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage) ExpectFileUIDParam2(fileUID uuid.UUID) *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage {
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation{}
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.params != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by Expect")
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.paramPtrs = &RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParamPtrs{}
	}
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.paramPtrs.fileUID = &fileUID

	return mmDeleteKnowledgeBaseFileAndDecreaseUsage
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage) Inspect(f func(ctx context.Context, fileUID uuid.UUID)) *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage {
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.inspectFuncDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage")
	}

	mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.inspectFuncDeleteKnowledgeBaseFileAndDecreaseUsage = f

	return mmDeleteKnowledgeBaseFileAndDecreaseUsage
}

// Return sets up results that will be returned by RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage) Return(err error) *RepositoryIMock {
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation{mock: mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock}
	}
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.results = &RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageResults{err}
	return mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock
}

// Set uses given function f to mock the RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage method
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage) Set(f func(ctx context.Context, fileUID uuid.UUID) (err error)) *RepositoryIMock {
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage method")
	}

	if len(mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectations) > 0 {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage method")
	}

	mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsage = f
	return mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock
}

// When sets expectation for the RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage which will trigger the result defined by the following
// Then helper
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage) When(ctx context.Context, fileUID uuid.UUID) *RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation {
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation{
		mock:   mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock,
		params: &RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParams{ctx, fileUID},
	}
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectations = append(mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteKnowledgeBaseFileAndDecreaseUsage should be invoked
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage) Times(n uint64) *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage {
	if n == 0 {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("Times of RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectedInvocations, n)
	return mmDeleteKnowledgeBaseFileAndDecreaseUsage
}

func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage) invocationsDone() bool {
	if len(mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectations) == 0 && mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation == nil && mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteKnowledgeBaseFileAndDecreaseUsage implements repository.RepositoryI
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *RepositoryIMock) DeleteKnowledgeBaseFileAndDecreaseUsage(ctx context.Context, fileUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.beforeDeleteKnowledgeBaseFileAndDecreaseUsageCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter, 1)

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.inspectFuncDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.inspectFuncDeleteKnowledgeBaseFileAndDecreaseUsage(ctx, fileUID)
	}

	mm_params := RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParams{ctx, fileUID}

	// Record call args
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.mutex.Lock()
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.callArgs = append(mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.callArgs, &mm_params)
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.mutex.Unlock()

	for _, e := range mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParams{ctx, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteKnowledgeBaseFileAndDecreaseUsage.t.Errorf("RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmDeleteKnowledgeBaseFileAndDecreaseUsage.t.Errorf("RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage got unexpected parameter fileUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteKnowledgeBaseFileAndDecreaseUsage.t.Errorf("RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteKnowledgeBaseFileAndDecreaseUsage.t.Fatal("No results are set for the RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage")
		}
		return (*mm_results).err
	}
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.funcDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		return mmDeleteKnowledgeBaseFileAndDecreaseUsage.funcDeleteKnowledgeBaseFileAndDecreaseUsage(ctx, fileUID)
	}
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.t.Fatalf("Unexpected call to RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage. %v %v", ctx, fileUID)
	return
}

// DeleteKnowledgeBaseFileAndDecreaseUsageAfterCounter returns a count of finished RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage invocations
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *RepositoryIMock) DeleteKnowledgeBaseFileAndDecreaseUsageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter)
}

// DeleteKnowledgeBaseFileAndDecreaseUsageBeforeCounter returns a count of RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage invocations
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *RepositoryIMock) DeleteKnowledgeBaseFileAndDecreaseUsageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.beforeDeleteKnowledgeBaseFileAndDecreaseUsageCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsage) Calls() []*RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParams {
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteKnowledgeBaseFileAndDecreaseUsageParams, len(mmDeleteKnowledgeBaseFileAndDecreaseUsage.callArgs))
	copy(argCopy, mmDeleteKnowledgeBaseFileAndDecreaseUsage.callArgs)

	mmDeleteKnowledgeBaseFileAndDecreaseUsage.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteKnowledgeBaseFileAndDecreaseUsageDone returns true if the count of the DeleteKnowledgeBaseFileAndDecreaseUsage invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteKnowledgeBaseFileAndDecreaseUsageDone() bool {
	for _, e := range m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.invocationsDone()
}

// MinimockDeleteKnowledgeBaseFileAndDecreaseUsageInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteKnowledgeBaseFileAndDecreaseUsageInspect() {
	for _, e := range m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage with params: %#v", *e.params)
		}
	}

	afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter := mm_atomic.LoadUint64(&m.afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation != nil && afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter < 1 {
		if m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage with params: %#v", *m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteKnowledgeBaseFileAndDecreaseUsage != nil && afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage")
	}

	if !m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.invocationsDone() && afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteKnowledgeBaseFileAndDecreaseUsage but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.expectedInvocations), afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter)
	}
}

type mRepositoryIMockDeleteObject struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteObjectExpectation
	expectations       []*RepositoryIMockDeleteObjectExpectation

	callArgs []*RepositoryIMockDeleteObjectParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteObjectExpectation specifies expectation struct of the RepositoryI.DeleteObject
type RepositoryIMockDeleteObjectExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteObjectParams
	paramPtrs *RepositoryIMockDeleteObjectParamPtrs
	results   *RepositoryIMockDeleteObjectResults
	Counter   uint64
}

// RepositoryIMockDeleteObjectParams contains parameters of the RepositoryI.DeleteObject
type RepositoryIMockDeleteObjectParams struct {
	ctx context.Context
	uid uuid.UUID
}

// RepositoryIMockDeleteObjectParamPtrs contains pointers to parameters of the RepositoryI.DeleteObject
type RepositoryIMockDeleteObjectParamPtrs struct {
	ctx *context.Context
	uid *uuid.UUID
}

// RepositoryIMockDeleteObjectResults contains results of the RepositoryI.DeleteObject
type RepositoryIMockDeleteObjectResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteObject
func (mmDeleteObject *mRepositoryIMockDeleteObject) Expect(ctx context.Context, uid uuid.UUID) *mRepositoryIMockDeleteObject {
	if mmDeleteObject.mock.funcDeleteObject != nil {
		mmDeleteObject.mock.t.Fatalf("RepositoryIMock.DeleteObject mock is already set by Set")
	}

	if mmDeleteObject.defaultExpectation == nil {
		mmDeleteObject.defaultExpectation = &RepositoryIMockDeleteObjectExpectation{}
	}

	if mmDeleteObject.defaultExpectation.paramPtrs != nil {
		mmDeleteObject.mock.t.Fatalf("RepositoryIMock.DeleteObject mock is already set by ExpectParams functions")
	}

	mmDeleteObject.defaultExpectation.params = &RepositoryIMockDeleteObjectParams{ctx, uid}
	for _, e := range mmDeleteObject.expectations {
		if minimock.Equal(e.params, mmDeleteObject.defaultExpectation.params) {
			mmDeleteObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteObject.defaultExpectation.params)
		}
	}

	return mmDeleteObject
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteObject
func (mmDeleteObject *mRepositoryIMockDeleteObject) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteObject {
	if mmDeleteObject.mock.funcDeleteObject != nil {
		mmDeleteObject.mock.t.Fatalf("RepositoryIMock.DeleteObject mock is already set by Set")
	}

	if mmDeleteObject.defaultExpectation == nil {
		mmDeleteObject.defaultExpectation = &RepositoryIMockDeleteObjectExpectation{}
	}

	if mmDeleteObject.defaultExpectation.params != nil {
		mmDeleteObject.mock.t.Fatalf("RepositoryIMock.DeleteObject mock is already set by Expect")
	}

	if mmDeleteObject.defaultExpectation.paramPtrs == nil {
		mmDeleteObject.defaultExpectation.paramPtrs = &RepositoryIMockDeleteObjectParamPtrs{}
	}
	mmDeleteObject.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteObject
}

// ExpectUidParam2 sets up expected param uid for RepositoryI.DeleteObject
func (mmDeleteObject *mRepositoryIMockDeleteObject) ExpectUidParam2(uid uuid.UUID) *mRepositoryIMockDeleteObject {
	if mmDeleteObject.mock.funcDeleteObject != nil {
		mmDeleteObject.mock.t.Fatalf("RepositoryIMock.DeleteObject mock is already set by Set")
	}

	if mmDeleteObject.defaultExpectation == nil {
		mmDeleteObject.defaultExpectation = &RepositoryIMockDeleteObjectExpectation{}
	}

	if mmDeleteObject.defaultExpectation.params != nil {
		mmDeleteObject.mock.t.Fatalf("RepositoryIMock.DeleteObject mock is already set by Expect")
	}

	if mmDeleteObject.defaultExpectation.paramPtrs == nil {
		mmDeleteObject.defaultExpectation.paramPtrs = &RepositoryIMockDeleteObjectParamPtrs{}
	}
	mmDeleteObject.defaultExpectation.paramPtrs.uid = &uid

	return mmDeleteObject
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteObject
func (mmDeleteObject *mRepositoryIMockDeleteObject) Inspect(f func(ctx context.Context, uid uuid.UUID)) *mRepositoryIMockDeleteObject {
	if mmDeleteObject.mock.inspectFuncDeleteObject != nil {
		mmDeleteObject.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteObject")
	}

	mmDeleteObject.mock.inspectFuncDeleteObject = f

	return mmDeleteObject
}

// Return sets up results that will be returned by RepositoryI.DeleteObject
func (mmDeleteObject *mRepositoryIMockDeleteObject) Return(err error) *RepositoryIMock {
	if mmDeleteObject.mock.funcDeleteObject != nil {
		mmDeleteObject.mock.t.Fatalf("RepositoryIMock.DeleteObject mock is already set by Set")
	}

	if mmDeleteObject.defaultExpectation == nil {
		mmDeleteObject.defaultExpectation = &RepositoryIMockDeleteObjectExpectation{mock: mmDeleteObject.mock}
	}
	mmDeleteObject.defaultExpectation.results = &RepositoryIMockDeleteObjectResults{err}
	return mmDeleteObject.mock
}

// Set uses given function f to mock the RepositoryI.DeleteObject method
func (mmDeleteObject *mRepositoryIMockDeleteObject) Set(f func(ctx context.Context, uid uuid.UUID) (err error)) *RepositoryIMock {
	if mmDeleteObject.defaultExpectation != nil {
		mmDeleteObject.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteObject method")
	}

	if len(mmDeleteObject.expectations) > 0 {
		mmDeleteObject.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteObject method")
	}

	mmDeleteObject.mock.funcDeleteObject = f
	return mmDeleteObject.mock
}

// When sets expectation for the RepositoryI.DeleteObject which will trigger the result defined by the following
// Then helper
func (mmDeleteObject *mRepositoryIMockDeleteObject) When(ctx context.Context, uid uuid.UUID) *RepositoryIMockDeleteObjectExpectation {
	if mmDeleteObject.mock.funcDeleteObject != nil {
		mmDeleteObject.mock.t.Fatalf("RepositoryIMock.DeleteObject mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteObjectExpectation{
		mock:   mmDeleteObject.mock,
		params: &RepositoryIMockDeleteObjectParams{ctx, uid},
	}
	mmDeleteObject.expectations = append(mmDeleteObject.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteObject return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteObjectExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteObjectResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteObject should be invoked
func (mmDeleteObject *mRepositoryIMockDeleteObject) Times(n uint64) *mRepositoryIMockDeleteObject {
	if n == 0 {
		mmDeleteObject.mock.t.Fatalf("Times of RepositoryIMock.DeleteObject mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteObject.expectedInvocations, n)
	return mmDeleteObject
}

func (mmDeleteObject *mRepositoryIMockDeleteObject) invocationsDone() bool {
	if len(mmDeleteObject.expectations) == 0 && mmDeleteObject.defaultExpectation == nil && mmDeleteObject.mock.funcDeleteObject == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteObject.mock.afterDeleteObjectCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteObject.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteObject implements repository.RepositoryI
func (mmDeleteObject *RepositoryIMock) DeleteObject(ctx context.Context, uid uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteObject.beforeDeleteObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteObject.afterDeleteObjectCounter, 1)

	if mmDeleteObject.inspectFuncDeleteObject != nil {
		mmDeleteObject.inspectFuncDeleteObject(ctx, uid)
	}

	mm_params := RepositoryIMockDeleteObjectParams{ctx, uid}

	// Record call args
	mmDeleteObject.DeleteObjectMock.mutex.Lock()
	mmDeleteObject.DeleteObjectMock.callArgs = append(mmDeleteObject.DeleteObjectMock.callArgs, &mm_params)
	mmDeleteObject.DeleteObjectMock.mutex.Unlock()

	for _, e := range mmDeleteObject.DeleteObjectMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteObject.DeleteObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteObject.DeleteObjectMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteObject.DeleteObjectMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteObject.DeleteObjectMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteObjectParams{ctx, uid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteObject.t.Errorf("RepositoryIMock.DeleteObject got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmDeleteObject.t.Errorf("RepositoryIMock.DeleteObject got unexpected parameter uid, want: %#v, got: %#v%s\n", *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteObject.t.Errorf("RepositoryIMock.DeleteObject got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteObject.DeleteObjectMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteObject.t.Fatal("No results are set for the RepositoryIMock.DeleteObject")
		}
		return (*mm_results).err
	}
	if mmDeleteObject.funcDeleteObject != nil {
		return mmDeleteObject.funcDeleteObject(ctx, uid)
	}
	mmDeleteObject.t.Fatalf("Unexpected call to RepositoryIMock.DeleteObject. %v %v", ctx, uid)
	return
}

// DeleteObjectAfterCounter returns a count of finished RepositoryIMock.DeleteObject invocations
func (mmDeleteObject *RepositoryIMock) DeleteObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteObject.afterDeleteObjectCounter)
}

// DeleteObjectBeforeCounter returns a count of RepositoryIMock.DeleteObject invocations
func (mmDeleteObject *RepositoryIMock) DeleteObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteObject.beforeDeleteObjectCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteObject *mRepositoryIMockDeleteObject) Calls() []*RepositoryIMockDeleteObjectParams {
	mmDeleteObject.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteObjectParams, len(mmDeleteObject.callArgs))
	copy(argCopy, mmDeleteObject.callArgs)

	mmDeleteObject.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteObjectDone returns true if the count of the DeleteObject invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteObjectDone() bool {
	for _, e := range m.DeleteObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteObjectMock.invocationsDone()
}

// MinimockDeleteObjectInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteObjectInspect() {
	for _, e := range m.DeleteObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteObject with params: %#v", *e.params)
		}
	}

	afterDeleteObjectCounter := mm_atomic.LoadUint64(&m.afterDeleteObjectCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteObjectMock.defaultExpectation != nil && afterDeleteObjectCounter < 1 {
		if m.DeleteObjectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteObject")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteObject with params: %#v", *m.DeleteObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteObject != nil && afterDeleteObjectCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteObject")
	}

	if !m.DeleteObjectMock.invocationsDone() && afterDeleteObjectCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteObject but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteObjectMock.expectedInvocations), afterDeleteObjectCounter)
	}
}

type mRepositoryIMockDeleteObjectURL struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteObjectURLExpectation
	expectations       []*RepositoryIMockDeleteObjectURLExpectation

	callArgs []*RepositoryIMockDeleteObjectURLParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteObjectURLExpectation specifies expectation struct of the RepositoryI.DeleteObjectURL
type RepositoryIMockDeleteObjectURLExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteObjectURLParams
	paramPtrs *RepositoryIMockDeleteObjectURLParamPtrs
	results   *RepositoryIMockDeleteObjectURLResults
	Counter   uint64
}

// RepositoryIMockDeleteObjectURLParams contains parameters of the RepositoryI.DeleteObjectURL
type RepositoryIMockDeleteObjectURLParams struct {
	ctx context.Context
	uid uuid.UUID
}

// RepositoryIMockDeleteObjectURLParamPtrs contains pointers to parameters of the RepositoryI.DeleteObjectURL
type RepositoryIMockDeleteObjectURLParamPtrs struct {
	ctx *context.Context
	uid *uuid.UUID
}

// RepositoryIMockDeleteObjectURLResults contains results of the RepositoryI.DeleteObjectURL
type RepositoryIMockDeleteObjectURLResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteObjectURL
func (mmDeleteObjectURL *mRepositoryIMockDeleteObjectURL) Expect(ctx context.Context, uid uuid.UUID) *mRepositoryIMockDeleteObjectURL {
	if mmDeleteObjectURL.mock.funcDeleteObjectURL != nil {
		mmDeleteObjectURL.mock.t.Fatalf("RepositoryIMock.DeleteObjectURL mock is already set by Set")
	}

	if mmDeleteObjectURL.defaultExpectation == nil {
		mmDeleteObjectURL.defaultExpectation = &RepositoryIMockDeleteObjectURLExpectation{}
	}

	if mmDeleteObjectURL.defaultExpectation.paramPtrs != nil {
		mmDeleteObjectURL.mock.t.Fatalf("RepositoryIMock.DeleteObjectURL mock is already set by ExpectParams functions")
	}

	mmDeleteObjectURL.defaultExpectation.params = &RepositoryIMockDeleteObjectURLParams{ctx, uid}
	for _, e := range mmDeleteObjectURL.expectations {
		if minimock.Equal(e.params, mmDeleteObjectURL.defaultExpectation.params) {
			mmDeleteObjectURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteObjectURL.defaultExpectation.params)
		}
	}

	return mmDeleteObjectURL
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteObjectURL
func (mmDeleteObjectURL *mRepositoryIMockDeleteObjectURL) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteObjectURL {
	if mmDeleteObjectURL.mock.funcDeleteObjectURL != nil {
		mmDeleteObjectURL.mock.t.Fatalf("RepositoryIMock.DeleteObjectURL mock is already set by Set")
	}

	if mmDeleteObjectURL.defaultExpectation == nil {
		mmDeleteObjectURL.defaultExpectation = &RepositoryIMockDeleteObjectURLExpectation{}
	}

	if mmDeleteObjectURL.defaultExpectation.params != nil {
		mmDeleteObjectURL.mock.t.Fatalf("RepositoryIMock.DeleteObjectURL mock is already set by Expect")
	}

	if mmDeleteObjectURL.defaultExpectation.paramPtrs == nil {
		mmDeleteObjectURL.defaultExpectation.paramPtrs = &RepositoryIMockDeleteObjectURLParamPtrs{}
	}
	mmDeleteObjectURL.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteObjectURL
}

// ExpectUidParam2 sets up expected param uid for RepositoryI.DeleteObjectURL
func (mmDeleteObjectURL *mRepositoryIMockDeleteObjectURL) ExpectUidParam2(uid uuid.UUID) *mRepositoryIMockDeleteObjectURL {
	if mmDeleteObjectURL.mock.funcDeleteObjectURL != nil {
		mmDeleteObjectURL.mock.t.Fatalf("RepositoryIMock.DeleteObjectURL mock is already set by Set")
	}

	if mmDeleteObjectURL.defaultExpectation == nil {
		mmDeleteObjectURL.defaultExpectation = &RepositoryIMockDeleteObjectURLExpectation{}
	}

	if mmDeleteObjectURL.defaultExpectation.params != nil {
		mmDeleteObjectURL.mock.t.Fatalf("RepositoryIMock.DeleteObjectURL mock is already set by Expect")
	}

	if mmDeleteObjectURL.defaultExpectation.paramPtrs == nil {
		mmDeleteObjectURL.defaultExpectation.paramPtrs = &RepositoryIMockDeleteObjectURLParamPtrs{}
	}
	mmDeleteObjectURL.defaultExpectation.paramPtrs.uid = &uid

	return mmDeleteObjectURL
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteObjectURL
func (mmDeleteObjectURL *mRepositoryIMockDeleteObjectURL) Inspect(f func(ctx context.Context, uid uuid.UUID)) *mRepositoryIMockDeleteObjectURL {
	if mmDeleteObjectURL.mock.inspectFuncDeleteObjectURL != nil {
		mmDeleteObjectURL.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteObjectURL")
	}

	mmDeleteObjectURL.mock.inspectFuncDeleteObjectURL = f

	return mmDeleteObjectURL
}

// Return sets up results that will be returned by RepositoryI.DeleteObjectURL
func (mmDeleteObjectURL *mRepositoryIMockDeleteObjectURL) Return(err error) *RepositoryIMock {
	if mmDeleteObjectURL.mock.funcDeleteObjectURL != nil {
		mmDeleteObjectURL.mock.t.Fatalf("RepositoryIMock.DeleteObjectURL mock is already set by Set")
	}

	if mmDeleteObjectURL.defaultExpectation == nil {
		mmDeleteObjectURL.defaultExpectation = &RepositoryIMockDeleteObjectURLExpectation{mock: mmDeleteObjectURL.mock}
	}
	mmDeleteObjectURL.defaultExpectation.results = &RepositoryIMockDeleteObjectURLResults{err}
	return mmDeleteObjectURL.mock
}

// Set uses given function f to mock the RepositoryI.DeleteObjectURL method
func (mmDeleteObjectURL *mRepositoryIMockDeleteObjectURL) Set(f func(ctx context.Context, uid uuid.UUID) (err error)) *RepositoryIMock {
	if mmDeleteObjectURL.defaultExpectation != nil {
		mmDeleteObjectURL.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteObjectURL method")
	}

	if len(mmDeleteObjectURL.expectations) > 0 {
		mmDeleteObjectURL.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteObjectURL method")
	}

	mmDeleteObjectURL.mock.funcDeleteObjectURL = f
	return mmDeleteObjectURL.mock
}

// When sets expectation for the RepositoryI.DeleteObjectURL which will trigger the result defined by the following
// Then helper
func (mmDeleteObjectURL *mRepositoryIMockDeleteObjectURL) When(ctx context.Context, uid uuid.UUID) *RepositoryIMockDeleteObjectURLExpectation {
	if mmDeleteObjectURL.mock.funcDeleteObjectURL != nil {
		mmDeleteObjectURL.mock.t.Fatalf("RepositoryIMock.DeleteObjectURL mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteObjectURLExpectation{
		mock:   mmDeleteObjectURL.mock,
		params: &RepositoryIMockDeleteObjectURLParams{ctx, uid},
	}
	mmDeleteObjectURL.expectations = append(mmDeleteObjectURL.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteObjectURL return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteObjectURLExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteObjectURLResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteObjectURL should be invoked
func (mmDeleteObjectURL *mRepositoryIMockDeleteObjectURL) Times(n uint64) *mRepositoryIMockDeleteObjectURL {
	if n == 0 {
		mmDeleteObjectURL.mock.t.Fatalf("Times of RepositoryIMock.DeleteObjectURL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteObjectURL.expectedInvocations, n)
	return mmDeleteObjectURL
}

func (mmDeleteObjectURL *mRepositoryIMockDeleteObjectURL) invocationsDone() bool {
	if len(mmDeleteObjectURL.expectations) == 0 && mmDeleteObjectURL.defaultExpectation == nil && mmDeleteObjectURL.mock.funcDeleteObjectURL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteObjectURL.mock.afterDeleteObjectURLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteObjectURL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteObjectURL implements repository.RepositoryI
func (mmDeleteObjectURL *RepositoryIMock) DeleteObjectURL(ctx context.Context, uid uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteObjectURL.beforeDeleteObjectURLCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteObjectURL.afterDeleteObjectURLCounter, 1)

	if mmDeleteObjectURL.inspectFuncDeleteObjectURL != nil {
		mmDeleteObjectURL.inspectFuncDeleteObjectURL(ctx, uid)
	}

	mm_params := RepositoryIMockDeleteObjectURLParams{ctx, uid}

	// Record call args
	mmDeleteObjectURL.DeleteObjectURLMock.mutex.Lock()
	mmDeleteObjectURL.DeleteObjectURLMock.callArgs = append(mmDeleteObjectURL.DeleteObjectURLMock.callArgs, &mm_params)
	mmDeleteObjectURL.DeleteObjectURLMock.mutex.Unlock()

	for _, e := range mmDeleteObjectURL.DeleteObjectURLMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteObjectURL.DeleteObjectURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteObjectURL.DeleteObjectURLMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteObjectURL.DeleteObjectURLMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteObjectURL.DeleteObjectURLMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteObjectURLParams{ctx, uid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteObjectURL.t.Errorf("RepositoryIMock.DeleteObjectURL got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmDeleteObjectURL.t.Errorf("RepositoryIMock.DeleteObjectURL got unexpected parameter uid, want: %#v, got: %#v%s\n", *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteObjectURL.t.Errorf("RepositoryIMock.DeleteObjectURL got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteObjectURL.DeleteObjectURLMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteObjectURL.t.Fatal("No results are set for the RepositoryIMock.DeleteObjectURL")
		}
		return (*mm_results).err
	}
	if mmDeleteObjectURL.funcDeleteObjectURL != nil {
		return mmDeleteObjectURL.funcDeleteObjectURL(ctx, uid)
	}
	mmDeleteObjectURL.t.Fatalf("Unexpected call to RepositoryIMock.DeleteObjectURL. %v %v", ctx, uid)
	return
}

// DeleteObjectURLAfterCounter returns a count of finished RepositoryIMock.DeleteObjectURL invocations
func (mmDeleteObjectURL *RepositoryIMock) DeleteObjectURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteObjectURL.afterDeleteObjectURLCounter)
}

// DeleteObjectURLBeforeCounter returns a count of RepositoryIMock.DeleteObjectURL invocations
func (mmDeleteObjectURL *RepositoryIMock) DeleteObjectURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteObjectURL.beforeDeleteObjectURLCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteObjectURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteObjectURL *mRepositoryIMockDeleteObjectURL) Calls() []*RepositoryIMockDeleteObjectURLParams {
	mmDeleteObjectURL.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteObjectURLParams, len(mmDeleteObjectURL.callArgs))
	copy(argCopy, mmDeleteObjectURL.callArgs)

	mmDeleteObjectURL.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteObjectURLDone returns true if the count of the DeleteObjectURL invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteObjectURLDone() bool {
	for _, e := range m.DeleteObjectURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteObjectURLMock.invocationsDone()
}

// MinimockDeleteObjectURLInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteObjectURLInspect() {
	for _, e := range m.DeleteObjectURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteObjectURL with params: %#v", *e.params)
		}
	}

	afterDeleteObjectURLCounter := mm_atomic.LoadUint64(&m.afterDeleteObjectURLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteObjectURLMock.defaultExpectation != nil && afterDeleteObjectURLCounter < 1 {
		if m.DeleteObjectURLMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteObjectURL")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteObjectURL with params: %#v", *m.DeleteObjectURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteObjectURL != nil && afterDeleteObjectURLCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteObjectURL")
	}

	if !m.DeleteObjectURLMock.invocationsDone() && afterDeleteObjectURLCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteObjectURL but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteObjectURLMock.expectedInvocations), afterDeleteObjectURLCounter)
	}
}

type mRepositoryIMockDeleteRepositoryTag struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteRepositoryTagExpectation
	expectations       []*RepositoryIMockDeleteRepositoryTagExpectation

	callArgs []*RepositoryIMockDeleteRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteRepositoryTagExpectation specifies expectation struct of the RepositoryI.DeleteRepositoryTag
type RepositoryIMockDeleteRepositoryTagExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteRepositoryTagParams
	paramPtrs *RepositoryIMockDeleteRepositoryTagParamPtrs
	results   *RepositoryIMockDeleteRepositoryTagResults
	Counter   uint64
}

// RepositoryIMockDeleteRepositoryTagParams contains parameters of the RepositoryI.DeleteRepositoryTag
type RepositoryIMockDeleteRepositoryTagParams struct {
	ctx context.Context
	s1  string
}

// RepositoryIMockDeleteRepositoryTagParamPtrs contains pointers to parameters of the RepositoryI.DeleteRepositoryTag
type RepositoryIMockDeleteRepositoryTagParamPtrs struct {
	ctx *context.Context
	s1  *string
}

// RepositoryIMockDeleteRepositoryTagResults contains results of the RepositoryI.DeleteRepositoryTag
type RepositoryIMockDeleteRepositoryTagResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) Expect(ctx context.Context, s1 string) *mRepositoryIMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryIMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &RepositoryIMockDeleteRepositoryTagExpectation{}
	}

	if mmDeleteRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryIMock.DeleteRepositoryTag mock is already set by ExpectParams functions")
	}

	mmDeleteRepositoryTag.defaultExpectation.params = &RepositoryIMockDeleteRepositoryTagParams{ctx, s1}
	for _, e := range mmDeleteRepositoryTag.expectations {
		if minimock.Equal(e.params, mmDeleteRepositoryTag.defaultExpectation.params) {
			mmDeleteRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteRepositoryTag.defaultExpectation.params)
		}
	}

	return mmDeleteRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryIMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &RepositoryIMockDeleteRepositoryTagExpectation{}
	}

	if mmDeleteRepositoryTag.defaultExpectation.params != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryIMock.DeleteRepositoryTag mock is already set by Expect")
	}

	if mmDeleteRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmDeleteRepositoryTag.defaultExpectation.paramPtrs = &RepositoryIMockDeleteRepositoryTagParamPtrs{}
	}
	mmDeleteRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteRepositoryTag
}

// ExpectS1Param2 sets up expected param s1 for RepositoryI.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) ExpectS1Param2(s1 string) *mRepositoryIMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryIMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &RepositoryIMockDeleteRepositoryTagExpectation{}
	}

	if mmDeleteRepositoryTag.defaultExpectation.params != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryIMock.DeleteRepositoryTag mock is already set by Expect")
	}

	if mmDeleteRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmDeleteRepositoryTag.defaultExpectation.paramPtrs = &RepositoryIMockDeleteRepositoryTagParamPtrs{}
	}
	mmDeleteRepositoryTag.defaultExpectation.paramPtrs.s1 = &s1

	return mmDeleteRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) Inspect(f func(ctx context.Context, s1 string)) *mRepositoryIMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.inspectFuncDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteRepositoryTag")
	}

	mmDeleteRepositoryTag.mock.inspectFuncDeleteRepositoryTag = f

	return mmDeleteRepositoryTag
}

// Return sets up results that will be returned by RepositoryI.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) Return(err error) *RepositoryIMock {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryIMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &RepositoryIMockDeleteRepositoryTagExpectation{mock: mmDeleteRepositoryTag.mock}
	}
	mmDeleteRepositoryTag.defaultExpectation.results = &RepositoryIMockDeleteRepositoryTagResults{err}
	return mmDeleteRepositoryTag.mock
}

// Set uses given function f to mock the RepositoryI.DeleteRepositoryTag method
func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) Set(f func(ctx context.Context, s1 string) (err error)) *RepositoryIMock {
	if mmDeleteRepositoryTag.defaultExpectation != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteRepositoryTag method")
	}

	if len(mmDeleteRepositoryTag.expectations) > 0 {
		mmDeleteRepositoryTag.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteRepositoryTag method")
	}

	mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag = f
	return mmDeleteRepositoryTag.mock
}

// When sets expectation for the RepositoryI.DeleteRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) When(ctx context.Context, s1 string) *RepositoryIMockDeleteRepositoryTagExpectation {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryIMock.DeleteRepositoryTag mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteRepositoryTagExpectation{
		mock:   mmDeleteRepositoryTag.mock,
		params: &RepositoryIMockDeleteRepositoryTagParams{ctx, s1},
	}
	mmDeleteRepositoryTag.expectations = append(mmDeleteRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteRepositoryTag return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteRepositoryTagExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteRepositoryTagResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteRepositoryTag should be invoked
func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) Times(n uint64) *mRepositoryIMockDeleteRepositoryTag {
	if n == 0 {
		mmDeleteRepositoryTag.mock.t.Fatalf("Times of RepositoryIMock.DeleteRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteRepositoryTag.expectedInvocations, n)
	return mmDeleteRepositoryTag
}

func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) invocationsDone() bool {
	if len(mmDeleteRepositoryTag.expectations) == 0 && mmDeleteRepositoryTag.defaultExpectation == nil && mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteRepositoryTag.mock.afterDeleteRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteRepositoryTag implements repository.RepositoryI
func (mmDeleteRepositoryTag *RepositoryIMock) DeleteRepositoryTag(ctx context.Context, s1 string) (err error) {
	mm_atomic.AddUint64(&mmDeleteRepositoryTag.beforeDeleteRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteRepositoryTag.afterDeleteRepositoryTagCounter, 1)

	if mmDeleteRepositoryTag.inspectFuncDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.inspectFuncDeleteRepositoryTag(ctx, s1)
	}

	mm_params := RepositoryIMockDeleteRepositoryTagParams{ctx, s1}

	// Record call args
	mmDeleteRepositoryTag.DeleteRepositoryTagMock.mutex.Lock()
	mmDeleteRepositoryTag.DeleteRepositoryTagMock.callArgs = append(mmDeleteRepositoryTag.DeleteRepositoryTagMock.callArgs, &mm_params)
	mmDeleteRepositoryTag.DeleteRepositoryTagMock.mutex.Unlock()

	for _, e := range mmDeleteRepositoryTag.DeleteRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteRepositoryTagParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteRepositoryTag.t.Errorf("RepositoryIMock.DeleteRepositoryTag got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmDeleteRepositoryTag.t.Errorf("RepositoryIMock.DeleteRepositoryTag got unexpected parameter s1, want: %#v, got: %#v%s\n", *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteRepositoryTag.t.Errorf("RepositoryIMock.DeleteRepositoryTag got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteRepositoryTag.t.Fatal("No results are set for the RepositoryIMock.DeleteRepositoryTag")
		}
		return (*mm_results).err
	}
	if mmDeleteRepositoryTag.funcDeleteRepositoryTag != nil {
		return mmDeleteRepositoryTag.funcDeleteRepositoryTag(ctx, s1)
	}
	mmDeleteRepositoryTag.t.Fatalf("Unexpected call to RepositoryIMock.DeleteRepositoryTag. %v %v", ctx, s1)
	return
}

// DeleteRepositoryTagAfterCounter returns a count of finished RepositoryIMock.DeleteRepositoryTag invocations
func (mmDeleteRepositoryTag *RepositoryIMock) DeleteRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRepositoryTag.afterDeleteRepositoryTagCounter)
}

// DeleteRepositoryTagBeforeCounter returns a count of RepositoryIMock.DeleteRepositoryTag invocations
func (mmDeleteRepositoryTag *RepositoryIMock) DeleteRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRepositoryTag.beforeDeleteRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) Calls() []*RepositoryIMockDeleteRepositoryTagParams {
	mmDeleteRepositoryTag.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteRepositoryTagParams, len(mmDeleteRepositoryTag.callArgs))
	copy(argCopy, mmDeleteRepositoryTag.callArgs)

	mmDeleteRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteRepositoryTagDone returns true if the count of the DeleteRepositoryTag invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteRepositoryTagDone() bool {
	for _, e := range m.DeleteRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteRepositoryTagMock.invocationsDone()
}

// MinimockDeleteRepositoryTagInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteRepositoryTagInspect() {
	for _, e := range m.DeleteRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteRepositoryTag with params: %#v", *e.params)
		}
	}

	afterDeleteRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterDeleteRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteRepositoryTagMock.defaultExpectation != nil && afterDeleteRepositoryTagCounter < 1 {
		if m.DeleteRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteRepositoryTag")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteRepositoryTag with params: %#v", *m.DeleteRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteRepositoryTag != nil && afterDeleteRepositoryTagCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteRepositoryTag")
	}

	if !m.DeleteRepositoryTagMock.invocationsDone() && afterDeleteRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteRepositoryTag but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteRepositoryTagMock.expectedInvocations), afterDeleteRepositoryTagCounter)
	}
}

type mRepositoryIMockGetChunksByUIDs struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetChunksByUIDsExpectation
	expectations       []*RepositoryIMockGetChunksByUIDsExpectation

	callArgs []*RepositoryIMockGetChunksByUIDsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetChunksByUIDsExpectation specifies expectation struct of the RepositoryI.GetChunksByUIDs
type RepositoryIMockGetChunksByUIDsExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetChunksByUIDsParams
	paramPtrs *RepositoryIMockGetChunksByUIDsParamPtrs
	results   *RepositoryIMockGetChunksByUIDsResults
	Counter   uint64
}

// RepositoryIMockGetChunksByUIDsParams contains parameters of the RepositoryI.GetChunksByUIDs
type RepositoryIMockGetChunksByUIDsParams struct {
	ctx       context.Context
	chunkUIDs []uuid.UUID
}

// RepositoryIMockGetChunksByUIDsParamPtrs contains pointers to parameters of the RepositoryI.GetChunksByUIDs
type RepositoryIMockGetChunksByUIDsParamPtrs struct {
	ctx       *context.Context
	chunkUIDs *[]uuid.UUID
}

// RepositoryIMockGetChunksByUIDsResults contains results of the RepositoryI.GetChunksByUIDs
type RepositoryIMockGetChunksByUIDsResults struct {
	ta1 []mm_repository.TextChunk
	err error
}

// Expect sets up expected params for RepositoryI.GetChunksByUIDs
func (mmGetChunksByUIDs *mRepositoryIMockGetChunksByUIDs) Expect(ctx context.Context, chunkUIDs []uuid.UUID) *mRepositoryIMockGetChunksByUIDs {
	if mmGetChunksByUIDs.mock.funcGetChunksByUIDs != nil {
		mmGetChunksByUIDs.mock.t.Fatalf("RepositoryIMock.GetChunksByUIDs mock is already set by Set")
	}

	if mmGetChunksByUIDs.defaultExpectation == nil {
		mmGetChunksByUIDs.defaultExpectation = &RepositoryIMockGetChunksByUIDsExpectation{}
	}

	if mmGetChunksByUIDs.defaultExpectation.paramPtrs != nil {
		mmGetChunksByUIDs.mock.t.Fatalf("RepositoryIMock.GetChunksByUIDs mock is already set by ExpectParams functions")
	}

	mmGetChunksByUIDs.defaultExpectation.params = &RepositoryIMockGetChunksByUIDsParams{ctx, chunkUIDs}
	for _, e := range mmGetChunksByUIDs.expectations {
		if minimock.Equal(e.params, mmGetChunksByUIDs.defaultExpectation.params) {
			mmGetChunksByUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChunksByUIDs.defaultExpectation.params)
		}
	}

	return mmGetChunksByUIDs
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetChunksByUIDs
func (mmGetChunksByUIDs *mRepositoryIMockGetChunksByUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetChunksByUIDs {
	if mmGetChunksByUIDs.mock.funcGetChunksByUIDs != nil {
		mmGetChunksByUIDs.mock.t.Fatalf("RepositoryIMock.GetChunksByUIDs mock is already set by Set")
	}

	if mmGetChunksByUIDs.defaultExpectation == nil {
		mmGetChunksByUIDs.defaultExpectation = &RepositoryIMockGetChunksByUIDsExpectation{}
	}

	if mmGetChunksByUIDs.defaultExpectation.params != nil {
		mmGetChunksByUIDs.mock.t.Fatalf("RepositoryIMock.GetChunksByUIDs mock is already set by Expect")
	}

	if mmGetChunksByUIDs.defaultExpectation.paramPtrs == nil {
		mmGetChunksByUIDs.defaultExpectation.paramPtrs = &RepositoryIMockGetChunksByUIDsParamPtrs{}
	}
	mmGetChunksByUIDs.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetChunksByUIDs
}

// ExpectChunkUIDsParam2 sets up expected param chunkUIDs for RepositoryI.GetChunksByUIDs
func (mmGetChunksByUIDs *mRepositoryIMockGetChunksByUIDs) ExpectChunkUIDsParam2(chunkUIDs []uuid.UUID) *mRepositoryIMockGetChunksByUIDs {
	if mmGetChunksByUIDs.mock.funcGetChunksByUIDs != nil {
		mmGetChunksByUIDs.mock.t.Fatalf("RepositoryIMock.GetChunksByUIDs mock is already set by Set")
	}

	if mmGetChunksByUIDs.defaultExpectation == nil {
		mmGetChunksByUIDs.defaultExpectation = &RepositoryIMockGetChunksByUIDsExpectation{}
	}

	if mmGetChunksByUIDs.defaultExpectation.params != nil {
		mmGetChunksByUIDs.mock.t.Fatalf("RepositoryIMock.GetChunksByUIDs mock is already set by Expect")
	}

	if mmGetChunksByUIDs.defaultExpectation.paramPtrs == nil {
		mmGetChunksByUIDs.defaultExpectation.paramPtrs = &RepositoryIMockGetChunksByUIDsParamPtrs{}
	}
	mmGetChunksByUIDs.defaultExpectation.paramPtrs.chunkUIDs = &chunkUIDs

	return mmGetChunksByUIDs
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetChunksByUIDs
func (mmGetChunksByUIDs *mRepositoryIMockGetChunksByUIDs) Inspect(f func(ctx context.Context, chunkUIDs []uuid.UUID)) *mRepositoryIMockGetChunksByUIDs {
	if mmGetChunksByUIDs.mock.inspectFuncGetChunksByUIDs != nil {
		mmGetChunksByUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetChunksByUIDs")
	}

	mmGetChunksByUIDs.mock.inspectFuncGetChunksByUIDs = f

	return mmGetChunksByUIDs
}

// Return sets up results that will be returned by RepositoryI.GetChunksByUIDs
func (mmGetChunksByUIDs *mRepositoryIMockGetChunksByUIDs) Return(ta1 []mm_repository.TextChunk, err error) *RepositoryIMock {
	if mmGetChunksByUIDs.mock.funcGetChunksByUIDs != nil {
		mmGetChunksByUIDs.mock.t.Fatalf("RepositoryIMock.GetChunksByUIDs mock is already set by Set")
	}

	if mmGetChunksByUIDs.defaultExpectation == nil {
		mmGetChunksByUIDs.defaultExpectation = &RepositoryIMockGetChunksByUIDsExpectation{mock: mmGetChunksByUIDs.mock}
	}
	mmGetChunksByUIDs.defaultExpectation.results = &RepositoryIMockGetChunksByUIDsResults{ta1, err}
	return mmGetChunksByUIDs.mock
}

// Set uses given function f to mock the RepositoryI.GetChunksByUIDs method
func (mmGetChunksByUIDs *mRepositoryIMockGetChunksByUIDs) Set(f func(ctx context.Context, chunkUIDs []uuid.UUID) (ta1 []mm_repository.TextChunk, err error)) *RepositoryIMock {
	if mmGetChunksByUIDs.defaultExpectation != nil {
		mmGetChunksByUIDs.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetChunksByUIDs method")
	}

	if len(mmGetChunksByUIDs.expectations) > 0 {
		mmGetChunksByUIDs.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetChunksByUIDs method")
	}

	mmGetChunksByUIDs.mock.funcGetChunksByUIDs = f
	return mmGetChunksByUIDs.mock
}

// When sets expectation for the RepositoryI.GetChunksByUIDs which will trigger the result defined by the following
// Then helper
func (mmGetChunksByUIDs *mRepositoryIMockGetChunksByUIDs) When(ctx context.Context, chunkUIDs []uuid.UUID) *RepositoryIMockGetChunksByUIDsExpectation {
	if mmGetChunksByUIDs.mock.funcGetChunksByUIDs != nil {
		mmGetChunksByUIDs.mock.t.Fatalf("RepositoryIMock.GetChunksByUIDs mock is already set by Set")
	}

	expectation := &RepositoryIMockGetChunksByUIDsExpectation{
		mock:   mmGetChunksByUIDs.mock,
		params: &RepositoryIMockGetChunksByUIDsParams{ctx, chunkUIDs},
	}
	mmGetChunksByUIDs.expectations = append(mmGetChunksByUIDs.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetChunksByUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetChunksByUIDsExpectation) Then(ta1 []mm_repository.TextChunk, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetChunksByUIDsResults{ta1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetChunksByUIDs should be invoked
func (mmGetChunksByUIDs *mRepositoryIMockGetChunksByUIDs) Times(n uint64) *mRepositoryIMockGetChunksByUIDs {
	if n == 0 {
		mmGetChunksByUIDs.mock.t.Fatalf("Times of RepositoryIMock.GetChunksByUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetChunksByUIDs.expectedInvocations, n)
	return mmGetChunksByUIDs
}

func (mmGetChunksByUIDs *mRepositoryIMockGetChunksByUIDs) invocationsDone() bool {
	if len(mmGetChunksByUIDs.expectations) == 0 && mmGetChunksByUIDs.defaultExpectation == nil && mmGetChunksByUIDs.mock.funcGetChunksByUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetChunksByUIDs.mock.afterGetChunksByUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetChunksByUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetChunksByUIDs implements repository.RepositoryI
func (mmGetChunksByUIDs *RepositoryIMock) GetChunksByUIDs(ctx context.Context, chunkUIDs []uuid.UUID) (ta1 []mm_repository.TextChunk, err error) {
	mm_atomic.AddUint64(&mmGetChunksByUIDs.beforeGetChunksByUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChunksByUIDs.afterGetChunksByUIDsCounter, 1)

	if mmGetChunksByUIDs.inspectFuncGetChunksByUIDs != nil {
		mmGetChunksByUIDs.inspectFuncGetChunksByUIDs(ctx, chunkUIDs)
	}

	mm_params := RepositoryIMockGetChunksByUIDsParams{ctx, chunkUIDs}

	// Record call args
	mmGetChunksByUIDs.GetChunksByUIDsMock.mutex.Lock()
	mmGetChunksByUIDs.GetChunksByUIDsMock.callArgs = append(mmGetChunksByUIDs.GetChunksByUIDsMock.callArgs, &mm_params)
	mmGetChunksByUIDs.GetChunksByUIDsMock.mutex.Unlock()

	for _, e := range mmGetChunksByUIDs.GetChunksByUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ta1, e.results.err
		}
	}

	if mmGetChunksByUIDs.GetChunksByUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChunksByUIDs.GetChunksByUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChunksByUIDs.GetChunksByUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmGetChunksByUIDs.GetChunksByUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetChunksByUIDsParams{ctx, chunkUIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetChunksByUIDs.t.Errorf("RepositoryIMock.GetChunksByUIDs got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chunkUIDs != nil && !minimock.Equal(*mm_want_ptrs.chunkUIDs, mm_got.chunkUIDs) {
				mmGetChunksByUIDs.t.Errorf("RepositoryIMock.GetChunksByUIDs got unexpected parameter chunkUIDs, want: %#v, got: %#v%s\n", *mm_want_ptrs.chunkUIDs, mm_got.chunkUIDs, minimock.Diff(*mm_want_ptrs.chunkUIDs, mm_got.chunkUIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChunksByUIDs.t.Errorf("RepositoryIMock.GetChunksByUIDs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChunksByUIDs.GetChunksByUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChunksByUIDs.t.Fatal("No results are set for the RepositoryIMock.GetChunksByUIDs")
		}
		return (*mm_results).ta1, (*mm_results).err
	}
	if mmGetChunksByUIDs.funcGetChunksByUIDs != nil {
		return mmGetChunksByUIDs.funcGetChunksByUIDs(ctx, chunkUIDs)
	}
	mmGetChunksByUIDs.t.Fatalf("Unexpected call to RepositoryIMock.GetChunksByUIDs. %v %v", ctx, chunkUIDs)
	return
}

// GetChunksByUIDsAfterCounter returns a count of finished RepositoryIMock.GetChunksByUIDs invocations
func (mmGetChunksByUIDs *RepositoryIMock) GetChunksByUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChunksByUIDs.afterGetChunksByUIDsCounter)
}

// GetChunksByUIDsBeforeCounter returns a count of RepositoryIMock.GetChunksByUIDs invocations
func (mmGetChunksByUIDs *RepositoryIMock) GetChunksByUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChunksByUIDs.beforeGetChunksByUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetChunksByUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChunksByUIDs *mRepositoryIMockGetChunksByUIDs) Calls() []*RepositoryIMockGetChunksByUIDsParams {
	mmGetChunksByUIDs.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetChunksByUIDsParams, len(mmGetChunksByUIDs.callArgs))
	copy(argCopy, mmGetChunksByUIDs.callArgs)

	mmGetChunksByUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockGetChunksByUIDsDone returns true if the count of the GetChunksByUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetChunksByUIDsDone() bool {
	for _, e := range m.GetChunksByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetChunksByUIDsMock.invocationsDone()
}

// MinimockGetChunksByUIDsInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetChunksByUIDsInspect() {
	for _, e := range m.GetChunksByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetChunksByUIDs with params: %#v", *e.params)
		}
	}

	afterGetChunksByUIDsCounter := mm_atomic.LoadUint64(&m.afterGetChunksByUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetChunksByUIDsMock.defaultExpectation != nil && afterGetChunksByUIDsCounter < 1 {
		if m.GetChunksByUIDsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetChunksByUIDs")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetChunksByUIDs with params: %#v", *m.GetChunksByUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChunksByUIDs != nil && afterGetChunksByUIDsCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetChunksByUIDs")
	}

	if !m.GetChunksByUIDsMock.invocationsDone() && afterGetChunksByUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetChunksByUIDs but found %d calls",
			mm_atomic.LoadUint64(&m.GetChunksByUIDsMock.expectedInvocations), afterGetChunksByUIDsCounter)
	}
}

type mRepositoryIMockGetConvertedFileByFileUID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetConvertedFileByFileUIDExpectation
	expectations       []*RepositoryIMockGetConvertedFileByFileUIDExpectation

	callArgs []*RepositoryIMockGetConvertedFileByFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetConvertedFileByFileUIDExpectation specifies expectation struct of the RepositoryI.GetConvertedFileByFileUID
type RepositoryIMockGetConvertedFileByFileUIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetConvertedFileByFileUIDParams
	paramPtrs *RepositoryIMockGetConvertedFileByFileUIDParamPtrs
	results   *RepositoryIMockGetConvertedFileByFileUIDResults
	Counter   uint64
}

// RepositoryIMockGetConvertedFileByFileUIDParams contains parameters of the RepositoryI.GetConvertedFileByFileUID
type RepositoryIMockGetConvertedFileByFileUIDParams struct {
	ctx     context.Context
	fileUID uuid.UUID
}

// RepositoryIMockGetConvertedFileByFileUIDParamPtrs contains pointers to parameters of the RepositoryI.GetConvertedFileByFileUID
type RepositoryIMockGetConvertedFileByFileUIDParamPtrs struct {
	ctx     *context.Context
	fileUID *uuid.UUID
}

// RepositoryIMockGetConvertedFileByFileUIDResults contains results of the RepositoryI.GetConvertedFileByFileUID
type RepositoryIMockGetConvertedFileByFileUIDResults struct {
	cp1 *mm_repository.ConvertedFile
	err error
}

// Expect sets up expected params for RepositoryI.GetConvertedFileByFileUID
func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) Expect(ctx context.Context, fileUID uuid.UUID) *mRepositoryIMockGetConvertedFileByFileUID {
	if mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.GetConvertedFileByFileUID mock is already set by Set")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation == nil {
		mmGetConvertedFileByFileUID.defaultExpectation = &RepositoryIMockGetConvertedFileByFileUIDExpectation{}
	}

	if mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.GetConvertedFileByFileUID mock is already set by ExpectParams functions")
	}

	mmGetConvertedFileByFileUID.defaultExpectation.params = &RepositoryIMockGetConvertedFileByFileUIDParams{ctx, fileUID}
	for _, e := range mmGetConvertedFileByFileUID.expectations {
		if minimock.Equal(e.params, mmGetConvertedFileByFileUID.defaultExpectation.params) {
			mmGetConvertedFileByFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetConvertedFileByFileUID.defaultExpectation.params)
		}
	}

	return mmGetConvertedFileByFileUID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetConvertedFileByFileUID
func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetConvertedFileByFileUID {
	if mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.GetConvertedFileByFileUID mock is already set by Set")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation == nil {
		mmGetConvertedFileByFileUID.defaultExpectation = &RepositoryIMockGetConvertedFileByFileUIDExpectation{}
	}

	if mmGetConvertedFileByFileUID.defaultExpectation.params != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.GetConvertedFileByFileUID mock is already set by Expect")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs = &RepositoryIMockGetConvertedFileByFileUIDParamPtrs{}
	}
	mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetConvertedFileByFileUID
}

// ExpectFileUIDParam2 sets up expected param fileUID for RepositoryI.GetConvertedFileByFileUID
func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) ExpectFileUIDParam2(fileUID uuid.UUID) *mRepositoryIMockGetConvertedFileByFileUID {
	if mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.GetConvertedFileByFileUID mock is already set by Set")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation == nil {
		mmGetConvertedFileByFileUID.defaultExpectation = &RepositoryIMockGetConvertedFileByFileUIDExpectation{}
	}

	if mmGetConvertedFileByFileUID.defaultExpectation.params != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.GetConvertedFileByFileUID mock is already set by Expect")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs = &RepositoryIMockGetConvertedFileByFileUIDParamPtrs{}
	}
	mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs.fileUID = &fileUID

	return mmGetConvertedFileByFileUID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetConvertedFileByFileUID
func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) Inspect(f func(ctx context.Context, fileUID uuid.UUID)) *mRepositoryIMockGetConvertedFileByFileUID {
	if mmGetConvertedFileByFileUID.mock.inspectFuncGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetConvertedFileByFileUID")
	}

	mmGetConvertedFileByFileUID.mock.inspectFuncGetConvertedFileByFileUID = f

	return mmGetConvertedFileByFileUID
}

// Return sets up results that will be returned by RepositoryI.GetConvertedFileByFileUID
func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) Return(cp1 *mm_repository.ConvertedFile, err error) *RepositoryIMock {
	if mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.GetConvertedFileByFileUID mock is already set by Set")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation == nil {
		mmGetConvertedFileByFileUID.defaultExpectation = &RepositoryIMockGetConvertedFileByFileUIDExpectation{mock: mmGetConvertedFileByFileUID.mock}
	}
	mmGetConvertedFileByFileUID.defaultExpectation.results = &RepositoryIMockGetConvertedFileByFileUIDResults{cp1, err}
	return mmGetConvertedFileByFileUID.mock
}

// Set uses given function f to mock the RepositoryI.GetConvertedFileByFileUID method
func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) Set(f func(ctx context.Context, fileUID uuid.UUID) (cp1 *mm_repository.ConvertedFile, err error)) *RepositoryIMock {
	if mmGetConvertedFileByFileUID.defaultExpectation != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetConvertedFileByFileUID method")
	}

	if len(mmGetConvertedFileByFileUID.expectations) > 0 {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetConvertedFileByFileUID method")
	}

	mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID = f
	return mmGetConvertedFileByFileUID.mock
}

// When sets expectation for the RepositoryI.GetConvertedFileByFileUID which will trigger the result defined by the following
// Then helper
func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) When(ctx context.Context, fileUID uuid.UUID) *RepositoryIMockGetConvertedFileByFileUIDExpectation {
	if mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.GetConvertedFileByFileUID mock is already set by Set")
	}

	expectation := &RepositoryIMockGetConvertedFileByFileUIDExpectation{
		mock:   mmGetConvertedFileByFileUID.mock,
		params: &RepositoryIMockGetConvertedFileByFileUIDParams{ctx, fileUID},
	}
	mmGetConvertedFileByFileUID.expectations = append(mmGetConvertedFileByFileUID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetConvertedFileByFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetConvertedFileByFileUIDExpectation) Then(cp1 *mm_repository.ConvertedFile, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetConvertedFileByFileUIDResults{cp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetConvertedFileByFileUID should be invoked
func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) Times(n uint64) *mRepositoryIMockGetConvertedFileByFileUID {
	if n == 0 {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("Times of RepositoryIMock.GetConvertedFileByFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetConvertedFileByFileUID.expectedInvocations, n)
	return mmGetConvertedFileByFileUID
}

func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) invocationsDone() bool {
	if len(mmGetConvertedFileByFileUID.expectations) == 0 && mmGetConvertedFileByFileUID.defaultExpectation == nil && mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetConvertedFileByFileUID.mock.afterGetConvertedFileByFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetConvertedFileByFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetConvertedFileByFileUID implements repository.RepositoryI
func (mmGetConvertedFileByFileUID *RepositoryIMock) GetConvertedFileByFileUID(ctx context.Context, fileUID uuid.UUID) (cp1 *mm_repository.ConvertedFile, err error) {
	mm_atomic.AddUint64(&mmGetConvertedFileByFileUID.beforeGetConvertedFileByFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetConvertedFileByFileUID.afterGetConvertedFileByFileUIDCounter, 1)

	if mmGetConvertedFileByFileUID.inspectFuncGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.inspectFuncGetConvertedFileByFileUID(ctx, fileUID)
	}

	mm_params := RepositoryIMockGetConvertedFileByFileUIDParams{ctx, fileUID}

	// Record call args
	mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.mutex.Lock()
	mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.callArgs = append(mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.callArgs, &mm_params)
	mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.mutex.Unlock()

	for _, e := range mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetConvertedFileByFileUIDParams{ctx, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetConvertedFileByFileUID.t.Errorf("RepositoryIMock.GetConvertedFileByFileUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmGetConvertedFileByFileUID.t.Errorf("RepositoryIMock.GetConvertedFileByFileUID got unexpected parameter fileUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetConvertedFileByFileUID.t.Errorf("RepositoryIMock.GetConvertedFileByFileUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetConvertedFileByFileUID.t.Fatal("No results are set for the RepositoryIMock.GetConvertedFileByFileUID")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetConvertedFileByFileUID.funcGetConvertedFileByFileUID != nil {
		return mmGetConvertedFileByFileUID.funcGetConvertedFileByFileUID(ctx, fileUID)
	}
	mmGetConvertedFileByFileUID.t.Fatalf("Unexpected call to RepositoryIMock.GetConvertedFileByFileUID. %v %v", ctx, fileUID)
	return
}

// GetConvertedFileByFileUIDAfterCounter returns a count of finished RepositoryIMock.GetConvertedFileByFileUID invocations
func (mmGetConvertedFileByFileUID *RepositoryIMock) GetConvertedFileByFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConvertedFileByFileUID.afterGetConvertedFileByFileUIDCounter)
}

// GetConvertedFileByFileUIDBeforeCounter returns a count of RepositoryIMock.GetConvertedFileByFileUID invocations
func (mmGetConvertedFileByFileUID *RepositoryIMock) GetConvertedFileByFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConvertedFileByFileUID.beforeGetConvertedFileByFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetConvertedFileByFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) Calls() []*RepositoryIMockGetConvertedFileByFileUIDParams {
	mmGetConvertedFileByFileUID.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetConvertedFileByFileUIDParams, len(mmGetConvertedFileByFileUID.callArgs))
	copy(argCopy, mmGetConvertedFileByFileUID.callArgs)

	mmGetConvertedFileByFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetConvertedFileByFileUIDDone returns true if the count of the GetConvertedFileByFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetConvertedFileByFileUIDDone() bool {
	for _, e := range m.GetConvertedFileByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetConvertedFileByFileUIDMock.invocationsDone()
}

// MinimockGetConvertedFileByFileUIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetConvertedFileByFileUIDInspect() {
	for _, e := range m.GetConvertedFileByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetConvertedFileByFileUID with params: %#v", *e.params)
		}
	}

	afterGetConvertedFileByFileUIDCounter := mm_atomic.LoadUint64(&m.afterGetConvertedFileByFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetConvertedFileByFileUIDMock.defaultExpectation != nil && afterGetConvertedFileByFileUIDCounter < 1 {
		if m.GetConvertedFileByFileUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetConvertedFileByFileUID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetConvertedFileByFileUID with params: %#v", *m.GetConvertedFileByFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetConvertedFileByFileUID != nil && afterGetConvertedFileByFileUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetConvertedFileByFileUID")
	}

	if !m.GetConvertedFileByFileUIDMock.invocationsDone() && afterGetConvertedFileByFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetConvertedFileByFileUID but found %d calls",
			mm_atomic.LoadUint64(&m.GetConvertedFileByFileUIDMock.expectedInvocations), afterGetConvertedFileByFileUIDCounter)
	}
}

type mRepositoryIMockGetCountFilesByListKnowledgeBaseUID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetCountFilesByListKnowledgeBaseUIDExpectation
	expectations       []*RepositoryIMockGetCountFilesByListKnowledgeBaseUIDExpectation

	callArgs []*RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetCountFilesByListKnowledgeBaseUIDExpectation specifies expectation struct of the RepositoryI.GetCountFilesByListKnowledgeBaseUID
type RepositoryIMockGetCountFilesByListKnowledgeBaseUIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParams
	paramPtrs *RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParamPtrs
	results   *RepositoryIMockGetCountFilesByListKnowledgeBaseUIDResults
	Counter   uint64
}

// RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParams contains parameters of the RepositoryI.GetCountFilesByListKnowledgeBaseUID
type RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParams struct {
	ctx    context.Context
	kbUIDs []mm_repository.KbUID
}

// RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParamPtrs contains pointers to parameters of the RepositoryI.GetCountFilesByListKnowledgeBaseUID
type RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParamPtrs struct {
	ctx    *context.Context
	kbUIDs *[]mm_repository.KbUID
}

// RepositoryIMockGetCountFilesByListKnowledgeBaseUIDResults contains results of the RepositoryI.GetCountFilesByListKnowledgeBaseUID
type RepositoryIMockGetCountFilesByListKnowledgeBaseUIDResults struct {
	m1  map[mm_repository.KbUID]int64
	err error
}

// Expect sets up expected params for RepositoryI.GetCountFilesByListKnowledgeBaseUID
func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID) Expect(ctx context.Context, kbUIDs []mm_repository.KbUID) *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID {
	if mmGetCountFilesByListKnowledgeBaseUID.mock.funcGetCountFilesByListKnowledgeBaseUID != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("RepositoryIMock.GetCountFilesByListKnowledgeBaseUID mock is already set by Set")
	}

	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation == nil {
		mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation = &RepositoryIMockGetCountFilesByListKnowledgeBaseUIDExpectation{}
	}

	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.paramPtrs != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("RepositoryIMock.GetCountFilesByListKnowledgeBaseUID mock is already set by ExpectParams functions")
	}

	mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.params = &RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParams{ctx, kbUIDs}
	for _, e := range mmGetCountFilesByListKnowledgeBaseUID.expectations {
		if minimock.Equal(e.params, mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.params) {
			mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.params)
		}
	}

	return mmGetCountFilesByListKnowledgeBaseUID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetCountFilesByListKnowledgeBaseUID
func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID {
	if mmGetCountFilesByListKnowledgeBaseUID.mock.funcGetCountFilesByListKnowledgeBaseUID != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("RepositoryIMock.GetCountFilesByListKnowledgeBaseUID mock is already set by Set")
	}

	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation == nil {
		mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation = &RepositoryIMockGetCountFilesByListKnowledgeBaseUIDExpectation{}
	}

	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.params != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("RepositoryIMock.GetCountFilesByListKnowledgeBaseUID mock is already set by Expect")
	}

	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.paramPtrs == nil {
		mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.paramPtrs = &RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParamPtrs{}
	}
	mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetCountFilesByListKnowledgeBaseUID
}

// ExpectKbUIDsParam2 sets up expected param kbUIDs for RepositoryI.GetCountFilesByListKnowledgeBaseUID
func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID) ExpectKbUIDsParam2(kbUIDs []mm_repository.KbUID) *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID {
	if mmGetCountFilesByListKnowledgeBaseUID.mock.funcGetCountFilesByListKnowledgeBaseUID != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("RepositoryIMock.GetCountFilesByListKnowledgeBaseUID mock is already set by Set")
	}

	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation == nil {
		mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation = &RepositoryIMockGetCountFilesByListKnowledgeBaseUIDExpectation{}
	}

	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.params != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("RepositoryIMock.GetCountFilesByListKnowledgeBaseUID mock is already set by Expect")
	}

	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.paramPtrs == nil {
		mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.paramPtrs = &RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParamPtrs{}
	}
	mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.paramPtrs.kbUIDs = &kbUIDs

	return mmGetCountFilesByListKnowledgeBaseUID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetCountFilesByListKnowledgeBaseUID
func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID) Inspect(f func(ctx context.Context, kbUIDs []mm_repository.KbUID)) *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID {
	if mmGetCountFilesByListKnowledgeBaseUID.mock.inspectFuncGetCountFilesByListKnowledgeBaseUID != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetCountFilesByListKnowledgeBaseUID")
	}

	mmGetCountFilesByListKnowledgeBaseUID.mock.inspectFuncGetCountFilesByListKnowledgeBaseUID = f

	return mmGetCountFilesByListKnowledgeBaseUID
}

// Return sets up results that will be returned by RepositoryI.GetCountFilesByListKnowledgeBaseUID
func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID) Return(m1 map[mm_repository.KbUID]int64, err error) *RepositoryIMock {
	if mmGetCountFilesByListKnowledgeBaseUID.mock.funcGetCountFilesByListKnowledgeBaseUID != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("RepositoryIMock.GetCountFilesByListKnowledgeBaseUID mock is already set by Set")
	}

	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation == nil {
		mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation = &RepositoryIMockGetCountFilesByListKnowledgeBaseUIDExpectation{mock: mmGetCountFilesByListKnowledgeBaseUID.mock}
	}
	mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.results = &RepositoryIMockGetCountFilesByListKnowledgeBaseUIDResults{m1, err}
	return mmGetCountFilesByListKnowledgeBaseUID.mock
}

// Set uses given function f to mock the RepositoryI.GetCountFilesByListKnowledgeBaseUID method
func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID) Set(f func(ctx context.Context, kbUIDs []mm_repository.KbUID) (m1 map[mm_repository.KbUID]int64, err error)) *RepositoryIMock {
	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetCountFilesByListKnowledgeBaseUID method")
	}

	if len(mmGetCountFilesByListKnowledgeBaseUID.expectations) > 0 {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetCountFilesByListKnowledgeBaseUID method")
	}

	mmGetCountFilesByListKnowledgeBaseUID.mock.funcGetCountFilesByListKnowledgeBaseUID = f
	return mmGetCountFilesByListKnowledgeBaseUID.mock
}

// When sets expectation for the RepositoryI.GetCountFilesByListKnowledgeBaseUID which will trigger the result defined by the following
// Then helper
func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID) When(ctx context.Context, kbUIDs []mm_repository.KbUID) *RepositoryIMockGetCountFilesByListKnowledgeBaseUIDExpectation {
	if mmGetCountFilesByListKnowledgeBaseUID.mock.funcGetCountFilesByListKnowledgeBaseUID != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("RepositoryIMock.GetCountFilesByListKnowledgeBaseUID mock is already set by Set")
	}

	expectation := &RepositoryIMockGetCountFilesByListKnowledgeBaseUIDExpectation{
		mock:   mmGetCountFilesByListKnowledgeBaseUID.mock,
		params: &RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParams{ctx, kbUIDs},
	}
	mmGetCountFilesByListKnowledgeBaseUID.expectations = append(mmGetCountFilesByListKnowledgeBaseUID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetCountFilesByListKnowledgeBaseUID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetCountFilesByListKnowledgeBaseUIDExpectation) Then(m1 map[mm_repository.KbUID]int64, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetCountFilesByListKnowledgeBaseUIDResults{m1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetCountFilesByListKnowledgeBaseUID should be invoked
func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID) Times(n uint64) *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID {
	if n == 0 {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("Times of RepositoryIMock.GetCountFilesByListKnowledgeBaseUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCountFilesByListKnowledgeBaseUID.expectedInvocations, n)
	return mmGetCountFilesByListKnowledgeBaseUID
}

func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID) invocationsDone() bool {
	if len(mmGetCountFilesByListKnowledgeBaseUID.expectations) == 0 && mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation == nil && mmGetCountFilesByListKnowledgeBaseUID.mock.funcGetCountFilesByListKnowledgeBaseUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCountFilesByListKnowledgeBaseUID.mock.afterGetCountFilesByListKnowledgeBaseUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCountFilesByListKnowledgeBaseUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCountFilesByListKnowledgeBaseUID implements repository.RepositoryI
func (mmGetCountFilesByListKnowledgeBaseUID *RepositoryIMock) GetCountFilesByListKnowledgeBaseUID(ctx context.Context, kbUIDs []mm_repository.KbUID) (m1 map[mm_repository.KbUID]int64, err error) {
	mm_atomic.AddUint64(&mmGetCountFilesByListKnowledgeBaseUID.beforeGetCountFilesByListKnowledgeBaseUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCountFilesByListKnowledgeBaseUID.afterGetCountFilesByListKnowledgeBaseUIDCounter, 1)

	if mmGetCountFilesByListKnowledgeBaseUID.inspectFuncGetCountFilesByListKnowledgeBaseUID != nil {
		mmGetCountFilesByListKnowledgeBaseUID.inspectFuncGetCountFilesByListKnowledgeBaseUID(ctx, kbUIDs)
	}

	mm_params := RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParams{ctx, kbUIDs}

	// Record call args
	mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.mutex.Lock()
	mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.callArgs = append(mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.callArgs, &mm_params)
	mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.mutex.Unlock()

	for _, e := range mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParams{ctx, kbUIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCountFilesByListKnowledgeBaseUID.t.Errorf("RepositoryIMock.GetCountFilesByListKnowledgeBaseUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUIDs != nil && !minimock.Equal(*mm_want_ptrs.kbUIDs, mm_got.kbUIDs) {
				mmGetCountFilesByListKnowledgeBaseUID.t.Errorf("RepositoryIMock.GetCountFilesByListKnowledgeBaseUID got unexpected parameter kbUIDs, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbUIDs, mm_got.kbUIDs, minimock.Diff(*mm_want_ptrs.kbUIDs, mm_got.kbUIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCountFilesByListKnowledgeBaseUID.t.Errorf("RepositoryIMock.GetCountFilesByListKnowledgeBaseUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCountFilesByListKnowledgeBaseUID.t.Fatal("No results are set for the RepositoryIMock.GetCountFilesByListKnowledgeBaseUID")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetCountFilesByListKnowledgeBaseUID.funcGetCountFilesByListKnowledgeBaseUID != nil {
		return mmGetCountFilesByListKnowledgeBaseUID.funcGetCountFilesByListKnowledgeBaseUID(ctx, kbUIDs)
	}
	mmGetCountFilesByListKnowledgeBaseUID.t.Fatalf("Unexpected call to RepositoryIMock.GetCountFilesByListKnowledgeBaseUID. %v %v", ctx, kbUIDs)
	return
}

// GetCountFilesByListKnowledgeBaseUIDAfterCounter returns a count of finished RepositoryIMock.GetCountFilesByListKnowledgeBaseUID invocations
func (mmGetCountFilesByListKnowledgeBaseUID *RepositoryIMock) GetCountFilesByListKnowledgeBaseUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCountFilesByListKnowledgeBaseUID.afterGetCountFilesByListKnowledgeBaseUIDCounter)
}

// GetCountFilesByListKnowledgeBaseUIDBeforeCounter returns a count of RepositoryIMock.GetCountFilesByListKnowledgeBaseUID invocations
func (mmGetCountFilesByListKnowledgeBaseUID *RepositoryIMock) GetCountFilesByListKnowledgeBaseUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCountFilesByListKnowledgeBaseUID.beforeGetCountFilesByListKnowledgeBaseUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetCountFilesByListKnowledgeBaseUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryIMockGetCountFilesByListKnowledgeBaseUID) Calls() []*RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParams {
	mmGetCountFilesByListKnowledgeBaseUID.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetCountFilesByListKnowledgeBaseUIDParams, len(mmGetCountFilesByListKnowledgeBaseUID.callArgs))
	copy(argCopy, mmGetCountFilesByListKnowledgeBaseUID.callArgs)

	mmGetCountFilesByListKnowledgeBaseUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetCountFilesByListKnowledgeBaseUIDDone returns true if the count of the GetCountFilesByListKnowledgeBaseUID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetCountFilesByListKnowledgeBaseUIDDone() bool {
	for _, e := range m.GetCountFilesByListKnowledgeBaseUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCountFilesByListKnowledgeBaseUIDMock.invocationsDone()
}

// MinimockGetCountFilesByListKnowledgeBaseUIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetCountFilesByListKnowledgeBaseUIDInspect() {
	for _, e := range m.GetCountFilesByListKnowledgeBaseUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetCountFilesByListKnowledgeBaseUID with params: %#v", *e.params)
		}
	}

	afterGetCountFilesByListKnowledgeBaseUIDCounter := mm_atomic.LoadUint64(&m.afterGetCountFilesByListKnowledgeBaseUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCountFilesByListKnowledgeBaseUIDMock.defaultExpectation != nil && afterGetCountFilesByListKnowledgeBaseUIDCounter < 1 {
		if m.GetCountFilesByListKnowledgeBaseUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetCountFilesByListKnowledgeBaseUID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetCountFilesByListKnowledgeBaseUID with params: %#v", *m.GetCountFilesByListKnowledgeBaseUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCountFilesByListKnowledgeBaseUID != nil && afterGetCountFilesByListKnowledgeBaseUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetCountFilesByListKnowledgeBaseUID")
	}

	if !m.GetCountFilesByListKnowledgeBaseUIDMock.invocationsDone() && afterGetCountFilesByListKnowledgeBaseUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetCountFilesByListKnowledgeBaseUID but found %d calls",
			mm_atomic.LoadUint64(&m.GetCountFilesByListKnowledgeBaseUIDMock.expectedInvocations), afterGetCountFilesByListKnowledgeBaseUIDCounter)
	}
}

type mRepositoryIMockGetEmbeddingByUIDs struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetEmbeddingByUIDsExpectation
	expectations       []*RepositoryIMockGetEmbeddingByUIDsExpectation

	callArgs []*RepositoryIMockGetEmbeddingByUIDsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetEmbeddingByUIDsExpectation specifies expectation struct of the RepositoryI.GetEmbeddingByUIDs
type RepositoryIMockGetEmbeddingByUIDsExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetEmbeddingByUIDsParams
	paramPtrs *RepositoryIMockGetEmbeddingByUIDsParamPtrs
	results   *RepositoryIMockGetEmbeddingByUIDsResults
	Counter   uint64
}

// RepositoryIMockGetEmbeddingByUIDsParams contains parameters of the RepositoryI.GetEmbeddingByUIDs
type RepositoryIMockGetEmbeddingByUIDsParams struct {
	ctx     context.Context
	embUIDs []uuid.UUID
}

// RepositoryIMockGetEmbeddingByUIDsParamPtrs contains pointers to parameters of the RepositoryI.GetEmbeddingByUIDs
type RepositoryIMockGetEmbeddingByUIDsParamPtrs struct {
	ctx     *context.Context
	embUIDs *[]uuid.UUID
}

// RepositoryIMockGetEmbeddingByUIDsResults contains results of the RepositoryI.GetEmbeddingByUIDs
type RepositoryIMockGetEmbeddingByUIDsResults struct {
	ea1 []mm_repository.Embedding
	err error
}

// Expect sets up expected params for RepositoryI.GetEmbeddingByUIDs
func (mmGetEmbeddingByUIDs *mRepositoryIMockGetEmbeddingByUIDs) Expect(ctx context.Context, embUIDs []uuid.UUID) *mRepositoryIMockGetEmbeddingByUIDs {
	if mmGetEmbeddingByUIDs.mock.funcGetEmbeddingByUIDs != nil {
		mmGetEmbeddingByUIDs.mock.t.Fatalf("RepositoryIMock.GetEmbeddingByUIDs mock is already set by Set")
	}

	if mmGetEmbeddingByUIDs.defaultExpectation == nil {
		mmGetEmbeddingByUIDs.defaultExpectation = &RepositoryIMockGetEmbeddingByUIDsExpectation{}
	}

	if mmGetEmbeddingByUIDs.defaultExpectation.paramPtrs != nil {
		mmGetEmbeddingByUIDs.mock.t.Fatalf("RepositoryIMock.GetEmbeddingByUIDs mock is already set by ExpectParams functions")
	}

	mmGetEmbeddingByUIDs.defaultExpectation.params = &RepositoryIMockGetEmbeddingByUIDsParams{ctx, embUIDs}
	for _, e := range mmGetEmbeddingByUIDs.expectations {
		if minimock.Equal(e.params, mmGetEmbeddingByUIDs.defaultExpectation.params) {
			mmGetEmbeddingByUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetEmbeddingByUIDs.defaultExpectation.params)
		}
	}

	return mmGetEmbeddingByUIDs
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetEmbeddingByUIDs
func (mmGetEmbeddingByUIDs *mRepositoryIMockGetEmbeddingByUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetEmbeddingByUIDs {
	if mmGetEmbeddingByUIDs.mock.funcGetEmbeddingByUIDs != nil {
		mmGetEmbeddingByUIDs.mock.t.Fatalf("RepositoryIMock.GetEmbeddingByUIDs mock is already set by Set")
	}

	if mmGetEmbeddingByUIDs.defaultExpectation == nil {
		mmGetEmbeddingByUIDs.defaultExpectation = &RepositoryIMockGetEmbeddingByUIDsExpectation{}
	}

	if mmGetEmbeddingByUIDs.defaultExpectation.params != nil {
		mmGetEmbeddingByUIDs.mock.t.Fatalf("RepositoryIMock.GetEmbeddingByUIDs mock is already set by Expect")
	}

	if mmGetEmbeddingByUIDs.defaultExpectation.paramPtrs == nil {
		mmGetEmbeddingByUIDs.defaultExpectation.paramPtrs = &RepositoryIMockGetEmbeddingByUIDsParamPtrs{}
	}
	mmGetEmbeddingByUIDs.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetEmbeddingByUIDs
}

// ExpectEmbUIDsParam2 sets up expected param embUIDs for RepositoryI.GetEmbeddingByUIDs
func (mmGetEmbeddingByUIDs *mRepositoryIMockGetEmbeddingByUIDs) ExpectEmbUIDsParam2(embUIDs []uuid.UUID) *mRepositoryIMockGetEmbeddingByUIDs {
	if mmGetEmbeddingByUIDs.mock.funcGetEmbeddingByUIDs != nil {
		mmGetEmbeddingByUIDs.mock.t.Fatalf("RepositoryIMock.GetEmbeddingByUIDs mock is already set by Set")
	}

	if mmGetEmbeddingByUIDs.defaultExpectation == nil {
		mmGetEmbeddingByUIDs.defaultExpectation = &RepositoryIMockGetEmbeddingByUIDsExpectation{}
	}

	if mmGetEmbeddingByUIDs.defaultExpectation.params != nil {
		mmGetEmbeddingByUIDs.mock.t.Fatalf("RepositoryIMock.GetEmbeddingByUIDs mock is already set by Expect")
	}

	if mmGetEmbeddingByUIDs.defaultExpectation.paramPtrs == nil {
		mmGetEmbeddingByUIDs.defaultExpectation.paramPtrs = &RepositoryIMockGetEmbeddingByUIDsParamPtrs{}
	}
	mmGetEmbeddingByUIDs.defaultExpectation.paramPtrs.embUIDs = &embUIDs

	return mmGetEmbeddingByUIDs
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetEmbeddingByUIDs
func (mmGetEmbeddingByUIDs *mRepositoryIMockGetEmbeddingByUIDs) Inspect(f func(ctx context.Context, embUIDs []uuid.UUID)) *mRepositoryIMockGetEmbeddingByUIDs {
	if mmGetEmbeddingByUIDs.mock.inspectFuncGetEmbeddingByUIDs != nil {
		mmGetEmbeddingByUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetEmbeddingByUIDs")
	}

	mmGetEmbeddingByUIDs.mock.inspectFuncGetEmbeddingByUIDs = f

	return mmGetEmbeddingByUIDs
}

// Return sets up results that will be returned by RepositoryI.GetEmbeddingByUIDs
func (mmGetEmbeddingByUIDs *mRepositoryIMockGetEmbeddingByUIDs) Return(ea1 []mm_repository.Embedding, err error) *RepositoryIMock {
	if mmGetEmbeddingByUIDs.mock.funcGetEmbeddingByUIDs != nil {
		mmGetEmbeddingByUIDs.mock.t.Fatalf("RepositoryIMock.GetEmbeddingByUIDs mock is already set by Set")
	}

	if mmGetEmbeddingByUIDs.defaultExpectation == nil {
		mmGetEmbeddingByUIDs.defaultExpectation = &RepositoryIMockGetEmbeddingByUIDsExpectation{mock: mmGetEmbeddingByUIDs.mock}
	}
	mmGetEmbeddingByUIDs.defaultExpectation.results = &RepositoryIMockGetEmbeddingByUIDsResults{ea1, err}
	return mmGetEmbeddingByUIDs.mock
}

// Set uses given function f to mock the RepositoryI.GetEmbeddingByUIDs method
func (mmGetEmbeddingByUIDs *mRepositoryIMockGetEmbeddingByUIDs) Set(f func(ctx context.Context, embUIDs []uuid.UUID) (ea1 []mm_repository.Embedding, err error)) *RepositoryIMock {
	if mmGetEmbeddingByUIDs.defaultExpectation != nil {
		mmGetEmbeddingByUIDs.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetEmbeddingByUIDs method")
	}

	if len(mmGetEmbeddingByUIDs.expectations) > 0 {
		mmGetEmbeddingByUIDs.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetEmbeddingByUIDs method")
	}

	mmGetEmbeddingByUIDs.mock.funcGetEmbeddingByUIDs = f
	return mmGetEmbeddingByUIDs.mock
}

// When sets expectation for the RepositoryI.GetEmbeddingByUIDs which will trigger the result defined by the following
// Then helper
func (mmGetEmbeddingByUIDs *mRepositoryIMockGetEmbeddingByUIDs) When(ctx context.Context, embUIDs []uuid.UUID) *RepositoryIMockGetEmbeddingByUIDsExpectation {
	if mmGetEmbeddingByUIDs.mock.funcGetEmbeddingByUIDs != nil {
		mmGetEmbeddingByUIDs.mock.t.Fatalf("RepositoryIMock.GetEmbeddingByUIDs mock is already set by Set")
	}

	expectation := &RepositoryIMockGetEmbeddingByUIDsExpectation{
		mock:   mmGetEmbeddingByUIDs.mock,
		params: &RepositoryIMockGetEmbeddingByUIDsParams{ctx, embUIDs},
	}
	mmGetEmbeddingByUIDs.expectations = append(mmGetEmbeddingByUIDs.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetEmbeddingByUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetEmbeddingByUIDsExpectation) Then(ea1 []mm_repository.Embedding, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetEmbeddingByUIDsResults{ea1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetEmbeddingByUIDs should be invoked
func (mmGetEmbeddingByUIDs *mRepositoryIMockGetEmbeddingByUIDs) Times(n uint64) *mRepositoryIMockGetEmbeddingByUIDs {
	if n == 0 {
		mmGetEmbeddingByUIDs.mock.t.Fatalf("Times of RepositoryIMock.GetEmbeddingByUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetEmbeddingByUIDs.expectedInvocations, n)
	return mmGetEmbeddingByUIDs
}

func (mmGetEmbeddingByUIDs *mRepositoryIMockGetEmbeddingByUIDs) invocationsDone() bool {
	if len(mmGetEmbeddingByUIDs.expectations) == 0 && mmGetEmbeddingByUIDs.defaultExpectation == nil && mmGetEmbeddingByUIDs.mock.funcGetEmbeddingByUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetEmbeddingByUIDs.mock.afterGetEmbeddingByUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetEmbeddingByUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetEmbeddingByUIDs implements repository.RepositoryI
func (mmGetEmbeddingByUIDs *RepositoryIMock) GetEmbeddingByUIDs(ctx context.Context, embUIDs []uuid.UUID) (ea1 []mm_repository.Embedding, err error) {
	mm_atomic.AddUint64(&mmGetEmbeddingByUIDs.beforeGetEmbeddingByUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetEmbeddingByUIDs.afterGetEmbeddingByUIDsCounter, 1)

	if mmGetEmbeddingByUIDs.inspectFuncGetEmbeddingByUIDs != nil {
		mmGetEmbeddingByUIDs.inspectFuncGetEmbeddingByUIDs(ctx, embUIDs)
	}

	mm_params := RepositoryIMockGetEmbeddingByUIDsParams{ctx, embUIDs}

	// Record call args
	mmGetEmbeddingByUIDs.GetEmbeddingByUIDsMock.mutex.Lock()
	mmGetEmbeddingByUIDs.GetEmbeddingByUIDsMock.callArgs = append(mmGetEmbeddingByUIDs.GetEmbeddingByUIDsMock.callArgs, &mm_params)
	mmGetEmbeddingByUIDs.GetEmbeddingByUIDsMock.mutex.Unlock()

	for _, e := range mmGetEmbeddingByUIDs.GetEmbeddingByUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1, e.results.err
		}
	}

	if mmGetEmbeddingByUIDs.GetEmbeddingByUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetEmbeddingByUIDs.GetEmbeddingByUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetEmbeddingByUIDs.GetEmbeddingByUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmGetEmbeddingByUIDs.GetEmbeddingByUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetEmbeddingByUIDsParams{ctx, embUIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetEmbeddingByUIDs.t.Errorf("RepositoryIMock.GetEmbeddingByUIDs got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.embUIDs != nil && !minimock.Equal(*mm_want_ptrs.embUIDs, mm_got.embUIDs) {
				mmGetEmbeddingByUIDs.t.Errorf("RepositoryIMock.GetEmbeddingByUIDs got unexpected parameter embUIDs, want: %#v, got: %#v%s\n", *mm_want_ptrs.embUIDs, mm_got.embUIDs, minimock.Diff(*mm_want_ptrs.embUIDs, mm_got.embUIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetEmbeddingByUIDs.t.Errorf("RepositoryIMock.GetEmbeddingByUIDs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetEmbeddingByUIDs.GetEmbeddingByUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetEmbeddingByUIDs.t.Fatal("No results are set for the RepositoryIMock.GetEmbeddingByUIDs")
		}
		return (*mm_results).ea1, (*mm_results).err
	}
	if mmGetEmbeddingByUIDs.funcGetEmbeddingByUIDs != nil {
		return mmGetEmbeddingByUIDs.funcGetEmbeddingByUIDs(ctx, embUIDs)
	}
	mmGetEmbeddingByUIDs.t.Fatalf("Unexpected call to RepositoryIMock.GetEmbeddingByUIDs. %v %v", ctx, embUIDs)
	return
}

// GetEmbeddingByUIDsAfterCounter returns a count of finished RepositoryIMock.GetEmbeddingByUIDs invocations
func (mmGetEmbeddingByUIDs *RepositoryIMock) GetEmbeddingByUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEmbeddingByUIDs.afterGetEmbeddingByUIDsCounter)
}

// GetEmbeddingByUIDsBeforeCounter returns a count of RepositoryIMock.GetEmbeddingByUIDs invocations
func (mmGetEmbeddingByUIDs *RepositoryIMock) GetEmbeddingByUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEmbeddingByUIDs.beforeGetEmbeddingByUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetEmbeddingByUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetEmbeddingByUIDs *mRepositoryIMockGetEmbeddingByUIDs) Calls() []*RepositoryIMockGetEmbeddingByUIDsParams {
	mmGetEmbeddingByUIDs.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetEmbeddingByUIDsParams, len(mmGetEmbeddingByUIDs.callArgs))
	copy(argCopy, mmGetEmbeddingByUIDs.callArgs)

	mmGetEmbeddingByUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockGetEmbeddingByUIDsDone returns true if the count of the GetEmbeddingByUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetEmbeddingByUIDsDone() bool {
	for _, e := range m.GetEmbeddingByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetEmbeddingByUIDsMock.invocationsDone()
}

// MinimockGetEmbeddingByUIDsInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetEmbeddingByUIDsInspect() {
	for _, e := range m.GetEmbeddingByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetEmbeddingByUIDs with params: %#v", *e.params)
		}
	}

	afterGetEmbeddingByUIDsCounter := mm_atomic.LoadUint64(&m.afterGetEmbeddingByUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetEmbeddingByUIDsMock.defaultExpectation != nil && afterGetEmbeddingByUIDsCounter < 1 {
		if m.GetEmbeddingByUIDsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetEmbeddingByUIDs")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetEmbeddingByUIDs with params: %#v", *m.GetEmbeddingByUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetEmbeddingByUIDs != nil && afterGetEmbeddingByUIDsCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetEmbeddingByUIDs")
	}

	if !m.GetEmbeddingByUIDsMock.invocationsDone() && afterGetEmbeddingByUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetEmbeddingByUIDs but found %d calls",
			mm_atomic.LoadUint64(&m.GetEmbeddingByUIDsMock.expectedInvocations), afterGetEmbeddingByUIDsCounter)
	}
}

type mRepositoryIMockGetFilesTotalTokens struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetFilesTotalTokensExpectation
	expectations       []*RepositoryIMockGetFilesTotalTokensExpectation

	callArgs []*RepositoryIMockGetFilesTotalTokensParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetFilesTotalTokensExpectation specifies expectation struct of the RepositoryI.GetFilesTotalTokens
type RepositoryIMockGetFilesTotalTokensExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetFilesTotalTokensParams
	paramPtrs *RepositoryIMockGetFilesTotalTokensParamPtrs
	results   *RepositoryIMockGetFilesTotalTokensResults
	Counter   uint64
}

// RepositoryIMockGetFilesTotalTokensParams contains parameters of the RepositoryI.GetFilesTotalTokens
type RepositoryIMockGetFilesTotalTokensParams struct {
	ctx     context.Context
	sources map[mm_repository.FileUID]struct {
		SourceTable mm_repository.SourceTable
		SourceUID   mm_repository.SourceUID
	}
}

// RepositoryIMockGetFilesTotalTokensParamPtrs contains pointers to parameters of the RepositoryI.GetFilesTotalTokens
type RepositoryIMockGetFilesTotalTokensParamPtrs struct {
	ctx     *context.Context
	sources *map[mm_repository.FileUID]struct {
		SourceTable mm_repository.SourceTable
		SourceUID   mm_repository.SourceUID
	}
}

// RepositoryIMockGetFilesTotalTokensResults contains results of the RepositoryI.GetFilesTotalTokens
type RepositoryIMockGetFilesTotalTokensResults struct {
	m1  map[mm_repository.FileUID]int
	err error
}

// Expect sets up expected params for RepositoryI.GetFilesTotalTokens
func (mmGetFilesTotalTokens *mRepositoryIMockGetFilesTotalTokens) Expect(ctx context.Context, sources map[mm_repository.FileUID]struct {
	SourceTable mm_repository.SourceTable
	SourceUID   mm_repository.SourceUID
}) *mRepositoryIMockGetFilesTotalTokens {
	if mmGetFilesTotalTokens.mock.funcGetFilesTotalTokens != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryIMock.GetFilesTotalTokens mock is already set by Set")
	}

	if mmGetFilesTotalTokens.defaultExpectation == nil {
		mmGetFilesTotalTokens.defaultExpectation = &RepositoryIMockGetFilesTotalTokensExpectation{}
	}

	if mmGetFilesTotalTokens.defaultExpectation.paramPtrs != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryIMock.GetFilesTotalTokens mock is already set by ExpectParams functions")
	}

	mmGetFilesTotalTokens.defaultExpectation.params = &RepositoryIMockGetFilesTotalTokensParams{ctx, sources}
	for _, e := range mmGetFilesTotalTokens.expectations {
		if minimock.Equal(e.params, mmGetFilesTotalTokens.defaultExpectation.params) {
			mmGetFilesTotalTokens.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFilesTotalTokens.defaultExpectation.params)
		}
	}

	return mmGetFilesTotalTokens
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetFilesTotalTokens
func (mmGetFilesTotalTokens *mRepositoryIMockGetFilesTotalTokens) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetFilesTotalTokens {
	if mmGetFilesTotalTokens.mock.funcGetFilesTotalTokens != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryIMock.GetFilesTotalTokens mock is already set by Set")
	}

	if mmGetFilesTotalTokens.defaultExpectation == nil {
		mmGetFilesTotalTokens.defaultExpectation = &RepositoryIMockGetFilesTotalTokensExpectation{}
	}

	if mmGetFilesTotalTokens.defaultExpectation.params != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryIMock.GetFilesTotalTokens mock is already set by Expect")
	}

	if mmGetFilesTotalTokens.defaultExpectation.paramPtrs == nil {
		mmGetFilesTotalTokens.defaultExpectation.paramPtrs = &RepositoryIMockGetFilesTotalTokensParamPtrs{}
	}
	mmGetFilesTotalTokens.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetFilesTotalTokens
}

// ExpectSourcesParam2 sets up expected param sources for RepositoryI.GetFilesTotalTokens
func (mmGetFilesTotalTokens *mRepositoryIMockGetFilesTotalTokens) ExpectSourcesParam2(sources map[mm_repository.FileUID]struct {
	SourceTable mm_repository.SourceTable
	SourceUID   mm_repository.SourceUID
}) *mRepositoryIMockGetFilesTotalTokens {
	if mmGetFilesTotalTokens.mock.funcGetFilesTotalTokens != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryIMock.GetFilesTotalTokens mock is already set by Set")
	}

	if mmGetFilesTotalTokens.defaultExpectation == nil {
		mmGetFilesTotalTokens.defaultExpectation = &RepositoryIMockGetFilesTotalTokensExpectation{}
	}

	if mmGetFilesTotalTokens.defaultExpectation.params != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryIMock.GetFilesTotalTokens mock is already set by Expect")
	}

	if mmGetFilesTotalTokens.defaultExpectation.paramPtrs == nil {
		mmGetFilesTotalTokens.defaultExpectation.paramPtrs = &RepositoryIMockGetFilesTotalTokensParamPtrs{}
	}
	mmGetFilesTotalTokens.defaultExpectation.paramPtrs.sources = &sources

	return mmGetFilesTotalTokens
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetFilesTotalTokens
func (mmGetFilesTotalTokens *mRepositoryIMockGetFilesTotalTokens) Inspect(f func(ctx context.Context, sources map[mm_repository.FileUID]struct {
	SourceTable mm_repository.SourceTable
	SourceUID   mm_repository.SourceUID
})) *mRepositoryIMockGetFilesTotalTokens {
	if mmGetFilesTotalTokens.mock.inspectFuncGetFilesTotalTokens != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetFilesTotalTokens")
	}

	mmGetFilesTotalTokens.mock.inspectFuncGetFilesTotalTokens = f

	return mmGetFilesTotalTokens
}

// Return sets up results that will be returned by RepositoryI.GetFilesTotalTokens
func (mmGetFilesTotalTokens *mRepositoryIMockGetFilesTotalTokens) Return(m1 map[mm_repository.FileUID]int, err error) *RepositoryIMock {
	if mmGetFilesTotalTokens.mock.funcGetFilesTotalTokens != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryIMock.GetFilesTotalTokens mock is already set by Set")
	}

	if mmGetFilesTotalTokens.defaultExpectation == nil {
		mmGetFilesTotalTokens.defaultExpectation = &RepositoryIMockGetFilesTotalTokensExpectation{mock: mmGetFilesTotalTokens.mock}
	}
	mmGetFilesTotalTokens.defaultExpectation.results = &RepositoryIMockGetFilesTotalTokensResults{m1, err}
	return mmGetFilesTotalTokens.mock
}

// Set uses given function f to mock the RepositoryI.GetFilesTotalTokens method
func (mmGetFilesTotalTokens *mRepositoryIMockGetFilesTotalTokens) Set(f func(ctx context.Context, sources map[mm_repository.FileUID]struct {
	SourceTable mm_repository.SourceTable
	SourceUID   mm_repository.SourceUID
}) (m1 map[mm_repository.FileUID]int, err error)) *RepositoryIMock {
	if mmGetFilesTotalTokens.defaultExpectation != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetFilesTotalTokens method")
	}

	if len(mmGetFilesTotalTokens.expectations) > 0 {
		mmGetFilesTotalTokens.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetFilesTotalTokens method")
	}

	mmGetFilesTotalTokens.mock.funcGetFilesTotalTokens = f
	return mmGetFilesTotalTokens.mock
}

// When sets expectation for the RepositoryI.GetFilesTotalTokens which will trigger the result defined by the following
// Then helper
func (mmGetFilesTotalTokens *mRepositoryIMockGetFilesTotalTokens) When(ctx context.Context, sources map[mm_repository.FileUID]struct {
	SourceTable mm_repository.SourceTable
	SourceUID   mm_repository.SourceUID
}) *RepositoryIMockGetFilesTotalTokensExpectation {
	if mmGetFilesTotalTokens.mock.funcGetFilesTotalTokens != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryIMock.GetFilesTotalTokens mock is already set by Set")
	}

	expectation := &RepositoryIMockGetFilesTotalTokensExpectation{
		mock:   mmGetFilesTotalTokens.mock,
		params: &RepositoryIMockGetFilesTotalTokensParams{ctx, sources},
	}
	mmGetFilesTotalTokens.expectations = append(mmGetFilesTotalTokens.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetFilesTotalTokens return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetFilesTotalTokensExpectation) Then(m1 map[mm_repository.FileUID]int, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetFilesTotalTokensResults{m1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetFilesTotalTokens should be invoked
func (mmGetFilesTotalTokens *mRepositoryIMockGetFilesTotalTokens) Times(n uint64) *mRepositoryIMockGetFilesTotalTokens {
	if n == 0 {
		mmGetFilesTotalTokens.mock.t.Fatalf("Times of RepositoryIMock.GetFilesTotalTokens mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFilesTotalTokens.expectedInvocations, n)
	return mmGetFilesTotalTokens
}

func (mmGetFilesTotalTokens *mRepositoryIMockGetFilesTotalTokens) invocationsDone() bool {
	if len(mmGetFilesTotalTokens.expectations) == 0 && mmGetFilesTotalTokens.defaultExpectation == nil && mmGetFilesTotalTokens.mock.funcGetFilesTotalTokens == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFilesTotalTokens.mock.afterGetFilesTotalTokensCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFilesTotalTokens.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFilesTotalTokens implements repository.RepositoryI
func (mmGetFilesTotalTokens *RepositoryIMock) GetFilesTotalTokens(ctx context.Context, sources map[mm_repository.FileUID]struct {
	SourceTable mm_repository.SourceTable
	SourceUID   mm_repository.SourceUID
}) (m1 map[mm_repository.FileUID]int, err error) {
	mm_atomic.AddUint64(&mmGetFilesTotalTokens.beforeGetFilesTotalTokensCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFilesTotalTokens.afterGetFilesTotalTokensCounter, 1)

	if mmGetFilesTotalTokens.inspectFuncGetFilesTotalTokens != nil {
		mmGetFilesTotalTokens.inspectFuncGetFilesTotalTokens(ctx, sources)
	}

	mm_params := RepositoryIMockGetFilesTotalTokensParams{ctx, sources}

	// Record call args
	mmGetFilesTotalTokens.GetFilesTotalTokensMock.mutex.Lock()
	mmGetFilesTotalTokens.GetFilesTotalTokensMock.callArgs = append(mmGetFilesTotalTokens.GetFilesTotalTokensMock.callArgs, &mm_params)
	mmGetFilesTotalTokens.GetFilesTotalTokensMock.mutex.Unlock()

	for _, e := range mmGetFilesTotalTokens.GetFilesTotalTokensMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetFilesTotalTokens.GetFilesTotalTokensMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFilesTotalTokens.GetFilesTotalTokensMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFilesTotalTokens.GetFilesTotalTokensMock.defaultExpectation.params
		mm_want_ptrs := mmGetFilesTotalTokens.GetFilesTotalTokensMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetFilesTotalTokensParams{ctx, sources}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFilesTotalTokens.t.Errorf("RepositoryIMock.GetFilesTotalTokens got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sources != nil && !minimock.Equal(*mm_want_ptrs.sources, mm_got.sources) {
				mmGetFilesTotalTokens.t.Errorf("RepositoryIMock.GetFilesTotalTokens got unexpected parameter sources, want: %#v, got: %#v%s\n", *mm_want_ptrs.sources, mm_got.sources, minimock.Diff(*mm_want_ptrs.sources, mm_got.sources))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFilesTotalTokens.t.Errorf("RepositoryIMock.GetFilesTotalTokens got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFilesTotalTokens.GetFilesTotalTokensMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFilesTotalTokens.t.Fatal("No results are set for the RepositoryIMock.GetFilesTotalTokens")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetFilesTotalTokens.funcGetFilesTotalTokens != nil {
		return mmGetFilesTotalTokens.funcGetFilesTotalTokens(ctx, sources)
	}
	mmGetFilesTotalTokens.t.Fatalf("Unexpected call to RepositoryIMock.GetFilesTotalTokens. %v %v", ctx, sources)
	return
}

// GetFilesTotalTokensAfterCounter returns a count of finished RepositoryIMock.GetFilesTotalTokens invocations
func (mmGetFilesTotalTokens *RepositoryIMock) GetFilesTotalTokensAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFilesTotalTokens.afterGetFilesTotalTokensCounter)
}

// GetFilesTotalTokensBeforeCounter returns a count of RepositoryIMock.GetFilesTotalTokens invocations
func (mmGetFilesTotalTokens *RepositoryIMock) GetFilesTotalTokensBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFilesTotalTokens.beforeGetFilesTotalTokensCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetFilesTotalTokens.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFilesTotalTokens *mRepositoryIMockGetFilesTotalTokens) Calls() []*RepositoryIMockGetFilesTotalTokensParams {
	mmGetFilesTotalTokens.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetFilesTotalTokensParams, len(mmGetFilesTotalTokens.callArgs))
	copy(argCopy, mmGetFilesTotalTokens.callArgs)

	mmGetFilesTotalTokens.mutex.RUnlock()

	return argCopy
}

// MinimockGetFilesTotalTokensDone returns true if the count of the GetFilesTotalTokens invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetFilesTotalTokensDone() bool {
	for _, e := range m.GetFilesTotalTokensMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFilesTotalTokensMock.invocationsDone()
}

// MinimockGetFilesTotalTokensInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetFilesTotalTokensInspect() {
	for _, e := range m.GetFilesTotalTokensMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetFilesTotalTokens with params: %#v", *e.params)
		}
	}

	afterGetFilesTotalTokensCounter := mm_atomic.LoadUint64(&m.afterGetFilesTotalTokensCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFilesTotalTokensMock.defaultExpectation != nil && afterGetFilesTotalTokensCounter < 1 {
		if m.GetFilesTotalTokensMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetFilesTotalTokens")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetFilesTotalTokens with params: %#v", *m.GetFilesTotalTokensMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFilesTotalTokens != nil && afterGetFilesTotalTokensCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetFilesTotalTokens")
	}

	if !m.GetFilesTotalTokensMock.invocationsDone() && afterGetFilesTotalTokensCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetFilesTotalTokens but found %d calls",
			mm_atomic.LoadUint64(&m.GetFilesTotalTokensMock.expectedInvocations), afterGetFilesTotalTokensCounter)
	}
}

type mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDExpectation
	expectations       []*RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDExpectation

	callArgs []*RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDExpectation specifies expectation struct of the RepositoryI.GetKnowledgeBaseByOwnerAndKbID
type RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParams
	paramPtrs *RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParamPtrs
	results   *RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDResults
	Counter   uint64
}

// RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParams contains parameters of the RepositoryI.GetKnowledgeBaseByOwnerAndKbID
type RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParams struct {
	ctx      context.Context
	ownerUID uuid.UUID
	kbID     string
}

// RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParamPtrs contains pointers to parameters of the RepositoryI.GetKnowledgeBaseByOwnerAndKbID
type RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParamPtrs struct {
	ctx      *context.Context
	ownerUID *uuid.UUID
	kbID     *string
}

// RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDResults contains results of the RepositoryI.GetKnowledgeBaseByOwnerAndKbID
type RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDResults struct {
	kp1 *mm_repository.KnowledgeBase
	err error
}

// Expect sets up expected params for RepositoryI.GetKnowledgeBaseByOwnerAndKbID
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID) Expect(ctx context.Context, ownerUID uuid.UUID, kbID string) *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID {
	if mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation = &RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDExpectation{}
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.params = &RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParams{ctx, ownerUID, kbID}
	for _, e := range mmGetKnowledgeBaseByOwnerAndKbID.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.params) {
			mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBaseByOwnerAndKbID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetKnowledgeBaseByOwnerAndKbID
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID {
	if mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation = &RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDExpectation{}
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.params != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Expect")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs = &RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParamPtrs{}
	}
	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetKnowledgeBaseByOwnerAndKbID
}

// ExpectOwnerUIDParam2 sets up expected param ownerUID for RepositoryI.GetKnowledgeBaseByOwnerAndKbID
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID) ExpectOwnerUIDParam2(ownerUID uuid.UUID) *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID {
	if mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation = &RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDExpectation{}
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.params != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Expect")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs = &RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParamPtrs{}
	}
	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs.ownerUID = &ownerUID

	return mmGetKnowledgeBaseByOwnerAndKbID
}

// ExpectKbIDParam3 sets up expected param kbID for RepositoryI.GetKnowledgeBaseByOwnerAndKbID
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID) ExpectKbIDParam3(kbID string) *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID {
	if mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation = &RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDExpectation{}
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.params != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Expect")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs = &RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParamPtrs{}
	}
	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs.kbID = &kbID

	return mmGetKnowledgeBaseByOwnerAndKbID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetKnowledgeBaseByOwnerAndKbID
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID) Inspect(f func(ctx context.Context, ownerUID uuid.UUID, kbID string)) *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID {
	if mmGetKnowledgeBaseByOwnerAndKbID.mock.inspectFuncGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID")
	}

	mmGetKnowledgeBaseByOwnerAndKbID.mock.inspectFuncGetKnowledgeBaseByOwnerAndKbID = f

	return mmGetKnowledgeBaseByOwnerAndKbID
}

// Return sets up results that will be returned by RepositoryI.GetKnowledgeBaseByOwnerAndKbID
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID) Return(kp1 *mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	if mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation = &RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDExpectation{mock: mmGetKnowledgeBaseByOwnerAndKbID.mock}
	}
	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.results = &RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDResults{kp1, err}
	return mmGetKnowledgeBaseByOwnerAndKbID.mock
}

// Set uses given function f to mock the RepositoryI.GetKnowledgeBaseByOwnerAndKbID method
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID) Set(f func(ctx context.Context, ownerUID uuid.UUID, kbID string) (kp1 *mm_repository.KnowledgeBase, err error)) *RepositoryIMock {
	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetKnowledgeBaseByOwnerAndKbID method")
	}

	if len(mmGetKnowledgeBaseByOwnerAndKbID.expectations) > 0 {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetKnowledgeBaseByOwnerAndKbID method")
	}

	mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID = f
	return mmGetKnowledgeBaseByOwnerAndKbID.mock
}

// When sets expectation for the RepositoryI.GetKnowledgeBaseByOwnerAndKbID which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID) When(ctx context.Context, ownerUID uuid.UUID, kbID string) *RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDExpectation {
	if mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Set")
	}

	expectation := &RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDExpectation{
		mock:   mmGetKnowledgeBaseByOwnerAndKbID.mock,
		params: &RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParams{ctx, ownerUID, kbID},
	}
	mmGetKnowledgeBaseByOwnerAndKbID.expectations = append(mmGetKnowledgeBaseByOwnerAndKbID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetKnowledgeBaseByOwnerAndKbID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDExpectation) Then(kp1 *mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDResults{kp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetKnowledgeBaseByOwnerAndKbID should be invoked
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID) Times(n uint64) *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID {
	if n == 0 {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("Times of RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBaseByOwnerAndKbID.expectedInvocations, n)
	return mmGetKnowledgeBaseByOwnerAndKbID
}

func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID) invocationsDone() bool {
	if len(mmGetKnowledgeBaseByOwnerAndKbID.expectations) == 0 && mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation == nil && mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseByOwnerAndKbID.mock.afterGetKnowledgeBaseByOwnerAndKbIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseByOwnerAndKbID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBaseByOwnerAndKbID implements repository.RepositoryI
func (mmGetKnowledgeBaseByOwnerAndKbID *RepositoryIMock) GetKnowledgeBaseByOwnerAndKbID(ctx context.Context, ownerUID uuid.UUID, kbID string) (kp1 *mm_repository.KnowledgeBase, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBaseByOwnerAndKbID.beforeGetKnowledgeBaseByOwnerAndKbIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBaseByOwnerAndKbID.afterGetKnowledgeBaseByOwnerAndKbIDCounter, 1)

	if mmGetKnowledgeBaseByOwnerAndKbID.inspectFuncGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.inspectFuncGetKnowledgeBaseByOwnerAndKbID(ctx, ownerUID, kbID)
	}

	mm_params := RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParams{ctx, ownerUID, kbID}

	// Record call args
	mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.mutex.Lock()
	mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.callArgs = append(mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.callArgs, &mm_params)
	mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParams{ctx, ownerUID, kbID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBaseByOwnerAndKbID.t.Errorf("RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmGetKnowledgeBaseByOwnerAndKbID.t.Errorf("RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID got unexpected parameter ownerUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

			if mm_want_ptrs.kbID != nil && !minimock.Equal(*mm_want_ptrs.kbID, mm_got.kbID) {
				mmGetKnowledgeBaseByOwnerAndKbID.t.Errorf("RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID got unexpected parameter kbID, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbID, mm_got.kbID, minimock.Diff(*mm_want_ptrs.kbID, mm_got.kbID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBaseByOwnerAndKbID.t.Errorf("RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBaseByOwnerAndKbID.t.Fatal("No results are set for the RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmGetKnowledgeBaseByOwnerAndKbID.funcGetKnowledgeBaseByOwnerAndKbID != nil {
		return mmGetKnowledgeBaseByOwnerAndKbID.funcGetKnowledgeBaseByOwnerAndKbID(ctx, ownerUID, kbID)
	}
	mmGetKnowledgeBaseByOwnerAndKbID.t.Fatalf("Unexpected call to RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID. %v %v %v", ctx, ownerUID, kbID)
	return
}

// GetKnowledgeBaseByOwnerAndKbIDAfterCounter returns a count of finished RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID invocations
func (mmGetKnowledgeBaseByOwnerAndKbID *RepositoryIMock) GetKnowledgeBaseByOwnerAndKbIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseByOwnerAndKbID.afterGetKnowledgeBaseByOwnerAndKbIDCounter)
}

// GetKnowledgeBaseByOwnerAndKbIDBeforeCounter returns a count of RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID invocations
func (mmGetKnowledgeBaseByOwnerAndKbID *RepositoryIMock) GetKnowledgeBaseByOwnerAndKbIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseByOwnerAndKbID.beforeGetKnowledgeBaseByOwnerAndKbIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryIMockGetKnowledgeBaseByOwnerAndKbID) Calls() []*RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParams {
	mmGetKnowledgeBaseByOwnerAndKbID.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetKnowledgeBaseByOwnerAndKbIDParams, len(mmGetKnowledgeBaseByOwnerAndKbID.callArgs))
	copy(argCopy, mmGetKnowledgeBaseByOwnerAndKbID.callArgs)

	mmGetKnowledgeBaseByOwnerAndKbID.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBaseByOwnerAndKbIDDone returns true if the count of the GetKnowledgeBaseByOwnerAndKbID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetKnowledgeBaseByOwnerAndKbIDDone() bool {
	for _, e := range m.GetKnowledgeBaseByOwnerAndKbIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBaseByOwnerAndKbIDMock.invocationsDone()
}

// MinimockGetKnowledgeBaseByOwnerAndKbIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetKnowledgeBaseByOwnerAndKbIDInspect() {
	for _, e := range m.GetKnowledgeBaseByOwnerAndKbIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID with params: %#v", *e.params)
		}
	}

	afterGetKnowledgeBaseByOwnerAndKbIDCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBaseByOwnerAndKbIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation != nil && afterGetKnowledgeBaseByOwnerAndKbIDCounter < 1 {
		if m.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID with params: %#v", *m.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBaseByOwnerAndKbID != nil && afterGetKnowledgeBaseByOwnerAndKbIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID")
	}

	if !m.GetKnowledgeBaseByOwnerAndKbIDMock.invocationsDone() && afterGetKnowledgeBaseByOwnerAndKbIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetKnowledgeBaseByOwnerAndKbID but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBaseByOwnerAndKbIDMock.expectedInvocations), afterGetKnowledgeBaseByOwnerAndKbIDCounter)
	}
}

type mRepositoryIMockGetKnowledgeBaseCountByOwner struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetKnowledgeBaseCountByOwnerExpectation
	expectations       []*RepositoryIMockGetKnowledgeBaseCountByOwnerExpectation

	callArgs []*RepositoryIMockGetKnowledgeBaseCountByOwnerParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetKnowledgeBaseCountByOwnerExpectation specifies expectation struct of the RepositoryI.GetKnowledgeBaseCountByOwner
type RepositoryIMockGetKnowledgeBaseCountByOwnerExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetKnowledgeBaseCountByOwnerParams
	paramPtrs *RepositoryIMockGetKnowledgeBaseCountByOwnerParamPtrs
	results   *RepositoryIMockGetKnowledgeBaseCountByOwnerResults
	Counter   uint64
}

// RepositoryIMockGetKnowledgeBaseCountByOwnerParams contains parameters of the RepositoryI.GetKnowledgeBaseCountByOwner
type RepositoryIMockGetKnowledgeBaseCountByOwnerParams struct {
	ctx         context.Context
	ownerUID    string
	catalogType artifactpb.CatalogType
}

// RepositoryIMockGetKnowledgeBaseCountByOwnerParamPtrs contains pointers to parameters of the RepositoryI.GetKnowledgeBaseCountByOwner
type RepositoryIMockGetKnowledgeBaseCountByOwnerParamPtrs struct {
	ctx         *context.Context
	ownerUID    *string
	catalogType *artifactpb.CatalogType
}

// RepositoryIMockGetKnowledgeBaseCountByOwnerResults contains results of the RepositoryI.GetKnowledgeBaseCountByOwner
type RepositoryIMockGetKnowledgeBaseCountByOwnerResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for RepositoryI.GetKnowledgeBaseCountByOwner
func (mmGetKnowledgeBaseCountByOwner *mRepositoryIMockGetKnowledgeBaseCountByOwner) Expect(ctx context.Context, ownerUID string, catalogType artifactpb.CatalogType) *mRepositoryIMockGetKnowledgeBaseCountByOwner {
	if mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseCountByOwner mock is already set by Set")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation = &RepositoryIMockGetKnowledgeBaseCountByOwnerExpectation{}
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseCountByOwner mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBaseCountByOwner.defaultExpectation.params = &RepositoryIMockGetKnowledgeBaseCountByOwnerParams{ctx, ownerUID, catalogType}
	for _, e := range mmGetKnowledgeBaseCountByOwner.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBaseCountByOwner.defaultExpectation.params) {
			mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBaseCountByOwner.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBaseCountByOwner
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetKnowledgeBaseCountByOwner
func (mmGetKnowledgeBaseCountByOwner *mRepositoryIMockGetKnowledgeBaseCountByOwner) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetKnowledgeBaseCountByOwner {
	if mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseCountByOwner mock is already set by Set")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation = &RepositoryIMockGetKnowledgeBaseCountByOwnerExpectation{}
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation.params != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseCountByOwner mock is already set by Expect")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs = &RepositoryIMockGetKnowledgeBaseCountByOwnerParamPtrs{}
	}
	mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetKnowledgeBaseCountByOwner
}

// ExpectOwnerUIDParam2 sets up expected param ownerUID for RepositoryI.GetKnowledgeBaseCountByOwner
func (mmGetKnowledgeBaseCountByOwner *mRepositoryIMockGetKnowledgeBaseCountByOwner) ExpectOwnerUIDParam2(ownerUID string) *mRepositoryIMockGetKnowledgeBaseCountByOwner {
	if mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseCountByOwner mock is already set by Set")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation = &RepositoryIMockGetKnowledgeBaseCountByOwnerExpectation{}
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation.params != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseCountByOwner mock is already set by Expect")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs = &RepositoryIMockGetKnowledgeBaseCountByOwnerParamPtrs{}
	}
	mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs.ownerUID = &ownerUID

	return mmGetKnowledgeBaseCountByOwner
}

// ExpectCatalogTypeParam3 sets up expected param catalogType for RepositoryI.GetKnowledgeBaseCountByOwner
func (mmGetKnowledgeBaseCountByOwner *mRepositoryIMockGetKnowledgeBaseCountByOwner) ExpectCatalogTypeParam3(catalogType artifactpb.CatalogType) *mRepositoryIMockGetKnowledgeBaseCountByOwner {
	if mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseCountByOwner mock is already set by Set")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation = &RepositoryIMockGetKnowledgeBaseCountByOwnerExpectation{}
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation.params != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseCountByOwner mock is already set by Expect")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs = &RepositoryIMockGetKnowledgeBaseCountByOwnerParamPtrs{}
	}
	mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs.catalogType = &catalogType

	return mmGetKnowledgeBaseCountByOwner
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetKnowledgeBaseCountByOwner
func (mmGetKnowledgeBaseCountByOwner *mRepositoryIMockGetKnowledgeBaseCountByOwner) Inspect(f func(ctx context.Context, ownerUID string, catalogType artifactpb.CatalogType)) *mRepositoryIMockGetKnowledgeBaseCountByOwner {
	if mmGetKnowledgeBaseCountByOwner.mock.inspectFuncGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetKnowledgeBaseCountByOwner")
	}

	mmGetKnowledgeBaseCountByOwner.mock.inspectFuncGetKnowledgeBaseCountByOwner = f

	return mmGetKnowledgeBaseCountByOwner
}

// Return sets up results that will be returned by RepositoryI.GetKnowledgeBaseCountByOwner
func (mmGetKnowledgeBaseCountByOwner *mRepositoryIMockGetKnowledgeBaseCountByOwner) Return(i1 int64, err error) *RepositoryIMock {
	if mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseCountByOwner mock is already set by Set")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation = &RepositoryIMockGetKnowledgeBaseCountByOwnerExpectation{mock: mmGetKnowledgeBaseCountByOwner.mock}
	}
	mmGetKnowledgeBaseCountByOwner.defaultExpectation.results = &RepositoryIMockGetKnowledgeBaseCountByOwnerResults{i1, err}
	return mmGetKnowledgeBaseCountByOwner.mock
}

// Set uses given function f to mock the RepositoryI.GetKnowledgeBaseCountByOwner method
func (mmGetKnowledgeBaseCountByOwner *mRepositoryIMockGetKnowledgeBaseCountByOwner) Set(f func(ctx context.Context, ownerUID string, catalogType artifactpb.CatalogType) (i1 int64, err error)) *RepositoryIMock {
	if mmGetKnowledgeBaseCountByOwner.defaultExpectation != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetKnowledgeBaseCountByOwner method")
	}

	if len(mmGetKnowledgeBaseCountByOwner.expectations) > 0 {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetKnowledgeBaseCountByOwner method")
	}

	mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner = f
	return mmGetKnowledgeBaseCountByOwner.mock
}

// When sets expectation for the RepositoryI.GetKnowledgeBaseCountByOwner which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBaseCountByOwner *mRepositoryIMockGetKnowledgeBaseCountByOwner) When(ctx context.Context, ownerUID string, catalogType artifactpb.CatalogType) *RepositoryIMockGetKnowledgeBaseCountByOwnerExpectation {
	if mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseCountByOwner mock is already set by Set")
	}

	expectation := &RepositoryIMockGetKnowledgeBaseCountByOwnerExpectation{
		mock:   mmGetKnowledgeBaseCountByOwner.mock,
		params: &RepositoryIMockGetKnowledgeBaseCountByOwnerParams{ctx, ownerUID, catalogType},
	}
	mmGetKnowledgeBaseCountByOwner.expectations = append(mmGetKnowledgeBaseCountByOwner.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetKnowledgeBaseCountByOwner return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetKnowledgeBaseCountByOwnerExpectation) Then(i1 int64, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetKnowledgeBaseCountByOwnerResults{i1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetKnowledgeBaseCountByOwner should be invoked
func (mmGetKnowledgeBaseCountByOwner *mRepositoryIMockGetKnowledgeBaseCountByOwner) Times(n uint64) *mRepositoryIMockGetKnowledgeBaseCountByOwner {
	if n == 0 {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("Times of RepositoryIMock.GetKnowledgeBaseCountByOwner mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBaseCountByOwner.expectedInvocations, n)
	return mmGetKnowledgeBaseCountByOwner
}

func (mmGetKnowledgeBaseCountByOwner *mRepositoryIMockGetKnowledgeBaseCountByOwner) invocationsDone() bool {
	if len(mmGetKnowledgeBaseCountByOwner.expectations) == 0 && mmGetKnowledgeBaseCountByOwner.defaultExpectation == nil && mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseCountByOwner.mock.afterGetKnowledgeBaseCountByOwnerCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseCountByOwner.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBaseCountByOwner implements repository.RepositoryI
func (mmGetKnowledgeBaseCountByOwner *RepositoryIMock) GetKnowledgeBaseCountByOwner(ctx context.Context, ownerUID string, catalogType artifactpb.CatalogType) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBaseCountByOwner.beforeGetKnowledgeBaseCountByOwnerCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBaseCountByOwner.afterGetKnowledgeBaseCountByOwnerCounter, 1)

	if mmGetKnowledgeBaseCountByOwner.inspectFuncGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.inspectFuncGetKnowledgeBaseCountByOwner(ctx, ownerUID, catalogType)
	}

	mm_params := RepositoryIMockGetKnowledgeBaseCountByOwnerParams{ctx, ownerUID, catalogType}

	// Record call args
	mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.mutex.Lock()
	mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.callArgs = append(mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.callArgs, &mm_params)
	mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetKnowledgeBaseCountByOwnerParams{ctx, ownerUID, catalogType}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBaseCountByOwner.t.Errorf("RepositoryIMock.GetKnowledgeBaseCountByOwner got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmGetKnowledgeBaseCountByOwner.t.Errorf("RepositoryIMock.GetKnowledgeBaseCountByOwner got unexpected parameter ownerUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

			if mm_want_ptrs.catalogType != nil && !minimock.Equal(*mm_want_ptrs.catalogType, mm_got.catalogType) {
				mmGetKnowledgeBaseCountByOwner.t.Errorf("RepositoryIMock.GetKnowledgeBaseCountByOwner got unexpected parameter catalogType, want: %#v, got: %#v%s\n", *mm_want_ptrs.catalogType, mm_got.catalogType, minimock.Diff(*mm_want_ptrs.catalogType, mm_got.catalogType))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBaseCountByOwner.t.Errorf("RepositoryIMock.GetKnowledgeBaseCountByOwner got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBaseCountByOwner.t.Fatal("No results are set for the RepositoryIMock.GetKnowledgeBaseCountByOwner")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetKnowledgeBaseCountByOwner.funcGetKnowledgeBaseCountByOwner != nil {
		return mmGetKnowledgeBaseCountByOwner.funcGetKnowledgeBaseCountByOwner(ctx, ownerUID, catalogType)
	}
	mmGetKnowledgeBaseCountByOwner.t.Fatalf("Unexpected call to RepositoryIMock.GetKnowledgeBaseCountByOwner. %v %v %v", ctx, ownerUID, catalogType)
	return
}

// GetKnowledgeBaseCountByOwnerAfterCounter returns a count of finished RepositoryIMock.GetKnowledgeBaseCountByOwner invocations
func (mmGetKnowledgeBaseCountByOwner *RepositoryIMock) GetKnowledgeBaseCountByOwnerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseCountByOwner.afterGetKnowledgeBaseCountByOwnerCounter)
}

// GetKnowledgeBaseCountByOwnerBeforeCounter returns a count of RepositoryIMock.GetKnowledgeBaseCountByOwner invocations
func (mmGetKnowledgeBaseCountByOwner *RepositoryIMock) GetKnowledgeBaseCountByOwnerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseCountByOwner.beforeGetKnowledgeBaseCountByOwnerCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetKnowledgeBaseCountByOwner.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBaseCountByOwner *mRepositoryIMockGetKnowledgeBaseCountByOwner) Calls() []*RepositoryIMockGetKnowledgeBaseCountByOwnerParams {
	mmGetKnowledgeBaseCountByOwner.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetKnowledgeBaseCountByOwnerParams, len(mmGetKnowledgeBaseCountByOwner.callArgs))
	copy(argCopy, mmGetKnowledgeBaseCountByOwner.callArgs)

	mmGetKnowledgeBaseCountByOwner.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBaseCountByOwnerDone returns true if the count of the GetKnowledgeBaseCountByOwner invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetKnowledgeBaseCountByOwnerDone() bool {
	for _, e := range m.GetKnowledgeBaseCountByOwnerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBaseCountByOwnerMock.invocationsDone()
}

// MinimockGetKnowledgeBaseCountByOwnerInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetKnowledgeBaseCountByOwnerInspect() {
	for _, e := range m.GetKnowledgeBaseCountByOwnerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetKnowledgeBaseCountByOwner with params: %#v", *e.params)
		}
	}

	afterGetKnowledgeBaseCountByOwnerCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBaseCountByOwnerCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBaseCountByOwnerMock.defaultExpectation != nil && afterGetKnowledgeBaseCountByOwnerCounter < 1 {
		if m.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetKnowledgeBaseCountByOwner")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetKnowledgeBaseCountByOwner with params: %#v", *m.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBaseCountByOwner != nil && afterGetKnowledgeBaseCountByOwnerCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetKnowledgeBaseCountByOwner")
	}

	if !m.GetKnowledgeBaseCountByOwnerMock.invocationsDone() && afterGetKnowledgeBaseCountByOwnerCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetKnowledgeBaseCountByOwner but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBaseCountByOwnerMock.expectedInvocations), afterGetKnowledgeBaseCountByOwnerCounter)
	}
}

type mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetKnowledgeBaseFilesByFileUIDsExpectation
	expectations       []*RepositoryIMockGetKnowledgeBaseFilesByFileUIDsExpectation

	callArgs []*RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetKnowledgeBaseFilesByFileUIDsExpectation specifies expectation struct of the RepositoryI.GetKnowledgeBaseFilesByFileUIDs
type RepositoryIMockGetKnowledgeBaseFilesByFileUIDsExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParams
	paramPtrs *RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParamPtrs
	results   *RepositoryIMockGetKnowledgeBaseFilesByFileUIDsResults
	Counter   uint64
}

// RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParams contains parameters of the RepositoryI.GetKnowledgeBaseFilesByFileUIDs
type RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParams struct {
	ctx      context.Context
	fileUIDs []uuid.UUID
	columns  []string
}

// RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParamPtrs contains pointers to parameters of the RepositoryI.GetKnowledgeBaseFilesByFileUIDs
type RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParamPtrs struct {
	ctx      *context.Context
	fileUIDs *[]uuid.UUID
	columns  *[]string
}

// RepositoryIMockGetKnowledgeBaseFilesByFileUIDsResults contains results of the RepositoryI.GetKnowledgeBaseFilesByFileUIDs
type RepositoryIMockGetKnowledgeBaseFilesByFileUIDsResults struct {
	ka1 []mm_repository.KnowledgeBaseFile
	err error
}

// Expect sets up expected params for RepositoryI.GetKnowledgeBaseFilesByFileUIDs
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs) Expect(ctx context.Context, fileUIDs []uuid.UUID, columns ...string) *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs {
	if mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation = &RepositoryIMockGetKnowledgeBaseFilesByFileUIDsExpectation{}
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.params = &RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParams{ctx, fileUIDs, columns}
	for _, e := range mmGetKnowledgeBaseFilesByFileUIDs.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.params) {
			mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBaseFilesByFileUIDs
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetKnowledgeBaseFilesByFileUIDs
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs {
	if mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation = &RepositoryIMockGetKnowledgeBaseFilesByFileUIDsExpectation{}
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.params != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Expect")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs = &RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParamPtrs{}
	}
	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetKnowledgeBaseFilesByFileUIDs
}

// ExpectFileUIDsParam2 sets up expected param fileUIDs for RepositoryI.GetKnowledgeBaseFilesByFileUIDs
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs) ExpectFileUIDsParam2(fileUIDs []uuid.UUID) *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs {
	if mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation = &RepositoryIMockGetKnowledgeBaseFilesByFileUIDsExpectation{}
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.params != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Expect")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs = &RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParamPtrs{}
	}
	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs.fileUIDs = &fileUIDs

	return mmGetKnowledgeBaseFilesByFileUIDs
}

// ExpectColumnsParam3 sets up expected param columns for RepositoryI.GetKnowledgeBaseFilesByFileUIDs
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs) ExpectColumnsParam3(columns ...string) *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs {
	if mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation = &RepositoryIMockGetKnowledgeBaseFilesByFileUIDsExpectation{}
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.params != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Expect")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs = &RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParamPtrs{}
	}
	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs.columns = &columns

	return mmGetKnowledgeBaseFilesByFileUIDs
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetKnowledgeBaseFilesByFileUIDs
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs) Inspect(f func(ctx context.Context, fileUIDs []uuid.UUID, columns ...string)) *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs {
	if mmGetKnowledgeBaseFilesByFileUIDs.mock.inspectFuncGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs")
	}

	mmGetKnowledgeBaseFilesByFileUIDs.mock.inspectFuncGetKnowledgeBaseFilesByFileUIDs = f

	return mmGetKnowledgeBaseFilesByFileUIDs
}

// Return sets up results that will be returned by RepositoryI.GetKnowledgeBaseFilesByFileUIDs
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs) Return(ka1 []mm_repository.KnowledgeBaseFile, err error) *RepositoryIMock {
	if mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation = &RepositoryIMockGetKnowledgeBaseFilesByFileUIDsExpectation{mock: mmGetKnowledgeBaseFilesByFileUIDs.mock}
	}
	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.results = &RepositoryIMockGetKnowledgeBaseFilesByFileUIDsResults{ka1, err}
	return mmGetKnowledgeBaseFilesByFileUIDs.mock
}

// Set uses given function f to mock the RepositoryI.GetKnowledgeBaseFilesByFileUIDs method
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs) Set(f func(ctx context.Context, fileUIDs []uuid.UUID, columns ...string) (ka1 []mm_repository.KnowledgeBaseFile, err error)) *RepositoryIMock {
	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetKnowledgeBaseFilesByFileUIDs method")
	}

	if len(mmGetKnowledgeBaseFilesByFileUIDs.expectations) > 0 {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetKnowledgeBaseFilesByFileUIDs method")
	}

	mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs = f
	return mmGetKnowledgeBaseFilesByFileUIDs.mock
}

// When sets expectation for the RepositoryI.GetKnowledgeBaseFilesByFileUIDs which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs) When(ctx context.Context, fileUIDs []uuid.UUID, columns ...string) *RepositoryIMockGetKnowledgeBaseFilesByFileUIDsExpectation {
	if mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Set")
	}

	expectation := &RepositoryIMockGetKnowledgeBaseFilesByFileUIDsExpectation{
		mock:   mmGetKnowledgeBaseFilesByFileUIDs.mock,
		params: &RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParams{ctx, fileUIDs, columns},
	}
	mmGetKnowledgeBaseFilesByFileUIDs.expectations = append(mmGetKnowledgeBaseFilesByFileUIDs.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetKnowledgeBaseFilesByFileUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetKnowledgeBaseFilesByFileUIDsExpectation) Then(ka1 []mm_repository.KnowledgeBaseFile, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetKnowledgeBaseFilesByFileUIDsResults{ka1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetKnowledgeBaseFilesByFileUIDs should be invoked
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs) Times(n uint64) *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs {
	if n == 0 {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("Times of RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBaseFilesByFileUIDs.expectedInvocations, n)
	return mmGetKnowledgeBaseFilesByFileUIDs
}

func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs) invocationsDone() bool {
	if len(mmGetKnowledgeBaseFilesByFileUIDs.expectations) == 0 && mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation == nil && mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseFilesByFileUIDs.mock.afterGetKnowledgeBaseFilesByFileUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseFilesByFileUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBaseFilesByFileUIDs implements repository.RepositoryI
func (mmGetKnowledgeBaseFilesByFileUIDs *RepositoryIMock) GetKnowledgeBaseFilesByFileUIDs(ctx context.Context, fileUIDs []uuid.UUID, columns ...string) (ka1 []mm_repository.KnowledgeBaseFile, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBaseFilesByFileUIDs.beforeGetKnowledgeBaseFilesByFileUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBaseFilesByFileUIDs.afterGetKnowledgeBaseFilesByFileUIDsCounter, 1)

	if mmGetKnowledgeBaseFilesByFileUIDs.inspectFuncGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.inspectFuncGetKnowledgeBaseFilesByFileUIDs(ctx, fileUIDs, columns...)
	}

	mm_params := RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParams{ctx, fileUIDs, columns}

	// Record call args
	mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.mutex.Lock()
	mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.callArgs = append(mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.callArgs, &mm_params)
	mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParams{ctx, fileUIDs, columns}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBaseFilesByFileUIDs.t.Errorf("RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUIDs != nil && !minimock.Equal(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs) {
				mmGetKnowledgeBaseFilesByFileUIDs.t.Errorf("RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs got unexpected parameter fileUIDs, want: %#v, got: %#v%s\n", *mm_want_ptrs.fileUIDs, mm_got.fileUIDs, minimock.Diff(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs))
			}

			if mm_want_ptrs.columns != nil && !minimock.Equal(*mm_want_ptrs.columns, mm_got.columns) {
				mmGetKnowledgeBaseFilesByFileUIDs.t.Errorf("RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs got unexpected parameter columns, want: %#v, got: %#v%s\n", *mm_want_ptrs.columns, mm_got.columns, minimock.Diff(*mm_want_ptrs.columns, mm_got.columns))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBaseFilesByFileUIDs.t.Errorf("RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBaseFilesByFileUIDs.t.Fatal("No results are set for the RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmGetKnowledgeBaseFilesByFileUIDs.funcGetKnowledgeBaseFilesByFileUIDs != nil {
		return mmGetKnowledgeBaseFilesByFileUIDs.funcGetKnowledgeBaseFilesByFileUIDs(ctx, fileUIDs, columns...)
	}
	mmGetKnowledgeBaseFilesByFileUIDs.t.Fatalf("Unexpected call to RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs. %v %v %v", ctx, fileUIDs, columns)
	return
}

// GetKnowledgeBaseFilesByFileUIDsAfterCounter returns a count of finished RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs invocations
func (mmGetKnowledgeBaseFilesByFileUIDs *RepositoryIMock) GetKnowledgeBaseFilesByFileUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseFilesByFileUIDs.afterGetKnowledgeBaseFilesByFileUIDsCounter)
}

// GetKnowledgeBaseFilesByFileUIDsBeforeCounter returns a count of RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs invocations
func (mmGetKnowledgeBaseFilesByFileUIDs *RepositoryIMock) GetKnowledgeBaseFilesByFileUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseFilesByFileUIDs.beforeGetKnowledgeBaseFilesByFileUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryIMockGetKnowledgeBaseFilesByFileUIDs) Calls() []*RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParams {
	mmGetKnowledgeBaseFilesByFileUIDs.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetKnowledgeBaseFilesByFileUIDsParams, len(mmGetKnowledgeBaseFilesByFileUIDs.callArgs))
	copy(argCopy, mmGetKnowledgeBaseFilesByFileUIDs.callArgs)

	mmGetKnowledgeBaseFilesByFileUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBaseFilesByFileUIDsDone returns true if the count of the GetKnowledgeBaseFilesByFileUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetKnowledgeBaseFilesByFileUIDsDone() bool {
	for _, e := range m.GetKnowledgeBaseFilesByFileUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBaseFilesByFileUIDsMock.invocationsDone()
}

// MinimockGetKnowledgeBaseFilesByFileUIDsInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetKnowledgeBaseFilesByFileUIDsInspect() {
	for _, e := range m.GetKnowledgeBaseFilesByFileUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs with params: %#v", *e.params)
		}
	}

	afterGetKnowledgeBaseFilesByFileUIDsCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBaseFilesByFileUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation != nil && afterGetKnowledgeBaseFilesByFileUIDsCounter < 1 {
		if m.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs with params: %#v", *m.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBaseFilesByFileUIDs != nil && afterGetKnowledgeBaseFilesByFileUIDsCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs")
	}

	if !m.GetKnowledgeBaseFilesByFileUIDsMock.invocationsDone() && afterGetKnowledgeBaseFilesByFileUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetKnowledgeBaseFilesByFileUIDs but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBaseFilesByFileUIDsMock.expectedInvocations), afterGetKnowledgeBaseFilesByFileUIDsCounter)
	}
}

type mRepositoryIMockGetKnowledgeBasesByUIDs struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetKnowledgeBasesByUIDsExpectation
	expectations       []*RepositoryIMockGetKnowledgeBasesByUIDsExpectation

	callArgs []*RepositoryIMockGetKnowledgeBasesByUIDsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetKnowledgeBasesByUIDsExpectation specifies expectation struct of the RepositoryI.GetKnowledgeBasesByUIDs
type RepositoryIMockGetKnowledgeBasesByUIDsExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetKnowledgeBasesByUIDsParams
	paramPtrs *RepositoryIMockGetKnowledgeBasesByUIDsParamPtrs
	results   *RepositoryIMockGetKnowledgeBasesByUIDsResults
	Counter   uint64
}

// RepositoryIMockGetKnowledgeBasesByUIDsParams contains parameters of the RepositoryI.GetKnowledgeBasesByUIDs
type RepositoryIMockGetKnowledgeBasesByUIDsParams struct {
	ctx    context.Context
	kbUIDs []uuid.UUID
}

// RepositoryIMockGetKnowledgeBasesByUIDsParamPtrs contains pointers to parameters of the RepositoryI.GetKnowledgeBasesByUIDs
type RepositoryIMockGetKnowledgeBasesByUIDsParamPtrs struct {
	ctx    *context.Context
	kbUIDs *[]uuid.UUID
}

// RepositoryIMockGetKnowledgeBasesByUIDsResults contains results of the RepositoryI.GetKnowledgeBasesByUIDs
type RepositoryIMockGetKnowledgeBasesByUIDsResults struct {
	ka1 []mm_repository.KnowledgeBase
	err error
}

// Expect sets up expected params for RepositoryI.GetKnowledgeBasesByUIDs
func (mmGetKnowledgeBasesByUIDs *mRepositoryIMockGetKnowledgeBasesByUIDs) Expect(ctx context.Context, kbUIDs []uuid.UUID) *mRepositoryIMockGetKnowledgeBasesByUIDs {
	if mmGetKnowledgeBasesByUIDs.mock.funcGetKnowledgeBasesByUIDs != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBasesByUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBasesByUIDs.defaultExpectation == nil {
		mmGetKnowledgeBasesByUIDs.defaultExpectation = &RepositoryIMockGetKnowledgeBasesByUIDsExpectation{}
	}

	if mmGetKnowledgeBasesByUIDs.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBasesByUIDs mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBasesByUIDs.defaultExpectation.params = &RepositoryIMockGetKnowledgeBasesByUIDsParams{ctx, kbUIDs}
	for _, e := range mmGetKnowledgeBasesByUIDs.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBasesByUIDs.defaultExpectation.params) {
			mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBasesByUIDs.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBasesByUIDs
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetKnowledgeBasesByUIDs
func (mmGetKnowledgeBasesByUIDs *mRepositoryIMockGetKnowledgeBasesByUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetKnowledgeBasesByUIDs {
	if mmGetKnowledgeBasesByUIDs.mock.funcGetKnowledgeBasesByUIDs != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBasesByUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBasesByUIDs.defaultExpectation == nil {
		mmGetKnowledgeBasesByUIDs.defaultExpectation = &RepositoryIMockGetKnowledgeBasesByUIDsExpectation{}
	}

	if mmGetKnowledgeBasesByUIDs.defaultExpectation.params != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBasesByUIDs mock is already set by Expect")
	}

	if mmGetKnowledgeBasesByUIDs.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBasesByUIDs.defaultExpectation.paramPtrs = &RepositoryIMockGetKnowledgeBasesByUIDsParamPtrs{}
	}
	mmGetKnowledgeBasesByUIDs.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetKnowledgeBasesByUIDs
}

// ExpectKbUIDsParam2 sets up expected param kbUIDs for RepositoryI.GetKnowledgeBasesByUIDs
func (mmGetKnowledgeBasesByUIDs *mRepositoryIMockGetKnowledgeBasesByUIDs) ExpectKbUIDsParam2(kbUIDs []uuid.UUID) *mRepositoryIMockGetKnowledgeBasesByUIDs {
	if mmGetKnowledgeBasesByUIDs.mock.funcGetKnowledgeBasesByUIDs != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBasesByUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBasesByUIDs.defaultExpectation == nil {
		mmGetKnowledgeBasesByUIDs.defaultExpectation = &RepositoryIMockGetKnowledgeBasesByUIDsExpectation{}
	}

	if mmGetKnowledgeBasesByUIDs.defaultExpectation.params != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBasesByUIDs mock is already set by Expect")
	}

	if mmGetKnowledgeBasesByUIDs.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBasesByUIDs.defaultExpectation.paramPtrs = &RepositoryIMockGetKnowledgeBasesByUIDsParamPtrs{}
	}
	mmGetKnowledgeBasesByUIDs.defaultExpectation.paramPtrs.kbUIDs = &kbUIDs

	return mmGetKnowledgeBasesByUIDs
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetKnowledgeBasesByUIDs
func (mmGetKnowledgeBasesByUIDs *mRepositoryIMockGetKnowledgeBasesByUIDs) Inspect(f func(ctx context.Context, kbUIDs []uuid.UUID)) *mRepositoryIMockGetKnowledgeBasesByUIDs {
	if mmGetKnowledgeBasesByUIDs.mock.inspectFuncGetKnowledgeBasesByUIDs != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetKnowledgeBasesByUIDs")
	}

	mmGetKnowledgeBasesByUIDs.mock.inspectFuncGetKnowledgeBasesByUIDs = f

	return mmGetKnowledgeBasesByUIDs
}

// Return sets up results that will be returned by RepositoryI.GetKnowledgeBasesByUIDs
func (mmGetKnowledgeBasesByUIDs *mRepositoryIMockGetKnowledgeBasesByUIDs) Return(ka1 []mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	if mmGetKnowledgeBasesByUIDs.mock.funcGetKnowledgeBasesByUIDs != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBasesByUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBasesByUIDs.defaultExpectation == nil {
		mmGetKnowledgeBasesByUIDs.defaultExpectation = &RepositoryIMockGetKnowledgeBasesByUIDsExpectation{mock: mmGetKnowledgeBasesByUIDs.mock}
	}
	mmGetKnowledgeBasesByUIDs.defaultExpectation.results = &RepositoryIMockGetKnowledgeBasesByUIDsResults{ka1, err}
	return mmGetKnowledgeBasesByUIDs.mock
}

// Set uses given function f to mock the RepositoryI.GetKnowledgeBasesByUIDs method
func (mmGetKnowledgeBasesByUIDs *mRepositoryIMockGetKnowledgeBasesByUIDs) Set(f func(ctx context.Context, kbUIDs []uuid.UUID) (ka1 []mm_repository.KnowledgeBase, err error)) *RepositoryIMock {
	if mmGetKnowledgeBasesByUIDs.defaultExpectation != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetKnowledgeBasesByUIDs method")
	}

	if len(mmGetKnowledgeBasesByUIDs.expectations) > 0 {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetKnowledgeBasesByUIDs method")
	}

	mmGetKnowledgeBasesByUIDs.mock.funcGetKnowledgeBasesByUIDs = f
	return mmGetKnowledgeBasesByUIDs.mock
}

// When sets expectation for the RepositoryI.GetKnowledgeBasesByUIDs which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBasesByUIDs *mRepositoryIMockGetKnowledgeBasesByUIDs) When(ctx context.Context, kbUIDs []uuid.UUID) *RepositoryIMockGetKnowledgeBasesByUIDsExpectation {
	if mmGetKnowledgeBasesByUIDs.mock.funcGetKnowledgeBasesByUIDs != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBasesByUIDs mock is already set by Set")
	}

	expectation := &RepositoryIMockGetKnowledgeBasesByUIDsExpectation{
		mock:   mmGetKnowledgeBasesByUIDs.mock,
		params: &RepositoryIMockGetKnowledgeBasesByUIDsParams{ctx, kbUIDs},
	}
	mmGetKnowledgeBasesByUIDs.expectations = append(mmGetKnowledgeBasesByUIDs.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetKnowledgeBasesByUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetKnowledgeBasesByUIDsExpectation) Then(ka1 []mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetKnowledgeBasesByUIDsResults{ka1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetKnowledgeBasesByUIDs should be invoked
func (mmGetKnowledgeBasesByUIDs *mRepositoryIMockGetKnowledgeBasesByUIDs) Times(n uint64) *mRepositoryIMockGetKnowledgeBasesByUIDs {
	if n == 0 {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("Times of RepositoryIMock.GetKnowledgeBasesByUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBasesByUIDs.expectedInvocations, n)
	return mmGetKnowledgeBasesByUIDs
}

func (mmGetKnowledgeBasesByUIDs *mRepositoryIMockGetKnowledgeBasesByUIDs) invocationsDone() bool {
	if len(mmGetKnowledgeBasesByUIDs.expectations) == 0 && mmGetKnowledgeBasesByUIDs.defaultExpectation == nil && mmGetKnowledgeBasesByUIDs.mock.funcGetKnowledgeBasesByUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBasesByUIDs.mock.afterGetKnowledgeBasesByUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBasesByUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBasesByUIDs implements repository.RepositoryI
func (mmGetKnowledgeBasesByUIDs *RepositoryIMock) GetKnowledgeBasesByUIDs(ctx context.Context, kbUIDs []uuid.UUID) (ka1 []mm_repository.KnowledgeBase, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBasesByUIDs.beforeGetKnowledgeBasesByUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBasesByUIDs.afterGetKnowledgeBasesByUIDsCounter, 1)

	if mmGetKnowledgeBasesByUIDs.inspectFuncGetKnowledgeBasesByUIDs != nil {
		mmGetKnowledgeBasesByUIDs.inspectFuncGetKnowledgeBasesByUIDs(ctx, kbUIDs)
	}

	mm_params := RepositoryIMockGetKnowledgeBasesByUIDsParams{ctx, kbUIDs}

	// Record call args
	mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.mutex.Lock()
	mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.callArgs = append(mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.callArgs, &mm_params)
	mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetKnowledgeBasesByUIDsParams{ctx, kbUIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBasesByUIDs.t.Errorf("RepositoryIMock.GetKnowledgeBasesByUIDs got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUIDs != nil && !minimock.Equal(*mm_want_ptrs.kbUIDs, mm_got.kbUIDs) {
				mmGetKnowledgeBasesByUIDs.t.Errorf("RepositoryIMock.GetKnowledgeBasesByUIDs got unexpected parameter kbUIDs, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbUIDs, mm_got.kbUIDs, minimock.Diff(*mm_want_ptrs.kbUIDs, mm_got.kbUIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBasesByUIDs.t.Errorf("RepositoryIMock.GetKnowledgeBasesByUIDs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBasesByUIDs.t.Fatal("No results are set for the RepositoryIMock.GetKnowledgeBasesByUIDs")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmGetKnowledgeBasesByUIDs.funcGetKnowledgeBasesByUIDs != nil {
		return mmGetKnowledgeBasesByUIDs.funcGetKnowledgeBasesByUIDs(ctx, kbUIDs)
	}
	mmGetKnowledgeBasesByUIDs.t.Fatalf("Unexpected call to RepositoryIMock.GetKnowledgeBasesByUIDs. %v %v", ctx, kbUIDs)
	return
}

// GetKnowledgeBasesByUIDsAfterCounter returns a count of finished RepositoryIMock.GetKnowledgeBasesByUIDs invocations
func (mmGetKnowledgeBasesByUIDs *RepositoryIMock) GetKnowledgeBasesByUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBasesByUIDs.afterGetKnowledgeBasesByUIDsCounter)
}

// GetKnowledgeBasesByUIDsBeforeCounter returns a count of RepositoryIMock.GetKnowledgeBasesByUIDs invocations
func (mmGetKnowledgeBasesByUIDs *RepositoryIMock) GetKnowledgeBasesByUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBasesByUIDs.beforeGetKnowledgeBasesByUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetKnowledgeBasesByUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBasesByUIDs *mRepositoryIMockGetKnowledgeBasesByUIDs) Calls() []*RepositoryIMockGetKnowledgeBasesByUIDsParams {
	mmGetKnowledgeBasesByUIDs.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetKnowledgeBasesByUIDsParams, len(mmGetKnowledgeBasesByUIDs.callArgs))
	copy(argCopy, mmGetKnowledgeBasesByUIDs.callArgs)

	mmGetKnowledgeBasesByUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBasesByUIDsDone returns true if the count of the GetKnowledgeBasesByUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetKnowledgeBasesByUIDsDone() bool {
	for _, e := range m.GetKnowledgeBasesByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBasesByUIDsMock.invocationsDone()
}

// MinimockGetKnowledgeBasesByUIDsInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetKnowledgeBasesByUIDsInspect() {
	for _, e := range m.GetKnowledgeBasesByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetKnowledgeBasesByUIDs with params: %#v", *e.params)
		}
	}

	afterGetKnowledgeBasesByUIDsCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBasesByUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBasesByUIDsMock.defaultExpectation != nil && afterGetKnowledgeBasesByUIDsCounter < 1 {
		if m.GetKnowledgeBasesByUIDsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetKnowledgeBasesByUIDs")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetKnowledgeBasesByUIDs with params: %#v", *m.GetKnowledgeBasesByUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBasesByUIDs != nil && afterGetKnowledgeBasesByUIDsCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetKnowledgeBasesByUIDs")
	}

	if !m.GetKnowledgeBasesByUIDsMock.invocationsDone() && afterGetKnowledgeBasesByUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetKnowledgeBasesByUIDs but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBasesByUIDsMock.expectedInvocations), afterGetKnowledgeBasesByUIDsCounter)
	}
}

type mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDExpectation
	expectations       []*RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDExpectation

	callArgs []*RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDExpectation specifies expectation struct of the RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID
type RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParams
	paramPtrs *RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParamPtrs
	results   *RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDResults
	Counter   uint64
}

// RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParams contains parameters of the RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID
type RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParams struct {
	ctx    context.Context
	kbUID  uuid.UUID
	fileID string
}

// RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParamPtrs contains pointers to parameters of the RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID
type RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParamPtrs struct {
	ctx    *context.Context
	kbUID  *uuid.UUID
	fileID *string
}

// RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDResults contains results of the RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID
type RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDResults struct {
	kp1 *mm_repository.KnowledgeBaseFile
	err error
}

// Expect sets up expected params for RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID
func (mmGetKnowledgebaseFileByKbUIDAndFileID *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID) Expect(ctx context.Context, kbUID uuid.UUID, fileID string) *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID {
	if mmGetKnowledgebaseFileByKbUIDAndFileID.mock.funcGetKnowledgebaseFileByKbUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID mock is already set by Set")
	}

	if mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation == nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation = &RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDExpectation{}
	}

	if mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID mock is already set by ExpectParams functions")
	}

	mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.params = &RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParams{ctx, kbUID, fileID}
	for _, e := range mmGetKnowledgebaseFileByKbUIDAndFileID.expectations {
		if minimock.Equal(e.params, mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.params) {
			mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.params)
		}
	}

	return mmGetKnowledgebaseFileByKbUIDAndFileID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID
func (mmGetKnowledgebaseFileByKbUIDAndFileID *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID {
	if mmGetKnowledgebaseFileByKbUIDAndFileID.mock.funcGetKnowledgebaseFileByKbUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID mock is already set by Set")
	}

	if mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation == nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation = &RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDExpectation{}
	}

	if mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.params != nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID mock is already set by Expect")
	}

	if mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.paramPtrs = &RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParamPtrs{}
	}
	mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetKnowledgebaseFileByKbUIDAndFileID
}

// ExpectKbUIDParam2 sets up expected param kbUID for RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID
func (mmGetKnowledgebaseFileByKbUIDAndFileID *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID) ExpectKbUIDParam2(kbUID uuid.UUID) *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID {
	if mmGetKnowledgebaseFileByKbUIDAndFileID.mock.funcGetKnowledgebaseFileByKbUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID mock is already set by Set")
	}

	if mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation == nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation = &RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDExpectation{}
	}

	if mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.params != nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID mock is already set by Expect")
	}

	if mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.paramPtrs = &RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParamPtrs{}
	}
	mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.paramPtrs.kbUID = &kbUID

	return mmGetKnowledgebaseFileByKbUIDAndFileID
}

// ExpectFileIDParam3 sets up expected param fileID for RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID
func (mmGetKnowledgebaseFileByKbUIDAndFileID *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID) ExpectFileIDParam3(fileID string) *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID {
	if mmGetKnowledgebaseFileByKbUIDAndFileID.mock.funcGetKnowledgebaseFileByKbUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID mock is already set by Set")
	}

	if mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation == nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation = &RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDExpectation{}
	}

	if mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.params != nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID mock is already set by Expect")
	}

	if mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.paramPtrs = &RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParamPtrs{}
	}
	mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.paramPtrs.fileID = &fileID

	return mmGetKnowledgebaseFileByKbUIDAndFileID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID
func (mmGetKnowledgebaseFileByKbUIDAndFileID *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID) Inspect(f func(ctx context.Context, kbUID uuid.UUID, fileID string)) *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID {
	if mmGetKnowledgebaseFileByKbUIDAndFileID.mock.inspectFuncGetKnowledgebaseFileByKbUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID")
	}

	mmGetKnowledgebaseFileByKbUIDAndFileID.mock.inspectFuncGetKnowledgebaseFileByKbUIDAndFileID = f

	return mmGetKnowledgebaseFileByKbUIDAndFileID
}

// Return sets up results that will be returned by RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID
func (mmGetKnowledgebaseFileByKbUIDAndFileID *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID) Return(kp1 *mm_repository.KnowledgeBaseFile, err error) *RepositoryIMock {
	if mmGetKnowledgebaseFileByKbUIDAndFileID.mock.funcGetKnowledgebaseFileByKbUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID mock is already set by Set")
	}

	if mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation == nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation = &RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDExpectation{mock: mmGetKnowledgebaseFileByKbUIDAndFileID.mock}
	}
	mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation.results = &RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDResults{kp1, err}
	return mmGetKnowledgebaseFileByKbUIDAndFileID.mock
}

// Set uses given function f to mock the RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID method
func (mmGetKnowledgebaseFileByKbUIDAndFileID *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID) Set(f func(ctx context.Context, kbUID uuid.UUID, fileID string) (kp1 *mm_repository.KnowledgeBaseFile, err error)) *RepositoryIMock {
	if mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation != nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID method")
	}

	if len(mmGetKnowledgebaseFileByKbUIDAndFileID.expectations) > 0 {
		mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID method")
	}

	mmGetKnowledgebaseFileByKbUIDAndFileID.mock.funcGetKnowledgebaseFileByKbUIDAndFileID = f
	return mmGetKnowledgebaseFileByKbUIDAndFileID.mock
}

// When sets expectation for the RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgebaseFileByKbUIDAndFileID *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID) When(ctx context.Context, kbUID uuid.UUID, fileID string) *RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDExpectation {
	if mmGetKnowledgebaseFileByKbUIDAndFileID.mock.funcGetKnowledgebaseFileByKbUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID mock is already set by Set")
	}

	expectation := &RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDExpectation{
		mock:   mmGetKnowledgebaseFileByKbUIDAndFileID.mock,
		params: &RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParams{ctx, kbUID, fileID},
	}
	mmGetKnowledgebaseFileByKbUIDAndFileID.expectations = append(mmGetKnowledgebaseFileByKbUIDAndFileID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDExpectation) Then(kp1 *mm_repository.KnowledgeBaseFile, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDResults{kp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetKnowledgebaseFileByKbUIDAndFileID should be invoked
func (mmGetKnowledgebaseFileByKbUIDAndFileID *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID) Times(n uint64) *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID {
	if n == 0 {
		mmGetKnowledgebaseFileByKbUIDAndFileID.mock.t.Fatalf("Times of RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgebaseFileByKbUIDAndFileID.expectedInvocations, n)
	return mmGetKnowledgebaseFileByKbUIDAndFileID
}

func (mmGetKnowledgebaseFileByKbUIDAndFileID *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID) invocationsDone() bool {
	if len(mmGetKnowledgebaseFileByKbUIDAndFileID.expectations) == 0 && mmGetKnowledgebaseFileByKbUIDAndFileID.defaultExpectation == nil && mmGetKnowledgebaseFileByKbUIDAndFileID.mock.funcGetKnowledgebaseFileByKbUIDAndFileID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgebaseFileByKbUIDAndFileID.mock.afterGetKnowledgebaseFileByKbUIDAndFileIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgebaseFileByKbUIDAndFileID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgebaseFileByKbUIDAndFileID implements repository.RepositoryI
func (mmGetKnowledgebaseFileByKbUIDAndFileID *RepositoryIMock) GetKnowledgebaseFileByKbUIDAndFileID(ctx context.Context, kbUID uuid.UUID, fileID string) (kp1 *mm_repository.KnowledgeBaseFile, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgebaseFileByKbUIDAndFileID.beforeGetKnowledgebaseFileByKbUIDAndFileIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgebaseFileByKbUIDAndFileID.afterGetKnowledgebaseFileByKbUIDAndFileIDCounter, 1)

	if mmGetKnowledgebaseFileByKbUIDAndFileID.inspectFuncGetKnowledgebaseFileByKbUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKbUIDAndFileID.inspectFuncGetKnowledgebaseFileByKbUIDAndFileID(ctx, kbUID, fileID)
	}

	mm_params := RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParams{ctx, kbUID, fileID}

	// Record call args
	mmGetKnowledgebaseFileByKbUIDAndFileID.GetKnowledgebaseFileByKbUIDAndFileIDMock.mutex.Lock()
	mmGetKnowledgebaseFileByKbUIDAndFileID.GetKnowledgebaseFileByKbUIDAndFileIDMock.callArgs = append(mmGetKnowledgebaseFileByKbUIDAndFileID.GetKnowledgebaseFileByKbUIDAndFileIDMock.callArgs, &mm_params)
	mmGetKnowledgebaseFileByKbUIDAndFileID.GetKnowledgebaseFileByKbUIDAndFileIDMock.mutex.Unlock()

	for _, e := range mmGetKnowledgebaseFileByKbUIDAndFileID.GetKnowledgebaseFileByKbUIDAndFileIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmGetKnowledgebaseFileByKbUIDAndFileID.GetKnowledgebaseFileByKbUIDAndFileIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgebaseFileByKbUIDAndFileID.GetKnowledgebaseFileByKbUIDAndFileIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgebaseFileByKbUIDAndFileID.GetKnowledgebaseFileByKbUIDAndFileIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgebaseFileByKbUIDAndFileID.GetKnowledgebaseFileByKbUIDAndFileIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParams{ctx, kbUID, fileID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgebaseFileByKbUIDAndFileID.t.Errorf("RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmGetKnowledgebaseFileByKbUIDAndFileID.t.Errorf("RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID got unexpected parameter kbUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.fileID != nil && !minimock.Equal(*mm_want_ptrs.fileID, mm_got.fileID) {
				mmGetKnowledgebaseFileByKbUIDAndFileID.t.Errorf("RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID got unexpected parameter fileID, want: %#v, got: %#v%s\n", *mm_want_ptrs.fileID, mm_got.fileID, minimock.Diff(*mm_want_ptrs.fileID, mm_got.fileID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgebaseFileByKbUIDAndFileID.t.Errorf("RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgebaseFileByKbUIDAndFileID.GetKnowledgebaseFileByKbUIDAndFileIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgebaseFileByKbUIDAndFileID.t.Fatal("No results are set for the RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmGetKnowledgebaseFileByKbUIDAndFileID.funcGetKnowledgebaseFileByKbUIDAndFileID != nil {
		return mmGetKnowledgebaseFileByKbUIDAndFileID.funcGetKnowledgebaseFileByKbUIDAndFileID(ctx, kbUID, fileID)
	}
	mmGetKnowledgebaseFileByKbUIDAndFileID.t.Fatalf("Unexpected call to RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID. %v %v %v", ctx, kbUID, fileID)
	return
}

// GetKnowledgebaseFileByKbUIDAndFileIDAfterCounter returns a count of finished RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID invocations
func (mmGetKnowledgebaseFileByKbUIDAndFileID *RepositoryIMock) GetKnowledgebaseFileByKbUIDAndFileIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgebaseFileByKbUIDAndFileID.afterGetKnowledgebaseFileByKbUIDAndFileIDCounter)
}

// GetKnowledgebaseFileByKbUIDAndFileIDBeforeCounter returns a count of RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID invocations
func (mmGetKnowledgebaseFileByKbUIDAndFileID *RepositoryIMock) GetKnowledgebaseFileByKbUIDAndFileIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgebaseFileByKbUIDAndFileID.beforeGetKnowledgebaseFileByKbUIDAndFileIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgebaseFileByKbUIDAndFileID *mRepositoryIMockGetKnowledgebaseFileByKbUIDAndFileID) Calls() []*RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParams {
	mmGetKnowledgebaseFileByKbUIDAndFileID.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetKnowledgebaseFileByKbUIDAndFileIDParams, len(mmGetKnowledgebaseFileByKbUIDAndFileID.callArgs))
	copy(argCopy, mmGetKnowledgebaseFileByKbUIDAndFileID.callArgs)

	mmGetKnowledgebaseFileByKbUIDAndFileID.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgebaseFileByKbUIDAndFileIDDone returns true if the count of the GetKnowledgebaseFileByKbUIDAndFileID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetKnowledgebaseFileByKbUIDAndFileIDDone() bool {
	for _, e := range m.GetKnowledgebaseFileByKbUIDAndFileIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgebaseFileByKbUIDAndFileIDMock.invocationsDone()
}

// MinimockGetKnowledgebaseFileByKbUIDAndFileIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetKnowledgebaseFileByKbUIDAndFileIDInspect() {
	for _, e := range m.GetKnowledgebaseFileByKbUIDAndFileIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID with params: %#v", *e.params)
		}
	}

	afterGetKnowledgebaseFileByKbUIDAndFileIDCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgebaseFileByKbUIDAndFileIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgebaseFileByKbUIDAndFileIDMock.defaultExpectation != nil && afterGetKnowledgebaseFileByKbUIDAndFileIDCounter < 1 {
		if m.GetKnowledgebaseFileByKbUIDAndFileIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID with params: %#v", *m.GetKnowledgebaseFileByKbUIDAndFileIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgebaseFileByKbUIDAndFileID != nil && afterGetKnowledgebaseFileByKbUIDAndFileIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID")
	}

	if !m.GetKnowledgebaseFileByKbUIDAndFileIDMock.invocationsDone() && afterGetKnowledgebaseFileByKbUIDAndFileIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetKnowledgebaseFileByKbUIDAndFileID but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgebaseFileByKbUIDAndFileIDMock.expectedInvocations), afterGetKnowledgebaseFileByKbUIDAndFileIDCounter)
	}
}

type mRepositoryIMockGetNeedProcessFiles struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetNeedProcessFilesExpectation
	expectations       []*RepositoryIMockGetNeedProcessFilesExpectation

	callArgs []*RepositoryIMockGetNeedProcessFilesParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetNeedProcessFilesExpectation specifies expectation struct of the RepositoryI.GetNeedProcessFiles
type RepositoryIMockGetNeedProcessFilesExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetNeedProcessFilesParams
	paramPtrs *RepositoryIMockGetNeedProcessFilesParamPtrs
	results   *RepositoryIMockGetNeedProcessFilesResults
	Counter   uint64
}

// RepositoryIMockGetNeedProcessFilesParams contains parameters of the RepositoryI.GetNeedProcessFiles
type RepositoryIMockGetNeedProcessFilesParams struct {
	ctx context.Context
}

// RepositoryIMockGetNeedProcessFilesParamPtrs contains pointers to parameters of the RepositoryI.GetNeedProcessFiles
type RepositoryIMockGetNeedProcessFilesParamPtrs struct {
	ctx *context.Context
}

// RepositoryIMockGetNeedProcessFilesResults contains results of the RepositoryI.GetNeedProcessFiles
type RepositoryIMockGetNeedProcessFilesResults struct {
	ka1 []mm_repository.KnowledgeBaseFile
}

// Expect sets up expected params for RepositoryI.GetNeedProcessFiles
func (mmGetNeedProcessFiles *mRepositoryIMockGetNeedProcessFiles) Expect(ctx context.Context) *mRepositoryIMockGetNeedProcessFiles {
	if mmGetNeedProcessFiles.mock.funcGetNeedProcessFiles != nil {
		mmGetNeedProcessFiles.mock.t.Fatalf("RepositoryIMock.GetNeedProcessFiles mock is already set by Set")
	}

	if mmGetNeedProcessFiles.defaultExpectation == nil {
		mmGetNeedProcessFiles.defaultExpectation = &RepositoryIMockGetNeedProcessFilesExpectation{}
	}

	if mmGetNeedProcessFiles.defaultExpectation.paramPtrs != nil {
		mmGetNeedProcessFiles.mock.t.Fatalf("RepositoryIMock.GetNeedProcessFiles mock is already set by ExpectParams functions")
	}

	mmGetNeedProcessFiles.defaultExpectation.params = &RepositoryIMockGetNeedProcessFilesParams{ctx}
	for _, e := range mmGetNeedProcessFiles.expectations {
		if minimock.Equal(e.params, mmGetNeedProcessFiles.defaultExpectation.params) {
			mmGetNeedProcessFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetNeedProcessFiles.defaultExpectation.params)
		}
	}

	return mmGetNeedProcessFiles
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetNeedProcessFiles
func (mmGetNeedProcessFiles *mRepositoryIMockGetNeedProcessFiles) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetNeedProcessFiles {
	if mmGetNeedProcessFiles.mock.funcGetNeedProcessFiles != nil {
		mmGetNeedProcessFiles.mock.t.Fatalf("RepositoryIMock.GetNeedProcessFiles mock is already set by Set")
	}

	if mmGetNeedProcessFiles.defaultExpectation == nil {
		mmGetNeedProcessFiles.defaultExpectation = &RepositoryIMockGetNeedProcessFilesExpectation{}
	}

	if mmGetNeedProcessFiles.defaultExpectation.params != nil {
		mmGetNeedProcessFiles.mock.t.Fatalf("RepositoryIMock.GetNeedProcessFiles mock is already set by Expect")
	}

	if mmGetNeedProcessFiles.defaultExpectation.paramPtrs == nil {
		mmGetNeedProcessFiles.defaultExpectation.paramPtrs = &RepositoryIMockGetNeedProcessFilesParamPtrs{}
	}
	mmGetNeedProcessFiles.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetNeedProcessFiles
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetNeedProcessFiles
func (mmGetNeedProcessFiles *mRepositoryIMockGetNeedProcessFiles) Inspect(f func(ctx context.Context)) *mRepositoryIMockGetNeedProcessFiles {
	if mmGetNeedProcessFiles.mock.inspectFuncGetNeedProcessFiles != nil {
		mmGetNeedProcessFiles.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetNeedProcessFiles")
	}

	mmGetNeedProcessFiles.mock.inspectFuncGetNeedProcessFiles = f

	return mmGetNeedProcessFiles
}

// Return sets up results that will be returned by RepositoryI.GetNeedProcessFiles
func (mmGetNeedProcessFiles *mRepositoryIMockGetNeedProcessFiles) Return(ka1 []mm_repository.KnowledgeBaseFile) *RepositoryIMock {
	if mmGetNeedProcessFiles.mock.funcGetNeedProcessFiles != nil {
		mmGetNeedProcessFiles.mock.t.Fatalf("RepositoryIMock.GetNeedProcessFiles mock is already set by Set")
	}

	if mmGetNeedProcessFiles.defaultExpectation == nil {
		mmGetNeedProcessFiles.defaultExpectation = &RepositoryIMockGetNeedProcessFilesExpectation{mock: mmGetNeedProcessFiles.mock}
	}
	mmGetNeedProcessFiles.defaultExpectation.results = &RepositoryIMockGetNeedProcessFilesResults{ka1}
	return mmGetNeedProcessFiles.mock
}

// Set uses given function f to mock the RepositoryI.GetNeedProcessFiles method
func (mmGetNeedProcessFiles *mRepositoryIMockGetNeedProcessFiles) Set(f func(ctx context.Context) (ka1 []mm_repository.KnowledgeBaseFile)) *RepositoryIMock {
	if mmGetNeedProcessFiles.defaultExpectation != nil {
		mmGetNeedProcessFiles.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetNeedProcessFiles method")
	}

	if len(mmGetNeedProcessFiles.expectations) > 0 {
		mmGetNeedProcessFiles.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetNeedProcessFiles method")
	}

	mmGetNeedProcessFiles.mock.funcGetNeedProcessFiles = f
	return mmGetNeedProcessFiles.mock
}

// When sets expectation for the RepositoryI.GetNeedProcessFiles which will trigger the result defined by the following
// Then helper
func (mmGetNeedProcessFiles *mRepositoryIMockGetNeedProcessFiles) When(ctx context.Context) *RepositoryIMockGetNeedProcessFilesExpectation {
	if mmGetNeedProcessFiles.mock.funcGetNeedProcessFiles != nil {
		mmGetNeedProcessFiles.mock.t.Fatalf("RepositoryIMock.GetNeedProcessFiles mock is already set by Set")
	}

	expectation := &RepositoryIMockGetNeedProcessFilesExpectation{
		mock:   mmGetNeedProcessFiles.mock,
		params: &RepositoryIMockGetNeedProcessFilesParams{ctx},
	}
	mmGetNeedProcessFiles.expectations = append(mmGetNeedProcessFiles.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetNeedProcessFiles return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetNeedProcessFilesExpectation) Then(ka1 []mm_repository.KnowledgeBaseFile) *RepositoryIMock {
	e.results = &RepositoryIMockGetNeedProcessFilesResults{ka1}
	return e.mock
}

// Times sets number of times RepositoryI.GetNeedProcessFiles should be invoked
func (mmGetNeedProcessFiles *mRepositoryIMockGetNeedProcessFiles) Times(n uint64) *mRepositoryIMockGetNeedProcessFiles {
	if n == 0 {
		mmGetNeedProcessFiles.mock.t.Fatalf("Times of RepositoryIMock.GetNeedProcessFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetNeedProcessFiles.expectedInvocations, n)
	return mmGetNeedProcessFiles
}

func (mmGetNeedProcessFiles *mRepositoryIMockGetNeedProcessFiles) invocationsDone() bool {
	if len(mmGetNeedProcessFiles.expectations) == 0 && mmGetNeedProcessFiles.defaultExpectation == nil && mmGetNeedProcessFiles.mock.funcGetNeedProcessFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetNeedProcessFiles.mock.afterGetNeedProcessFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetNeedProcessFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetNeedProcessFiles implements repository.RepositoryI
func (mmGetNeedProcessFiles *RepositoryIMock) GetNeedProcessFiles(ctx context.Context) (ka1 []mm_repository.KnowledgeBaseFile) {
	mm_atomic.AddUint64(&mmGetNeedProcessFiles.beforeGetNeedProcessFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNeedProcessFiles.afterGetNeedProcessFilesCounter, 1)

	if mmGetNeedProcessFiles.inspectFuncGetNeedProcessFiles != nil {
		mmGetNeedProcessFiles.inspectFuncGetNeedProcessFiles(ctx)
	}

	mm_params := RepositoryIMockGetNeedProcessFilesParams{ctx}

	// Record call args
	mmGetNeedProcessFiles.GetNeedProcessFilesMock.mutex.Lock()
	mmGetNeedProcessFiles.GetNeedProcessFilesMock.callArgs = append(mmGetNeedProcessFiles.GetNeedProcessFilesMock.callArgs, &mm_params)
	mmGetNeedProcessFiles.GetNeedProcessFilesMock.mutex.Unlock()

	for _, e := range mmGetNeedProcessFiles.GetNeedProcessFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1
		}
	}

	if mmGetNeedProcessFiles.GetNeedProcessFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNeedProcessFiles.GetNeedProcessFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmGetNeedProcessFiles.GetNeedProcessFilesMock.defaultExpectation.params
		mm_want_ptrs := mmGetNeedProcessFiles.GetNeedProcessFilesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetNeedProcessFilesParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetNeedProcessFiles.t.Errorf("RepositoryIMock.GetNeedProcessFiles got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetNeedProcessFiles.t.Errorf("RepositoryIMock.GetNeedProcessFiles got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetNeedProcessFiles.GetNeedProcessFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNeedProcessFiles.t.Fatal("No results are set for the RepositoryIMock.GetNeedProcessFiles")
		}
		return (*mm_results).ka1
	}
	if mmGetNeedProcessFiles.funcGetNeedProcessFiles != nil {
		return mmGetNeedProcessFiles.funcGetNeedProcessFiles(ctx)
	}
	mmGetNeedProcessFiles.t.Fatalf("Unexpected call to RepositoryIMock.GetNeedProcessFiles. %v", ctx)
	return
}

// GetNeedProcessFilesAfterCounter returns a count of finished RepositoryIMock.GetNeedProcessFiles invocations
func (mmGetNeedProcessFiles *RepositoryIMock) GetNeedProcessFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNeedProcessFiles.afterGetNeedProcessFilesCounter)
}

// GetNeedProcessFilesBeforeCounter returns a count of RepositoryIMock.GetNeedProcessFiles invocations
func (mmGetNeedProcessFiles *RepositoryIMock) GetNeedProcessFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNeedProcessFiles.beforeGetNeedProcessFilesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetNeedProcessFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetNeedProcessFiles *mRepositoryIMockGetNeedProcessFiles) Calls() []*RepositoryIMockGetNeedProcessFilesParams {
	mmGetNeedProcessFiles.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetNeedProcessFilesParams, len(mmGetNeedProcessFiles.callArgs))
	copy(argCopy, mmGetNeedProcessFiles.callArgs)

	mmGetNeedProcessFiles.mutex.RUnlock()

	return argCopy
}

// MinimockGetNeedProcessFilesDone returns true if the count of the GetNeedProcessFiles invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetNeedProcessFilesDone() bool {
	for _, e := range m.GetNeedProcessFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetNeedProcessFilesMock.invocationsDone()
}

// MinimockGetNeedProcessFilesInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetNeedProcessFilesInspect() {
	for _, e := range m.GetNeedProcessFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetNeedProcessFiles with params: %#v", *e.params)
		}
	}

	afterGetNeedProcessFilesCounter := mm_atomic.LoadUint64(&m.afterGetNeedProcessFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetNeedProcessFilesMock.defaultExpectation != nil && afterGetNeedProcessFilesCounter < 1 {
		if m.GetNeedProcessFilesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetNeedProcessFiles")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetNeedProcessFiles with params: %#v", *m.GetNeedProcessFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNeedProcessFiles != nil && afterGetNeedProcessFilesCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetNeedProcessFiles")
	}

	if !m.GetNeedProcessFilesMock.invocationsDone() && afterGetNeedProcessFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetNeedProcessFiles but found %d calls",
			mm_atomic.LoadUint64(&m.GetNeedProcessFilesMock.expectedInvocations), afterGetNeedProcessFilesCounter)
	}
}

type mRepositoryIMockGetObjectByUID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetObjectByUIDExpectation
	expectations       []*RepositoryIMockGetObjectByUIDExpectation

	callArgs []*RepositoryIMockGetObjectByUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetObjectByUIDExpectation specifies expectation struct of the RepositoryI.GetObjectByUID
type RepositoryIMockGetObjectByUIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetObjectByUIDParams
	paramPtrs *RepositoryIMockGetObjectByUIDParamPtrs
	results   *RepositoryIMockGetObjectByUIDResults
	Counter   uint64
}

// RepositoryIMockGetObjectByUIDParams contains parameters of the RepositoryI.GetObjectByUID
type RepositoryIMockGetObjectByUIDParams struct {
	ctx context.Context
	uid uuid.UUID
}

// RepositoryIMockGetObjectByUIDParamPtrs contains pointers to parameters of the RepositoryI.GetObjectByUID
type RepositoryIMockGetObjectByUIDParamPtrs struct {
	ctx *context.Context
	uid *uuid.UUID
}

// RepositoryIMockGetObjectByUIDResults contains results of the RepositoryI.GetObjectByUID
type RepositoryIMockGetObjectByUIDResults struct {
	op1 *mm_repository.Object
	err error
}

// Expect sets up expected params for RepositoryI.GetObjectByUID
func (mmGetObjectByUID *mRepositoryIMockGetObjectByUID) Expect(ctx context.Context, uid uuid.UUID) *mRepositoryIMockGetObjectByUID {
	if mmGetObjectByUID.mock.funcGetObjectByUID != nil {
		mmGetObjectByUID.mock.t.Fatalf("RepositoryIMock.GetObjectByUID mock is already set by Set")
	}

	if mmGetObjectByUID.defaultExpectation == nil {
		mmGetObjectByUID.defaultExpectation = &RepositoryIMockGetObjectByUIDExpectation{}
	}

	if mmGetObjectByUID.defaultExpectation.paramPtrs != nil {
		mmGetObjectByUID.mock.t.Fatalf("RepositoryIMock.GetObjectByUID mock is already set by ExpectParams functions")
	}

	mmGetObjectByUID.defaultExpectation.params = &RepositoryIMockGetObjectByUIDParams{ctx, uid}
	for _, e := range mmGetObjectByUID.expectations {
		if minimock.Equal(e.params, mmGetObjectByUID.defaultExpectation.params) {
			mmGetObjectByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetObjectByUID.defaultExpectation.params)
		}
	}

	return mmGetObjectByUID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetObjectByUID
func (mmGetObjectByUID *mRepositoryIMockGetObjectByUID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetObjectByUID {
	if mmGetObjectByUID.mock.funcGetObjectByUID != nil {
		mmGetObjectByUID.mock.t.Fatalf("RepositoryIMock.GetObjectByUID mock is already set by Set")
	}

	if mmGetObjectByUID.defaultExpectation == nil {
		mmGetObjectByUID.defaultExpectation = &RepositoryIMockGetObjectByUIDExpectation{}
	}

	if mmGetObjectByUID.defaultExpectation.params != nil {
		mmGetObjectByUID.mock.t.Fatalf("RepositoryIMock.GetObjectByUID mock is already set by Expect")
	}

	if mmGetObjectByUID.defaultExpectation.paramPtrs == nil {
		mmGetObjectByUID.defaultExpectation.paramPtrs = &RepositoryIMockGetObjectByUIDParamPtrs{}
	}
	mmGetObjectByUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetObjectByUID
}

// ExpectUidParam2 sets up expected param uid for RepositoryI.GetObjectByUID
func (mmGetObjectByUID *mRepositoryIMockGetObjectByUID) ExpectUidParam2(uid uuid.UUID) *mRepositoryIMockGetObjectByUID {
	if mmGetObjectByUID.mock.funcGetObjectByUID != nil {
		mmGetObjectByUID.mock.t.Fatalf("RepositoryIMock.GetObjectByUID mock is already set by Set")
	}

	if mmGetObjectByUID.defaultExpectation == nil {
		mmGetObjectByUID.defaultExpectation = &RepositoryIMockGetObjectByUIDExpectation{}
	}

	if mmGetObjectByUID.defaultExpectation.params != nil {
		mmGetObjectByUID.mock.t.Fatalf("RepositoryIMock.GetObjectByUID mock is already set by Expect")
	}

	if mmGetObjectByUID.defaultExpectation.paramPtrs == nil {
		mmGetObjectByUID.defaultExpectation.paramPtrs = &RepositoryIMockGetObjectByUIDParamPtrs{}
	}
	mmGetObjectByUID.defaultExpectation.paramPtrs.uid = &uid

	return mmGetObjectByUID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetObjectByUID
func (mmGetObjectByUID *mRepositoryIMockGetObjectByUID) Inspect(f func(ctx context.Context, uid uuid.UUID)) *mRepositoryIMockGetObjectByUID {
	if mmGetObjectByUID.mock.inspectFuncGetObjectByUID != nil {
		mmGetObjectByUID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetObjectByUID")
	}

	mmGetObjectByUID.mock.inspectFuncGetObjectByUID = f

	return mmGetObjectByUID
}

// Return sets up results that will be returned by RepositoryI.GetObjectByUID
func (mmGetObjectByUID *mRepositoryIMockGetObjectByUID) Return(op1 *mm_repository.Object, err error) *RepositoryIMock {
	if mmGetObjectByUID.mock.funcGetObjectByUID != nil {
		mmGetObjectByUID.mock.t.Fatalf("RepositoryIMock.GetObjectByUID mock is already set by Set")
	}

	if mmGetObjectByUID.defaultExpectation == nil {
		mmGetObjectByUID.defaultExpectation = &RepositoryIMockGetObjectByUIDExpectation{mock: mmGetObjectByUID.mock}
	}
	mmGetObjectByUID.defaultExpectation.results = &RepositoryIMockGetObjectByUIDResults{op1, err}
	return mmGetObjectByUID.mock
}

// Set uses given function f to mock the RepositoryI.GetObjectByUID method
func (mmGetObjectByUID *mRepositoryIMockGetObjectByUID) Set(f func(ctx context.Context, uid uuid.UUID) (op1 *mm_repository.Object, err error)) *RepositoryIMock {
	if mmGetObjectByUID.defaultExpectation != nil {
		mmGetObjectByUID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetObjectByUID method")
	}

	if len(mmGetObjectByUID.expectations) > 0 {
		mmGetObjectByUID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetObjectByUID method")
	}

	mmGetObjectByUID.mock.funcGetObjectByUID = f
	return mmGetObjectByUID.mock
}

// When sets expectation for the RepositoryI.GetObjectByUID which will trigger the result defined by the following
// Then helper
func (mmGetObjectByUID *mRepositoryIMockGetObjectByUID) When(ctx context.Context, uid uuid.UUID) *RepositoryIMockGetObjectByUIDExpectation {
	if mmGetObjectByUID.mock.funcGetObjectByUID != nil {
		mmGetObjectByUID.mock.t.Fatalf("RepositoryIMock.GetObjectByUID mock is already set by Set")
	}

	expectation := &RepositoryIMockGetObjectByUIDExpectation{
		mock:   mmGetObjectByUID.mock,
		params: &RepositoryIMockGetObjectByUIDParams{ctx, uid},
	}
	mmGetObjectByUID.expectations = append(mmGetObjectByUID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetObjectByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetObjectByUIDExpectation) Then(op1 *mm_repository.Object, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetObjectByUIDResults{op1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetObjectByUID should be invoked
func (mmGetObjectByUID *mRepositoryIMockGetObjectByUID) Times(n uint64) *mRepositoryIMockGetObjectByUID {
	if n == 0 {
		mmGetObjectByUID.mock.t.Fatalf("Times of RepositoryIMock.GetObjectByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetObjectByUID.expectedInvocations, n)
	return mmGetObjectByUID
}

func (mmGetObjectByUID *mRepositoryIMockGetObjectByUID) invocationsDone() bool {
	if len(mmGetObjectByUID.expectations) == 0 && mmGetObjectByUID.defaultExpectation == nil && mmGetObjectByUID.mock.funcGetObjectByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetObjectByUID.mock.afterGetObjectByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetObjectByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetObjectByUID implements repository.RepositoryI
func (mmGetObjectByUID *RepositoryIMock) GetObjectByUID(ctx context.Context, uid uuid.UUID) (op1 *mm_repository.Object, err error) {
	mm_atomic.AddUint64(&mmGetObjectByUID.beforeGetObjectByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetObjectByUID.afterGetObjectByUIDCounter, 1)

	if mmGetObjectByUID.inspectFuncGetObjectByUID != nil {
		mmGetObjectByUID.inspectFuncGetObjectByUID(ctx, uid)
	}

	mm_params := RepositoryIMockGetObjectByUIDParams{ctx, uid}

	// Record call args
	mmGetObjectByUID.GetObjectByUIDMock.mutex.Lock()
	mmGetObjectByUID.GetObjectByUIDMock.callArgs = append(mmGetObjectByUID.GetObjectByUIDMock.callArgs, &mm_params)
	mmGetObjectByUID.GetObjectByUIDMock.mutex.Unlock()

	for _, e := range mmGetObjectByUID.GetObjectByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetObjectByUID.GetObjectByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetObjectByUID.GetObjectByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetObjectByUID.GetObjectByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetObjectByUID.GetObjectByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetObjectByUIDParams{ctx, uid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetObjectByUID.t.Errorf("RepositoryIMock.GetObjectByUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmGetObjectByUID.t.Errorf("RepositoryIMock.GetObjectByUID got unexpected parameter uid, want: %#v, got: %#v%s\n", *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetObjectByUID.t.Errorf("RepositoryIMock.GetObjectByUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetObjectByUID.GetObjectByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetObjectByUID.t.Fatal("No results are set for the RepositoryIMock.GetObjectByUID")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetObjectByUID.funcGetObjectByUID != nil {
		return mmGetObjectByUID.funcGetObjectByUID(ctx, uid)
	}
	mmGetObjectByUID.t.Fatalf("Unexpected call to RepositoryIMock.GetObjectByUID. %v %v", ctx, uid)
	return
}

// GetObjectByUIDAfterCounter returns a count of finished RepositoryIMock.GetObjectByUID invocations
func (mmGetObjectByUID *RepositoryIMock) GetObjectByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectByUID.afterGetObjectByUIDCounter)
}

// GetObjectByUIDBeforeCounter returns a count of RepositoryIMock.GetObjectByUID invocations
func (mmGetObjectByUID *RepositoryIMock) GetObjectByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectByUID.beforeGetObjectByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetObjectByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetObjectByUID *mRepositoryIMockGetObjectByUID) Calls() []*RepositoryIMockGetObjectByUIDParams {
	mmGetObjectByUID.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetObjectByUIDParams, len(mmGetObjectByUID.callArgs))
	copy(argCopy, mmGetObjectByUID.callArgs)

	mmGetObjectByUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetObjectByUIDDone returns true if the count of the GetObjectByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetObjectByUIDDone() bool {
	for _, e := range m.GetObjectByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetObjectByUIDMock.invocationsDone()
}

// MinimockGetObjectByUIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetObjectByUIDInspect() {
	for _, e := range m.GetObjectByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetObjectByUID with params: %#v", *e.params)
		}
	}

	afterGetObjectByUIDCounter := mm_atomic.LoadUint64(&m.afterGetObjectByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetObjectByUIDMock.defaultExpectation != nil && afterGetObjectByUIDCounter < 1 {
		if m.GetObjectByUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetObjectByUID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetObjectByUID with params: %#v", *m.GetObjectByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetObjectByUID != nil && afterGetObjectByUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetObjectByUID")
	}

	if !m.GetObjectByUIDMock.invocationsDone() && afterGetObjectByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetObjectByUID but found %d calls",
			mm_atomic.LoadUint64(&m.GetObjectByUIDMock.expectedInvocations), afterGetObjectByUIDCounter)
	}
}

type mRepositoryIMockGetObjectDownloadURL struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetObjectDownloadURLExpectation
	expectations       []*RepositoryIMockGetObjectDownloadURLExpectation

	callArgs []*RepositoryIMockGetObjectDownloadURLParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetObjectDownloadURLExpectation specifies expectation struct of the RepositoryI.GetObjectDownloadURL
type RepositoryIMockGetObjectDownloadURLExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetObjectDownloadURLParams
	paramPtrs *RepositoryIMockGetObjectDownloadURLParamPtrs
	results   *RepositoryIMockGetObjectDownloadURLResults
	Counter   uint64
}

// RepositoryIMockGetObjectDownloadURLParams contains parameters of the RepositoryI.GetObjectDownloadURL
type RepositoryIMockGetObjectDownloadURLParams struct {
	ctx       context.Context
	objectUID uuid.UUID
}

// RepositoryIMockGetObjectDownloadURLParamPtrs contains pointers to parameters of the RepositoryI.GetObjectDownloadURL
type RepositoryIMockGetObjectDownloadURLParamPtrs struct {
	ctx       *context.Context
	objectUID *uuid.UUID
}

// RepositoryIMockGetObjectDownloadURLResults contains results of the RepositoryI.GetObjectDownloadURL
type RepositoryIMockGetObjectDownloadURLResults struct {
	op1 *mm_repository.ObjectURL
	err error
}

// Expect sets up expected params for RepositoryI.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mRepositoryIMockGetObjectDownloadURL) Expect(ctx context.Context, objectUID uuid.UUID) *mRepositoryIMockGetObjectDownloadURL {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("RepositoryIMock.GetObjectDownloadURL mock is already set by Set")
	}

	if mmGetObjectDownloadURL.defaultExpectation == nil {
		mmGetObjectDownloadURL.defaultExpectation = &RepositoryIMockGetObjectDownloadURLExpectation{}
	}

	if mmGetObjectDownloadURL.defaultExpectation.paramPtrs != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("RepositoryIMock.GetObjectDownloadURL mock is already set by ExpectParams functions")
	}

	mmGetObjectDownloadURL.defaultExpectation.params = &RepositoryIMockGetObjectDownloadURLParams{ctx, objectUID}
	for _, e := range mmGetObjectDownloadURL.expectations {
		if minimock.Equal(e.params, mmGetObjectDownloadURL.defaultExpectation.params) {
			mmGetObjectDownloadURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetObjectDownloadURL.defaultExpectation.params)
		}
	}

	return mmGetObjectDownloadURL
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mRepositoryIMockGetObjectDownloadURL) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetObjectDownloadURL {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("RepositoryIMock.GetObjectDownloadURL mock is already set by Set")
	}

	if mmGetObjectDownloadURL.defaultExpectation == nil {
		mmGetObjectDownloadURL.defaultExpectation = &RepositoryIMockGetObjectDownloadURLExpectation{}
	}

	if mmGetObjectDownloadURL.defaultExpectation.params != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("RepositoryIMock.GetObjectDownloadURL mock is already set by Expect")
	}

	if mmGetObjectDownloadURL.defaultExpectation.paramPtrs == nil {
		mmGetObjectDownloadURL.defaultExpectation.paramPtrs = &RepositoryIMockGetObjectDownloadURLParamPtrs{}
	}
	mmGetObjectDownloadURL.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetObjectDownloadURL
}

// ExpectObjectUIDParam2 sets up expected param objectUID for RepositoryI.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mRepositoryIMockGetObjectDownloadURL) ExpectObjectUIDParam2(objectUID uuid.UUID) *mRepositoryIMockGetObjectDownloadURL {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("RepositoryIMock.GetObjectDownloadURL mock is already set by Set")
	}

	if mmGetObjectDownloadURL.defaultExpectation == nil {
		mmGetObjectDownloadURL.defaultExpectation = &RepositoryIMockGetObjectDownloadURLExpectation{}
	}

	if mmGetObjectDownloadURL.defaultExpectation.params != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("RepositoryIMock.GetObjectDownloadURL mock is already set by Expect")
	}

	if mmGetObjectDownloadURL.defaultExpectation.paramPtrs == nil {
		mmGetObjectDownloadURL.defaultExpectation.paramPtrs = &RepositoryIMockGetObjectDownloadURLParamPtrs{}
	}
	mmGetObjectDownloadURL.defaultExpectation.paramPtrs.objectUID = &objectUID

	return mmGetObjectDownloadURL
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mRepositoryIMockGetObjectDownloadURL) Inspect(f func(ctx context.Context, objectUID uuid.UUID)) *mRepositoryIMockGetObjectDownloadURL {
	if mmGetObjectDownloadURL.mock.inspectFuncGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetObjectDownloadURL")
	}

	mmGetObjectDownloadURL.mock.inspectFuncGetObjectDownloadURL = f

	return mmGetObjectDownloadURL
}

// Return sets up results that will be returned by RepositoryI.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mRepositoryIMockGetObjectDownloadURL) Return(op1 *mm_repository.ObjectURL, err error) *RepositoryIMock {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("RepositoryIMock.GetObjectDownloadURL mock is already set by Set")
	}

	if mmGetObjectDownloadURL.defaultExpectation == nil {
		mmGetObjectDownloadURL.defaultExpectation = &RepositoryIMockGetObjectDownloadURLExpectation{mock: mmGetObjectDownloadURL.mock}
	}
	mmGetObjectDownloadURL.defaultExpectation.results = &RepositoryIMockGetObjectDownloadURLResults{op1, err}
	return mmGetObjectDownloadURL.mock
}

// Set uses given function f to mock the RepositoryI.GetObjectDownloadURL method
func (mmGetObjectDownloadURL *mRepositoryIMockGetObjectDownloadURL) Set(f func(ctx context.Context, objectUID uuid.UUID) (op1 *mm_repository.ObjectURL, err error)) *RepositoryIMock {
	if mmGetObjectDownloadURL.defaultExpectation != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetObjectDownloadURL method")
	}

	if len(mmGetObjectDownloadURL.expectations) > 0 {
		mmGetObjectDownloadURL.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetObjectDownloadURL method")
	}

	mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL = f
	return mmGetObjectDownloadURL.mock
}

// When sets expectation for the RepositoryI.GetObjectDownloadURL which will trigger the result defined by the following
// Then helper
func (mmGetObjectDownloadURL *mRepositoryIMockGetObjectDownloadURL) When(ctx context.Context, objectUID uuid.UUID) *RepositoryIMockGetObjectDownloadURLExpectation {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("RepositoryIMock.GetObjectDownloadURL mock is already set by Set")
	}

	expectation := &RepositoryIMockGetObjectDownloadURLExpectation{
		mock:   mmGetObjectDownloadURL.mock,
		params: &RepositoryIMockGetObjectDownloadURLParams{ctx, objectUID},
	}
	mmGetObjectDownloadURL.expectations = append(mmGetObjectDownloadURL.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetObjectDownloadURL return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetObjectDownloadURLExpectation) Then(op1 *mm_repository.ObjectURL, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetObjectDownloadURLResults{op1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetObjectDownloadURL should be invoked
func (mmGetObjectDownloadURL *mRepositoryIMockGetObjectDownloadURL) Times(n uint64) *mRepositoryIMockGetObjectDownloadURL {
	if n == 0 {
		mmGetObjectDownloadURL.mock.t.Fatalf("Times of RepositoryIMock.GetObjectDownloadURL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetObjectDownloadURL.expectedInvocations, n)
	return mmGetObjectDownloadURL
}

func (mmGetObjectDownloadURL *mRepositoryIMockGetObjectDownloadURL) invocationsDone() bool {
	if len(mmGetObjectDownloadURL.expectations) == 0 && mmGetObjectDownloadURL.defaultExpectation == nil && mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetObjectDownloadURL.mock.afterGetObjectDownloadURLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetObjectDownloadURL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetObjectDownloadURL implements repository.RepositoryI
func (mmGetObjectDownloadURL *RepositoryIMock) GetObjectDownloadURL(ctx context.Context, objectUID uuid.UUID) (op1 *mm_repository.ObjectURL, err error) {
	mm_atomic.AddUint64(&mmGetObjectDownloadURL.beforeGetObjectDownloadURLCounter, 1)
	defer mm_atomic.AddUint64(&mmGetObjectDownloadURL.afterGetObjectDownloadURLCounter, 1)

	if mmGetObjectDownloadURL.inspectFuncGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.inspectFuncGetObjectDownloadURL(ctx, objectUID)
	}

	mm_params := RepositoryIMockGetObjectDownloadURLParams{ctx, objectUID}

	// Record call args
	mmGetObjectDownloadURL.GetObjectDownloadURLMock.mutex.Lock()
	mmGetObjectDownloadURL.GetObjectDownloadURLMock.callArgs = append(mmGetObjectDownloadURL.GetObjectDownloadURLMock.callArgs, &mm_params)
	mmGetObjectDownloadURL.GetObjectDownloadURLMock.mutex.Unlock()

	for _, e := range mmGetObjectDownloadURL.GetObjectDownloadURLMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.Counter, 1)
		mm_want := mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.params
		mm_want_ptrs := mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetObjectDownloadURLParams{ctx, objectUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetObjectDownloadURL.t.Errorf("RepositoryIMock.GetObjectDownloadURL got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmGetObjectDownloadURL.t.Errorf("RepositoryIMock.GetObjectDownloadURL got unexpected parameter objectUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetObjectDownloadURL.t.Errorf("RepositoryIMock.GetObjectDownloadURL got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.results
		if mm_results == nil {
			mmGetObjectDownloadURL.t.Fatal("No results are set for the RepositoryIMock.GetObjectDownloadURL")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetObjectDownloadURL.funcGetObjectDownloadURL != nil {
		return mmGetObjectDownloadURL.funcGetObjectDownloadURL(ctx, objectUID)
	}
	mmGetObjectDownloadURL.t.Fatalf("Unexpected call to RepositoryIMock.GetObjectDownloadURL. %v %v", ctx, objectUID)
	return
}

// GetObjectDownloadURLAfterCounter returns a count of finished RepositoryIMock.GetObjectDownloadURL invocations
func (mmGetObjectDownloadURL *RepositoryIMock) GetObjectDownloadURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectDownloadURL.afterGetObjectDownloadURLCounter)
}

// GetObjectDownloadURLBeforeCounter returns a count of RepositoryIMock.GetObjectDownloadURL invocations
func (mmGetObjectDownloadURL *RepositoryIMock) GetObjectDownloadURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectDownloadURL.beforeGetObjectDownloadURLCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetObjectDownloadURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetObjectDownloadURL *mRepositoryIMockGetObjectDownloadURL) Calls() []*RepositoryIMockGetObjectDownloadURLParams {
	mmGetObjectDownloadURL.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetObjectDownloadURLParams, len(mmGetObjectDownloadURL.callArgs))
	copy(argCopy, mmGetObjectDownloadURL.callArgs)

	mmGetObjectDownloadURL.mutex.RUnlock()

	return argCopy
}

// MinimockGetObjectDownloadURLDone returns true if the count of the GetObjectDownloadURL invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetObjectDownloadURLDone() bool {
	for _, e := range m.GetObjectDownloadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetObjectDownloadURLMock.invocationsDone()
}

// MinimockGetObjectDownloadURLInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetObjectDownloadURLInspect() {
	for _, e := range m.GetObjectDownloadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetObjectDownloadURL with params: %#v", *e.params)
		}
	}

	afterGetObjectDownloadURLCounter := mm_atomic.LoadUint64(&m.afterGetObjectDownloadURLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetObjectDownloadURLMock.defaultExpectation != nil && afterGetObjectDownloadURLCounter < 1 {
		if m.GetObjectDownloadURLMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetObjectDownloadURL")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetObjectDownloadURL with params: %#v", *m.GetObjectDownloadURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetObjectDownloadURL != nil && afterGetObjectDownloadURLCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetObjectDownloadURL")
	}

	if !m.GetObjectDownloadURLMock.invocationsDone() && afterGetObjectDownloadURLCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetObjectDownloadURL but found %d calls",
			mm_atomic.LoadUint64(&m.GetObjectDownloadURLMock.expectedInvocations), afterGetObjectDownloadURLCounter)
	}
}

type mRepositoryIMockGetObjectURLByEncodedURLPath struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetObjectURLByEncodedURLPathExpectation
	expectations       []*RepositoryIMockGetObjectURLByEncodedURLPathExpectation

	callArgs []*RepositoryIMockGetObjectURLByEncodedURLPathParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetObjectURLByEncodedURLPathExpectation specifies expectation struct of the RepositoryI.GetObjectURLByEncodedURLPath
type RepositoryIMockGetObjectURLByEncodedURLPathExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetObjectURLByEncodedURLPathParams
	paramPtrs *RepositoryIMockGetObjectURLByEncodedURLPathParamPtrs
	results   *RepositoryIMockGetObjectURLByEncodedURLPathResults
	Counter   uint64
}

// RepositoryIMockGetObjectURLByEncodedURLPathParams contains parameters of the RepositoryI.GetObjectURLByEncodedURLPath
type RepositoryIMockGetObjectURLByEncodedURLPathParams struct {
	ctx            context.Context
	encodedURLPath string
}

// RepositoryIMockGetObjectURLByEncodedURLPathParamPtrs contains pointers to parameters of the RepositoryI.GetObjectURLByEncodedURLPath
type RepositoryIMockGetObjectURLByEncodedURLPathParamPtrs struct {
	ctx            *context.Context
	encodedURLPath *string
}

// RepositoryIMockGetObjectURLByEncodedURLPathResults contains results of the RepositoryI.GetObjectURLByEncodedURLPath
type RepositoryIMockGetObjectURLByEncodedURLPathResults struct {
	op1 *mm_repository.ObjectURL
	err error
}

// Expect sets up expected params for RepositoryI.GetObjectURLByEncodedURLPath
func (mmGetObjectURLByEncodedURLPath *mRepositoryIMockGetObjectURLByEncodedURLPath) Expect(ctx context.Context, encodedURLPath string) *mRepositoryIMockGetObjectURLByEncodedURLPath {
	if mmGetObjectURLByEncodedURLPath.mock.funcGetObjectURLByEncodedURLPath != nil {
		mmGetObjectURLByEncodedURLPath.mock.t.Fatalf("RepositoryIMock.GetObjectURLByEncodedURLPath mock is already set by Set")
	}

	if mmGetObjectURLByEncodedURLPath.defaultExpectation == nil {
		mmGetObjectURLByEncodedURLPath.defaultExpectation = &RepositoryIMockGetObjectURLByEncodedURLPathExpectation{}
	}

	if mmGetObjectURLByEncodedURLPath.defaultExpectation.paramPtrs != nil {
		mmGetObjectURLByEncodedURLPath.mock.t.Fatalf("RepositoryIMock.GetObjectURLByEncodedURLPath mock is already set by ExpectParams functions")
	}

	mmGetObjectURLByEncodedURLPath.defaultExpectation.params = &RepositoryIMockGetObjectURLByEncodedURLPathParams{ctx, encodedURLPath}
	for _, e := range mmGetObjectURLByEncodedURLPath.expectations {
		if minimock.Equal(e.params, mmGetObjectURLByEncodedURLPath.defaultExpectation.params) {
			mmGetObjectURLByEncodedURLPath.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetObjectURLByEncodedURLPath.defaultExpectation.params)
		}
	}

	return mmGetObjectURLByEncodedURLPath
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetObjectURLByEncodedURLPath
func (mmGetObjectURLByEncodedURLPath *mRepositoryIMockGetObjectURLByEncodedURLPath) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetObjectURLByEncodedURLPath {
	if mmGetObjectURLByEncodedURLPath.mock.funcGetObjectURLByEncodedURLPath != nil {
		mmGetObjectURLByEncodedURLPath.mock.t.Fatalf("RepositoryIMock.GetObjectURLByEncodedURLPath mock is already set by Set")
	}

	if mmGetObjectURLByEncodedURLPath.defaultExpectation == nil {
		mmGetObjectURLByEncodedURLPath.defaultExpectation = &RepositoryIMockGetObjectURLByEncodedURLPathExpectation{}
	}

	if mmGetObjectURLByEncodedURLPath.defaultExpectation.params != nil {
		mmGetObjectURLByEncodedURLPath.mock.t.Fatalf("RepositoryIMock.GetObjectURLByEncodedURLPath mock is already set by Expect")
	}

	if mmGetObjectURLByEncodedURLPath.defaultExpectation.paramPtrs == nil {
		mmGetObjectURLByEncodedURLPath.defaultExpectation.paramPtrs = &RepositoryIMockGetObjectURLByEncodedURLPathParamPtrs{}
	}
	mmGetObjectURLByEncodedURLPath.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetObjectURLByEncodedURLPath
}

// ExpectEncodedURLPathParam2 sets up expected param encodedURLPath for RepositoryI.GetObjectURLByEncodedURLPath
func (mmGetObjectURLByEncodedURLPath *mRepositoryIMockGetObjectURLByEncodedURLPath) ExpectEncodedURLPathParam2(encodedURLPath string) *mRepositoryIMockGetObjectURLByEncodedURLPath {
	if mmGetObjectURLByEncodedURLPath.mock.funcGetObjectURLByEncodedURLPath != nil {
		mmGetObjectURLByEncodedURLPath.mock.t.Fatalf("RepositoryIMock.GetObjectURLByEncodedURLPath mock is already set by Set")
	}

	if mmGetObjectURLByEncodedURLPath.defaultExpectation == nil {
		mmGetObjectURLByEncodedURLPath.defaultExpectation = &RepositoryIMockGetObjectURLByEncodedURLPathExpectation{}
	}

	if mmGetObjectURLByEncodedURLPath.defaultExpectation.params != nil {
		mmGetObjectURLByEncodedURLPath.mock.t.Fatalf("RepositoryIMock.GetObjectURLByEncodedURLPath mock is already set by Expect")
	}

	if mmGetObjectURLByEncodedURLPath.defaultExpectation.paramPtrs == nil {
		mmGetObjectURLByEncodedURLPath.defaultExpectation.paramPtrs = &RepositoryIMockGetObjectURLByEncodedURLPathParamPtrs{}
	}
	mmGetObjectURLByEncodedURLPath.defaultExpectation.paramPtrs.encodedURLPath = &encodedURLPath

	return mmGetObjectURLByEncodedURLPath
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetObjectURLByEncodedURLPath
func (mmGetObjectURLByEncodedURLPath *mRepositoryIMockGetObjectURLByEncodedURLPath) Inspect(f func(ctx context.Context, encodedURLPath string)) *mRepositoryIMockGetObjectURLByEncodedURLPath {
	if mmGetObjectURLByEncodedURLPath.mock.inspectFuncGetObjectURLByEncodedURLPath != nil {
		mmGetObjectURLByEncodedURLPath.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetObjectURLByEncodedURLPath")
	}

	mmGetObjectURLByEncodedURLPath.mock.inspectFuncGetObjectURLByEncodedURLPath = f

	return mmGetObjectURLByEncodedURLPath
}

// Return sets up results that will be returned by RepositoryI.GetObjectURLByEncodedURLPath
func (mmGetObjectURLByEncodedURLPath *mRepositoryIMockGetObjectURLByEncodedURLPath) Return(op1 *mm_repository.ObjectURL, err error) *RepositoryIMock {
	if mmGetObjectURLByEncodedURLPath.mock.funcGetObjectURLByEncodedURLPath != nil {
		mmGetObjectURLByEncodedURLPath.mock.t.Fatalf("RepositoryIMock.GetObjectURLByEncodedURLPath mock is already set by Set")
	}

	if mmGetObjectURLByEncodedURLPath.defaultExpectation == nil {
		mmGetObjectURLByEncodedURLPath.defaultExpectation = &RepositoryIMockGetObjectURLByEncodedURLPathExpectation{mock: mmGetObjectURLByEncodedURLPath.mock}
	}
	mmGetObjectURLByEncodedURLPath.defaultExpectation.results = &RepositoryIMockGetObjectURLByEncodedURLPathResults{op1, err}
	return mmGetObjectURLByEncodedURLPath.mock
}

// Set uses given function f to mock the RepositoryI.GetObjectURLByEncodedURLPath method
func (mmGetObjectURLByEncodedURLPath *mRepositoryIMockGetObjectURLByEncodedURLPath) Set(f func(ctx context.Context, encodedURLPath string) (op1 *mm_repository.ObjectURL, err error)) *RepositoryIMock {
	if mmGetObjectURLByEncodedURLPath.defaultExpectation != nil {
		mmGetObjectURLByEncodedURLPath.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetObjectURLByEncodedURLPath method")
	}

	if len(mmGetObjectURLByEncodedURLPath.expectations) > 0 {
		mmGetObjectURLByEncodedURLPath.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetObjectURLByEncodedURLPath method")
	}

	mmGetObjectURLByEncodedURLPath.mock.funcGetObjectURLByEncodedURLPath = f
	return mmGetObjectURLByEncodedURLPath.mock
}

// When sets expectation for the RepositoryI.GetObjectURLByEncodedURLPath which will trigger the result defined by the following
// Then helper
func (mmGetObjectURLByEncodedURLPath *mRepositoryIMockGetObjectURLByEncodedURLPath) When(ctx context.Context, encodedURLPath string) *RepositoryIMockGetObjectURLByEncodedURLPathExpectation {
	if mmGetObjectURLByEncodedURLPath.mock.funcGetObjectURLByEncodedURLPath != nil {
		mmGetObjectURLByEncodedURLPath.mock.t.Fatalf("RepositoryIMock.GetObjectURLByEncodedURLPath mock is already set by Set")
	}

	expectation := &RepositoryIMockGetObjectURLByEncodedURLPathExpectation{
		mock:   mmGetObjectURLByEncodedURLPath.mock,
		params: &RepositoryIMockGetObjectURLByEncodedURLPathParams{ctx, encodedURLPath},
	}
	mmGetObjectURLByEncodedURLPath.expectations = append(mmGetObjectURLByEncodedURLPath.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetObjectURLByEncodedURLPath return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetObjectURLByEncodedURLPathExpectation) Then(op1 *mm_repository.ObjectURL, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetObjectURLByEncodedURLPathResults{op1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetObjectURLByEncodedURLPath should be invoked
func (mmGetObjectURLByEncodedURLPath *mRepositoryIMockGetObjectURLByEncodedURLPath) Times(n uint64) *mRepositoryIMockGetObjectURLByEncodedURLPath {
	if n == 0 {
		mmGetObjectURLByEncodedURLPath.mock.t.Fatalf("Times of RepositoryIMock.GetObjectURLByEncodedURLPath mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetObjectURLByEncodedURLPath.expectedInvocations, n)
	return mmGetObjectURLByEncodedURLPath
}

func (mmGetObjectURLByEncodedURLPath *mRepositoryIMockGetObjectURLByEncodedURLPath) invocationsDone() bool {
	if len(mmGetObjectURLByEncodedURLPath.expectations) == 0 && mmGetObjectURLByEncodedURLPath.defaultExpectation == nil && mmGetObjectURLByEncodedURLPath.mock.funcGetObjectURLByEncodedURLPath == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetObjectURLByEncodedURLPath.mock.afterGetObjectURLByEncodedURLPathCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetObjectURLByEncodedURLPath.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetObjectURLByEncodedURLPath implements repository.RepositoryI
func (mmGetObjectURLByEncodedURLPath *RepositoryIMock) GetObjectURLByEncodedURLPath(ctx context.Context, encodedURLPath string) (op1 *mm_repository.ObjectURL, err error) {
	mm_atomic.AddUint64(&mmGetObjectURLByEncodedURLPath.beforeGetObjectURLByEncodedURLPathCounter, 1)
	defer mm_atomic.AddUint64(&mmGetObjectURLByEncodedURLPath.afterGetObjectURLByEncodedURLPathCounter, 1)

	if mmGetObjectURLByEncodedURLPath.inspectFuncGetObjectURLByEncodedURLPath != nil {
		mmGetObjectURLByEncodedURLPath.inspectFuncGetObjectURLByEncodedURLPath(ctx, encodedURLPath)
	}

	mm_params := RepositoryIMockGetObjectURLByEncodedURLPathParams{ctx, encodedURLPath}

	// Record call args
	mmGetObjectURLByEncodedURLPath.GetObjectURLByEncodedURLPathMock.mutex.Lock()
	mmGetObjectURLByEncodedURLPath.GetObjectURLByEncodedURLPathMock.callArgs = append(mmGetObjectURLByEncodedURLPath.GetObjectURLByEncodedURLPathMock.callArgs, &mm_params)
	mmGetObjectURLByEncodedURLPath.GetObjectURLByEncodedURLPathMock.mutex.Unlock()

	for _, e := range mmGetObjectURLByEncodedURLPath.GetObjectURLByEncodedURLPathMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetObjectURLByEncodedURLPath.GetObjectURLByEncodedURLPathMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetObjectURLByEncodedURLPath.GetObjectURLByEncodedURLPathMock.defaultExpectation.Counter, 1)
		mm_want := mmGetObjectURLByEncodedURLPath.GetObjectURLByEncodedURLPathMock.defaultExpectation.params
		mm_want_ptrs := mmGetObjectURLByEncodedURLPath.GetObjectURLByEncodedURLPathMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetObjectURLByEncodedURLPathParams{ctx, encodedURLPath}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetObjectURLByEncodedURLPath.t.Errorf("RepositoryIMock.GetObjectURLByEncodedURLPath got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.encodedURLPath != nil && !minimock.Equal(*mm_want_ptrs.encodedURLPath, mm_got.encodedURLPath) {
				mmGetObjectURLByEncodedURLPath.t.Errorf("RepositoryIMock.GetObjectURLByEncodedURLPath got unexpected parameter encodedURLPath, want: %#v, got: %#v%s\n", *mm_want_ptrs.encodedURLPath, mm_got.encodedURLPath, minimock.Diff(*mm_want_ptrs.encodedURLPath, mm_got.encodedURLPath))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetObjectURLByEncodedURLPath.t.Errorf("RepositoryIMock.GetObjectURLByEncodedURLPath got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetObjectURLByEncodedURLPath.GetObjectURLByEncodedURLPathMock.defaultExpectation.results
		if mm_results == nil {
			mmGetObjectURLByEncodedURLPath.t.Fatal("No results are set for the RepositoryIMock.GetObjectURLByEncodedURLPath")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetObjectURLByEncodedURLPath.funcGetObjectURLByEncodedURLPath != nil {
		return mmGetObjectURLByEncodedURLPath.funcGetObjectURLByEncodedURLPath(ctx, encodedURLPath)
	}
	mmGetObjectURLByEncodedURLPath.t.Fatalf("Unexpected call to RepositoryIMock.GetObjectURLByEncodedURLPath. %v %v", ctx, encodedURLPath)
	return
}

// GetObjectURLByEncodedURLPathAfterCounter returns a count of finished RepositoryIMock.GetObjectURLByEncodedURLPath invocations
func (mmGetObjectURLByEncodedURLPath *RepositoryIMock) GetObjectURLByEncodedURLPathAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectURLByEncodedURLPath.afterGetObjectURLByEncodedURLPathCounter)
}

// GetObjectURLByEncodedURLPathBeforeCounter returns a count of RepositoryIMock.GetObjectURLByEncodedURLPath invocations
func (mmGetObjectURLByEncodedURLPath *RepositoryIMock) GetObjectURLByEncodedURLPathBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectURLByEncodedURLPath.beforeGetObjectURLByEncodedURLPathCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetObjectURLByEncodedURLPath.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetObjectURLByEncodedURLPath *mRepositoryIMockGetObjectURLByEncodedURLPath) Calls() []*RepositoryIMockGetObjectURLByEncodedURLPathParams {
	mmGetObjectURLByEncodedURLPath.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetObjectURLByEncodedURLPathParams, len(mmGetObjectURLByEncodedURLPath.callArgs))
	copy(argCopy, mmGetObjectURLByEncodedURLPath.callArgs)

	mmGetObjectURLByEncodedURLPath.mutex.RUnlock()

	return argCopy
}

// MinimockGetObjectURLByEncodedURLPathDone returns true if the count of the GetObjectURLByEncodedURLPath invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetObjectURLByEncodedURLPathDone() bool {
	for _, e := range m.GetObjectURLByEncodedURLPathMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetObjectURLByEncodedURLPathMock.invocationsDone()
}

// MinimockGetObjectURLByEncodedURLPathInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetObjectURLByEncodedURLPathInspect() {
	for _, e := range m.GetObjectURLByEncodedURLPathMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetObjectURLByEncodedURLPath with params: %#v", *e.params)
		}
	}

	afterGetObjectURLByEncodedURLPathCounter := mm_atomic.LoadUint64(&m.afterGetObjectURLByEncodedURLPathCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetObjectURLByEncodedURLPathMock.defaultExpectation != nil && afterGetObjectURLByEncodedURLPathCounter < 1 {
		if m.GetObjectURLByEncodedURLPathMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetObjectURLByEncodedURLPath")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetObjectURLByEncodedURLPath with params: %#v", *m.GetObjectURLByEncodedURLPathMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetObjectURLByEncodedURLPath != nil && afterGetObjectURLByEncodedURLPathCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetObjectURLByEncodedURLPath")
	}

	if !m.GetObjectURLByEncodedURLPathMock.invocationsDone() && afterGetObjectURLByEncodedURLPathCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetObjectURLByEncodedURLPath but found %d calls",
			mm_atomic.LoadUint64(&m.GetObjectURLByEncodedURLPathMock.expectedInvocations), afterGetObjectURLByEncodedURLPathCounter)
	}
}

type mRepositoryIMockGetObjectURLByUID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetObjectURLByUIDExpectation
	expectations       []*RepositoryIMockGetObjectURLByUIDExpectation

	callArgs []*RepositoryIMockGetObjectURLByUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetObjectURLByUIDExpectation specifies expectation struct of the RepositoryI.GetObjectURLByUID
type RepositoryIMockGetObjectURLByUIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetObjectURLByUIDParams
	paramPtrs *RepositoryIMockGetObjectURLByUIDParamPtrs
	results   *RepositoryIMockGetObjectURLByUIDResults
	Counter   uint64
}

// RepositoryIMockGetObjectURLByUIDParams contains parameters of the RepositoryI.GetObjectURLByUID
type RepositoryIMockGetObjectURLByUIDParams struct {
	ctx context.Context
	uid uuid.UUID
}

// RepositoryIMockGetObjectURLByUIDParamPtrs contains pointers to parameters of the RepositoryI.GetObjectURLByUID
type RepositoryIMockGetObjectURLByUIDParamPtrs struct {
	ctx *context.Context
	uid *uuid.UUID
}

// RepositoryIMockGetObjectURLByUIDResults contains results of the RepositoryI.GetObjectURLByUID
type RepositoryIMockGetObjectURLByUIDResults struct {
	op1 *mm_repository.ObjectURL
	err error
}

// Expect sets up expected params for RepositoryI.GetObjectURLByUID
func (mmGetObjectURLByUID *mRepositoryIMockGetObjectURLByUID) Expect(ctx context.Context, uid uuid.UUID) *mRepositoryIMockGetObjectURLByUID {
	if mmGetObjectURLByUID.mock.funcGetObjectURLByUID != nil {
		mmGetObjectURLByUID.mock.t.Fatalf("RepositoryIMock.GetObjectURLByUID mock is already set by Set")
	}

	if mmGetObjectURLByUID.defaultExpectation == nil {
		mmGetObjectURLByUID.defaultExpectation = &RepositoryIMockGetObjectURLByUIDExpectation{}
	}

	if mmGetObjectURLByUID.defaultExpectation.paramPtrs != nil {
		mmGetObjectURLByUID.mock.t.Fatalf("RepositoryIMock.GetObjectURLByUID mock is already set by ExpectParams functions")
	}

	mmGetObjectURLByUID.defaultExpectation.params = &RepositoryIMockGetObjectURLByUIDParams{ctx, uid}
	for _, e := range mmGetObjectURLByUID.expectations {
		if minimock.Equal(e.params, mmGetObjectURLByUID.defaultExpectation.params) {
			mmGetObjectURLByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetObjectURLByUID.defaultExpectation.params)
		}
	}

	return mmGetObjectURLByUID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetObjectURLByUID
func (mmGetObjectURLByUID *mRepositoryIMockGetObjectURLByUID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetObjectURLByUID {
	if mmGetObjectURLByUID.mock.funcGetObjectURLByUID != nil {
		mmGetObjectURLByUID.mock.t.Fatalf("RepositoryIMock.GetObjectURLByUID mock is already set by Set")
	}

	if mmGetObjectURLByUID.defaultExpectation == nil {
		mmGetObjectURLByUID.defaultExpectation = &RepositoryIMockGetObjectURLByUIDExpectation{}
	}

	if mmGetObjectURLByUID.defaultExpectation.params != nil {
		mmGetObjectURLByUID.mock.t.Fatalf("RepositoryIMock.GetObjectURLByUID mock is already set by Expect")
	}

	if mmGetObjectURLByUID.defaultExpectation.paramPtrs == nil {
		mmGetObjectURLByUID.defaultExpectation.paramPtrs = &RepositoryIMockGetObjectURLByUIDParamPtrs{}
	}
	mmGetObjectURLByUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetObjectURLByUID
}

// ExpectUidParam2 sets up expected param uid for RepositoryI.GetObjectURLByUID
func (mmGetObjectURLByUID *mRepositoryIMockGetObjectURLByUID) ExpectUidParam2(uid uuid.UUID) *mRepositoryIMockGetObjectURLByUID {
	if mmGetObjectURLByUID.mock.funcGetObjectURLByUID != nil {
		mmGetObjectURLByUID.mock.t.Fatalf("RepositoryIMock.GetObjectURLByUID mock is already set by Set")
	}

	if mmGetObjectURLByUID.defaultExpectation == nil {
		mmGetObjectURLByUID.defaultExpectation = &RepositoryIMockGetObjectURLByUIDExpectation{}
	}

	if mmGetObjectURLByUID.defaultExpectation.params != nil {
		mmGetObjectURLByUID.mock.t.Fatalf("RepositoryIMock.GetObjectURLByUID mock is already set by Expect")
	}

	if mmGetObjectURLByUID.defaultExpectation.paramPtrs == nil {
		mmGetObjectURLByUID.defaultExpectation.paramPtrs = &RepositoryIMockGetObjectURLByUIDParamPtrs{}
	}
	mmGetObjectURLByUID.defaultExpectation.paramPtrs.uid = &uid

	return mmGetObjectURLByUID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetObjectURLByUID
func (mmGetObjectURLByUID *mRepositoryIMockGetObjectURLByUID) Inspect(f func(ctx context.Context, uid uuid.UUID)) *mRepositoryIMockGetObjectURLByUID {
	if mmGetObjectURLByUID.mock.inspectFuncGetObjectURLByUID != nil {
		mmGetObjectURLByUID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetObjectURLByUID")
	}

	mmGetObjectURLByUID.mock.inspectFuncGetObjectURLByUID = f

	return mmGetObjectURLByUID
}

// Return sets up results that will be returned by RepositoryI.GetObjectURLByUID
func (mmGetObjectURLByUID *mRepositoryIMockGetObjectURLByUID) Return(op1 *mm_repository.ObjectURL, err error) *RepositoryIMock {
	if mmGetObjectURLByUID.mock.funcGetObjectURLByUID != nil {
		mmGetObjectURLByUID.mock.t.Fatalf("RepositoryIMock.GetObjectURLByUID mock is already set by Set")
	}

	if mmGetObjectURLByUID.defaultExpectation == nil {
		mmGetObjectURLByUID.defaultExpectation = &RepositoryIMockGetObjectURLByUIDExpectation{mock: mmGetObjectURLByUID.mock}
	}
	mmGetObjectURLByUID.defaultExpectation.results = &RepositoryIMockGetObjectURLByUIDResults{op1, err}
	return mmGetObjectURLByUID.mock
}

// Set uses given function f to mock the RepositoryI.GetObjectURLByUID method
func (mmGetObjectURLByUID *mRepositoryIMockGetObjectURLByUID) Set(f func(ctx context.Context, uid uuid.UUID) (op1 *mm_repository.ObjectURL, err error)) *RepositoryIMock {
	if mmGetObjectURLByUID.defaultExpectation != nil {
		mmGetObjectURLByUID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetObjectURLByUID method")
	}

	if len(mmGetObjectURLByUID.expectations) > 0 {
		mmGetObjectURLByUID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetObjectURLByUID method")
	}

	mmGetObjectURLByUID.mock.funcGetObjectURLByUID = f
	return mmGetObjectURLByUID.mock
}

// When sets expectation for the RepositoryI.GetObjectURLByUID which will trigger the result defined by the following
// Then helper
func (mmGetObjectURLByUID *mRepositoryIMockGetObjectURLByUID) When(ctx context.Context, uid uuid.UUID) *RepositoryIMockGetObjectURLByUIDExpectation {
	if mmGetObjectURLByUID.mock.funcGetObjectURLByUID != nil {
		mmGetObjectURLByUID.mock.t.Fatalf("RepositoryIMock.GetObjectURLByUID mock is already set by Set")
	}

	expectation := &RepositoryIMockGetObjectURLByUIDExpectation{
		mock:   mmGetObjectURLByUID.mock,
		params: &RepositoryIMockGetObjectURLByUIDParams{ctx, uid},
	}
	mmGetObjectURLByUID.expectations = append(mmGetObjectURLByUID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetObjectURLByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetObjectURLByUIDExpectation) Then(op1 *mm_repository.ObjectURL, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetObjectURLByUIDResults{op1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetObjectURLByUID should be invoked
func (mmGetObjectURLByUID *mRepositoryIMockGetObjectURLByUID) Times(n uint64) *mRepositoryIMockGetObjectURLByUID {
	if n == 0 {
		mmGetObjectURLByUID.mock.t.Fatalf("Times of RepositoryIMock.GetObjectURLByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetObjectURLByUID.expectedInvocations, n)
	return mmGetObjectURLByUID
}

func (mmGetObjectURLByUID *mRepositoryIMockGetObjectURLByUID) invocationsDone() bool {
	if len(mmGetObjectURLByUID.expectations) == 0 && mmGetObjectURLByUID.defaultExpectation == nil && mmGetObjectURLByUID.mock.funcGetObjectURLByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetObjectURLByUID.mock.afterGetObjectURLByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetObjectURLByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetObjectURLByUID implements repository.RepositoryI
func (mmGetObjectURLByUID *RepositoryIMock) GetObjectURLByUID(ctx context.Context, uid uuid.UUID) (op1 *mm_repository.ObjectURL, err error) {
	mm_atomic.AddUint64(&mmGetObjectURLByUID.beforeGetObjectURLByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetObjectURLByUID.afterGetObjectURLByUIDCounter, 1)

	if mmGetObjectURLByUID.inspectFuncGetObjectURLByUID != nil {
		mmGetObjectURLByUID.inspectFuncGetObjectURLByUID(ctx, uid)
	}

	mm_params := RepositoryIMockGetObjectURLByUIDParams{ctx, uid}

	// Record call args
	mmGetObjectURLByUID.GetObjectURLByUIDMock.mutex.Lock()
	mmGetObjectURLByUID.GetObjectURLByUIDMock.callArgs = append(mmGetObjectURLByUID.GetObjectURLByUIDMock.callArgs, &mm_params)
	mmGetObjectURLByUID.GetObjectURLByUIDMock.mutex.Unlock()

	for _, e := range mmGetObjectURLByUID.GetObjectURLByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetObjectURLByUID.GetObjectURLByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetObjectURLByUID.GetObjectURLByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetObjectURLByUID.GetObjectURLByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetObjectURLByUID.GetObjectURLByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetObjectURLByUIDParams{ctx, uid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetObjectURLByUID.t.Errorf("RepositoryIMock.GetObjectURLByUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmGetObjectURLByUID.t.Errorf("RepositoryIMock.GetObjectURLByUID got unexpected parameter uid, want: %#v, got: %#v%s\n", *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetObjectURLByUID.t.Errorf("RepositoryIMock.GetObjectURLByUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetObjectURLByUID.GetObjectURLByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetObjectURLByUID.t.Fatal("No results are set for the RepositoryIMock.GetObjectURLByUID")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetObjectURLByUID.funcGetObjectURLByUID != nil {
		return mmGetObjectURLByUID.funcGetObjectURLByUID(ctx, uid)
	}
	mmGetObjectURLByUID.t.Fatalf("Unexpected call to RepositoryIMock.GetObjectURLByUID. %v %v", ctx, uid)
	return
}

// GetObjectURLByUIDAfterCounter returns a count of finished RepositoryIMock.GetObjectURLByUID invocations
func (mmGetObjectURLByUID *RepositoryIMock) GetObjectURLByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectURLByUID.afterGetObjectURLByUIDCounter)
}

// GetObjectURLByUIDBeforeCounter returns a count of RepositoryIMock.GetObjectURLByUID invocations
func (mmGetObjectURLByUID *RepositoryIMock) GetObjectURLByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectURLByUID.beforeGetObjectURLByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetObjectURLByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetObjectURLByUID *mRepositoryIMockGetObjectURLByUID) Calls() []*RepositoryIMockGetObjectURLByUIDParams {
	mmGetObjectURLByUID.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetObjectURLByUIDParams, len(mmGetObjectURLByUID.callArgs))
	copy(argCopy, mmGetObjectURLByUID.callArgs)

	mmGetObjectURLByUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetObjectURLByUIDDone returns true if the count of the GetObjectURLByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetObjectURLByUIDDone() bool {
	for _, e := range m.GetObjectURLByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetObjectURLByUIDMock.invocationsDone()
}

// MinimockGetObjectURLByUIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetObjectURLByUIDInspect() {
	for _, e := range m.GetObjectURLByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetObjectURLByUID with params: %#v", *e.params)
		}
	}

	afterGetObjectURLByUIDCounter := mm_atomic.LoadUint64(&m.afterGetObjectURLByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetObjectURLByUIDMock.defaultExpectation != nil && afterGetObjectURLByUIDCounter < 1 {
		if m.GetObjectURLByUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetObjectURLByUID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetObjectURLByUID with params: %#v", *m.GetObjectURLByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetObjectURLByUID != nil && afterGetObjectURLByUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetObjectURLByUID")
	}

	if !m.GetObjectURLByUIDMock.invocationsDone() && afterGetObjectURLByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetObjectURLByUID but found %d calls",
			mm_atomic.LoadUint64(&m.GetObjectURLByUIDMock.expectedInvocations), afterGetObjectURLByUIDCounter)
	}
}

type mRepositoryIMockGetObjectURLCountByObject struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetObjectURLCountByObjectExpectation
	expectations       []*RepositoryIMockGetObjectURLCountByObjectExpectation

	callArgs []*RepositoryIMockGetObjectURLCountByObjectParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetObjectURLCountByObjectExpectation specifies expectation struct of the RepositoryI.GetObjectURLCountByObject
type RepositoryIMockGetObjectURLCountByObjectExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetObjectURLCountByObjectParams
	paramPtrs *RepositoryIMockGetObjectURLCountByObjectParamPtrs
	results   *RepositoryIMockGetObjectURLCountByObjectResults
	Counter   uint64
}

// RepositoryIMockGetObjectURLCountByObjectParams contains parameters of the RepositoryI.GetObjectURLCountByObject
type RepositoryIMockGetObjectURLCountByObjectParams struct {
	ctx       context.Context
	objectUID uuid.UUID
}

// RepositoryIMockGetObjectURLCountByObjectParamPtrs contains pointers to parameters of the RepositoryI.GetObjectURLCountByObject
type RepositoryIMockGetObjectURLCountByObjectParamPtrs struct {
	ctx       *context.Context
	objectUID *uuid.UUID
}

// RepositoryIMockGetObjectURLCountByObjectResults contains results of the RepositoryI.GetObjectURLCountByObject
type RepositoryIMockGetObjectURLCountByObjectResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for RepositoryI.GetObjectURLCountByObject
func (mmGetObjectURLCountByObject *mRepositoryIMockGetObjectURLCountByObject) Expect(ctx context.Context, objectUID uuid.UUID) *mRepositoryIMockGetObjectURLCountByObject {
	if mmGetObjectURLCountByObject.mock.funcGetObjectURLCountByObject != nil {
		mmGetObjectURLCountByObject.mock.t.Fatalf("RepositoryIMock.GetObjectURLCountByObject mock is already set by Set")
	}

	if mmGetObjectURLCountByObject.defaultExpectation == nil {
		mmGetObjectURLCountByObject.defaultExpectation = &RepositoryIMockGetObjectURLCountByObjectExpectation{}
	}

	if mmGetObjectURLCountByObject.defaultExpectation.paramPtrs != nil {
		mmGetObjectURLCountByObject.mock.t.Fatalf("RepositoryIMock.GetObjectURLCountByObject mock is already set by ExpectParams functions")
	}

	mmGetObjectURLCountByObject.defaultExpectation.params = &RepositoryIMockGetObjectURLCountByObjectParams{ctx, objectUID}
	for _, e := range mmGetObjectURLCountByObject.expectations {
		if minimock.Equal(e.params, mmGetObjectURLCountByObject.defaultExpectation.params) {
			mmGetObjectURLCountByObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetObjectURLCountByObject.defaultExpectation.params)
		}
	}

	return mmGetObjectURLCountByObject
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetObjectURLCountByObject
func (mmGetObjectURLCountByObject *mRepositoryIMockGetObjectURLCountByObject) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetObjectURLCountByObject {
	if mmGetObjectURLCountByObject.mock.funcGetObjectURLCountByObject != nil {
		mmGetObjectURLCountByObject.mock.t.Fatalf("RepositoryIMock.GetObjectURLCountByObject mock is already set by Set")
	}

	if mmGetObjectURLCountByObject.defaultExpectation == nil {
		mmGetObjectURLCountByObject.defaultExpectation = &RepositoryIMockGetObjectURLCountByObjectExpectation{}
	}

	if mmGetObjectURLCountByObject.defaultExpectation.params != nil {
		mmGetObjectURLCountByObject.mock.t.Fatalf("RepositoryIMock.GetObjectURLCountByObject mock is already set by Expect")
	}

	if mmGetObjectURLCountByObject.defaultExpectation.paramPtrs == nil {
		mmGetObjectURLCountByObject.defaultExpectation.paramPtrs = &RepositoryIMockGetObjectURLCountByObjectParamPtrs{}
	}
	mmGetObjectURLCountByObject.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetObjectURLCountByObject
}

// ExpectObjectUIDParam2 sets up expected param objectUID for RepositoryI.GetObjectURLCountByObject
func (mmGetObjectURLCountByObject *mRepositoryIMockGetObjectURLCountByObject) ExpectObjectUIDParam2(objectUID uuid.UUID) *mRepositoryIMockGetObjectURLCountByObject {
	if mmGetObjectURLCountByObject.mock.funcGetObjectURLCountByObject != nil {
		mmGetObjectURLCountByObject.mock.t.Fatalf("RepositoryIMock.GetObjectURLCountByObject mock is already set by Set")
	}

	if mmGetObjectURLCountByObject.defaultExpectation == nil {
		mmGetObjectURLCountByObject.defaultExpectation = &RepositoryIMockGetObjectURLCountByObjectExpectation{}
	}

	if mmGetObjectURLCountByObject.defaultExpectation.params != nil {
		mmGetObjectURLCountByObject.mock.t.Fatalf("RepositoryIMock.GetObjectURLCountByObject mock is already set by Expect")
	}

	if mmGetObjectURLCountByObject.defaultExpectation.paramPtrs == nil {
		mmGetObjectURLCountByObject.defaultExpectation.paramPtrs = &RepositoryIMockGetObjectURLCountByObjectParamPtrs{}
	}
	mmGetObjectURLCountByObject.defaultExpectation.paramPtrs.objectUID = &objectUID

	return mmGetObjectURLCountByObject
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetObjectURLCountByObject
func (mmGetObjectURLCountByObject *mRepositoryIMockGetObjectURLCountByObject) Inspect(f func(ctx context.Context, objectUID uuid.UUID)) *mRepositoryIMockGetObjectURLCountByObject {
	if mmGetObjectURLCountByObject.mock.inspectFuncGetObjectURLCountByObject != nil {
		mmGetObjectURLCountByObject.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetObjectURLCountByObject")
	}

	mmGetObjectURLCountByObject.mock.inspectFuncGetObjectURLCountByObject = f

	return mmGetObjectURLCountByObject
}

// Return sets up results that will be returned by RepositoryI.GetObjectURLCountByObject
func (mmGetObjectURLCountByObject *mRepositoryIMockGetObjectURLCountByObject) Return(i1 int64, err error) *RepositoryIMock {
	if mmGetObjectURLCountByObject.mock.funcGetObjectURLCountByObject != nil {
		mmGetObjectURLCountByObject.mock.t.Fatalf("RepositoryIMock.GetObjectURLCountByObject mock is already set by Set")
	}

	if mmGetObjectURLCountByObject.defaultExpectation == nil {
		mmGetObjectURLCountByObject.defaultExpectation = &RepositoryIMockGetObjectURLCountByObjectExpectation{mock: mmGetObjectURLCountByObject.mock}
	}
	mmGetObjectURLCountByObject.defaultExpectation.results = &RepositoryIMockGetObjectURLCountByObjectResults{i1, err}
	return mmGetObjectURLCountByObject.mock
}

// Set uses given function f to mock the RepositoryI.GetObjectURLCountByObject method
func (mmGetObjectURLCountByObject *mRepositoryIMockGetObjectURLCountByObject) Set(f func(ctx context.Context, objectUID uuid.UUID) (i1 int64, err error)) *RepositoryIMock {
	if mmGetObjectURLCountByObject.defaultExpectation != nil {
		mmGetObjectURLCountByObject.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetObjectURLCountByObject method")
	}

	if len(mmGetObjectURLCountByObject.expectations) > 0 {
		mmGetObjectURLCountByObject.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetObjectURLCountByObject method")
	}

	mmGetObjectURLCountByObject.mock.funcGetObjectURLCountByObject = f
	return mmGetObjectURLCountByObject.mock
}

// When sets expectation for the RepositoryI.GetObjectURLCountByObject which will trigger the result defined by the following
// Then helper
func (mmGetObjectURLCountByObject *mRepositoryIMockGetObjectURLCountByObject) When(ctx context.Context, objectUID uuid.UUID) *RepositoryIMockGetObjectURLCountByObjectExpectation {
	if mmGetObjectURLCountByObject.mock.funcGetObjectURLCountByObject != nil {
		mmGetObjectURLCountByObject.mock.t.Fatalf("RepositoryIMock.GetObjectURLCountByObject mock is already set by Set")
	}

	expectation := &RepositoryIMockGetObjectURLCountByObjectExpectation{
		mock:   mmGetObjectURLCountByObject.mock,
		params: &RepositoryIMockGetObjectURLCountByObjectParams{ctx, objectUID},
	}
	mmGetObjectURLCountByObject.expectations = append(mmGetObjectURLCountByObject.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetObjectURLCountByObject return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetObjectURLCountByObjectExpectation) Then(i1 int64, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetObjectURLCountByObjectResults{i1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetObjectURLCountByObject should be invoked
func (mmGetObjectURLCountByObject *mRepositoryIMockGetObjectURLCountByObject) Times(n uint64) *mRepositoryIMockGetObjectURLCountByObject {
	if n == 0 {
		mmGetObjectURLCountByObject.mock.t.Fatalf("Times of RepositoryIMock.GetObjectURLCountByObject mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetObjectURLCountByObject.expectedInvocations, n)
	return mmGetObjectURLCountByObject
}

func (mmGetObjectURLCountByObject *mRepositoryIMockGetObjectURLCountByObject) invocationsDone() bool {
	if len(mmGetObjectURLCountByObject.expectations) == 0 && mmGetObjectURLCountByObject.defaultExpectation == nil && mmGetObjectURLCountByObject.mock.funcGetObjectURLCountByObject == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetObjectURLCountByObject.mock.afterGetObjectURLCountByObjectCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetObjectURLCountByObject.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetObjectURLCountByObject implements repository.RepositoryI
func (mmGetObjectURLCountByObject *RepositoryIMock) GetObjectURLCountByObject(ctx context.Context, objectUID uuid.UUID) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetObjectURLCountByObject.beforeGetObjectURLCountByObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmGetObjectURLCountByObject.afterGetObjectURLCountByObjectCounter, 1)

	if mmGetObjectURLCountByObject.inspectFuncGetObjectURLCountByObject != nil {
		mmGetObjectURLCountByObject.inspectFuncGetObjectURLCountByObject(ctx, objectUID)
	}

	mm_params := RepositoryIMockGetObjectURLCountByObjectParams{ctx, objectUID}

	// Record call args
	mmGetObjectURLCountByObject.GetObjectURLCountByObjectMock.mutex.Lock()
	mmGetObjectURLCountByObject.GetObjectURLCountByObjectMock.callArgs = append(mmGetObjectURLCountByObject.GetObjectURLCountByObjectMock.callArgs, &mm_params)
	mmGetObjectURLCountByObject.GetObjectURLCountByObjectMock.mutex.Unlock()

	for _, e := range mmGetObjectURLCountByObject.GetObjectURLCountByObjectMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetObjectURLCountByObject.GetObjectURLCountByObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetObjectURLCountByObject.GetObjectURLCountByObjectMock.defaultExpectation.Counter, 1)
		mm_want := mmGetObjectURLCountByObject.GetObjectURLCountByObjectMock.defaultExpectation.params
		mm_want_ptrs := mmGetObjectURLCountByObject.GetObjectURLCountByObjectMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetObjectURLCountByObjectParams{ctx, objectUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetObjectURLCountByObject.t.Errorf("RepositoryIMock.GetObjectURLCountByObject got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmGetObjectURLCountByObject.t.Errorf("RepositoryIMock.GetObjectURLCountByObject got unexpected parameter objectUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetObjectURLCountByObject.t.Errorf("RepositoryIMock.GetObjectURLCountByObject got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetObjectURLCountByObject.GetObjectURLCountByObjectMock.defaultExpectation.results
		if mm_results == nil {
			mmGetObjectURLCountByObject.t.Fatal("No results are set for the RepositoryIMock.GetObjectURLCountByObject")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetObjectURLCountByObject.funcGetObjectURLCountByObject != nil {
		return mmGetObjectURLCountByObject.funcGetObjectURLCountByObject(ctx, objectUID)
	}
	mmGetObjectURLCountByObject.t.Fatalf("Unexpected call to RepositoryIMock.GetObjectURLCountByObject. %v %v", ctx, objectUID)
	return
}

// GetObjectURLCountByObjectAfterCounter returns a count of finished RepositoryIMock.GetObjectURLCountByObject invocations
func (mmGetObjectURLCountByObject *RepositoryIMock) GetObjectURLCountByObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectURLCountByObject.afterGetObjectURLCountByObjectCounter)
}

// GetObjectURLCountByObjectBeforeCounter returns a count of RepositoryIMock.GetObjectURLCountByObject invocations
func (mmGetObjectURLCountByObject *RepositoryIMock) GetObjectURLCountByObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectURLCountByObject.beforeGetObjectURLCountByObjectCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetObjectURLCountByObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetObjectURLCountByObject *mRepositoryIMockGetObjectURLCountByObject) Calls() []*RepositoryIMockGetObjectURLCountByObjectParams {
	mmGetObjectURLCountByObject.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetObjectURLCountByObjectParams, len(mmGetObjectURLCountByObject.callArgs))
	copy(argCopy, mmGetObjectURLCountByObject.callArgs)

	mmGetObjectURLCountByObject.mutex.RUnlock()

	return argCopy
}

// MinimockGetObjectURLCountByObjectDone returns true if the count of the GetObjectURLCountByObject invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetObjectURLCountByObjectDone() bool {
	for _, e := range m.GetObjectURLCountByObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetObjectURLCountByObjectMock.invocationsDone()
}

// MinimockGetObjectURLCountByObjectInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetObjectURLCountByObjectInspect() {
	for _, e := range m.GetObjectURLCountByObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetObjectURLCountByObject with params: %#v", *e.params)
		}
	}

	afterGetObjectURLCountByObjectCounter := mm_atomic.LoadUint64(&m.afterGetObjectURLCountByObjectCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetObjectURLCountByObjectMock.defaultExpectation != nil && afterGetObjectURLCountByObjectCounter < 1 {
		if m.GetObjectURLCountByObjectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetObjectURLCountByObject")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetObjectURLCountByObject with params: %#v", *m.GetObjectURLCountByObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetObjectURLCountByObject != nil && afterGetObjectURLCountByObjectCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetObjectURLCountByObject")
	}

	if !m.GetObjectURLCountByObjectMock.invocationsDone() && afterGetObjectURLCountByObjectCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetObjectURLCountByObject but found %d calls",
			mm_atomic.LoadUint64(&m.GetObjectURLCountByObjectMock.expectedInvocations), afterGetObjectURLCountByObjectCounter)
	}
}

type mRepositoryIMockGetObjectUploadURL struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetObjectUploadURLExpectation
	expectations       []*RepositoryIMockGetObjectUploadURLExpectation

	callArgs []*RepositoryIMockGetObjectUploadURLParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetObjectUploadURLExpectation specifies expectation struct of the RepositoryI.GetObjectUploadURL
type RepositoryIMockGetObjectUploadURLExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetObjectUploadURLParams
	paramPtrs *RepositoryIMockGetObjectUploadURLParamPtrs
	results   *RepositoryIMockGetObjectUploadURLResults
	Counter   uint64
}

// RepositoryIMockGetObjectUploadURLParams contains parameters of the RepositoryI.GetObjectUploadURL
type RepositoryIMockGetObjectUploadURLParams struct {
	ctx       context.Context
	objectUID uuid.UUID
}

// RepositoryIMockGetObjectUploadURLParamPtrs contains pointers to parameters of the RepositoryI.GetObjectUploadURL
type RepositoryIMockGetObjectUploadURLParamPtrs struct {
	ctx       *context.Context
	objectUID *uuid.UUID
}

// RepositoryIMockGetObjectUploadURLResults contains results of the RepositoryI.GetObjectUploadURL
type RepositoryIMockGetObjectUploadURLResults struct {
	op1 *mm_repository.ObjectURL
	err error
}

// Expect sets up expected params for RepositoryI.GetObjectUploadURL
func (mmGetObjectUploadURL *mRepositoryIMockGetObjectUploadURL) Expect(ctx context.Context, objectUID uuid.UUID) *mRepositoryIMockGetObjectUploadURL {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("RepositoryIMock.GetObjectUploadURL mock is already set by Set")
	}

	if mmGetObjectUploadURL.defaultExpectation == nil {
		mmGetObjectUploadURL.defaultExpectation = &RepositoryIMockGetObjectUploadURLExpectation{}
	}

	if mmGetObjectUploadURL.defaultExpectation.paramPtrs != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("RepositoryIMock.GetObjectUploadURL mock is already set by ExpectParams functions")
	}

	mmGetObjectUploadURL.defaultExpectation.params = &RepositoryIMockGetObjectUploadURLParams{ctx, objectUID}
	for _, e := range mmGetObjectUploadURL.expectations {
		if minimock.Equal(e.params, mmGetObjectUploadURL.defaultExpectation.params) {
			mmGetObjectUploadURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetObjectUploadURL.defaultExpectation.params)
		}
	}

	return mmGetObjectUploadURL
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetObjectUploadURL
func (mmGetObjectUploadURL *mRepositoryIMockGetObjectUploadURL) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetObjectUploadURL {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("RepositoryIMock.GetObjectUploadURL mock is already set by Set")
	}

	if mmGetObjectUploadURL.defaultExpectation == nil {
		mmGetObjectUploadURL.defaultExpectation = &RepositoryIMockGetObjectUploadURLExpectation{}
	}

	if mmGetObjectUploadURL.defaultExpectation.params != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("RepositoryIMock.GetObjectUploadURL mock is already set by Expect")
	}

	if mmGetObjectUploadURL.defaultExpectation.paramPtrs == nil {
		mmGetObjectUploadURL.defaultExpectation.paramPtrs = &RepositoryIMockGetObjectUploadURLParamPtrs{}
	}
	mmGetObjectUploadURL.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetObjectUploadURL
}

// ExpectObjectUIDParam2 sets up expected param objectUID for RepositoryI.GetObjectUploadURL
func (mmGetObjectUploadURL *mRepositoryIMockGetObjectUploadURL) ExpectObjectUIDParam2(objectUID uuid.UUID) *mRepositoryIMockGetObjectUploadURL {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("RepositoryIMock.GetObjectUploadURL mock is already set by Set")
	}

	if mmGetObjectUploadURL.defaultExpectation == nil {
		mmGetObjectUploadURL.defaultExpectation = &RepositoryIMockGetObjectUploadURLExpectation{}
	}

	if mmGetObjectUploadURL.defaultExpectation.params != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("RepositoryIMock.GetObjectUploadURL mock is already set by Expect")
	}

	if mmGetObjectUploadURL.defaultExpectation.paramPtrs == nil {
		mmGetObjectUploadURL.defaultExpectation.paramPtrs = &RepositoryIMockGetObjectUploadURLParamPtrs{}
	}
	mmGetObjectUploadURL.defaultExpectation.paramPtrs.objectUID = &objectUID

	return mmGetObjectUploadURL
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetObjectUploadURL
func (mmGetObjectUploadURL *mRepositoryIMockGetObjectUploadURL) Inspect(f func(ctx context.Context, objectUID uuid.UUID)) *mRepositoryIMockGetObjectUploadURL {
	if mmGetObjectUploadURL.mock.inspectFuncGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetObjectUploadURL")
	}

	mmGetObjectUploadURL.mock.inspectFuncGetObjectUploadURL = f

	return mmGetObjectUploadURL
}

// Return sets up results that will be returned by RepositoryI.GetObjectUploadURL
func (mmGetObjectUploadURL *mRepositoryIMockGetObjectUploadURL) Return(op1 *mm_repository.ObjectURL, err error) *RepositoryIMock {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("RepositoryIMock.GetObjectUploadURL mock is already set by Set")
	}

	if mmGetObjectUploadURL.defaultExpectation == nil {
		mmGetObjectUploadURL.defaultExpectation = &RepositoryIMockGetObjectUploadURLExpectation{mock: mmGetObjectUploadURL.mock}
	}
	mmGetObjectUploadURL.defaultExpectation.results = &RepositoryIMockGetObjectUploadURLResults{op1, err}
	return mmGetObjectUploadURL.mock
}

// Set uses given function f to mock the RepositoryI.GetObjectUploadURL method
func (mmGetObjectUploadURL *mRepositoryIMockGetObjectUploadURL) Set(f func(ctx context.Context, objectUID uuid.UUID) (op1 *mm_repository.ObjectURL, err error)) *RepositoryIMock {
	if mmGetObjectUploadURL.defaultExpectation != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetObjectUploadURL method")
	}

	if len(mmGetObjectUploadURL.expectations) > 0 {
		mmGetObjectUploadURL.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetObjectUploadURL method")
	}

	mmGetObjectUploadURL.mock.funcGetObjectUploadURL = f
	return mmGetObjectUploadURL.mock
}

// When sets expectation for the RepositoryI.GetObjectUploadURL which will trigger the result defined by the following
// Then helper
func (mmGetObjectUploadURL *mRepositoryIMockGetObjectUploadURL) When(ctx context.Context, objectUID uuid.UUID) *RepositoryIMockGetObjectUploadURLExpectation {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("RepositoryIMock.GetObjectUploadURL mock is already set by Set")
	}

	expectation := &RepositoryIMockGetObjectUploadURLExpectation{
		mock:   mmGetObjectUploadURL.mock,
		params: &RepositoryIMockGetObjectUploadURLParams{ctx, objectUID},
	}
	mmGetObjectUploadURL.expectations = append(mmGetObjectUploadURL.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetObjectUploadURL return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetObjectUploadURLExpectation) Then(op1 *mm_repository.ObjectURL, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetObjectUploadURLResults{op1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetObjectUploadURL should be invoked
func (mmGetObjectUploadURL *mRepositoryIMockGetObjectUploadURL) Times(n uint64) *mRepositoryIMockGetObjectUploadURL {
	if n == 0 {
		mmGetObjectUploadURL.mock.t.Fatalf("Times of RepositoryIMock.GetObjectUploadURL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetObjectUploadURL.expectedInvocations, n)
	return mmGetObjectUploadURL
}

func (mmGetObjectUploadURL *mRepositoryIMockGetObjectUploadURL) invocationsDone() bool {
	if len(mmGetObjectUploadURL.expectations) == 0 && mmGetObjectUploadURL.defaultExpectation == nil && mmGetObjectUploadURL.mock.funcGetObjectUploadURL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetObjectUploadURL.mock.afterGetObjectUploadURLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetObjectUploadURL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetObjectUploadURL implements repository.RepositoryI
func (mmGetObjectUploadURL *RepositoryIMock) GetObjectUploadURL(ctx context.Context, objectUID uuid.UUID) (op1 *mm_repository.ObjectURL, err error) {
	mm_atomic.AddUint64(&mmGetObjectUploadURL.beforeGetObjectUploadURLCounter, 1)
	defer mm_atomic.AddUint64(&mmGetObjectUploadURL.afterGetObjectUploadURLCounter, 1)

	if mmGetObjectUploadURL.inspectFuncGetObjectUploadURL != nil {
		mmGetObjectUploadURL.inspectFuncGetObjectUploadURL(ctx, objectUID)
	}

	mm_params := RepositoryIMockGetObjectUploadURLParams{ctx, objectUID}

	// Record call args
	mmGetObjectUploadURL.GetObjectUploadURLMock.mutex.Lock()
	mmGetObjectUploadURL.GetObjectUploadURLMock.callArgs = append(mmGetObjectUploadURL.GetObjectUploadURLMock.callArgs, &mm_params)
	mmGetObjectUploadURL.GetObjectUploadURLMock.mutex.Unlock()

	for _, e := range mmGetObjectUploadURL.GetObjectUploadURLMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.Counter, 1)
		mm_want := mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.params
		mm_want_ptrs := mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetObjectUploadURLParams{ctx, objectUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetObjectUploadURL.t.Errorf("RepositoryIMock.GetObjectUploadURL got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmGetObjectUploadURL.t.Errorf("RepositoryIMock.GetObjectUploadURL got unexpected parameter objectUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetObjectUploadURL.t.Errorf("RepositoryIMock.GetObjectUploadURL got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.results
		if mm_results == nil {
			mmGetObjectUploadURL.t.Fatal("No results are set for the RepositoryIMock.GetObjectUploadURL")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetObjectUploadURL.funcGetObjectUploadURL != nil {
		return mmGetObjectUploadURL.funcGetObjectUploadURL(ctx, objectUID)
	}
	mmGetObjectUploadURL.t.Fatalf("Unexpected call to RepositoryIMock.GetObjectUploadURL. %v %v", ctx, objectUID)
	return
}

// GetObjectUploadURLAfterCounter returns a count of finished RepositoryIMock.GetObjectUploadURL invocations
func (mmGetObjectUploadURL *RepositoryIMock) GetObjectUploadURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectUploadURL.afterGetObjectUploadURLCounter)
}

// GetObjectUploadURLBeforeCounter returns a count of RepositoryIMock.GetObjectUploadURL invocations
func (mmGetObjectUploadURL *RepositoryIMock) GetObjectUploadURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectUploadURL.beforeGetObjectUploadURLCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetObjectUploadURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetObjectUploadURL *mRepositoryIMockGetObjectUploadURL) Calls() []*RepositoryIMockGetObjectUploadURLParams {
	mmGetObjectUploadURL.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetObjectUploadURLParams, len(mmGetObjectUploadURL.callArgs))
	copy(argCopy, mmGetObjectUploadURL.callArgs)

	mmGetObjectUploadURL.mutex.RUnlock()

	return argCopy
}

// MinimockGetObjectUploadURLDone returns true if the count of the GetObjectUploadURL invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetObjectUploadURLDone() bool {
	for _, e := range m.GetObjectUploadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetObjectUploadURLMock.invocationsDone()
}

// MinimockGetObjectUploadURLInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetObjectUploadURLInspect() {
	for _, e := range m.GetObjectUploadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetObjectUploadURL with params: %#v", *e.params)
		}
	}

	afterGetObjectUploadURLCounter := mm_atomic.LoadUint64(&m.afterGetObjectUploadURLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetObjectUploadURLMock.defaultExpectation != nil && afterGetObjectUploadURLCounter < 1 {
		if m.GetObjectUploadURLMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetObjectUploadURL")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetObjectUploadURL with params: %#v", *m.GetObjectUploadURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetObjectUploadURL != nil && afterGetObjectUploadURLCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetObjectUploadURL")
	}

	if !m.GetObjectUploadURLMock.invocationsDone() && afterGetObjectUploadURLCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetObjectUploadURL but found %d calls",
			mm_atomic.LoadUint64(&m.GetObjectUploadURLMock.expectedInvocations), afterGetObjectUploadURLCounter)
	}
}

type mRepositoryIMockGetRepositoryTag struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetRepositoryTagExpectation
	expectations       []*RepositoryIMockGetRepositoryTagExpectation

	callArgs []*RepositoryIMockGetRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetRepositoryTagExpectation specifies expectation struct of the RepositoryI.GetRepositoryTag
type RepositoryIMockGetRepositoryTagExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetRepositoryTagParams
	paramPtrs *RepositoryIMockGetRepositoryTagParamPtrs
	results   *RepositoryIMockGetRepositoryTagResults
	Counter   uint64
}

// RepositoryIMockGetRepositoryTagParams contains parameters of the RepositoryI.GetRepositoryTag
type RepositoryIMockGetRepositoryTagParams struct {
	ctx context.Context
	r1  utils.RepositoryTagName
}

// RepositoryIMockGetRepositoryTagParamPtrs contains pointers to parameters of the RepositoryI.GetRepositoryTag
type RepositoryIMockGetRepositoryTagParamPtrs struct {
	ctx *context.Context
	r1  *utils.RepositoryTagName
}

// RepositoryIMockGetRepositoryTagResults contains results of the RepositoryI.GetRepositoryTag
type RepositoryIMockGetRepositoryTagResults struct {
	rp1 *pb.RepositoryTag
	err error
}

// Expect sets up expected params for RepositoryI.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) Expect(ctx context.Context, r1 utils.RepositoryTagName) *mRepositoryIMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryIMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by ExpectParams functions")
	}

	mmGetRepositoryTag.defaultExpectation.params = &RepositoryIMockGetRepositoryTagParams{ctx, r1}
	for _, e := range mmGetRepositoryTag.expectations {
		if minimock.Equal(e.params, mmGetRepositoryTag.defaultExpectation.params) {
			mmGetRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRepositoryTag.defaultExpectation.params)
		}
	}

	return mmGetRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryIMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.params != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by Expect")
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmGetRepositoryTag.defaultExpectation.paramPtrs = &RepositoryIMockGetRepositoryTagParamPtrs{}
	}
	mmGetRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetRepositoryTag
}

// ExpectR1Param2 sets up expected param r1 for RepositoryI.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) ExpectR1Param2(r1 utils.RepositoryTagName) *mRepositoryIMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryIMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.params != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by Expect")
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmGetRepositoryTag.defaultExpectation.paramPtrs = &RepositoryIMockGetRepositoryTagParamPtrs{}
	}
	mmGetRepositoryTag.defaultExpectation.paramPtrs.r1 = &r1

	return mmGetRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) Inspect(f func(ctx context.Context, r1 utils.RepositoryTagName)) *mRepositoryIMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.inspectFuncGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetRepositoryTag")
	}

	mmGetRepositoryTag.mock.inspectFuncGetRepositoryTag = f

	return mmGetRepositoryTag
}

// Return sets up results that will be returned by RepositoryI.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) Return(rp1 *pb.RepositoryTag, err error) *RepositoryIMock {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryIMockGetRepositoryTagExpectation{mock: mmGetRepositoryTag.mock}
	}
	mmGetRepositoryTag.defaultExpectation.results = &RepositoryIMockGetRepositoryTagResults{rp1, err}
	return mmGetRepositoryTag.mock
}

// Set uses given function f to mock the RepositoryI.GetRepositoryTag method
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) Set(f func(ctx context.Context, r1 utils.RepositoryTagName) (rp1 *pb.RepositoryTag, err error)) *RepositoryIMock {
	if mmGetRepositoryTag.defaultExpectation != nil {
		mmGetRepositoryTag.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetRepositoryTag method")
	}

	if len(mmGetRepositoryTag.expectations) > 0 {
		mmGetRepositoryTag.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetRepositoryTag method")
	}

	mmGetRepositoryTag.mock.funcGetRepositoryTag = f
	return mmGetRepositoryTag.mock
}

// When sets expectation for the RepositoryI.GetRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) When(ctx context.Context, r1 utils.RepositoryTagName) *RepositoryIMockGetRepositoryTagExpectation {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by Set")
	}

	expectation := &RepositoryIMockGetRepositoryTagExpectation{
		mock:   mmGetRepositoryTag.mock,
		params: &RepositoryIMockGetRepositoryTagParams{ctx, r1},
	}
	mmGetRepositoryTag.expectations = append(mmGetRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetRepositoryTag return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetRepositoryTagExpectation) Then(rp1 *pb.RepositoryTag, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetRepositoryTagResults{rp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetRepositoryTag should be invoked
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) Times(n uint64) *mRepositoryIMockGetRepositoryTag {
	if n == 0 {
		mmGetRepositoryTag.mock.t.Fatalf("Times of RepositoryIMock.GetRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRepositoryTag.expectedInvocations, n)
	return mmGetRepositoryTag
}

func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) invocationsDone() bool {
	if len(mmGetRepositoryTag.expectations) == 0 && mmGetRepositoryTag.defaultExpectation == nil && mmGetRepositoryTag.mock.funcGetRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRepositoryTag.mock.afterGetRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRepositoryTag implements repository.RepositoryI
func (mmGetRepositoryTag *RepositoryIMock) GetRepositoryTag(ctx context.Context, r1 utils.RepositoryTagName) (rp1 *pb.RepositoryTag, err error) {
	mm_atomic.AddUint64(&mmGetRepositoryTag.beforeGetRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRepositoryTag.afterGetRepositoryTagCounter, 1)

	if mmGetRepositoryTag.inspectFuncGetRepositoryTag != nil {
		mmGetRepositoryTag.inspectFuncGetRepositoryTag(ctx, r1)
	}

	mm_params := RepositoryIMockGetRepositoryTagParams{ctx, r1}

	// Record call args
	mmGetRepositoryTag.GetRepositoryTagMock.mutex.Lock()
	mmGetRepositoryTag.GetRepositoryTagMock.callArgs = append(mmGetRepositoryTag.GetRepositoryTagMock.callArgs, &mm_params)
	mmGetRepositoryTag.GetRepositoryTagMock.mutex.Unlock()

	for _, e := range mmGetRepositoryTag.GetRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetRepositoryTagParams{ctx, r1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetRepositoryTag.t.Errorf("RepositoryIMock.GetRepositoryTag got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.r1 != nil && !minimock.Equal(*mm_want_ptrs.r1, mm_got.r1) {
				mmGetRepositoryTag.t.Errorf("RepositoryIMock.GetRepositoryTag got unexpected parameter r1, want: %#v, got: %#v%s\n", *mm_want_ptrs.r1, mm_got.r1, minimock.Diff(*mm_want_ptrs.r1, mm_got.r1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRepositoryTag.t.Errorf("RepositoryIMock.GetRepositoryTag got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRepositoryTag.t.Fatal("No results are set for the RepositoryIMock.GetRepositoryTag")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmGetRepositoryTag.funcGetRepositoryTag != nil {
		return mmGetRepositoryTag.funcGetRepositoryTag(ctx, r1)
	}
	mmGetRepositoryTag.t.Fatalf("Unexpected call to RepositoryIMock.GetRepositoryTag. %v %v", ctx, r1)
	return
}

// GetRepositoryTagAfterCounter returns a count of finished RepositoryIMock.GetRepositoryTag invocations
func (mmGetRepositoryTag *RepositoryIMock) GetRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRepositoryTag.afterGetRepositoryTagCounter)
}

// GetRepositoryTagBeforeCounter returns a count of RepositoryIMock.GetRepositoryTag invocations
func (mmGetRepositoryTag *RepositoryIMock) GetRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRepositoryTag.beforeGetRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) Calls() []*RepositoryIMockGetRepositoryTagParams {
	mmGetRepositoryTag.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetRepositoryTagParams, len(mmGetRepositoryTag.callArgs))
	copy(argCopy, mmGetRepositoryTag.callArgs)

	mmGetRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockGetRepositoryTagDone returns true if the count of the GetRepositoryTag invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetRepositoryTagDone() bool {
	for _, e := range m.GetRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRepositoryTagMock.invocationsDone()
}

// MinimockGetRepositoryTagInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetRepositoryTagInspect() {
	for _, e := range m.GetRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetRepositoryTag with params: %#v", *e.params)
		}
	}

	afterGetRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterGetRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRepositoryTagMock.defaultExpectation != nil && afterGetRepositoryTagCounter < 1 {
		if m.GetRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetRepositoryTag")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetRepositoryTag with params: %#v", *m.GetRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRepositoryTag != nil && afterGetRepositoryTagCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetRepositoryTag")
	}

	if !m.GetRepositoryTagMock.invocationsDone() && afterGetRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetRepositoryTag but found %d calls",
			mm_atomic.LoadUint64(&m.GetRepositoryTagMock.expectedInvocations), afterGetRepositoryTagCounter)
	}
}

type mRepositoryIMockGetSourceTableAndUIDByFileUIDs struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetSourceTableAndUIDByFileUIDsExpectation
	expectations       []*RepositoryIMockGetSourceTableAndUIDByFileUIDsExpectation

	callArgs []*RepositoryIMockGetSourceTableAndUIDByFileUIDsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetSourceTableAndUIDByFileUIDsExpectation specifies expectation struct of the RepositoryI.GetSourceTableAndUIDByFileUIDs
type RepositoryIMockGetSourceTableAndUIDByFileUIDsExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetSourceTableAndUIDByFileUIDsParams
	paramPtrs *RepositoryIMockGetSourceTableAndUIDByFileUIDsParamPtrs
	results   *RepositoryIMockGetSourceTableAndUIDByFileUIDsResults
	Counter   uint64
}

// RepositoryIMockGetSourceTableAndUIDByFileUIDsParams contains parameters of the RepositoryI.GetSourceTableAndUIDByFileUIDs
type RepositoryIMockGetSourceTableAndUIDByFileUIDsParams struct {
	ctx   context.Context
	files []mm_repository.KnowledgeBaseFile
}

// RepositoryIMockGetSourceTableAndUIDByFileUIDsParamPtrs contains pointers to parameters of the RepositoryI.GetSourceTableAndUIDByFileUIDs
type RepositoryIMockGetSourceTableAndUIDByFileUIDsParamPtrs struct {
	ctx   *context.Context
	files *[]mm_repository.KnowledgeBaseFile
}

// RepositoryIMockGetSourceTableAndUIDByFileUIDsResults contains results of the RepositoryI.GetSourceTableAndUIDByFileUIDs
type RepositoryIMockGetSourceTableAndUIDByFileUIDsResults struct {
	m1 map[mm_repository.FileUID]struct {
		SourceTable string
		SourceUID   uuid.UUID
	}
	err error
}

// Expect sets up expected params for RepositoryI.GetSourceTableAndUIDByFileUIDs
func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryIMockGetSourceTableAndUIDByFileUIDs) Expect(ctx context.Context, files []mm_repository.KnowledgeBaseFile) *mRepositoryIMockGetSourceTableAndUIDByFileUIDs {
	if mmGetSourceTableAndUIDByFileUIDs.mock.funcGetSourceTableAndUIDByFileUIDs != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetSourceTableAndUIDByFileUIDs mock is already set by Set")
	}

	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation == nil {
		mmGetSourceTableAndUIDByFileUIDs.defaultExpectation = &RepositoryIMockGetSourceTableAndUIDByFileUIDsExpectation{}
	}

	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.paramPtrs != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetSourceTableAndUIDByFileUIDs mock is already set by ExpectParams functions")
	}

	mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.params = &RepositoryIMockGetSourceTableAndUIDByFileUIDsParams{ctx, files}
	for _, e := range mmGetSourceTableAndUIDByFileUIDs.expectations {
		if minimock.Equal(e.params, mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.params) {
			mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.params)
		}
	}

	return mmGetSourceTableAndUIDByFileUIDs
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetSourceTableAndUIDByFileUIDs
func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryIMockGetSourceTableAndUIDByFileUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetSourceTableAndUIDByFileUIDs {
	if mmGetSourceTableAndUIDByFileUIDs.mock.funcGetSourceTableAndUIDByFileUIDs != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetSourceTableAndUIDByFileUIDs mock is already set by Set")
	}

	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation == nil {
		mmGetSourceTableAndUIDByFileUIDs.defaultExpectation = &RepositoryIMockGetSourceTableAndUIDByFileUIDsExpectation{}
	}

	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.params != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetSourceTableAndUIDByFileUIDs mock is already set by Expect")
	}

	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.paramPtrs == nil {
		mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.paramPtrs = &RepositoryIMockGetSourceTableAndUIDByFileUIDsParamPtrs{}
	}
	mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetSourceTableAndUIDByFileUIDs
}

// ExpectFilesParam2 sets up expected param files for RepositoryI.GetSourceTableAndUIDByFileUIDs
func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryIMockGetSourceTableAndUIDByFileUIDs) ExpectFilesParam2(files []mm_repository.KnowledgeBaseFile) *mRepositoryIMockGetSourceTableAndUIDByFileUIDs {
	if mmGetSourceTableAndUIDByFileUIDs.mock.funcGetSourceTableAndUIDByFileUIDs != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetSourceTableAndUIDByFileUIDs mock is already set by Set")
	}

	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation == nil {
		mmGetSourceTableAndUIDByFileUIDs.defaultExpectation = &RepositoryIMockGetSourceTableAndUIDByFileUIDsExpectation{}
	}

	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.params != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetSourceTableAndUIDByFileUIDs mock is already set by Expect")
	}

	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.paramPtrs == nil {
		mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.paramPtrs = &RepositoryIMockGetSourceTableAndUIDByFileUIDsParamPtrs{}
	}
	mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.paramPtrs.files = &files

	return mmGetSourceTableAndUIDByFileUIDs
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetSourceTableAndUIDByFileUIDs
func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryIMockGetSourceTableAndUIDByFileUIDs) Inspect(f func(ctx context.Context, files []mm_repository.KnowledgeBaseFile)) *mRepositoryIMockGetSourceTableAndUIDByFileUIDs {
	if mmGetSourceTableAndUIDByFileUIDs.mock.inspectFuncGetSourceTableAndUIDByFileUIDs != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetSourceTableAndUIDByFileUIDs")
	}

	mmGetSourceTableAndUIDByFileUIDs.mock.inspectFuncGetSourceTableAndUIDByFileUIDs = f

	return mmGetSourceTableAndUIDByFileUIDs
}

// Return sets up results that will be returned by RepositoryI.GetSourceTableAndUIDByFileUIDs
func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryIMockGetSourceTableAndUIDByFileUIDs) Return(m1 map[mm_repository.FileUID]struct {
	SourceTable string
	SourceUID   uuid.UUID
}, err error) *RepositoryIMock {
	if mmGetSourceTableAndUIDByFileUIDs.mock.funcGetSourceTableAndUIDByFileUIDs != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetSourceTableAndUIDByFileUIDs mock is already set by Set")
	}

	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation == nil {
		mmGetSourceTableAndUIDByFileUIDs.defaultExpectation = &RepositoryIMockGetSourceTableAndUIDByFileUIDsExpectation{mock: mmGetSourceTableAndUIDByFileUIDs.mock}
	}
	mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.results = &RepositoryIMockGetSourceTableAndUIDByFileUIDsResults{m1, err}
	return mmGetSourceTableAndUIDByFileUIDs.mock
}

// Set uses given function f to mock the RepositoryI.GetSourceTableAndUIDByFileUIDs method
func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryIMockGetSourceTableAndUIDByFileUIDs) Set(f func(ctx context.Context, files []mm_repository.KnowledgeBaseFile) (m1 map[mm_repository.FileUID]struct {
	SourceTable string
	SourceUID   uuid.UUID
}, err error)) *RepositoryIMock {
	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetSourceTableAndUIDByFileUIDs method")
	}

	if len(mmGetSourceTableAndUIDByFileUIDs.expectations) > 0 {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetSourceTableAndUIDByFileUIDs method")
	}

	mmGetSourceTableAndUIDByFileUIDs.mock.funcGetSourceTableAndUIDByFileUIDs = f
	return mmGetSourceTableAndUIDByFileUIDs.mock
}

// When sets expectation for the RepositoryI.GetSourceTableAndUIDByFileUIDs which will trigger the result defined by the following
// Then helper
func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryIMockGetSourceTableAndUIDByFileUIDs) When(ctx context.Context, files []mm_repository.KnowledgeBaseFile) *RepositoryIMockGetSourceTableAndUIDByFileUIDsExpectation {
	if mmGetSourceTableAndUIDByFileUIDs.mock.funcGetSourceTableAndUIDByFileUIDs != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("RepositoryIMock.GetSourceTableAndUIDByFileUIDs mock is already set by Set")
	}

	expectation := &RepositoryIMockGetSourceTableAndUIDByFileUIDsExpectation{
		mock:   mmGetSourceTableAndUIDByFileUIDs.mock,
		params: &RepositoryIMockGetSourceTableAndUIDByFileUIDsParams{ctx, files},
	}
	mmGetSourceTableAndUIDByFileUIDs.expectations = append(mmGetSourceTableAndUIDByFileUIDs.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetSourceTableAndUIDByFileUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetSourceTableAndUIDByFileUIDsExpectation) Then(m1 map[mm_repository.FileUID]struct {
	SourceTable string
	SourceUID   uuid.UUID
}, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetSourceTableAndUIDByFileUIDsResults{m1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetSourceTableAndUIDByFileUIDs should be invoked
func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryIMockGetSourceTableAndUIDByFileUIDs) Times(n uint64) *mRepositoryIMockGetSourceTableAndUIDByFileUIDs {
	if n == 0 {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("Times of RepositoryIMock.GetSourceTableAndUIDByFileUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetSourceTableAndUIDByFileUIDs.expectedInvocations, n)
	return mmGetSourceTableAndUIDByFileUIDs
}

func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryIMockGetSourceTableAndUIDByFileUIDs) invocationsDone() bool {
	if len(mmGetSourceTableAndUIDByFileUIDs.expectations) == 0 && mmGetSourceTableAndUIDByFileUIDs.defaultExpectation == nil && mmGetSourceTableAndUIDByFileUIDs.mock.funcGetSourceTableAndUIDByFileUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetSourceTableAndUIDByFileUIDs.mock.afterGetSourceTableAndUIDByFileUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetSourceTableAndUIDByFileUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetSourceTableAndUIDByFileUIDs implements repository.RepositoryI
func (mmGetSourceTableAndUIDByFileUIDs *RepositoryIMock) GetSourceTableAndUIDByFileUIDs(ctx context.Context, files []mm_repository.KnowledgeBaseFile) (m1 map[mm_repository.FileUID]struct {
	SourceTable string
	SourceUID   uuid.UUID
}, err error) {
	mm_atomic.AddUint64(&mmGetSourceTableAndUIDByFileUIDs.beforeGetSourceTableAndUIDByFileUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSourceTableAndUIDByFileUIDs.afterGetSourceTableAndUIDByFileUIDsCounter, 1)

	if mmGetSourceTableAndUIDByFileUIDs.inspectFuncGetSourceTableAndUIDByFileUIDs != nil {
		mmGetSourceTableAndUIDByFileUIDs.inspectFuncGetSourceTableAndUIDByFileUIDs(ctx, files)
	}

	mm_params := RepositoryIMockGetSourceTableAndUIDByFileUIDsParams{ctx, files}

	// Record call args
	mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.mutex.Lock()
	mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.callArgs = append(mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.callArgs, &mm_params)
	mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.mutex.Unlock()

	for _, e := range mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetSourceTableAndUIDByFileUIDsParams{ctx, files}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetSourceTableAndUIDByFileUIDs.t.Errorf("RepositoryIMock.GetSourceTableAndUIDByFileUIDs got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.files != nil && !minimock.Equal(*mm_want_ptrs.files, mm_got.files) {
				mmGetSourceTableAndUIDByFileUIDs.t.Errorf("RepositoryIMock.GetSourceTableAndUIDByFileUIDs got unexpected parameter files, want: %#v, got: %#v%s\n", *mm_want_ptrs.files, mm_got.files, minimock.Diff(*mm_want_ptrs.files, mm_got.files))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSourceTableAndUIDByFileUIDs.t.Errorf("RepositoryIMock.GetSourceTableAndUIDByFileUIDs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSourceTableAndUIDByFileUIDs.t.Fatal("No results are set for the RepositoryIMock.GetSourceTableAndUIDByFileUIDs")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetSourceTableAndUIDByFileUIDs.funcGetSourceTableAndUIDByFileUIDs != nil {
		return mmGetSourceTableAndUIDByFileUIDs.funcGetSourceTableAndUIDByFileUIDs(ctx, files)
	}
	mmGetSourceTableAndUIDByFileUIDs.t.Fatalf("Unexpected call to RepositoryIMock.GetSourceTableAndUIDByFileUIDs. %v %v", ctx, files)
	return
}

// GetSourceTableAndUIDByFileUIDsAfterCounter returns a count of finished RepositoryIMock.GetSourceTableAndUIDByFileUIDs invocations
func (mmGetSourceTableAndUIDByFileUIDs *RepositoryIMock) GetSourceTableAndUIDByFileUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSourceTableAndUIDByFileUIDs.afterGetSourceTableAndUIDByFileUIDsCounter)
}

// GetSourceTableAndUIDByFileUIDsBeforeCounter returns a count of RepositoryIMock.GetSourceTableAndUIDByFileUIDs invocations
func (mmGetSourceTableAndUIDByFileUIDs *RepositoryIMock) GetSourceTableAndUIDByFileUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSourceTableAndUIDByFileUIDs.beforeGetSourceTableAndUIDByFileUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetSourceTableAndUIDByFileUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryIMockGetSourceTableAndUIDByFileUIDs) Calls() []*RepositoryIMockGetSourceTableAndUIDByFileUIDsParams {
	mmGetSourceTableAndUIDByFileUIDs.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetSourceTableAndUIDByFileUIDsParams, len(mmGetSourceTableAndUIDByFileUIDs.callArgs))
	copy(argCopy, mmGetSourceTableAndUIDByFileUIDs.callArgs)

	mmGetSourceTableAndUIDByFileUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockGetSourceTableAndUIDByFileUIDsDone returns true if the count of the GetSourceTableAndUIDByFileUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetSourceTableAndUIDByFileUIDsDone() bool {
	for _, e := range m.GetSourceTableAndUIDByFileUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetSourceTableAndUIDByFileUIDsMock.invocationsDone()
}

// MinimockGetSourceTableAndUIDByFileUIDsInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetSourceTableAndUIDByFileUIDsInspect() {
	for _, e := range m.GetSourceTableAndUIDByFileUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetSourceTableAndUIDByFileUIDs with params: %#v", *e.params)
		}
	}

	afterGetSourceTableAndUIDByFileUIDsCounter := mm_atomic.LoadUint64(&m.afterGetSourceTableAndUIDByFileUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetSourceTableAndUIDByFileUIDsMock.defaultExpectation != nil && afterGetSourceTableAndUIDByFileUIDsCounter < 1 {
		if m.GetSourceTableAndUIDByFileUIDsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetSourceTableAndUIDByFileUIDs")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetSourceTableAndUIDByFileUIDs with params: %#v", *m.GetSourceTableAndUIDByFileUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSourceTableAndUIDByFileUIDs != nil && afterGetSourceTableAndUIDByFileUIDsCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetSourceTableAndUIDByFileUIDs")
	}

	if !m.GetSourceTableAndUIDByFileUIDsMock.invocationsDone() && afterGetSourceTableAndUIDByFileUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetSourceTableAndUIDByFileUIDs but found %d calls",
			mm_atomic.LoadUint64(&m.GetSourceTableAndUIDByFileUIDsMock.expectedInvocations), afterGetSourceTableAndUIDByFileUIDsCounter)
	}
}

type mRepositoryIMockGetTextChunksBySource struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetTextChunksBySourceExpectation
	expectations       []*RepositoryIMockGetTextChunksBySourceExpectation

	callArgs []*RepositoryIMockGetTextChunksBySourceParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetTextChunksBySourceExpectation specifies expectation struct of the RepositoryI.GetTextChunksBySource
type RepositoryIMockGetTextChunksBySourceExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetTextChunksBySourceParams
	paramPtrs *RepositoryIMockGetTextChunksBySourceParamPtrs
	results   *RepositoryIMockGetTextChunksBySourceResults
	Counter   uint64
}

// RepositoryIMockGetTextChunksBySourceParams contains parameters of the RepositoryI.GetTextChunksBySource
type RepositoryIMockGetTextChunksBySourceParams struct {
	ctx         context.Context
	sourceTable string
	sourceUID   uuid.UUID
}

// RepositoryIMockGetTextChunksBySourceParamPtrs contains pointers to parameters of the RepositoryI.GetTextChunksBySource
type RepositoryIMockGetTextChunksBySourceParamPtrs struct {
	ctx         *context.Context
	sourceTable *string
	sourceUID   *uuid.UUID
}

// RepositoryIMockGetTextChunksBySourceResults contains results of the RepositoryI.GetTextChunksBySource
type RepositoryIMockGetTextChunksBySourceResults struct {
	ta1 []mm_repository.TextChunk
	err error
}

// Expect sets up expected params for RepositoryI.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) Expect(ctx context.Context, sourceTable string, sourceUID uuid.UUID) *mRepositoryIMockGetTextChunksBySource {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by Set")
	}

	if mmGetTextChunksBySource.defaultExpectation == nil {
		mmGetTextChunksBySource.defaultExpectation = &RepositoryIMockGetTextChunksBySourceExpectation{}
	}

	if mmGetTextChunksBySource.defaultExpectation.paramPtrs != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by ExpectParams functions")
	}

	mmGetTextChunksBySource.defaultExpectation.params = &RepositoryIMockGetTextChunksBySourceParams{ctx, sourceTable, sourceUID}
	for _, e := range mmGetTextChunksBySource.expectations {
		if minimock.Equal(e.params, mmGetTextChunksBySource.defaultExpectation.params) {
			mmGetTextChunksBySource.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTextChunksBySource.defaultExpectation.params)
		}
	}

	return mmGetTextChunksBySource
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetTextChunksBySource {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by Set")
	}

	if mmGetTextChunksBySource.defaultExpectation == nil {
		mmGetTextChunksBySource.defaultExpectation = &RepositoryIMockGetTextChunksBySourceExpectation{}
	}

	if mmGetTextChunksBySource.defaultExpectation.params != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by Expect")
	}

	if mmGetTextChunksBySource.defaultExpectation.paramPtrs == nil {
		mmGetTextChunksBySource.defaultExpectation.paramPtrs = &RepositoryIMockGetTextChunksBySourceParamPtrs{}
	}
	mmGetTextChunksBySource.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetTextChunksBySource
}

// ExpectSourceTableParam2 sets up expected param sourceTable for RepositoryI.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) ExpectSourceTableParam2(sourceTable string) *mRepositoryIMockGetTextChunksBySource {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by Set")
	}

	if mmGetTextChunksBySource.defaultExpectation == nil {
		mmGetTextChunksBySource.defaultExpectation = &RepositoryIMockGetTextChunksBySourceExpectation{}
	}

	if mmGetTextChunksBySource.defaultExpectation.params != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by Expect")
	}

	if mmGetTextChunksBySource.defaultExpectation.paramPtrs == nil {
		mmGetTextChunksBySource.defaultExpectation.paramPtrs = &RepositoryIMockGetTextChunksBySourceParamPtrs{}
	}
	mmGetTextChunksBySource.defaultExpectation.paramPtrs.sourceTable = &sourceTable

	return mmGetTextChunksBySource
}

// ExpectSourceUIDParam3 sets up expected param sourceUID for RepositoryI.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) ExpectSourceUIDParam3(sourceUID uuid.UUID) *mRepositoryIMockGetTextChunksBySource {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by Set")
	}

	if mmGetTextChunksBySource.defaultExpectation == nil {
		mmGetTextChunksBySource.defaultExpectation = &RepositoryIMockGetTextChunksBySourceExpectation{}
	}

	if mmGetTextChunksBySource.defaultExpectation.params != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by Expect")
	}

	if mmGetTextChunksBySource.defaultExpectation.paramPtrs == nil {
		mmGetTextChunksBySource.defaultExpectation.paramPtrs = &RepositoryIMockGetTextChunksBySourceParamPtrs{}
	}
	mmGetTextChunksBySource.defaultExpectation.paramPtrs.sourceUID = &sourceUID

	return mmGetTextChunksBySource
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) Inspect(f func(ctx context.Context, sourceTable string, sourceUID uuid.UUID)) *mRepositoryIMockGetTextChunksBySource {
	if mmGetTextChunksBySource.mock.inspectFuncGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetTextChunksBySource")
	}

	mmGetTextChunksBySource.mock.inspectFuncGetTextChunksBySource = f

	return mmGetTextChunksBySource
}

// Return sets up results that will be returned by RepositoryI.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) Return(ta1 []mm_repository.TextChunk, err error) *RepositoryIMock {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by Set")
	}

	if mmGetTextChunksBySource.defaultExpectation == nil {
		mmGetTextChunksBySource.defaultExpectation = &RepositoryIMockGetTextChunksBySourceExpectation{mock: mmGetTextChunksBySource.mock}
	}
	mmGetTextChunksBySource.defaultExpectation.results = &RepositoryIMockGetTextChunksBySourceResults{ta1, err}
	return mmGetTextChunksBySource.mock
}

// Set uses given function f to mock the RepositoryI.GetTextChunksBySource method
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) Set(f func(ctx context.Context, sourceTable string, sourceUID uuid.UUID) (ta1 []mm_repository.TextChunk, err error)) *RepositoryIMock {
	if mmGetTextChunksBySource.defaultExpectation != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetTextChunksBySource method")
	}

	if len(mmGetTextChunksBySource.expectations) > 0 {
		mmGetTextChunksBySource.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetTextChunksBySource method")
	}

	mmGetTextChunksBySource.mock.funcGetTextChunksBySource = f
	return mmGetTextChunksBySource.mock
}

// When sets expectation for the RepositoryI.GetTextChunksBySource which will trigger the result defined by the following
// Then helper
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) When(ctx context.Context, sourceTable string, sourceUID uuid.UUID) *RepositoryIMockGetTextChunksBySourceExpectation {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by Set")
	}

	expectation := &RepositoryIMockGetTextChunksBySourceExpectation{
		mock:   mmGetTextChunksBySource.mock,
		params: &RepositoryIMockGetTextChunksBySourceParams{ctx, sourceTable, sourceUID},
	}
	mmGetTextChunksBySource.expectations = append(mmGetTextChunksBySource.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetTextChunksBySource return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetTextChunksBySourceExpectation) Then(ta1 []mm_repository.TextChunk, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetTextChunksBySourceResults{ta1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetTextChunksBySource should be invoked
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) Times(n uint64) *mRepositoryIMockGetTextChunksBySource {
	if n == 0 {
		mmGetTextChunksBySource.mock.t.Fatalf("Times of RepositoryIMock.GetTextChunksBySource mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTextChunksBySource.expectedInvocations, n)
	return mmGetTextChunksBySource
}

func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) invocationsDone() bool {
	if len(mmGetTextChunksBySource.expectations) == 0 && mmGetTextChunksBySource.defaultExpectation == nil && mmGetTextChunksBySource.mock.funcGetTextChunksBySource == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTextChunksBySource.mock.afterGetTextChunksBySourceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTextChunksBySource.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTextChunksBySource implements repository.RepositoryI
func (mmGetTextChunksBySource *RepositoryIMock) GetTextChunksBySource(ctx context.Context, sourceTable string, sourceUID uuid.UUID) (ta1 []mm_repository.TextChunk, err error) {
	mm_atomic.AddUint64(&mmGetTextChunksBySource.beforeGetTextChunksBySourceCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTextChunksBySource.afterGetTextChunksBySourceCounter, 1)

	if mmGetTextChunksBySource.inspectFuncGetTextChunksBySource != nil {
		mmGetTextChunksBySource.inspectFuncGetTextChunksBySource(ctx, sourceTable, sourceUID)
	}

	mm_params := RepositoryIMockGetTextChunksBySourceParams{ctx, sourceTable, sourceUID}

	// Record call args
	mmGetTextChunksBySource.GetTextChunksBySourceMock.mutex.Lock()
	mmGetTextChunksBySource.GetTextChunksBySourceMock.callArgs = append(mmGetTextChunksBySource.GetTextChunksBySourceMock.callArgs, &mm_params)
	mmGetTextChunksBySource.GetTextChunksBySourceMock.mutex.Unlock()

	for _, e := range mmGetTextChunksBySource.GetTextChunksBySourceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ta1, e.results.err
		}
	}

	if mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation.params
		mm_want_ptrs := mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetTextChunksBySourceParams{ctx, sourceTable, sourceUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTextChunksBySource.t.Errorf("RepositoryIMock.GetTextChunksBySource got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sourceTable != nil && !minimock.Equal(*mm_want_ptrs.sourceTable, mm_got.sourceTable) {
				mmGetTextChunksBySource.t.Errorf("RepositoryIMock.GetTextChunksBySource got unexpected parameter sourceTable, want: %#v, got: %#v%s\n", *mm_want_ptrs.sourceTable, mm_got.sourceTable, minimock.Diff(*mm_want_ptrs.sourceTable, mm_got.sourceTable))
			}

			if mm_want_ptrs.sourceUID != nil && !minimock.Equal(*mm_want_ptrs.sourceUID, mm_got.sourceUID) {
				mmGetTextChunksBySource.t.Errorf("RepositoryIMock.GetTextChunksBySource got unexpected parameter sourceUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.sourceUID, mm_got.sourceUID, minimock.Diff(*mm_want_ptrs.sourceUID, mm_got.sourceUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTextChunksBySource.t.Errorf("RepositoryIMock.GetTextChunksBySource got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTextChunksBySource.t.Fatal("No results are set for the RepositoryIMock.GetTextChunksBySource")
		}
		return (*mm_results).ta1, (*mm_results).err
	}
	if mmGetTextChunksBySource.funcGetTextChunksBySource != nil {
		return mmGetTextChunksBySource.funcGetTextChunksBySource(ctx, sourceTable, sourceUID)
	}
	mmGetTextChunksBySource.t.Fatalf("Unexpected call to RepositoryIMock.GetTextChunksBySource. %v %v %v", ctx, sourceTable, sourceUID)
	return
}

// GetTextChunksBySourceAfterCounter returns a count of finished RepositoryIMock.GetTextChunksBySource invocations
func (mmGetTextChunksBySource *RepositoryIMock) GetTextChunksBySourceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTextChunksBySource.afterGetTextChunksBySourceCounter)
}

// GetTextChunksBySourceBeforeCounter returns a count of RepositoryIMock.GetTextChunksBySource invocations
func (mmGetTextChunksBySource *RepositoryIMock) GetTextChunksBySourceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTextChunksBySource.beforeGetTextChunksBySourceCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetTextChunksBySource.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) Calls() []*RepositoryIMockGetTextChunksBySourceParams {
	mmGetTextChunksBySource.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetTextChunksBySourceParams, len(mmGetTextChunksBySource.callArgs))
	copy(argCopy, mmGetTextChunksBySource.callArgs)

	mmGetTextChunksBySource.mutex.RUnlock()

	return argCopy
}

// MinimockGetTextChunksBySourceDone returns true if the count of the GetTextChunksBySource invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetTextChunksBySourceDone() bool {
	for _, e := range m.GetTextChunksBySourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTextChunksBySourceMock.invocationsDone()
}

// MinimockGetTextChunksBySourceInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetTextChunksBySourceInspect() {
	for _, e := range m.GetTextChunksBySourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetTextChunksBySource with params: %#v", *e.params)
		}
	}

	afterGetTextChunksBySourceCounter := mm_atomic.LoadUint64(&m.afterGetTextChunksBySourceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTextChunksBySourceMock.defaultExpectation != nil && afterGetTextChunksBySourceCounter < 1 {
		if m.GetTextChunksBySourceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetTextChunksBySource")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetTextChunksBySource with params: %#v", *m.GetTextChunksBySourceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTextChunksBySource != nil && afterGetTextChunksBySourceCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetTextChunksBySource")
	}

	if !m.GetTextChunksBySourceMock.invocationsDone() && afterGetTextChunksBySourceCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetTextChunksBySource but found %d calls",
			mm_atomic.LoadUint64(&m.GetTextChunksBySourceMock.expectedInvocations), afterGetTextChunksBySourceCounter)
	}
}

type mRepositoryIMockGetTotalChunksBySources struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetTotalChunksBySourcesExpectation
	expectations       []*RepositoryIMockGetTotalChunksBySourcesExpectation

	callArgs []*RepositoryIMockGetTotalChunksBySourcesParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetTotalChunksBySourcesExpectation specifies expectation struct of the RepositoryI.GetTotalChunksBySources
type RepositoryIMockGetTotalChunksBySourcesExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetTotalChunksBySourcesParams
	paramPtrs *RepositoryIMockGetTotalChunksBySourcesParamPtrs
	results   *RepositoryIMockGetTotalChunksBySourcesResults
	Counter   uint64
}

// RepositoryIMockGetTotalChunksBySourcesParams contains parameters of the RepositoryI.GetTotalChunksBySources
type RepositoryIMockGetTotalChunksBySourcesParams struct {
	ctx     context.Context
	sources map[mm_repository.FileUID]struct {
		SourceTable mm_repository.SourceTable
		SourceUID   mm_repository.SourceUID
	}
}

// RepositoryIMockGetTotalChunksBySourcesParamPtrs contains pointers to parameters of the RepositoryI.GetTotalChunksBySources
type RepositoryIMockGetTotalChunksBySourcesParamPtrs struct {
	ctx     *context.Context
	sources *map[mm_repository.FileUID]struct {
		SourceTable mm_repository.SourceTable
		SourceUID   mm_repository.SourceUID
	}
}

// RepositoryIMockGetTotalChunksBySourcesResults contains results of the RepositoryI.GetTotalChunksBySources
type RepositoryIMockGetTotalChunksBySourcesResults struct {
	m1  map[mm_repository.FileUID]int
	err error
}

// Expect sets up expected params for RepositoryI.GetTotalChunksBySources
func (mmGetTotalChunksBySources *mRepositoryIMockGetTotalChunksBySources) Expect(ctx context.Context, sources map[mm_repository.FileUID]struct {
	SourceTable mm_repository.SourceTable
	SourceUID   mm_repository.SourceUID
}) *mRepositoryIMockGetTotalChunksBySources {
	if mmGetTotalChunksBySources.mock.funcGetTotalChunksBySources != nil {
		mmGetTotalChunksBySources.mock.t.Fatalf("RepositoryIMock.GetTotalChunksBySources mock is already set by Set")
	}

	if mmGetTotalChunksBySources.defaultExpectation == nil {
		mmGetTotalChunksBySources.defaultExpectation = &RepositoryIMockGetTotalChunksBySourcesExpectation{}
	}

	if mmGetTotalChunksBySources.defaultExpectation.paramPtrs != nil {
		mmGetTotalChunksBySources.mock.t.Fatalf("RepositoryIMock.GetTotalChunksBySources mock is already set by ExpectParams functions")
	}

	mmGetTotalChunksBySources.defaultExpectation.params = &RepositoryIMockGetTotalChunksBySourcesParams{ctx, sources}
	for _, e := range mmGetTotalChunksBySources.expectations {
		if minimock.Equal(e.params, mmGetTotalChunksBySources.defaultExpectation.params) {
			mmGetTotalChunksBySources.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTotalChunksBySources.defaultExpectation.params)
		}
	}

	return mmGetTotalChunksBySources
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetTotalChunksBySources
func (mmGetTotalChunksBySources *mRepositoryIMockGetTotalChunksBySources) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetTotalChunksBySources {
	if mmGetTotalChunksBySources.mock.funcGetTotalChunksBySources != nil {
		mmGetTotalChunksBySources.mock.t.Fatalf("RepositoryIMock.GetTotalChunksBySources mock is already set by Set")
	}

	if mmGetTotalChunksBySources.defaultExpectation == nil {
		mmGetTotalChunksBySources.defaultExpectation = &RepositoryIMockGetTotalChunksBySourcesExpectation{}
	}

	if mmGetTotalChunksBySources.defaultExpectation.params != nil {
		mmGetTotalChunksBySources.mock.t.Fatalf("RepositoryIMock.GetTotalChunksBySources mock is already set by Expect")
	}

	if mmGetTotalChunksBySources.defaultExpectation.paramPtrs == nil {
		mmGetTotalChunksBySources.defaultExpectation.paramPtrs = &RepositoryIMockGetTotalChunksBySourcesParamPtrs{}
	}
	mmGetTotalChunksBySources.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetTotalChunksBySources
}

// ExpectSourcesParam2 sets up expected param sources for RepositoryI.GetTotalChunksBySources
func (mmGetTotalChunksBySources *mRepositoryIMockGetTotalChunksBySources) ExpectSourcesParam2(sources map[mm_repository.FileUID]struct {
	SourceTable mm_repository.SourceTable
	SourceUID   mm_repository.SourceUID
}) *mRepositoryIMockGetTotalChunksBySources {
	if mmGetTotalChunksBySources.mock.funcGetTotalChunksBySources != nil {
		mmGetTotalChunksBySources.mock.t.Fatalf("RepositoryIMock.GetTotalChunksBySources mock is already set by Set")
	}

	if mmGetTotalChunksBySources.defaultExpectation == nil {
		mmGetTotalChunksBySources.defaultExpectation = &RepositoryIMockGetTotalChunksBySourcesExpectation{}
	}

	if mmGetTotalChunksBySources.defaultExpectation.params != nil {
		mmGetTotalChunksBySources.mock.t.Fatalf("RepositoryIMock.GetTotalChunksBySources mock is already set by Expect")
	}

	if mmGetTotalChunksBySources.defaultExpectation.paramPtrs == nil {
		mmGetTotalChunksBySources.defaultExpectation.paramPtrs = &RepositoryIMockGetTotalChunksBySourcesParamPtrs{}
	}
	mmGetTotalChunksBySources.defaultExpectation.paramPtrs.sources = &sources

	return mmGetTotalChunksBySources
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetTotalChunksBySources
func (mmGetTotalChunksBySources *mRepositoryIMockGetTotalChunksBySources) Inspect(f func(ctx context.Context, sources map[mm_repository.FileUID]struct {
	SourceTable mm_repository.SourceTable
	SourceUID   mm_repository.SourceUID
})) *mRepositoryIMockGetTotalChunksBySources {
	if mmGetTotalChunksBySources.mock.inspectFuncGetTotalChunksBySources != nil {
		mmGetTotalChunksBySources.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetTotalChunksBySources")
	}

	mmGetTotalChunksBySources.mock.inspectFuncGetTotalChunksBySources = f

	return mmGetTotalChunksBySources
}

// Return sets up results that will be returned by RepositoryI.GetTotalChunksBySources
func (mmGetTotalChunksBySources *mRepositoryIMockGetTotalChunksBySources) Return(m1 map[mm_repository.FileUID]int, err error) *RepositoryIMock {
	if mmGetTotalChunksBySources.mock.funcGetTotalChunksBySources != nil {
		mmGetTotalChunksBySources.mock.t.Fatalf("RepositoryIMock.GetTotalChunksBySources mock is already set by Set")
	}

	if mmGetTotalChunksBySources.defaultExpectation == nil {
		mmGetTotalChunksBySources.defaultExpectation = &RepositoryIMockGetTotalChunksBySourcesExpectation{mock: mmGetTotalChunksBySources.mock}
	}
	mmGetTotalChunksBySources.defaultExpectation.results = &RepositoryIMockGetTotalChunksBySourcesResults{m1, err}
	return mmGetTotalChunksBySources.mock
}

// Set uses given function f to mock the RepositoryI.GetTotalChunksBySources method
func (mmGetTotalChunksBySources *mRepositoryIMockGetTotalChunksBySources) Set(f func(ctx context.Context, sources map[mm_repository.FileUID]struct {
	SourceTable mm_repository.SourceTable
	SourceUID   mm_repository.SourceUID
}) (m1 map[mm_repository.FileUID]int, err error)) *RepositoryIMock {
	if mmGetTotalChunksBySources.defaultExpectation != nil {
		mmGetTotalChunksBySources.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetTotalChunksBySources method")
	}

	if len(mmGetTotalChunksBySources.expectations) > 0 {
		mmGetTotalChunksBySources.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetTotalChunksBySources method")
	}

	mmGetTotalChunksBySources.mock.funcGetTotalChunksBySources = f
	return mmGetTotalChunksBySources.mock
}

// When sets expectation for the RepositoryI.GetTotalChunksBySources which will trigger the result defined by the following
// Then helper
func (mmGetTotalChunksBySources *mRepositoryIMockGetTotalChunksBySources) When(ctx context.Context, sources map[mm_repository.FileUID]struct {
	SourceTable mm_repository.SourceTable
	SourceUID   mm_repository.SourceUID
}) *RepositoryIMockGetTotalChunksBySourcesExpectation {
	if mmGetTotalChunksBySources.mock.funcGetTotalChunksBySources != nil {
		mmGetTotalChunksBySources.mock.t.Fatalf("RepositoryIMock.GetTotalChunksBySources mock is already set by Set")
	}

	expectation := &RepositoryIMockGetTotalChunksBySourcesExpectation{
		mock:   mmGetTotalChunksBySources.mock,
		params: &RepositoryIMockGetTotalChunksBySourcesParams{ctx, sources},
	}
	mmGetTotalChunksBySources.expectations = append(mmGetTotalChunksBySources.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetTotalChunksBySources return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetTotalChunksBySourcesExpectation) Then(m1 map[mm_repository.FileUID]int, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetTotalChunksBySourcesResults{m1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetTotalChunksBySources should be invoked
func (mmGetTotalChunksBySources *mRepositoryIMockGetTotalChunksBySources) Times(n uint64) *mRepositoryIMockGetTotalChunksBySources {
	if n == 0 {
		mmGetTotalChunksBySources.mock.t.Fatalf("Times of RepositoryIMock.GetTotalChunksBySources mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTotalChunksBySources.expectedInvocations, n)
	return mmGetTotalChunksBySources
}

func (mmGetTotalChunksBySources *mRepositoryIMockGetTotalChunksBySources) invocationsDone() bool {
	if len(mmGetTotalChunksBySources.expectations) == 0 && mmGetTotalChunksBySources.defaultExpectation == nil && mmGetTotalChunksBySources.mock.funcGetTotalChunksBySources == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTotalChunksBySources.mock.afterGetTotalChunksBySourcesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTotalChunksBySources.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTotalChunksBySources implements repository.RepositoryI
func (mmGetTotalChunksBySources *RepositoryIMock) GetTotalChunksBySources(ctx context.Context, sources map[mm_repository.FileUID]struct {
	SourceTable mm_repository.SourceTable
	SourceUID   mm_repository.SourceUID
}) (m1 map[mm_repository.FileUID]int, err error) {
	mm_atomic.AddUint64(&mmGetTotalChunksBySources.beforeGetTotalChunksBySourcesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTotalChunksBySources.afterGetTotalChunksBySourcesCounter, 1)

	if mmGetTotalChunksBySources.inspectFuncGetTotalChunksBySources != nil {
		mmGetTotalChunksBySources.inspectFuncGetTotalChunksBySources(ctx, sources)
	}

	mm_params := RepositoryIMockGetTotalChunksBySourcesParams{ctx, sources}

	// Record call args
	mmGetTotalChunksBySources.GetTotalChunksBySourcesMock.mutex.Lock()
	mmGetTotalChunksBySources.GetTotalChunksBySourcesMock.callArgs = append(mmGetTotalChunksBySources.GetTotalChunksBySourcesMock.callArgs, &mm_params)
	mmGetTotalChunksBySources.GetTotalChunksBySourcesMock.mutex.Unlock()

	for _, e := range mmGetTotalChunksBySources.GetTotalChunksBySourcesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetTotalChunksBySources.GetTotalChunksBySourcesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTotalChunksBySources.GetTotalChunksBySourcesMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTotalChunksBySources.GetTotalChunksBySourcesMock.defaultExpectation.params
		mm_want_ptrs := mmGetTotalChunksBySources.GetTotalChunksBySourcesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetTotalChunksBySourcesParams{ctx, sources}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTotalChunksBySources.t.Errorf("RepositoryIMock.GetTotalChunksBySources got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sources != nil && !minimock.Equal(*mm_want_ptrs.sources, mm_got.sources) {
				mmGetTotalChunksBySources.t.Errorf("RepositoryIMock.GetTotalChunksBySources got unexpected parameter sources, want: %#v, got: %#v%s\n", *mm_want_ptrs.sources, mm_got.sources, minimock.Diff(*mm_want_ptrs.sources, mm_got.sources))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTotalChunksBySources.t.Errorf("RepositoryIMock.GetTotalChunksBySources got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTotalChunksBySources.GetTotalChunksBySourcesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTotalChunksBySources.t.Fatal("No results are set for the RepositoryIMock.GetTotalChunksBySources")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetTotalChunksBySources.funcGetTotalChunksBySources != nil {
		return mmGetTotalChunksBySources.funcGetTotalChunksBySources(ctx, sources)
	}
	mmGetTotalChunksBySources.t.Fatalf("Unexpected call to RepositoryIMock.GetTotalChunksBySources. %v %v", ctx, sources)
	return
}

// GetTotalChunksBySourcesAfterCounter returns a count of finished RepositoryIMock.GetTotalChunksBySources invocations
func (mmGetTotalChunksBySources *RepositoryIMock) GetTotalChunksBySourcesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotalChunksBySources.afterGetTotalChunksBySourcesCounter)
}

// GetTotalChunksBySourcesBeforeCounter returns a count of RepositoryIMock.GetTotalChunksBySources invocations
func (mmGetTotalChunksBySources *RepositoryIMock) GetTotalChunksBySourcesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotalChunksBySources.beforeGetTotalChunksBySourcesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetTotalChunksBySources.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTotalChunksBySources *mRepositoryIMockGetTotalChunksBySources) Calls() []*RepositoryIMockGetTotalChunksBySourcesParams {
	mmGetTotalChunksBySources.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetTotalChunksBySourcesParams, len(mmGetTotalChunksBySources.callArgs))
	copy(argCopy, mmGetTotalChunksBySources.callArgs)

	mmGetTotalChunksBySources.mutex.RUnlock()

	return argCopy
}

// MinimockGetTotalChunksBySourcesDone returns true if the count of the GetTotalChunksBySources invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetTotalChunksBySourcesDone() bool {
	for _, e := range m.GetTotalChunksBySourcesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTotalChunksBySourcesMock.invocationsDone()
}

// MinimockGetTotalChunksBySourcesInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetTotalChunksBySourcesInspect() {
	for _, e := range m.GetTotalChunksBySourcesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetTotalChunksBySources with params: %#v", *e.params)
		}
	}

	afterGetTotalChunksBySourcesCounter := mm_atomic.LoadUint64(&m.afterGetTotalChunksBySourcesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTotalChunksBySourcesMock.defaultExpectation != nil && afterGetTotalChunksBySourcesCounter < 1 {
		if m.GetTotalChunksBySourcesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetTotalChunksBySources")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetTotalChunksBySources with params: %#v", *m.GetTotalChunksBySourcesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTotalChunksBySources != nil && afterGetTotalChunksBySourcesCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetTotalChunksBySources")
	}

	if !m.GetTotalChunksBySourcesMock.invocationsDone() && afterGetTotalChunksBySourcesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetTotalChunksBySources but found %d calls",
			mm_atomic.LoadUint64(&m.GetTotalChunksBySourcesMock.expectedInvocations), afterGetTotalChunksBySourcesCounter)
	}
}

type mRepositoryIMockGetTotalTokensByListKBUIDs struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetTotalTokensByListKBUIDsExpectation
	expectations       []*RepositoryIMockGetTotalTokensByListKBUIDsExpectation

	callArgs []*RepositoryIMockGetTotalTokensByListKBUIDsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetTotalTokensByListKBUIDsExpectation specifies expectation struct of the RepositoryI.GetTotalTokensByListKBUIDs
type RepositoryIMockGetTotalTokensByListKBUIDsExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetTotalTokensByListKBUIDsParams
	paramPtrs *RepositoryIMockGetTotalTokensByListKBUIDsParamPtrs
	results   *RepositoryIMockGetTotalTokensByListKBUIDsResults
	Counter   uint64
}

// RepositoryIMockGetTotalTokensByListKBUIDsParams contains parameters of the RepositoryI.GetTotalTokensByListKBUIDs
type RepositoryIMockGetTotalTokensByListKBUIDsParams struct {
	ctx    context.Context
	kbUIDs []uuid.UUID
}

// RepositoryIMockGetTotalTokensByListKBUIDsParamPtrs contains pointers to parameters of the RepositoryI.GetTotalTokensByListKBUIDs
type RepositoryIMockGetTotalTokensByListKBUIDsParamPtrs struct {
	ctx    *context.Context
	kbUIDs *[]uuid.UUID
}

// RepositoryIMockGetTotalTokensByListKBUIDsResults contains results of the RepositoryI.GetTotalTokensByListKBUIDs
type RepositoryIMockGetTotalTokensByListKBUIDsResults struct {
	m1  map[uuid.UUID]int
	err error
}

// Expect sets up expected params for RepositoryI.GetTotalTokensByListKBUIDs
func (mmGetTotalTokensByListKBUIDs *mRepositoryIMockGetTotalTokensByListKBUIDs) Expect(ctx context.Context, kbUIDs []uuid.UUID) *mRepositoryIMockGetTotalTokensByListKBUIDs {
	if mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDs != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryIMock.GetTotalTokensByListKBUIDs mock is already set by Set")
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation == nil {
		mmGetTotalTokensByListKBUIDs.defaultExpectation = &RepositoryIMockGetTotalTokensByListKBUIDsExpectation{}
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation.paramPtrs != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryIMock.GetTotalTokensByListKBUIDs mock is already set by ExpectParams functions")
	}

	mmGetTotalTokensByListKBUIDs.defaultExpectation.params = &RepositoryIMockGetTotalTokensByListKBUIDsParams{ctx, kbUIDs}
	for _, e := range mmGetTotalTokensByListKBUIDs.expectations {
		if minimock.Equal(e.params, mmGetTotalTokensByListKBUIDs.defaultExpectation.params) {
			mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTotalTokensByListKBUIDs.defaultExpectation.params)
		}
	}

	return mmGetTotalTokensByListKBUIDs
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetTotalTokensByListKBUIDs
func (mmGetTotalTokensByListKBUIDs *mRepositoryIMockGetTotalTokensByListKBUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetTotalTokensByListKBUIDs {
	if mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDs != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryIMock.GetTotalTokensByListKBUIDs mock is already set by Set")
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation == nil {
		mmGetTotalTokensByListKBUIDs.defaultExpectation = &RepositoryIMockGetTotalTokensByListKBUIDsExpectation{}
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation.params != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryIMock.GetTotalTokensByListKBUIDs mock is already set by Expect")
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation.paramPtrs == nil {
		mmGetTotalTokensByListKBUIDs.defaultExpectation.paramPtrs = &RepositoryIMockGetTotalTokensByListKBUIDsParamPtrs{}
	}
	mmGetTotalTokensByListKBUIDs.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetTotalTokensByListKBUIDs
}

// ExpectKbUIDsParam2 sets up expected param kbUIDs for RepositoryI.GetTotalTokensByListKBUIDs
func (mmGetTotalTokensByListKBUIDs *mRepositoryIMockGetTotalTokensByListKBUIDs) ExpectKbUIDsParam2(kbUIDs []uuid.UUID) *mRepositoryIMockGetTotalTokensByListKBUIDs {
	if mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDs != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryIMock.GetTotalTokensByListKBUIDs mock is already set by Set")
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation == nil {
		mmGetTotalTokensByListKBUIDs.defaultExpectation = &RepositoryIMockGetTotalTokensByListKBUIDsExpectation{}
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation.params != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryIMock.GetTotalTokensByListKBUIDs mock is already set by Expect")
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation.paramPtrs == nil {
		mmGetTotalTokensByListKBUIDs.defaultExpectation.paramPtrs = &RepositoryIMockGetTotalTokensByListKBUIDsParamPtrs{}
	}
	mmGetTotalTokensByListKBUIDs.defaultExpectation.paramPtrs.kbUIDs = &kbUIDs

	return mmGetTotalTokensByListKBUIDs
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetTotalTokensByListKBUIDs
func (mmGetTotalTokensByListKBUIDs *mRepositoryIMockGetTotalTokensByListKBUIDs) Inspect(f func(ctx context.Context, kbUIDs []uuid.UUID)) *mRepositoryIMockGetTotalTokensByListKBUIDs {
	if mmGetTotalTokensByListKBUIDs.mock.inspectFuncGetTotalTokensByListKBUIDs != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetTotalTokensByListKBUIDs")
	}

	mmGetTotalTokensByListKBUIDs.mock.inspectFuncGetTotalTokensByListKBUIDs = f

	return mmGetTotalTokensByListKBUIDs
}

// Return sets up results that will be returned by RepositoryI.GetTotalTokensByListKBUIDs
func (mmGetTotalTokensByListKBUIDs *mRepositoryIMockGetTotalTokensByListKBUIDs) Return(m1 map[uuid.UUID]int, err error) *RepositoryIMock {
	if mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDs != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryIMock.GetTotalTokensByListKBUIDs mock is already set by Set")
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation == nil {
		mmGetTotalTokensByListKBUIDs.defaultExpectation = &RepositoryIMockGetTotalTokensByListKBUIDsExpectation{mock: mmGetTotalTokensByListKBUIDs.mock}
	}
	mmGetTotalTokensByListKBUIDs.defaultExpectation.results = &RepositoryIMockGetTotalTokensByListKBUIDsResults{m1, err}
	return mmGetTotalTokensByListKBUIDs.mock
}

// Set uses given function f to mock the RepositoryI.GetTotalTokensByListKBUIDs method
func (mmGetTotalTokensByListKBUIDs *mRepositoryIMockGetTotalTokensByListKBUIDs) Set(f func(ctx context.Context, kbUIDs []uuid.UUID) (m1 map[uuid.UUID]int, err error)) *RepositoryIMock {
	if mmGetTotalTokensByListKBUIDs.defaultExpectation != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetTotalTokensByListKBUIDs method")
	}

	if len(mmGetTotalTokensByListKBUIDs.expectations) > 0 {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetTotalTokensByListKBUIDs method")
	}

	mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDs = f
	return mmGetTotalTokensByListKBUIDs.mock
}

// When sets expectation for the RepositoryI.GetTotalTokensByListKBUIDs which will trigger the result defined by the following
// Then helper
func (mmGetTotalTokensByListKBUIDs *mRepositoryIMockGetTotalTokensByListKBUIDs) When(ctx context.Context, kbUIDs []uuid.UUID) *RepositoryIMockGetTotalTokensByListKBUIDsExpectation {
	if mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDs != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryIMock.GetTotalTokensByListKBUIDs mock is already set by Set")
	}

	expectation := &RepositoryIMockGetTotalTokensByListKBUIDsExpectation{
		mock:   mmGetTotalTokensByListKBUIDs.mock,
		params: &RepositoryIMockGetTotalTokensByListKBUIDsParams{ctx, kbUIDs},
	}
	mmGetTotalTokensByListKBUIDs.expectations = append(mmGetTotalTokensByListKBUIDs.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetTotalTokensByListKBUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetTotalTokensByListKBUIDsExpectation) Then(m1 map[uuid.UUID]int, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetTotalTokensByListKBUIDsResults{m1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetTotalTokensByListKBUIDs should be invoked
func (mmGetTotalTokensByListKBUIDs *mRepositoryIMockGetTotalTokensByListKBUIDs) Times(n uint64) *mRepositoryIMockGetTotalTokensByListKBUIDs {
	if n == 0 {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("Times of RepositoryIMock.GetTotalTokensByListKBUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTotalTokensByListKBUIDs.expectedInvocations, n)
	return mmGetTotalTokensByListKBUIDs
}

func (mmGetTotalTokensByListKBUIDs *mRepositoryIMockGetTotalTokensByListKBUIDs) invocationsDone() bool {
	if len(mmGetTotalTokensByListKBUIDs.expectations) == 0 && mmGetTotalTokensByListKBUIDs.defaultExpectation == nil && mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTotalTokensByListKBUIDs.mock.afterGetTotalTokensByListKBUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTotalTokensByListKBUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTotalTokensByListKBUIDs implements repository.RepositoryI
func (mmGetTotalTokensByListKBUIDs *RepositoryIMock) GetTotalTokensByListKBUIDs(ctx context.Context, kbUIDs []uuid.UUID) (m1 map[uuid.UUID]int, err error) {
	mm_atomic.AddUint64(&mmGetTotalTokensByListKBUIDs.beforeGetTotalTokensByListKBUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTotalTokensByListKBUIDs.afterGetTotalTokensByListKBUIDsCounter, 1)

	if mmGetTotalTokensByListKBUIDs.inspectFuncGetTotalTokensByListKBUIDs != nil {
		mmGetTotalTokensByListKBUIDs.inspectFuncGetTotalTokensByListKBUIDs(ctx, kbUIDs)
	}

	mm_params := RepositoryIMockGetTotalTokensByListKBUIDsParams{ctx, kbUIDs}

	// Record call args
	mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.mutex.Lock()
	mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.callArgs = append(mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.callArgs, &mm_params)
	mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.mutex.Unlock()

	for _, e := range mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetTotalTokensByListKBUIDsParams{ctx, kbUIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTotalTokensByListKBUIDs.t.Errorf("RepositoryIMock.GetTotalTokensByListKBUIDs got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUIDs != nil && !minimock.Equal(*mm_want_ptrs.kbUIDs, mm_got.kbUIDs) {
				mmGetTotalTokensByListKBUIDs.t.Errorf("RepositoryIMock.GetTotalTokensByListKBUIDs got unexpected parameter kbUIDs, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbUIDs, mm_got.kbUIDs, minimock.Diff(*mm_want_ptrs.kbUIDs, mm_got.kbUIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTotalTokensByListKBUIDs.t.Errorf("RepositoryIMock.GetTotalTokensByListKBUIDs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTotalTokensByListKBUIDs.t.Fatal("No results are set for the RepositoryIMock.GetTotalTokensByListKBUIDs")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetTotalTokensByListKBUIDs.funcGetTotalTokensByListKBUIDs != nil {
		return mmGetTotalTokensByListKBUIDs.funcGetTotalTokensByListKBUIDs(ctx, kbUIDs)
	}
	mmGetTotalTokensByListKBUIDs.t.Fatalf("Unexpected call to RepositoryIMock.GetTotalTokensByListKBUIDs. %v %v", ctx, kbUIDs)
	return
}

// GetTotalTokensByListKBUIDsAfterCounter returns a count of finished RepositoryIMock.GetTotalTokensByListKBUIDs invocations
func (mmGetTotalTokensByListKBUIDs *RepositoryIMock) GetTotalTokensByListKBUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotalTokensByListKBUIDs.afterGetTotalTokensByListKBUIDsCounter)
}

// GetTotalTokensByListKBUIDsBeforeCounter returns a count of RepositoryIMock.GetTotalTokensByListKBUIDs invocations
func (mmGetTotalTokensByListKBUIDs *RepositoryIMock) GetTotalTokensByListKBUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotalTokensByListKBUIDs.beforeGetTotalTokensByListKBUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetTotalTokensByListKBUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTotalTokensByListKBUIDs *mRepositoryIMockGetTotalTokensByListKBUIDs) Calls() []*RepositoryIMockGetTotalTokensByListKBUIDsParams {
	mmGetTotalTokensByListKBUIDs.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetTotalTokensByListKBUIDsParams, len(mmGetTotalTokensByListKBUIDs.callArgs))
	copy(argCopy, mmGetTotalTokensByListKBUIDs.callArgs)

	mmGetTotalTokensByListKBUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockGetTotalTokensByListKBUIDsDone returns true if the count of the GetTotalTokensByListKBUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetTotalTokensByListKBUIDsDone() bool {
	for _, e := range m.GetTotalTokensByListKBUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTotalTokensByListKBUIDsMock.invocationsDone()
}

// MinimockGetTotalTokensByListKBUIDsInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetTotalTokensByListKBUIDsInspect() {
	for _, e := range m.GetTotalTokensByListKBUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetTotalTokensByListKBUIDs with params: %#v", *e.params)
		}
	}

	afterGetTotalTokensByListKBUIDsCounter := mm_atomic.LoadUint64(&m.afterGetTotalTokensByListKBUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTotalTokensByListKBUIDsMock.defaultExpectation != nil && afterGetTotalTokensByListKBUIDsCounter < 1 {
		if m.GetTotalTokensByListKBUIDsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetTotalTokensByListKBUIDs")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetTotalTokensByListKBUIDs with params: %#v", *m.GetTotalTokensByListKBUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTotalTokensByListKBUIDs != nil && afterGetTotalTokensByListKBUIDsCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetTotalTokensByListKBUIDs")
	}

	if !m.GetTotalTokensByListKBUIDsMock.invocationsDone() && afterGetTotalTokensByListKBUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetTotalTokensByListKBUIDs but found %d calls",
			mm_atomic.LoadUint64(&m.GetTotalTokensByListKBUIDsMock.expectedInvocations), afterGetTotalTokensByListKBUIDsCounter)
	}
}

type mRepositoryIMockGetTruthSourceByFileUID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetTruthSourceByFileUIDExpectation
	expectations       []*RepositoryIMockGetTruthSourceByFileUIDExpectation

	callArgs []*RepositoryIMockGetTruthSourceByFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetTruthSourceByFileUIDExpectation specifies expectation struct of the RepositoryI.GetTruthSourceByFileUID
type RepositoryIMockGetTruthSourceByFileUIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetTruthSourceByFileUIDParams
	paramPtrs *RepositoryIMockGetTruthSourceByFileUIDParamPtrs
	results   *RepositoryIMockGetTruthSourceByFileUIDResults
	Counter   uint64
}

// RepositoryIMockGetTruthSourceByFileUIDParams contains parameters of the RepositoryI.GetTruthSourceByFileUID
type RepositoryIMockGetTruthSourceByFileUIDParams struct {
	ctx     context.Context
	fileUID uuid.UUID
}

// RepositoryIMockGetTruthSourceByFileUIDParamPtrs contains pointers to parameters of the RepositoryI.GetTruthSourceByFileUID
type RepositoryIMockGetTruthSourceByFileUIDParamPtrs struct {
	ctx     *context.Context
	fileUID *uuid.UUID
}

// RepositoryIMockGetTruthSourceByFileUIDResults contains results of the RepositoryI.GetTruthSourceByFileUID
type RepositoryIMockGetTruthSourceByFileUIDResults struct {
	sp1 *mm_repository.SourceMeta
	err error
}

// Expect sets up expected params for RepositoryI.GetTruthSourceByFileUID
func (mmGetTruthSourceByFileUID *mRepositoryIMockGetTruthSourceByFileUID) Expect(ctx context.Context, fileUID uuid.UUID) *mRepositoryIMockGetTruthSourceByFileUID {
	if mmGetTruthSourceByFileUID.mock.funcGetTruthSourceByFileUID != nil {
		mmGetTruthSourceByFileUID.mock.t.Fatalf("RepositoryIMock.GetTruthSourceByFileUID mock is already set by Set")
	}

	if mmGetTruthSourceByFileUID.defaultExpectation == nil {
		mmGetTruthSourceByFileUID.defaultExpectation = &RepositoryIMockGetTruthSourceByFileUIDExpectation{}
	}

	if mmGetTruthSourceByFileUID.defaultExpectation.paramPtrs != nil {
		mmGetTruthSourceByFileUID.mock.t.Fatalf("RepositoryIMock.GetTruthSourceByFileUID mock is already set by ExpectParams functions")
	}

	mmGetTruthSourceByFileUID.defaultExpectation.params = &RepositoryIMockGetTruthSourceByFileUIDParams{ctx, fileUID}
	for _, e := range mmGetTruthSourceByFileUID.expectations {
		if minimock.Equal(e.params, mmGetTruthSourceByFileUID.defaultExpectation.params) {
			mmGetTruthSourceByFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTruthSourceByFileUID.defaultExpectation.params)
		}
	}

	return mmGetTruthSourceByFileUID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetTruthSourceByFileUID
func (mmGetTruthSourceByFileUID *mRepositoryIMockGetTruthSourceByFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetTruthSourceByFileUID {
	if mmGetTruthSourceByFileUID.mock.funcGetTruthSourceByFileUID != nil {
		mmGetTruthSourceByFileUID.mock.t.Fatalf("RepositoryIMock.GetTruthSourceByFileUID mock is already set by Set")
	}

	if mmGetTruthSourceByFileUID.defaultExpectation == nil {
		mmGetTruthSourceByFileUID.defaultExpectation = &RepositoryIMockGetTruthSourceByFileUIDExpectation{}
	}

	if mmGetTruthSourceByFileUID.defaultExpectation.params != nil {
		mmGetTruthSourceByFileUID.mock.t.Fatalf("RepositoryIMock.GetTruthSourceByFileUID mock is already set by Expect")
	}

	if mmGetTruthSourceByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetTruthSourceByFileUID.defaultExpectation.paramPtrs = &RepositoryIMockGetTruthSourceByFileUIDParamPtrs{}
	}
	mmGetTruthSourceByFileUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetTruthSourceByFileUID
}

// ExpectFileUIDParam2 sets up expected param fileUID for RepositoryI.GetTruthSourceByFileUID
func (mmGetTruthSourceByFileUID *mRepositoryIMockGetTruthSourceByFileUID) ExpectFileUIDParam2(fileUID uuid.UUID) *mRepositoryIMockGetTruthSourceByFileUID {
	if mmGetTruthSourceByFileUID.mock.funcGetTruthSourceByFileUID != nil {
		mmGetTruthSourceByFileUID.mock.t.Fatalf("RepositoryIMock.GetTruthSourceByFileUID mock is already set by Set")
	}

	if mmGetTruthSourceByFileUID.defaultExpectation == nil {
		mmGetTruthSourceByFileUID.defaultExpectation = &RepositoryIMockGetTruthSourceByFileUIDExpectation{}
	}

	if mmGetTruthSourceByFileUID.defaultExpectation.params != nil {
		mmGetTruthSourceByFileUID.mock.t.Fatalf("RepositoryIMock.GetTruthSourceByFileUID mock is already set by Expect")
	}

	if mmGetTruthSourceByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetTruthSourceByFileUID.defaultExpectation.paramPtrs = &RepositoryIMockGetTruthSourceByFileUIDParamPtrs{}
	}
	mmGetTruthSourceByFileUID.defaultExpectation.paramPtrs.fileUID = &fileUID

	return mmGetTruthSourceByFileUID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetTruthSourceByFileUID
func (mmGetTruthSourceByFileUID *mRepositoryIMockGetTruthSourceByFileUID) Inspect(f func(ctx context.Context, fileUID uuid.UUID)) *mRepositoryIMockGetTruthSourceByFileUID {
	if mmGetTruthSourceByFileUID.mock.inspectFuncGetTruthSourceByFileUID != nil {
		mmGetTruthSourceByFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetTruthSourceByFileUID")
	}

	mmGetTruthSourceByFileUID.mock.inspectFuncGetTruthSourceByFileUID = f

	return mmGetTruthSourceByFileUID
}

// Return sets up results that will be returned by RepositoryI.GetTruthSourceByFileUID
func (mmGetTruthSourceByFileUID *mRepositoryIMockGetTruthSourceByFileUID) Return(sp1 *mm_repository.SourceMeta, err error) *RepositoryIMock {
	if mmGetTruthSourceByFileUID.mock.funcGetTruthSourceByFileUID != nil {
		mmGetTruthSourceByFileUID.mock.t.Fatalf("RepositoryIMock.GetTruthSourceByFileUID mock is already set by Set")
	}

	if mmGetTruthSourceByFileUID.defaultExpectation == nil {
		mmGetTruthSourceByFileUID.defaultExpectation = &RepositoryIMockGetTruthSourceByFileUIDExpectation{mock: mmGetTruthSourceByFileUID.mock}
	}
	mmGetTruthSourceByFileUID.defaultExpectation.results = &RepositoryIMockGetTruthSourceByFileUIDResults{sp1, err}
	return mmGetTruthSourceByFileUID.mock
}

// Set uses given function f to mock the RepositoryI.GetTruthSourceByFileUID method
func (mmGetTruthSourceByFileUID *mRepositoryIMockGetTruthSourceByFileUID) Set(f func(ctx context.Context, fileUID uuid.UUID) (sp1 *mm_repository.SourceMeta, err error)) *RepositoryIMock {
	if mmGetTruthSourceByFileUID.defaultExpectation != nil {
		mmGetTruthSourceByFileUID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetTruthSourceByFileUID method")
	}

	if len(mmGetTruthSourceByFileUID.expectations) > 0 {
		mmGetTruthSourceByFileUID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetTruthSourceByFileUID method")
	}

	mmGetTruthSourceByFileUID.mock.funcGetTruthSourceByFileUID = f
	return mmGetTruthSourceByFileUID.mock
}

// When sets expectation for the RepositoryI.GetTruthSourceByFileUID which will trigger the result defined by the following
// Then helper
func (mmGetTruthSourceByFileUID *mRepositoryIMockGetTruthSourceByFileUID) When(ctx context.Context, fileUID uuid.UUID) *RepositoryIMockGetTruthSourceByFileUIDExpectation {
	if mmGetTruthSourceByFileUID.mock.funcGetTruthSourceByFileUID != nil {
		mmGetTruthSourceByFileUID.mock.t.Fatalf("RepositoryIMock.GetTruthSourceByFileUID mock is already set by Set")
	}

	expectation := &RepositoryIMockGetTruthSourceByFileUIDExpectation{
		mock:   mmGetTruthSourceByFileUID.mock,
		params: &RepositoryIMockGetTruthSourceByFileUIDParams{ctx, fileUID},
	}
	mmGetTruthSourceByFileUID.expectations = append(mmGetTruthSourceByFileUID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetTruthSourceByFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetTruthSourceByFileUIDExpectation) Then(sp1 *mm_repository.SourceMeta, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetTruthSourceByFileUIDResults{sp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetTruthSourceByFileUID should be invoked
func (mmGetTruthSourceByFileUID *mRepositoryIMockGetTruthSourceByFileUID) Times(n uint64) *mRepositoryIMockGetTruthSourceByFileUID {
	if n == 0 {
		mmGetTruthSourceByFileUID.mock.t.Fatalf("Times of RepositoryIMock.GetTruthSourceByFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTruthSourceByFileUID.expectedInvocations, n)
	return mmGetTruthSourceByFileUID
}

func (mmGetTruthSourceByFileUID *mRepositoryIMockGetTruthSourceByFileUID) invocationsDone() bool {
	if len(mmGetTruthSourceByFileUID.expectations) == 0 && mmGetTruthSourceByFileUID.defaultExpectation == nil && mmGetTruthSourceByFileUID.mock.funcGetTruthSourceByFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTruthSourceByFileUID.mock.afterGetTruthSourceByFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTruthSourceByFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTruthSourceByFileUID implements repository.RepositoryI
func (mmGetTruthSourceByFileUID *RepositoryIMock) GetTruthSourceByFileUID(ctx context.Context, fileUID uuid.UUID) (sp1 *mm_repository.SourceMeta, err error) {
	mm_atomic.AddUint64(&mmGetTruthSourceByFileUID.beforeGetTruthSourceByFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTruthSourceByFileUID.afterGetTruthSourceByFileUIDCounter, 1)

	if mmGetTruthSourceByFileUID.inspectFuncGetTruthSourceByFileUID != nil {
		mmGetTruthSourceByFileUID.inspectFuncGetTruthSourceByFileUID(ctx, fileUID)
	}

	mm_params := RepositoryIMockGetTruthSourceByFileUIDParams{ctx, fileUID}

	// Record call args
	mmGetTruthSourceByFileUID.GetTruthSourceByFileUIDMock.mutex.Lock()
	mmGetTruthSourceByFileUID.GetTruthSourceByFileUIDMock.callArgs = append(mmGetTruthSourceByFileUID.GetTruthSourceByFileUIDMock.callArgs, &mm_params)
	mmGetTruthSourceByFileUID.GetTruthSourceByFileUIDMock.mutex.Unlock()

	for _, e := range mmGetTruthSourceByFileUID.GetTruthSourceByFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGetTruthSourceByFileUID.GetTruthSourceByFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTruthSourceByFileUID.GetTruthSourceByFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTruthSourceByFileUID.GetTruthSourceByFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetTruthSourceByFileUID.GetTruthSourceByFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetTruthSourceByFileUIDParams{ctx, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTruthSourceByFileUID.t.Errorf("RepositoryIMock.GetTruthSourceByFileUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmGetTruthSourceByFileUID.t.Errorf("RepositoryIMock.GetTruthSourceByFileUID got unexpected parameter fileUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTruthSourceByFileUID.t.Errorf("RepositoryIMock.GetTruthSourceByFileUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTruthSourceByFileUID.GetTruthSourceByFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTruthSourceByFileUID.t.Fatal("No results are set for the RepositoryIMock.GetTruthSourceByFileUID")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGetTruthSourceByFileUID.funcGetTruthSourceByFileUID != nil {
		return mmGetTruthSourceByFileUID.funcGetTruthSourceByFileUID(ctx, fileUID)
	}
	mmGetTruthSourceByFileUID.t.Fatalf("Unexpected call to RepositoryIMock.GetTruthSourceByFileUID. %v %v", ctx, fileUID)
	return
}

// GetTruthSourceByFileUIDAfterCounter returns a count of finished RepositoryIMock.GetTruthSourceByFileUID invocations
func (mmGetTruthSourceByFileUID *RepositoryIMock) GetTruthSourceByFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTruthSourceByFileUID.afterGetTruthSourceByFileUIDCounter)
}

// GetTruthSourceByFileUIDBeforeCounter returns a count of RepositoryIMock.GetTruthSourceByFileUID invocations
func (mmGetTruthSourceByFileUID *RepositoryIMock) GetTruthSourceByFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTruthSourceByFileUID.beforeGetTruthSourceByFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetTruthSourceByFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTruthSourceByFileUID *mRepositoryIMockGetTruthSourceByFileUID) Calls() []*RepositoryIMockGetTruthSourceByFileUIDParams {
	mmGetTruthSourceByFileUID.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetTruthSourceByFileUIDParams, len(mmGetTruthSourceByFileUID.callArgs))
	copy(argCopy, mmGetTruthSourceByFileUID.callArgs)

	mmGetTruthSourceByFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetTruthSourceByFileUIDDone returns true if the count of the GetTruthSourceByFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetTruthSourceByFileUIDDone() bool {
	for _, e := range m.GetTruthSourceByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTruthSourceByFileUIDMock.invocationsDone()
}

// MinimockGetTruthSourceByFileUIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetTruthSourceByFileUIDInspect() {
	for _, e := range m.GetTruthSourceByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetTruthSourceByFileUID with params: %#v", *e.params)
		}
	}

	afterGetTruthSourceByFileUIDCounter := mm_atomic.LoadUint64(&m.afterGetTruthSourceByFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTruthSourceByFileUIDMock.defaultExpectation != nil && afterGetTruthSourceByFileUIDCounter < 1 {
		if m.GetTruthSourceByFileUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetTruthSourceByFileUID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetTruthSourceByFileUID with params: %#v", *m.GetTruthSourceByFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTruthSourceByFileUID != nil && afterGetTruthSourceByFileUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetTruthSourceByFileUID")
	}

	if !m.GetTruthSourceByFileUIDMock.invocationsDone() && afterGetTruthSourceByFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetTruthSourceByFileUID but found %d calls",
			mm_atomic.LoadUint64(&m.GetTruthSourceByFileUIDMock.expectedInvocations), afterGetTruthSourceByFileUIDCounter)
	}
}

type mRepositoryIMockHardDeleteChunksByKbFileUID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockHardDeleteChunksByKbFileUIDExpectation
	expectations       []*RepositoryIMockHardDeleteChunksByKbFileUIDExpectation

	callArgs []*RepositoryIMockHardDeleteChunksByKbFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockHardDeleteChunksByKbFileUIDExpectation specifies expectation struct of the RepositoryI.HardDeleteChunksByKbFileUID
type RepositoryIMockHardDeleteChunksByKbFileUIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockHardDeleteChunksByKbFileUIDParams
	paramPtrs *RepositoryIMockHardDeleteChunksByKbFileUIDParamPtrs
	results   *RepositoryIMockHardDeleteChunksByKbFileUIDResults
	Counter   uint64
}

// RepositoryIMockHardDeleteChunksByKbFileUIDParams contains parameters of the RepositoryI.HardDeleteChunksByKbFileUID
type RepositoryIMockHardDeleteChunksByKbFileUIDParams struct {
	ctx       context.Context
	kbFileUID uuid.UUID
}

// RepositoryIMockHardDeleteChunksByKbFileUIDParamPtrs contains pointers to parameters of the RepositoryI.HardDeleteChunksByKbFileUID
type RepositoryIMockHardDeleteChunksByKbFileUIDParamPtrs struct {
	ctx       *context.Context
	kbFileUID *uuid.UUID
}

// RepositoryIMockHardDeleteChunksByKbFileUIDResults contains results of the RepositoryI.HardDeleteChunksByKbFileUID
type RepositoryIMockHardDeleteChunksByKbFileUIDResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.HardDeleteChunksByKbFileUID
func (mmHardDeleteChunksByKbFileUID *mRepositoryIMockHardDeleteChunksByKbFileUID) Expect(ctx context.Context, kbFileUID uuid.UUID) *mRepositoryIMockHardDeleteChunksByKbFileUID {
	if mmHardDeleteChunksByKbFileUID.mock.funcHardDeleteChunksByKbFileUID != nil {
		mmHardDeleteChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbFileUID mock is already set by Set")
	}

	if mmHardDeleteChunksByKbFileUID.defaultExpectation == nil {
		mmHardDeleteChunksByKbFileUID.defaultExpectation = &RepositoryIMockHardDeleteChunksByKbFileUIDExpectation{}
	}

	if mmHardDeleteChunksByKbFileUID.defaultExpectation.paramPtrs != nil {
		mmHardDeleteChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbFileUID mock is already set by ExpectParams functions")
	}

	mmHardDeleteChunksByKbFileUID.defaultExpectation.params = &RepositoryIMockHardDeleteChunksByKbFileUIDParams{ctx, kbFileUID}
	for _, e := range mmHardDeleteChunksByKbFileUID.expectations {
		if minimock.Equal(e.params, mmHardDeleteChunksByKbFileUID.defaultExpectation.params) {
			mmHardDeleteChunksByKbFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHardDeleteChunksByKbFileUID.defaultExpectation.params)
		}
	}

	return mmHardDeleteChunksByKbFileUID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.HardDeleteChunksByKbFileUID
func (mmHardDeleteChunksByKbFileUID *mRepositoryIMockHardDeleteChunksByKbFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockHardDeleteChunksByKbFileUID {
	if mmHardDeleteChunksByKbFileUID.mock.funcHardDeleteChunksByKbFileUID != nil {
		mmHardDeleteChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbFileUID mock is already set by Set")
	}

	if mmHardDeleteChunksByKbFileUID.defaultExpectation == nil {
		mmHardDeleteChunksByKbFileUID.defaultExpectation = &RepositoryIMockHardDeleteChunksByKbFileUIDExpectation{}
	}

	if mmHardDeleteChunksByKbFileUID.defaultExpectation.params != nil {
		mmHardDeleteChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbFileUID mock is already set by Expect")
	}

	if mmHardDeleteChunksByKbFileUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteChunksByKbFileUID.defaultExpectation.paramPtrs = &RepositoryIMockHardDeleteChunksByKbFileUIDParamPtrs{}
	}
	mmHardDeleteChunksByKbFileUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmHardDeleteChunksByKbFileUID
}

// ExpectKbFileUIDParam2 sets up expected param kbFileUID for RepositoryI.HardDeleteChunksByKbFileUID
func (mmHardDeleteChunksByKbFileUID *mRepositoryIMockHardDeleteChunksByKbFileUID) ExpectKbFileUIDParam2(kbFileUID uuid.UUID) *mRepositoryIMockHardDeleteChunksByKbFileUID {
	if mmHardDeleteChunksByKbFileUID.mock.funcHardDeleteChunksByKbFileUID != nil {
		mmHardDeleteChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbFileUID mock is already set by Set")
	}

	if mmHardDeleteChunksByKbFileUID.defaultExpectation == nil {
		mmHardDeleteChunksByKbFileUID.defaultExpectation = &RepositoryIMockHardDeleteChunksByKbFileUIDExpectation{}
	}

	if mmHardDeleteChunksByKbFileUID.defaultExpectation.params != nil {
		mmHardDeleteChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbFileUID mock is already set by Expect")
	}

	if mmHardDeleteChunksByKbFileUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteChunksByKbFileUID.defaultExpectation.paramPtrs = &RepositoryIMockHardDeleteChunksByKbFileUIDParamPtrs{}
	}
	mmHardDeleteChunksByKbFileUID.defaultExpectation.paramPtrs.kbFileUID = &kbFileUID

	return mmHardDeleteChunksByKbFileUID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.HardDeleteChunksByKbFileUID
func (mmHardDeleteChunksByKbFileUID *mRepositoryIMockHardDeleteChunksByKbFileUID) Inspect(f func(ctx context.Context, kbFileUID uuid.UUID)) *mRepositoryIMockHardDeleteChunksByKbFileUID {
	if mmHardDeleteChunksByKbFileUID.mock.inspectFuncHardDeleteChunksByKbFileUID != nil {
		mmHardDeleteChunksByKbFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.HardDeleteChunksByKbFileUID")
	}

	mmHardDeleteChunksByKbFileUID.mock.inspectFuncHardDeleteChunksByKbFileUID = f

	return mmHardDeleteChunksByKbFileUID
}

// Return sets up results that will be returned by RepositoryI.HardDeleteChunksByKbFileUID
func (mmHardDeleteChunksByKbFileUID *mRepositoryIMockHardDeleteChunksByKbFileUID) Return(err error) *RepositoryIMock {
	if mmHardDeleteChunksByKbFileUID.mock.funcHardDeleteChunksByKbFileUID != nil {
		mmHardDeleteChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbFileUID mock is already set by Set")
	}

	if mmHardDeleteChunksByKbFileUID.defaultExpectation == nil {
		mmHardDeleteChunksByKbFileUID.defaultExpectation = &RepositoryIMockHardDeleteChunksByKbFileUIDExpectation{mock: mmHardDeleteChunksByKbFileUID.mock}
	}
	mmHardDeleteChunksByKbFileUID.defaultExpectation.results = &RepositoryIMockHardDeleteChunksByKbFileUIDResults{err}
	return mmHardDeleteChunksByKbFileUID.mock
}

// Set uses given function f to mock the RepositoryI.HardDeleteChunksByKbFileUID method
func (mmHardDeleteChunksByKbFileUID *mRepositoryIMockHardDeleteChunksByKbFileUID) Set(f func(ctx context.Context, kbFileUID uuid.UUID) (err error)) *RepositoryIMock {
	if mmHardDeleteChunksByKbFileUID.defaultExpectation != nil {
		mmHardDeleteChunksByKbFileUID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.HardDeleteChunksByKbFileUID method")
	}

	if len(mmHardDeleteChunksByKbFileUID.expectations) > 0 {
		mmHardDeleteChunksByKbFileUID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.HardDeleteChunksByKbFileUID method")
	}

	mmHardDeleteChunksByKbFileUID.mock.funcHardDeleteChunksByKbFileUID = f
	return mmHardDeleteChunksByKbFileUID.mock
}

// When sets expectation for the RepositoryI.HardDeleteChunksByKbFileUID which will trigger the result defined by the following
// Then helper
func (mmHardDeleteChunksByKbFileUID *mRepositoryIMockHardDeleteChunksByKbFileUID) When(ctx context.Context, kbFileUID uuid.UUID) *RepositoryIMockHardDeleteChunksByKbFileUIDExpectation {
	if mmHardDeleteChunksByKbFileUID.mock.funcHardDeleteChunksByKbFileUID != nil {
		mmHardDeleteChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbFileUID mock is already set by Set")
	}

	expectation := &RepositoryIMockHardDeleteChunksByKbFileUIDExpectation{
		mock:   mmHardDeleteChunksByKbFileUID.mock,
		params: &RepositoryIMockHardDeleteChunksByKbFileUIDParams{ctx, kbFileUID},
	}
	mmHardDeleteChunksByKbFileUID.expectations = append(mmHardDeleteChunksByKbFileUID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.HardDeleteChunksByKbFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockHardDeleteChunksByKbFileUIDExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockHardDeleteChunksByKbFileUIDResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.HardDeleteChunksByKbFileUID should be invoked
func (mmHardDeleteChunksByKbFileUID *mRepositoryIMockHardDeleteChunksByKbFileUID) Times(n uint64) *mRepositoryIMockHardDeleteChunksByKbFileUID {
	if n == 0 {
		mmHardDeleteChunksByKbFileUID.mock.t.Fatalf("Times of RepositoryIMock.HardDeleteChunksByKbFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHardDeleteChunksByKbFileUID.expectedInvocations, n)
	return mmHardDeleteChunksByKbFileUID
}

func (mmHardDeleteChunksByKbFileUID *mRepositoryIMockHardDeleteChunksByKbFileUID) invocationsDone() bool {
	if len(mmHardDeleteChunksByKbFileUID.expectations) == 0 && mmHardDeleteChunksByKbFileUID.defaultExpectation == nil && mmHardDeleteChunksByKbFileUID.mock.funcHardDeleteChunksByKbFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHardDeleteChunksByKbFileUID.mock.afterHardDeleteChunksByKbFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHardDeleteChunksByKbFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HardDeleteChunksByKbFileUID implements repository.RepositoryI
func (mmHardDeleteChunksByKbFileUID *RepositoryIMock) HardDeleteChunksByKbFileUID(ctx context.Context, kbFileUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmHardDeleteChunksByKbFileUID.beforeHardDeleteChunksByKbFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmHardDeleteChunksByKbFileUID.afterHardDeleteChunksByKbFileUIDCounter, 1)

	if mmHardDeleteChunksByKbFileUID.inspectFuncHardDeleteChunksByKbFileUID != nil {
		mmHardDeleteChunksByKbFileUID.inspectFuncHardDeleteChunksByKbFileUID(ctx, kbFileUID)
	}

	mm_params := RepositoryIMockHardDeleteChunksByKbFileUIDParams{ctx, kbFileUID}

	// Record call args
	mmHardDeleteChunksByKbFileUID.HardDeleteChunksByKbFileUIDMock.mutex.Lock()
	mmHardDeleteChunksByKbFileUID.HardDeleteChunksByKbFileUIDMock.callArgs = append(mmHardDeleteChunksByKbFileUID.HardDeleteChunksByKbFileUIDMock.callArgs, &mm_params)
	mmHardDeleteChunksByKbFileUID.HardDeleteChunksByKbFileUIDMock.mutex.Unlock()

	for _, e := range mmHardDeleteChunksByKbFileUID.HardDeleteChunksByKbFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHardDeleteChunksByKbFileUID.HardDeleteChunksByKbFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHardDeleteChunksByKbFileUID.HardDeleteChunksByKbFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmHardDeleteChunksByKbFileUID.HardDeleteChunksByKbFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmHardDeleteChunksByKbFileUID.HardDeleteChunksByKbFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockHardDeleteChunksByKbFileUIDParams{ctx, kbFileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHardDeleteChunksByKbFileUID.t.Errorf("RepositoryIMock.HardDeleteChunksByKbFileUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbFileUID != nil && !minimock.Equal(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID) {
				mmHardDeleteChunksByKbFileUID.t.Errorf("RepositoryIMock.HardDeleteChunksByKbFileUID got unexpected parameter kbFileUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbFileUID, mm_got.kbFileUID, minimock.Diff(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHardDeleteChunksByKbFileUID.t.Errorf("RepositoryIMock.HardDeleteChunksByKbFileUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHardDeleteChunksByKbFileUID.HardDeleteChunksByKbFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmHardDeleteChunksByKbFileUID.t.Fatal("No results are set for the RepositoryIMock.HardDeleteChunksByKbFileUID")
		}
		return (*mm_results).err
	}
	if mmHardDeleteChunksByKbFileUID.funcHardDeleteChunksByKbFileUID != nil {
		return mmHardDeleteChunksByKbFileUID.funcHardDeleteChunksByKbFileUID(ctx, kbFileUID)
	}
	mmHardDeleteChunksByKbFileUID.t.Fatalf("Unexpected call to RepositoryIMock.HardDeleteChunksByKbFileUID. %v %v", ctx, kbFileUID)
	return
}

// HardDeleteChunksByKbFileUIDAfterCounter returns a count of finished RepositoryIMock.HardDeleteChunksByKbFileUID invocations
func (mmHardDeleteChunksByKbFileUID *RepositoryIMock) HardDeleteChunksByKbFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteChunksByKbFileUID.afterHardDeleteChunksByKbFileUIDCounter)
}

// HardDeleteChunksByKbFileUIDBeforeCounter returns a count of RepositoryIMock.HardDeleteChunksByKbFileUID invocations
func (mmHardDeleteChunksByKbFileUID *RepositoryIMock) HardDeleteChunksByKbFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteChunksByKbFileUID.beforeHardDeleteChunksByKbFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.HardDeleteChunksByKbFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHardDeleteChunksByKbFileUID *mRepositoryIMockHardDeleteChunksByKbFileUID) Calls() []*RepositoryIMockHardDeleteChunksByKbFileUIDParams {
	mmHardDeleteChunksByKbFileUID.mutex.RLock()

	argCopy := make([]*RepositoryIMockHardDeleteChunksByKbFileUIDParams, len(mmHardDeleteChunksByKbFileUID.callArgs))
	copy(argCopy, mmHardDeleteChunksByKbFileUID.callArgs)

	mmHardDeleteChunksByKbFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockHardDeleteChunksByKbFileUIDDone returns true if the count of the HardDeleteChunksByKbFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockHardDeleteChunksByKbFileUIDDone() bool {
	for _, e := range m.HardDeleteChunksByKbFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HardDeleteChunksByKbFileUIDMock.invocationsDone()
}

// MinimockHardDeleteChunksByKbFileUIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockHardDeleteChunksByKbFileUIDInspect() {
	for _, e := range m.HardDeleteChunksByKbFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.HardDeleteChunksByKbFileUID with params: %#v", *e.params)
		}
	}

	afterHardDeleteChunksByKbFileUIDCounter := mm_atomic.LoadUint64(&m.afterHardDeleteChunksByKbFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HardDeleteChunksByKbFileUIDMock.defaultExpectation != nil && afterHardDeleteChunksByKbFileUIDCounter < 1 {
		if m.HardDeleteChunksByKbFileUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.HardDeleteChunksByKbFileUID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.HardDeleteChunksByKbFileUID with params: %#v", *m.HardDeleteChunksByKbFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHardDeleteChunksByKbFileUID != nil && afterHardDeleteChunksByKbFileUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.HardDeleteChunksByKbFileUID")
	}

	if !m.HardDeleteChunksByKbFileUIDMock.invocationsDone() && afterHardDeleteChunksByKbFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.HardDeleteChunksByKbFileUID but found %d calls",
			mm_atomic.LoadUint64(&m.HardDeleteChunksByKbFileUIDMock.expectedInvocations), afterHardDeleteChunksByKbFileUIDCounter)
	}
}

type mRepositoryIMockHardDeleteChunksByKbUID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockHardDeleteChunksByKbUIDExpectation
	expectations       []*RepositoryIMockHardDeleteChunksByKbUIDExpectation

	callArgs []*RepositoryIMockHardDeleteChunksByKbUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockHardDeleteChunksByKbUIDExpectation specifies expectation struct of the RepositoryI.HardDeleteChunksByKbUID
type RepositoryIMockHardDeleteChunksByKbUIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockHardDeleteChunksByKbUIDParams
	paramPtrs *RepositoryIMockHardDeleteChunksByKbUIDParamPtrs
	results   *RepositoryIMockHardDeleteChunksByKbUIDResults
	Counter   uint64
}

// RepositoryIMockHardDeleteChunksByKbUIDParams contains parameters of the RepositoryI.HardDeleteChunksByKbUID
type RepositoryIMockHardDeleteChunksByKbUIDParams struct {
	ctx   context.Context
	kbUID uuid.UUID
}

// RepositoryIMockHardDeleteChunksByKbUIDParamPtrs contains pointers to parameters of the RepositoryI.HardDeleteChunksByKbUID
type RepositoryIMockHardDeleteChunksByKbUIDParamPtrs struct {
	ctx   *context.Context
	kbUID *uuid.UUID
}

// RepositoryIMockHardDeleteChunksByKbUIDResults contains results of the RepositoryI.HardDeleteChunksByKbUID
type RepositoryIMockHardDeleteChunksByKbUIDResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.HardDeleteChunksByKbUID
func (mmHardDeleteChunksByKbUID *mRepositoryIMockHardDeleteChunksByKbUID) Expect(ctx context.Context, kbUID uuid.UUID) *mRepositoryIMockHardDeleteChunksByKbUID {
	if mmHardDeleteChunksByKbUID.mock.funcHardDeleteChunksByKbUID != nil {
		mmHardDeleteChunksByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbUID mock is already set by Set")
	}

	if mmHardDeleteChunksByKbUID.defaultExpectation == nil {
		mmHardDeleteChunksByKbUID.defaultExpectation = &RepositoryIMockHardDeleteChunksByKbUIDExpectation{}
	}

	if mmHardDeleteChunksByKbUID.defaultExpectation.paramPtrs != nil {
		mmHardDeleteChunksByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbUID mock is already set by ExpectParams functions")
	}

	mmHardDeleteChunksByKbUID.defaultExpectation.params = &RepositoryIMockHardDeleteChunksByKbUIDParams{ctx, kbUID}
	for _, e := range mmHardDeleteChunksByKbUID.expectations {
		if minimock.Equal(e.params, mmHardDeleteChunksByKbUID.defaultExpectation.params) {
			mmHardDeleteChunksByKbUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHardDeleteChunksByKbUID.defaultExpectation.params)
		}
	}

	return mmHardDeleteChunksByKbUID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.HardDeleteChunksByKbUID
func (mmHardDeleteChunksByKbUID *mRepositoryIMockHardDeleteChunksByKbUID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockHardDeleteChunksByKbUID {
	if mmHardDeleteChunksByKbUID.mock.funcHardDeleteChunksByKbUID != nil {
		mmHardDeleteChunksByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbUID mock is already set by Set")
	}

	if mmHardDeleteChunksByKbUID.defaultExpectation == nil {
		mmHardDeleteChunksByKbUID.defaultExpectation = &RepositoryIMockHardDeleteChunksByKbUIDExpectation{}
	}

	if mmHardDeleteChunksByKbUID.defaultExpectation.params != nil {
		mmHardDeleteChunksByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbUID mock is already set by Expect")
	}

	if mmHardDeleteChunksByKbUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteChunksByKbUID.defaultExpectation.paramPtrs = &RepositoryIMockHardDeleteChunksByKbUIDParamPtrs{}
	}
	mmHardDeleteChunksByKbUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmHardDeleteChunksByKbUID
}

// ExpectKbUIDParam2 sets up expected param kbUID for RepositoryI.HardDeleteChunksByKbUID
func (mmHardDeleteChunksByKbUID *mRepositoryIMockHardDeleteChunksByKbUID) ExpectKbUIDParam2(kbUID uuid.UUID) *mRepositoryIMockHardDeleteChunksByKbUID {
	if mmHardDeleteChunksByKbUID.mock.funcHardDeleteChunksByKbUID != nil {
		mmHardDeleteChunksByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbUID mock is already set by Set")
	}

	if mmHardDeleteChunksByKbUID.defaultExpectation == nil {
		mmHardDeleteChunksByKbUID.defaultExpectation = &RepositoryIMockHardDeleteChunksByKbUIDExpectation{}
	}

	if mmHardDeleteChunksByKbUID.defaultExpectation.params != nil {
		mmHardDeleteChunksByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbUID mock is already set by Expect")
	}

	if mmHardDeleteChunksByKbUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteChunksByKbUID.defaultExpectation.paramPtrs = &RepositoryIMockHardDeleteChunksByKbUIDParamPtrs{}
	}
	mmHardDeleteChunksByKbUID.defaultExpectation.paramPtrs.kbUID = &kbUID

	return mmHardDeleteChunksByKbUID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.HardDeleteChunksByKbUID
func (mmHardDeleteChunksByKbUID *mRepositoryIMockHardDeleteChunksByKbUID) Inspect(f func(ctx context.Context, kbUID uuid.UUID)) *mRepositoryIMockHardDeleteChunksByKbUID {
	if mmHardDeleteChunksByKbUID.mock.inspectFuncHardDeleteChunksByKbUID != nil {
		mmHardDeleteChunksByKbUID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.HardDeleteChunksByKbUID")
	}

	mmHardDeleteChunksByKbUID.mock.inspectFuncHardDeleteChunksByKbUID = f

	return mmHardDeleteChunksByKbUID
}

// Return sets up results that will be returned by RepositoryI.HardDeleteChunksByKbUID
func (mmHardDeleteChunksByKbUID *mRepositoryIMockHardDeleteChunksByKbUID) Return(err error) *RepositoryIMock {
	if mmHardDeleteChunksByKbUID.mock.funcHardDeleteChunksByKbUID != nil {
		mmHardDeleteChunksByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbUID mock is already set by Set")
	}

	if mmHardDeleteChunksByKbUID.defaultExpectation == nil {
		mmHardDeleteChunksByKbUID.defaultExpectation = &RepositoryIMockHardDeleteChunksByKbUIDExpectation{mock: mmHardDeleteChunksByKbUID.mock}
	}
	mmHardDeleteChunksByKbUID.defaultExpectation.results = &RepositoryIMockHardDeleteChunksByKbUIDResults{err}
	return mmHardDeleteChunksByKbUID.mock
}

// Set uses given function f to mock the RepositoryI.HardDeleteChunksByKbUID method
func (mmHardDeleteChunksByKbUID *mRepositoryIMockHardDeleteChunksByKbUID) Set(f func(ctx context.Context, kbUID uuid.UUID) (err error)) *RepositoryIMock {
	if mmHardDeleteChunksByKbUID.defaultExpectation != nil {
		mmHardDeleteChunksByKbUID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.HardDeleteChunksByKbUID method")
	}

	if len(mmHardDeleteChunksByKbUID.expectations) > 0 {
		mmHardDeleteChunksByKbUID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.HardDeleteChunksByKbUID method")
	}

	mmHardDeleteChunksByKbUID.mock.funcHardDeleteChunksByKbUID = f
	return mmHardDeleteChunksByKbUID.mock
}

// When sets expectation for the RepositoryI.HardDeleteChunksByKbUID which will trigger the result defined by the following
// Then helper
func (mmHardDeleteChunksByKbUID *mRepositoryIMockHardDeleteChunksByKbUID) When(ctx context.Context, kbUID uuid.UUID) *RepositoryIMockHardDeleteChunksByKbUIDExpectation {
	if mmHardDeleteChunksByKbUID.mock.funcHardDeleteChunksByKbUID != nil {
		mmHardDeleteChunksByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteChunksByKbUID mock is already set by Set")
	}

	expectation := &RepositoryIMockHardDeleteChunksByKbUIDExpectation{
		mock:   mmHardDeleteChunksByKbUID.mock,
		params: &RepositoryIMockHardDeleteChunksByKbUIDParams{ctx, kbUID},
	}
	mmHardDeleteChunksByKbUID.expectations = append(mmHardDeleteChunksByKbUID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.HardDeleteChunksByKbUID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockHardDeleteChunksByKbUIDExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockHardDeleteChunksByKbUIDResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.HardDeleteChunksByKbUID should be invoked
func (mmHardDeleteChunksByKbUID *mRepositoryIMockHardDeleteChunksByKbUID) Times(n uint64) *mRepositoryIMockHardDeleteChunksByKbUID {
	if n == 0 {
		mmHardDeleteChunksByKbUID.mock.t.Fatalf("Times of RepositoryIMock.HardDeleteChunksByKbUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHardDeleteChunksByKbUID.expectedInvocations, n)
	return mmHardDeleteChunksByKbUID
}

func (mmHardDeleteChunksByKbUID *mRepositoryIMockHardDeleteChunksByKbUID) invocationsDone() bool {
	if len(mmHardDeleteChunksByKbUID.expectations) == 0 && mmHardDeleteChunksByKbUID.defaultExpectation == nil && mmHardDeleteChunksByKbUID.mock.funcHardDeleteChunksByKbUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHardDeleteChunksByKbUID.mock.afterHardDeleteChunksByKbUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHardDeleteChunksByKbUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HardDeleteChunksByKbUID implements repository.RepositoryI
func (mmHardDeleteChunksByKbUID *RepositoryIMock) HardDeleteChunksByKbUID(ctx context.Context, kbUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmHardDeleteChunksByKbUID.beforeHardDeleteChunksByKbUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmHardDeleteChunksByKbUID.afterHardDeleteChunksByKbUIDCounter, 1)

	if mmHardDeleteChunksByKbUID.inspectFuncHardDeleteChunksByKbUID != nil {
		mmHardDeleteChunksByKbUID.inspectFuncHardDeleteChunksByKbUID(ctx, kbUID)
	}

	mm_params := RepositoryIMockHardDeleteChunksByKbUIDParams{ctx, kbUID}

	// Record call args
	mmHardDeleteChunksByKbUID.HardDeleteChunksByKbUIDMock.mutex.Lock()
	mmHardDeleteChunksByKbUID.HardDeleteChunksByKbUIDMock.callArgs = append(mmHardDeleteChunksByKbUID.HardDeleteChunksByKbUIDMock.callArgs, &mm_params)
	mmHardDeleteChunksByKbUID.HardDeleteChunksByKbUIDMock.mutex.Unlock()

	for _, e := range mmHardDeleteChunksByKbUID.HardDeleteChunksByKbUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHardDeleteChunksByKbUID.HardDeleteChunksByKbUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHardDeleteChunksByKbUID.HardDeleteChunksByKbUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmHardDeleteChunksByKbUID.HardDeleteChunksByKbUIDMock.defaultExpectation.params
		mm_want_ptrs := mmHardDeleteChunksByKbUID.HardDeleteChunksByKbUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockHardDeleteChunksByKbUIDParams{ctx, kbUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHardDeleteChunksByKbUID.t.Errorf("RepositoryIMock.HardDeleteChunksByKbUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmHardDeleteChunksByKbUID.t.Errorf("RepositoryIMock.HardDeleteChunksByKbUID got unexpected parameter kbUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHardDeleteChunksByKbUID.t.Errorf("RepositoryIMock.HardDeleteChunksByKbUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHardDeleteChunksByKbUID.HardDeleteChunksByKbUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmHardDeleteChunksByKbUID.t.Fatal("No results are set for the RepositoryIMock.HardDeleteChunksByKbUID")
		}
		return (*mm_results).err
	}
	if mmHardDeleteChunksByKbUID.funcHardDeleteChunksByKbUID != nil {
		return mmHardDeleteChunksByKbUID.funcHardDeleteChunksByKbUID(ctx, kbUID)
	}
	mmHardDeleteChunksByKbUID.t.Fatalf("Unexpected call to RepositoryIMock.HardDeleteChunksByKbUID. %v %v", ctx, kbUID)
	return
}

// HardDeleteChunksByKbUIDAfterCounter returns a count of finished RepositoryIMock.HardDeleteChunksByKbUID invocations
func (mmHardDeleteChunksByKbUID *RepositoryIMock) HardDeleteChunksByKbUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteChunksByKbUID.afterHardDeleteChunksByKbUIDCounter)
}

// HardDeleteChunksByKbUIDBeforeCounter returns a count of RepositoryIMock.HardDeleteChunksByKbUID invocations
func (mmHardDeleteChunksByKbUID *RepositoryIMock) HardDeleteChunksByKbUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteChunksByKbUID.beforeHardDeleteChunksByKbUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.HardDeleteChunksByKbUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHardDeleteChunksByKbUID *mRepositoryIMockHardDeleteChunksByKbUID) Calls() []*RepositoryIMockHardDeleteChunksByKbUIDParams {
	mmHardDeleteChunksByKbUID.mutex.RLock()

	argCopy := make([]*RepositoryIMockHardDeleteChunksByKbUIDParams, len(mmHardDeleteChunksByKbUID.callArgs))
	copy(argCopy, mmHardDeleteChunksByKbUID.callArgs)

	mmHardDeleteChunksByKbUID.mutex.RUnlock()

	return argCopy
}

// MinimockHardDeleteChunksByKbUIDDone returns true if the count of the HardDeleteChunksByKbUID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockHardDeleteChunksByKbUIDDone() bool {
	for _, e := range m.HardDeleteChunksByKbUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HardDeleteChunksByKbUIDMock.invocationsDone()
}

// MinimockHardDeleteChunksByKbUIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockHardDeleteChunksByKbUIDInspect() {
	for _, e := range m.HardDeleteChunksByKbUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.HardDeleteChunksByKbUID with params: %#v", *e.params)
		}
	}

	afterHardDeleteChunksByKbUIDCounter := mm_atomic.LoadUint64(&m.afterHardDeleteChunksByKbUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HardDeleteChunksByKbUIDMock.defaultExpectation != nil && afterHardDeleteChunksByKbUIDCounter < 1 {
		if m.HardDeleteChunksByKbUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.HardDeleteChunksByKbUID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.HardDeleteChunksByKbUID with params: %#v", *m.HardDeleteChunksByKbUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHardDeleteChunksByKbUID != nil && afterHardDeleteChunksByKbUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.HardDeleteChunksByKbUID")
	}

	if !m.HardDeleteChunksByKbUIDMock.invocationsDone() && afterHardDeleteChunksByKbUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.HardDeleteChunksByKbUID but found %d calls",
			mm_atomic.LoadUint64(&m.HardDeleteChunksByKbUIDMock.expectedInvocations), afterHardDeleteChunksByKbUIDCounter)
	}
}

type mRepositoryIMockHardDeleteConvertedFileByFileUID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockHardDeleteConvertedFileByFileUIDExpectation
	expectations       []*RepositoryIMockHardDeleteConvertedFileByFileUIDExpectation

	callArgs []*RepositoryIMockHardDeleteConvertedFileByFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockHardDeleteConvertedFileByFileUIDExpectation specifies expectation struct of the RepositoryI.HardDeleteConvertedFileByFileUID
type RepositoryIMockHardDeleteConvertedFileByFileUIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockHardDeleteConvertedFileByFileUIDParams
	paramPtrs *RepositoryIMockHardDeleteConvertedFileByFileUIDParamPtrs
	results   *RepositoryIMockHardDeleteConvertedFileByFileUIDResults
	Counter   uint64
}

// RepositoryIMockHardDeleteConvertedFileByFileUIDParams contains parameters of the RepositoryI.HardDeleteConvertedFileByFileUID
type RepositoryIMockHardDeleteConvertedFileByFileUIDParams struct {
	ctx     context.Context
	fileUID uuid.UUID
}

// RepositoryIMockHardDeleteConvertedFileByFileUIDParamPtrs contains pointers to parameters of the RepositoryI.HardDeleteConvertedFileByFileUID
type RepositoryIMockHardDeleteConvertedFileByFileUIDParamPtrs struct {
	ctx     *context.Context
	fileUID *uuid.UUID
}

// RepositoryIMockHardDeleteConvertedFileByFileUIDResults contains results of the RepositoryI.HardDeleteConvertedFileByFileUID
type RepositoryIMockHardDeleteConvertedFileByFileUIDResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.HardDeleteConvertedFileByFileUID
func (mmHardDeleteConvertedFileByFileUID *mRepositoryIMockHardDeleteConvertedFileByFileUID) Expect(ctx context.Context, fileUID uuid.UUID) *mRepositoryIMockHardDeleteConvertedFileByFileUID {
	if mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUID != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteConvertedFileByFileUID mock is already set by Set")
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation == nil {
		mmHardDeleteConvertedFileByFileUID.defaultExpectation = &RepositoryIMockHardDeleteConvertedFileByFileUIDExpectation{}
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteConvertedFileByFileUID mock is already set by ExpectParams functions")
	}

	mmHardDeleteConvertedFileByFileUID.defaultExpectation.params = &RepositoryIMockHardDeleteConvertedFileByFileUIDParams{ctx, fileUID}
	for _, e := range mmHardDeleteConvertedFileByFileUID.expectations {
		if minimock.Equal(e.params, mmHardDeleteConvertedFileByFileUID.defaultExpectation.params) {
			mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHardDeleteConvertedFileByFileUID.defaultExpectation.params)
		}
	}

	return mmHardDeleteConvertedFileByFileUID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.HardDeleteConvertedFileByFileUID
func (mmHardDeleteConvertedFileByFileUID *mRepositoryIMockHardDeleteConvertedFileByFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockHardDeleteConvertedFileByFileUID {
	if mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUID != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteConvertedFileByFileUID mock is already set by Set")
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation == nil {
		mmHardDeleteConvertedFileByFileUID.defaultExpectation = &RepositoryIMockHardDeleteConvertedFileByFileUIDExpectation{}
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation.params != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteConvertedFileByFileUID mock is already set by Expect")
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs = &RepositoryIMockHardDeleteConvertedFileByFileUIDParamPtrs{}
	}
	mmHardDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmHardDeleteConvertedFileByFileUID
}

// ExpectFileUIDParam2 sets up expected param fileUID for RepositoryI.HardDeleteConvertedFileByFileUID
func (mmHardDeleteConvertedFileByFileUID *mRepositoryIMockHardDeleteConvertedFileByFileUID) ExpectFileUIDParam2(fileUID uuid.UUID) *mRepositoryIMockHardDeleteConvertedFileByFileUID {
	if mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUID != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteConvertedFileByFileUID mock is already set by Set")
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation == nil {
		mmHardDeleteConvertedFileByFileUID.defaultExpectation = &RepositoryIMockHardDeleteConvertedFileByFileUIDExpectation{}
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation.params != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteConvertedFileByFileUID mock is already set by Expect")
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs = &RepositoryIMockHardDeleteConvertedFileByFileUIDParamPtrs{}
	}
	mmHardDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs.fileUID = &fileUID

	return mmHardDeleteConvertedFileByFileUID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.HardDeleteConvertedFileByFileUID
func (mmHardDeleteConvertedFileByFileUID *mRepositoryIMockHardDeleteConvertedFileByFileUID) Inspect(f func(ctx context.Context, fileUID uuid.UUID)) *mRepositoryIMockHardDeleteConvertedFileByFileUID {
	if mmHardDeleteConvertedFileByFileUID.mock.inspectFuncHardDeleteConvertedFileByFileUID != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.HardDeleteConvertedFileByFileUID")
	}

	mmHardDeleteConvertedFileByFileUID.mock.inspectFuncHardDeleteConvertedFileByFileUID = f

	return mmHardDeleteConvertedFileByFileUID
}

// Return sets up results that will be returned by RepositoryI.HardDeleteConvertedFileByFileUID
func (mmHardDeleteConvertedFileByFileUID *mRepositoryIMockHardDeleteConvertedFileByFileUID) Return(err error) *RepositoryIMock {
	if mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUID != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteConvertedFileByFileUID mock is already set by Set")
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation == nil {
		mmHardDeleteConvertedFileByFileUID.defaultExpectation = &RepositoryIMockHardDeleteConvertedFileByFileUIDExpectation{mock: mmHardDeleteConvertedFileByFileUID.mock}
	}
	mmHardDeleteConvertedFileByFileUID.defaultExpectation.results = &RepositoryIMockHardDeleteConvertedFileByFileUIDResults{err}
	return mmHardDeleteConvertedFileByFileUID.mock
}

// Set uses given function f to mock the RepositoryI.HardDeleteConvertedFileByFileUID method
func (mmHardDeleteConvertedFileByFileUID *mRepositoryIMockHardDeleteConvertedFileByFileUID) Set(f func(ctx context.Context, fileUID uuid.UUID) (err error)) *RepositoryIMock {
	if mmHardDeleteConvertedFileByFileUID.defaultExpectation != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.HardDeleteConvertedFileByFileUID method")
	}

	if len(mmHardDeleteConvertedFileByFileUID.expectations) > 0 {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.HardDeleteConvertedFileByFileUID method")
	}

	mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUID = f
	return mmHardDeleteConvertedFileByFileUID.mock
}

// When sets expectation for the RepositoryI.HardDeleteConvertedFileByFileUID which will trigger the result defined by the following
// Then helper
func (mmHardDeleteConvertedFileByFileUID *mRepositoryIMockHardDeleteConvertedFileByFileUID) When(ctx context.Context, fileUID uuid.UUID) *RepositoryIMockHardDeleteConvertedFileByFileUIDExpectation {
	if mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUID != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteConvertedFileByFileUID mock is already set by Set")
	}

	expectation := &RepositoryIMockHardDeleteConvertedFileByFileUIDExpectation{
		mock:   mmHardDeleteConvertedFileByFileUID.mock,
		params: &RepositoryIMockHardDeleteConvertedFileByFileUIDParams{ctx, fileUID},
	}
	mmHardDeleteConvertedFileByFileUID.expectations = append(mmHardDeleteConvertedFileByFileUID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.HardDeleteConvertedFileByFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockHardDeleteConvertedFileByFileUIDExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockHardDeleteConvertedFileByFileUIDResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.HardDeleteConvertedFileByFileUID should be invoked
func (mmHardDeleteConvertedFileByFileUID *mRepositoryIMockHardDeleteConvertedFileByFileUID) Times(n uint64) *mRepositoryIMockHardDeleteConvertedFileByFileUID {
	if n == 0 {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("Times of RepositoryIMock.HardDeleteConvertedFileByFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHardDeleteConvertedFileByFileUID.expectedInvocations, n)
	return mmHardDeleteConvertedFileByFileUID
}

func (mmHardDeleteConvertedFileByFileUID *mRepositoryIMockHardDeleteConvertedFileByFileUID) invocationsDone() bool {
	if len(mmHardDeleteConvertedFileByFileUID.expectations) == 0 && mmHardDeleteConvertedFileByFileUID.defaultExpectation == nil && mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHardDeleteConvertedFileByFileUID.mock.afterHardDeleteConvertedFileByFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHardDeleteConvertedFileByFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HardDeleteConvertedFileByFileUID implements repository.RepositoryI
func (mmHardDeleteConvertedFileByFileUID *RepositoryIMock) HardDeleteConvertedFileByFileUID(ctx context.Context, fileUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmHardDeleteConvertedFileByFileUID.beforeHardDeleteConvertedFileByFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmHardDeleteConvertedFileByFileUID.afterHardDeleteConvertedFileByFileUIDCounter, 1)

	if mmHardDeleteConvertedFileByFileUID.inspectFuncHardDeleteConvertedFileByFileUID != nil {
		mmHardDeleteConvertedFileByFileUID.inspectFuncHardDeleteConvertedFileByFileUID(ctx, fileUID)
	}

	mm_params := RepositoryIMockHardDeleteConvertedFileByFileUIDParams{ctx, fileUID}

	// Record call args
	mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.mutex.Lock()
	mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.callArgs = append(mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.callArgs, &mm_params)
	mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.mutex.Unlock()

	for _, e := range mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockHardDeleteConvertedFileByFileUIDParams{ctx, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHardDeleteConvertedFileByFileUID.t.Errorf("RepositoryIMock.HardDeleteConvertedFileByFileUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmHardDeleteConvertedFileByFileUID.t.Errorf("RepositoryIMock.HardDeleteConvertedFileByFileUID got unexpected parameter fileUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHardDeleteConvertedFileByFileUID.t.Errorf("RepositoryIMock.HardDeleteConvertedFileByFileUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmHardDeleteConvertedFileByFileUID.t.Fatal("No results are set for the RepositoryIMock.HardDeleteConvertedFileByFileUID")
		}
		return (*mm_results).err
	}
	if mmHardDeleteConvertedFileByFileUID.funcHardDeleteConvertedFileByFileUID != nil {
		return mmHardDeleteConvertedFileByFileUID.funcHardDeleteConvertedFileByFileUID(ctx, fileUID)
	}
	mmHardDeleteConvertedFileByFileUID.t.Fatalf("Unexpected call to RepositoryIMock.HardDeleteConvertedFileByFileUID. %v %v", ctx, fileUID)
	return
}

// HardDeleteConvertedFileByFileUIDAfterCounter returns a count of finished RepositoryIMock.HardDeleteConvertedFileByFileUID invocations
func (mmHardDeleteConvertedFileByFileUID *RepositoryIMock) HardDeleteConvertedFileByFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteConvertedFileByFileUID.afterHardDeleteConvertedFileByFileUIDCounter)
}

// HardDeleteConvertedFileByFileUIDBeforeCounter returns a count of RepositoryIMock.HardDeleteConvertedFileByFileUID invocations
func (mmHardDeleteConvertedFileByFileUID *RepositoryIMock) HardDeleteConvertedFileByFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteConvertedFileByFileUID.beforeHardDeleteConvertedFileByFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.HardDeleteConvertedFileByFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHardDeleteConvertedFileByFileUID *mRepositoryIMockHardDeleteConvertedFileByFileUID) Calls() []*RepositoryIMockHardDeleteConvertedFileByFileUIDParams {
	mmHardDeleteConvertedFileByFileUID.mutex.RLock()

	argCopy := make([]*RepositoryIMockHardDeleteConvertedFileByFileUIDParams, len(mmHardDeleteConvertedFileByFileUID.callArgs))
	copy(argCopy, mmHardDeleteConvertedFileByFileUID.callArgs)

	mmHardDeleteConvertedFileByFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockHardDeleteConvertedFileByFileUIDDone returns true if the count of the HardDeleteConvertedFileByFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockHardDeleteConvertedFileByFileUIDDone() bool {
	for _, e := range m.HardDeleteConvertedFileByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HardDeleteConvertedFileByFileUIDMock.invocationsDone()
}

// MinimockHardDeleteConvertedFileByFileUIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockHardDeleteConvertedFileByFileUIDInspect() {
	for _, e := range m.HardDeleteConvertedFileByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.HardDeleteConvertedFileByFileUID with params: %#v", *e.params)
		}
	}

	afterHardDeleteConvertedFileByFileUIDCounter := mm_atomic.LoadUint64(&m.afterHardDeleteConvertedFileByFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HardDeleteConvertedFileByFileUIDMock.defaultExpectation != nil && afterHardDeleteConvertedFileByFileUIDCounter < 1 {
		if m.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.HardDeleteConvertedFileByFileUID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.HardDeleteConvertedFileByFileUID with params: %#v", *m.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHardDeleteConvertedFileByFileUID != nil && afterHardDeleteConvertedFileByFileUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.HardDeleteConvertedFileByFileUID")
	}

	if !m.HardDeleteConvertedFileByFileUIDMock.invocationsDone() && afterHardDeleteConvertedFileByFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.HardDeleteConvertedFileByFileUID but found %d calls",
			mm_atomic.LoadUint64(&m.HardDeleteConvertedFileByFileUIDMock.expectedInvocations), afterHardDeleteConvertedFileByFileUIDCounter)
	}
}

type mRepositoryIMockHardDeleteEmbeddingsByKbFileUID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockHardDeleteEmbeddingsByKbFileUIDExpectation
	expectations       []*RepositoryIMockHardDeleteEmbeddingsByKbFileUIDExpectation

	callArgs []*RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockHardDeleteEmbeddingsByKbFileUIDExpectation specifies expectation struct of the RepositoryI.HardDeleteEmbeddingsByKbFileUID
type RepositoryIMockHardDeleteEmbeddingsByKbFileUIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParams
	paramPtrs *RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParamPtrs
	results   *RepositoryIMockHardDeleteEmbeddingsByKbFileUIDResults
	Counter   uint64
}

// RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParams contains parameters of the RepositoryI.HardDeleteEmbeddingsByKbFileUID
type RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParams struct {
	ctx       context.Context
	kbFileUID uuid.UUID
}

// RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParamPtrs contains pointers to parameters of the RepositoryI.HardDeleteEmbeddingsByKbFileUID
type RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParamPtrs struct {
	ctx       *context.Context
	kbFileUID *uuid.UUID
}

// RepositoryIMockHardDeleteEmbeddingsByKbFileUIDResults contains results of the RepositoryI.HardDeleteEmbeddingsByKbFileUID
type RepositoryIMockHardDeleteEmbeddingsByKbFileUIDResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.HardDeleteEmbeddingsByKbFileUID
func (mmHardDeleteEmbeddingsByKbFileUID *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID) Expect(ctx context.Context, kbFileUID uuid.UUID) *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID {
	if mmHardDeleteEmbeddingsByKbFileUID.mock.funcHardDeleteEmbeddingsByKbFileUID != nil {
		mmHardDeleteEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbFileUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation = &RepositoryIMockHardDeleteEmbeddingsByKbFileUIDExpectation{}
	}

	if mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation.paramPtrs != nil {
		mmHardDeleteEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbFileUID mock is already set by ExpectParams functions")
	}

	mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation.params = &RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParams{ctx, kbFileUID}
	for _, e := range mmHardDeleteEmbeddingsByKbFileUID.expectations {
		if minimock.Equal(e.params, mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation.params) {
			mmHardDeleteEmbeddingsByKbFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation.params)
		}
	}

	return mmHardDeleteEmbeddingsByKbFileUID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.HardDeleteEmbeddingsByKbFileUID
func (mmHardDeleteEmbeddingsByKbFileUID *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID {
	if mmHardDeleteEmbeddingsByKbFileUID.mock.funcHardDeleteEmbeddingsByKbFileUID != nil {
		mmHardDeleteEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbFileUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation = &RepositoryIMockHardDeleteEmbeddingsByKbFileUIDExpectation{}
	}

	if mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation.params != nil {
		mmHardDeleteEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbFileUID mock is already set by Expect")
	}

	if mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation.paramPtrs = &RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParamPtrs{}
	}
	mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmHardDeleteEmbeddingsByKbFileUID
}

// ExpectKbFileUIDParam2 sets up expected param kbFileUID for RepositoryI.HardDeleteEmbeddingsByKbFileUID
func (mmHardDeleteEmbeddingsByKbFileUID *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID) ExpectKbFileUIDParam2(kbFileUID uuid.UUID) *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID {
	if mmHardDeleteEmbeddingsByKbFileUID.mock.funcHardDeleteEmbeddingsByKbFileUID != nil {
		mmHardDeleteEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbFileUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation = &RepositoryIMockHardDeleteEmbeddingsByKbFileUIDExpectation{}
	}

	if mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation.params != nil {
		mmHardDeleteEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbFileUID mock is already set by Expect")
	}

	if mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation.paramPtrs = &RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParamPtrs{}
	}
	mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation.paramPtrs.kbFileUID = &kbFileUID

	return mmHardDeleteEmbeddingsByKbFileUID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.HardDeleteEmbeddingsByKbFileUID
func (mmHardDeleteEmbeddingsByKbFileUID *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID) Inspect(f func(ctx context.Context, kbFileUID uuid.UUID)) *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID {
	if mmHardDeleteEmbeddingsByKbFileUID.mock.inspectFuncHardDeleteEmbeddingsByKbFileUID != nil {
		mmHardDeleteEmbeddingsByKbFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.HardDeleteEmbeddingsByKbFileUID")
	}

	mmHardDeleteEmbeddingsByKbFileUID.mock.inspectFuncHardDeleteEmbeddingsByKbFileUID = f

	return mmHardDeleteEmbeddingsByKbFileUID
}

// Return sets up results that will be returned by RepositoryI.HardDeleteEmbeddingsByKbFileUID
func (mmHardDeleteEmbeddingsByKbFileUID *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID) Return(err error) *RepositoryIMock {
	if mmHardDeleteEmbeddingsByKbFileUID.mock.funcHardDeleteEmbeddingsByKbFileUID != nil {
		mmHardDeleteEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbFileUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation = &RepositoryIMockHardDeleteEmbeddingsByKbFileUIDExpectation{mock: mmHardDeleteEmbeddingsByKbFileUID.mock}
	}
	mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation.results = &RepositoryIMockHardDeleteEmbeddingsByKbFileUIDResults{err}
	return mmHardDeleteEmbeddingsByKbFileUID.mock
}

// Set uses given function f to mock the RepositoryI.HardDeleteEmbeddingsByKbFileUID method
func (mmHardDeleteEmbeddingsByKbFileUID *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID) Set(f func(ctx context.Context, kbFileUID uuid.UUID) (err error)) *RepositoryIMock {
	if mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation != nil {
		mmHardDeleteEmbeddingsByKbFileUID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.HardDeleteEmbeddingsByKbFileUID method")
	}

	if len(mmHardDeleteEmbeddingsByKbFileUID.expectations) > 0 {
		mmHardDeleteEmbeddingsByKbFileUID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.HardDeleteEmbeddingsByKbFileUID method")
	}

	mmHardDeleteEmbeddingsByKbFileUID.mock.funcHardDeleteEmbeddingsByKbFileUID = f
	return mmHardDeleteEmbeddingsByKbFileUID.mock
}

// When sets expectation for the RepositoryI.HardDeleteEmbeddingsByKbFileUID which will trigger the result defined by the following
// Then helper
func (mmHardDeleteEmbeddingsByKbFileUID *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID) When(ctx context.Context, kbFileUID uuid.UUID) *RepositoryIMockHardDeleteEmbeddingsByKbFileUIDExpectation {
	if mmHardDeleteEmbeddingsByKbFileUID.mock.funcHardDeleteEmbeddingsByKbFileUID != nil {
		mmHardDeleteEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbFileUID mock is already set by Set")
	}

	expectation := &RepositoryIMockHardDeleteEmbeddingsByKbFileUIDExpectation{
		mock:   mmHardDeleteEmbeddingsByKbFileUID.mock,
		params: &RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParams{ctx, kbFileUID},
	}
	mmHardDeleteEmbeddingsByKbFileUID.expectations = append(mmHardDeleteEmbeddingsByKbFileUID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.HardDeleteEmbeddingsByKbFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockHardDeleteEmbeddingsByKbFileUIDExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockHardDeleteEmbeddingsByKbFileUIDResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.HardDeleteEmbeddingsByKbFileUID should be invoked
func (mmHardDeleteEmbeddingsByKbFileUID *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID) Times(n uint64) *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID {
	if n == 0 {
		mmHardDeleteEmbeddingsByKbFileUID.mock.t.Fatalf("Times of RepositoryIMock.HardDeleteEmbeddingsByKbFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHardDeleteEmbeddingsByKbFileUID.expectedInvocations, n)
	return mmHardDeleteEmbeddingsByKbFileUID
}

func (mmHardDeleteEmbeddingsByKbFileUID *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID) invocationsDone() bool {
	if len(mmHardDeleteEmbeddingsByKbFileUID.expectations) == 0 && mmHardDeleteEmbeddingsByKbFileUID.defaultExpectation == nil && mmHardDeleteEmbeddingsByKbFileUID.mock.funcHardDeleteEmbeddingsByKbFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKbFileUID.mock.afterHardDeleteEmbeddingsByKbFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKbFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HardDeleteEmbeddingsByKbFileUID implements repository.RepositoryI
func (mmHardDeleteEmbeddingsByKbFileUID *RepositoryIMock) HardDeleteEmbeddingsByKbFileUID(ctx context.Context, kbFileUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmHardDeleteEmbeddingsByKbFileUID.beforeHardDeleteEmbeddingsByKbFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmHardDeleteEmbeddingsByKbFileUID.afterHardDeleteEmbeddingsByKbFileUIDCounter, 1)

	if mmHardDeleteEmbeddingsByKbFileUID.inspectFuncHardDeleteEmbeddingsByKbFileUID != nil {
		mmHardDeleteEmbeddingsByKbFileUID.inspectFuncHardDeleteEmbeddingsByKbFileUID(ctx, kbFileUID)
	}

	mm_params := RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParams{ctx, kbFileUID}

	// Record call args
	mmHardDeleteEmbeddingsByKbFileUID.HardDeleteEmbeddingsByKbFileUIDMock.mutex.Lock()
	mmHardDeleteEmbeddingsByKbFileUID.HardDeleteEmbeddingsByKbFileUIDMock.callArgs = append(mmHardDeleteEmbeddingsByKbFileUID.HardDeleteEmbeddingsByKbFileUIDMock.callArgs, &mm_params)
	mmHardDeleteEmbeddingsByKbFileUID.HardDeleteEmbeddingsByKbFileUIDMock.mutex.Unlock()

	for _, e := range mmHardDeleteEmbeddingsByKbFileUID.HardDeleteEmbeddingsByKbFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHardDeleteEmbeddingsByKbFileUID.HardDeleteEmbeddingsByKbFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHardDeleteEmbeddingsByKbFileUID.HardDeleteEmbeddingsByKbFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmHardDeleteEmbeddingsByKbFileUID.HardDeleteEmbeddingsByKbFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmHardDeleteEmbeddingsByKbFileUID.HardDeleteEmbeddingsByKbFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParams{ctx, kbFileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHardDeleteEmbeddingsByKbFileUID.t.Errorf("RepositoryIMock.HardDeleteEmbeddingsByKbFileUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbFileUID != nil && !minimock.Equal(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID) {
				mmHardDeleteEmbeddingsByKbFileUID.t.Errorf("RepositoryIMock.HardDeleteEmbeddingsByKbFileUID got unexpected parameter kbFileUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbFileUID, mm_got.kbFileUID, minimock.Diff(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHardDeleteEmbeddingsByKbFileUID.t.Errorf("RepositoryIMock.HardDeleteEmbeddingsByKbFileUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHardDeleteEmbeddingsByKbFileUID.HardDeleteEmbeddingsByKbFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmHardDeleteEmbeddingsByKbFileUID.t.Fatal("No results are set for the RepositoryIMock.HardDeleteEmbeddingsByKbFileUID")
		}
		return (*mm_results).err
	}
	if mmHardDeleteEmbeddingsByKbFileUID.funcHardDeleteEmbeddingsByKbFileUID != nil {
		return mmHardDeleteEmbeddingsByKbFileUID.funcHardDeleteEmbeddingsByKbFileUID(ctx, kbFileUID)
	}
	mmHardDeleteEmbeddingsByKbFileUID.t.Fatalf("Unexpected call to RepositoryIMock.HardDeleteEmbeddingsByKbFileUID. %v %v", ctx, kbFileUID)
	return
}

// HardDeleteEmbeddingsByKbFileUIDAfterCounter returns a count of finished RepositoryIMock.HardDeleteEmbeddingsByKbFileUID invocations
func (mmHardDeleteEmbeddingsByKbFileUID *RepositoryIMock) HardDeleteEmbeddingsByKbFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKbFileUID.afterHardDeleteEmbeddingsByKbFileUIDCounter)
}

// HardDeleteEmbeddingsByKbFileUIDBeforeCounter returns a count of RepositoryIMock.HardDeleteEmbeddingsByKbFileUID invocations
func (mmHardDeleteEmbeddingsByKbFileUID *RepositoryIMock) HardDeleteEmbeddingsByKbFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKbFileUID.beforeHardDeleteEmbeddingsByKbFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.HardDeleteEmbeddingsByKbFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHardDeleteEmbeddingsByKbFileUID *mRepositoryIMockHardDeleteEmbeddingsByKbFileUID) Calls() []*RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParams {
	mmHardDeleteEmbeddingsByKbFileUID.mutex.RLock()

	argCopy := make([]*RepositoryIMockHardDeleteEmbeddingsByKbFileUIDParams, len(mmHardDeleteEmbeddingsByKbFileUID.callArgs))
	copy(argCopy, mmHardDeleteEmbeddingsByKbFileUID.callArgs)

	mmHardDeleteEmbeddingsByKbFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockHardDeleteEmbeddingsByKbFileUIDDone returns true if the count of the HardDeleteEmbeddingsByKbFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockHardDeleteEmbeddingsByKbFileUIDDone() bool {
	for _, e := range m.HardDeleteEmbeddingsByKbFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HardDeleteEmbeddingsByKbFileUIDMock.invocationsDone()
}

// MinimockHardDeleteEmbeddingsByKbFileUIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockHardDeleteEmbeddingsByKbFileUIDInspect() {
	for _, e := range m.HardDeleteEmbeddingsByKbFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.HardDeleteEmbeddingsByKbFileUID with params: %#v", *e.params)
		}
	}

	afterHardDeleteEmbeddingsByKbFileUIDCounter := mm_atomic.LoadUint64(&m.afterHardDeleteEmbeddingsByKbFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HardDeleteEmbeddingsByKbFileUIDMock.defaultExpectation != nil && afterHardDeleteEmbeddingsByKbFileUIDCounter < 1 {
		if m.HardDeleteEmbeddingsByKbFileUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.HardDeleteEmbeddingsByKbFileUID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.HardDeleteEmbeddingsByKbFileUID with params: %#v", *m.HardDeleteEmbeddingsByKbFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHardDeleteEmbeddingsByKbFileUID != nil && afterHardDeleteEmbeddingsByKbFileUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.HardDeleteEmbeddingsByKbFileUID")
	}

	if !m.HardDeleteEmbeddingsByKbFileUIDMock.invocationsDone() && afterHardDeleteEmbeddingsByKbFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.HardDeleteEmbeddingsByKbFileUID but found %d calls",
			mm_atomic.LoadUint64(&m.HardDeleteEmbeddingsByKbFileUIDMock.expectedInvocations), afterHardDeleteEmbeddingsByKbFileUIDCounter)
	}
}

type mRepositoryIMockHardDeleteEmbeddingsByKbUID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockHardDeleteEmbeddingsByKbUIDExpectation
	expectations       []*RepositoryIMockHardDeleteEmbeddingsByKbUIDExpectation

	callArgs []*RepositoryIMockHardDeleteEmbeddingsByKbUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockHardDeleteEmbeddingsByKbUIDExpectation specifies expectation struct of the RepositoryI.HardDeleteEmbeddingsByKbUID
type RepositoryIMockHardDeleteEmbeddingsByKbUIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockHardDeleteEmbeddingsByKbUIDParams
	paramPtrs *RepositoryIMockHardDeleteEmbeddingsByKbUIDParamPtrs
	results   *RepositoryIMockHardDeleteEmbeddingsByKbUIDResults
	Counter   uint64
}

// RepositoryIMockHardDeleteEmbeddingsByKbUIDParams contains parameters of the RepositoryI.HardDeleteEmbeddingsByKbUID
type RepositoryIMockHardDeleteEmbeddingsByKbUIDParams struct {
	ctx   context.Context
	kbUID uuid.UUID
}

// RepositoryIMockHardDeleteEmbeddingsByKbUIDParamPtrs contains pointers to parameters of the RepositoryI.HardDeleteEmbeddingsByKbUID
type RepositoryIMockHardDeleteEmbeddingsByKbUIDParamPtrs struct {
	ctx   *context.Context
	kbUID *uuid.UUID
}

// RepositoryIMockHardDeleteEmbeddingsByKbUIDResults contains results of the RepositoryI.HardDeleteEmbeddingsByKbUID
type RepositoryIMockHardDeleteEmbeddingsByKbUIDResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.HardDeleteEmbeddingsByKbUID
func (mmHardDeleteEmbeddingsByKbUID *mRepositoryIMockHardDeleteEmbeddingsByKbUID) Expect(ctx context.Context, kbUID uuid.UUID) *mRepositoryIMockHardDeleteEmbeddingsByKbUID {
	if mmHardDeleteEmbeddingsByKbUID.mock.funcHardDeleteEmbeddingsByKbUID != nil {
		mmHardDeleteEmbeddingsByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKbUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKbUID.defaultExpectation = &RepositoryIMockHardDeleteEmbeddingsByKbUIDExpectation{}
	}

	if mmHardDeleteEmbeddingsByKbUID.defaultExpectation.paramPtrs != nil {
		mmHardDeleteEmbeddingsByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbUID mock is already set by ExpectParams functions")
	}

	mmHardDeleteEmbeddingsByKbUID.defaultExpectation.params = &RepositoryIMockHardDeleteEmbeddingsByKbUIDParams{ctx, kbUID}
	for _, e := range mmHardDeleteEmbeddingsByKbUID.expectations {
		if minimock.Equal(e.params, mmHardDeleteEmbeddingsByKbUID.defaultExpectation.params) {
			mmHardDeleteEmbeddingsByKbUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHardDeleteEmbeddingsByKbUID.defaultExpectation.params)
		}
	}

	return mmHardDeleteEmbeddingsByKbUID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.HardDeleteEmbeddingsByKbUID
func (mmHardDeleteEmbeddingsByKbUID *mRepositoryIMockHardDeleteEmbeddingsByKbUID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockHardDeleteEmbeddingsByKbUID {
	if mmHardDeleteEmbeddingsByKbUID.mock.funcHardDeleteEmbeddingsByKbUID != nil {
		mmHardDeleteEmbeddingsByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKbUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKbUID.defaultExpectation = &RepositoryIMockHardDeleteEmbeddingsByKbUIDExpectation{}
	}

	if mmHardDeleteEmbeddingsByKbUID.defaultExpectation.params != nil {
		mmHardDeleteEmbeddingsByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbUID mock is already set by Expect")
	}

	if mmHardDeleteEmbeddingsByKbUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteEmbeddingsByKbUID.defaultExpectation.paramPtrs = &RepositoryIMockHardDeleteEmbeddingsByKbUIDParamPtrs{}
	}
	mmHardDeleteEmbeddingsByKbUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmHardDeleteEmbeddingsByKbUID
}

// ExpectKbUIDParam2 sets up expected param kbUID for RepositoryI.HardDeleteEmbeddingsByKbUID
func (mmHardDeleteEmbeddingsByKbUID *mRepositoryIMockHardDeleteEmbeddingsByKbUID) ExpectKbUIDParam2(kbUID uuid.UUID) *mRepositoryIMockHardDeleteEmbeddingsByKbUID {
	if mmHardDeleteEmbeddingsByKbUID.mock.funcHardDeleteEmbeddingsByKbUID != nil {
		mmHardDeleteEmbeddingsByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKbUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKbUID.defaultExpectation = &RepositoryIMockHardDeleteEmbeddingsByKbUIDExpectation{}
	}

	if mmHardDeleteEmbeddingsByKbUID.defaultExpectation.params != nil {
		mmHardDeleteEmbeddingsByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbUID mock is already set by Expect")
	}

	if mmHardDeleteEmbeddingsByKbUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteEmbeddingsByKbUID.defaultExpectation.paramPtrs = &RepositoryIMockHardDeleteEmbeddingsByKbUIDParamPtrs{}
	}
	mmHardDeleteEmbeddingsByKbUID.defaultExpectation.paramPtrs.kbUID = &kbUID

	return mmHardDeleteEmbeddingsByKbUID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.HardDeleteEmbeddingsByKbUID
func (mmHardDeleteEmbeddingsByKbUID *mRepositoryIMockHardDeleteEmbeddingsByKbUID) Inspect(f func(ctx context.Context, kbUID uuid.UUID)) *mRepositoryIMockHardDeleteEmbeddingsByKbUID {
	if mmHardDeleteEmbeddingsByKbUID.mock.inspectFuncHardDeleteEmbeddingsByKbUID != nil {
		mmHardDeleteEmbeddingsByKbUID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.HardDeleteEmbeddingsByKbUID")
	}

	mmHardDeleteEmbeddingsByKbUID.mock.inspectFuncHardDeleteEmbeddingsByKbUID = f

	return mmHardDeleteEmbeddingsByKbUID
}

// Return sets up results that will be returned by RepositoryI.HardDeleteEmbeddingsByKbUID
func (mmHardDeleteEmbeddingsByKbUID *mRepositoryIMockHardDeleteEmbeddingsByKbUID) Return(err error) *RepositoryIMock {
	if mmHardDeleteEmbeddingsByKbUID.mock.funcHardDeleteEmbeddingsByKbUID != nil {
		mmHardDeleteEmbeddingsByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKbUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKbUID.defaultExpectation = &RepositoryIMockHardDeleteEmbeddingsByKbUIDExpectation{mock: mmHardDeleteEmbeddingsByKbUID.mock}
	}
	mmHardDeleteEmbeddingsByKbUID.defaultExpectation.results = &RepositoryIMockHardDeleteEmbeddingsByKbUIDResults{err}
	return mmHardDeleteEmbeddingsByKbUID.mock
}

// Set uses given function f to mock the RepositoryI.HardDeleteEmbeddingsByKbUID method
func (mmHardDeleteEmbeddingsByKbUID *mRepositoryIMockHardDeleteEmbeddingsByKbUID) Set(f func(ctx context.Context, kbUID uuid.UUID) (err error)) *RepositoryIMock {
	if mmHardDeleteEmbeddingsByKbUID.defaultExpectation != nil {
		mmHardDeleteEmbeddingsByKbUID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.HardDeleteEmbeddingsByKbUID method")
	}

	if len(mmHardDeleteEmbeddingsByKbUID.expectations) > 0 {
		mmHardDeleteEmbeddingsByKbUID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.HardDeleteEmbeddingsByKbUID method")
	}

	mmHardDeleteEmbeddingsByKbUID.mock.funcHardDeleteEmbeddingsByKbUID = f
	return mmHardDeleteEmbeddingsByKbUID.mock
}

// When sets expectation for the RepositoryI.HardDeleteEmbeddingsByKbUID which will trigger the result defined by the following
// Then helper
func (mmHardDeleteEmbeddingsByKbUID *mRepositoryIMockHardDeleteEmbeddingsByKbUID) When(ctx context.Context, kbUID uuid.UUID) *RepositoryIMockHardDeleteEmbeddingsByKbUIDExpectation {
	if mmHardDeleteEmbeddingsByKbUID.mock.funcHardDeleteEmbeddingsByKbUID != nil {
		mmHardDeleteEmbeddingsByKbUID.mock.t.Fatalf("RepositoryIMock.HardDeleteEmbeddingsByKbUID mock is already set by Set")
	}

	expectation := &RepositoryIMockHardDeleteEmbeddingsByKbUIDExpectation{
		mock:   mmHardDeleteEmbeddingsByKbUID.mock,
		params: &RepositoryIMockHardDeleteEmbeddingsByKbUIDParams{ctx, kbUID},
	}
	mmHardDeleteEmbeddingsByKbUID.expectations = append(mmHardDeleteEmbeddingsByKbUID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.HardDeleteEmbeddingsByKbUID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockHardDeleteEmbeddingsByKbUIDExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockHardDeleteEmbeddingsByKbUIDResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.HardDeleteEmbeddingsByKbUID should be invoked
func (mmHardDeleteEmbeddingsByKbUID *mRepositoryIMockHardDeleteEmbeddingsByKbUID) Times(n uint64) *mRepositoryIMockHardDeleteEmbeddingsByKbUID {
	if n == 0 {
		mmHardDeleteEmbeddingsByKbUID.mock.t.Fatalf("Times of RepositoryIMock.HardDeleteEmbeddingsByKbUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHardDeleteEmbeddingsByKbUID.expectedInvocations, n)
	return mmHardDeleteEmbeddingsByKbUID
}

func (mmHardDeleteEmbeddingsByKbUID *mRepositoryIMockHardDeleteEmbeddingsByKbUID) invocationsDone() bool {
	if len(mmHardDeleteEmbeddingsByKbUID.expectations) == 0 && mmHardDeleteEmbeddingsByKbUID.defaultExpectation == nil && mmHardDeleteEmbeddingsByKbUID.mock.funcHardDeleteEmbeddingsByKbUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKbUID.mock.afterHardDeleteEmbeddingsByKbUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKbUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HardDeleteEmbeddingsByKbUID implements repository.RepositoryI
func (mmHardDeleteEmbeddingsByKbUID *RepositoryIMock) HardDeleteEmbeddingsByKbUID(ctx context.Context, kbUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmHardDeleteEmbeddingsByKbUID.beforeHardDeleteEmbeddingsByKbUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmHardDeleteEmbeddingsByKbUID.afterHardDeleteEmbeddingsByKbUIDCounter, 1)

	if mmHardDeleteEmbeddingsByKbUID.inspectFuncHardDeleteEmbeddingsByKbUID != nil {
		mmHardDeleteEmbeddingsByKbUID.inspectFuncHardDeleteEmbeddingsByKbUID(ctx, kbUID)
	}

	mm_params := RepositoryIMockHardDeleteEmbeddingsByKbUIDParams{ctx, kbUID}

	// Record call args
	mmHardDeleteEmbeddingsByKbUID.HardDeleteEmbeddingsByKbUIDMock.mutex.Lock()
	mmHardDeleteEmbeddingsByKbUID.HardDeleteEmbeddingsByKbUIDMock.callArgs = append(mmHardDeleteEmbeddingsByKbUID.HardDeleteEmbeddingsByKbUIDMock.callArgs, &mm_params)
	mmHardDeleteEmbeddingsByKbUID.HardDeleteEmbeddingsByKbUIDMock.mutex.Unlock()

	for _, e := range mmHardDeleteEmbeddingsByKbUID.HardDeleteEmbeddingsByKbUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHardDeleteEmbeddingsByKbUID.HardDeleteEmbeddingsByKbUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHardDeleteEmbeddingsByKbUID.HardDeleteEmbeddingsByKbUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmHardDeleteEmbeddingsByKbUID.HardDeleteEmbeddingsByKbUIDMock.defaultExpectation.params
		mm_want_ptrs := mmHardDeleteEmbeddingsByKbUID.HardDeleteEmbeddingsByKbUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockHardDeleteEmbeddingsByKbUIDParams{ctx, kbUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHardDeleteEmbeddingsByKbUID.t.Errorf("RepositoryIMock.HardDeleteEmbeddingsByKbUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmHardDeleteEmbeddingsByKbUID.t.Errorf("RepositoryIMock.HardDeleteEmbeddingsByKbUID got unexpected parameter kbUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHardDeleteEmbeddingsByKbUID.t.Errorf("RepositoryIMock.HardDeleteEmbeddingsByKbUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHardDeleteEmbeddingsByKbUID.HardDeleteEmbeddingsByKbUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmHardDeleteEmbeddingsByKbUID.t.Fatal("No results are set for the RepositoryIMock.HardDeleteEmbeddingsByKbUID")
		}
		return (*mm_results).err
	}
	if mmHardDeleteEmbeddingsByKbUID.funcHardDeleteEmbeddingsByKbUID != nil {
		return mmHardDeleteEmbeddingsByKbUID.funcHardDeleteEmbeddingsByKbUID(ctx, kbUID)
	}
	mmHardDeleteEmbeddingsByKbUID.t.Fatalf("Unexpected call to RepositoryIMock.HardDeleteEmbeddingsByKbUID. %v %v", ctx, kbUID)
	return
}

// HardDeleteEmbeddingsByKbUIDAfterCounter returns a count of finished RepositoryIMock.HardDeleteEmbeddingsByKbUID invocations
func (mmHardDeleteEmbeddingsByKbUID *RepositoryIMock) HardDeleteEmbeddingsByKbUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKbUID.afterHardDeleteEmbeddingsByKbUIDCounter)
}

// HardDeleteEmbeddingsByKbUIDBeforeCounter returns a count of RepositoryIMock.HardDeleteEmbeddingsByKbUID invocations
func (mmHardDeleteEmbeddingsByKbUID *RepositoryIMock) HardDeleteEmbeddingsByKbUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKbUID.beforeHardDeleteEmbeddingsByKbUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.HardDeleteEmbeddingsByKbUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHardDeleteEmbeddingsByKbUID *mRepositoryIMockHardDeleteEmbeddingsByKbUID) Calls() []*RepositoryIMockHardDeleteEmbeddingsByKbUIDParams {
	mmHardDeleteEmbeddingsByKbUID.mutex.RLock()

	argCopy := make([]*RepositoryIMockHardDeleteEmbeddingsByKbUIDParams, len(mmHardDeleteEmbeddingsByKbUID.callArgs))
	copy(argCopy, mmHardDeleteEmbeddingsByKbUID.callArgs)

	mmHardDeleteEmbeddingsByKbUID.mutex.RUnlock()

	return argCopy
}

// MinimockHardDeleteEmbeddingsByKbUIDDone returns true if the count of the HardDeleteEmbeddingsByKbUID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockHardDeleteEmbeddingsByKbUIDDone() bool {
	for _, e := range m.HardDeleteEmbeddingsByKbUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HardDeleteEmbeddingsByKbUIDMock.invocationsDone()
}

// MinimockHardDeleteEmbeddingsByKbUIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockHardDeleteEmbeddingsByKbUIDInspect() {
	for _, e := range m.HardDeleteEmbeddingsByKbUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.HardDeleteEmbeddingsByKbUID with params: %#v", *e.params)
		}
	}

	afterHardDeleteEmbeddingsByKbUIDCounter := mm_atomic.LoadUint64(&m.afterHardDeleteEmbeddingsByKbUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HardDeleteEmbeddingsByKbUIDMock.defaultExpectation != nil && afterHardDeleteEmbeddingsByKbUIDCounter < 1 {
		if m.HardDeleteEmbeddingsByKbUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.HardDeleteEmbeddingsByKbUID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.HardDeleteEmbeddingsByKbUID with params: %#v", *m.HardDeleteEmbeddingsByKbUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHardDeleteEmbeddingsByKbUID != nil && afterHardDeleteEmbeddingsByKbUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.HardDeleteEmbeddingsByKbUID")
	}

	if !m.HardDeleteEmbeddingsByKbUIDMock.invocationsDone() && afterHardDeleteEmbeddingsByKbUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.HardDeleteEmbeddingsByKbUID but found %d calls",
			mm_atomic.LoadUint64(&m.HardDeleteEmbeddingsByKbUIDMock.expectedInvocations), afterHardDeleteEmbeddingsByKbUIDCounter)
	}
}

type mRepositoryIMockIncreaseKnowledgeBaseUsage struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockIncreaseKnowledgeBaseUsageExpectation
	expectations       []*RepositoryIMockIncreaseKnowledgeBaseUsageExpectation

	callArgs []*RepositoryIMockIncreaseKnowledgeBaseUsageParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockIncreaseKnowledgeBaseUsageExpectation specifies expectation struct of the RepositoryI.IncreaseKnowledgeBaseUsage
type RepositoryIMockIncreaseKnowledgeBaseUsageExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockIncreaseKnowledgeBaseUsageParams
	paramPtrs *RepositoryIMockIncreaseKnowledgeBaseUsageParamPtrs
	results   *RepositoryIMockIncreaseKnowledgeBaseUsageResults
	Counter   uint64
}

// RepositoryIMockIncreaseKnowledgeBaseUsageParams contains parameters of the RepositoryI.IncreaseKnowledgeBaseUsage
type RepositoryIMockIncreaseKnowledgeBaseUsageParams struct {
	ctx    context.Context
	tx     *gorm.DB
	kbUID  string
	amount int
}

// RepositoryIMockIncreaseKnowledgeBaseUsageParamPtrs contains pointers to parameters of the RepositoryI.IncreaseKnowledgeBaseUsage
type RepositoryIMockIncreaseKnowledgeBaseUsageParamPtrs struct {
	ctx    *context.Context
	tx     **gorm.DB
	kbUID  *string
	amount *int
}

// RepositoryIMockIncreaseKnowledgeBaseUsageResults contains results of the RepositoryI.IncreaseKnowledgeBaseUsage
type RepositoryIMockIncreaseKnowledgeBaseUsageResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.IncreaseKnowledgeBaseUsage
func (mmIncreaseKnowledgeBaseUsage *mRepositoryIMockIncreaseKnowledgeBaseUsage) Expect(ctx context.Context, tx *gorm.DB, kbUID string, amount int) *mRepositoryIMockIncreaseKnowledgeBaseUsage {
	if mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryIMock.IncreaseKnowledgeBaseUsage mock is already set by Set")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation = &RepositoryIMockIncreaseKnowledgeBaseUsageExpectation{}
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryIMock.IncreaseKnowledgeBaseUsage mock is already set by ExpectParams functions")
	}

	mmIncreaseKnowledgeBaseUsage.defaultExpectation.params = &RepositoryIMockIncreaseKnowledgeBaseUsageParams{ctx, tx, kbUID, amount}
	for _, e := range mmIncreaseKnowledgeBaseUsage.expectations {
		if minimock.Equal(e.params, mmIncreaseKnowledgeBaseUsage.defaultExpectation.params) {
			mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIncreaseKnowledgeBaseUsage.defaultExpectation.params)
		}
	}

	return mmIncreaseKnowledgeBaseUsage
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.IncreaseKnowledgeBaseUsage
func (mmIncreaseKnowledgeBaseUsage *mRepositoryIMockIncreaseKnowledgeBaseUsage) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockIncreaseKnowledgeBaseUsage {
	if mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryIMock.IncreaseKnowledgeBaseUsage mock is already set by Set")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation = &RepositoryIMockIncreaseKnowledgeBaseUsageExpectation{}
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.params != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryIMock.IncreaseKnowledgeBaseUsage mock is already set by Expect")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs = &RepositoryIMockIncreaseKnowledgeBaseUsageParamPtrs{}
	}
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs.ctx = &ctx

	return mmIncreaseKnowledgeBaseUsage
}

// ExpectTxParam2 sets up expected param tx for RepositoryI.IncreaseKnowledgeBaseUsage
func (mmIncreaseKnowledgeBaseUsage *mRepositoryIMockIncreaseKnowledgeBaseUsage) ExpectTxParam2(tx *gorm.DB) *mRepositoryIMockIncreaseKnowledgeBaseUsage {
	if mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryIMock.IncreaseKnowledgeBaseUsage mock is already set by Set")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation = &RepositoryIMockIncreaseKnowledgeBaseUsageExpectation{}
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.params != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryIMock.IncreaseKnowledgeBaseUsage mock is already set by Expect")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs = &RepositoryIMockIncreaseKnowledgeBaseUsageParamPtrs{}
	}
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs.tx = &tx

	return mmIncreaseKnowledgeBaseUsage
}

// ExpectKbUIDParam3 sets up expected param kbUID for RepositoryI.IncreaseKnowledgeBaseUsage
func (mmIncreaseKnowledgeBaseUsage *mRepositoryIMockIncreaseKnowledgeBaseUsage) ExpectKbUIDParam3(kbUID string) *mRepositoryIMockIncreaseKnowledgeBaseUsage {
	if mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryIMock.IncreaseKnowledgeBaseUsage mock is already set by Set")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation = &RepositoryIMockIncreaseKnowledgeBaseUsageExpectation{}
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.params != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryIMock.IncreaseKnowledgeBaseUsage mock is already set by Expect")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs = &RepositoryIMockIncreaseKnowledgeBaseUsageParamPtrs{}
	}
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs.kbUID = &kbUID

	return mmIncreaseKnowledgeBaseUsage
}

// ExpectAmountParam4 sets up expected param amount for RepositoryI.IncreaseKnowledgeBaseUsage
func (mmIncreaseKnowledgeBaseUsage *mRepositoryIMockIncreaseKnowledgeBaseUsage) ExpectAmountParam4(amount int) *mRepositoryIMockIncreaseKnowledgeBaseUsage {
	if mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryIMock.IncreaseKnowledgeBaseUsage mock is already set by Set")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation = &RepositoryIMockIncreaseKnowledgeBaseUsageExpectation{}
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.params != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryIMock.IncreaseKnowledgeBaseUsage mock is already set by Expect")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs = &RepositoryIMockIncreaseKnowledgeBaseUsageParamPtrs{}
	}
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs.amount = &amount

	return mmIncreaseKnowledgeBaseUsage
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.IncreaseKnowledgeBaseUsage
func (mmIncreaseKnowledgeBaseUsage *mRepositoryIMockIncreaseKnowledgeBaseUsage) Inspect(f func(ctx context.Context, tx *gorm.DB, kbUID string, amount int)) *mRepositoryIMockIncreaseKnowledgeBaseUsage {
	if mmIncreaseKnowledgeBaseUsage.mock.inspectFuncIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.IncreaseKnowledgeBaseUsage")
	}

	mmIncreaseKnowledgeBaseUsage.mock.inspectFuncIncreaseKnowledgeBaseUsage = f

	return mmIncreaseKnowledgeBaseUsage
}

// Return sets up results that will be returned by RepositoryI.IncreaseKnowledgeBaseUsage
func (mmIncreaseKnowledgeBaseUsage *mRepositoryIMockIncreaseKnowledgeBaseUsage) Return(err error) *RepositoryIMock {
	if mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryIMock.IncreaseKnowledgeBaseUsage mock is already set by Set")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation = &RepositoryIMockIncreaseKnowledgeBaseUsageExpectation{mock: mmIncreaseKnowledgeBaseUsage.mock}
	}
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.results = &RepositoryIMockIncreaseKnowledgeBaseUsageResults{err}
	return mmIncreaseKnowledgeBaseUsage.mock
}

// Set uses given function f to mock the RepositoryI.IncreaseKnowledgeBaseUsage method
func (mmIncreaseKnowledgeBaseUsage *mRepositoryIMockIncreaseKnowledgeBaseUsage) Set(f func(ctx context.Context, tx *gorm.DB, kbUID string, amount int) (err error)) *RepositoryIMock {
	if mmIncreaseKnowledgeBaseUsage.defaultExpectation != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("Default expectation is already set for the RepositoryI.IncreaseKnowledgeBaseUsage method")
	}

	if len(mmIncreaseKnowledgeBaseUsage.expectations) > 0 {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("Some expectations are already set for the RepositoryI.IncreaseKnowledgeBaseUsage method")
	}

	mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage = f
	return mmIncreaseKnowledgeBaseUsage.mock
}

// When sets expectation for the RepositoryI.IncreaseKnowledgeBaseUsage which will trigger the result defined by the following
// Then helper
func (mmIncreaseKnowledgeBaseUsage *mRepositoryIMockIncreaseKnowledgeBaseUsage) When(ctx context.Context, tx *gorm.DB, kbUID string, amount int) *RepositoryIMockIncreaseKnowledgeBaseUsageExpectation {
	if mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryIMock.IncreaseKnowledgeBaseUsage mock is already set by Set")
	}

	expectation := &RepositoryIMockIncreaseKnowledgeBaseUsageExpectation{
		mock:   mmIncreaseKnowledgeBaseUsage.mock,
		params: &RepositoryIMockIncreaseKnowledgeBaseUsageParams{ctx, tx, kbUID, amount},
	}
	mmIncreaseKnowledgeBaseUsage.expectations = append(mmIncreaseKnowledgeBaseUsage.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.IncreaseKnowledgeBaseUsage return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockIncreaseKnowledgeBaseUsageExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockIncreaseKnowledgeBaseUsageResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.IncreaseKnowledgeBaseUsage should be invoked
func (mmIncreaseKnowledgeBaseUsage *mRepositoryIMockIncreaseKnowledgeBaseUsage) Times(n uint64) *mRepositoryIMockIncreaseKnowledgeBaseUsage {
	if n == 0 {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("Times of RepositoryIMock.IncreaseKnowledgeBaseUsage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIncreaseKnowledgeBaseUsage.expectedInvocations, n)
	return mmIncreaseKnowledgeBaseUsage
}

func (mmIncreaseKnowledgeBaseUsage *mRepositoryIMockIncreaseKnowledgeBaseUsage) invocationsDone() bool {
	if len(mmIncreaseKnowledgeBaseUsage.expectations) == 0 && mmIncreaseKnowledgeBaseUsage.defaultExpectation == nil && mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIncreaseKnowledgeBaseUsage.mock.afterIncreaseKnowledgeBaseUsageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIncreaseKnowledgeBaseUsage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IncreaseKnowledgeBaseUsage implements repository.RepositoryI
func (mmIncreaseKnowledgeBaseUsage *RepositoryIMock) IncreaseKnowledgeBaseUsage(ctx context.Context, tx *gorm.DB, kbUID string, amount int) (err error) {
	mm_atomic.AddUint64(&mmIncreaseKnowledgeBaseUsage.beforeIncreaseKnowledgeBaseUsageCounter, 1)
	defer mm_atomic.AddUint64(&mmIncreaseKnowledgeBaseUsage.afterIncreaseKnowledgeBaseUsageCounter, 1)

	if mmIncreaseKnowledgeBaseUsage.inspectFuncIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.inspectFuncIncreaseKnowledgeBaseUsage(ctx, tx, kbUID, amount)
	}

	mm_params := RepositoryIMockIncreaseKnowledgeBaseUsageParams{ctx, tx, kbUID, amount}

	// Record call args
	mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.mutex.Lock()
	mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.callArgs = append(mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.callArgs, &mm_params)
	mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.mutex.Unlock()

	for _, e := range mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation.Counter, 1)
		mm_want := mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation.params
		mm_want_ptrs := mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockIncreaseKnowledgeBaseUsageParams{ctx, tx, kbUID, amount}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmIncreaseKnowledgeBaseUsage.t.Errorf("RepositoryIMock.IncreaseKnowledgeBaseUsage got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tx != nil && !minimock.Equal(*mm_want_ptrs.tx, mm_got.tx) {
				mmIncreaseKnowledgeBaseUsage.t.Errorf("RepositoryIMock.IncreaseKnowledgeBaseUsage got unexpected parameter tx, want: %#v, got: %#v%s\n", *mm_want_ptrs.tx, mm_got.tx, minimock.Diff(*mm_want_ptrs.tx, mm_got.tx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmIncreaseKnowledgeBaseUsage.t.Errorf("RepositoryIMock.IncreaseKnowledgeBaseUsage got unexpected parameter kbUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.amount != nil && !minimock.Equal(*mm_want_ptrs.amount, mm_got.amount) {
				mmIncreaseKnowledgeBaseUsage.t.Errorf("RepositoryIMock.IncreaseKnowledgeBaseUsage got unexpected parameter amount, want: %#v, got: %#v%s\n", *mm_want_ptrs.amount, mm_got.amount, minimock.Diff(*mm_want_ptrs.amount, mm_got.amount))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIncreaseKnowledgeBaseUsage.t.Errorf("RepositoryIMock.IncreaseKnowledgeBaseUsage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation.results
		if mm_results == nil {
			mmIncreaseKnowledgeBaseUsage.t.Fatal("No results are set for the RepositoryIMock.IncreaseKnowledgeBaseUsage")
		}
		return (*mm_results).err
	}
	if mmIncreaseKnowledgeBaseUsage.funcIncreaseKnowledgeBaseUsage != nil {
		return mmIncreaseKnowledgeBaseUsage.funcIncreaseKnowledgeBaseUsage(ctx, tx, kbUID, amount)
	}
	mmIncreaseKnowledgeBaseUsage.t.Fatalf("Unexpected call to RepositoryIMock.IncreaseKnowledgeBaseUsage. %v %v %v %v", ctx, tx, kbUID, amount)
	return
}

// IncreaseKnowledgeBaseUsageAfterCounter returns a count of finished RepositoryIMock.IncreaseKnowledgeBaseUsage invocations
func (mmIncreaseKnowledgeBaseUsage *RepositoryIMock) IncreaseKnowledgeBaseUsageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIncreaseKnowledgeBaseUsage.afterIncreaseKnowledgeBaseUsageCounter)
}

// IncreaseKnowledgeBaseUsageBeforeCounter returns a count of RepositoryIMock.IncreaseKnowledgeBaseUsage invocations
func (mmIncreaseKnowledgeBaseUsage *RepositoryIMock) IncreaseKnowledgeBaseUsageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIncreaseKnowledgeBaseUsage.beforeIncreaseKnowledgeBaseUsageCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.IncreaseKnowledgeBaseUsage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIncreaseKnowledgeBaseUsage *mRepositoryIMockIncreaseKnowledgeBaseUsage) Calls() []*RepositoryIMockIncreaseKnowledgeBaseUsageParams {
	mmIncreaseKnowledgeBaseUsage.mutex.RLock()

	argCopy := make([]*RepositoryIMockIncreaseKnowledgeBaseUsageParams, len(mmIncreaseKnowledgeBaseUsage.callArgs))
	copy(argCopy, mmIncreaseKnowledgeBaseUsage.callArgs)

	mmIncreaseKnowledgeBaseUsage.mutex.RUnlock()

	return argCopy
}

// MinimockIncreaseKnowledgeBaseUsageDone returns true if the count of the IncreaseKnowledgeBaseUsage invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockIncreaseKnowledgeBaseUsageDone() bool {
	for _, e := range m.IncreaseKnowledgeBaseUsageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IncreaseKnowledgeBaseUsageMock.invocationsDone()
}

// MinimockIncreaseKnowledgeBaseUsageInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockIncreaseKnowledgeBaseUsageInspect() {
	for _, e := range m.IncreaseKnowledgeBaseUsageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.IncreaseKnowledgeBaseUsage with params: %#v", *e.params)
		}
	}

	afterIncreaseKnowledgeBaseUsageCounter := mm_atomic.LoadUint64(&m.afterIncreaseKnowledgeBaseUsageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IncreaseKnowledgeBaseUsageMock.defaultExpectation != nil && afterIncreaseKnowledgeBaseUsageCounter < 1 {
		if m.IncreaseKnowledgeBaseUsageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.IncreaseKnowledgeBaseUsage")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.IncreaseKnowledgeBaseUsage with params: %#v", *m.IncreaseKnowledgeBaseUsageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIncreaseKnowledgeBaseUsage != nil && afterIncreaseKnowledgeBaseUsageCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.IncreaseKnowledgeBaseUsage")
	}

	if !m.IncreaseKnowledgeBaseUsageMock.invocationsDone() && afterIncreaseKnowledgeBaseUsageCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.IncreaseKnowledgeBaseUsage but found %d calls",
			mm_atomic.LoadUint64(&m.IncreaseKnowledgeBaseUsageMock.expectedInvocations), afterIncreaseKnowledgeBaseUsageCounter)
	}
}

type mRepositoryIMockKnowledgeBaseFileTableName struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockKnowledgeBaseFileTableNameExpectation
	expectations       []*RepositoryIMockKnowledgeBaseFileTableNameExpectation

	expectedInvocations uint64
}

// RepositoryIMockKnowledgeBaseFileTableNameExpectation specifies expectation struct of the RepositoryI.KnowledgeBaseFileTableName
type RepositoryIMockKnowledgeBaseFileTableNameExpectation struct {
	mock *RepositoryIMock

	results *RepositoryIMockKnowledgeBaseFileTableNameResults
	Counter uint64
}

// RepositoryIMockKnowledgeBaseFileTableNameResults contains results of the RepositoryI.KnowledgeBaseFileTableName
type RepositoryIMockKnowledgeBaseFileTableNameResults struct {
	s1 string
}

// Expect sets up expected params for RepositoryI.KnowledgeBaseFileTableName
func (mmKnowledgeBaseFileTableName *mRepositoryIMockKnowledgeBaseFileTableName) Expect() *mRepositoryIMockKnowledgeBaseFileTableName {
	if mmKnowledgeBaseFileTableName.mock.funcKnowledgeBaseFileTableName != nil {
		mmKnowledgeBaseFileTableName.mock.t.Fatalf("RepositoryIMock.KnowledgeBaseFileTableName mock is already set by Set")
	}

	if mmKnowledgeBaseFileTableName.defaultExpectation == nil {
		mmKnowledgeBaseFileTableName.defaultExpectation = &RepositoryIMockKnowledgeBaseFileTableNameExpectation{}
	}

	return mmKnowledgeBaseFileTableName
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.KnowledgeBaseFileTableName
func (mmKnowledgeBaseFileTableName *mRepositoryIMockKnowledgeBaseFileTableName) Inspect(f func()) *mRepositoryIMockKnowledgeBaseFileTableName {
	if mmKnowledgeBaseFileTableName.mock.inspectFuncKnowledgeBaseFileTableName != nil {
		mmKnowledgeBaseFileTableName.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.KnowledgeBaseFileTableName")
	}

	mmKnowledgeBaseFileTableName.mock.inspectFuncKnowledgeBaseFileTableName = f

	return mmKnowledgeBaseFileTableName
}

// Return sets up results that will be returned by RepositoryI.KnowledgeBaseFileTableName
func (mmKnowledgeBaseFileTableName *mRepositoryIMockKnowledgeBaseFileTableName) Return(s1 string) *RepositoryIMock {
	if mmKnowledgeBaseFileTableName.mock.funcKnowledgeBaseFileTableName != nil {
		mmKnowledgeBaseFileTableName.mock.t.Fatalf("RepositoryIMock.KnowledgeBaseFileTableName mock is already set by Set")
	}

	if mmKnowledgeBaseFileTableName.defaultExpectation == nil {
		mmKnowledgeBaseFileTableName.defaultExpectation = &RepositoryIMockKnowledgeBaseFileTableNameExpectation{mock: mmKnowledgeBaseFileTableName.mock}
	}
	mmKnowledgeBaseFileTableName.defaultExpectation.results = &RepositoryIMockKnowledgeBaseFileTableNameResults{s1}
	return mmKnowledgeBaseFileTableName.mock
}

// Set uses given function f to mock the RepositoryI.KnowledgeBaseFileTableName method
func (mmKnowledgeBaseFileTableName *mRepositoryIMockKnowledgeBaseFileTableName) Set(f func() (s1 string)) *RepositoryIMock {
	if mmKnowledgeBaseFileTableName.defaultExpectation != nil {
		mmKnowledgeBaseFileTableName.mock.t.Fatalf("Default expectation is already set for the RepositoryI.KnowledgeBaseFileTableName method")
	}

	if len(mmKnowledgeBaseFileTableName.expectations) > 0 {
		mmKnowledgeBaseFileTableName.mock.t.Fatalf("Some expectations are already set for the RepositoryI.KnowledgeBaseFileTableName method")
	}

	mmKnowledgeBaseFileTableName.mock.funcKnowledgeBaseFileTableName = f
	return mmKnowledgeBaseFileTableName.mock
}

// Times sets number of times RepositoryI.KnowledgeBaseFileTableName should be invoked
func (mmKnowledgeBaseFileTableName *mRepositoryIMockKnowledgeBaseFileTableName) Times(n uint64) *mRepositoryIMockKnowledgeBaseFileTableName {
	if n == 0 {
		mmKnowledgeBaseFileTableName.mock.t.Fatalf("Times of RepositoryIMock.KnowledgeBaseFileTableName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmKnowledgeBaseFileTableName.expectedInvocations, n)
	return mmKnowledgeBaseFileTableName
}

func (mmKnowledgeBaseFileTableName *mRepositoryIMockKnowledgeBaseFileTableName) invocationsDone() bool {
	if len(mmKnowledgeBaseFileTableName.expectations) == 0 && mmKnowledgeBaseFileTableName.defaultExpectation == nil && mmKnowledgeBaseFileTableName.mock.funcKnowledgeBaseFileTableName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmKnowledgeBaseFileTableName.mock.afterKnowledgeBaseFileTableNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmKnowledgeBaseFileTableName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// KnowledgeBaseFileTableName implements repository.RepositoryI
func (mmKnowledgeBaseFileTableName *RepositoryIMock) KnowledgeBaseFileTableName() (s1 string) {
	mm_atomic.AddUint64(&mmKnowledgeBaseFileTableName.beforeKnowledgeBaseFileTableNameCounter, 1)
	defer mm_atomic.AddUint64(&mmKnowledgeBaseFileTableName.afterKnowledgeBaseFileTableNameCounter, 1)

	if mmKnowledgeBaseFileTableName.inspectFuncKnowledgeBaseFileTableName != nil {
		mmKnowledgeBaseFileTableName.inspectFuncKnowledgeBaseFileTableName()
	}

	if mmKnowledgeBaseFileTableName.KnowledgeBaseFileTableNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmKnowledgeBaseFileTableName.KnowledgeBaseFileTableNameMock.defaultExpectation.Counter, 1)

		mm_results := mmKnowledgeBaseFileTableName.KnowledgeBaseFileTableNameMock.defaultExpectation.results
		if mm_results == nil {
			mmKnowledgeBaseFileTableName.t.Fatal("No results are set for the RepositoryIMock.KnowledgeBaseFileTableName")
		}
		return (*mm_results).s1
	}
	if mmKnowledgeBaseFileTableName.funcKnowledgeBaseFileTableName != nil {
		return mmKnowledgeBaseFileTableName.funcKnowledgeBaseFileTableName()
	}
	mmKnowledgeBaseFileTableName.t.Fatalf("Unexpected call to RepositoryIMock.KnowledgeBaseFileTableName.")
	return
}

// KnowledgeBaseFileTableNameAfterCounter returns a count of finished RepositoryIMock.KnowledgeBaseFileTableName invocations
func (mmKnowledgeBaseFileTableName *RepositoryIMock) KnowledgeBaseFileTableNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmKnowledgeBaseFileTableName.afterKnowledgeBaseFileTableNameCounter)
}

// KnowledgeBaseFileTableNameBeforeCounter returns a count of RepositoryIMock.KnowledgeBaseFileTableName invocations
func (mmKnowledgeBaseFileTableName *RepositoryIMock) KnowledgeBaseFileTableNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmKnowledgeBaseFileTableName.beforeKnowledgeBaseFileTableNameCounter)
}

// MinimockKnowledgeBaseFileTableNameDone returns true if the count of the KnowledgeBaseFileTableName invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockKnowledgeBaseFileTableNameDone() bool {
	for _, e := range m.KnowledgeBaseFileTableNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.KnowledgeBaseFileTableNameMock.invocationsDone()
}

// MinimockKnowledgeBaseFileTableNameInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockKnowledgeBaseFileTableNameInspect() {
	for _, e := range m.KnowledgeBaseFileTableNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryIMock.KnowledgeBaseFileTableName")
		}
	}

	afterKnowledgeBaseFileTableNameCounter := mm_atomic.LoadUint64(&m.afterKnowledgeBaseFileTableNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.KnowledgeBaseFileTableNameMock.defaultExpectation != nil && afterKnowledgeBaseFileTableNameCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.KnowledgeBaseFileTableName")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcKnowledgeBaseFileTableName != nil && afterKnowledgeBaseFileTableNameCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.KnowledgeBaseFileTableName")
	}

	if !m.KnowledgeBaseFileTableNameMock.invocationsDone() && afterKnowledgeBaseFileTableNameCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.KnowledgeBaseFileTableName but found %d calls",
			mm_atomic.LoadUint64(&m.KnowledgeBaseFileTableNameMock.expectedInvocations), afterKnowledgeBaseFileTableNameCounter)
	}
}

type mRepositoryIMockListAllObjectURLs struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockListAllObjectURLsExpectation
	expectations       []*RepositoryIMockListAllObjectURLsExpectation

	callArgs []*RepositoryIMockListAllObjectURLsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockListAllObjectURLsExpectation specifies expectation struct of the RepositoryI.ListAllObjectURLs
type RepositoryIMockListAllObjectURLsExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockListAllObjectURLsParams
	paramPtrs *RepositoryIMockListAllObjectURLsParamPtrs
	results   *RepositoryIMockListAllObjectURLsResults
	Counter   uint64
}

// RepositoryIMockListAllObjectURLsParams contains parameters of the RepositoryI.ListAllObjectURLs
type RepositoryIMockListAllObjectURLsParams struct {
	ctx          context.Context
	namespaceUID uuid.UUID
	objectUID    uuid.UUID
}

// RepositoryIMockListAllObjectURLsParamPtrs contains pointers to parameters of the RepositoryI.ListAllObjectURLs
type RepositoryIMockListAllObjectURLsParamPtrs struct {
	ctx          *context.Context
	namespaceUID *uuid.UUID
	objectUID    *uuid.UUID
}

// RepositoryIMockListAllObjectURLsResults contains results of the RepositoryI.ListAllObjectURLs
type RepositoryIMockListAllObjectURLsResults struct {
	oa1 []mm_repository.ObjectURL
	err error
}

// Expect sets up expected params for RepositoryI.ListAllObjectURLs
func (mmListAllObjectURLs *mRepositoryIMockListAllObjectURLs) Expect(ctx context.Context, namespaceUID uuid.UUID, objectUID uuid.UUID) *mRepositoryIMockListAllObjectURLs {
	if mmListAllObjectURLs.mock.funcListAllObjectURLs != nil {
		mmListAllObjectURLs.mock.t.Fatalf("RepositoryIMock.ListAllObjectURLs mock is already set by Set")
	}

	if mmListAllObjectURLs.defaultExpectation == nil {
		mmListAllObjectURLs.defaultExpectation = &RepositoryIMockListAllObjectURLsExpectation{}
	}

	if mmListAllObjectURLs.defaultExpectation.paramPtrs != nil {
		mmListAllObjectURLs.mock.t.Fatalf("RepositoryIMock.ListAllObjectURLs mock is already set by ExpectParams functions")
	}

	mmListAllObjectURLs.defaultExpectation.params = &RepositoryIMockListAllObjectURLsParams{ctx, namespaceUID, objectUID}
	for _, e := range mmListAllObjectURLs.expectations {
		if minimock.Equal(e.params, mmListAllObjectURLs.defaultExpectation.params) {
			mmListAllObjectURLs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListAllObjectURLs.defaultExpectation.params)
		}
	}

	return mmListAllObjectURLs
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.ListAllObjectURLs
func (mmListAllObjectURLs *mRepositoryIMockListAllObjectURLs) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockListAllObjectURLs {
	if mmListAllObjectURLs.mock.funcListAllObjectURLs != nil {
		mmListAllObjectURLs.mock.t.Fatalf("RepositoryIMock.ListAllObjectURLs mock is already set by Set")
	}

	if mmListAllObjectURLs.defaultExpectation == nil {
		mmListAllObjectURLs.defaultExpectation = &RepositoryIMockListAllObjectURLsExpectation{}
	}

	if mmListAllObjectURLs.defaultExpectation.params != nil {
		mmListAllObjectURLs.mock.t.Fatalf("RepositoryIMock.ListAllObjectURLs mock is already set by Expect")
	}

	if mmListAllObjectURLs.defaultExpectation.paramPtrs == nil {
		mmListAllObjectURLs.defaultExpectation.paramPtrs = &RepositoryIMockListAllObjectURLsParamPtrs{}
	}
	mmListAllObjectURLs.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListAllObjectURLs
}

// ExpectNamespaceUIDParam2 sets up expected param namespaceUID for RepositoryI.ListAllObjectURLs
func (mmListAllObjectURLs *mRepositoryIMockListAllObjectURLs) ExpectNamespaceUIDParam2(namespaceUID uuid.UUID) *mRepositoryIMockListAllObjectURLs {
	if mmListAllObjectURLs.mock.funcListAllObjectURLs != nil {
		mmListAllObjectURLs.mock.t.Fatalf("RepositoryIMock.ListAllObjectURLs mock is already set by Set")
	}

	if mmListAllObjectURLs.defaultExpectation == nil {
		mmListAllObjectURLs.defaultExpectation = &RepositoryIMockListAllObjectURLsExpectation{}
	}

	if mmListAllObjectURLs.defaultExpectation.params != nil {
		mmListAllObjectURLs.mock.t.Fatalf("RepositoryIMock.ListAllObjectURLs mock is already set by Expect")
	}

	if mmListAllObjectURLs.defaultExpectation.paramPtrs == nil {
		mmListAllObjectURLs.defaultExpectation.paramPtrs = &RepositoryIMockListAllObjectURLsParamPtrs{}
	}
	mmListAllObjectURLs.defaultExpectation.paramPtrs.namespaceUID = &namespaceUID

	return mmListAllObjectURLs
}

// ExpectObjectUIDParam3 sets up expected param objectUID for RepositoryI.ListAllObjectURLs
func (mmListAllObjectURLs *mRepositoryIMockListAllObjectURLs) ExpectObjectUIDParam3(objectUID uuid.UUID) *mRepositoryIMockListAllObjectURLs {
	if mmListAllObjectURLs.mock.funcListAllObjectURLs != nil {
		mmListAllObjectURLs.mock.t.Fatalf("RepositoryIMock.ListAllObjectURLs mock is already set by Set")
	}

	if mmListAllObjectURLs.defaultExpectation == nil {
		mmListAllObjectURLs.defaultExpectation = &RepositoryIMockListAllObjectURLsExpectation{}
	}

	if mmListAllObjectURLs.defaultExpectation.params != nil {
		mmListAllObjectURLs.mock.t.Fatalf("RepositoryIMock.ListAllObjectURLs mock is already set by Expect")
	}

	if mmListAllObjectURLs.defaultExpectation.paramPtrs == nil {
		mmListAllObjectURLs.defaultExpectation.paramPtrs = &RepositoryIMockListAllObjectURLsParamPtrs{}
	}
	mmListAllObjectURLs.defaultExpectation.paramPtrs.objectUID = &objectUID

	return mmListAllObjectURLs
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.ListAllObjectURLs
func (mmListAllObjectURLs *mRepositoryIMockListAllObjectURLs) Inspect(f func(ctx context.Context, namespaceUID uuid.UUID, objectUID uuid.UUID)) *mRepositoryIMockListAllObjectURLs {
	if mmListAllObjectURLs.mock.inspectFuncListAllObjectURLs != nil {
		mmListAllObjectURLs.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.ListAllObjectURLs")
	}

	mmListAllObjectURLs.mock.inspectFuncListAllObjectURLs = f

	return mmListAllObjectURLs
}

// Return sets up results that will be returned by RepositoryI.ListAllObjectURLs
func (mmListAllObjectURLs *mRepositoryIMockListAllObjectURLs) Return(oa1 []mm_repository.ObjectURL, err error) *RepositoryIMock {
	if mmListAllObjectURLs.mock.funcListAllObjectURLs != nil {
		mmListAllObjectURLs.mock.t.Fatalf("RepositoryIMock.ListAllObjectURLs mock is already set by Set")
	}

	if mmListAllObjectURLs.defaultExpectation == nil {
		mmListAllObjectURLs.defaultExpectation = &RepositoryIMockListAllObjectURLsExpectation{mock: mmListAllObjectURLs.mock}
	}
	mmListAllObjectURLs.defaultExpectation.results = &RepositoryIMockListAllObjectURLsResults{oa1, err}
	return mmListAllObjectURLs.mock
}

// Set uses given function f to mock the RepositoryI.ListAllObjectURLs method
func (mmListAllObjectURLs *mRepositoryIMockListAllObjectURLs) Set(f func(ctx context.Context, namespaceUID uuid.UUID, objectUID uuid.UUID) (oa1 []mm_repository.ObjectURL, err error)) *RepositoryIMock {
	if mmListAllObjectURLs.defaultExpectation != nil {
		mmListAllObjectURLs.mock.t.Fatalf("Default expectation is already set for the RepositoryI.ListAllObjectURLs method")
	}

	if len(mmListAllObjectURLs.expectations) > 0 {
		mmListAllObjectURLs.mock.t.Fatalf("Some expectations are already set for the RepositoryI.ListAllObjectURLs method")
	}

	mmListAllObjectURLs.mock.funcListAllObjectURLs = f
	return mmListAllObjectURLs.mock
}

// When sets expectation for the RepositoryI.ListAllObjectURLs which will trigger the result defined by the following
// Then helper
func (mmListAllObjectURLs *mRepositoryIMockListAllObjectURLs) When(ctx context.Context, namespaceUID uuid.UUID, objectUID uuid.UUID) *RepositoryIMockListAllObjectURLsExpectation {
	if mmListAllObjectURLs.mock.funcListAllObjectURLs != nil {
		mmListAllObjectURLs.mock.t.Fatalf("RepositoryIMock.ListAllObjectURLs mock is already set by Set")
	}

	expectation := &RepositoryIMockListAllObjectURLsExpectation{
		mock:   mmListAllObjectURLs.mock,
		params: &RepositoryIMockListAllObjectURLsParams{ctx, namespaceUID, objectUID},
	}
	mmListAllObjectURLs.expectations = append(mmListAllObjectURLs.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.ListAllObjectURLs return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockListAllObjectURLsExpectation) Then(oa1 []mm_repository.ObjectURL, err error) *RepositoryIMock {
	e.results = &RepositoryIMockListAllObjectURLsResults{oa1, err}
	return e.mock
}

// Times sets number of times RepositoryI.ListAllObjectURLs should be invoked
func (mmListAllObjectURLs *mRepositoryIMockListAllObjectURLs) Times(n uint64) *mRepositoryIMockListAllObjectURLs {
	if n == 0 {
		mmListAllObjectURLs.mock.t.Fatalf("Times of RepositoryIMock.ListAllObjectURLs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListAllObjectURLs.expectedInvocations, n)
	return mmListAllObjectURLs
}

func (mmListAllObjectURLs *mRepositoryIMockListAllObjectURLs) invocationsDone() bool {
	if len(mmListAllObjectURLs.expectations) == 0 && mmListAllObjectURLs.defaultExpectation == nil && mmListAllObjectURLs.mock.funcListAllObjectURLs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListAllObjectURLs.mock.afterListAllObjectURLsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListAllObjectURLs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListAllObjectURLs implements repository.RepositoryI
func (mmListAllObjectURLs *RepositoryIMock) ListAllObjectURLs(ctx context.Context, namespaceUID uuid.UUID, objectUID uuid.UUID) (oa1 []mm_repository.ObjectURL, err error) {
	mm_atomic.AddUint64(&mmListAllObjectURLs.beforeListAllObjectURLsCounter, 1)
	defer mm_atomic.AddUint64(&mmListAllObjectURLs.afterListAllObjectURLsCounter, 1)

	if mmListAllObjectURLs.inspectFuncListAllObjectURLs != nil {
		mmListAllObjectURLs.inspectFuncListAllObjectURLs(ctx, namespaceUID, objectUID)
	}

	mm_params := RepositoryIMockListAllObjectURLsParams{ctx, namespaceUID, objectUID}

	// Record call args
	mmListAllObjectURLs.ListAllObjectURLsMock.mutex.Lock()
	mmListAllObjectURLs.ListAllObjectURLsMock.callArgs = append(mmListAllObjectURLs.ListAllObjectURLsMock.callArgs, &mm_params)
	mmListAllObjectURLs.ListAllObjectURLsMock.mutex.Unlock()

	for _, e := range mmListAllObjectURLs.ListAllObjectURLsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmListAllObjectURLs.ListAllObjectURLsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListAllObjectURLs.ListAllObjectURLsMock.defaultExpectation.Counter, 1)
		mm_want := mmListAllObjectURLs.ListAllObjectURLsMock.defaultExpectation.params
		mm_want_ptrs := mmListAllObjectURLs.ListAllObjectURLsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockListAllObjectURLsParams{ctx, namespaceUID, objectUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListAllObjectURLs.t.Errorf("RepositoryIMock.ListAllObjectURLs got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.namespaceUID != nil && !minimock.Equal(*mm_want_ptrs.namespaceUID, mm_got.namespaceUID) {
				mmListAllObjectURLs.t.Errorf("RepositoryIMock.ListAllObjectURLs got unexpected parameter namespaceUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.namespaceUID, mm_got.namespaceUID, minimock.Diff(*mm_want_ptrs.namespaceUID, mm_got.namespaceUID))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmListAllObjectURLs.t.Errorf("RepositoryIMock.ListAllObjectURLs got unexpected parameter objectUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListAllObjectURLs.t.Errorf("RepositoryIMock.ListAllObjectURLs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListAllObjectURLs.ListAllObjectURLsMock.defaultExpectation.results
		if mm_results == nil {
			mmListAllObjectURLs.t.Fatal("No results are set for the RepositoryIMock.ListAllObjectURLs")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmListAllObjectURLs.funcListAllObjectURLs != nil {
		return mmListAllObjectURLs.funcListAllObjectURLs(ctx, namespaceUID, objectUID)
	}
	mmListAllObjectURLs.t.Fatalf("Unexpected call to RepositoryIMock.ListAllObjectURLs. %v %v %v", ctx, namespaceUID, objectUID)
	return
}

// ListAllObjectURLsAfterCounter returns a count of finished RepositoryIMock.ListAllObjectURLs invocations
func (mmListAllObjectURLs *RepositoryIMock) ListAllObjectURLsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAllObjectURLs.afterListAllObjectURLsCounter)
}

// ListAllObjectURLsBeforeCounter returns a count of RepositoryIMock.ListAllObjectURLs invocations
func (mmListAllObjectURLs *RepositoryIMock) ListAllObjectURLsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAllObjectURLs.beforeListAllObjectURLsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.ListAllObjectURLs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListAllObjectURLs *mRepositoryIMockListAllObjectURLs) Calls() []*RepositoryIMockListAllObjectURLsParams {
	mmListAllObjectURLs.mutex.RLock()

	argCopy := make([]*RepositoryIMockListAllObjectURLsParams, len(mmListAllObjectURLs.callArgs))
	copy(argCopy, mmListAllObjectURLs.callArgs)

	mmListAllObjectURLs.mutex.RUnlock()

	return argCopy
}

// MinimockListAllObjectURLsDone returns true if the count of the ListAllObjectURLs invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockListAllObjectURLsDone() bool {
	for _, e := range m.ListAllObjectURLsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListAllObjectURLsMock.invocationsDone()
}

// MinimockListAllObjectURLsInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockListAllObjectURLsInspect() {
	for _, e := range m.ListAllObjectURLsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.ListAllObjectURLs with params: %#v", *e.params)
		}
	}

	afterListAllObjectURLsCounter := mm_atomic.LoadUint64(&m.afterListAllObjectURLsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListAllObjectURLsMock.defaultExpectation != nil && afterListAllObjectURLsCounter < 1 {
		if m.ListAllObjectURLsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.ListAllObjectURLs")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.ListAllObjectURLs with params: %#v", *m.ListAllObjectURLsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListAllObjectURLs != nil && afterListAllObjectURLsCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.ListAllObjectURLs")
	}

	if !m.ListAllObjectURLsMock.invocationsDone() && afterListAllObjectURLsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.ListAllObjectURLs but found %d calls",
			mm_atomic.LoadUint64(&m.ListAllObjectURLsMock.expectedInvocations), afterListAllObjectURLsCounter)
	}
}

type mRepositoryIMockListAllObjects struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockListAllObjectsExpectation
	expectations       []*RepositoryIMockListAllObjectsExpectation

	callArgs []*RepositoryIMockListAllObjectsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockListAllObjectsExpectation specifies expectation struct of the RepositoryI.ListAllObjects
type RepositoryIMockListAllObjectsExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockListAllObjectsParams
	paramPtrs *RepositoryIMockListAllObjectsParamPtrs
	results   *RepositoryIMockListAllObjectsResults
	Counter   uint64
}

// RepositoryIMockListAllObjectsParams contains parameters of the RepositoryI.ListAllObjects
type RepositoryIMockListAllObjectsParams struct {
	ctx          context.Context
	namespaceUID uuid.UUID
	creatorUID   uuid.UUID
}

// RepositoryIMockListAllObjectsParamPtrs contains pointers to parameters of the RepositoryI.ListAllObjects
type RepositoryIMockListAllObjectsParamPtrs struct {
	ctx          *context.Context
	namespaceUID *uuid.UUID
	creatorUID   *uuid.UUID
}

// RepositoryIMockListAllObjectsResults contains results of the RepositoryI.ListAllObjects
type RepositoryIMockListAllObjectsResults struct {
	oa1 []mm_repository.Object
	err error
}

// Expect sets up expected params for RepositoryI.ListAllObjects
func (mmListAllObjects *mRepositoryIMockListAllObjects) Expect(ctx context.Context, namespaceUID uuid.UUID, creatorUID uuid.UUID) *mRepositoryIMockListAllObjects {
	if mmListAllObjects.mock.funcListAllObjects != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryIMock.ListAllObjects mock is already set by Set")
	}

	if mmListAllObjects.defaultExpectation == nil {
		mmListAllObjects.defaultExpectation = &RepositoryIMockListAllObjectsExpectation{}
	}

	if mmListAllObjects.defaultExpectation.paramPtrs != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryIMock.ListAllObjects mock is already set by ExpectParams functions")
	}

	mmListAllObjects.defaultExpectation.params = &RepositoryIMockListAllObjectsParams{ctx, namespaceUID, creatorUID}
	for _, e := range mmListAllObjects.expectations {
		if minimock.Equal(e.params, mmListAllObjects.defaultExpectation.params) {
			mmListAllObjects.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListAllObjects.defaultExpectation.params)
		}
	}

	return mmListAllObjects
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.ListAllObjects
func (mmListAllObjects *mRepositoryIMockListAllObjects) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockListAllObjects {
	if mmListAllObjects.mock.funcListAllObjects != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryIMock.ListAllObjects mock is already set by Set")
	}

	if mmListAllObjects.defaultExpectation == nil {
		mmListAllObjects.defaultExpectation = &RepositoryIMockListAllObjectsExpectation{}
	}

	if mmListAllObjects.defaultExpectation.params != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryIMock.ListAllObjects mock is already set by Expect")
	}

	if mmListAllObjects.defaultExpectation.paramPtrs == nil {
		mmListAllObjects.defaultExpectation.paramPtrs = &RepositoryIMockListAllObjectsParamPtrs{}
	}
	mmListAllObjects.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListAllObjects
}

// ExpectNamespaceUIDParam2 sets up expected param namespaceUID for RepositoryI.ListAllObjects
func (mmListAllObjects *mRepositoryIMockListAllObjects) ExpectNamespaceUIDParam2(namespaceUID uuid.UUID) *mRepositoryIMockListAllObjects {
	if mmListAllObjects.mock.funcListAllObjects != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryIMock.ListAllObjects mock is already set by Set")
	}

	if mmListAllObjects.defaultExpectation == nil {
		mmListAllObjects.defaultExpectation = &RepositoryIMockListAllObjectsExpectation{}
	}

	if mmListAllObjects.defaultExpectation.params != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryIMock.ListAllObjects mock is already set by Expect")
	}

	if mmListAllObjects.defaultExpectation.paramPtrs == nil {
		mmListAllObjects.defaultExpectation.paramPtrs = &RepositoryIMockListAllObjectsParamPtrs{}
	}
	mmListAllObjects.defaultExpectation.paramPtrs.namespaceUID = &namespaceUID

	return mmListAllObjects
}

// ExpectCreatorUIDParam3 sets up expected param creatorUID for RepositoryI.ListAllObjects
func (mmListAllObjects *mRepositoryIMockListAllObjects) ExpectCreatorUIDParam3(creatorUID uuid.UUID) *mRepositoryIMockListAllObjects {
	if mmListAllObjects.mock.funcListAllObjects != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryIMock.ListAllObjects mock is already set by Set")
	}

	if mmListAllObjects.defaultExpectation == nil {
		mmListAllObjects.defaultExpectation = &RepositoryIMockListAllObjectsExpectation{}
	}

	if mmListAllObjects.defaultExpectation.params != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryIMock.ListAllObjects mock is already set by Expect")
	}

	if mmListAllObjects.defaultExpectation.paramPtrs == nil {
		mmListAllObjects.defaultExpectation.paramPtrs = &RepositoryIMockListAllObjectsParamPtrs{}
	}
	mmListAllObjects.defaultExpectation.paramPtrs.creatorUID = &creatorUID

	return mmListAllObjects
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.ListAllObjects
func (mmListAllObjects *mRepositoryIMockListAllObjects) Inspect(f func(ctx context.Context, namespaceUID uuid.UUID, creatorUID uuid.UUID)) *mRepositoryIMockListAllObjects {
	if mmListAllObjects.mock.inspectFuncListAllObjects != nil {
		mmListAllObjects.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.ListAllObjects")
	}

	mmListAllObjects.mock.inspectFuncListAllObjects = f

	return mmListAllObjects
}

// Return sets up results that will be returned by RepositoryI.ListAllObjects
func (mmListAllObjects *mRepositoryIMockListAllObjects) Return(oa1 []mm_repository.Object, err error) *RepositoryIMock {
	if mmListAllObjects.mock.funcListAllObjects != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryIMock.ListAllObjects mock is already set by Set")
	}

	if mmListAllObjects.defaultExpectation == nil {
		mmListAllObjects.defaultExpectation = &RepositoryIMockListAllObjectsExpectation{mock: mmListAllObjects.mock}
	}
	mmListAllObjects.defaultExpectation.results = &RepositoryIMockListAllObjectsResults{oa1, err}
	return mmListAllObjects.mock
}

// Set uses given function f to mock the RepositoryI.ListAllObjects method
func (mmListAllObjects *mRepositoryIMockListAllObjects) Set(f func(ctx context.Context, namespaceUID uuid.UUID, creatorUID uuid.UUID) (oa1 []mm_repository.Object, err error)) *RepositoryIMock {
	if mmListAllObjects.defaultExpectation != nil {
		mmListAllObjects.mock.t.Fatalf("Default expectation is already set for the RepositoryI.ListAllObjects method")
	}

	if len(mmListAllObjects.expectations) > 0 {
		mmListAllObjects.mock.t.Fatalf("Some expectations are already set for the RepositoryI.ListAllObjects method")
	}

	mmListAllObjects.mock.funcListAllObjects = f
	return mmListAllObjects.mock
}

// When sets expectation for the RepositoryI.ListAllObjects which will trigger the result defined by the following
// Then helper
func (mmListAllObjects *mRepositoryIMockListAllObjects) When(ctx context.Context, namespaceUID uuid.UUID, creatorUID uuid.UUID) *RepositoryIMockListAllObjectsExpectation {
	if mmListAllObjects.mock.funcListAllObjects != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryIMock.ListAllObjects mock is already set by Set")
	}

	expectation := &RepositoryIMockListAllObjectsExpectation{
		mock:   mmListAllObjects.mock,
		params: &RepositoryIMockListAllObjectsParams{ctx, namespaceUID, creatorUID},
	}
	mmListAllObjects.expectations = append(mmListAllObjects.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.ListAllObjects return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockListAllObjectsExpectation) Then(oa1 []mm_repository.Object, err error) *RepositoryIMock {
	e.results = &RepositoryIMockListAllObjectsResults{oa1, err}
	return e.mock
}

// Times sets number of times RepositoryI.ListAllObjects should be invoked
func (mmListAllObjects *mRepositoryIMockListAllObjects) Times(n uint64) *mRepositoryIMockListAllObjects {
	if n == 0 {
		mmListAllObjects.mock.t.Fatalf("Times of RepositoryIMock.ListAllObjects mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListAllObjects.expectedInvocations, n)
	return mmListAllObjects
}

func (mmListAllObjects *mRepositoryIMockListAllObjects) invocationsDone() bool {
	if len(mmListAllObjects.expectations) == 0 && mmListAllObjects.defaultExpectation == nil && mmListAllObjects.mock.funcListAllObjects == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListAllObjects.mock.afterListAllObjectsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListAllObjects.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListAllObjects implements repository.RepositoryI
func (mmListAllObjects *RepositoryIMock) ListAllObjects(ctx context.Context, namespaceUID uuid.UUID, creatorUID uuid.UUID) (oa1 []mm_repository.Object, err error) {
	mm_atomic.AddUint64(&mmListAllObjects.beforeListAllObjectsCounter, 1)
	defer mm_atomic.AddUint64(&mmListAllObjects.afterListAllObjectsCounter, 1)

	if mmListAllObjects.inspectFuncListAllObjects != nil {
		mmListAllObjects.inspectFuncListAllObjects(ctx, namespaceUID, creatorUID)
	}

	mm_params := RepositoryIMockListAllObjectsParams{ctx, namespaceUID, creatorUID}

	// Record call args
	mmListAllObjects.ListAllObjectsMock.mutex.Lock()
	mmListAllObjects.ListAllObjectsMock.callArgs = append(mmListAllObjects.ListAllObjectsMock.callArgs, &mm_params)
	mmListAllObjects.ListAllObjectsMock.mutex.Unlock()

	for _, e := range mmListAllObjects.ListAllObjectsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmListAllObjects.ListAllObjectsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListAllObjects.ListAllObjectsMock.defaultExpectation.Counter, 1)
		mm_want := mmListAllObjects.ListAllObjectsMock.defaultExpectation.params
		mm_want_ptrs := mmListAllObjects.ListAllObjectsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockListAllObjectsParams{ctx, namespaceUID, creatorUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListAllObjects.t.Errorf("RepositoryIMock.ListAllObjects got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.namespaceUID != nil && !minimock.Equal(*mm_want_ptrs.namespaceUID, mm_got.namespaceUID) {
				mmListAllObjects.t.Errorf("RepositoryIMock.ListAllObjects got unexpected parameter namespaceUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.namespaceUID, mm_got.namespaceUID, minimock.Diff(*mm_want_ptrs.namespaceUID, mm_got.namespaceUID))
			}

			if mm_want_ptrs.creatorUID != nil && !minimock.Equal(*mm_want_ptrs.creatorUID, mm_got.creatorUID) {
				mmListAllObjects.t.Errorf("RepositoryIMock.ListAllObjects got unexpected parameter creatorUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.creatorUID, mm_got.creatorUID, minimock.Diff(*mm_want_ptrs.creatorUID, mm_got.creatorUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListAllObjects.t.Errorf("RepositoryIMock.ListAllObjects got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListAllObjects.ListAllObjectsMock.defaultExpectation.results
		if mm_results == nil {
			mmListAllObjects.t.Fatal("No results are set for the RepositoryIMock.ListAllObjects")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmListAllObjects.funcListAllObjects != nil {
		return mmListAllObjects.funcListAllObjects(ctx, namespaceUID, creatorUID)
	}
	mmListAllObjects.t.Fatalf("Unexpected call to RepositoryIMock.ListAllObjects. %v %v %v", ctx, namespaceUID, creatorUID)
	return
}

// ListAllObjectsAfterCounter returns a count of finished RepositoryIMock.ListAllObjects invocations
func (mmListAllObjects *RepositoryIMock) ListAllObjectsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAllObjects.afterListAllObjectsCounter)
}

// ListAllObjectsBeforeCounter returns a count of RepositoryIMock.ListAllObjects invocations
func (mmListAllObjects *RepositoryIMock) ListAllObjectsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAllObjects.beforeListAllObjectsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.ListAllObjects.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListAllObjects *mRepositoryIMockListAllObjects) Calls() []*RepositoryIMockListAllObjectsParams {
	mmListAllObjects.mutex.RLock()

	argCopy := make([]*RepositoryIMockListAllObjectsParams, len(mmListAllObjects.callArgs))
	copy(argCopy, mmListAllObjects.callArgs)

	mmListAllObjects.mutex.RUnlock()

	return argCopy
}

// MinimockListAllObjectsDone returns true if the count of the ListAllObjects invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockListAllObjectsDone() bool {
	for _, e := range m.ListAllObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListAllObjectsMock.invocationsDone()
}

// MinimockListAllObjectsInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockListAllObjectsInspect() {
	for _, e := range m.ListAllObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.ListAllObjects with params: %#v", *e.params)
		}
	}

	afterListAllObjectsCounter := mm_atomic.LoadUint64(&m.afterListAllObjectsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListAllObjectsMock.defaultExpectation != nil && afterListAllObjectsCounter < 1 {
		if m.ListAllObjectsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.ListAllObjects")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.ListAllObjects with params: %#v", *m.ListAllObjectsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListAllObjects != nil && afterListAllObjectsCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.ListAllObjects")
	}

	if !m.ListAllObjectsMock.invocationsDone() && afterListAllObjectsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.ListAllObjects but found %d calls",
			mm_atomic.LoadUint64(&m.ListAllObjectsMock.expectedInvocations), afterListAllObjectsCounter)
	}
}

type mRepositoryIMockListChunksByKbFileUID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockListChunksByKbFileUIDExpectation
	expectations       []*RepositoryIMockListChunksByKbFileUIDExpectation

	callArgs []*RepositoryIMockListChunksByKbFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockListChunksByKbFileUIDExpectation specifies expectation struct of the RepositoryI.ListChunksByKbFileUID
type RepositoryIMockListChunksByKbFileUIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockListChunksByKbFileUIDParams
	paramPtrs *RepositoryIMockListChunksByKbFileUIDParamPtrs
	results   *RepositoryIMockListChunksByKbFileUIDResults
	Counter   uint64
}

// RepositoryIMockListChunksByKbFileUIDParams contains parameters of the RepositoryI.ListChunksByKbFileUID
type RepositoryIMockListChunksByKbFileUIDParams struct {
	ctx       context.Context
	kbFileUID uuid.UUID
}

// RepositoryIMockListChunksByKbFileUIDParamPtrs contains pointers to parameters of the RepositoryI.ListChunksByKbFileUID
type RepositoryIMockListChunksByKbFileUIDParamPtrs struct {
	ctx       *context.Context
	kbFileUID *uuid.UUID
}

// RepositoryIMockListChunksByKbFileUIDResults contains results of the RepositoryI.ListChunksByKbFileUID
type RepositoryIMockListChunksByKbFileUIDResults struct {
	ta1 []mm_repository.TextChunk
	err error
}

// Expect sets up expected params for RepositoryI.ListChunksByKbFileUID
func (mmListChunksByKbFileUID *mRepositoryIMockListChunksByKbFileUID) Expect(ctx context.Context, kbFileUID uuid.UUID) *mRepositoryIMockListChunksByKbFileUID {
	if mmListChunksByKbFileUID.mock.funcListChunksByKbFileUID != nil {
		mmListChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListChunksByKbFileUID mock is already set by Set")
	}

	if mmListChunksByKbFileUID.defaultExpectation == nil {
		mmListChunksByKbFileUID.defaultExpectation = &RepositoryIMockListChunksByKbFileUIDExpectation{}
	}

	if mmListChunksByKbFileUID.defaultExpectation.paramPtrs != nil {
		mmListChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListChunksByKbFileUID mock is already set by ExpectParams functions")
	}

	mmListChunksByKbFileUID.defaultExpectation.params = &RepositoryIMockListChunksByKbFileUIDParams{ctx, kbFileUID}
	for _, e := range mmListChunksByKbFileUID.expectations {
		if minimock.Equal(e.params, mmListChunksByKbFileUID.defaultExpectation.params) {
			mmListChunksByKbFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListChunksByKbFileUID.defaultExpectation.params)
		}
	}

	return mmListChunksByKbFileUID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.ListChunksByKbFileUID
func (mmListChunksByKbFileUID *mRepositoryIMockListChunksByKbFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockListChunksByKbFileUID {
	if mmListChunksByKbFileUID.mock.funcListChunksByKbFileUID != nil {
		mmListChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListChunksByKbFileUID mock is already set by Set")
	}

	if mmListChunksByKbFileUID.defaultExpectation == nil {
		mmListChunksByKbFileUID.defaultExpectation = &RepositoryIMockListChunksByKbFileUIDExpectation{}
	}

	if mmListChunksByKbFileUID.defaultExpectation.params != nil {
		mmListChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListChunksByKbFileUID mock is already set by Expect")
	}

	if mmListChunksByKbFileUID.defaultExpectation.paramPtrs == nil {
		mmListChunksByKbFileUID.defaultExpectation.paramPtrs = &RepositoryIMockListChunksByKbFileUIDParamPtrs{}
	}
	mmListChunksByKbFileUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListChunksByKbFileUID
}

// ExpectKbFileUIDParam2 sets up expected param kbFileUID for RepositoryI.ListChunksByKbFileUID
func (mmListChunksByKbFileUID *mRepositoryIMockListChunksByKbFileUID) ExpectKbFileUIDParam2(kbFileUID uuid.UUID) *mRepositoryIMockListChunksByKbFileUID {
	if mmListChunksByKbFileUID.mock.funcListChunksByKbFileUID != nil {
		mmListChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListChunksByKbFileUID mock is already set by Set")
	}

	if mmListChunksByKbFileUID.defaultExpectation == nil {
		mmListChunksByKbFileUID.defaultExpectation = &RepositoryIMockListChunksByKbFileUIDExpectation{}
	}

	if mmListChunksByKbFileUID.defaultExpectation.params != nil {
		mmListChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListChunksByKbFileUID mock is already set by Expect")
	}

	if mmListChunksByKbFileUID.defaultExpectation.paramPtrs == nil {
		mmListChunksByKbFileUID.defaultExpectation.paramPtrs = &RepositoryIMockListChunksByKbFileUIDParamPtrs{}
	}
	mmListChunksByKbFileUID.defaultExpectation.paramPtrs.kbFileUID = &kbFileUID

	return mmListChunksByKbFileUID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.ListChunksByKbFileUID
func (mmListChunksByKbFileUID *mRepositoryIMockListChunksByKbFileUID) Inspect(f func(ctx context.Context, kbFileUID uuid.UUID)) *mRepositoryIMockListChunksByKbFileUID {
	if mmListChunksByKbFileUID.mock.inspectFuncListChunksByKbFileUID != nil {
		mmListChunksByKbFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.ListChunksByKbFileUID")
	}

	mmListChunksByKbFileUID.mock.inspectFuncListChunksByKbFileUID = f

	return mmListChunksByKbFileUID
}

// Return sets up results that will be returned by RepositoryI.ListChunksByKbFileUID
func (mmListChunksByKbFileUID *mRepositoryIMockListChunksByKbFileUID) Return(ta1 []mm_repository.TextChunk, err error) *RepositoryIMock {
	if mmListChunksByKbFileUID.mock.funcListChunksByKbFileUID != nil {
		mmListChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListChunksByKbFileUID mock is already set by Set")
	}

	if mmListChunksByKbFileUID.defaultExpectation == nil {
		mmListChunksByKbFileUID.defaultExpectation = &RepositoryIMockListChunksByKbFileUIDExpectation{mock: mmListChunksByKbFileUID.mock}
	}
	mmListChunksByKbFileUID.defaultExpectation.results = &RepositoryIMockListChunksByKbFileUIDResults{ta1, err}
	return mmListChunksByKbFileUID.mock
}

// Set uses given function f to mock the RepositoryI.ListChunksByKbFileUID method
func (mmListChunksByKbFileUID *mRepositoryIMockListChunksByKbFileUID) Set(f func(ctx context.Context, kbFileUID uuid.UUID) (ta1 []mm_repository.TextChunk, err error)) *RepositoryIMock {
	if mmListChunksByKbFileUID.defaultExpectation != nil {
		mmListChunksByKbFileUID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.ListChunksByKbFileUID method")
	}

	if len(mmListChunksByKbFileUID.expectations) > 0 {
		mmListChunksByKbFileUID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.ListChunksByKbFileUID method")
	}

	mmListChunksByKbFileUID.mock.funcListChunksByKbFileUID = f
	return mmListChunksByKbFileUID.mock
}

// When sets expectation for the RepositoryI.ListChunksByKbFileUID which will trigger the result defined by the following
// Then helper
func (mmListChunksByKbFileUID *mRepositoryIMockListChunksByKbFileUID) When(ctx context.Context, kbFileUID uuid.UUID) *RepositoryIMockListChunksByKbFileUIDExpectation {
	if mmListChunksByKbFileUID.mock.funcListChunksByKbFileUID != nil {
		mmListChunksByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListChunksByKbFileUID mock is already set by Set")
	}

	expectation := &RepositoryIMockListChunksByKbFileUIDExpectation{
		mock:   mmListChunksByKbFileUID.mock,
		params: &RepositoryIMockListChunksByKbFileUIDParams{ctx, kbFileUID},
	}
	mmListChunksByKbFileUID.expectations = append(mmListChunksByKbFileUID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.ListChunksByKbFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockListChunksByKbFileUIDExpectation) Then(ta1 []mm_repository.TextChunk, err error) *RepositoryIMock {
	e.results = &RepositoryIMockListChunksByKbFileUIDResults{ta1, err}
	return e.mock
}

// Times sets number of times RepositoryI.ListChunksByKbFileUID should be invoked
func (mmListChunksByKbFileUID *mRepositoryIMockListChunksByKbFileUID) Times(n uint64) *mRepositoryIMockListChunksByKbFileUID {
	if n == 0 {
		mmListChunksByKbFileUID.mock.t.Fatalf("Times of RepositoryIMock.ListChunksByKbFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListChunksByKbFileUID.expectedInvocations, n)
	return mmListChunksByKbFileUID
}

func (mmListChunksByKbFileUID *mRepositoryIMockListChunksByKbFileUID) invocationsDone() bool {
	if len(mmListChunksByKbFileUID.expectations) == 0 && mmListChunksByKbFileUID.defaultExpectation == nil && mmListChunksByKbFileUID.mock.funcListChunksByKbFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListChunksByKbFileUID.mock.afterListChunksByKbFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListChunksByKbFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListChunksByKbFileUID implements repository.RepositoryI
func (mmListChunksByKbFileUID *RepositoryIMock) ListChunksByKbFileUID(ctx context.Context, kbFileUID uuid.UUID) (ta1 []mm_repository.TextChunk, err error) {
	mm_atomic.AddUint64(&mmListChunksByKbFileUID.beforeListChunksByKbFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmListChunksByKbFileUID.afterListChunksByKbFileUIDCounter, 1)

	if mmListChunksByKbFileUID.inspectFuncListChunksByKbFileUID != nil {
		mmListChunksByKbFileUID.inspectFuncListChunksByKbFileUID(ctx, kbFileUID)
	}

	mm_params := RepositoryIMockListChunksByKbFileUIDParams{ctx, kbFileUID}

	// Record call args
	mmListChunksByKbFileUID.ListChunksByKbFileUIDMock.mutex.Lock()
	mmListChunksByKbFileUID.ListChunksByKbFileUIDMock.callArgs = append(mmListChunksByKbFileUID.ListChunksByKbFileUIDMock.callArgs, &mm_params)
	mmListChunksByKbFileUID.ListChunksByKbFileUIDMock.mutex.Unlock()

	for _, e := range mmListChunksByKbFileUID.ListChunksByKbFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ta1, e.results.err
		}
	}

	if mmListChunksByKbFileUID.ListChunksByKbFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListChunksByKbFileUID.ListChunksByKbFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmListChunksByKbFileUID.ListChunksByKbFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmListChunksByKbFileUID.ListChunksByKbFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockListChunksByKbFileUIDParams{ctx, kbFileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListChunksByKbFileUID.t.Errorf("RepositoryIMock.ListChunksByKbFileUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbFileUID != nil && !minimock.Equal(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID) {
				mmListChunksByKbFileUID.t.Errorf("RepositoryIMock.ListChunksByKbFileUID got unexpected parameter kbFileUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbFileUID, mm_got.kbFileUID, minimock.Diff(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListChunksByKbFileUID.t.Errorf("RepositoryIMock.ListChunksByKbFileUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListChunksByKbFileUID.ListChunksByKbFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmListChunksByKbFileUID.t.Fatal("No results are set for the RepositoryIMock.ListChunksByKbFileUID")
		}
		return (*mm_results).ta1, (*mm_results).err
	}
	if mmListChunksByKbFileUID.funcListChunksByKbFileUID != nil {
		return mmListChunksByKbFileUID.funcListChunksByKbFileUID(ctx, kbFileUID)
	}
	mmListChunksByKbFileUID.t.Fatalf("Unexpected call to RepositoryIMock.ListChunksByKbFileUID. %v %v", ctx, kbFileUID)
	return
}

// ListChunksByKbFileUIDAfterCounter returns a count of finished RepositoryIMock.ListChunksByKbFileUID invocations
func (mmListChunksByKbFileUID *RepositoryIMock) ListChunksByKbFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListChunksByKbFileUID.afterListChunksByKbFileUIDCounter)
}

// ListChunksByKbFileUIDBeforeCounter returns a count of RepositoryIMock.ListChunksByKbFileUID invocations
func (mmListChunksByKbFileUID *RepositoryIMock) ListChunksByKbFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListChunksByKbFileUID.beforeListChunksByKbFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.ListChunksByKbFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListChunksByKbFileUID *mRepositoryIMockListChunksByKbFileUID) Calls() []*RepositoryIMockListChunksByKbFileUIDParams {
	mmListChunksByKbFileUID.mutex.RLock()

	argCopy := make([]*RepositoryIMockListChunksByKbFileUIDParams, len(mmListChunksByKbFileUID.callArgs))
	copy(argCopy, mmListChunksByKbFileUID.callArgs)

	mmListChunksByKbFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockListChunksByKbFileUIDDone returns true if the count of the ListChunksByKbFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockListChunksByKbFileUIDDone() bool {
	for _, e := range m.ListChunksByKbFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListChunksByKbFileUIDMock.invocationsDone()
}

// MinimockListChunksByKbFileUIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockListChunksByKbFileUIDInspect() {
	for _, e := range m.ListChunksByKbFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.ListChunksByKbFileUID with params: %#v", *e.params)
		}
	}

	afterListChunksByKbFileUIDCounter := mm_atomic.LoadUint64(&m.afterListChunksByKbFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListChunksByKbFileUIDMock.defaultExpectation != nil && afterListChunksByKbFileUIDCounter < 1 {
		if m.ListChunksByKbFileUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.ListChunksByKbFileUID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.ListChunksByKbFileUID with params: %#v", *m.ListChunksByKbFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListChunksByKbFileUID != nil && afterListChunksByKbFileUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.ListChunksByKbFileUID")
	}

	if !m.ListChunksByKbFileUIDMock.invocationsDone() && afterListChunksByKbFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.ListChunksByKbFileUID but found %d calls",
			mm_atomic.LoadUint64(&m.ListChunksByKbFileUIDMock.expectedInvocations), afterListChunksByKbFileUIDCounter)
	}
}

type mRepositoryIMockListEmbeddingsByKbFileUID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockListEmbeddingsByKbFileUIDExpectation
	expectations       []*RepositoryIMockListEmbeddingsByKbFileUIDExpectation

	callArgs []*RepositoryIMockListEmbeddingsByKbFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockListEmbeddingsByKbFileUIDExpectation specifies expectation struct of the RepositoryI.ListEmbeddingsByKbFileUID
type RepositoryIMockListEmbeddingsByKbFileUIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockListEmbeddingsByKbFileUIDParams
	paramPtrs *RepositoryIMockListEmbeddingsByKbFileUIDParamPtrs
	results   *RepositoryIMockListEmbeddingsByKbFileUIDResults
	Counter   uint64
}

// RepositoryIMockListEmbeddingsByKbFileUIDParams contains parameters of the RepositoryI.ListEmbeddingsByKbFileUID
type RepositoryIMockListEmbeddingsByKbFileUIDParams struct {
	ctx       context.Context
	kbFileUID uuid.UUID
}

// RepositoryIMockListEmbeddingsByKbFileUIDParamPtrs contains pointers to parameters of the RepositoryI.ListEmbeddingsByKbFileUID
type RepositoryIMockListEmbeddingsByKbFileUIDParamPtrs struct {
	ctx       *context.Context
	kbFileUID *uuid.UUID
}

// RepositoryIMockListEmbeddingsByKbFileUIDResults contains results of the RepositoryI.ListEmbeddingsByKbFileUID
type RepositoryIMockListEmbeddingsByKbFileUIDResults struct {
	ea1 []mm_repository.Embedding
	err error
}

// Expect sets up expected params for RepositoryI.ListEmbeddingsByKbFileUID
func (mmListEmbeddingsByKbFileUID *mRepositoryIMockListEmbeddingsByKbFileUID) Expect(ctx context.Context, kbFileUID uuid.UUID) *mRepositoryIMockListEmbeddingsByKbFileUID {
	if mmListEmbeddingsByKbFileUID.mock.funcListEmbeddingsByKbFileUID != nil {
		mmListEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListEmbeddingsByKbFileUID mock is already set by Set")
	}

	if mmListEmbeddingsByKbFileUID.defaultExpectation == nil {
		mmListEmbeddingsByKbFileUID.defaultExpectation = &RepositoryIMockListEmbeddingsByKbFileUIDExpectation{}
	}

	if mmListEmbeddingsByKbFileUID.defaultExpectation.paramPtrs != nil {
		mmListEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListEmbeddingsByKbFileUID mock is already set by ExpectParams functions")
	}

	mmListEmbeddingsByKbFileUID.defaultExpectation.params = &RepositoryIMockListEmbeddingsByKbFileUIDParams{ctx, kbFileUID}
	for _, e := range mmListEmbeddingsByKbFileUID.expectations {
		if minimock.Equal(e.params, mmListEmbeddingsByKbFileUID.defaultExpectation.params) {
			mmListEmbeddingsByKbFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListEmbeddingsByKbFileUID.defaultExpectation.params)
		}
	}

	return mmListEmbeddingsByKbFileUID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.ListEmbeddingsByKbFileUID
func (mmListEmbeddingsByKbFileUID *mRepositoryIMockListEmbeddingsByKbFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockListEmbeddingsByKbFileUID {
	if mmListEmbeddingsByKbFileUID.mock.funcListEmbeddingsByKbFileUID != nil {
		mmListEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListEmbeddingsByKbFileUID mock is already set by Set")
	}

	if mmListEmbeddingsByKbFileUID.defaultExpectation == nil {
		mmListEmbeddingsByKbFileUID.defaultExpectation = &RepositoryIMockListEmbeddingsByKbFileUIDExpectation{}
	}

	if mmListEmbeddingsByKbFileUID.defaultExpectation.params != nil {
		mmListEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListEmbeddingsByKbFileUID mock is already set by Expect")
	}

	if mmListEmbeddingsByKbFileUID.defaultExpectation.paramPtrs == nil {
		mmListEmbeddingsByKbFileUID.defaultExpectation.paramPtrs = &RepositoryIMockListEmbeddingsByKbFileUIDParamPtrs{}
	}
	mmListEmbeddingsByKbFileUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListEmbeddingsByKbFileUID
}

// ExpectKbFileUIDParam2 sets up expected param kbFileUID for RepositoryI.ListEmbeddingsByKbFileUID
func (mmListEmbeddingsByKbFileUID *mRepositoryIMockListEmbeddingsByKbFileUID) ExpectKbFileUIDParam2(kbFileUID uuid.UUID) *mRepositoryIMockListEmbeddingsByKbFileUID {
	if mmListEmbeddingsByKbFileUID.mock.funcListEmbeddingsByKbFileUID != nil {
		mmListEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListEmbeddingsByKbFileUID mock is already set by Set")
	}

	if mmListEmbeddingsByKbFileUID.defaultExpectation == nil {
		mmListEmbeddingsByKbFileUID.defaultExpectation = &RepositoryIMockListEmbeddingsByKbFileUIDExpectation{}
	}

	if mmListEmbeddingsByKbFileUID.defaultExpectation.params != nil {
		mmListEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListEmbeddingsByKbFileUID mock is already set by Expect")
	}

	if mmListEmbeddingsByKbFileUID.defaultExpectation.paramPtrs == nil {
		mmListEmbeddingsByKbFileUID.defaultExpectation.paramPtrs = &RepositoryIMockListEmbeddingsByKbFileUIDParamPtrs{}
	}
	mmListEmbeddingsByKbFileUID.defaultExpectation.paramPtrs.kbFileUID = &kbFileUID

	return mmListEmbeddingsByKbFileUID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.ListEmbeddingsByKbFileUID
func (mmListEmbeddingsByKbFileUID *mRepositoryIMockListEmbeddingsByKbFileUID) Inspect(f func(ctx context.Context, kbFileUID uuid.UUID)) *mRepositoryIMockListEmbeddingsByKbFileUID {
	if mmListEmbeddingsByKbFileUID.mock.inspectFuncListEmbeddingsByKbFileUID != nil {
		mmListEmbeddingsByKbFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.ListEmbeddingsByKbFileUID")
	}

	mmListEmbeddingsByKbFileUID.mock.inspectFuncListEmbeddingsByKbFileUID = f

	return mmListEmbeddingsByKbFileUID
}

// Return sets up results that will be returned by RepositoryI.ListEmbeddingsByKbFileUID
func (mmListEmbeddingsByKbFileUID *mRepositoryIMockListEmbeddingsByKbFileUID) Return(ea1 []mm_repository.Embedding, err error) *RepositoryIMock {
	if mmListEmbeddingsByKbFileUID.mock.funcListEmbeddingsByKbFileUID != nil {
		mmListEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListEmbeddingsByKbFileUID mock is already set by Set")
	}

	if mmListEmbeddingsByKbFileUID.defaultExpectation == nil {
		mmListEmbeddingsByKbFileUID.defaultExpectation = &RepositoryIMockListEmbeddingsByKbFileUIDExpectation{mock: mmListEmbeddingsByKbFileUID.mock}
	}
	mmListEmbeddingsByKbFileUID.defaultExpectation.results = &RepositoryIMockListEmbeddingsByKbFileUIDResults{ea1, err}
	return mmListEmbeddingsByKbFileUID.mock
}

// Set uses given function f to mock the RepositoryI.ListEmbeddingsByKbFileUID method
func (mmListEmbeddingsByKbFileUID *mRepositoryIMockListEmbeddingsByKbFileUID) Set(f func(ctx context.Context, kbFileUID uuid.UUID) (ea1 []mm_repository.Embedding, err error)) *RepositoryIMock {
	if mmListEmbeddingsByKbFileUID.defaultExpectation != nil {
		mmListEmbeddingsByKbFileUID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.ListEmbeddingsByKbFileUID method")
	}

	if len(mmListEmbeddingsByKbFileUID.expectations) > 0 {
		mmListEmbeddingsByKbFileUID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.ListEmbeddingsByKbFileUID method")
	}

	mmListEmbeddingsByKbFileUID.mock.funcListEmbeddingsByKbFileUID = f
	return mmListEmbeddingsByKbFileUID.mock
}

// When sets expectation for the RepositoryI.ListEmbeddingsByKbFileUID which will trigger the result defined by the following
// Then helper
func (mmListEmbeddingsByKbFileUID *mRepositoryIMockListEmbeddingsByKbFileUID) When(ctx context.Context, kbFileUID uuid.UUID) *RepositoryIMockListEmbeddingsByKbFileUIDExpectation {
	if mmListEmbeddingsByKbFileUID.mock.funcListEmbeddingsByKbFileUID != nil {
		mmListEmbeddingsByKbFileUID.mock.t.Fatalf("RepositoryIMock.ListEmbeddingsByKbFileUID mock is already set by Set")
	}

	expectation := &RepositoryIMockListEmbeddingsByKbFileUIDExpectation{
		mock:   mmListEmbeddingsByKbFileUID.mock,
		params: &RepositoryIMockListEmbeddingsByKbFileUIDParams{ctx, kbFileUID},
	}
	mmListEmbeddingsByKbFileUID.expectations = append(mmListEmbeddingsByKbFileUID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.ListEmbeddingsByKbFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockListEmbeddingsByKbFileUIDExpectation) Then(ea1 []mm_repository.Embedding, err error) *RepositoryIMock {
	e.results = &RepositoryIMockListEmbeddingsByKbFileUIDResults{ea1, err}
	return e.mock
}

// Times sets number of times RepositoryI.ListEmbeddingsByKbFileUID should be invoked
func (mmListEmbeddingsByKbFileUID *mRepositoryIMockListEmbeddingsByKbFileUID) Times(n uint64) *mRepositoryIMockListEmbeddingsByKbFileUID {
	if n == 0 {
		mmListEmbeddingsByKbFileUID.mock.t.Fatalf("Times of RepositoryIMock.ListEmbeddingsByKbFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListEmbeddingsByKbFileUID.expectedInvocations, n)
	return mmListEmbeddingsByKbFileUID
}

func (mmListEmbeddingsByKbFileUID *mRepositoryIMockListEmbeddingsByKbFileUID) invocationsDone() bool {
	if len(mmListEmbeddingsByKbFileUID.expectations) == 0 && mmListEmbeddingsByKbFileUID.defaultExpectation == nil && mmListEmbeddingsByKbFileUID.mock.funcListEmbeddingsByKbFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListEmbeddingsByKbFileUID.mock.afterListEmbeddingsByKbFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListEmbeddingsByKbFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListEmbeddingsByKbFileUID implements repository.RepositoryI
func (mmListEmbeddingsByKbFileUID *RepositoryIMock) ListEmbeddingsByKbFileUID(ctx context.Context, kbFileUID uuid.UUID) (ea1 []mm_repository.Embedding, err error) {
	mm_atomic.AddUint64(&mmListEmbeddingsByKbFileUID.beforeListEmbeddingsByKbFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmListEmbeddingsByKbFileUID.afterListEmbeddingsByKbFileUIDCounter, 1)

	if mmListEmbeddingsByKbFileUID.inspectFuncListEmbeddingsByKbFileUID != nil {
		mmListEmbeddingsByKbFileUID.inspectFuncListEmbeddingsByKbFileUID(ctx, kbFileUID)
	}

	mm_params := RepositoryIMockListEmbeddingsByKbFileUIDParams{ctx, kbFileUID}

	// Record call args
	mmListEmbeddingsByKbFileUID.ListEmbeddingsByKbFileUIDMock.mutex.Lock()
	mmListEmbeddingsByKbFileUID.ListEmbeddingsByKbFileUIDMock.callArgs = append(mmListEmbeddingsByKbFileUID.ListEmbeddingsByKbFileUIDMock.callArgs, &mm_params)
	mmListEmbeddingsByKbFileUID.ListEmbeddingsByKbFileUIDMock.mutex.Unlock()

	for _, e := range mmListEmbeddingsByKbFileUID.ListEmbeddingsByKbFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1, e.results.err
		}
	}

	if mmListEmbeddingsByKbFileUID.ListEmbeddingsByKbFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListEmbeddingsByKbFileUID.ListEmbeddingsByKbFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmListEmbeddingsByKbFileUID.ListEmbeddingsByKbFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmListEmbeddingsByKbFileUID.ListEmbeddingsByKbFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockListEmbeddingsByKbFileUIDParams{ctx, kbFileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListEmbeddingsByKbFileUID.t.Errorf("RepositoryIMock.ListEmbeddingsByKbFileUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbFileUID != nil && !minimock.Equal(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID) {
				mmListEmbeddingsByKbFileUID.t.Errorf("RepositoryIMock.ListEmbeddingsByKbFileUID got unexpected parameter kbFileUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbFileUID, mm_got.kbFileUID, minimock.Diff(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListEmbeddingsByKbFileUID.t.Errorf("RepositoryIMock.ListEmbeddingsByKbFileUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListEmbeddingsByKbFileUID.ListEmbeddingsByKbFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmListEmbeddingsByKbFileUID.t.Fatal("No results are set for the RepositoryIMock.ListEmbeddingsByKbFileUID")
		}
		return (*mm_results).ea1, (*mm_results).err
	}
	if mmListEmbeddingsByKbFileUID.funcListEmbeddingsByKbFileUID != nil {
		return mmListEmbeddingsByKbFileUID.funcListEmbeddingsByKbFileUID(ctx, kbFileUID)
	}
	mmListEmbeddingsByKbFileUID.t.Fatalf("Unexpected call to RepositoryIMock.ListEmbeddingsByKbFileUID. %v %v", ctx, kbFileUID)
	return
}

// ListEmbeddingsByKbFileUIDAfterCounter returns a count of finished RepositoryIMock.ListEmbeddingsByKbFileUID invocations
func (mmListEmbeddingsByKbFileUID *RepositoryIMock) ListEmbeddingsByKbFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListEmbeddingsByKbFileUID.afterListEmbeddingsByKbFileUIDCounter)
}

// ListEmbeddingsByKbFileUIDBeforeCounter returns a count of RepositoryIMock.ListEmbeddingsByKbFileUID invocations
func (mmListEmbeddingsByKbFileUID *RepositoryIMock) ListEmbeddingsByKbFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListEmbeddingsByKbFileUID.beforeListEmbeddingsByKbFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.ListEmbeddingsByKbFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListEmbeddingsByKbFileUID *mRepositoryIMockListEmbeddingsByKbFileUID) Calls() []*RepositoryIMockListEmbeddingsByKbFileUIDParams {
	mmListEmbeddingsByKbFileUID.mutex.RLock()

	argCopy := make([]*RepositoryIMockListEmbeddingsByKbFileUIDParams, len(mmListEmbeddingsByKbFileUID.callArgs))
	copy(argCopy, mmListEmbeddingsByKbFileUID.callArgs)

	mmListEmbeddingsByKbFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockListEmbeddingsByKbFileUIDDone returns true if the count of the ListEmbeddingsByKbFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockListEmbeddingsByKbFileUIDDone() bool {
	for _, e := range m.ListEmbeddingsByKbFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListEmbeddingsByKbFileUIDMock.invocationsDone()
}

// MinimockListEmbeddingsByKbFileUIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockListEmbeddingsByKbFileUIDInspect() {
	for _, e := range m.ListEmbeddingsByKbFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.ListEmbeddingsByKbFileUID with params: %#v", *e.params)
		}
	}

	afterListEmbeddingsByKbFileUIDCounter := mm_atomic.LoadUint64(&m.afterListEmbeddingsByKbFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListEmbeddingsByKbFileUIDMock.defaultExpectation != nil && afterListEmbeddingsByKbFileUIDCounter < 1 {
		if m.ListEmbeddingsByKbFileUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.ListEmbeddingsByKbFileUID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.ListEmbeddingsByKbFileUID with params: %#v", *m.ListEmbeddingsByKbFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListEmbeddingsByKbFileUID != nil && afterListEmbeddingsByKbFileUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.ListEmbeddingsByKbFileUID")
	}

	if !m.ListEmbeddingsByKbFileUIDMock.invocationsDone() && afterListEmbeddingsByKbFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.ListEmbeddingsByKbFileUID but found %d calls",
			mm_atomic.LoadUint64(&m.ListEmbeddingsByKbFileUIDMock.expectedInvocations), afterListEmbeddingsByKbFileUIDCounter)
	}
}

type mRepositoryIMockListKnowledgeBaseFiles struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockListKnowledgeBaseFilesExpectation
	expectations       []*RepositoryIMockListKnowledgeBaseFilesExpectation

	callArgs []*RepositoryIMockListKnowledgeBaseFilesParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockListKnowledgeBaseFilesExpectation specifies expectation struct of the RepositoryI.ListKnowledgeBaseFiles
type RepositoryIMockListKnowledgeBaseFilesExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockListKnowledgeBaseFilesParams
	paramPtrs *RepositoryIMockListKnowledgeBaseFilesParamPtrs
	results   *RepositoryIMockListKnowledgeBaseFilesResults
	Counter   uint64
}

// RepositoryIMockListKnowledgeBaseFilesParams contains parameters of the RepositoryI.ListKnowledgeBaseFiles
type RepositoryIMockListKnowledgeBaseFilesParams struct {
	ctx           context.Context
	uid           string
	ownerUID      string
	kbUID         string
	pageSize      int32
	nextPageToken string
	filesUID      []string
}

// RepositoryIMockListKnowledgeBaseFilesParamPtrs contains pointers to parameters of the RepositoryI.ListKnowledgeBaseFiles
type RepositoryIMockListKnowledgeBaseFilesParamPtrs struct {
	ctx           *context.Context
	uid           *string
	ownerUID      *string
	kbUID         *string
	pageSize      *int32
	nextPageToken *string
	filesUID      *[]string
}

// RepositoryIMockListKnowledgeBaseFilesResults contains results of the RepositoryI.ListKnowledgeBaseFiles
type RepositoryIMockListKnowledgeBaseFilesResults struct {
	ka1 []mm_repository.KnowledgeBaseFile
	i1  int
	s1  string
	err error
}

// Expect sets up expected params for RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) Expect(ctx context.Context, uid string, ownerUID string, kbUID string, pageSize int32, nextPageToken string, filesUID []string) *mRepositoryIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by ExpectParams functions")
	}

	mmListKnowledgeBaseFiles.defaultExpectation.params = &RepositoryIMockListKnowledgeBaseFilesParams{ctx, uid, ownerUID, kbUID, pageSize, nextPageToken, filesUID}
	for _, e := range mmListKnowledgeBaseFiles.expectations {
		if minimock.Equal(e.params, mmListKnowledgeBaseFiles.defaultExpectation.params) {
			mmListKnowledgeBaseFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListKnowledgeBaseFiles.defaultExpectation.params)
		}
	}

	return mmListKnowledgeBaseFiles
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBaseFilesParamPtrs{}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListKnowledgeBaseFiles
}

// ExpectUidParam2 sets up expected param uid for RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) ExpectUidParam2(uid string) *mRepositoryIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBaseFilesParamPtrs{}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs.uid = &uid

	return mmListKnowledgeBaseFiles
}

// ExpectOwnerUIDParam3 sets up expected param ownerUID for RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) ExpectOwnerUIDParam3(ownerUID string) *mRepositoryIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBaseFilesParamPtrs{}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs.ownerUID = &ownerUID

	return mmListKnowledgeBaseFiles
}

// ExpectKbUIDParam4 sets up expected param kbUID for RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) ExpectKbUIDParam4(kbUID string) *mRepositoryIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBaseFilesParamPtrs{}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs.kbUID = &kbUID

	return mmListKnowledgeBaseFiles
}

// ExpectPageSizeParam5 sets up expected param pageSize for RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) ExpectPageSizeParam5(pageSize int32) *mRepositoryIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBaseFilesParamPtrs{}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs.pageSize = &pageSize

	return mmListKnowledgeBaseFiles
}

// ExpectNextPageTokenParam6 sets up expected param nextPageToken for RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) ExpectNextPageTokenParam6(nextPageToken string) *mRepositoryIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBaseFilesParamPtrs{}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs.nextPageToken = &nextPageToken

	return mmListKnowledgeBaseFiles
}

// ExpectFilesUIDParam7 sets up expected param filesUID for RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) ExpectFilesUIDParam7(filesUID []string) *mRepositoryIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBaseFilesParamPtrs{}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs.filesUID = &filesUID

	return mmListKnowledgeBaseFiles
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) Inspect(f func(ctx context.Context, uid string, ownerUID string, kbUID string, pageSize int32, nextPageToken string, filesUID []string)) *mRepositoryIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.inspectFuncListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.ListKnowledgeBaseFiles")
	}

	mmListKnowledgeBaseFiles.mock.inspectFuncListKnowledgeBaseFiles = f

	return mmListKnowledgeBaseFiles
}

// Return sets up results that will be returned by RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) Return(ka1 []mm_repository.KnowledgeBaseFile, i1 int, s1 string, err error) *RepositoryIMock {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockListKnowledgeBaseFilesExpectation{mock: mmListKnowledgeBaseFiles.mock}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.results = &RepositoryIMockListKnowledgeBaseFilesResults{ka1, i1, s1, err}
	return mmListKnowledgeBaseFiles.mock
}

// Set uses given function f to mock the RepositoryI.ListKnowledgeBaseFiles method
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) Set(f func(ctx context.Context, uid string, ownerUID string, kbUID string, pageSize int32, nextPageToken string, filesUID []string) (ka1 []mm_repository.KnowledgeBaseFile, i1 int, s1 string, err error)) *RepositoryIMock {
	if mmListKnowledgeBaseFiles.defaultExpectation != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("Default expectation is already set for the RepositoryI.ListKnowledgeBaseFiles method")
	}

	if len(mmListKnowledgeBaseFiles.expectations) > 0 {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("Some expectations are already set for the RepositoryI.ListKnowledgeBaseFiles method")
	}

	mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles = f
	return mmListKnowledgeBaseFiles.mock
}

// When sets expectation for the RepositoryI.ListKnowledgeBaseFiles which will trigger the result defined by the following
// Then helper
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) When(ctx context.Context, uid string, ownerUID string, kbUID string, pageSize int32, nextPageToken string, filesUID []string) *RepositoryIMockListKnowledgeBaseFilesExpectation {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	expectation := &RepositoryIMockListKnowledgeBaseFilesExpectation{
		mock:   mmListKnowledgeBaseFiles.mock,
		params: &RepositoryIMockListKnowledgeBaseFilesParams{ctx, uid, ownerUID, kbUID, pageSize, nextPageToken, filesUID},
	}
	mmListKnowledgeBaseFiles.expectations = append(mmListKnowledgeBaseFiles.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.ListKnowledgeBaseFiles return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockListKnowledgeBaseFilesExpectation) Then(ka1 []mm_repository.KnowledgeBaseFile, i1 int, s1 string, err error) *RepositoryIMock {
	e.results = &RepositoryIMockListKnowledgeBaseFilesResults{ka1, i1, s1, err}
	return e.mock
}

// Times sets number of times RepositoryI.ListKnowledgeBaseFiles should be invoked
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) Times(n uint64) *mRepositoryIMockListKnowledgeBaseFiles {
	if n == 0 {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("Times of RepositoryIMock.ListKnowledgeBaseFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListKnowledgeBaseFiles.expectedInvocations, n)
	return mmListKnowledgeBaseFiles
}

func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) invocationsDone() bool {
	if len(mmListKnowledgeBaseFiles.expectations) == 0 && mmListKnowledgeBaseFiles.defaultExpectation == nil && mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBaseFiles.mock.afterListKnowledgeBaseFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBaseFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListKnowledgeBaseFiles implements repository.RepositoryI
func (mmListKnowledgeBaseFiles *RepositoryIMock) ListKnowledgeBaseFiles(ctx context.Context, uid string, ownerUID string, kbUID string, pageSize int32, nextPageToken string, filesUID []string) (ka1 []mm_repository.KnowledgeBaseFile, i1 int, s1 string, err error) {
	mm_atomic.AddUint64(&mmListKnowledgeBaseFiles.beforeListKnowledgeBaseFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmListKnowledgeBaseFiles.afterListKnowledgeBaseFilesCounter, 1)

	if mmListKnowledgeBaseFiles.inspectFuncListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.inspectFuncListKnowledgeBaseFiles(ctx, uid, ownerUID, kbUID, pageSize, nextPageToken, filesUID)
	}

	mm_params := RepositoryIMockListKnowledgeBaseFilesParams{ctx, uid, ownerUID, kbUID, pageSize, nextPageToken, filesUID}

	// Record call args
	mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.mutex.Lock()
	mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.callArgs = append(mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.callArgs, &mm_params)
	mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.mutex.Unlock()

	for _, e := range mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.i1, e.results.s1, e.results.err
		}
	}

	if mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.params
		mm_want_ptrs := mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockListKnowledgeBaseFilesParams{ctx, uid, ownerUID, kbUID, pageSize, nextPageToken, filesUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ListKnowledgeBaseFiles got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmListKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ListKnowledgeBaseFiles got unexpected parameter uid, want: %#v, got: %#v%s\n", *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmListKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ListKnowledgeBaseFiles got unexpected parameter ownerUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmListKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ListKnowledgeBaseFiles got unexpected parameter kbUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ListKnowledgeBaseFiles got unexpected parameter pageSize, want: %#v, got: %#v%s\n", *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.nextPageToken != nil && !minimock.Equal(*mm_want_ptrs.nextPageToken, mm_got.nextPageToken) {
				mmListKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ListKnowledgeBaseFiles got unexpected parameter nextPageToken, want: %#v, got: %#v%s\n", *mm_want_ptrs.nextPageToken, mm_got.nextPageToken, minimock.Diff(*mm_want_ptrs.nextPageToken, mm_got.nextPageToken))
			}

			if mm_want_ptrs.filesUID != nil && !minimock.Equal(*mm_want_ptrs.filesUID, mm_got.filesUID) {
				mmListKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ListKnowledgeBaseFiles got unexpected parameter filesUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.filesUID, mm_got.filesUID, minimock.Diff(*mm_want_ptrs.filesUID, mm_got.filesUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ListKnowledgeBaseFiles got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmListKnowledgeBaseFiles.t.Fatal("No results are set for the RepositoryIMock.ListKnowledgeBaseFiles")
		}
		return (*mm_results).ka1, (*mm_results).i1, (*mm_results).s1, (*mm_results).err
	}
	if mmListKnowledgeBaseFiles.funcListKnowledgeBaseFiles != nil {
		return mmListKnowledgeBaseFiles.funcListKnowledgeBaseFiles(ctx, uid, ownerUID, kbUID, pageSize, nextPageToken, filesUID)
	}
	mmListKnowledgeBaseFiles.t.Fatalf("Unexpected call to RepositoryIMock.ListKnowledgeBaseFiles. %v %v %v %v %v %v %v", ctx, uid, ownerUID, kbUID, pageSize, nextPageToken, filesUID)
	return
}

// ListKnowledgeBaseFilesAfterCounter returns a count of finished RepositoryIMock.ListKnowledgeBaseFiles invocations
func (mmListKnowledgeBaseFiles *RepositoryIMock) ListKnowledgeBaseFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBaseFiles.afterListKnowledgeBaseFilesCounter)
}

// ListKnowledgeBaseFilesBeforeCounter returns a count of RepositoryIMock.ListKnowledgeBaseFiles invocations
func (mmListKnowledgeBaseFiles *RepositoryIMock) ListKnowledgeBaseFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBaseFiles.beforeListKnowledgeBaseFilesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.ListKnowledgeBaseFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) Calls() []*RepositoryIMockListKnowledgeBaseFilesParams {
	mmListKnowledgeBaseFiles.mutex.RLock()

	argCopy := make([]*RepositoryIMockListKnowledgeBaseFilesParams, len(mmListKnowledgeBaseFiles.callArgs))
	copy(argCopy, mmListKnowledgeBaseFiles.callArgs)

	mmListKnowledgeBaseFiles.mutex.RUnlock()

	return argCopy
}

// MinimockListKnowledgeBaseFilesDone returns true if the count of the ListKnowledgeBaseFiles invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockListKnowledgeBaseFilesDone() bool {
	for _, e := range m.ListKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListKnowledgeBaseFilesMock.invocationsDone()
}

// MinimockListKnowledgeBaseFilesInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockListKnowledgeBaseFilesInspect() {
	for _, e := range m.ListKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.ListKnowledgeBaseFiles with params: %#v", *e.params)
		}
	}

	afterListKnowledgeBaseFilesCounter := mm_atomic.LoadUint64(&m.afterListKnowledgeBaseFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListKnowledgeBaseFilesMock.defaultExpectation != nil && afterListKnowledgeBaseFilesCounter < 1 {
		if m.ListKnowledgeBaseFilesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.ListKnowledgeBaseFiles")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.ListKnowledgeBaseFiles with params: %#v", *m.ListKnowledgeBaseFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListKnowledgeBaseFiles != nil && afterListKnowledgeBaseFilesCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.ListKnowledgeBaseFiles")
	}

	if !m.ListKnowledgeBaseFilesMock.invocationsDone() && afterListKnowledgeBaseFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.ListKnowledgeBaseFiles but found %d calls",
			mm_atomic.LoadUint64(&m.ListKnowledgeBaseFilesMock.expectedInvocations), afterListKnowledgeBaseFilesCounter)
	}
}

type mRepositoryIMockListKnowledgeBases struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockListKnowledgeBasesExpectation
	expectations       []*RepositoryIMockListKnowledgeBasesExpectation

	callArgs []*RepositoryIMockListKnowledgeBasesParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockListKnowledgeBasesExpectation specifies expectation struct of the RepositoryI.ListKnowledgeBases
type RepositoryIMockListKnowledgeBasesExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockListKnowledgeBasesParams
	paramPtrs *RepositoryIMockListKnowledgeBasesParamPtrs
	results   *RepositoryIMockListKnowledgeBasesResults
	Counter   uint64
}

// RepositoryIMockListKnowledgeBasesParams contains parameters of the RepositoryI.ListKnowledgeBases
type RepositoryIMockListKnowledgeBasesParams struct {
	ctx      context.Context
	ownerUID string
}

// RepositoryIMockListKnowledgeBasesParamPtrs contains pointers to parameters of the RepositoryI.ListKnowledgeBases
type RepositoryIMockListKnowledgeBasesParamPtrs struct {
	ctx      *context.Context
	ownerUID *string
}

// RepositoryIMockListKnowledgeBasesResults contains results of the RepositoryI.ListKnowledgeBases
type RepositoryIMockListKnowledgeBasesResults struct {
	ka1 []mm_repository.KnowledgeBase
	err error
}

// Expect sets up expected params for RepositoryI.ListKnowledgeBases
func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) Expect(ctx context.Context, ownerUID string) *mRepositoryIMockListKnowledgeBases {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBases mock is already set by Set")
	}

	if mmListKnowledgeBases.defaultExpectation == nil {
		mmListKnowledgeBases.defaultExpectation = &RepositoryIMockListKnowledgeBasesExpectation{}
	}

	if mmListKnowledgeBases.defaultExpectation.paramPtrs != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBases mock is already set by ExpectParams functions")
	}

	mmListKnowledgeBases.defaultExpectation.params = &RepositoryIMockListKnowledgeBasesParams{ctx, ownerUID}
	for _, e := range mmListKnowledgeBases.expectations {
		if minimock.Equal(e.params, mmListKnowledgeBases.defaultExpectation.params) {
			mmListKnowledgeBases.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListKnowledgeBases.defaultExpectation.params)
		}
	}

	return mmListKnowledgeBases
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.ListKnowledgeBases
func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockListKnowledgeBases {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBases mock is already set by Set")
	}

	if mmListKnowledgeBases.defaultExpectation == nil {
		mmListKnowledgeBases.defaultExpectation = &RepositoryIMockListKnowledgeBasesExpectation{}
	}

	if mmListKnowledgeBases.defaultExpectation.params != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBases mock is already set by Expect")
	}

	if mmListKnowledgeBases.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBases.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBasesParamPtrs{}
	}
	mmListKnowledgeBases.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListKnowledgeBases
}

// ExpectOwnerUIDParam2 sets up expected param ownerUID for RepositoryI.ListKnowledgeBases
func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) ExpectOwnerUIDParam2(ownerUID string) *mRepositoryIMockListKnowledgeBases {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBases mock is already set by Set")
	}

	if mmListKnowledgeBases.defaultExpectation == nil {
		mmListKnowledgeBases.defaultExpectation = &RepositoryIMockListKnowledgeBasesExpectation{}
	}

	if mmListKnowledgeBases.defaultExpectation.params != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBases mock is already set by Expect")
	}

	if mmListKnowledgeBases.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBases.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBasesParamPtrs{}
	}
	mmListKnowledgeBases.defaultExpectation.paramPtrs.ownerUID = &ownerUID

	return mmListKnowledgeBases
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.ListKnowledgeBases
func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) Inspect(f func(ctx context.Context, ownerUID string)) *mRepositoryIMockListKnowledgeBases {
	if mmListKnowledgeBases.mock.inspectFuncListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.ListKnowledgeBases")
	}

	mmListKnowledgeBases.mock.inspectFuncListKnowledgeBases = f

	return mmListKnowledgeBases
}

// Return sets up results that will be returned by RepositoryI.ListKnowledgeBases
func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) Return(ka1 []mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBases mock is already set by Set")
	}

	if mmListKnowledgeBases.defaultExpectation == nil {
		mmListKnowledgeBases.defaultExpectation = &RepositoryIMockListKnowledgeBasesExpectation{mock: mmListKnowledgeBases.mock}
	}
	mmListKnowledgeBases.defaultExpectation.results = &RepositoryIMockListKnowledgeBasesResults{ka1, err}
	return mmListKnowledgeBases.mock
}

// Set uses given function f to mock the RepositoryI.ListKnowledgeBases method
func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) Set(f func(ctx context.Context, ownerUID string) (ka1 []mm_repository.KnowledgeBase, err error)) *RepositoryIMock {
	if mmListKnowledgeBases.defaultExpectation != nil {
		mmListKnowledgeBases.mock.t.Fatalf("Default expectation is already set for the RepositoryI.ListKnowledgeBases method")
	}

	if len(mmListKnowledgeBases.expectations) > 0 {
		mmListKnowledgeBases.mock.t.Fatalf("Some expectations are already set for the RepositoryI.ListKnowledgeBases method")
	}

	mmListKnowledgeBases.mock.funcListKnowledgeBases = f
	return mmListKnowledgeBases.mock
}

// When sets expectation for the RepositoryI.ListKnowledgeBases which will trigger the result defined by the following
// Then helper
func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) When(ctx context.Context, ownerUID string) *RepositoryIMockListKnowledgeBasesExpectation {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBases mock is already set by Set")
	}

	expectation := &RepositoryIMockListKnowledgeBasesExpectation{
		mock:   mmListKnowledgeBases.mock,
		params: &RepositoryIMockListKnowledgeBasesParams{ctx, ownerUID},
	}
	mmListKnowledgeBases.expectations = append(mmListKnowledgeBases.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.ListKnowledgeBases return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockListKnowledgeBasesExpectation) Then(ka1 []mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	e.results = &RepositoryIMockListKnowledgeBasesResults{ka1, err}
	return e.mock
}

// Times sets number of times RepositoryI.ListKnowledgeBases should be invoked
func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) Times(n uint64) *mRepositoryIMockListKnowledgeBases {
	if n == 0 {
		mmListKnowledgeBases.mock.t.Fatalf("Times of RepositoryIMock.ListKnowledgeBases mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListKnowledgeBases.expectedInvocations, n)
	return mmListKnowledgeBases
}

func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) invocationsDone() bool {
	if len(mmListKnowledgeBases.expectations) == 0 && mmListKnowledgeBases.defaultExpectation == nil && mmListKnowledgeBases.mock.funcListKnowledgeBases == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBases.mock.afterListKnowledgeBasesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBases.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListKnowledgeBases implements repository.RepositoryI
func (mmListKnowledgeBases *RepositoryIMock) ListKnowledgeBases(ctx context.Context, ownerUID string) (ka1 []mm_repository.KnowledgeBase, err error) {
	mm_atomic.AddUint64(&mmListKnowledgeBases.beforeListKnowledgeBasesCounter, 1)
	defer mm_atomic.AddUint64(&mmListKnowledgeBases.afterListKnowledgeBasesCounter, 1)

	if mmListKnowledgeBases.inspectFuncListKnowledgeBases != nil {
		mmListKnowledgeBases.inspectFuncListKnowledgeBases(ctx, ownerUID)
	}

	mm_params := RepositoryIMockListKnowledgeBasesParams{ctx, ownerUID}

	// Record call args
	mmListKnowledgeBases.ListKnowledgeBasesMock.mutex.Lock()
	mmListKnowledgeBases.ListKnowledgeBasesMock.callArgs = append(mmListKnowledgeBases.ListKnowledgeBasesMock.callArgs, &mm_params)
	mmListKnowledgeBases.ListKnowledgeBasesMock.mutex.Unlock()

	for _, e := range mmListKnowledgeBases.ListKnowledgeBasesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.Counter, 1)
		mm_want := mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.params
		mm_want_ptrs := mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockListKnowledgeBasesParams{ctx, ownerUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListKnowledgeBases.t.Errorf("RepositoryIMock.ListKnowledgeBases got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmListKnowledgeBases.t.Errorf("RepositoryIMock.ListKnowledgeBases got unexpected parameter ownerUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListKnowledgeBases.t.Errorf("RepositoryIMock.ListKnowledgeBases got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.results
		if mm_results == nil {
			mmListKnowledgeBases.t.Fatal("No results are set for the RepositoryIMock.ListKnowledgeBases")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmListKnowledgeBases.funcListKnowledgeBases != nil {
		return mmListKnowledgeBases.funcListKnowledgeBases(ctx, ownerUID)
	}
	mmListKnowledgeBases.t.Fatalf("Unexpected call to RepositoryIMock.ListKnowledgeBases. %v %v", ctx, ownerUID)
	return
}

// ListKnowledgeBasesAfterCounter returns a count of finished RepositoryIMock.ListKnowledgeBases invocations
func (mmListKnowledgeBases *RepositoryIMock) ListKnowledgeBasesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBases.afterListKnowledgeBasesCounter)
}

// ListKnowledgeBasesBeforeCounter returns a count of RepositoryIMock.ListKnowledgeBases invocations
func (mmListKnowledgeBases *RepositoryIMock) ListKnowledgeBasesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBases.beforeListKnowledgeBasesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.ListKnowledgeBases.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) Calls() []*RepositoryIMockListKnowledgeBasesParams {
	mmListKnowledgeBases.mutex.RLock()

	argCopy := make([]*RepositoryIMockListKnowledgeBasesParams, len(mmListKnowledgeBases.callArgs))
	copy(argCopy, mmListKnowledgeBases.callArgs)

	mmListKnowledgeBases.mutex.RUnlock()

	return argCopy
}

// MinimockListKnowledgeBasesDone returns true if the count of the ListKnowledgeBases invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockListKnowledgeBasesDone() bool {
	for _, e := range m.ListKnowledgeBasesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListKnowledgeBasesMock.invocationsDone()
}

// MinimockListKnowledgeBasesInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockListKnowledgeBasesInspect() {
	for _, e := range m.ListKnowledgeBasesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.ListKnowledgeBases with params: %#v", *e.params)
		}
	}

	afterListKnowledgeBasesCounter := mm_atomic.LoadUint64(&m.afterListKnowledgeBasesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListKnowledgeBasesMock.defaultExpectation != nil && afterListKnowledgeBasesCounter < 1 {
		if m.ListKnowledgeBasesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.ListKnowledgeBases")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.ListKnowledgeBases with params: %#v", *m.ListKnowledgeBasesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListKnowledgeBases != nil && afterListKnowledgeBasesCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.ListKnowledgeBases")
	}

	if !m.ListKnowledgeBasesMock.invocationsDone() && afterListKnowledgeBasesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.ListKnowledgeBases but found %d calls",
			mm_atomic.LoadUint64(&m.ListKnowledgeBasesMock.expectedInvocations), afterListKnowledgeBasesCounter)
	}
}

type mRepositoryIMockListKnowledgeBasesByCatalogType struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockListKnowledgeBasesByCatalogTypeExpectation
	expectations       []*RepositoryIMockListKnowledgeBasesByCatalogTypeExpectation

	callArgs []*RepositoryIMockListKnowledgeBasesByCatalogTypeParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockListKnowledgeBasesByCatalogTypeExpectation specifies expectation struct of the RepositoryI.ListKnowledgeBasesByCatalogType
type RepositoryIMockListKnowledgeBasesByCatalogTypeExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockListKnowledgeBasesByCatalogTypeParams
	paramPtrs *RepositoryIMockListKnowledgeBasesByCatalogTypeParamPtrs
	results   *RepositoryIMockListKnowledgeBasesByCatalogTypeResults
	Counter   uint64
}

// RepositoryIMockListKnowledgeBasesByCatalogTypeParams contains parameters of the RepositoryI.ListKnowledgeBasesByCatalogType
type RepositoryIMockListKnowledgeBasesByCatalogTypeParams struct {
	ctx         context.Context
	ownerUID    string
	catalogType artifactpb.CatalogType
}

// RepositoryIMockListKnowledgeBasesByCatalogTypeParamPtrs contains pointers to parameters of the RepositoryI.ListKnowledgeBasesByCatalogType
type RepositoryIMockListKnowledgeBasesByCatalogTypeParamPtrs struct {
	ctx         *context.Context
	ownerUID    *string
	catalogType *artifactpb.CatalogType
}

// RepositoryIMockListKnowledgeBasesByCatalogTypeResults contains results of the RepositoryI.ListKnowledgeBasesByCatalogType
type RepositoryIMockListKnowledgeBasesByCatalogTypeResults struct {
	ka1 []mm_repository.KnowledgeBase
	err error
}

// Expect sets up expected params for RepositoryI.ListKnowledgeBasesByCatalogType
func (mmListKnowledgeBasesByCatalogType *mRepositoryIMockListKnowledgeBasesByCatalogType) Expect(ctx context.Context, ownerUID string, catalogType artifactpb.CatalogType) *mRepositoryIMockListKnowledgeBasesByCatalogType {
	if mmListKnowledgeBasesByCatalogType.mock.funcListKnowledgeBasesByCatalogType != nil {
		mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBasesByCatalogType mock is already set by Set")
	}

	if mmListKnowledgeBasesByCatalogType.defaultExpectation == nil {
		mmListKnowledgeBasesByCatalogType.defaultExpectation = &RepositoryIMockListKnowledgeBasesByCatalogTypeExpectation{}
	}

	if mmListKnowledgeBasesByCatalogType.defaultExpectation.paramPtrs != nil {
		mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBasesByCatalogType mock is already set by ExpectParams functions")
	}

	mmListKnowledgeBasesByCatalogType.defaultExpectation.params = &RepositoryIMockListKnowledgeBasesByCatalogTypeParams{ctx, ownerUID, catalogType}
	for _, e := range mmListKnowledgeBasesByCatalogType.expectations {
		if minimock.Equal(e.params, mmListKnowledgeBasesByCatalogType.defaultExpectation.params) {
			mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListKnowledgeBasesByCatalogType.defaultExpectation.params)
		}
	}

	return mmListKnowledgeBasesByCatalogType
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.ListKnowledgeBasesByCatalogType
func (mmListKnowledgeBasesByCatalogType *mRepositoryIMockListKnowledgeBasesByCatalogType) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockListKnowledgeBasesByCatalogType {
	if mmListKnowledgeBasesByCatalogType.mock.funcListKnowledgeBasesByCatalogType != nil {
		mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBasesByCatalogType mock is already set by Set")
	}

	if mmListKnowledgeBasesByCatalogType.defaultExpectation == nil {
		mmListKnowledgeBasesByCatalogType.defaultExpectation = &RepositoryIMockListKnowledgeBasesByCatalogTypeExpectation{}
	}

	if mmListKnowledgeBasesByCatalogType.defaultExpectation.params != nil {
		mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBasesByCatalogType mock is already set by Expect")
	}

	if mmListKnowledgeBasesByCatalogType.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBasesByCatalogType.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBasesByCatalogTypeParamPtrs{}
	}
	mmListKnowledgeBasesByCatalogType.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListKnowledgeBasesByCatalogType
}

// ExpectOwnerUIDParam2 sets up expected param ownerUID for RepositoryI.ListKnowledgeBasesByCatalogType
func (mmListKnowledgeBasesByCatalogType *mRepositoryIMockListKnowledgeBasesByCatalogType) ExpectOwnerUIDParam2(ownerUID string) *mRepositoryIMockListKnowledgeBasesByCatalogType {
	if mmListKnowledgeBasesByCatalogType.mock.funcListKnowledgeBasesByCatalogType != nil {
		mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBasesByCatalogType mock is already set by Set")
	}

	if mmListKnowledgeBasesByCatalogType.defaultExpectation == nil {
		mmListKnowledgeBasesByCatalogType.defaultExpectation = &RepositoryIMockListKnowledgeBasesByCatalogTypeExpectation{}
	}

	if mmListKnowledgeBasesByCatalogType.defaultExpectation.params != nil {
		mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBasesByCatalogType mock is already set by Expect")
	}

	if mmListKnowledgeBasesByCatalogType.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBasesByCatalogType.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBasesByCatalogTypeParamPtrs{}
	}
	mmListKnowledgeBasesByCatalogType.defaultExpectation.paramPtrs.ownerUID = &ownerUID

	return mmListKnowledgeBasesByCatalogType
}

// ExpectCatalogTypeParam3 sets up expected param catalogType for RepositoryI.ListKnowledgeBasesByCatalogType
func (mmListKnowledgeBasesByCatalogType *mRepositoryIMockListKnowledgeBasesByCatalogType) ExpectCatalogTypeParam3(catalogType artifactpb.CatalogType) *mRepositoryIMockListKnowledgeBasesByCatalogType {
	if mmListKnowledgeBasesByCatalogType.mock.funcListKnowledgeBasesByCatalogType != nil {
		mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBasesByCatalogType mock is already set by Set")
	}

	if mmListKnowledgeBasesByCatalogType.defaultExpectation == nil {
		mmListKnowledgeBasesByCatalogType.defaultExpectation = &RepositoryIMockListKnowledgeBasesByCatalogTypeExpectation{}
	}

	if mmListKnowledgeBasesByCatalogType.defaultExpectation.params != nil {
		mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBasesByCatalogType mock is already set by Expect")
	}

	if mmListKnowledgeBasesByCatalogType.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBasesByCatalogType.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBasesByCatalogTypeParamPtrs{}
	}
	mmListKnowledgeBasesByCatalogType.defaultExpectation.paramPtrs.catalogType = &catalogType

	return mmListKnowledgeBasesByCatalogType
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.ListKnowledgeBasesByCatalogType
func (mmListKnowledgeBasesByCatalogType *mRepositoryIMockListKnowledgeBasesByCatalogType) Inspect(f func(ctx context.Context, ownerUID string, catalogType artifactpb.CatalogType)) *mRepositoryIMockListKnowledgeBasesByCatalogType {
	if mmListKnowledgeBasesByCatalogType.mock.inspectFuncListKnowledgeBasesByCatalogType != nil {
		mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.ListKnowledgeBasesByCatalogType")
	}

	mmListKnowledgeBasesByCatalogType.mock.inspectFuncListKnowledgeBasesByCatalogType = f

	return mmListKnowledgeBasesByCatalogType
}

// Return sets up results that will be returned by RepositoryI.ListKnowledgeBasesByCatalogType
func (mmListKnowledgeBasesByCatalogType *mRepositoryIMockListKnowledgeBasesByCatalogType) Return(ka1 []mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	if mmListKnowledgeBasesByCatalogType.mock.funcListKnowledgeBasesByCatalogType != nil {
		mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBasesByCatalogType mock is already set by Set")
	}

	if mmListKnowledgeBasesByCatalogType.defaultExpectation == nil {
		mmListKnowledgeBasesByCatalogType.defaultExpectation = &RepositoryIMockListKnowledgeBasesByCatalogTypeExpectation{mock: mmListKnowledgeBasesByCatalogType.mock}
	}
	mmListKnowledgeBasesByCatalogType.defaultExpectation.results = &RepositoryIMockListKnowledgeBasesByCatalogTypeResults{ka1, err}
	return mmListKnowledgeBasesByCatalogType.mock
}

// Set uses given function f to mock the RepositoryI.ListKnowledgeBasesByCatalogType method
func (mmListKnowledgeBasesByCatalogType *mRepositoryIMockListKnowledgeBasesByCatalogType) Set(f func(ctx context.Context, ownerUID string, catalogType artifactpb.CatalogType) (ka1 []mm_repository.KnowledgeBase, err error)) *RepositoryIMock {
	if mmListKnowledgeBasesByCatalogType.defaultExpectation != nil {
		mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("Default expectation is already set for the RepositoryI.ListKnowledgeBasesByCatalogType method")
	}

	if len(mmListKnowledgeBasesByCatalogType.expectations) > 0 {
		mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("Some expectations are already set for the RepositoryI.ListKnowledgeBasesByCatalogType method")
	}

	mmListKnowledgeBasesByCatalogType.mock.funcListKnowledgeBasesByCatalogType = f
	return mmListKnowledgeBasesByCatalogType.mock
}

// When sets expectation for the RepositoryI.ListKnowledgeBasesByCatalogType which will trigger the result defined by the following
// Then helper
func (mmListKnowledgeBasesByCatalogType *mRepositoryIMockListKnowledgeBasesByCatalogType) When(ctx context.Context, ownerUID string, catalogType artifactpb.CatalogType) *RepositoryIMockListKnowledgeBasesByCatalogTypeExpectation {
	if mmListKnowledgeBasesByCatalogType.mock.funcListKnowledgeBasesByCatalogType != nil {
		mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBasesByCatalogType mock is already set by Set")
	}

	expectation := &RepositoryIMockListKnowledgeBasesByCatalogTypeExpectation{
		mock:   mmListKnowledgeBasesByCatalogType.mock,
		params: &RepositoryIMockListKnowledgeBasesByCatalogTypeParams{ctx, ownerUID, catalogType},
	}
	mmListKnowledgeBasesByCatalogType.expectations = append(mmListKnowledgeBasesByCatalogType.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.ListKnowledgeBasesByCatalogType return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockListKnowledgeBasesByCatalogTypeExpectation) Then(ka1 []mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	e.results = &RepositoryIMockListKnowledgeBasesByCatalogTypeResults{ka1, err}
	return e.mock
}

// Times sets number of times RepositoryI.ListKnowledgeBasesByCatalogType should be invoked
func (mmListKnowledgeBasesByCatalogType *mRepositoryIMockListKnowledgeBasesByCatalogType) Times(n uint64) *mRepositoryIMockListKnowledgeBasesByCatalogType {
	if n == 0 {
		mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("Times of RepositoryIMock.ListKnowledgeBasesByCatalogType mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListKnowledgeBasesByCatalogType.expectedInvocations, n)
	return mmListKnowledgeBasesByCatalogType
}

func (mmListKnowledgeBasesByCatalogType *mRepositoryIMockListKnowledgeBasesByCatalogType) invocationsDone() bool {
	if len(mmListKnowledgeBasesByCatalogType.expectations) == 0 && mmListKnowledgeBasesByCatalogType.defaultExpectation == nil && mmListKnowledgeBasesByCatalogType.mock.funcListKnowledgeBasesByCatalogType == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBasesByCatalogType.mock.afterListKnowledgeBasesByCatalogTypeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBasesByCatalogType.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListKnowledgeBasesByCatalogType implements repository.RepositoryI
func (mmListKnowledgeBasesByCatalogType *RepositoryIMock) ListKnowledgeBasesByCatalogType(ctx context.Context, ownerUID string, catalogType artifactpb.CatalogType) (ka1 []mm_repository.KnowledgeBase, err error) {
	mm_atomic.AddUint64(&mmListKnowledgeBasesByCatalogType.beforeListKnowledgeBasesByCatalogTypeCounter, 1)
	defer mm_atomic.AddUint64(&mmListKnowledgeBasesByCatalogType.afterListKnowledgeBasesByCatalogTypeCounter, 1)

	if mmListKnowledgeBasesByCatalogType.inspectFuncListKnowledgeBasesByCatalogType != nil {
		mmListKnowledgeBasesByCatalogType.inspectFuncListKnowledgeBasesByCatalogType(ctx, ownerUID, catalogType)
	}

	mm_params := RepositoryIMockListKnowledgeBasesByCatalogTypeParams{ctx, ownerUID, catalogType}

	// Record call args
	mmListKnowledgeBasesByCatalogType.ListKnowledgeBasesByCatalogTypeMock.mutex.Lock()
	mmListKnowledgeBasesByCatalogType.ListKnowledgeBasesByCatalogTypeMock.callArgs = append(mmListKnowledgeBasesByCatalogType.ListKnowledgeBasesByCatalogTypeMock.callArgs, &mm_params)
	mmListKnowledgeBasesByCatalogType.ListKnowledgeBasesByCatalogTypeMock.mutex.Unlock()

	for _, e := range mmListKnowledgeBasesByCatalogType.ListKnowledgeBasesByCatalogTypeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmListKnowledgeBasesByCatalogType.ListKnowledgeBasesByCatalogTypeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListKnowledgeBasesByCatalogType.ListKnowledgeBasesByCatalogTypeMock.defaultExpectation.Counter, 1)
		mm_want := mmListKnowledgeBasesByCatalogType.ListKnowledgeBasesByCatalogTypeMock.defaultExpectation.params
		mm_want_ptrs := mmListKnowledgeBasesByCatalogType.ListKnowledgeBasesByCatalogTypeMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockListKnowledgeBasesByCatalogTypeParams{ctx, ownerUID, catalogType}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListKnowledgeBasesByCatalogType.t.Errorf("RepositoryIMock.ListKnowledgeBasesByCatalogType got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmListKnowledgeBasesByCatalogType.t.Errorf("RepositoryIMock.ListKnowledgeBasesByCatalogType got unexpected parameter ownerUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

			if mm_want_ptrs.catalogType != nil && !minimock.Equal(*mm_want_ptrs.catalogType, mm_got.catalogType) {
				mmListKnowledgeBasesByCatalogType.t.Errorf("RepositoryIMock.ListKnowledgeBasesByCatalogType got unexpected parameter catalogType, want: %#v, got: %#v%s\n", *mm_want_ptrs.catalogType, mm_got.catalogType, minimock.Diff(*mm_want_ptrs.catalogType, mm_got.catalogType))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListKnowledgeBasesByCatalogType.t.Errorf("RepositoryIMock.ListKnowledgeBasesByCatalogType got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListKnowledgeBasesByCatalogType.ListKnowledgeBasesByCatalogTypeMock.defaultExpectation.results
		if mm_results == nil {
			mmListKnowledgeBasesByCatalogType.t.Fatal("No results are set for the RepositoryIMock.ListKnowledgeBasesByCatalogType")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmListKnowledgeBasesByCatalogType.funcListKnowledgeBasesByCatalogType != nil {
		return mmListKnowledgeBasesByCatalogType.funcListKnowledgeBasesByCatalogType(ctx, ownerUID, catalogType)
	}
	mmListKnowledgeBasesByCatalogType.t.Fatalf("Unexpected call to RepositoryIMock.ListKnowledgeBasesByCatalogType. %v %v %v", ctx, ownerUID, catalogType)
	return
}

// ListKnowledgeBasesByCatalogTypeAfterCounter returns a count of finished RepositoryIMock.ListKnowledgeBasesByCatalogType invocations
func (mmListKnowledgeBasesByCatalogType *RepositoryIMock) ListKnowledgeBasesByCatalogTypeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBasesByCatalogType.afterListKnowledgeBasesByCatalogTypeCounter)
}

// ListKnowledgeBasesByCatalogTypeBeforeCounter returns a count of RepositoryIMock.ListKnowledgeBasesByCatalogType invocations
func (mmListKnowledgeBasesByCatalogType *RepositoryIMock) ListKnowledgeBasesByCatalogTypeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBasesByCatalogType.beforeListKnowledgeBasesByCatalogTypeCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.ListKnowledgeBasesByCatalogType.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListKnowledgeBasesByCatalogType *mRepositoryIMockListKnowledgeBasesByCatalogType) Calls() []*RepositoryIMockListKnowledgeBasesByCatalogTypeParams {
	mmListKnowledgeBasesByCatalogType.mutex.RLock()

	argCopy := make([]*RepositoryIMockListKnowledgeBasesByCatalogTypeParams, len(mmListKnowledgeBasesByCatalogType.callArgs))
	copy(argCopy, mmListKnowledgeBasesByCatalogType.callArgs)

	mmListKnowledgeBasesByCatalogType.mutex.RUnlock()

	return argCopy
}

// MinimockListKnowledgeBasesByCatalogTypeDone returns true if the count of the ListKnowledgeBasesByCatalogType invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockListKnowledgeBasesByCatalogTypeDone() bool {
	for _, e := range m.ListKnowledgeBasesByCatalogTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListKnowledgeBasesByCatalogTypeMock.invocationsDone()
}

// MinimockListKnowledgeBasesByCatalogTypeInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockListKnowledgeBasesByCatalogTypeInspect() {
	for _, e := range m.ListKnowledgeBasesByCatalogTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.ListKnowledgeBasesByCatalogType with params: %#v", *e.params)
		}
	}

	afterListKnowledgeBasesByCatalogTypeCounter := mm_atomic.LoadUint64(&m.afterListKnowledgeBasesByCatalogTypeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListKnowledgeBasesByCatalogTypeMock.defaultExpectation != nil && afterListKnowledgeBasesByCatalogTypeCounter < 1 {
		if m.ListKnowledgeBasesByCatalogTypeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.ListKnowledgeBasesByCatalogType")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.ListKnowledgeBasesByCatalogType with params: %#v", *m.ListKnowledgeBasesByCatalogTypeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListKnowledgeBasesByCatalogType != nil && afterListKnowledgeBasesByCatalogTypeCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.ListKnowledgeBasesByCatalogType")
	}

	if !m.ListKnowledgeBasesByCatalogTypeMock.invocationsDone() && afterListKnowledgeBasesByCatalogTypeCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.ListKnowledgeBasesByCatalogType but found %d calls",
			mm_atomic.LoadUint64(&m.ListKnowledgeBasesByCatalogTypeMock.expectedInvocations), afterListKnowledgeBasesByCatalogTypeCounter)
	}
}

type mRepositoryIMockProcessKnowledgeBaseFiles struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockProcessKnowledgeBaseFilesExpectation
	expectations       []*RepositoryIMockProcessKnowledgeBaseFilesExpectation

	callArgs []*RepositoryIMockProcessKnowledgeBaseFilesParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockProcessKnowledgeBaseFilesExpectation specifies expectation struct of the RepositoryI.ProcessKnowledgeBaseFiles
type RepositoryIMockProcessKnowledgeBaseFilesExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockProcessKnowledgeBaseFilesParams
	paramPtrs *RepositoryIMockProcessKnowledgeBaseFilesParamPtrs
	results   *RepositoryIMockProcessKnowledgeBaseFilesResults
	Counter   uint64
}

// RepositoryIMockProcessKnowledgeBaseFilesParams contains parameters of the RepositoryI.ProcessKnowledgeBaseFiles
type RepositoryIMockProcessKnowledgeBaseFilesParams struct {
	ctx       context.Context
	fileUIDs  []string
	requester uuid.UUID
}

// RepositoryIMockProcessKnowledgeBaseFilesParamPtrs contains pointers to parameters of the RepositoryI.ProcessKnowledgeBaseFiles
type RepositoryIMockProcessKnowledgeBaseFilesParamPtrs struct {
	ctx       *context.Context
	fileUIDs  *[]string
	requester *uuid.UUID
}

// RepositoryIMockProcessKnowledgeBaseFilesResults contains results of the RepositoryI.ProcessKnowledgeBaseFiles
type RepositoryIMockProcessKnowledgeBaseFilesResults struct {
	ka1 []mm_repository.KnowledgeBaseFile
	err error
}

// Expect sets up expected params for RepositoryI.ProcessKnowledgeBaseFiles
func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) Expect(ctx context.Context, fileUIDs []string, requester uuid.UUID) *mRepositoryIMockProcessKnowledgeBaseFiles {
	if mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ProcessKnowledgeBaseFiles mock is already set by Set")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockProcessKnowledgeBaseFilesExpectation{}
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ProcessKnowledgeBaseFiles mock is already set by ExpectParams functions")
	}

	mmProcessKnowledgeBaseFiles.defaultExpectation.params = &RepositoryIMockProcessKnowledgeBaseFilesParams{ctx, fileUIDs, requester}
	for _, e := range mmProcessKnowledgeBaseFiles.expectations {
		if minimock.Equal(e.params, mmProcessKnowledgeBaseFiles.defaultExpectation.params) {
			mmProcessKnowledgeBaseFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmProcessKnowledgeBaseFiles.defaultExpectation.params)
		}
	}

	return mmProcessKnowledgeBaseFiles
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.ProcessKnowledgeBaseFiles
func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockProcessKnowledgeBaseFiles {
	if mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ProcessKnowledgeBaseFiles mock is already set by Set")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockProcessKnowledgeBaseFilesExpectation{}
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ProcessKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockProcessKnowledgeBaseFilesParamPtrs{}
	}
	mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs.ctx = &ctx

	return mmProcessKnowledgeBaseFiles
}

// ExpectFileUIDsParam2 sets up expected param fileUIDs for RepositoryI.ProcessKnowledgeBaseFiles
func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) ExpectFileUIDsParam2(fileUIDs []string) *mRepositoryIMockProcessKnowledgeBaseFiles {
	if mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ProcessKnowledgeBaseFiles mock is already set by Set")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockProcessKnowledgeBaseFilesExpectation{}
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ProcessKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockProcessKnowledgeBaseFilesParamPtrs{}
	}
	mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs.fileUIDs = &fileUIDs

	return mmProcessKnowledgeBaseFiles
}

// ExpectRequesterParam3 sets up expected param requester for RepositoryI.ProcessKnowledgeBaseFiles
func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) ExpectRequesterParam3(requester uuid.UUID) *mRepositoryIMockProcessKnowledgeBaseFiles {
	if mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ProcessKnowledgeBaseFiles mock is already set by Set")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockProcessKnowledgeBaseFilesExpectation{}
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ProcessKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockProcessKnowledgeBaseFilesParamPtrs{}
	}
	mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs.requester = &requester

	return mmProcessKnowledgeBaseFiles
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.ProcessKnowledgeBaseFiles
func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) Inspect(f func(ctx context.Context, fileUIDs []string, requester uuid.UUID)) *mRepositoryIMockProcessKnowledgeBaseFiles {
	if mmProcessKnowledgeBaseFiles.mock.inspectFuncProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.ProcessKnowledgeBaseFiles")
	}

	mmProcessKnowledgeBaseFiles.mock.inspectFuncProcessKnowledgeBaseFiles = f

	return mmProcessKnowledgeBaseFiles
}

// Return sets up results that will be returned by RepositoryI.ProcessKnowledgeBaseFiles
func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) Return(ka1 []mm_repository.KnowledgeBaseFile, err error) *RepositoryIMock {
	if mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ProcessKnowledgeBaseFiles mock is already set by Set")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockProcessKnowledgeBaseFilesExpectation{mock: mmProcessKnowledgeBaseFiles.mock}
	}
	mmProcessKnowledgeBaseFiles.defaultExpectation.results = &RepositoryIMockProcessKnowledgeBaseFilesResults{ka1, err}
	return mmProcessKnowledgeBaseFiles.mock
}

// Set uses given function f to mock the RepositoryI.ProcessKnowledgeBaseFiles method
func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) Set(f func(ctx context.Context, fileUIDs []string, requester uuid.UUID) (ka1 []mm_repository.KnowledgeBaseFile, err error)) *RepositoryIMock {
	if mmProcessKnowledgeBaseFiles.defaultExpectation != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("Default expectation is already set for the RepositoryI.ProcessKnowledgeBaseFiles method")
	}

	if len(mmProcessKnowledgeBaseFiles.expectations) > 0 {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("Some expectations are already set for the RepositoryI.ProcessKnowledgeBaseFiles method")
	}

	mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles = f
	return mmProcessKnowledgeBaseFiles.mock
}

// When sets expectation for the RepositoryI.ProcessKnowledgeBaseFiles which will trigger the result defined by the following
// Then helper
func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) When(ctx context.Context, fileUIDs []string, requester uuid.UUID) *RepositoryIMockProcessKnowledgeBaseFilesExpectation {
	if mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ProcessKnowledgeBaseFiles mock is already set by Set")
	}

	expectation := &RepositoryIMockProcessKnowledgeBaseFilesExpectation{
		mock:   mmProcessKnowledgeBaseFiles.mock,
		params: &RepositoryIMockProcessKnowledgeBaseFilesParams{ctx, fileUIDs, requester},
	}
	mmProcessKnowledgeBaseFiles.expectations = append(mmProcessKnowledgeBaseFiles.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.ProcessKnowledgeBaseFiles return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockProcessKnowledgeBaseFilesExpectation) Then(ka1 []mm_repository.KnowledgeBaseFile, err error) *RepositoryIMock {
	e.results = &RepositoryIMockProcessKnowledgeBaseFilesResults{ka1, err}
	return e.mock
}

// Times sets number of times RepositoryI.ProcessKnowledgeBaseFiles should be invoked
func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) Times(n uint64) *mRepositoryIMockProcessKnowledgeBaseFiles {
	if n == 0 {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("Times of RepositoryIMock.ProcessKnowledgeBaseFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmProcessKnowledgeBaseFiles.expectedInvocations, n)
	return mmProcessKnowledgeBaseFiles
}

func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) invocationsDone() bool {
	if len(mmProcessKnowledgeBaseFiles.expectations) == 0 && mmProcessKnowledgeBaseFiles.defaultExpectation == nil && mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmProcessKnowledgeBaseFiles.mock.afterProcessKnowledgeBaseFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmProcessKnowledgeBaseFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ProcessKnowledgeBaseFiles implements repository.RepositoryI
func (mmProcessKnowledgeBaseFiles *RepositoryIMock) ProcessKnowledgeBaseFiles(ctx context.Context, fileUIDs []string, requester uuid.UUID) (ka1 []mm_repository.KnowledgeBaseFile, err error) {
	mm_atomic.AddUint64(&mmProcessKnowledgeBaseFiles.beforeProcessKnowledgeBaseFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmProcessKnowledgeBaseFiles.afterProcessKnowledgeBaseFilesCounter, 1)

	if mmProcessKnowledgeBaseFiles.inspectFuncProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.inspectFuncProcessKnowledgeBaseFiles(ctx, fileUIDs, requester)
	}

	mm_params := RepositoryIMockProcessKnowledgeBaseFilesParams{ctx, fileUIDs, requester}

	// Record call args
	mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.mutex.Lock()
	mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.callArgs = append(mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.callArgs, &mm_params)
	mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.mutex.Unlock()

	for _, e := range mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation.params
		mm_want_ptrs := mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockProcessKnowledgeBaseFilesParams{ctx, fileUIDs, requester}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmProcessKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ProcessKnowledgeBaseFiles got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUIDs != nil && !minimock.Equal(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs) {
				mmProcessKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ProcessKnowledgeBaseFiles got unexpected parameter fileUIDs, want: %#v, got: %#v%s\n", *mm_want_ptrs.fileUIDs, mm_got.fileUIDs, minimock.Diff(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs))
			}

			if mm_want_ptrs.requester != nil && !minimock.Equal(*mm_want_ptrs.requester, mm_got.requester) {
				mmProcessKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ProcessKnowledgeBaseFiles got unexpected parameter requester, want: %#v, got: %#v%s\n", *mm_want_ptrs.requester, mm_got.requester, minimock.Diff(*mm_want_ptrs.requester, mm_got.requester))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmProcessKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ProcessKnowledgeBaseFiles got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmProcessKnowledgeBaseFiles.t.Fatal("No results are set for the RepositoryIMock.ProcessKnowledgeBaseFiles")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmProcessKnowledgeBaseFiles.funcProcessKnowledgeBaseFiles != nil {
		return mmProcessKnowledgeBaseFiles.funcProcessKnowledgeBaseFiles(ctx, fileUIDs, requester)
	}
	mmProcessKnowledgeBaseFiles.t.Fatalf("Unexpected call to RepositoryIMock.ProcessKnowledgeBaseFiles. %v %v %v", ctx, fileUIDs, requester)
	return
}

// ProcessKnowledgeBaseFilesAfterCounter returns a count of finished RepositoryIMock.ProcessKnowledgeBaseFiles invocations
func (mmProcessKnowledgeBaseFiles *RepositoryIMock) ProcessKnowledgeBaseFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessKnowledgeBaseFiles.afterProcessKnowledgeBaseFilesCounter)
}

// ProcessKnowledgeBaseFilesBeforeCounter returns a count of RepositoryIMock.ProcessKnowledgeBaseFiles invocations
func (mmProcessKnowledgeBaseFiles *RepositoryIMock) ProcessKnowledgeBaseFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessKnowledgeBaseFiles.beforeProcessKnowledgeBaseFilesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.ProcessKnowledgeBaseFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) Calls() []*RepositoryIMockProcessKnowledgeBaseFilesParams {
	mmProcessKnowledgeBaseFiles.mutex.RLock()

	argCopy := make([]*RepositoryIMockProcessKnowledgeBaseFilesParams, len(mmProcessKnowledgeBaseFiles.callArgs))
	copy(argCopy, mmProcessKnowledgeBaseFiles.callArgs)

	mmProcessKnowledgeBaseFiles.mutex.RUnlock()

	return argCopy
}

// MinimockProcessKnowledgeBaseFilesDone returns true if the count of the ProcessKnowledgeBaseFiles invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockProcessKnowledgeBaseFilesDone() bool {
	for _, e := range m.ProcessKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ProcessKnowledgeBaseFilesMock.invocationsDone()
}

// MinimockProcessKnowledgeBaseFilesInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockProcessKnowledgeBaseFilesInspect() {
	for _, e := range m.ProcessKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.ProcessKnowledgeBaseFiles with params: %#v", *e.params)
		}
	}

	afterProcessKnowledgeBaseFilesCounter := mm_atomic.LoadUint64(&m.afterProcessKnowledgeBaseFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ProcessKnowledgeBaseFilesMock.defaultExpectation != nil && afterProcessKnowledgeBaseFilesCounter < 1 {
		if m.ProcessKnowledgeBaseFilesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.ProcessKnowledgeBaseFiles")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.ProcessKnowledgeBaseFiles with params: %#v", *m.ProcessKnowledgeBaseFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProcessKnowledgeBaseFiles != nil && afterProcessKnowledgeBaseFilesCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.ProcessKnowledgeBaseFiles")
	}

	if !m.ProcessKnowledgeBaseFilesMock.invocationsDone() && afterProcessKnowledgeBaseFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.ProcessKnowledgeBaseFiles but found %d calls",
			mm_atomic.LoadUint64(&m.ProcessKnowledgeBaseFilesMock.expectedInvocations), afterProcessKnowledgeBaseFilesCounter)
	}
}

type mRepositoryIMockTextChunkTableName struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockTextChunkTableNameExpectation
	expectations       []*RepositoryIMockTextChunkTableNameExpectation

	expectedInvocations uint64
}

// RepositoryIMockTextChunkTableNameExpectation specifies expectation struct of the RepositoryI.TextChunkTableName
type RepositoryIMockTextChunkTableNameExpectation struct {
	mock *RepositoryIMock

	results *RepositoryIMockTextChunkTableNameResults
	Counter uint64
}

// RepositoryIMockTextChunkTableNameResults contains results of the RepositoryI.TextChunkTableName
type RepositoryIMockTextChunkTableNameResults struct {
	s1 string
}

// Expect sets up expected params for RepositoryI.TextChunkTableName
func (mmTextChunkTableName *mRepositoryIMockTextChunkTableName) Expect() *mRepositoryIMockTextChunkTableName {
	if mmTextChunkTableName.mock.funcTextChunkTableName != nil {
		mmTextChunkTableName.mock.t.Fatalf("RepositoryIMock.TextChunkTableName mock is already set by Set")
	}

	if mmTextChunkTableName.defaultExpectation == nil {
		mmTextChunkTableName.defaultExpectation = &RepositoryIMockTextChunkTableNameExpectation{}
	}

	return mmTextChunkTableName
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.TextChunkTableName
func (mmTextChunkTableName *mRepositoryIMockTextChunkTableName) Inspect(f func()) *mRepositoryIMockTextChunkTableName {
	if mmTextChunkTableName.mock.inspectFuncTextChunkTableName != nil {
		mmTextChunkTableName.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.TextChunkTableName")
	}

	mmTextChunkTableName.mock.inspectFuncTextChunkTableName = f

	return mmTextChunkTableName
}

// Return sets up results that will be returned by RepositoryI.TextChunkTableName
func (mmTextChunkTableName *mRepositoryIMockTextChunkTableName) Return(s1 string) *RepositoryIMock {
	if mmTextChunkTableName.mock.funcTextChunkTableName != nil {
		mmTextChunkTableName.mock.t.Fatalf("RepositoryIMock.TextChunkTableName mock is already set by Set")
	}

	if mmTextChunkTableName.defaultExpectation == nil {
		mmTextChunkTableName.defaultExpectation = &RepositoryIMockTextChunkTableNameExpectation{mock: mmTextChunkTableName.mock}
	}
	mmTextChunkTableName.defaultExpectation.results = &RepositoryIMockTextChunkTableNameResults{s1}
	return mmTextChunkTableName.mock
}

// Set uses given function f to mock the RepositoryI.TextChunkTableName method
func (mmTextChunkTableName *mRepositoryIMockTextChunkTableName) Set(f func() (s1 string)) *RepositoryIMock {
	if mmTextChunkTableName.defaultExpectation != nil {
		mmTextChunkTableName.mock.t.Fatalf("Default expectation is already set for the RepositoryI.TextChunkTableName method")
	}

	if len(mmTextChunkTableName.expectations) > 0 {
		mmTextChunkTableName.mock.t.Fatalf("Some expectations are already set for the RepositoryI.TextChunkTableName method")
	}

	mmTextChunkTableName.mock.funcTextChunkTableName = f
	return mmTextChunkTableName.mock
}

// Times sets number of times RepositoryI.TextChunkTableName should be invoked
func (mmTextChunkTableName *mRepositoryIMockTextChunkTableName) Times(n uint64) *mRepositoryIMockTextChunkTableName {
	if n == 0 {
		mmTextChunkTableName.mock.t.Fatalf("Times of RepositoryIMock.TextChunkTableName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTextChunkTableName.expectedInvocations, n)
	return mmTextChunkTableName
}

func (mmTextChunkTableName *mRepositoryIMockTextChunkTableName) invocationsDone() bool {
	if len(mmTextChunkTableName.expectations) == 0 && mmTextChunkTableName.defaultExpectation == nil && mmTextChunkTableName.mock.funcTextChunkTableName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTextChunkTableName.mock.afterTextChunkTableNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTextChunkTableName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TextChunkTableName implements repository.RepositoryI
func (mmTextChunkTableName *RepositoryIMock) TextChunkTableName() (s1 string) {
	mm_atomic.AddUint64(&mmTextChunkTableName.beforeTextChunkTableNameCounter, 1)
	defer mm_atomic.AddUint64(&mmTextChunkTableName.afterTextChunkTableNameCounter, 1)

	if mmTextChunkTableName.inspectFuncTextChunkTableName != nil {
		mmTextChunkTableName.inspectFuncTextChunkTableName()
	}

	if mmTextChunkTableName.TextChunkTableNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTextChunkTableName.TextChunkTableNameMock.defaultExpectation.Counter, 1)

		mm_results := mmTextChunkTableName.TextChunkTableNameMock.defaultExpectation.results
		if mm_results == nil {
			mmTextChunkTableName.t.Fatal("No results are set for the RepositoryIMock.TextChunkTableName")
		}
		return (*mm_results).s1
	}
	if mmTextChunkTableName.funcTextChunkTableName != nil {
		return mmTextChunkTableName.funcTextChunkTableName()
	}
	mmTextChunkTableName.t.Fatalf("Unexpected call to RepositoryIMock.TextChunkTableName.")
	return
}

// TextChunkTableNameAfterCounter returns a count of finished RepositoryIMock.TextChunkTableName invocations
func (mmTextChunkTableName *RepositoryIMock) TextChunkTableNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTextChunkTableName.afterTextChunkTableNameCounter)
}

// TextChunkTableNameBeforeCounter returns a count of RepositoryIMock.TextChunkTableName invocations
func (mmTextChunkTableName *RepositoryIMock) TextChunkTableNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTextChunkTableName.beforeTextChunkTableNameCounter)
}

// MinimockTextChunkTableNameDone returns true if the count of the TextChunkTableName invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockTextChunkTableNameDone() bool {
	for _, e := range m.TextChunkTableNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TextChunkTableNameMock.invocationsDone()
}

// MinimockTextChunkTableNameInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockTextChunkTableNameInspect() {
	for _, e := range m.TextChunkTableNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryIMock.TextChunkTableName")
		}
	}

	afterTextChunkTableNameCounter := mm_atomic.LoadUint64(&m.afterTextChunkTableNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TextChunkTableNameMock.defaultExpectation != nil && afterTextChunkTableNameCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.TextChunkTableName")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTextChunkTableName != nil && afterTextChunkTableNameCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.TextChunkTableName")
	}

	if !m.TextChunkTableNameMock.invocationsDone() && afterTextChunkTableNameCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.TextChunkTableName but found %d calls",
			mm_atomic.LoadUint64(&m.TextChunkTableNameMock.expectedInvocations), afterTextChunkTableNameCounter)
	}
}

type mRepositoryIMockUpdateChunk struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockUpdateChunkExpectation
	expectations       []*RepositoryIMockUpdateChunkExpectation

	callArgs []*RepositoryIMockUpdateChunkParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockUpdateChunkExpectation specifies expectation struct of the RepositoryI.UpdateChunk
type RepositoryIMockUpdateChunkExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockUpdateChunkParams
	paramPtrs *RepositoryIMockUpdateChunkParamPtrs
	results   *RepositoryIMockUpdateChunkResults
	Counter   uint64
}

// RepositoryIMockUpdateChunkParams contains parameters of the RepositoryI.UpdateChunk
type RepositoryIMockUpdateChunkParams struct {
	ctx      context.Context
	chunkUID string
	updates  map[string]interface{}
}

// RepositoryIMockUpdateChunkParamPtrs contains pointers to parameters of the RepositoryI.UpdateChunk
type RepositoryIMockUpdateChunkParamPtrs struct {
	ctx      *context.Context
	chunkUID *string
	updates  *map[string]interface{}
}

// RepositoryIMockUpdateChunkResults contains results of the RepositoryI.UpdateChunk
type RepositoryIMockUpdateChunkResults struct {
	tp1 *mm_repository.TextChunk
	err error
}

// Expect sets up expected params for RepositoryI.UpdateChunk
func (mmUpdateChunk *mRepositoryIMockUpdateChunk) Expect(ctx context.Context, chunkUID string, updates map[string]interface{}) *mRepositoryIMockUpdateChunk {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("RepositoryIMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &RepositoryIMockUpdateChunkExpectation{}
	}

	if mmUpdateChunk.defaultExpectation.paramPtrs != nil {
		mmUpdateChunk.mock.t.Fatalf("RepositoryIMock.UpdateChunk mock is already set by ExpectParams functions")
	}

	mmUpdateChunk.defaultExpectation.params = &RepositoryIMockUpdateChunkParams{ctx, chunkUID, updates}
	for _, e := range mmUpdateChunk.expectations {
		if minimock.Equal(e.params, mmUpdateChunk.defaultExpectation.params) {
			mmUpdateChunk.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateChunk.defaultExpectation.params)
		}
	}

	return mmUpdateChunk
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.UpdateChunk
func (mmUpdateChunk *mRepositoryIMockUpdateChunk) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockUpdateChunk {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("RepositoryIMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &RepositoryIMockUpdateChunkExpectation{}
	}

	if mmUpdateChunk.defaultExpectation.params != nil {
		mmUpdateChunk.mock.t.Fatalf("RepositoryIMock.UpdateChunk mock is already set by Expect")
	}

	if mmUpdateChunk.defaultExpectation.paramPtrs == nil {
		mmUpdateChunk.defaultExpectation.paramPtrs = &RepositoryIMockUpdateChunkParamPtrs{}
	}
	mmUpdateChunk.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateChunk
}

// ExpectChunkUIDParam2 sets up expected param chunkUID for RepositoryI.UpdateChunk
func (mmUpdateChunk *mRepositoryIMockUpdateChunk) ExpectChunkUIDParam2(chunkUID string) *mRepositoryIMockUpdateChunk {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("RepositoryIMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &RepositoryIMockUpdateChunkExpectation{}
	}

	if mmUpdateChunk.defaultExpectation.params != nil {
		mmUpdateChunk.mock.t.Fatalf("RepositoryIMock.UpdateChunk mock is already set by Expect")
	}

	if mmUpdateChunk.defaultExpectation.paramPtrs == nil {
		mmUpdateChunk.defaultExpectation.paramPtrs = &RepositoryIMockUpdateChunkParamPtrs{}
	}
	mmUpdateChunk.defaultExpectation.paramPtrs.chunkUID = &chunkUID

	return mmUpdateChunk
}

// ExpectUpdatesParam3 sets up expected param updates for RepositoryI.UpdateChunk
func (mmUpdateChunk *mRepositoryIMockUpdateChunk) ExpectUpdatesParam3(updates map[string]interface{}) *mRepositoryIMockUpdateChunk {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("RepositoryIMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &RepositoryIMockUpdateChunkExpectation{}
	}

	if mmUpdateChunk.defaultExpectation.params != nil {
		mmUpdateChunk.mock.t.Fatalf("RepositoryIMock.UpdateChunk mock is already set by Expect")
	}

	if mmUpdateChunk.defaultExpectation.paramPtrs == nil {
		mmUpdateChunk.defaultExpectation.paramPtrs = &RepositoryIMockUpdateChunkParamPtrs{}
	}
	mmUpdateChunk.defaultExpectation.paramPtrs.updates = &updates

	return mmUpdateChunk
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.UpdateChunk
func (mmUpdateChunk *mRepositoryIMockUpdateChunk) Inspect(f func(ctx context.Context, chunkUID string, updates map[string]interface{})) *mRepositoryIMockUpdateChunk {
	if mmUpdateChunk.mock.inspectFuncUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.UpdateChunk")
	}

	mmUpdateChunk.mock.inspectFuncUpdateChunk = f

	return mmUpdateChunk
}

// Return sets up results that will be returned by RepositoryI.UpdateChunk
func (mmUpdateChunk *mRepositoryIMockUpdateChunk) Return(tp1 *mm_repository.TextChunk, err error) *RepositoryIMock {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("RepositoryIMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &RepositoryIMockUpdateChunkExpectation{mock: mmUpdateChunk.mock}
	}
	mmUpdateChunk.defaultExpectation.results = &RepositoryIMockUpdateChunkResults{tp1, err}
	return mmUpdateChunk.mock
}

// Set uses given function f to mock the RepositoryI.UpdateChunk method
func (mmUpdateChunk *mRepositoryIMockUpdateChunk) Set(f func(ctx context.Context, chunkUID string, updates map[string]interface{}) (tp1 *mm_repository.TextChunk, err error)) *RepositoryIMock {
	if mmUpdateChunk.defaultExpectation != nil {
		mmUpdateChunk.mock.t.Fatalf("Default expectation is already set for the RepositoryI.UpdateChunk method")
	}

	if len(mmUpdateChunk.expectations) > 0 {
		mmUpdateChunk.mock.t.Fatalf("Some expectations are already set for the RepositoryI.UpdateChunk method")
	}

	mmUpdateChunk.mock.funcUpdateChunk = f
	return mmUpdateChunk.mock
}

// When sets expectation for the RepositoryI.UpdateChunk which will trigger the result defined by the following
// Then helper
func (mmUpdateChunk *mRepositoryIMockUpdateChunk) When(ctx context.Context, chunkUID string, updates map[string]interface{}) *RepositoryIMockUpdateChunkExpectation {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("RepositoryIMock.UpdateChunk mock is already set by Set")
	}

	expectation := &RepositoryIMockUpdateChunkExpectation{
		mock:   mmUpdateChunk.mock,
		params: &RepositoryIMockUpdateChunkParams{ctx, chunkUID, updates},
	}
	mmUpdateChunk.expectations = append(mmUpdateChunk.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.UpdateChunk return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockUpdateChunkExpectation) Then(tp1 *mm_repository.TextChunk, err error) *RepositoryIMock {
	e.results = &RepositoryIMockUpdateChunkResults{tp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.UpdateChunk should be invoked
func (mmUpdateChunk *mRepositoryIMockUpdateChunk) Times(n uint64) *mRepositoryIMockUpdateChunk {
	if n == 0 {
		mmUpdateChunk.mock.t.Fatalf("Times of RepositoryIMock.UpdateChunk mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateChunk.expectedInvocations, n)
	return mmUpdateChunk
}

func (mmUpdateChunk *mRepositoryIMockUpdateChunk) invocationsDone() bool {
	if len(mmUpdateChunk.expectations) == 0 && mmUpdateChunk.defaultExpectation == nil && mmUpdateChunk.mock.funcUpdateChunk == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateChunk.mock.afterUpdateChunkCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateChunk.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateChunk implements repository.RepositoryI
func (mmUpdateChunk *RepositoryIMock) UpdateChunk(ctx context.Context, chunkUID string, updates map[string]interface{}) (tp1 *mm_repository.TextChunk, err error) {
	mm_atomic.AddUint64(&mmUpdateChunk.beforeUpdateChunkCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateChunk.afterUpdateChunkCounter, 1)

	if mmUpdateChunk.inspectFuncUpdateChunk != nil {
		mmUpdateChunk.inspectFuncUpdateChunk(ctx, chunkUID, updates)
	}

	mm_params := RepositoryIMockUpdateChunkParams{ctx, chunkUID, updates}

	// Record call args
	mmUpdateChunk.UpdateChunkMock.mutex.Lock()
	mmUpdateChunk.UpdateChunkMock.callArgs = append(mmUpdateChunk.UpdateChunkMock.callArgs, &mm_params)
	mmUpdateChunk.UpdateChunkMock.mutex.Unlock()

	for _, e := range mmUpdateChunk.UpdateChunkMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp1, e.results.err
		}
	}

	if mmUpdateChunk.UpdateChunkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateChunk.UpdateChunkMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateChunk.UpdateChunkMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateChunk.UpdateChunkMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockUpdateChunkParams{ctx, chunkUID, updates}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateChunk.t.Errorf("RepositoryIMock.UpdateChunk got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chunkUID != nil && !minimock.Equal(*mm_want_ptrs.chunkUID, mm_got.chunkUID) {
				mmUpdateChunk.t.Errorf("RepositoryIMock.UpdateChunk got unexpected parameter chunkUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.chunkUID, mm_got.chunkUID, minimock.Diff(*mm_want_ptrs.chunkUID, mm_got.chunkUID))
			}

			if mm_want_ptrs.updates != nil && !minimock.Equal(*mm_want_ptrs.updates, mm_got.updates) {
				mmUpdateChunk.t.Errorf("RepositoryIMock.UpdateChunk got unexpected parameter updates, want: %#v, got: %#v%s\n", *mm_want_ptrs.updates, mm_got.updates, minimock.Diff(*mm_want_ptrs.updates, mm_got.updates))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateChunk.t.Errorf("RepositoryIMock.UpdateChunk got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateChunk.UpdateChunkMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateChunk.t.Fatal("No results are set for the RepositoryIMock.UpdateChunk")
		}
		return (*mm_results).tp1, (*mm_results).err
	}
	if mmUpdateChunk.funcUpdateChunk != nil {
		return mmUpdateChunk.funcUpdateChunk(ctx, chunkUID, updates)
	}
	mmUpdateChunk.t.Fatalf("Unexpected call to RepositoryIMock.UpdateChunk. %v %v %v", ctx, chunkUID, updates)
	return
}

// UpdateChunkAfterCounter returns a count of finished RepositoryIMock.UpdateChunk invocations
func (mmUpdateChunk *RepositoryIMock) UpdateChunkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateChunk.afterUpdateChunkCounter)
}

// UpdateChunkBeforeCounter returns a count of RepositoryIMock.UpdateChunk invocations
func (mmUpdateChunk *RepositoryIMock) UpdateChunkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateChunk.beforeUpdateChunkCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.UpdateChunk.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateChunk *mRepositoryIMockUpdateChunk) Calls() []*RepositoryIMockUpdateChunkParams {
	mmUpdateChunk.mutex.RLock()

	argCopy := make([]*RepositoryIMockUpdateChunkParams, len(mmUpdateChunk.callArgs))
	copy(argCopy, mmUpdateChunk.callArgs)

	mmUpdateChunk.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateChunkDone returns true if the count of the UpdateChunk invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockUpdateChunkDone() bool {
	for _, e := range m.UpdateChunkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateChunkMock.invocationsDone()
}

// MinimockUpdateChunkInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockUpdateChunkInspect() {
	for _, e := range m.UpdateChunkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateChunk with params: %#v", *e.params)
		}
	}

	afterUpdateChunkCounter := mm_atomic.LoadUint64(&m.afterUpdateChunkCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateChunkMock.defaultExpectation != nil && afterUpdateChunkCounter < 1 {
		if m.UpdateChunkMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.UpdateChunk")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateChunk with params: %#v", *m.UpdateChunkMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateChunk != nil && afterUpdateChunkCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.UpdateChunk")
	}

	if !m.UpdateChunkMock.invocationsDone() && afterUpdateChunkCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.UpdateChunk but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateChunkMock.expectedInvocations), afterUpdateChunkCounter)
	}
}

type mRepositoryIMockUpdateKbFileExtraMetaData struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockUpdateKbFileExtraMetaDataExpectation
	expectations       []*RepositoryIMockUpdateKbFileExtraMetaDataExpectation

	callArgs []*RepositoryIMockUpdateKbFileExtraMetaDataParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockUpdateKbFileExtraMetaDataExpectation specifies expectation struct of the RepositoryI.UpdateKbFileExtraMetaData
type RepositoryIMockUpdateKbFileExtraMetaDataExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockUpdateKbFileExtraMetaDataParams
	paramPtrs *RepositoryIMockUpdateKbFileExtraMetaDataParamPtrs
	results   *RepositoryIMockUpdateKbFileExtraMetaDataResults
	Counter   uint64
}

// RepositoryIMockUpdateKbFileExtraMetaDataParams contains parameters of the RepositoryI.UpdateKbFileExtraMetaData
type RepositoryIMockUpdateKbFileExtraMetaDataParams struct {
	ctx            context.Context
	fileUID        uuid.UUID
	failureReason  string
	convertingPipe string
	chunkingPipe   string
	embeddingPipe  string
	processingTime *int64
	convertingTime *int64
	chunkingTime   *int64
	embeddingTime  *int64
}

// RepositoryIMockUpdateKbFileExtraMetaDataParamPtrs contains pointers to parameters of the RepositoryI.UpdateKbFileExtraMetaData
type RepositoryIMockUpdateKbFileExtraMetaDataParamPtrs struct {
	ctx            *context.Context
	fileUID        *uuid.UUID
	failureReason  *string
	convertingPipe *string
	chunkingPipe   *string
	embeddingPipe  *string
	processingTime **int64
	convertingTime **int64
	chunkingTime   **int64
	embeddingTime  **int64
}

// RepositoryIMockUpdateKbFileExtraMetaDataResults contains results of the RepositoryI.UpdateKbFileExtraMetaData
type RepositoryIMockUpdateKbFileExtraMetaDataResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.UpdateKbFileExtraMetaData
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) Expect(ctx context.Context, fileUID uuid.UUID, failureReason string, convertingPipe string, chunkingPipe string, embeddingPipe string, processingTime *int64, convertingTime *int64, chunkingTime *int64, embeddingTime *int64) *mRepositoryIMockUpdateKbFileExtraMetaData {
	if mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Set")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation = &RepositoryIMockUpdateKbFileExtraMetaDataExpectation{}
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by ExpectParams functions")
	}

	mmUpdateKbFileExtraMetaData.defaultExpectation.params = &RepositoryIMockUpdateKbFileExtraMetaDataParams{ctx, fileUID, failureReason, convertingPipe, chunkingPipe, embeddingPipe, processingTime, convertingTime, chunkingTime, embeddingTime}
	for _, e := range mmUpdateKbFileExtraMetaData.expectations {
		if minimock.Equal(e.params, mmUpdateKbFileExtraMetaData.defaultExpectation.params) {
			mmUpdateKbFileExtraMetaData.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateKbFileExtraMetaData.defaultExpectation.params)
		}
	}

	return mmUpdateKbFileExtraMetaData
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.UpdateKbFileExtraMetaData
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockUpdateKbFileExtraMetaData {
	if mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Set")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation = &RepositoryIMockUpdateKbFileExtraMetaDataExpectation{}
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.params != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Expect")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKbFileExtraMetaDataParamPtrs{}
	}
	mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateKbFileExtraMetaData
}

// ExpectFileUIDParam2 sets up expected param fileUID for RepositoryI.UpdateKbFileExtraMetaData
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) ExpectFileUIDParam2(fileUID uuid.UUID) *mRepositoryIMockUpdateKbFileExtraMetaData {
	if mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Set")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation = &RepositoryIMockUpdateKbFileExtraMetaDataExpectation{}
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.params != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Expect")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKbFileExtraMetaDataParamPtrs{}
	}
	mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs.fileUID = &fileUID

	return mmUpdateKbFileExtraMetaData
}

// ExpectFailureReasonParam3 sets up expected param failureReason for RepositoryI.UpdateKbFileExtraMetaData
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) ExpectFailureReasonParam3(failureReason string) *mRepositoryIMockUpdateKbFileExtraMetaData {
	if mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Set")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation = &RepositoryIMockUpdateKbFileExtraMetaDataExpectation{}
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.params != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Expect")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKbFileExtraMetaDataParamPtrs{}
	}
	mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs.failureReason = &failureReason

	return mmUpdateKbFileExtraMetaData
}

// ExpectConvertingPipeParam4 sets up expected param convertingPipe for RepositoryI.UpdateKbFileExtraMetaData
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) ExpectConvertingPipeParam4(convertingPipe string) *mRepositoryIMockUpdateKbFileExtraMetaData {
	if mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Set")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation = &RepositoryIMockUpdateKbFileExtraMetaDataExpectation{}
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.params != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Expect")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKbFileExtraMetaDataParamPtrs{}
	}
	mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs.convertingPipe = &convertingPipe

	return mmUpdateKbFileExtraMetaData
}

// ExpectChunkingPipeParam5 sets up expected param chunkingPipe for RepositoryI.UpdateKbFileExtraMetaData
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) ExpectChunkingPipeParam5(chunkingPipe string) *mRepositoryIMockUpdateKbFileExtraMetaData {
	if mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Set")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation = &RepositoryIMockUpdateKbFileExtraMetaDataExpectation{}
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.params != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Expect")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKbFileExtraMetaDataParamPtrs{}
	}
	mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs.chunkingPipe = &chunkingPipe

	return mmUpdateKbFileExtraMetaData
}

// ExpectEmbeddingPipeParam6 sets up expected param embeddingPipe for RepositoryI.UpdateKbFileExtraMetaData
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) ExpectEmbeddingPipeParam6(embeddingPipe string) *mRepositoryIMockUpdateKbFileExtraMetaData {
	if mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Set")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation = &RepositoryIMockUpdateKbFileExtraMetaDataExpectation{}
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.params != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Expect")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKbFileExtraMetaDataParamPtrs{}
	}
	mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs.embeddingPipe = &embeddingPipe

	return mmUpdateKbFileExtraMetaData
}

// ExpectProcessingTimeParam7 sets up expected param processingTime for RepositoryI.UpdateKbFileExtraMetaData
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) ExpectProcessingTimeParam7(processingTime *int64) *mRepositoryIMockUpdateKbFileExtraMetaData {
	if mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Set")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation = &RepositoryIMockUpdateKbFileExtraMetaDataExpectation{}
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.params != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Expect")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKbFileExtraMetaDataParamPtrs{}
	}
	mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs.processingTime = &processingTime

	return mmUpdateKbFileExtraMetaData
}

// ExpectConvertingTimeParam8 sets up expected param convertingTime for RepositoryI.UpdateKbFileExtraMetaData
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) ExpectConvertingTimeParam8(convertingTime *int64) *mRepositoryIMockUpdateKbFileExtraMetaData {
	if mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Set")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation = &RepositoryIMockUpdateKbFileExtraMetaDataExpectation{}
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.params != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Expect")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKbFileExtraMetaDataParamPtrs{}
	}
	mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs.convertingTime = &convertingTime

	return mmUpdateKbFileExtraMetaData
}

// ExpectChunkingTimeParam9 sets up expected param chunkingTime for RepositoryI.UpdateKbFileExtraMetaData
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) ExpectChunkingTimeParam9(chunkingTime *int64) *mRepositoryIMockUpdateKbFileExtraMetaData {
	if mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Set")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation = &RepositoryIMockUpdateKbFileExtraMetaDataExpectation{}
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.params != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Expect")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKbFileExtraMetaDataParamPtrs{}
	}
	mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs.chunkingTime = &chunkingTime

	return mmUpdateKbFileExtraMetaData
}

// ExpectEmbeddingTimeParam10 sets up expected param embeddingTime for RepositoryI.UpdateKbFileExtraMetaData
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) ExpectEmbeddingTimeParam10(embeddingTime *int64) *mRepositoryIMockUpdateKbFileExtraMetaData {
	if mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Set")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation = &RepositoryIMockUpdateKbFileExtraMetaDataExpectation{}
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.params != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Expect")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKbFileExtraMetaDataParamPtrs{}
	}
	mmUpdateKbFileExtraMetaData.defaultExpectation.paramPtrs.embeddingTime = &embeddingTime

	return mmUpdateKbFileExtraMetaData
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.UpdateKbFileExtraMetaData
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) Inspect(f func(ctx context.Context, fileUID uuid.UUID, failureReason string, convertingPipe string, chunkingPipe string, embeddingPipe string, processingTime *int64, convertingTime *int64, chunkingTime *int64, embeddingTime *int64)) *mRepositoryIMockUpdateKbFileExtraMetaData {
	if mmUpdateKbFileExtraMetaData.mock.inspectFuncUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.UpdateKbFileExtraMetaData")
	}

	mmUpdateKbFileExtraMetaData.mock.inspectFuncUpdateKbFileExtraMetaData = f

	return mmUpdateKbFileExtraMetaData
}

// Return sets up results that will be returned by RepositoryI.UpdateKbFileExtraMetaData
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) Return(err error) *RepositoryIMock {
	if mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Set")
	}

	if mmUpdateKbFileExtraMetaData.defaultExpectation == nil {
		mmUpdateKbFileExtraMetaData.defaultExpectation = &RepositoryIMockUpdateKbFileExtraMetaDataExpectation{mock: mmUpdateKbFileExtraMetaData.mock}
	}
	mmUpdateKbFileExtraMetaData.defaultExpectation.results = &RepositoryIMockUpdateKbFileExtraMetaDataResults{err}
	return mmUpdateKbFileExtraMetaData.mock
}

// Set uses given function f to mock the RepositoryI.UpdateKbFileExtraMetaData method
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) Set(f func(ctx context.Context, fileUID uuid.UUID, failureReason string, convertingPipe string, chunkingPipe string, embeddingPipe string, processingTime *int64, convertingTime *int64, chunkingTime *int64, embeddingTime *int64) (err error)) *RepositoryIMock {
	if mmUpdateKbFileExtraMetaData.defaultExpectation != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("Default expectation is already set for the RepositoryI.UpdateKbFileExtraMetaData method")
	}

	if len(mmUpdateKbFileExtraMetaData.expectations) > 0 {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("Some expectations are already set for the RepositoryI.UpdateKbFileExtraMetaData method")
	}

	mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData = f
	return mmUpdateKbFileExtraMetaData.mock
}

// When sets expectation for the RepositoryI.UpdateKbFileExtraMetaData which will trigger the result defined by the following
// Then helper
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) When(ctx context.Context, fileUID uuid.UUID, failureReason string, convertingPipe string, chunkingPipe string, embeddingPipe string, processingTime *int64, convertingTime *int64, chunkingTime *int64, embeddingTime *int64) *RepositoryIMockUpdateKbFileExtraMetaDataExpectation {
	if mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("RepositoryIMock.UpdateKbFileExtraMetaData mock is already set by Set")
	}

	expectation := &RepositoryIMockUpdateKbFileExtraMetaDataExpectation{
		mock:   mmUpdateKbFileExtraMetaData.mock,
		params: &RepositoryIMockUpdateKbFileExtraMetaDataParams{ctx, fileUID, failureReason, convertingPipe, chunkingPipe, embeddingPipe, processingTime, convertingTime, chunkingTime, embeddingTime},
	}
	mmUpdateKbFileExtraMetaData.expectations = append(mmUpdateKbFileExtraMetaData.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.UpdateKbFileExtraMetaData return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockUpdateKbFileExtraMetaDataExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockUpdateKbFileExtraMetaDataResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.UpdateKbFileExtraMetaData should be invoked
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) Times(n uint64) *mRepositoryIMockUpdateKbFileExtraMetaData {
	if n == 0 {
		mmUpdateKbFileExtraMetaData.mock.t.Fatalf("Times of RepositoryIMock.UpdateKbFileExtraMetaData mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateKbFileExtraMetaData.expectedInvocations, n)
	return mmUpdateKbFileExtraMetaData
}

func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) invocationsDone() bool {
	if len(mmUpdateKbFileExtraMetaData.expectations) == 0 && mmUpdateKbFileExtraMetaData.defaultExpectation == nil && mmUpdateKbFileExtraMetaData.mock.funcUpdateKbFileExtraMetaData == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateKbFileExtraMetaData.mock.afterUpdateKbFileExtraMetaDataCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateKbFileExtraMetaData.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateKbFileExtraMetaData implements repository.RepositoryI
func (mmUpdateKbFileExtraMetaData *RepositoryIMock) UpdateKbFileExtraMetaData(ctx context.Context, fileUID uuid.UUID, failureReason string, convertingPipe string, chunkingPipe string, embeddingPipe string, processingTime *int64, convertingTime *int64, chunkingTime *int64, embeddingTime *int64) (err error) {
	mm_atomic.AddUint64(&mmUpdateKbFileExtraMetaData.beforeUpdateKbFileExtraMetaDataCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateKbFileExtraMetaData.afterUpdateKbFileExtraMetaDataCounter, 1)

	if mmUpdateKbFileExtraMetaData.inspectFuncUpdateKbFileExtraMetaData != nil {
		mmUpdateKbFileExtraMetaData.inspectFuncUpdateKbFileExtraMetaData(ctx, fileUID, failureReason, convertingPipe, chunkingPipe, embeddingPipe, processingTime, convertingTime, chunkingTime, embeddingTime)
	}

	mm_params := RepositoryIMockUpdateKbFileExtraMetaDataParams{ctx, fileUID, failureReason, convertingPipe, chunkingPipe, embeddingPipe, processingTime, convertingTime, chunkingTime, embeddingTime}

	// Record call args
	mmUpdateKbFileExtraMetaData.UpdateKbFileExtraMetaDataMock.mutex.Lock()
	mmUpdateKbFileExtraMetaData.UpdateKbFileExtraMetaDataMock.callArgs = append(mmUpdateKbFileExtraMetaData.UpdateKbFileExtraMetaDataMock.callArgs, &mm_params)
	mmUpdateKbFileExtraMetaData.UpdateKbFileExtraMetaDataMock.mutex.Unlock()

	for _, e := range mmUpdateKbFileExtraMetaData.UpdateKbFileExtraMetaDataMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateKbFileExtraMetaData.UpdateKbFileExtraMetaDataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateKbFileExtraMetaData.UpdateKbFileExtraMetaDataMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateKbFileExtraMetaData.UpdateKbFileExtraMetaDataMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateKbFileExtraMetaData.UpdateKbFileExtraMetaDataMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockUpdateKbFileExtraMetaDataParams{ctx, fileUID, failureReason, convertingPipe, chunkingPipe, embeddingPipe, processingTime, convertingTime, chunkingTime, embeddingTime}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateKbFileExtraMetaData.t.Errorf("RepositoryIMock.UpdateKbFileExtraMetaData got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmUpdateKbFileExtraMetaData.t.Errorf("RepositoryIMock.UpdateKbFileExtraMetaData got unexpected parameter fileUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

			if mm_want_ptrs.failureReason != nil && !minimock.Equal(*mm_want_ptrs.failureReason, mm_got.failureReason) {
				mmUpdateKbFileExtraMetaData.t.Errorf("RepositoryIMock.UpdateKbFileExtraMetaData got unexpected parameter failureReason, want: %#v, got: %#v%s\n", *mm_want_ptrs.failureReason, mm_got.failureReason, minimock.Diff(*mm_want_ptrs.failureReason, mm_got.failureReason))
			}

			if mm_want_ptrs.convertingPipe != nil && !minimock.Equal(*mm_want_ptrs.convertingPipe, mm_got.convertingPipe) {
				mmUpdateKbFileExtraMetaData.t.Errorf("RepositoryIMock.UpdateKbFileExtraMetaData got unexpected parameter convertingPipe, want: %#v, got: %#v%s\n", *mm_want_ptrs.convertingPipe, mm_got.convertingPipe, minimock.Diff(*mm_want_ptrs.convertingPipe, mm_got.convertingPipe))
			}

			if mm_want_ptrs.chunkingPipe != nil && !minimock.Equal(*mm_want_ptrs.chunkingPipe, mm_got.chunkingPipe) {
				mmUpdateKbFileExtraMetaData.t.Errorf("RepositoryIMock.UpdateKbFileExtraMetaData got unexpected parameter chunkingPipe, want: %#v, got: %#v%s\n", *mm_want_ptrs.chunkingPipe, mm_got.chunkingPipe, minimock.Diff(*mm_want_ptrs.chunkingPipe, mm_got.chunkingPipe))
			}

			if mm_want_ptrs.embeddingPipe != nil && !minimock.Equal(*mm_want_ptrs.embeddingPipe, mm_got.embeddingPipe) {
				mmUpdateKbFileExtraMetaData.t.Errorf("RepositoryIMock.UpdateKbFileExtraMetaData got unexpected parameter embeddingPipe, want: %#v, got: %#v%s\n", *mm_want_ptrs.embeddingPipe, mm_got.embeddingPipe, minimock.Diff(*mm_want_ptrs.embeddingPipe, mm_got.embeddingPipe))
			}

			if mm_want_ptrs.processingTime != nil && !minimock.Equal(*mm_want_ptrs.processingTime, mm_got.processingTime) {
				mmUpdateKbFileExtraMetaData.t.Errorf("RepositoryIMock.UpdateKbFileExtraMetaData got unexpected parameter processingTime, want: %#v, got: %#v%s\n", *mm_want_ptrs.processingTime, mm_got.processingTime, minimock.Diff(*mm_want_ptrs.processingTime, mm_got.processingTime))
			}

			if mm_want_ptrs.convertingTime != nil && !minimock.Equal(*mm_want_ptrs.convertingTime, mm_got.convertingTime) {
				mmUpdateKbFileExtraMetaData.t.Errorf("RepositoryIMock.UpdateKbFileExtraMetaData got unexpected parameter convertingTime, want: %#v, got: %#v%s\n", *mm_want_ptrs.convertingTime, mm_got.convertingTime, minimock.Diff(*mm_want_ptrs.convertingTime, mm_got.convertingTime))
			}

			if mm_want_ptrs.chunkingTime != nil && !minimock.Equal(*mm_want_ptrs.chunkingTime, mm_got.chunkingTime) {
				mmUpdateKbFileExtraMetaData.t.Errorf("RepositoryIMock.UpdateKbFileExtraMetaData got unexpected parameter chunkingTime, want: %#v, got: %#v%s\n", *mm_want_ptrs.chunkingTime, mm_got.chunkingTime, minimock.Diff(*mm_want_ptrs.chunkingTime, mm_got.chunkingTime))
			}

			if mm_want_ptrs.embeddingTime != nil && !minimock.Equal(*mm_want_ptrs.embeddingTime, mm_got.embeddingTime) {
				mmUpdateKbFileExtraMetaData.t.Errorf("RepositoryIMock.UpdateKbFileExtraMetaData got unexpected parameter embeddingTime, want: %#v, got: %#v%s\n", *mm_want_ptrs.embeddingTime, mm_got.embeddingTime, minimock.Diff(*mm_want_ptrs.embeddingTime, mm_got.embeddingTime))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateKbFileExtraMetaData.t.Errorf("RepositoryIMock.UpdateKbFileExtraMetaData got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateKbFileExtraMetaData.UpdateKbFileExtraMetaDataMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateKbFileExtraMetaData.t.Fatal("No results are set for the RepositoryIMock.UpdateKbFileExtraMetaData")
		}
		return (*mm_results).err
	}
	if mmUpdateKbFileExtraMetaData.funcUpdateKbFileExtraMetaData != nil {
		return mmUpdateKbFileExtraMetaData.funcUpdateKbFileExtraMetaData(ctx, fileUID, failureReason, convertingPipe, chunkingPipe, embeddingPipe, processingTime, convertingTime, chunkingTime, embeddingTime)
	}
	mmUpdateKbFileExtraMetaData.t.Fatalf("Unexpected call to RepositoryIMock.UpdateKbFileExtraMetaData. %v %v %v %v %v %v %v %v %v %v", ctx, fileUID, failureReason, convertingPipe, chunkingPipe, embeddingPipe, processingTime, convertingTime, chunkingTime, embeddingTime)
	return
}

// UpdateKbFileExtraMetaDataAfterCounter returns a count of finished RepositoryIMock.UpdateKbFileExtraMetaData invocations
func (mmUpdateKbFileExtraMetaData *RepositoryIMock) UpdateKbFileExtraMetaDataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKbFileExtraMetaData.afterUpdateKbFileExtraMetaDataCounter)
}

// UpdateKbFileExtraMetaDataBeforeCounter returns a count of RepositoryIMock.UpdateKbFileExtraMetaData invocations
func (mmUpdateKbFileExtraMetaData *RepositoryIMock) UpdateKbFileExtraMetaDataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKbFileExtraMetaData.beforeUpdateKbFileExtraMetaDataCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.UpdateKbFileExtraMetaData.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateKbFileExtraMetaData *mRepositoryIMockUpdateKbFileExtraMetaData) Calls() []*RepositoryIMockUpdateKbFileExtraMetaDataParams {
	mmUpdateKbFileExtraMetaData.mutex.RLock()

	argCopy := make([]*RepositoryIMockUpdateKbFileExtraMetaDataParams, len(mmUpdateKbFileExtraMetaData.callArgs))
	copy(argCopy, mmUpdateKbFileExtraMetaData.callArgs)

	mmUpdateKbFileExtraMetaData.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateKbFileExtraMetaDataDone returns true if the count of the UpdateKbFileExtraMetaData invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockUpdateKbFileExtraMetaDataDone() bool {
	for _, e := range m.UpdateKbFileExtraMetaDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateKbFileExtraMetaDataMock.invocationsDone()
}

// MinimockUpdateKbFileExtraMetaDataInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockUpdateKbFileExtraMetaDataInspect() {
	for _, e := range m.UpdateKbFileExtraMetaDataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateKbFileExtraMetaData with params: %#v", *e.params)
		}
	}

	afterUpdateKbFileExtraMetaDataCounter := mm_atomic.LoadUint64(&m.afterUpdateKbFileExtraMetaDataCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateKbFileExtraMetaDataMock.defaultExpectation != nil && afterUpdateKbFileExtraMetaDataCounter < 1 {
		if m.UpdateKbFileExtraMetaDataMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.UpdateKbFileExtraMetaData")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateKbFileExtraMetaData with params: %#v", *m.UpdateKbFileExtraMetaDataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateKbFileExtraMetaData != nil && afterUpdateKbFileExtraMetaDataCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.UpdateKbFileExtraMetaData")
	}

	if !m.UpdateKbFileExtraMetaDataMock.invocationsDone() && afterUpdateKbFileExtraMetaDataCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.UpdateKbFileExtraMetaData but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateKbFileExtraMetaDataMock.expectedInvocations), afterUpdateKbFileExtraMetaDataCounter)
	}
}

type mRepositoryIMockUpdateKnowledgeBase struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockUpdateKnowledgeBaseExpectation
	expectations       []*RepositoryIMockUpdateKnowledgeBaseExpectation

	callArgs []*RepositoryIMockUpdateKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockUpdateKnowledgeBaseExpectation specifies expectation struct of the RepositoryI.UpdateKnowledgeBase
type RepositoryIMockUpdateKnowledgeBaseExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockUpdateKnowledgeBaseParams
	paramPtrs *RepositoryIMockUpdateKnowledgeBaseParamPtrs
	results   *RepositoryIMockUpdateKnowledgeBaseResults
	Counter   uint64
}

// RepositoryIMockUpdateKnowledgeBaseParams contains parameters of the RepositoryI.UpdateKnowledgeBase
type RepositoryIMockUpdateKnowledgeBaseParams struct {
	ctx      context.Context
	ownerUID string
	kb       mm_repository.KnowledgeBase
}

// RepositoryIMockUpdateKnowledgeBaseParamPtrs contains pointers to parameters of the RepositoryI.UpdateKnowledgeBase
type RepositoryIMockUpdateKnowledgeBaseParamPtrs struct {
	ctx      *context.Context
	ownerUID *string
	kb       *mm_repository.KnowledgeBase
}

// RepositoryIMockUpdateKnowledgeBaseResults contains results of the RepositoryI.UpdateKnowledgeBase
type RepositoryIMockUpdateKnowledgeBaseResults struct {
	kp1 *mm_repository.KnowledgeBase
	err error
}

// Expect sets up expected params for RepositoryI.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) Expect(ctx context.Context, ownerUID string, kb mm_repository.KnowledgeBase) *mRepositoryIMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmUpdateKnowledgeBase.defaultExpectation.params = &RepositoryIMockUpdateKnowledgeBaseParams{ctx, ownerUID, kb}
	for _, e := range mmUpdateKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmUpdateKnowledgeBase.defaultExpectation.params) {
			mmUpdateKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmUpdateKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.params != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Expect")
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKnowledgeBaseParamPtrs{}
	}
	mmUpdateKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateKnowledgeBase
}

// ExpectOwnerUIDParam2 sets up expected param ownerUID for RepositoryI.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) ExpectOwnerUIDParam2(ownerUID string) *mRepositoryIMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.params != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Expect")
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKnowledgeBaseParamPtrs{}
	}
	mmUpdateKnowledgeBase.defaultExpectation.paramPtrs.ownerUID = &ownerUID

	return mmUpdateKnowledgeBase
}

// ExpectKbParam3 sets up expected param kb for RepositoryI.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) ExpectKbParam3(kb mm_repository.KnowledgeBase) *mRepositoryIMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.params != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Expect")
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKnowledgeBaseParamPtrs{}
	}
	mmUpdateKnowledgeBase.defaultExpectation.paramPtrs.kb = &kb

	return mmUpdateKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) Inspect(f func(ctx context.Context, ownerUID string, kb mm_repository.KnowledgeBase)) *mRepositoryIMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.inspectFuncUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.UpdateKnowledgeBase")
	}

	mmUpdateKnowledgeBase.mock.inspectFuncUpdateKnowledgeBase = f

	return mmUpdateKnowledgeBase
}

// Return sets up results that will be returned by RepositoryI.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) Return(kp1 *mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseExpectation{mock: mmUpdateKnowledgeBase.mock}
	}
	mmUpdateKnowledgeBase.defaultExpectation.results = &RepositoryIMockUpdateKnowledgeBaseResults{kp1, err}
	return mmUpdateKnowledgeBase.mock
}

// Set uses given function f to mock the RepositoryI.UpdateKnowledgeBase method
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) Set(f func(ctx context.Context, ownerUID string, kb mm_repository.KnowledgeBase) (kp1 *mm_repository.KnowledgeBase, err error)) *RepositoryIMock {
	if mmUpdateKnowledgeBase.defaultExpectation != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the RepositoryI.UpdateKnowledgeBase method")
	}

	if len(mmUpdateKnowledgeBase.expectations) > 0 {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the RepositoryI.UpdateKnowledgeBase method")
	}

	mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase = f
	return mmUpdateKnowledgeBase.mock
}

// When sets expectation for the RepositoryI.UpdateKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) When(ctx context.Context, ownerUID string, kb mm_repository.KnowledgeBase) *RepositoryIMockUpdateKnowledgeBaseExpectation {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Set")
	}

	expectation := &RepositoryIMockUpdateKnowledgeBaseExpectation{
		mock:   mmUpdateKnowledgeBase.mock,
		params: &RepositoryIMockUpdateKnowledgeBaseParams{ctx, ownerUID, kb},
	}
	mmUpdateKnowledgeBase.expectations = append(mmUpdateKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.UpdateKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockUpdateKnowledgeBaseExpectation) Then(kp1 *mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	e.results = &RepositoryIMockUpdateKnowledgeBaseResults{kp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.UpdateKnowledgeBase should be invoked
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) Times(n uint64) *mRepositoryIMockUpdateKnowledgeBase {
	if n == 0 {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Times of RepositoryIMock.UpdateKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateKnowledgeBase.expectedInvocations, n)
	return mmUpdateKnowledgeBase
}

func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) invocationsDone() bool {
	if len(mmUpdateKnowledgeBase.expectations) == 0 && mmUpdateKnowledgeBase.defaultExpectation == nil && mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.mock.afterUpdateKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateKnowledgeBase implements repository.RepositoryI
func (mmUpdateKnowledgeBase *RepositoryIMock) UpdateKnowledgeBase(ctx context.Context, ownerUID string, kb mm_repository.KnowledgeBase) (kp1 *mm_repository.KnowledgeBase, err error) {
	mm_atomic.AddUint64(&mmUpdateKnowledgeBase.beforeUpdateKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateKnowledgeBase.afterUpdateKnowledgeBaseCounter, 1)

	if mmUpdateKnowledgeBase.inspectFuncUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.inspectFuncUpdateKnowledgeBase(ctx, ownerUID, kb)
	}

	mm_params := RepositoryIMockUpdateKnowledgeBaseParams{ctx, ownerUID, kb}

	// Record call args
	mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.mutex.Lock()
	mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.callArgs = append(mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.callArgs, &mm_params)
	mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockUpdateKnowledgeBaseParams{ctx, ownerUID, kb}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateKnowledgeBase.t.Errorf("RepositoryIMock.UpdateKnowledgeBase got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmUpdateKnowledgeBase.t.Errorf("RepositoryIMock.UpdateKnowledgeBase got unexpected parameter ownerUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

			if mm_want_ptrs.kb != nil && !minimock.Equal(*mm_want_ptrs.kb, mm_got.kb) {
				mmUpdateKnowledgeBase.t.Errorf("RepositoryIMock.UpdateKnowledgeBase got unexpected parameter kb, want: %#v, got: %#v%s\n", *mm_want_ptrs.kb, mm_got.kb, minimock.Diff(*mm_want_ptrs.kb, mm_got.kb))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateKnowledgeBase.t.Errorf("RepositoryIMock.UpdateKnowledgeBase got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateKnowledgeBase.t.Fatal("No results are set for the RepositoryIMock.UpdateKnowledgeBase")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmUpdateKnowledgeBase.funcUpdateKnowledgeBase != nil {
		return mmUpdateKnowledgeBase.funcUpdateKnowledgeBase(ctx, ownerUID, kb)
	}
	mmUpdateKnowledgeBase.t.Fatalf("Unexpected call to RepositoryIMock.UpdateKnowledgeBase. %v %v %v", ctx, ownerUID, kb)
	return
}

// UpdateKnowledgeBaseAfterCounter returns a count of finished RepositoryIMock.UpdateKnowledgeBase invocations
func (mmUpdateKnowledgeBase *RepositoryIMock) UpdateKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.afterUpdateKnowledgeBaseCounter)
}

// UpdateKnowledgeBaseBeforeCounter returns a count of RepositoryIMock.UpdateKnowledgeBase invocations
func (mmUpdateKnowledgeBase *RepositoryIMock) UpdateKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.beforeUpdateKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.UpdateKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) Calls() []*RepositoryIMockUpdateKnowledgeBaseParams {
	mmUpdateKnowledgeBase.mutex.RLock()

	argCopy := make([]*RepositoryIMockUpdateKnowledgeBaseParams, len(mmUpdateKnowledgeBase.callArgs))
	copy(argCopy, mmUpdateKnowledgeBase.callArgs)

	mmUpdateKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateKnowledgeBaseDone returns true if the count of the UpdateKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockUpdateKnowledgeBaseDone() bool {
	for _, e := range m.UpdateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateKnowledgeBaseMock.invocationsDone()
}

// MinimockUpdateKnowledgeBaseInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockUpdateKnowledgeBaseInspect() {
	for _, e := range m.UpdateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateKnowledgeBase with params: %#v", *e.params)
		}
	}

	afterUpdateKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterUpdateKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateKnowledgeBaseMock.defaultExpectation != nil && afterUpdateKnowledgeBaseCounter < 1 {
		if m.UpdateKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.UpdateKnowledgeBase")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateKnowledgeBase with params: %#v", *m.UpdateKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateKnowledgeBase != nil && afterUpdateKnowledgeBaseCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.UpdateKnowledgeBase")
	}

	if !m.UpdateKnowledgeBaseMock.invocationsDone() && afterUpdateKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.UpdateKnowledgeBase but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateKnowledgeBaseMock.expectedInvocations), afterUpdateKnowledgeBaseCounter)
	}
}

type mRepositoryIMockUpdateKnowledgeBaseFile struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockUpdateKnowledgeBaseFileExpectation
	expectations       []*RepositoryIMockUpdateKnowledgeBaseFileExpectation

	callArgs []*RepositoryIMockUpdateKnowledgeBaseFileParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockUpdateKnowledgeBaseFileExpectation specifies expectation struct of the RepositoryI.UpdateKnowledgeBaseFile
type RepositoryIMockUpdateKnowledgeBaseFileExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockUpdateKnowledgeBaseFileParams
	paramPtrs *RepositoryIMockUpdateKnowledgeBaseFileParamPtrs
	results   *RepositoryIMockUpdateKnowledgeBaseFileResults
	Counter   uint64
}

// RepositoryIMockUpdateKnowledgeBaseFileParams contains parameters of the RepositoryI.UpdateKnowledgeBaseFile
type RepositoryIMockUpdateKnowledgeBaseFileParams struct {
	ctx       context.Context
	fileUID   string
	updateMap map[string]interface{}
}

// RepositoryIMockUpdateKnowledgeBaseFileParamPtrs contains pointers to parameters of the RepositoryI.UpdateKnowledgeBaseFile
type RepositoryIMockUpdateKnowledgeBaseFileParamPtrs struct {
	ctx       *context.Context
	fileUID   *string
	updateMap *map[string]interface{}
}

// RepositoryIMockUpdateKnowledgeBaseFileResults contains results of the RepositoryI.UpdateKnowledgeBaseFile
type RepositoryIMockUpdateKnowledgeBaseFileResults struct {
	kp1 *mm_repository.KnowledgeBaseFile
	err error
}

// Expect sets up expected params for RepositoryI.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) Expect(ctx context.Context, fileUID string, updateMap map[string]interface{}) *mRepositoryIMockUpdateKnowledgeBaseFile {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseFileExpectation{}
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by ExpectParams functions")
	}

	mmUpdateKnowledgeBaseFile.defaultExpectation.params = &RepositoryIMockUpdateKnowledgeBaseFileParams{ctx, fileUID, updateMap}
	for _, e := range mmUpdateKnowledgeBaseFile.expectations {
		if minimock.Equal(e.params, mmUpdateKnowledgeBaseFile.defaultExpectation.params) {
			mmUpdateKnowledgeBaseFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateKnowledgeBaseFile.defaultExpectation.params)
		}
	}

	return mmUpdateKnowledgeBaseFile
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockUpdateKnowledgeBaseFile {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseFileExpectation{}
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKnowledgeBaseFileParamPtrs{}
	}
	mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateKnowledgeBaseFile
}

// ExpectFileUIDParam2 sets up expected param fileUID for RepositoryI.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) ExpectFileUIDParam2(fileUID string) *mRepositoryIMockUpdateKnowledgeBaseFile {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseFileExpectation{}
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKnowledgeBaseFileParamPtrs{}
	}
	mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs.fileUID = &fileUID

	return mmUpdateKnowledgeBaseFile
}

// ExpectUpdateMapParam3 sets up expected param updateMap for RepositoryI.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) ExpectUpdateMapParam3(updateMap map[string]interface{}) *mRepositoryIMockUpdateKnowledgeBaseFile {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseFileExpectation{}
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKnowledgeBaseFileParamPtrs{}
	}
	mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs.updateMap = &updateMap

	return mmUpdateKnowledgeBaseFile
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) Inspect(f func(ctx context.Context, fileUID string, updateMap map[string]interface{})) *mRepositoryIMockUpdateKnowledgeBaseFile {
	if mmUpdateKnowledgeBaseFile.mock.inspectFuncUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.UpdateKnowledgeBaseFile")
	}

	mmUpdateKnowledgeBaseFile.mock.inspectFuncUpdateKnowledgeBaseFile = f

	return mmUpdateKnowledgeBaseFile
}

// Return sets up results that will be returned by RepositoryI.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) Return(kp1 *mm_repository.KnowledgeBaseFile, err error) *RepositoryIMock {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseFileExpectation{mock: mmUpdateKnowledgeBaseFile.mock}
	}
	mmUpdateKnowledgeBaseFile.defaultExpectation.results = &RepositoryIMockUpdateKnowledgeBaseFileResults{kp1, err}
	return mmUpdateKnowledgeBaseFile.mock
}

// Set uses given function f to mock the RepositoryI.UpdateKnowledgeBaseFile method
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) Set(f func(ctx context.Context, fileUID string, updateMap map[string]interface{}) (kp1 *mm_repository.KnowledgeBaseFile, err error)) *RepositoryIMock {
	if mmUpdateKnowledgeBaseFile.defaultExpectation != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("Default expectation is already set for the RepositoryI.UpdateKnowledgeBaseFile method")
	}

	if len(mmUpdateKnowledgeBaseFile.expectations) > 0 {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("Some expectations are already set for the RepositoryI.UpdateKnowledgeBaseFile method")
	}

	mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile = f
	return mmUpdateKnowledgeBaseFile.mock
}

// When sets expectation for the RepositoryI.UpdateKnowledgeBaseFile which will trigger the result defined by the following
// Then helper
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) When(ctx context.Context, fileUID string, updateMap map[string]interface{}) *RepositoryIMockUpdateKnowledgeBaseFileExpectation {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	expectation := &RepositoryIMockUpdateKnowledgeBaseFileExpectation{
		mock:   mmUpdateKnowledgeBaseFile.mock,
		params: &RepositoryIMockUpdateKnowledgeBaseFileParams{ctx, fileUID, updateMap},
	}
	mmUpdateKnowledgeBaseFile.expectations = append(mmUpdateKnowledgeBaseFile.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.UpdateKnowledgeBaseFile return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockUpdateKnowledgeBaseFileExpectation) Then(kp1 *mm_repository.KnowledgeBaseFile, err error) *RepositoryIMock {
	e.results = &RepositoryIMockUpdateKnowledgeBaseFileResults{kp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.UpdateKnowledgeBaseFile should be invoked
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) Times(n uint64) *mRepositoryIMockUpdateKnowledgeBaseFile {
	if n == 0 {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("Times of RepositoryIMock.UpdateKnowledgeBaseFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateKnowledgeBaseFile.expectedInvocations, n)
	return mmUpdateKnowledgeBaseFile
}

func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) invocationsDone() bool {
	if len(mmUpdateKnowledgeBaseFile.expectations) == 0 && mmUpdateKnowledgeBaseFile.defaultExpectation == nil && mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseFile.mock.afterUpdateKnowledgeBaseFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateKnowledgeBaseFile implements repository.RepositoryI
func (mmUpdateKnowledgeBaseFile *RepositoryIMock) UpdateKnowledgeBaseFile(ctx context.Context, fileUID string, updateMap map[string]interface{}) (kp1 *mm_repository.KnowledgeBaseFile, err error) {
	mm_atomic.AddUint64(&mmUpdateKnowledgeBaseFile.beforeUpdateKnowledgeBaseFileCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateKnowledgeBaseFile.afterUpdateKnowledgeBaseFileCounter, 1)

	if mmUpdateKnowledgeBaseFile.inspectFuncUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.inspectFuncUpdateKnowledgeBaseFile(ctx, fileUID, updateMap)
	}

	mm_params := RepositoryIMockUpdateKnowledgeBaseFileParams{ctx, fileUID, updateMap}

	// Record call args
	mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.mutex.Lock()
	mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.callArgs = append(mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.callArgs, &mm_params)
	mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.mutex.Unlock()

	for _, e := range mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockUpdateKnowledgeBaseFileParams{ctx, fileUID, updateMap}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateKnowledgeBaseFile.t.Errorf("RepositoryIMock.UpdateKnowledgeBaseFile got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmUpdateKnowledgeBaseFile.t.Errorf("RepositoryIMock.UpdateKnowledgeBaseFile got unexpected parameter fileUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

			if mm_want_ptrs.updateMap != nil && !minimock.Equal(*mm_want_ptrs.updateMap, mm_got.updateMap) {
				mmUpdateKnowledgeBaseFile.t.Errorf("RepositoryIMock.UpdateKnowledgeBaseFile got unexpected parameter updateMap, want: %#v, got: %#v%s\n", *mm_want_ptrs.updateMap, mm_got.updateMap, minimock.Diff(*mm_want_ptrs.updateMap, mm_got.updateMap))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateKnowledgeBaseFile.t.Errorf("RepositoryIMock.UpdateKnowledgeBaseFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateKnowledgeBaseFile.t.Fatal("No results are set for the RepositoryIMock.UpdateKnowledgeBaseFile")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmUpdateKnowledgeBaseFile.funcUpdateKnowledgeBaseFile != nil {
		return mmUpdateKnowledgeBaseFile.funcUpdateKnowledgeBaseFile(ctx, fileUID, updateMap)
	}
	mmUpdateKnowledgeBaseFile.t.Fatalf("Unexpected call to RepositoryIMock.UpdateKnowledgeBaseFile. %v %v %v", ctx, fileUID, updateMap)
	return
}

// UpdateKnowledgeBaseFileAfterCounter returns a count of finished RepositoryIMock.UpdateKnowledgeBaseFile invocations
func (mmUpdateKnowledgeBaseFile *RepositoryIMock) UpdateKnowledgeBaseFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseFile.afterUpdateKnowledgeBaseFileCounter)
}

// UpdateKnowledgeBaseFileBeforeCounter returns a count of RepositoryIMock.UpdateKnowledgeBaseFile invocations
func (mmUpdateKnowledgeBaseFile *RepositoryIMock) UpdateKnowledgeBaseFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseFile.beforeUpdateKnowledgeBaseFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.UpdateKnowledgeBaseFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) Calls() []*RepositoryIMockUpdateKnowledgeBaseFileParams {
	mmUpdateKnowledgeBaseFile.mutex.RLock()

	argCopy := make([]*RepositoryIMockUpdateKnowledgeBaseFileParams, len(mmUpdateKnowledgeBaseFile.callArgs))
	copy(argCopy, mmUpdateKnowledgeBaseFile.callArgs)

	mmUpdateKnowledgeBaseFile.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateKnowledgeBaseFileDone returns true if the count of the UpdateKnowledgeBaseFile invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockUpdateKnowledgeBaseFileDone() bool {
	for _, e := range m.UpdateKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateKnowledgeBaseFileMock.invocationsDone()
}

// MinimockUpdateKnowledgeBaseFileInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockUpdateKnowledgeBaseFileInspect() {
	for _, e := range m.UpdateKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateKnowledgeBaseFile with params: %#v", *e.params)
		}
	}

	afterUpdateKnowledgeBaseFileCounter := mm_atomic.LoadUint64(&m.afterUpdateKnowledgeBaseFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateKnowledgeBaseFileMock.defaultExpectation != nil && afterUpdateKnowledgeBaseFileCounter < 1 {
		if m.UpdateKnowledgeBaseFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.UpdateKnowledgeBaseFile")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateKnowledgeBaseFile with params: %#v", *m.UpdateKnowledgeBaseFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateKnowledgeBaseFile != nil && afterUpdateKnowledgeBaseFileCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.UpdateKnowledgeBaseFile")
	}

	if !m.UpdateKnowledgeBaseFileMock.invocationsDone() && afterUpdateKnowledgeBaseFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.UpdateKnowledgeBaseFile but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateKnowledgeBaseFileMock.expectedInvocations), afterUpdateKnowledgeBaseFileCounter)
	}
}

type mRepositoryIMockUpdateObject struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockUpdateObjectExpectation
	expectations       []*RepositoryIMockUpdateObjectExpectation

	callArgs []*RepositoryIMockUpdateObjectParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockUpdateObjectExpectation specifies expectation struct of the RepositoryI.UpdateObject
type RepositoryIMockUpdateObjectExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockUpdateObjectParams
	paramPtrs *RepositoryIMockUpdateObjectParamPtrs
	results   *RepositoryIMockUpdateObjectResults
	Counter   uint64
}

// RepositoryIMockUpdateObjectParams contains parameters of the RepositoryI.UpdateObject
type RepositoryIMockUpdateObjectParams struct {
	ctx context.Context
	obj mm_repository.Object
}

// RepositoryIMockUpdateObjectParamPtrs contains pointers to parameters of the RepositoryI.UpdateObject
type RepositoryIMockUpdateObjectParamPtrs struct {
	ctx *context.Context
	obj *mm_repository.Object
}

// RepositoryIMockUpdateObjectResults contains results of the RepositoryI.UpdateObject
type RepositoryIMockUpdateObjectResults struct {
	op1 *mm_repository.Object
	err error
}

// Expect sets up expected params for RepositoryI.UpdateObject
func (mmUpdateObject *mRepositoryIMockUpdateObject) Expect(ctx context.Context, obj mm_repository.Object) *mRepositoryIMockUpdateObject {
	if mmUpdateObject.mock.funcUpdateObject != nil {
		mmUpdateObject.mock.t.Fatalf("RepositoryIMock.UpdateObject mock is already set by Set")
	}

	if mmUpdateObject.defaultExpectation == nil {
		mmUpdateObject.defaultExpectation = &RepositoryIMockUpdateObjectExpectation{}
	}

	if mmUpdateObject.defaultExpectation.paramPtrs != nil {
		mmUpdateObject.mock.t.Fatalf("RepositoryIMock.UpdateObject mock is already set by ExpectParams functions")
	}

	mmUpdateObject.defaultExpectation.params = &RepositoryIMockUpdateObjectParams{ctx, obj}
	for _, e := range mmUpdateObject.expectations {
		if minimock.Equal(e.params, mmUpdateObject.defaultExpectation.params) {
			mmUpdateObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateObject.defaultExpectation.params)
		}
	}

	return mmUpdateObject
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.UpdateObject
func (mmUpdateObject *mRepositoryIMockUpdateObject) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockUpdateObject {
	if mmUpdateObject.mock.funcUpdateObject != nil {
		mmUpdateObject.mock.t.Fatalf("RepositoryIMock.UpdateObject mock is already set by Set")
	}

	if mmUpdateObject.defaultExpectation == nil {
		mmUpdateObject.defaultExpectation = &RepositoryIMockUpdateObjectExpectation{}
	}

	if mmUpdateObject.defaultExpectation.params != nil {
		mmUpdateObject.mock.t.Fatalf("RepositoryIMock.UpdateObject mock is already set by Expect")
	}

	if mmUpdateObject.defaultExpectation.paramPtrs == nil {
		mmUpdateObject.defaultExpectation.paramPtrs = &RepositoryIMockUpdateObjectParamPtrs{}
	}
	mmUpdateObject.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateObject
}

// ExpectObjParam2 sets up expected param obj for RepositoryI.UpdateObject
func (mmUpdateObject *mRepositoryIMockUpdateObject) ExpectObjParam2(obj mm_repository.Object) *mRepositoryIMockUpdateObject {
	if mmUpdateObject.mock.funcUpdateObject != nil {
		mmUpdateObject.mock.t.Fatalf("RepositoryIMock.UpdateObject mock is already set by Set")
	}

	if mmUpdateObject.defaultExpectation == nil {
		mmUpdateObject.defaultExpectation = &RepositoryIMockUpdateObjectExpectation{}
	}

	if mmUpdateObject.defaultExpectation.params != nil {
		mmUpdateObject.mock.t.Fatalf("RepositoryIMock.UpdateObject mock is already set by Expect")
	}

	if mmUpdateObject.defaultExpectation.paramPtrs == nil {
		mmUpdateObject.defaultExpectation.paramPtrs = &RepositoryIMockUpdateObjectParamPtrs{}
	}
	mmUpdateObject.defaultExpectation.paramPtrs.obj = &obj

	return mmUpdateObject
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.UpdateObject
func (mmUpdateObject *mRepositoryIMockUpdateObject) Inspect(f func(ctx context.Context, obj mm_repository.Object)) *mRepositoryIMockUpdateObject {
	if mmUpdateObject.mock.inspectFuncUpdateObject != nil {
		mmUpdateObject.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.UpdateObject")
	}

	mmUpdateObject.mock.inspectFuncUpdateObject = f

	return mmUpdateObject
}

// Return sets up results that will be returned by RepositoryI.UpdateObject
func (mmUpdateObject *mRepositoryIMockUpdateObject) Return(op1 *mm_repository.Object, err error) *RepositoryIMock {
	if mmUpdateObject.mock.funcUpdateObject != nil {
		mmUpdateObject.mock.t.Fatalf("RepositoryIMock.UpdateObject mock is already set by Set")
	}

	if mmUpdateObject.defaultExpectation == nil {
		mmUpdateObject.defaultExpectation = &RepositoryIMockUpdateObjectExpectation{mock: mmUpdateObject.mock}
	}
	mmUpdateObject.defaultExpectation.results = &RepositoryIMockUpdateObjectResults{op1, err}
	return mmUpdateObject.mock
}

// Set uses given function f to mock the RepositoryI.UpdateObject method
func (mmUpdateObject *mRepositoryIMockUpdateObject) Set(f func(ctx context.Context, obj mm_repository.Object) (op1 *mm_repository.Object, err error)) *RepositoryIMock {
	if mmUpdateObject.defaultExpectation != nil {
		mmUpdateObject.mock.t.Fatalf("Default expectation is already set for the RepositoryI.UpdateObject method")
	}

	if len(mmUpdateObject.expectations) > 0 {
		mmUpdateObject.mock.t.Fatalf("Some expectations are already set for the RepositoryI.UpdateObject method")
	}

	mmUpdateObject.mock.funcUpdateObject = f
	return mmUpdateObject.mock
}

// When sets expectation for the RepositoryI.UpdateObject which will trigger the result defined by the following
// Then helper
func (mmUpdateObject *mRepositoryIMockUpdateObject) When(ctx context.Context, obj mm_repository.Object) *RepositoryIMockUpdateObjectExpectation {
	if mmUpdateObject.mock.funcUpdateObject != nil {
		mmUpdateObject.mock.t.Fatalf("RepositoryIMock.UpdateObject mock is already set by Set")
	}

	expectation := &RepositoryIMockUpdateObjectExpectation{
		mock:   mmUpdateObject.mock,
		params: &RepositoryIMockUpdateObjectParams{ctx, obj},
	}
	mmUpdateObject.expectations = append(mmUpdateObject.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.UpdateObject return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockUpdateObjectExpectation) Then(op1 *mm_repository.Object, err error) *RepositoryIMock {
	e.results = &RepositoryIMockUpdateObjectResults{op1, err}
	return e.mock
}

// Times sets number of times RepositoryI.UpdateObject should be invoked
func (mmUpdateObject *mRepositoryIMockUpdateObject) Times(n uint64) *mRepositoryIMockUpdateObject {
	if n == 0 {
		mmUpdateObject.mock.t.Fatalf("Times of RepositoryIMock.UpdateObject mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateObject.expectedInvocations, n)
	return mmUpdateObject
}

func (mmUpdateObject *mRepositoryIMockUpdateObject) invocationsDone() bool {
	if len(mmUpdateObject.expectations) == 0 && mmUpdateObject.defaultExpectation == nil && mmUpdateObject.mock.funcUpdateObject == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateObject.mock.afterUpdateObjectCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateObject.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateObject implements repository.RepositoryI
func (mmUpdateObject *RepositoryIMock) UpdateObject(ctx context.Context, obj mm_repository.Object) (op1 *mm_repository.Object, err error) {
	mm_atomic.AddUint64(&mmUpdateObject.beforeUpdateObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateObject.afterUpdateObjectCounter, 1)

	if mmUpdateObject.inspectFuncUpdateObject != nil {
		mmUpdateObject.inspectFuncUpdateObject(ctx, obj)
	}

	mm_params := RepositoryIMockUpdateObjectParams{ctx, obj}

	// Record call args
	mmUpdateObject.UpdateObjectMock.mutex.Lock()
	mmUpdateObject.UpdateObjectMock.callArgs = append(mmUpdateObject.UpdateObjectMock.callArgs, &mm_params)
	mmUpdateObject.UpdateObjectMock.mutex.Unlock()

	for _, e := range mmUpdateObject.UpdateObjectMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmUpdateObject.UpdateObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateObject.UpdateObjectMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateObject.UpdateObjectMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateObject.UpdateObjectMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockUpdateObjectParams{ctx, obj}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateObject.t.Errorf("RepositoryIMock.UpdateObject got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.obj != nil && !minimock.Equal(*mm_want_ptrs.obj, mm_got.obj) {
				mmUpdateObject.t.Errorf("RepositoryIMock.UpdateObject got unexpected parameter obj, want: %#v, got: %#v%s\n", *mm_want_ptrs.obj, mm_got.obj, minimock.Diff(*mm_want_ptrs.obj, mm_got.obj))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateObject.t.Errorf("RepositoryIMock.UpdateObject got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateObject.UpdateObjectMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateObject.t.Fatal("No results are set for the RepositoryIMock.UpdateObject")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmUpdateObject.funcUpdateObject != nil {
		return mmUpdateObject.funcUpdateObject(ctx, obj)
	}
	mmUpdateObject.t.Fatalf("Unexpected call to RepositoryIMock.UpdateObject. %v %v", ctx, obj)
	return
}

// UpdateObjectAfterCounter returns a count of finished RepositoryIMock.UpdateObject invocations
func (mmUpdateObject *RepositoryIMock) UpdateObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateObject.afterUpdateObjectCounter)
}

// UpdateObjectBeforeCounter returns a count of RepositoryIMock.UpdateObject invocations
func (mmUpdateObject *RepositoryIMock) UpdateObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateObject.beforeUpdateObjectCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.UpdateObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateObject *mRepositoryIMockUpdateObject) Calls() []*RepositoryIMockUpdateObjectParams {
	mmUpdateObject.mutex.RLock()

	argCopy := make([]*RepositoryIMockUpdateObjectParams, len(mmUpdateObject.callArgs))
	copy(argCopy, mmUpdateObject.callArgs)

	mmUpdateObject.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateObjectDone returns true if the count of the UpdateObject invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockUpdateObjectDone() bool {
	for _, e := range m.UpdateObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateObjectMock.invocationsDone()
}

// MinimockUpdateObjectInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockUpdateObjectInspect() {
	for _, e := range m.UpdateObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateObject with params: %#v", *e.params)
		}
	}

	afterUpdateObjectCounter := mm_atomic.LoadUint64(&m.afterUpdateObjectCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateObjectMock.defaultExpectation != nil && afterUpdateObjectCounter < 1 {
		if m.UpdateObjectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.UpdateObject")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateObject with params: %#v", *m.UpdateObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateObject != nil && afterUpdateObjectCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.UpdateObject")
	}

	if !m.UpdateObjectMock.invocationsDone() && afterUpdateObjectCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.UpdateObject but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateObjectMock.expectedInvocations), afterUpdateObjectCounter)
	}
}

type mRepositoryIMockUpdateObjectByUpdateMap struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockUpdateObjectByUpdateMapExpectation
	expectations       []*RepositoryIMockUpdateObjectByUpdateMapExpectation

	callArgs []*RepositoryIMockUpdateObjectByUpdateMapParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockUpdateObjectByUpdateMapExpectation specifies expectation struct of the RepositoryI.UpdateObjectByUpdateMap
type RepositoryIMockUpdateObjectByUpdateMapExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockUpdateObjectByUpdateMapParams
	paramPtrs *RepositoryIMockUpdateObjectByUpdateMapParamPtrs
	results   *RepositoryIMockUpdateObjectByUpdateMapResults
	Counter   uint64
}

// RepositoryIMockUpdateObjectByUpdateMapParams contains parameters of the RepositoryI.UpdateObjectByUpdateMap
type RepositoryIMockUpdateObjectByUpdateMapParams struct {
	ctx       context.Context
	objUID    uuid.UUID
	updateMap map[string]any
}

// RepositoryIMockUpdateObjectByUpdateMapParamPtrs contains pointers to parameters of the RepositoryI.UpdateObjectByUpdateMap
type RepositoryIMockUpdateObjectByUpdateMapParamPtrs struct {
	ctx       *context.Context
	objUID    *uuid.UUID
	updateMap *map[string]any
}

// RepositoryIMockUpdateObjectByUpdateMapResults contains results of the RepositoryI.UpdateObjectByUpdateMap
type RepositoryIMockUpdateObjectByUpdateMapResults struct {
	op1 *mm_repository.Object
	err error
}

// Expect sets up expected params for RepositoryI.UpdateObjectByUpdateMap
func (mmUpdateObjectByUpdateMap *mRepositoryIMockUpdateObjectByUpdateMap) Expect(ctx context.Context, objUID uuid.UUID, updateMap map[string]any) *mRepositoryIMockUpdateObjectByUpdateMap {
	if mmUpdateObjectByUpdateMap.mock.funcUpdateObjectByUpdateMap != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateObjectByUpdateMap mock is already set by Set")
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation == nil {
		mmUpdateObjectByUpdateMap.defaultExpectation = &RepositoryIMockUpdateObjectByUpdateMapExpectation{}
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateObjectByUpdateMap mock is already set by ExpectParams functions")
	}

	mmUpdateObjectByUpdateMap.defaultExpectation.params = &RepositoryIMockUpdateObjectByUpdateMapParams{ctx, objUID, updateMap}
	for _, e := range mmUpdateObjectByUpdateMap.expectations {
		if minimock.Equal(e.params, mmUpdateObjectByUpdateMap.defaultExpectation.params) {
			mmUpdateObjectByUpdateMap.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateObjectByUpdateMap.defaultExpectation.params)
		}
	}

	return mmUpdateObjectByUpdateMap
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.UpdateObjectByUpdateMap
func (mmUpdateObjectByUpdateMap *mRepositoryIMockUpdateObjectByUpdateMap) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockUpdateObjectByUpdateMap {
	if mmUpdateObjectByUpdateMap.mock.funcUpdateObjectByUpdateMap != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateObjectByUpdateMap mock is already set by Set")
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation == nil {
		mmUpdateObjectByUpdateMap.defaultExpectation = &RepositoryIMockUpdateObjectByUpdateMapExpectation{}
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation.params != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateObjectByUpdateMap mock is already set by Expect")
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs == nil {
		mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs = &RepositoryIMockUpdateObjectByUpdateMapParamPtrs{}
	}
	mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateObjectByUpdateMap
}

// ExpectObjUIDParam2 sets up expected param objUID for RepositoryI.UpdateObjectByUpdateMap
func (mmUpdateObjectByUpdateMap *mRepositoryIMockUpdateObjectByUpdateMap) ExpectObjUIDParam2(objUID uuid.UUID) *mRepositoryIMockUpdateObjectByUpdateMap {
	if mmUpdateObjectByUpdateMap.mock.funcUpdateObjectByUpdateMap != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateObjectByUpdateMap mock is already set by Set")
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation == nil {
		mmUpdateObjectByUpdateMap.defaultExpectation = &RepositoryIMockUpdateObjectByUpdateMapExpectation{}
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation.params != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateObjectByUpdateMap mock is already set by Expect")
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs == nil {
		mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs = &RepositoryIMockUpdateObjectByUpdateMapParamPtrs{}
	}
	mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs.objUID = &objUID

	return mmUpdateObjectByUpdateMap
}

// ExpectUpdateMapParam3 sets up expected param updateMap for RepositoryI.UpdateObjectByUpdateMap
func (mmUpdateObjectByUpdateMap *mRepositoryIMockUpdateObjectByUpdateMap) ExpectUpdateMapParam3(updateMap map[string]any) *mRepositoryIMockUpdateObjectByUpdateMap {
	if mmUpdateObjectByUpdateMap.mock.funcUpdateObjectByUpdateMap != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateObjectByUpdateMap mock is already set by Set")
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation == nil {
		mmUpdateObjectByUpdateMap.defaultExpectation = &RepositoryIMockUpdateObjectByUpdateMapExpectation{}
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation.params != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateObjectByUpdateMap mock is already set by Expect")
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs == nil {
		mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs = &RepositoryIMockUpdateObjectByUpdateMapParamPtrs{}
	}
	mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs.updateMap = &updateMap

	return mmUpdateObjectByUpdateMap
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.UpdateObjectByUpdateMap
func (mmUpdateObjectByUpdateMap *mRepositoryIMockUpdateObjectByUpdateMap) Inspect(f func(ctx context.Context, objUID uuid.UUID, updateMap map[string]any)) *mRepositoryIMockUpdateObjectByUpdateMap {
	if mmUpdateObjectByUpdateMap.mock.inspectFuncUpdateObjectByUpdateMap != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.UpdateObjectByUpdateMap")
	}

	mmUpdateObjectByUpdateMap.mock.inspectFuncUpdateObjectByUpdateMap = f

	return mmUpdateObjectByUpdateMap
}

// Return sets up results that will be returned by RepositoryI.UpdateObjectByUpdateMap
func (mmUpdateObjectByUpdateMap *mRepositoryIMockUpdateObjectByUpdateMap) Return(op1 *mm_repository.Object, err error) *RepositoryIMock {
	if mmUpdateObjectByUpdateMap.mock.funcUpdateObjectByUpdateMap != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateObjectByUpdateMap mock is already set by Set")
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation == nil {
		mmUpdateObjectByUpdateMap.defaultExpectation = &RepositoryIMockUpdateObjectByUpdateMapExpectation{mock: mmUpdateObjectByUpdateMap.mock}
	}
	mmUpdateObjectByUpdateMap.defaultExpectation.results = &RepositoryIMockUpdateObjectByUpdateMapResults{op1, err}
	return mmUpdateObjectByUpdateMap.mock
}

// Set uses given function f to mock the RepositoryI.UpdateObjectByUpdateMap method
func (mmUpdateObjectByUpdateMap *mRepositoryIMockUpdateObjectByUpdateMap) Set(f func(ctx context.Context, objUID uuid.UUID, updateMap map[string]any) (op1 *mm_repository.Object, err error)) *RepositoryIMock {
	if mmUpdateObjectByUpdateMap.defaultExpectation != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("Default expectation is already set for the RepositoryI.UpdateObjectByUpdateMap method")
	}

	if len(mmUpdateObjectByUpdateMap.expectations) > 0 {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("Some expectations are already set for the RepositoryI.UpdateObjectByUpdateMap method")
	}

	mmUpdateObjectByUpdateMap.mock.funcUpdateObjectByUpdateMap = f
	return mmUpdateObjectByUpdateMap.mock
}

// When sets expectation for the RepositoryI.UpdateObjectByUpdateMap which will trigger the result defined by the following
// Then helper
func (mmUpdateObjectByUpdateMap *mRepositoryIMockUpdateObjectByUpdateMap) When(ctx context.Context, objUID uuid.UUID, updateMap map[string]any) *RepositoryIMockUpdateObjectByUpdateMapExpectation {
	if mmUpdateObjectByUpdateMap.mock.funcUpdateObjectByUpdateMap != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryIMock.UpdateObjectByUpdateMap mock is already set by Set")
	}

	expectation := &RepositoryIMockUpdateObjectByUpdateMapExpectation{
		mock:   mmUpdateObjectByUpdateMap.mock,
		params: &RepositoryIMockUpdateObjectByUpdateMapParams{ctx, objUID, updateMap},
	}
	mmUpdateObjectByUpdateMap.expectations = append(mmUpdateObjectByUpdateMap.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.UpdateObjectByUpdateMap return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockUpdateObjectByUpdateMapExpectation) Then(op1 *mm_repository.Object, err error) *RepositoryIMock {
	e.results = &RepositoryIMockUpdateObjectByUpdateMapResults{op1, err}
	return e.mock
}

// Times sets number of times RepositoryI.UpdateObjectByUpdateMap should be invoked
func (mmUpdateObjectByUpdateMap *mRepositoryIMockUpdateObjectByUpdateMap) Times(n uint64) *mRepositoryIMockUpdateObjectByUpdateMap {
	if n == 0 {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("Times of RepositoryIMock.UpdateObjectByUpdateMap mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateObjectByUpdateMap.expectedInvocations, n)
	return mmUpdateObjectByUpdateMap
}

func (mmUpdateObjectByUpdateMap *mRepositoryIMockUpdateObjectByUpdateMap) invocationsDone() bool {
	if len(mmUpdateObjectByUpdateMap.expectations) == 0 && mmUpdateObjectByUpdateMap.defaultExpectation == nil && mmUpdateObjectByUpdateMap.mock.funcUpdateObjectByUpdateMap == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateObjectByUpdateMap.mock.afterUpdateObjectByUpdateMapCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateObjectByUpdateMap.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateObjectByUpdateMap implements repository.RepositoryI
func (mmUpdateObjectByUpdateMap *RepositoryIMock) UpdateObjectByUpdateMap(ctx context.Context, objUID uuid.UUID, updateMap map[string]any) (op1 *mm_repository.Object, err error) {
	mm_atomic.AddUint64(&mmUpdateObjectByUpdateMap.beforeUpdateObjectByUpdateMapCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateObjectByUpdateMap.afterUpdateObjectByUpdateMapCounter, 1)

	if mmUpdateObjectByUpdateMap.inspectFuncUpdateObjectByUpdateMap != nil {
		mmUpdateObjectByUpdateMap.inspectFuncUpdateObjectByUpdateMap(ctx, objUID, updateMap)
	}

	mm_params := RepositoryIMockUpdateObjectByUpdateMapParams{ctx, objUID, updateMap}

	// Record call args
	mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.mutex.Lock()
	mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.callArgs = append(mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.callArgs, &mm_params)
	mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.mutex.Unlock()

	for _, e := range mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockUpdateObjectByUpdateMapParams{ctx, objUID, updateMap}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateObjectByUpdateMap.t.Errorf("RepositoryIMock.UpdateObjectByUpdateMap got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objUID != nil && !minimock.Equal(*mm_want_ptrs.objUID, mm_got.objUID) {
				mmUpdateObjectByUpdateMap.t.Errorf("RepositoryIMock.UpdateObjectByUpdateMap got unexpected parameter objUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.objUID, mm_got.objUID, minimock.Diff(*mm_want_ptrs.objUID, mm_got.objUID))
			}

			if mm_want_ptrs.updateMap != nil && !minimock.Equal(*mm_want_ptrs.updateMap, mm_got.updateMap) {
				mmUpdateObjectByUpdateMap.t.Errorf("RepositoryIMock.UpdateObjectByUpdateMap got unexpected parameter updateMap, want: %#v, got: %#v%s\n", *mm_want_ptrs.updateMap, mm_got.updateMap, minimock.Diff(*mm_want_ptrs.updateMap, mm_got.updateMap))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateObjectByUpdateMap.t.Errorf("RepositoryIMock.UpdateObjectByUpdateMap got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateObjectByUpdateMap.t.Fatal("No results are set for the RepositoryIMock.UpdateObjectByUpdateMap")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmUpdateObjectByUpdateMap.funcUpdateObjectByUpdateMap != nil {
		return mmUpdateObjectByUpdateMap.funcUpdateObjectByUpdateMap(ctx, objUID, updateMap)
	}
	mmUpdateObjectByUpdateMap.t.Fatalf("Unexpected call to RepositoryIMock.UpdateObjectByUpdateMap. %v %v %v", ctx, objUID, updateMap)
	return
}

// UpdateObjectByUpdateMapAfterCounter returns a count of finished RepositoryIMock.UpdateObjectByUpdateMap invocations
func (mmUpdateObjectByUpdateMap *RepositoryIMock) UpdateObjectByUpdateMapAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateObjectByUpdateMap.afterUpdateObjectByUpdateMapCounter)
}

// UpdateObjectByUpdateMapBeforeCounter returns a count of RepositoryIMock.UpdateObjectByUpdateMap invocations
func (mmUpdateObjectByUpdateMap *RepositoryIMock) UpdateObjectByUpdateMapBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateObjectByUpdateMap.beforeUpdateObjectByUpdateMapCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.UpdateObjectByUpdateMap.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateObjectByUpdateMap *mRepositoryIMockUpdateObjectByUpdateMap) Calls() []*RepositoryIMockUpdateObjectByUpdateMapParams {
	mmUpdateObjectByUpdateMap.mutex.RLock()

	argCopy := make([]*RepositoryIMockUpdateObjectByUpdateMapParams, len(mmUpdateObjectByUpdateMap.callArgs))
	copy(argCopy, mmUpdateObjectByUpdateMap.callArgs)

	mmUpdateObjectByUpdateMap.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateObjectByUpdateMapDone returns true if the count of the UpdateObjectByUpdateMap invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockUpdateObjectByUpdateMapDone() bool {
	for _, e := range m.UpdateObjectByUpdateMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateObjectByUpdateMapMock.invocationsDone()
}

// MinimockUpdateObjectByUpdateMapInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockUpdateObjectByUpdateMapInspect() {
	for _, e := range m.UpdateObjectByUpdateMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateObjectByUpdateMap with params: %#v", *e.params)
		}
	}

	afterUpdateObjectByUpdateMapCounter := mm_atomic.LoadUint64(&m.afterUpdateObjectByUpdateMapCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateObjectByUpdateMapMock.defaultExpectation != nil && afterUpdateObjectByUpdateMapCounter < 1 {
		if m.UpdateObjectByUpdateMapMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.UpdateObjectByUpdateMap")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateObjectByUpdateMap with params: %#v", *m.UpdateObjectByUpdateMapMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateObjectByUpdateMap != nil && afterUpdateObjectByUpdateMapCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.UpdateObjectByUpdateMap")
	}

	if !m.UpdateObjectByUpdateMapMock.invocationsDone() && afterUpdateObjectByUpdateMapCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.UpdateObjectByUpdateMap but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateObjectByUpdateMapMock.expectedInvocations), afterUpdateObjectByUpdateMapCounter)
	}
}

type mRepositoryIMockUpdateObjectURL struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockUpdateObjectURLExpectation
	expectations       []*RepositoryIMockUpdateObjectURLExpectation

	callArgs []*RepositoryIMockUpdateObjectURLParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockUpdateObjectURLExpectation specifies expectation struct of the RepositoryI.UpdateObjectURL
type RepositoryIMockUpdateObjectURLExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockUpdateObjectURLParams
	paramPtrs *RepositoryIMockUpdateObjectURLParamPtrs
	results   *RepositoryIMockUpdateObjectURLResults
	Counter   uint64
}

// RepositoryIMockUpdateObjectURLParams contains parameters of the RepositoryI.UpdateObjectURL
type RepositoryIMockUpdateObjectURLParams struct {
	ctx       context.Context
	objectURL mm_repository.ObjectURL
}

// RepositoryIMockUpdateObjectURLParamPtrs contains pointers to parameters of the RepositoryI.UpdateObjectURL
type RepositoryIMockUpdateObjectURLParamPtrs struct {
	ctx       *context.Context
	objectURL *mm_repository.ObjectURL
}

// RepositoryIMockUpdateObjectURLResults contains results of the RepositoryI.UpdateObjectURL
type RepositoryIMockUpdateObjectURLResults struct {
	op1 *mm_repository.ObjectURL
	err error
}

// Expect sets up expected params for RepositoryI.UpdateObjectURL
func (mmUpdateObjectURL *mRepositoryIMockUpdateObjectURL) Expect(ctx context.Context, objectURL mm_repository.ObjectURL) *mRepositoryIMockUpdateObjectURL {
	if mmUpdateObjectURL.mock.funcUpdateObjectURL != nil {
		mmUpdateObjectURL.mock.t.Fatalf("RepositoryIMock.UpdateObjectURL mock is already set by Set")
	}

	if mmUpdateObjectURL.defaultExpectation == nil {
		mmUpdateObjectURL.defaultExpectation = &RepositoryIMockUpdateObjectURLExpectation{}
	}

	if mmUpdateObjectURL.defaultExpectation.paramPtrs != nil {
		mmUpdateObjectURL.mock.t.Fatalf("RepositoryIMock.UpdateObjectURL mock is already set by ExpectParams functions")
	}

	mmUpdateObjectURL.defaultExpectation.params = &RepositoryIMockUpdateObjectURLParams{ctx, objectURL}
	for _, e := range mmUpdateObjectURL.expectations {
		if minimock.Equal(e.params, mmUpdateObjectURL.defaultExpectation.params) {
			mmUpdateObjectURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateObjectURL.defaultExpectation.params)
		}
	}

	return mmUpdateObjectURL
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.UpdateObjectURL
func (mmUpdateObjectURL *mRepositoryIMockUpdateObjectURL) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockUpdateObjectURL {
	if mmUpdateObjectURL.mock.funcUpdateObjectURL != nil {
		mmUpdateObjectURL.mock.t.Fatalf("RepositoryIMock.UpdateObjectURL mock is already set by Set")
	}

	if mmUpdateObjectURL.defaultExpectation == nil {
		mmUpdateObjectURL.defaultExpectation = &RepositoryIMockUpdateObjectURLExpectation{}
	}

	if mmUpdateObjectURL.defaultExpectation.params != nil {
		mmUpdateObjectURL.mock.t.Fatalf("RepositoryIMock.UpdateObjectURL mock is already set by Expect")
	}

	if mmUpdateObjectURL.defaultExpectation.paramPtrs == nil {
		mmUpdateObjectURL.defaultExpectation.paramPtrs = &RepositoryIMockUpdateObjectURLParamPtrs{}
	}
	mmUpdateObjectURL.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateObjectURL
}

// ExpectObjectURLParam2 sets up expected param objectURL for RepositoryI.UpdateObjectURL
func (mmUpdateObjectURL *mRepositoryIMockUpdateObjectURL) ExpectObjectURLParam2(objectURL mm_repository.ObjectURL) *mRepositoryIMockUpdateObjectURL {
	if mmUpdateObjectURL.mock.funcUpdateObjectURL != nil {
		mmUpdateObjectURL.mock.t.Fatalf("RepositoryIMock.UpdateObjectURL mock is already set by Set")
	}

	if mmUpdateObjectURL.defaultExpectation == nil {
		mmUpdateObjectURL.defaultExpectation = &RepositoryIMockUpdateObjectURLExpectation{}
	}

	if mmUpdateObjectURL.defaultExpectation.params != nil {
		mmUpdateObjectURL.mock.t.Fatalf("RepositoryIMock.UpdateObjectURL mock is already set by Expect")
	}

	if mmUpdateObjectURL.defaultExpectation.paramPtrs == nil {
		mmUpdateObjectURL.defaultExpectation.paramPtrs = &RepositoryIMockUpdateObjectURLParamPtrs{}
	}
	mmUpdateObjectURL.defaultExpectation.paramPtrs.objectURL = &objectURL

	return mmUpdateObjectURL
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.UpdateObjectURL
func (mmUpdateObjectURL *mRepositoryIMockUpdateObjectURL) Inspect(f func(ctx context.Context, objectURL mm_repository.ObjectURL)) *mRepositoryIMockUpdateObjectURL {
	if mmUpdateObjectURL.mock.inspectFuncUpdateObjectURL != nil {
		mmUpdateObjectURL.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.UpdateObjectURL")
	}

	mmUpdateObjectURL.mock.inspectFuncUpdateObjectURL = f

	return mmUpdateObjectURL
}

// Return sets up results that will be returned by RepositoryI.UpdateObjectURL
func (mmUpdateObjectURL *mRepositoryIMockUpdateObjectURL) Return(op1 *mm_repository.ObjectURL, err error) *RepositoryIMock {
	if mmUpdateObjectURL.mock.funcUpdateObjectURL != nil {
		mmUpdateObjectURL.mock.t.Fatalf("RepositoryIMock.UpdateObjectURL mock is already set by Set")
	}

	if mmUpdateObjectURL.defaultExpectation == nil {
		mmUpdateObjectURL.defaultExpectation = &RepositoryIMockUpdateObjectURLExpectation{mock: mmUpdateObjectURL.mock}
	}
	mmUpdateObjectURL.defaultExpectation.results = &RepositoryIMockUpdateObjectURLResults{op1, err}
	return mmUpdateObjectURL.mock
}

// Set uses given function f to mock the RepositoryI.UpdateObjectURL method
func (mmUpdateObjectURL *mRepositoryIMockUpdateObjectURL) Set(f func(ctx context.Context, objectURL mm_repository.ObjectURL) (op1 *mm_repository.ObjectURL, err error)) *RepositoryIMock {
	if mmUpdateObjectURL.defaultExpectation != nil {
		mmUpdateObjectURL.mock.t.Fatalf("Default expectation is already set for the RepositoryI.UpdateObjectURL method")
	}

	if len(mmUpdateObjectURL.expectations) > 0 {
		mmUpdateObjectURL.mock.t.Fatalf("Some expectations are already set for the RepositoryI.UpdateObjectURL method")
	}

	mmUpdateObjectURL.mock.funcUpdateObjectURL = f
	return mmUpdateObjectURL.mock
}

// When sets expectation for the RepositoryI.UpdateObjectURL which will trigger the result defined by the following
// Then helper
func (mmUpdateObjectURL *mRepositoryIMockUpdateObjectURL) When(ctx context.Context, objectURL mm_repository.ObjectURL) *RepositoryIMockUpdateObjectURLExpectation {
	if mmUpdateObjectURL.mock.funcUpdateObjectURL != nil {
		mmUpdateObjectURL.mock.t.Fatalf("RepositoryIMock.UpdateObjectURL mock is already set by Set")
	}

	expectation := &RepositoryIMockUpdateObjectURLExpectation{
		mock:   mmUpdateObjectURL.mock,
		params: &RepositoryIMockUpdateObjectURLParams{ctx, objectURL},
	}
	mmUpdateObjectURL.expectations = append(mmUpdateObjectURL.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.UpdateObjectURL return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockUpdateObjectURLExpectation) Then(op1 *mm_repository.ObjectURL, err error) *RepositoryIMock {
	e.results = &RepositoryIMockUpdateObjectURLResults{op1, err}
	return e.mock
}

// Times sets number of times RepositoryI.UpdateObjectURL should be invoked
func (mmUpdateObjectURL *mRepositoryIMockUpdateObjectURL) Times(n uint64) *mRepositoryIMockUpdateObjectURL {
	if n == 0 {
		mmUpdateObjectURL.mock.t.Fatalf("Times of RepositoryIMock.UpdateObjectURL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateObjectURL.expectedInvocations, n)
	return mmUpdateObjectURL
}

func (mmUpdateObjectURL *mRepositoryIMockUpdateObjectURL) invocationsDone() bool {
	if len(mmUpdateObjectURL.expectations) == 0 && mmUpdateObjectURL.defaultExpectation == nil && mmUpdateObjectURL.mock.funcUpdateObjectURL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateObjectURL.mock.afterUpdateObjectURLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateObjectURL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateObjectURL implements repository.RepositoryI
func (mmUpdateObjectURL *RepositoryIMock) UpdateObjectURL(ctx context.Context, objectURL mm_repository.ObjectURL) (op1 *mm_repository.ObjectURL, err error) {
	mm_atomic.AddUint64(&mmUpdateObjectURL.beforeUpdateObjectURLCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateObjectURL.afterUpdateObjectURLCounter, 1)

	if mmUpdateObjectURL.inspectFuncUpdateObjectURL != nil {
		mmUpdateObjectURL.inspectFuncUpdateObjectURL(ctx, objectURL)
	}

	mm_params := RepositoryIMockUpdateObjectURLParams{ctx, objectURL}

	// Record call args
	mmUpdateObjectURL.UpdateObjectURLMock.mutex.Lock()
	mmUpdateObjectURL.UpdateObjectURLMock.callArgs = append(mmUpdateObjectURL.UpdateObjectURLMock.callArgs, &mm_params)
	mmUpdateObjectURL.UpdateObjectURLMock.mutex.Unlock()

	for _, e := range mmUpdateObjectURL.UpdateObjectURLMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmUpdateObjectURL.UpdateObjectURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateObjectURL.UpdateObjectURLMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateObjectURL.UpdateObjectURLMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateObjectURL.UpdateObjectURLMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockUpdateObjectURLParams{ctx, objectURL}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateObjectURL.t.Errorf("RepositoryIMock.UpdateObjectURL got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectURL != nil && !minimock.Equal(*mm_want_ptrs.objectURL, mm_got.objectURL) {
				mmUpdateObjectURL.t.Errorf("RepositoryIMock.UpdateObjectURL got unexpected parameter objectURL, want: %#v, got: %#v%s\n", *mm_want_ptrs.objectURL, mm_got.objectURL, minimock.Diff(*mm_want_ptrs.objectURL, mm_got.objectURL))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateObjectURL.t.Errorf("RepositoryIMock.UpdateObjectURL got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateObjectURL.UpdateObjectURLMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateObjectURL.t.Fatal("No results are set for the RepositoryIMock.UpdateObjectURL")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmUpdateObjectURL.funcUpdateObjectURL != nil {
		return mmUpdateObjectURL.funcUpdateObjectURL(ctx, objectURL)
	}
	mmUpdateObjectURL.t.Fatalf("Unexpected call to RepositoryIMock.UpdateObjectURL. %v %v", ctx, objectURL)
	return
}

// UpdateObjectURLAfterCounter returns a count of finished RepositoryIMock.UpdateObjectURL invocations
func (mmUpdateObjectURL *RepositoryIMock) UpdateObjectURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateObjectURL.afterUpdateObjectURLCounter)
}

// UpdateObjectURLBeforeCounter returns a count of RepositoryIMock.UpdateObjectURL invocations
func (mmUpdateObjectURL *RepositoryIMock) UpdateObjectURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateObjectURL.beforeUpdateObjectURLCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.UpdateObjectURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateObjectURL *mRepositoryIMockUpdateObjectURL) Calls() []*RepositoryIMockUpdateObjectURLParams {
	mmUpdateObjectURL.mutex.RLock()

	argCopy := make([]*RepositoryIMockUpdateObjectURLParams, len(mmUpdateObjectURL.callArgs))
	copy(argCopy, mmUpdateObjectURL.callArgs)

	mmUpdateObjectURL.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateObjectURLDone returns true if the count of the UpdateObjectURL invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockUpdateObjectURLDone() bool {
	for _, e := range m.UpdateObjectURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateObjectURLMock.invocationsDone()
}

// MinimockUpdateObjectURLInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockUpdateObjectURLInspect() {
	for _, e := range m.UpdateObjectURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateObjectURL with params: %#v", *e.params)
		}
	}

	afterUpdateObjectURLCounter := mm_atomic.LoadUint64(&m.afterUpdateObjectURLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateObjectURLMock.defaultExpectation != nil && afterUpdateObjectURLCounter < 1 {
		if m.UpdateObjectURLMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.UpdateObjectURL")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateObjectURL with params: %#v", *m.UpdateObjectURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateObjectURL != nil && afterUpdateObjectURLCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.UpdateObjectURL")
	}

	if !m.UpdateObjectURLMock.invocationsDone() && afterUpdateObjectURLCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.UpdateObjectURL but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateObjectURLMock.expectedInvocations), afterUpdateObjectURLCounter)
	}
}

type mRepositoryIMockUpsertEmbeddings struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockUpsertEmbeddingsExpectation
	expectations       []*RepositoryIMockUpsertEmbeddingsExpectation

	callArgs []*RepositoryIMockUpsertEmbeddingsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockUpsertEmbeddingsExpectation specifies expectation struct of the RepositoryI.UpsertEmbeddings
type RepositoryIMockUpsertEmbeddingsExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockUpsertEmbeddingsParams
	paramPtrs *RepositoryIMockUpsertEmbeddingsParamPtrs
	results   *RepositoryIMockUpsertEmbeddingsResults
	Counter   uint64
}

// RepositoryIMockUpsertEmbeddingsParams contains parameters of the RepositoryI.UpsertEmbeddings
type RepositoryIMockUpsertEmbeddingsParams struct {
	ctx                 context.Context
	embeddings          []mm_repository.Embedding
	externalServiceCall func(embUIDs []string) error
}

// RepositoryIMockUpsertEmbeddingsParamPtrs contains pointers to parameters of the RepositoryI.UpsertEmbeddings
type RepositoryIMockUpsertEmbeddingsParamPtrs struct {
	ctx                 *context.Context
	embeddings          *[]mm_repository.Embedding
	externalServiceCall *func(embUIDs []string) error
}

// RepositoryIMockUpsertEmbeddingsResults contains results of the RepositoryI.UpsertEmbeddings
type RepositoryIMockUpsertEmbeddingsResults struct {
	ea1 []mm_repository.Embedding
	err error
}

// Expect sets up expected params for RepositoryI.UpsertEmbeddings
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) Expect(ctx context.Context, embeddings []mm_repository.Embedding, externalServiceCall func(embUIDs []string) error) *mRepositoryIMockUpsertEmbeddings {
	if mmUpsertEmbeddings.mock.funcUpsertEmbeddings != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by Set")
	}

	if mmUpsertEmbeddings.defaultExpectation == nil {
		mmUpsertEmbeddings.defaultExpectation = &RepositoryIMockUpsertEmbeddingsExpectation{}
	}

	if mmUpsertEmbeddings.defaultExpectation.paramPtrs != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by ExpectParams functions")
	}

	mmUpsertEmbeddings.defaultExpectation.params = &RepositoryIMockUpsertEmbeddingsParams{ctx, embeddings, externalServiceCall}
	for _, e := range mmUpsertEmbeddings.expectations {
		if minimock.Equal(e.params, mmUpsertEmbeddings.defaultExpectation.params) {
			mmUpsertEmbeddings.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertEmbeddings.defaultExpectation.params)
		}
	}

	return mmUpsertEmbeddings
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.UpsertEmbeddings
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockUpsertEmbeddings {
	if mmUpsertEmbeddings.mock.funcUpsertEmbeddings != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by Set")
	}

	if mmUpsertEmbeddings.defaultExpectation == nil {
		mmUpsertEmbeddings.defaultExpectation = &RepositoryIMockUpsertEmbeddingsExpectation{}
	}

	if mmUpsertEmbeddings.defaultExpectation.params != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by Expect")
	}

	if mmUpsertEmbeddings.defaultExpectation.paramPtrs == nil {
		mmUpsertEmbeddings.defaultExpectation.paramPtrs = &RepositoryIMockUpsertEmbeddingsParamPtrs{}
	}
	mmUpsertEmbeddings.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpsertEmbeddings
}

// ExpectEmbeddingsParam2 sets up expected param embeddings for RepositoryI.UpsertEmbeddings
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) ExpectEmbeddingsParam2(embeddings []mm_repository.Embedding) *mRepositoryIMockUpsertEmbeddings {
	if mmUpsertEmbeddings.mock.funcUpsertEmbeddings != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by Set")
	}

	if mmUpsertEmbeddings.defaultExpectation == nil {
		mmUpsertEmbeddings.defaultExpectation = &RepositoryIMockUpsertEmbeddingsExpectation{}
	}

	if mmUpsertEmbeddings.defaultExpectation.params != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by Expect")
	}

	if mmUpsertEmbeddings.defaultExpectation.paramPtrs == nil {
		mmUpsertEmbeddings.defaultExpectation.paramPtrs = &RepositoryIMockUpsertEmbeddingsParamPtrs{}
	}
	mmUpsertEmbeddings.defaultExpectation.paramPtrs.embeddings = &embeddings

	return mmUpsertEmbeddings
}

// ExpectExternalServiceCallParam3 sets up expected param externalServiceCall for RepositoryI.UpsertEmbeddings
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) ExpectExternalServiceCallParam3(externalServiceCall func(embUIDs []string) error) *mRepositoryIMockUpsertEmbeddings {
	if mmUpsertEmbeddings.mock.funcUpsertEmbeddings != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by Set")
	}

	if mmUpsertEmbeddings.defaultExpectation == nil {
		mmUpsertEmbeddings.defaultExpectation = &RepositoryIMockUpsertEmbeddingsExpectation{}
	}

	if mmUpsertEmbeddings.defaultExpectation.params != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by Expect")
	}

	if mmUpsertEmbeddings.defaultExpectation.paramPtrs == nil {
		mmUpsertEmbeddings.defaultExpectation.paramPtrs = &RepositoryIMockUpsertEmbeddingsParamPtrs{}
	}
	mmUpsertEmbeddings.defaultExpectation.paramPtrs.externalServiceCall = &externalServiceCall

	return mmUpsertEmbeddings
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.UpsertEmbeddings
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) Inspect(f func(ctx context.Context, embeddings []mm_repository.Embedding, externalServiceCall func(embUIDs []string) error)) *mRepositoryIMockUpsertEmbeddings {
	if mmUpsertEmbeddings.mock.inspectFuncUpsertEmbeddings != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.UpsertEmbeddings")
	}

	mmUpsertEmbeddings.mock.inspectFuncUpsertEmbeddings = f

	return mmUpsertEmbeddings
}

// Return sets up results that will be returned by RepositoryI.UpsertEmbeddings
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) Return(ea1 []mm_repository.Embedding, err error) *RepositoryIMock {
	if mmUpsertEmbeddings.mock.funcUpsertEmbeddings != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by Set")
	}

	if mmUpsertEmbeddings.defaultExpectation == nil {
		mmUpsertEmbeddings.defaultExpectation = &RepositoryIMockUpsertEmbeddingsExpectation{mock: mmUpsertEmbeddings.mock}
	}
	mmUpsertEmbeddings.defaultExpectation.results = &RepositoryIMockUpsertEmbeddingsResults{ea1, err}
	return mmUpsertEmbeddings.mock
}

// Set uses given function f to mock the RepositoryI.UpsertEmbeddings method
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) Set(f func(ctx context.Context, embeddings []mm_repository.Embedding, externalServiceCall func(embUIDs []string) error) (ea1 []mm_repository.Embedding, err error)) *RepositoryIMock {
	if mmUpsertEmbeddings.defaultExpectation != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("Default expectation is already set for the RepositoryI.UpsertEmbeddings method")
	}

	if len(mmUpsertEmbeddings.expectations) > 0 {
		mmUpsertEmbeddings.mock.t.Fatalf("Some expectations are already set for the RepositoryI.UpsertEmbeddings method")
	}

	mmUpsertEmbeddings.mock.funcUpsertEmbeddings = f
	return mmUpsertEmbeddings.mock
}

// When sets expectation for the RepositoryI.UpsertEmbeddings which will trigger the result defined by the following
// Then helper
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) When(ctx context.Context, embeddings []mm_repository.Embedding, externalServiceCall func(embUIDs []string) error) *RepositoryIMockUpsertEmbeddingsExpectation {
	if mmUpsertEmbeddings.mock.funcUpsertEmbeddings != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by Set")
	}

	expectation := &RepositoryIMockUpsertEmbeddingsExpectation{
		mock:   mmUpsertEmbeddings.mock,
		params: &RepositoryIMockUpsertEmbeddingsParams{ctx, embeddings, externalServiceCall},
	}
	mmUpsertEmbeddings.expectations = append(mmUpsertEmbeddings.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.UpsertEmbeddings return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockUpsertEmbeddingsExpectation) Then(ea1 []mm_repository.Embedding, err error) *RepositoryIMock {
	e.results = &RepositoryIMockUpsertEmbeddingsResults{ea1, err}
	return e.mock
}

// Times sets number of times RepositoryI.UpsertEmbeddings should be invoked
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) Times(n uint64) *mRepositoryIMockUpsertEmbeddings {
	if n == 0 {
		mmUpsertEmbeddings.mock.t.Fatalf("Times of RepositoryIMock.UpsertEmbeddings mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpsertEmbeddings.expectedInvocations, n)
	return mmUpsertEmbeddings
}

func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) invocationsDone() bool {
	if len(mmUpsertEmbeddings.expectations) == 0 && mmUpsertEmbeddings.defaultExpectation == nil && mmUpsertEmbeddings.mock.funcUpsertEmbeddings == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpsertEmbeddings.mock.afterUpsertEmbeddingsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpsertEmbeddings.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpsertEmbeddings implements repository.RepositoryI
func (mmUpsertEmbeddings *RepositoryIMock) UpsertEmbeddings(ctx context.Context, embeddings []mm_repository.Embedding, externalServiceCall func(embUIDs []string) error) (ea1 []mm_repository.Embedding, err error) {
	mm_atomic.AddUint64(&mmUpsertEmbeddings.beforeUpsertEmbeddingsCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertEmbeddings.afterUpsertEmbeddingsCounter, 1)

	if mmUpsertEmbeddings.inspectFuncUpsertEmbeddings != nil {
		mmUpsertEmbeddings.inspectFuncUpsertEmbeddings(ctx, embeddings, externalServiceCall)
	}

	mm_params := RepositoryIMockUpsertEmbeddingsParams{ctx, embeddings, externalServiceCall}

	// Record call args
	mmUpsertEmbeddings.UpsertEmbeddingsMock.mutex.Lock()
	mmUpsertEmbeddings.UpsertEmbeddingsMock.callArgs = append(mmUpsertEmbeddings.UpsertEmbeddingsMock.callArgs, &mm_params)
	mmUpsertEmbeddings.UpsertEmbeddingsMock.mutex.Unlock()

	for _, e := range mmUpsertEmbeddings.UpsertEmbeddingsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1, e.results.err
		}
	}

	if mmUpsertEmbeddings.UpsertEmbeddingsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertEmbeddings.UpsertEmbeddingsMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsertEmbeddings.UpsertEmbeddingsMock.defaultExpectation.params
		mm_want_ptrs := mmUpsertEmbeddings.UpsertEmbeddingsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockUpsertEmbeddingsParams{ctx, embeddings, externalServiceCall}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpsertEmbeddings.t.Errorf("RepositoryIMock.UpsertEmbeddings got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.embeddings != nil && !minimock.Equal(*mm_want_ptrs.embeddings, mm_got.embeddings) {
				mmUpsertEmbeddings.t.Errorf("RepositoryIMock.UpsertEmbeddings got unexpected parameter embeddings, want: %#v, got: %#v%s\n", *mm_want_ptrs.embeddings, mm_got.embeddings, minimock.Diff(*mm_want_ptrs.embeddings, mm_got.embeddings))
			}

			if mm_want_ptrs.externalServiceCall != nil && !minimock.Equal(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall) {
				mmUpsertEmbeddings.t.Errorf("RepositoryIMock.UpsertEmbeddings got unexpected parameter externalServiceCall, want: %#v, got: %#v%s\n", *mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall, minimock.Diff(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsertEmbeddings.t.Errorf("RepositoryIMock.UpsertEmbeddings got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsertEmbeddings.UpsertEmbeddingsMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsertEmbeddings.t.Fatal("No results are set for the RepositoryIMock.UpsertEmbeddings")
		}
		return (*mm_results).ea1, (*mm_results).err
	}
	if mmUpsertEmbeddings.funcUpsertEmbeddings != nil {
		return mmUpsertEmbeddings.funcUpsertEmbeddings(ctx, embeddings, externalServiceCall)
	}
	mmUpsertEmbeddings.t.Fatalf("Unexpected call to RepositoryIMock.UpsertEmbeddings. %v %v %v", ctx, embeddings, externalServiceCall)
	return
}

// UpsertEmbeddingsAfterCounter returns a count of finished RepositoryIMock.UpsertEmbeddings invocations
func (mmUpsertEmbeddings *RepositoryIMock) UpsertEmbeddingsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertEmbeddings.afterUpsertEmbeddingsCounter)
}

// UpsertEmbeddingsBeforeCounter returns a count of RepositoryIMock.UpsertEmbeddings invocations
func (mmUpsertEmbeddings *RepositoryIMock) UpsertEmbeddingsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertEmbeddings.beforeUpsertEmbeddingsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.UpsertEmbeddings.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) Calls() []*RepositoryIMockUpsertEmbeddingsParams {
	mmUpsertEmbeddings.mutex.RLock()

	argCopy := make([]*RepositoryIMockUpsertEmbeddingsParams, len(mmUpsertEmbeddings.callArgs))
	copy(argCopy, mmUpsertEmbeddings.callArgs)

	mmUpsertEmbeddings.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertEmbeddingsDone returns true if the count of the UpsertEmbeddings invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockUpsertEmbeddingsDone() bool {
	for _, e := range m.UpsertEmbeddingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpsertEmbeddingsMock.invocationsDone()
}

// MinimockUpsertEmbeddingsInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockUpsertEmbeddingsInspect() {
	for _, e := range m.UpsertEmbeddingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.UpsertEmbeddings with params: %#v", *e.params)
		}
	}

	afterUpsertEmbeddingsCounter := mm_atomic.LoadUint64(&m.afterUpsertEmbeddingsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertEmbeddingsMock.defaultExpectation != nil && afterUpsertEmbeddingsCounter < 1 {
		if m.UpsertEmbeddingsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.UpsertEmbeddings")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.UpsertEmbeddings with params: %#v", *m.UpsertEmbeddingsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertEmbeddings != nil && afterUpsertEmbeddingsCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.UpsertEmbeddings")
	}

	if !m.UpsertEmbeddingsMock.invocationsDone() && afterUpsertEmbeddingsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.UpsertEmbeddings but found %d calls",
			mm_atomic.LoadUint64(&m.UpsertEmbeddingsMock.expectedInvocations), afterUpsertEmbeddingsCounter)
	}
}

type mRepositoryIMockUpsertRepositoryTag struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockUpsertRepositoryTagExpectation
	expectations       []*RepositoryIMockUpsertRepositoryTagExpectation

	callArgs []*RepositoryIMockUpsertRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockUpsertRepositoryTagExpectation specifies expectation struct of the RepositoryI.UpsertRepositoryTag
type RepositoryIMockUpsertRepositoryTagExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockUpsertRepositoryTagParams
	paramPtrs *RepositoryIMockUpsertRepositoryTagParamPtrs
	results   *RepositoryIMockUpsertRepositoryTagResults
	Counter   uint64
}

// RepositoryIMockUpsertRepositoryTagParams contains parameters of the RepositoryI.UpsertRepositoryTag
type RepositoryIMockUpsertRepositoryTagParams struct {
	ctx context.Context
	rp1 *pb.RepositoryTag
}

// RepositoryIMockUpsertRepositoryTagParamPtrs contains pointers to parameters of the RepositoryI.UpsertRepositoryTag
type RepositoryIMockUpsertRepositoryTagParamPtrs struct {
	ctx *context.Context
	rp1 **pb.RepositoryTag
}

// RepositoryIMockUpsertRepositoryTagResults contains results of the RepositoryI.UpsertRepositoryTag
type RepositoryIMockUpsertRepositoryTagResults struct {
	rp2 *pb.RepositoryTag
	err error
}

// Expect sets up expected params for RepositoryI.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) Expect(ctx context.Context, rp1 *pb.RepositoryTag) *mRepositoryIMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryIMockUpsertRepositoryTagExpectation{}
	}

	if mmUpsertRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by ExpectParams functions")
	}

	mmUpsertRepositoryTag.defaultExpectation.params = &RepositoryIMockUpsertRepositoryTagParams{ctx, rp1}
	for _, e := range mmUpsertRepositoryTag.expectations {
		if minimock.Equal(e.params, mmUpsertRepositoryTag.defaultExpectation.params) {
			mmUpsertRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertRepositoryTag.defaultExpectation.params)
		}
	}

	return mmUpsertRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryIMockUpsertRepositoryTagExpectation{}
	}

	if mmUpsertRepositoryTag.defaultExpectation.params != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by Expect")
	}

	if mmUpsertRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmUpsertRepositoryTag.defaultExpectation.paramPtrs = &RepositoryIMockUpsertRepositoryTagParamPtrs{}
	}
	mmUpsertRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpsertRepositoryTag
}

// ExpectRp1Param2 sets up expected param rp1 for RepositoryI.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) ExpectRp1Param2(rp1 *pb.RepositoryTag) *mRepositoryIMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryIMockUpsertRepositoryTagExpectation{}
	}

	if mmUpsertRepositoryTag.defaultExpectation.params != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by Expect")
	}

	if mmUpsertRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmUpsertRepositoryTag.defaultExpectation.paramPtrs = &RepositoryIMockUpsertRepositoryTagParamPtrs{}
	}
	mmUpsertRepositoryTag.defaultExpectation.paramPtrs.rp1 = &rp1

	return mmUpsertRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) Inspect(f func(ctx context.Context, rp1 *pb.RepositoryTag)) *mRepositoryIMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.inspectFuncUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.UpsertRepositoryTag")
	}

	mmUpsertRepositoryTag.mock.inspectFuncUpsertRepositoryTag = f

	return mmUpsertRepositoryTag
}

// Return sets up results that will be returned by RepositoryI.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) Return(rp2 *pb.RepositoryTag, err error) *RepositoryIMock {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryIMockUpsertRepositoryTagExpectation{mock: mmUpsertRepositoryTag.mock}
	}
	mmUpsertRepositoryTag.defaultExpectation.results = &RepositoryIMockUpsertRepositoryTagResults{rp2, err}
	return mmUpsertRepositoryTag.mock
}

// Set uses given function f to mock the RepositoryI.UpsertRepositoryTag method
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) Set(f func(ctx context.Context, rp1 *pb.RepositoryTag) (rp2 *pb.RepositoryTag, err error)) *RepositoryIMock {
	if mmUpsertRepositoryTag.defaultExpectation != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("Default expectation is already set for the RepositoryI.UpsertRepositoryTag method")
	}

	if len(mmUpsertRepositoryTag.expectations) > 0 {
		mmUpsertRepositoryTag.mock.t.Fatalf("Some expectations are already set for the RepositoryI.UpsertRepositoryTag method")
	}

	mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag = f
	return mmUpsertRepositoryTag.mock
}

// When sets expectation for the RepositoryI.UpsertRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) When(ctx context.Context, rp1 *pb.RepositoryTag) *RepositoryIMockUpsertRepositoryTagExpectation {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by Set")
	}

	expectation := &RepositoryIMockUpsertRepositoryTagExpectation{
		mock:   mmUpsertRepositoryTag.mock,
		params: &RepositoryIMockUpsertRepositoryTagParams{ctx, rp1},
	}
	mmUpsertRepositoryTag.expectations = append(mmUpsertRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.UpsertRepositoryTag return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockUpsertRepositoryTagExpectation) Then(rp2 *pb.RepositoryTag, err error) *RepositoryIMock {
	e.results = &RepositoryIMockUpsertRepositoryTagResults{rp2, err}
	return e.mock
}

// Times sets number of times RepositoryI.UpsertRepositoryTag should be invoked
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) Times(n uint64) *mRepositoryIMockUpsertRepositoryTag {
	if n == 0 {
		mmUpsertRepositoryTag.mock.t.Fatalf("Times of RepositoryIMock.UpsertRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpsertRepositoryTag.expectedInvocations, n)
	return mmUpsertRepositoryTag
}

func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) invocationsDone() bool {
	if len(mmUpsertRepositoryTag.expectations) == 0 && mmUpsertRepositoryTag.defaultExpectation == nil && mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpsertRepositoryTag.mock.afterUpsertRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpsertRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpsertRepositoryTag implements repository.RepositoryI
func (mmUpsertRepositoryTag *RepositoryIMock) UpsertRepositoryTag(ctx context.Context, rp1 *pb.RepositoryTag) (rp2 *pb.RepositoryTag, err error) {
	mm_atomic.AddUint64(&mmUpsertRepositoryTag.beforeUpsertRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertRepositoryTag.afterUpsertRepositoryTagCounter, 1)

	if mmUpsertRepositoryTag.inspectFuncUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.inspectFuncUpsertRepositoryTag(ctx, rp1)
	}

	mm_params := RepositoryIMockUpsertRepositoryTagParams{ctx, rp1}

	// Record call args
	mmUpsertRepositoryTag.UpsertRepositoryTagMock.mutex.Lock()
	mmUpsertRepositoryTag.UpsertRepositoryTagMock.callArgs = append(mmUpsertRepositoryTag.UpsertRepositoryTagMock.callArgs, &mm_params)
	mmUpsertRepositoryTag.UpsertRepositoryTagMock.mutex.Unlock()

	for _, e := range mmUpsertRepositoryTag.UpsertRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp2, e.results.err
		}
	}

	if mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockUpsertRepositoryTagParams{ctx, rp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpsertRepositoryTag.t.Errorf("RepositoryIMock.UpsertRepositoryTag got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.rp1 != nil && !minimock.Equal(*mm_want_ptrs.rp1, mm_got.rp1) {
				mmUpsertRepositoryTag.t.Errorf("RepositoryIMock.UpsertRepositoryTag got unexpected parameter rp1, want: %#v, got: %#v%s\n", *mm_want_ptrs.rp1, mm_got.rp1, minimock.Diff(*mm_want_ptrs.rp1, mm_got.rp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsertRepositoryTag.t.Errorf("RepositoryIMock.UpsertRepositoryTag got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsertRepositoryTag.t.Fatal("No results are set for the RepositoryIMock.UpsertRepositoryTag")
		}
		return (*mm_results).rp2, (*mm_results).err
	}
	if mmUpsertRepositoryTag.funcUpsertRepositoryTag != nil {
		return mmUpsertRepositoryTag.funcUpsertRepositoryTag(ctx, rp1)
	}
	mmUpsertRepositoryTag.t.Fatalf("Unexpected call to RepositoryIMock.UpsertRepositoryTag. %v %v", ctx, rp1)
	return
}

// UpsertRepositoryTagAfterCounter returns a count of finished RepositoryIMock.UpsertRepositoryTag invocations
func (mmUpsertRepositoryTag *RepositoryIMock) UpsertRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertRepositoryTag.afterUpsertRepositoryTagCounter)
}

// UpsertRepositoryTagBeforeCounter returns a count of RepositoryIMock.UpsertRepositoryTag invocations
func (mmUpsertRepositoryTag *RepositoryIMock) UpsertRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertRepositoryTag.beforeUpsertRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.UpsertRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) Calls() []*RepositoryIMockUpsertRepositoryTagParams {
	mmUpsertRepositoryTag.mutex.RLock()

	argCopy := make([]*RepositoryIMockUpsertRepositoryTagParams, len(mmUpsertRepositoryTag.callArgs))
	copy(argCopy, mmUpsertRepositoryTag.callArgs)

	mmUpsertRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertRepositoryTagDone returns true if the count of the UpsertRepositoryTag invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockUpsertRepositoryTagDone() bool {
	for _, e := range m.UpsertRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpsertRepositoryTagMock.invocationsDone()
}

// MinimockUpsertRepositoryTagInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockUpsertRepositoryTagInspect() {
	for _, e := range m.UpsertRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.UpsertRepositoryTag with params: %#v", *e.params)
		}
	}

	afterUpsertRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterUpsertRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertRepositoryTagMock.defaultExpectation != nil && afterUpsertRepositoryTagCounter < 1 {
		if m.UpsertRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.UpsertRepositoryTag")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.UpsertRepositoryTag with params: %#v", *m.UpsertRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertRepositoryTag != nil && afterUpsertRepositoryTagCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.UpsertRepositoryTag")
	}

	if !m.UpsertRepositoryTagMock.invocationsDone() && afterUpsertRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.UpsertRepositoryTag but found %d calls",
			mm_atomic.LoadUint64(&m.UpsertRepositoryTagMock.expectedInvocations), afterUpsertRepositoryTagCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryIMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockConvertedFileTableNameInspect()

			m.MinimockCreateConvertedFileInspect()

			m.MinimockCreateKnowledgeBaseInspect()

			m.MinimockCreateKnowledgeBaseFileInspect()

			m.MinimockCreateObjectInspect()

			m.MinimockCreateObjectURLInspect()

			m.MinimockDeleteAllConvertedFilesInKbInspect()

			m.MinimockDeleteAllKnowledgeBaseFilesInspect()

			m.MinimockDeleteAndCreateChunksInspect()

			m.MinimockDeleteChunksBySourceInspect()

			m.MinimockDeleteChunksByUIDsInspect()

			m.MinimockDeleteConvertedFileInspect()

			m.MinimockDeleteEmbeddingsBySourceInspect()

			m.MinimockDeleteEmbeddingsByUIDsInspect()

			m.MinimockDeleteKnowledgeBaseInspect()

			m.MinimockDeleteKnowledgeBaseFileInspect()

			m.MinimockDeleteKnowledgeBaseFileAndDecreaseUsageInspect()

			m.MinimockDeleteObjectInspect()

			m.MinimockDeleteObjectURLInspect()

			m.MinimockDeleteRepositoryTagInspect()

			m.MinimockGetChunksByUIDsInspect()

			m.MinimockGetConvertedFileByFileUIDInspect()

			m.MinimockGetCountFilesByListKnowledgeBaseUIDInspect()

			m.MinimockGetEmbeddingByUIDsInspect()

			m.MinimockGetFilesTotalTokensInspect()

			m.MinimockGetKnowledgeBaseByOwnerAndKbIDInspect()

			m.MinimockGetKnowledgeBaseCountByOwnerInspect()

			m.MinimockGetKnowledgeBaseFilesByFileUIDsInspect()

			m.MinimockGetKnowledgeBasesByUIDsInspect()

			m.MinimockGetKnowledgebaseFileByKbUIDAndFileIDInspect()

			m.MinimockGetNeedProcessFilesInspect()

			m.MinimockGetObjectByUIDInspect()

			m.MinimockGetObjectDownloadURLInspect()

			m.MinimockGetObjectURLByEncodedURLPathInspect()

			m.MinimockGetObjectURLByUIDInspect()

			m.MinimockGetObjectURLCountByObjectInspect()

			m.MinimockGetObjectUploadURLInspect()

			m.MinimockGetRepositoryTagInspect()

			m.MinimockGetSourceTableAndUIDByFileUIDsInspect()

			m.MinimockGetTextChunksBySourceInspect()

			m.MinimockGetTotalChunksBySourcesInspect()

			m.MinimockGetTotalTokensByListKBUIDsInspect()

			m.MinimockGetTruthSourceByFileUIDInspect()

			m.MinimockHardDeleteChunksByKbFileUIDInspect()

			m.MinimockHardDeleteChunksByKbUIDInspect()

			m.MinimockHardDeleteConvertedFileByFileUIDInspect()

			m.MinimockHardDeleteEmbeddingsByKbFileUIDInspect()

			m.MinimockHardDeleteEmbeddingsByKbUIDInspect()

			m.MinimockIncreaseKnowledgeBaseUsageInspect()

			m.MinimockKnowledgeBaseFileTableNameInspect()

			m.MinimockListAllObjectURLsInspect()

			m.MinimockListAllObjectsInspect()

			m.MinimockListChunksByKbFileUIDInspect()

			m.MinimockListEmbeddingsByKbFileUIDInspect()

			m.MinimockListKnowledgeBaseFilesInspect()

			m.MinimockListKnowledgeBasesInspect()

			m.MinimockListKnowledgeBasesByCatalogTypeInspect()

			m.MinimockProcessKnowledgeBaseFilesInspect()

			m.MinimockTextChunkTableNameInspect()

			m.MinimockUpdateChunkInspect()

			m.MinimockUpdateKbFileExtraMetaDataInspect()

			m.MinimockUpdateKnowledgeBaseInspect()

			m.MinimockUpdateKnowledgeBaseFileInspect()

			m.MinimockUpdateObjectInspect()

			m.MinimockUpdateObjectByUpdateMapInspect()

			m.MinimockUpdateObjectURLInspect()

			m.MinimockUpsertEmbeddingsInspect()

			m.MinimockUpsertRepositoryTagInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryIMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryIMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockConvertedFileTableNameDone() &&
		m.MinimockCreateConvertedFileDone() &&
		m.MinimockCreateKnowledgeBaseDone() &&
		m.MinimockCreateKnowledgeBaseFileDone() &&
		m.MinimockCreateObjectDone() &&
		m.MinimockCreateObjectURLDone() &&
		m.MinimockDeleteAllConvertedFilesInKbDone() &&
		m.MinimockDeleteAllKnowledgeBaseFilesDone() &&
		m.MinimockDeleteAndCreateChunksDone() &&
		m.MinimockDeleteChunksBySourceDone() &&
		m.MinimockDeleteChunksByUIDsDone() &&
		m.MinimockDeleteConvertedFileDone() &&
		m.MinimockDeleteEmbeddingsBySourceDone() &&
		m.MinimockDeleteEmbeddingsByUIDsDone() &&
		m.MinimockDeleteKnowledgeBaseDone() &&
		m.MinimockDeleteKnowledgeBaseFileDone() &&
		m.MinimockDeleteKnowledgeBaseFileAndDecreaseUsageDone() &&
		m.MinimockDeleteObjectDone() &&
		m.MinimockDeleteObjectURLDone() &&
		m.MinimockDeleteRepositoryTagDone() &&
		m.MinimockGetChunksByUIDsDone() &&
		m.MinimockGetConvertedFileByFileUIDDone() &&
		m.MinimockGetCountFilesByListKnowledgeBaseUIDDone() &&
		m.MinimockGetEmbeddingByUIDsDone() &&
		m.MinimockGetFilesTotalTokensDone() &&
		m.MinimockGetKnowledgeBaseByOwnerAndKbIDDone() &&
		m.MinimockGetKnowledgeBaseCountByOwnerDone() &&
		m.MinimockGetKnowledgeBaseFilesByFileUIDsDone() &&
		m.MinimockGetKnowledgeBasesByUIDsDone() &&
		m.MinimockGetKnowledgebaseFileByKbUIDAndFileIDDone() &&
		m.MinimockGetNeedProcessFilesDone() &&
		m.MinimockGetObjectByUIDDone() &&
		m.MinimockGetObjectDownloadURLDone() &&
		m.MinimockGetObjectURLByEncodedURLPathDone() &&
		m.MinimockGetObjectURLByUIDDone() &&
		m.MinimockGetObjectURLCountByObjectDone() &&
		m.MinimockGetObjectUploadURLDone() &&
		m.MinimockGetRepositoryTagDone() &&
		m.MinimockGetSourceTableAndUIDByFileUIDsDone() &&
		m.MinimockGetTextChunksBySourceDone() &&
		m.MinimockGetTotalChunksBySourcesDone() &&
		m.MinimockGetTotalTokensByListKBUIDsDone() &&
		m.MinimockGetTruthSourceByFileUIDDone() &&
		m.MinimockHardDeleteChunksByKbFileUIDDone() &&
		m.MinimockHardDeleteChunksByKbUIDDone() &&
		m.MinimockHardDeleteConvertedFileByFileUIDDone() &&
		m.MinimockHardDeleteEmbeddingsByKbFileUIDDone() &&
		m.MinimockHardDeleteEmbeddingsByKbUIDDone() &&
		m.MinimockIncreaseKnowledgeBaseUsageDone() &&
		m.MinimockKnowledgeBaseFileTableNameDone() &&
		m.MinimockListAllObjectURLsDone() &&
		m.MinimockListAllObjectsDone() &&
		m.MinimockListChunksByKbFileUIDDone() &&
		m.MinimockListEmbeddingsByKbFileUIDDone() &&
		m.MinimockListKnowledgeBaseFilesDone() &&
		m.MinimockListKnowledgeBasesDone() &&
		m.MinimockListKnowledgeBasesByCatalogTypeDone() &&
		m.MinimockProcessKnowledgeBaseFilesDone() &&
		m.MinimockTextChunkTableNameDone() &&
		m.MinimockUpdateChunkDone() &&
		m.MinimockUpdateKbFileExtraMetaDataDone() &&
		m.MinimockUpdateKnowledgeBaseDone() &&
		m.MinimockUpdateKnowledgeBaseFileDone() &&
		m.MinimockUpdateObjectDone() &&
		m.MinimockUpdateObjectByUpdateMapDone() &&
		m.MinimockUpdateObjectURLDone() &&
		m.MinimockUpsertEmbeddingsDone() &&
		m.MinimockUpsertRepositoryTagDone()
}
