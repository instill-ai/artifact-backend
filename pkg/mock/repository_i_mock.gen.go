// Code generated by http://github.com/gojuno/minimock (v3.3.9). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/google/uuid"
	"github.com/gojuno/minimock/v3"
	mm_repository "github.com/instill-ai/artifact-backend/pkg/repository"
	"github.com/instill-ai/artifact-backend/pkg/utils"
	pb "github.com/instill-ai/protogen-go/artifact/artifact/v1alpha"
)

// RepositoryIMock implements repository.RepositoryI
type RepositoryIMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcConvertedFileTableName          func() (s1 string)
	inspectFuncConvertedFileTableName   func()
	afterConvertedFileTableNameCounter  uint64
	beforeConvertedFileTableNameCounter uint64
	ConvertedFileTableNameMock          mRepositoryIMockConvertedFileTableName

	funcCreateConvertedFile          func(ctx context.Context, cf mm_repository.ConvertedFile, callExternalService func(convertedFileUID uuid.UUID) error) (cp1 *mm_repository.ConvertedFile, err error)
	inspectFuncCreateConvertedFile   func(ctx context.Context, cf mm_repository.ConvertedFile, callExternalService func(convertedFileUID uuid.UUID) error)
	afterCreateConvertedFileCounter  uint64
	beforeCreateConvertedFileCounter uint64
	CreateConvertedFileMock          mRepositoryIMockCreateConvertedFile

	funcCreateKnowledgeBase          func(ctx context.Context, kb mm_repository.KnowledgeBase, externalService func(kbUID string) error) (kp1 *mm_repository.KnowledgeBase, err error)
	inspectFuncCreateKnowledgeBase   func(ctx context.Context, kb mm_repository.KnowledgeBase, externalService func(kbUID string) error)
	afterCreateKnowledgeBaseCounter  uint64
	beforeCreateKnowledgeBaseCounter uint64
	CreateKnowledgeBaseMock          mRepositoryIMockCreateKnowledgeBase

	funcCreateKnowledgeBaseFile          func(ctx context.Context, kb mm_repository.KnowledgeBaseFile, externalServiceCall func(FileUID string) error) (kp1 *mm_repository.KnowledgeBaseFile, err error)
	inspectFuncCreateKnowledgeBaseFile   func(ctx context.Context, kb mm_repository.KnowledgeBaseFile, externalServiceCall func(FileUID string) error)
	afterCreateKnowledgeBaseFileCounter  uint64
	beforeCreateKnowledgeBaseFileCounter uint64
	CreateKnowledgeBaseFileMock          mRepositoryIMockCreateKnowledgeBaseFile

	funcDeleteAndCreateChunks          func(ctx context.Context, sourceTable string, sourceUID uuid.UUID, chunks []*mm_repository.TextChunk, externalServiceCall func(chunkUIDs []string) (map[string]any, error)) (tpa1 []*mm_repository.TextChunk, err error)
	inspectFuncDeleteAndCreateChunks   func(ctx context.Context, sourceTable string, sourceUID uuid.UUID, chunks []*mm_repository.TextChunk, externalServiceCall func(chunkUIDs []string) (map[string]any, error))
	afterDeleteAndCreateChunksCounter  uint64
	beforeDeleteAndCreateChunksCounter uint64
	DeleteAndCreateChunksMock          mRepositoryIMockDeleteAndCreateChunks

	funcDeleteChunksBySource          func(ctx context.Context, sourceTable string, sourceUID uuid.UUID) (err error)
	inspectFuncDeleteChunksBySource   func(ctx context.Context, sourceTable string, sourceUID uuid.UUID)
	afterDeleteChunksBySourceCounter  uint64
	beforeDeleteChunksBySourceCounter uint64
	DeleteChunksBySourceMock          mRepositoryIMockDeleteChunksBySource

	funcDeleteChunksByUIDs          func(ctx context.Context, chunkUIDs []uuid.UUID) (err error)
	inspectFuncDeleteChunksByUIDs   func(ctx context.Context, chunkUIDs []uuid.UUID)
	afterDeleteChunksByUIDsCounter  uint64
	beforeDeleteChunksByUIDsCounter uint64
	DeleteChunksByUIDsMock          mRepositoryIMockDeleteChunksByUIDs

	funcDeleteConvertedFile          func(ctx context.Context, uid uuid.UUID) (err error)
	inspectFuncDeleteConvertedFile   func(ctx context.Context, uid uuid.UUID)
	afterDeleteConvertedFileCounter  uint64
	beforeDeleteConvertedFileCounter uint64
	DeleteConvertedFileMock          mRepositoryIMockDeleteConvertedFile

	funcDeleteEmbeddingsBySource          func(ctx context.Context, sourceTable string, sourceUID uuid.UUID) (err error)
	inspectFuncDeleteEmbeddingsBySource   func(ctx context.Context, sourceTable string, sourceUID uuid.UUID)
	afterDeleteEmbeddingsBySourceCounter  uint64
	beforeDeleteEmbeddingsBySourceCounter uint64
	DeleteEmbeddingsBySourceMock          mRepositoryIMockDeleteEmbeddingsBySource

	funcDeleteEmbeddingsByUIDs          func(ctx context.Context, embUIDs []uuid.UUID) (err error)
	inspectFuncDeleteEmbeddingsByUIDs   func(ctx context.Context, embUIDs []uuid.UUID)
	afterDeleteEmbeddingsByUIDsCounter  uint64
	beforeDeleteEmbeddingsByUIDsCounter uint64
	DeleteEmbeddingsByUIDsMock          mRepositoryIMockDeleteEmbeddingsByUIDs

	funcDeleteKnowledgeBase          func(ctx context.Context, ownerUID string, kbID string) (kp1 *mm_repository.KnowledgeBase, err error)
	inspectFuncDeleteKnowledgeBase   func(ctx context.Context, ownerUID string, kbID string)
	afterDeleteKnowledgeBaseCounter  uint64
	beforeDeleteKnowledgeBaseCounter uint64
	DeleteKnowledgeBaseMock          mRepositoryIMockDeleteKnowledgeBase

	funcDeleteKnowledgeBaseFile          func(ctx context.Context, fileUID string) (err error)
	inspectFuncDeleteKnowledgeBaseFile   func(ctx context.Context, fileUID string)
	afterDeleteKnowledgeBaseFileCounter  uint64
	beforeDeleteKnowledgeBaseFileCounter uint64
	DeleteKnowledgeBaseFileMock          mRepositoryIMockDeleteKnowledgeBaseFile

	funcDeleteRepositoryTag          func(ctx context.Context, s1 string) (err error)
	inspectFuncDeleteRepositoryTag   func(ctx context.Context, s1 string)
	afterDeleteRepositoryTagCounter  uint64
	beforeDeleteRepositoryTagCounter uint64
	DeleteRepositoryTagMock          mRepositoryIMockDeleteRepositoryTag

	funcGetConvertedFileByFileUID          func(ctx context.Context, fileUID uuid.UUID) (cp1 *mm_repository.ConvertedFile, err error)
	inspectFuncGetConvertedFileByFileUID   func(ctx context.Context, fileUID uuid.UUID)
	afterGetConvertedFileByFileUIDCounter  uint64
	beforeGetConvertedFileByFileUIDCounter uint64
	GetConvertedFileByFileUIDMock          mRepositoryIMockGetConvertedFileByFileUID

	funcGetIncompleteFile          func(ctx context.Context) (ka1 []mm_repository.KnowledgeBaseFile)
	inspectFuncGetIncompleteFile   func(ctx context.Context)
	afterGetIncompleteFileCounter  uint64
	beforeGetIncompleteFileCounter uint64
	GetIncompleteFileMock          mRepositoryIMockGetIncompleteFile

	funcGetKnowledgeBaseByOwnerAndID          func(ctx context.Context, ownerUID string, kbID string) (kp1 *mm_repository.KnowledgeBase, err error)
	inspectFuncGetKnowledgeBaseByOwnerAndID   func(ctx context.Context, ownerUID string, kbID string)
	afterGetKnowledgeBaseByOwnerAndIDCounter  uint64
	beforeGetKnowledgeBaseByOwnerAndIDCounter uint64
	GetKnowledgeBaseByOwnerAndIDMock          mRepositoryIMockGetKnowledgeBaseByOwnerAndID

	funcGetRepositoryTag          func(ctx context.Context, r1 utils.RepositoryTagName) (rp1 *pb.RepositoryTag, err error)
	inspectFuncGetRepositoryTag   func(ctx context.Context, r1 utils.RepositoryTagName)
	afterGetRepositoryTagCounter  uint64
	beforeGetRepositoryTagCounter uint64
	GetRepositoryTagMock          mRepositoryIMockGetRepositoryTag

	funcGetTextChunksBySource          func(ctx context.Context, sourceTable string, sourceUID uuid.UUID) (ta1 []mm_repository.TextChunk, err error)
	inspectFuncGetTextChunksBySource   func(ctx context.Context, sourceTable string, sourceUID uuid.UUID)
	afterGetTextChunksBySourceCounter  uint64
	beforeGetTextChunksBySourceCounter uint64
	GetTextChunksBySourceMock          mRepositoryIMockGetTextChunksBySource

	funcKnowledgeBaseFileTableName          func() (s1 string)
	inspectFuncKnowledgeBaseFileTableName   func()
	afterKnowledgeBaseFileTableNameCounter  uint64
	beforeKnowledgeBaseFileTableNameCounter uint64
	KnowledgeBaseFileTableNameMock          mRepositoryIMockKnowledgeBaseFileTableName

	funcListKnowledgeBaseFiles          func(ctx context.Context, uid string, ownerUID string, kbUID string, pageSize int32, nextPageToken string, filesUID []string) (ka1 []mm_repository.KnowledgeBaseFile, i1 int, s1 string, err error)
	inspectFuncListKnowledgeBaseFiles   func(ctx context.Context, uid string, ownerUID string, kbUID string, pageSize int32, nextPageToken string, filesUID []string)
	afterListKnowledgeBaseFilesCounter  uint64
	beforeListKnowledgeBaseFilesCounter uint64
	ListKnowledgeBaseFilesMock          mRepositoryIMockListKnowledgeBaseFiles

	funcListKnowledgeBases          func(ctx context.Context, ownerUID string) (ka1 []mm_repository.KnowledgeBase, err error)
	inspectFuncListKnowledgeBases   func(ctx context.Context, ownerUID string)
	afterListKnowledgeBasesCounter  uint64
	beforeListKnowledgeBasesCounter uint64
	ListKnowledgeBasesMock          mRepositoryIMockListKnowledgeBases

	funcProcessKnowledgeBaseFiles          func(ctx context.Context, fileUids []string) (ka1 []mm_repository.KnowledgeBaseFile, err error)
	inspectFuncProcessKnowledgeBaseFiles   func(ctx context.Context, fileUids []string)
	afterProcessKnowledgeBaseFilesCounter  uint64
	beforeProcessKnowledgeBaseFilesCounter uint64
	ProcessKnowledgeBaseFilesMock          mRepositoryIMockProcessKnowledgeBaseFiles

	funcUpdateKnowledgeBase          func(ctx context.Context, ownerUID string, kb mm_repository.KnowledgeBase) (kp1 *mm_repository.KnowledgeBase, err error)
	inspectFuncUpdateKnowledgeBase   func(ctx context.Context, ownerUID string, kb mm_repository.KnowledgeBase)
	afterUpdateKnowledgeBaseCounter  uint64
	beforeUpdateKnowledgeBaseCounter uint64
	UpdateKnowledgeBaseMock          mRepositoryIMockUpdateKnowledgeBase

	funcUpdateKnowledgeBaseFile          func(ctx context.Context, fileUID string, updateMap map[string]interface{}) (kp1 *mm_repository.KnowledgeBaseFile, err error)
	inspectFuncUpdateKnowledgeBaseFile   func(ctx context.Context, fileUID string, updateMap map[string]interface{})
	afterUpdateKnowledgeBaseFileCounter  uint64
	beforeUpdateKnowledgeBaseFileCounter uint64
	UpdateKnowledgeBaseFileMock          mRepositoryIMockUpdateKnowledgeBaseFile

	funcUpsertEmbeddings          func(ctx context.Context, embeddings []mm_repository.Embedding, externalServiceCall func(embUIDs []string) error) (ea1 []mm_repository.Embedding, err error)
	inspectFuncUpsertEmbeddings   func(ctx context.Context, embeddings []mm_repository.Embedding, externalServiceCall func(embUIDs []string) error)
	afterUpsertEmbeddingsCounter  uint64
	beforeUpsertEmbeddingsCounter uint64
	UpsertEmbeddingsMock          mRepositoryIMockUpsertEmbeddings

	funcUpsertRepositoryTag          func(ctx context.Context, rp1 *pb.RepositoryTag) (rp2 *pb.RepositoryTag, err error)
	inspectFuncUpsertRepositoryTag   func(ctx context.Context, rp1 *pb.RepositoryTag)
	afterUpsertRepositoryTagCounter  uint64
	beforeUpsertRepositoryTagCounter uint64
	UpsertRepositoryTagMock          mRepositoryIMockUpsertRepositoryTag
}

// NewRepositoryIMock returns a mock for repository.RepositoryI
func NewRepositoryIMock(t minimock.Tester) *RepositoryIMock {
	m := &RepositoryIMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ConvertedFileTableNameMock = mRepositoryIMockConvertedFileTableName{mock: m}

	m.CreateConvertedFileMock = mRepositoryIMockCreateConvertedFile{mock: m}
	m.CreateConvertedFileMock.callArgs = []*RepositoryIMockCreateConvertedFileParams{}

	m.CreateKnowledgeBaseMock = mRepositoryIMockCreateKnowledgeBase{mock: m}
	m.CreateKnowledgeBaseMock.callArgs = []*RepositoryIMockCreateKnowledgeBaseParams{}

	m.CreateKnowledgeBaseFileMock = mRepositoryIMockCreateKnowledgeBaseFile{mock: m}
	m.CreateKnowledgeBaseFileMock.callArgs = []*RepositoryIMockCreateKnowledgeBaseFileParams{}

	m.DeleteAndCreateChunksMock = mRepositoryIMockDeleteAndCreateChunks{mock: m}
	m.DeleteAndCreateChunksMock.callArgs = []*RepositoryIMockDeleteAndCreateChunksParams{}

	m.DeleteChunksBySourceMock = mRepositoryIMockDeleteChunksBySource{mock: m}
	m.DeleteChunksBySourceMock.callArgs = []*RepositoryIMockDeleteChunksBySourceParams{}

	m.DeleteChunksByUIDsMock = mRepositoryIMockDeleteChunksByUIDs{mock: m}
	m.DeleteChunksByUIDsMock.callArgs = []*RepositoryIMockDeleteChunksByUIDsParams{}

	m.DeleteConvertedFileMock = mRepositoryIMockDeleteConvertedFile{mock: m}
	m.DeleteConvertedFileMock.callArgs = []*RepositoryIMockDeleteConvertedFileParams{}

	m.DeleteEmbeddingsBySourceMock = mRepositoryIMockDeleteEmbeddingsBySource{mock: m}
	m.DeleteEmbeddingsBySourceMock.callArgs = []*RepositoryIMockDeleteEmbeddingsBySourceParams{}

	m.DeleteEmbeddingsByUIDsMock = mRepositoryIMockDeleteEmbeddingsByUIDs{mock: m}
	m.DeleteEmbeddingsByUIDsMock.callArgs = []*RepositoryIMockDeleteEmbeddingsByUIDsParams{}

	m.DeleteKnowledgeBaseMock = mRepositoryIMockDeleteKnowledgeBase{mock: m}
	m.DeleteKnowledgeBaseMock.callArgs = []*RepositoryIMockDeleteKnowledgeBaseParams{}

	m.DeleteKnowledgeBaseFileMock = mRepositoryIMockDeleteKnowledgeBaseFile{mock: m}
	m.DeleteKnowledgeBaseFileMock.callArgs = []*RepositoryIMockDeleteKnowledgeBaseFileParams{}

	m.DeleteRepositoryTagMock = mRepositoryIMockDeleteRepositoryTag{mock: m}
	m.DeleteRepositoryTagMock.callArgs = []*RepositoryIMockDeleteRepositoryTagParams{}

	m.GetConvertedFileByFileUIDMock = mRepositoryIMockGetConvertedFileByFileUID{mock: m}
	m.GetConvertedFileByFileUIDMock.callArgs = []*RepositoryIMockGetConvertedFileByFileUIDParams{}

	m.GetIncompleteFileMock = mRepositoryIMockGetIncompleteFile{mock: m}
	m.GetIncompleteFileMock.callArgs = []*RepositoryIMockGetIncompleteFileParams{}

	m.GetKnowledgeBaseByOwnerAndIDMock = mRepositoryIMockGetKnowledgeBaseByOwnerAndID{mock: m}
	m.GetKnowledgeBaseByOwnerAndIDMock.callArgs = []*RepositoryIMockGetKnowledgeBaseByOwnerAndIDParams{}

	m.GetRepositoryTagMock = mRepositoryIMockGetRepositoryTag{mock: m}
	m.GetRepositoryTagMock.callArgs = []*RepositoryIMockGetRepositoryTagParams{}

	m.GetTextChunksBySourceMock = mRepositoryIMockGetTextChunksBySource{mock: m}
	m.GetTextChunksBySourceMock.callArgs = []*RepositoryIMockGetTextChunksBySourceParams{}

	m.KnowledgeBaseFileTableNameMock = mRepositoryIMockKnowledgeBaseFileTableName{mock: m}

	m.ListKnowledgeBaseFilesMock = mRepositoryIMockListKnowledgeBaseFiles{mock: m}
	m.ListKnowledgeBaseFilesMock.callArgs = []*RepositoryIMockListKnowledgeBaseFilesParams{}

	m.ListKnowledgeBasesMock = mRepositoryIMockListKnowledgeBases{mock: m}
	m.ListKnowledgeBasesMock.callArgs = []*RepositoryIMockListKnowledgeBasesParams{}

	m.ProcessKnowledgeBaseFilesMock = mRepositoryIMockProcessKnowledgeBaseFiles{mock: m}
	m.ProcessKnowledgeBaseFilesMock.callArgs = []*RepositoryIMockProcessKnowledgeBaseFilesParams{}

	m.UpdateKnowledgeBaseMock = mRepositoryIMockUpdateKnowledgeBase{mock: m}
	m.UpdateKnowledgeBaseMock.callArgs = []*RepositoryIMockUpdateKnowledgeBaseParams{}

	m.UpdateKnowledgeBaseFileMock = mRepositoryIMockUpdateKnowledgeBaseFile{mock: m}
	m.UpdateKnowledgeBaseFileMock.callArgs = []*RepositoryIMockUpdateKnowledgeBaseFileParams{}

	m.UpsertEmbeddingsMock = mRepositoryIMockUpsertEmbeddings{mock: m}
	m.UpsertEmbeddingsMock.callArgs = []*RepositoryIMockUpsertEmbeddingsParams{}

	m.UpsertRepositoryTagMock = mRepositoryIMockUpsertRepositoryTag{mock: m}
	m.UpsertRepositoryTagMock.callArgs = []*RepositoryIMockUpsertRepositoryTagParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryIMockConvertedFileTableName struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockConvertedFileTableNameExpectation
	expectations       []*RepositoryIMockConvertedFileTableNameExpectation

	expectedInvocations uint64
}

// RepositoryIMockConvertedFileTableNameExpectation specifies expectation struct of the RepositoryI.ConvertedFileTableName
type RepositoryIMockConvertedFileTableNameExpectation struct {
	mock *RepositoryIMock

	results *RepositoryIMockConvertedFileTableNameResults
	Counter uint64
}

// RepositoryIMockConvertedFileTableNameResults contains results of the RepositoryI.ConvertedFileTableName
type RepositoryIMockConvertedFileTableNameResults struct {
	s1 string
}

// Expect sets up expected params for RepositoryI.ConvertedFileTableName
func (mmConvertedFileTableName *mRepositoryIMockConvertedFileTableName) Expect() *mRepositoryIMockConvertedFileTableName {
	if mmConvertedFileTableName.mock.funcConvertedFileTableName != nil {
		mmConvertedFileTableName.mock.t.Fatalf("RepositoryIMock.ConvertedFileTableName mock is already set by Set")
	}

	if mmConvertedFileTableName.defaultExpectation == nil {
		mmConvertedFileTableName.defaultExpectation = &RepositoryIMockConvertedFileTableNameExpectation{}
	}

	return mmConvertedFileTableName
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.ConvertedFileTableName
func (mmConvertedFileTableName *mRepositoryIMockConvertedFileTableName) Inspect(f func()) *mRepositoryIMockConvertedFileTableName {
	if mmConvertedFileTableName.mock.inspectFuncConvertedFileTableName != nil {
		mmConvertedFileTableName.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.ConvertedFileTableName")
	}

	mmConvertedFileTableName.mock.inspectFuncConvertedFileTableName = f

	return mmConvertedFileTableName
}

// Return sets up results that will be returned by RepositoryI.ConvertedFileTableName
func (mmConvertedFileTableName *mRepositoryIMockConvertedFileTableName) Return(s1 string) *RepositoryIMock {
	if mmConvertedFileTableName.mock.funcConvertedFileTableName != nil {
		mmConvertedFileTableName.mock.t.Fatalf("RepositoryIMock.ConvertedFileTableName mock is already set by Set")
	}

	if mmConvertedFileTableName.defaultExpectation == nil {
		mmConvertedFileTableName.defaultExpectation = &RepositoryIMockConvertedFileTableNameExpectation{mock: mmConvertedFileTableName.mock}
	}
	mmConvertedFileTableName.defaultExpectation.results = &RepositoryIMockConvertedFileTableNameResults{s1}
	return mmConvertedFileTableName.mock
}

// Set uses given function f to mock the RepositoryI.ConvertedFileTableName method
func (mmConvertedFileTableName *mRepositoryIMockConvertedFileTableName) Set(f func() (s1 string)) *RepositoryIMock {
	if mmConvertedFileTableName.defaultExpectation != nil {
		mmConvertedFileTableName.mock.t.Fatalf("Default expectation is already set for the RepositoryI.ConvertedFileTableName method")
	}

	if len(mmConvertedFileTableName.expectations) > 0 {
		mmConvertedFileTableName.mock.t.Fatalf("Some expectations are already set for the RepositoryI.ConvertedFileTableName method")
	}

	mmConvertedFileTableName.mock.funcConvertedFileTableName = f
	return mmConvertedFileTableName.mock
}

// Times sets number of times RepositoryI.ConvertedFileTableName should be invoked
func (mmConvertedFileTableName *mRepositoryIMockConvertedFileTableName) Times(n uint64) *mRepositoryIMockConvertedFileTableName {
	if n == 0 {
		mmConvertedFileTableName.mock.t.Fatalf("Times of RepositoryIMock.ConvertedFileTableName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertedFileTableName.expectedInvocations, n)
	return mmConvertedFileTableName
}

func (mmConvertedFileTableName *mRepositoryIMockConvertedFileTableName) invocationsDone() bool {
	if len(mmConvertedFileTableName.expectations) == 0 && mmConvertedFileTableName.defaultExpectation == nil && mmConvertedFileTableName.mock.funcConvertedFileTableName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertedFileTableName.mock.afterConvertedFileTableNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertedFileTableName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertedFileTableName implements repository.RepositoryI
func (mmConvertedFileTableName *RepositoryIMock) ConvertedFileTableName() (s1 string) {
	mm_atomic.AddUint64(&mmConvertedFileTableName.beforeConvertedFileTableNameCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertedFileTableName.afterConvertedFileTableNameCounter, 1)

	if mmConvertedFileTableName.inspectFuncConvertedFileTableName != nil {
		mmConvertedFileTableName.inspectFuncConvertedFileTableName()
	}

	if mmConvertedFileTableName.ConvertedFileTableNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertedFileTableName.ConvertedFileTableNameMock.defaultExpectation.Counter, 1)

		mm_results := mmConvertedFileTableName.ConvertedFileTableNameMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertedFileTableName.t.Fatal("No results are set for the RepositoryIMock.ConvertedFileTableName")
		}
		return (*mm_results).s1
	}
	if mmConvertedFileTableName.funcConvertedFileTableName != nil {
		return mmConvertedFileTableName.funcConvertedFileTableName()
	}
	mmConvertedFileTableName.t.Fatalf("Unexpected call to RepositoryIMock.ConvertedFileTableName.")
	return
}

// ConvertedFileTableNameAfterCounter returns a count of finished RepositoryIMock.ConvertedFileTableName invocations
func (mmConvertedFileTableName *RepositoryIMock) ConvertedFileTableNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertedFileTableName.afterConvertedFileTableNameCounter)
}

// ConvertedFileTableNameBeforeCounter returns a count of RepositoryIMock.ConvertedFileTableName invocations
func (mmConvertedFileTableName *RepositoryIMock) ConvertedFileTableNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertedFileTableName.beforeConvertedFileTableNameCounter)
}

// MinimockConvertedFileTableNameDone returns true if the count of the ConvertedFileTableName invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockConvertedFileTableNameDone() bool {
	for _, e := range m.ConvertedFileTableNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertedFileTableNameMock.invocationsDone()
}

// MinimockConvertedFileTableNameInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockConvertedFileTableNameInspect() {
	for _, e := range m.ConvertedFileTableNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryIMock.ConvertedFileTableName")
		}
	}

	afterConvertedFileTableNameCounter := mm_atomic.LoadUint64(&m.afterConvertedFileTableNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertedFileTableNameMock.defaultExpectation != nil && afterConvertedFileTableNameCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.ConvertedFileTableName")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertedFileTableName != nil && afterConvertedFileTableNameCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.ConvertedFileTableName")
	}

	if !m.ConvertedFileTableNameMock.invocationsDone() && afterConvertedFileTableNameCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.ConvertedFileTableName but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertedFileTableNameMock.expectedInvocations), afterConvertedFileTableNameCounter)
	}
}

type mRepositoryIMockCreateConvertedFile struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockCreateConvertedFileExpectation
	expectations       []*RepositoryIMockCreateConvertedFileExpectation

	callArgs []*RepositoryIMockCreateConvertedFileParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockCreateConvertedFileExpectation specifies expectation struct of the RepositoryI.CreateConvertedFile
type RepositoryIMockCreateConvertedFileExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockCreateConvertedFileParams
	paramPtrs *RepositoryIMockCreateConvertedFileParamPtrs
	results   *RepositoryIMockCreateConvertedFileResults
	Counter   uint64
}

// RepositoryIMockCreateConvertedFileParams contains parameters of the RepositoryI.CreateConvertedFile
type RepositoryIMockCreateConvertedFileParams struct {
	ctx                 context.Context
	cf                  mm_repository.ConvertedFile
	callExternalService func(convertedFileUID uuid.UUID) error
}

// RepositoryIMockCreateConvertedFileParamPtrs contains pointers to parameters of the RepositoryI.CreateConvertedFile
type RepositoryIMockCreateConvertedFileParamPtrs struct {
	ctx                 *context.Context
	cf                  *mm_repository.ConvertedFile
	callExternalService *func(convertedFileUID uuid.UUID) error
}

// RepositoryIMockCreateConvertedFileResults contains results of the RepositoryI.CreateConvertedFile
type RepositoryIMockCreateConvertedFileResults struct {
	cp1 *mm_repository.ConvertedFile
	err error
}

// Expect sets up expected params for RepositoryI.CreateConvertedFile
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) Expect(ctx context.Context, cf mm_repository.ConvertedFile, callExternalService func(convertedFileUID uuid.UUID) error) *mRepositoryIMockCreateConvertedFile {
	if mmCreateConvertedFile.mock.funcCreateConvertedFile != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by Set")
	}

	if mmCreateConvertedFile.defaultExpectation == nil {
		mmCreateConvertedFile.defaultExpectation = &RepositoryIMockCreateConvertedFileExpectation{}
	}

	if mmCreateConvertedFile.defaultExpectation.paramPtrs != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by ExpectParams functions")
	}

	mmCreateConvertedFile.defaultExpectation.params = &RepositoryIMockCreateConvertedFileParams{ctx, cf, callExternalService}
	for _, e := range mmCreateConvertedFile.expectations {
		if minimock.Equal(e.params, mmCreateConvertedFile.defaultExpectation.params) {
			mmCreateConvertedFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateConvertedFile.defaultExpectation.params)
		}
	}

	return mmCreateConvertedFile
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.CreateConvertedFile
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockCreateConvertedFile {
	if mmCreateConvertedFile.mock.funcCreateConvertedFile != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by Set")
	}

	if mmCreateConvertedFile.defaultExpectation == nil {
		mmCreateConvertedFile.defaultExpectation = &RepositoryIMockCreateConvertedFileExpectation{}
	}

	if mmCreateConvertedFile.defaultExpectation.params != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by Expect")
	}

	if mmCreateConvertedFile.defaultExpectation.paramPtrs == nil {
		mmCreateConvertedFile.defaultExpectation.paramPtrs = &RepositoryIMockCreateConvertedFileParamPtrs{}
	}
	mmCreateConvertedFile.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateConvertedFile
}

// ExpectCfParam2 sets up expected param cf for RepositoryI.CreateConvertedFile
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) ExpectCfParam2(cf mm_repository.ConvertedFile) *mRepositoryIMockCreateConvertedFile {
	if mmCreateConvertedFile.mock.funcCreateConvertedFile != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by Set")
	}

	if mmCreateConvertedFile.defaultExpectation == nil {
		mmCreateConvertedFile.defaultExpectation = &RepositoryIMockCreateConvertedFileExpectation{}
	}

	if mmCreateConvertedFile.defaultExpectation.params != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by Expect")
	}

	if mmCreateConvertedFile.defaultExpectation.paramPtrs == nil {
		mmCreateConvertedFile.defaultExpectation.paramPtrs = &RepositoryIMockCreateConvertedFileParamPtrs{}
	}
	mmCreateConvertedFile.defaultExpectation.paramPtrs.cf = &cf

	return mmCreateConvertedFile
}

// ExpectCallExternalServiceParam3 sets up expected param callExternalService for RepositoryI.CreateConvertedFile
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) ExpectCallExternalServiceParam3(callExternalService func(convertedFileUID uuid.UUID) error) *mRepositoryIMockCreateConvertedFile {
	if mmCreateConvertedFile.mock.funcCreateConvertedFile != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by Set")
	}

	if mmCreateConvertedFile.defaultExpectation == nil {
		mmCreateConvertedFile.defaultExpectation = &RepositoryIMockCreateConvertedFileExpectation{}
	}

	if mmCreateConvertedFile.defaultExpectation.params != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by Expect")
	}

	if mmCreateConvertedFile.defaultExpectation.paramPtrs == nil {
		mmCreateConvertedFile.defaultExpectation.paramPtrs = &RepositoryIMockCreateConvertedFileParamPtrs{}
	}
	mmCreateConvertedFile.defaultExpectation.paramPtrs.callExternalService = &callExternalService

	return mmCreateConvertedFile
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.CreateConvertedFile
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) Inspect(f func(ctx context.Context, cf mm_repository.ConvertedFile, callExternalService func(convertedFileUID uuid.UUID) error)) *mRepositoryIMockCreateConvertedFile {
	if mmCreateConvertedFile.mock.inspectFuncCreateConvertedFile != nil {
		mmCreateConvertedFile.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.CreateConvertedFile")
	}

	mmCreateConvertedFile.mock.inspectFuncCreateConvertedFile = f

	return mmCreateConvertedFile
}

// Return sets up results that will be returned by RepositoryI.CreateConvertedFile
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) Return(cp1 *mm_repository.ConvertedFile, err error) *RepositoryIMock {
	if mmCreateConvertedFile.mock.funcCreateConvertedFile != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by Set")
	}

	if mmCreateConvertedFile.defaultExpectation == nil {
		mmCreateConvertedFile.defaultExpectation = &RepositoryIMockCreateConvertedFileExpectation{mock: mmCreateConvertedFile.mock}
	}
	mmCreateConvertedFile.defaultExpectation.results = &RepositoryIMockCreateConvertedFileResults{cp1, err}
	return mmCreateConvertedFile.mock
}

// Set uses given function f to mock the RepositoryI.CreateConvertedFile method
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) Set(f func(ctx context.Context, cf mm_repository.ConvertedFile, callExternalService func(convertedFileUID uuid.UUID) error) (cp1 *mm_repository.ConvertedFile, err error)) *RepositoryIMock {
	if mmCreateConvertedFile.defaultExpectation != nil {
		mmCreateConvertedFile.mock.t.Fatalf("Default expectation is already set for the RepositoryI.CreateConvertedFile method")
	}

	if len(mmCreateConvertedFile.expectations) > 0 {
		mmCreateConvertedFile.mock.t.Fatalf("Some expectations are already set for the RepositoryI.CreateConvertedFile method")
	}

	mmCreateConvertedFile.mock.funcCreateConvertedFile = f
	return mmCreateConvertedFile.mock
}

// When sets expectation for the RepositoryI.CreateConvertedFile which will trigger the result defined by the following
// Then helper
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) When(ctx context.Context, cf mm_repository.ConvertedFile, callExternalService func(convertedFileUID uuid.UUID) error) *RepositoryIMockCreateConvertedFileExpectation {
	if mmCreateConvertedFile.mock.funcCreateConvertedFile != nil {
		mmCreateConvertedFile.mock.t.Fatalf("RepositoryIMock.CreateConvertedFile mock is already set by Set")
	}

	expectation := &RepositoryIMockCreateConvertedFileExpectation{
		mock:   mmCreateConvertedFile.mock,
		params: &RepositoryIMockCreateConvertedFileParams{ctx, cf, callExternalService},
	}
	mmCreateConvertedFile.expectations = append(mmCreateConvertedFile.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.CreateConvertedFile return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockCreateConvertedFileExpectation) Then(cp1 *mm_repository.ConvertedFile, err error) *RepositoryIMock {
	e.results = &RepositoryIMockCreateConvertedFileResults{cp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.CreateConvertedFile should be invoked
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) Times(n uint64) *mRepositoryIMockCreateConvertedFile {
	if n == 0 {
		mmCreateConvertedFile.mock.t.Fatalf("Times of RepositoryIMock.CreateConvertedFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateConvertedFile.expectedInvocations, n)
	return mmCreateConvertedFile
}

func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) invocationsDone() bool {
	if len(mmCreateConvertedFile.expectations) == 0 && mmCreateConvertedFile.defaultExpectation == nil && mmCreateConvertedFile.mock.funcCreateConvertedFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateConvertedFile.mock.afterCreateConvertedFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateConvertedFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateConvertedFile implements repository.RepositoryI
func (mmCreateConvertedFile *RepositoryIMock) CreateConvertedFile(ctx context.Context, cf mm_repository.ConvertedFile, callExternalService func(convertedFileUID uuid.UUID) error) (cp1 *mm_repository.ConvertedFile, err error) {
	mm_atomic.AddUint64(&mmCreateConvertedFile.beforeCreateConvertedFileCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateConvertedFile.afterCreateConvertedFileCounter, 1)

	if mmCreateConvertedFile.inspectFuncCreateConvertedFile != nil {
		mmCreateConvertedFile.inspectFuncCreateConvertedFile(ctx, cf, callExternalService)
	}

	mm_params := RepositoryIMockCreateConvertedFileParams{ctx, cf, callExternalService}

	// Record call args
	mmCreateConvertedFile.CreateConvertedFileMock.mutex.Lock()
	mmCreateConvertedFile.CreateConvertedFileMock.callArgs = append(mmCreateConvertedFile.CreateConvertedFileMock.callArgs, &mm_params)
	mmCreateConvertedFile.CreateConvertedFileMock.mutex.Unlock()

	for _, e := range mmCreateConvertedFile.CreateConvertedFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCreateConvertedFile.CreateConvertedFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateConvertedFile.CreateConvertedFileMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateConvertedFile.CreateConvertedFileMock.defaultExpectation.params
		mm_want_ptrs := mmCreateConvertedFile.CreateConvertedFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockCreateConvertedFileParams{ctx, cf, callExternalService}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateConvertedFile.t.Errorf("RepositoryIMock.CreateConvertedFile got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cf != nil && !minimock.Equal(*mm_want_ptrs.cf, mm_got.cf) {
				mmCreateConvertedFile.t.Errorf("RepositoryIMock.CreateConvertedFile got unexpected parameter cf, want: %#v, got: %#v%s\n", *mm_want_ptrs.cf, mm_got.cf, minimock.Diff(*mm_want_ptrs.cf, mm_got.cf))
			}

			if mm_want_ptrs.callExternalService != nil && !minimock.Equal(*mm_want_ptrs.callExternalService, mm_got.callExternalService) {
				mmCreateConvertedFile.t.Errorf("RepositoryIMock.CreateConvertedFile got unexpected parameter callExternalService, want: %#v, got: %#v%s\n", *mm_want_ptrs.callExternalService, mm_got.callExternalService, minimock.Diff(*mm_want_ptrs.callExternalService, mm_got.callExternalService))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateConvertedFile.t.Errorf("RepositoryIMock.CreateConvertedFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateConvertedFile.CreateConvertedFileMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateConvertedFile.t.Fatal("No results are set for the RepositoryIMock.CreateConvertedFile")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCreateConvertedFile.funcCreateConvertedFile != nil {
		return mmCreateConvertedFile.funcCreateConvertedFile(ctx, cf, callExternalService)
	}
	mmCreateConvertedFile.t.Fatalf("Unexpected call to RepositoryIMock.CreateConvertedFile. %v %v %v", ctx, cf, callExternalService)
	return
}

// CreateConvertedFileAfterCounter returns a count of finished RepositoryIMock.CreateConvertedFile invocations
func (mmCreateConvertedFile *RepositoryIMock) CreateConvertedFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateConvertedFile.afterCreateConvertedFileCounter)
}

// CreateConvertedFileBeforeCounter returns a count of RepositoryIMock.CreateConvertedFile invocations
func (mmCreateConvertedFile *RepositoryIMock) CreateConvertedFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateConvertedFile.beforeCreateConvertedFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.CreateConvertedFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateConvertedFile *mRepositoryIMockCreateConvertedFile) Calls() []*RepositoryIMockCreateConvertedFileParams {
	mmCreateConvertedFile.mutex.RLock()

	argCopy := make([]*RepositoryIMockCreateConvertedFileParams, len(mmCreateConvertedFile.callArgs))
	copy(argCopy, mmCreateConvertedFile.callArgs)

	mmCreateConvertedFile.mutex.RUnlock()

	return argCopy
}

// MinimockCreateConvertedFileDone returns true if the count of the CreateConvertedFile invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockCreateConvertedFileDone() bool {
	for _, e := range m.CreateConvertedFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateConvertedFileMock.invocationsDone()
}

// MinimockCreateConvertedFileInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockCreateConvertedFileInspect() {
	for _, e := range m.CreateConvertedFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.CreateConvertedFile with params: %#v", *e.params)
		}
	}

	afterCreateConvertedFileCounter := mm_atomic.LoadUint64(&m.afterCreateConvertedFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateConvertedFileMock.defaultExpectation != nil && afterCreateConvertedFileCounter < 1 {
		if m.CreateConvertedFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.CreateConvertedFile")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.CreateConvertedFile with params: %#v", *m.CreateConvertedFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateConvertedFile != nil && afterCreateConvertedFileCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.CreateConvertedFile")
	}

	if !m.CreateConvertedFileMock.invocationsDone() && afterCreateConvertedFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.CreateConvertedFile but found %d calls",
			mm_atomic.LoadUint64(&m.CreateConvertedFileMock.expectedInvocations), afterCreateConvertedFileCounter)
	}
}

type mRepositoryIMockCreateKnowledgeBase struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockCreateKnowledgeBaseExpectation
	expectations       []*RepositoryIMockCreateKnowledgeBaseExpectation

	callArgs []*RepositoryIMockCreateKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockCreateKnowledgeBaseExpectation specifies expectation struct of the RepositoryI.CreateKnowledgeBase
type RepositoryIMockCreateKnowledgeBaseExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockCreateKnowledgeBaseParams
	paramPtrs *RepositoryIMockCreateKnowledgeBaseParamPtrs
	results   *RepositoryIMockCreateKnowledgeBaseResults
	Counter   uint64
}

// RepositoryIMockCreateKnowledgeBaseParams contains parameters of the RepositoryI.CreateKnowledgeBase
type RepositoryIMockCreateKnowledgeBaseParams struct {
	ctx             context.Context
	kb              mm_repository.KnowledgeBase
	externalService func(kbUID string) error
}

// RepositoryIMockCreateKnowledgeBaseParamPtrs contains pointers to parameters of the RepositoryI.CreateKnowledgeBase
type RepositoryIMockCreateKnowledgeBaseParamPtrs struct {
	ctx             *context.Context
	kb              *mm_repository.KnowledgeBase
	externalService *func(kbUID string) error
}

// RepositoryIMockCreateKnowledgeBaseResults contains results of the RepositoryI.CreateKnowledgeBase
type RepositoryIMockCreateKnowledgeBaseResults struct {
	kp1 *mm_repository.KnowledgeBase
	err error
}

// Expect sets up expected params for RepositoryI.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) Expect(ctx context.Context, kb mm_repository.KnowledgeBase, externalService func(kbUID string) error) *mRepositoryIMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmCreateKnowledgeBase.defaultExpectation.params = &RepositoryIMockCreateKnowledgeBaseParams{ctx, kb, externalService}
	for _, e := range mmCreateKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmCreateKnowledgeBase.defaultExpectation.params) {
			mmCreateKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmCreateKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.params != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Expect")
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockCreateKnowledgeBaseParamPtrs{}
	}
	mmCreateKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateKnowledgeBase
}

// ExpectKbParam2 sets up expected param kb for RepositoryI.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) ExpectKbParam2(kb mm_repository.KnowledgeBase) *mRepositoryIMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.params != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Expect")
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockCreateKnowledgeBaseParamPtrs{}
	}
	mmCreateKnowledgeBase.defaultExpectation.paramPtrs.kb = &kb

	return mmCreateKnowledgeBase
}

// ExpectExternalServiceParam3 sets up expected param externalService for RepositoryI.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) ExpectExternalServiceParam3(externalService func(kbUID string) error) *mRepositoryIMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.params != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Expect")
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockCreateKnowledgeBaseParamPtrs{}
	}
	mmCreateKnowledgeBase.defaultExpectation.paramPtrs.externalService = &externalService

	return mmCreateKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) Inspect(f func(ctx context.Context, kb mm_repository.KnowledgeBase, externalService func(kbUID string) error)) *mRepositoryIMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.inspectFuncCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.CreateKnowledgeBase")
	}

	mmCreateKnowledgeBase.mock.inspectFuncCreateKnowledgeBase = f

	return mmCreateKnowledgeBase
}

// Return sets up results that will be returned by RepositoryI.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) Return(kp1 *mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseExpectation{mock: mmCreateKnowledgeBase.mock}
	}
	mmCreateKnowledgeBase.defaultExpectation.results = &RepositoryIMockCreateKnowledgeBaseResults{kp1, err}
	return mmCreateKnowledgeBase.mock
}

// Set uses given function f to mock the RepositoryI.CreateKnowledgeBase method
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) Set(f func(ctx context.Context, kb mm_repository.KnowledgeBase, externalService func(kbUID string) error) (kp1 *mm_repository.KnowledgeBase, err error)) *RepositoryIMock {
	if mmCreateKnowledgeBase.defaultExpectation != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the RepositoryI.CreateKnowledgeBase method")
	}

	if len(mmCreateKnowledgeBase.expectations) > 0 {
		mmCreateKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the RepositoryI.CreateKnowledgeBase method")
	}

	mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase = f
	return mmCreateKnowledgeBase.mock
}

// When sets expectation for the RepositoryI.CreateKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) When(ctx context.Context, kb mm_repository.KnowledgeBase, externalService func(kbUID string) error) *RepositoryIMockCreateKnowledgeBaseExpectation {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBase mock is already set by Set")
	}

	expectation := &RepositoryIMockCreateKnowledgeBaseExpectation{
		mock:   mmCreateKnowledgeBase.mock,
		params: &RepositoryIMockCreateKnowledgeBaseParams{ctx, kb, externalService},
	}
	mmCreateKnowledgeBase.expectations = append(mmCreateKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.CreateKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockCreateKnowledgeBaseExpectation) Then(kp1 *mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	e.results = &RepositoryIMockCreateKnowledgeBaseResults{kp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.CreateKnowledgeBase should be invoked
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) Times(n uint64) *mRepositoryIMockCreateKnowledgeBase {
	if n == 0 {
		mmCreateKnowledgeBase.mock.t.Fatalf("Times of RepositoryIMock.CreateKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateKnowledgeBase.expectedInvocations, n)
	return mmCreateKnowledgeBase
}

func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) invocationsDone() bool {
	if len(mmCreateKnowledgeBase.expectations) == 0 && mmCreateKnowledgeBase.defaultExpectation == nil && mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateKnowledgeBase.mock.afterCreateKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateKnowledgeBase implements repository.RepositoryI
func (mmCreateKnowledgeBase *RepositoryIMock) CreateKnowledgeBase(ctx context.Context, kb mm_repository.KnowledgeBase, externalService func(kbUID string) error) (kp1 *mm_repository.KnowledgeBase, err error) {
	mm_atomic.AddUint64(&mmCreateKnowledgeBase.beforeCreateKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateKnowledgeBase.afterCreateKnowledgeBaseCounter, 1)

	if mmCreateKnowledgeBase.inspectFuncCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.inspectFuncCreateKnowledgeBase(ctx, kb, externalService)
	}

	mm_params := RepositoryIMockCreateKnowledgeBaseParams{ctx, kb, externalService}

	// Record call args
	mmCreateKnowledgeBase.CreateKnowledgeBaseMock.mutex.Lock()
	mmCreateKnowledgeBase.CreateKnowledgeBaseMock.callArgs = append(mmCreateKnowledgeBase.CreateKnowledgeBaseMock.callArgs, &mm_params)
	mmCreateKnowledgeBase.CreateKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmCreateKnowledgeBase.CreateKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockCreateKnowledgeBaseParams{ctx, kb, externalService}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateKnowledgeBase.t.Errorf("RepositoryIMock.CreateKnowledgeBase got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kb != nil && !minimock.Equal(*mm_want_ptrs.kb, mm_got.kb) {
				mmCreateKnowledgeBase.t.Errorf("RepositoryIMock.CreateKnowledgeBase got unexpected parameter kb, want: %#v, got: %#v%s\n", *mm_want_ptrs.kb, mm_got.kb, minimock.Diff(*mm_want_ptrs.kb, mm_got.kb))
			}

			if mm_want_ptrs.externalService != nil && !minimock.Equal(*mm_want_ptrs.externalService, mm_got.externalService) {
				mmCreateKnowledgeBase.t.Errorf("RepositoryIMock.CreateKnowledgeBase got unexpected parameter externalService, want: %#v, got: %#v%s\n", *mm_want_ptrs.externalService, mm_got.externalService, minimock.Diff(*mm_want_ptrs.externalService, mm_got.externalService))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateKnowledgeBase.t.Errorf("RepositoryIMock.CreateKnowledgeBase got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateKnowledgeBase.t.Fatal("No results are set for the RepositoryIMock.CreateKnowledgeBase")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmCreateKnowledgeBase.funcCreateKnowledgeBase != nil {
		return mmCreateKnowledgeBase.funcCreateKnowledgeBase(ctx, kb, externalService)
	}
	mmCreateKnowledgeBase.t.Fatalf("Unexpected call to RepositoryIMock.CreateKnowledgeBase. %v %v %v", ctx, kb, externalService)
	return
}

// CreateKnowledgeBaseAfterCounter returns a count of finished RepositoryIMock.CreateKnowledgeBase invocations
func (mmCreateKnowledgeBase *RepositoryIMock) CreateKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateKnowledgeBase.afterCreateKnowledgeBaseCounter)
}

// CreateKnowledgeBaseBeforeCounter returns a count of RepositoryIMock.CreateKnowledgeBase invocations
func (mmCreateKnowledgeBase *RepositoryIMock) CreateKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateKnowledgeBase.beforeCreateKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.CreateKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateKnowledgeBase *mRepositoryIMockCreateKnowledgeBase) Calls() []*RepositoryIMockCreateKnowledgeBaseParams {
	mmCreateKnowledgeBase.mutex.RLock()

	argCopy := make([]*RepositoryIMockCreateKnowledgeBaseParams, len(mmCreateKnowledgeBase.callArgs))
	copy(argCopy, mmCreateKnowledgeBase.callArgs)

	mmCreateKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockCreateKnowledgeBaseDone returns true if the count of the CreateKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockCreateKnowledgeBaseDone() bool {
	for _, e := range m.CreateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateKnowledgeBaseMock.invocationsDone()
}

// MinimockCreateKnowledgeBaseInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockCreateKnowledgeBaseInspect() {
	for _, e := range m.CreateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.CreateKnowledgeBase with params: %#v", *e.params)
		}
	}

	afterCreateKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterCreateKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateKnowledgeBaseMock.defaultExpectation != nil && afterCreateKnowledgeBaseCounter < 1 {
		if m.CreateKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.CreateKnowledgeBase")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.CreateKnowledgeBase with params: %#v", *m.CreateKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateKnowledgeBase != nil && afterCreateKnowledgeBaseCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.CreateKnowledgeBase")
	}

	if !m.CreateKnowledgeBaseMock.invocationsDone() && afterCreateKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.CreateKnowledgeBase but found %d calls",
			mm_atomic.LoadUint64(&m.CreateKnowledgeBaseMock.expectedInvocations), afterCreateKnowledgeBaseCounter)
	}
}

type mRepositoryIMockCreateKnowledgeBaseFile struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockCreateKnowledgeBaseFileExpectation
	expectations       []*RepositoryIMockCreateKnowledgeBaseFileExpectation

	callArgs []*RepositoryIMockCreateKnowledgeBaseFileParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockCreateKnowledgeBaseFileExpectation specifies expectation struct of the RepositoryI.CreateKnowledgeBaseFile
type RepositoryIMockCreateKnowledgeBaseFileExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockCreateKnowledgeBaseFileParams
	paramPtrs *RepositoryIMockCreateKnowledgeBaseFileParamPtrs
	results   *RepositoryIMockCreateKnowledgeBaseFileResults
	Counter   uint64
}

// RepositoryIMockCreateKnowledgeBaseFileParams contains parameters of the RepositoryI.CreateKnowledgeBaseFile
type RepositoryIMockCreateKnowledgeBaseFileParams struct {
	ctx                 context.Context
	kb                  mm_repository.KnowledgeBaseFile
	externalServiceCall func(FileUID string) error
}

// RepositoryIMockCreateKnowledgeBaseFileParamPtrs contains pointers to parameters of the RepositoryI.CreateKnowledgeBaseFile
type RepositoryIMockCreateKnowledgeBaseFileParamPtrs struct {
	ctx                 *context.Context
	kb                  *mm_repository.KnowledgeBaseFile
	externalServiceCall *func(FileUID string) error
}

// RepositoryIMockCreateKnowledgeBaseFileResults contains results of the RepositoryI.CreateKnowledgeBaseFile
type RepositoryIMockCreateKnowledgeBaseFileResults struct {
	kp1 *mm_repository.KnowledgeBaseFile
	err error
}

// Expect sets up expected params for RepositoryI.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) Expect(ctx context.Context, kb mm_repository.KnowledgeBaseFile, externalServiceCall func(FileUID string) error) *mRepositoryIMockCreateKnowledgeBaseFile {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseFileExpectation{}
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by ExpectParams functions")
	}

	mmCreateKnowledgeBaseFile.defaultExpectation.params = &RepositoryIMockCreateKnowledgeBaseFileParams{ctx, kb, externalServiceCall}
	for _, e := range mmCreateKnowledgeBaseFile.expectations {
		if minimock.Equal(e.params, mmCreateKnowledgeBaseFile.defaultExpectation.params) {
			mmCreateKnowledgeBaseFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateKnowledgeBaseFile.defaultExpectation.params)
		}
	}

	return mmCreateKnowledgeBaseFile
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockCreateKnowledgeBaseFile {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseFileExpectation{}
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryIMockCreateKnowledgeBaseFileParamPtrs{}
	}
	mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateKnowledgeBaseFile
}

// ExpectKbParam2 sets up expected param kb for RepositoryI.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) ExpectKbParam2(kb mm_repository.KnowledgeBaseFile) *mRepositoryIMockCreateKnowledgeBaseFile {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseFileExpectation{}
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryIMockCreateKnowledgeBaseFileParamPtrs{}
	}
	mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs.kb = &kb

	return mmCreateKnowledgeBaseFile
}

// ExpectExternalServiceCallParam3 sets up expected param externalServiceCall for RepositoryI.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) ExpectExternalServiceCallParam3(externalServiceCall func(FileUID string) error) *mRepositoryIMockCreateKnowledgeBaseFile {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseFileExpectation{}
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryIMockCreateKnowledgeBaseFileParamPtrs{}
	}
	mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs.externalServiceCall = &externalServiceCall

	return mmCreateKnowledgeBaseFile
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) Inspect(f func(ctx context.Context, kb mm_repository.KnowledgeBaseFile, externalServiceCall func(FileUID string) error)) *mRepositoryIMockCreateKnowledgeBaseFile {
	if mmCreateKnowledgeBaseFile.mock.inspectFuncCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.CreateKnowledgeBaseFile")
	}

	mmCreateKnowledgeBaseFile.mock.inspectFuncCreateKnowledgeBaseFile = f

	return mmCreateKnowledgeBaseFile
}

// Return sets up results that will be returned by RepositoryI.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) Return(kp1 *mm_repository.KnowledgeBaseFile, err error) *RepositoryIMock {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockCreateKnowledgeBaseFileExpectation{mock: mmCreateKnowledgeBaseFile.mock}
	}
	mmCreateKnowledgeBaseFile.defaultExpectation.results = &RepositoryIMockCreateKnowledgeBaseFileResults{kp1, err}
	return mmCreateKnowledgeBaseFile.mock
}

// Set uses given function f to mock the RepositoryI.CreateKnowledgeBaseFile method
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) Set(f func(ctx context.Context, kb mm_repository.KnowledgeBaseFile, externalServiceCall func(FileUID string) error) (kp1 *mm_repository.KnowledgeBaseFile, err error)) *RepositoryIMock {
	if mmCreateKnowledgeBaseFile.defaultExpectation != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("Default expectation is already set for the RepositoryI.CreateKnowledgeBaseFile method")
	}

	if len(mmCreateKnowledgeBaseFile.expectations) > 0 {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("Some expectations are already set for the RepositoryI.CreateKnowledgeBaseFile method")
	}

	mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile = f
	return mmCreateKnowledgeBaseFile.mock
}

// When sets expectation for the RepositoryI.CreateKnowledgeBaseFile which will trigger the result defined by the following
// Then helper
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) When(ctx context.Context, kb mm_repository.KnowledgeBaseFile, externalServiceCall func(FileUID string) error) *RepositoryIMockCreateKnowledgeBaseFileExpectation {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	expectation := &RepositoryIMockCreateKnowledgeBaseFileExpectation{
		mock:   mmCreateKnowledgeBaseFile.mock,
		params: &RepositoryIMockCreateKnowledgeBaseFileParams{ctx, kb, externalServiceCall},
	}
	mmCreateKnowledgeBaseFile.expectations = append(mmCreateKnowledgeBaseFile.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.CreateKnowledgeBaseFile return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockCreateKnowledgeBaseFileExpectation) Then(kp1 *mm_repository.KnowledgeBaseFile, err error) *RepositoryIMock {
	e.results = &RepositoryIMockCreateKnowledgeBaseFileResults{kp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.CreateKnowledgeBaseFile should be invoked
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) Times(n uint64) *mRepositoryIMockCreateKnowledgeBaseFile {
	if n == 0 {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("Times of RepositoryIMock.CreateKnowledgeBaseFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateKnowledgeBaseFile.expectedInvocations, n)
	return mmCreateKnowledgeBaseFile
}

func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) invocationsDone() bool {
	if len(mmCreateKnowledgeBaseFile.expectations) == 0 && mmCreateKnowledgeBaseFile.defaultExpectation == nil && mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateKnowledgeBaseFile.mock.afterCreateKnowledgeBaseFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateKnowledgeBaseFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateKnowledgeBaseFile implements repository.RepositoryI
func (mmCreateKnowledgeBaseFile *RepositoryIMock) CreateKnowledgeBaseFile(ctx context.Context, kb mm_repository.KnowledgeBaseFile, externalServiceCall func(FileUID string) error) (kp1 *mm_repository.KnowledgeBaseFile, err error) {
	mm_atomic.AddUint64(&mmCreateKnowledgeBaseFile.beforeCreateKnowledgeBaseFileCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateKnowledgeBaseFile.afterCreateKnowledgeBaseFileCounter, 1)

	if mmCreateKnowledgeBaseFile.inspectFuncCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.inspectFuncCreateKnowledgeBaseFile(ctx, kb, externalServiceCall)
	}

	mm_params := RepositoryIMockCreateKnowledgeBaseFileParams{ctx, kb, externalServiceCall}

	// Record call args
	mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.mutex.Lock()
	mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.callArgs = append(mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.callArgs, &mm_params)
	mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.mutex.Unlock()

	for _, e := range mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation.params
		mm_want_ptrs := mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockCreateKnowledgeBaseFileParams{ctx, kb, externalServiceCall}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateKnowledgeBaseFile.t.Errorf("RepositoryIMock.CreateKnowledgeBaseFile got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kb != nil && !minimock.Equal(*mm_want_ptrs.kb, mm_got.kb) {
				mmCreateKnowledgeBaseFile.t.Errorf("RepositoryIMock.CreateKnowledgeBaseFile got unexpected parameter kb, want: %#v, got: %#v%s\n", *mm_want_ptrs.kb, mm_got.kb, minimock.Diff(*mm_want_ptrs.kb, mm_got.kb))
			}

			if mm_want_ptrs.externalServiceCall != nil && !minimock.Equal(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall) {
				mmCreateKnowledgeBaseFile.t.Errorf("RepositoryIMock.CreateKnowledgeBaseFile got unexpected parameter externalServiceCall, want: %#v, got: %#v%s\n", *mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall, minimock.Diff(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateKnowledgeBaseFile.t.Errorf("RepositoryIMock.CreateKnowledgeBaseFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateKnowledgeBaseFile.t.Fatal("No results are set for the RepositoryIMock.CreateKnowledgeBaseFile")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmCreateKnowledgeBaseFile.funcCreateKnowledgeBaseFile != nil {
		return mmCreateKnowledgeBaseFile.funcCreateKnowledgeBaseFile(ctx, kb, externalServiceCall)
	}
	mmCreateKnowledgeBaseFile.t.Fatalf("Unexpected call to RepositoryIMock.CreateKnowledgeBaseFile. %v %v %v", ctx, kb, externalServiceCall)
	return
}

// CreateKnowledgeBaseFileAfterCounter returns a count of finished RepositoryIMock.CreateKnowledgeBaseFile invocations
func (mmCreateKnowledgeBaseFile *RepositoryIMock) CreateKnowledgeBaseFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateKnowledgeBaseFile.afterCreateKnowledgeBaseFileCounter)
}

// CreateKnowledgeBaseFileBeforeCounter returns a count of RepositoryIMock.CreateKnowledgeBaseFile invocations
func (mmCreateKnowledgeBaseFile *RepositoryIMock) CreateKnowledgeBaseFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateKnowledgeBaseFile.beforeCreateKnowledgeBaseFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.CreateKnowledgeBaseFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateKnowledgeBaseFile *mRepositoryIMockCreateKnowledgeBaseFile) Calls() []*RepositoryIMockCreateKnowledgeBaseFileParams {
	mmCreateKnowledgeBaseFile.mutex.RLock()

	argCopy := make([]*RepositoryIMockCreateKnowledgeBaseFileParams, len(mmCreateKnowledgeBaseFile.callArgs))
	copy(argCopy, mmCreateKnowledgeBaseFile.callArgs)

	mmCreateKnowledgeBaseFile.mutex.RUnlock()

	return argCopy
}

// MinimockCreateKnowledgeBaseFileDone returns true if the count of the CreateKnowledgeBaseFile invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockCreateKnowledgeBaseFileDone() bool {
	for _, e := range m.CreateKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateKnowledgeBaseFileMock.invocationsDone()
}

// MinimockCreateKnowledgeBaseFileInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockCreateKnowledgeBaseFileInspect() {
	for _, e := range m.CreateKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.CreateKnowledgeBaseFile with params: %#v", *e.params)
		}
	}

	afterCreateKnowledgeBaseFileCounter := mm_atomic.LoadUint64(&m.afterCreateKnowledgeBaseFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateKnowledgeBaseFileMock.defaultExpectation != nil && afterCreateKnowledgeBaseFileCounter < 1 {
		if m.CreateKnowledgeBaseFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.CreateKnowledgeBaseFile")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.CreateKnowledgeBaseFile with params: %#v", *m.CreateKnowledgeBaseFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateKnowledgeBaseFile != nil && afterCreateKnowledgeBaseFileCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.CreateKnowledgeBaseFile")
	}

	if !m.CreateKnowledgeBaseFileMock.invocationsDone() && afterCreateKnowledgeBaseFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.CreateKnowledgeBaseFile but found %d calls",
			mm_atomic.LoadUint64(&m.CreateKnowledgeBaseFileMock.expectedInvocations), afterCreateKnowledgeBaseFileCounter)
	}
}

type mRepositoryIMockDeleteAndCreateChunks struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteAndCreateChunksExpectation
	expectations       []*RepositoryIMockDeleteAndCreateChunksExpectation

	callArgs []*RepositoryIMockDeleteAndCreateChunksParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteAndCreateChunksExpectation specifies expectation struct of the RepositoryI.DeleteAndCreateChunks
type RepositoryIMockDeleteAndCreateChunksExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteAndCreateChunksParams
	paramPtrs *RepositoryIMockDeleteAndCreateChunksParamPtrs
	results   *RepositoryIMockDeleteAndCreateChunksResults
	Counter   uint64
}

// RepositoryIMockDeleteAndCreateChunksParams contains parameters of the RepositoryI.DeleteAndCreateChunks
type RepositoryIMockDeleteAndCreateChunksParams struct {
	ctx                 context.Context
	sourceTable         string
	sourceUID           uuid.UUID
	chunks              []*mm_repository.TextChunk
	externalServiceCall func(chunkUIDs []string) (map[string]any, error)
}

// RepositoryIMockDeleteAndCreateChunksParamPtrs contains pointers to parameters of the RepositoryI.DeleteAndCreateChunks
type RepositoryIMockDeleteAndCreateChunksParamPtrs struct {
	ctx                 *context.Context
	sourceTable         *string
	sourceUID           *uuid.UUID
	chunks              *[]*mm_repository.TextChunk
	externalServiceCall *func(chunkUIDs []string) (map[string]any, error)
}

// RepositoryIMockDeleteAndCreateChunksResults contains results of the RepositoryI.DeleteAndCreateChunks
type RepositoryIMockDeleteAndCreateChunksResults struct {
	tpa1 []*mm_repository.TextChunk
	err  error
}

// Expect sets up expected params for RepositoryI.DeleteAndCreateChunks
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) Expect(ctx context.Context, sourceTable string, sourceUID uuid.UUID, chunks []*mm_repository.TextChunk, externalServiceCall func(chunkUIDs []string) (map[string]any, error)) *mRepositoryIMockDeleteAndCreateChunks {
	if mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Set")
	}

	if mmDeleteAndCreateChunks.defaultExpectation == nil {
		mmDeleteAndCreateChunks.defaultExpectation = &RepositoryIMockDeleteAndCreateChunksExpectation{}
	}

	if mmDeleteAndCreateChunks.defaultExpectation.paramPtrs != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by ExpectParams functions")
	}

	mmDeleteAndCreateChunks.defaultExpectation.params = &RepositoryIMockDeleteAndCreateChunksParams{ctx, sourceTable, sourceUID, chunks, externalServiceCall}
	for _, e := range mmDeleteAndCreateChunks.expectations {
		if minimock.Equal(e.params, mmDeleteAndCreateChunks.defaultExpectation.params) {
			mmDeleteAndCreateChunks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteAndCreateChunks.defaultExpectation.params)
		}
	}

	return mmDeleteAndCreateChunks
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteAndCreateChunks
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteAndCreateChunks {
	if mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Set")
	}

	if mmDeleteAndCreateChunks.defaultExpectation == nil {
		mmDeleteAndCreateChunks.defaultExpectation = &RepositoryIMockDeleteAndCreateChunksExpectation{}
	}

	if mmDeleteAndCreateChunks.defaultExpectation.params != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Expect")
	}

	if mmDeleteAndCreateChunks.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateChunks.defaultExpectation.paramPtrs = &RepositoryIMockDeleteAndCreateChunksParamPtrs{}
	}
	mmDeleteAndCreateChunks.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteAndCreateChunks
}

// ExpectSourceTableParam2 sets up expected param sourceTable for RepositoryI.DeleteAndCreateChunks
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) ExpectSourceTableParam2(sourceTable string) *mRepositoryIMockDeleteAndCreateChunks {
	if mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Set")
	}

	if mmDeleteAndCreateChunks.defaultExpectation == nil {
		mmDeleteAndCreateChunks.defaultExpectation = &RepositoryIMockDeleteAndCreateChunksExpectation{}
	}

	if mmDeleteAndCreateChunks.defaultExpectation.params != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Expect")
	}

	if mmDeleteAndCreateChunks.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateChunks.defaultExpectation.paramPtrs = &RepositoryIMockDeleteAndCreateChunksParamPtrs{}
	}
	mmDeleteAndCreateChunks.defaultExpectation.paramPtrs.sourceTable = &sourceTable

	return mmDeleteAndCreateChunks
}

// ExpectSourceUIDParam3 sets up expected param sourceUID for RepositoryI.DeleteAndCreateChunks
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) ExpectSourceUIDParam3(sourceUID uuid.UUID) *mRepositoryIMockDeleteAndCreateChunks {
	if mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Set")
	}

	if mmDeleteAndCreateChunks.defaultExpectation == nil {
		mmDeleteAndCreateChunks.defaultExpectation = &RepositoryIMockDeleteAndCreateChunksExpectation{}
	}

	if mmDeleteAndCreateChunks.defaultExpectation.params != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Expect")
	}

	if mmDeleteAndCreateChunks.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateChunks.defaultExpectation.paramPtrs = &RepositoryIMockDeleteAndCreateChunksParamPtrs{}
	}
	mmDeleteAndCreateChunks.defaultExpectation.paramPtrs.sourceUID = &sourceUID

	return mmDeleteAndCreateChunks
}

// ExpectChunksParam4 sets up expected param chunks for RepositoryI.DeleteAndCreateChunks
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) ExpectChunksParam4(chunks []*mm_repository.TextChunk) *mRepositoryIMockDeleteAndCreateChunks {
	if mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Set")
	}

	if mmDeleteAndCreateChunks.defaultExpectation == nil {
		mmDeleteAndCreateChunks.defaultExpectation = &RepositoryIMockDeleteAndCreateChunksExpectation{}
	}

	if mmDeleteAndCreateChunks.defaultExpectation.params != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Expect")
	}

	if mmDeleteAndCreateChunks.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateChunks.defaultExpectation.paramPtrs = &RepositoryIMockDeleteAndCreateChunksParamPtrs{}
	}
	mmDeleteAndCreateChunks.defaultExpectation.paramPtrs.chunks = &chunks

	return mmDeleteAndCreateChunks
}

// ExpectExternalServiceCallParam5 sets up expected param externalServiceCall for RepositoryI.DeleteAndCreateChunks
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) ExpectExternalServiceCallParam5(externalServiceCall func(chunkUIDs []string) (map[string]any, error)) *mRepositoryIMockDeleteAndCreateChunks {
	if mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Set")
	}

	if mmDeleteAndCreateChunks.defaultExpectation == nil {
		mmDeleteAndCreateChunks.defaultExpectation = &RepositoryIMockDeleteAndCreateChunksExpectation{}
	}

	if mmDeleteAndCreateChunks.defaultExpectation.params != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Expect")
	}

	if mmDeleteAndCreateChunks.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateChunks.defaultExpectation.paramPtrs = &RepositoryIMockDeleteAndCreateChunksParamPtrs{}
	}
	mmDeleteAndCreateChunks.defaultExpectation.paramPtrs.externalServiceCall = &externalServiceCall

	return mmDeleteAndCreateChunks
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteAndCreateChunks
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) Inspect(f func(ctx context.Context, sourceTable string, sourceUID uuid.UUID, chunks []*mm_repository.TextChunk, externalServiceCall func(chunkUIDs []string) (map[string]any, error))) *mRepositoryIMockDeleteAndCreateChunks {
	if mmDeleteAndCreateChunks.mock.inspectFuncDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteAndCreateChunks")
	}

	mmDeleteAndCreateChunks.mock.inspectFuncDeleteAndCreateChunks = f

	return mmDeleteAndCreateChunks
}

// Return sets up results that will be returned by RepositoryI.DeleteAndCreateChunks
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) Return(tpa1 []*mm_repository.TextChunk, err error) *RepositoryIMock {
	if mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Set")
	}

	if mmDeleteAndCreateChunks.defaultExpectation == nil {
		mmDeleteAndCreateChunks.defaultExpectation = &RepositoryIMockDeleteAndCreateChunksExpectation{mock: mmDeleteAndCreateChunks.mock}
	}
	mmDeleteAndCreateChunks.defaultExpectation.results = &RepositoryIMockDeleteAndCreateChunksResults{tpa1, err}
	return mmDeleteAndCreateChunks.mock
}

// Set uses given function f to mock the RepositoryI.DeleteAndCreateChunks method
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) Set(f func(ctx context.Context, sourceTable string, sourceUID uuid.UUID, chunks []*mm_repository.TextChunk, externalServiceCall func(chunkUIDs []string) (map[string]any, error)) (tpa1 []*mm_repository.TextChunk, err error)) *RepositoryIMock {
	if mmDeleteAndCreateChunks.defaultExpectation != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteAndCreateChunks method")
	}

	if len(mmDeleteAndCreateChunks.expectations) > 0 {
		mmDeleteAndCreateChunks.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteAndCreateChunks method")
	}

	mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks = f
	return mmDeleteAndCreateChunks.mock
}

// When sets expectation for the RepositoryI.DeleteAndCreateChunks which will trigger the result defined by the following
// Then helper
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) When(ctx context.Context, sourceTable string, sourceUID uuid.UUID, chunks []*mm_repository.TextChunk, externalServiceCall func(chunkUIDs []string) (map[string]any, error)) *RepositoryIMockDeleteAndCreateChunksExpectation {
	if mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.mock.t.Fatalf("RepositoryIMock.DeleteAndCreateChunks mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteAndCreateChunksExpectation{
		mock:   mmDeleteAndCreateChunks.mock,
		params: &RepositoryIMockDeleteAndCreateChunksParams{ctx, sourceTable, sourceUID, chunks, externalServiceCall},
	}
	mmDeleteAndCreateChunks.expectations = append(mmDeleteAndCreateChunks.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteAndCreateChunks return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteAndCreateChunksExpectation) Then(tpa1 []*mm_repository.TextChunk, err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteAndCreateChunksResults{tpa1, err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteAndCreateChunks should be invoked
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) Times(n uint64) *mRepositoryIMockDeleteAndCreateChunks {
	if n == 0 {
		mmDeleteAndCreateChunks.mock.t.Fatalf("Times of RepositoryIMock.DeleteAndCreateChunks mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteAndCreateChunks.expectedInvocations, n)
	return mmDeleteAndCreateChunks
}

func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) invocationsDone() bool {
	if len(mmDeleteAndCreateChunks.expectations) == 0 && mmDeleteAndCreateChunks.defaultExpectation == nil && mmDeleteAndCreateChunks.mock.funcDeleteAndCreateChunks == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteAndCreateChunks.mock.afterDeleteAndCreateChunksCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteAndCreateChunks.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteAndCreateChunks implements repository.RepositoryI
func (mmDeleteAndCreateChunks *RepositoryIMock) DeleteAndCreateChunks(ctx context.Context, sourceTable string, sourceUID uuid.UUID, chunks []*mm_repository.TextChunk, externalServiceCall func(chunkUIDs []string) (map[string]any, error)) (tpa1 []*mm_repository.TextChunk, err error) {
	mm_atomic.AddUint64(&mmDeleteAndCreateChunks.beforeDeleteAndCreateChunksCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteAndCreateChunks.afterDeleteAndCreateChunksCounter, 1)

	if mmDeleteAndCreateChunks.inspectFuncDeleteAndCreateChunks != nil {
		mmDeleteAndCreateChunks.inspectFuncDeleteAndCreateChunks(ctx, sourceTable, sourceUID, chunks, externalServiceCall)
	}

	mm_params := RepositoryIMockDeleteAndCreateChunksParams{ctx, sourceTable, sourceUID, chunks, externalServiceCall}

	// Record call args
	mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.mutex.Lock()
	mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.callArgs = append(mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.callArgs, &mm_params)
	mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.mutex.Unlock()

	for _, e := range mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tpa1, e.results.err
		}
	}

	if mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteAndCreateChunksParams{ctx, sourceTable, sourceUID, chunks, externalServiceCall}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteAndCreateChunks.t.Errorf("RepositoryIMock.DeleteAndCreateChunks got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sourceTable != nil && !minimock.Equal(*mm_want_ptrs.sourceTable, mm_got.sourceTable) {
				mmDeleteAndCreateChunks.t.Errorf("RepositoryIMock.DeleteAndCreateChunks got unexpected parameter sourceTable, want: %#v, got: %#v%s\n", *mm_want_ptrs.sourceTable, mm_got.sourceTable, minimock.Diff(*mm_want_ptrs.sourceTable, mm_got.sourceTable))
			}

			if mm_want_ptrs.sourceUID != nil && !minimock.Equal(*mm_want_ptrs.sourceUID, mm_got.sourceUID) {
				mmDeleteAndCreateChunks.t.Errorf("RepositoryIMock.DeleteAndCreateChunks got unexpected parameter sourceUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.sourceUID, mm_got.sourceUID, minimock.Diff(*mm_want_ptrs.sourceUID, mm_got.sourceUID))
			}

			if mm_want_ptrs.chunks != nil && !minimock.Equal(*mm_want_ptrs.chunks, mm_got.chunks) {
				mmDeleteAndCreateChunks.t.Errorf("RepositoryIMock.DeleteAndCreateChunks got unexpected parameter chunks, want: %#v, got: %#v%s\n", *mm_want_ptrs.chunks, mm_got.chunks, minimock.Diff(*mm_want_ptrs.chunks, mm_got.chunks))
			}

			if mm_want_ptrs.externalServiceCall != nil && !minimock.Equal(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall) {
				mmDeleteAndCreateChunks.t.Errorf("RepositoryIMock.DeleteAndCreateChunks got unexpected parameter externalServiceCall, want: %#v, got: %#v%s\n", *mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall, minimock.Diff(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteAndCreateChunks.t.Errorf("RepositoryIMock.DeleteAndCreateChunks got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteAndCreateChunks.DeleteAndCreateChunksMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteAndCreateChunks.t.Fatal("No results are set for the RepositoryIMock.DeleteAndCreateChunks")
		}
		return (*mm_results).tpa1, (*mm_results).err
	}
	if mmDeleteAndCreateChunks.funcDeleteAndCreateChunks != nil {
		return mmDeleteAndCreateChunks.funcDeleteAndCreateChunks(ctx, sourceTable, sourceUID, chunks, externalServiceCall)
	}
	mmDeleteAndCreateChunks.t.Fatalf("Unexpected call to RepositoryIMock.DeleteAndCreateChunks. %v %v %v %v %v", ctx, sourceTable, sourceUID, chunks, externalServiceCall)
	return
}

// DeleteAndCreateChunksAfterCounter returns a count of finished RepositoryIMock.DeleteAndCreateChunks invocations
func (mmDeleteAndCreateChunks *RepositoryIMock) DeleteAndCreateChunksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAndCreateChunks.afterDeleteAndCreateChunksCounter)
}

// DeleteAndCreateChunksBeforeCounter returns a count of RepositoryIMock.DeleteAndCreateChunks invocations
func (mmDeleteAndCreateChunks *RepositoryIMock) DeleteAndCreateChunksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAndCreateChunks.beforeDeleteAndCreateChunksCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteAndCreateChunks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteAndCreateChunks *mRepositoryIMockDeleteAndCreateChunks) Calls() []*RepositoryIMockDeleteAndCreateChunksParams {
	mmDeleteAndCreateChunks.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteAndCreateChunksParams, len(mmDeleteAndCreateChunks.callArgs))
	copy(argCopy, mmDeleteAndCreateChunks.callArgs)

	mmDeleteAndCreateChunks.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteAndCreateChunksDone returns true if the count of the DeleteAndCreateChunks invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteAndCreateChunksDone() bool {
	for _, e := range m.DeleteAndCreateChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteAndCreateChunksMock.invocationsDone()
}

// MinimockDeleteAndCreateChunksInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteAndCreateChunksInspect() {
	for _, e := range m.DeleteAndCreateChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteAndCreateChunks with params: %#v", *e.params)
		}
	}

	afterDeleteAndCreateChunksCounter := mm_atomic.LoadUint64(&m.afterDeleteAndCreateChunksCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteAndCreateChunksMock.defaultExpectation != nil && afterDeleteAndCreateChunksCounter < 1 {
		if m.DeleteAndCreateChunksMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteAndCreateChunks")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteAndCreateChunks with params: %#v", *m.DeleteAndCreateChunksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteAndCreateChunks != nil && afterDeleteAndCreateChunksCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteAndCreateChunks")
	}

	if !m.DeleteAndCreateChunksMock.invocationsDone() && afterDeleteAndCreateChunksCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteAndCreateChunks but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteAndCreateChunksMock.expectedInvocations), afterDeleteAndCreateChunksCounter)
	}
}

type mRepositoryIMockDeleteChunksBySource struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteChunksBySourceExpectation
	expectations       []*RepositoryIMockDeleteChunksBySourceExpectation

	callArgs []*RepositoryIMockDeleteChunksBySourceParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteChunksBySourceExpectation specifies expectation struct of the RepositoryI.DeleteChunksBySource
type RepositoryIMockDeleteChunksBySourceExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteChunksBySourceParams
	paramPtrs *RepositoryIMockDeleteChunksBySourceParamPtrs
	results   *RepositoryIMockDeleteChunksBySourceResults
	Counter   uint64
}

// RepositoryIMockDeleteChunksBySourceParams contains parameters of the RepositoryI.DeleteChunksBySource
type RepositoryIMockDeleteChunksBySourceParams struct {
	ctx         context.Context
	sourceTable string
	sourceUID   uuid.UUID
}

// RepositoryIMockDeleteChunksBySourceParamPtrs contains pointers to parameters of the RepositoryI.DeleteChunksBySource
type RepositoryIMockDeleteChunksBySourceParamPtrs struct {
	ctx         *context.Context
	sourceTable *string
	sourceUID   *uuid.UUID
}

// RepositoryIMockDeleteChunksBySourceResults contains results of the RepositoryI.DeleteChunksBySource
type RepositoryIMockDeleteChunksBySourceResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteChunksBySource
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) Expect(ctx context.Context, sourceTable string, sourceUID uuid.UUID) *mRepositoryIMockDeleteChunksBySource {
	if mmDeleteChunksBySource.mock.funcDeleteChunksBySource != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by Set")
	}

	if mmDeleteChunksBySource.defaultExpectation == nil {
		mmDeleteChunksBySource.defaultExpectation = &RepositoryIMockDeleteChunksBySourceExpectation{}
	}

	if mmDeleteChunksBySource.defaultExpectation.paramPtrs != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by ExpectParams functions")
	}

	mmDeleteChunksBySource.defaultExpectation.params = &RepositoryIMockDeleteChunksBySourceParams{ctx, sourceTable, sourceUID}
	for _, e := range mmDeleteChunksBySource.expectations {
		if minimock.Equal(e.params, mmDeleteChunksBySource.defaultExpectation.params) {
			mmDeleteChunksBySource.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChunksBySource.defaultExpectation.params)
		}
	}

	return mmDeleteChunksBySource
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteChunksBySource
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteChunksBySource {
	if mmDeleteChunksBySource.mock.funcDeleteChunksBySource != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by Set")
	}

	if mmDeleteChunksBySource.defaultExpectation == nil {
		mmDeleteChunksBySource.defaultExpectation = &RepositoryIMockDeleteChunksBySourceExpectation{}
	}

	if mmDeleteChunksBySource.defaultExpectation.params != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by Expect")
	}

	if mmDeleteChunksBySource.defaultExpectation.paramPtrs == nil {
		mmDeleteChunksBySource.defaultExpectation.paramPtrs = &RepositoryIMockDeleteChunksBySourceParamPtrs{}
	}
	mmDeleteChunksBySource.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteChunksBySource
}

// ExpectSourceTableParam2 sets up expected param sourceTable for RepositoryI.DeleteChunksBySource
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) ExpectSourceTableParam2(sourceTable string) *mRepositoryIMockDeleteChunksBySource {
	if mmDeleteChunksBySource.mock.funcDeleteChunksBySource != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by Set")
	}

	if mmDeleteChunksBySource.defaultExpectation == nil {
		mmDeleteChunksBySource.defaultExpectation = &RepositoryIMockDeleteChunksBySourceExpectation{}
	}

	if mmDeleteChunksBySource.defaultExpectation.params != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by Expect")
	}

	if mmDeleteChunksBySource.defaultExpectation.paramPtrs == nil {
		mmDeleteChunksBySource.defaultExpectation.paramPtrs = &RepositoryIMockDeleteChunksBySourceParamPtrs{}
	}
	mmDeleteChunksBySource.defaultExpectation.paramPtrs.sourceTable = &sourceTable

	return mmDeleteChunksBySource
}

// ExpectSourceUIDParam3 sets up expected param sourceUID for RepositoryI.DeleteChunksBySource
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) ExpectSourceUIDParam3(sourceUID uuid.UUID) *mRepositoryIMockDeleteChunksBySource {
	if mmDeleteChunksBySource.mock.funcDeleteChunksBySource != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by Set")
	}

	if mmDeleteChunksBySource.defaultExpectation == nil {
		mmDeleteChunksBySource.defaultExpectation = &RepositoryIMockDeleteChunksBySourceExpectation{}
	}

	if mmDeleteChunksBySource.defaultExpectation.params != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by Expect")
	}

	if mmDeleteChunksBySource.defaultExpectation.paramPtrs == nil {
		mmDeleteChunksBySource.defaultExpectation.paramPtrs = &RepositoryIMockDeleteChunksBySourceParamPtrs{}
	}
	mmDeleteChunksBySource.defaultExpectation.paramPtrs.sourceUID = &sourceUID

	return mmDeleteChunksBySource
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteChunksBySource
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) Inspect(f func(ctx context.Context, sourceTable string, sourceUID uuid.UUID)) *mRepositoryIMockDeleteChunksBySource {
	if mmDeleteChunksBySource.mock.inspectFuncDeleteChunksBySource != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteChunksBySource")
	}

	mmDeleteChunksBySource.mock.inspectFuncDeleteChunksBySource = f

	return mmDeleteChunksBySource
}

// Return sets up results that will be returned by RepositoryI.DeleteChunksBySource
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) Return(err error) *RepositoryIMock {
	if mmDeleteChunksBySource.mock.funcDeleteChunksBySource != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by Set")
	}

	if mmDeleteChunksBySource.defaultExpectation == nil {
		mmDeleteChunksBySource.defaultExpectation = &RepositoryIMockDeleteChunksBySourceExpectation{mock: mmDeleteChunksBySource.mock}
	}
	mmDeleteChunksBySource.defaultExpectation.results = &RepositoryIMockDeleteChunksBySourceResults{err}
	return mmDeleteChunksBySource.mock
}

// Set uses given function f to mock the RepositoryI.DeleteChunksBySource method
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) Set(f func(ctx context.Context, sourceTable string, sourceUID uuid.UUID) (err error)) *RepositoryIMock {
	if mmDeleteChunksBySource.defaultExpectation != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteChunksBySource method")
	}

	if len(mmDeleteChunksBySource.expectations) > 0 {
		mmDeleteChunksBySource.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteChunksBySource method")
	}

	mmDeleteChunksBySource.mock.funcDeleteChunksBySource = f
	return mmDeleteChunksBySource.mock
}

// When sets expectation for the RepositoryI.DeleteChunksBySource which will trigger the result defined by the following
// Then helper
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) When(ctx context.Context, sourceTable string, sourceUID uuid.UUID) *RepositoryIMockDeleteChunksBySourceExpectation {
	if mmDeleteChunksBySource.mock.funcDeleteChunksBySource != nil {
		mmDeleteChunksBySource.mock.t.Fatalf("RepositoryIMock.DeleteChunksBySource mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteChunksBySourceExpectation{
		mock:   mmDeleteChunksBySource.mock,
		params: &RepositoryIMockDeleteChunksBySourceParams{ctx, sourceTable, sourceUID},
	}
	mmDeleteChunksBySource.expectations = append(mmDeleteChunksBySource.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteChunksBySource return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteChunksBySourceExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteChunksBySourceResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteChunksBySource should be invoked
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) Times(n uint64) *mRepositoryIMockDeleteChunksBySource {
	if n == 0 {
		mmDeleteChunksBySource.mock.t.Fatalf("Times of RepositoryIMock.DeleteChunksBySource mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteChunksBySource.expectedInvocations, n)
	return mmDeleteChunksBySource
}

func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) invocationsDone() bool {
	if len(mmDeleteChunksBySource.expectations) == 0 && mmDeleteChunksBySource.defaultExpectation == nil && mmDeleteChunksBySource.mock.funcDeleteChunksBySource == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteChunksBySource.mock.afterDeleteChunksBySourceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteChunksBySource.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteChunksBySource implements repository.RepositoryI
func (mmDeleteChunksBySource *RepositoryIMock) DeleteChunksBySource(ctx context.Context, sourceTable string, sourceUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteChunksBySource.beforeDeleteChunksBySourceCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChunksBySource.afterDeleteChunksBySourceCounter, 1)

	if mmDeleteChunksBySource.inspectFuncDeleteChunksBySource != nil {
		mmDeleteChunksBySource.inspectFuncDeleteChunksBySource(ctx, sourceTable, sourceUID)
	}

	mm_params := RepositoryIMockDeleteChunksBySourceParams{ctx, sourceTable, sourceUID}

	// Record call args
	mmDeleteChunksBySource.DeleteChunksBySourceMock.mutex.Lock()
	mmDeleteChunksBySource.DeleteChunksBySourceMock.callArgs = append(mmDeleteChunksBySource.DeleteChunksBySourceMock.callArgs, &mm_params)
	mmDeleteChunksBySource.DeleteChunksBySourceMock.mutex.Unlock()

	for _, e := range mmDeleteChunksBySource.DeleteChunksBySourceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChunksBySource.DeleteChunksBySourceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChunksBySource.DeleteChunksBySourceMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChunksBySource.DeleteChunksBySourceMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteChunksBySource.DeleteChunksBySourceMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteChunksBySourceParams{ctx, sourceTable, sourceUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteChunksBySource.t.Errorf("RepositoryIMock.DeleteChunksBySource got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sourceTable != nil && !minimock.Equal(*mm_want_ptrs.sourceTable, mm_got.sourceTable) {
				mmDeleteChunksBySource.t.Errorf("RepositoryIMock.DeleteChunksBySource got unexpected parameter sourceTable, want: %#v, got: %#v%s\n", *mm_want_ptrs.sourceTable, mm_got.sourceTable, minimock.Diff(*mm_want_ptrs.sourceTable, mm_got.sourceTable))
			}

			if mm_want_ptrs.sourceUID != nil && !minimock.Equal(*mm_want_ptrs.sourceUID, mm_got.sourceUID) {
				mmDeleteChunksBySource.t.Errorf("RepositoryIMock.DeleteChunksBySource got unexpected parameter sourceUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.sourceUID, mm_got.sourceUID, minimock.Diff(*mm_want_ptrs.sourceUID, mm_got.sourceUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChunksBySource.t.Errorf("RepositoryIMock.DeleteChunksBySource got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChunksBySource.DeleteChunksBySourceMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChunksBySource.t.Fatal("No results are set for the RepositoryIMock.DeleteChunksBySource")
		}
		return (*mm_results).err
	}
	if mmDeleteChunksBySource.funcDeleteChunksBySource != nil {
		return mmDeleteChunksBySource.funcDeleteChunksBySource(ctx, sourceTable, sourceUID)
	}
	mmDeleteChunksBySource.t.Fatalf("Unexpected call to RepositoryIMock.DeleteChunksBySource. %v %v %v", ctx, sourceTable, sourceUID)
	return
}

// DeleteChunksBySourceAfterCounter returns a count of finished RepositoryIMock.DeleteChunksBySource invocations
func (mmDeleteChunksBySource *RepositoryIMock) DeleteChunksBySourceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChunksBySource.afterDeleteChunksBySourceCounter)
}

// DeleteChunksBySourceBeforeCounter returns a count of RepositoryIMock.DeleteChunksBySource invocations
func (mmDeleteChunksBySource *RepositoryIMock) DeleteChunksBySourceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChunksBySource.beforeDeleteChunksBySourceCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteChunksBySource.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChunksBySource *mRepositoryIMockDeleteChunksBySource) Calls() []*RepositoryIMockDeleteChunksBySourceParams {
	mmDeleteChunksBySource.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteChunksBySourceParams, len(mmDeleteChunksBySource.callArgs))
	copy(argCopy, mmDeleteChunksBySource.callArgs)

	mmDeleteChunksBySource.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChunksBySourceDone returns true if the count of the DeleteChunksBySource invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteChunksBySourceDone() bool {
	for _, e := range m.DeleteChunksBySourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteChunksBySourceMock.invocationsDone()
}

// MinimockDeleteChunksBySourceInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteChunksBySourceInspect() {
	for _, e := range m.DeleteChunksBySourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteChunksBySource with params: %#v", *e.params)
		}
	}

	afterDeleteChunksBySourceCounter := mm_atomic.LoadUint64(&m.afterDeleteChunksBySourceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChunksBySourceMock.defaultExpectation != nil && afterDeleteChunksBySourceCounter < 1 {
		if m.DeleteChunksBySourceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteChunksBySource")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteChunksBySource with params: %#v", *m.DeleteChunksBySourceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChunksBySource != nil && afterDeleteChunksBySourceCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteChunksBySource")
	}

	if !m.DeleteChunksBySourceMock.invocationsDone() && afterDeleteChunksBySourceCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteChunksBySource but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteChunksBySourceMock.expectedInvocations), afterDeleteChunksBySourceCounter)
	}
}

type mRepositoryIMockDeleteChunksByUIDs struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteChunksByUIDsExpectation
	expectations       []*RepositoryIMockDeleteChunksByUIDsExpectation

	callArgs []*RepositoryIMockDeleteChunksByUIDsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteChunksByUIDsExpectation specifies expectation struct of the RepositoryI.DeleteChunksByUIDs
type RepositoryIMockDeleteChunksByUIDsExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteChunksByUIDsParams
	paramPtrs *RepositoryIMockDeleteChunksByUIDsParamPtrs
	results   *RepositoryIMockDeleteChunksByUIDsResults
	Counter   uint64
}

// RepositoryIMockDeleteChunksByUIDsParams contains parameters of the RepositoryI.DeleteChunksByUIDs
type RepositoryIMockDeleteChunksByUIDsParams struct {
	ctx       context.Context
	chunkUIDs []uuid.UUID
}

// RepositoryIMockDeleteChunksByUIDsParamPtrs contains pointers to parameters of the RepositoryI.DeleteChunksByUIDs
type RepositoryIMockDeleteChunksByUIDsParamPtrs struct {
	ctx       *context.Context
	chunkUIDs *[]uuid.UUID
}

// RepositoryIMockDeleteChunksByUIDsResults contains results of the RepositoryI.DeleteChunksByUIDs
type RepositoryIMockDeleteChunksByUIDsResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteChunksByUIDs
func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) Expect(ctx context.Context, chunkUIDs []uuid.UUID) *mRepositoryIMockDeleteChunksByUIDs {
	if mmDeleteChunksByUIDs.mock.funcDeleteChunksByUIDs != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteChunksByUIDs mock is already set by Set")
	}

	if mmDeleteChunksByUIDs.defaultExpectation == nil {
		mmDeleteChunksByUIDs.defaultExpectation = &RepositoryIMockDeleteChunksByUIDsExpectation{}
	}

	if mmDeleteChunksByUIDs.defaultExpectation.paramPtrs != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteChunksByUIDs mock is already set by ExpectParams functions")
	}

	mmDeleteChunksByUIDs.defaultExpectation.params = &RepositoryIMockDeleteChunksByUIDsParams{ctx, chunkUIDs}
	for _, e := range mmDeleteChunksByUIDs.expectations {
		if minimock.Equal(e.params, mmDeleteChunksByUIDs.defaultExpectation.params) {
			mmDeleteChunksByUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChunksByUIDs.defaultExpectation.params)
		}
	}

	return mmDeleteChunksByUIDs
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteChunksByUIDs
func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteChunksByUIDs {
	if mmDeleteChunksByUIDs.mock.funcDeleteChunksByUIDs != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteChunksByUIDs mock is already set by Set")
	}

	if mmDeleteChunksByUIDs.defaultExpectation == nil {
		mmDeleteChunksByUIDs.defaultExpectation = &RepositoryIMockDeleteChunksByUIDsExpectation{}
	}

	if mmDeleteChunksByUIDs.defaultExpectation.params != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteChunksByUIDs mock is already set by Expect")
	}

	if mmDeleteChunksByUIDs.defaultExpectation.paramPtrs == nil {
		mmDeleteChunksByUIDs.defaultExpectation.paramPtrs = &RepositoryIMockDeleteChunksByUIDsParamPtrs{}
	}
	mmDeleteChunksByUIDs.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteChunksByUIDs
}

// ExpectChunkUIDsParam2 sets up expected param chunkUIDs for RepositoryI.DeleteChunksByUIDs
func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) ExpectChunkUIDsParam2(chunkUIDs []uuid.UUID) *mRepositoryIMockDeleteChunksByUIDs {
	if mmDeleteChunksByUIDs.mock.funcDeleteChunksByUIDs != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteChunksByUIDs mock is already set by Set")
	}

	if mmDeleteChunksByUIDs.defaultExpectation == nil {
		mmDeleteChunksByUIDs.defaultExpectation = &RepositoryIMockDeleteChunksByUIDsExpectation{}
	}

	if mmDeleteChunksByUIDs.defaultExpectation.params != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteChunksByUIDs mock is already set by Expect")
	}

	if mmDeleteChunksByUIDs.defaultExpectation.paramPtrs == nil {
		mmDeleteChunksByUIDs.defaultExpectation.paramPtrs = &RepositoryIMockDeleteChunksByUIDsParamPtrs{}
	}
	mmDeleteChunksByUIDs.defaultExpectation.paramPtrs.chunkUIDs = &chunkUIDs

	return mmDeleteChunksByUIDs
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteChunksByUIDs
func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) Inspect(f func(ctx context.Context, chunkUIDs []uuid.UUID)) *mRepositoryIMockDeleteChunksByUIDs {
	if mmDeleteChunksByUIDs.mock.inspectFuncDeleteChunksByUIDs != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteChunksByUIDs")
	}

	mmDeleteChunksByUIDs.mock.inspectFuncDeleteChunksByUIDs = f

	return mmDeleteChunksByUIDs
}

// Return sets up results that will be returned by RepositoryI.DeleteChunksByUIDs
func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) Return(err error) *RepositoryIMock {
	if mmDeleteChunksByUIDs.mock.funcDeleteChunksByUIDs != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteChunksByUIDs mock is already set by Set")
	}

	if mmDeleteChunksByUIDs.defaultExpectation == nil {
		mmDeleteChunksByUIDs.defaultExpectation = &RepositoryIMockDeleteChunksByUIDsExpectation{mock: mmDeleteChunksByUIDs.mock}
	}
	mmDeleteChunksByUIDs.defaultExpectation.results = &RepositoryIMockDeleteChunksByUIDsResults{err}
	return mmDeleteChunksByUIDs.mock
}

// Set uses given function f to mock the RepositoryI.DeleteChunksByUIDs method
func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) Set(f func(ctx context.Context, chunkUIDs []uuid.UUID) (err error)) *RepositoryIMock {
	if mmDeleteChunksByUIDs.defaultExpectation != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteChunksByUIDs method")
	}

	if len(mmDeleteChunksByUIDs.expectations) > 0 {
		mmDeleteChunksByUIDs.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteChunksByUIDs method")
	}

	mmDeleteChunksByUIDs.mock.funcDeleteChunksByUIDs = f
	return mmDeleteChunksByUIDs.mock
}

// When sets expectation for the RepositoryI.DeleteChunksByUIDs which will trigger the result defined by the following
// Then helper
func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) When(ctx context.Context, chunkUIDs []uuid.UUID) *RepositoryIMockDeleteChunksByUIDsExpectation {
	if mmDeleteChunksByUIDs.mock.funcDeleteChunksByUIDs != nil {
		mmDeleteChunksByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteChunksByUIDs mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteChunksByUIDsExpectation{
		mock:   mmDeleteChunksByUIDs.mock,
		params: &RepositoryIMockDeleteChunksByUIDsParams{ctx, chunkUIDs},
	}
	mmDeleteChunksByUIDs.expectations = append(mmDeleteChunksByUIDs.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteChunksByUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteChunksByUIDsExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteChunksByUIDsResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteChunksByUIDs should be invoked
func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) Times(n uint64) *mRepositoryIMockDeleteChunksByUIDs {
	if n == 0 {
		mmDeleteChunksByUIDs.mock.t.Fatalf("Times of RepositoryIMock.DeleteChunksByUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteChunksByUIDs.expectedInvocations, n)
	return mmDeleteChunksByUIDs
}

func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) invocationsDone() bool {
	if len(mmDeleteChunksByUIDs.expectations) == 0 && mmDeleteChunksByUIDs.defaultExpectation == nil && mmDeleteChunksByUIDs.mock.funcDeleteChunksByUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteChunksByUIDs.mock.afterDeleteChunksByUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteChunksByUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteChunksByUIDs implements repository.RepositoryI
func (mmDeleteChunksByUIDs *RepositoryIMock) DeleteChunksByUIDs(ctx context.Context, chunkUIDs []uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteChunksByUIDs.beforeDeleteChunksByUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChunksByUIDs.afterDeleteChunksByUIDsCounter, 1)

	if mmDeleteChunksByUIDs.inspectFuncDeleteChunksByUIDs != nil {
		mmDeleteChunksByUIDs.inspectFuncDeleteChunksByUIDs(ctx, chunkUIDs)
	}

	mm_params := RepositoryIMockDeleteChunksByUIDsParams{ctx, chunkUIDs}

	// Record call args
	mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.mutex.Lock()
	mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.callArgs = append(mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.callArgs, &mm_params)
	mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.mutex.Unlock()

	for _, e := range mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteChunksByUIDsParams{ctx, chunkUIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteChunksByUIDs.t.Errorf("RepositoryIMock.DeleteChunksByUIDs got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chunkUIDs != nil && !minimock.Equal(*mm_want_ptrs.chunkUIDs, mm_got.chunkUIDs) {
				mmDeleteChunksByUIDs.t.Errorf("RepositoryIMock.DeleteChunksByUIDs got unexpected parameter chunkUIDs, want: %#v, got: %#v%s\n", *mm_want_ptrs.chunkUIDs, mm_got.chunkUIDs, minimock.Diff(*mm_want_ptrs.chunkUIDs, mm_got.chunkUIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChunksByUIDs.t.Errorf("RepositoryIMock.DeleteChunksByUIDs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChunksByUIDs.DeleteChunksByUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChunksByUIDs.t.Fatal("No results are set for the RepositoryIMock.DeleteChunksByUIDs")
		}
		return (*mm_results).err
	}
	if mmDeleteChunksByUIDs.funcDeleteChunksByUIDs != nil {
		return mmDeleteChunksByUIDs.funcDeleteChunksByUIDs(ctx, chunkUIDs)
	}
	mmDeleteChunksByUIDs.t.Fatalf("Unexpected call to RepositoryIMock.DeleteChunksByUIDs. %v %v", ctx, chunkUIDs)
	return
}

// DeleteChunksByUIDsAfterCounter returns a count of finished RepositoryIMock.DeleteChunksByUIDs invocations
func (mmDeleteChunksByUIDs *RepositoryIMock) DeleteChunksByUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChunksByUIDs.afterDeleteChunksByUIDsCounter)
}

// DeleteChunksByUIDsBeforeCounter returns a count of RepositoryIMock.DeleteChunksByUIDs invocations
func (mmDeleteChunksByUIDs *RepositoryIMock) DeleteChunksByUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChunksByUIDs.beforeDeleteChunksByUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteChunksByUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChunksByUIDs *mRepositoryIMockDeleteChunksByUIDs) Calls() []*RepositoryIMockDeleteChunksByUIDsParams {
	mmDeleteChunksByUIDs.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteChunksByUIDsParams, len(mmDeleteChunksByUIDs.callArgs))
	copy(argCopy, mmDeleteChunksByUIDs.callArgs)

	mmDeleteChunksByUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChunksByUIDsDone returns true if the count of the DeleteChunksByUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteChunksByUIDsDone() bool {
	for _, e := range m.DeleteChunksByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteChunksByUIDsMock.invocationsDone()
}

// MinimockDeleteChunksByUIDsInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteChunksByUIDsInspect() {
	for _, e := range m.DeleteChunksByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteChunksByUIDs with params: %#v", *e.params)
		}
	}

	afterDeleteChunksByUIDsCounter := mm_atomic.LoadUint64(&m.afterDeleteChunksByUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChunksByUIDsMock.defaultExpectation != nil && afterDeleteChunksByUIDsCounter < 1 {
		if m.DeleteChunksByUIDsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteChunksByUIDs")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteChunksByUIDs with params: %#v", *m.DeleteChunksByUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChunksByUIDs != nil && afterDeleteChunksByUIDsCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteChunksByUIDs")
	}

	if !m.DeleteChunksByUIDsMock.invocationsDone() && afterDeleteChunksByUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteChunksByUIDs but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteChunksByUIDsMock.expectedInvocations), afterDeleteChunksByUIDsCounter)
	}
}

type mRepositoryIMockDeleteConvertedFile struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteConvertedFileExpectation
	expectations       []*RepositoryIMockDeleteConvertedFileExpectation

	callArgs []*RepositoryIMockDeleteConvertedFileParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteConvertedFileExpectation specifies expectation struct of the RepositoryI.DeleteConvertedFile
type RepositoryIMockDeleteConvertedFileExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteConvertedFileParams
	paramPtrs *RepositoryIMockDeleteConvertedFileParamPtrs
	results   *RepositoryIMockDeleteConvertedFileResults
	Counter   uint64
}

// RepositoryIMockDeleteConvertedFileParams contains parameters of the RepositoryI.DeleteConvertedFile
type RepositoryIMockDeleteConvertedFileParams struct {
	ctx context.Context
	uid uuid.UUID
}

// RepositoryIMockDeleteConvertedFileParamPtrs contains pointers to parameters of the RepositoryI.DeleteConvertedFile
type RepositoryIMockDeleteConvertedFileParamPtrs struct {
	ctx *context.Context
	uid *uuid.UUID
}

// RepositoryIMockDeleteConvertedFileResults contains results of the RepositoryI.DeleteConvertedFile
type RepositoryIMockDeleteConvertedFileResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteConvertedFile
func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) Expect(ctx context.Context, uid uuid.UUID) *mRepositoryIMockDeleteConvertedFile {
	if mmDeleteConvertedFile.mock.funcDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryIMock.DeleteConvertedFile mock is already set by Set")
	}

	if mmDeleteConvertedFile.defaultExpectation == nil {
		mmDeleteConvertedFile.defaultExpectation = &RepositoryIMockDeleteConvertedFileExpectation{}
	}

	if mmDeleteConvertedFile.defaultExpectation.paramPtrs != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryIMock.DeleteConvertedFile mock is already set by ExpectParams functions")
	}

	mmDeleteConvertedFile.defaultExpectation.params = &RepositoryIMockDeleteConvertedFileParams{ctx, uid}
	for _, e := range mmDeleteConvertedFile.expectations {
		if minimock.Equal(e.params, mmDeleteConvertedFile.defaultExpectation.params) {
			mmDeleteConvertedFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteConvertedFile.defaultExpectation.params)
		}
	}

	return mmDeleteConvertedFile
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteConvertedFile
func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteConvertedFile {
	if mmDeleteConvertedFile.mock.funcDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryIMock.DeleteConvertedFile mock is already set by Set")
	}

	if mmDeleteConvertedFile.defaultExpectation == nil {
		mmDeleteConvertedFile.defaultExpectation = &RepositoryIMockDeleteConvertedFileExpectation{}
	}

	if mmDeleteConvertedFile.defaultExpectation.params != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryIMock.DeleteConvertedFile mock is already set by Expect")
	}

	if mmDeleteConvertedFile.defaultExpectation.paramPtrs == nil {
		mmDeleteConvertedFile.defaultExpectation.paramPtrs = &RepositoryIMockDeleteConvertedFileParamPtrs{}
	}
	mmDeleteConvertedFile.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteConvertedFile
}

// ExpectUidParam2 sets up expected param uid for RepositoryI.DeleteConvertedFile
func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) ExpectUidParam2(uid uuid.UUID) *mRepositoryIMockDeleteConvertedFile {
	if mmDeleteConvertedFile.mock.funcDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryIMock.DeleteConvertedFile mock is already set by Set")
	}

	if mmDeleteConvertedFile.defaultExpectation == nil {
		mmDeleteConvertedFile.defaultExpectation = &RepositoryIMockDeleteConvertedFileExpectation{}
	}

	if mmDeleteConvertedFile.defaultExpectation.params != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryIMock.DeleteConvertedFile mock is already set by Expect")
	}

	if mmDeleteConvertedFile.defaultExpectation.paramPtrs == nil {
		mmDeleteConvertedFile.defaultExpectation.paramPtrs = &RepositoryIMockDeleteConvertedFileParamPtrs{}
	}
	mmDeleteConvertedFile.defaultExpectation.paramPtrs.uid = &uid

	return mmDeleteConvertedFile
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteConvertedFile
func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) Inspect(f func(ctx context.Context, uid uuid.UUID)) *mRepositoryIMockDeleteConvertedFile {
	if mmDeleteConvertedFile.mock.inspectFuncDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteConvertedFile")
	}

	mmDeleteConvertedFile.mock.inspectFuncDeleteConvertedFile = f

	return mmDeleteConvertedFile
}

// Return sets up results that will be returned by RepositoryI.DeleteConvertedFile
func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) Return(err error) *RepositoryIMock {
	if mmDeleteConvertedFile.mock.funcDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryIMock.DeleteConvertedFile mock is already set by Set")
	}

	if mmDeleteConvertedFile.defaultExpectation == nil {
		mmDeleteConvertedFile.defaultExpectation = &RepositoryIMockDeleteConvertedFileExpectation{mock: mmDeleteConvertedFile.mock}
	}
	mmDeleteConvertedFile.defaultExpectation.results = &RepositoryIMockDeleteConvertedFileResults{err}
	return mmDeleteConvertedFile.mock
}

// Set uses given function f to mock the RepositoryI.DeleteConvertedFile method
func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) Set(f func(ctx context.Context, uid uuid.UUID) (err error)) *RepositoryIMock {
	if mmDeleteConvertedFile.defaultExpectation != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteConvertedFile method")
	}

	if len(mmDeleteConvertedFile.expectations) > 0 {
		mmDeleteConvertedFile.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteConvertedFile method")
	}

	mmDeleteConvertedFile.mock.funcDeleteConvertedFile = f
	return mmDeleteConvertedFile.mock
}

// When sets expectation for the RepositoryI.DeleteConvertedFile which will trigger the result defined by the following
// Then helper
func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) When(ctx context.Context, uid uuid.UUID) *RepositoryIMockDeleteConvertedFileExpectation {
	if mmDeleteConvertedFile.mock.funcDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryIMock.DeleteConvertedFile mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteConvertedFileExpectation{
		mock:   mmDeleteConvertedFile.mock,
		params: &RepositoryIMockDeleteConvertedFileParams{ctx, uid},
	}
	mmDeleteConvertedFile.expectations = append(mmDeleteConvertedFile.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteConvertedFile return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteConvertedFileExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteConvertedFileResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteConvertedFile should be invoked
func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) Times(n uint64) *mRepositoryIMockDeleteConvertedFile {
	if n == 0 {
		mmDeleteConvertedFile.mock.t.Fatalf("Times of RepositoryIMock.DeleteConvertedFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteConvertedFile.expectedInvocations, n)
	return mmDeleteConvertedFile
}

func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) invocationsDone() bool {
	if len(mmDeleteConvertedFile.expectations) == 0 && mmDeleteConvertedFile.defaultExpectation == nil && mmDeleteConvertedFile.mock.funcDeleteConvertedFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteConvertedFile.mock.afterDeleteConvertedFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteConvertedFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteConvertedFile implements repository.RepositoryI
func (mmDeleteConvertedFile *RepositoryIMock) DeleteConvertedFile(ctx context.Context, uid uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteConvertedFile.beforeDeleteConvertedFileCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteConvertedFile.afterDeleteConvertedFileCounter, 1)

	if mmDeleteConvertedFile.inspectFuncDeleteConvertedFile != nil {
		mmDeleteConvertedFile.inspectFuncDeleteConvertedFile(ctx, uid)
	}

	mm_params := RepositoryIMockDeleteConvertedFileParams{ctx, uid}

	// Record call args
	mmDeleteConvertedFile.DeleteConvertedFileMock.mutex.Lock()
	mmDeleteConvertedFile.DeleteConvertedFileMock.callArgs = append(mmDeleteConvertedFile.DeleteConvertedFileMock.callArgs, &mm_params)
	mmDeleteConvertedFile.DeleteConvertedFileMock.mutex.Unlock()

	for _, e := range mmDeleteConvertedFile.DeleteConvertedFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteConvertedFileParams{ctx, uid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteConvertedFile.t.Errorf("RepositoryIMock.DeleteConvertedFile got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmDeleteConvertedFile.t.Errorf("RepositoryIMock.DeleteConvertedFile got unexpected parameter uid, want: %#v, got: %#v%s\n", *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteConvertedFile.t.Errorf("RepositoryIMock.DeleteConvertedFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteConvertedFile.t.Fatal("No results are set for the RepositoryIMock.DeleteConvertedFile")
		}
		return (*mm_results).err
	}
	if mmDeleteConvertedFile.funcDeleteConvertedFile != nil {
		return mmDeleteConvertedFile.funcDeleteConvertedFile(ctx, uid)
	}
	mmDeleteConvertedFile.t.Fatalf("Unexpected call to RepositoryIMock.DeleteConvertedFile. %v %v", ctx, uid)
	return
}

// DeleteConvertedFileAfterCounter returns a count of finished RepositoryIMock.DeleteConvertedFile invocations
func (mmDeleteConvertedFile *RepositoryIMock) DeleteConvertedFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteConvertedFile.afterDeleteConvertedFileCounter)
}

// DeleteConvertedFileBeforeCounter returns a count of RepositoryIMock.DeleteConvertedFile invocations
func (mmDeleteConvertedFile *RepositoryIMock) DeleteConvertedFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteConvertedFile.beforeDeleteConvertedFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteConvertedFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteConvertedFile *mRepositoryIMockDeleteConvertedFile) Calls() []*RepositoryIMockDeleteConvertedFileParams {
	mmDeleteConvertedFile.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteConvertedFileParams, len(mmDeleteConvertedFile.callArgs))
	copy(argCopy, mmDeleteConvertedFile.callArgs)

	mmDeleteConvertedFile.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteConvertedFileDone returns true if the count of the DeleteConvertedFile invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteConvertedFileDone() bool {
	for _, e := range m.DeleteConvertedFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteConvertedFileMock.invocationsDone()
}

// MinimockDeleteConvertedFileInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteConvertedFileInspect() {
	for _, e := range m.DeleteConvertedFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteConvertedFile with params: %#v", *e.params)
		}
	}

	afterDeleteConvertedFileCounter := mm_atomic.LoadUint64(&m.afterDeleteConvertedFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteConvertedFileMock.defaultExpectation != nil && afterDeleteConvertedFileCounter < 1 {
		if m.DeleteConvertedFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteConvertedFile")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteConvertedFile with params: %#v", *m.DeleteConvertedFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteConvertedFile != nil && afterDeleteConvertedFileCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteConvertedFile")
	}

	if !m.DeleteConvertedFileMock.invocationsDone() && afterDeleteConvertedFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteConvertedFile but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteConvertedFileMock.expectedInvocations), afterDeleteConvertedFileCounter)
	}
}

type mRepositoryIMockDeleteEmbeddingsBySource struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteEmbeddingsBySourceExpectation
	expectations       []*RepositoryIMockDeleteEmbeddingsBySourceExpectation

	callArgs []*RepositoryIMockDeleteEmbeddingsBySourceParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteEmbeddingsBySourceExpectation specifies expectation struct of the RepositoryI.DeleteEmbeddingsBySource
type RepositoryIMockDeleteEmbeddingsBySourceExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteEmbeddingsBySourceParams
	paramPtrs *RepositoryIMockDeleteEmbeddingsBySourceParamPtrs
	results   *RepositoryIMockDeleteEmbeddingsBySourceResults
	Counter   uint64
}

// RepositoryIMockDeleteEmbeddingsBySourceParams contains parameters of the RepositoryI.DeleteEmbeddingsBySource
type RepositoryIMockDeleteEmbeddingsBySourceParams struct {
	ctx         context.Context
	sourceTable string
	sourceUID   uuid.UUID
}

// RepositoryIMockDeleteEmbeddingsBySourceParamPtrs contains pointers to parameters of the RepositoryI.DeleteEmbeddingsBySource
type RepositoryIMockDeleteEmbeddingsBySourceParamPtrs struct {
	ctx         *context.Context
	sourceTable *string
	sourceUID   *uuid.UUID
}

// RepositoryIMockDeleteEmbeddingsBySourceResults contains results of the RepositoryI.DeleteEmbeddingsBySource
type RepositoryIMockDeleteEmbeddingsBySourceResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteEmbeddingsBySource
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) Expect(ctx context.Context, sourceTable string, sourceUID uuid.UUID) *mRepositoryIMockDeleteEmbeddingsBySource {
	if mmDeleteEmbeddingsBySource.mock.funcDeleteEmbeddingsBySource != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by Set")
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation == nil {
		mmDeleteEmbeddingsBySource.defaultExpectation = &RepositoryIMockDeleteEmbeddingsBySourceExpectation{}
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by ExpectParams functions")
	}

	mmDeleteEmbeddingsBySource.defaultExpectation.params = &RepositoryIMockDeleteEmbeddingsBySourceParams{ctx, sourceTable, sourceUID}
	for _, e := range mmDeleteEmbeddingsBySource.expectations {
		if minimock.Equal(e.params, mmDeleteEmbeddingsBySource.defaultExpectation.params) {
			mmDeleteEmbeddingsBySource.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteEmbeddingsBySource.defaultExpectation.params)
		}
	}

	return mmDeleteEmbeddingsBySource
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteEmbeddingsBySource
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteEmbeddingsBySource {
	if mmDeleteEmbeddingsBySource.mock.funcDeleteEmbeddingsBySource != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by Set")
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation == nil {
		mmDeleteEmbeddingsBySource.defaultExpectation = &RepositoryIMockDeleteEmbeddingsBySourceExpectation{}
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation.params != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by Expect")
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs == nil {
		mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs = &RepositoryIMockDeleteEmbeddingsBySourceParamPtrs{}
	}
	mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteEmbeddingsBySource
}

// ExpectSourceTableParam2 sets up expected param sourceTable for RepositoryI.DeleteEmbeddingsBySource
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) ExpectSourceTableParam2(sourceTable string) *mRepositoryIMockDeleteEmbeddingsBySource {
	if mmDeleteEmbeddingsBySource.mock.funcDeleteEmbeddingsBySource != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by Set")
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation == nil {
		mmDeleteEmbeddingsBySource.defaultExpectation = &RepositoryIMockDeleteEmbeddingsBySourceExpectation{}
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation.params != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by Expect")
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs == nil {
		mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs = &RepositoryIMockDeleteEmbeddingsBySourceParamPtrs{}
	}
	mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs.sourceTable = &sourceTable

	return mmDeleteEmbeddingsBySource
}

// ExpectSourceUIDParam3 sets up expected param sourceUID for RepositoryI.DeleteEmbeddingsBySource
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) ExpectSourceUIDParam3(sourceUID uuid.UUID) *mRepositoryIMockDeleteEmbeddingsBySource {
	if mmDeleteEmbeddingsBySource.mock.funcDeleteEmbeddingsBySource != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by Set")
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation == nil {
		mmDeleteEmbeddingsBySource.defaultExpectation = &RepositoryIMockDeleteEmbeddingsBySourceExpectation{}
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation.params != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by Expect")
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs == nil {
		mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs = &RepositoryIMockDeleteEmbeddingsBySourceParamPtrs{}
	}
	mmDeleteEmbeddingsBySource.defaultExpectation.paramPtrs.sourceUID = &sourceUID

	return mmDeleteEmbeddingsBySource
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteEmbeddingsBySource
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) Inspect(f func(ctx context.Context, sourceTable string, sourceUID uuid.UUID)) *mRepositoryIMockDeleteEmbeddingsBySource {
	if mmDeleteEmbeddingsBySource.mock.inspectFuncDeleteEmbeddingsBySource != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteEmbeddingsBySource")
	}

	mmDeleteEmbeddingsBySource.mock.inspectFuncDeleteEmbeddingsBySource = f

	return mmDeleteEmbeddingsBySource
}

// Return sets up results that will be returned by RepositoryI.DeleteEmbeddingsBySource
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) Return(err error) *RepositoryIMock {
	if mmDeleteEmbeddingsBySource.mock.funcDeleteEmbeddingsBySource != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by Set")
	}

	if mmDeleteEmbeddingsBySource.defaultExpectation == nil {
		mmDeleteEmbeddingsBySource.defaultExpectation = &RepositoryIMockDeleteEmbeddingsBySourceExpectation{mock: mmDeleteEmbeddingsBySource.mock}
	}
	mmDeleteEmbeddingsBySource.defaultExpectation.results = &RepositoryIMockDeleteEmbeddingsBySourceResults{err}
	return mmDeleteEmbeddingsBySource.mock
}

// Set uses given function f to mock the RepositoryI.DeleteEmbeddingsBySource method
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) Set(f func(ctx context.Context, sourceTable string, sourceUID uuid.UUID) (err error)) *RepositoryIMock {
	if mmDeleteEmbeddingsBySource.defaultExpectation != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteEmbeddingsBySource method")
	}

	if len(mmDeleteEmbeddingsBySource.expectations) > 0 {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteEmbeddingsBySource method")
	}

	mmDeleteEmbeddingsBySource.mock.funcDeleteEmbeddingsBySource = f
	return mmDeleteEmbeddingsBySource.mock
}

// When sets expectation for the RepositoryI.DeleteEmbeddingsBySource which will trigger the result defined by the following
// Then helper
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) When(ctx context.Context, sourceTable string, sourceUID uuid.UUID) *RepositoryIMockDeleteEmbeddingsBySourceExpectation {
	if mmDeleteEmbeddingsBySource.mock.funcDeleteEmbeddingsBySource != nil {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsBySource mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteEmbeddingsBySourceExpectation{
		mock:   mmDeleteEmbeddingsBySource.mock,
		params: &RepositoryIMockDeleteEmbeddingsBySourceParams{ctx, sourceTable, sourceUID},
	}
	mmDeleteEmbeddingsBySource.expectations = append(mmDeleteEmbeddingsBySource.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteEmbeddingsBySource return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteEmbeddingsBySourceExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteEmbeddingsBySourceResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteEmbeddingsBySource should be invoked
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) Times(n uint64) *mRepositoryIMockDeleteEmbeddingsBySource {
	if n == 0 {
		mmDeleteEmbeddingsBySource.mock.t.Fatalf("Times of RepositoryIMock.DeleteEmbeddingsBySource mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteEmbeddingsBySource.expectedInvocations, n)
	return mmDeleteEmbeddingsBySource
}

func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) invocationsDone() bool {
	if len(mmDeleteEmbeddingsBySource.expectations) == 0 && mmDeleteEmbeddingsBySource.defaultExpectation == nil && mmDeleteEmbeddingsBySource.mock.funcDeleteEmbeddingsBySource == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteEmbeddingsBySource.mock.afterDeleteEmbeddingsBySourceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteEmbeddingsBySource.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteEmbeddingsBySource implements repository.RepositoryI
func (mmDeleteEmbeddingsBySource *RepositoryIMock) DeleteEmbeddingsBySource(ctx context.Context, sourceTable string, sourceUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteEmbeddingsBySource.beforeDeleteEmbeddingsBySourceCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteEmbeddingsBySource.afterDeleteEmbeddingsBySourceCounter, 1)

	if mmDeleteEmbeddingsBySource.inspectFuncDeleteEmbeddingsBySource != nil {
		mmDeleteEmbeddingsBySource.inspectFuncDeleteEmbeddingsBySource(ctx, sourceTable, sourceUID)
	}

	mm_params := RepositoryIMockDeleteEmbeddingsBySourceParams{ctx, sourceTable, sourceUID}

	// Record call args
	mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.mutex.Lock()
	mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.callArgs = append(mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.callArgs, &mm_params)
	mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.mutex.Unlock()

	for _, e := range mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteEmbeddingsBySourceParams{ctx, sourceTable, sourceUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteEmbeddingsBySource.t.Errorf("RepositoryIMock.DeleteEmbeddingsBySource got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sourceTable != nil && !minimock.Equal(*mm_want_ptrs.sourceTable, mm_got.sourceTable) {
				mmDeleteEmbeddingsBySource.t.Errorf("RepositoryIMock.DeleteEmbeddingsBySource got unexpected parameter sourceTable, want: %#v, got: %#v%s\n", *mm_want_ptrs.sourceTable, mm_got.sourceTable, minimock.Diff(*mm_want_ptrs.sourceTable, mm_got.sourceTable))
			}

			if mm_want_ptrs.sourceUID != nil && !minimock.Equal(*mm_want_ptrs.sourceUID, mm_got.sourceUID) {
				mmDeleteEmbeddingsBySource.t.Errorf("RepositoryIMock.DeleteEmbeddingsBySource got unexpected parameter sourceUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.sourceUID, mm_got.sourceUID, minimock.Diff(*mm_want_ptrs.sourceUID, mm_got.sourceUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteEmbeddingsBySource.t.Errorf("RepositoryIMock.DeleteEmbeddingsBySource got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteEmbeddingsBySource.DeleteEmbeddingsBySourceMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteEmbeddingsBySource.t.Fatal("No results are set for the RepositoryIMock.DeleteEmbeddingsBySource")
		}
		return (*mm_results).err
	}
	if mmDeleteEmbeddingsBySource.funcDeleteEmbeddingsBySource != nil {
		return mmDeleteEmbeddingsBySource.funcDeleteEmbeddingsBySource(ctx, sourceTable, sourceUID)
	}
	mmDeleteEmbeddingsBySource.t.Fatalf("Unexpected call to RepositoryIMock.DeleteEmbeddingsBySource. %v %v %v", ctx, sourceTable, sourceUID)
	return
}

// DeleteEmbeddingsBySourceAfterCounter returns a count of finished RepositoryIMock.DeleteEmbeddingsBySource invocations
func (mmDeleteEmbeddingsBySource *RepositoryIMock) DeleteEmbeddingsBySourceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEmbeddingsBySource.afterDeleteEmbeddingsBySourceCounter)
}

// DeleteEmbeddingsBySourceBeforeCounter returns a count of RepositoryIMock.DeleteEmbeddingsBySource invocations
func (mmDeleteEmbeddingsBySource *RepositoryIMock) DeleteEmbeddingsBySourceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEmbeddingsBySource.beforeDeleteEmbeddingsBySourceCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteEmbeddingsBySource.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteEmbeddingsBySource *mRepositoryIMockDeleteEmbeddingsBySource) Calls() []*RepositoryIMockDeleteEmbeddingsBySourceParams {
	mmDeleteEmbeddingsBySource.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteEmbeddingsBySourceParams, len(mmDeleteEmbeddingsBySource.callArgs))
	copy(argCopy, mmDeleteEmbeddingsBySource.callArgs)

	mmDeleteEmbeddingsBySource.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteEmbeddingsBySourceDone returns true if the count of the DeleteEmbeddingsBySource invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteEmbeddingsBySourceDone() bool {
	for _, e := range m.DeleteEmbeddingsBySourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteEmbeddingsBySourceMock.invocationsDone()
}

// MinimockDeleteEmbeddingsBySourceInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteEmbeddingsBySourceInspect() {
	for _, e := range m.DeleteEmbeddingsBySourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteEmbeddingsBySource with params: %#v", *e.params)
		}
	}

	afterDeleteEmbeddingsBySourceCounter := mm_atomic.LoadUint64(&m.afterDeleteEmbeddingsBySourceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteEmbeddingsBySourceMock.defaultExpectation != nil && afterDeleteEmbeddingsBySourceCounter < 1 {
		if m.DeleteEmbeddingsBySourceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteEmbeddingsBySource")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteEmbeddingsBySource with params: %#v", *m.DeleteEmbeddingsBySourceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteEmbeddingsBySource != nil && afterDeleteEmbeddingsBySourceCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteEmbeddingsBySource")
	}

	if !m.DeleteEmbeddingsBySourceMock.invocationsDone() && afterDeleteEmbeddingsBySourceCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteEmbeddingsBySource but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteEmbeddingsBySourceMock.expectedInvocations), afterDeleteEmbeddingsBySourceCounter)
	}
}

type mRepositoryIMockDeleteEmbeddingsByUIDs struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteEmbeddingsByUIDsExpectation
	expectations       []*RepositoryIMockDeleteEmbeddingsByUIDsExpectation

	callArgs []*RepositoryIMockDeleteEmbeddingsByUIDsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteEmbeddingsByUIDsExpectation specifies expectation struct of the RepositoryI.DeleteEmbeddingsByUIDs
type RepositoryIMockDeleteEmbeddingsByUIDsExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteEmbeddingsByUIDsParams
	paramPtrs *RepositoryIMockDeleteEmbeddingsByUIDsParamPtrs
	results   *RepositoryIMockDeleteEmbeddingsByUIDsResults
	Counter   uint64
}

// RepositoryIMockDeleteEmbeddingsByUIDsParams contains parameters of the RepositoryI.DeleteEmbeddingsByUIDs
type RepositoryIMockDeleteEmbeddingsByUIDsParams struct {
	ctx     context.Context
	embUIDs []uuid.UUID
}

// RepositoryIMockDeleteEmbeddingsByUIDsParamPtrs contains pointers to parameters of the RepositoryI.DeleteEmbeddingsByUIDs
type RepositoryIMockDeleteEmbeddingsByUIDsParamPtrs struct {
	ctx     *context.Context
	embUIDs *[]uuid.UUID
}

// RepositoryIMockDeleteEmbeddingsByUIDsResults contains results of the RepositoryI.DeleteEmbeddingsByUIDs
type RepositoryIMockDeleteEmbeddingsByUIDsResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteEmbeddingsByUIDs
func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) Expect(ctx context.Context, embUIDs []uuid.UUID) *mRepositoryIMockDeleteEmbeddingsByUIDs {
	if mmDeleteEmbeddingsByUIDs.mock.funcDeleteEmbeddingsByUIDs != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsByUIDs mock is already set by Set")
	}

	if mmDeleteEmbeddingsByUIDs.defaultExpectation == nil {
		mmDeleteEmbeddingsByUIDs.defaultExpectation = &RepositoryIMockDeleteEmbeddingsByUIDsExpectation{}
	}

	if mmDeleteEmbeddingsByUIDs.defaultExpectation.paramPtrs != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsByUIDs mock is already set by ExpectParams functions")
	}

	mmDeleteEmbeddingsByUIDs.defaultExpectation.params = &RepositoryIMockDeleteEmbeddingsByUIDsParams{ctx, embUIDs}
	for _, e := range mmDeleteEmbeddingsByUIDs.expectations {
		if minimock.Equal(e.params, mmDeleteEmbeddingsByUIDs.defaultExpectation.params) {
			mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteEmbeddingsByUIDs.defaultExpectation.params)
		}
	}

	return mmDeleteEmbeddingsByUIDs
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteEmbeddingsByUIDs
func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteEmbeddingsByUIDs {
	if mmDeleteEmbeddingsByUIDs.mock.funcDeleteEmbeddingsByUIDs != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsByUIDs mock is already set by Set")
	}

	if mmDeleteEmbeddingsByUIDs.defaultExpectation == nil {
		mmDeleteEmbeddingsByUIDs.defaultExpectation = &RepositoryIMockDeleteEmbeddingsByUIDsExpectation{}
	}

	if mmDeleteEmbeddingsByUIDs.defaultExpectation.params != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsByUIDs mock is already set by Expect")
	}

	if mmDeleteEmbeddingsByUIDs.defaultExpectation.paramPtrs == nil {
		mmDeleteEmbeddingsByUIDs.defaultExpectation.paramPtrs = &RepositoryIMockDeleteEmbeddingsByUIDsParamPtrs{}
	}
	mmDeleteEmbeddingsByUIDs.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteEmbeddingsByUIDs
}

// ExpectEmbUIDsParam2 sets up expected param embUIDs for RepositoryI.DeleteEmbeddingsByUIDs
func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) ExpectEmbUIDsParam2(embUIDs []uuid.UUID) *mRepositoryIMockDeleteEmbeddingsByUIDs {
	if mmDeleteEmbeddingsByUIDs.mock.funcDeleteEmbeddingsByUIDs != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsByUIDs mock is already set by Set")
	}

	if mmDeleteEmbeddingsByUIDs.defaultExpectation == nil {
		mmDeleteEmbeddingsByUIDs.defaultExpectation = &RepositoryIMockDeleteEmbeddingsByUIDsExpectation{}
	}

	if mmDeleteEmbeddingsByUIDs.defaultExpectation.params != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsByUIDs mock is already set by Expect")
	}

	if mmDeleteEmbeddingsByUIDs.defaultExpectation.paramPtrs == nil {
		mmDeleteEmbeddingsByUIDs.defaultExpectation.paramPtrs = &RepositoryIMockDeleteEmbeddingsByUIDsParamPtrs{}
	}
	mmDeleteEmbeddingsByUIDs.defaultExpectation.paramPtrs.embUIDs = &embUIDs

	return mmDeleteEmbeddingsByUIDs
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteEmbeddingsByUIDs
func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) Inspect(f func(ctx context.Context, embUIDs []uuid.UUID)) *mRepositoryIMockDeleteEmbeddingsByUIDs {
	if mmDeleteEmbeddingsByUIDs.mock.inspectFuncDeleteEmbeddingsByUIDs != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteEmbeddingsByUIDs")
	}

	mmDeleteEmbeddingsByUIDs.mock.inspectFuncDeleteEmbeddingsByUIDs = f

	return mmDeleteEmbeddingsByUIDs
}

// Return sets up results that will be returned by RepositoryI.DeleteEmbeddingsByUIDs
func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) Return(err error) *RepositoryIMock {
	if mmDeleteEmbeddingsByUIDs.mock.funcDeleteEmbeddingsByUIDs != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsByUIDs mock is already set by Set")
	}

	if mmDeleteEmbeddingsByUIDs.defaultExpectation == nil {
		mmDeleteEmbeddingsByUIDs.defaultExpectation = &RepositoryIMockDeleteEmbeddingsByUIDsExpectation{mock: mmDeleteEmbeddingsByUIDs.mock}
	}
	mmDeleteEmbeddingsByUIDs.defaultExpectation.results = &RepositoryIMockDeleteEmbeddingsByUIDsResults{err}
	return mmDeleteEmbeddingsByUIDs.mock
}

// Set uses given function f to mock the RepositoryI.DeleteEmbeddingsByUIDs method
func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) Set(f func(ctx context.Context, embUIDs []uuid.UUID) (err error)) *RepositoryIMock {
	if mmDeleteEmbeddingsByUIDs.defaultExpectation != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteEmbeddingsByUIDs method")
	}

	if len(mmDeleteEmbeddingsByUIDs.expectations) > 0 {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteEmbeddingsByUIDs method")
	}

	mmDeleteEmbeddingsByUIDs.mock.funcDeleteEmbeddingsByUIDs = f
	return mmDeleteEmbeddingsByUIDs.mock
}

// When sets expectation for the RepositoryI.DeleteEmbeddingsByUIDs which will trigger the result defined by the following
// Then helper
func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) When(ctx context.Context, embUIDs []uuid.UUID) *RepositoryIMockDeleteEmbeddingsByUIDsExpectation {
	if mmDeleteEmbeddingsByUIDs.mock.funcDeleteEmbeddingsByUIDs != nil {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("RepositoryIMock.DeleteEmbeddingsByUIDs mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteEmbeddingsByUIDsExpectation{
		mock:   mmDeleteEmbeddingsByUIDs.mock,
		params: &RepositoryIMockDeleteEmbeddingsByUIDsParams{ctx, embUIDs},
	}
	mmDeleteEmbeddingsByUIDs.expectations = append(mmDeleteEmbeddingsByUIDs.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteEmbeddingsByUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteEmbeddingsByUIDsExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteEmbeddingsByUIDsResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteEmbeddingsByUIDs should be invoked
func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) Times(n uint64) *mRepositoryIMockDeleteEmbeddingsByUIDs {
	if n == 0 {
		mmDeleteEmbeddingsByUIDs.mock.t.Fatalf("Times of RepositoryIMock.DeleteEmbeddingsByUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteEmbeddingsByUIDs.expectedInvocations, n)
	return mmDeleteEmbeddingsByUIDs
}

func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) invocationsDone() bool {
	if len(mmDeleteEmbeddingsByUIDs.expectations) == 0 && mmDeleteEmbeddingsByUIDs.defaultExpectation == nil && mmDeleteEmbeddingsByUIDs.mock.funcDeleteEmbeddingsByUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteEmbeddingsByUIDs.mock.afterDeleteEmbeddingsByUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteEmbeddingsByUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteEmbeddingsByUIDs implements repository.RepositoryI
func (mmDeleteEmbeddingsByUIDs *RepositoryIMock) DeleteEmbeddingsByUIDs(ctx context.Context, embUIDs []uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteEmbeddingsByUIDs.beforeDeleteEmbeddingsByUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteEmbeddingsByUIDs.afterDeleteEmbeddingsByUIDsCounter, 1)

	if mmDeleteEmbeddingsByUIDs.inspectFuncDeleteEmbeddingsByUIDs != nil {
		mmDeleteEmbeddingsByUIDs.inspectFuncDeleteEmbeddingsByUIDs(ctx, embUIDs)
	}

	mm_params := RepositoryIMockDeleteEmbeddingsByUIDsParams{ctx, embUIDs}

	// Record call args
	mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.mutex.Lock()
	mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.callArgs = append(mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.callArgs, &mm_params)
	mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.mutex.Unlock()

	for _, e := range mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteEmbeddingsByUIDsParams{ctx, embUIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteEmbeddingsByUIDs.t.Errorf("RepositoryIMock.DeleteEmbeddingsByUIDs got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.embUIDs != nil && !minimock.Equal(*mm_want_ptrs.embUIDs, mm_got.embUIDs) {
				mmDeleteEmbeddingsByUIDs.t.Errorf("RepositoryIMock.DeleteEmbeddingsByUIDs got unexpected parameter embUIDs, want: %#v, got: %#v%s\n", *mm_want_ptrs.embUIDs, mm_got.embUIDs, minimock.Diff(*mm_want_ptrs.embUIDs, mm_got.embUIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteEmbeddingsByUIDs.t.Errorf("RepositoryIMock.DeleteEmbeddingsByUIDs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteEmbeddingsByUIDs.DeleteEmbeddingsByUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteEmbeddingsByUIDs.t.Fatal("No results are set for the RepositoryIMock.DeleteEmbeddingsByUIDs")
		}
		return (*mm_results).err
	}
	if mmDeleteEmbeddingsByUIDs.funcDeleteEmbeddingsByUIDs != nil {
		return mmDeleteEmbeddingsByUIDs.funcDeleteEmbeddingsByUIDs(ctx, embUIDs)
	}
	mmDeleteEmbeddingsByUIDs.t.Fatalf("Unexpected call to RepositoryIMock.DeleteEmbeddingsByUIDs. %v %v", ctx, embUIDs)
	return
}

// DeleteEmbeddingsByUIDsAfterCounter returns a count of finished RepositoryIMock.DeleteEmbeddingsByUIDs invocations
func (mmDeleteEmbeddingsByUIDs *RepositoryIMock) DeleteEmbeddingsByUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEmbeddingsByUIDs.afterDeleteEmbeddingsByUIDsCounter)
}

// DeleteEmbeddingsByUIDsBeforeCounter returns a count of RepositoryIMock.DeleteEmbeddingsByUIDs invocations
func (mmDeleteEmbeddingsByUIDs *RepositoryIMock) DeleteEmbeddingsByUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEmbeddingsByUIDs.beforeDeleteEmbeddingsByUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteEmbeddingsByUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteEmbeddingsByUIDs *mRepositoryIMockDeleteEmbeddingsByUIDs) Calls() []*RepositoryIMockDeleteEmbeddingsByUIDsParams {
	mmDeleteEmbeddingsByUIDs.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteEmbeddingsByUIDsParams, len(mmDeleteEmbeddingsByUIDs.callArgs))
	copy(argCopy, mmDeleteEmbeddingsByUIDs.callArgs)

	mmDeleteEmbeddingsByUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteEmbeddingsByUIDsDone returns true if the count of the DeleteEmbeddingsByUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteEmbeddingsByUIDsDone() bool {
	for _, e := range m.DeleteEmbeddingsByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteEmbeddingsByUIDsMock.invocationsDone()
}

// MinimockDeleteEmbeddingsByUIDsInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteEmbeddingsByUIDsInspect() {
	for _, e := range m.DeleteEmbeddingsByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteEmbeddingsByUIDs with params: %#v", *e.params)
		}
	}

	afterDeleteEmbeddingsByUIDsCounter := mm_atomic.LoadUint64(&m.afterDeleteEmbeddingsByUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteEmbeddingsByUIDsMock.defaultExpectation != nil && afterDeleteEmbeddingsByUIDsCounter < 1 {
		if m.DeleteEmbeddingsByUIDsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteEmbeddingsByUIDs")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteEmbeddingsByUIDs with params: %#v", *m.DeleteEmbeddingsByUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteEmbeddingsByUIDs != nil && afterDeleteEmbeddingsByUIDsCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteEmbeddingsByUIDs")
	}

	if !m.DeleteEmbeddingsByUIDsMock.invocationsDone() && afterDeleteEmbeddingsByUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteEmbeddingsByUIDs but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteEmbeddingsByUIDsMock.expectedInvocations), afterDeleteEmbeddingsByUIDsCounter)
	}
}

type mRepositoryIMockDeleteKnowledgeBase struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteKnowledgeBaseExpectation
	expectations       []*RepositoryIMockDeleteKnowledgeBaseExpectation

	callArgs []*RepositoryIMockDeleteKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteKnowledgeBaseExpectation specifies expectation struct of the RepositoryI.DeleteKnowledgeBase
type RepositoryIMockDeleteKnowledgeBaseExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteKnowledgeBaseParams
	paramPtrs *RepositoryIMockDeleteKnowledgeBaseParamPtrs
	results   *RepositoryIMockDeleteKnowledgeBaseResults
	Counter   uint64
}

// RepositoryIMockDeleteKnowledgeBaseParams contains parameters of the RepositoryI.DeleteKnowledgeBase
type RepositoryIMockDeleteKnowledgeBaseParams struct {
	ctx      context.Context
	ownerUID string
	kbID     string
}

// RepositoryIMockDeleteKnowledgeBaseParamPtrs contains pointers to parameters of the RepositoryI.DeleteKnowledgeBase
type RepositoryIMockDeleteKnowledgeBaseParamPtrs struct {
	ctx      *context.Context
	ownerUID *string
	kbID     *string
}

// RepositoryIMockDeleteKnowledgeBaseResults contains results of the RepositoryI.DeleteKnowledgeBase
type RepositoryIMockDeleteKnowledgeBaseResults struct {
	kp1 *mm_repository.KnowledgeBase
	err error
}

// Expect sets up expected params for RepositoryI.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) Expect(ctx context.Context, ownerUID string, kbID string) *mRepositoryIMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmDeleteKnowledgeBase.defaultExpectation.params = &RepositoryIMockDeleteKnowledgeBaseParams{ctx, ownerUID, kbID}
	for _, e := range mmDeleteKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmDeleteKnowledgeBase.defaultExpectation.params) {
			mmDeleteKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmDeleteKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.params != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Expect")
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockDeleteKnowledgeBaseParamPtrs{}
	}
	mmDeleteKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteKnowledgeBase
}

// ExpectOwnerUIDParam2 sets up expected param ownerUID for RepositoryI.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) ExpectOwnerUIDParam2(ownerUID string) *mRepositoryIMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.params != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Expect")
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockDeleteKnowledgeBaseParamPtrs{}
	}
	mmDeleteKnowledgeBase.defaultExpectation.paramPtrs.ownerUID = &ownerUID

	return mmDeleteKnowledgeBase
}

// ExpectKbIDParam3 sets up expected param kbID for RepositoryI.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) ExpectKbIDParam3(kbID string) *mRepositoryIMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.params != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Expect")
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockDeleteKnowledgeBaseParamPtrs{}
	}
	mmDeleteKnowledgeBase.defaultExpectation.paramPtrs.kbID = &kbID

	return mmDeleteKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) Inspect(f func(ctx context.Context, ownerUID string, kbID string)) *mRepositoryIMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.inspectFuncDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteKnowledgeBase")
	}

	mmDeleteKnowledgeBase.mock.inspectFuncDeleteKnowledgeBase = f

	return mmDeleteKnowledgeBase
}

// Return sets up results that will be returned by RepositoryI.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) Return(kp1 *mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseExpectation{mock: mmDeleteKnowledgeBase.mock}
	}
	mmDeleteKnowledgeBase.defaultExpectation.results = &RepositoryIMockDeleteKnowledgeBaseResults{kp1, err}
	return mmDeleteKnowledgeBase.mock
}

// Set uses given function f to mock the RepositoryI.DeleteKnowledgeBase method
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) Set(f func(ctx context.Context, ownerUID string, kbID string) (kp1 *mm_repository.KnowledgeBase, err error)) *RepositoryIMock {
	if mmDeleteKnowledgeBase.defaultExpectation != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteKnowledgeBase method")
	}

	if len(mmDeleteKnowledgeBase.expectations) > 0 {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteKnowledgeBase method")
	}

	mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase = f
	return mmDeleteKnowledgeBase.mock
}

// When sets expectation for the RepositoryI.DeleteKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) When(ctx context.Context, ownerUID string, kbID string) *RepositoryIMockDeleteKnowledgeBaseExpectation {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBase mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteKnowledgeBaseExpectation{
		mock:   mmDeleteKnowledgeBase.mock,
		params: &RepositoryIMockDeleteKnowledgeBaseParams{ctx, ownerUID, kbID},
	}
	mmDeleteKnowledgeBase.expectations = append(mmDeleteKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteKnowledgeBaseExpectation) Then(kp1 *mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteKnowledgeBaseResults{kp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteKnowledgeBase should be invoked
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) Times(n uint64) *mRepositoryIMockDeleteKnowledgeBase {
	if n == 0 {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Times of RepositoryIMock.DeleteKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteKnowledgeBase.expectedInvocations, n)
	return mmDeleteKnowledgeBase
}

func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) invocationsDone() bool {
	if len(mmDeleteKnowledgeBase.expectations) == 0 && mmDeleteKnowledgeBase.defaultExpectation == nil && mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.mock.afterDeleteKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteKnowledgeBase implements repository.RepositoryI
func (mmDeleteKnowledgeBase *RepositoryIMock) DeleteKnowledgeBase(ctx context.Context, ownerUID string, kbID string) (kp1 *mm_repository.KnowledgeBase, err error) {
	mm_atomic.AddUint64(&mmDeleteKnowledgeBase.beforeDeleteKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteKnowledgeBase.afterDeleteKnowledgeBaseCounter, 1)

	if mmDeleteKnowledgeBase.inspectFuncDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.inspectFuncDeleteKnowledgeBase(ctx, ownerUID, kbID)
	}

	mm_params := RepositoryIMockDeleteKnowledgeBaseParams{ctx, ownerUID, kbID}

	// Record call args
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.mutex.Lock()
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.callArgs = append(mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.callArgs, &mm_params)
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteKnowledgeBaseParams{ctx, ownerUID, kbID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteKnowledgeBase.t.Errorf("RepositoryIMock.DeleteKnowledgeBase got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmDeleteKnowledgeBase.t.Errorf("RepositoryIMock.DeleteKnowledgeBase got unexpected parameter ownerUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

			if mm_want_ptrs.kbID != nil && !minimock.Equal(*mm_want_ptrs.kbID, mm_got.kbID) {
				mmDeleteKnowledgeBase.t.Errorf("RepositoryIMock.DeleteKnowledgeBase got unexpected parameter kbID, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbID, mm_got.kbID, minimock.Diff(*mm_want_ptrs.kbID, mm_got.kbID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteKnowledgeBase.t.Errorf("RepositoryIMock.DeleteKnowledgeBase got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteKnowledgeBase.t.Fatal("No results are set for the RepositoryIMock.DeleteKnowledgeBase")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmDeleteKnowledgeBase.funcDeleteKnowledgeBase != nil {
		return mmDeleteKnowledgeBase.funcDeleteKnowledgeBase(ctx, ownerUID, kbID)
	}
	mmDeleteKnowledgeBase.t.Fatalf("Unexpected call to RepositoryIMock.DeleteKnowledgeBase. %v %v %v", ctx, ownerUID, kbID)
	return
}

// DeleteKnowledgeBaseAfterCounter returns a count of finished RepositoryIMock.DeleteKnowledgeBase invocations
func (mmDeleteKnowledgeBase *RepositoryIMock) DeleteKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.afterDeleteKnowledgeBaseCounter)
}

// DeleteKnowledgeBaseBeforeCounter returns a count of RepositoryIMock.DeleteKnowledgeBase invocations
func (mmDeleteKnowledgeBase *RepositoryIMock) DeleteKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.beforeDeleteKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteKnowledgeBase *mRepositoryIMockDeleteKnowledgeBase) Calls() []*RepositoryIMockDeleteKnowledgeBaseParams {
	mmDeleteKnowledgeBase.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteKnowledgeBaseParams, len(mmDeleteKnowledgeBase.callArgs))
	copy(argCopy, mmDeleteKnowledgeBase.callArgs)

	mmDeleteKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteKnowledgeBaseDone returns true if the count of the DeleteKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteKnowledgeBaseDone() bool {
	for _, e := range m.DeleteKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteKnowledgeBaseMock.invocationsDone()
}

// MinimockDeleteKnowledgeBaseInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteKnowledgeBaseInspect() {
	for _, e := range m.DeleteKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteKnowledgeBase with params: %#v", *e.params)
		}
	}

	afterDeleteKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterDeleteKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteKnowledgeBaseMock.defaultExpectation != nil && afterDeleteKnowledgeBaseCounter < 1 {
		if m.DeleteKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteKnowledgeBase")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteKnowledgeBase with params: %#v", *m.DeleteKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteKnowledgeBase != nil && afterDeleteKnowledgeBaseCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteKnowledgeBase")
	}

	if !m.DeleteKnowledgeBaseMock.invocationsDone() && afterDeleteKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteKnowledgeBase but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteKnowledgeBaseMock.expectedInvocations), afterDeleteKnowledgeBaseCounter)
	}
}

type mRepositoryIMockDeleteKnowledgeBaseFile struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteKnowledgeBaseFileExpectation
	expectations       []*RepositoryIMockDeleteKnowledgeBaseFileExpectation

	callArgs []*RepositoryIMockDeleteKnowledgeBaseFileParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteKnowledgeBaseFileExpectation specifies expectation struct of the RepositoryI.DeleteKnowledgeBaseFile
type RepositoryIMockDeleteKnowledgeBaseFileExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteKnowledgeBaseFileParams
	paramPtrs *RepositoryIMockDeleteKnowledgeBaseFileParamPtrs
	results   *RepositoryIMockDeleteKnowledgeBaseFileResults
	Counter   uint64
}

// RepositoryIMockDeleteKnowledgeBaseFileParams contains parameters of the RepositoryI.DeleteKnowledgeBaseFile
type RepositoryIMockDeleteKnowledgeBaseFileParams struct {
	ctx     context.Context
	fileUID string
}

// RepositoryIMockDeleteKnowledgeBaseFileParamPtrs contains pointers to parameters of the RepositoryI.DeleteKnowledgeBaseFile
type RepositoryIMockDeleteKnowledgeBaseFileParamPtrs struct {
	ctx     *context.Context
	fileUID *string
}

// RepositoryIMockDeleteKnowledgeBaseFileResults contains results of the RepositoryI.DeleteKnowledgeBaseFile
type RepositoryIMockDeleteKnowledgeBaseFileResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteKnowledgeBaseFile
func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) Expect(ctx context.Context, fileUID string) *mRepositoryIMockDeleteKnowledgeBaseFile {
	if mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFile mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseFileExpectation{}
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFile mock is already set by ExpectParams functions")
	}

	mmDeleteKnowledgeBaseFile.defaultExpectation.params = &RepositoryIMockDeleteKnowledgeBaseFileParams{ctx, fileUID}
	for _, e := range mmDeleteKnowledgeBaseFile.expectations {
		if minimock.Equal(e.params, mmDeleteKnowledgeBaseFile.defaultExpectation.params) {
			mmDeleteKnowledgeBaseFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteKnowledgeBaseFile.defaultExpectation.params)
		}
	}

	return mmDeleteKnowledgeBaseFile
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteKnowledgeBaseFile
func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteKnowledgeBaseFile {
	if mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFile mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseFileExpectation{}
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation.params != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFile mock is already set by Expect")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryIMockDeleteKnowledgeBaseFileParamPtrs{}
	}
	mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteKnowledgeBaseFile
}

// ExpectFileUIDParam2 sets up expected param fileUID for RepositoryI.DeleteKnowledgeBaseFile
func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) ExpectFileUIDParam2(fileUID string) *mRepositoryIMockDeleteKnowledgeBaseFile {
	if mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFile mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseFileExpectation{}
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation.params != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFile mock is already set by Expect")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryIMockDeleteKnowledgeBaseFileParamPtrs{}
	}
	mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs.fileUID = &fileUID

	return mmDeleteKnowledgeBaseFile
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteKnowledgeBaseFile
func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) Inspect(f func(ctx context.Context, fileUID string)) *mRepositoryIMockDeleteKnowledgeBaseFile {
	if mmDeleteKnowledgeBaseFile.mock.inspectFuncDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteKnowledgeBaseFile")
	}

	mmDeleteKnowledgeBaseFile.mock.inspectFuncDeleteKnowledgeBaseFile = f

	return mmDeleteKnowledgeBaseFile
}

// Return sets up results that will be returned by RepositoryI.DeleteKnowledgeBaseFile
func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) Return(err error) *RepositoryIMock {
	if mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFile mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation = &RepositoryIMockDeleteKnowledgeBaseFileExpectation{mock: mmDeleteKnowledgeBaseFile.mock}
	}
	mmDeleteKnowledgeBaseFile.defaultExpectation.results = &RepositoryIMockDeleteKnowledgeBaseFileResults{err}
	return mmDeleteKnowledgeBaseFile.mock
}

// Set uses given function f to mock the RepositoryI.DeleteKnowledgeBaseFile method
func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) Set(f func(ctx context.Context, fileUID string) (err error)) *RepositoryIMock {
	if mmDeleteKnowledgeBaseFile.defaultExpectation != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteKnowledgeBaseFile method")
	}

	if len(mmDeleteKnowledgeBaseFile.expectations) > 0 {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteKnowledgeBaseFile method")
	}

	mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile = f
	return mmDeleteKnowledgeBaseFile.mock
}

// When sets expectation for the RepositoryI.DeleteKnowledgeBaseFile which will trigger the result defined by the following
// Then helper
func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) When(ctx context.Context, fileUID string) *RepositoryIMockDeleteKnowledgeBaseFileExpectation {
	if mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.DeleteKnowledgeBaseFile mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteKnowledgeBaseFileExpectation{
		mock:   mmDeleteKnowledgeBaseFile.mock,
		params: &RepositoryIMockDeleteKnowledgeBaseFileParams{ctx, fileUID},
	}
	mmDeleteKnowledgeBaseFile.expectations = append(mmDeleteKnowledgeBaseFile.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteKnowledgeBaseFile return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteKnowledgeBaseFileExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteKnowledgeBaseFileResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteKnowledgeBaseFile should be invoked
func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) Times(n uint64) *mRepositoryIMockDeleteKnowledgeBaseFile {
	if n == 0 {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("Times of RepositoryIMock.DeleteKnowledgeBaseFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteKnowledgeBaseFile.expectedInvocations, n)
	return mmDeleteKnowledgeBaseFile
}

func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) invocationsDone() bool {
	if len(mmDeleteKnowledgeBaseFile.expectations) == 0 && mmDeleteKnowledgeBaseFile.defaultExpectation == nil && mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFile.mock.afterDeleteKnowledgeBaseFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteKnowledgeBaseFile implements repository.RepositoryI
func (mmDeleteKnowledgeBaseFile *RepositoryIMock) DeleteKnowledgeBaseFile(ctx context.Context, fileUID string) (err error) {
	mm_atomic.AddUint64(&mmDeleteKnowledgeBaseFile.beforeDeleteKnowledgeBaseFileCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteKnowledgeBaseFile.afterDeleteKnowledgeBaseFileCounter, 1)

	if mmDeleteKnowledgeBaseFile.inspectFuncDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.inspectFuncDeleteKnowledgeBaseFile(ctx, fileUID)
	}

	mm_params := RepositoryIMockDeleteKnowledgeBaseFileParams{ctx, fileUID}

	// Record call args
	mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.mutex.Lock()
	mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.callArgs = append(mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.callArgs, &mm_params)
	mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.mutex.Unlock()

	for _, e := range mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteKnowledgeBaseFileParams{ctx, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteKnowledgeBaseFile.t.Errorf("RepositoryIMock.DeleteKnowledgeBaseFile got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmDeleteKnowledgeBaseFile.t.Errorf("RepositoryIMock.DeleteKnowledgeBaseFile got unexpected parameter fileUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteKnowledgeBaseFile.t.Errorf("RepositoryIMock.DeleteKnowledgeBaseFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteKnowledgeBaseFile.t.Fatal("No results are set for the RepositoryIMock.DeleteKnowledgeBaseFile")
		}
		return (*mm_results).err
	}
	if mmDeleteKnowledgeBaseFile.funcDeleteKnowledgeBaseFile != nil {
		return mmDeleteKnowledgeBaseFile.funcDeleteKnowledgeBaseFile(ctx, fileUID)
	}
	mmDeleteKnowledgeBaseFile.t.Fatalf("Unexpected call to RepositoryIMock.DeleteKnowledgeBaseFile. %v %v", ctx, fileUID)
	return
}

// DeleteKnowledgeBaseFileAfterCounter returns a count of finished RepositoryIMock.DeleteKnowledgeBaseFile invocations
func (mmDeleteKnowledgeBaseFile *RepositoryIMock) DeleteKnowledgeBaseFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFile.afterDeleteKnowledgeBaseFileCounter)
}

// DeleteKnowledgeBaseFileBeforeCounter returns a count of RepositoryIMock.DeleteKnowledgeBaseFile invocations
func (mmDeleteKnowledgeBaseFile *RepositoryIMock) DeleteKnowledgeBaseFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFile.beforeDeleteKnowledgeBaseFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteKnowledgeBaseFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteKnowledgeBaseFile *mRepositoryIMockDeleteKnowledgeBaseFile) Calls() []*RepositoryIMockDeleteKnowledgeBaseFileParams {
	mmDeleteKnowledgeBaseFile.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteKnowledgeBaseFileParams, len(mmDeleteKnowledgeBaseFile.callArgs))
	copy(argCopy, mmDeleteKnowledgeBaseFile.callArgs)

	mmDeleteKnowledgeBaseFile.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteKnowledgeBaseFileDone returns true if the count of the DeleteKnowledgeBaseFile invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteKnowledgeBaseFileDone() bool {
	for _, e := range m.DeleteKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteKnowledgeBaseFileMock.invocationsDone()
}

// MinimockDeleteKnowledgeBaseFileInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteKnowledgeBaseFileInspect() {
	for _, e := range m.DeleteKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteKnowledgeBaseFile with params: %#v", *e.params)
		}
	}

	afterDeleteKnowledgeBaseFileCounter := mm_atomic.LoadUint64(&m.afterDeleteKnowledgeBaseFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteKnowledgeBaseFileMock.defaultExpectation != nil && afterDeleteKnowledgeBaseFileCounter < 1 {
		if m.DeleteKnowledgeBaseFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteKnowledgeBaseFile")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteKnowledgeBaseFile with params: %#v", *m.DeleteKnowledgeBaseFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteKnowledgeBaseFile != nil && afterDeleteKnowledgeBaseFileCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteKnowledgeBaseFile")
	}

	if !m.DeleteKnowledgeBaseFileMock.invocationsDone() && afterDeleteKnowledgeBaseFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteKnowledgeBaseFile but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteKnowledgeBaseFileMock.expectedInvocations), afterDeleteKnowledgeBaseFileCounter)
	}
}

type mRepositoryIMockDeleteRepositoryTag struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockDeleteRepositoryTagExpectation
	expectations       []*RepositoryIMockDeleteRepositoryTagExpectation

	callArgs []*RepositoryIMockDeleteRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockDeleteRepositoryTagExpectation specifies expectation struct of the RepositoryI.DeleteRepositoryTag
type RepositoryIMockDeleteRepositoryTagExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockDeleteRepositoryTagParams
	paramPtrs *RepositoryIMockDeleteRepositoryTagParamPtrs
	results   *RepositoryIMockDeleteRepositoryTagResults
	Counter   uint64
}

// RepositoryIMockDeleteRepositoryTagParams contains parameters of the RepositoryI.DeleteRepositoryTag
type RepositoryIMockDeleteRepositoryTagParams struct {
	ctx context.Context
	s1  string
}

// RepositoryIMockDeleteRepositoryTagParamPtrs contains pointers to parameters of the RepositoryI.DeleteRepositoryTag
type RepositoryIMockDeleteRepositoryTagParamPtrs struct {
	ctx *context.Context
	s1  *string
}

// RepositoryIMockDeleteRepositoryTagResults contains results of the RepositoryI.DeleteRepositoryTag
type RepositoryIMockDeleteRepositoryTagResults struct {
	err error
}

// Expect sets up expected params for RepositoryI.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) Expect(ctx context.Context, s1 string) *mRepositoryIMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryIMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &RepositoryIMockDeleteRepositoryTagExpectation{}
	}

	if mmDeleteRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryIMock.DeleteRepositoryTag mock is already set by ExpectParams functions")
	}

	mmDeleteRepositoryTag.defaultExpectation.params = &RepositoryIMockDeleteRepositoryTagParams{ctx, s1}
	for _, e := range mmDeleteRepositoryTag.expectations {
		if minimock.Equal(e.params, mmDeleteRepositoryTag.defaultExpectation.params) {
			mmDeleteRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteRepositoryTag.defaultExpectation.params)
		}
	}

	return mmDeleteRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryIMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &RepositoryIMockDeleteRepositoryTagExpectation{}
	}

	if mmDeleteRepositoryTag.defaultExpectation.params != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryIMock.DeleteRepositoryTag mock is already set by Expect")
	}

	if mmDeleteRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmDeleteRepositoryTag.defaultExpectation.paramPtrs = &RepositoryIMockDeleteRepositoryTagParamPtrs{}
	}
	mmDeleteRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteRepositoryTag
}

// ExpectS1Param2 sets up expected param s1 for RepositoryI.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) ExpectS1Param2(s1 string) *mRepositoryIMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryIMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &RepositoryIMockDeleteRepositoryTagExpectation{}
	}

	if mmDeleteRepositoryTag.defaultExpectation.params != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryIMock.DeleteRepositoryTag mock is already set by Expect")
	}

	if mmDeleteRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmDeleteRepositoryTag.defaultExpectation.paramPtrs = &RepositoryIMockDeleteRepositoryTagParamPtrs{}
	}
	mmDeleteRepositoryTag.defaultExpectation.paramPtrs.s1 = &s1

	return mmDeleteRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) Inspect(f func(ctx context.Context, s1 string)) *mRepositoryIMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.inspectFuncDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.DeleteRepositoryTag")
	}

	mmDeleteRepositoryTag.mock.inspectFuncDeleteRepositoryTag = f

	return mmDeleteRepositoryTag
}

// Return sets up results that will be returned by RepositoryI.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) Return(err error) *RepositoryIMock {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryIMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &RepositoryIMockDeleteRepositoryTagExpectation{mock: mmDeleteRepositoryTag.mock}
	}
	mmDeleteRepositoryTag.defaultExpectation.results = &RepositoryIMockDeleteRepositoryTagResults{err}
	return mmDeleteRepositoryTag.mock
}

// Set uses given function f to mock the RepositoryI.DeleteRepositoryTag method
func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) Set(f func(ctx context.Context, s1 string) (err error)) *RepositoryIMock {
	if mmDeleteRepositoryTag.defaultExpectation != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("Default expectation is already set for the RepositoryI.DeleteRepositoryTag method")
	}

	if len(mmDeleteRepositoryTag.expectations) > 0 {
		mmDeleteRepositoryTag.mock.t.Fatalf("Some expectations are already set for the RepositoryI.DeleteRepositoryTag method")
	}

	mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag = f
	return mmDeleteRepositoryTag.mock
}

// When sets expectation for the RepositoryI.DeleteRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) When(ctx context.Context, s1 string) *RepositoryIMockDeleteRepositoryTagExpectation {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryIMock.DeleteRepositoryTag mock is already set by Set")
	}

	expectation := &RepositoryIMockDeleteRepositoryTagExpectation{
		mock:   mmDeleteRepositoryTag.mock,
		params: &RepositoryIMockDeleteRepositoryTagParams{ctx, s1},
	}
	mmDeleteRepositoryTag.expectations = append(mmDeleteRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.DeleteRepositoryTag return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockDeleteRepositoryTagExpectation) Then(err error) *RepositoryIMock {
	e.results = &RepositoryIMockDeleteRepositoryTagResults{err}
	return e.mock
}

// Times sets number of times RepositoryI.DeleteRepositoryTag should be invoked
func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) Times(n uint64) *mRepositoryIMockDeleteRepositoryTag {
	if n == 0 {
		mmDeleteRepositoryTag.mock.t.Fatalf("Times of RepositoryIMock.DeleteRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteRepositoryTag.expectedInvocations, n)
	return mmDeleteRepositoryTag
}

func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) invocationsDone() bool {
	if len(mmDeleteRepositoryTag.expectations) == 0 && mmDeleteRepositoryTag.defaultExpectation == nil && mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteRepositoryTag.mock.afterDeleteRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteRepositoryTag implements repository.RepositoryI
func (mmDeleteRepositoryTag *RepositoryIMock) DeleteRepositoryTag(ctx context.Context, s1 string) (err error) {
	mm_atomic.AddUint64(&mmDeleteRepositoryTag.beforeDeleteRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteRepositoryTag.afterDeleteRepositoryTagCounter, 1)

	if mmDeleteRepositoryTag.inspectFuncDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.inspectFuncDeleteRepositoryTag(ctx, s1)
	}

	mm_params := RepositoryIMockDeleteRepositoryTagParams{ctx, s1}

	// Record call args
	mmDeleteRepositoryTag.DeleteRepositoryTagMock.mutex.Lock()
	mmDeleteRepositoryTag.DeleteRepositoryTagMock.callArgs = append(mmDeleteRepositoryTag.DeleteRepositoryTagMock.callArgs, &mm_params)
	mmDeleteRepositoryTag.DeleteRepositoryTagMock.mutex.Unlock()

	for _, e := range mmDeleteRepositoryTag.DeleteRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockDeleteRepositoryTagParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteRepositoryTag.t.Errorf("RepositoryIMock.DeleteRepositoryTag got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmDeleteRepositoryTag.t.Errorf("RepositoryIMock.DeleteRepositoryTag got unexpected parameter s1, want: %#v, got: %#v%s\n", *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteRepositoryTag.t.Errorf("RepositoryIMock.DeleteRepositoryTag got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteRepositoryTag.t.Fatal("No results are set for the RepositoryIMock.DeleteRepositoryTag")
		}
		return (*mm_results).err
	}
	if mmDeleteRepositoryTag.funcDeleteRepositoryTag != nil {
		return mmDeleteRepositoryTag.funcDeleteRepositoryTag(ctx, s1)
	}
	mmDeleteRepositoryTag.t.Fatalf("Unexpected call to RepositoryIMock.DeleteRepositoryTag. %v %v", ctx, s1)
	return
}

// DeleteRepositoryTagAfterCounter returns a count of finished RepositoryIMock.DeleteRepositoryTag invocations
func (mmDeleteRepositoryTag *RepositoryIMock) DeleteRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRepositoryTag.afterDeleteRepositoryTagCounter)
}

// DeleteRepositoryTagBeforeCounter returns a count of RepositoryIMock.DeleteRepositoryTag invocations
func (mmDeleteRepositoryTag *RepositoryIMock) DeleteRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRepositoryTag.beforeDeleteRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.DeleteRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteRepositoryTag *mRepositoryIMockDeleteRepositoryTag) Calls() []*RepositoryIMockDeleteRepositoryTagParams {
	mmDeleteRepositoryTag.mutex.RLock()

	argCopy := make([]*RepositoryIMockDeleteRepositoryTagParams, len(mmDeleteRepositoryTag.callArgs))
	copy(argCopy, mmDeleteRepositoryTag.callArgs)

	mmDeleteRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteRepositoryTagDone returns true if the count of the DeleteRepositoryTag invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockDeleteRepositoryTagDone() bool {
	for _, e := range m.DeleteRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteRepositoryTagMock.invocationsDone()
}

// MinimockDeleteRepositoryTagInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockDeleteRepositoryTagInspect() {
	for _, e := range m.DeleteRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteRepositoryTag with params: %#v", *e.params)
		}
	}

	afterDeleteRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterDeleteRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteRepositoryTagMock.defaultExpectation != nil && afterDeleteRepositoryTagCounter < 1 {
		if m.DeleteRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.DeleteRepositoryTag")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.DeleteRepositoryTag with params: %#v", *m.DeleteRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteRepositoryTag != nil && afterDeleteRepositoryTagCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.DeleteRepositoryTag")
	}

	if !m.DeleteRepositoryTagMock.invocationsDone() && afterDeleteRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.DeleteRepositoryTag but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteRepositoryTagMock.expectedInvocations), afterDeleteRepositoryTagCounter)
	}
}

type mRepositoryIMockGetConvertedFileByFileUID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetConvertedFileByFileUIDExpectation
	expectations       []*RepositoryIMockGetConvertedFileByFileUIDExpectation

	callArgs []*RepositoryIMockGetConvertedFileByFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetConvertedFileByFileUIDExpectation specifies expectation struct of the RepositoryI.GetConvertedFileByFileUID
type RepositoryIMockGetConvertedFileByFileUIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetConvertedFileByFileUIDParams
	paramPtrs *RepositoryIMockGetConvertedFileByFileUIDParamPtrs
	results   *RepositoryIMockGetConvertedFileByFileUIDResults
	Counter   uint64
}

// RepositoryIMockGetConvertedFileByFileUIDParams contains parameters of the RepositoryI.GetConvertedFileByFileUID
type RepositoryIMockGetConvertedFileByFileUIDParams struct {
	ctx     context.Context
	fileUID uuid.UUID
}

// RepositoryIMockGetConvertedFileByFileUIDParamPtrs contains pointers to parameters of the RepositoryI.GetConvertedFileByFileUID
type RepositoryIMockGetConvertedFileByFileUIDParamPtrs struct {
	ctx     *context.Context
	fileUID *uuid.UUID
}

// RepositoryIMockGetConvertedFileByFileUIDResults contains results of the RepositoryI.GetConvertedFileByFileUID
type RepositoryIMockGetConvertedFileByFileUIDResults struct {
	cp1 *mm_repository.ConvertedFile
	err error
}

// Expect sets up expected params for RepositoryI.GetConvertedFileByFileUID
func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) Expect(ctx context.Context, fileUID uuid.UUID) *mRepositoryIMockGetConvertedFileByFileUID {
	if mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.GetConvertedFileByFileUID mock is already set by Set")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation == nil {
		mmGetConvertedFileByFileUID.defaultExpectation = &RepositoryIMockGetConvertedFileByFileUIDExpectation{}
	}

	if mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.GetConvertedFileByFileUID mock is already set by ExpectParams functions")
	}

	mmGetConvertedFileByFileUID.defaultExpectation.params = &RepositoryIMockGetConvertedFileByFileUIDParams{ctx, fileUID}
	for _, e := range mmGetConvertedFileByFileUID.expectations {
		if minimock.Equal(e.params, mmGetConvertedFileByFileUID.defaultExpectation.params) {
			mmGetConvertedFileByFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetConvertedFileByFileUID.defaultExpectation.params)
		}
	}

	return mmGetConvertedFileByFileUID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetConvertedFileByFileUID
func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetConvertedFileByFileUID {
	if mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.GetConvertedFileByFileUID mock is already set by Set")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation == nil {
		mmGetConvertedFileByFileUID.defaultExpectation = &RepositoryIMockGetConvertedFileByFileUIDExpectation{}
	}

	if mmGetConvertedFileByFileUID.defaultExpectation.params != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.GetConvertedFileByFileUID mock is already set by Expect")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs = &RepositoryIMockGetConvertedFileByFileUIDParamPtrs{}
	}
	mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetConvertedFileByFileUID
}

// ExpectFileUIDParam2 sets up expected param fileUID for RepositoryI.GetConvertedFileByFileUID
func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) ExpectFileUIDParam2(fileUID uuid.UUID) *mRepositoryIMockGetConvertedFileByFileUID {
	if mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.GetConvertedFileByFileUID mock is already set by Set")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation == nil {
		mmGetConvertedFileByFileUID.defaultExpectation = &RepositoryIMockGetConvertedFileByFileUIDExpectation{}
	}

	if mmGetConvertedFileByFileUID.defaultExpectation.params != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.GetConvertedFileByFileUID mock is already set by Expect")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs = &RepositoryIMockGetConvertedFileByFileUIDParamPtrs{}
	}
	mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs.fileUID = &fileUID

	return mmGetConvertedFileByFileUID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetConvertedFileByFileUID
func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) Inspect(f func(ctx context.Context, fileUID uuid.UUID)) *mRepositoryIMockGetConvertedFileByFileUID {
	if mmGetConvertedFileByFileUID.mock.inspectFuncGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetConvertedFileByFileUID")
	}

	mmGetConvertedFileByFileUID.mock.inspectFuncGetConvertedFileByFileUID = f

	return mmGetConvertedFileByFileUID
}

// Return sets up results that will be returned by RepositoryI.GetConvertedFileByFileUID
func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) Return(cp1 *mm_repository.ConvertedFile, err error) *RepositoryIMock {
	if mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.GetConvertedFileByFileUID mock is already set by Set")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation == nil {
		mmGetConvertedFileByFileUID.defaultExpectation = &RepositoryIMockGetConvertedFileByFileUIDExpectation{mock: mmGetConvertedFileByFileUID.mock}
	}
	mmGetConvertedFileByFileUID.defaultExpectation.results = &RepositoryIMockGetConvertedFileByFileUIDResults{cp1, err}
	return mmGetConvertedFileByFileUID.mock
}

// Set uses given function f to mock the RepositoryI.GetConvertedFileByFileUID method
func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) Set(f func(ctx context.Context, fileUID uuid.UUID) (cp1 *mm_repository.ConvertedFile, err error)) *RepositoryIMock {
	if mmGetConvertedFileByFileUID.defaultExpectation != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetConvertedFileByFileUID method")
	}

	if len(mmGetConvertedFileByFileUID.expectations) > 0 {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetConvertedFileByFileUID method")
	}

	mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID = f
	return mmGetConvertedFileByFileUID.mock
}

// When sets expectation for the RepositoryI.GetConvertedFileByFileUID which will trigger the result defined by the following
// Then helper
func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) When(ctx context.Context, fileUID uuid.UUID) *RepositoryIMockGetConvertedFileByFileUIDExpectation {
	if mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryIMock.GetConvertedFileByFileUID mock is already set by Set")
	}

	expectation := &RepositoryIMockGetConvertedFileByFileUIDExpectation{
		mock:   mmGetConvertedFileByFileUID.mock,
		params: &RepositoryIMockGetConvertedFileByFileUIDParams{ctx, fileUID},
	}
	mmGetConvertedFileByFileUID.expectations = append(mmGetConvertedFileByFileUID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetConvertedFileByFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetConvertedFileByFileUIDExpectation) Then(cp1 *mm_repository.ConvertedFile, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetConvertedFileByFileUIDResults{cp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetConvertedFileByFileUID should be invoked
func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) Times(n uint64) *mRepositoryIMockGetConvertedFileByFileUID {
	if n == 0 {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("Times of RepositoryIMock.GetConvertedFileByFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetConvertedFileByFileUID.expectedInvocations, n)
	return mmGetConvertedFileByFileUID
}

func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) invocationsDone() bool {
	if len(mmGetConvertedFileByFileUID.expectations) == 0 && mmGetConvertedFileByFileUID.defaultExpectation == nil && mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetConvertedFileByFileUID.mock.afterGetConvertedFileByFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetConvertedFileByFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetConvertedFileByFileUID implements repository.RepositoryI
func (mmGetConvertedFileByFileUID *RepositoryIMock) GetConvertedFileByFileUID(ctx context.Context, fileUID uuid.UUID) (cp1 *mm_repository.ConvertedFile, err error) {
	mm_atomic.AddUint64(&mmGetConvertedFileByFileUID.beforeGetConvertedFileByFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetConvertedFileByFileUID.afterGetConvertedFileByFileUIDCounter, 1)

	if mmGetConvertedFileByFileUID.inspectFuncGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.inspectFuncGetConvertedFileByFileUID(ctx, fileUID)
	}

	mm_params := RepositoryIMockGetConvertedFileByFileUIDParams{ctx, fileUID}

	// Record call args
	mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.mutex.Lock()
	mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.callArgs = append(mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.callArgs, &mm_params)
	mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.mutex.Unlock()

	for _, e := range mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetConvertedFileByFileUIDParams{ctx, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetConvertedFileByFileUID.t.Errorf("RepositoryIMock.GetConvertedFileByFileUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmGetConvertedFileByFileUID.t.Errorf("RepositoryIMock.GetConvertedFileByFileUID got unexpected parameter fileUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetConvertedFileByFileUID.t.Errorf("RepositoryIMock.GetConvertedFileByFileUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetConvertedFileByFileUID.t.Fatal("No results are set for the RepositoryIMock.GetConvertedFileByFileUID")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetConvertedFileByFileUID.funcGetConvertedFileByFileUID != nil {
		return mmGetConvertedFileByFileUID.funcGetConvertedFileByFileUID(ctx, fileUID)
	}
	mmGetConvertedFileByFileUID.t.Fatalf("Unexpected call to RepositoryIMock.GetConvertedFileByFileUID. %v %v", ctx, fileUID)
	return
}

// GetConvertedFileByFileUIDAfterCounter returns a count of finished RepositoryIMock.GetConvertedFileByFileUID invocations
func (mmGetConvertedFileByFileUID *RepositoryIMock) GetConvertedFileByFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConvertedFileByFileUID.afterGetConvertedFileByFileUIDCounter)
}

// GetConvertedFileByFileUIDBeforeCounter returns a count of RepositoryIMock.GetConvertedFileByFileUID invocations
func (mmGetConvertedFileByFileUID *RepositoryIMock) GetConvertedFileByFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConvertedFileByFileUID.beforeGetConvertedFileByFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetConvertedFileByFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetConvertedFileByFileUID *mRepositoryIMockGetConvertedFileByFileUID) Calls() []*RepositoryIMockGetConvertedFileByFileUIDParams {
	mmGetConvertedFileByFileUID.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetConvertedFileByFileUIDParams, len(mmGetConvertedFileByFileUID.callArgs))
	copy(argCopy, mmGetConvertedFileByFileUID.callArgs)

	mmGetConvertedFileByFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetConvertedFileByFileUIDDone returns true if the count of the GetConvertedFileByFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetConvertedFileByFileUIDDone() bool {
	for _, e := range m.GetConvertedFileByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetConvertedFileByFileUIDMock.invocationsDone()
}

// MinimockGetConvertedFileByFileUIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetConvertedFileByFileUIDInspect() {
	for _, e := range m.GetConvertedFileByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetConvertedFileByFileUID with params: %#v", *e.params)
		}
	}

	afterGetConvertedFileByFileUIDCounter := mm_atomic.LoadUint64(&m.afterGetConvertedFileByFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetConvertedFileByFileUIDMock.defaultExpectation != nil && afterGetConvertedFileByFileUIDCounter < 1 {
		if m.GetConvertedFileByFileUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetConvertedFileByFileUID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetConvertedFileByFileUID with params: %#v", *m.GetConvertedFileByFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetConvertedFileByFileUID != nil && afterGetConvertedFileByFileUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetConvertedFileByFileUID")
	}

	if !m.GetConvertedFileByFileUIDMock.invocationsDone() && afterGetConvertedFileByFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetConvertedFileByFileUID but found %d calls",
			mm_atomic.LoadUint64(&m.GetConvertedFileByFileUIDMock.expectedInvocations), afterGetConvertedFileByFileUIDCounter)
	}
}

type mRepositoryIMockGetIncompleteFile struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetIncompleteFileExpectation
	expectations       []*RepositoryIMockGetIncompleteFileExpectation

	callArgs []*RepositoryIMockGetIncompleteFileParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetIncompleteFileExpectation specifies expectation struct of the RepositoryI.GetIncompleteFile
type RepositoryIMockGetIncompleteFileExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetIncompleteFileParams
	paramPtrs *RepositoryIMockGetIncompleteFileParamPtrs
	results   *RepositoryIMockGetIncompleteFileResults
	Counter   uint64
}

// RepositoryIMockGetIncompleteFileParams contains parameters of the RepositoryI.GetIncompleteFile
type RepositoryIMockGetIncompleteFileParams struct {
	ctx context.Context
}

// RepositoryIMockGetIncompleteFileParamPtrs contains pointers to parameters of the RepositoryI.GetIncompleteFile
type RepositoryIMockGetIncompleteFileParamPtrs struct {
	ctx *context.Context
}

// RepositoryIMockGetIncompleteFileResults contains results of the RepositoryI.GetIncompleteFile
type RepositoryIMockGetIncompleteFileResults struct {
	ka1 []mm_repository.KnowledgeBaseFile
}

// Expect sets up expected params for RepositoryI.GetIncompleteFile
func (mmGetIncompleteFile *mRepositoryIMockGetIncompleteFile) Expect(ctx context.Context) *mRepositoryIMockGetIncompleteFile {
	if mmGetIncompleteFile.mock.funcGetIncompleteFile != nil {
		mmGetIncompleteFile.mock.t.Fatalf("RepositoryIMock.GetIncompleteFile mock is already set by Set")
	}

	if mmGetIncompleteFile.defaultExpectation == nil {
		mmGetIncompleteFile.defaultExpectation = &RepositoryIMockGetIncompleteFileExpectation{}
	}

	if mmGetIncompleteFile.defaultExpectation.paramPtrs != nil {
		mmGetIncompleteFile.mock.t.Fatalf("RepositoryIMock.GetIncompleteFile mock is already set by ExpectParams functions")
	}

	mmGetIncompleteFile.defaultExpectation.params = &RepositoryIMockGetIncompleteFileParams{ctx}
	for _, e := range mmGetIncompleteFile.expectations {
		if minimock.Equal(e.params, mmGetIncompleteFile.defaultExpectation.params) {
			mmGetIncompleteFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetIncompleteFile.defaultExpectation.params)
		}
	}

	return mmGetIncompleteFile
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetIncompleteFile
func (mmGetIncompleteFile *mRepositoryIMockGetIncompleteFile) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetIncompleteFile {
	if mmGetIncompleteFile.mock.funcGetIncompleteFile != nil {
		mmGetIncompleteFile.mock.t.Fatalf("RepositoryIMock.GetIncompleteFile mock is already set by Set")
	}

	if mmGetIncompleteFile.defaultExpectation == nil {
		mmGetIncompleteFile.defaultExpectation = &RepositoryIMockGetIncompleteFileExpectation{}
	}

	if mmGetIncompleteFile.defaultExpectation.params != nil {
		mmGetIncompleteFile.mock.t.Fatalf("RepositoryIMock.GetIncompleteFile mock is already set by Expect")
	}

	if mmGetIncompleteFile.defaultExpectation.paramPtrs == nil {
		mmGetIncompleteFile.defaultExpectation.paramPtrs = &RepositoryIMockGetIncompleteFileParamPtrs{}
	}
	mmGetIncompleteFile.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetIncompleteFile
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetIncompleteFile
func (mmGetIncompleteFile *mRepositoryIMockGetIncompleteFile) Inspect(f func(ctx context.Context)) *mRepositoryIMockGetIncompleteFile {
	if mmGetIncompleteFile.mock.inspectFuncGetIncompleteFile != nil {
		mmGetIncompleteFile.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetIncompleteFile")
	}

	mmGetIncompleteFile.mock.inspectFuncGetIncompleteFile = f

	return mmGetIncompleteFile
}

// Return sets up results that will be returned by RepositoryI.GetIncompleteFile
func (mmGetIncompleteFile *mRepositoryIMockGetIncompleteFile) Return(ka1 []mm_repository.KnowledgeBaseFile) *RepositoryIMock {
	if mmGetIncompleteFile.mock.funcGetIncompleteFile != nil {
		mmGetIncompleteFile.mock.t.Fatalf("RepositoryIMock.GetIncompleteFile mock is already set by Set")
	}

	if mmGetIncompleteFile.defaultExpectation == nil {
		mmGetIncompleteFile.defaultExpectation = &RepositoryIMockGetIncompleteFileExpectation{mock: mmGetIncompleteFile.mock}
	}
	mmGetIncompleteFile.defaultExpectation.results = &RepositoryIMockGetIncompleteFileResults{ka1}
	return mmGetIncompleteFile.mock
}

// Set uses given function f to mock the RepositoryI.GetIncompleteFile method
func (mmGetIncompleteFile *mRepositoryIMockGetIncompleteFile) Set(f func(ctx context.Context) (ka1 []mm_repository.KnowledgeBaseFile)) *RepositoryIMock {
	if mmGetIncompleteFile.defaultExpectation != nil {
		mmGetIncompleteFile.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetIncompleteFile method")
	}

	if len(mmGetIncompleteFile.expectations) > 0 {
		mmGetIncompleteFile.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetIncompleteFile method")
	}

	mmGetIncompleteFile.mock.funcGetIncompleteFile = f
	return mmGetIncompleteFile.mock
}

// When sets expectation for the RepositoryI.GetIncompleteFile which will trigger the result defined by the following
// Then helper
func (mmGetIncompleteFile *mRepositoryIMockGetIncompleteFile) When(ctx context.Context) *RepositoryIMockGetIncompleteFileExpectation {
	if mmGetIncompleteFile.mock.funcGetIncompleteFile != nil {
		mmGetIncompleteFile.mock.t.Fatalf("RepositoryIMock.GetIncompleteFile mock is already set by Set")
	}

	expectation := &RepositoryIMockGetIncompleteFileExpectation{
		mock:   mmGetIncompleteFile.mock,
		params: &RepositoryIMockGetIncompleteFileParams{ctx},
	}
	mmGetIncompleteFile.expectations = append(mmGetIncompleteFile.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetIncompleteFile return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetIncompleteFileExpectation) Then(ka1 []mm_repository.KnowledgeBaseFile) *RepositoryIMock {
	e.results = &RepositoryIMockGetIncompleteFileResults{ka1}
	return e.mock
}

// Times sets number of times RepositoryI.GetIncompleteFile should be invoked
func (mmGetIncompleteFile *mRepositoryIMockGetIncompleteFile) Times(n uint64) *mRepositoryIMockGetIncompleteFile {
	if n == 0 {
		mmGetIncompleteFile.mock.t.Fatalf("Times of RepositoryIMock.GetIncompleteFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetIncompleteFile.expectedInvocations, n)
	return mmGetIncompleteFile
}

func (mmGetIncompleteFile *mRepositoryIMockGetIncompleteFile) invocationsDone() bool {
	if len(mmGetIncompleteFile.expectations) == 0 && mmGetIncompleteFile.defaultExpectation == nil && mmGetIncompleteFile.mock.funcGetIncompleteFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetIncompleteFile.mock.afterGetIncompleteFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetIncompleteFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetIncompleteFile implements repository.RepositoryI
func (mmGetIncompleteFile *RepositoryIMock) GetIncompleteFile(ctx context.Context) (ka1 []mm_repository.KnowledgeBaseFile) {
	mm_atomic.AddUint64(&mmGetIncompleteFile.beforeGetIncompleteFileCounter, 1)
	defer mm_atomic.AddUint64(&mmGetIncompleteFile.afterGetIncompleteFileCounter, 1)

	if mmGetIncompleteFile.inspectFuncGetIncompleteFile != nil {
		mmGetIncompleteFile.inspectFuncGetIncompleteFile(ctx)
	}

	mm_params := RepositoryIMockGetIncompleteFileParams{ctx}

	// Record call args
	mmGetIncompleteFile.GetIncompleteFileMock.mutex.Lock()
	mmGetIncompleteFile.GetIncompleteFileMock.callArgs = append(mmGetIncompleteFile.GetIncompleteFileMock.callArgs, &mm_params)
	mmGetIncompleteFile.GetIncompleteFileMock.mutex.Unlock()

	for _, e := range mmGetIncompleteFile.GetIncompleteFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1
		}
	}

	if mmGetIncompleteFile.GetIncompleteFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetIncompleteFile.GetIncompleteFileMock.defaultExpectation.Counter, 1)
		mm_want := mmGetIncompleteFile.GetIncompleteFileMock.defaultExpectation.params
		mm_want_ptrs := mmGetIncompleteFile.GetIncompleteFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetIncompleteFileParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetIncompleteFile.t.Errorf("RepositoryIMock.GetIncompleteFile got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetIncompleteFile.t.Errorf("RepositoryIMock.GetIncompleteFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetIncompleteFile.GetIncompleteFileMock.defaultExpectation.results
		if mm_results == nil {
			mmGetIncompleteFile.t.Fatal("No results are set for the RepositoryIMock.GetIncompleteFile")
		}
		return (*mm_results).ka1
	}
	if mmGetIncompleteFile.funcGetIncompleteFile != nil {
		return mmGetIncompleteFile.funcGetIncompleteFile(ctx)
	}
	mmGetIncompleteFile.t.Fatalf("Unexpected call to RepositoryIMock.GetIncompleteFile. %v", ctx)
	return
}

// GetIncompleteFileAfterCounter returns a count of finished RepositoryIMock.GetIncompleteFile invocations
func (mmGetIncompleteFile *RepositoryIMock) GetIncompleteFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetIncompleteFile.afterGetIncompleteFileCounter)
}

// GetIncompleteFileBeforeCounter returns a count of RepositoryIMock.GetIncompleteFile invocations
func (mmGetIncompleteFile *RepositoryIMock) GetIncompleteFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetIncompleteFile.beforeGetIncompleteFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetIncompleteFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetIncompleteFile *mRepositoryIMockGetIncompleteFile) Calls() []*RepositoryIMockGetIncompleteFileParams {
	mmGetIncompleteFile.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetIncompleteFileParams, len(mmGetIncompleteFile.callArgs))
	copy(argCopy, mmGetIncompleteFile.callArgs)

	mmGetIncompleteFile.mutex.RUnlock()

	return argCopy
}

// MinimockGetIncompleteFileDone returns true if the count of the GetIncompleteFile invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetIncompleteFileDone() bool {
	for _, e := range m.GetIncompleteFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetIncompleteFileMock.invocationsDone()
}

// MinimockGetIncompleteFileInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetIncompleteFileInspect() {
	for _, e := range m.GetIncompleteFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetIncompleteFile with params: %#v", *e.params)
		}
	}

	afterGetIncompleteFileCounter := mm_atomic.LoadUint64(&m.afterGetIncompleteFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetIncompleteFileMock.defaultExpectation != nil && afterGetIncompleteFileCounter < 1 {
		if m.GetIncompleteFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetIncompleteFile")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetIncompleteFile with params: %#v", *m.GetIncompleteFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetIncompleteFile != nil && afterGetIncompleteFileCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetIncompleteFile")
	}

	if !m.GetIncompleteFileMock.invocationsDone() && afterGetIncompleteFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetIncompleteFile but found %d calls",
			mm_atomic.LoadUint64(&m.GetIncompleteFileMock.expectedInvocations), afterGetIncompleteFileCounter)
	}
}

type mRepositoryIMockGetKnowledgeBaseByOwnerAndID struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetKnowledgeBaseByOwnerAndIDExpectation
	expectations       []*RepositoryIMockGetKnowledgeBaseByOwnerAndIDExpectation

	callArgs []*RepositoryIMockGetKnowledgeBaseByOwnerAndIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetKnowledgeBaseByOwnerAndIDExpectation specifies expectation struct of the RepositoryI.GetKnowledgeBaseByOwnerAndID
type RepositoryIMockGetKnowledgeBaseByOwnerAndIDExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetKnowledgeBaseByOwnerAndIDParams
	paramPtrs *RepositoryIMockGetKnowledgeBaseByOwnerAndIDParamPtrs
	results   *RepositoryIMockGetKnowledgeBaseByOwnerAndIDResults
	Counter   uint64
}

// RepositoryIMockGetKnowledgeBaseByOwnerAndIDParams contains parameters of the RepositoryI.GetKnowledgeBaseByOwnerAndID
type RepositoryIMockGetKnowledgeBaseByOwnerAndIDParams struct {
	ctx      context.Context
	ownerUID string
	kbID     string
}

// RepositoryIMockGetKnowledgeBaseByOwnerAndIDParamPtrs contains pointers to parameters of the RepositoryI.GetKnowledgeBaseByOwnerAndID
type RepositoryIMockGetKnowledgeBaseByOwnerAndIDParamPtrs struct {
	ctx      *context.Context
	ownerUID *string
	kbID     *string
}

// RepositoryIMockGetKnowledgeBaseByOwnerAndIDResults contains results of the RepositoryI.GetKnowledgeBaseByOwnerAndID
type RepositoryIMockGetKnowledgeBaseByOwnerAndIDResults struct {
	kp1 *mm_repository.KnowledgeBase
	err error
}

// Expect sets up expected params for RepositoryI.GetKnowledgeBaseByOwnerAndID
func (mmGetKnowledgeBaseByOwnerAndID *mRepositoryIMockGetKnowledgeBaseByOwnerAndID) Expect(ctx context.Context, ownerUID string, kbID string) *mRepositoryIMockGetKnowledgeBaseByOwnerAndID {
	if mmGetKnowledgeBaseByOwnerAndID.mock.funcGetKnowledgeBaseByOwnerAndID != nil {
		mmGetKnowledgeBaseByOwnerAndID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByOwnerAndID.defaultExpectation == nil {
		mmGetKnowledgeBaseByOwnerAndID.defaultExpectation = &RepositoryIMockGetKnowledgeBaseByOwnerAndIDExpectation{}
	}

	if mmGetKnowledgeBaseByOwnerAndID.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBaseByOwnerAndID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndID mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBaseByOwnerAndID.defaultExpectation.params = &RepositoryIMockGetKnowledgeBaseByOwnerAndIDParams{ctx, ownerUID, kbID}
	for _, e := range mmGetKnowledgeBaseByOwnerAndID.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBaseByOwnerAndID.defaultExpectation.params) {
			mmGetKnowledgeBaseByOwnerAndID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBaseByOwnerAndID.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBaseByOwnerAndID
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetKnowledgeBaseByOwnerAndID
func (mmGetKnowledgeBaseByOwnerAndID *mRepositoryIMockGetKnowledgeBaseByOwnerAndID) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetKnowledgeBaseByOwnerAndID {
	if mmGetKnowledgeBaseByOwnerAndID.mock.funcGetKnowledgeBaseByOwnerAndID != nil {
		mmGetKnowledgeBaseByOwnerAndID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByOwnerAndID.defaultExpectation == nil {
		mmGetKnowledgeBaseByOwnerAndID.defaultExpectation = &RepositoryIMockGetKnowledgeBaseByOwnerAndIDExpectation{}
	}

	if mmGetKnowledgeBaseByOwnerAndID.defaultExpectation.params != nil {
		mmGetKnowledgeBaseByOwnerAndID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndID mock is already set by Expect")
	}

	if mmGetKnowledgeBaseByOwnerAndID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseByOwnerAndID.defaultExpectation.paramPtrs = &RepositoryIMockGetKnowledgeBaseByOwnerAndIDParamPtrs{}
	}
	mmGetKnowledgeBaseByOwnerAndID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetKnowledgeBaseByOwnerAndID
}

// ExpectOwnerUIDParam2 sets up expected param ownerUID for RepositoryI.GetKnowledgeBaseByOwnerAndID
func (mmGetKnowledgeBaseByOwnerAndID *mRepositoryIMockGetKnowledgeBaseByOwnerAndID) ExpectOwnerUIDParam2(ownerUID string) *mRepositoryIMockGetKnowledgeBaseByOwnerAndID {
	if mmGetKnowledgeBaseByOwnerAndID.mock.funcGetKnowledgeBaseByOwnerAndID != nil {
		mmGetKnowledgeBaseByOwnerAndID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByOwnerAndID.defaultExpectation == nil {
		mmGetKnowledgeBaseByOwnerAndID.defaultExpectation = &RepositoryIMockGetKnowledgeBaseByOwnerAndIDExpectation{}
	}

	if mmGetKnowledgeBaseByOwnerAndID.defaultExpectation.params != nil {
		mmGetKnowledgeBaseByOwnerAndID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndID mock is already set by Expect")
	}

	if mmGetKnowledgeBaseByOwnerAndID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseByOwnerAndID.defaultExpectation.paramPtrs = &RepositoryIMockGetKnowledgeBaseByOwnerAndIDParamPtrs{}
	}
	mmGetKnowledgeBaseByOwnerAndID.defaultExpectation.paramPtrs.ownerUID = &ownerUID

	return mmGetKnowledgeBaseByOwnerAndID
}

// ExpectKbIDParam3 sets up expected param kbID for RepositoryI.GetKnowledgeBaseByOwnerAndID
func (mmGetKnowledgeBaseByOwnerAndID *mRepositoryIMockGetKnowledgeBaseByOwnerAndID) ExpectKbIDParam3(kbID string) *mRepositoryIMockGetKnowledgeBaseByOwnerAndID {
	if mmGetKnowledgeBaseByOwnerAndID.mock.funcGetKnowledgeBaseByOwnerAndID != nil {
		mmGetKnowledgeBaseByOwnerAndID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByOwnerAndID.defaultExpectation == nil {
		mmGetKnowledgeBaseByOwnerAndID.defaultExpectation = &RepositoryIMockGetKnowledgeBaseByOwnerAndIDExpectation{}
	}

	if mmGetKnowledgeBaseByOwnerAndID.defaultExpectation.params != nil {
		mmGetKnowledgeBaseByOwnerAndID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndID mock is already set by Expect")
	}

	if mmGetKnowledgeBaseByOwnerAndID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseByOwnerAndID.defaultExpectation.paramPtrs = &RepositoryIMockGetKnowledgeBaseByOwnerAndIDParamPtrs{}
	}
	mmGetKnowledgeBaseByOwnerAndID.defaultExpectation.paramPtrs.kbID = &kbID

	return mmGetKnowledgeBaseByOwnerAndID
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetKnowledgeBaseByOwnerAndID
func (mmGetKnowledgeBaseByOwnerAndID *mRepositoryIMockGetKnowledgeBaseByOwnerAndID) Inspect(f func(ctx context.Context, ownerUID string, kbID string)) *mRepositoryIMockGetKnowledgeBaseByOwnerAndID {
	if mmGetKnowledgeBaseByOwnerAndID.mock.inspectFuncGetKnowledgeBaseByOwnerAndID != nil {
		mmGetKnowledgeBaseByOwnerAndID.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetKnowledgeBaseByOwnerAndID")
	}

	mmGetKnowledgeBaseByOwnerAndID.mock.inspectFuncGetKnowledgeBaseByOwnerAndID = f

	return mmGetKnowledgeBaseByOwnerAndID
}

// Return sets up results that will be returned by RepositoryI.GetKnowledgeBaseByOwnerAndID
func (mmGetKnowledgeBaseByOwnerAndID *mRepositoryIMockGetKnowledgeBaseByOwnerAndID) Return(kp1 *mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	if mmGetKnowledgeBaseByOwnerAndID.mock.funcGetKnowledgeBaseByOwnerAndID != nil {
		mmGetKnowledgeBaseByOwnerAndID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByOwnerAndID.defaultExpectation == nil {
		mmGetKnowledgeBaseByOwnerAndID.defaultExpectation = &RepositoryIMockGetKnowledgeBaseByOwnerAndIDExpectation{mock: mmGetKnowledgeBaseByOwnerAndID.mock}
	}
	mmGetKnowledgeBaseByOwnerAndID.defaultExpectation.results = &RepositoryIMockGetKnowledgeBaseByOwnerAndIDResults{kp1, err}
	return mmGetKnowledgeBaseByOwnerAndID.mock
}

// Set uses given function f to mock the RepositoryI.GetKnowledgeBaseByOwnerAndID method
func (mmGetKnowledgeBaseByOwnerAndID *mRepositoryIMockGetKnowledgeBaseByOwnerAndID) Set(f func(ctx context.Context, ownerUID string, kbID string) (kp1 *mm_repository.KnowledgeBase, err error)) *RepositoryIMock {
	if mmGetKnowledgeBaseByOwnerAndID.defaultExpectation != nil {
		mmGetKnowledgeBaseByOwnerAndID.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetKnowledgeBaseByOwnerAndID method")
	}

	if len(mmGetKnowledgeBaseByOwnerAndID.expectations) > 0 {
		mmGetKnowledgeBaseByOwnerAndID.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetKnowledgeBaseByOwnerAndID method")
	}

	mmGetKnowledgeBaseByOwnerAndID.mock.funcGetKnowledgeBaseByOwnerAndID = f
	return mmGetKnowledgeBaseByOwnerAndID.mock
}

// When sets expectation for the RepositoryI.GetKnowledgeBaseByOwnerAndID which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBaseByOwnerAndID *mRepositoryIMockGetKnowledgeBaseByOwnerAndID) When(ctx context.Context, ownerUID string, kbID string) *RepositoryIMockGetKnowledgeBaseByOwnerAndIDExpectation {
	if mmGetKnowledgeBaseByOwnerAndID.mock.funcGetKnowledgeBaseByOwnerAndID != nil {
		mmGetKnowledgeBaseByOwnerAndID.mock.t.Fatalf("RepositoryIMock.GetKnowledgeBaseByOwnerAndID mock is already set by Set")
	}

	expectation := &RepositoryIMockGetKnowledgeBaseByOwnerAndIDExpectation{
		mock:   mmGetKnowledgeBaseByOwnerAndID.mock,
		params: &RepositoryIMockGetKnowledgeBaseByOwnerAndIDParams{ctx, ownerUID, kbID},
	}
	mmGetKnowledgeBaseByOwnerAndID.expectations = append(mmGetKnowledgeBaseByOwnerAndID.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetKnowledgeBaseByOwnerAndID return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetKnowledgeBaseByOwnerAndIDExpectation) Then(kp1 *mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetKnowledgeBaseByOwnerAndIDResults{kp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetKnowledgeBaseByOwnerAndID should be invoked
func (mmGetKnowledgeBaseByOwnerAndID *mRepositoryIMockGetKnowledgeBaseByOwnerAndID) Times(n uint64) *mRepositoryIMockGetKnowledgeBaseByOwnerAndID {
	if n == 0 {
		mmGetKnowledgeBaseByOwnerAndID.mock.t.Fatalf("Times of RepositoryIMock.GetKnowledgeBaseByOwnerAndID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBaseByOwnerAndID.expectedInvocations, n)
	return mmGetKnowledgeBaseByOwnerAndID
}

func (mmGetKnowledgeBaseByOwnerAndID *mRepositoryIMockGetKnowledgeBaseByOwnerAndID) invocationsDone() bool {
	if len(mmGetKnowledgeBaseByOwnerAndID.expectations) == 0 && mmGetKnowledgeBaseByOwnerAndID.defaultExpectation == nil && mmGetKnowledgeBaseByOwnerAndID.mock.funcGetKnowledgeBaseByOwnerAndID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseByOwnerAndID.mock.afterGetKnowledgeBaseByOwnerAndIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseByOwnerAndID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBaseByOwnerAndID implements repository.RepositoryI
func (mmGetKnowledgeBaseByOwnerAndID *RepositoryIMock) GetKnowledgeBaseByOwnerAndID(ctx context.Context, ownerUID string, kbID string) (kp1 *mm_repository.KnowledgeBase, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBaseByOwnerAndID.beforeGetKnowledgeBaseByOwnerAndIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBaseByOwnerAndID.afterGetKnowledgeBaseByOwnerAndIDCounter, 1)

	if mmGetKnowledgeBaseByOwnerAndID.inspectFuncGetKnowledgeBaseByOwnerAndID != nil {
		mmGetKnowledgeBaseByOwnerAndID.inspectFuncGetKnowledgeBaseByOwnerAndID(ctx, ownerUID, kbID)
	}

	mm_params := RepositoryIMockGetKnowledgeBaseByOwnerAndIDParams{ctx, ownerUID, kbID}

	// Record call args
	mmGetKnowledgeBaseByOwnerAndID.GetKnowledgeBaseByOwnerAndIDMock.mutex.Lock()
	mmGetKnowledgeBaseByOwnerAndID.GetKnowledgeBaseByOwnerAndIDMock.callArgs = append(mmGetKnowledgeBaseByOwnerAndID.GetKnowledgeBaseByOwnerAndIDMock.callArgs, &mm_params)
	mmGetKnowledgeBaseByOwnerAndID.GetKnowledgeBaseByOwnerAndIDMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBaseByOwnerAndID.GetKnowledgeBaseByOwnerAndIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmGetKnowledgeBaseByOwnerAndID.GetKnowledgeBaseByOwnerAndIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBaseByOwnerAndID.GetKnowledgeBaseByOwnerAndIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBaseByOwnerAndID.GetKnowledgeBaseByOwnerAndIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBaseByOwnerAndID.GetKnowledgeBaseByOwnerAndIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetKnowledgeBaseByOwnerAndIDParams{ctx, ownerUID, kbID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBaseByOwnerAndID.t.Errorf("RepositoryIMock.GetKnowledgeBaseByOwnerAndID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmGetKnowledgeBaseByOwnerAndID.t.Errorf("RepositoryIMock.GetKnowledgeBaseByOwnerAndID got unexpected parameter ownerUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

			if mm_want_ptrs.kbID != nil && !minimock.Equal(*mm_want_ptrs.kbID, mm_got.kbID) {
				mmGetKnowledgeBaseByOwnerAndID.t.Errorf("RepositoryIMock.GetKnowledgeBaseByOwnerAndID got unexpected parameter kbID, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbID, mm_got.kbID, minimock.Diff(*mm_want_ptrs.kbID, mm_got.kbID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBaseByOwnerAndID.t.Errorf("RepositoryIMock.GetKnowledgeBaseByOwnerAndID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBaseByOwnerAndID.GetKnowledgeBaseByOwnerAndIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBaseByOwnerAndID.t.Fatal("No results are set for the RepositoryIMock.GetKnowledgeBaseByOwnerAndID")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmGetKnowledgeBaseByOwnerAndID.funcGetKnowledgeBaseByOwnerAndID != nil {
		return mmGetKnowledgeBaseByOwnerAndID.funcGetKnowledgeBaseByOwnerAndID(ctx, ownerUID, kbID)
	}
	mmGetKnowledgeBaseByOwnerAndID.t.Fatalf("Unexpected call to RepositoryIMock.GetKnowledgeBaseByOwnerAndID. %v %v %v", ctx, ownerUID, kbID)
	return
}

// GetKnowledgeBaseByOwnerAndIDAfterCounter returns a count of finished RepositoryIMock.GetKnowledgeBaseByOwnerAndID invocations
func (mmGetKnowledgeBaseByOwnerAndID *RepositoryIMock) GetKnowledgeBaseByOwnerAndIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseByOwnerAndID.afterGetKnowledgeBaseByOwnerAndIDCounter)
}

// GetKnowledgeBaseByOwnerAndIDBeforeCounter returns a count of RepositoryIMock.GetKnowledgeBaseByOwnerAndID invocations
func (mmGetKnowledgeBaseByOwnerAndID *RepositoryIMock) GetKnowledgeBaseByOwnerAndIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseByOwnerAndID.beforeGetKnowledgeBaseByOwnerAndIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetKnowledgeBaseByOwnerAndID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBaseByOwnerAndID *mRepositoryIMockGetKnowledgeBaseByOwnerAndID) Calls() []*RepositoryIMockGetKnowledgeBaseByOwnerAndIDParams {
	mmGetKnowledgeBaseByOwnerAndID.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetKnowledgeBaseByOwnerAndIDParams, len(mmGetKnowledgeBaseByOwnerAndID.callArgs))
	copy(argCopy, mmGetKnowledgeBaseByOwnerAndID.callArgs)

	mmGetKnowledgeBaseByOwnerAndID.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBaseByOwnerAndIDDone returns true if the count of the GetKnowledgeBaseByOwnerAndID invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetKnowledgeBaseByOwnerAndIDDone() bool {
	for _, e := range m.GetKnowledgeBaseByOwnerAndIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBaseByOwnerAndIDMock.invocationsDone()
}

// MinimockGetKnowledgeBaseByOwnerAndIDInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetKnowledgeBaseByOwnerAndIDInspect() {
	for _, e := range m.GetKnowledgeBaseByOwnerAndIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetKnowledgeBaseByOwnerAndID with params: %#v", *e.params)
		}
	}

	afterGetKnowledgeBaseByOwnerAndIDCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBaseByOwnerAndIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBaseByOwnerAndIDMock.defaultExpectation != nil && afterGetKnowledgeBaseByOwnerAndIDCounter < 1 {
		if m.GetKnowledgeBaseByOwnerAndIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetKnowledgeBaseByOwnerAndID")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetKnowledgeBaseByOwnerAndID with params: %#v", *m.GetKnowledgeBaseByOwnerAndIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBaseByOwnerAndID != nil && afterGetKnowledgeBaseByOwnerAndIDCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetKnowledgeBaseByOwnerAndID")
	}

	if !m.GetKnowledgeBaseByOwnerAndIDMock.invocationsDone() && afterGetKnowledgeBaseByOwnerAndIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetKnowledgeBaseByOwnerAndID but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBaseByOwnerAndIDMock.expectedInvocations), afterGetKnowledgeBaseByOwnerAndIDCounter)
	}
}

type mRepositoryIMockGetRepositoryTag struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetRepositoryTagExpectation
	expectations       []*RepositoryIMockGetRepositoryTagExpectation

	callArgs []*RepositoryIMockGetRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetRepositoryTagExpectation specifies expectation struct of the RepositoryI.GetRepositoryTag
type RepositoryIMockGetRepositoryTagExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetRepositoryTagParams
	paramPtrs *RepositoryIMockGetRepositoryTagParamPtrs
	results   *RepositoryIMockGetRepositoryTagResults
	Counter   uint64
}

// RepositoryIMockGetRepositoryTagParams contains parameters of the RepositoryI.GetRepositoryTag
type RepositoryIMockGetRepositoryTagParams struct {
	ctx context.Context
	r1  utils.RepositoryTagName
}

// RepositoryIMockGetRepositoryTagParamPtrs contains pointers to parameters of the RepositoryI.GetRepositoryTag
type RepositoryIMockGetRepositoryTagParamPtrs struct {
	ctx *context.Context
	r1  *utils.RepositoryTagName
}

// RepositoryIMockGetRepositoryTagResults contains results of the RepositoryI.GetRepositoryTag
type RepositoryIMockGetRepositoryTagResults struct {
	rp1 *pb.RepositoryTag
	err error
}

// Expect sets up expected params for RepositoryI.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) Expect(ctx context.Context, r1 utils.RepositoryTagName) *mRepositoryIMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryIMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by ExpectParams functions")
	}

	mmGetRepositoryTag.defaultExpectation.params = &RepositoryIMockGetRepositoryTagParams{ctx, r1}
	for _, e := range mmGetRepositoryTag.expectations {
		if minimock.Equal(e.params, mmGetRepositoryTag.defaultExpectation.params) {
			mmGetRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRepositoryTag.defaultExpectation.params)
		}
	}

	return mmGetRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryIMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.params != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by Expect")
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmGetRepositoryTag.defaultExpectation.paramPtrs = &RepositoryIMockGetRepositoryTagParamPtrs{}
	}
	mmGetRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetRepositoryTag
}

// ExpectR1Param2 sets up expected param r1 for RepositoryI.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) ExpectR1Param2(r1 utils.RepositoryTagName) *mRepositoryIMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryIMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.params != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by Expect")
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmGetRepositoryTag.defaultExpectation.paramPtrs = &RepositoryIMockGetRepositoryTagParamPtrs{}
	}
	mmGetRepositoryTag.defaultExpectation.paramPtrs.r1 = &r1

	return mmGetRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) Inspect(f func(ctx context.Context, r1 utils.RepositoryTagName)) *mRepositoryIMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.inspectFuncGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetRepositoryTag")
	}

	mmGetRepositoryTag.mock.inspectFuncGetRepositoryTag = f

	return mmGetRepositoryTag
}

// Return sets up results that will be returned by RepositoryI.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) Return(rp1 *pb.RepositoryTag, err error) *RepositoryIMock {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryIMockGetRepositoryTagExpectation{mock: mmGetRepositoryTag.mock}
	}
	mmGetRepositoryTag.defaultExpectation.results = &RepositoryIMockGetRepositoryTagResults{rp1, err}
	return mmGetRepositoryTag.mock
}

// Set uses given function f to mock the RepositoryI.GetRepositoryTag method
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) Set(f func(ctx context.Context, r1 utils.RepositoryTagName) (rp1 *pb.RepositoryTag, err error)) *RepositoryIMock {
	if mmGetRepositoryTag.defaultExpectation != nil {
		mmGetRepositoryTag.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetRepositoryTag method")
	}

	if len(mmGetRepositoryTag.expectations) > 0 {
		mmGetRepositoryTag.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetRepositoryTag method")
	}

	mmGetRepositoryTag.mock.funcGetRepositoryTag = f
	return mmGetRepositoryTag.mock
}

// When sets expectation for the RepositoryI.GetRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) When(ctx context.Context, r1 utils.RepositoryTagName) *RepositoryIMockGetRepositoryTagExpectation {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryIMock.GetRepositoryTag mock is already set by Set")
	}

	expectation := &RepositoryIMockGetRepositoryTagExpectation{
		mock:   mmGetRepositoryTag.mock,
		params: &RepositoryIMockGetRepositoryTagParams{ctx, r1},
	}
	mmGetRepositoryTag.expectations = append(mmGetRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetRepositoryTag return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetRepositoryTagExpectation) Then(rp1 *pb.RepositoryTag, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetRepositoryTagResults{rp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetRepositoryTag should be invoked
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) Times(n uint64) *mRepositoryIMockGetRepositoryTag {
	if n == 0 {
		mmGetRepositoryTag.mock.t.Fatalf("Times of RepositoryIMock.GetRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRepositoryTag.expectedInvocations, n)
	return mmGetRepositoryTag
}

func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) invocationsDone() bool {
	if len(mmGetRepositoryTag.expectations) == 0 && mmGetRepositoryTag.defaultExpectation == nil && mmGetRepositoryTag.mock.funcGetRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRepositoryTag.mock.afterGetRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRepositoryTag implements repository.RepositoryI
func (mmGetRepositoryTag *RepositoryIMock) GetRepositoryTag(ctx context.Context, r1 utils.RepositoryTagName) (rp1 *pb.RepositoryTag, err error) {
	mm_atomic.AddUint64(&mmGetRepositoryTag.beforeGetRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRepositoryTag.afterGetRepositoryTagCounter, 1)

	if mmGetRepositoryTag.inspectFuncGetRepositoryTag != nil {
		mmGetRepositoryTag.inspectFuncGetRepositoryTag(ctx, r1)
	}

	mm_params := RepositoryIMockGetRepositoryTagParams{ctx, r1}

	// Record call args
	mmGetRepositoryTag.GetRepositoryTagMock.mutex.Lock()
	mmGetRepositoryTag.GetRepositoryTagMock.callArgs = append(mmGetRepositoryTag.GetRepositoryTagMock.callArgs, &mm_params)
	mmGetRepositoryTag.GetRepositoryTagMock.mutex.Unlock()

	for _, e := range mmGetRepositoryTag.GetRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetRepositoryTagParams{ctx, r1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetRepositoryTag.t.Errorf("RepositoryIMock.GetRepositoryTag got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.r1 != nil && !minimock.Equal(*mm_want_ptrs.r1, mm_got.r1) {
				mmGetRepositoryTag.t.Errorf("RepositoryIMock.GetRepositoryTag got unexpected parameter r1, want: %#v, got: %#v%s\n", *mm_want_ptrs.r1, mm_got.r1, minimock.Diff(*mm_want_ptrs.r1, mm_got.r1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRepositoryTag.t.Errorf("RepositoryIMock.GetRepositoryTag got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRepositoryTag.t.Fatal("No results are set for the RepositoryIMock.GetRepositoryTag")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmGetRepositoryTag.funcGetRepositoryTag != nil {
		return mmGetRepositoryTag.funcGetRepositoryTag(ctx, r1)
	}
	mmGetRepositoryTag.t.Fatalf("Unexpected call to RepositoryIMock.GetRepositoryTag. %v %v", ctx, r1)
	return
}

// GetRepositoryTagAfterCounter returns a count of finished RepositoryIMock.GetRepositoryTag invocations
func (mmGetRepositoryTag *RepositoryIMock) GetRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRepositoryTag.afterGetRepositoryTagCounter)
}

// GetRepositoryTagBeforeCounter returns a count of RepositoryIMock.GetRepositoryTag invocations
func (mmGetRepositoryTag *RepositoryIMock) GetRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRepositoryTag.beforeGetRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRepositoryTag *mRepositoryIMockGetRepositoryTag) Calls() []*RepositoryIMockGetRepositoryTagParams {
	mmGetRepositoryTag.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetRepositoryTagParams, len(mmGetRepositoryTag.callArgs))
	copy(argCopy, mmGetRepositoryTag.callArgs)

	mmGetRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockGetRepositoryTagDone returns true if the count of the GetRepositoryTag invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetRepositoryTagDone() bool {
	for _, e := range m.GetRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRepositoryTagMock.invocationsDone()
}

// MinimockGetRepositoryTagInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetRepositoryTagInspect() {
	for _, e := range m.GetRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetRepositoryTag with params: %#v", *e.params)
		}
	}

	afterGetRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterGetRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRepositoryTagMock.defaultExpectation != nil && afterGetRepositoryTagCounter < 1 {
		if m.GetRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetRepositoryTag")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetRepositoryTag with params: %#v", *m.GetRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRepositoryTag != nil && afterGetRepositoryTagCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetRepositoryTag")
	}

	if !m.GetRepositoryTagMock.invocationsDone() && afterGetRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetRepositoryTag but found %d calls",
			mm_atomic.LoadUint64(&m.GetRepositoryTagMock.expectedInvocations), afterGetRepositoryTagCounter)
	}
}

type mRepositoryIMockGetTextChunksBySource struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockGetTextChunksBySourceExpectation
	expectations       []*RepositoryIMockGetTextChunksBySourceExpectation

	callArgs []*RepositoryIMockGetTextChunksBySourceParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockGetTextChunksBySourceExpectation specifies expectation struct of the RepositoryI.GetTextChunksBySource
type RepositoryIMockGetTextChunksBySourceExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockGetTextChunksBySourceParams
	paramPtrs *RepositoryIMockGetTextChunksBySourceParamPtrs
	results   *RepositoryIMockGetTextChunksBySourceResults
	Counter   uint64
}

// RepositoryIMockGetTextChunksBySourceParams contains parameters of the RepositoryI.GetTextChunksBySource
type RepositoryIMockGetTextChunksBySourceParams struct {
	ctx         context.Context
	sourceTable string
	sourceUID   uuid.UUID
}

// RepositoryIMockGetTextChunksBySourceParamPtrs contains pointers to parameters of the RepositoryI.GetTextChunksBySource
type RepositoryIMockGetTextChunksBySourceParamPtrs struct {
	ctx         *context.Context
	sourceTable *string
	sourceUID   *uuid.UUID
}

// RepositoryIMockGetTextChunksBySourceResults contains results of the RepositoryI.GetTextChunksBySource
type RepositoryIMockGetTextChunksBySourceResults struct {
	ta1 []mm_repository.TextChunk
	err error
}

// Expect sets up expected params for RepositoryI.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) Expect(ctx context.Context, sourceTable string, sourceUID uuid.UUID) *mRepositoryIMockGetTextChunksBySource {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by Set")
	}

	if mmGetTextChunksBySource.defaultExpectation == nil {
		mmGetTextChunksBySource.defaultExpectation = &RepositoryIMockGetTextChunksBySourceExpectation{}
	}

	if mmGetTextChunksBySource.defaultExpectation.paramPtrs != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by ExpectParams functions")
	}

	mmGetTextChunksBySource.defaultExpectation.params = &RepositoryIMockGetTextChunksBySourceParams{ctx, sourceTable, sourceUID}
	for _, e := range mmGetTextChunksBySource.expectations {
		if minimock.Equal(e.params, mmGetTextChunksBySource.defaultExpectation.params) {
			mmGetTextChunksBySource.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTextChunksBySource.defaultExpectation.params)
		}
	}

	return mmGetTextChunksBySource
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockGetTextChunksBySource {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by Set")
	}

	if mmGetTextChunksBySource.defaultExpectation == nil {
		mmGetTextChunksBySource.defaultExpectation = &RepositoryIMockGetTextChunksBySourceExpectation{}
	}

	if mmGetTextChunksBySource.defaultExpectation.params != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by Expect")
	}

	if mmGetTextChunksBySource.defaultExpectation.paramPtrs == nil {
		mmGetTextChunksBySource.defaultExpectation.paramPtrs = &RepositoryIMockGetTextChunksBySourceParamPtrs{}
	}
	mmGetTextChunksBySource.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetTextChunksBySource
}

// ExpectSourceTableParam2 sets up expected param sourceTable for RepositoryI.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) ExpectSourceTableParam2(sourceTable string) *mRepositoryIMockGetTextChunksBySource {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by Set")
	}

	if mmGetTextChunksBySource.defaultExpectation == nil {
		mmGetTextChunksBySource.defaultExpectation = &RepositoryIMockGetTextChunksBySourceExpectation{}
	}

	if mmGetTextChunksBySource.defaultExpectation.params != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by Expect")
	}

	if mmGetTextChunksBySource.defaultExpectation.paramPtrs == nil {
		mmGetTextChunksBySource.defaultExpectation.paramPtrs = &RepositoryIMockGetTextChunksBySourceParamPtrs{}
	}
	mmGetTextChunksBySource.defaultExpectation.paramPtrs.sourceTable = &sourceTable

	return mmGetTextChunksBySource
}

// ExpectSourceUIDParam3 sets up expected param sourceUID for RepositoryI.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) ExpectSourceUIDParam3(sourceUID uuid.UUID) *mRepositoryIMockGetTextChunksBySource {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by Set")
	}

	if mmGetTextChunksBySource.defaultExpectation == nil {
		mmGetTextChunksBySource.defaultExpectation = &RepositoryIMockGetTextChunksBySourceExpectation{}
	}

	if mmGetTextChunksBySource.defaultExpectation.params != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by Expect")
	}

	if mmGetTextChunksBySource.defaultExpectation.paramPtrs == nil {
		mmGetTextChunksBySource.defaultExpectation.paramPtrs = &RepositoryIMockGetTextChunksBySourceParamPtrs{}
	}
	mmGetTextChunksBySource.defaultExpectation.paramPtrs.sourceUID = &sourceUID

	return mmGetTextChunksBySource
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) Inspect(f func(ctx context.Context, sourceTable string, sourceUID uuid.UUID)) *mRepositoryIMockGetTextChunksBySource {
	if mmGetTextChunksBySource.mock.inspectFuncGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.GetTextChunksBySource")
	}

	mmGetTextChunksBySource.mock.inspectFuncGetTextChunksBySource = f

	return mmGetTextChunksBySource
}

// Return sets up results that will be returned by RepositoryI.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) Return(ta1 []mm_repository.TextChunk, err error) *RepositoryIMock {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by Set")
	}

	if mmGetTextChunksBySource.defaultExpectation == nil {
		mmGetTextChunksBySource.defaultExpectation = &RepositoryIMockGetTextChunksBySourceExpectation{mock: mmGetTextChunksBySource.mock}
	}
	mmGetTextChunksBySource.defaultExpectation.results = &RepositoryIMockGetTextChunksBySourceResults{ta1, err}
	return mmGetTextChunksBySource.mock
}

// Set uses given function f to mock the RepositoryI.GetTextChunksBySource method
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) Set(f func(ctx context.Context, sourceTable string, sourceUID uuid.UUID) (ta1 []mm_repository.TextChunk, err error)) *RepositoryIMock {
	if mmGetTextChunksBySource.defaultExpectation != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("Default expectation is already set for the RepositoryI.GetTextChunksBySource method")
	}

	if len(mmGetTextChunksBySource.expectations) > 0 {
		mmGetTextChunksBySource.mock.t.Fatalf("Some expectations are already set for the RepositoryI.GetTextChunksBySource method")
	}

	mmGetTextChunksBySource.mock.funcGetTextChunksBySource = f
	return mmGetTextChunksBySource.mock
}

// When sets expectation for the RepositoryI.GetTextChunksBySource which will trigger the result defined by the following
// Then helper
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) When(ctx context.Context, sourceTable string, sourceUID uuid.UUID) *RepositoryIMockGetTextChunksBySourceExpectation {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryIMock.GetTextChunksBySource mock is already set by Set")
	}

	expectation := &RepositoryIMockGetTextChunksBySourceExpectation{
		mock:   mmGetTextChunksBySource.mock,
		params: &RepositoryIMockGetTextChunksBySourceParams{ctx, sourceTable, sourceUID},
	}
	mmGetTextChunksBySource.expectations = append(mmGetTextChunksBySource.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.GetTextChunksBySource return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockGetTextChunksBySourceExpectation) Then(ta1 []mm_repository.TextChunk, err error) *RepositoryIMock {
	e.results = &RepositoryIMockGetTextChunksBySourceResults{ta1, err}
	return e.mock
}

// Times sets number of times RepositoryI.GetTextChunksBySource should be invoked
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) Times(n uint64) *mRepositoryIMockGetTextChunksBySource {
	if n == 0 {
		mmGetTextChunksBySource.mock.t.Fatalf("Times of RepositoryIMock.GetTextChunksBySource mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTextChunksBySource.expectedInvocations, n)
	return mmGetTextChunksBySource
}

func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) invocationsDone() bool {
	if len(mmGetTextChunksBySource.expectations) == 0 && mmGetTextChunksBySource.defaultExpectation == nil && mmGetTextChunksBySource.mock.funcGetTextChunksBySource == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTextChunksBySource.mock.afterGetTextChunksBySourceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTextChunksBySource.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTextChunksBySource implements repository.RepositoryI
func (mmGetTextChunksBySource *RepositoryIMock) GetTextChunksBySource(ctx context.Context, sourceTable string, sourceUID uuid.UUID) (ta1 []mm_repository.TextChunk, err error) {
	mm_atomic.AddUint64(&mmGetTextChunksBySource.beforeGetTextChunksBySourceCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTextChunksBySource.afterGetTextChunksBySourceCounter, 1)

	if mmGetTextChunksBySource.inspectFuncGetTextChunksBySource != nil {
		mmGetTextChunksBySource.inspectFuncGetTextChunksBySource(ctx, sourceTable, sourceUID)
	}

	mm_params := RepositoryIMockGetTextChunksBySourceParams{ctx, sourceTable, sourceUID}

	// Record call args
	mmGetTextChunksBySource.GetTextChunksBySourceMock.mutex.Lock()
	mmGetTextChunksBySource.GetTextChunksBySourceMock.callArgs = append(mmGetTextChunksBySource.GetTextChunksBySourceMock.callArgs, &mm_params)
	mmGetTextChunksBySource.GetTextChunksBySourceMock.mutex.Unlock()

	for _, e := range mmGetTextChunksBySource.GetTextChunksBySourceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ta1, e.results.err
		}
	}

	if mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation.params
		mm_want_ptrs := mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockGetTextChunksBySourceParams{ctx, sourceTable, sourceUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTextChunksBySource.t.Errorf("RepositoryIMock.GetTextChunksBySource got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sourceTable != nil && !minimock.Equal(*mm_want_ptrs.sourceTable, mm_got.sourceTable) {
				mmGetTextChunksBySource.t.Errorf("RepositoryIMock.GetTextChunksBySource got unexpected parameter sourceTable, want: %#v, got: %#v%s\n", *mm_want_ptrs.sourceTable, mm_got.sourceTable, minimock.Diff(*mm_want_ptrs.sourceTable, mm_got.sourceTable))
			}

			if mm_want_ptrs.sourceUID != nil && !minimock.Equal(*mm_want_ptrs.sourceUID, mm_got.sourceUID) {
				mmGetTextChunksBySource.t.Errorf("RepositoryIMock.GetTextChunksBySource got unexpected parameter sourceUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.sourceUID, mm_got.sourceUID, minimock.Diff(*mm_want_ptrs.sourceUID, mm_got.sourceUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTextChunksBySource.t.Errorf("RepositoryIMock.GetTextChunksBySource got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTextChunksBySource.t.Fatal("No results are set for the RepositoryIMock.GetTextChunksBySource")
		}
		return (*mm_results).ta1, (*mm_results).err
	}
	if mmGetTextChunksBySource.funcGetTextChunksBySource != nil {
		return mmGetTextChunksBySource.funcGetTextChunksBySource(ctx, sourceTable, sourceUID)
	}
	mmGetTextChunksBySource.t.Fatalf("Unexpected call to RepositoryIMock.GetTextChunksBySource. %v %v %v", ctx, sourceTable, sourceUID)
	return
}

// GetTextChunksBySourceAfterCounter returns a count of finished RepositoryIMock.GetTextChunksBySource invocations
func (mmGetTextChunksBySource *RepositoryIMock) GetTextChunksBySourceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTextChunksBySource.afterGetTextChunksBySourceCounter)
}

// GetTextChunksBySourceBeforeCounter returns a count of RepositoryIMock.GetTextChunksBySource invocations
func (mmGetTextChunksBySource *RepositoryIMock) GetTextChunksBySourceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTextChunksBySource.beforeGetTextChunksBySourceCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.GetTextChunksBySource.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTextChunksBySource *mRepositoryIMockGetTextChunksBySource) Calls() []*RepositoryIMockGetTextChunksBySourceParams {
	mmGetTextChunksBySource.mutex.RLock()

	argCopy := make([]*RepositoryIMockGetTextChunksBySourceParams, len(mmGetTextChunksBySource.callArgs))
	copy(argCopy, mmGetTextChunksBySource.callArgs)

	mmGetTextChunksBySource.mutex.RUnlock()

	return argCopy
}

// MinimockGetTextChunksBySourceDone returns true if the count of the GetTextChunksBySource invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockGetTextChunksBySourceDone() bool {
	for _, e := range m.GetTextChunksBySourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTextChunksBySourceMock.invocationsDone()
}

// MinimockGetTextChunksBySourceInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockGetTextChunksBySourceInspect() {
	for _, e := range m.GetTextChunksBySourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.GetTextChunksBySource with params: %#v", *e.params)
		}
	}

	afterGetTextChunksBySourceCounter := mm_atomic.LoadUint64(&m.afterGetTextChunksBySourceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTextChunksBySourceMock.defaultExpectation != nil && afterGetTextChunksBySourceCounter < 1 {
		if m.GetTextChunksBySourceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.GetTextChunksBySource")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.GetTextChunksBySource with params: %#v", *m.GetTextChunksBySourceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTextChunksBySource != nil && afterGetTextChunksBySourceCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.GetTextChunksBySource")
	}

	if !m.GetTextChunksBySourceMock.invocationsDone() && afterGetTextChunksBySourceCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.GetTextChunksBySource but found %d calls",
			mm_atomic.LoadUint64(&m.GetTextChunksBySourceMock.expectedInvocations), afterGetTextChunksBySourceCounter)
	}
}

type mRepositoryIMockKnowledgeBaseFileTableName struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockKnowledgeBaseFileTableNameExpectation
	expectations       []*RepositoryIMockKnowledgeBaseFileTableNameExpectation

	expectedInvocations uint64
}

// RepositoryIMockKnowledgeBaseFileTableNameExpectation specifies expectation struct of the RepositoryI.KnowledgeBaseFileTableName
type RepositoryIMockKnowledgeBaseFileTableNameExpectation struct {
	mock *RepositoryIMock

	results *RepositoryIMockKnowledgeBaseFileTableNameResults
	Counter uint64
}

// RepositoryIMockKnowledgeBaseFileTableNameResults contains results of the RepositoryI.KnowledgeBaseFileTableName
type RepositoryIMockKnowledgeBaseFileTableNameResults struct {
	s1 string
}

// Expect sets up expected params for RepositoryI.KnowledgeBaseFileTableName
func (mmKnowledgeBaseFileTableName *mRepositoryIMockKnowledgeBaseFileTableName) Expect() *mRepositoryIMockKnowledgeBaseFileTableName {
	if mmKnowledgeBaseFileTableName.mock.funcKnowledgeBaseFileTableName != nil {
		mmKnowledgeBaseFileTableName.mock.t.Fatalf("RepositoryIMock.KnowledgeBaseFileTableName mock is already set by Set")
	}

	if mmKnowledgeBaseFileTableName.defaultExpectation == nil {
		mmKnowledgeBaseFileTableName.defaultExpectation = &RepositoryIMockKnowledgeBaseFileTableNameExpectation{}
	}

	return mmKnowledgeBaseFileTableName
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.KnowledgeBaseFileTableName
func (mmKnowledgeBaseFileTableName *mRepositoryIMockKnowledgeBaseFileTableName) Inspect(f func()) *mRepositoryIMockKnowledgeBaseFileTableName {
	if mmKnowledgeBaseFileTableName.mock.inspectFuncKnowledgeBaseFileTableName != nil {
		mmKnowledgeBaseFileTableName.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.KnowledgeBaseFileTableName")
	}

	mmKnowledgeBaseFileTableName.mock.inspectFuncKnowledgeBaseFileTableName = f

	return mmKnowledgeBaseFileTableName
}

// Return sets up results that will be returned by RepositoryI.KnowledgeBaseFileTableName
func (mmKnowledgeBaseFileTableName *mRepositoryIMockKnowledgeBaseFileTableName) Return(s1 string) *RepositoryIMock {
	if mmKnowledgeBaseFileTableName.mock.funcKnowledgeBaseFileTableName != nil {
		mmKnowledgeBaseFileTableName.mock.t.Fatalf("RepositoryIMock.KnowledgeBaseFileTableName mock is already set by Set")
	}

	if mmKnowledgeBaseFileTableName.defaultExpectation == nil {
		mmKnowledgeBaseFileTableName.defaultExpectation = &RepositoryIMockKnowledgeBaseFileTableNameExpectation{mock: mmKnowledgeBaseFileTableName.mock}
	}
	mmKnowledgeBaseFileTableName.defaultExpectation.results = &RepositoryIMockKnowledgeBaseFileTableNameResults{s1}
	return mmKnowledgeBaseFileTableName.mock
}

// Set uses given function f to mock the RepositoryI.KnowledgeBaseFileTableName method
func (mmKnowledgeBaseFileTableName *mRepositoryIMockKnowledgeBaseFileTableName) Set(f func() (s1 string)) *RepositoryIMock {
	if mmKnowledgeBaseFileTableName.defaultExpectation != nil {
		mmKnowledgeBaseFileTableName.mock.t.Fatalf("Default expectation is already set for the RepositoryI.KnowledgeBaseFileTableName method")
	}

	if len(mmKnowledgeBaseFileTableName.expectations) > 0 {
		mmKnowledgeBaseFileTableName.mock.t.Fatalf("Some expectations are already set for the RepositoryI.KnowledgeBaseFileTableName method")
	}

	mmKnowledgeBaseFileTableName.mock.funcKnowledgeBaseFileTableName = f
	return mmKnowledgeBaseFileTableName.mock
}

// Times sets number of times RepositoryI.KnowledgeBaseFileTableName should be invoked
func (mmKnowledgeBaseFileTableName *mRepositoryIMockKnowledgeBaseFileTableName) Times(n uint64) *mRepositoryIMockKnowledgeBaseFileTableName {
	if n == 0 {
		mmKnowledgeBaseFileTableName.mock.t.Fatalf("Times of RepositoryIMock.KnowledgeBaseFileTableName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmKnowledgeBaseFileTableName.expectedInvocations, n)
	return mmKnowledgeBaseFileTableName
}

func (mmKnowledgeBaseFileTableName *mRepositoryIMockKnowledgeBaseFileTableName) invocationsDone() bool {
	if len(mmKnowledgeBaseFileTableName.expectations) == 0 && mmKnowledgeBaseFileTableName.defaultExpectation == nil && mmKnowledgeBaseFileTableName.mock.funcKnowledgeBaseFileTableName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmKnowledgeBaseFileTableName.mock.afterKnowledgeBaseFileTableNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmKnowledgeBaseFileTableName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// KnowledgeBaseFileTableName implements repository.RepositoryI
func (mmKnowledgeBaseFileTableName *RepositoryIMock) KnowledgeBaseFileTableName() (s1 string) {
	mm_atomic.AddUint64(&mmKnowledgeBaseFileTableName.beforeKnowledgeBaseFileTableNameCounter, 1)
	defer mm_atomic.AddUint64(&mmKnowledgeBaseFileTableName.afterKnowledgeBaseFileTableNameCounter, 1)

	if mmKnowledgeBaseFileTableName.inspectFuncKnowledgeBaseFileTableName != nil {
		mmKnowledgeBaseFileTableName.inspectFuncKnowledgeBaseFileTableName()
	}

	if mmKnowledgeBaseFileTableName.KnowledgeBaseFileTableNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmKnowledgeBaseFileTableName.KnowledgeBaseFileTableNameMock.defaultExpectation.Counter, 1)

		mm_results := mmKnowledgeBaseFileTableName.KnowledgeBaseFileTableNameMock.defaultExpectation.results
		if mm_results == nil {
			mmKnowledgeBaseFileTableName.t.Fatal("No results are set for the RepositoryIMock.KnowledgeBaseFileTableName")
		}
		return (*mm_results).s1
	}
	if mmKnowledgeBaseFileTableName.funcKnowledgeBaseFileTableName != nil {
		return mmKnowledgeBaseFileTableName.funcKnowledgeBaseFileTableName()
	}
	mmKnowledgeBaseFileTableName.t.Fatalf("Unexpected call to RepositoryIMock.KnowledgeBaseFileTableName.")
	return
}

// KnowledgeBaseFileTableNameAfterCounter returns a count of finished RepositoryIMock.KnowledgeBaseFileTableName invocations
func (mmKnowledgeBaseFileTableName *RepositoryIMock) KnowledgeBaseFileTableNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmKnowledgeBaseFileTableName.afterKnowledgeBaseFileTableNameCounter)
}

// KnowledgeBaseFileTableNameBeforeCounter returns a count of RepositoryIMock.KnowledgeBaseFileTableName invocations
func (mmKnowledgeBaseFileTableName *RepositoryIMock) KnowledgeBaseFileTableNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmKnowledgeBaseFileTableName.beforeKnowledgeBaseFileTableNameCounter)
}

// MinimockKnowledgeBaseFileTableNameDone returns true if the count of the KnowledgeBaseFileTableName invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockKnowledgeBaseFileTableNameDone() bool {
	for _, e := range m.KnowledgeBaseFileTableNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.KnowledgeBaseFileTableNameMock.invocationsDone()
}

// MinimockKnowledgeBaseFileTableNameInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockKnowledgeBaseFileTableNameInspect() {
	for _, e := range m.KnowledgeBaseFileTableNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryIMock.KnowledgeBaseFileTableName")
		}
	}

	afterKnowledgeBaseFileTableNameCounter := mm_atomic.LoadUint64(&m.afterKnowledgeBaseFileTableNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.KnowledgeBaseFileTableNameMock.defaultExpectation != nil && afterKnowledgeBaseFileTableNameCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.KnowledgeBaseFileTableName")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcKnowledgeBaseFileTableName != nil && afterKnowledgeBaseFileTableNameCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.KnowledgeBaseFileTableName")
	}

	if !m.KnowledgeBaseFileTableNameMock.invocationsDone() && afterKnowledgeBaseFileTableNameCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.KnowledgeBaseFileTableName but found %d calls",
			mm_atomic.LoadUint64(&m.KnowledgeBaseFileTableNameMock.expectedInvocations), afterKnowledgeBaseFileTableNameCounter)
	}
}

type mRepositoryIMockListKnowledgeBaseFiles struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockListKnowledgeBaseFilesExpectation
	expectations       []*RepositoryIMockListKnowledgeBaseFilesExpectation

	callArgs []*RepositoryIMockListKnowledgeBaseFilesParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockListKnowledgeBaseFilesExpectation specifies expectation struct of the RepositoryI.ListKnowledgeBaseFiles
type RepositoryIMockListKnowledgeBaseFilesExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockListKnowledgeBaseFilesParams
	paramPtrs *RepositoryIMockListKnowledgeBaseFilesParamPtrs
	results   *RepositoryIMockListKnowledgeBaseFilesResults
	Counter   uint64
}

// RepositoryIMockListKnowledgeBaseFilesParams contains parameters of the RepositoryI.ListKnowledgeBaseFiles
type RepositoryIMockListKnowledgeBaseFilesParams struct {
	ctx           context.Context
	uid           string
	ownerUID      string
	kbUID         string
	pageSize      int32
	nextPageToken string
	filesUID      []string
}

// RepositoryIMockListKnowledgeBaseFilesParamPtrs contains pointers to parameters of the RepositoryI.ListKnowledgeBaseFiles
type RepositoryIMockListKnowledgeBaseFilesParamPtrs struct {
	ctx           *context.Context
	uid           *string
	ownerUID      *string
	kbUID         *string
	pageSize      *int32
	nextPageToken *string
	filesUID      *[]string
}

// RepositoryIMockListKnowledgeBaseFilesResults contains results of the RepositoryI.ListKnowledgeBaseFiles
type RepositoryIMockListKnowledgeBaseFilesResults struct {
	ka1 []mm_repository.KnowledgeBaseFile
	i1  int
	s1  string
	err error
}

// Expect sets up expected params for RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) Expect(ctx context.Context, uid string, ownerUID string, kbUID string, pageSize int32, nextPageToken string, filesUID []string) *mRepositoryIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by ExpectParams functions")
	}

	mmListKnowledgeBaseFiles.defaultExpectation.params = &RepositoryIMockListKnowledgeBaseFilesParams{ctx, uid, ownerUID, kbUID, pageSize, nextPageToken, filesUID}
	for _, e := range mmListKnowledgeBaseFiles.expectations {
		if minimock.Equal(e.params, mmListKnowledgeBaseFiles.defaultExpectation.params) {
			mmListKnowledgeBaseFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListKnowledgeBaseFiles.defaultExpectation.params)
		}
	}

	return mmListKnowledgeBaseFiles
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBaseFilesParamPtrs{}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListKnowledgeBaseFiles
}

// ExpectUidParam2 sets up expected param uid for RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) ExpectUidParam2(uid string) *mRepositoryIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBaseFilesParamPtrs{}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs.uid = &uid

	return mmListKnowledgeBaseFiles
}

// ExpectOwnerUIDParam3 sets up expected param ownerUID for RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) ExpectOwnerUIDParam3(ownerUID string) *mRepositoryIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBaseFilesParamPtrs{}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs.ownerUID = &ownerUID

	return mmListKnowledgeBaseFiles
}

// ExpectKbUIDParam4 sets up expected param kbUID for RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) ExpectKbUIDParam4(kbUID string) *mRepositoryIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBaseFilesParamPtrs{}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs.kbUID = &kbUID

	return mmListKnowledgeBaseFiles
}

// ExpectPageSizeParam5 sets up expected param pageSize for RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) ExpectPageSizeParam5(pageSize int32) *mRepositoryIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBaseFilesParamPtrs{}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs.pageSize = &pageSize

	return mmListKnowledgeBaseFiles
}

// ExpectNextPageTokenParam6 sets up expected param nextPageToken for RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) ExpectNextPageTokenParam6(nextPageToken string) *mRepositoryIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBaseFilesParamPtrs{}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs.nextPageToken = &nextPageToken

	return mmListKnowledgeBaseFiles
}

// ExpectFilesUIDParam7 sets up expected param filesUID for RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) ExpectFilesUIDParam7(filesUID []string) *mRepositoryIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBaseFilesParamPtrs{}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs.filesUID = &filesUID

	return mmListKnowledgeBaseFiles
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) Inspect(f func(ctx context.Context, uid string, ownerUID string, kbUID string, pageSize int32, nextPageToken string, filesUID []string)) *mRepositoryIMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.inspectFuncListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.ListKnowledgeBaseFiles")
	}

	mmListKnowledgeBaseFiles.mock.inspectFuncListKnowledgeBaseFiles = f

	return mmListKnowledgeBaseFiles
}

// Return sets up results that will be returned by RepositoryI.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) Return(ka1 []mm_repository.KnowledgeBaseFile, i1 int, s1 string, err error) *RepositoryIMock {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockListKnowledgeBaseFilesExpectation{mock: mmListKnowledgeBaseFiles.mock}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.results = &RepositoryIMockListKnowledgeBaseFilesResults{ka1, i1, s1, err}
	return mmListKnowledgeBaseFiles.mock
}

// Set uses given function f to mock the RepositoryI.ListKnowledgeBaseFiles method
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) Set(f func(ctx context.Context, uid string, ownerUID string, kbUID string, pageSize int32, nextPageToken string, filesUID []string) (ka1 []mm_repository.KnowledgeBaseFile, i1 int, s1 string, err error)) *RepositoryIMock {
	if mmListKnowledgeBaseFiles.defaultExpectation != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("Default expectation is already set for the RepositoryI.ListKnowledgeBaseFiles method")
	}

	if len(mmListKnowledgeBaseFiles.expectations) > 0 {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("Some expectations are already set for the RepositoryI.ListKnowledgeBaseFiles method")
	}

	mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles = f
	return mmListKnowledgeBaseFiles.mock
}

// When sets expectation for the RepositoryI.ListKnowledgeBaseFiles which will trigger the result defined by the following
// Then helper
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) When(ctx context.Context, uid string, ownerUID string, kbUID string, pageSize int32, nextPageToken string, filesUID []string) *RepositoryIMockListKnowledgeBaseFilesExpectation {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	expectation := &RepositoryIMockListKnowledgeBaseFilesExpectation{
		mock:   mmListKnowledgeBaseFiles.mock,
		params: &RepositoryIMockListKnowledgeBaseFilesParams{ctx, uid, ownerUID, kbUID, pageSize, nextPageToken, filesUID},
	}
	mmListKnowledgeBaseFiles.expectations = append(mmListKnowledgeBaseFiles.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.ListKnowledgeBaseFiles return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockListKnowledgeBaseFilesExpectation) Then(ka1 []mm_repository.KnowledgeBaseFile, i1 int, s1 string, err error) *RepositoryIMock {
	e.results = &RepositoryIMockListKnowledgeBaseFilesResults{ka1, i1, s1, err}
	return e.mock
}

// Times sets number of times RepositoryI.ListKnowledgeBaseFiles should be invoked
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) Times(n uint64) *mRepositoryIMockListKnowledgeBaseFiles {
	if n == 0 {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("Times of RepositoryIMock.ListKnowledgeBaseFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListKnowledgeBaseFiles.expectedInvocations, n)
	return mmListKnowledgeBaseFiles
}

func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) invocationsDone() bool {
	if len(mmListKnowledgeBaseFiles.expectations) == 0 && mmListKnowledgeBaseFiles.defaultExpectation == nil && mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBaseFiles.mock.afterListKnowledgeBaseFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBaseFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListKnowledgeBaseFiles implements repository.RepositoryI
func (mmListKnowledgeBaseFiles *RepositoryIMock) ListKnowledgeBaseFiles(ctx context.Context, uid string, ownerUID string, kbUID string, pageSize int32, nextPageToken string, filesUID []string) (ka1 []mm_repository.KnowledgeBaseFile, i1 int, s1 string, err error) {
	mm_atomic.AddUint64(&mmListKnowledgeBaseFiles.beforeListKnowledgeBaseFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmListKnowledgeBaseFiles.afterListKnowledgeBaseFilesCounter, 1)

	if mmListKnowledgeBaseFiles.inspectFuncListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.inspectFuncListKnowledgeBaseFiles(ctx, uid, ownerUID, kbUID, pageSize, nextPageToken, filesUID)
	}

	mm_params := RepositoryIMockListKnowledgeBaseFilesParams{ctx, uid, ownerUID, kbUID, pageSize, nextPageToken, filesUID}

	// Record call args
	mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.mutex.Lock()
	mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.callArgs = append(mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.callArgs, &mm_params)
	mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.mutex.Unlock()

	for _, e := range mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.i1, e.results.s1, e.results.err
		}
	}

	if mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.params
		mm_want_ptrs := mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockListKnowledgeBaseFilesParams{ctx, uid, ownerUID, kbUID, pageSize, nextPageToken, filesUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ListKnowledgeBaseFiles got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmListKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ListKnowledgeBaseFiles got unexpected parameter uid, want: %#v, got: %#v%s\n", *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmListKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ListKnowledgeBaseFiles got unexpected parameter ownerUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmListKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ListKnowledgeBaseFiles got unexpected parameter kbUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ListKnowledgeBaseFiles got unexpected parameter pageSize, want: %#v, got: %#v%s\n", *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.nextPageToken != nil && !minimock.Equal(*mm_want_ptrs.nextPageToken, mm_got.nextPageToken) {
				mmListKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ListKnowledgeBaseFiles got unexpected parameter nextPageToken, want: %#v, got: %#v%s\n", *mm_want_ptrs.nextPageToken, mm_got.nextPageToken, minimock.Diff(*mm_want_ptrs.nextPageToken, mm_got.nextPageToken))
			}

			if mm_want_ptrs.filesUID != nil && !minimock.Equal(*mm_want_ptrs.filesUID, mm_got.filesUID) {
				mmListKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ListKnowledgeBaseFiles got unexpected parameter filesUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.filesUID, mm_got.filesUID, minimock.Diff(*mm_want_ptrs.filesUID, mm_got.filesUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ListKnowledgeBaseFiles got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmListKnowledgeBaseFiles.t.Fatal("No results are set for the RepositoryIMock.ListKnowledgeBaseFiles")
		}
		return (*mm_results).ka1, (*mm_results).i1, (*mm_results).s1, (*mm_results).err
	}
	if mmListKnowledgeBaseFiles.funcListKnowledgeBaseFiles != nil {
		return mmListKnowledgeBaseFiles.funcListKnowledgeBaseFiles(ctx, uid, ownerUID, kbUID, pageSize, nextPageToken, filesUID)
	}
	mmListKnowledgeBaseFiles.t.Fatalf("Unexpected call to RepositoryIMock.ListKnowledgeBaseFiles. %v %v %v %v %v %v %v", ctx, uid, ownerUID, kbUID, pageSize, nextPageToken, filesUID)
	return
}

// ListKnowledgeBaseFilesAfterCounter returns a count of finished RepositoryIMock.ListKnowledgeBaseFiles invocations
func (mmListKnowledgeBaseFiles *RepositoryIMock) ListKnowledgeBaseFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBaseFiles.afterListKnowledgeBaseFilesCounter)
}

// ListKnowledgeBaseFilesBeforeCounter returns a count of RepositoryIMock.ListKnowledgeBaseFiles invocations
func (mmListKnowledgeBaseFiles *RepositoryIMock) ListKnowledgeBaseFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBaseFiles.beforeListKnowledgeBaseFilesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.ListKnowledgeBaseFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListKnowledgeBaseFiles *mRepositoryIMockListKnowledgeBaseFiles) Calls() []*RepositoryIMockListKnowledgeBaseFilesParams {
	mmListKnowledgeBaseFiles.mutex.RLock()

	argCopy := make([]*RepositoryIMockListKnowledgeBaseFilesParams, len(mmListKnowledgeBaseFiles.callArgs))
	copy(argCopy, mmListKnowledgeBaseFiles.callArgs)

	mmListKnowledgeBaseFiles.mutex.RUnlock()

	return argCopy
}

// MinimockListKnowledgeBaseFilesDone returns true if the count of the ListKnowledgeBaseFiles invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockListKnowledgeBaseFilesDone() bool {
	for _, e := range m.ListKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListKnowledgeBaseFilesMock.invocationsDone()
}

// MinimockListKnowledgeBaseFilesInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockListKnowledgeBaseFilesInspect() {
	for _, e := range m.ListKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.ListKnowledgeBaseFiles with params: %#v", *e.params)
		}
	}

	afterListKnowledgeBaseFilesCounter := mm_atomic.LoadUint64(&m.afterListKnowledgeBaseFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListKnowledgeBaseFilesMock.defaultExpectation != nil && afterListKnowledgeBaseFilesCounter < 1 {
		if m.ListKnowledgeBaseFilesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.ListKnowledgeBaseFiles")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.ListKnowledgeBaseFiles with params: %#v", *m.ListKnowledgeBaseFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListKnowledgeBaseFiles != nil && afterListKnowledgeBaseFilesCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.ListKnowledgeBaseFiles")
	}

	if !m.ListKnowledgeBaseFilesMock.invocationsDone() && afterListKnowledgeBaseFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.ListKnowledgeBaseFiles but found %d calls",
			mm_atomic.LoadUint64(&m.ListKnowledgeBaseFilesMock.expectedInvocations), afterListKnowledgeBaseFilesCounter)
	}
}

type mRepositoryIMockListKnowledgeBases struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockListKnowledgeBasesExpectation
	expectations       []*RepositoryIMockListKnowledgeBasesExpectation

	callArgs []*RepositoryIMockListKnowledgeBasesParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockListKnowledgeBasesExpectation specifies expectation struct of the RepositoryI.ListKnowledgeBases
type RepositoryIMockListKnowledgeBasesExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockListKnowledgeBasesParams
	paramPtrs *RepositoryIMockListKnowledgeBasesParamPtrs
	results   *RepositoryIMockListKnowledgeBasesResults
	Counter   uint64
}

// RepositoryIMockListKnowledgeBasesParams contains parameters of the RepositoryI.ListKnowledgeBases
type RepositoryIMockListKnowledgeBasesParams struct {
	ctx      context.Context
	ownerUID string
}

// RepositoryIMockListKnowledgeBasesParamPtrs contains pointers to parameters of the RepositoryI.ListKnowledgeBases
type RepositoryIMockListKnowledgeBasesParamPtrs struct {
	ctx      *context.Context
	ownerUID *string
}

// RepositoryIMockListKnowledgeBasesResults contains results of the RepositoryI.ListKnowledgeBases
type RepositoryIMockListKnowledgeBasesResults struct {
	ka1 []mm_repository.KnowledgeBase
	err error
}

// Expect sets up expected params for RepositoryI.ListKnowledgeBases
func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) Expect(ctx context.Context, ownerUID string) *mRepositoryIMockListKnowledgeBases {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBases mock is already set by Set")
	}

	if mmListKnowledgeBases.defaultExpectation == nil {
		mmListKnowledgeBases.defaultExpectation = &RepositoryIMockListKnowledgeBasesExpectation{}
	}

	if mmListKnowledgeBases.defaultExpectation.paramPtrs != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBases mock is already set by ExpectParams functions")
	}

	mmListKnowledgeBases.defaultExpectation.params = &RepositoryIMockListKnowledgeBasesParams{ctx, ownerUID}
	for _, e := range mmListKnowledgeBases.expectations {
		if minimock.Equal(e.params, mmListKnowledgeBases.defaultExpectation.params) {
			mmListKnowledgeBases.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListKnowledgeBases.defaultExpectation.params)
		}
	}

	return mmListKnowledgeBases
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.ListKnowledgeBases
func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockListKnowledgeBases {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBases mock is already set by Set")
	}

	if mmListKnowledgeBases.defaultExpectation == nil {
		mmListKnowledgeBases.defaultExpectation = &RepositoryIMockListKnowledgeBasesExpectation{}
	}

	if mmListKnowledgeBases.defaultExpectation.params != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBases mock is already set by Expect")
	}

	if mmListKnowledgeBases.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBases.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBasesParamPtrs{}
	}
	mmListKnowledgeBases.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListKnowledgeBases
}

// ExpectOwnerUIDParam2 sets up expected param ownerUID for RepositoryI.ListKnowledgeBases
func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) ExpectOwnerUIDParam2(ownerUID string) *mRepositoryIMockListKnowledgeBases {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBases mock is already set by Set")
	}

	if mmListKnowledgeBases.defaultExpectation == nil {
		mmListKnowledgeBases.defaultExpectation = &RepositoryIMockListKnowledgeBasesExpectation{}
	}

	if mmListKnowledgeBases.defaultExpectation.params != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBases mock is already set by Expect")
	}

	if mmListKnowledgeBases.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBases.defaultExpectation.paramPtrs = &RepositoryIMockListKnowledgeBasesParamPtrs{}
	}
	mmListKnowledgeBases.defaultExpectation.paramPtrs.ownerUID = &ownerUID

	return mmListKnowledgeBases
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.ListKnowledgeBases
func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) Inspect(f func(ctx context.Context, ownerUID string)) *mRepositoryIMockListKnowledgeBases {
	if mmListKnowledgeBases.mock.inspectFuncListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.ListKnowledgeBases")
	}

	mmListKnowledgeBases.mock.inspectFuncListKnowledgeBases = f

	return mmListKnowledgeBases
}

// Return sets up results that will be returned by RepositoryI.ListKnowledgeBases
func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) Return(ka1 []mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBases mock is already set by Set")
	}

	if mmListKnowledgeBases.defaultExpectation == nil {
		mmListKnowledgeBases.defaultExpectation = &RepositoryIMockListKnowledgeBasesExpectation{mock: mmListKnowledgeBases.mock}
	}
	mmListKnowledgeBases.defaultExpectation.results = &RepositoryIMockListKnowledgeBasesResults{ka1, err}
	return mmListKnowledgeBases.mock
}

// Set uses given function f to mock the RepositoryI.ListKnowledgeBases method
func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) Set(f func(ctx context.Context, ownerUID string) (ka1 []mm_repository.KnowledgeBase, err error)) *RepositoryIMock {
	if mmListKnowledgeBases.defaultExpectation != nil {
		mmListKnowledgeBases.mock.t.Fatalf("Default expectation is already set for the RepositoryI.ListKnowledgeBases method")
	}

	if len(mmListKnowledgeBases.expectations) > 0 {
		mmListKnowledgeBases.mock.t.Fatalf("Some expectations are already set for the RepositoryI.ListKnowledgeBases method")
	}

	mmListKnowledgeBases.mock.funcListKnowledgeBases = f
	return mmListKnowledgeBases.mock
}

// When sets expectation for the RepositoryI.ListKnowledgeBases which will trigger the result defined by the following
// Then helper
func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) When(ctx context.Context, ownerUID string) *RepositoryIMockListKnowledgeBasesExpectation {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryIMock.ListKnowledgeBases mock is already set by Set")
	}

	expectation := &RepositoryIMockListKnowledgeBasesExpectation{
		mock:   mmListKnowledgeBases.mock,
		params: &RepositoryIMockListKnowledgeBasesParams{ctx, ownerUID},
	}
	mmListKnowledgeBases.expectations = append(mmListKnowledgeBases.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.ListKnowledgeBases return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockListKnowledgeBasesExpectation) Then(ka1 []mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	e.results = &RepositoryIMockListKnowledgeBasesResults{ka1, err}
	return e.mock
}

// Times sets number of times RepositoryI.ListKnowledgeBases should be invoked
func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) Times(n uint64) *mRepositoryIMockListKnowledgeBases {
	if n == 0 {
		mmListKnowledgeBases.mock.t.Fatalf("Times of RepositoryIMock.ListKnowledgeBases mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListKnowledgeBases.expectedInvocations, n)
	return mmListKnowledgeBases
}

func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) invocationsDone() bool {
	if len(mmListKnowledgeBases.expectations) == 0 && mmListKnowledgeBases.defaultExpectation == nil && mmListKnowledgeBases.mock.funcListKnowledgeBases == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBases.mock.afterListKnowledgeBasesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBases.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListKnowledgeBases implements repository.RepositoryI
func (mmListKnowledgeBases *RepositoryIMock) ListKnowledgeBases(ctx context.Context, ownerUID string) (ka1 []mm_repository.KnowledgeBase, err error) {
	mm_atomic.AddUint64(&mmListKnowledgeBases.beforeListKnowledgeBasesCounter, 1)
	defer mm_atomic.AddUint64(&mmListKnowledgeBases.afterListKnowledgeBasesCounter, 1)

	if mmListKnowledgeBases.inspectFuncListKnowledgeBases != nil {
		mmListKnowledgeBases.inspectFuncListKnowledgeBases(ctx, ownerUID)
	}

	mm_params := RepositoryIMockListKnowledgeBasesParams{ctx, ownerUID}

	// Record call args
	mmListKnowledgeBases.ListKnowledgeBasesMock.mutex.Lock()
	mmListKnowledgeBases.ListKnowledgeBasesMock.callArgs = append(mmListKnowledgeBases.ListKnowledgeBasesMock.callArgs, &mm_params)
	mmListKnowledgeBases.ListKnowledgeBasesMock.mutex.Unlock()

	for _, e := range mmListKnowledgeBases.ListKnowledgeBasesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.Counter, 1)
		mm_want := mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.params
		mm_want_ptrs := mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockListKnowledgeBasesParams{ctx, ownerUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListKnowledgeBases.t.Errorf("RepositoryIMock.ListKnowledgeBases got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmListKnowledgeBases.t.Errorf("RepositoryIMock.ListKnowledgeBases got unexpected parameter ownerUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListKnowledgeBases.t.Errorf("RepositoryIMock.ListKnowledgeBases got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.results
		if mm_results == nil {
			mmListKnowledgeBases.t.Fatal("No results are set for the RepositoryIMock.ListKnowledgeBases")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmListKnowledgeBases.funcListKnowledgeBases != nil {
		return mmListKnowledgeBases.funcListKnowledgeBases(ctx, ownerUID)
	}
	mmListKnowledgeBases.t.Fatalf("Unexpected call to RepositoryIMock.ListKnowledgeBases. %v %v", ctx, ownerUID)
	return
}

// ListKnowledgeBasesAfterCounter returns a count of finished RepositoryIMock.ListKnowledgeBases invocations
func (mmListKnowledgeBases *RepositoryIMock) ListKnowledgeBasesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBases.afterListKnowledgeBasesCounter)
}

// ListKnowledgeBasesBeforeCounter returns a count of RepositoryIMock.ListKnowledgeBases invocations
func (mmListKnowledgeBases *RepositoryIMock) ListKnowledgeBasesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBases.beforeListKnowledgeBasesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.ListKnowledgeBases.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListKnowledgeBases *mRepositoryIMockListKnowledgeBases) Calls() []*RepositoryIMockListKnowledgeBasesParams {
	mmListKnowledgeBases.mutex.RLock()

	argCopy := make([]*RepositoryIMockListKnowledgeBasesParams, len(mmListKnowledgeBases.callArgs))
	copy(argCopy, mmListKnowledgeBases.callArgs)

	mmListKnowledgeBases.mutex.RUnlock()

	return argCopy
}

// MinimockListKnowledgeBasesDone returns true if the count of the ListKnowledgeBases invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockListKnowledgeBasesDone() bool {
	for _, e := range m.ListKnowledgeBasesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListKnowledgeBasesMock.invocationsDone()
}

// MinimockListKnowledgeBasesInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockListKnowledgeBasesInspect() {
	for _, e := range m.ListKnowledgeBasesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.ListKnowledgeBases with params: %#v", *e.params)
		}
	}

	afterListKnowledgeBasesCounter := mm_atomic.LoadUint64(&m.afterListKnowledgeBasesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListKnowledgeBasesMock.defaultExpectation != nil && afterListKnowledgeBasesCounter < 1 {
		if m.ListKnowledgeBasesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.ListKnowledgeBases")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.ListKnowledgeBases with params: %#v", *m.ListKnowledgeBasesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListKnowledgeBases != nil && afterListKnowledgeBasesCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.ListKnowledgeBases")
	}

	if !m.ListKnowledgeBasesMock.invocationsDone() && afterListKnowledgeBasesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.ListKnowledgeBases but found %d calls",
			mm_atomic.LoadUint64(&m.ListKnowledgeBasesMock.expectedInvocations), afterListKnowledgeBasesCounter)
	}
}

type mRepositoryIMockProcessKnowledgeBaseFiles struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockProcessKnowledgeBaseFilesExpectation
	expectations       []*RepositoryIMockProcessKnowledgeBaseFilesExpectation

	callArgs []*RepositoryIMockProcessKnowledgeBaseFilesParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockProcessKnowledgeBaseFilesExpectation specifies expectation struct of the RepositoryI.ProcessKnowledgeBaseFiles
type RepositoryIMockProcessKnowledgeBaseFilesExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockProcessKnowledgeBaseFilesParams
	paramPtrs *RepositoryIMockProcessKnowledgeBaseFilesParamPtrs
	results   *RepositoryIMockProcessKnowledgeBaseFilesResults
	Counter   uint64
}

// RepositoryIMockProcessKnowledgeBaseFilesParams contains parameters of the RepositoryI.ProcessKnowledgeBaseFiles
type RepositoryIMockProcessKnowledgeBaseFilesParams struct {
	ctx      context.Context
	fileUids []string
}

// RepositoryIMockProcessKnowledgeBaseFilesParamPtrs contains pointers to parameters of the RepositoryI.ProcessKnowledgeBaseFiles
type RepositoryIMockProcessKnowledgeBaseFilesParamPtrs struct {
	ctx      *context.Context
	fileUids *[]string
}

// RepositoryIMockProcessKnowledgeBaseFilesResults contains results of the RepositoryI.ProcessKnowledgeBaseFiles
type RepositoryIMockProcessKnowledgeBaseFilesResults struct {
	ka1 []mm_repository.KnowledgeBaseFile
	err error
}

// Expect sets up expected params for RepositoryI.ProcessKnowledgeBaseFiles
func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) Expect(ctx context.Context, fileUids []string) *mRepositoryIMockProcessKnowledgeBaseFiles {
	if mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ProcessKnowledgeBaseFiles mock is already set by Set")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockProcessKnowledgeBaseFilesExpectation{}
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ProcessKnowledgeBaseFiles mock is already set by ExpectParams functions")
	}

	mmProcessKnowledgeBaseFiles.defaultExpectation.params = &RepositoryIMockProcessKnowledgeBaseFilesParams{ctx, fileUids}
	for _, e := range mmProcessKnowledgeBaseFiles.expectations {
		if minimock.Equal(e.params, mmProcessKnowledgeBaseFiles.defaultExpectation.params) {
			mmProcessKnowledgeBaseFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmProcessKnowledgeBaseFiles.defaultExpectation.params)
		}
	}

	return mmProcessKnowledgeBaseFiles
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.ProcessKnowledgeBaseFiles
func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockProcessKnowledgeBaseFiles {
	if mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ProcessKnowledgeBaseFiles mock is already set by Set")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockProcessKnowledgeBaseFilesExpectation{}
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ProcessKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockProcessKnowledgeBaseFilesParamPtrs{}
	}
	mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs.ctx = &ctx

	return mmProcessKnowledgeBaseFiles
}

// ExpectFileUidsParam2 sets up expected param fileUids for RepositoryI.ProcessKnowledgeBaseFiles
func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) ExpectFileUidsParam2(fileUids []string) *mRepositoryIMockProcessKnowledgeBaseFiles {
	if mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ProcessKnowledgeBaseFiles mock is already set by Set")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockProcessKnowledgeBaseFilesExpectation{}
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ProcessKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryIMockProcessKnowledgeBaseFilesParamPtrs{}
	}
	mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs.fileUids = &fileUids

	return mmProcessKnowledgeBaseFiles
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.ProcessKnowledgeBaseFiles
func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) Inspect(f func(ctx context.Context, fileUids []string)) *mRepositoryIMockProcessKnowledgeBaseFiles {
	if mmProcessKnowledgeBaseFiles.mock.inspectFuncProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.ProcessKnowledgeBaseFiles")
	}

	mmProcessKnowledgeBaseFiles.mock.inspectFuncProcessKnowledgeBaseFiles = f

	return mmProcessKnowledgeBaseFiles
}

// Return sets up results that will be returned by RepositoryI.ProcessKnowledgeBaseFiles
func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) Return(ka1 []mm_repository.KnowledgeBaseFile, err error) *RepositoryIMock {
	if mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ProcessKnowledgeBaseFiles mock is already set by Set")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation = &RepositoryIMockProcessKnowledgeBaseFilesExpectation{mock: mmProcessKnowledgeBaseFiles.mock}
	}
	mmProcessKnowledgeBaseFiles.defaultExpectation.results = &RepositoryIMockProcessKnowledgeBaseFilesResults{ka1, err}
	return mmProcessKnowledgeBaseFiles.mock
}

// Set uses given function f to mock the RepositoryI.ProcessKnowledgeBaseFiles method
func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) Set(f func(ctx context.Context, fileUids []string) (ka1 []mm_repository.KnowledgeBaseFile, err error)) *RepositoryIMock {
	if mmProcessKnowledgeBaseFiles.defaultExpectation != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("Default expectation is already set for the RepositoryI.ProcessKnowledgeBaseFiles method")
	}

	if len(mmProcessKnowledgeBaseFiles.expectations) > 0 {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("Some expectations are already set for the RepositoryI.ProcessKnowledgeBaseFiles method")
	}

	mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles = f
	return mmProcessKnowledgeBaseFiles.mock
}

// When sets expectation for the RepositoryI.ProcessKnowledgeBaseFiles which will trigger the result defined by the following
// Then helper
func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) When(ctx context.Context, fileUids []string) *RepositoryIMockProcessKnowledgeBaseFilesExpectation {
	if mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryIMock.ProcessKnowledgeBaseFiles mock is already set by Set")
	}

	expectation := &RepositoryIMockProcessKnowledgeBaseFilesExpectation{
		mock:   mmProcessKnowledgeBaseFiles.mock,
		params: &RepositoryIMockProcessKnowledgeBaseFilesParams{ctx, fileUids},
	}
	mmProcessKnowledgeBaseFiles.expectations = append(mmProcessKnowledgeBaseFiles.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.ProcessKnowledgeBaseFiles return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockProcessKnowledgeBaseFilesExpectation) Then(ka1 []mm_repository.KnowledgeBaseFile, err error) *RepositoryIMock {
	e.results = &RepositoryIMockProcessKnowledgeBaseFilesResults{ka1, err}
	return e.mock
}

// Times sets number of times RepositoryI.ProcessKnowledgeBaseFiles should be invoked
func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) Times(n uint64) *mRepositoryIMockProcessKnowledgeBaseFiles {
	if n == 0 {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("Times of RepositoryIMock.ProcessKnowledgeBaseFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmProcessKnowledgeBaseFiles.expectedInvocations, n)
	return mmProcessKnowledgeBaseFiles
}

func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) invocationsDone() bool {
	if len(mmProcessKnowledgeBaseFiles.expectations) == 0 && mmProcessKnowledgeBaseFiles.defaultExpectation == nil && mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmProcessKnowledgeBaseFiles.mock.afterProcessKnowledgeBaseFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmProcessKnowledgeBaseFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ProcessKnowledgeBaseFiles implements repository.RepositoryI
func (mmProcessKnowledgeBaseFiles *RepositoryIMock) ProcessKnowledgeBaseFiles(ctx context.Context, fileUids []string) (ka1 []mm_repository.KnowledgeBaseFile, err error) {
	mm_atomic.AddUint64(&mmProcessKnowledgeBaseFiles.beforeProcessKnowledgeBaseFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmProcessKnowledgeBaseFiles.afterProcessKnowledgeBaseFilesCounter, 1)

	if mmProcessKnowledgeBaseFiles.inspectFuncProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.inspectFuncProcessKnowledgeBaseFiles(ctx, fileUids)
	}

	mm_params := RepositoryIMockProcessKnowledgeBaseFilesParams{ctx, fileUids}

	// Record call args
	mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.mutex.Lock()
	mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.callArgs = append(mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.callArgs, &mm_params)
	mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.mutex.Unlock()

	for _, e := range mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation.params
		mm_want_ptrs := mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockProcessKnowledgeBaseFilesParams{ctx, fileUids}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmProcessKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ProcessKnowledgeBaseFiles got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUids != nil && !minimock.Equal(*mm_want_ptrs.fileUids, mm_got.fileUids) {
				mmProcessKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ProcessKnowledgeBaseFiles got unexpected parameter fileUids, want: %#v, got: %#v%s\n", *mm_want_ptrs.fileUids, mm_got.fileUids, minimock.Diff(*mm_want_ptrs.fileUids, mm_got.fileUids))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmProcessKnowledgeBaseFiles.t.Errorf("RepositoryIMock.ProcessKnowledgeBaseFiles got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmProcessKnowledgeBaseFiles.t.Fatal("No results are set for the RepositoryIMock.ProcessKnowledgeBaseFiles")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmProcessKnowledgeBaseFiles.funcProcessKnowledgeBaseFiles != nil {
		return mmProcessKnowledgeBaseFiles.funcProcessKnowledgeBaseFiles(ctx, fileUids)
	}
	mmProcessKnowledgeBaseFiles.t.Fatalf("Unexpected call to RepositoryIMock.ProcessKnowledgeBaseFiles. %v %v", ctx, fileUids)
	return
}

// ProcessKnowledgeBaseFilesAfterCounter returns a count of finished RepositoryIMock.ProcessKnowledgeBaseFiles invocations
func (mmProcessKnowledgeBaseFiles *RepositoryIMock) ProcessKnowledgeBaseFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessKnowledgeBaseFiles.afterProcessKnowledgeBaseFilesCounter)
}

// ProcessKnowledgeBaseFilesBeforeCounter returns a count of RepositoryIMock.ProcessKnowledgeBaseFiles invocations
func (mmProcessKnowledgeBaseFiles *RepositoryIMock) ProcessKnowledgeBaseFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessKnowledgeBaseFiles.beforeProcessKnowledgeBaseFilesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.ProcessKnowledgeBaseFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmProcessKnowledgeBaseFiles *mRepositoryIMockProcessKnowledgeBaseFiles) Calls() []*RepositoryIMockProcessKnowledgeBaseFilesParams {
	mmProcessKnowledgeBaseFiles.mutex.RLock()

	argCopy := make([]*RepositoryIMockProcessKnowledgeBaseFilesParams, len(mmProcessKnowledgeBaseFiles.callArgs))
	copy(argCopy, mmProcessKnowledgeBaseFiles.callArgs)

	mmProcessKnowledgeBaseFiles.mutex.RUnlock()

	return argCopy
}

// MinimockProcessKnowledgeBaseFilesDone returns true if the count of the ProcessKnowledgeBaseFiles invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockProcessKnowledgeBaseFilesDone() bool {
	for _, e := range m.ProcessKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ProcessKnowledgeBaseFilesMock.invocationsDone()
}

// MinimockProcessKnowledgeBaseFilesInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockProcessKnowledgeBaseFilesInspect() {
	for _, e := range m.ProcessKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.ProcessKnowledgeBaseFiles with params: %#v", *e.params)
		}
	}

	afterProcessKnowledgeBaseFilesCounter := mm_atomic.LoadUint64(&m.afterProcessKnowledgeBaseFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ProcessKnowledgeBaseFilesMock.defaultExpectation != nil && afterProcessKnowledgeBaseFilesCounter < 1 {
		if m.ProcessKnowledgeBaseFilesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.ProcessKnowledgeBaseFiles")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.ProcessKnowledgeBaseFiles with params: %#v", *m.ProcessKnowledgeBaseFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProcessKnowledgeBaseFiles != nil && afterProcessKnowledgeBaseFilesCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.ProcessKnowledgeBaseFiles")
	}

	if !m.ProcessKnowledgeBaseFilesMock.invocationsDone() && afterProcessKnowledgeBaseFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.ProcessKnowledgeBaseFiles but found %d calls",
			mm_atomic.LoadUint64(&m.ProcessKnowledgeBaseFilesMock.expectedInvocations), afterProcessKnowledgeBaseFilesCounter)
	}
}

type mRepositoryIMockUpdateKnowledgeBase struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockUpdateKnowledgeBaseExpectation
	expectations       []*RepositoryIMockUpdateKnowledgeBaseExpectation

	callArgs []*RepositoryIMockUpdateKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockUpdateKnowledgeBaseExpectation specifies expectation struct of the RepositoryI.UpdateKnowledgeBase
type RepositoryIMockUpdateKnowledgeBaseExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockUpdateKnowledgeBaseParams
	paramPtrs *RepositoryIMockUpdateKnowledgeBaseParamPtrs
	results   *RepositoryIMockUpdateKnowledgeBaseResults
	Counter   uint64
}

// RepositoryIMockUpdateKnowledgeBaseParams contains parameters of the RepositoryI.UpdateKnowledgeBase
type RepositoryIMockUpdateKnowledgeBaseParams struct {
	ctx      context.Context
	ownerUID string
	kb       mm_repository.KnowledgeBase
}

// RepositoryIMockUpdateKnowledgeBaseParamPtrs contains pointers to parameters of the RepositoryI.UpdateKnowledgeBase
type RepositoryIMockUpdateKnowledgeBaseParamPtrs struct {
	ctx      *context.Context
	ownerUID *string
	kb       *mm_repository.KnowledgeBase
}

// RepositoryIMockUpdateKnowledgeBaseResults contains results of the RepositoryI.UpdateKnowledgeBase
type RepositoryIMockUpdateKnowledgeBaseResults struct {
	kp1 *mm_repository.KnowledgeBase
	err error
}

// Expect sets up expected params for RepositoryI.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) Expect(ctx context.Context, ownerUID string, kb mm_repository.KnowledgeBase) *mRepositoryIMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmUpdateKnowledgeBase.defaultExpectation.params = &RepositoryIMockUpdateKnowledgeBaseParams{ctx, ownerUID, kb}
	for _, e := range mmUpdateKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmUpdateKnowledgeBase.defaultExpectation.params) {
			mmUpdateKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmUpdateKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.params != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Expect")
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKnowledgeBaseParamPtrs{}
	}
	mmUpdateKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateKnowledgeBase
}

// ExpectOwnerUIDParam2 sets up expected param ownerUID for RepositoryI.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) ExpectOwnerUIDParam2(ownerUID string) *mRepositoryIMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.params != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Expect")
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKnowledgeBaseParamPtrs{}
	}
	mmUpdateKnowledgeBase.defaultExpectation.paramPtrs.ownerUID = &ownerUID

	return mmUpdateKnowledgeBase
}

// ExpectKbParam3 sets up expected param kb for RepositoryI.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) ExpectKbParam3(kb mm_repository.KnowledgeBase) *mRepositoryIMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.params != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Expect")
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKnowledgeBaseParamPtrs{}
	}
	mmUpdateKnowledgeBase.defaultExpectation.paramPtrs.kb = &kb

	return mmUpdateKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) Inspect(f func(ctx context.Context, ownerUID string, kb mm_repository.KnowledgeBase)) *mRepositoryIMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.inspectFuncUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.UpdateKnowledgeBase")
	}

	mmUpdateKnowledgeBase.mock.inspectFuncUpdateKnowledgeBase = f

	return mmUpdateKnowledgeBase
}

// Return sets up results that will be returned by RepositoryI.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) Return(kp1 *mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseExpectation{mock: mmUpdateKnowledgeBase.mock}
	}
	mmUpdateKnowledgeBase.defaultExpectation.results = &RepositoryIMockUpdateKnowledgeBaseResults{kp1, err}
	return mmUpdateKnowledgeBase.mock
}

// Set uses given function f to mock the RepositoryI.UpdateKnowledgeBase method
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) Set(f func(ctx context.Context, ownerUID string, kb mm_repository.KnowledgeBase) (kp1 *mm_repository.KnowledgeBase, err error)) *RepositoryIMock {
	if mmUpdateKnowledgeBase.defaultExpectation != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the RepositoryI.UpdateKnowledgeBase method")
	}

	if len(mmUpdateKnowledgeBase.expectations) > 0 {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the RepositoryI.UpdateKnowledgeBase method")
	}

	mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase = f
	return mmUpdateKnowledgeBase.mock
}

// When sets expectation for the RepositoryI.UpdateKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) When(ctx context.Context, ownerUID string, kb mm_repository.KnowledgeBase) *RepositoryIMockUpdateKnowledgeBaseExpectation {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBase mock is already set by Set")
	}

	expectation := &RepositoryIMockUpdateKnowledgeBaseExpectation{
		mock:   mmUpdateKnowledgeBase.mock,
		params: &RepositoryIMockUpdateKnowledgeBaseParams{ctx, ownerUID, kb},
	}
	mmUpdateKnowledgeBase.expectations = append(mmUpdateKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.UpdateKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockUpdateKnowledgeBaseExpectation) Then(kp1 *mm_repository.KnowledgeBase, err error) *RepositoryIMock {
	e.results = &RepositoryIMockUpdateKnowledgeBaseResults{kp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.UpdateKnowledgeBase should be invoked
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) Times(n uint64) *mRepositoryIMockUpdateKnowledgeBase {
	if n == 0 {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Times of RepositoryIMock.UpdateKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateKnowledgeBase.expectedInvocations, n)
	return mmUpdateKnowledgeBase
}

func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) invocationsDone() bool {
	if len(mmUpdateKnowledgeBase.expectations) == 0 && mmUpdateKnowledgeBase.defaultExpectation == nil && mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.mock.afterUpdateKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateKnowledgeBase implements repository.RepositoryI
func (mmUpdateKnowledgeBase *RepositoryIMock) UpdateKnowledgeBase(ctx context.Context, ownerUID string, kb mm_repository.KnowledgeBase) (kp1 *mm_repository.KnowledgeBase, err error) {
	mm_atomic.AddUint64(&mmUpdateKnowledgeBase.beforeUpdateKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateKnowledgeBase.afterUpdateKnowledgeBaseCounter, 1)

	if mmUpdateKnowledgeBase.inspectFuncUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.inspectFuncUpdateKnowledgeBase(ctx, ownerUID, kb)
	}

	mm_params := RepositoryIMockUpdateKnowledgeBaseParams{ctx, ownerUID, kb}

	// Record call args
	mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.mutex.Lock()
	mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.callArgs = append(mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.callArgs, &mm_params)
	mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockUpdateKnowledgeBaseParams{ctx, ownerUID, kb}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateKnowledgeBase.t.Errorf("RepositoryIMock.UpdateKnowledgeBase got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmUpdateKnowledgeBase.t.Errorf("RepositoryIMock.UpdateKnowledgeBase got unexpected parameter ownerUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

			if mm_want_ptrs.kb != nil && !minimock.Equal(*mm_want_ptrs.kb, mm_got.kb) {
				mmUpdateKnowledgeBase.t.Errorf("RepositoryIMock.UpdateKnowledgeBase got unexpected parameter kb, want: %#v, got: %#v%s\n", *mm_want_ptrs.kb, mm_got.kb, minimock.Diff(*mm_want_ptrs.kb, mm_got.kb))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateKnowledgeBase.t.Errorf("RepositoryIMock.UpdateKnowledgeBase got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateKnowledgeBase.t.Fatal("No results are set for the RepositoryIMock.UpdateKnowledgeBase")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmUpdateKnowledgeBase.funcUpdateKnowledgeBase != nil {
		return mmUpdateKnowledgeBase.funcUpdateKnowledgeBase(ctx, ownerUID, kb)
	}
	mmUpdateKnowledgeBase.t.Fatalf("Unexpected call to RepositoryIMock.UpdateKnowledgeBase. %v %v %v", ctx, ownerUID, kb)
	return
}

// UpdateKnowledgeBaseAfterCounter returns a count of finished RepositoryIMock.UpdateKnowledgeBase invocations
func (mmUpdateKnowledgeBase *RepositoryIMock) UpdateKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.afterUpdateKnowledgeBaseCounter)
}

// UpdateKnowledgeBaseBeforeCounter returns a count of RepositoryIMock.UpdateKnowledgeBase invocations
func (mmUpdateKnowledgeBase *RepositoryIMock) UpdateKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.beforeUpdateKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.UpdateKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateKnowledgeBase *mRepositoryIMockUpdateKnowledgeBase) Calls() []*RepositoryIMockUpdateKnowledgeBaseParams {
	mmUpdateKnowledgeBase.mutex.RLock()

	argCopy := make([]*RepositoryIMockUpdateKnowledgeBaseParams, len(mmUpdateKnowledgeBase.callArgs))
	copy(argCopy, mmUpdateKnowledgeBase.callArgs)

	mmUpdateKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateKnowledgeBaseDone returns true if the count of the UpdateKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockUpdateKnowledgeBaseDone() bool {
	for _, e := range m.UpdateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateKnowledgeBaseMock.invocationsDone()
}

// MinimockUpdateKnowledgeBaseInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockUpdateKnowledgeBaseInspect() {
	for _, e := range m.UpdateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateKnowledgeBase with params: %#v", *e.params)
		}
	}

	afterUpdateKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterUpdateKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateKnowledgeBaseMock.defaultExpectation != nil && afterUpdateKnowledgeBaseCounter < 1 {
		if m.UpdateKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.UpdateKnowledgeBase")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateKnowledgeBase with params: %#v", *m.UpdateKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateKnowledgeBase != nil && afterUpdateKnowledgeBaseCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.UpdateKnowledgeBase")
	}

	if !m.UpdateKnowledgeBaseMock.invocationsDone() && afterUpdateKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.UpdateKnowledgeBase but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateKnowledgeBaseMock.expectedInvocations), afterUpdateKnowledgeBaseCounter)
	}
}

type mRepositoryIMockUpdateKnowledgeBaseFile struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockUpdateKnowledgeBaseFileExpectation
	expectations       []*RepositoryIMockUpdateKnowledgeBaseFileExpectation

	callArgs []*RepositoryIMockUpdateKnowledgeBaseFileParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockUpdateKnowledgeBaseFileExpectation specifies expectation struct of the RepositoryI.UpdateKnowledgeBaseFile
type RepositoryIMockUpdateKnowledgeBaseFileExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockUpdateKnowledgeBaseFileParams
	paramPtrs *RepositoryIMockUpdateKnowledgeBaseFileParamPtrs
	results   *RepositoryIMockUpdateKnowledgeBaseFileResults
	Counter   uint64
}

// RepositoryIMockUpdateKnowledgeBaseFileParams contains parameters of the RepositoryI.UpdateKnowledgeBaseFile
type RepositoryIMockUpdateKnowledgeBaseFileParams struct {
	ctx       context.Context
	fileUID   string
	updateMap map[string]interface{}
}

// RepositoryIMockUpdateKnowledgeBaseFileParamPtrs contains pointers to parameters of the RepositoryI.UpdateKnowledgeBaseFile
type RepositoryIMockUpdateKnowledgeBaseFileParamPtrs struct {
	ctx       *context.Context
	fileUID   *string
	updateMap *map[string]interface{}
}

// RepositoryIMockUpdateKnowledgeBaseFileResults contains results of the RepositoryI.UpdateKnowledgeBaseFile
type RepositoryIMockUpdateKnowledgeBaseFileResults struct {
	kp1 *mm_repository.KnowledgeBaseFile
	err error
}

// Expect sets up expected params for RepositoryI.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) Expect(ctx context.Context, fileUID string, updateMap map[string]interface{}) *mRepositoryIMockUpdateKnowledgeBaseFile {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseFileExpectation{}
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by ExpectParams functions")
	}

	mmUpdateKnowledgeBaseFile.defaultExpectation.params = &RepositoryIMockUpdateKnowledgeBaseFileParams{ctx, fileUID, updateMap}
	for _, e := range mmUpdateKnowledgeBaseFile.expectations {
		if minimock.Equal(e.params, mmUpdateKnowledgeBaseFile.defaultExpectation.params) {
			mmUpdateKnowledgeBaseFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateKnowledgeBaseFile.defaultExpectation.params)
		}
	}

	return mmUpdateKnowledgeBaseFile
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockUpdateKnowledgeBaseFile {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseFileExpectation{}
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKnowledgeBaseFileParamPtrs{}
	}
	mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateKnowledgeBaseFile
}

// ExpectFileUIDParam2 sets up expected param fileUID for RepositoryI.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) ExpectFileUIDParam2(fileUID string) *mRepositoryIMockUpdateKnowledgeBaseFile {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseFileExpectation{}
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKnowledgeBaseFileParamPtrs{}
	}
	mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs.fileUID = &fileUID

	return mmUpdateKnowledgeBaseFile
}

// ExpectUpdateMapParam3 sets up expected param updateMap for RepositoryI.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) ExpectUpdateMapParam3(updateMap map[string]interface{}) *mRepositoryIMockUpdateKnowledgeBaseFile {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseFileExpectation{}
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryIMockUpdateKnowledgeBaseFileParamPtrs{}
	}
	mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs.updateMap = &updateMap

	return mmUpdateKnowledgeBaseFile
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) Inspect(f func(ctx context.Context, fileUID string, updateMap map[string]interface{})) *mRepositoryIMockUpdateKnowledgeBaseFile {
	if mmUpdateKnowledgeBaseFile.mock.inspectFuncUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.UpdateKnowledgeBaseFile")
	}

	mmUpdateKnowledgeBaseFile.mock.inspectFuncUpdateKnowledgeBaseFile = f

	return mmUpdateKnowledgeBaseFile
}

// Return sets up results that will be returned by RepositoryI.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) Return(kp1 *mm_repository.KnowledgeBaseFile, err error) *RepositoryIMock {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation = &RepositoryIMockUpdateKnowledgeBaseFileExpectation{mock: mmUpdateKnowledgeBaseFile.mock}
	}
	mmUpdateKnowledgeBaseFile.defaultExpectation.results = &RepositoryIMockUpdateKnowledgeBaseFileResults{kp1, err}
	return mmUpdateKnowledgeBaseFile.mock
}

// Set uses given function f to mock the RepositoryI.UpdateKnowledgeBaseFile method
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) Set(f func(ctx context.Context, fileUID string, updateMap map[string]interface{}) (kp1 *mm_repository.KnowledgeBaseFile, err error)) *RepositoryIMock {
	if mmUpdateKnowledgeBaseFile.defaultExpectation != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("Default expectation is already set for the RepositoryI.UpdateKnowledgeBaseFile method")
	}

	if len(mmUpdateKnowledgeBaseFile.expectations) > 0 {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("Some expectations are already set for the RepositoryI.UpdateKnowledgeBaseFile method")
	}

	mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile = f
	return mmUpdateKnowledgeBaseFile.mock
}

// When sets expectation for the RepositoryI.UpdateKnowledgeBaseFile which will trigger the result defined by the following
// Then helper
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) When(ctx context.Context, fileUID string, updateMap map[string]interface{}) *RepositoryIMockUpdateKnowledgeBaseFileExpectation {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryIMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	expectation := &RepositoryIMockUpdateKnowledgeBaseFileExpectation{
		mock:   mmUpdateKnowledgeBaseFile.mock,
		params: &RepositoryIMockUpdateKnowledgeBaseFileParams{ctx, fileUID, updateMap},
	}
	mmUpdateKnowledgeBaseFile.expectations = append(mmUpdateKnowledgeBaseFile.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.UpdateKnowledgeBaseFile return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockUpdateKnowledgeBaseFileExpectation) Then(kp1 *mm_repository.KnowledgeBaseFile, err error) *RepositoryIMock {
	e.results = &RepositoryIMockUpdateKnowledgeBaseFileResults{kp1, err}
	return e.mock
}

// Times sets number of times RepositoryI.UpdateKnowledgeBaseFile should be invoked
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) Times(n uint64) *mRepositoryIMockUpdateKnowledgeBaseFile {
	if n == 0 {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("Times of RepositoryIMock.UpdateKnowledgeBaseFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateKnowledgeBaseFile.expectedInvocations, n)
	return mmUpdateKnowledgeBaseFile
}

func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) invocationsDone() bool {
	if len(mmUpdateKnowledgeBaseFile.expectations) == 0 && mmUpdateKnowledgeBaseFile.defaultExpectation == nil && mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseFile.mock.afterUpdateKnowledgeBaseFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateKnowledgeBaseFile implements repository.RepositoryI
func (mmUpdateKnowledgeBaseFile *RepositoryIMock) UpdateKnowledgeBaseFile(ctx context.Context, fileUID string, updateMap map[string]interface{}) (kp1 *mm_repository.KnowledgeBaseFile, err error) {
	mm_atomic.AddUint64(&mmUpdateKnowledgeBaseFile.beforeUpdateKnowledgeBaseFileCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateKnowledgeBaseFile.afterUpdateKnowledgeBaseFileCounter, 1)

	if mmUpdateKnowledgeBaseFile.inspectFuncUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.inspectFuncUpdateKnowledgeBaseFile(ctx, fileUID, updateMap)
	}

	mm_params := RepositoryIMockUpdateKnowledgeBaseFileParams{ctx, fileUID, updateMap}

	// Record call args
	mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.mutex.Lock()
	mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.callArgs = append(mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.callArgs, &mm_params)
	mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.mutex.Unlock()

	for _, e := range mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockUpdateKnowledgeBaseFileParams{ctx, fileUID, updateMap}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateKnowledgeBaseFile.t.Errorf("RepositoryIMock.UpdateKnowledgeBaseFile got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmUpdateKnowledgeBaseFile.t.Errorf("RepositoryIMock.UpdateKnowledgeBaseFile got unexpected parameter fileUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

			if mm_want_ptrs.updateMap != nil && !minimock.Equal(*mm_want_ptrs.updateMap, mm_got.updateMap) {
				mmUpdateKnowledgeBaseFile.t.Errorf("RepositoryIMock.UpdateKnowledgeBaseFile got unexpected parameter updateMap, want: %#v, got: %#v%s\n", *mm_want_ptrs.updateMap, mm_got.updateMap, minimock.Diff(*mm_want_ptrs.updateMap, mm_got.updateMap))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateKnowledgeBaseFile.t.Errorf("RepositoryIMock.UpdateKnowledgeBaseFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateKnowledgeBaseFile.t.Fatal("No results are set for the RepositoryIMock.UpdateKnowledgeBaseFile")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmUpdateKnowledgeBaseFile.funcUpdateKnowledgeBaseFile != nil {
		return mmUpdateKnowledgeBaseFile.funcUpdateKnowledgeBaseFile(ctx, fileUID, updateMap)
	}
	mmUpdateKnowledgeBaseFile.t.Fatalf("Unexpected call to RepositoryIMock.UpdateKnowledgeBaseFile. %v %v %v", ctx, fileUID, updateMap)
	return
}

// UpdateKnowledgeBaseFileAfterCounter returns a count of finished RepositoryIMock.UpdateKnowledgeBaseFile invocations
func (mmUpdateKnowledgeBaseFile *RepositoryIMock) UpdateKnowledgeBaseFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseFile.afterUpdateKnowledgeBaseFileCounter)
}

// UpdateKnowledgeBaseFileBeforeCounter returns a count of RepositoryIMock.UpdateKnowledgeBaseFile invocations
func (mmUpdateKnowledgeBaseFile *RepositoryIMock) UpdateKnowledgeBaseFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseFile.beforeUpdateKnowledgeBaseFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.UpdateKnowledgeBaseFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateKnowledgeBaseFile *mRepositoryIMockUpdateKnowledgeBaseFile) Calls() []*RepositoryIMockUpdateKnowledgeBaseFileParams {
	mmUpdateKnowledgeBaseFile.mutex.RLock()

	argCopy := make([]*RepositoryIMockUpdateKnowledgeBaseFileParams, len(mmUpdateKnowledgeBaseFile.callArgs))
	copy(argCopy, mmUpdateKnowledgeBaseFile.callArgs)

	mmUpdateKnowledgeBaseFile.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateKnowledgeBaseFileDone returns true if the count of the UpdateKnowledgeBaseFile invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockUpdateKnowledgeBaseFileDone() bool {
	for _, e := range m.UpdateKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateKnowledgeBaseFileMock.invocationsDone()
}

// MinimockUpdateKnowledgeBaseFileInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockUpdateKnowledgeBaseFileInspect() {
	for _, e := range m.UpdateKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateKnowledgeBaseFile with params: %#v", *e.params)
		}
	}

	afterUpdateKnowledgeBaseFileCounter := mm_atomic.LoadUint64(&m.afterUpdateKnowledgeBaseFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateKnowledgeBaseFileMock.defaultExpectation != nil && afterUpdateKnowledgeBaseFileCounter < 1 {
		if m.UpdateKnowledgeBaseFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.UpdateKnowledgeBaseFile")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.UpdateKnowledgeBaseFile with params: %#v", *m.UpdateKnowledgeBaseFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateKnowledgeBaseFile != nil && afterUpdateKnowledgeBaseFileCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.UpdateKnowledgeBaseFile")
	}

	if !m.UpdateKnowledgeBaseFileMock.invocationsDone() && afterUpdateKnowledgeBaseFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.UpdateKnowledgeBaseFile but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateKnowledgeBaseFileMock.expectedInvocations), afterUpdateKnowledgeBaseFileCounter)
	}
}

type mRepositoryIMockUpsertEmbeddings struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockUpsertEmbeddingsExpectation
	expectations       []*RepositoryIMockUpsertEmbeddingsExpectation

	callArgs []*RepositoryIMockUpsertEmbeddingsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockUpsertEmbeddingsExpectation specifies expectation struct of the RepositoryI.UpsertEmbeddings
type RepositoryIMockUpsertEmbeddingsExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockUpsertEmbeddingsParams
	paramPtrs *RepositoryIMockUpsertEmbeddingsParamPtrs
	results   *RepositoryIMockUpsertEmbeddingsResults
	Counter   uint64
}

// RepositoryIMockUpsertEmbeddingsParams contains parameters of the RepositoryI.UpsertEmbeddings
type RepositoryIMockUpsertEmbeddingsParams struct {
	ctx                 context.Context
	embeddings          []mm_repository.Embedding
	externalServiceCall func(embUIDs []string) error
}

// RepositoryIMockUpsertEmbeddingsParamPtrs contains pointers to parameters of the RepositoryI.UpsertEmbeddings
type RepositoryIMockUpsertEmbeddingsParamPtrs struct {
	ctx                 *context.Context
	embeddings          *[]mm_repository.Embedding
	externalServiceCall *func(embUIDs []string) error
}

// RepositoryIMockUpsertEmbeddingsResults contains results of the RepositoryI.UpsertEmbeddings
type RepositoryIMockUpsertEmbeddingsResults struct {
	ea1 []mm_repository.Embedding
	err error
}

// Expect sets up expected params for RepositoryI.UpsertEmbeddings
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) Expect(ctx context.Context, embeddings []mm_repository.Embedding, externalServiceCall func(embUIDs []string) error) *mRepositoryIMockUpsertEmbeddings {
	if mmUpsertEmbeddings.mock.funcUpsertEmbeddings != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by Set")
	}

	if mmUpsertEmbeddings.defaultExpectation == nil {
		mmUpsertEmbeddings.defaultExpectation = &RepositoryIMockUpsertEmbeddingsExpectation{}
	}

	if mmUpsertEmbeddings.defaultExpectation.paramPtrs != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by ExpectParams functions")
	}

	mmUpsertEmbeddings.defaultExpectation.params = &RepositoryIMockUpsertEmbeddingsParams{ctx, embeddings, externalServiceCall}
	for _, e := range mmUpsertEmbeddings.expectations {
		if minimock.Equal(e.params, mmUpsertEmbeddings.defaultExpectation.params) {
			mmUpsertEmbeddings.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertEmbeddings.defaultExpectation.params)
		}
	}

	return mmUpsertEmbeddings
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.UpsertEmbeddings
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockUpsertEmbeddings {
	if mmUpsertEmbeddings.mock.funcUpsertEmbeddings != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by Set")
	}

	if mmUpsertEmbeddings.defaultExpectation == nil {
		mmUpsertEmbeddings.defaultExpectation = &RepositoryIMockUpsertEmbeddingsExpectation{}
	}

	if mmUpsertEmbeddings.defaultExpectation.params != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by Expect")
	}

	if mmUpsertEmbeddings.defaultExpectation.paramPtrs == nil {
		mmUpsertEmbeddings.defaultExpectation.paramPtrs = &RepositoryIMockUpsertEmbeddingsParamPtrs{}
	}
	mmUpsertEmbeddings.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpsertEmbeddings
}

// ExpectEmbeddingsParam2 sets up expected param embeddings for RepositoryI.UpsertEmbeddings
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) ExpectEmbeddingsParam2(embeddings []mm_repository.Embedding) *mRepositoryIMockUpsertEmbeddings {
	if mmUpsertEmbeddings.mock.funcUpsertEmbeddings != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by Set")
	}

	if mmUpsertEmbeddings.defaultExpectation == nil {
		mmUpsertEmbeddings.defaultExpectation = &RepositoryIMockUpsertEmbeddingsExpectation{}
	}

	if mmUpsertEmbeddings.defaultExpectation.params != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by Expect")
	}

	if mmUpsertEmbeddings.defaultExpectation.paramPtrs == nil {
		mmUpsertEmbeddings.defaultExpectation.paramPtrs = &RepositoryIMockUpsertEmbeddingsParamPtrs{}
	}
	mmUpsertEmbeddings.defaultExpectation.paramPtrs.embeddings = &embeddings

	return mmUpsertEmbeddings
}

// ExpectExternalServiceCallParam3 sets up expected param externalServiceCall for RepositoryI.UpsertEmbeddings
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) ExpectExternalServiceCallParam3(externalServiceCall func(embUIDs []string) error) *mRepositoryIMockUpsertEmbeddings {
	if mmUpsertEmbeddings.mock.funcUpsertEmbeddings != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by Set")
	}

	if mmUpsertEmbeddings.defaultExpectation == nil {
		mmUpsertEmbeddings.defaultExpectation = &RepositoryIMockUpsertEmbeddingsExpectation{}
	}

	if mmUpsertEmbeddings.defaultExpectation.params != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by Expect")
	}

	if mmUpsertEmbeddings.defaultExpectation.paramPtrs == nil {
		mmUpsertEmbeddings.defaultExpectation.paramPtrs = &RepositoryIMockUpsertEmbeddingsParamPtrs{}
	}
	mmUpsertEmbeddings.defaultExpectation.paramPtrs.externalServiceCall = &externalServiceCall

	return mmUpsertEmbeddings
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.UpsertEmbeddings
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) Inspect(f func(ctx context.Context, embeddings []mm_repository.Embedding, externalServiceCall func(embUIDs []string) error)) *mRepositoryIMockUpsertEmbeddings {
	if mmUpsertEmbeddings.mock.inspectFuncUpsertEmbeddings != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.UpsertEmbeddings")
	}

	mmUpsertEmbeddings.mock.inspectFuncUpsertEmbeddings = f

	return mmUpsertEmbeddings
}

// Return sets up results that will be returned by RepositoryI.UpsertEmbeddings
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) Return(ea1 []mm_repository.Embedding, err error) *RepositoryIMock {
	if mmUpsertEmbeddings.mock.funcUpsertEmbeddings != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by Set")
	}

	if mmUpsertEmbeddings.defaultExpectation == nil {
		mmUpsertEmbeddings.defaultExpectation = &RepositoryIMockUpsertEmbeddingsExpectation{mock: mmUpsertEmbeddings.mock}
	}
	mmUpsertEmbeddings.defaultExpectation.results = &RepositoryIMockUpsertEmbeddingsResults{ea1, err}
	return mmUpsertEmbeddings.mock
}

// Set uses given function f to mock the RepositoryI.UpsertEmbeddings method
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) Set(f func(ctx context.Context, embeddings []mm_repository.Embedding, externalServiceCall func(embUIDs []string) error) (ea1 []mm_repository.Embedding, err error)) *RepositoryIMock {
	if mmUpsertEmbeddings.defaultExpectation != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("Default expectation is already set for the RepositoryI.UpsertEmbeddings method")
	}

	if len(mmUpsertEmbeddings.expectations) > 0 {
		mmUpsertEmbeddings.mock.t.Fatalf("Some expectations are already set for the RepositoryI.UpsertEmbeddings method")
	}

	mmUpsertEmbeddings.mock.funcUpsertEmbeddings = f
	return mmUpsertEmbeddings.mock
}

// When sets expectation for the RepositoryI.UpsertEmbeddings which will trigger the result defined by the following
// Then helper
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) When(ctx context.Context, embeddings []mm_repository.Embedding, externalServiceCall func(embUIDs []string) error) *RepositoryIMockUpsertEmbeddingsExpectation {
	if mmUpsertEmbeddings.mock.funcUpsertEmbeddings != nil {
		mmUpsertEmbeddings.mock.t.Fatalf("RepositoryIMock.UpsertEmbeddings mock is already set by Set")
	}

	expectation := &RepositoryIMockUpsertEmbeddingsExpectation{
		mock:   mmUpsertEmbeddings.mock,
		params: &RepositoryIMockUpsertEmbeddingsParams{ctx, embeddings, externalServiceCall},
	}
	mmUpsertEmbeddings.expectations = append(mmUpsertEmbeddings.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.UpsertEmbeddings return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockUpsertEmbeddingsExpectation) Then(ea1 []mm_repository.Embedding, err error) *RepositoryIMock {
	e.results = &RepositoryIMockUpsertEmbeddingsResults{ea1, err}
	return e.mock
}

// Times sets number of times RepositoryI.UpsertEmbeddings should be invoked
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) Times(n uint64) *mRepositoryIMockUpsertEmbeddings {
	if n == 0 {
		mmUpsertEmbeddings.mock.t.Fatalf("Times of RepositoryIMock.UpsertEmbeddings mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpsertEmbeddings.expectedInvocations, n)
	return mmUpsertEmbeddings
}

func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) invocationsDone() bool {
	if len(mmUpsertEmbeddings.expectations) == 0 && mmUpsertEmbeddings.defaultExpectation == nil && mmUpsertEmbeddings.mock.funcUpsertEmbeddings == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpsertEmbeddings.mock.afterUpsertEmbeddingsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpsertEmbeddings.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpsertEmbeddings implements repository.RepositoryI
func (mmUpsertEmbeddings *RepositoryIMock) UpsertEmbeddings(ctx context.Context, embeddings []mm_repository.Embedding, externalServiceCall func(embUIDs []string) error) (ea1 []mm_repository.Embedding, err error) {
	mm_atomic.AddUint64(&mmUpsertEmbeddings.beforeUpsertEmbeddingsCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertEmbeddings.afterUpsertEmbeddingsCounter, 1)

	if mmUpsertEmbeddings.inspectFuncUpsertEmbeddings != nil {
		mmUpsertEmbeddings.inspectFuncUpsertEmbeddings(ctx, embeddings, externalServiceCall)
	}

	mm_params := RepositoryIMockUpsertEmbeddingsParams{ctx, embeddings, externalServiceCall}

	// Record call args
	mmUpsertEmbeddings.UpsertEmbeddingsMock.mutex.Lock()
	mmUpsertEmbeddings.UpsertEmbeddingsMock.callArgs = append(mmUpsertEmbeddings.UpsertEmbeddingsMock.callArgs, &mm_params)
	mmUpsertEmbeddings.UpsertEmbeddingsMock.mutex.Unlock()

	for _, e := range mmUpsertEmbeddings.UpsertEmbeddingsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1, e.results.err
		}
	}

	if mmUpsertEmbeddings.UpsertEmbeddingsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertEmbeddings.UpsertEmbeddingsMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsertEmbeddings.UpsertEmbeddingsMock.defaultExpectation.params
		mm_want_ptrs := mmUpsertEmbeddings.UpsertEmbeddingsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockUpsertEmbeddingsParams{ctx, embeddings, externalServiceCall}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpsertEmbeddings.t.Errorf("RepositoryIMock.UpsertEmbeddings got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.embeddings != nil && !minimock.Equal(*mm_want_ptrs.embeddings, mm_got.embeddings) {
				mmUpsertEmbeddings.t.Errorf("RepositoryIMock.UpsertEmbeddings got unexpected parameter embeddings, want: %#v, got: %#v%s\n", *mm_want_ptrs.embeddings, mm_got.embeddings, minimock.Diff(*mm_want_ptrs.embeddings, mm_got.embeddings))
			}

			if mm_want_ptrs.externalServiceCall != nil && !minimock.Equal(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall) {
				mmUpsertEmbeddings.t.Errorf("RepositoryIMock.UpsertEmbeddings got unexpected parameter externalServiceCall, want: %#v, got: %#v%s\n", *mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall, minimock.Diff(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsertEmbeddings.t.Errorf("RepositoryIMock.UpsertEmbeddings got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsertEmbeddings.UpsertEmbeddingsMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsertEmbeddings.t.Fatal("No results are set for the RepositoryIMock.UpsertEmbeddings")
		}
		return (*mm_results).ea1, (*mm_results).err
	}
	if mmUpsertEmbeddings.funcUpsertEmbeddings != nil {
		return mmUpsertEmbeddings.funcUpsertEmbeddings(ctx, embeddings, externalServiceCall)
	}
	mmUpsertEmbeddings.t.Fatalf("Unexpected call to RepositoryIMock.UpsertEmbeddings. %v %v %v", ctx, embeddings, externalServiceCall)
	return
}

// UpsertEmbeddingsAfterCounter returns a count of finished RepositoryIMock.UpsertEmbeddings invocations
func (mmUpsertEmbeddings *RepositoryIMock) UpsertEmbeddingsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertEmbeddings.afterUpsertEmbeddingsCounter)
}

// UpsertEmbeddingsBeforeCounter returns a count of RepositoryIMock.UpsertEmbeddings invocations
func (mmUpsertEmbeddings *RepositoryIMock) UpsertEmbeddingsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertEmbeddings.beforeUpsertEmbeddingsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.UpsertEmbeddings.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertEmbeddings *mRepositoryIMockUpsertEmbeddings) Calls() []*RepositoryIMockUpsertEmbeddingsParams {
	mmUpsertEmbeddings.mutex.RLock()

	argCopy := make([]*RepositoryIMockUpsertEmbeddingsParams, len(mmUpsertEmbeddings.callArgs))
	copy(argCopy, mmUpsertEmbeddings.callArgs)

	mmUpsertEmbeddings.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertEmbeddingsDone returns true if the count of the UpsertEmbeddings invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockUpsertEmbeddingsDone() bool {
	for _, e := range m.UpsertEmbeddingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpsertEmbeddingsMock.invocationsDone()
}

// MinimockUpsertEmbeddingsInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockUpsertEmbeddingsInspect() {
	for _, e := range m.UpsertEmbeddingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.UpsertEmbeddings with params: %#v", *e.params)
		}
	}

	afterUpsertEmbeddingsCounter := mm_atomic.LoadUint64(&m.afterUpsertEmbeddingsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertEmbeddingsMock.defaultExpectation != nil && afterUpsertEmbeddingsCounter < 1 {
		if m.UpsertEmbeddingsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.UpsertEmbeddings")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.UpsertEmbeddings with params: %#v", *m.UpsertEmbeddingsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertEmbeddings != nil && afterUpsertEmbeddingsCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.UpsertEmbeddings")
	}

	if !m.UpsertEmbeddingsMock.invocationsDone() && afterUpsertEmbeddingsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.UpsertEmbeddings but found %d calls",
			mm_atomic.LoadUint64(&m.UpsertEmbeddingsMock.expectedInvocations), afterUpsertEmbeddingsCounter)
	}
}

type mRepositoryIMockUpsertRepositoryTag struct {
	mock               *RepositoryIMock
	defaultExpectation *RepositoryIMockUpsertRepositoryTagExpectation
	expectations       []*RepositoryIMockUpsertRepositoryTagExpectation

	callArgs []*RepositoryIMockUpsertRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryIMockUpsertRepositoryTagExpectation specifies expectation struct of the RepositoryI.UpsertRepositoryTag
type RepositoryIMockUpsertRepositoryTagExpectation struct {
	mock      *RepositoryIMock
	params    *RepositoryIMockUpsertRepositoryTagParams
	paramPtrs *RepositoryIMockUpsertRepositoryTagParamPtrs
	results   *RepositoryIMockUpsertRepositoryTagResults
	Counter   uint64
}

// RepositoryIMockUpsertRepositoryTagParams contains parameters of the RepositoryI.UpsertRepositoryTag
type RepositoryIMockUpsertRepositoryTagParams struct {
	ctx context.Context
	rp1 *pb.RepositoryTag
}

// RepositoryIMockUpsertRepositoryTagParamPtrs contains pointers to parameters of the RepositoryI.UpsertRepositoryTag
type RepositoryIMockUpsertRepositoryTagParamPtrs struct {
	ctx *context.Context
	rp1 **pb.RepositoryTag
}

// RepositoryIMockUpsertRepositoryTagResults contains results of the RepositoryI.UpsertRepositoryTag
type RepositoryIMockUpsertRepositoryTagResults struct {
	rp2 *pb.RepositoryTag
	err error
}

// Expect sets up expected params for RepositoryI.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) Expect(ctx context.Context, rp1 *pb.RepositoryTag) *mRepositoryIMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryIMockUpsertRepositoryTagExpectation{}
	}

	if mmUpsertRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by ExpectParams functions")
	}

	mmUpsertRepositoryTag.defaultExpectation.params = &RepositoryIMockUpsertRepositoryTagParams{ctx, rp1}
	for _, e := range mmUpsertRepositoryTag.expectations {
		if minimock.Equal(e.params, mmUpsertRepositoryTag.defaultExpectation.params) {
			mmUpsertRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertRepositoryTag.defaultExpectation.params)
		}
	}

	return mmUpsertRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for RepositoryI.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) ExpectCtxParam1(ctx context.Context) *mRepositoryIMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryIMockUpsertRepositoryTagExpectation{}
	}

	if mmUpsertRepositoryTag.defaultExpectation.params != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by Expect")
	}

	if mmUpsertRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmUpsertRepositoryTag.defaultExpectation.paramPtrs = &RepositoryIMockUpsertRepositoryTagParamPtrs{}
	}
	mmUpsertRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpsertRepositoryTag
}

// ExpectRp1Param2 sets up expected param rp1 for RepositoryI.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) ExpectRp1Param2(rp1 *pb.RepositoryTag) *mRepositoryIMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryIMockUpsertRepositoryTagExpectation{}
	}

	if mmUpsertRepositoryTag.defaultExpectation.params != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by Expect")
	}

	if mmUpsertRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmUpsertRepositoryTag.defaultExpectation.paramPtrs = &RepositoryIMockUpsertRepositoryTagParamPtrs{}
	}
	mmUpsertRepositoryTag.defaultExpectation.paramPtrs.rp1 = &rp1

	return mmUpsertRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the RepositoryI.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) Inspect(f func(ctx context.Context, rp1 *pb.RepositoryTag)) *mRepositoryIMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.inspectFuncUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("Inspect function is already set for RepositoryIMock.UpsertRepositoryTag")
	}

	mmUpsertRepositoryTag.mock.inspectFuncUpsertRepositoryTag = f

	return mmUpsertRepositoryTag
}

// Return sets up results that will be returned by RepositoryI.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) Return(rp2 *pb.RepositoryTag, err error) *RepositoryIMock {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryIMockUpsertRepositoryTagExpectation{mock: mmUpsertRepositoryTag.mock}
	}
	mmUpsertRepositoryTag.defaultExpectation.results = &RepositoryIMockUpsertRepositoryTagResults{rp2, err}
	return mmUpsertRepositoryTag.mock
}

// Set uses given function f to mock the RepositoryI.UpsertRepositoryTag method
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) Set(f func(ctx context.Context, rp1 *pb.RepositoryTag) (rp2 *pb.RepositoryTag, err error)) *RepositoryIMock {
	if mmUpsertRepositoryTag.defaultExpectation != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("Default expectation is already set for the RepositoryI.UpsertRepositoryTag method")
	}

	if len(mmUpsertRepositoryTag.expectations) > 0 {
		mmUpsertRepositoryTag.mock.t.Fatalf("Some expectations are already set for the RepositoryI.UpsertRepositoryTag method")
	}

	mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag = f
	return mmUpsertRepositoryTag.mock
}

// When sets expectation for the RepositoryI.UpsertRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) When(ctx context.Context, rp1 *pb.RepositoryTag) *RepositoryIMockUpsertRepositoryTagExpectation {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryIMock.UpsertRepositoryTag mock is already set by Set")
	}

	expectation := &RepositoryIMockUpsertRepositoryTagExpectation{
		mock:   mmUpsertRepositoryTag.mock,
		params: &RepositoryIMockUpsertRepositoryTagParams{ctx, rp1},
	}
	mmUpsertRepositoryTag.expectations = append(mmUpsertRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up RepositoryI.UpsertRepositoryTag return parameters for the expectation previously defined by the When method
func (e *RepositoryIMockUpsertRepositoryTagExpectation) Then(rp2 *pb.RepositoryTag, err error) *RepositoryIMock {
	e.results = &RepositoryIMockUpsertRepositoryTagResults{rp2, err}
	return e.mock
}

// Times sets number of times RepositoryI.UpsertRepositoryTag should be invoked
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) Times(n uint64) *mRepositoryIMockUpsertRepositoryTag {
	if n == 0 {
		mmUpsertRepositoryTag.mock.t.Fatalf("Times of RepositoryIMock.UpsertRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpsertRepositoryTag.expectedInvocations, n)
	return mmUpsertRepositoryTag
}

func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) invocationsDone() bool {
	if len(mmUpsertRepositoryTag.expectations) == 0 && mmUpsertRepositoryTag.defaultExpectation == nil && mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpsertRepositoryTag.mock.afterUpsertRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpsertRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpsertRepositoryTag implements repository.RepositoryI
func (mmUpsertRepositoryTag *RepositoryIMock) UpsertRepositoryTag(ctx context.Context, rp1 *pb.RepositoryTag) (rp2 *pb.RepositoryTag, err error) {
	mm_atomic.AddUint64(&mmUpsertRepositoryTag.beforeUpsertRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertRepositoryTag.afterUpsertRepositoryTagCounter, 1)

	if mmUpsertRepositoryTag.inspectFuncUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.inspectFuncUpsertRepositoryTag(ctx, rp1)
	}

	mm_params := RepositoryIMockUpsertRepositoryTagParams{ctx, rp1}

	// Record call args
	mmUpsertRepositoryTag.UpsertRepositoryTagMock.mutex.Lock()
	mmUpsertRepositoryTag.UpsertRepositoryTagMock.callArgs = append(mmUpsertRepositoryTag.UpsertRepositoryTagMock.callArgs, &mm_params)
	mmUpsertRepositoryTag.UpsertRepositoryTagMock.mutex.Unlock()

	for _, e := range mmUpsertRepositoryTag.UpsertRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp2, e.results.err
		}
	}

	if mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := RepositoryIMockUpsertRepositoryTagParams{ctx, rp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpsertRepositoryTag.t.Errorf("RepositoryIMock.UpsertRepositoryTag got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.rp1 != nil && !minimock.Equal(*mm_want_ptrs.rp1, mm_got.rp1) {
				mmUpsertRepositoryTag.t.Errorf("RepositoryIMock.UpsertRepositoryTag got unexpected parameter rp1, want: %#v, got: %#v%s\n", *mm_want_ptrs.rp1, mm_got.rp1, minimock.Diff(*mm_want_ptrs.rp1, mm_got.rp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsertRepositoryTag.t.Errorf("RepositoryIMock.UpsertRepositoryTag got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsertRepositoryTag.t.Fatal("No results are set for the RepositoryIMock.UpsertRepositoryTag")
		}
		return (*mm_results).rp2, (*mm_results).err
	}
	if mmUpsertRepositoryTag.funcUpsertRepositoryTag != nil {
		return mmUpsertRepositoryTag.funcUpsertRepositoryTag(ctx, rp1)
	}
	mmUpsertRepositoryTag.t.Fatalf("Unexpected call to RepositoryIMock.UpsertRepositoryTag. %v %v", ctx, rp1)
	return
}

// UpsertRepositoryTagAfterCounter returns a count of finished RepositoryIMock.UpsertRepositoryTag invocations
func (mmUpsertRepositoryTag *RepositoryIMock) UpsertRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertRepositoryTag.afterUpsertRepositoryTagCounter)
}

// UpsertRepositoryTagBeforeCounter returns a count of RepositoryIMock.UpsertRepositoryTag invocations
func (mmUpsertRepositoryTag *RepositoryIMock) UpsertRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertRepositoryTag.beforeUpsertRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to RepositoryIMock.UpsertRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertRepositoryTag *mRepositoryIMockUpsertRepositoryTag) Calls() []*RepositoryIMockUpsertRepositoryTagParams {
	mmUpsertRepositoryTag.mutex.RLock()

	argCopy := make([]*RepositoryIMockUpsertRepositoryTagParams, len(mmUpsertRepositoryTag.callArgs))
	copy(argCopy, mmUpsertRepositoryTag.callArgs)

	mmUpsertRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertRepositoryTagDone returns true if the count of the UpsertRepositoryTag invocations corresponds
// the number of defined expectations
func (m *RepositoryIMock) MinimockUpsertRepositoryTagDone() bool {
	for _, e := range m.UpsertRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpsertRepositoryTagMock.invocationsDone()
}

// MinimockUpsertRepositoryTagInspect logs each unmet expectation
func (m *RepositoryIMock) MinimockUpsertRepositoryTagInspect() {
	for _, e := range m.UpsertRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryIMock.UpsertRepositoryTag with params: %#v", *e.params)
		}
	}

	afterUpsertRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterUpsertRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertRepositoryTagMock.defaultExpectation != nil && afterUpsertRepositoryTagCounter < 1 {
		if m.UpsertRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryIMock.UpsertRepositoryTag")
		} else {
			m.t.Errorf("Expected call to RepositoryIMock.UpsertRepositoryTag with params: %#v", *m.UpsertRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertRepositoryTag != nil && afterUpsertRepositoryTagCounter < 1 {
		m.t.Error("Expected call to RepositoryIMock.UpsertRepositoryTag")
	}

	if !m.UpsertRepositoryTagMock.invocationsDone() && afterUpsertRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryIMock.UpsertRepositoryTag but found %d calls",
			mm_atomic.LoadUint64(&m.UpsertRepositoryTagMock.expectedInvocations), afterUpsertRepositoryTagCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryIMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockConvertedFileTableNameInspect()

			m.MinimockCreateConvertedFileInspect()

			m.MinimockCreateKnowledgeBaseInspect()

			m.MinimockCreateKnowledgeBaseFileInspect()

			m.MinimockDeleteAndCreateChunksInspect()

			m.MinimockDeleteChunksBySourceInspect()

			m.MinimockDeleteChunksByUIDsInspect()

			m.MinimockDeleteConvertedFileInspect()

			m.MinimockDeleteEmbeddingsBySourceInspect()

			m.MinimockDeleteEmbeddingsByUIDsInspect()

			m.MinimockDeleteKnowledgeBaseInspect()

			m.MinimockDeleteKnowledgeBaseFileInspect()

			m.MinimockDeleteRepositoryTagInspect()

			m.MinimockGetConvertedFileByFileUIDInspect()

			m.MinimockGetIncompleteFileInspect()

			m.MinimockGetKnowledgeBaseByOwnerAndIDInspect()

			m.MinimockGetRepositoryTagInspect()

			m.MinimockGetTextChunksBySourceInspect()

			m.MinimockKnowledgeBaseFileTableNameInspect()

			m.MinimockListKnowledgeBaseFilesInspect()

			m.MinimockListKnowledgeBasesInspect()

			m.MinimockProcessKnowledgeBaseFilesInspect()

			m.MinimockUpdateKnowledgeBaseInspect()

			m.MinimockUpdateKnowledgeBaseFileInspect()

			m.MinimockUpsertEmbeddingsInspect()

			m.MinimockUpsertRepositoryTagInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryIMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryIMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockConvertedFileTableNameDone() &&
		m.MinimockCreateConvertedFileDone() &&
		m.MinimockCreateKnowledgeBaseDone() &&
		m.MinimockCreateKnowledgeBaseFileDone() &&
		m.MinimockDeleteAndCreateChunksDone() &&
		m.MinimockDeleteChunksBySourceDone() &&
		m.MinimockDeleteChunksByUIDsDone() &&
		m.MinimockDeleteConvertedFileDone() &&
		m.MinimockDeleteEmbeddingsBySourceDone() &&
		m.MinimockDeleteEmbeddingsByUIDsDone() &&
		m.MinimockDeleteKnowledgeBaseDone() &&
		m.MinimockDeleteKnowledgeBaseFileDone() &&
		m.MinimockDeleteRepositoryTagDone() &&
		m.MinimockGetConvertedFileByFileUIDDone() &&
		m.MinimockGetIncompleteFileDone() &&
		m.MinimockGetKnowledgeBaseByOwnerAndIDDone() &&
		m.MinimockGetRepositoryTagDone() &&
		m.MinimockGetTextChunksBySourceDone() &&
		m.MinimockKnowledgeBaseFileTableNameDone() &&
		m.MinimockListKnowledgeBaseFilesDone() &&
		m.MinimockListKnowledgeBasesDone() &&
		m.MinimockProcessKnowledgeBaseFilesDone() &&
		m.MinimockUpdateKnowledgeBaseDone() &&
		m.MinimockUpdateKnowledgeBaseFileDone() &&
		m.MinimockUpsertEmbeddingsDone() &&
		m.MinimockUpsertRepositoryTagDone()
}
