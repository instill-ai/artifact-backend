package types

import (
	"time"

	"github.com/gofrs/uuid"
)

// FileType represents the type of file being processed
type FileType string

const (
	// DocumentFileType represents the type of document file
	DocumentFileType FileType = "document"
	// VideoFileType represents the type of video file
	VideoFileType FileType = "video"
	// ImageFileType represents the type of image file
	ImageFileType FileType = "image"
	// AudioFileType represents the type of audio file
	AudioFileType FileType = "audio"
)

// CatalogType represents the type of knowledge base catalog
type CatalogType string

const (
	// CatalogTypeUnspecified is the default/unspecified catalog type
	CatalogTypeUnspecified CatalogType = ""
	// CatalogTypePersistent represents a persistent catalog
	CatalogTypePersistent CatalogType = "persistent"
	// CatalogTypeEphemeral represents an ephemeral/temporary catalog
	CatalogTypeEphemeral CatalogType = "ephemeral"
)

// Tag represents a repository tag (domain model)
type Tag struct {
	Name       string    // The name of the tag (e.g. "repositories/{repo}/tags/{id}")
	ID         string    // The tag identifier
	Digest     string    // Unique identifier from the manifest
	UpdateTime time.Time // Tag update time
}

// ContentType represents the type of content in a chunk
type ContentType string

const (
	// ChunkContentType represents the type of chunk content
	ChunkContentType ContentType = "chunk"
	// SummaryContentType represents the type of summary content
	SummaryContentType ContentType = "summary"
	// AugmentedContentType represents the type of augmented content
	AugmentedContentType ContentType = "augmented"
)

// PositionData contains metadata from the file-to-markdown conversion step used for visual grounding.
// It maps text positions in the stored markdown back to their location in the original file (page numbers).
// This is generated by both AI conversion (Gemini, etc.) and pipeline conversion routes.
//
// PageDelimiters store the END position (in runes) of each page in the converted markdown:
//   - Delimiter[0] = end of page 1, Delimiter[1] = end of page 2, etc.
//   - AI Route: End position = where next [Page: X] tag starts (or end of doc for last page)
//   - Pipeline Route: End position = cumulative rune count after each page
//   - Both routes produce semantically identical position data
//
// Example: markdown = "[Page: 1]\nContent1\n[Page: 2]\nContent2"
//
//	PageDelimiters = [26, 44]
//	- Delimiter[0] = 26: End of page 1 (where [Page: 2] starts)
//	- Delimiter[1] = 44: End of page 2 (end of document)
//
// Visual grounding usage: Given a text chunk at position P, find its page by checking
// which delimiter range it falls into (0 to delimiter[0] = page 1, delimiter[0] to delimiter[1] = page 2, etc.)
type PositionData struct {
	// PageDelimiters contains the end position (rune offset) of each page in the converted markdown.
	PageDelimiters []uint32 `json:"page_delimiters"`
}

type (
	// KBUIDType is the Knowledge Base unique identifier
	KBUIDType = uuid.UUID
	// FileUIDType is the File unique identifier
	FileUIDType = uuid.UUID
	// TextChunkUIDType is the Text chunk unique identifier
	TextChunkUIDType = uuid.UUID
	// ConvertedFileUIDType is the Converted file unique identifier
	ConvertedFileUIDType = uuid.UUID

	// UserUIDType is the User unique identifier
	UserUIDType = uuid.UUID
	// RequesterUIDType is the Request initiator unique identifier
	RequesterUIDType = uuid.UUID
	// CreatorUIDType is the Creator unique identifier
	CreatorUIDType = uuid.UUID
	// OwnerUIDType is the Owner unique identifier
	OwnerUIDType = uuid.UUID

	// NamespaceUIDType is the Namespace unique identifier
	NamespaceUIDType = uuid.UUID
	// ObjectUIDType is the Object unique identifier
	ObjectUIDType = uuid.UUID

	// SourceUIDType is the Source entity unique identifier
	SourceUIDType = uuid.UUID
	// SourceTableType is the Source table name
	SourceTableType = string
)
