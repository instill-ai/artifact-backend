package types

import (
	"time"

	"github.com/gofrs/uuid"

	artifactpb "github.com/instill-ai/protogen-go/artifact/artifact/v1alpha"
)

// FileType represents the type of file being processed
type FileType string

const (
	// DocumentFileType represents the type of document file
	DocumentFileType FileType = "document"
	// VideoFileType represents the type of video file
	VideoFileType FileType = "video"
	// ImageFileType represents the type of image file
	ImageFileType FileType = "image"
	// AudioFileType represents the type of audio file
	AudioFileType FileType = "audio"
)

// Tag represents a repository tag (domain model)
type Tag struct {
	Name       string    // The name of the tag (e.g. "repositories/{repo}/tags/{id}")
	ID         string    // The tag identifier
	Digest     string    // Unique identifier from the manifest
	UpdateTime time.Time // Tag update time
}

// PositionData contains metadata from the file-to-markdown conversion step used for visual grounding.
// It maps text positions in the stored markdown back to their location in the original file (page numbers).
// This is generated by both AI conversion (Gemini, etc.) and pipeline conversion routes.
//
// PageDelimiters store the END position (in runes) of each page in the converted markdown:
//   - Delimiter[0] = end of page 1, Delimiter[1] = end of page 2, etc.
//   - AI Route: End position = where next [Page: X] tag starts (or end of doc for last page)
//   - Pipeline Route: End position = cumulative rune count after each page
//   - Both routes produce semantically identical position data
//
// Example: markdown = "[Page: 1]\nContent1\n[Page: 2]\nContent2"
//
//	PageDelimiters = [26, 44]
//	- Delimiter[0] = 26: End of page 1 (where [Page: 2] starts)
//	- Delimiter[1] = 44: End of page 2 (end of document)
//
// Visual grounding usage: Given a text chunk at position P, find its page by checking
// which delimiter range it falls into (0 to delimiter[0] = page 1, delimiter[0] to delimiter[1] = page 2, etc.)
type PositionData struct {
	// PageDelimiters contains the end position (rune offset) of each page in the converted markdown.
	PageDelimiters []uint32 `json:"PageDelimiters"`
}

// TextChunkReference contains the position information of the text chunk within the
// original file.
type TextChunkReference struct {
	// PageRange contains the start and end pages of the text chunk when the page
	// belongs to a document. Positions in this case are 1-indexed in order
	// to align with the document visualization standards (e.g. page 4 of 4).
	PageRange [2]uint32 `json:"PageRange,omitempty"`
}

// TextChunk represents a chunk of text extracted from a file.
// It contains position information (Start/End) within the converted markdown,
// token count for embedding purposes, and an optional reference to source pages.
type TextChunk struct {
	// Start and End contain the start and end positions of the chunk within
	// the converted file.
	Start     int
	End       int
	Text      string
	Tokens    int
	Reference *TextChunkReference
	Type      artifactpb.Chunk_Type
}

type (

	// NamespaceUIDType is the Namespace unique identifier
	NamespaceUIDType = uuid.UUID
	// UserUIDType is the User unique identifier
	UserUIDType = uuid.UUID
	// RequesterUIDType is the Request initiator unique identifier
	RequesterUIDType = uuid.UUID
	// CreatorUIDType is the Creator unique identifier
	CreatorUIDType = uuid.UUID
	// OwnerUIDType is the Owner unique identifier
	OwnerUIDType = uuid.UUID

	// KBUIDType is the Knowledge Base unique identifier
	KBUIDType = uuid.UUID
	// CollectionUIDType is the Collection unique identifier
	CollectionUIDType = uuid.UUID
	// FileUIDType is the File unique identifier
	FileUIDType = uuid.UUID
	// TextChunkUIDType is the Text chunk unique identifier
	TextChunkUIDType = uuid.UUID
	// ConvertedFileUIDType is the Converted file unique identifier
	ConvertedFileUIDType = uuid.UUID

	// ObjectUIDType is the Object unique identifier
	ObjectUIDType = uuid.UUID
	// ObjectURLUIDType is the Object URL unique identifier
	ObjectURLUIDType = uuid.UUID

	// SourceUIDType is the Source entity unique identifier
	SourceUIDType = uuid.UUID
	// SourceTableType is the Source table name
	SourceTableType = string

	// EmbeddingUIDType is the Embedding unique identifier
	EmbeddingUIDType = uuid.UUID

	// SystemUIDType is the System unique identifier
	SystemUIDType = uuid.UUID
)
