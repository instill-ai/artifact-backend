package repository

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/gofrs/uuid"

	"github.com/instill-ai/artifact-backend/pkg/types"
	"github.com/milvus-io/milvus/client/v2/column"
	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/client/v2/index"
	"github.com/milvus-io/milvus/client/v2/milvusclient"
	"go.uber.org/zap"

	errorsx "github.com/instill-ai/x/errors"
	logx "github.com/instill-ai/x/log"
)

// VectorEmbedding is a vector representation of an object (extracted from a file as
// part or the whole of its contents) in a collection.
type VectorEmbedding struct {
	SourceTable     string
	SourceUID       string
	EmbeddingUID    string
	Vector          []float32
	FileUID         types.FileUIDType
	FileDisplayName string
	ContentType     string // MIME type (e.g., "text/markdown", "application/pdf")
	ChunkType       string // Chunk classification ("content", "summary", "augmented")
	Tags            []string
	Text            string // Original text content for BM25 sparse vector generation
}

// SimilarVectorEmbedding extends VectorEmbedding to add a similarity search score.
type SimilarVectorEmbedding struct {
	VectorEmbedding
	Score float32
}

// SearchVectorParam contains the parameters for a similarity vector
// search.
type SearchVectorParam struct {
	CollectionID string
	Vectors      [][]float32
	TopK         uint32
	FileUIDs     []types.FileUIDType
	ContentType  string   // MIME type filter (e.g., "text/markdown", "application/pdf")
	ChunkType    string   // Chunk classification filter ("content", "summary", "augmented")
	Tags         []string // Tags to filter by (OR logic when multiple tags provided)
	QueryText    string   // Original query text for BM25 sparse vector generation (hybrid search)

	// The filename filter was implemented back when the filename in a knowledge base was
	// unique, which isn't the case anymore. Using this filter might yield
	// unexpected results if there are several files with the same name in the
	// collection.
	// We need this field, however, as a fallback for collections that don't
	// have a file UID in the schema. Some collections have rigid schemas
	// without dynamic fields, so the original schema (with filename) couldn't
	// be extended and backfilled to have a file UID.
	Filenames []string
}

// VectorDatabase implements the necessary use cases to interact with a vector
// database (e.g., Milvus).
type VectorDatabase interface {
	CreateCollection(_ context.Context, id string, dimensionality uint32) error
	InsertVectorsInCollection(_ context.Context, collID string, embeddings []VectorEmbedding) error
	DropCollection(_ context.Context, id string) error
	SearchVectorsInCollection(context.Context, SearchVectorParam) ([][]SimilarVectorEmbedding, error)
	DeleteEmbeddingsWithFileUID(_ context.Context, collID string, fileUID types.FileUIDType) error
	// CheckFileUIDMetadata checks if the collection has the file UID metadata
	// field, which wasn't introduced since the beginning and is not present in
	// legacy collections.
	CheckFileUIDMetadata(_ context.Context, collectionID string) (bool, error)
	// FlushCollection flushes a collection to persist data immediately
	FlushCollection(_ context.Context, collectionID string) error
	// CollectionExists checks if a collection exists in the vector database
	CollectionExists(_ context.Context, collectionID string) (bool, error)
	// UpdateEmbeddingTags updates tags for all embeddings belonging to a file
	UpdateEmbeddingTags(_ context.Context, collectionID string, fileUID types.FileUIDType, tags []string) error
}

// Milvus implementation constants
const (
	scanNList  = 1024
	metricType = entity.COSINE
	withRaw    = true

	nProbe   = 250
	reorderK = 250

	kbCollectionFieldSourceTable       = "source_table"
	kbCollectionFieldSourceUID         = "source_uid"
	kbCollectionFieldDenseEmbeddingUID = "embedding_uid"
	kbCollectionFieldDenseEmbedding    = "embedding"        // Dense vectors (Gemini 3072-dim)
	kbCollectionFieldSparseEmbedding   = "sparse_embedding" // Sparse vectors (BM25) - auto-generated by Milvus native BM25
	kbCollectionFieldText              = "text"             // Raw text for native Milvus BM25 full-text search
	kbCollectionFieldFileUID           = "file_uid"
	kbCollectionFieldFileName          = "file_name"
	kbCollectionFieldFileType          = "file_type"
	kbCollectionFieldContentType       = "content_type"
	kbCollectionFieldTags              = "tags"

	// BM25 function name for native Milvus full-text search
	bm25FunctionName = "text_bm25_emb"
)

type milvusClient struct {
	c *milvusclient.Client
}

// MilvusConfig holds the configuration for connecting to Milvus or Zilliz Cloud.
// This is a subset of the main config.MilvusConfig to avoid circular imports.
type MilvusConfig struct {
	Host      string
	Port      string
	APIKey    string
	Username  string
	Password  string
	EnableTLS bool
}

// NewVectorDatabase returns a VectorDatabase implementation (milvus).
// Supports both self-hosted Milvus (CE) and Zilliz Cloud (EE) with authentication.
func NewVectorDatabase(ctx context.Context, cfg MilvusConfig) (db VectorDatabase, closeFn func() error, _ error) {
	clientCfg := &milvusclient.ClientConfig{
		Address: cfg.Host + ":" + cfg.Port,
	}

	// Configure authentication
	// API key takes precedence (recommended for Zilliz Cloud)
	if cfg.APIKey != "" {
		clientCfg.APIKey = cfg.APIKey
	} else if cfg.Username != "" && cfg.Password != "" {
		// Fallback to username/password authentication
		clientCfg.Username = cfg.Username
		clientCfg.Password = cfg.Password
	}

	// Enable TLS if configured (required for Zilliz Cloud)
	if cfg.EnableTLS {
		clientCfg.EnableTLSAuth = true
	}

	c, err := milvusclient.New(ctx, clientCfg)
	if err != nil {
		return nil, nil, err
	}

	// Wrap the new Close signature (takes context) to match the old signature (no args)
	closeFn = func() error {
		return c.Close(context.Background())
	}

	return &milvusClient{
		c: c,
	}, closeFn, nil
}

func (m *milvusClient) CreateCollection(ctx context.Context, collectionName string, dimensionality uint32) error {
	logger, _ := logx.GetZapLogger(ctx)
	logger = logger.With(zap.String("collection_name", collectionName), zap.Uint32("dimensionality", dimensionality))

	// 1. Check if the collection already exists
	has, err := m.c.HasCollection(ctx, milvusclient.NewHasCollectionOption(collectionName))
	if err != nil {
		return fmt.Errorf("checking collection existence: %w", err)
	}
	if has {
		logger.Info("Skipping collection creation: already exists.")
		return nil
	}

	// 2. Create the collection schema with the specified dimensionality
	// Using native Milvus BM25 for full-text search (Milvus 2.5+)
	// - Text field with enable_analyzer for tokenization
	// - BM25 Function automatically generates sparse vectors from text
	// - No client-side BM25 encoding needed
	schema := entity.NewSchema().
		WithName(collectionName).
		WithField(entity.NewField().WithName(kbCollectionFieldSourceTable).WithDataType(entity.FieldTypeVarChar).WithMaxLength(255)).
		WithField(entity.NewField().WithName(kbCollectionFieldSourceUID).WithDataType(entity.FieldTypeVarChar).WithMaxLength(255)).
		WithField(entity.NewField().WithName(kbCollectionFieldDenseEmbeddingUID).WithDataType(entity.FieldTypeVarChar).WithMaxLength(255).WithIsPrimaryKey(true)).
		WithField(entity.NewField().WithName(kbCollectionFieldDenseEmbedding).WithDataType(entity.FieldTypeFloatVector).WithDim(int64(dimensionality))).
		// Text field for native Milvus BM25 full-text search
		// enable_analyzer: tokenizes text for BM25 scoring
		// enable_match: allows text matching queries
		WithField(entity.NewField().WithName(kbCollectionFieldText).WithDataType(entity.FieldTypeVarChar).WithMaxLength(65535).
			WithEnableAnalyzer(true).
			WithAnalyzerParams(map[string]any{"type": "standard"}).
			WithEnableMatch(true)).
		// Sparse embedding field - auto-populated by BM25 Function
		WithField(entity.NewField().WithName(kbCollectionFieldSparseEmbedding).WithDataType(entity.FieldTypeSparseVector)).
		WithField(entity.NewField().WithName(kbCollectionFieldFileUID).WithDataType(entity.FieldTypeVarChar).WithMaxLength(255)).
		WithField(entity.NewField().WithName(kbCollectionFieldFileName).WithDataType(entity.FieldTypeVarChar).WithMaxLength(255)).
		WithField(entity.NewField().WithName(kbCollectionFieldFileType).WithDataType(entity.FieldTypeVarChar).WithMaxLength(255)).
		WithField(entity.NewField().WithName(kbCollectionFieldContentType).WithDataType(entity.FieldTypeVarChar).WithMaxLength(255)).
		WithField(entity.NewField().WithName(kbCollectionFieldTags).WithDataType(entity.FieldTypeArray).WithElementType(entity.FieldTypeVarChar).WithMaxLength(255).WithMaxCapacity(100)).
		// BM25 Function: automatically generates sparse vectors from text field
		// This replaces client-side BM25 encoding with Milvus native implementation
		WithFunction(entity.NewFunction().
			WithName(bm25FunctionName).
			WithType(entity.FunctionTypeBM25).
			WithInputFields(kbCollectionFieldText).
			WithOutputFields(kbCollectionFieldSparseEmbedding))

	// 3. Create indexes
	indexOptions := []milvusclient.CreateIndexOption{
		// Dense vector index (SCANN)
		milvusclient.NewCreateIndexOption(collectionName, kbCollectionFieldDenseEmbedding,
			index.NewSCANNIndex(index.MetricType(metricType), scanNList, withRaw)).WithIndexName("dense_vector_index"),
		// Sparse vector index for native BM25 - use BM25 metric type
		milvusclient.NewCreateIndexOption(collectionName, kbCollectionFieldSparseEmbedding,
			index.NewSparseInvertedIndex(entity.BM25, 0.0)).WithIndexName("sparse_vector_index"),
		// Scalar index for file UID filtering
		milvusclient.NewCreateIndexOption(collectionName, kbCollectionFieldFileUID,
			index.NewInvertedIndex()).WithIndexName("file_uid_index"),
	}

	// 4. Create collection with schema and indexes
	err = m.c.CreateCollection(ctx, milvusclient.NewCreateCollectionOption(collectionName, schema).
		WithShardNum(1).
		WithIndexOptions(indexOptions...))
	if err != nil {
		return fmt.Errorf("creating collection: %w", err)
	}

	logger.Info("Collection created successfully with native Milvus BM25 hybrid search support.")
	return nil
}

func (m *milvusClient) InsertVectorsInCollection(ctx context.Context, collectionName string, embeddings []VectorEmbedding) error {
	logger, _ := logx.GetZapLogger(ctx)
	logger = logger.With(zap.String("collection_name", collectionName))

	// Check if the collection exists
	has, err := m.c.HasCollection(ctx, milvusclient.NewHasCollectionOption(collectionName))
	if err != nil {
		return fmt.Errorf("checking collection existence: %w", err)
	}
	if !has {
		return fmt.Errorf("collection does not exist: %w", errorsx.ErrNotFound)
	}

	// Get collection schema to determine vector dimension
	collDesc, err := m.c.DescribeCollection(ctx, milvusclient.NewDescribeCollectionOption(collectionName))
	if err != nil {
		return fmt.Errorf("describing collection: %w", err)
	}

	// Find the embedding field to get its dimension
	var vectorDim int
	for _, field := range collDesc.Schema.Fields {
		if field.Name == kbCollectionFieldDenseEmbedding {
			if dimStr, ok := field.TypeParams["dim"]; ok {
				if _, err := fmt.Sscanf(dimStr, "%d", &vectorDim); err != nil {
					return fmt.Errorf("failed to parse vector dimension: %w", err)
				}
			}
			break
		}
	}
	if vectorDim == 0 {
		return fmt.Errorf("could not determine vector dimension from collection schema")
	}

	// Prepare the data for insertion
	vectorCount := len(embeddings)
	sourceTables := make([]string, vectorCount)
	sourceUIDs := make([]string, vectorCount)
	embeddingUIDs := make([]string, vectorCount) // Use the provided embeddingUID instead of generating a new one
	vectors := make([][]float32, vectorCount)
	fileUIDs := make([]string, vectorCount)
	fileNames := make([]string, vectorCount)
	fileTypes := make([]string, vectorCount)
	contentTypes := make([]string, vectorCount)
	tags := make([][]string, vectorCount)

	for i, embedding := range embeddings {
		sourceTables[i] = embedding.SourceTable
		sourceUIDs[i] = embedding.SourceUID
		embeddingUIDs[i] = embedding.EmbeddingUID
		fileUIDs[i] = embedding.FileUID.String()
		fileNames[i] = embedding.FileDisplayName
		fileTypes[i] = embedding.ContentType
		contentTypes[i] = embedding.ChunkType
		tags[i] = embedding.Tags
		vectors[i] = embedding.Vector
	}

	// Check metadata field support
	hasMetadata, hasFileUID, hasTags, err := m.checkMetadataFields(ctx, collectionName)
	if err != nil {
		return fmt.Errorf("checking metadata fields: %w", err)
	}

	// Build insert option using fluent API
	insertOpt := milvusclient.NewColumnBasedInsertOption(collectionName).
		WithVarcharColumn(kbCollectionFieldSourceTable, sourceTables).
		WithVarcharColumn(kbCollectionFieldSourceUID, sourceUIDs).
		WithVarcharColumn(kbCollectionFieldDenseEmbeddingUID, embeddingUIDs).
		WithFloatVectorColumn(kbCollectionFieldDenseEmbedding, vectorDim, vectors)

	if hasMetadata {
		insertOpt.WithVarcharColumn(kbCollectionFieldFileName, fileNames).
			WithVarcharColumn(kbCollectionFieldFileType, fileTypes).
			WithVarcharColumn(kbCollectionFieldContentType, contentTypes)
	}

	if hasFileUID {
		insertOpt.WithVarcharColumn(kbCollectionFieldFileUID, fileUIDs)
	}

	if hasTags {
		// Create array column for tags
		tagsColumn := column.NewColumnVarCharArray(kbCollectionFieldTags, tags)
		insertOpt.WithColumns(tagsColumn)
		logger.Info("Inserting embeddings with tags",
			zap.Int("embedding_count", len(tags)))
	} else {
		logger.Warn("Collection does not support tags - embeddings will be inserted without tags")
	}

	// Check if collection supports native BM25 (has text field with BM25 function)
	hasNativeBM25, err := m.checkNativeBM25Support(ctx, collectionName)
	if err != nil {
		return fmt.Errorf("checking native BM25 support: %w", err)
	}

	if hasNativeBM25 {
		// Native Milvus BM25: Just insert the raw text, Milvus auto-generates sparse vectors
		texts := make([]string, len(embeddings))
		for i, emb := range embeddings {
			texts[i] = emb.Text
		}

		insertOpt.WithVarcharColumn(kbCollectionFieldText, texts)
		logger.Info("Inserting embeddings with native Milvus BM25 (text field)",
			zap.Int("embedding_count", len(texts)))
	} else {
		logger.Debug("Collection does not support native BM25 - using dense-only search")
	}

	// Insert the data with retry
	maxRetries := 3
	for attempt := 1; attempt <= maxRetries; attempt++ {
		_, err = m.c.Upsert(ctx, insertOpt)
		if err == nil {
			break
		}
		logger.Warn("Failed to insert vectors, retrying", zap.Int("attempt", attempt), zap.Error(err))
		time.Sleep(time.Second * time.Duration(attempt))
	}
	if err != nil {
		return fmt.Errorf("failed to insert vectors after %d attempts: %w", maxRetries, err)
	}

	logger.Info("Successfully inserted vectors", zap.Int("count", vectorCount))
	return nil
}

// FlushCollection flushes a collection to persist all data immediately
func (m *milvusClient) FlushCollection(ctx context.Context, collectionName string) error {
	logger, _ := logx.GetZapLogger(ctx)
	logger = logger.With(zap.String("collection_name", collectionName))

	// Check if the collection exists
	has, err := m.c.HasCollection(ctx, milvusclient.NewHasCollectionOption(collectionName))
	if err != nil {
		return fmt.Errorf("checking collection existence: %w", err)
	}
	if !has {
		return fmt.Errorf("collection does not exist: %w", errorsx.ErrNotFound)
	}

	// Flush the collection with retry
	maxRetries := 3
	var flushErr error
	for attempt := 1; attempt <= maxRetries; attempt++ {
		task, err := m.c.Flush(ctx, milvusclient.NewFlushOption(collectionName))
		if err == nil {
			// Wait for flush to complete
			flushErr = task.Await(ctx)
			if flushErr == nil {
				break
			}
		} else {
			flushErr = err
		}
		logger.Warn("Failed to flush collection, retrying", zap.Int("attempt", attempt), zap.Error(flushErr))
		time.Sleep(time.Second * time.Duration(attempt))
	}
	if flushErr != nil {
		return fmt.Errorf("flushing collection: %w", flushErr)
	}

	logger.Info("Successfully flushed collection")
	return nil
}

func (m *milvusClient) DeleteEmbeddingsWithFileUID(ctx context.Context, collectionName string, fileUID types.FileUIDType) error {
	logger, _ := logx.GetZapLogger(ctx)
	logger = logger.With(zap.String("collection_name", collectionName), zap.String("file_uid", fileUID.String()))

	// Check if collection exists first
	has, err := m.c.HasCollection(ctx, milvusclient.NewHasCollectionOption(collectionName))
	if err != nil {
		return fmt.Errorf("checking collection existence: %w", err)
	}

	// If collection doesn't exist, there's nothing to delete - return success
	if !has {
		logger.Info("Collection does not exist, skipping delete")
		return nil
	}

	_, hasFileUID, _, err := m.checkMetadataFields(ctx, collectionName)
	if err != nil {
		return fmt.Errorf("checking metadata fields: %w", err)
	}

	if !hasFileUID {
		logger.Info("Collection does not have file_uid field, skipping delete")
		return nil
	}

	// Load collection if needed - check load state first to avoid redundant load
	loadState, err := m.c.GetLoadState(ctx, milvusclient.NewGetLoadStateOption(collectionName))
	if err != nil {
		return fmt.Errorf("checking load state: %w", err)
	}

	// Only load if not already loaded
	if loadState.State != entity.LoadStateLoaded {
		loadTask, err := m.c.LoadCollection(ctx, milvusclient.NewLoadCollectionOption(collectionName))
		if err != nil {
			return fmt.Errorf("loading collection for delete: %w", err)
		}
		if err = loadTask.Await(ctx); err != nil {
			return fmt.Errorf("waiting for collection load: %w", err)
		}
		logger.Info("Collection loaded for delete operation")
	} else {
		logger.Info("Collection already loaded, skipping load")
	}

	expr := fmt.Sprintf("%s == '%s'", kbCollectionFieldFileUID, fileUID.String())
	deleteOpt := milvusclient.NewDeleteOption(collectionName).WithExpr(expr)
	_, err = m.c.Delete(ctx, deleteOpt)
	if err != nil {
		return fmt.Errorf("deleting embeddings: %w", err)
	}

	logger.Info("Successfully deleted embeddings")
	return nil
}

func (m *milvusClient) fileUIDFilter(fileUIDs []types.FileUIDType) string {
	validUIDs := make([]string, 0, len(fileUIDs))
	for _, uid := range fileUIDs {
		if uid.IsNil() {
			continue
		}
		validUIDs = append(validUIDs, `"`+uid.String()+`"`)
	}

	if len(validUIDs) == 0 {
		return ""
	}

	return fmt.Sprintf("%s in [%s]", kbCollectionFieldFileUID, strings.Join(validUIDs, ","))
}

func (m *milvusClient) SearchVectorsInCollection(ctx context.Context, p SearchVectorParam) ([][]SimilarVectorEmbedding, error) {
	logger, _ := logx.GetZapLogger(ctx)

	collectionName := p.CollectionID
	topK := int(p.TopK)

	logger = logger.With(zap.String("collection_name", collectionName))

	// Check if the collection exists
	t := time.Now()
	has, err := m.c.HasCollection(ctx, milvusclient.NewHasCollectionOption(collectionName))
	if err != nil {
		return nil, fmt.Errorf("checking collection existence: %w", err)
	}
	if !has {
		return nil, fmt.Errorf("checking collection existence: %w", errorsx.ErrNotFound)
	}

	logger.Info("Existence check.", zap.Duration("duration", time.Since(t)))
	t = time.Now()

	// Load the collection if it's not already loaded
	loadTask, err := m.c.LoadCollection(ctx, milvusclient.NewLoadCollectionOption(collectionName))
	if err != nil {
		return nil, fmt.Errorf("loading collection: %w", err)
	}
	if err = loadTask.Await(ctx); err != nil {
		return nil, fmt.Errorf("waiting for collection load: %w", err)
	}

	logger.Info("Collection load.", zap.Duration("duration", time.Since(t)))

	hasMetadata, hasFileUID, hasTags, err := m.checkMetadataFields(ctx, collectionName)
	if err != nil {
		return nil, fmt.Errorf("checking metadata fields: %w", err)
	}

	// Check if collection supports native Milvus BM25 (has text field with BM25 function)
	hasNativeBM25, err := m.checkNativeBM25Support(ctx, collectionName)
	if err != nil {
		return nil, fmt.Errorf("checking native BM25 support: %w", err)
	}

	// Use hybrid search if native BM25 is available and query text is provided
	useHybridSearch := hasNativeBM25 && p.QueryText != ""
	if useHybridSearch {
		logger.Debug("Using HYBRID search (dense + native Milvus BM25)")
	} else {
		logger.Debug("Using dense-only search", zap.Bool("has_native_bm25", hasNativeBM25), zap.Bool("has_query_text", p.QueryText != ""))
	}

	outputFields := []string{
		kbCollectionFieldSourceTable,
		kbCollectionFieldSourceUID,
		kbCollectionFieldDenseEmbeddingUID,
		kbCollectionFieldDenseEmbedding,
	}
	var filterStrs []string
	if hasMetadata {
		outputFields = append(
			outputFields,
			kbCollectionFieldFileName,
			kbCollectionFieldFileType,
			kbCollectionFieldContentType,
		)

		if hasFileUID {
			outputFields = append(outputFields, kbCollectionFieldFileUID)

			filter := m.fileUIDFilter(p.FileUIDs)
			if filter != "" {
				logger.Info("Applying file UID filter",
					zap.String("filter", filter),
					zap.Int("file_uid_count", len(p.FileUIDs)))
				filterStrs = append(filterStrs, filter)
			} else if len(p.FileUIDs) > 0 {
				logger.Warn("File UIDs provided but filter is empty - check if UIDs are valid",
					zap.Int("file_uid_count", len(p.FileUIDs)))
			}
		} else if len(p.Filenames) > 0 {
			// Filename filter is only used for backwards compatibility in
			// collections that lack the file UID metadata.
			filter := fmt.Sprintf(`%s in ["%s"]`, kbCollectionFieldFileName, strings.Join(p.Filenames, `","`))
			logger.Info("Applying filename filter (legacy mode)",
				zap.String("filter", filter),
				zap.Int("filename_count", len(p.Filenames)))
			filterStrs = append(filterStrs, filter)
		} else if len(p.FileUIDs) > 0 {
			logger.Warn("File UIDs provided but collection doesn't have file_uid field - NO FILTERING APPLIED",
				zap.Int("file_uid_count", len(p.FileUIDs)),
				zap.String("collection", collectionName))
		}

		if p.ContentType != "" {
			filterStrs = append(filterStrs, fmt.Sprintf("%s == '%s'", kbCollectionFieldFileType, p.ContentType))
		}

		if p.ChunkType != "" {
			filterStrs = append(filterStrs, fmt.Sprintf("%s == '%s'", kbCollectionFieldContentType, p.ChunkType))
		}

		// Add tags filtering with ARRAY_CONTAINS_ANY logic
		// Only apply if collection supports tags and tags are provided
		if hasTags && len(p.Tags) > 0 {
			// Build ARRAY_CONTAINS_ANY filter: array_contains_any(tags, ["tag1", "tag2"])
			quotedTags := make([]string, len(p.Tags))
			for i, tag := range p.Tags {
				quotedTags[i] = fmt.Sprintf(`"%s"`, tag)
			}
			tagsFilter := fmt.Sprintf("array_contains_any(%s, [%s])",
				kbCollectionFieldTags,
				strings.Join(quotedTags, ","))
			filterStrs = append(filterStrs, tagsFilter)
		}
	}

	t = time.Now()
	// Convert the input vector to float32
	milvusVectors := make([]entity.Vector, len(p.Vectors))
	// milvus search vector support batch search, but we just need one vector
	for i, v := range p.Vectors {
		milvusVectors[i] = entity.FloatVector(v)
	}

	filterExpr := strings.Join(filterStrs, " and ")

	logger.Debug("Executing Milvus search",
		zap.String("filter_expression", filterExpr),
		zap.Int("filter_count", len(filterStrs)),
		zap.Int("topK", topK),
		zap.Bool("hybrid_search", useHybridSearch))

	var results []milvusclient.ResultSet

	if useHybridSearch {
		// HYBRID SEARCH: Dense + Native Milvus BM25
		// Create ANN requests for both dense and sparse vectors
		denseAnnParam := index.NewSCANNAnnParam(nProbe, reorderK)
		denseRequest := milvusclient.NewAnnRequest(kbCollectionFieldDenseEmbedding, topK, milvusVectors...).
			WithAnnParam(denseAnnParam)
		if filterExpr != "" {
			denseRequest.WithFilter(filterExpr)
		}

		// Native Milvus BM25: Pass raw text query, Milvus handles tokenization and scoring
		sparseAnnParam := index.NewSparseAnnParam()
		sparseRequest := milvusclient.NewAnnRequest(kbCollectionFieldSparseEmbedding, topK, entity.Text(p.QueryText)).
			WithAnnParam(sparseAnnParam)
		if filterExpr != "" {
			sparseRequest.WithFilter(filterExpr)
		}
		logger.Debug("Using native Milvus BM25 with text query",
			zap.String("query_text", p.QueryText[:min(50, len(p.QueryText))]))

		// Execute hybrid search with RRF reranker
		hybridOpt := milvusclient.NewHybridSearchOption(collectionName, topK, denseRequest, sparseRequest).
			WithReranker(milvusclient.NewRRFReranker()).
			WithOutputFields(outputFields...)

		results, err = m.c.HybridSearch(ctx, hybridOpt)
		if err != nil {
			return nil, fmt.Errorf("hybrid search failed: %w", err)
		}

		logger.Info("Hybrid search completed",
			zap.Duration("duration", time.Since(t)),
			zap.Int("result_count", len(results)))
	}

	// Fall back to dense-only search if hybrid search is not available or failed
	if !useHybridSearch {
		// DENSE-ONLY SEARCH
		annParam := index.NewSCANNAnnParam(nProbe, reorderK)

		searchOpt := milvusclient.NewSearchOption(collectionName, topK, milvusVectors).
			WithANNSField(kbCollectionFieldDenseEmbedding).
			WithOutputFields(outputFields...).
			WithAnnParam(annParam)

		if filterExpr != "" {
			searchOpt.WithFilter(filterExpr)
		}

		results, err = m.c.Search(ctx, searchOpt)
		if err != nil {
			return nil, fmt.Errorf("dense search failed: %w", err)
		}

		logger.Debug("Dense-only search completed",
			zap.Duration("duration", time.Since(t)),
			zap.Int("result_count", len(results)))
	}

	// Extract the embeddings from the search results
	var embeddings [][]SimilarVectorEmbedding
	for idx, result := range results {
		logger.Debug("Processing result set",
			zap.Int("set_index", idx),
			zap.Int("hits_in_set", result.ResultCount))
		if result.ResultCount == 0 {
			logger.Warn("Result set is empty, skipping",
				zap.Int("set_index", idx))
			continue
		}
		sourceTables, err := getStringData(result.GetColumn(kbCollectionFieldSourceTable))
		if err != nil {
			return nil, fmt.Errorf("getting source table column value: %w", err)
		}

		sourceUIDs, err := getStringData(result.GetColumn(kbCollectionFieldSourceUID))
		if err != nil {
			return nil, fmt.Errorf("getting source UID column value: %w", err)
		}
		embeddingUIDs, err := getStringData(result.GetColumn(kbCollectionFieldDenseEmbeddingUID))
		if err != nil {
			return nil, fmt.Errorf("getting embedding UID column value: %w", err)
		}
		vectorsCol := result.GetColumn(kbCollectionFieldDenseEmbedding)
		scores := result.Scores

		// Extract metadata fields if available
		var fileUIDs, fileDisplayNames, fileTypes, contentTypes []string
		if hasMetadata {
			fileDisplayNames, err = getStringData(result.GetColumn(kbCollectionFieldFileName))
			if err != nil {
				return nil, fmt.Errorf("getting file name column value: %w", err)
			}
			fileTypes, err = getStringData(result.GetColumn(kbCollectionFieldFileType))
			if err != nil {
				return nil, fmt.Errorf("getting file type column value: %w", err)
			}
			contentTypes, err = getStringData(result.GetColumn(kbCollectionFieldContentType))
			if err != nil {
				return nil, fmt.Errorf("getting content type column value: %w", err)
			}
			if hasFileUID {
				fileUIDs, err = getStringData(result.GetColumn(kbCollectionFieldFileUID))
				if err != nil {
					return nil, fmt.Errorf("getting file UID column value: %w", err)
				}
			}
		}

		// Cast vector column to ColumnFloatVector to access data
		vectorData, ok := vectorsCol.(*column.ColumnFloatVector)
		if !ok {
			return nil, fmt.Errorf("unexpected vector column type: %T", vectorsCol)
		}

		tempVectors := []SimilarVectorEmbedding{}
		returnedFileUIDs := make(map[string]int) // Track unique file UIDs in results
		for i := range sourceTables {
			emb := VectorEmbedding{
				SourceTable:  sourceTables[i],
				SourceUID:    sourceUIDs[i],
				EmbeddingUID: embeddingUIDs[i],
				Vector:       vectorData.Data()[i],
			}
			if hasMetadata {
				emb.FileDisplayName = fileDisplayNames[i]
				emb.ContentType = fileTypes[i]  // MIME type from file_type field
				emb.ChunkType = contentTypes[i] // chunk type from content_type field
				if hasFileUID {
					emb.FileUID = uuid.FromStringOrNil(fileUIDs[i])
					// Track which file UIDs are in the results
					if fileUIDs[i] != "" {
						returnedFileUIDs[fileUIDs[i]]++
					}
				}
			}
			tempVectors = append(tempVectors, SimilarVectorEmbedding{
				VectorEmbedding: emb,
				Score:           scores[i],
			})
		}

		// Log file UID distribution in results to help debug filtering issues
		if len(returnedFileUIDs) > 0 {
			logger.Debug("Search results file UID distribution",
				zap.Int("unique_file_uids", len(returnedFileUIDs)),
				zap.Int("total_chunks", len(tempVectors)),
				zap.Any("file_uid_counts", returnedFileUIDs))

			// Check if results contain chunks from files NOT in the filter
			if len(p.FileUIDs) > 0 {
				requestedUIDs := make(map[string]bool)
				for _, uid := range p.FileUIDs {
					if !uid.IsNil() {
						requestedUIDs[uid.String()] = true
					}
				}

				unexpectedFileUIDs := []string{}
				for fileUID := range returnedFileUIDs {
					if !requestedUIDs[fileUID] {
						unexpectedFileUIDs = append(unexpectedFileUIDs, fileUID)
					}
				}

				if len(unexpectedFileUIDs) > 0 {
					logger.Error("BUG: Search returned chunks from files NOT in the filter",
						zap.Strings("unexpected_file_uids", unexpectedFileUIDs),
						zap.Int("requested_file_count", len(p.FileUIDs)),
						zap.String("filter_expression", filterExpr))
				}
			}
		}

		embeddings = append(embeddings, tempVectors)
	}

	return embeddings, nil
}

func (m *milvusClient) DropCollection(ctx context.Context, collectionName string) error {
	return m.c.DropCollection(ctx, milvusclient.NewDropCollectionOption(collectionName))
}

func (m *milvusClient) CheckFileUIDMetadata(ctx context.Context, collectionName string) (bool, error) {
	_, hasFileUID, _, err := m.checkMetadataFields(ctx, collectionName)
	return hasFileUID, err
}

// checkMetadataFields returns whether the collection schema has metadata
// fields. Additionally, it checks the file UID, tags, and sparse embedding fields separately as they
// were introduced later and certain legacy collections don't have them.
func (m *milvusClient) checkMetadataFields(ctx context.Context, collectionName string) (hasMetadata, hasFileUID, hasTags bool, _ error) {
	collDesc, err := m.c.DescribeCollection(ctx, milvusclient.NewDescribeCollectionOption(collectionName))
	if err != nil {
		return false, false, false, fmt.Errorf("describing collection: %w", err)
	}

	var existingFields = map[string]bool{}
	for _, field := range collDesc.Schema.Fields {
		existingFields[field.Name] = true
	}

	hasMetadata = existingFields[kbCollectionFieldFileName] &&
		existingFields[kbCollectionFieldFileType] &&
		existingFields[kbCollectionFieldContentType]

	hasFileUID = existingFields[kbCollectionFieldFileUID]
	hasTags = existingFields[kbCollectionFieldTags]

	return hasMetadata, hasFileUID, hasTags, nil
}

// checkNativeBM25Support checks if the collection uses native Milvus BM25 (has text and sparse_embedding fields).
// Native BM25 collections have:
// - A text VARCHAR field with enable_analyzer=true
// - A sparse_embedding SparseVector field
// - A BM25 Function that auto-generates sparse vectors from text
//
// NOTE: We check for both text and sparse_embedding field existence, not the BM25 function.
// This is because:
// 1. Zilliz Cloud may not report functions in the same way as self-hosted Milvus
// 2. If these fields exist, Milvus REQUIRES data for them and BM25 search should work
// 3. These fields are always created together with the BM25 function in CreateCollection
func (m *milvusClient) checkNativeBM25Support(ctx context.Context, collectionName string) (bool, error) {
	logger, _ := logx.GetZapLogger(ctx)

	collDesc, err := m.c.DescribeCollection(ctx, milvusclient.NewDescribeCollectionOption(collectionName))
	if err != nil {
		return false, fmt.Errorf("describing collection: %w", err)
	}

	// Check for text field and sparse_embedding field
	hasTextField := false
	hasSparseField := false
	for _, field := range collDesc.Schema.Fields {
		if field.Name == kbCollectionFieldText {
			hasTextField = true
		}
		if field.Name == kbCollectionFieldSparseEmbedding {
			hasSparseField = true
		}
	}

	// Check for BM25 function (for logging/debugging purposes)
	hasBM25Function := false
	for _, fn := range collDesc.Schema.Functions {
		if fn.Name == bm25FunctionName && fn.Type == entity.FunctionTypeBM25 {
			hasBM25Function = true
			break
		}
	}

	// Log the detected configuration for debugging
	logger.Debug("Native BM25 support check",
		zap.String("collection", collectionName),
		zap.Bool("hasTextField", hasTextField),
		zap.Bool("hasSparseField", hasSparseField),
		zap.Bool("hasBM25Function", hasBM25Function))

	// Return true if both text and sparse_embedding fields exist
	// These fields are always created together with the BM25 function,
	// so their presence indicates BM25 is supported even if Zilliz Cloud
	// doesn't report the function metadata
	return hasTextField && hasSparseField, nil
}

func getStringData(col column.Column) ([]string, error) {
	switch v := col.(type) {
	case *column.ColumnVarChar:
		return v.Data(), nil
	case *column.ColumnString:
		return v.Data(), nil
	default:
		return nil, fmt.Errorf("unexpected column type for string data: %T", col)
	}
}

func getFloatVectorData(col column.Column) ([][]float32, error) {
	switch v := col.(type) {
	case *column.ColumnFloatVector:
		// Convert []entity.FloatVector to [][]float32
		data := v.Data()
		result := make([][]float32, len(data))
		for i, fv := range data {
			result[i] = []float32(fv)
		}
		return result, nil
	default:
		return nil, fmt.Errorf("unexpected column type for float vector data: %T", col)
	}
}

// convertTagsToArray converts tags to [][]string format for multiple rows
func convertTagsToArray(embeddingUIDs []string, tags []string) [][]string {
	result := make([][]string, len(embeddingUIDs))
	for i := range embeddingUIDs {
		result[i] = tags
	}
	return result
}

// CollectionExists checks if a collection exists in Milvus
func (m *milvusClient) CollectionExists(ctx context.Context, collectionID string) (bool, error) {
	logger, _ := logx.GetZapLogger(ctx)
	logger = logger.With(zap.String("collection_id", collectionID))

	has, err := m.c.HasCollection(ctx, milvusclient.NewHasCollectionOption(collectionID))
	if err != nil {
		logger.Error("Failed to check collection existence",
			zap.String("collection", collectionID),
			zap.Error(err))
		return false, fmt.Errorf("checking collection existence: %w", err)
	}

	logger.Debug("Collection existence check completed",
		zap.Bool("exists", has))

	return has, nil
}

// UpdateEmbeddingTags updates tags for all embeddings belonging to a specific file
// This is used when file tags are updated to keep Milvus embeddings in sync
// IMPORTANT: Milvus upsert is delete+insert, so we must query ALL fields first
// and include them in the upsert to avoid losing vector data.
func (m *milvusClient) UpdateEmbeddingTags(ctx context.Context, collectionID string, fileUID types.FileUIDType, tags []string) error {
	logger, _ := logx.GetZapLogger(ctx)
	logger = logger.With(
		zap.String("collection_id", collectionID),
		zap.String("file_uid", fileUID.String()),
		zap.Strings("tags", tags))

	logger.Info("UpdateEmbeddingTags: Starting tags update")

	// Check if collection exists
	has, err := m.c.HasCollection(ctx, milvusclient.NewHasCollectionOption(collectionID))
	if err != nil {
		return fmt.Errorf("checking collection existence: %w", err)
	}
	if !has {
		logger.Warn("UpdateEmbeddingTags: Collection does not exist, skipping")
		return nil
	}

	// Check if collection has tags field and other metadata
	hasMetadata, hasFileUID, hasTags, err := m.checkMetadataFields(ctx, collectionID)
	if err != nil {
		return fmt.Errorf("checking metadata fields: %w", err)
	}
	if !hasTags {
		logger.Warn("UpdateEmbeddingTags: Collection does not support tags, skipping")
		return nil
	}

	// Load collection before querying
	loadTask, err := m.c.LoadCollection(ctx, milvusclient.NewLoadCollectionOption(collectionID))
	if err != nil {
		logger.Warn("UpdateEmbeddingTags: Failed to load collection (may already be loaded)",
			zap.Error(err))
		// Continue anyway - collection might already be loaded
	} else {
		if err = loadTask.Await(ctx); err != nil {
			logger.Warn("UpdateEmbeddingTags: Failed to wait for collection load",
				zap.Error(err))
		}
	}

	// Check if collection supports native BM25 (has text field)
	hasNativeBM25, err := m.checkNativeBM25Support(ctx, collectionID)
	if err != nil {
		return fmt.Errorf("checking native BM25 support: %w", err)
	}

	// Query ALL fields for embeddings of this file (Milvus upsert is delete+insert)
	// We must preserve all existing data when updating tags
	expr := fmt.Sprintf("%s == '%s'", kbCollectionFieldFileUID, fileUID.String())

	// Build list of output fields to query
	outputFields := []string{
		kbCollectionFieldSourceTable,
		kbCollectionFieldSourceUID,
		kbCollectionFieldDenseEmbeddingUID,
		kbCollectionFieldDenseEmbedding,
	}
	if hasMetadata {
		outputFields = append(outputFields, kbCollectionFieldFileName, kbCollectionFieldFileType, kbCollectionFieldContentType)
	}
	if hasFileUID {
		outputFields = append(outputFields, kbCollectionFieldFileUID)
	}
	// Include text field if native BM25 is supported
	if hasNativeBM25 {
		outputFields = append(outputFields, kbCollectionFieldText)
	}

	queryOpt := milvusclient.NewQueryOption(collectionID).
		WithFilter(expr).
		WithOutputFields(outputFields...)

	searchResult, err := m.c.Query(ctx, queryOpt)
	if err != nil {
		return fmt.Errorf("querying embeddings for file: %w", err)
	}

	if searchResult.ResultCount == 0 {
		logger.Info("UpdateEmbeddingTags: No embeddings found for file")
		return nil
	}

	// Extract all field data from the result set
	embeddingUIDs, err := getStringData(searchResult.GetColumn(kbCollectionFieldDenseEmbeddingUID))
	if err != nil {
		return fmt.Errorf("extracting embedding UIDs: %w", err)
	}

	if len(embeddingUIDs) == 0 {
		logger.Info("UpdateEmbeddingTags: No embeddings to update")
		return nil
	}

	sourceTables, _ := getStringData(searchResult.GetColumn(kbCollectionFieldSourceTable))
	sourceUIDs, _ := getStringData(searchResult.GetColumn(kbCollectionFieldSourceUID))
	vectors, _ := getFloatVectorData(searchResult.GetColumn(kbCollectionFieldDenseEmbedding))

	// Optional fields
	var fileNames, fileTypes, contentTypes, fileUIDs, texts []string
	if hasMetadata {
		fileNames, _ = getStringData(searchResult.GetColumn(kbCollectionFieldFileName))
		fileTypes, _ = getStringData(searchResult.GetColumn(kbCollectionFieldFileType))
		contentTypes, _ = getStringData(searchResult.GetColumn(kbCollectionFieldContentType))
	}
	if hasFileUID {
		fileUIDs, _ = getStringData(searchResult.GetColumn(kbCollectionFieldFileUID))
	}
	// Extract text field for native BM25 collections
	if hasNativeBM25 {
		texts, _ = getStringData(searchResult.GetColumn(kbCollectionFieldText))
	}

	logger.Info("UpdateEmbeddingTags: Found embeddings to update",
		zap.Int("count", len(embeddingUIDs)),
		zap.Bool("hasNativeBM25", hasNativeBM25))

	// Build upsert option with ALL fields to preserve existing data
	// CRITICAL: Milvus upsert is delete+insert, so we must include all fields
	vectorDim := 0
	if len(vectors) > 0 {
		vectorDim = len(vectors[0])
	}

	upsertOpt := milvusclient.NewColumnBasedInsertOption(collectionID).
		WithVarcharColumn(kbCollectionFieldSourceTable, sourceTables).
		WithVarcharColumn(kbCollectionFieldSourceUID, sourceUIDs).
		WithVarcharColumn(kbCollectionFieldDenseEmbeddingUID, embeddingUIDs).
		WithFloatVectorColumn(kbCollectionFieldDenseEmbedding, vectorDim, vectors)

	if hasMetadata {
		upsertOpt.WithVarcharColumn(kbCollectionFieldFileName, fileNames).
			WithVarcharColumn(kbCollectionFieldFileType, fileTypes).
			WithVarcharColumn(kbCollectionFieldContentType, contentTypes)
	}

	if hasFileUID {
		upsertOpt.WithVarcharColumn(kbCollectionFieldFileUID, fileUIDs)
	}

	// Include text field for native BM25 collections (required for upsert)
	if hasNativeBM25 && len(texts) > 0 {
		upsertOpt.WithVarcharColumn(kbCollectionFieldText, texts)
	}

	// Add updated tags for all embeddings
	tagsColumn := column.NewColumnVarCharArray(kbCollectionFieldTags, convertTagsToArray(embeddingUIDs, tags))
	upsertOpt.WithColumns(tagsColumn)

	// Upsert to update tags while preserving all other data
	_, err = m.c.Upsert(ctx, upsertOpt)
	if err != nil {
		return fmt.Errorf("updating embedding tags: %w", err)
	}

	logger.Info("UpdateEmbeddingTags: Successfully updated tags",
		zap.Int("embeddings_updated", len(embeddingUIDs)))

	return nil
}
