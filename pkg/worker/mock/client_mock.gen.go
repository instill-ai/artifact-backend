// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_ai "github.com/instill-ai/artifact-backend/pkg/ai"
	artifactpb "github.com/instill-ai/protogen-go/artifact/artifact/v1alpha"
)

// ClientMock implements mm_ai.Client
type ClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcClose          func() (err error)
	funcCloseOrigin    string
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mClientMockClose

	funcConvertToMarkdownWithCache          func(ctx context.Context, cacheName string, prompt string) (cp1 *mm_ai.ConversionResult, err error)
	funcConvertToMarkdownWithCacheOrigin    string
	inspectFuncConvertToMarkdownWithCache   func(ctx context.Context, cacheName string, prompt string)
	afterConvertToMarkdownWithCacheCounter  uint64
	beforeConvertToMarkdownWithCacheCounter uint64
	ConvertToMarkdownWithCacheMock          mClientMockConvertToMarkdownWithCache

	funcConvertToMarkdownWithoutCache          func(ctx context.Context, content []byte, fileType artifactpb.File_Type, filename string, prompt string) (cp1 *mm_ai.ConversionResult, err error)
	funcConvertToMarkdownWithoutCacheOrigin    string
	inspectFuncConvertToMarkdownWithoutCache   func(ctx context.Context, content []byte, fileType artifactpb.File_Type, filename string, prompt string)
	afterConvertToMarkdownWithoutCacheCounter  uint64
	beforeConvertToMarkdownWithoutCacheCounter uint64
	ConvertToMarkdownWithoutCacheMock          mClientMockConvertToMarkdownWithoutCache

	funcCreateCache          func(ctx context.Context, files []mm_ai.FileContent, ttl time.Duration, systemInstruction string) (cp1 *mm_ai.CacheResult, err error)
	funcCreateCacheOrigin    string
	inspectFuncCreateCache   func(ctx context.Context, files []mm_ai.FileContent, ttl time.Duration, systemInstruction string)
	afterCreateCacheCounter  uint64
	beforeCreateCacheCounter uint64
	CreateCacheMock          mClientMockCreateCache

	funcDeleteCache          func(ctx context.Context, cacheName string) (err error)
	funcDeleteCacheOrigin    string
	inspectFuncDeleteCache   func(ctx context.Context, cacheName string)
	afterDeleteCacheCounter  uint64
	beforeDeleteCacheCounter uint64
	DeleteCacheMock          mClientMockDeleteCache

	funcEmbedTexts          func(ctx context.Context, texts []string, taskType string, dimensionality int32) (ep1 *mm_ai.EmbedResult, err error)
	funcEmbedTextsOrigin    string
	inspectFuncEmbedTexts   func(ctx context.Context, texts []string, taskType string, dimensionality int32)
	afterEmbedTextsCounter  uint64
	beforeEmbedTextsCounter uint64
	EmbedTextsMock          mClientMockEmbedTexts

	funcGetCache          func(ctx context.Context, cacheName string) (cp1 *mm_ai.CacheResult, err error)
	funcGetCacheOrigin    string
	inspectFuncGetCache   func(ctx context.Context, cacheName string)
	afterGetCacheCounter  uint64
	beforeGetCacheCounter uint64
	GetCacheMock          mClientMockGetCache

	funcGetEmbeddingDimensionality          func() (i1 int32)
	funcGetEmbeddingDimensionalityOrigin    string
	inspectFuncGetEmbeddingDimensionality   func()
	afterGetEmbeddingDimensionalityCounter  uint64
	beforeGetEmbeddingDimensionalityCounter uint64
	GetEmbeddingDimensionalityMock          mClientMockGetEmbeddingDimensionality

	funcGetModelFamily          func(modelFamily string) (c1 mm_ai.Client, err error)
	funcGetModelFamilyOrigin    string
	inspectFuncGetModelFamily   func(modelFamily string)
	afterGetModelFamilyCounter  uint64
	beforeGetModelFamilyCounter uint64
	GetModelFamilyMock          mClientMockGetModelFamily

	funcListCaches          func(ctx context.Context, options *mm_ai.CacheListOptions) (cp1 *mm_ai.CacheListResult, err error)
	funcListCachesOrigin    string
	inspectFuncListCaches   func(ctx context.Context, options *mm_ai.CacheListOptions)
	afterListCachesCounter  uint64
	beforeListCachesCounter uint64
	ListCachesMock          mClientMockListCaches

	funcName          func() (s1 string)
	funcNameOrigin    string
	inspectFuncName   func()
	afterNameCounter  uint64
	beforeNameCounter uint64
	NameMock          mClientMockName

	funcSupportsFileType          func(fileType artifactpb.File_Type) (b1 bool)
	funcSupportsFileTypeOrigin    string
	inspectFuncSupportsFileType   func(fileType artifactpb.File_Type)
	afterSupportsFileTypeCounter  uint64
	beforeSupportsFileTypeCounter uint64
	SupportsFileTypeMock          mClientMockSupportsFileType

	funcUpdateCache          func(ctx context.Context, cacheName string, options *mm_ai.CacheUpdateOptions) (cp1 *mm_ai.CacheResult, err error)
	funcUpdateCacheOrigin    string
	inspectFuncUpdateCache   func(ctx context.Context, cacheName string, options *mm_ai.CacheUpdateOptions)
	afterUpdateCacheCounter  uint64
	beforeUpdateCacheCounter uint64
	UpdateCacheMock          mClientMockUpdateCache
}

// NewClientMock returns a mock for mm_ai.Client
func NewClientMock(t minimock.Tester) *ClientMock {
	m := &ClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseMock = mClientMockClose{mock: m}

	m.ConvertToMarkdownWithCacheMock = mClientMockConvertToMarkdownWithCache{mock: m}
	m.ConvertToMarkdownWithCacheMock.callArgs = []*ClientMockConvertToMarkdownWithCacheParams{}

	m.ConvertToMarkdownWithoutCacheMock = mClientMockConvertToMarkdownWithoutCache{mock: m}
	m.ConvertToMarkdownWithoutCacheMock.callArgs = []*ClientMockConvertToMarkdownWithoutCacheParams{}

	m.CreateCacheMock = mClientMockCreateCache{mock: m}
	m.CreateCacheMock.callArgs = []*ClientMockCreateCacheParams{}

	m.DeleteCacheMock = mClientMockDeleteCache{mock: m}
	m.DeleteCacheMock.callArgs = []*ClientMockDeleteCacheParams{}

	m.EmbedTextsMock = mClientMockEmbedTexts{mock: m}
	m.EmbedTextsMock.callArgs = []*ClientMockEmbedTextsParams{}

	m.GetCacheMock = mClientMockGetCache{mock: m}
	m.GetCacheMock.callArgs = []*ClientMockGetCacheParams{}

	m.GetEmbeddingDimensionalityMock = mClientMockGetEmbeddingDimensionality{mock: m}

	m.GetModelFamilyMock = mClientMockGetModelFamily{mock: m}
	m.GetModelFamilyMock.callArgs = []*ClientMockGetModelFamilyParams{}

	m.ListCachesMock = mClientMockListCaches{mock: m}
	m.ListCachesMock.callArgs = []*ClientMockListCachesParams{}

	m.NameMock = mClientMockName{mock: m}

	m.SupportsFileTypeMock = mClientMockSupportsFileType{mock: m}
	m.SupportsFileTypeMock.callArgs = []*ClientMockSupportsFileTypeParams{}

	m.UpdateCacheMock = mClientMockUpdateCache{mock: m}
	m.UpdateCacheMock.callArgs = []*ClientMockUpdateCacheParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mClientMockClose struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockCloseExpectation
	expectations       []*ClientMockCloseExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockCloseExpectation specifies expectation struct of the Client.Close
type ClientMockCloseExpectation struct {
	mock *ClientMock

	results      *ClientMockCloseResults
	returnOrigin string
	Counter      uint64
}

// ClientMockCloseResults contains results of the Client.Close
type ClientMockCloseResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClose *mClientMockClose) Optional() *mClientMockClose {
	mmClose.optional = true
	return mmClose
}

// Expect sets up expected params for Client.Close
func (mmClose *mClientMockClose) Expect() *mClientMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ClientMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ClientMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the Client.Close
func (mmClose *mClientMockClose) Inspect(f func()) *mClientMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for ClientMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by Client.Close
func (mmClose *mClientMockClose) Return(err error) *ClientMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ClientMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ClientMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &ClientMockCloseResults{err}
	mmClose.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Set uses given function f to mock the Client.Close method
func (mmClose *mClientMockClose) Set(f func() (err error)) *ClientMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the Client.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the Client.Close method")
	}

	mmClose.mock.funcClose = f
	mmClose.mock.funcCloseOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Times sets number of times Client.Close should be invoked
func (mmClose *mClientMockClose) Times(n uint64) *mClientMockClose {
	if n == 0 {
		mmClose.mock.t.Fatalf("Times of ClientMock.Close mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClose.expectedInvocations, n)
	mmClose.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClose
}

func (mmClose *mClientMockClose) invocationsDone() bool {
	if len(mmClose.expectations) == 0 && mmClose.defaultExpectation == nil && mmClose.mock.funcClose == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClose.mock.afterCloseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClose.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Close implements mm_ai.Client
func (mmClose *ClientMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	mmClose.t.Helper()

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the ClientMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to ClientMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished ClientMock.Close invocations
func (mmClose *ClientMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of ClientMock.Close invocations
func (mmClose *ClientMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCloseDone() bool {
	if m.CloseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CloseMock.invocationsDone()
}

// MinimockCloseInspect logs each unmet expectation
func (m *ClientMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ClientMock.Close")
		}
	}

	afterCloseCounter := mm_atomic.LoadUint64(&m.afterCloseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.Close at\n%s", m.CloseMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.Close at\n%s", m.funcCloseOrigin)
	}

	if !m.CloseMock.invocationsDone() && afterCloseCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.Close at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CloseMock.expectedInvocations), m.CloseMock.expectedInvocationsOrigin, afterCloseCounter)
	}
}

type mClientMockConvertToMarkdownWithCache struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockConvertToMarkdownWithCacheExpectation
	expectations       []*ClientMockConvertToMarkdownWithCacheExpectation

	callArgs []*ClientMockConvertToMarkdownWithCacheParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockConvertToMarkdownWithCacheExpectation specifies expectation struct of the Client.ConvertToMarkdownWithCache
type ClientMockConvertToMarkdownWithCacheExpectation struct {
	mock               *ClientMock
	params             *ClientMockConvertToMarkdownWithCacheParams
	paramPtrs          *ClientMockConvertToMarkdownWithCacheParamPtrs
	expectationOrigins ClientMockConvertToMarkdownWithCacheExpectationOrigins
	results            *ClientMockConvertToMarkdownWithCacheResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockConvertToMarkdownWithCacheParams contains parameters of the Client.ConvertToMarkdownWithCache
type ClientMockConvertToMarkdownWithCacheParams struct {
	ctx       context.Context
	cacheName string
	prompt    string
}

// ClientMockConvertToMarkdownWithCacheParamPtrs contains pointers to parameters of the Client.ConvertToMarkdownWithCache
type ClientMockConvertToMarkdownWithCacheParamPtrs struct {
	ctx       *context.Context
	cacheName *string
	prompt    *string
}

// ClientMockConvertToMarkdownWithCacheResults contains results of the Client.ConvertToMarkdownWithCache
type ClientMockConvertToMarkdownWithCacheResults struct {
	cp1 *mm_ai.ConversionResult
	err error
}

// ClientMockConvertToMarkdownWithCacheOrigins contains origins of expectations of the Client.ConvertToMarkdownWithCache
type ClientMockConvertToMarkdownWithCacheExpectationOrigins struct {
	origin          string
	originCtx       string
	originCacheName string
	originPrompt    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConvertToMarkdownWithCache *mClientMockConvertToMarkdownWithCache) Optional() *mClientMockConvertToMarkdownWithCache {
	mmConvertToMarkdownWithCache.optional = true
	return mmConvertToMarkdownWithCache
}

// Expect sets up expected params for Client.ConvertToMarkdownWithCache
func (mmConvertToMarkdownWithCache *mClientMockConvertToMarkdownWithCache) Expect(ctx context.Context, cacheName string, prompt string) *mClientMockConvertToMarkdownWithCache {
	if mmConvertToMarkdownWithCache.mock.funcConvertToMarkdownWithCache != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ClientMock.ConvertToMarkdownWithCache mock is already set by Set")
	}

	if mmConvertToMarkdownWithCache.defaultExpectation == nil {
		mmConvertToMarkdownWithCache.defaultExpectation = &ClientMockConvertToMarkdownWithCacheExpectation{}
	}

	if mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ClientMock.ConvertToMarkdownWithCache mock is already set by ExpectParams functions")
	}

	mmConvertToMarkdownWithCache.defaultExpectation.params = &ClientMockConvertToMarkdownWithCacheParams{ctx, cacheName, prompt}
	mmConvertToMarkdownWithCache.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmConvertToMarkdownWithCache.expectations {
		if minimock.Equal(e.params, mmConvertToMarkdownWithCache.defaultExpectation.params) {
			mmConvertToMarkdownWithCache.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertToMarkdownWithCache.defaultExpectation.params)
		}
	}

	return mmConvertToMarkdownWithCache
}

// ExpectCtxParam1 sets up expected param ctx for Client.ConvertToMarkdownWithCache
func (mmConvertToMarkdownWithCache *mClientMockConvertToMarkdownWithCache) ExpectCtxParam1(ctx context.Context) *mClientMockConvertToMarkdownWithCache {
	if mmConvertToMarkdownWithCache.mock.funcConvertToMarkdownWithCache != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ClientMock.ConvertToMarkdownWithCache mock is already set by Set")
	}

	if mmConvertToMarkdownWithCache.defaultExpectation == nil {
		mmConvertToMarkdownWithCache.defaultExpectation = &ClientMockConvertToMarkdownWithCacheExpectation{}
	}

	if mmConvertToMarkdownWithCache.defaultExpectation.params != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ClientMock.ConvertToMarkdownWithCache mock is already set by Expect")
	}

	if mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs == nil {
		mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs = &ClientMockConvertToMarkdownWithCacheParamPtrs{}
	}
	mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs.ctx = &ctx
	mmConvertToMarkdownWithCache.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmConvertToMarkdownWithCache
}

// ExpectCacheNameParam2 sets up expected param cacheName for Client.ConvertToMarkdownWithCache
func (mmConvertToMarkdownWithCache *mClientMockConvertToMarkdownWithCache) ExpectCacheNameParam2(cacheName string) *mClientMockConvertToMarkdownWithCache {
	if mmConvertToMarkdownWithCache.mock.funcConvertToMarkdownWithCache != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ClientMock.ConvertToMarkdownWithCache mock is already set by Set")
	}

	if mmConvertToMarkdownWithCache.defaultExpectation == nil {
		mmConvertToMarkdownWithCache.defaultExpectation = &ClientMockConvertToMarkdownWithCacheExpectation{}
	}

	if mmConvertToMarkdownWithCache.defaultExpectation.params != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ClientMock.ConvertToMarkdownWithCache mock is already set by Expect")
	}

	if mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs == nil {
		mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs = &ClientMockConvertToMarkdownWithCacheParamPtrs{}
	}
	mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs.cacheName = &cacheName
	mmConvertToMarkdownWithCache.defaultExpectation.expectationOrigins.originCacheName = minimock.CallerInfo(1)

	return mmConvertToMarkdownWithCache
}

// ExpectPromptParam3 sets up expected param prompt for Client.ConvertToMarkdownWithCache
func (mmConvertToMarkdownWithCache *mClientMockConvertToMarkdownWithCache) ExpectPromptParam3(prompt string) *mClientMockConvertToMarkdownWithCache {
	if mmConvertToMarkdownWithCache.mock.funcConvertToMarkdownWithCache != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ClientMock.ConvertToMarkdownWithCache mock is already set by Set")
	}

	if mmConvertToMarkdownWithCache.defaultExpectation == nil {
		mmConvertToMarkdownWithCache.defaultExpectation = &ClientMockConvertToMarkdownWithCacheExpectation{}
	}

	if mmConvertToMarkdownWithCache.defaultExpectation.params != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ClientMock.ConvertToMarkdownWithCache mock is already set by Expect")
	}

	if mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs == nil {
		mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs = &ClientMockConvertToMarkdownWithCacheParamPtrs{}
	}
	mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs.prompt = &prompt
	mmConvertToMarkdownWithCache.defaultExpectation.expectationOrigins.originPrompt = minimock.CallerInfo(1)

	return mmConvertToMarkdownWithCache
}

// Inspect accepts an inspector function that has same arguments as the Client.ConvertToMarkdownWithCache
func (mmConvertToMarkdownWithCache *mClientMockConvertToMarkdownWithCache) Inspect(f func(ctx context.Context, cacheName string, prompt string)) *mClientMockConvertToMarkdownWithCache {
	if mmConvertToMarkdownWithCache.mock.inspectFuncConvertToMarkdownWithCache != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("Inspect function is already set for ClientMock.ConvertToMarkdownWithCache")
	}

	mmConvertToMarkdownWithCache.mock.inspectFuncConvertToMarkdownWithCache = f

	return mmConvertToMarkdownWithCache
}

// Return sets up results that will be returned by Client.ConvertToMarkdownWithCache
func (mmConvertToMarkdownWithCache *mClientMockConvertToMarkdownWithCache) Return(cp1 *mm_ai.ConversionResult, err error) *ClientMock {
	if mmConvertToMarkdownWithCache.mock.funcConvertToMarkdownWithCache != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ClientMock.ConvertToMarkdownWithCache mock is already set by Set")
	}

	if mmConvertToMarkdownWithCache.defaultExpectation == nil {
		mmConvertToMarkdownWithCache.defaultExpectation = &ClientMockConvertToMarkdownWithCacheExpectation{mock: mmConvertToMarkdownWithCache.mock}
	}
	mmConvertToMarkdownWithCache.defaultExpectation.results = &ClientMockConvertToMarkdownWithCacheResults{cp1, err}
	mmConvertToMarkdownWithCache.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmConvertToMarkdownWithCache.mock
}

// Set uses given function f to mock the Client.ConvertToMarkdownWithCache method
func (mmConvertToMarkdownWithCache *mClientMockConvertToMarkdownWithCache) Set(f func(ctx context.Context, cacheName string, prompt string) (cp1 *mm_ai.ConversionResult, err error)) *ClientMock {
	if mmConvertToMarkdownWithCache.defaultExpectation != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("Default expectation is already set for the Client.ConvertToMarkdownWithCache method")
	}

	if len(mmConvertToMarkdownWithCache.expectations) > 0 {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("Some expectations are already set for the Client.ConvertToMarkdownWithCache method")
	}

	mmConvertToMarkdownWithCache.mock.funcConvertToMarkdownWithCache = f
	mmConvertToMarkdownWithCache.mock.funcConvertToMarkdownWithCacheOrigin = minimock.CallerInfo(1)
	return mmConvertToMarkdownWithCache.mock
}

// When sets expectation for the Client.ConvertToMarkdownWithCache which will trigger the result defined by the following
// Then helper
func (mmConvertToMarkdownWithCache *mClientMockConvertToMarkdownWithCache) When(ctx context.Context, cacheName string, prompt string) *ClientMockConvertToMarkdownWithCacheExpectation {
	if mmConvertToMarkdownWithCache.mock.funcConvertToMarkdownWithCache != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ClientMock.ConvertToMarkdownWithCache mock is already set by Set")
	}

	expectation := &ClientMockConvertToMarkdownWithCacheExpectation{
		mock:               mmConvertToMarkdownWithCache.mock,
		params:             &ClientMockConvertToMarkdownWithCacheParams{ctx, cacheName, prompt},
		expectationOrigins: ClientMockConvertToMarkdownWithCacheExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmConvertToMarkdownWithCache.expectations = append(mmConvertToMarkdownWithCache.expectations, expectation)
	return expectation
}

// Then sets up Client.ConvertToMarkdownWithCache return parameters for the expectation previously defined by the When method
func (e *ClientMockConvertToMarkdownWithCacheExpectation) Then(cp1 *mm_ai.ConversionResult, err error) *ClientMock {
	e.results = &ClientMockConvertToMarkdownWithCacheResults{cp1, err}
	return e.mock
}

// Times sets number of times Client.ConvertToMarkdownWithCache should be invoked
func (mmConvertToMarkdownWithCache *mClientMockConvertToMarkdownWithCache) Times(n uint64) *mClientMockConvertToMarkdownWithCache {
	if n == 0 {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("Times of ClientMock.ConvertToMarkdownWithCache mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertToMarkdownWithCache.expectedInvocations, n)
	mmConvertToMarkdownWithCache.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmConvertToMarkdownWithCache
}

func (mmConvertToMarkdownWithCache *mClientMockConvertToMarkdownWithCache) invocationsDone() bool {
	if len(mmConvertToMarkdownWithCache.expectations) == 0 && mmConvertToMarkdownWithCache.defaultExpectation == nil && mmConvertToMarkdownWithCache.mock.funcConvertToMarkdownWithCache == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertToMarkdownWithCache.mock.afterConvertToMarkdownWithCacheCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertToMarkdownWithCache.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertToMarkdownWithCache implements mm_ai.Client
func (mmConvertToMarkdownWithCache *ClientMock) ConvertToMarkdownWithCache(ctx context.Context, cacheName string, prompt string) (cp1 *mm_ai.ConversionResult, err error) {
	mm_atomic.AddUint64(&mmConvertToMarkdownWithCache.beforeConvertToMarkdownWithCacheCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertToMarkdownWithCache.afterConvertToMarkdownWithCacheCounter, 1)

	mmConvertToMarkdownWithCache.t.Helper()

	if mmConvertToMarkdownWithCache.inspectFuncConvertToMarkdownWithCache != nil {
		mmConvertToMarkdownWithCache.inspectFuncConvertToMarkdownWithCache(ctx, cacheName, prompt)
	}

	mm_params := ClientMockConvertToMarkdownWithCacheParams{ctx, cacheName, prompt}

	// Record call args
	mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.mutex.Lock()
	mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.callArgs = append(mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.callArgs, &mm_params)
	mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.mutex.Unlock()

	for _, e := range mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.defaultExpectation.params
		mm_want_ptrs := mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.defaultExpectation.paramPtrs

		mm_got := ClientMockConvertToMarkdownWithCacheParams{ctx, cacheName, prompt}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConvertToMarkdownWithCache.t.Errorf("ClientMock.ConvertToMarkdownWithCache got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cacheName != nil && !minimock.Equal(*mm_want_ptrs.cacheName, mm_got.cacheName) {
				mmConvertToMarkdownWithCache.t.Errorf("ClientMock.ConvertToMarkdownWithCache got unexpected parameter cacheName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.defaultExpectation.expectationOrigins.originCacheName, *mm_want_ptrs.cacheName, mm_got.cacheName, minimock.Diff(*mm_want_ptrs.cacheName, mm_got.cacheName))
			}

			if mm_want_ptrs.prompt != nil && !minimock.Equal(*mm_want_ptrs.prompt, mm_got.prompt) {
				mmConvertToMarkdownWithCache.t.Errorf("ClientMock.ConvertToMarkdownWithCache got unexpected parameter prompt, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.defaultExpectation.expectationOrigins.originPrompt, *mm_want_ptrs.prompt, mm_got.prompt, minimock.Diff(*mm_want_ptrs.prompt, mm_got.prompt))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertToMarkdownWithCache.t.Errorf("ClientMock.ConvertToMarkdownWithCache got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertToMarkdownWithCache.t.Fatal("No results are set for the ClientMock.ConvertToMarkdownWithCache")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmConvertToMarkdownWithCache.funcConvertToMarkdownWithCache != nil {
		return mmConvertToMarkdownWithCache.funcConvertToMarkdownWithCache(ctx, cacheName, prompt)
	}
	mmConvertToMarkdownWithCache.t.Fatalf("Unexpected call to ClientMock.ConvertToMarkdownWithCache. %v %v %v", ctx, cacheName, prompt)
	return
}

// ConvertToMarkdownWithCacheAfterCounter returns a count of finished ClientMock.ConvertToMarkdownWithCache invocations
func (mmConvertToMarkdownWithCache *ClientMock) ConvertToMarkdownWithCacheAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertToMarkdownWithCache.afterConvertToMarkdownWithCacheCounter)
}

// ConvertToMarkdownWithCacheBeforeCounter returns a count of ClientMock.ConvertToMarkdownWithCache invocations
func (mmConvertToMarkdownWithCache *ClientMock) ConvertToMarkdownWithCacheBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertToMarkdownWithCache.beforeConvertToMarkdownWithCacheCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.ConvertToMarkdownWithCache.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertToMarkdownWithCache *mClientMockConvertToMarkdownWithCache) Calls() []*ClientMockConvertToMarkdownWithCacheParams {
	mmConvertToMarkdownWithCache.mutex.RLock()

	argCopy := make([]*ClientMockConvertToMarkdownWithCacheParams, len(mmConvertToMarkdownWithCache.callArgs))
	copy(argCopy, mmConvertToMarkdownWithCache.callArgs)

	mmConvertToMarkdownWithCache.mutex.RUnlock()

	return argCopy
}

// MinimockConvertToMarkdownWithCacheDone returns true if the count of the ConvertToMarkdownWithCache invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockConvertToMarkdownWithCacheDone() bool {
	if m.ConvertToMarkdownWithCacheMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConvertToMarkdownWithCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertToMarkdownWithCacheMock.invocationsDone()
}

// MinimockConvertToMarkdownWithCacheInspect logs each unmet expectation
func (m *ClientMock) MinimockConvertToMarkdownWithCacheInspect() {
	for _, e := range m.ConvertToMarkdownWithCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.ConvertToMarkdownWithCache at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterConvertToMarkdownWithCacheCounter := mm_atomic.LoadUint64(&m.afterConvertToMarkdownWithCacheCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertToMarkdownWithCacheMock.defaultExpectation != nil && afterConvertToMarkdownWithCacheCounter < 1 {
		if m.ConvertToMarkdownWithCacheMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.ConvertToMarkdownWithCache at\n%s", m.ConvertToMarkdownWithCacheMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.ConvertToMarkdownWithCache at\n%s with params: %#v", m.ConvertToMarkdownWithCacheMock.defaultExpectation.expectationOrigins.origin, *m.ConvertToMarkdownWithCacheMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertToMarkdownWithCache != nil && afterConvertToMarkdownWithCacheCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.ConvertToMarkdownWithCache at\n%s", m.funcConvertToMarkdownWithCacheOrigin)
	}

	if !m.ConvertToMarkdownWithCacheMock.invocationsDone() && afterConvertToMarkdownWithCacheCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.ConvertToMarkdownWithCache at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertToMarkdownWithCacheMock.expectedInvocations), m.ConvertToMarkdownWithCacheMock.expectedInvocationsOrigin, afterConvertToMarkdownWithCacheCounter)
	}
}

type mClientMockConvertToMarkdownWithoutCache struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockConvertToMarkdownWithoutCacheExpectation
	expectations       []*ClientMockConvertToMarkdownWithoutCacheExpectation

	callArgs []*ClientMockConvertToMarkdownWithoutCacheParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockConvertToMarkdownWithoutCacheExpectation specifies expectation struct of the Client.ConvertToMarkdownWithoutCache
type ClientMockConvertToMarkdownWithoutCacheExpectation struct {
	mock               *ClientMock
	params             *ClientMockConvertToMarkdownWithoutCacheParams
	paramPtrs          *ClientMockConvertToMarkdownWithoutCacheParamPtrs
	expectationOrigins ClientMockConvertToMarkdownWithoutCacheExpectationOrigins
	results            *ClientMockConvertToMarkdownWithoutCacheResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockConvertToMarkdownWithoutCacheParams contains parameters of the Client.ConvertToMarkdownWithoutCache
type ClientMockConvertToMarkdownWithoutCacheParams struct {
	ctx      context.Context
	content  []byte
	fileType artifactpb.File_Type
	filename string
	prompt   string
}

// ClientMockConvertToMarkdownWithoutCacheParamPtrs contains pointers to parameters of the Client.ConvertToMarkdownWithoutCache
type ClientMockConvertToMarkdownWithoutCacheParamPtrs struct {
	ctx      *context.Context
	content  *[]byte
	fileType *artifactpb.File_Type
	filename *string
	prompt   *string
}

// ClientMockConvertToMarkdownWithoutCacheResults contains results of the Client.ConvertToMarkdownWithoutCache
type ClientMockConvertToMarkdownWithoutCacheResults struct {
	cp1 *mm_ai.ConversionResult
	err error
}

// ClientMockConvertToMarkdownWithoutCacheOrigins contains origins of expectations of the Client.ConvertToMarkdownWithoutCache
type ClientMockConvertToMarkdownWithoutCacheExpectationOrigins struct {
	origin         string
	originCtx      string
	originContent  string
	originFileType string
	originFilename string
	originPrompt   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConvertToMarkdownWithoutCache *mClientMockConvertToMarkdownWithoutCache) Optional() *mClientMockConvertToMarkdownWithoutCache {
	mmConvertToMarkdownWithoutCache.optional = true
	return mmConvertToMarkdownWithoutCache
}

// Expect sets up expected params for Client.ConvertToMarkdownWithoutCache
func (mmConvertToMarkdownWithoutCache *mClientMockConvertToMarkdownWithoutCache) Expect(ctx context.Context, content []byte, fileType artifactpb.File_Type, filename string, prompt string) *mClientMockConvertToMarkdownWithoutCache {
	if mmConvertToMarkdownWithoutCache.mock.funcConvertToMarkdownWithoutCache != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("ClientMock.ConvertToMarkdownWithoutCache mock is already set by Set")
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation == nil {
		mmConvertToMarkdownWithoutCache.defaultExpectation = &ClientMockConvertToMarkdownWithoutCacheExpectation{}
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("ClientMock.ConvertToMarkdownWithoutCache mock is already set by ExpectParams functions")
	}

	mmConvertToMarkdownWithoutCache.defaultExpectation.params = &ClientMockConvertToMarkdownWithoutCacheParams{ctx, content, fileType, filename, prompt}
	mmConvertToMarkdownWithoutCache.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmConvertToMarkdownWithoutCache.expectations {
		if minimock.Equal(e.params, mmConvertToMarkdownWithoutCache.defaultExpectation.params) {
			mmConvertToMarkdownWithoutCache.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertToMarkdownWithoutCache.defaultExpectation.params)
		}
	}

	return mmConvertToMarkdownWithoutCache
}

// ExpectCtxParam1 sets up expected param ctx for Client.ConvertToMarkdownWithoutCache
func (mmConvertToMarkdownWithoutCache *mClientMockConvertToMarkdownWithoutCache) ExpectCtxParam1(ctx context.Context) *mClientMockConvertToMarkdownWithoutCache {
	if mmConvertToMarkdownWithoutCache.mock.funcConvertToMarkdownWithoutCache != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("ClientMock.ConvertToMarkdownWithoutCache mock is already set by Set")
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation == nil {
		mmConvertToMarkdownWithoutCache.defaultExpectation = &ClientMockConvertToMarkdownWithoutCacheExpectation{}
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation.params != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("ClientMock.ConvertToMarkdownWithoutCache mock is already set by Expect")
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs == nil {
		mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs = &ClientMockConvertToMarkdownWithoutCacheParamPtrs{}
	}
	mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs.ctx = &ctx
	mmConvertToMarkdownWithoutCache.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmConvertToMarkdownWithoutCache
}

// ExpectContentParam2 sets up expected param content for Client.ConvertToMarkdownWithoutCache
func (mmConvertToMarkdownWithoutCache *mClientMockConvertToMarkdownWithoutCache) ExpectContentParam2(content []byte) *mClientMockConvertToMarkdownWithoutCache {
	if mmConvertToMarkdownWithoutCache.mock.funcConvertToMarkdownWithoutCache != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("ClientMock.ConvertToMarkdownWithoutCache mock is already set by Set")
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation == nil {
		mmConvertToMarkdownWithoutCache.defaultExpectation = &ClientMockConvertToMarkdownWithoutCacheExpectation{}
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation.params != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("ClientMock.ConvertToMarkdownWithoutCache mock is already set by Expect")
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs == nil {
		mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs = &ClientMockConvertToMarkdownWithoutCacheParamPtrs{}
	}
	mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs.content = &content
	mmConvertToMarkdownWithoutCache.defaultExpectation.expectationOrigins.originContent = minimock.CallerInfo(1)

	return mmConvertToMarkdownWithoutCache
}

// ExpectFileTypeParam3 sets up expected param fileType for Client.ConvertToMarkdownWithoutCache
func (mmConvertToMarkdownWithoutCache *mClientMockConvertToMarkdownWithoutCache) ExpectFileTypeParam3(fileType artifactpb.File_Type) *mClientMockConvertToMarkdownWithoutCache {
	if mmConvertToMarkdownWithoutCache.mock.funcConvertToMarkdownWithoutCache != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("ClientMock.ConvertToMarkdownWithoutCache mock is already set by Set")
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation == nil {
		mmConvertToMarkdownWithoutCache.defaultExpectation = &ClientMockConvertToMarkdownWithoutCacheExpectation{}
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation.params != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("ClientMock.ConvertToMarkdownWithoutCache mock is already set by Expect")
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs == nil {
		mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs = &ClientMockConvertToMarkdownWithoutCacheParamPtrs{}
	}
	mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs.fileType = &fileType
	mmConvertToMarkdownWithoutCache.defaultExpectation.expectationOrigins.originFileType = minimock.CallerInfo(1)

	return mmConvertToMarkdownWithoutCache
}

// ExpectFilenameParam4 sets up expected param filename for Client.ConvertToMarkdownWithoutCache
func (mmConvertToMarkdownWithoutCache *mClientMockConvertToMarkdownWithoutCache) ExpectFilenameParam4(filename string) *mClientMockConvertToMarkdownWithoutCache {
	if mmConvertToMarkdownWithoutCache.mock.funcConvertToMarkdownWithoutCache != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("ClientMock.ConvertToMarkdownWithoutCache mock is already set by Set")
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation == nil {
		mmConvertToMarkdownWithoutCache.defaultExpectation = &ClientMockConvertToMarkdownWithoutCacheExpectation{}
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation.params != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("ClientMock.ConvertToMarkdownWithoutCache mock is already set by Expect")
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs == nil {
		mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs = &ClientMockConvertToMarkdownWithoutCacheParamPtrs{}
	}
	mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs.filename = &filename
	mmConvertToMarkdownWithoutCache.defaultExpectation.expectationOrigins.originFilename = minimock.CallerInfo(1)

	return mmConvertToMarkdownWithoutCache
}

// ExpectPromptParam5 sets up expected param prompt for Client.ConvertToMarkdownWithoutCache
func (mmConvertToMarkdownWithoutCache *mClientMockConvertToMarkdownWithoutCache) ExpectPromptParam5(prompt string) *mClientMockConvertToMarkdownWithoutCache {
	if mmConvertToMarkdownWithoutCache.mock.funcConvertToMarkdownWithoutCache != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("ClientMock.ConvertToMarkdownWithoutCache mock is already set by Set")
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation == nil {
		mmConvertToMarkdownWithoutCache.defaultExpectation = &ClientMockConvertToMarkdownWithoutCacheExpectation{}
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation.params != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("ClientMock.ConvertToMarkdownWithoutCache mock is already set by Expect")
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs == nil {
		mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs = &ClientMockConvertToMarkdownWithoutCacheParamPtrs{}
	}
	mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs.prompt = &prompt
	mmConvertToMarkdownWithoutCache.defaultExpectation.expectationOrigins.originPrompt = minimock.CallerInfo(1)

	return mmConvertToMarkdownWithoutCache
}

// Inspect accepts an inspector function that has same arguments as the Client.ConvertToMarkdownWithoutCache
func (mmConvertToMarkdownWithoutCache *mClientMockConvertToMarkdownWithoutCache) Inspect(f func(ctx context.Context, content []byte, fileType artifactpb.File_Type, filename string, prompt string)) *mClientMockConvertToMarkdownWithoutCache {
	if mmConvertToMarkdownWithoutCache.mock.inspectFuncConvertToMarkdownWithoutCache != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("Inspect function is already set for ClientMock.ConvertToMarkdownWithoutCache")
	}

	mmConvertToMarkdownWithoutCache.mock.inspectFuncConvertToMarkdownWithoutCache = f

	return mmConvertToMarkdownWithoutCache
}

// Return sets up results that will be returned by Client.ConvertToMarkdownWithoutCache
func (mmConvertToMarkdownWithoutCache *mClientMockConvertToMarkdownWithoutCache) Return(cp1 *mm_ai.ConversionResult, err error) *ClientMock {
	if mmConvertToMarkdownWithoutCache.mock.funcConvertToMarkdownWithoutCache != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("ClientMock.ConvertToMarkdownWithoutCache mock is already set by Set")
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation == nil {
		mmConvertToMarkdownWithoutCache.defaultExpectation = &ClientMockConvertToMarkdownWithoutCacheExpectation{mock: mmConvertToMarkdownWithoutCache.mock}
	}
	mmConvertToMarkdownWithoutCache.defaultExpectation.results = &ClientMockConvertToMarkdownWithoutCacheResults{cp1, err}
	mmConvertToMarkdownWithoutCache.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmConvertToMarkdownWithoutCache.mock
}

// Set uses given function f to mock the Client.ConvertToMarkdownWithoutCache method
func (mmConvertToMarkdownWithoutCache *mClientMockConvertToMarkdownWithoutCache) Set(f func(ctx context.Context, content []byte, fileType artifactpb.File_Type, filename string, prompt string) (cp1 *mm_ai.ConversionResult, err error)) *ClientMock {
	if mmConvertToMarkdownWithoutCache.defaultExpectation != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("Default expectation is already set for the Client.ConvertToMarkdownWithoutCache method")
	}

	if len(mmConvertToMarkdownWithoutCache.expectations) > 0 {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("Some expectations are already set for the Client.ConvertToMarkdownWithoutCache method")
	}

	mmConvertToMarkdownWithoutCache.mock.funcConvertToMarkdownWithoutCache = f
	mmConvertToMarkdownWithoutCache.mock.funcConvertToMarkdownWithoutCacheOrigin = minimock.CallerInfo(1)
	return mmConvertToMarkdownWithoutCache.mock
}

// When sets expectation for the Client.ConvertToMarkdownWithoutCache which will trigger the result defined by the following
// Then helper
func (mmConvertToMarkdownWithoutCache *mClientMockConvertToMarkdownWithoutCache) When(ctx context.Context, content []byte, fileType artifactpb.File_Type, filename string, prompt string) *ClientMockConvertToMarkdownWithoutCacheExpectation {
	if mmConvertToMarkdownWithoutCache.mock.funcConvertToMarkdownWithoutCache != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("ClientMock.ConvertToMarkdownWithoutCache mock is already set by Set")
	}

	expectation := &ClientMockConvertToMarkdownWithoutCacheExpectation{
		mock:               mmConvertToMarkdownWithoutCache.mock,
		params:             &ClientMockConvertToMarkdownWithoutCacheParams{ctx, content, fileType, filename, prompt},
		expectationOrigins: ClientMockConvertToMarkdownWithoutCacheExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmConvertToMarkdownWithoutCache.expectations = append(mmConvertToMarkdownWithoutCache.expectations, expectation)
	return expectation
}

// Then sets up Client.ConvertToMarkdownWithoutCache return parameters for the expectation previously defined by the When method
func (e *ClientMockConvertToMarkdownWithoutCacheExpectation) Then(cp1 *mm_ai.ConversionResult, err error) *ClientMock {
	e.results = &ClientMockConvertToMarkdownWithoutCacheResults{cp1, err}
	return e.mock
}

// Times sets number of times Client.ConvertToMarkdownWithoutCache should be invoked
func (mmConvertToMarkdownWithoutCache *mClientMockConvertToMarkdownWithoutCache) Times(n uint64) *mClientMockConvertToMarkdownWithoutCache {
	if n == 0 {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("Times of ClientMock.ConvertToMarkdownWithoutCache mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertToMarkdownWithoutCache.expectedInvocations, n)
	mmConvertToMarkdownWithoutCache.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmConvertToMarkdownWithoutCache
}

func (mmConvertToMarkdownWithoutCache *mClientMockConvertToMarkdownWithoutCache) invocationsDone() bool {
	if len(mmConvertToMarkdownWithoutCache.expectations) == 0 && mmConvertToMarkdownWithoutCache.defaultExpectation == nil && mmConvertToMarkdownWithoutCache.mock.funcConvertToMarkdownWithoutCache == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertToMarkdownWithoutCache.mock.afterConvertToMarkdownWithoutCacheCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertToMarkdownWithoutCache.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertToMarkdownWithoutCache implements mm_ai.Client
func (mmConvertToMarkdownWithoutCache *ClientMock) ConvertToMarkdownWithoutCache(ctx context.Context, content []byte, fileType artifactpb.File_Type, filename string, prompt string) (cp1 *mm_ai.ConversionResult, err error) {
	mm_atomic.AddUint64(&mmConvertToMarkdownWithoutCache.beforeConvertToMarkdownWithoutCacheCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertToMarkdownWithoutCache.afterConvertToMarkdownWithoutCacheCounter, 1)

	mmConvertToMarkdownWithoutCache.t.Helper()

	if mmConvertToMarkdownWithoutCache.inspectFuncConvertToMarkdownWithoutCache != nil {
		mmConvertToMarkdownWithoutCache.inspectFuncConvertToMarkdownWithoutCache(ctx, content, fileType, filename, prompt)
	}

	mm_params := ClientMockConvertToMarkdownWithoutCacheParams{ctx, content, fileType, filename, prompt}

	// Record call args
	mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.mutex.Lock()
	mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.callArgs = append(mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.callArgs, &mm_params)
	mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.mutex.Unlock()

	for _, e := range mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.defaultExpectation.params
		mm_want_ptrs := mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.defaultExpectation.paramPtrs

		mm_got := ClientMockConvertToMarkdownWithoutCacheParams{ctx, content, fileType, filename, prompt}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConvertToMarkdownWithoutCache.t.Errorf("ClientMock.ConvertToMarkdownWithoutCache got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.content != nil && !minimock.Equal(*mm_want_ptrs.content, mm_got.content) {
				mmConvertToMarkdownWithoutCache.t.Errorf("ClientMock.ConvertToMarkdownWithoutCache got unexpected parameter content, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.defaultExpectation.expectationOrigins.originContent, *mm_want_ptrs.content, mm_got.content, minimock.Diff(*mm_want_ptrs.content, mm_got.content))
			}

			if mm_want_ptrs.fileType != nil && !minimock.Equal(*mm_want_ptrs.fileType, mm_got.fileType) {
				mmConvertToMarkdownWithoutCache.t.Errorf("ClientMock.ConvertToMarkdownWithoutCache got unexpected parameter fileType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.defaultExpectation.expectationOrigins.originFileType, *mm_want_ptrs.fileType, mm_got.fileType, minimock.Diff(*mm_want_ptrs.fileType, mm_got.fileType))
			}

			if mm_want_ptrs.filename != nil && !minimock.Equal(*mm_want_ptrs.filename, mm_got.filename) {
				mmConvertToMarkdownWithoutCache.t.Errorf("ClientMock.ConvertToMarkdownWithoutCache got unexpected parameter filename, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.defaultExpectation.expectationOrigins.originFilename, *mm_want_ptrs.filename, mm_got.filename, minimock.Diff(*mm_want_ptrs.filename, mm_got.filename))
			}

			if mm_want_ptrs.prompt != nil && !minimock.Equal(*mm_want_ptrs.prompt, mm_got.prompt) {
				mmConvertToMarkdownWithoutCache.t.Errorf("ClientMock.ConvertToMarkdownWithoutCache got unexpected parameter prompt, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.defaultExpectation.expectationOrigins.originPrompt, *mm_want_ptrs.prompt, mm_got.prompt, minimock.Diff(*mm_want_ptrs.prompt, mm_got.prompt))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertToMarkdownWithoutCache.t.Errorf("ClientMock.ConvertToMarkdownWithoutCache got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertToMarkdownWithoutCache.t.Fatal("No results are set for the ClientMock.ConvertToMarkdownWithoutCache")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmConvertToMarkdownWithoutCache.funcConvertToMarkdownWithoutCache != nil {
		return mmConvertToMarkdownWithoutCache.funcConvertToMarkdownWithoutCache(ctx, content, fileType, filename, prompt)
	}
	mmConvertToMarkdownWithoutCache.t.Fatalf("Unexpected call to ClientMock.ConvertToMarkdownWithoutCache. %v %v %v %v %v", ctx, content, fileType, filename, prompt)
	return
}

// ConvertToMarkdownWithoutCacheAfterCounter returns a count of finished ClientMock.ConvertToMarkdownWithoutCache invocations
func (mmConvertToMarkdownWithoutCache *ClientMock) ConvertToMarkdownWithoutCacheAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertToMarkdownWithoutCache.afterConvertToMarkdownWithoutCacheCounter)
}

// ConvertToMarkdownWithoutCacheBeforeCounter returns a count of ClientMock.ConvertToMarkdownWithoutCache invocations
func (mmConvertToMarkdownWithoutCache *ClientMock) ConvertToMarkdownWithoutCacheBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertToMarkdownWithoutCache.beforeConvertToMarkdownWithoutCacheCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.ConvertToMarkdownWithoutCache.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertToMarkdownWithoutCache *mClientMockConvertToMarkdownWithoutCache) Calls() []*ClientMockConvertToMarkdownWithoutCacheParams {
	mmConvertToMarkdownWithoutCache.mutex.RLock()

	argCopy := make([]*ClientMockConvertToMarkdownWithoutCacheParams, len(mmConvertToMarkdownWithoutCache.callArgs))
	copy(argCopy, mmConvertToMarkdownWithoutCache.callArgs)

	mmConvertToMarkdownWithoutCache.mutex.RUnlock()

	return argCopy
}

// MinimockConvertToMarkdownWithoutCacheDone returns true if the count of the ConvertToMarkdownWithoutCache invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockConvertToMarkdownWithoutCacheDone() bool {
	if m.ConvertToMarkdownWithoutCacheMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConvertToMarkdownWithoutCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertToMarkdownWithoutCacheMock.invocationsDone()
}

// MinimockConvertToMarkdownWithoutCacheInspect logs each unmet expectation
func (m *ClientMock) MinimockConvertToMarkdownWithoutCacheInspect() {
	for _, e := range m.ConvertToMarkdownWithoutCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.ConvertToMarkdownWithoutCache at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterConvertToMarkdownWithoutCacheCounter := mm_atomic.LoadUint64(&m.afterConvertToMarkdownWithoutCacheCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertToMarkdownWithoutCacheMock.defaultExpectation != nil && afterConvertToMarkdownWithoutCacheCounter < 1 {
		if m.ConvertToMarkdownWithoutCacheMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.ConvertToMarkdownWithoutCache at\n%s", m.ConvertToMarkdownWithoutCacheMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.ConvertToMarkdownWithoutCache at\n%s with params: %#v", m.ConvertToMarkdownWithoutCacheMock.defaultExpectation.expectationOrigins.origin, *m.ConvertToMarkdownWithoutCacheMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertToMarkdownWithoutCache != nil && afterConvertToMarkdownWithoutCacheCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.ConvertToMarkdownWithoutCache at\n%s", m.funcConvertToMarkdownWithoutCacheOrigin)
	}

	if !m.ConvertToMarkdownWithoutCacheMock.invocationsDone() && afterConvertToMarkdownWithoutCacheCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.ConvertToMarkdownWithoutCache at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertToMarkdownWithoutCacheMock.expectedInvocations), m.ConvertToMarkdownWithoutCacheMock.expectedInvocationsOrigin, afterConvertToMarkdownWithoutCacheCounter)
	}
}

type mClientMockCreateCache struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockCreateCacheExpectation
	expectations       []*ClientMockCreateCacheExpectation

	callArgs []*ClientMockCreateCacheParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockCreateCacheExpectation specifies expectation struct of the Client.CreateCache
type ClientMockCreateCacheExpectation struct {
	mock               *ClientMock
	params             *ClientMockCreateCacheParams
	paramPtrs          *ClientMockCreateCacheParamPtrs
	expectationOrigins ClientMockCreateCacheExpectationOrigins
	results            *ClientMockCreateCacheResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockCreateCacheParams contains parameters of the Client.CreateCache
type ClientMockCreateCacheParams struct {
	ctx               context.Context
	files             []mm_ai.FileContent
	ttl               time.Duration
	systemInstruction string
}

// ClientMockCreateCacheParamPtrs contains pointers to parameters of the Client.CreateCache
type ClientMockCreateCacheParamPtrs struct {
	ctx               *context.Context
	files             *[]mm_ai.FileContent
	ttl               *time.Duration
	systemInstruction *string
}

// ClientMockCreateCacheResults contains results of the Client.CreateCache
type ClientMockCreateCacheResults struct {
	cp1 *mm_ai.CacheResult
	err error
}

// ClientMockCreateCacheOrigins contains origins of expectations of the Client.CreateCache
type ClientMockCreateCacheExpectationOrigins struct {
	origin                  string
	originCtx               string
	originFiles             string
	originTtl               string
	originSystemInstruction string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateCache *mClientMockCreateCache) Optional() *mClientMockCreateCache {
	mmCreateCache.optional = true
	return mmCreateCache
}

// Expect sets up expected params for Client.CreateCache
func (mmCreateCache *mClientMockCreateCache) Expect(ctx context.Context, files []mm_ai.FileContent, ttl time.Duration, systemInstruction string) *mClientMockCreateCache {
	if mmCreateCache.mock.funcCreateCache != nil {
		mmCreateCache.mock.t.Fatalf("ClientMock.CreateCache mock is already set by Set")
	}

	if mmCreateCache.defaultExpectation == nil {
		mmCreateCache.defaultExpectation = &ClientMockCreateCacheExpectation{}
	}

	if mmCreateCache.defaultExpectation.paramPtrs != nil {
		mmCreateCache.mock.t.Fatalf("ClientMock.CreateCache mock is already set by ExpectParams functions")
	}

	mmCreateCache.defaultExpectation.params = &ClientMockCreateCacheParams{ctx, files, ttl, systemInstruction}
	mmCreateCache.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateCache.expectations {
		if minimock.Equal(e.params, mmCreateCache.defaultExpectation.params) {
			mmCreateCache.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateCache.defaultExpectation.params)
		}
	}

	return mmCreateCache
}

// ExpectCtxParam1 sets up expected param ctx for Client.CreateCache
func (mmCreateCache *mClientMockCreateCache) ExpectCtxParam1(ctx context.Context) *mClientMockCreateCache {
	if mmCreateCache.mock.funcCreateCache != nil {
		mmCreateCache.mock.t.Fatalf("ClientMock.CreateCache mock is already set by Set")
	}

	if mmCreateCache.defaultExpectation == nil {
		mmCreateCache.defaultExpectation = &ClientMockCreateCacheExpectation{}
	}

	if mmCreateCache.defaultExpectation.params != nil {
		mmCreateCache.mock.t.Fatalf("ClientMock.CreateCache mock is already set by Expect")
	}

	if mmCreateCache.defaultExpectation.paramPtrs == nil {
		mmCreateCache.defaultExpectation.paramPtrs = &ClientMockCreateCacheParamPtrs{}
	}
	mmCreateCache.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateCache.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateCache
}

// ExpectFilesParam2 sets up expected param files for Client.CreateCache
func (mmCreateCache *mClientMockCreateCache) ExpectFilesParam2(files []mm_ai.FileContent) *mClientMockCreateCache {
	if mmCreateCache.mock.funcCreateCache != nil {
		mmCreateCache.mock.t.Fatalf("ClientMock.CreateCache mock is already set by Set")
	}

	if mmCreateCache.defaultExpectation == nil {
		mmCreateCache.defaultExpectation = &ClientMockCreateCacheExpectation{}
	}

	if mmCreateCache.defaultExpectation.params != nil {
		mmCreateCache.mock.t.Fatalf("ClientMock.CreateCache mock is already set by Expect")
	}

	if mmCreateCache.defaultExpectation.paramPtrs == nil {
		mmCreateCache.defaultExpectation.paramPtrs = &ClientMockCreateCacheParamPtrs{}
	}
	mmCreateCache.defaultExpectation.paramPtrs.files = &files
	mmCreateCache.defaultExpectation.expectationOrigins.originFiles = minimock.CallerInfo(1)

	return mmCreateCache
}

// ExpectTtlParam3 sets up expected param ttl for Client.CreateCache
func (mmCreateCache *mClientMockCreateCache) ExpectTtlParam3(ttl time.Duration) *mClientMockCreateCache {
	if mmCreateCache.mock.funcCreateCache != nil {
		mmCreateCache.mock.t.Fatalf("ClientMock.CreateCache mock is already set by Set")
	}

	if mmCreateCache.defaultExpectation == nil {
		mmCreateCache.defaultExpectation = &ClientMockCreateCacheExpectation{}
	}

	if mmCreateCache.defaultExpectation.params != nil {
		mmCreateCache.mock.t.Fatalf("ClientMock.CreateCache mock is already set by Expect")
	}

	if mmCreateCache.defaultExpectation.paramPtrs == nil {
		mmCreateCache.defaultExpectation.paramPtrs = &ClientMockCreateCacheParamPtrs{}
	}
	mmCreateCache.defaultExpectation.paramPtrs.ttl = &ttl
	mmCreateCache.defaultExpectation.expectationOrigins.originTtl = minimock.CallerInfo(1)

	return mmCreateCache
}

// ExpectSystemInstructionParam4 sets up expected param systemInstruction for Client.CreateCache
func (mmCreateCache *mClientMockCreateCache) ExpectSystemInstructionParam4(systemInstruction string) *mClientMockCreateCache {
	if mmCreateCache.mock.funcCreateCache != nil {
		mmCreateCache.mock.t.Fatalf("ClientMock.CreateCache mock is already set by Set")
	}

	if mmCreateCache.defaultExpectation == nil {
		mmCreateCache.defaultExpectation = &ClientMockCreateCacheExpectation{}
	}

	if mmCreateCache.defaultExpectation.params != nil {
		mmCreateCache.mock.t.Fatalf("ClientMock.CreateCache mock is already set by Expect")
	}

	if mmCreateCache.defaultExpectation.paramPtrs == nil {
		mmCreateCache.defaultExpectation.paramPtrs = &ClientMockCreateCacheParamPtrs{}
	}
	mmCreateCache.defaultExpectation.paramPtrs.systemInstruction = &systemInstruction
	mmCreateCache.defaultExpectation.expectationOrigins.originSystemInstruction = minimock.CallerInfo(1)

	return mmCreateCache
}

// Inspect accepts an inspector function that has same arguments as the Client.CreateCache
func (mmCreateCache *mClientMockCreateCache) Inspect(f func(ctx context.Context, files []mm_ai.FileContent, ttl time.Duration, systemInstruction string)) *mClientMockCreateCache {
	if mmCreateCache.mock.inspectFuncCreateCache != nil {
		mmCreateCache.mock.t.Fatalf("Inspect function is already set for ClientMock.CreateCache")
	}

	mmCreateCache.mock.inspectFuncCreateCache = f

	return mmCreateCache
}

// Return sets up results that will be returned by Client.CreateCache
func (mmCreateCache *mClientMockCreateCache) Return(cp1 *mm_ai.CacheResult, err error) *ClientMock {
	if mmCreateCache.mock.funcCreateCache != nil {
		mmCreateCache.mock.t.Fatalf("ClientMock.CreateCache mock is already set by Set")
	}

	if mmCreateCache.defaultExpectation == nil {
		mmCreateCache.defaultExpectation = &ClientMockCreateCacheExpectation{mock: mmCreateCache.mock}
	}
	mmCreateCache.defaultExpectation.results = &ClientMockCreateCacheResults{cp1, err}
	mmCreateCache.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateCache.mock
}

// Set uses given function f to mock the Client.CreateCache method
func (mmCreateCache *mClientMockCreateCache) Set(f func(ctx context.Context, files []mm_ai.FileContent, ttl time.Duration, systemInstruction string) (cp1 *mm_ai.CacheResult, err error)) *ClientMock {
	if mmCreateCache.defaultExpectation != nil {
		mmCreateCache.mock.t.Fatalf("Default expectation is already set for the Client.CreateCache method")
	}

	if len(mmCreateCache.expectations) > 0 {
		mmCreateCache.mock.t.Fatalf("Some expectations are already set for the Client.CreateCache method")
	}

	mmCreateCache.mock.funcCreateCache = f
	mmCreateCache.mock.funcCreateCacheOrigin = minimock.CallerInfo(1)
	return mmCreateCache.mock
}

// When sets expectation for the Client.CreateCache which will trigger the result defined by the following
// Then helper
func (mmCreateCache *mClientMockCreateCache) When(ctx context.Context, files []mm_ai.FileContent, ttl time.Duration, systemInstruction string) *ClientMockCreateCacheExpectation {
	if mmCreateCache.mock.funcCreateCache != nil {
		mmCreateCache.mock.t.Fatalf("ClientMock.CreateCache mock is already set by Set")
	}

	expectation := &ClientMockCreateCacheExpectation{
		mock:               mmCreateCache.mock,
		params:             &ClientMockCreateCacheParams{ctx, files, ttl, systemInstruction},
		expectationOrigins: ClientMockCreateCacheExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateCache.expectations = append(mmCreateCache.expectations, expectation)
	return expectation
}

// Then sets up Client.CreateCache return parameters for the expectation previously defined by the When method
func (e *ClientMockCreateCacheExpectation) Then(cp1 *mm_ai.CacheResult, err error) *ClientMock {
	e.results = &ClientMockCreateCacheResults{cp1, err}
	return e.mock
}

// Times sets number of times Client.CreateCache should be invoked
func (mmCreateCache *mClientMockCreateCache) Times(n uint64) *mClientMockCreateCache {
	if n == 0 {
		mmCreateCache.mock.t.Fatalf("Times of ClientMock.CreateCache mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateCache.expectedInvocations, n)
	mmCreateCache.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateCache
}

func (mmCreateCache *mClientMockCreateCache) invocationsDone() bool {
	if len(mmCreateCache.expectations) == 0 && mmCreateCache.defaultExpectation == nil && mmCreateCache.mock.funcCreateCache == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateCache.mock.afterCreateCacheCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateCache.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateCache implements mm_ai.Client
func (mmCreateCache *ClientMock) CreateCache(ctx context.Context, files []mm_ai.FileContent, ttl time.Duration, systemInstruction string) (cp1 *mm_ai.CacheResult, err error) {
	mm_atomic.AddUint64(&mmCreateCache.beforeCreateCacheCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateCache.afterCreateCacheCounter, 1)

	mmCreateCache.t.Helper()

	if mmCreateCache.inspectFuncCreateCache != nil {
		mmCreateCache.inspectFuncCreateCache(ctx, files, ttl, systemInstruction)
	}

	mm_params := ClientMockCreateCacheParams{ctx, files, ttl, systemInstruction}

	// Record call args
	mmCreateCache.CreateCacheMock.mutex.Lock()
	mmCreateCache.CreateCacheMock.callArgs = append(mmCreateCache.CreateCacheMock.callArgs, &mm_params)
	mmCreateCache.CreateCacheMock.mutex.Unlock()

	for _, e := range mmCreateCache.CreateCacheMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCreateCache.CreateCacheMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateCache.CreateCacheMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateCache.CreateCacheMock.defaultExpectation.params
		mm_want_ptrs := mmCreateCache.CreateCacheMock.defaultExpectation.paramPtrs

		mm_got := ClientMockCreateCacheParams{ctx, files, ttl, systemInstruction}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateCache.t.Errorf("ClientMock.CreateCache got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCache.CreateCacheMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.files != nil && !minimock.Equal(*mm_want_ptrs.files, mm_got.files) {
				mmCreateCache.t.Errorf("ClientMock.CreateCache got unexpected parameter files, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCache.CreateCacheMock.defaultExpectation.expectationOrigins.originFiles, *mm_want_ptrs.files, mm_got.files, minimock.Diff(*mm_want_ptrs.files, mm_got.files))
			}

			if mm_want_ptrs.ttl != nil && !minimock.Equal(*mm_want_ptrs.ttl, mm_got.ttl) {
				mmCreateCache.t.Errorf("ClientMock.CreateCache got unexpected parameter ttl, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCache.CreateCacheMock.defaultExpectation.expectationOrigins.originTtl, *mm_want_ptrs.ttl, mm_got.ttl, minimock.Diff(*mm_want_ptrs.ttl, mm_got.ttl))
			}

			if mm_want_ptrs.systemInstruction != nil && !minimock.Equal(*mm_want_ptrs.systemInstruction, mm_got.systemInstruction) {
				mmCreateCache.t.Errorf("ClientMock.CreateCache got unexpected parameter systemInstruction, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCache.CreateCacheMock.defaultExpectation.expectationOrigins.originSystemInstruction, *mm_want_ptrs.systemInstruction, mm_got.systemInstruction, minimock.Diff(*mm_want_ptrs.systemInstruction, mm_got.systemInstruction))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateCache.t.Errorf("ClientMock.CreateCache got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateCache.CreateCacheMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateCache.CreateCacheMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateCache.t.Fatal("No results are set for the ClientMock.CreateCache")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCreateCache.funcCreateCache != nil {
		return mmCreateCache.funcCreateCache(ctx, files, ttl, systemInstruction)
	}
	mmCreateCache.t.Fatalf("Unexpected call to ClientMock.CreateCache. %v %v %v %v", ctx, files, ttl, systemInstruction)
	return
}

// CreateCacheAfterCounter returns a count of finished ClientMock.CreateCache invocations
func (mmCreateCache *ClientMock) CreateCacheAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCache.afterCreateCacheCounter)
}

// CreateCacheBeforeCounter returns a count of ClientMock.CreateCache invocations
func (mmCreateCache *ClientMock) CreateCacheBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCache.beforeCreateCacheCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.CreateCache.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateCache *mClientMockCreateCache) Calls() []*ClientMockCreateCacheParams {
	mmCreateCache.mutex.RLock()

	argCopy := make([]*ClientMockCreateCacheParams, len(mmCreateCache.callArgs))
	copy(argCopy, mmCreateCache.callArgs)

	mmCreateCache.mutex.RUnlock()

	return argCopy
}

// MinimockCreateCacheDone returns true if the count of the CreateCache invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCreateCacheDone() bool {
	if m.CreateCacheMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateCacheMock.invocationsDone()
}

// MinimockCreateCacheInspect logs each unmet expectation
func (m *ClientMock) MinimockCreateCacheInspect() {
	for _, e := range m.CreateCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.CreateCache at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCacheCounter := mm_atomic.LoadUint64(&m.afterCreateCacheCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateCacheMock.defaultExpectation != nil && afterCreateCacheCounter < 1 {
		if m.CreateCacheMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.CreateCache at\n%s", m.CreateCacheMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.CreateCache at\n%s with params: %#v", m.CreateCacheMock.defaultExpectation.expectationOrigins.origin, *m.CreateCacheMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateCache != nil && afterCreateCacheCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.CreateCache at\n%s", m.funcCreateCacheOrigin)
	}

	if !m.CreateCacheMock.invocationsDone() && afterCreateCacheCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.CreateCache at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateCacheMock.expectedInvocations), m.CreateCacheMock.expectedInvocationsOrigin, afterCreateCacheCounter)
	}
}

type mClientMockDeleteCache struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockDeleteCacheExpectation
	expectations       []*ClientMockDeleteCacheExpectation

	callArgs []*ClientMockDeleteCacheParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockDeleteCacheExpectation specifies expectation struct of the Client.DeleteCache
type ClientMockDeleteCacheExpectation struct {
	mock               *ClientMock
	params             *ClientMockDeleteCacheParams
	paramPtrs          *ClientMockDeleteCacheParamPtrs
	expectationOrigins ClientMockDeleteCacheExpectationOrigins
	results            *ClientMockDeleteCacheResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockDeleteCacheParams contains parameters of the Client.DeleteCache
type ClientMockDeleteCacheParams struct {
	ctx       context.Context
	cacheName string
}

// ClientMockDeleteCacheParamPtrs contains pointers to parameters of the Client.DeleteCache
type ClientMockDeleteCacheParamPtrs struct {
	ctx       *context.Context
	cacheName *string
}

// ClientMockDeleteCacheResults contains results of the Client.DeleteCache
type ClientMockDeleteCacheResults struct {
	err error
}

// ClientMockDeleteCacheOrigins contains origins of expectations of the Client.DeleteCache
type ClientMockDeleteCacheExpectationOrigins struct {
	origin          string
	originCtx       string
	originCacheName string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteCache *mClientMockDeleteCache) Optional() *mClientMockDeleteCache {
	mmDeleteCache.optional = true
	return mmDeleteCache
}

// Expect sets up expected params for Client.DeleteCache
func (mmDeleteCache *mClientMockDeleteCache) Expect(ctx context.Context, cacheName string) *mClientMockDeleteCache {
	if mmDeleteCache.mock.funcDeleteCache != nil {
		mmDeleteCache.mock.t.Fatalf("ClientMock.DeleteCache mock is already set by Set")
	}

	if mmDeleteCache.defaultExpectation == nil {
		mmDeleteCache.defaultExpectation = &ClientMockDeleteCacheExpectation{}
	}

	if mmDeleteCache.defaultExpectation.paramPtrs != nil {
		mmDeleteCache.mock.t.Fatalf("ClientMock.DeleteCache mock is already set by ExpectParams functions")
	}

	mmDeleteCache.defaultExpectation.params = &ClientMockDeleteCacheParams{ctx, cacheName}
	mmDeleteCache.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteCache.expectations {
		if minimock.Equal(e.params, mmDeleteCache.defaultExpectation.params) {
			mmDeleteCache.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteCache.defaultExpectation.params)
		}
	}

	return mmDeleteCache
}

// ExpectCtxParam1 sets up expected param ctx for Client.DeleteCache
func (mmDeleteCache *mClientMockDeleteCache) ExpectCtxParam1(ctx context.Context) *mClientMockDeleteCache {
	if mmDeleteCache.mock.funcDeleteCache != nil {
		mmDeleteCache.mock.t.Fatalf("ClientMock.DeleteCache mock is already set by Set")
	}

	if mmDeleteCache.defaultExpectation == nil {
		mmDeleteCache.defaultExpectation = &ClientMockDeleteCacheExpectation{}
	}

	if mmDeleteCache.defaultExpectation.params != nil {
		mmDeleteCache.mock.t.Fatalf("ClientMock.DeleteCache mock is already set by Expect")
	}

	if mmDeleteCache.defaultExpectation.paramPtrs == nil {
		mmDeleteCache.defaultExpectation.paramPtrs = &ClientMockDeleteCacheParamPtrs{}
	}
	mmDeleteCache.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteCache.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteCache
}

// ExpectCacheNameParam2 sets up expected param cacheName for Client.DeleteCache
func (mmDeleteCache *mClientMockDeleteCache) ExpectCacheNameParam2(cacheName string) *mClientMockDeleteCache {
	if mmDeleteCache.mock.funcDeleteCache != nil {
		mmDeleteCache.mock.t.Fatalf("ClientMock.DeleteCache mock is already set by Set")
	}

	if mmDeleteCache.defaultExpectation == nil {
		mmDeleteCache.defaultExpectation = &ClientMockDeleteCacheExpectation{}
	}

	if mmDeleteCache.defaultExpectation.params != nil {
		mmDeleteCache.mock.t.Fatalf("ClientMock.DeleteCache mock is already set by Expect")
	}

	if mmDeleteCache.defaultExpectation.paramPtrs == nil {
		mmDeleteCache.defaultExpectation.paramPtrs = &ClientMockDeleteCacheParamPtrs{}
	}
	mmDeleteCache.defaultExpectation.paramPtrs.cacheName = &cacheName
	mmDeleteCache.defaultExpectation.expectationOrigins.originCacheName = minimock.CallerInfo(1)

	return mmDeleteCache
}

// Inspect accepts an inspector function that has same arguments as the Client.DeleteCache
func (mmDeleteCache *mClientMockDeleteCache) Inspect(f func(ctx context.Context, cacheName string)) *mClientMockDeleteCache {
	if mmDeleteCache.mock.inspectFuncDeleteCache != nil {
		mmDeleteCache.mock.t.Fatalf("Inspect function is already set for ClientMock.DeleteCache")
	}

	mmDeleteCache.mock.inspectFuncDeleteCache = f

	return mmDeleteCache
}

// Return sets up results that will be returned by Client.DeleteCache
func (mmDeleteCache *mClientMockDeleteCache) Return(err error) *ClientMock {
	if mmDeleteCache.mock.funcDeleteCache != nil {
		mmDeleteCache.mock.t.Fatalf("ClientMock.DeleteCache mock is already set by Set")
	}

	if mmDeleteCache.defaultExpectation == nil {
		mmDeleteCache.defaultExpectation = &ClientMockDeleteCacheExpectation{mock: mmDeleteCache.mock}
	}
	mmDeleteCache.defaultExpectation.results = &ClientMockDeleteCacheResults{err}
	mmDeleteCache.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteCache.mock
}

// Set uses given function f to mock the Client.DeleteCache method
func (mmDeleteCache *mClientMockDeleteCache) Set(f func(ctx context.Context, cacheName string) (err error)) *ClientMock {
	if mmDeleteCache.defaultExpectation != nil {
		mmDeleteCache.mock.t.Fatalf("Default expectation is already set for the Client.DeleteCache method")
	}

	if len(mmDeleteCache.expectations) > 0 {
		mmDeleteCache.mock.t.Fatalf("Some expectations are already set for the Client.DeleteCache method")
	}

	mmDeleteCache.mock.funcDeleteCache = f
	mmDeleteCache.mock.funcDeleteCacheOrigin = minimock.CallerInfo(1)
	return mmDeleteCache.mock
}

// When sets expectation for the Client.DeleteCache which will trigger the result defined by the following
// Then helper
func (mmDeleteCache *mClientMockDeleteCache) When(ctx context.Context, cacheName string) *ClientMockDeleteCacheExpectation {
	if mmDeleteCache.mock.funcDeleteCache != nil {
		mmDeleteCache.mock.t.Fatalf("ClientMock.DeleteCache mock is already set by Set")
	}

	expectation := &ClientMockDeleteCacheExpectation{
		mock:               mmDeleteCache.mock,
		params:             &ClientMockDeleteCacheParams{ctx, cacheName},
		expectationOrigins: ClientMockDeleteCacheExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteCache.expectations = append(mmDeleteCache.expectations, expectation)
	return expectation
}

// Then sets up Client.DeleteCache return parameters for the expectation previously defined by the When method
func (e *ClientMockDeleteCacheExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockDeleteCacheResults{err}
	return e.mock
}

// Times sets number of times Client.DeleteCache should be invoked
func (mmDeleteCache *mClientMockDeleteCache) Times(n uint64) *mClientMockDeleteCache {
	if n == 0 {
		mmDeleteCache.mock.t.Fatalf("Times of ClientMock.DeleteCache mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteCache.expectedInvocations, n)
	mmDeleteCache.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteCache
}

func (mmDeleteCache *mClientMockDeleteCache) invocationsDone() bool {
	if len(mmDeleteCache.expectations) == 0 && mmDeleteCache.defaultExpectation == nil && mmDeleteCache.mock.funcDeleteCache == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteCache.mock.afterDeleteCacheCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteCache.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteCache implements mm_ai.Client
func (mmDeleteCache *ClientMock) DeleteCache(ctx context.Context, cacheName string) (err error) {
	mm_atomic.AddUint64(&mmDeleteCache.beforeDeleteCacheCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteCache.afterDeleteCacheCounter, 1)

	mmDeleteCache.t.Helper()

	if mmDeleteCache.inspectFuncDeleteCache != nil {
		mmDeleteCache.inspectFuncDeleteCache(ctx, cacheName)
	}

	mm_params := ClientMockDeleteCacheParams{ctx, cacheName}

	// Record call args
	mmDeleteCache.DeleteCacheMock.mutex.Lock()
	mmDeleteCache.DeleteCacheMock.callArgs = append(mmDeleteCache.DeleteCacheMock.callArgs, &mm_params)
	mmDeleteCache.DeleteCacheMock.mutex.Unlock()

	for _, e := range mmDeleteCache.DeleteCacheMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteCache.DeleteCacheMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteCache.DeleteCacheMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteCache.DeleteCacheMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteCache.DeleteCacheMock.defaultExpectation.paramPtrs

		mm_got := ClientMockDeleteCacheParams{ctx, cacheName}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteCache.t.Errorf("ClientMock.DeleteCache got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCache.DeleteCacheMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cacheName != nil && !minimock.Equal(*mm_want_ptrs.cacheName, mm_got.cacheName) {
				mmDeleteCache.t.Errorf("ClientMock.DeleteCache got unexpected parameter cacheName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCache.DeleteCacheMock.defaultExpectation.expectationOrigins.originCacheName, *mm_want_ptrs.cacheName, mm_got.cacheName, minimock.Diff(*mm_want_ptrs.cacheName, mm_got.cacheName))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteCache.t.Errorf("ClientMock.DeleteCache got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteCache.DeleteCacheMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteCache.DeleteCacheMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteCache.t.Fatal("No results are set for the ClientMock.DeleteCache")
		}
		return (*mm_results).err
	}
	if mmDeleteCache.funcDeleteCache != nil {
		return mmDeleteCache.funcDeleteCache(ctx, cacheName)
	}
	mmDeleteCache.t.Fatalf("Unexpected call to ClientMock.DeleteCache. %v %v", ctx, cacheName)
	return
}

// DeleteCacheAfterCounter returns a count of finished ClientMock.DeleteCache invocations
func (mmDeleteCache *ClientMock) DeleteCacheAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCache.afterDeleteCacheCounter)
}

// DeleteCacheBeforeCounter returns a count of ClientMock.DeleteCache invocations
func (mmDeleteCache *ClientMock) DeleteCacheBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCache.beforeDeleteCacheCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.DeleteCache.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteCache *mClientMockDeleteCache) Calls() []*ClientMockDeleteCacheParams {
	mmDeleteCache.mutex.RLock()

	argCopy := make([]*ClientMockDeleteCacheParams, len(mmDeleteCache.callArgs))
	copy(argCopy, mmDeleteCache.callArgs)

	mmDeleteCache.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCacheDone returns true if the count of the DeleteCache invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDeleteCacheDone() bool {
	if m.DeleteCacheMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteCacheMock.invocationsDone()
}

// MinimockDeleteCacheInspect logs each unmet expectation
func (m *ClientMock) MinimockDeleteCacheInspect() {
	for _, e := range m.DeleteCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.DeleteCache at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCacheCounter := mm_atomic.LoadUint64(&m.afterDeleteCacheCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCacheMock.defaultExpectation != nil && afterDeleteCacheCounter < 1 {
		if m.DeleteCacheMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.DeleteCache at\n%s", m.DeleteCacheMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.DeleteCache at\n%s with params: %#v", m.DeleteCacheMock.defaultExpectation.expectationOrigins.origin, *m.DeleteCacheMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCache != nil && afterDeleteCacheCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.DeleteCache at\n%s", m.funcDeleteCacheOrigin)
	}

	if !m.DeleteCacheMock.invocationsDone() && afterDeleteCacheCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.DeleteCache at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteCacheMock.expectedInvocations), m.DeleteCacheMock.expectedInvocationsOrigin, afterDeleteCacheCounter)
	}
}

type mClientMockEmbedTexts struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockEmbedTextsExpectation
	expectations       []*ClientMockEmbedTextsExpectation

	callArgs []*ClientMockEmbedTextsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockEmbedTextsExpectation specifies expectation struct of the Client.EmbedTexts
type ClientMockEmbedTextsExpectation struct {
	mock               *ClientMock
	params             *ClientMockEmbedTextsParams
	paramPtrs          *ClientMockEmbedTextsParamPtrs
	expectationOrigins ClientMockEmbedTextsExpectationOrigins
	results            *ClientMockEmbedTextsResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockEmbedTextsParams contains parameters of the Client.EmbedTexts
type ClientMockEmbedTextsParams struct {
	ctx            context.Context
	texts          []string
	taskType       string
	dimensionality int32
}

// ClientMockEmbedTextsParamPtrs contains pointers to parameters of the Client.EmbedTexts
type ClientMockEmbedTextsParamPtrs struct {
	ctx            *context.Context
	texts          *[]string
	taskType       *string
	dimensionality *int32
}

// ClientMockEmbedTextsResults contains results of the Client.EmbedTexts
type ClientMockEmbedTextsResults struct {
	ep1 *mm_ai.EmbedResult
	err error
}

// ClientMockEmbedTextsOrigins contains origins of expectations of the Client.EmbedTexts
type ClientMockEmbedTextsExpectationOrigins struct {
	origin               string
	originCtx            string
	originTexts          string
	originTaskType       string
	originDimensionality string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmEmbedTexts *mClientMockEmbedTexts) Optional() *mClientMockEmbedTexts {
	mmEmbedTexts.optional = true
	return mmEmbedTexts
}

// Expect sets up expected params for Client.EmbedTexts
func (mmEmbedTexts *mClientMockEmbedTexts) Expect(ctx context.Context, texts []string, taskType string, dimensionality int32) *mClientMockEmbedTexts {
	if mmEmbedTexts.mock.funcEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("ClientMock.EmbedTexts mock is already set by Set")
	}

	if mmEmbedTexts.defaultExpectation == nil {
		mmEmbedTexts.defaultExpectation = &ClientMockEmbedTextsExpectation{}
	}

	if mmEmbedTexts.defaultExpectation.paramPtrs != nil {
		mmEmbedTexts.mock.t.Fatalf("ClientMock.EmbedTexts mock is already set by ExpectParams functions")
	}

	mmEmbedTexts.defaultExpectation.params = &ClientMockEmbedTextsParams{ctx, texts, taskType, dimensionality}
	mmEmbedTexts.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmEmbedTexts.expectations {
		if minimock.Equal(e.params, mmEmbedTexts.defaultExpectation.params) {
			mmEmbedTexts.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEmbedTexts.defaultExpectation.params)
		}
	}

	return mmEmbedTexts
}

// ExpectCtxParam1 sets up expected param ctx for Client.EmbedTexts
func (mmEmbedTexts *mClientMockEmbedTexts) ExpectCtxParam1(ctx context.Context) *mClientMockEmbedTexts {
	if mmEmbedTexts.mock.funcEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("ClientMock.EmbedTexts mock is already set by Set")
	}

	if mmEmbedTexts.defaultExpectation == nil {
		mmEmbedTexts.defaultExpectation = &ClientMockEmbedTextsExpectation{}
	}

	if mmEmbedTexts.defaultExpectation.params != nil {
		mmEmbedTexts.mock.t.Fatalf("ClientMock.EmbedTexts mock is already set by Expect")
	}

	if mmEmbedTexts.defaultExpectation.paramPtrs == nil {
		mmEmbedTexts.defaultExpectation.paramPtrs = &ClientMockEmbedTextsParamPtrs{}
	}
	mmEmbedTexts.defaultExpectation.paramPtrs.ctx = &ctx
	mmEmbedTexts.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmEmbedTexts
}

// ExpectTextsParam2 sets up expected param texts for Client.EmbedTexts
func (mmEmbedTexts *mClientMockEmbedTexts) ExpectTextsParam2(texts []string) *mClientMockEmbedTexts {
	if mmEmbedTexts.mock.funcEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("ClientMock.EmbedTexts mock is already set by Set")
	}

	if mmEmbedTexts.defaultExpectation == nil {
		mmEmbedTexts.defaultExpectation = &ClientMockEmbedTextsExpectation{}
	}

	if mmEmbedTexts.defaultExpectation.params != nil {
		mmEmbedTexts.mock.t.Fatalf("ClientMock.EmbedTexts mock is already set by Expect")
	}

	if mmEmbedTexts.defaultExpectation.paramPtrs == nil {
		mmEmbedTexts.defaultExpectation.paramPtrs = &ClientMockEmbedTextsParamPtrs{}
	}
	mmEmbedTexts.defaultExpectation.paramPtrs.texts = &texts
	mmEmbedTexts.defaultExpectation.expectationOrigins.originTexts = minimock.CallerInfo(1)

	return mmEmbedTexts
}

// ExpectTaskTypeParam3 sets up expected param taskType for Client.EmbedTexts
func (mmEmbedTexts *mClientMockEmbedTexts) ExpectTaskTypeParam3(taskType string) *mClientMockEmbedTexts {
	if mmEmbedTexts.mock.funcEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("ClientMock.EmbedTexts mock is already set by Set")
	}

	if mmEmbedTexts.defaultExpectation == nil {
		mmEmbedTexts.defaultExpectation = &ClientMockEmbedTextsExpectation{}
	}

	if mmEmbedTexts.defaultExpectation.params != nil {
		mmEmbedTexts.mock.t.Fatalf("ClientMock.EmbedTexts mock is already set by Expect")
	}

	if mmEmbedTexts.defaultExpectation.paramPtrs == nil {
		mmEmbedTexts.defaultExpectation.paramPtrs = &ClientMockEmbedTextsParamPtrs{}
	}
	mmEmbedTexts.defaultExpectation.paramPtrs.taskType = &taskType
	mmEmbedTexts.defaultExpectation.expectationOrigins.originTaskType = minimock.CallerInfo(1)

	return mmEmbedTexts
}

// ExpectDimensionalityParam4 sets up expected param dimensionality for Client.EmbedTexts
func (mmEmbedTexts *mClientMockEmbedTexts) ExpectDimensionalityParam4(dimensionality int32) *mClientMockEmbedTexts {
	if mmEmbedTexts.mock.funcEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("ClientMock.EmbedTexts mock is already set by Set")
	}

	if mmEmbedTexts.defaultExpectation == nil {
		mmEmbedTexts.defaultExpectation = &ClientMockEmbedTextsExpectation{}
	}

	if mmEmbedTexts.defaultExpectation.params != nil {
		mmEmbedTexts.mock.t.Fatalf("ClientMock.EmbedTexts mock is already set by Expect")
	}

	if mmEmbedTexts.defaultExpectation.paramPtrs == nil {
		mmEmbedTexts.defaultExpectation.paramPtrs = &ClientMockEmbedTextsParamPtrs{}
	}
	mmEmbedTexts.defaultExpectation.paramPtrs.dimensionality = &dimensionality
	mmEmbedTexts.defaultExpectation.expectationOrigins.originDimensionality = minimock.CallerInfo(1)

	return mmEmbedTexts
}

// Inspect accepts an inspector function that has same arguments as the Client.EmbedTexts
func (mmEmbedTexts *mClientMockEmbedTexts) Inspect(f func(ctx context.Context, texts []string, taskType string, dimensionality int32)) *mClientMockEmbedTexts {
	if mmEmbedTexts.mock.inspectFuncEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("Inspect function is already set for ClientMock.EmbedTexts")
	}

	mmEmbedTexts.mock.inspectFuncEmbedTexts = f

	return mmEmbedTexts
}

// Return sets up results that will be returned by Client.EmbedTexts
func (mmEmbedTexts *mClientMockEmbedTexts) Return(ep1 *mm_ai.EmbedResult, err error) *ClientMock {
	if mmEmbedTexts.mock.funcEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("ClientMock.EmbedTexts mock is already set by Set")
	}

	if mmEmbedTexts.defaultExpectation == nil {
		mmEmbedTexts.defaultExpectation = &ClientMockEmbedTextsExpectation{mock: mmEmbedTexts.mock}
	}
	mmEmbedTexts.defaultExpectation.results = &ClientMockEmbedTextsResults{ep1, err}
	mmEmbedTexts.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmEmbedTexts.mock
}

// Set uses given function f to mock the Client.EmbedTexts method
func (mmEmbedTexts *mClientMockEmbedTexts) Set(f func(ctx context.Context, texts []string, taskType string, dimensionality int32) (ep1 *mm_ai.EmbedResult, err error)) *ClientMock {
	if mmEmbedTexts.defaultExpectation != nil {
		mmEmbedTexts.mock.t.Fatalf("Default expectation is already set for the Client.EmbedTexts method")
	}

	if len(mmEmbedTexts.expectations) > 0 {
		mmEmbedTexts.mock.t.Fatalf("Some expectations are already set for the Client.EmbedTexts method")
	}

	mmEmbedTexts.mock.funcEmbedTexts = f
	mmEmbedTexts.mock.funcEmbedTextsOrigin = minimock.CallerInfo(1)
	return mmEmbedTexts.mock
}

// When sets expectation for the Client.EmbedTexts which will trigger the result defined by the following
// Then helper
func (mmEmbedTexts *mClientMockEmbedTexts) When(ctx context.Context, texts []string, taskType string, dimensionality int32) *ClientMockEmbedTextsExpectation {
	if mmEmbedTexts.mock.funcEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("ClientMock.EmbedTexts mock is already set by Set")
	}

	expectation := &ClientMockEmbedTextsExpectation{
		mock:               mmEmbedTexts.mock,
		params:             &ClientMockEmbedTextsParams{ctx, texts, taskType, dimensionality},
		expectationOrigins: ClientMockEmbedTextsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmEmbedTexts.expectations = append(mmEmbedTexts.expectations, expectation)
	return expectation
}

// Then sets up Client.EmbedTexts return parameters for the expectation previously defined by the When method
func (e *ClientMockEmbedTextsExpectation) Then(ep1 *mm_ai.EmbedResult, err error) *ClientMock {
	e.results = &ClientMockEmbedTextsResults{ep1, err}
	return e.mock
}

// Times sets number of times Client.EmbedTexts should be invoked
func (mmEmbedTexts *mClientMockEmbedTexts) Times(n uint64) *mClientMockEmbedTexts {
	if n == 0 {
		mmEmbedTexts.mock.t.Fatalf("Times of ClientMock.EmbedTexts mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmEmbedTexts.expectedInvocations, n)
	mmEmbedTexts.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmEmbedTexts
}

func (mmEmbedTexts *mClientMockEmbedTexts) invocationsDone() bool {
	if len(mmEmbedTexts.expectations) == 0 && mmEmbedTexts.defaultExpectation == nil && mmEmbedTexts.mock.funcEmbedTexts == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmEmbedTexts.mock.afterEmbedTextsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmEmbedTexts.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// EmbedTexts implements mm_ai.Client
func (mmEmbedTexts *ClientMock) EmbedTexts(ctx context.Context, texts []string, taskType string, dimensionality int32) (ep1 *mm_ai.EmbedResult, err error) {
	mm_atomic.AddUint64(&mmEmbedTexts.beforeEmbedTextsCounter, 1)
	defer mm_atomic.AddUint64(&mmEmbedTexts.afterEmbedTextsCounter, 1)

	mmEmbedTexts.t.Helper()

	if mmEmbedTexts.inspectFuncEmbedTexts != nil {
		mmEmbedTexts.inspectFuncEmbedTexts(ctx, texts, taskType, dimensionality)
	}

	mm_params := ClientMockEmbedTextsParams{ctx, texts, taskType, dimensionality}

	// Record call args
	mmEmbedTexts.EmbedTextsMock.mutex.Lock()
	mmEmbedTexts.EmbedTextsMock.callArgs = append(mmEmbedTexts.EmbedTextsMock.callArgs, &mm_params)
	mmEmbedTexts.EmbedTextsMock.mutex.Unlock()

	for _, e := range mmEmbedTexts.EmbedTextsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ep1, e.results.err
		}
	}

	if mmEmbedTexts.EmbedTextsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEmbedTexts.EmbedTextsMock.defaultExpectation.Counter, 1)
		mm_want := mmEmbedTexts.EmbedTextsMock.defaultExpectation.params
		mm_want_ptrs := mmEmbedTexts.EmbedTextsMock.defaultExpectation.paramPtrs

		mm_got := ClientMockEmbedTextsParams{ctx, texts, taskType, dimensionality}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmEmbedTexts.t.Errorf("ClientMock.EmbedTexts got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEmbedTexts.EmbedTextsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.texts != nil && !minimock.Equal(*mm_want_ptrs.texts, mm_got.texts) {
				mmEmbedTexts.t.Errorf("ClientMock.EmbedTexts got unexpected parameter texts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEmbedTexts.EmbedTextsMock.defaultExpectation.expectationOrigins.originTexts, *mm_want_ptrs.texts, mm_got.texts, minimock.Diff(*mm_want_ptrs.texts, mm_got.texts))
			}

			if mm_want_ptrs.taskType != nil && !minimock.Equal(*mm_want_ptrs.taskType, mm_got.taskType) {
				mmEmbedTexts.t.Errorf("ClientMock.EmbedTexts got unexpected parameter taskType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEmbedTexts.EmbedTextsMock.defaultExpectation.expectationOrigins.originTaskType, *mm_want_ptrs.taskType, mm_got.taskType, minimock.Diff(*mm_want_ptrs.taskType, mm_got.taskType))
			}

			if mm_want_ptrs.dimensionality != nil && !minimock.Equal(*mm_want_ptrs.dimensionality, mm_got.dimensionality) {
				mmEmbedTexts.t.Errorf("ClientMock.EmbedTexts got unexpected parameter dimensionality, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEmbedTexts.EmbedTextsMock.defaultExpectation.expectationOrigins.originDimensionality, *mm_want_ptrs.dimensionality, mm_got.dimensionality, minimock.Diff(*mm_want_ptrs.dimensionality, mm_got.dimensionality))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEmbedTexts.t.Errorf("ClientMock.EmbedTexts got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmEmbedTexts.EmbedTextsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEmbedTexts.EmbedTextsMock.defaultExpectation.results
		if mm_results == nil {
			mmEmbedTexts.t.Fatal("No results are set for the ClientMock.EmbedTexts")
		}
		return (*mm_results).ep1, (*mm_results).err
	}
	if mmEmbedTexts.funcEmbedTexts != nil {
		return mmEmbedTexts.funcEmbedTexts(ctx, texts, taskType, dimensionality)
	}
	mmEmbedTexts.t.Fatalf("Unexpected call to ClientMock.EmbedTexts. %v %v %v %v", ctx, texts, taskType, dimensionality)
	return
}

// EmbedTextsAfterCounter returns a count of finished ClientMock.EmbedTexts invocations
func (mmEmbedTexts *ClientMock) EmbedTextsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEmbedTexts.afterEmbedTextsCounter)
}

// EmbedTextsBeforeCounter returns a count of ClientMock.EmbedTexts invocations
func (mmEmbedTexts *ClientMock) EmbedTextsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEmbedTexts.beforeEmbedTextsCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.EmbedTexts.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEmbedTexts *mClientMockEmbedTexts) Calls() []*ClientMockEmbedTextsParams {
	mmEmbedTexts.mutex.RLock()

	argCopy := make([]*ClientMockEmbedTextsParams, len(mmEmbedTexts.callArgs))
	copy(argCopy, mmEmbedTexts.callArgs)

	mmEmbedTexts.mutex.RUnlock()

	return argCopy
}

// MinimockEmbedTextsDone returns true if the count of the EmbedTexts invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockEmbedTextsDone() bool {
	if m.EmbedTextsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.EmbedTextsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.EmbedTextsMock.invocationsDone()
}

// MinimockEmbedTextsInspect logs each unmet expectation
func (m *ClientMock) MinimockEmbedTextsInspect() {
	for _, e := range m.EmbedTextsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.EmbedTexts at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterEmbedTextsCounter := mm_atomic.LoadUint64(&m.afterEmbedTextsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.EmbedTextsMock.defaultExpectation != nil && afterEmbedTextsCounter < 1 {
		if m.EmbedTextsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.EmbedTexts at\n%s", m.EmbedTextsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.EmbedTexts at\n%s with params: %#v", m.EmbedTextsMock.defaultExpectation.expectationOrigins.origin, *m.EmbedTextsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEmbedTexts != nil && afterEmbedTextsCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.EmbedTexts at\n%s", m.funcEmbedTextsOrigin)
	}

	if !m.EmbedTextsMock.invocationsDone() && afterEmbedTextsCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.EmbedTexts at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.EmbedTextsMock.expectedInvocations), m.EmbedTextsMock.expectedInvocationsOrigin, afterEmbedTextsCounter)
	}
}

type mClientMockGetCache struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetCacheExpectation
	expectations       []*ClientMockGetCacheExpectation

	callArgs []*ClientMockGetCacheParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockGetCacheExpectation specifies expectation struct of the Client.GetCache
type ClientMockGetCacheExpectation struct {
	mock               *ClientMock
	params             *ClientMockGetCacheParams
	paramPtrs          *ClientMockGetCacheParamPtrs
	expectationOrigins ClientMockGetCacheExpectationOrigins
	results            *ClientMockGetCacheResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockGetCacheParams contains parameters of the Client.GetCache
type ClientMockGetCacheParams struct {
	ctx       context.Context
	cacheName string
}

// ClientMockGetCacheParamPtrs contains pointers to parameters of the Client.GetCache
type ClientMockGetCacheParamPtrs struct {
	ctx       *context.Context
	cacheName *string
}

// ClientMockGetCacheResults contains results of the Client.GetCache
type ClientMockGetCacheResults struct {
	cp1 *mm_ai.CacheResult
	err error
}

// ClientMockGetCacheOrigins contains origins of expectations of the Client.GetCache
type ClientMockGetCacheExpectationOrigins struct {
	origin          string
	originCtx       string
	originCacheName string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCache *mClientMockGetCache) Optional() *mClientMockGetCache {
	mmGetCache.optional = true
	return mmGetCache
}

// Expect sets up expected params for Client.GetCache
func (mmGetCache *mClientMockGetCache) Expect(ctx context.Context, cacheName string) *mClientMockGetCache {
	if mmGetCache.mock.funcGetCache != nil {
		mmGetCache.mock.t.Fatalf("ClientMock.GetCache mock is already set by Set")
	}

	if mmGetCache.defaultExpectation == nil {
		mmGetCache.defaultExpectation = &ClientMockGetCacheExpectation{}
	}

	if mmGetCache.defaultExpectation.paramPtrs != nil {
		mmGetCache.mock.t.Fatalf("ClientMock.GetCache mock is already set by ExpectParams functions")
	}

	mmGetCache.defaultExpectation.params = &ClientMockGetCacheParams{ctx, cacheName}
	mmGetCache.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCache.expectations {
		if minimock.Equal(e.params, mmGetCache.defaultExpectation.params) {
			mmGetCache.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCache.defaultExpectation.params)
		}
	}

	return mmGetCache
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetCache
func (mmGetCache *mClientMockGetCache) ExpectCtxParam1(ctx context.Context) *mClientMockGetCache {
	if mmGetCache.mock.funcGetCache != nil {
		mmGetCache.mock.t.Fatalf("ClientMock.GetCache mock is already set by Set")
	}

	if mmGetCache.defaultExpectation == nil {
		mmGetCache.defaultExpectation = &ClientMockGetCacheExpectation{}
	}

	if mmGetCache.defaultExpectation.params != nil {
		mmGetCache.mock.t.Fatalf("ClientMock.GetCache mock is already set by Expect")
	}

	if mmGetCache.defaultExpectation.paramPtrs == nil {
		mmGetCache.defaultExpectation.paramPtrs = &ClientMockGetCacheParamPtrs{}
	}
	mmGetCache.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetCache.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetCache
}

// ExpectCacheNameParam2 sets up expected param cacheName for Client.GetCache
func (mmGetCache *mClientMockGetCache) ExpectCacheNameParam2(cacheName string) *mClientMockGetCache {
	if mmGetCache.mock.funcGetCache != nil {
		mmGetCache.mock.t.Fatalf("ClientMock.GetCache mock is already set by Set")
	}

	if mmGetCache.defaultExpectation == nil {
		mmGetCache.defaultExpectation = &ClientMockGetCacheExpectation{}
	}

	if mmGetCache.defaultExpectation.params != nil {
		mmGetCache.mock.t.Fatalf("ClientMock.GetCache mock is already set by Expect")
	}

	if mmGetCache.defaultExpectation.paramPtrs == nil {
		mmGetCache.defaultExpectation.paramPtrs = &ClientMockGetCacheParamPtrs{}
	}
	mmGetCache.defaultExpectation.paramPtrs.cacheName = &cacheName
	mmGetCache.defaultExpectation.expectationOrigins.originCacheName = minimock.CallerInfo(1)

	return mmGetCache
}

// Inspect accepts an inspector function that has same arguments as the Client.GetCache
func (mmGetCache *mClientMockGetCache) Inspect(f func(ctx context.Context, cacheName string)) *mClientMockGetCache {
	if mmGetCache.mock.inspectFuncGetCache != nil {
		mmGetCache.mock.t.Fatalf("Inspect function is already set for ClientMock.GetCache")
	}

	mmGetCache.mock.inspectFuncGetCache = f

	return mmGetCache
}

// Return sets up results that will be returned by Client.GetCache
func (mmGetCache *mClientMockGetCache) Return(cp1 *mm_ai.CacheResult, err error) *ClientMock {
	if mmGetCache.mock.funcGetCache != nil {
		mmGetCache.mock.t.Fatalf("ClientMock.GetCache mock is already set by Set")
	}

	if mmGetCache.defaultExpectation == nil {
		mmGetCache.defaultExpectation = &ClientMockGetCacheExpectation{mock: mmGetCache.mock}
	}
	mmGetCache.defaultExpectation.results = &ClientMockGetCacheResults{cp1, err}
	mmGetCache.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCache.mock
}

// Set uses given function f to mock the Client.GetCache method
func (mmGetCache *mClientMockGetCache) Set(f func(ctx context.Context, cacheName string) (cp1 *mm_ai.CacheResult, err error)) *ClientMock {
	if mmGetCache.defaultExpectation != nil {
		mmGetCache.mock.t.Fatalf("Default expectation is already set for the Client.GetCache method")
	}

	if len(mmGetCache.expectations) > 0 {
		mmGetCache.mock.t.Fatalf("Some expectations are already set for the Client.GetCache method")
	}

	mmGetCache.mock.funcGetCache = f
	mmGetCache.mock.funcGetCacheOrigin = minimock.CallerInfo(1)
	return mmGetCache.mock
}

// When sets expectation for the Client.GetCache which will trigger the result defined by the following
// Then helper
func (mmGetCache *mClientMockGetCache) When(ctx context.Context, cacheName string) *ClientMockGetCacheExpectation {
	if mmGetCache.mock.funcGetCache != nil {
		mmGetCache.mock.t.Fatalf("ClientMock.GetCache mock is already set by Set")
	}

	expectation := &ClientMockGetCacheExpectation{
		mock:               mmGetCache.mock,
		params:             &ClientMockGetCacheParams{ctx, cacheName},
		expectationOrigins: ClientMockGetCacheExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCache.expectations = append(mmGetCache.expectations, expectation)
	return expectation
}

// Then sets up Client.GetCache return parameters for the expectation previously defined by the When method
func (e *ClientMockGetCacheExpectation) Then(cp1 *mm_ai.CacheResult, err error) *ClientMock {
	e.results = &ClientMockGetCacheResults{cp1, err}
	return e.mock
}

// Times sets number of times Client.GetCache should be invoked
func (mmGetCache *mClientMockGetCache) Times(n uint64) *mClientMockGetCache {
	if n == 0 {
		mmGetCache.mock.t.Fatalf("Times of ClientMock.GetCache mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCache.expectedInvocations, n)
	mmGetCache.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCache
}

func (mmGetCache *mClientMockGetCache) invocationsDone() bool {
	if len(mmGetCache.expectations) == 0 && mmGetCache.defaultExpectation == nil && mmGetCache.mock.funcGetCache == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCache.mock.afterGetCacheCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCache.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCache implements mm_ai.Client
func (mmGetCache *ClientMock) GetCache(ctx context.Context, cacheName string) (cp1 *mm_ai.CacheResult, err error) {
	mm_atomic.AddUint64(&mmGetCache.beforeGetCacheCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCache.afterGetCacheCounter, 1)

	mmGetCache.t.Helper()

	if mmGetCache.inspectFuncGetCache != nil {
		mmGetCache.inspectFuncGetCache(ctx, cacheName)
	}

	mm_params := ClientMockGetCacheParams{ctx, cacheName}

	// Record call args
	mmGetCache.GetCacheMock.mutex.Lock()
	mmGetCache.GetCacheMock.callArgs = append(mmGetCache.GetCacheMock.callArgs, &mm_params)
	mmGetCache.GetCacheMock.mutex.Unlock()

	for _, e := range mmGetCache.GetCacheMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetCache.GetCacheMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCache.GetCacheMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCache.GetCacheMock.defaultExpectation.params
		mm_want_ptrs := mmGetCache.GetCacheMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetCacheParams{ctx, cacheName}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCache.t.Errorf("ClientMock.GetCache got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCache.GetCacheMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cacheName != nil && !minimock.Equal(*mm_want_ptrs.cacheName, mm_got.cacheName) {
				mmGetCache.t.Errorf("ClientMock.GetCache got unexpected parameter cacheName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCache.GetCacheMock.defaultExpectation.expectationOrigins.originCacheName, *mm_want_ptrs.cacheName, mm_got.cacheName, minimock.Diff(*mm_want_ptrs.cacheName, mm_got.cacheName))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCache.t.Errorf("ClientMock.GetCache got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCache.GetCacheMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCache.GetCacheMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCache.t.Fatal("No results are set for the ClientMock.GetCache")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetCache.funcGetCache != nil {
		return mmGetCache.funcGetCache(ctx, cacheName)
	}
	mmGetCache.t.Fatalf("Unexpected call to ClientMock.GetCache. %v %v", ctx, cacheName)
	return
}

// GetCacheAfterCounter returns a count of finished ClientMock.GetCache invocations
func (mmGetCache *ClientMock) GetCacheAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCache.afterGetCacheCounter)
}

// GetCacheBeforeCounter returns a count of ClientMock.GetCache invocations
func (mmGetCache *ClientMock) GetCacheBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCache.beforeGetCacheCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetCache.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCache *mClientMockGetCache) Calls() []*ClientMockGetCacheParams {
	mmGetCache.mutex.RLock()

	argCopy := make([]*ClientMockGetCacheParams, len(mmGetCache.callArgs))
	copy(argCopy, mmGetCache.callArgs)

	mmGetCache.mutex.RUnlock()

	return argCopy
}

// MinimockGetCacheDone returns true if the count of the GetCache invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetCacheDone() bool {
	if m.GetCacheMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCacheMock.invocationsDone()
}

// MinimockGetCacheInspect logs each unmet expectation
func (m *ClientMock) MinimockGetCacheInspect() {
	for _, e := range m.GetCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetCache at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCacheCounter := mm_atomic.LoadUint64(&m.afterGetCacheCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCacheMock.defaultExpectation != nil && afterGetCacheCounter < 1 {
		if m.GetCacheMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.GetCache at\n%s", m.GetCacheMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.GetCache at\n%s with params: %#v", m.GetCacheMock.defaultExpectation.expectationOrigins.origin, *m.GetCacheMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCache != nil && afterGetCacheCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.GetCache at\n%s", m.funcGetCacheOrigin)
	}

	if !m.GetCacheMock.invocationsDone() && afterGetCacheCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetCache at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCacheMock.expectedInvocations), m.GetCacheMock.expectedInvocationsOrigin, afterGetCacheCounter)
	}
}

type mClientMockGetEmbeddingDimensionality struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetEmbeddingDimensionalityExpectation
	expectations       []*ClientMockGetEmbeddingDimensionalityExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockGetEmbeddingDimensionalityExpectation specifies expectation struct of the Client.GetEmbeddingDimensionality
type ClientMockGetEmbeddingDimensionalityExpectation struct {
	mock *ClientMock

	results      *ClientMockGetEmbeddingDimensionalityResults
	returnOrigin string
	Counter      uint64
}

// ClientMockGetEmbeddingDimensionalityResults contains results of the Client.GetEmbeddingDimensionality
type ClientMockGetEmbeddingDimensionalityResults struct {
	i1 int32
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetEmbeddingDimensionality *mClientMockGetEmbeddingDimensionality) Optional() *mClientMockGetEmbeddingDimensionality {
	mmGetEmbeddingDimensionality.optional = true
	return mmGetEmbeddingDimensionality
}

// Expect sets up expected params for Client.GetEmbeddingDimensionality
func (mmGetEmbeddingDimensionality *mClientMockGetEmbeddingDimensionality) Expect() *mClientMockGetEmbeddingDimensionality {
	if mmGetEmbeddingDimensionality.mock.funcGetEmbeddingDimensionality != nil {
		mmGetEmbeddingDimensionality.mock.t.Fatalf("ClientMock.GetEmbeddingDimensionality mock is already set by Set")
	}

	if mmGetEmbeddingDimensionality.defaultExpectation == nil {
		mmGetEmbeddingDimensionality.defaultExpectation = &ClientMockGetEmbeddingDimensionalityExpectation{}
	}

	return mmGetEmbeddingDimensionality
}

// Inspect accepts an inspector function that has same arguments as the Client.GetEmbeddingDimensionality
func (mmGetEmbeddingDimensionality *mClientMockGetEmbeddingDimensionality) Inspect(f func()) *mClientMockGetEmbeddingDimensionality {
	if mmGetEmbeddingDimensionality.mock.inspectFuncGetEmbeddingDimensionality != nil {
		mmGetEmbeddingDimensionality.mock.t.Fatalf("Inspect function is already set for ClientMock.GetEmbeddingDimensionality")
	}

	mmGetEmbeddingDimensionality.mock.inspectFuncGetEmbeddingDimensionality = f

	return mmGetEmbeddingDimensionality
}

// Return sets up results that will be returned by Client.GetEmbeddingDimensionality
func (mmGetEmbeddingDimensionality *mClientMockGetEmbeddingDimensionality) Return(i1 int32) *ClientMock {
	if mmGetEmbeddingDimensionality.mock.funcGetEmbeddingDimensionality != nil {
		mmGetEmbeddingDimensionality.mock.t.Fatalf("ClientMock.GetEmbeddingDimensionality mock is already set by Set")
	}

	if mmGetEmbeddingDimensionality.defaultExpectation == nil {
		mmGetEmbeddingDimensionality.defaultExpectation = &ClientMockGetEmbeddingDimensionalityExpectation{mock: mmGetEmbeddingDimensionality.mock}
	}
	mmGetEmbeddingDimensionality.defaultExpectation.results = &ClientMockGetEmbeddingDimensionalityResults{i1}
	mmGetEmbeddingDimensionality.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetEmbeddingDimensionality.mock
}

// Set uses given function f to mock the Client.GetEmbeddingDimensionality method
func (mmGetEmbeddingDimensionality *mClientMockGetEmbeddingDimensionality) Set(f func() (i1 int32)) *ClientMock {
	if mmGetEmbeddingDimensionality.defaultExpectation != nil {
		mmGetEmbeddingDimensionality.mock.t.Fatalf("Default expectation is already set for the Client.GetEmbeddingDimensionality method")
	}

	if len(mmGetEmbeddingDimensionality.expectations) > 0 {
		mmGetEmbeddingDimensionality.mock.t.Fatalf("Some expectations are already set for the Client.GetEmbeddingDimensionality method")
	}

	mmGetEmbeddingDimensionality.mock.funcGetEmbeddingDimensionality = f
	mmGetEmbeddingDimensionality.mock.funcGetEmbeddingDimensionalityOrigin = minimock.CallerInfo(1)
	return mmGetEmbeddingDimensionality.mock
}

// Times sets number of times Client.GetEmbeddingDimensionality should be invoked
func (mmGetEmbeddingDimensionality *mClientMockGetEmbeddingDimensionality) Times(n uint64) *mClientMockGetEmbeddingDimensionality {
	if n == 0 {
		mmGetEmbeddingDimensionality.mock.t.Fatalf("Times of ClientMock.GetEmbeddingDimensionality mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetEmbeddingDimensionality.expectedInvocations, n)
	mmGetEmbeddingDimensionality.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetEmbeddingDimensionality
}

func (mmGetEmbeddingDimensionality *mClientMockGetEmbeddingDimensionality) invocationsDone() bool {
	if len(mmGetEmbeddingDimensionality.expectations) == 0 && mmGetEmbeddingDimensionality.defaultExpectation == nil && mmGetEmbeddingDimensionality.mock.funcGetEmbeddingDimensionality == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetEmbeddingDimensionality.mock.afterGetEmbeddingDimensionalityCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetEmbeddingDimensionality.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetEmbeddingDimensionality implements mm_ai.Client
func (mmGetEmbeddingDimensionality *ClientMock) GetEmbeddingDimensionality() (i1 int32) {
	mm_atomic.AddUint64(&mmGetEmbeddingDimensionality.beforeGetEmbeddingDimensionalityCounter, 1)
	defer mm_atomic.AddUint64(&mmGetEmbeddingDimensionality.afterGetEmbeddingDimensionalityCounter, 1)

	mmGetEmbeddingDimensionality.t.Helper()

	if mmGetEmbeddingDimensionality.inspectFuncGetEmbeddingDimensionality != nil {
		mmGetEmbeddingDimensionality.inspectFuncGetEmbeddingDimensionality()
	}

	if mmGetEmbeddingDimensionality.GetEmbeddingDimensionalityMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetEmbeddingDimensionality.GetEmbeddingDimensionalityMock.defaultExpectation.Counter, 1)

		mm_results := mmGetEmbeddingDimensionality.GetEmbeddingDimensionalityMock.defaultExpectation.results
		if mm_results == nil {
			mmGetEmbeddingDimensionality.t.Fatal("No results are set for the ClientMock.GetEmbeddingDimensionality")
		}
		return (*mm_results).i1
	}
	if mmGetEmbeddingDimensionality.funcGetEmbeddingDimensionality != nil {
		return mmGetEmbeddingDimensionality.funcGetEmbeddingDimensionality()
	}
	mmGetEmbeddingDimensionality.t.Fatalf("Unexpected call to ClientMock.GetEmbeddingDimensionality.")
	return
}

// GetEmbeddingDimensionalityAfterCounter returns a count of finished ClientMock.GetEmbeddingDimensionality invocations
func (mmGetEmbeddingDimensionality *ClientMock) GetEmbeddingDimensionalityAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEmbeddingDimensionality.afterGetEmbeddingDimensionalityCounter)
}

// GetEmbeddingDimensionalityBeforeCounter returns a count of ClientMock.GetEmbeddingDimensionality invocations
func (mmGetEmbeddingDimensionality *ClientMock) GetEmbeddingDimensionalityBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEmbeddingDimensionality.beforeGetEmbeddingDimensionalityCounter)
}

// MinimockGetEmbeddingDimensionalityDone returns true if the count of the GetEmbeddingDimensionality invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetEmbeddingDimensionalityDone() bool {
	if m.GetEmbeddingDimensionalityMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetEmbeddingDimensionalityMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetEmbeddingDimensionalityMock.invocationsDone()
}

// MinimockGetEmbeddingDimensionalityInspect logs each unmet expectation
func (m *ClientMock) MinimockGetEmbeddingDimensionalityInspect() {
	for _, e := range m.GetEmbeddingDimensionalityMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ClientMock.GetEmbeddingDimensionality")
		}
	}

	afterGetEmbeddingDimensionalityCounter := mm_atomic.LoadUint64(&m.afterGetEmbeddingDimensionalityCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetEmbeddingDimensionalityMock.defaultExpectation != nil && afterGetEmbeddingDimensionalityCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.GetEmbeddingDimensionality at\n%s", m.GetEmbeddingDimensionalityMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetEmbeddingDimensionality != nil && afterGetEmbeddingDimensionalityCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.GetEmbeddingDimensionality at\n%s", m.funcGetEmbeddingDimensionalityOrigin)
	}

	if !m.GetEmbeddingDimensionalityMock.invocationsDone() && afterGetEmbeddingDimensionalityCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetEmbeddingDimensionality at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetEmbeddingDimensionalityMock.expectedInvocations), m.GetEmbeddingDimensionalityMock.expectedInvocationsOrigin, afterGetEmbeddingDimensionalityCounter)
	}
}

type mClientMockGetModelFamily struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetModelFamilyExpectation
	expectations       []*ClientMockGetModelFamilyExpectation

	callArgs []*ClientMockGetModelFamilyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockGetModelFamilyExpectation specifies expectation struct of the Client.GetModelFamily
type ClientMockGetModelFamilyExpectation struct {
	mock               *ClientMock
	params             *ClientMockGetModelFamilyParams
	paramPtrs          *ClientMockGetModelFamilyParamPtrs
	expectationOrigins ClientMockGetModelFamilyExpectationOrigins
	results            *ClientMockGetModelFamilyResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockGetModelFamilyParams contains parameters of the Client.GetModelFamily
type ClientMockGetModelFamilyParams struct {
	modelFamily string
}

// ClientMockGetModelFamilyParamPtrs contains pointers to parameters of the Client.GetModelFamily
type ClientMockGetModelFamilyParamPtrs struct {
	modelFamily *string
}

// ClientMockGetModelFamilyResults contains results of the Client.GetModelFamily
type ClientMockGetModelFamilyResults struct {
	c1  mm_ai.Client
	err error
}

// ClientMockGetModelFamilyOrigins contains origins of expectations of the Client.GetModelFamily
type ClientMockGetModelFamilyExpectationOrigins struct {
	origin            string
	originModelFamily string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetModelFamily *mClientMockGetModelFamily) Optional() *mClientMockGetModelFamily {
	mmGetModelFamily.optional = true
	return mmGetModelFamily
}

// Expect sets up expected params for Client.GetModelFamily
func (mmGetModelFamily *mClientMockGetModelFamily) Expect(modelFamily string) *mClientMockGetModelFamily {
	if mmGetModelFamily.mock.funcGetModelFamily != nil {
		mmGetModelFamily.mock.t.Fatalf("ClientMock.GetModelFamily mock is already set by Set")
	}

	if mmGetModelFamily.defaultExpectation == nil {
		mmGetModelFamily.defaultExpectation = &ClientMockGetModelFamilyExpectation{}
	}

	if mmGetModelFamily.defaultExpectation.paramPtrs != nil {
		mmGetModelFamily.mock.t.Fatalf("ClientMock.GetModelFamily mock is already set by ExpectParams functions")
	}

	mmGetModelFamily.defaultExpectation.params = &ClientMockGetModelFamilyParams{modelFamily}
	mmGetModelFamily.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetModelFamily.expectations {
		if minimock.Equal(e.params, mmGetModelFamily.defaultExpectation.params) {
			mmGetModelFamily.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetModelFamily.defaultExpectation.params)
		}
	}

	return mmGetModelFamily
}

// ExpectModelFamilyParam1 sets up expected param modelFamily for Client.GetModelFamily
func (mmGetModelFamily *mClientMockGetModelFamily) ExpectModelFamilyParam1(modelFamily string) *mClientMockGetModelFamily {
	if mmGetModelFamily.mock.funcGetModelFamily != nil {
		mmGetModelFamily.mock.t.Fatalf("ClientMock.GetModelFamily mock is already set by Set")
	}

	if mmGetModelFamily.defaultExpectation == nil {
		mmGetModelFamily.defaultExpectation = &ClientMockGetModelFamilyExpectation{}
	}

	if mmGetModelFamily.defaultExpectation.params != nil {
		mmGetModelFamily.mock.t.Fatalf("ClientMock.GetModelFamily mock is already set by Expect")
	}

	if mmGetModelFamily.defaultExpectation.paramPtrs == nil {
		mmGetModelFamily.defaultExpectation.paramPtrs = &ClientMockGetModelFamilyParamPtrs{}
	}
	mmGetModelFamily.defaultExpectation.paramPtrs.modelFamily = &modelFamily
	mmGetModelFamily.defaultExpectation.expectationOrigins.originModelFamily = minimock.CallerInfo(1)

	return mmGetModelFamily
}

// Inspect accepts an inspector function that has same arguments as the Client.GetModelFamily
func (mmGetModelFamily *mClientMockGetModelFamily) Inspect(f func(modelFamily string)) *mClientMockGetModelFamily {
	if mmGetModelFamily.mock.inspectFuncGetModelFamily != nil {
		mmGetModelFamily.mock.t.Fatalf("Inspect function is already set for ClientMock.GetModelFamily")
	}

	mmGetModelFamily.mock.inspectFuncGetModelFamily = f

	return mmGetModelFamily
}

// Return sets up results that will be returned by Client.GetModelFamily
func (mmGetModelFamily *mClientMockGetModelFamily) Return(c1 mm_ai.Client, err error) *ClientMock {
	if mmGetModelFamily.mock.funcGetModelFamily != nil {
		mmGetModelFamily.mock.t.Fatalf("ClientMock.GetModelFamily mock is already set by Set")
	}

	if mmGetModelFamily.defaultExpectation == nil {
		mmGetModelFamily.defaultExpectation = &ClientMockGetModelFamilyExpectation{mock: mmGetModelFamily.mock}
	}
	mmGetModelFamily.defaultExpectation.results = &ClientMockGetModelFamilyResults{c1, err}
	mmGetModelFamily.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetModelFamily.mock
}

// Set uses given function f to mock the Client.GetModelFamily method
func (mmGetModelFamily *mClientMockGetModelFamily) Set(f func(modelFamily string) (c1 mm_ai.Client, err error)) *ClientMock {
	if mmGetModelFamily.defaultExpectation != nil {
		mmGetModelFamily.mock.t.Fatalf("Default expectation is already set for the Client.GetModelFamily method")
	}

	if len(mmGetModelFamily.expectations) > 0 {
		mmGetModelFamily.mock.t.Fatalf("Some expectations are already set for the Client.GetModelFamily method")
	}

	mmGetModelFamily.mock.funcGetModelFamily = f
	mmGetModelFamily.mock.funcGetModelFamilyOrigin = minimock.CallerInfo(1)
	return mmGetModelFamily.mock
}

// When sets expectation for the Client.GetModelFamily which will trigger the result defined by the following
// Then helper
func (mmGetModelFamily *mClientMockGetModelFamily) When(modelFamily string) *ClientMockGetModelFamilyExpectation {
	if mmGetModelFamily.mock.funcGetModelFamily != nil {
		mmGetModelFamily.mock.t.Fatalf("ClientMock.GetModelFamily mock is already set by Set")
	}

	expectation := &ClientMockGetModelFamilyExpectation{
		mock:               mmGetModelFamily.mock,
		params:             &ClientMockGetModelFamilyParams{modelFamily},
		expectationOrigins: ClientMockGetModelFamilyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetModelFamily.expectations = append(mmGetModelFamily.expectations, expectation)
	return expectation
}

// Then sets up Client.GetModelFamily return parameters for the expectation previously defined by the When method
func (e *ClientMockGetModelFamilyExpectation) Then(c1 mm_ai.Client, err error) *ClientMock {
	e.results = &ClientMockGetModelFamilyResults{c1, err}
	return e.mock
}

// Times sets number of times Client.GetModelFamily should be invoked
func (mmGetModelFamily *mClientMockGetModelFamily) Times(n uint64) *mClientMockGetModelFamily {
	if n == 0 {
		mmGetModelFamily.mock.t.Fatalf("Times of ClientMock.GetModelFamily mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetModelFamily.expectedInvocations, n)
	mmGetModelFamily.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetModelFamily
}

func (mmGetModelFamily *mClientMockGetModelFamily) invocationsDone() bool {
	if len(mmGetModelFamily.expectations) == 0 && mmGetModelFamily.defaultExpectation == nil && mmGetModelFamily.mock.funcGetModelFamily == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetModelFamily.mock.afterGetModelFamilyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetModelFamily.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetModelFamily implements mm_ai.Client
func (mmGetModelFamily *ClientMock) GetModelFamily(modelFamily string) (c1 mm_ai.Client, err error) {
	mm_atomic.AddUint64(&mmGetModelFamily.beforeGetModelFamilyCounter, 1)
	defer mm_atomic.AddUint64(&mmGetModelFamily.afterGetModelFamilyCounter, 1)

	mmGetModelFamily.t.Helper()

	if mmGetModelFamily.inspectFuncGetModelFamily != nil {
		mmGetModelFamily.inspectFuncGetModelFamily(modelFamily)
	}

	mm_params := ClientMockGetModelFamilyParams{modelFamily}

	// Record call args
	mmGetModelFamily.GetModelFamilyMock.mutex.Lock()
	mmGetModelFamily.GetModelFamilyMock.callArgs = append(mmGetModelFamily.GetModelFamilyMock.callArgs, &mm_params)
	mmGetModelFamily.GetModelFamilyMock.mutex.Unlock()

	for _, e := range mmGetModelFamily.GetModelFamilyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c1, e.results.err
		}
	}

	if mmGetModelFamily.GetModelFamilyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetModelFamily.GetModelFamilyMock.defaultExpectation.Counter, 1)
		mm_want := mmGetModelFamily.GetModelFamilyMock.defaultExpectation.params
		mm_want_ptrs := mmGetModelFamily.GetModelFamilyMock.defaultExpectation.paramPtrs

		mm_got := ClientMockGetModelFamilyParams{modelFamily}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.modelFamily != nil && !minimock.Equal(*mm_want_ptrs.modelFamily, mm_got.modelFamily) {
				mmGetModelFamily.t.Errorf("ClientMock.GetModelFamily got unexpected parameter modelFamily, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetModelFamily.GetModelFamilyMock.defaultExpectation.expectationOrigins.originModelFamily, *mm_want_ptrs.modelFamily, mm_got.modelFamily, minimock.Diff(*mm_want_ptrs.modelFamily, mm_got.modelFamily))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetModelFamily.t.Errorf("ClientMock.GetModelFamily got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetModelFamily.GetModelFamilyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetModelFamily.GetModelFamilyMock.defaultExpectation.results
		if mm_results == nil {
			mmGetModelFamily.t.Fatal("No results are set for the ClientMock.GetModelFamily")
		}
		return (*mm_results).c1, (*mm_results).err
	}
	if mmGetModelFamily.funcGetModelFamily != nil {
		return mmGetModelFamily.funcGetModelFamily(modelFamily)
	}
	mmGetModelFamily.t.Fatalf("Unexpected call to ClientMock.GetModelFamily. %v", modelFamily)
	return
}

// GetModelFamilyAfterCounter returns a count of finished ClientMock.GetModelFamily invocations
func (mmGetModelFamily *ClientMock) GetModelFamilyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelFamily.afterGetModelFamilyCounter)
}

// GetModelFamilyBeforeCounter returns a count of ClientMock.GetModelFamily invocations
func (mmGetModelFamily *ClientMock) GetModelFamilyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelFamily.beforeGetModelFamilyCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetModelFamily.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetModelFamily *mClientMockGetModelFamily) Calls() []*ClientMockGetModelFamilyParams {
	mmGetModelFamily.mutex.RLock()

	argCopy := make([]*ClientMockGetModelFamilyParams, len(mmGetModelFamily.callArgs))
	copy(argCopy, mmGetModelFamily.callArgs)

	mmGetModelFamily.mutex.RUnlock()

	return argCopy
}

// MinimockGetModelFamilyDone returns true if the count of the GetModelFamily invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetModelFamilyDone() bool {
	if m.GetModelFamilyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetModelFamilyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetModelFamilyMock.invocationsDone()
}

// MinimockGetModelFamilyInspect logs each unmet expectation
func (m *ClientMock) MinimockGetModelFamilyInspect() {
	for _, e := range m.GetModelFamilyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetModelFamily at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetModelFamilyCounter := mm_atomic.LoadUint64(&m.afterGetModelFamilyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetModelFamilyMock.defaultExpectation != nil && afterGetModelFamilyCounter < 1 {
		if m.GetModelFamilyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.GetModelFamily at\n%s", m.GetModelFamilyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.GetModelFamily at\n%s with params: %#v", m.GetModelFamilyMock.defaultExpectation.expectationOrigins.origin, *m.GetModelFamilyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetModelFamily != nil && afterGetModelFamilyCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.GetModelFamily at\n%s", m.funcGetModelFamilyOrigin)
	}

	if !m.GetModelFamilyMock.invocationsDone() && afterGetModelFamilyCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetModelFamily at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetModelFamilyMock.expectedInvocations), m.GetModelFamilyMock.expectedInvocationsOrigin, afterGetModelFamilyCounter)
	}
}

type mClientMockListCaches struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockListCachesExpectation
	expectations       []*ClientMockListCachesExpectation

	callArgs []*ClientMockListCachesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockListCachesExpectation specifies expectation struct of the Client.ListCaches
type ClientMockListCachesExpectation struct {
	mock               *ClientMock
	params             *ClientMockListCachesParams
	paramPtrs          *ClientMockListCachesParamPtrs
	expectationOrigins ClientMockListCachesExpectationOrigins
	results            *ClientMockListCachesResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockListCachesParams contains parameters of the Client.ListCaches
type ClientMockListCachesParams struct {
	ctx     context.Context
	options *mm_ai.CacheListOptions
}

// ClientMockListCachesParamPtrs contains pointers to parameters of the Client.ListCaches
type ClientMockListCachesParamPtrs struct {
	ctx     *context.Context
	options **mm_ai.CacheListOptions
}

// ClientMockListCachesResults contains results of the Client.ListCaches
type ClientMockListCachesResults struct {
	cp1 *mm_ai.CacheListResult
	err error
}

// ClientMockListCachesOrigins contains origins of expectations of the Client.ListCaches
type ClientMockListCachesExpectationOrigins struct {
	origin        string
	originCtx     string
	originOptions string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListCaches *mClientMockListCaches) Optional() *mClientMockListCaches {
	mmListCaches.optional = true
	return mmListCaches
}

// Expect sets up expected params for Client.ListCaches
func (mmListCaches *mClientMockListCaches) Expect(ctx context.Context, options *mm_ai.CacheListOptions) *mClientMockListCaches {
	if mmListCaches.mock.funcListCaches != nil {
		mmListCaches.mock.t.Fatalf("ClientMock.ListCaches mock is already set by Set")
	}

	if mmListCaches.defaultExpectation == nil {
		mmListCaches.defaultExpectation = &ClientMockListCachesExpectation{}
	}

	if mmListCaches.defaultExpectation.paramPtrs != nil {
		mmListCaches.mock.t.Fatalf("ClientMock.ListCaches mock is already set by ExpectParams functions")
	}

	mmListCaches.defaultExpectation.params = &ClientMockListCachesParams{ctx, options}
	mmListCaches.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListCaches.expectations {
		if minimock.Equal(e.params, mmListCaches.defaultExpectation.params) {
			mmListCaches.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListCaches.defaultExpectation.params)
		}
	}

	return mmListCaches
}

// ExpectCtxParam1 sets up expected param ctx for Client.ListCaches
func (mmListCaches *mClientMockListCaches) ExpectCtxParam1(ctx context.Context) *mClientMockListCaches {
	if mmListCaches.mock.funcListCaches != nil {
		mmListCaches.mock.t.Fatalf("ClientMock.ListCaches mock is already set by Set")
	}

	if mmListCaches.defaultExpectation == nil {
		mmListCaches.defaultExpectation = &ClientMockListCachesExpectation{}
	}

	if mmListCaches.defaultExpectation.params != nil {
		mmListCaches.mock.t.Fatalf("ClientMock.ListCaches mock is already set by Expect")
	}

	if mmListCaches.defaultExpectation.paramPtrs == nil {
		mmListCaches.defaultExpectation.paramPtrs = &ClientMockListCachesParamPtrs{}
	}
	mmListCaches.defaultExpectation.paramPtrs.ctx = &ctx
	mmListCaches.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListCaches
}

// ExpectOptionsParam2 sets up expected param options for Client.ListCaches
func (mmListCaches *mClientMockListCaches) ExpectOptionsParam2(options *mm_ai.CacheListOptions) *mClientMockListCaches {
	if mmListCaches.mock.funcListCaches != nil {
		mmListCaches.mock.t.Fatalf("ClientMock.ListCaches mock is already set by Set")
	}

	if mmListCaches.defaultExpectation == nil {
		mmListCaches.defaultExpectation = &ClientMockListCachesExpectation{}
	}

	if mmListCaches.defaultExpectation.params != nil {
		mmListCaches.mock.t.Fatalf("ClientMock.ListCaches mock is already set by Expect")
	}

	if mmListCaches.defaultExpectation.paramPtrs == nil {
		mmListCaches.defaultExpectation.paramPtrs = &ClientMockListCachesParamPtrs{}
	}
	mmListCaches.defaultExpectation.paramPtrs.options = &options
	mmListCaches.defaultExpectation.expectationOrigins.originOptions = minimock.CallerInfo(1)

	return mmListCaches
}

// Inspect accepts an inspector function that has same arguments as the Client.ListCaches
func (mmListCaches *mClientMockListCaches) Inspect(f func(ctx context.Context, options *mm_ai.CacheListOptions)) *mClientMockListCaches {
	if mmListCaches.mock.inspectFuncListCaches != nil {
		mmListCaches.mock.t.Fatalf("Inspect function is already set for ClientMock.ListCaches")
	}

	mmListCaches.mock.inspectFuncListCaches = f

	return mmListCaches
}

// Return sets up results that will be returned by Client.ListCaches
func (mmListCaches *mClientMockListCaches) Return(cp1 *mm_ai.CacheListResult, err error) *ClientMock {
	if mmListCaches.mock.funcListCaches != nil {
		mmListCaches.mock.t.Fatalf("ClientMock.ListCaches mock is already set by Set")
	}

	if mmListCaches.defaultExpectation == nil {
		mmListCaches.defaultExpectation = &ClientMockListCachesExpectation{mock: mmListCaches.mock}
	}
	mmListCaches.defaultExpectation.results = &ClientMockListCachesResults{cp1, err}
	mmListCaches.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListCaches.mock
}

// Set uses given function f to mock the Client.ListCaches method
func (mmListCaches *mClientMockListCaches) Set(f func(ctx context.Context, options *mm_ai.CacheListOptions) (cp1 *mm_ai.CacheListResult, err error)) *ClientMock {
	if mmListCaches.defaultExpectation != nil {
		mmListCaches.mock.t.Fatalf("Default expectation is already set for the Client.ListCaches method")
	}

	if len(mmListCaches.expectations) > 0 {
		mmListCaches.mock.t.Fatalf("Some expectations are already set for the Client.ListCaches method")
	}

	mmListCaches.mock.funcListCaches = f
	mmListCaches.mock.funcListCachesOrigin = minimock.CallerInfo(1)
	return mmListCaches.mock
}

// When sets expectation for the Client.ListCaches which will trigger the result defined by the following
// Then helper
func (mmListCaches *mClientMockListCaches) When(ctx context.Context, options *mm_ai.CacheListOptions) *ClientMockListCachesExpectation {
	if mmListCaches.mock.funcListCaches != nil {
		mmListCaches.mock.t.Fatalf("ClientMock.ListCaches mock is already set by Set")
	}

	expectation := &ClientMockListCachesExpectation{
		mock:               mmListCaches.mock,
		params:             &ClientMockListCachesParams{ctx, options},
		expectationOrigins: ClientMockListCachesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListCaches.expectations = append(mmListCaches.expectations, expectation)
	return expectation
}

// Then sets up Client.ListCaches return parameters for the expectation previously defined by the When method
func (e *ClientMockListCachesExpectation) Then(cp1 *mm_ai.CacheListResult, err error) *ClientMock {
	e.results = &ClientMockListCachesResults{cp1, err}
	return e.mock
}

// Times sets number of times Client.ListCaches should be invoked
func (mmListCaches *mClientMockListCaches) Times(n uint64) *mClientMockListCaches {
	if n == 0 {
		mmListCaches.mock.t.Fatalf("Times of ClientMock.ListCaches mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListCaches.expectedInvocations, n)
	mmListCaches.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListCaches
}

func (mmListCaches *mClientMockListCaches) invocationsDone() bool {
	if len(mmListCaches.expectations) == 0 && mmListCaches.defaultExpectation == nil && mmListCaches.mock.funcListCaches == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListCaches.mock.afterListCachesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListCaches.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListCaches implements mm_ai.Client
func (mmListCaches *ClientMock) ListCaches(ctx context.Context, options *mm_ai.CacheListOptions) (cp1 *mm_ai.CacheListResult, err error) {
	mm_atomic.AddUint64(&mmListCaches.beforeListCachesCounter, 1)
	defer mm_atomic.AddUint64(&mmListCaches.afterListCachesCounter, 1)

	mmListCaches.t.Helper()

	if mmListCaches.inspectFuncListCaches != nil {
		mmListCaches.inspectFuncListCaches(ctx, options)
	}

	mm_params := ClientMockListCachesParams{ctx, options}

	// Record call args
	mmListCaches.ListCachesMock.mutex.Lock()
	mmListCaches.ListCachesMock.callArgs = append(mmListCaches.ListCachesMock.callArgs, &mm_params)
	mmListCaches.ListCachesMock.mutex.Unlock()

	for _, e := range mmListCaches.ListCachesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmListCaches.ListCachesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListCaches.ListCachesMock.defaultExpectation.Counter, 1)
		mm_want := mmListCaches.ListCachesMock.defaultExpectation.params
		mm_want_ptrs := mmListCaches.ListCachesMock.defaultExpectation.paramPtrs

		mm_got := ClientMockListCachesParams{ctx, options}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListCaches.t.Errorf("ClientMock.ListCaches got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCaches.ListCachesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.options != nil && !minimock.Equal(*mm_want_ptrs.options, mm_got.options) {
				mmListCaches.t.Errorf("ClientMock.ListCaches got unexpected parameter options, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCaches.ListCachesMock.defaultExpectation.expectationOrigins.originOptions, *mm_want_ptrs.options, mm_got.options, minimock.Diff(*mm_want_ptrs.options, mm_got.options))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListCaches.t.Errorf("ClientMock.ListCaches got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListCaches.ListCachesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListCaches.ListCachesMock.defaultExpectation.results
		if mm_results == nil {
			mmListCaches.t.Fatal("No results are set for the ClientMock.ListCaches")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmListCaches.funcListCaches != nil {
		return mmListCaches.funcListCaches(ctx, options)
	}
	mmListCaches.t.Fatalf("Unexpected call to ClientMock.ListCaches. %v %v", ctx, options)
	return
}

// ListCachesAfterCounter returns a count of finished ClientMock.ListCaches invocations
func (mmListCaches *ClientMock) ListCachesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCaches.afterListCachesCounter)
}

// ListCachesBeforeCounter returns a count of ClientMock.ListCaches invocations
func (mmListCaches *ClientMock) ListCachesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCaches.beforeListCachesCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.ListCaches.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListCaches *mClientMockListCaches) Calls() []*ClientMockListCachesParams {
	mmListCaches.mutex.RLock()

	argCopy := make([]*ClientMockListCachesParams, len(mmListCaches.callArgs))
	copy(argCopy, mmListCaches.callArgs)

	mmListCaches.mutex.RUnlock()

	return argCopy
}

// MinimockListCachesDone returns true if the count of the ListCaches invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockListCachesDone() bool {
	if m.ListCachesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListCachesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListCachesMock.invocationsDone()
}

// MinimockListCachesInspect logs each unmet expectation
func (m *ClientMock) MinimockListCachesInspect() {
	for _, e := range m.ListCachesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.ListCaches at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListCachesCounter := mm_atomic.LoadUint64(&m.afterListCachesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListCachesMock.defaultExpectation != nil && afterListCachesCounter < 1 {
		if m.ListCachesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.ListCaches at\n%s", m.ListCachesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.ListCaches at\n%s with params: %#v", m.ListCachesMock.defaultExpectation.expectationOrigins.origin, *m.ListCachesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCaches != nil && afterListCachesCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.ListCaches at\n%s", m.funcListCachesOrigin)
	}

	if !m.ListCachesMock.invocationsDone() && afterListCachesCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.ListCaches at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListCachesMock.expectedInvocations), m.ListCachesMock.expectedInvocationsOrigin, afterListCachesCounter)
	}
}

type mClientMockName struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockNameExpectation
	expectations       []*ClientMockNameExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockNameExpectation specifies expectation struct of the Client.Name
type ClientMockNameExpectation struct {
	mock *ClientMock

	results      *ClientMockNameResults
	returnOrigin string
	Counter      uint64
}

// ClientMockNameResults contains results of the Client.Name
type ClientMockNameResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmName *mClientMockName) Optional() *mClientMockName {
	mmName.optional = true
	return mmName
}

// Expect sets up expected params for Client.Name
func (mmName *mClientMockName) Expect() *mClientMockName {
	if mmName.mock.funcName != nil {
		mmName.mock.t.Fatalf("ClientMock.Name mock is already set by Set")
	}

	if mmName.defaultExpectation == nil {
		mmName.defaultExpectation = &ClientMockNameExpectation{}
	}

	return mmName
}

// Inspect accepts an inspector function that has same arguments as the Client.Name
func (mmName *mClientMockName) Inspect(f func()) *mClientMockName {
	if mmName.mock.inspectFuncName != nil {
		mmName.mock.t.Fatalf("Inspect function is already set for ClientMock.Name")
	}

	mmName.mock.inspectFuncName = f

	return mmName
}

// Return sets up results that will be returned by Client.Name
func (mmName *mClientMockName) Return(s1 string) *ClientMock {
	if mmName.mock.funcName != nil {
		mmName.mock.t.Fatalf("ClientMock.Name mock is already set by Set")
	}

	if mmName.defaultExpectation == nil {
		mmName.defaultExpectation = &ClientMockNameExpectation{mock: mmName.mock}
	}
	mmName.defaultExpectation.results = &ClientMockNameResults{s1}
	mmName.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmName.mock
}

// Set uses given function f to mock the Client.Name method
func (mmName *mClientMockName) Set(f func() (s1 string)) *ClientMock {
	if mmName.defaultExpectation != nil {
		mmName.mock.t.Fatalf("Default expectation is already set for the Client.Name method")
	}

	if len(mmName.expectations) > 0 {
		mmName.mock.t.Fatalf("Some expectations are already set for the Client.Name method")
	}

	mmName.mock.funcName = f
	mmName.mock.funcNameOrigin = minimock.CallerInfo(1)
	return mmName.mock
}

// Times sets number of times Client.Name should be invoked
func (mmName *mClientMockName) Times(n uint64) *mClientMockName {
	if n == 0 {
		mmName.mock.t.Fatalf("Times of ClientMock.Name mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmName.expectedInvocations, n)
	mmName.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmName
}

func (mmName *mClientMockName) invocationsDone() bool {
	if len(mmName.expectations) == 0 && mmName.defaultExpectation == nil && mmName.mock.funcName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmName.mock.afterNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Name implements mm_ai.Client
func (mmName *ClientMock) Name() (s1 string) {
	mm_atomic.AddUint64(&mmName.beforeNameCounter, 1)
	defer mm_atomic.AddUint64(&mmName.afterNameCounter, 1)

	mmName.t.Helper()

	if mmName.inspectFuncName != nil {
		mmName.inspectFuncName()
	}

	if mmName.NameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmName.NameMock.defaultExpectation.Counter, 1)

		mm_results := mmName.NameMock.defaultExpectation.results
		if mm_results == nil {
			mmName.t.Fatal("No results are set for the ClientMock.Name")
		}
		return (*mm_results).s1
	}
	if mmName.funcName != nil {
		return mmName.funcName()
	}
	mmName.t.Fatalf("Unexpected call to ClientMock.Name.")
	return
}

// NameAfterCounter returns a count of finished ClientMock.Name invocations
func (mmName *ClientMock) NameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmName.afterNameCounter)
}

// NameBeforeCounter returns a count of ClientMock.Name invocations
func (mmName *ClientMock) NameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmName.beforeNameCounter)
}

// MinimockNameDone returns true if the count of the Name invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockNameDone() bool {
	if m.NameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.NameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.NameMock.invocationsDone()
}

// MinimockNameInspect logs each unmet expectation
func (m *ClientMock) MinimockNameInspect() {
	for _, e := range m.NameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ClientMock.Name")
		}
	}

	afterNameCounter := mm_atomic.LoadUint64(&m.afterNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.NameMock.defaultExpectation != nil && afterNameCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.Name at\n%s", m.NameMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcName != nil && afterNameCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.Name at\n%s", m.funcNameOrigin)
	}

	if !m.NameMock.invocationsDone() && afterNameCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.Name at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.NameMock.expectedInvocations), m.NameMock.expectedInvocationsOrigin, afterNameCounter)
	}
}

type mClientMockSupportsFileType struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockSupportsFileTypeExpectation
	expectations       []*ClientMockSupportsFileTypeExpectation

	callArgs []*ClientMockSupportsFileTypeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockSupportsFileTypeExpectation specifies expectation struct of the Client.SupportsFileType
type ClientMockSupportsFileTypeExpectation struct {
	mock               *ClientMock
	params             *ClientMockSupportsFileTypeParams
	paramPtrs          *ClientMockSupportsFileTypeParamPtrs
	expectationOrigins ClientMockSupportsFileTypeExpectationOrigins
	results            *ClientMockSupportsFileTypeResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockSupportsFileTypeParams contains parameters of the Client.SupportsFileType
type ClientMockSupportsFileTypeParams struct {
	fileType artifactpb.File_Type
}

// ClientMockSupportsFileTypeParamPtrs contains pointers to parameters of the Client.SupportsFileType
type ClientMockSupportsFileTypeParamPtrs struct {
	fileType *artifactpb.File_Type
}

// ClientMockSupportsFileTypeResults contains results of the Client.SupportsFileType
type ClientMockSupportsFileTypeResults struct {
	b1 bool
}

// ClientMockSupportsFileTypeOrigins contains origins of expectations of the Client.SupportsFileType
type ClientMockSupportsFileTypeExpectationOrigins struct {
	origin         string
	originFileType string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSupportsFileType *mClientMockSupportsFileType) Optional() *mClientMockSupportsFileType {
	mmSupportsFileType.optional = true
	return mmSupportsFileType
}

// Expect sets up expected params for Client.SupportsFileType
func (mmSupportsFileType *mClientMockSupportsFileType) Expect(fileType artifactpb.File_Type) *mClientMockSupportsFileType {
	if mmSupportsFileType.mock.funcSupportsFileType != nil {
		mmSupportsFileType.mock.t.Fatalf("ClientMock.SupportsFileType mock is already set by Set")
	}

	if mmSupportsFileType.defaultExpectation == nil {
		mmSupportsFileType.defaultExpectation = &ClientMockSupportsFileTypeExpectation{}
	}

	if mmSupportsFileType.defaultExpectation.paramPtrs != nil {
		mmSupportsFileType.mock.t.Fatalf("ClientMock.SupportsFileType mock is already set by ExpectParams functions")
	}

	mmSupportsFileType.defaultExpectation.params = &ClientMockSupportsFileTypeParams{fileType}
	mmSupportsFileType.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSupportsFileType.expectations {
		if minimock.Equal(e.params, mmSupportsFileType.defaultExpectation.params) {
			mmSupportsFileType.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSupportsFileType.defaultExpectation.params)
		}
	}

	return mmSupportsFileType
}

// ExpectFileTypeParam1 sets up expected param fileType for Client.SupportsFileType
func (mmSupportsFileType *mClientMockSupportsFileType) ExpectFileTypeParam1(fileType artifactpb.File_Type) *mClientMockSupportsFileType {
	if mmSupportsFileType.mock.funcSupportsFileType != nil {
		mmSupportsFileType.mock.t.Fatalf("ClientMock.SupportsFileType mock is already set by Set")
	}

	if mmSupportsFileType.defaultExpectation == nil {
		mmSupportsFileType.defaultExpectation = &ClientMockSupportsFileTypeExpectation{}
	}

	if mmSupportsFileType.defaultExpectation.params != nil {
		mmSupportsFileType.mock.t.Fatalf("ClientMock.SupportsFileType mock is already set by Expect")
	}

	if mmSupportsFileType.defaultExpectation.paramPtrs == nil {
		mmSupportsFileType.defaultExpectation.paramPtrs = &ClientMockSupportsFileTypeParamPtrs{}
	}
	mmSupportsFileType.defaultExpectation.paramPtrs.fileType = &fileType
	mmSupportsFileType.defaultExpectation.expectationOrigins.originFileType = minimock.CallerInfo(1)

	return mmSupportsFileType
}

// Inspect accepts an inspector function that has same arguments as the Client.SupportsFileType
func (mmSupportsFileType *mClientMockSupportsFileType) Inspect(f func(fileType artifactpb.File_Type)) *mClientMockSupportsFileType {
	if mmSupportsFileType.mock.inspectFuncSupportsFileType != nil {
		mmSupportsFileType.mock.t.Fatalf("Inspect function is already set for ClientMock.SupportsFileType")
	}

	mmSupportsFileType.mock.inspectFuncSupportsFileType = f

	return mmSupportsFileType
}

// Return sets up results that will be returned by Client.SupportsFileType
func (mmSupportsFileType *mClientMockSupportsFileType) Return(b1 bool) *ClientMock {
	if mmSupportsFileType.mock.funcSupportsFileType != nil {
		mmSupportsFileType.mock.t.Fatalf("ClientMock.SupportsFileType mock is already set by Set")
	}

	if mmSupportsFileType.defaultExpectation == nil {
		mmSupportsFileType.defaultExpectation = &ClientMockSupportsFileTypeExpectation{mock: mmSupportsFileType.mock}
	}
	mmSupportsFileType.defaultExpectation.results = &ClientMockSupportsFileTypeResults{b1}
	mmSupportsFileType.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSupportsFileType.mock
}

// Set uses given function f to mock the Client.SupportsFileType method
func (mmSupportsFileType *mClientMockSupportsFileType) Set(f func(fileType artifactpb.File_Type) (b1 bool)) *ClientMock {
	if mmSupportsFileType.defaultExpectation != nil {
		mmSupportsFileType.mock.t.Fatalf("Default expectation is already set for the Client.SupportsFileType method")
	}

	if len(mmSupportsFileType.expectations) > 0 {
		mmSupportsFileType.mock.t.Fatalf("Some expectations are already set for the Client.SupportsFileType method")
	}

	mmSupportsFileType.mock.funcSupportsFileType = f
	mmSupportsFileType.mock.funcSupportsFileTypeOrigin = minimock.CallerInfo(1)
	return mmSupportsFileType.mock
}

// When sets expectation for the Client.SupportsFileType which will trigger the result defined by the following
// Then helper
func (mmSupportsFileType *mClientMockSupportsFileType) When(fileType artifactpb.File_Type) *ClientMockSupportsFileTypeExpectation {
	if mmSupportsFileType.mock.funcSupportsFileType != nil {
		mmSupportsFileType.mock.t.Fatalf("ClientMock.SupportsFileType mock is already set by Set")
	}

	expectation := &ClientMockSupportsFileTypeExpectation{
		mock:               mmSupportsFileType.mock,
		params:             &ClientMockSupportsFileTypeParams{fileType},
		expectationOrigins: ClientMockSupportsFileTypeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSupportsFileType.expectations = append(mmSupportsFileType.expectations, expectation)
	return expectation
}

// Then sets up Client.SupportsFileType return parameters for the expectation previously defined by the When method
func (e *ClientMockSupportsFileTypeExpectation) Then(b1 bool) *ClientMock {
	e.results = &ClientMockSupportsFileTypeResults{b1}
	return e.mock
}

// Times sets number of times Client.SupportsFileType should be invoked
func (mmSupportsFileType *mClientMockSupportsFileType) Times(n uint64) *mClientMockSupportsFileType {
	if n == 0 {
		mmSupportsFileType.mock.t.Fatalf("Times of ClientMock.SupportsFileType mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSupportsFileType.expectedInvocations, n)
	mmSupportsFileType.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSupportsFileType
}

func (mmSupportsFileType *mClientMockSupportsFileType) invocationsDone() bool {
	if len(mmSupportsFileType.expectations) == 0 && mmSupportsFileType.defaultExpectation == nil && mmSupportsFileType.mock.funcSupportsFileType == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSupportsFileType.mock.afterSupportsFileTypeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSupportsFileType.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SupportsFileType implements mm_ai.Client
func (mmSupportsFileType *ClientMock) SupportsFileType(fileType artifactpb.File_Type) (b1 bool) {
	mm_atomic.AddUint64(&mmSupportsFileType.beforeSupportsFileTypeCounter, 1)
	defer mm_atomic.AddUint64(&mmSupportsFileType.afterSupportsFileTypeCounter, 1)

	mmSupportsFileType.t.Helper()

	if mmSupportsFileType.inspectFuncSupportsFileType != nil {
		mmSupportsFileType.inspectFuncSupportsFileType(fileType)
	}

	mm_params := ClientMockSupportsFileTypeParams{fileType}

	// Record call args
	mmSupportsFileType.SupportsFileTypeMock.mutex.Lock()
	mmSupportsFileType.SupportsFileTypeMock.callArgs = append(mmSupportsFileType.SupportsFileTypeMock.callArgs, &mm_params)
	mmSupportsFileType.SupportsFileTypeMock.mutex.Unlock()

	for _, e := range mmSupportsFileType.SupportsFileTypeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmSupportsFileType.SupportsFileTypeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSupportsFileType.SupportsFileTypeMock.defaultExpectation.Counter, 1)
		mm_want := mmSupportsFileType.SupportsFileTypeMock.defaultExpectation.params
		mm_want_ptrs := mmSupportsFileType.SupportsFileTypeMock.defaultExpectation.paramPtrs

		mm_got := ClientMockSupportsFileTypeParams{fileType}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.fileType != nil && !minimock.Equal(*mm_want_ptrs.fileType, mm_got.fileType) {
				mmSupportsFileType.t.Errorf("ClientMock.SupportsFileType got unexpected parameter fileType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSupportsFileType.SupportsFileTypeMock.defaultExpectation.expectationOrigins.originFileType, *mm_want_ptrs.fileType, mm_got.fileType, minimock.Diff(*mm_want_ptrs.fileType, mm_got.fileType))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSupportsFileType.t.Errorf("ClientMock.SupportsFileType got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSupportsFileType.SupportsFileTypeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSupportsFileType.SupportsFileTypeMock.defaultExpectation.results
		if mm_results == nil {
			mmSupportsFileType.t.Fatal("No results are set for the ClientMock.SupportsFileType")
		}
		return (*mm_results).b1
	}
	if mmSupportsFileType.funcSupportsFileType != nil {
		return mmSupportsFileType.funcSupportsFileType(fileType)
	}
	mmSupportsFileType.t.Fatalf("Unexpected call to ClientMock.SupportsFileType. %v", fileType)
	return
}

// SupportsFileTypeAfterCounter returns a count of finished ClientMock.SupportsFileType invocations
func (mmSupportsFileType *ClientMock) SupportsFileTypeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSupportsFileType.afterSupportsFileTypeCounter)
}

// SupportsFileTypeBeforeCounter returns a count of ClientMock.SupportsFileType invocations
func (mmSupportsFileType *ClientMock) SupportsFileTypeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSupportsFileType.beforeSupportsFileTypeCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.SupportsFileType.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSupportsFileType *mClientMockSupportsFileType) Calls() []*ClientMockSupportsFileTypeParams {
	mmSupportsFileType.mutex.RLock()

	argCopy := make([]*ClientMockSupportsFileTypeParams, len(mmSupportsFileType.callArgs))
	copy(argCopy, mmSupportsFileType.callArgs)

	mmSupportsFileType.mutex.RUnlock()

	return argCopy
}

// MinimockSupportsFileTypeDone returns true if the count of the SupportsFileType invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockSupportsFileTypeDone() bool {
	if m.SupportsFileTypeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SupportsFileTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SupportsFileTypeMock.invocationsDone()
}

// MinimockSupportsFileTypeInspect logs each unmet expectation
func (m *ClientMock) MinimockSupportsFileTypeInspect() {
	for _, e := range m.SupportsFileTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.SupportsFileType at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSupportsFileTypeCounter := mm_atomic.LoadUint64(&m.afterSupportsFileTypeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SupportsFileTypeMock.defaultExpectation != nil && afterSupportsFileTypeCounter < 1 {
		if m.SupportsFileTypeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.SupportsFileType at\n%s", m.SupportsFileTypeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.SupportsFileType at\n%s with params: %#v", m.SupportsFileTypeMock.defaultExpectation.expectationOrigins.origin, *m.SupportsFileTypeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSupportsFileType != nil && afterSupportsFileTypeCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.SupportsFileType at\n%s", m.funcSupportsFileTypeOrigin)
	}

	if !m.SupportsFileTypeMock.invocationsDone() && afterSupportsFileTypeCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.SupportsFileType at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SupportsFileTypeMock.expectedInvocations), m.SupportsFileTypeMock.expectedInvocationsOrigin, afterSupportsFileTypeCounter)
	}
}

type mClientMockUpdateCache struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockUpdateCacheExpectation
	expectations       []*ClientMockUpdateCacheExpectation

	callArgs []*ClientMockUpdateCacheParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockUpdateCacheExpectation specifies expectation struct of the Client.UpdateCache
type ClientMockUpdateCacheExpectation struct {
	mock               *ClientMock
	params             *ClientMockUpdateCacheParams
	paramPtrs          *ClientMockUpdateCacheParamPtrs
	expectationOrigins ClientMockUpdateCacheExpectationOrigins
	results            *ClientMockUpdateCacheResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockUpdateCacheParams contains parameters of the Client.UpdateCache
type ClientMockUpdateCacheParams struct {
	ctx       context.Context
	cacheName string
	options   *mm_ai.CacheUpdateOptions
}

// ClientMockUpdateCacheParamPtrs contains pointers to parameters of the Client.UpdateCache
type ClientMockUpdateCacheParamPtrs struct {
	ctx       *context.Context
	cacheName *string
	options   **mm_ai.CacheUpdateOptions
}

// ClientMockUpdateCacheResults contains results of the Client.UpdateCache
type ClientMockUpdateCacheResults struct {
	cp1 *mm_ai.CacheResult
	err error
}

// ClientMockUpdateCacheOrigins contains origins of expectations of the Client.UpdateCache
type ClientMockUpdateCacheExpectationOrigins struct {
	origin          string
	originCtx       string
	originCacheName string
	originOptions   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateCache *mClientMockUpdateCache) Optional() *mClientMockUpdateCache {
	mmUpdateCache.optional = true
	return mmUpdateCache
}

// Expect sets up expected params for Client.UpdateCache
func (mmUpdateCache *mClientMockUpdateCache) Expect(ctx context.Context, cacheName string, options *mm_ai.CacheUpdateOptions) *mClientMockUpdateCache {
	if mmUpdateCache.mock.funcUpdateCache != nil {
		mmUpdateCache.mock.t.Fatalf("ClientMock.UpdateCache mock is already set by Set")
	}

	if mmUpdateCache.defaultExpectation == nil {
		mmUpdateCache.defaultExpectation = &ClientMockUpdateCacheExpectation{}
	}

	if mmUpdateCache.defaultExpectation.paramPtrs != nil {
		mmUpdateCache.mock.t.Fatalf("ClientMock.UpdateCache mock is already set by ExpectParams functions")
	}

	mmUpdateCache.defaultExpectation.params = &ClientMockUpdateCacheParams{ctx, cacheName, options}
	mmUpdateCache.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateCache.expectations {
		if minimock.Equal(e.params, mmUpdateCache.defaultExpectation.params) {
			mmUpdateCache.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateCache.defaultExpectation.params)
		}
	}

	return mmUpdateCache
}

// ExpectCtxParam1 sets up expected param ctx for Client.UpdateCache
func (mmUpdateCache *mClientMockUpdateCache) ExpectCtxParam1(ctx context.Context) *mClientMockUpdateCache {
	if mmUpdateCache.mock.funcUpdateCache != nil {
		mmUpdateCache.mock.t.Fatalf("ClientMock.UpdateCache mock is already set by Set")
	}

	if mmUpdateCache.defaultExpectation == nil {
		mmUpdateCache.defaultExpectation = &ClientMockUpdateCacheExpectation{}
	}

	if mmUpdateCache.defaultExpectation.params != nil {
		mmUpdateCache.mock.t.Fatalf("ClientMock.UpdateCache mock is already set by Expect")
	}

	if mmUpdateCache.defaultExpectation.paramPtrs == nil {
		mmUpdateCache.defaultExpectation.paramPtrs = &ClientMockUpdateCacheParamPtrs{}
	}
	mmUpdateCache.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateCache.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateCache
}

// ExpectCacheNameParam2 sets up expected param cacheName for Client.UpdateCache
func (mmUpdateCache *mClientMockUpdateCache) ExpectCacheNameParam2(cacheName string) *mClientMockUpdateCache {
	if mmUpdateCache.mock.funcUpdateCache != nil {
		mmUpdateCache.mock.t.Fatalf("ClientMock.UpdateCache mock is already set by Set")
	}

	if mmUpdateCache.defaultExpectation == nil {
		mmUpdateCache.defaultExpectation = &ClientMockUpdateCacheExpectation{}
	}

	if mmUpdateCache.defaultExpectation.params != nil {
		mmUpdateCache.mock.t.Fatalf("ClientMock.UpdateCache mock is already set by Expect")
	}

	if mmUpdateCache.defaultExpectation.paramPtrs == nil {
		mmUpdateCache.defaultExpectation.paramPtrs = &ClientMockUpdateCacheParamPtrs{}
	}
	mmUpdateCache.defaultExpectation.paramPtrs.cacheName = &cacheName
	mmUpdateCache.defaultExpectation.expectationOrigins.originCacheName = minimock.CallerInfo(1)

	return mmUpdateCache
}

// ExpectOptionsParam3 sets up expected param options for Client.UpdateCache
func (mmUpdateCache *mClientMockUpdateCache) ExpectOptionsParam3(options *mm_ai.CacheUpdateOptions) *mClientMockUpdateCache {
	if mmUpdateCache.mock.funcUpdateCache != nil {
		mmUpdateCache.mock.t.Fatalf("ClientMock.UpdateCache mock is already set by Set")
	}

	if mmUpdateCache.defaultExpectation == nil {
		mmUpdateCache.defaultExpectation = &ClientMockUpdateCacheExpectation{}
	}

	if mmUpdateCache.defaultExpectation.params != nil {
		mmUpdateCache.mock.t.Fatalf("ClientMock.UpdateCache mock is already set by Expect")
	}

	if mmUpdateCache.defaultExpectation.paramPtrs == nil {
		mmUpdateCache.defaultExpectation.paramPtrs = &ClientMockUpdateCacheParamPtrs{}
	}
	mmUpdateCache.defaultExpectation.paramPtrs.options = &options
	mmUpdateCache.defaultExpectation.expectationOrigins.originOptions = minimock.CallerInfo(1)

	return mmUpdateCache
}

// Inspect accepts an inspector function that has same arguments as the Client.UpdateCache
func (mmUpdateCache *mClientMockUpdateCache) Inspect(f func(ctx context.Context, cacheName string, options *mm_ai.CacheUpdateOptions)) *mClientMockUpdateCache {
	if mmUpdateCache.mock.inspectFuncUpdateCache != nil {
		mmUpdateCache.mock.t.Fatalf("Inspect function is already set for ClientMock.UpdateCache")
	}

	mmUpdateCache.mock.inspectFuncUpdateCache = f

	return mmUpdateCache
}

// Return sets up results that will be returned by Client.UpdateCache
func (mmUpdateCache *mClientMockUpdateCache) Return(cp1 *mm_ai.CacheResult, err error) *ClientMock {
	if mmUpdateCache.mock.funcUpdateCache != nil {
		mmUpdateCache.mock.t.Fatalf("ClientMock.UpdateCache mock is already set by Set")
	}

	if mmUpdateCache.defaultExpectation == nil {
		mmUpdateCache.defaultExpectation = &ClientMockUpdateCacheExpectation{mock: mmUpdateCache.mock}
	}
	mmUpdateCache.defaultExpectation.results = &ClientMockUpdateCacheResults{cp1, err}
	mmUpdateCache.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateCache.mock
}

// Set uses given function f to mock the Client.UpdateCache method
func (mmUpdateCache *mClientMockUpdateCache) Set(f func(ctx context.Context, cacheName string, options *mm_ai.CacheUpdateOptions) (cp1 *mm_ai.CacheResult, err error)) *ClientMock {
	if mmUpdateCache.defaultExpectation != nil {
		mmUpdateCache.mock.t.Fatalf("Default expectation is already set for the Client.UpdateCache method")
	}

	if len(mmUpdateCache.expectations) > 0 {
		mmUpdateCache.mock.t.Fatalf("Some expectations are already set for the Client.UpdateCache method")
	}

	mmUpdateCache.mock.funcUpdateCache = f
	mmUpdateCache.mock.funcUpdateCacheOrigin = minimock.CallerInfo(1)
	return mmUpdateCache.mock
}

// When sets expectation for the Client.UpdateCache which will trigger the result defined by the following
// Then helper
func (mmUpdateCache *mClientMockUpdateCache) When(ctx context.Context, cacheName string, options *mm_ai.CacheUpdateOptions) *ClientMockUpdateCacheExpectation {
	if mmUpdateCache.mock.funcUpdateCache != nil {
		mmUpdateCache.mock.t.Fatalf("ClientMock.UpdateCache mock is already set by Set")
	}

	expectation := &ClientMockUpdateCacheExpectation{
		mock:               mmUpdateCache.mock,
		params:             &ClientMockUpdateCacheParams{ctx, cacheName, options},
		expectationOrigins: ClientMockUpdateCacheExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateCache.expectations = append(mmUpdateCache.expectations, expectation)
	return expectation
}

// Then sets up Client.UpdateCache return parameters for the expectation previously defined by the When method
func (e *ClientMockUpdateCacheExpectation) Then(cp1 *mm_ai.CacheResult, err error) *ClientMock {
	e.results = &ClientMockUpdateCacheResults{cp1, err}
	return e.mock
}

// Times sets number of times Client.UpdateCache should be invoked
func (mmUpdateCache *mClientMockUpdateCache) Times(n uint64) *mClientMockUpdateCache {
	if n == 0 {
		mmUpdateCache.mock.t.Fatalf("Times of ClientMock.UpdateCache mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateCache.expectedInvocations, n)
	mmUpdateCache.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateCache
}

func (mmUpdateCache *mClientMockUpdateCache) invocationsDone() bool {
	if len(mmUpdateCache.expectations) == 0 && mmUpdateCache.defaultExpectation == nil && mmUpdateCache.mock.funcUpdateCache == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateCache.mock.afterUpdateCacheCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateCache.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateCache implements mm_ai.Client
func (mmUpdateCache *ClientMock) UpdateCache(ctx context.Context, cacheName string, options *mm_ai.CacheUpdateOptions) (cp1 *mm_ai.CacheResult, err error) {
	mm_atomic.AddUint64(&mmUpdateCache.beforeUpdateCacheCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateCache.afterUpdateCacheCounter, 1)

	mmUpdateCache.t.Helper()

	if mmUpdateCache.inspectFuncUpdateCache != nil {
		mmUpdateCache.inspectFuncUpdateCache(ctx, cacheName, options)
	}

	mm_params := ClientMockUpdateCacheParams{ctx, cacheName, options}

	// Record call args
	mmUpdateCache.UpdateCacheMock.mutex.Lock()
	mmUpdateCache.UpdateCacheMock.callArgs = append(mmUpdateCache.UpdateCacheMock.callArgs, &mm_params)
	mmUpdateCache.UpdateCacheMock.mutex.Unlock()

	for _, e := range mmUpdateCache.UpdateCacheMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmUpdateCache.UpdateCacheMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateCache.UpdateCacheMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateCache.UpdateCacheMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateCache.UpdateCacheMock.defaultExpectation.paramPtrs

		mm_got := ClientMockUpdateCacheParams{ctx, cacheName, options}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateCache.t.Errorf("ClientMock.UpdateCache got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateCache.UpdateCacheMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cacheName != nil && !minimock.Equal(*mm_want_ptrs.cacheName, mm_got.cacheName) {
				mmUpdateCache.t.Errorf("ClientMock.UpdateCache got unexpected parameter cacheName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateCache.UpdateCacheMock.defaultExpectation.expectationOrigins.originCacheName, *mm_want_ptrs.cacheName, mm_got.cacheName, minimock.Diff(*mm_want_ptrs.cacheName, mm_got.cacheName))
			}

			if mm_want_ptrs.options != nil && !minimock.Equal(*mm_want_ptrs.options, mm_got.options) {
				mmUpdateCache.t.Errorf("ClientMock.UpdateCache got unexpected parameter options, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateCache.UpdateCacheMock.defaultExpectation.expectationOrigins.originOptions, *mm_want_ptrs.options, mm_got.options, minimock.Diff(*mm_want_ptrs.options, mm_got.options))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateCache.t.Errorf("ClientMock.UpdateCache got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateCache.UpdateCacheMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateCache.UpdateCacheMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateCache.t.Fatal("No results are set for the ClientMock.UpdateCache")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmUpdateCache.funcUpdateCache != nil {
		return mmUpdateCache.funcUpdateCache(ctx, cacheName, options)
	}
	mmUpdateCache.t.Fatalf("Unexpected call to ClientMock.UpdateCache. %v %v %v", ctx, cacheName, options)
	return
}

// UpdateCacheAfterCounter returns a count of finished ClientMock.UpdateCache invocations
func (mmUpdateCache *ClientMock) UpdateCacheAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCache.afterUpdateCacheCounter)
}

// UpdateCacheBeforeCounter returns a count of ClientMock.UpdateCache invocations
func (mmUpdateCache *ClientMock) UpdateCacheBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCache.beforeUpdateCacheCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.UpdateCache.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateCache *mClientMockUpdateCache) Calls() []*ClientMockUpdateCacheParams {
	mmUpdateCache.mutex.RLock()

	argCopy := make([]*ClientMockUpdateCacheParams, len(mmUpdateCache.callArgs))
	copy(argCopy, mmUpdateCache.callArgs)

	mmUpdateCache.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateCacheDone returns true if the count of the UpdateCache invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockUpdateCacheDone() bool {
	if m.UpdateCacheMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateCacheMock.invocationsDone()
}

// MinimockUpdateCacheInspect logs each unmet expectation
func (m *ClientMock) MinimockUpdateCacheInspect() {
	for _, e := range m.UpdateCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.UpdateCache at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCacheCounter := mm_atomic.LoadUint64(&m.afterUpdateCacheCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCacheMock.defaultExpectation != nil && afterUpdateCacheCounter < 1 {
		if m.UpdateCacheMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.UpdateCache at\n%s", m.UpdateCacheMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.UpdateCache at\n%s with params: %#v", m.UpdateCacheMock.defaultExpectation.expectationOrigins.origin, *m.UpdateCacheMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCache != nil && afterUpdateCacheCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.UpdateCache at\n%s", m.funcUpdateCacheOrigin)
	}

	if !m.UpdateCacheMock.invocationsDone() && afterUpdateCacheCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.UpdateCache at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateCacheMock.expectedInvocations), m.UpdateCacheMock.expectedInvocationsOrigin, afterUpdateCacheCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCloseInspect()

			m.MinimockConvertToMarkdownWithCacheInspect()

			m.MinimockConvertToMarkdownWithoutCacheInspect()

			m.MinimockCreateCacheInspect()

			m.MinimockDeleteCacheInspect()

			m.MinimockEmbedTextsInspect()

			m.MinimockGetCacheInspect()

			m.MinimockGetEmbeddingDimensionalityInspect()

			m.MinimockGetModelFamilyInspect()

			m.MinimockListCachesInspect()

			m.MinimockNameInspect()

			m.MinimockSupportsFileTypeInspect()

			m.MinimockUpdateCacheInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseDone() &&
		m.MinimockConvertToMarkdownWithCacheDone() &&
		m.MinimockConvertToMarkdownWithoutCacheDone() &&
		m.MinimockCreateCacheDone() &&
		m.MinimockDeleteCacheDone() &&
		m.MinimockEmbedTextsDone() &&
		m.MinimockGetCacheDone() &&
		m.MinimockGetEmbeddingDimensionalityDone() &&
		m.MinimockGetModelFamilyDone() &&
		m.MinimockListCachesDone() &&
		m.MinimockNameDone() &&
		m.MinimockSupportsFileTypeDone() &&
		m.MinimockUpdateCacheDone()
}
