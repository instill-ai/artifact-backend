// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

import (
	"context"
	"net/url"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/instill-ai/artifact-backend/pkg/types"
	"github.com/minio/minio-go/v7"
)

// StorageMock implements mm_object.Storage
type StorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDeleteFile          func(ctx context.Context, bucket string, filePath string) (err error)
	funcDeleteFileOrigin    string
	inspectFuncDeleteFile   func(ctx context.Context, bucket string, filePath string)
	afterDeleteFileCounter  uint64
	beforeDeleteFileCounter uint64
	DeleteFileMock          mStorageMockDeleteFile

	funcGetBucket          func() (s1 string)
	funcGetBucketOrigin    string
	inspectFuncGetBucket   func()
	afterGetBucketCounter  uint64
	beforeGetBucketCounter uint64
	GetBucketMock          mStorageMockGetBucket

	funcGetFile          func(ctx context.Context, bucket string, filePath string) (ba1 []byte, err error)
	funcGetFileOrigin    string
	inspectFuncGetFile   func(ctx context.Context, bucket string, filePath string)
	afterGetFileCounter  uint64
	beforeGetFileCounter uint64
	GetFileMock          mStorageMockGetFile

	funcGetFileMetadata          func(ctx context.Context, bucket string, filePath string) (op1 *minio.ObjectInfo, err error)
	funcGetFileMetadataOrigin    string
	inspectFuncGetFileMetadata   func(ctx context.Context, bucket string, filePath string)
	afterGetFileMetadataCounter  uint64
	beforeGetFileMetadataCounter uint64
	GetFileMetadataMock          mStorageMockGetFileMetadata

	funcGetPresignedURLForDownload          func(ctx context.Context, bucket string, objectPath string, filename string, contentType string, expiration time.Duration) (up1 *url.URL, err error)
	funcGetPresignedURLForDownloadOrigin    string
	inspectFuncGetPresignedURLForDownload   func(ctx context.Context, bucket string, objectPath string, filename string, contentType string, expiration time.Duration)
	afterGetPresignedURLForDownloadCounter  uint64
	beforeGetPresignedURLForDownloadCounter uint64
	GetPresignedURLForDownloadMock          mStorageMockGetPresignedURLForDownload

	funcGetPresignedURLForUpload          func(ctx context.Context, namespaceUUID types.NamespaceUIDType, objectUUID types.ObjectUIDType, filename string, urlExpiration time.Duration) (up1 *url.URL, err error)
	funcGetPresignedURLForUploadOrigin    string
	inspectFuncGetPresignedURLForUpload   func(ctx context.Context, namespaceUUID types.NamespaceUIDType, objectUUID types.ObjectUIDType, filename string, urlExpiration time.Duration)
	afterGetPresignedURLForUploadCounter  uint64
	beforeGetPresignedURLForUploadCounter uint64
	GetPresignedURLForUploadMock          mStorageMockGetPresignedURLForUpload

	funcListConvertedFilesByFileUID          func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType) (sa1 []string, err error)
	funcListConvertedFilesByFileUIDOrigin    string
	inspectFuncListConvertedFilesByFileUID   func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType)
	afterListConvertedFilesByFileUIDCounter  uint64
	beforeListConvertedFilesByFileUIDCounter uint64
	ListConvertedFilesByFileUIDMock          mStorageMockListConvertedFilesByFileUID

	funcListFilePathsWithPrefix          func(ctx context.Context, bucket string, prefix string) (sa1 []string, err error)
	funcListFilePathsWithPrefixOrigin    string
	inspectFuncListFilePathsWithPrefix   func(ctx context.Context, bucket string, prefix string)
	afterListFilePathsWithPrefixCounter  uint64
	beforeListFilePathsWithPrefixCounter uint64
	ListFilePathsWithPrefixMock          mStorageMockListFilePathsWithPrefix

	funcListKnowledgeBaseFilePaths          func(ctx context.Context, kbUID types.KBUIDType) (sa1 []string, err error)
	funcListKnowledgeBaseFilePathsOrigin    string
	inspectFuncListKnowledgeBaseFilePaths   func(ctx context.Context, kbUID types.KBUIDType)
	afterListKnowledgeBaseFilePathsCounter  uint64
	beforeListKnowledgeBaseFilePathsCounter uint64
	ListKnowledgeBaseFilePathsMock          mStorageMockListKnowledgeBaseFilePaths

	funcListTextChunksByFileUID          func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType) (sa1 []string, err error)
	funcListTextChunksByFileUIDOrigin    string
	inspectFuncListTextChunksByFileUID   func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType)
	afterListTextChunksByFileUIDCounter  uint64
	beforeListTextChunksByFileUIDCounter uint64
	ListTextChunksByFileUIDMock          mStorageMockListTextChunksByFileUID

	funcSaveConvertedFile          func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, convertedFileUID types.ConvertedFileUIDType, fileExt string, content []byte) (path string, err error)
	funcSaveConvertedFileOrigin    string
	inspectFuncSaveConvertedFile   func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, convertedFileUID types.ConvertedFileUIDType, fileExt string, content []byte)
	afterSaveConvertedFileCounter  uint64
	beforeSaveConvertedFileCounter uint64
	SaveConvertedFileMock          mStorageMockSaveConvertedFile

	funcUploadBase64File          func(ctx context.Context, bucket string, filePath string, base64Content string, fileMimeType string) (err error)
	funcUploadBase64FileOrigin    string
	inspectFuncUploadBase64File   func(ctx context.Context, bucket string, filePath string, base64Content string, fileMimeType string)
	afterUploadBase64FileCounter  uint64
	beforeUploadBase64FileCounter uint64
	UploadBase64FileMock          mStorageMockUploadBase64File
}

// NewStorageMock returns a mock for mm_object.Storage
func NewStorageMock(t minimock.Tester) *StorageMock {
	m := &StorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeleteFileMock = mStorageMockDeleteFile{mock: m}
	m.DeleteFileMock.callArgs = []*StorageMockDeleteFileParams{}

	m.GetBucketMock = mStorageMockGetBucket{mock: m}

	m.GetFileMock = mStorageMockGetFile{mock: m}
	m.GetFileMock.callArgs = []*StorageMockGetFileParams{}

	m.GetFileMetadataMock = mStorageMockGetFileMetadata{mock: m}
	m.GetFileMetadataMock.callArgs = []*StorageMockGetFileMetadataParams{}

	m.GetPresignedURLForDownloadMock = mStorageMockGetPresignedURLForDownload{mock: m}
	m.GetPresignedURLForDownloadMock.callArgs = []*StorageMockGetPresignedURLForDownloadParams{}

	m.GetPresignedURLForUploadMock = mStorageMockGetPresignedURLForUpload{mock: m}
	m.GetPresignedURLForUploadMock.callArgs = []*StorageMockGetPresignedURLForUploadParams{}

	m.ListConvertedFilesByFileUIDMock = mStorageMockListConvertedFilesByFileUID{mock: m}
	m.ListConvertedFilesByFileUIDMock.callArgs = []*StorageMockListConvertedFilesByFileUIDParams{}

	m.ListFilePathsWithPrefixMock = mStorageMockListFilePathsWithPrefix{mock: m}
	m.ListFilePathsWithPrefixMock.callArgs = []*StorageMockListFilePathsWithPrefixParams{}

	m.ListKnowledgeBaseFilePathsMock = mStorageMockListKnowledgeBaseFilePaths{mock: m}
	m.ListKnowledgeBaseFilePathsMock.callArgs = []*StorageMockListKnowledgeBaseFilePathsParams{}

	m.ListTextChunksByFileUIDMock = mStorageMockListTextChunksByFileUID{mock: m}
	m.ListTextChunksByFileUIDMock.callArgs = []*StorageMockListTextChunksByFileUIDParams{}

	m.SaveConvertedFileMock = mStorageMockSaveConvertedFile{mock: m}
	m.SaveConvertedFileMock.callArgs = []*StorageMockSaveConvertedFileParams{}

	m.UploadBase64FileMock = mStorageMockUploadBase64File{mock: m}
	m.UploadBase64FileMock.callArgs = []*StorageMockUploadBase64FileParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStorageMockDeleteFile struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockDeleteFileExpectation
	expectations       []*StorageMockDeleteFileExpectation

	callArgs []*StorageMockDeleteFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockDeleteFileExpectation specifies expectation struct of the Storage.DeleteFile
type StorageMockDeleteFileExpectation struct {
	mock               *StorageMock
	params             *StorageMockDeleteFileParams
	paramPtrs          *StorageMockDeleteFileParamPtrs
	expectationOrigins StorageMockDeleteFileExpectationOrigins
	results            *StorageMockDeleteFileResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockDeleteFileParams contains parameters of the Storage.DeleteFile
type StorageMockDeleteFileParams struct {
	ctx      context.Context
	bucket   string
	filePath string
}

// StorageMockDeleteFileParamPtrs contains pointers to parameters of the Storage.DeleteFile
type StorageMockDeleteFileParamPtrs struct {
	ctx      *context.Context
	bucket   *string
	filePath *string
}

// StorageMockDeleteFileResults contains results of the Storage.DeleteFile
type StorageMockDeleteFileResults struct {
	err error
}

// StorageMockDeleteFileOrigins contains origins of expectations of the Storage.DeleteFile
type StorageMockDeleteFileExpectationOrigins struct {
	origin         string
	originCtx      string
	originBucket   string
	originFilePath string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteFile *mStorageMockDeleteFile) Optional() *mStorageMockDeleteFile {
	mmDeleteFile.optional = true
	return mmDeleteFile
}

// Expect sets up expected params for Storage.DeleteFile
func (mmDeleteFile *mStorageMockDeleteFile) Expect(ctx context.Context, bucket string, filePath string) *mStorageMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("StorageMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &StorageMockDeleteFileExpectation{}
	}

	if mmDeleteFile.defaultExpectation.paramPtrs != nil {
		mmDeleteFile.mock.t.Fatalf("StorageMock.DeleteFile mock is already set by ExpectParams functions")
	}

	mmDeleteFile.defaultExpectation.params = &StorageMockDeleteFileParams{ctx, bucket, filePath}
	mmDeleteFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteFile.expectations {
		if minimock.Equal(e.params, mmDeleteFile.defaultExpectation.params) {
			mmDeleteFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteFile.defaultExpectation.params)
		}
	}

	return mmDeleteFile
}

// ExpectCtxParam1 sets up expected param ctx for Storage.DeleteFile
func (mmDeleteFile *mStorageMockDeleteFile) ExpectCtxParam1(ctx context.Context) *mStorageMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("StorageMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &StorageMockDeleteFileExpectation{}
	}

	if mmDeleteFile.defaultExpectation.params != nil {
		mmDeleteFile.mock.t.Fatalf("StorageMock.DeleteFile mock is already set by Expect")
	}

	if mmDeleteFile.defaultExpectation.paramPtrs == nil {
		mmDeleteFile.defaultExpectation.paramPtrs = &StorageMockDeleteFileParamPtrs{}
	}
	mmDeleteFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteFile
}

// ExpectBucketParam2 sets up expected param bucket for Storage.DeleteFile
func (mmDeleteFile *mStorageMockDeleteFile) ExpectBucketParam2(bucket string) *mStorageMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("StorageMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &StorageMockDeleteFileExpectation{}
	}

	if mmDeleteFile.defaultExpectation.params != nil {
		mmDeleteFile.mock.t.Fatalf("StorageMock.DeleteFile mock is already set by Expect")
	}

	if mmDeleteFile.defaultExpectation.paramPtrs == nil {
		mmDeleteFile.defaultExpectation.paramPtrs = &StorageMockDeleteFileParamPtrs{}
	}
	mmDeleteFile.defaultExpectation.paramPtrs.bucket = &bucket
	mmDeleteFile.defaultExpectation.expectationOrigins.originBucket = minimock.CallerInfo(1)

	return mmDeleteFile
}

// ExpectFilePathParam3 sets up expected param filePath for Storage.DeleteFile
func (mmDeleteFile *mStorageMockDeleteFile) ExpectFilePathParam3(filePath string) *mStorageMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("StorageMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &StorageMockDeleteFileExpectation{}
	}

	if mmDeleteFile.defaultExpectation.params != nil {
		mmDeleteFile.mock.t.Fatalf("StorageMock.DeleteFile mock is already set by Expect")
	}

	if mmDeleteFile.defaultExpectation.paramPtrs == nil {
		mmDeleteFile.defaultExpectation.paramPtrs = &StorageMockDeleteFileParamPtrs{}
	}
	mmDeleteFile.defaultExpectation.paramPtrs.filePath = &filePath
	mmDeleteFile.defaultExpectation.expectationOrigins.originFilePath = minimock.CallerInfo(1)

	return mmDeleteFile
}

// Inspect accepts an inspector function that has same arguments as the Storage.DeleteFile
func (mmDeleteFile *mStorageMockDeleteFile) Inspect(f func(ctx context.Context, bucket string, filePath string)) *mStorageMockDeleteFile {
	if mmDeleteFile.mock.inspectFuncDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("Inspect function is already set for StorageMock.DeleteFile")
	}

	mmDeleteFile.mock.inspectFuncDeleteFile = f

	return mmDeleteFile
}

// Return sets up results that will be returned by Storage.DeleteFile
func (mmDeleteFile *mStorageMockDeleteFile) Return(err error) *StorageMock {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("StorageMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &StorageMockDeleteFileExpectation{mock: mmDeleteFile.mock}
	}
	mmDeleteFile.defaultExpectation.results = &StorageMockDeleteFileResults{err}
	mmDeleteFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteFile.mock
}

// Set uses given function f to mock the Storage.DeleteFile method
func (mmDeleteFile *mStorageMockDeleteFile) Set(f func(ctx context.Context, bucket string, filePath string) (err error)) *StorageMock {
	if mmDeleteFile.defaultExpectation != nil {
		mmDeleteFile.mock.t.Fatalf("Default expectation is already set for the Storage.DeleteFile method")
	}

	if len(mmDeleteFile.expectations) > 0 {
		mmDeleteFile.mock.t.Fatalf("Some expectations are already set for the Storage.DeleteFile method")
	}

	mmDeleteFile.mock.funcDeleteFile = f
	mmDeleteFile.mock.funcDeleteFileOrigin = minimock.CallerInfo(1)
	return mmDeleteFile.mock
}

// When sets expectation for the Storage.DeleteFile which will trigger the result defined by the following
// Then helper
func (mmDeleteFile *mStorageMockDeleteFile) When(ctx context.Context, bucket string, filePath string) *StorageMockDeleteFileExpectation {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("StorageMock.DeleteFile mock is already set by Set")
	}

	expectation := &StorageMockDeleteFileExpectation{
		mock:               mmDeleteFile.mock,
		params:             &StorageMockDeleteFileParams{ctx, bucket, filePath},
		expectationOrigins: StorageMockDeleteFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteFile.expectations = append(mmDeleteFile.expectations, expectation)
	return expectation
}

// Then sets up Storage.DeleteFile return parameters for the expectation previously defined by the When method
func (e *StorageMockDeleteFileExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockDeleteFileResults{err}
	return e.mock
}

// Times sets number of times Storage.DeleteFile should be invoked
func (mmDeleteFile *mStorageMockDeleteFile) Times(n uint64) *mStorageMockDeleteFile {
	if n == 0 {
		mmDeleteFile.mock.t.Fatalf("Times of StorageMock.DeleteFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteFile.expectedInvocations, n)
	mmDeleteFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteFile
}

func (mmDeleteFile *mStorageMockDeleteFile) invocationsDone() bool {
	if len(mmDeleteFile.expectations) == 0 && mmDeleteFile.defaultExpectation == nil && mmDeleteFile.mock.funcDeleteFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteFile.mock.afterDeleteFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteFile implements mm_object.Storage
func (mmDeleteFile *StorageMock) DeleteFile(ctx context.Context, bucket string, filePath string) (err error) {
	mm_atomic.AddUint64(&mmDeleteFile.beforeDeleteFileCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteFile.afterDeleteFileCounter, 1)

	mmDeleteFile.t.Helper()

	if mmDeleteFile.inspectFuncDeleteFile != nil {
		mmDeleteFile.inspectFuncDeleteFile(ctx, bucket, filePath)
	}

	mm_params := StorageMockDeleteFileParams{ctx, bucket, filePath}

	// Record call args
	mmDeleteFile.DeleteFileMock.mutex.Lock()
	mmDeleteFile.DeleteFileMock.callArgs = append(mmDeleteFile.DeleteFileMock.callArgs, &mm_params)
	mmDeleteFile.DeleteFileMock.mutex.Unlock()

	for _, e := range mmDeleteFile.DeleteFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteFile.DeleteFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteFile.DeleteFileMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteFile.DeleteFileMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteFile.DeleteFileMock.defaultExpectation.paramPtrs

		mm_got := StorageMockDeleteFileParams{ctx, bucket, filePath}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteFile.t.Errorf("StorageMock.DeleteFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFile.DeleteFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.bucket != nil && !minimock.Equal(*mm_want_ptrs.bucket, mm_got.bucket) {
				mmDeleteFile.t.Errorf("StorageMock.DeleteFile got unexpected parameter bucket, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFile.DeleteFileMock.defaultExpectation.expectationOrigins.originBucket, *mm_want_ptrs.bucket, mm_got.bucket, minimock.Diff(*mm_want_ptrs.bucket, mm_got.bucket))
			}

			if mm_want_ptrs.filePath != nil && !minimock.Equal(*mm_want_ptrs.filePath, mm_got.filePath) {
				mmDeleteFile.t.Errorf("StorageMock.DeleteFile got unexpected parameter filePath, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFile.DeleteFileMock.defaultExpectation.expectationOrigins.originFilePath, *mm_want_ptrs.filePath, mm_got.filePath, minimock.Diff(*mm_want_ptrs.filePath, mm_got.filePath))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteFile.t.Errorf("StorageMock.DeleteFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteFile.DeleteFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteFile.DeleteFileMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteFile.t.Fatal("No results are set for the StorageMock.DeleteFile")
		}
		return (*mm_results).err
	}
	if mmDeleteFile.funcDeleteFile != nil {
		return mmDeleteFile.funcDeleteFile(ctx, bucket, filePath)
	}
	mmDeleteFile.t.Fatalf("Unexpected call to StorageMock.DeleteFile. %v %v %v", ctx, bucket, filePath)
	return
}

// DeleteFileAfterCounter returns a count of finished StorageMock.DeleteFile invocations
func (mmDeleteFile *StorageMock) DeleteFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFile.afterDeleteFileCounter)
}

// DeleteFileBeforeCounter returns a count of StorageMock.DeleteFile invocations
func (mmDeleteFile *StorageMock) DeleteFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFile.beforeDeleteFileCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.DeleteFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteFile *mStorageMockDeleteFile) Calls() []*StorageMockDeleteFileParams {
	mmDeleteFile.mutex.RLock()

	argCopy := make([]*StorageMockDeleteFileParams, len(mmDeleteFile.callArgs))
	copy(argCopy, mmDeleteFile.callArgs)

	mmDeleteFile.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteFileDone returns true if the count of the DeleteFile invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockDeleteFileDone() bool {
	if m.DeleteFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteFileMock.invocationsDone()
}

// MinimockDeleteFileInspect logs each unmet expectation
func (m *StorageMock) MinimockDeleteFileInspect() {
	for _, e := range m.DeleteFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.DeleteFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteFileCounter := mm_atomic.LoadUint64(&m.afterDeleteFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFileMock.defaultExpectation != nil && afterDeleteFileCounter < 1 {
		if m.DeleteFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.DeleteFile at\n%s", m.DeleteFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.DeleteFile at\n%s with params: %#v", m.DeleteFileMock.defaultExpectation.expectationOrigins.origin, *m.DeleteFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFile != nil && afterDeleteFileCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.DeleteFile at\n%s", m.funcDeleteFileOrigin)
	}

	if !m.DeleteFileMock.invocationsDone() && afterDeleteFileCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.DeleteFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteFileMock.expectedInvocations), m.DeleteFileMock.expectedInvocationsOrigin, afterDeleteFileCounter)
	}
}

type mStorageMockGetBucket struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetBucketExpectation
	expectations       []*StorageMockGetBucketExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGetBucketExpectation specifies expectation struct of the Storage.GetBucket
type StorageMockGetBucketExpectation struct {
	mock *StorageMock

	results      *StorageMockGetBucketResults
	returnOrigin string
	Counter      uint64
}

// StorageMockGetBucketResults contains results of the Storage.GetBucket
type StorageMockGetBucketResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetBucket *mStorageMockGetBucket) Optional() *mStorageMockGetBucket {
	mmGetBucket.optional = true
	return mmGetBucket
}

// Expect sets up expected params for Storage.GetBucket
func (mmGetBucket *mStorageMockGetBucket) Expect() *mStorageMockGetBucket {
	if mmGetBucket.mock.funcGetBucket != nil {
		mmGetBucket.mock.t.Fatalf("StorageMock.GetBucket mock is already set by Set")
	}

	if mmGetBucket.defaultExpectation == nil {
		mmGetBucket.defaultExpectation = &StorageMockGetBucketExpectation{}
	}

	return mmGetBucket
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetBucket
func (mmGetBucket *mStorageMockGetBucket) Inspect(f func()) *mStorageMockGetBucket {
	if mmGetBucket.mock.inspectFuncGetBucket != nil {
		mmGetBucket.mock.t.Fatalf("Inspect function is already set for StorageMock.GetBucket")
	}

	mmGetBucket.mock.inspectFuncGetBucket = f

	return mmGetBucket
}

// Return sets up results that will be returned by Storage.GetBucket
func (mmGetBucket *mStorageMockGetBucket) Return(s1 string) *StorageMock {
	if mmGetBucket.mock.funcGetBucket != nil {
		mmGetBucket.mock.t.Fatalf("StorageMock.GetBucket mock is already set by Set")
	}

	if mmGetBucket.defaultExpectation == nil {
		mmGetBucket.defaultExpectation = &StorageMockGetBucketExpectation{mock: mmGetBucket.mock}
	}
	mmGetBucket.defaultExpectation.results = &StorageMockGetBucketResults{s1}
	mmGetBucket.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetBucket.mock
}

// Set uses given function f to mock the Storage.GetBucket method
func (mmGetBucket *mStorageMockGetBucket) Set(f func() (s1 string)) *StorageMock {
	if mmGetBucket.defaultExpectation != nil {
		mmGetBucket.mock.t.Fatalf("Default expectation is already set for the Storage.GetBucket method")
	}

	if len(mmGetBucket.expectations) > 0 {
		mmGetBucket.mock.t.Fatalf("Some expectations are already set for the Storage.GetBucket method")
	}

	mmGetBucket.mock.funcGetBucket = f
	mmGetBucket.mock.funcGetBucketOrigin = minimock.CallerInfo(1)
	return mmGetBucket.mock
}

// Times sets number of times Storage.GetBucket should be invoked
func (mmGetBucket *mStorageMockGetBucket) Times(n uint64) *mStorageMockGetBucket {
	if n == 0 {
		mmGetBucket.mock.t.Fatalf("Times of StorageMock.GetBucket mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetBucket.expectedInvocations, n)
	mmGetBucket.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetBucket
}

func (mmGetBucket *mStorageMockGetBucket) invocationsDone() bool {
	if len(mmGetBucket.expectations) == 0 && mmGetBucket.defaultExpectation == nil && mmGetBucket.mock.funcGetBucket == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetBucket.mock.afterGetBucketCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetBucket.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetBucket implements mm_object.Storage
func (mmGetBucket *StorageMock) GetBucket() (s1 string) {
	mm_atomic.AddUint64(&mmGetBucket.beforeGetBucketCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBucket.afterGetBucketCounter, 1)

	mmGetBucket.t.Helper()

	if mmGetBucket.inspectFuncGetBucket != nil {
		mmGetBucket.inspectFuncGetBucket()
	}

	if mmGetBucket.GetBucketMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBucket.GetBucketMock.defaultExpectation.Counter, 1)

		mm_results := mmGetBucket.GetBucketMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBucket.t.Fatal("No results are set for the StorageMock.GetBucket")
		}
		return (*mm_results).s1
	}
	if mmGetBucket.funcGetBucket != nil {
		return mmGetBucket.funcGetBucket()
	}
	mmGetBucket.t.Fatalf("Unexpected call to StorageMock.GetBucket.")
	return
}

// GetBucketAfterCounter returns a count of finished StorageMock.GetBucket invocations
func (mmGetBucket *StorageMock) GetBucketAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBucket.afterGetBucketCounter)
}

// GetBucketBeforeCounter returns a count of StorageMock.GetBucket invocations
func (mmGetBucket *StorageMock) GetBucketBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBucket.beforeGetBucketCounter)
}

// MinimockGetBucketDone returns true if the count of the GetBucket invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetBucketDone() bool {
	if m.GetBucketMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetBucketMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetBucketMock.invocationsDone()
}

// MinimockGetBucketInspect logs each unmet expectation
func (m *StorageMock) MinimockGetBucketInspect() {
	for _, e := range m.GetBucketMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StorageMock.GetBucket")
		}
	}

	afterGetBucketCounter := mm_atomic.LoadUint64(&m.afterGetBucketCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetBucketMock.defaultExpectation != nil && afterGetBucketCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetBucket at\n%s", m.GetBucketMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBucket != nil && afterGetBucketCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetBucket at\n%s", m.funcGetBucketOrigin)
	}

	if !m.GetBucketMock.invocationsDone() && afterGetBucketCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetBucket at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetBucketMock.expectedInvocations), m.GetBucketMock.expectedInvocationsOrigin, afterGetBucketCounter)
	}
}

type mStorageMockGetFile struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetFileExpectation
	expectations       []*StorageMockGetFileExpectation

	callArgs []*StorageMockGetFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGetFileExpectation specifies expectation struct of the Storage.GetFile
type StorageMockGetFileExpectation struct {
	mock               *StorageMock
	params             *StorageMockGetFileParams
	paramPtrs          *StorageMockGetFileParamPtrs
	expectationOrigins StorageMockGetFileExpectationOrigins
	results            *StorageMockGetFileResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockGetFileParams contains parameters of the Storage.GetFile
type StorageMockGetFileParams struct {
	ctx      context.Context
	bucket   string
	filePath string
}

// StorageMockGetFileParamPtrs contains pointers to parameters of the Storage.GetFile
type StorageMockGetFileParamPtrs struct {
	ctx      *context.Context
	bucket   *string
	filePath *string
}

// StorageMockGetFileResults contains results of the Storage.GetFile
type StorageMockGetFileResults struct {
	ba1 []byte
	err error
}

// StorageMockGetFileOrigins contains origins of expectations of the Storage.GetFile
type StorageMockGetFileExpectationOrigins struct {
	origin         string
	originCtx      string
	originBucket   string
	originFilePath string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFile *mStorageMockGetFile) Optional() *mStorageMockGetFile {
	mmGetFile.optional = true
	return mmGetFile
}

// Expect sets up expected params for Storage.GetFile
func (mmGetFile *mStorageMockGetFile) Expect(ctx context.Context, bucket string, filePath string) *mStorageMockGetFile {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("StorageMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &StorageMockGetFileExpectation{}
	}

	if mmGetFile.defaultExpectation.paramPtrs != nil {
		mmGetFile.mock.t.Fatalf("StorageMock.GetFile mock is already set by ExpectParams functions")
	}

	mmGetFile.defaultExpectation.params = &StorageMockGetFileParams{ctx, bucket, filePath}
	mmGetFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetFile.expectations {
		if minimock.Equal(e.params, mmGetFile.defaultExpectation.params) {
			mmGetFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFile.defaultExpectation.params)
		}
	}

	return mmGetFile
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetFile
func (mmGetFile *mStorageMockGetFile) ExpectCtxParam1(ctx context.Context) *mStorageMockGetFile {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("StorageMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &StorageMockGetFileExpectation{}
	}

	if mmGetFile.defaultExpectation.params != nil {
		mmGetFile.mock.t.Fatalf("StorageMock.GetFile mock is already set by Expect")
	}

	if mmGetFile.defaultExpectation.paramPtrs == nil {
		mmGetFile.defaultExpectation.paramPtrs = &StorageMockGetFileParamPtrs{}
	}
	mmGetFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetFile
}

// ExpectBucketParam2 sets up expected param bucket for Storage.GetFile
func (mmGetFile *mStorageMockGetFile) ExpectBucketParam2(bucket string) *mStorageMockGetFile {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("StorageMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &StorageMockGetFileExpectation{}
	}

	if mmGetFile.defaultExpectation.params != nil {
		mmGetFile.mock.t.Fatalf("StorageMock.GetFile mock is already set by Expect")
	}

	if mmGetFile.defaultExpectation.paramPtrs == nil {
		mmGetFile.defaultExpectation.paramPtrs = &StorageMockGetFileParamPtrs{}
	}
	mmGetFile.defaultExpectation.paramPtrs.bucket = &bucket
	mmGetFile.defaultExpectation.expectationOrigins.originBucket = minimock.CallerInfo(1)

	return mmGetFile
}

// ExpectFilePathParam3 sets up expected param filePath for Storage.GetFile
func (mmGetFile *mStorageMockGetFile) ExpectFilePathParam3(filePath string) *mStorageMockGetFile {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("StorageMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &StorageMockGetFileExpectation{}
	}

	if mmGetFile.defaultExpectation.params != nil {
		mmGetFile.mock.t.Fatalf("StorageMock.GetFile mock is already set by Expect")
	}

	if mmGetFile.defaultExpectation.paramPtrs == nil {
		mmGetFile.defaultExpectation.paramPtrs = &StorageMockGetFileParamPtrs{}
	}
	mmGetFile.defaultExpectation.paramPtrs.filePath = &filePath
	mmGetFile.defaultExpectation.expectationOrigins.originFilePath = minimock.CallerInfo(1)

	return mmGetFile
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetFile
func (mmGetFile *mStorageMockGetFile) Inspect(f func(ctx context.Context, bucket string, filePath string)) *mStorageMockGetFile {
	if mmGetFile.mock.inspectFuncGetFile != nil {
		mmGetFile.mock.t.Fatalf("Inspect function is already set for StorageMock.GetFile")
	}

	mmGetFile.mock.inspectFuncGetFile = f

	return mmGetFile
}

// Return sets up results that will be returned by Storage.GetFile
func (mmGetFile *mStorageMockGetFile) Return(ba1 []byte, err error) *StorageMock {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("StorageMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &StorageMockGetFileExpectation{mock: mmGetFile.mock}
	}
	mmGetFile.defaultExpectation.results = &StorageMockGetFileResults{ba1, err}
	mmGetFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetFile.mock
}

// Set uses given function f to mock the Storage.GetFile method
func (mmGetFile *mStorageMockGetFile) Set(f func(ctx context.Context, bucket string, filePath string) (ba1 []byte, err error)) *StorageMock {
	if mmGetFile.defaultExpectation != nil {
		mmGetFile.mock.t.Fatalf("Default expectation is already set for the Storage.GetFile method")
	}

	if len(mmGetFile.expectations) > 0 {
		mmGetFile.mock.t.Fatalf("Some expectations are already set for the Storage.GetFile method")
	}

	mmGetFile.mock.funcGetFile = f
	mmGetFile.mock.funcGetFileOrigin = minimock.CallerInfo(1)
	return mmGetFile.mock
}

// When sets expectation for the Storage.GetFile which will trigger the result defined by the following
// Then helper
func (mmGetFile *mStorageMockGetFile) When(ctx context.Context, bucket string, filePath string) *StorageMockGetFileExpectation {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("StorageMock.GetFile mock is already set by Set")
	}

	expectation := &StorageMockGetFileExpectation{
		mock:               mmGetFile.mock,
		params:             &StorageMockGetFileParams{ctx, bucket, filePath},
		expectationOrigins: StorageMockGetFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetFile.expectations = append(mmGetFile.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetFile return parameters for the expectation previously defined by the When method
func (e *StorageMockGetFileExpectation) Then(ba1 []byte, err error) *StorageMock {
	e.results = &StorageMockGetFileResults{ba1, err}
	return e.mock
}

// Times sets number of times Storage.GetFile should be invoked
func (mmGetFile *mStorageMockGetFile) Times(n uint64) *mStorageMockGetFile {
	if n == 0 {
		mmGetFile.mock.t.Fatalf("Times of StorageMock.GetFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFile.expectedInvocations, n)
	mmGetFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetFile
}

func (mmGetFile *mStorageMockGetFile) invocationsDone() bool {
	if len(mmGetFile.expectations) == 0 && mmGetFile.defaultExpectation == nil && mmGetFile.mock.funcGetFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFile.mock.afterGetFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFile implements mm_object.Storage
func (mmGetFile *StorageMock) GetFile(ctx context.Context, bucket string, filePath string) (ba1 []byte, err error) {
	mm_atomic.AddUint64(&mmGetFile.beforeGetFileCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFile.afterGetFileCounter, 1)

	mmGetFile.t.Helper()

	if mmGetFile.inspectFuncGetFile != nil {
		mmGetFile.inspectFuncGetFile(ctx, bucket, filePath)
	}

	mm_params := StorageMockGetFileParams{ctx, bucket, filePath}

	// Record call args
	mmGetFile.GetFileMock.mutex.Lock()
	mmGetFile.GetFileMock.callArgs = append(mmGetFile.GetFileMock.callArgs, &mm_params)
	mmGetFile.GetFileMock.mutex.Unlock()

	for _, e := range mmGetFile.GetFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ba1, e.results.err
		}
	}

	if mmGetFile.GetFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFile.GetFileMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFile.GetFileMock.defaultExpectation.params
		mm_want_ptrs := mmGetFile.GetFileMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGetFileParams{ctx, bucket, filePath}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFile.t.Errorf("StorageMock.GetFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFile.GetFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.bucket != nil && !minimock.Equal(*mm_want_ptrs.bucket, mm_got.bucket) {
				mmGetFile.t.Errorf("StorageMock.GetFile got unexpected parameter bucket, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFile.GetFileMock.defaultExpectation.expectationOrigins.originBucket, *mm_want_ptrs.bucket, mm_got.bucket, minimock.Diff(*mm_want_ptrs.bucket, mm_got.bucket))
			}

			if mm_want_ptrs.filePath != nil && !minimock.Equal(*mm_want_ptrs.filePath, mm_got.filePath) {
				mmGetFile.t.Errorf("StorageMock.GetFile got unexpected parameter filePath, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFile.GetFileMock.defaultExpectation.expectationOrigins.originFilePath, *mm_want_ptrs.filePath, mm_got.filePath, minimock.Diff(*mm_want_ptrs.filePath, mm_got.filePath))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFile.t.Errorf("StorageMock.GetFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetFile.GetFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFile.GetFileMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFile.t.Fatal("No results are set for the StorageMock.GetFile")
		}
		return (*mm_results).ba1, (*mm_results).err
	}
	if mmGetFile.funcGetFile != nil {
		return mmGetFile.funcGetFile(ctx, bucket, filePath)
	}
	mmGetFile.t.Fatalf("Unexpected call to StorageMock.GetFile. %v %v %v", ctx, bucket, filePath)
	return
}

// GetFileAfterCounter returns a count of finished StorageMock.GetFile invocations
func (mmGetFile *StorageMock) GetFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFile.afterGetFileCounter)
}

// GetFileBeforeCounter returns a count of StorageMock.GetFile invocations
func (mmGetFile *StorageMock) GetFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFile.beforeGetFileCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFile *mStorageMockGetFile) Calls() []*StorageMockGetFileParams {
	mmGetFile.mutex.RLock()

	argCopy := make([]*StorageMockGetFileParams, len(mmGetFile.callArgs))
	copy(argCopy, mmGetFile.callArgs)

	mmGetFile.mutex.RUnlock()

	return argCopy
}

// MinimockGetFileDone returns true if the count of the GetFile invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetFileDone() bool {
	if m.GetFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFileMock.invocationsDone()
}

// MinimockGetFileInspect logs each unmet expectation
func (m *StorageMock) MinimockGetFileInspect() {
	for _, e := range m.GetFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetFileCounter := mm_atomic.LoadUint64(&m.afterGetFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFileMock.defaultExpectation != nil && afterGetFileCounter < 1 {
		if m.GetFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GetFile at\n%s", m.GetFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GetFile at\n%s with params: %#v", m.GetFileMock.defaultExpectation.expectationOrigins.origin, *m.GetFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFile != nil && afterGetFileCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetFile at\n%s", m.funcGetFileOrigin)
	}

	if !m.GetFileMock.invocationsDone() && afterGetFileCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetFileMock.expectedInvocations), m.GetFileMock.expectedInvocationsOrigin, afterGetFileCounter)
	}
}

type mStorageMockGetFileMetadata struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetFileMetadataExpectation
	expectations       []*StorageMockGetFileMetadataExpectation

	callArgs []*StorageMockGetFileMetadataParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGetFileMetadataExpectation specifies expectation struct of the Storage.GetFileMetadata
type StorageMockGetFileMetadataExpectation struct {
	mock               *StorageMock
	params             *StorageMockGetFileMetadataParams
	paramPtrs          *StorageMockGetFileMetadataParamPtrs
	expectationOrigins StorageMockGetFileMetadataExpectationOrigins
	results            *StorageMockGetFileMetadataResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockGetFileMetadataParams contains parameters of the Storage.GetFileMetadata
type StorageMockGetFileMetadataParams struct {
	ctx      context.Context
	bucket   string
	filePath string
}

// StorageMockGetFileMetadataParamPtrs contains pointers to parameters of the Storage.GetFileMetadata
type StorageMockGetFileMetadataParamPtrs struct {
	ctx      *context.Context
	bucket   *string
	filePath *string
}

// StorageMockGetFileMetadataResults contains results of the Storage.GetFileMetadata
type StorageMockGetFileMetadataResults struct {
	op1 *minio.ObjectInfo
	err error
}

// StorageMockGetFileMetadataOrigins contains origins of expectations of the Storage.GetFileMetadata
type StorageMockGetFileMetadataExpectationOrigins struct {
	origin         string
	originCtx      string
	originBucket   string
	originFilePath string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFileMetadata *mStorageMockGetFileMetadata) Optional() *mStorageMockGetFileMetadata {
	mmGetFileMetadata.optional = true
	return mmGetFileMetadata
}

// Expect sets up expected params for Storage.GetFileMetadata
func (mmGetFileMetadata *mStorageMockGetFileMetadata) Expect(ctx context.Context, bucket string, filePath string) *mStorageMockGetFileMetadata {
	if mmGetFileMetadata.mock.funcGetFileMetadata != nil {
		mmGetFileMetadata.mock.t.Fatalf("StorageMock.GetFileMetadata mock is already set by Set")
	}

	if mmGetFileMetadata.defaultExpectation == nil {
		mmGetFileMetadata.defaultExpectation = &StorageMockGetFileMetadataExpectation{}
	}

	if mmGetFileMetadata.defaultExpectation.paramPtrs != nil {
		mmGetFileMetadata.mock.t.Fatalf("StorageMock.GetFileMetadata mock is already set by ExpectParams functions")
	}

	mmGetFileMetadata.defaultExpectation.params = &StorageMockGetFileMetadataParams{ctx, bucket, filePath}
	mmGetFileMetadata.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetFileMetadata.expectations {
		if minimock.Equal(e.params, mmGetFileMetadata.defaultExpectation.params) {
			mmGetFileMetadata.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFileMetadata.defaultExpectation.params)
		}
	}

	return mmGetFileMetadata
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetFileMetadata
func (mmGetFileMetadata *mStorageMockGetFileMetadata) ExpectCtxParam1(ctx context.Context) *mStorageMockGetFileMetadata {
	if mmGetFileMetadata.mock.funcGetFileMetadata != nil {
		mmGetFileMetadata.mock.t.Fatalf("StorageMock.GetFileMetadata mock is already set by Set")
	}

	if mmGetFileMetadata.defaultExpectation == nil {
		mmGetFileMetadata.defaultExpectation = &StorageMockGetFileMetadataExpectation{}
	}

	if mmGetFileMetadata.defaultExpectation.params != nil {
		mmGetFileMetadata.mock.t.Fatalf("StorageMock.GetFileMetadata mock is already set by Expect")
	}

	if mmGetFileMetadata.defaultExpectation.paramPtrs == nil {
		mmGetFileMetadata.defaultExpectation.paramPtrs = &StorageMockGetFileMetadataParamPtrs{}
	}
	mmGetFileMetadata.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetFileMetadata.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetFileMetadata
}

// ExpectBucketParam2 sets up expected param bucket for Storage.GetFileMetadata
func (mmGetFileMetadata *mStorageMockGetFileMetadata) ExpectBucketParam2(bucket string) *mStorageMockGetFileMetadata {
	if mmGetFileMetadata.mock.funcGetFileMetadata != nil {
		mmGetFileMetadata.mock.t.Fatalf("StorageMock.GetFileMetadata mock is already set by Set")
	}

	if mmGetFileMetadata.defaultExpectation == nil {
		mmGetFileMetadata.defaultExpectation = &StorageMockGetFileMetadataExpectation{}
	}

	if mmGetFileMetadata.defaultExpectation.params != nil {
		mmGetFileMetadata.mock.t.Fatalf("StorageMock.GetFileMetadata mock is already set by Expect")
	}

	if mmGetFileMetadata.defaultExpectation.paramPtrs == nil {
		mmGetFileMetadata.defaultExpectation.paramPtrs = &StorageMockGetFileMetadataParamPtrs{}
	}
	mmGetFileMetadata.defaultExpectation.paramPtrs.bucket = &bucket
	mmGetFileMetadata.defaultExpectation.expectationOrigins.originBucket = minimock.CallerInfo(1)

	return mmGetFileMetadata
}

// ExpectFilePathParam3 sets up expected param filePath for Storage.GetFileMetadata
func (mmGetFileMetadata *mStorageMockGetFileMetadata) ExpectFilePathParam3(filePath string) *mStorageMockGetFileMetadata {
	if mmGetFileMetadata.mock.funcGetFileMetadata != nil {
		mmGetFileMetadata.mock.t.Fatalf("StorageMock.GetFileMetadata mock is already set by Set")
	}

	if mmGetFileMetadata.defaultExpectation == nil {
		mmGetFileMetadata.defaultExpectation = &StorageMockGetFileMetadataExpectation{}
	}

	if mmGetFileMetadata.defaultExpectation.params != nil {
		mmGetFileMetadata.mock.t.Fatalf("StorageMock.GetFileMetadata mock is already set by Expect")
	}

	if mmGetFileMetadata.defaultExpectation.paramPtrs == nil {
		mmGetFileMetadata.defaultExpectation.paramPtrs = &StorageMockGetFileMetadataParamPtrs{}
	}
	mmGetFileMetadata.defaultExpectation.paramPtrs.filePath = &filePath
	mmGetFileMetadata.defaultExpectation.expectationOrigins.originFilePath = minimock.CallerInfo(1)

	return mmGetFileMetadata
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetFileMetadata
func (mmGetFileMetadata *mStorageMockGetFileMetadata) Inspect(f func(ctx context.Context, bucket string, filePath string)) *mStorageMockGetFileMetadata {
	if mmGetFileMetadata.mock.inspectFuncGetFileMetadata != nil {
		mmGetFileMetadata.mock.t.Fatalf("Inspect function is already set for StorageMock.GetFileMetadata")
	}

	mmGetFileMetadata.mock.inspectFuncGetFileMetadata = f

	return mmGetFileMetadata
}

// Return sets up results that will be returned by Storage.GetFileMetadata
func (mmGetFileMetadata *mStorageMockGetFileMetadata) Return(op1 *minio.ObjectInfo, err error) *StorageMock {
	if mmGetFileMetadata.mock.funcGetFileMetadata != nil {
		mmGetFileMetadata.mock.t.Fatalf("StorageMock.GetFileMetadata mock is already set by Set")
	}

	if mmGetFileMetadata.defaultExpectation == nil {
		mmGetFileMetadata.defaultExpectation = &StorageMockGetFileMetadataExpectation{mock: mmGetFileMetadata.mock}
	}
	mmGetFileMetadata.defaultExpectation.results = &StorageMockGetFileMetadataResults{op1, err}
	mmGetFileMetadata.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetFileMetadata.mock
}

// Set uses given function f to mock the Storage.GetFileMetadata method
func (mmGetFileMetadata *mStorageMockGetFileMetadata) Set(f func(ctx context.Context, bucket string, filePath string) (op1 *minio.ObjectInfo, err error)) *StorageMock {
	if mmGetFileMetadata.defaultExpectation != nil {
		mmGetFileMetadata.mock.t.Fatalf("Default expectation is already set for the Storage.GetFileMetadata method")
	}

	if len(mmGetFileMetadata.expectations) > 0 {
		mmGetFileMetadata.mock.t.Fatalf("Some expectations are already set for the Storage.GetFileMetadata method")
	}

	mmGetFileMetadata.mock.funcGetFileMetadata = f
	mmGetFileMetadata.mock.funcGetFileMetadataOrigin = minimock.CallerInfo(1)
	return mmGetFileMetadata.mock
}

// When sets expectation for the Storage.GetFileMetadata which will trigger the result defined by the following
// Then helper
func (mmGetFileMetadata *mStorageMockGetFileMetadata) When(ctx context.Context, bucket string, filePath string) *StorageMockGetFileMetadataExpectation {
	if mmGetFileMetadata.mock.funcGetFileMetadata != nil {
		mmGetFileMetadata.mock.t.Fatalf("StorageMock.GetFileMetadata mock is already set by Set")
	}

	expectation := &StorageMockGetFileMetadataExpectation{
		mock:               mmGetFileMetadata.mock,
		params:             &StorageMockGetFileMetadataParams{ctx, bucket, filePath},
		expectationOrigins: StorageMockGetFileMetadataExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetFileMetadata.expectations = append(mmGetFileMetadata.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetFileMetadata return parameters for the expectation previously defined by the When method
func (e *StorageMockGetFileMetadataExpectation) Then(op1 *minio.ObjectInfo, err error) *StorageMock {
	e.results = &StorageMockGetFileMetadataResults{op1, err}
	return e.mock
}

// Times sets number of times Storage.GetFileMetadata should be invoked
func (mmGetFileMetadata *mStorageMockGetFileMetadata) Times(n uint64) *mStorageMockGetFileMetadata {
	if n == 0 {
		mmGetFileMetadata.mock.t.Fatalf("Times of StorageMock.GetFileMetadata mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFileMetadata.expectedInvocations, n)
	mmGetFileMetadata.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetFileMetadata
}

func (mmGetFileMetadata *mStorageMockGetFileMetadata) invocationsDone() bool {
	if len(mmGetFileMetadata.expectations) == 0 && mmGetFileMetadata.defaultExpectation == nil && mmGetFileMetadata.mock.funcGetFileMetadata == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFileMetadata.mock.afterGetFileMetadataCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFileMetadata.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFileMetadata implements mm_object.Storage
func (mmGetFileMetadata *StorageMock) GetFileMetadata(ctx context.Context, bucket string, filePath string) (op1 *minio.ObjectInfo, err error) {
	mm_atomic.AddUint64(&mmGetFileMetadata.beforeGetFileMetadataCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFileMetadata.afterGetFileMetadataCounter, 1)

	mmGetFileMetadata.t.Helper()

	if mmGetFileMetadata.inspectFuncGetFileMetadata != nil {
		mmGetFileMetadata.inspectFuncGetFileMetadata(ctx, bucket, filePath)
	}

	mm_params := StorageMockGetFileMetadataParams{ctx, bucket, filePath}

	// Record call args
	mmGetFileMetadata.GetFileMetadataMock.mutex.Lock()
	mmGetFileMetadata.GetFileMetadataMock.callArgs = append(mmGetFileMetadata.GetFileMetadataMock.callArgs, &mm_params)
	mmGetFileMetadata.GetFileMetadataMock.mutex.Unlock()

	for _, e := range mmGetFileMetadata.GetFileMetadataMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetFileMetadata.GetFileMetadataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFileMetadata.GetFileMetadataMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFileMetadata.GetFileMetadataMock.defaultExpectation.params
		mm_want_ptrs := mmGetFileMetadata.GetFileMetadataMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGetFileMetadataParams{ctx, bucket, filePath}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFileMetadata.t.Errorf("StorageMock.GetFileMetadata got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFileMetadata.GetFileMetadataMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.bucket != nil && !minimock.Equal(*mm_want_ptrs.bucket, mm_got.bucket) {
				mmGetFileMetadata.t.Errorf("StorageMock.GetFileMetadata got unexpected parameter bucket, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFileMetadata.GetFileMetadataMock.defaultExpectation.expectationOrigins.originBucket, *mm_want_ptrs.bucket, mm_got.bucket, minimock.Diff(*mm_want_ptrs.bucket, mm_got.bucket))
			}

			if mm_want_ptrs.filePath != nil && !minimock.Equal(*mm_want_ptrs.filePath, mm_got.filePath) {
				mmGetFileMetadata.t.Errorf("StorageMock.GetFileMetadata got unexpected parameter filePath, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFileMetadata.GetFileMetadataMock.defaultExpectation.expectationOrigins.originFilePath, *mm_want_ptrs.filePath, mm_got.filePath, minimock.Diff(*mm_want_ptrs.filePath, mm_got.filePath))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFileMetadata.t.Errorf("StorageMock.GetFileMetadata got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetFileMetadata.GetFileMetadataMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFileMetadata.GetFileMetadataMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFileMetadata.t.Fatal("No results are set for the StorageMock.GetFileMetadata")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetFileMetadata.funcGetFileMetadata != nil {
		return mmGetFileMetadata.funcGetFileMetadata(ctx, bucket, filePath)
	}
	mmGetFileMetadata.t.Fatalf("Unexpected call to StorageMock.GetFileMetadata. %v %v %v", ctx, bucket, filePath)
	return
}

// GetFileMetadataAfterCounter returns a count of finished StorageMock.GetFileMetadata invocations
func (mmGetFileMetadata *StorageMock) GetFileMetadataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFileMetadata.afterGetFileMetadataCounter)
}

// GetFileMetadataBeforeCounter returns a count of StorageMock.GetFileMetadata invocations
func (mmGetFileMetadata *StorageMock) GetFileMetadataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFileMetadata.beforeGetFileMetadataCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetFileMetadata.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFileMetadata *mStorageMockGetFileMetadata) Calls() []*StorageMockGetFileMetadataParams {
	mmGetFileMetadata.mutex.RLock()

	argCopy := make([]*StorageMockGetFileMetadataParams, len(mmGetFileMetadata.callArgs))
	copy(argCopy, mmGetFileMetadata.callArgs)

	mmGetFileMetadata.mutex.RUnlock()

	return argCopy
}

// MinimockGetFileMetadataDone returns true if the count of the GetFileMetadata invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetFileMetadataDone() bool {
	if m.GetFileMetadataMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFileMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFileMetadataMock.invocationsDone()
}

// MinimockGetFileMetadataInspect logs each unmet expectation
func (m *StorageMock) MinimockGetFileMetadataInspect() {
	for _, e := range m.GetFileMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetFileMetadata at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetFileMetadataCounter := mm_atomic.LoadUint64(&m.afterGetFileMetadataCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFileMetadataMock.defaultExpectation != nil && afterGetFileMetadataCounter < 1 {
		if m.GetFileMetadataMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GetFileMetadata at\n%s", m.GetFileMetadataMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GetFileMetadata at\n%s with params: %#v", m.GetFileMetadataMock.defaultExpectation.expectationOrigins.origin, *m.GetFileMetadataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFileMetadata != nil && afterGetFileMetadataCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetFileMetadata at\n%s", m.funcGetFileMetadataOrigin)
	}

	if !m.GetFileMetadataMock.invocationsDone() && afterGetFileMetadataCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetFileMetadata at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetFileMetadataMock.expectedInvocations), m.GetFileMetadataMock.expectedInvocationsOrigin, afterGetFileMetadataCounter)
	}
}

type mStorageMockGetPresignedURLForDownload struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetPresignedURLForDownloadExpectation
	expectations       []*StorageMockGetPresignedURLForDownloadExpectation

	callArgs []*StorageMockGetPresignedURLForDownloadParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGetPresignedURLForDownloadExpectation specifies expectation struct of the Storage.GetPresignedURLForDownload
type StorageMockGetPresignedURLForDownloadExpectation struct {
	mock               *StorageMock
	params             *StorageMockGetPresignedURLForDownloadParams
	paramPtrs          *StorageMockGetPresignedURLForDownloadParamPtrs
	expectationOrigins StorageMockGetPresignedURLForDownloadExpectationOrigins
	results            *StorageMockGetPresignedURLForDownloadResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockGetPresignedURLForDownloadParams contains parameters of the Storage.GetPresignedURLForDownload
type StorageMockGetPresignedURLForDownloadParams struct {
	ctx         context.Context
	bucket      string
	objectPath  string
	filename    string
	contentType string
	expiration  time.Duration
}

// StorageMockGetPresignedURLForDownloadParamPtrs contains pointers to parameters of the Storage.GetPresignedURLForDownload
type StorageMockGetPresignedURLForDownloadParamPtrs struct {
	ctx         *context.Context
	bucket      *string
	objectPath  *string
	filename    *string
	contentType *string
	expiration  *time.Duration
}

// StorageMockGetPresignedURLForDownloadResults contains results of the Storage.GetPresignedURLForDownload
type StorageMockGetPresignedURLForDownloadResults struct {
	up1 *url.URL
	err error
}

// StorageMockGetPresignedURLForDownloadOrigins contains origins of expectations of the Storage.GetPresignedURLForDownload
type StorageMockGetPresignedURLForDownloadExpectationOrigins struct {
	origin            string
	originCtx         string
	originBucket      string
	originObjectPath  string
	originFilename    string
	originContentType string
	originExpiration  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPresignedURLForDownload *mStorageMockGetPresignedURLForDownload) Optional() *mStorageMockGetPresignedURLForDownload {
	mmGetPresignedURLForDownload.optional = true
	return mmGetPresignedURLForDownload
}

// Expect sets up expected params for Storage.GetPresignedURLForDownload
func (mmGetPresignedURLForDownload *mStorageMockGetPresignedURLForDownload) Expect(ctx context.Context, bucket string, objectPath string, filename string, contentType string, expiration time.Duration) *mStorageMockGetPresignedURLForDownload {
	if mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("StorageMock.GetPresignedURLForDownload mock is already set by Set")
	}

	if mmGetPresignedURLForDownload.defaultExpectation == nil {
		mmGetPresignedURLForDownload.defaultExpectation = &StorageMockGetPresignedURLForDownloadExpectation{}
	}

	if mmGetPresignedURLForDownload.defaultExpectation.paramPtrs != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("StorageMock.GetPresignedURLForDownload mock is already set by ExpectParams functions")
	}

	mmGetPresignedURLForDownload.defaultExpectation.params = &StorageMockGetPresignedURLForDownloadParams{ctx, bucket, objectPath, filename, contentType, expiration}
	mmGetPresignedURLForDownload.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPresignedURLForDownload.expectations {
		if minimock.Equal(e.params, mmGetPresignedURLForDownload.defaultExpectation.params) {
			mmGetPresignedURLForDownload.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPresignedURLForDownload.defaultExpectation.params)
		}
	}

	return mmGetPresignedURLForDownload
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetPresignedURLForDownload
func (mmGetPresignedURLForDownload *mStorageMockGetPresignedURLForDownload) ExpectCtxParam1(ctx context.Context) *mStorageMockGetPresignedURLForDownload {
	if mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("StorageMock.GetPresignedURLForDownload mock is already set by Set")
	}

	if mmGetPresignedURLForDownload.defaultExpectation == nil {
		mmGetPresignedURLForDownload.defaultExpectation = &StorageMockGetPresignedURLForDownloadExpectation{}
	}

	if mmGetPresignedURLForDownload.defaultExpectation.params != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("StorageMock.GetPresignedURLForDownload mock is already set by Expect")
	}

	if mmGetPresignedURLForDownload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForDownload.defaultExpectation.paramPtrs = &StorageMockGetPresignedURLForDownloadParamPtrs{}
	}
	mmGetPresignedURLForDownload.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPresignedURLForDownload.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPresignedURLForDownload
}

// ExpectBucketParam2 sets up expected param bucket for Storage.GetPresignedURLForDownload
func (mmGetPresignedURLForDownload *mStorageMockGetPresignedURLForDownload) ExpectBucketParam2(bucket string) *mStorageMockGetPresignedURLForDownload {
	if mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("StorageMock.GetPresignedURLForDownload mock is already set by Set")
	}

	if mmGetPresignedURLForDownload.defaultExpectation == nil {
		mmGetPresignedURLForDownload.defaultExpectation = &StorageMockGetPresignedURLForDownloadExpectation{}
	}

	if mmGetPresignedURLForDownload.defaultExpectation.params != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("StorageMock.GetPresignedURLForDownload mock is already set by Expect")
	}

	if mmGetPresignedURLForDownload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForDownload.defaultExpectation.paramPtrs = &StorageMockGetPresignedURLForDownloadParamPtrs{}
	}
	mmGetPresignedURLForDownload.defaultExpectation.paramPtrs.bucket = &bucket
	mmGetPresignedURLForDownload.defaultExpectation.expectationOrigins.originBucket = minimock.CallerInfo(1)

	return mmGetPresignedURLForDownload
}

// ExpectObjectPathParam3 sets up expected param objectPath for Storage.GetPresignedURLForDownload
func (mmGetPresignedURLForDownload *mStorageMockGetPresignedURLForDownload) ExpectObjectPathParam3(objectPath string) *mStorageMockGetPresignedURLForDownload {
	if mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("StorageMock.GetPresignedURLForDownload mock is already set by Set")
	}

	if mmGetPresignedURLForDownload.defaultExpectation == nil {
		mmGetPresignedURLForDownload.defaultExpectation = &StorageMockGetPresignedURLForDownloadExpectation{}
	}

	if mmGetPresignedURLForDownload.defaultExpectation.params != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("StorageMock.GetPresignedURLForDownload mock is already set by Expect")
	}

	if mmGetPresignedURLForDownload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForDownload.defaultExpectation.paramPtrs = &StorageMockGetPresignedURLForDownloadParamPtrs{}
	}
	mmGetPresignedURLForDownload.defaultExpectation.paramPtrs.objectPath = &objectPath
	mmGetPresignedURLForDownload.defaultExpectation.expectationOrigins.originObjectPath = minimock.CallerInfo(1)

	return mmGetPresignedURLForDownload
}

// ExpectFilenameParam4 sets up expected param filename for Storage.GetPresignedURLForDownload
func (mmGetPresignedURLForDownload *mStorageMockGetPresignedURLForDownload) ExpectFilenameParam4(filename string) *mStorageMockGetPresignedURLForDownload {
	if mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("StorageMock.GetPresignedURLForDownload mock is already set by Set")
	}

	if mmGetPresignedURLForDownload.defaultExpectation == nil {
		mmGetPresignedURLForDownload.defaultExpectation = &StorageMockGetPresignedURLForDownloadExpectation{}
	}

	if mmGetPresignedURLForDownload.defaultExpectation.params != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("StorageMock.GetPresignedURLForDownload mock is already set by Expect")
	}

	if mmGetPresignedURLForDownload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForDownload.defaultExpectation.paramPtrs = &StorageMockGetPresignedURLForDownloadParamPtrs{}
	}
	mmGetPresignedURLForDownload.defaultExpectation.paramPtrs.filename = &filename
	mmGetPresignedURLForDownload.defaultExpectation.expectationOrigins.originFilename = minimock.CallerInfo(1)

	return mmGetPresignedURLForDownload
}

// ExpectContentTypeParam5 sets up expected param contentType for Storage.GetPresignedURLForDownload
func (mmGetPresignedURLForDownload *mStorageMockGetPresignedURLForDownload) ExpectContentTypeParam5(contentType string) *mStorageMockGetPresignedURLForDownload {
	if mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("StorageMock.GetPresignedURLForDownload mock is already set by Set")
	}

	if mmGetPresignedURLForDownload.defaultExpectation == nil {
		mmGetPresignedURLForDownload.defaultExpectation = &StorageMockGetPresignedURLForDownloadExpectation{}
	}

	if mmGetPresignedURLForDownload.defaultExpectation.params != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("StorageMock.GetPresignedURLForDownload mock is already set by Expect")
	}

	if mmGetPresignedURLForDownload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForDownload.defaultExpectation.paramPtrs = &StorageMockGetPresignedURLForDownloadParamPtrs{}
	}
	mmGetPresignedURLForDownload.defaultExpectation.paramPtrs.contentType = &contentType
	mmGetPresignedURLForDownload.defaultExpectation.expectationOrigins.originContentType = minimock.CallerInfo(1)

	return mmGetPresignedURLForDownload
}

// ExpectExpirationParam6 sets up expected param expiration for Storage.GetPresignedURLForDownload
func (mmGetPresignedURLForDownload *mStorageMockGetPresignedURLForDownload) ExpectExpirationParam6(expiration time.Duration) *mStorageMockGetPresignedURLForDownload {
	if mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("StorageMock.GetPresignedURLForDownload mock is already set by Set")
	}

	if mmGetPresignedURLForDownload.defaultExpectation == nil {
		mmGetPresignedURLForDownload.defaultExpectation = &StorageMockGetPresignedURLForDownloadExpectation{}
	}

	if mmGetPresignedURLForDownload.defaultExpectation.params != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("StorageMock.GetPresignedURLForDownload mock is already set by Expect")
	}

	if mmGetPresignedURLForDownload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForDownload.defaultExpectation.paramPtrs = &StorageMockGetPresignedURLForDownloadParamPtrs{}
	}
	mmGetPresignedURLForDownload.defaultExpectation.paramPtrs.expiration = &expiration
	mmGetPresignedURLForDownload.defaultExpectation.expectationOrigins.originExpiration = minimock.CallerInfo(1)

	return mmGetPresignedURLForDownload
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetPresignedURLForDownload
func (mmGetPresignedURLForDownload *mStorageMockGetPresignedURLForDownload) Inspect(f func(ctx context.Context, bucket string, objectPath string, filename string, contentType string, expiration time.Duration)) *mStorageMockGetPresignedURLForDownload {
	if mmGetPresignedURLForDownload.mock.inspectFuncGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("Inspect function is already set for StorageMock.GetPresignedURLForDownload")
	}

	mmGetPresignedURLForDownload.mock.inspectFuncGetPresignedURLForDownload = f

	return mmGetPresignedURLForDownload
}

// Return sets up results that will be returned by Storage.GetPresignedURLForDownload
func (mmGetPresignedURLForDownload *mStorageMockGetPresignedURLForDownload) Return(up1 *url.URL, err error) *StorageMock {
	if mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("StorageMock.GetPresignedURLForDownload mock is already set by Set")
	}

	if mmGetPresignedURLForDownload.defaultExpectation == nil {
		mmGetPresignedURLForDownload.defaultExpectation = &StorageMockGetPresignedURLForDownloadExpectation{mock: mmGetPresignedURLForDownload.mock}
	}
	mmGetPresignedURLForDownload.defaultExpectation.results = &StorageMockGetPresignedURLForDownloadResults{up1, err}
	mmGetPresignedURLForDownload.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPresignedURLForDownload.mock
}

// Set uses given function f to mock the Storage.GetPresignedURLForDownload method
func (mmGetPresignedURLForDownload *mStorageMockGetPresignedURLForDownload) Set(f func(ctx context.Context, bucket string, objectPath string, filename string, contentType string, expiration time.Duration) (up1 *url.URL, err error)) *StorageMock {
	if mmGetPresignedURLForDownload.defaultExpectation != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("Default expectation is already set for the Storage.GetPresignedURLForDownload method")
	}

	if len(mmGetPresignedURLForDownload.expectations) > 0 {
		mmGetPresignedURLForDownload.mock.t.Fatalf("Some expectations are already set for the Storage.GetPresignedURLForDownload method")
	}

	mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload = f
	mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownloadOrigin = minimock.CallerInfo(1)
	return mmGetPresignedURLForDownload.mock
}

// When sets expectation for the Storage.GetPresignedURLForDownload which will trigger the result defined by the following
// Then helper
func (mmGetPresignedURLForDownload *mStorageMockGetPresignedURLForDownload) When(ctx context.Context, bucket string, objectPath string, filename string, contentType string, expiration time.Duration) *StorageMockGetPresignedURLForDownloadExpectation {
	if mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("StorageMock.GetPresignedURLForDownload mock is already set by Set")
	}

	expectation := &StorageMockGetPresignedURLForDownloadExpectation{
		mock:               mmGetPresignedURLForDownload.mock,
		params:             &StorageMockGetPresignedURLForDownloadParams{ctx, bucket, objectPath, filename, contentType, expiration},
		expectationOrigins: StorageMockGetPresignedURLForDownloadExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPresignedURLForDownload.expectations = append(mmGetPresignedURLForDownload.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetPresignedURLForDownload return parameters for the expectation previously defined by the When method
func (e *StorageMockGetPresignedURLForDownloadExpectation) Then(up1 *url.URL, err error) *StorageMock {
	e.results = &StorageMockGetPresignedURLForDownloadResults{up1, err}
	return e.mock
}

// Times sets number of times Storage.GetPresignedURLForDownload should be invoked
func (mmGetPresignedURLForDownload *mStorageMockGetPresignedURLForDownload) Times(n uint64) *mStorageMockGetPresignedURLForDownload {
	if n == 0 {
		mmGetPresignedURLForDownload.mock.t.Fatalf("Times of StorageMock.GetPresignedURLForDownload mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPresignedURLForDownload.expectedInvocations, n)
	mmGetPresignedURLForDownload.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPresignedURLForDownload
}

func (mmGetPresignedURLForDownload *mStorageMockGetPresignedURLForDownload) invocationsDone() bool {
	if len(mmGetPresignedURLForDownload.expectations) == 0 && mmGetPresignedURLForDownload.defaultExpectation == nil && mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPresignedURLForDownload.mock.afterGetPresignedURLForDownloadCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPresignedURLForDownload.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPresignedURLForDownload implements mm_object.Storage
func (mmGetPresignedURLForDownload *StorageMock) GetPresignedURLForDownload(ctx context.Context, bucket string, objectPath string, filename string, contentType string, expiration time.Duration) (up1 *url.URL, err error) {
	mm_atomic.AddUint64(&mmGetPresignedURLForDownload.beforeGetPresignedURLForDownloadCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPresignedURLForDownload.afterGetPresignedURLForDownloadCounter, 1)

	mmGetPresignedURLForDownload.t.Helper()

	if mmGetPresignedURLForDownload.inspectFuncGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.inspectFuncGetPresignedURLForDownload(ctx, bucket, objectPath, filename, contentType, expiration)
	}

	mm_params := StorageMockGetPresignedURLForDownloadParams{ctx, bucket, objectPath, filename, contentType, expiration}

	// Record call args
	mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.mutex.Lock()
	mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.callArgs = append(mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.callArgs, &mm_params)
	mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.mutex.Unlock()

	for _, e := range mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.params
		mm_want_ptrs := mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGetPresignedURLForDownloadParams{ctx, bucket, objectPath, filename, contentType, expiration}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPresignedURLForDownload.t.Errorf("StorageMock.GetPresignedURLForDownload got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.bucket != nil && !minimock.Equal(*mm_want_ptrs.bucket, mm_got.bucket) {
				mmGetPresignedURLForDownload.t.Errorf("StorageMock.GetPresignedURLForDownload got unexpected parameter bucket, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.expectationOrigins.originBucket, *mm_want_ptrs.bucket, mm_got.bucket, minimock.Diff(*mm_want_ptrs.bucket, mm_got.bucket))
			}

			if mm_want_ptrs.objectPath != nil && !minimock.Equal(*mm_want_ptrs.objectPath, mm_got.objectPath) {
				mmGetPresignedURLForDownload.t.Errorf("StorageMock.GetPresignedURLForDownload got unexpected parameter objectPath, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.expectationOrigins.originObjectPath, *mm_want_ptrs.objectPath, mm_got.objectPath, minimock.Diff(*mm_want_ptrs.objectPath, mm_got.objectPath))
			}

			if mm_want_ptrs.filename != nil && !minimock.Equal(*mm_want_ptrs.filename, mm_got.filename) {
				mmGetPresignedURLForDownload.t.Errorf("StorageMock.GetPresignedURLForDownload got unexpected parameter filename, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.expectationOrigins.originFilename, *mm_want_ptrs.filename, mm_got.filename, minimock.Diff(*mm_want_ptrs.filename, mm_got.filename))
			}

			if mm_want_ptrs.contentType != nil && !minimock.Equal(*mm_want_ptrs.contentType, mm_got.contentType) {
				mmGetPresignedURLForDownload.t.Errorf("StorageMock.GetPresignedURLForDownload got unexpected parameter contentType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.expectationOrigins.originContentType, *mm_want_ptrs.contentType, mm_got.contentType, minimock.Diff(*mm_want_ptrs.contentType, mm_got.contentType))
			}

			if mm_want_ptrs.expiration != nil && !minimock.Equal(*mm_want_ptrs.expiration, mm_got.expiration) {
				mmGetPresignedURLForDownload.t.Errorf("StorageMock.GetPresignedURLForDownload got unexpected parameter expiration, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.expectationOrigins.originExpiration, *mm_want_ptrs.expiration, mm_got.expiration, minimock.Diff(*mm_want_ptrs.expiration, mm_got.expiration))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPresignedURLForDownload.t.Errorf("StorageMock.GetPresignedURLForDownload got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPresignedURLForDownload.t.Fatal("No results are set for the StorageMock.GetPresignedURLForDownload")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetPresignedURLForDownload.funcGetPresignedURLForDownload != nil {
		return mmGetPresignedURLForDownload.funcGetPresignedURLForDownload(ctx, bucket, objectPath, filename, contentType, expiration)
	}
	mmGetPresignedURLForDownload.t.Fatalf("Unexpected call to StorageMock.GetPresignedURLForDownload. %v %v %v %v %v %v", ctx, bucket, objectPath, filename, contentType, expiration)
	return
}

// GetPresignedURLForDownloadAfterCounter returns a count of finished StorageMock.GetPresignedURLForDownload invocations
func (mmGetPresignedURLForDownload *StorageMock) GetPresignedURLForDownloadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPresignedURLForDownload.afterGetPresignedURLForDownloadCounter)
}

// GetPresignedURLForDownloadBeforeCounter returns a count of StorageMock.GetPresignedURLForDownload invocations
func (mmGetPresignedURLForDownload *StorageMock) GetPresignedURLForDownloadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPresignedURLForDownload.beforeGetPresignedURLForDownloadCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetPresignedURLForDownload.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPresignedURLForDownload *mStorageMockGetPresignedURLForDownload) Calls() []*StorageMockGetPresignedURLForDownloadParams {
	mmGetPresignedURLForDownload.mutex.RLock()

	argCopy := make([]*StorageMockGetPresignedURLForDownloadParams, len(mmGetPresignedURLForDownload.callArgs))
	copy(argCopy, mmGetPresignedURLForDownload.callArgs)

	mmGetPresignedURLForDownload.mutex.RUnlock()

	return argCopy
}

// MinimockGetPresignedURLForDownloadDone returns true if the count of the GetPresignedURLForDownload invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetPresignedURLForDownloadDone() bool {
	if m.GetPresignedURLForDownloadMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPresignedURLForDownloadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPresignedURLForDownloadMock.invocationsDone()
}

// MinimockGetPresignedURLForDownloadInspect logs each unmet expectation
func (m *StorageMock) MinimockGetPresignedURLForDownloadInspect() {
	for _, e := range m.GetPresignedURLForDownloadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetPresignedURLForDownload at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPresignedURLForDownloadCounter := mm_atomic.LoadUint64(&m.afterGetPresignedURLForDownloadCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPresignedURLForDownloadMock.defaultExpectation != nil && afterGetPresignedURLForDownloadCounter < 1 {
		if m.GetPresignedURLForDownloadMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GetPresignedURLForDownload at\n%s", m.GetPresignedURLForDownloadMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GetPresignedURLForDownload at\n%s with params: %#v", m.GetPresignedURLForDownloadMock.defaultExpectation.expectationOrigins.origin, *m.GetPresignedURLForDownloadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPresignedURLForDownload != nil && afterGetPresignedURLForDownloadCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetPresignedURLForDownload at\n%s", m.funcGetPresignedURLForDownloadOrigin)
	}

	if !m.GetPresignedURLForDownloadMock.invocationsDone() && afterGetPresignedURLForDownloadCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetPresignedURLForDownload at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPresignedURLForDownloadMock.expectedInvocations), m.GetPresignedURLForDownloadMock.expectedInvocationsOrigin, afterGetPresignedURLForDownloadCounter)
	}
}

type mStorageMockGetPresignedURLForUpload struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetPresignedURLForUploadExpectation
	expectations       []*StorageMockGetPresignedURLForUploadExpectation

	callArgs []*StorageMockGetPresignedURLForUploadParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGetPresignedURLForUploadExpectation specifies expectation struct of the Storage.GetPresignedURLForUpload
type StorageMockGetPresignedURLForUploadExpectation struct {
	mock               *StorageMock
	params             *StorageMockGetPresignedURLForUploadParams
	paramPtrs          *StorageMockGetPresignedURLForUploadParamPtrs
	expectationOrigins StorageMockGetPresignedURLForUploadExpectationOrigins
	results            *StorageMockGetPresignedURLForUploadResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockGetPresignedURLForUploadParams contains parameters of the Storage.GetPresignedURLForUpload
type StorageMockGetPresignedURLForUploadParams struct {
	ctx           context.Context
	namespaceUUID types.NamespaceUIDType
	objectUUID    types.ObjectUIDType
	filename      string
	urlExpiration time.Duration
}

// StorageMockGetPresignedURLForUploadParamPtrs contains pointers to parameters of the Storage.GetPresignedURLForUpload
type StorageMockGetPresignedURLForUploadParamPtrs struct {
	ctx           *context.Context
	namespaceUUID *types.NamespaceUIDType
	objectUUID    *types.ObjectUIDType
	filename      *string
	urlExpiration *time.Duration
}

// StorageMockGetPresignedURLForUploadResults contains results of the Storage.GetPresignedURLForUpload
type StorageMockGetPresignedURLForUploadResults struct {
	up1 *url.URL
	err error
}

// StorageMockGetPresignedURLForUploadOrigins contains origins of expectations of the Storage.GetPresignedURLForUpload
type StorageMockGetPresignedURLForUploadExpectationOrigins struct {
	origin              string
	originCtx           string
	originNamespaceUUID string
	originObjectUUID    string
	originFilename      string
	originUrlExpiration string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPresignedURLForUpload *mStorageMockGetPresignedURLForUpload) Optional() *mStorageMockGetPresignedURLForUpload {
	mmGetPresignedURLForUpload.optional = true
	return mmGetPresignedURLForUpload
}

// Expect sets up expected params for Storage.GetPresignedURLForUpload
func (mmGetPresignedURLForUpload *mStorageMockGetPresignedURLForUpload) Expect(ctx context.Context, namespaceUUID types.NamespaceUIDType, objectUUID types.ObjectUIDType, filename string, urlExpiration time.Duration) *mStorageMockGetPresignedURLForUpload {
	if mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("StorageMock.GetPresignedURLForUpload mock is already set by Set")
	}

	if mmGetPresignedURLForUpload.defaultExpectation == nil {
		mmGetPresignedURLForUpload.defaultExpectation = &StorageMockGetPresignedURLForUploadExpectation{}
	}

	if mmGetPresignedURLForUpload.defaultExpectation.paramPtrs != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("StorageMock.GetPresignedURLForUpload mock is already set by ExpectParams functions")
	}

	mmGetPresignedURLForUpload.defaultExpectation.params = &StorageMockGetPresignedURLForUploadParams{ctx, namespaceUUID, objectUUID, filename, urlExpiration}
	mmGetPresignedURLForUpload.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPresignedURLForUpload.expectations {
		if minimock.Equal(e.params, mmGetPresignedURLForUpload.defaultExpectation.params) {
			mmGetPresignedURLForUpload.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPresignedURLForUpload.defaultExpectation.params)
		}
	}

	return mmGetPresignedURLForUpload
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetPresignedURLForUpload
func (mmGetPresignedURLForUpload *mStorageMockGetPresignedURLForUpload) ExpectCtxParam1(ctx context.Context) *mStorageMockGetPresignedURLForUpload {
	if mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("StorageMock.GetPresignedURLForUpload mock is already set by Set")
	}

	if mmGetPresignedURLForUpload.defaultExpectation == nil {
		mmGetPresignedURLForUpload.defaultExpectation = &StorageMockGetPresignedURLForUploadExpectation{}
	}

	if mmGetPresignedURLForUpload.defaultExpectation.params != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("StorageMock.GetPresignedURLForUpload mock is already set by Expect")
	}

	if mmGetPresignedURLForUpload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForUpload.defaultExpectation.paramPtrs = &StorageMockGetPresignedURLForUploadParamPtrs{}
	}
	mmGetPresignedURLForUpload.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPresignedURLForUpload.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPresignedURLForUpload
}

// ExpectNamespaceUUIDParam2 sets up expected param namespaceUUID for Storage.GetPresignedURLForUpload
func (mmGetPresignedURLForUpload *mStorageMockGetPresignedURLForUpload) ExpectNamespaceUUIDParam2(namespaceUUID types.NamespaceUIDType) *mStorageMockGetPresignedURLForUpload {
	if mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("StorageMock.GetPresignedURLForUpload mock is already set by Set")
	}

	if mmGetPresignedURLForUpload.defaultExpectation == nil {
		mmGetPresignedURLForUpload.defaultExpectation = &StorageMockGetPresignedURLForUploadExpectation{}
	}

	if mmGetPresignedURLForUpload.defaultExpectation.params != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("StorageMock.GetPresignedURLForUpload mock is already set by Expect")
	}

	if mmGetPresignedURLForUpload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForUpload.defaultExpectation.paramPtrs = &StorageMockGetPresignedURLForUploadParamPtrs{}
	}
	mmGetPresignedURLForUpload.defaultExpectation.paramPtrs.namespaceUUID = &namespaceUUID
	mmGetPresignedURLForUpload.defaultExpectation.expectationOrigins.originNamespaceUUID = minimock.CallerInfo(1)

	return mmGetPresignedURLForUpload
}

// ExpectObjectUUIDParam3 sets up expected param objectUUID for Storage.GetPresignedURLForUpload
func (mmGetPresignedURLForUpload *mStorageMockGetPresignedURLForUpload) ExpectObjectUUIDParam3(objectUUID types.ObjectUIDType) *mStorageMockGetPresignedURLForUpload {
	if mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("StorageMock.GetPresignedURLForUpload mock is already set by Set")
	}

	if mmGetPresignedURLForUpload.defaultExpectation == nil {
		mmGetPresignedURLForUpload.defaultExpectation = &StorageMockGetPresignedURLForUploadExpectation{}
	}

	if mmGetPresignedURLForUpload.defaultExpectation.params != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("StorageMock.GetPresignedURLForUpload mock is already set by Expect")
	}

	if mmGetPresignedURLForUpload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForUpload.defaultExpectation.paramPtrs = &StorageMockGetPresignedURLForUploadParamPtrs{}
	}
	mmGetPresignedURLForUpload.defaultExpectation.paramPtrs.objectUUID = &objectUUID
	mmGetPresignedURLForUpload.defaultExpectation.expectationOrigins.originObjectUUID = minimock.CallerInfo(1)

	return mmGetPresignedURLForUpload
}

// ExpectFilenameParam4 sets up expected param filename for Storage.GetPresignedURLForUpload
func (mmGetPresignedURLForUpload *mStorageMockGetPresignedURLForUpload) ExpectFilenameParam4(filename string) *mStorageMockGetPresignedURLForUpload {
	if mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("StorageMock.GetPresignedURLForUpload mock is already set by Set")
	}

	if mmGetPresignedURLForUpload.defaultExpectation == nil {
		mmGetPresignedURLForUpload.defaultExpectation = &StorageMockGetPresignedURLForUploadExpectation{}
	}

	if mmGetPresignedURLForUpload.defaultExpectation.params != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("StorageMock.GetPresignedURLForUpload mock is already set by Expect")
	}

	if mmGetPresignedURLForUpload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForUpload.defaultExpectation.paramPtrs = &StorageMockGetPresignedURLForUploadParamPtrs{}
	}
	mmGetPresignedURLForUpload.defaultExpectation.paramPtrs.filename = &filename
	mmGetPresignedURLForUpload.defaultExpectation.expectationOrigins.originFilename = minimock.CallerInfo(1)

	return mmGetPresignedURLForUpload
}

// ExpectUrlExpirationParam5 sets up expected param urlExpiration for Storage.GetPresignedURLForUpload
func (mmGetPresignedURLForUpload *mStorageMockGetPresignedURLForUpload) ExpectUrlExpirationParam5(urlExpiration time.Duration) *mStorageMockGetPresignedURLForUpload {
	if mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("StorageMock.GetPresignedURLForUpload mock is already set by Set")
	}

	if mmGetPresignedURLForUpload.defaultExpectation == nil {
		mmGetPresignedURLForUpload.defaultExpectation = &StorageMockGetPresignedURLForUploadExpectation{}
	}

	if mmGetPresignedURLForUpload.defaultExpectation.params != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("StorageMock.GetPresignedURLForUpload mock is already set by Expect")
	}

	if mmGetPresignedURLForUpload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForUpload.defaultExpectation.paramPtrs = &StorageMockGetPresignedURLForUploadParamPtrs{}
	}
	mmGetPresignedURLForUpload.defaultExpectation.paramPtrs.urlExpiration = &urlExpiration
	mmGetPresignedURLForUpload.defaultExpectation.expectationOrigins.originUrlExpiration = minimock.CallerInfo(1)

	return mmGetPresignedURLForUpload
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetPresignedURLForUpload
func (mmGetPresignedURLForUpload *mStorageMockGetPresignedURLForUpload) Inspect(f func(ctx context.Context, namespaceUUID types.NamespaceUIDType, objectUUID types.ObjectUIDType, filename string, urlExpiration time.Duration)) *mStorageMockGetPresignedURLForUpload {
	if mmGetPresignedURLForUpload.mock.inspectFuncGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("Inspect function is already set for StorageMock.GetPresignedURLForUpload")
	}

	mmGetPresignedURLForUpload.mock.inspectFuncGetPresignedURLForUpload = f

	return mmGetPresignedURLForUpload
}

// Return sets up results that will be returned by Storage.GetPresignedURLForUpload
func (mmGetPresignedURLForUpload *mStorageMockGetPresignedURLForUpload) Return(up1 *url.URL, err error) *StorageMock {
	if mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("StorageMock.GetPresignedURLForUpload mock is already set by Set")
	}

	if mmGetPresignedURLForUpload.defaultExpectation == nil {
		mmGetPresignedURLForUpload.defaultExpectation = &StorageMockGetPresignedURLForUploadExpectation{mock: mmGetPresignedURLForUpload.mock}
	}
	mmGetPresignedURLForUpload.defaultExpectation.results = &StorageMockGetPresignedURLForUploadResults{up1, err}
	mmGetPresignedURLForUpload.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPresignedURLForUpload.mock
}

// Set uses given function f to mock the Storage.GetPresignedURLForUpload method
func (mmGetPresignedURLForUpload *mStorageMockGetPresignedURLForUpload) Set(f func(ctx context.Context, namespaceUUID types.NamespaceUIDType, objectUUID types.ObjectUIDType, filename string, urlExpiration time.Duration) (up1 *url.URL, err error)) *StorageMock {
	if mmGetPresignedURLForUpload.defaultExpectation != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("Default expectation is already set for the Storage.GetPresignedURLForUpload method")
	}

	if len(mmGetPresignedURLForUpload.expectations) > 0 {
		mmGetPresignedURLForUpload.mock.t.Fatalf("Some expectations are already set for the Storage.GetPresignedURLForUpload method")
	}

	mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload = f
	mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUploadOrigin = minimock.CallerInfo(1)
	return mmGetPresignedURLForUpload.mock
}

// When sets expectation for the Storage.GetPresignedURLForUpload which will trigger the result defined by the following
// Then helper
func (mmGetPresignedURLForUpload *mStorageMockGetPresignedURLForUpload) When(ctx context.Context, namespaceUUID types.NamespaceUIDType, objectUUID types.ObjectUIDType, filename string, urlExpiration time.Duration) *StorageMockGetPresignedURLForUploadExpectation {
	if mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("StorageMock.GetPresignedURLForUpload mock is already set by Set")
	}

	expectation := &StorageMockGetPresignedURLForUploadExpectation{
		mock:               mmGetPresignedURLForUpload.mock,
		params:             &StorageMockGetPresignedURLForUploadParams{ctx, namespaceUUID, objectUUID, filename, urlExpiration},
		expectationOrigins: StorageMockGetPresignedURLForUploadExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPresignedURLForUpload.expectations = append(mmGetPresignedURLForUpload.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetPresignedURLForUpload return parameters for the expectation previously defined by the When method
func (e *StorageMockGetPresignedURLForUploadExpectation) Then(up1 *url.URL, err error) *StorageMock {
	e.results = &StorageMockGetPresignedURLForUploadResults{up1, err}
	return e.mock
}

// Times sets number of times Storage.GetPresignedURLForUpload should be invoked
func (mmGetPresignedURLForUpload *mStorageMockGetPresignedURLForUpload) Times(n uint64) *mStorageMockGetPresignedURLForUpload {
	if n == 0 {
		mmGetPresignedURLForUpload.mock.t.Fatalf("Times of StorageMock.GetPresignedURLForUpload mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPresignedURLForUpload.expectedInvocations, n)
	mmGetPresignedURLForUpload.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPresignedURLForUpload
}

func (mmGetPresignedURLForUpload *mStorageMockGetPresignedURLForUpload) invocationsDone() bool {
	if len(mmGetPresignedURLForUpload.expectations) == 0 && mmGetPresignedURLForUpload.defaultExpectation == nil && mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPresignedURLForUpload.mock.afterGetPresignedURLForUploadCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPresignedURLForUpload.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPresignedURLForUpload implements mm_object.Storage
func (mmGetPresignedURLForUpload *StorageMock) GetPresignedURLForUpload(ctx context.Context, namespaceUUID types.NamespaceUIDType, objectUUID types.ObjectUIDType, filename string, urlExpiration time.Duration) (up1 *url.URL, err error) {
	mm_atomic.AddUint64(&mmGetPresignedURLForUpload.beforeGetPresignedURLForUploadCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPresignedURLForUpload.afterGetPresignedURLForUploadCounter, 1)

	mmGetPresignedURLForUpload.t.Helper()

	if mmGetPresignedURLForUpload.inspectFuncGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.inspectFuncGetPresignedURLForUpload(ctx, namespaceUUID, objectUUID, filename, urlExpiration)
	}

	mm_params := StorageMockGetPresignedURLForUploadParams{ctx, namespaceUUID, objectUUID, filename, urlExpiration}

	// Record call args
	mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.mutex.Lock()
	mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.callArgs = append(mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.callArgs, &mm_params)
	mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.mutex.Unlock()

	for _, e := range mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.params
		mm_want_ptrs := mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGetPresignedURLForUploadParams{ctx, namespaceUUID, objectUUID, filename, urlExpiration}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPresignedURLForUpload.t.Errorf("StorageMock.GetPresignedURLForUpload got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.namespaceUUID != nil && !minimock.Equal(*mm_want_ptrs.namespaceUUID, mm_got.namespaceUUID) {
				mmGetPresignedURLForUpload.t.Errorf("StorageMock.GetPresignedURLForUpload got unexpected parameter namespaceUUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.expectationOrigins.originNamespaceUUID, *mm_want_ptrs.namespaceUUID, mm_got.namespaceUUID, minimock.Diff(*mm_want_ptrs.namespaceUUID, mm_got.namespaceUUID))
			}

			if mm_want_ptrs.objectUUID != nil && !minimock.Equal(*mm_want_ptrs.objectUUID, mm_got.objectUUID) {
				mmGetPresignedURLForUpload.t.Errorf("StorageMock.GetPresignedURLForUpload got unexpected parameter objectUUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.expectationOrigins.originObjectUUID, *mm_want_ptrs.objectUUID, mm_got.objectUUID, minimock.Diff(*mm_want_ptrs.objectUUID, mm_got.objectUUID))
			}

			if mm_want_ptrs.filename != nil && !minimock.Equal(*mm_want_ptrs.filename, mm_got.filename) {
				mmGetPresignedURLForUpload.t.Errorf("StorageMock.GetPresignedURLForUpload got unexpected parameter filename, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.expectationOrigins.originFilename, *mm_want_ptrs.filename, mm_got.filename, minimock.Diff(*mm_want_ptrs.filename, mm_got.filename))
			}

			if mm_want_ptrs.urlExpiration != nil && !minimock.Equal(*mm_want_ptrs.urlExpiration, mm_got.urlExpiration) {
				mmGetPresignedURLForUpload.t.Errorf("StorageMock.GetPresignedURLForUpload got unexpected parameter urlExpiration, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.expectationOrigins.originUrlExpiration, *mm_want_ptrs.urlExpiration, mm_got.urlExpiration, minimock.Diff(*mm_want_ptrs.urlExpiration, mm_got.urlExpiration))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPresignedURLForUpload.t.Errorf("StorageMock.GetPresignedURLForUpload got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPresignedURLForUpload.t.Fatal("No results are set for the StorageMock.GetPresignedURLForUpload")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetPresignedURLForUpload.funcGetPresignedURLForUpload != nil {
		return mmGetPresignedURLForUpload.funcGetPresignedURLForUpload(ctx, namespaceUUID, objectUUID, filename, urlExpiration)
	}
	mmGetPresignedURLForUpload.t.Fatalf("Unexpected call to StorageMock.GetPresignedURLForUpload. %v %v %v %v %v", ctx, namespaceUUID, objectUUID, filename, urlExpiration)
	return
}

// GetPresignedURLForUploadAfterCounter returns a count of finished StorageMock.GetPresignedURLForUpload invocations
func (mmGetPresignedURLForUpload *StorageMock) GetPresignedURLForUploadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPresignedURLForUpload.afterGetPresignedURLForUploadCounter)
}

// GetPresignedURLForUploadBeforeCounter returns a count of StorageMock.GetPresignedURLForUpload invocations
func (mmGetPresignedURLForUpload *StorageMock) GetPresignedURLForUploadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPresignedURLForUpload.beforeGetPresignedURLForUploadCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetPresignedURLForUpload.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPresignedURLForUpload *mStorageMockGetPresignedURLForUpload) Calls() []*StorageMockGetPresignedURLForUploadParams {
	mmGetPresignedURLForUpload.mutex.RLock()

	argCopy := make([]*StorageMockGetPresignedURLForUploadParams, len(mmGetPresignedURLForUpload.callArgs))
	copy(argCopy, mmGetPresignedURLForUpload.callArgs)

	mmGetPresignedURLForUpload.mutex.RUnlock()

	return argCopy
}

// MinimockGetPresignedURLForUploadDone returns true if the count of the GetPresignedURLForUpload invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetPresignedURLForUploadDone() bool {
	if m.GetPresignedURLForUploadMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPresignedURLForUploadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPresignedURLForUploadMock.invocationsDone()
}

// MinimockGetPresignedURLForUploadInspect logs each unmet expectation
func (m *StorageMock) MinimockGetPresignedURLForUploadInspect() {
	for _, e := range m.GetPresignedURLForUploadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetPresignedURLForUpload at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPresignedURLForUploadCounter := mm_atomic.LoadUint64(&m.afterGetPresignedURLForUploadCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPresignedURLForUploadMock.defaultExpectation != nil && afterGetPresignedURLForUploadCounter < 1 {
		if m.GetPresignedURLForUploadMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GetPresignedURLForUpload at\n%s", m.GetPresignedURLForUploadMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GetPresignedURLForUpload at\n%s with params: %#v", m.GetPresignedURLForUploadMock.defaultExpectation.expectationOrigins.origin, *m.GetPresignedURLForUploadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPresignedURLForUpload != nil && afterGetPresignedURLForUploadCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetPresignedURLForUpload at\n%s", m.funcGetPresignedURLForUploadOrigin)
	}

	if !m.GetPresignedURLForUploadMock.invocationsDone() && afterGetPresignedURLForUploadCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetPresignedURLForUpload at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPresignedURLForUploadMock.expectedInvocations), m.GetPresignedURLForUploadMock.expectedInvocationsOrigin, afterGetPresignedURLForUploadCounter)
	}
}

type mStorageMockListConvertedFilesByFileUID struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockListConvertedFilesByFileUIDExpectation
	expectations       []*StorageMockListConvertedFilesByFileUIDExpectation

	callArgs []*StorageMockListConvertedFilesByFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockListConvertedFilesByFileUIDExpectation specifies expectation struct of the Storage.ListConvertedFilesByFileUID
type StorageMockListConvertedFilesByFileUIDExpectation struct {
	mock               *StorageMock
	params             *StorageMockListConvertedFilesByFileUIDParams
	paramPtrs          *StorageMockListConvertedFilesByFileUIDParamPtrs
	expectationOrigins StorageMockListConvertedFilesByFileUIDExpectationOrigins
	results            *StorageMockListConvertedFilesByFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockListConvertedFilesByFileUIDParams contains parameters of the Storage.ListConvertedFilesByFileUID
type StorageMockListConvertedFilesByFileUIDParams struct {
	ctx     context.Context
	kbUID   types.KBUIDType
	fileUID types.FileUIDType
}

// StorageMockListConvertedFilesByFileUIDParamPtrs contains pointers to parameters of the Storage.ListConvertedFilesByFileUID
type StorageMockListConvertedFilesByFileUIDParamPtrs struct {
	ctx     *context.Context
	kbUID   *types.KBUIDType
	fileUID *types.FileUIDType
}

// StorageMockListConvertedFilesByFileUIDResults contains results of the Storage.ListConvertedFilesByFileUID
type StorageMockListConvertedFilesByFileUIDResults struct {
	sa1 []string
	err error
}

// StorageMockListConvertedFilesByFileUIDOrigins contains origins of expectations of the Storage.ListConvertedFilesByFileUID
type StorageMockListConvertedFilesByFileUIDExpectationOrigins struct {
	origin        string
	originCtx     string
	originKbUID   string
	originFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListConvertedFilesByFileUID *mStorageMockListConvertedFilesByFileUID) Optional() *mStorageMockListConvertedFilesByFileUID {
	mmListConvertedFilesByFileUID.optional = true
	return mmListConvertedFilesByFileUID
}

// Expect sets up expected params for Storage.ListConvertedFilesByFileUID
func (mmListConvertedFilesByFileUID *mStorageMockListConvertedFilesByFileUID) Expect(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType) *mStorageMockListConvertedFilesByFileUID {
	if mmListConvertedFilesByFileUID.mock.funcListConvertedFilesByFileUID != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("StorageMock.ListConvertedFilesByFileUID mock is already set by Set")
	}

	if mmListConvertedFilesByFileUID.defaultExpectation == nil {
		mmListConvertedFilesByFileUID.defaultExpectation = &StorageMockListConvertedFilesByFileUIDExpectation{}
	}

	if mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("StorageMock.ListConvertedFilesByFileUID mock is already set by ExpectParams functions")
	}

	mmListConvertedFilesByFileUID.defaultExpectation.params = &StorageMockListConvertedFilesByFileUIDParams{ctx, kbUID, fileUID}
	mmListConvertedFilesByFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListConvertedFilesByFileUID.expectations {
		if minimock.Equal(e.params, mmListConvertedFilesByFileUID.defaultExpectation.params) {
			mmListConvertedFilesByFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListConvertedFilesByFileUID.defaultExpectation.params)
		}
	}

	return mmListConvertedFilesByFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Storage.ListConvertedFilesByFileUID
func (mmListConvertedFilesByFileUID *mStorageMockListConvertedFilesByFileUID) ExpectCtxParam1(ctx context.Context) *mStorageMockListConvertedFilesByFileUID {
	if mmListConvertedFilesByFileUID.mock.funcListConvertedFilesByFileUID != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("StorageMock.ListConvertedFilesByFileUID mock is already set by Set")
	}

	if mmListConvertedFilesByFileUID.defaultExpectation == nil {
		mmListConvertedFilesByFileUID.defaultExpectation = &StorageMockListConvertedFilesByFileUIDExpectation{}
	}

	if mmListConvertedFilesByFileUID.defaultExpectation.params != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("StorageMock.ListConvertedFilesByFileUID mock is already set by Expect")
	}

	if mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs == nil {
		mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs = &StorageMockListConvertedFilesByFileUIDParamPtrs{}
	}
	mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmListConvertedFilesByFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListConvertedFilesByFileUID
}

// ExpectKbUIDParam2 sets up expected param kbUID for Storage.ListConvertedFilesByFileUID
func (mmListConvertedFilesByFileUID *mStorageMockListConvertedFilesByFileUID) ExpectKbUIDParam2(kbUID types.KBUIDType) *mStorageMockListConvertedFilesByFileUID {
	if mmListConvertedFilesByFileUID.mock.funcListConvertedFilesByFileUID != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("StorageMock.ListConvertedFilesByFileUID mock is already set by Set")
	}

	if mmListConvertedFilesByFileUID.defaultExpectation == nil {
		mmListConvertedFilesByFileUID.defaultExpectation = &StorageMockListConvertedFilesByFileUIDExpectation{}
	}

	if mmListConvertedFilesByFileUID.defaultExpectation.params != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("StorageMock.ListConvertedFilesByFileUID mock is already set by Expect")
	}

	if mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs == nil {
		mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs = &StorageMockListConvertedFilesByFileUIDParamPtrs{}
	}
	mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmListConvertedFilesByFileUID.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmListConvertedFilesByFileUID
}

// ExpectFileUIDParam3 sets up expected param fileUID for Storage.ListConvertedFilesByFileUID
func (mmListConvertedFilesByFileUID *mStorageMockListConvertedFilesByFileUID) ExpectFileUIDParam3(fileUID types.FileUIDType) *mStorageMockListConvertedFilesByFileUID {
	if mmListConvertedFilesByFileUID.mock.funcListConvertedFilesByFileUID != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("StorageMock.ListConvertedFilesByFileUID mock is already set by Set")
	}

	if mmListConvertedFilesByFileUID.defaultExpectation == nil {
		mmListConvertedFilesByFileUID.defaultExpectation = &StorageMockListConvertedFilesByFileUIDExpectation{}
	}

	if mmListConvertedFilesByFileUID.defaultExpectation.params != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("StorageMock.ListConvertedFilesByFileUID mock is already set by Expect")
	}

	if mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs == nil {
		mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs = &StorageMockListConvertedFilesByFileUIDParamPtrs{}
	}
	mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmListConvertedFilesByFileUID.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmListConvertedFilesByFileUID
}

// Inspect accepts an inspector function that has same arguments as the Storage.ListConvertedFilesByFileUID
func (mmListConvertedFilesByFileUID *mStorageMockListConvertedFilesByFileUID) Inspect(f func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType)) *mStorageMockListConvertedFilesByFileUID {
	if mmListConvertedFilesByFileUID.mock.inspectFuncListConvertedFilesByFileUID != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("Inspect function is already set for StorageMock.ListConvertedFilesByFileUID")
	}

	mmListConvertedFilesByFileUID.mock.inspectFuncListConvertedFilesByFileUID = f

	return mmListConvertedFilesByFileUID
}

// Return sets up results that will be returned by Storage.ListConvertedFilesByFileUID
func (mmListConvertedFilesByFileUID *mStorageMockListConvertedFilesByFileUID) Return(sa1 []string, err error) *StorageMock {
	if mmListConvertedFilesByFileUID.mock.funcListConvertedFilesByFileUID != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("StorageMock.ListConvertedFilesByFileUID mock is already set by Set")
	}

	if mmListConvertedFilesByFileUID.defaultExpectation == nil {
		mmListConvertedFilesByFileUID.defaultExpectation = &StorageMockListConvertedFilesByFileUIDExpectation{mock: mmListConvertedFilesByFileUID.mock}
	}
	mmListConvertedFilesByFileUID.defaultExpectation.results = &StorageMockListConvertedFilesByFileUIDResults{sa1, err}
	mmListConvertedFilesByFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListConvertedFilesByFileUID.mock
}

// Set uses given function f to mock the Storage.ListConvertedFilesByFileUID method
func (mmListConvertedFilesByFileUID *mStorageMockListConvertedFilesByFileUID) Set(f func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType) (sa1 []string, err error)) *StorageMock {
	if mmListConvertedFilesByFileUID.defaultExpectation != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("Default expectation is already set for the Storage.ListConvertedFilesByFileUID method")
	}

	if len(mmListConvertedFilesByFileUID.expectations) > 0 {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("Some expectations are already set for the Storage.ListConvertedFilesByFileUID method")
	}

	mmListConvertedFilesByFileUID.mock.funcListConvertedFilesByFileUID = f
	mmListConvertedFilesByFileUID.mock.funcListConvertedFilesByFileUIDOrigin = minimock.CallerInfo(1)
	return mmListConvertedFilesByFileUID.mock
}

// When sets expectation for the Storage.ListConvertedFilesByFileUID which will trigger the result defined by the following
// Then helper
func (mmListConvertedFilesByFileUID *mStorageMockListConvertedFilesByFileUID) When(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType) *StorageMockListConvertedFilesByFileUIDExpectation {
	if mmListConvertedFilesByFileUID.mock.funcListConvertedFilesByFileUID != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("StorageMock.ListConvertedFilesByFileUID mock is already set by Set")
	}

	expectation := &StorageMockListConvertedFilesByFileUIDExpectation{
		mock:               mmListConvertedFilesByFileUID.mock,
		params:             &StorageMockListConvertedFilesByFileUIDParams{ctx, kbUID, fileUID},
		expectationOrigins: StorageMockListConvertedFilesByFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListConvertedFilesByFileUID.expectations = append(mmListConvertedFilesByFileUID.expectations, expectation)
	return expectation
}

// Then sets up Storage.ListConvertedFilesByFileUID return parameters for the expectation previously defined by the When method
func (e *StorageMockListConvertedFilesByFileUIDExpectation) Then(sa1 []string, err error) *StorageMock {
	e.results = &StorageMockListConvertedFilesByFileUIDResults{sa1, err}
	return e.mock
}

// Times sets number of times Storage.ListConvertedFilesByFileUID should be invoked
func (mmListConvertedFilesByFileUID *mStorageMockListConvertedFilesByFileUID) Times(n uint64) *mStorageMockListConvertedFilesByFileUID {
	if n == 0 {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("Times of StorageMock.ListConvertedFilesByFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListConvertedFilesByFileUID.expectedInvocations, n)
	mmListConvertedFilesByFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListConvertedFilesByFileUID
}

func (mmListConvertedFilesByFileUID *mStorageMockListConvertedFilesByFileUID) invocationsDone() bool {
	if len(mmListConvertedFilesByFileUID.expectations) == 0 && mmListConvertedFilesByFileUID.defaultExpectation == nil && mmListConvertedFilesByFileUID.mock.funcListConvertedFilesByFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListConvertedFilesByFileUID.mock.afterListConvertedFilesByFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListConvertedFilesByFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListConvertedFilesByFileUID implements mm_object.Storage
func (mmListConvertedFilesByFileUID *StorageMock) ListConvertedFilesByFileUID(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmListConvertedFilesByFileUID.beforeListConvertedFilesByFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmListConvertedFilesByFileUID.afterListConvertedFilesByFileUIDCounter, 1)

	mmListConvertedFilesByFileUID.t.Helper()

	if mmListConvertedFilesByFileUID.inspectFuncListConvertedFilesByFileUID != nil {
		mmListConvertedFilesByFileUID.inspectFuncListConvertedFilesByFileUID(ctx, kbUID, fileUID)
	}

	mm_params := StorageMockListConvertedFilesByFileUIDParams{ctx, kbUID, fileUID}

	// Record call args
	mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.mutex.Lock()
	mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.callArgs = append(mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.callArgs, &mm_params)
	mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.mutex.Unlock()

	for _, e := range mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.defaultExpectation.paramPtrs

		mm_got := StorageMockListConvertedFilesByFileUIDParams{ctx, kbUID, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListConvertedFilesByFileUID.t.Errorf("StorageMock.ListConvertedFilesByFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmListConvertedFilesByFileUID.t.Errorf("StorageMock.ListConvertedFilesByFileUID got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmListConvertedFilesByFileUID.t.Errorf("StorageMock.ListConvertedFilesByFileUID got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListConvertedFilesByFileUID.t.Errorf("StorageMock.ListConvertedFilesByFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmListConvertedFilesByFileUID.t.Fatal("No results are set for the StorageMock.ListConvertedFilesByFileUID")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmListConvertedFilesByFileUID.funcListConvertedFilesByFileUID != nil {
		return mmListConvertedFilesByFileUID.funcListConvertedFilesByFileUID(ctx, kbUID, fileUID)
	}
	mmListConvertedFilesByFileUID.t.Fatalf("Unexpected call to StorageMock.ListConvertedFilesByFileUID. %v %v %v", ctx, kbUID, fileUID)
	return
}

// ListConvertedFilesByFileUIDAfterCounter returns a count of finished StorageMock.ListConvertedFilesByFileUID invocations
func (mmListConvertedFilesByFileUID *StorageMock) ListConvertedFilesByFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListConvertedFilesByFileUID.afterListConvertedFilesByFileUIDCounter)
}

// ListConvertedFilesByFileUIDBeforeCounter returns a count of StorageMock.ListConvertedFilesByFileUID invocations
func (mmListConvertedFilesByFileUID *StorageMock) ListConvertedFilesByFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListConvertedFilesByFileUID.beforeListConvertedFilesByFileUIDCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.ListConvertedFilesByFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListConvertedFilesByFileUID *mStorageMockListConvertedFilesByFileUID) Calls() []*StorageMockListConvertedFilesByFileUIDParams {
	mmListConvertedFilesByFileUID.mutex.RLock()

	argCopy := make([]*StorageMockListConvertedFilesByFileUIDParams, len(mmListConvertedFilesByFileUID.callArgs))
	copy(argCopy, mmListConvertedFilesByFileUID.callArgs)

	mmListConvertedFilesByFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockListConvertedFilesByFileUIDDone returns true if the count of the ListConvertedFilesByFileUID invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockListConvertedFilesByFileUIDDone() bool {
	if m.ListConvertedFilesByFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListConvertedFilesByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListConvertedFilesByFileUIDMock.invocationsDone()
}

// MinimockListConvertedFilesByFileUIDInspect logs each unmet expectation
func (m *StorageMock) MinimockListConvertedFilesByFileUIDInspect() {
	for _, e := range m.ListConvertedFilesByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.ListConvertedFilesByFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListConvertedFilesByFileUIDCounter := mm_atomic.LoadUint64(&m.afterListConvertedFilesByFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListConvertedFilesByFileUIDMock.defaultExpectation != nil && afterListConvertedFilesByFileUIDCounter < 1 {
		if m.ListConvertedFilesByFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.ListConvertedFilesByFileUID at\n%s", m.ListConvertedFilesByFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.ListConvertedFilesByFileUID at\n%s with params: %#v", m.ListConvertedFilesByFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.ListConvertedFilesByFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListConvertedFilesByFileUID != nil && afterListConvertedFilesByFileUIDCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.ListConvertedFilesByFileUID at\n%s", m.funcListConvertedFilesByFileUIDOrigin)
	}

	if !m.ListConvertedFilesByFileUIDMock.invocationsDone() && afterListConvertedFilesByFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.ListConvertedFilesByFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListConvertedFilesByFileUIDMock.expectedInvocations), m.ListConvertedFilesByFileUIDMock.expectedInvocationsOrigin, afterListConvertedFilesByFileUIDCounter)
	}
}

type mStorageMockListFilePathsWithPrefix struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockListFilePathsWithPrefixExpectation
	expectations       []*StorageMockListFilePathsWithPrefixExpectation

	callArgs []*StorageMockListFilePathsWithPrefixParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockListFilePathsWithPrefixExpectation specifies expectation struct of the Storage.ListFilePathsWithPrefix
type StorageMockListFilePathsWithPrefixExpectation struct {
	mock               *StorageMock
	params             *StorageMockListFilePathsWithPrefixParams
	paramPtrs          *StorageMockListFilePathsWithPrefixParamPtrs
	expectationOrigins StorageMockListFilePathsWithPrefixExpectationOrigins
	results            *StorageMockListFilePathsWithPrefixResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockListFilePathsWithPrefixParams contains parameters of the Storage.ListFilePathsWithPrefix
type StorageMockListFilePathsWithPrefixParams struct {
	ctx    context.Context
	bucket string
	prefix string
}

// StorageMockListFilePathsWithPrefixParamPtrs contains pointers to parameters of the Storage.ListFilePathsWithPrefix
type StorageMockListFilePathsWithPrefixParamPtrs struct {
	ctx    *context.Context
	bucket *string
	prefix *string
}

// StorageMockListFilePathsWithPrefixResults contains results of the Storage.ListFilePathsWithPrefix
type StorageMockListFilePathsWithPrefixResults struct {
	sa1 []string
	err error
}

// StorageMockListFilePathsWithPrefixOrigins contains origins of expectations of the Storage.ListFilePathsWithPrefix
type StorageMockListFilePathsWithPrefixExpectationOrigins struct {
	origin       string
	originCtx    string
	originBucket string
	originPrefix string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListFilePathsWithPrefix *mStorageMockListFilePathsWithPrefix) Optional() *mStorageMockListFilePathsWithPrefix {
	mmListFilePathsWithPrefix.optional = true
	return mmListFilePathsWithPrefix
}

// Expect sets up expected params for Storage.ListFilePathsWithPrefix
func (mmListFilePathsWithPrefix *mStorageMockListFilePathsWithPrefix) Expect(ctx context.Context, bucket string, prefix string) *mStorageMockListFilePathsWithPrefix {
	if mmListFilePathsWithPrefix.mock.funcListFilePathsWithPrefix != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("StorageMock.ListFilePathsWithPrefix mock is already set by Set")
	}

	if mmListFilePathsWithPrefix.defaultExpectation == nil {
		mmListFilePathsWithPrefix.defaultExpectation = &StorageMockListFilePathsWithPrefixExpectation{}
	}

	if mmListFilePathsWithPrefix.defaultExpectation.paramPtrs != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("StorageMock.ListFilePathsWithPrefix mock is already set by ExpectParams functions")
	}

	mmListFilePathsWithPrefix.defaultExpectation.params = &StorageMockListFilePathsWithPrefixParams{ctx, bucket, prefix}
	mmListFilePathsWithPrefix.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListFilePathsWithPrefix.expectations {
		if minimock.Equal(e.params, mmListFilePathsWithPrefix.defaultExpectation.params) {
			mmListFilePathsWithPrefix.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListFilePathsWithPrefix.defaultExpectation.params)
		}
	}

	return mmListFilePathsWithPrefix
}

// ExpectCtxParam1 sets up expected param ctx for Storage.ListFilePathsWithPrefix
func (mmListFilePathsWithPrefix *mStorageMockListFilePathsWithPrefix) ExpectCtxParam1(ctx context.Context) *mStorageMockListFilePathsWithPrefix {
	if mmListFilePathsWithPrefix.mock.funcListFilePathsWithPrefix != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("StorageMock.ListFilePathsWithPrefix mock is already set by Set")
	}

	if mmListFilePathsWithPrefix.defaultExpectation == nil {
		mmListFilePathsWithPrefix.defaultExpectation = &StorageMockListFilePathsWithPrefixExpectation{}
	}

	if mmListFilePathsWithPrefix.defaultExpectation.params != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("StorageMock.ListFilePathsWithPrefix mock is already set by Expect")
	}

	if mmListFilePathsWithPrefix.defaultExpectation.paramPtrs == nil {
		mmListFilePathsWithPrefix.defaultExpectation.paramPtrs = &StorageMockListFilePathsWithPrefixParamPtrs{}
	}
	mmListFilePathsWithPrefix.defaultExpectation.paramPtrs.ctx = &ctx
	mmListFilePathsWithPrefix.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListFilePathsWithPrefix
}

// ExpectBucketParam2 sets up expected param bucket for Storage.ListFilePathsWithPrefix
func (mmListFilePathsWithPrefix *mStorageMockListFilePathsWithPrefix) ExpectBucketParam2(bucket string) *mStorageMockListFilePathsWithPrefix {
	if mmListFilePathsWithPrefix.mock.funcListFilePathsWithPrefix != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("StorageMock.ListFilePathsWithPrefix mock is already set by Set")
	}

	if mmListFilePathsWithPrefix.defaultExpectation == nil {
		mmListFilePathsWithPrefix.defaultExpectation = &StorageMockListFilePathsWithPrefixExpectation{}
	}

	if mmListFilePathsWithPrefix.defaultExpectation.params != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("StorageMock.ListFilePathsWithPrefix mock is already set by Expect")
	}

	if mmListFilePathsWithPrefix.defaultExpectation.paramPtrs == nil {
		mmListFilePathsWithPrefix.defaultExpectation.paramPtrs = &StorageMockListFilePathsWithPrefixParamPtrs{}
	}
	mmListFilePathsWithPrefix.defaultExpectation.paramPtrs.bucket = &bucket
	mmListFilePathsWithPrefix.defaultExpectation.expectationOrigins.originBucket = minimock.CallerInfo(1)

	return mmListFilePathsWithPrefix
}

// ExpectPrefixParam3 sets up expected param prefix for Storage.ListFilePathsWithPrefix
func (mmListFilePathsWithPrefix *mStorageMockListFilePathsWithPrefix) ExpectPrefixParam3(prefix string) *mStorageMockListFilePathsWithPrefix {
	if mmListFilePathsWithPrefix.mock.funcListFilePathsWithPrefix != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("StorageMock.ListFilePathsWithPrefix mock is already set by Set")
	}

	if mmListFilePathsWithPrefix.defaultExpectation == nil {
		mmListFilePathsWithPrefix.defaultExpectation = &StorageMockListFilePathsWithPrefixExpectation{}
	}

	if mmListFilePathsWithPrefix.defaultExpectation.params != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("StorageMock.ListFilePathsWithPrefix mock is already set by Expect")
	}

	if mmListFilePathsWithPrefix.defaultExpectation.paramPtrs == nil {
		mmListFilePathsWithPrefix.defaultExpectation.paramPtrs = &StorageMockListFilePathsWithPrefixParamPtrs{}
	}
	mmListFilePathsWithPrefix.defaultExpectation.paramPtrs.prefix = &prefix
	mmListFilePathsWithPrefix.defaultExpectation.expectationOrigins.originPrefix = minimock.CallerInfo(1)

	return mmListFilePathsWithPrefix
}

// Inspect accepts an inspector function that has same arguments as the Storage.ListFilePathsWithPrefix
func (mmListFilePathsWithPrefix *mStorageMockListFilePathsWithPrefix) Inspect(f func(ctx context.Context, bucket string, prefix string)) *mStorageMockListFilePathsWithPrefix {
	if mmListFilePathsWithPrefix.mock.inspectFuncListFilePathsWithPrefix != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("Inspect function is already set for StorageMock.ListFilePathsWithPrefix")
	}

	mmListFilePathsWithPrefix.mock.inspectFuncListFilePathsWithPrefix = f

	return mmListFilePathsWithPrefix
}

// Return sets up results that will be returned by Storage.ListFilePathsWithPrefix
func (mmListFilePathsWithPrefix *mStorageMockListFilePathsWithPrefix) Return(sa1 []string, err error) *StorageMock {
	if mmListFilePathsWithPrefix.mock.funcListFilePathsWithPrefix != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("StorageMock.ListFilePathsWithPrefix mock is already set by Set")
	}

	if mmListFilePathsWithPrefix.defaultExpectation == nil {
		mmListFilePathsWithPrefix.defaultExpectation = &StorageMockListFilePathsWithPrefixExpectation{mock: mmListFilePathsWithPrefix.mock}
	}
	mmListFilePathsWithPrefix.defaultExpectation.results = &StorageMockListFilePathsWithPrefixResults{sa1, err}
	mmListFilePathsWithPrefix.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListFilePathsWithPrefix.mock
}

// Set uses given function f to mock the Storage.ListFilePathsWithPrefix method
func (mmListFilePathsWithPrefix *mStorageMockListFilePathsWithPrefix) Set(f func(ctx context.Context, bucket string, prefix string) (sa1 []string, err error)) *StorageMock {
	if mmListFilePathsWithPrefix.defaultExpectation != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("Default expectation is already set for the Storage.ListFilePathsWithPrefix method")
	}

	if len(mmListFilePathsWithPrefix.expectations) > 0 {
		mmListFilePathsWithPrefix.mock.t.Fatalf("Some expectations are already set for the Storage.ListFilePathsWithPrefix method")
	}

	mmListFilePathsWithPrefix.mock.funcListFilePathsWithPrefix = f
	mmListFilePathsWithPrefix.mock.funcListFilePathsWithPrefixOrigin = minimock.CallerInfo(1)
	return mmListFilePathsWithPrefix.mock
}

// When sets expectation for the Storage.ListFilePathsWithPrefix which will trigger the result defined by the following
// Then helper
func (mmListFilePathsWithPrefix *mStorageMockListFilePathsWithPrefix) When(ctx context.Context, bucket string, prefix string) *StorageMockListFilePathsWithPrefixExpectation {
	if mmListFilePathsWithPrefix.mock.funcListFilePathsWithPrefix != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("StorageMock.ListFilePathsWithPrefix mock is already set by Set")
	}

	expectation := &StorageMockListFilePathsWithPrefixExpectation{
		mock:               mmListFilePathsWithPrefix.mock,
		params:             &StorageMockListFilePathsWithPrefixParams{ctx, bucket, prefix},
		expectationOrigins: StorageMockListFilePathsWithPrefixExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListFilePathsWithPrefix.expectations = append(mmListFilePathsWithPrefix.expectations, expectation)
	return expectation
}

// Then sets up Storage.ListFilePathsWithPrefix return parameters for the expectation previously defined by the When method
func (e *StorageMockListFilePathsWithPrefixExpectation) Then(sa1 []string, err error) *StorageMock {
	e.results = &StorageMockListFilePathsWithPrefixResults{sa1, err}
	return e.mock
}

// Times sets number of times Storage.ListFilePathsWithPrefix should be invoked
func (mmListFilePathsWithPrefix *mStorageMockListFilePathsWithPrefix) Times(n uint64) *mStorageMockListFilePathsWithPrefix {
	if n == 0 {
		mmListFilePathsWithPrefix.mock.t.Fatalf("Times of StorageMock.ListFilePathsWithPrefix mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListFilePathsWithPrefix.expectedInvocations, n)
	mmListFilePathsWithPrefix.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListFilePathsWithPrefix
}

func (mmListFilePathsWithPrefix *mStorageMockListFilePathsWithPrefix) invocationsDone() bool {
	if len(mmListFilePathsWithPrefix.expectations) == 0 && mmListFilePathsWithPrefix.defaultExpectation == nil && mmListFilePathsWithPrefix.mock.funcListFilePathsWithPrefix == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListFilePathsWithPrefix.mock.afterListFilePathsWithPrefixCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListFilePathsWithPrefix.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListFilePathsWithPrefix implements mm_object.Storage
func (mmListFilePathsWithPrefix *StorageMock) ListFilePathsWithPrefix(ctx context.Context, bucket string, prefix string) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmListFilePathsWithPrefix.beforeListFilePathsWithPrefixCounter, 1)
	defer mm_atomic.AddUint64(&mmListFilePathsWithPrefix.afterListFilePathsWithPrefixCounter, 1)

	mmListFilePathsWithPrefix.t.Helper()

	if mmListFilePathsWithPrefix.inspectFuncListFilePathsWithPrefix != nil {
		mmListFilePathsWithPrefix.inspectFuncListFilePathsWithPrefix(ctx, bucket, prefix)
	}

	mm_params := StorageMockListFilePathsWithPrefixParams{ctx, bucket, prefix}

	// Record call args
	mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.mutex.Lock()
	mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.callArgs = append(mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.callArgs, &mm_params)
	mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.mutex.Unlock()

	for _, e := range mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.defaultExpectation.Counter, 1)
		mm_want := mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.defaultExpectation.params
		mm_want_ptrs := mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.defaultExpectation.paramPtrs

		mm_got := StorageMockListFilePathsWithPrefixParams{ctx, bucket, prefix}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListFilePathsWithPrefix.t.Errorf("StorageMock.ListFilePathsWithPrefix got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.bucket != nil && !minimock.Equal(*mm_want_ptrs.bucket, mm_got.bucket) {
				mmListFilePathsWithPrefix.t.Errorf("StorageMock.ListFilePathsWithPrefix got unexpected parameter bucket, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.defaultExpectation.expectationOrigins.originBucket, *mm_want_ptrs.bucket, mm_got.bucket, minimock.Diff(*mm_want_ptrs.bucket, mm_got.bucket))
			}

			if mm_want_ptrs.prefix != nil && !minimock.Equal(*mm_want_ptrs.prefix, mm_got.prefix) {
				mmListFilePathsWithPrefix.t.Errorf("StorageMock.ListFilePathsWithPrefix got unexpected parameter prefix, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.defaultExpectation.expectationOrigins.originPrefix, *mm_want_ptrs.prefix, mm_got.prefix, minimock.Diff(*mm_want_ptrs.prefix, mm_got.prefix))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListFilePathsWithPrefix.t.Errorf("StorageMock.ListFilePathsWithPrefix got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.defaultExpectation.results
		if mm_results == nil {
			mmListFilePathsWithPrefix.t.Fatal("No results are set for the StorageMock.ListFilePathsWithPrefix")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmListFilePathsWithPrefix.funcListFilePathsWithPrefix != nil {
		return mmListFilePathsWithPrefix.funcListFilePathsWithPrefix(ctx, bucket, prefix)
	}
	mmListFilePathsWithPrefix.t.Fatalf("Unexpected call to StorageMock.ListFilePathsWithPrefix. %v %v %v", ctx, bucket, prefix)
	return
}

// ListFilePathsWithPrefixAfterCounter returns a count of finished StorageMock.ListFilePathsWithPrefix invocations
func (mmListFilePathsWithPrefix *StorageMock) ListFilePathsWithPrefixAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListFilePathsWithPrefix.afterListFilePathsWithPrefixCounter)
}

// ListFilePathsWithPrefixBeforeCounter returns a count of StorageMock.ListFilePathsWithPrefix invocations
func (mmListFilePathsWithPrefix *StorageMock) ListFilePathsWithPrefixBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListFilePathsWithPrefix.beforeListFilePathsWithPrefixCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.ListFilePathsWithPrefix.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListFilePathsWithPrefix *mStorageMockListFilePathsWithPrefix) Calls() []*StorageMockListFilePathsWithPrefixParams {
	mmListFilePathsWithPrefix.mutex.RLock()

	argCopy := make([]*StorageMockListFilePathsWithPrefixParams, len(mmListFilePathsWithPrefix.callArgs))
	copy(argCopy, mmListFilePathsWithPrefix.callArgs)

	mmListFilePathsWithPrefix.mutex.RUnlock()

	return argCopy
}

// MinimockListFilePathsWithPrefixDone returns true if the count of the ListFilePathsWithPrefix invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockListFilePathsWithPrefixDone() bool {
	if m.ListFilePathsWithPrefixMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListFilePathsWithPrefixMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListFilePathsWithPrefixMock.invocationsDone()
}

// MinimockListFilePathsWithPrefixInspect logs each unmet expectation
func (m *StorageMock) MinimockListFilePathsWithPrefixInspect() {
	for _, e := range m.ListFilePathsWithPrefixMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.ListFilePathsWithPrefix at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListFilePathsWithPrefixCounter := mm_atomic.LoadUint64(&m.afterListFilePathsWithPrefixCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListFilePathsWithPrefixMock.defaultExpectation != nil && afterListFilePathsWithPrefixCounter < 1 {
		if m.ListFilePathsWithPrefixMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.ListFilePathsWithPrefix at\n%s", m.ListFilePathsWithPrefixMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.ListFilePathsWithPrefix at\n%s with params: %#v", m.ListFilePathsWithPrefixMock.defaultExpectation.expectationOrigins.origin, *m.ListFilePathsWithPrefixMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListFilePathsWithPrefix != nil && afterListFilePathsWithPrefixCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.ListFilePathsWithPrefix at\n%s", m.funcListFilePathsWithPrefixOrigin)
	}

	if !m.ListFilePathsWithPrefixMock.invocationsDone() && afterListFilePathsWithPrefixCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.ListFilePathsWithPrefix at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListFilePathsWithPrefixMock.expectedInvocations), m.ListFilePathsWithPrefixMock.expectedInvocationsOrigin, afterListFilePathsWithPrefixCounter)
	}
}

type mStorageMockListKnowledgeBaseFilePaths struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockListKnowledgeBaseFilePathsExpectation
	expectations       []*StorageMockListKnowledgeBaseFilePathsExpectation

	callArgs []*StorageMockListKnowledgeBaseFilePathsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockListKnowledgeBaseFilePathsExpectation specifies expectation struct of the Storage.ListKnowledgeBaseFilePaths
type StorageMockListKnowledgeBaseFilePathsExpectation struct {
	mock               *StorageMock
	params             *StorageMockListKnowledgeBaseFilePathsParams
	paramPtrs          *StorageMockListKnowledgeBaseFilePathsParamPtrs
	expectationOrigins StorageMockListKnowledgeBaseFilePathsExpectationOrigins
	results            *StorageMockListKnowledgeBaseFilePathsResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockListKnowledgeBaseFilePathsParams contains parameters of the Storage.ListKnowledgeBaseFilePaths
type StorageMockListKnowledgeBaseFilePathsParams struct {
	ctx   context.Context
	kbUID types.KBUIDType
}

// StorageMockListKnowledgeBaseFilePathsParamPtrs contains pointers to parameters of the Storage.ListKnowledgeBaseFilePaths
type StorageMockListKnowledgeBaseFilePathsParamPtrs struct {
	ctx   *context.Context
	kbUID *types.KBUIDType
}

// StorageMockListKnowledgeBaseFilePathsResults contains results of the Storage.ListKnowledgeBaseFilePaths
type StorageMockListKnowledgeBaseFilePathsResults struct {
	sa1 []string
	err error
}

// StorageMockListKnowledgeBaseFilePathsOrigins contains origins of expectations of the Storage.ListKnowledgeBaseFilePaths
type StorageMockListKnowledgeBaseFilePathsExpectationOrigins struct {
	origin      string
	originCtx   string
	originKbUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListKnowledgeBaseFilePaths *mStorageMockListKnowledgeBaseFilePaths) Optional() *mStorageMockListKnowledgeBaseFilePaths {
	mmListKnowledgeBaseFilePaths.optional = true
	return mmListKnowledgeBaseFilePaths
}

// Expect sets up expected params for Storage.ListKnowledgeBaseFilePaths
func (mmListKnowledgeBaseFilePaths *mStorageMockListKnowledgeBaseFilePaths) Expect(ctx context.Context, kbUID types.KBUIDType) *mStorageMockListKnowledgeBaseFilePaths {
	if mmListKnowledgeBaseFilePaths.mock.funcListKnowledgeBaseFilePaths != nil {
		mmListKnowledgeBaseFilePaths.mock.t.Fatalf("StorageMock.ListKnowledgeBaseFilePaths mock is already set by Set")
	}

	if mmListKnowledgeBaseFilePaths.defaultExpectation == nil {
		mmListKnowledgeBaseFilePaths.defaultExpectation = &StorageMockListKnowledgeBaseFilePathsExpectation{}
	}

	if mmListKnowledgeBaseFilePaths.defaultExpectation.paramPtrs != nil {
		mmListKnowledgeBaseFilePaths.mock.t.Fatalf("StorageMock.ListKnowledgeBaseFilePaths mock is already set by ExpectParams functions")
	}

	mmListKnowledgeBaseFilePaths.defaultExpectation.params = &StorageMockListKnowledgeBaseFilePathsParams{ctx, kbUID}
	mmListKnowledgeBaseFilePaths.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListKnowledgeBaseFilePaths.expectations {
		if minimock.Equal(e.params, mmListKnowledgeBaseFilePaths.defaultExpectation.params) {
			mmListKnowledgeBaseFilePaths.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListKnowledgeBaseFilePaths.defaultExpectation.params)
		}
	}

	return mmListKnowledgeBaseFilePaths
}

// ExpectCtxParam1 sets up expected param ctx for Storage.ListKnowledgeBaseFilePaths
func (mmListKnowledgeBaseFilePaths *mStorageMockListKnowledgeBaseFilePaths) ExpectCtxParam1(ctx context.Context) *mStorageMockListKnowledgeBaseFilePaths {
	if mmListKnowledgeBaseFilePaths.mock.funcListKnowledgeBaseFilePaths != nil {
		mmListKnowledgeBaseFilePaths.mock.t.Fatalf("StorageMock.ListKnowledgeBaseFilePaths mock is already set by Set")
	}

	if mmListKnowledgeBaseFilePaths.defaultExpectation == nil {
		mmListKnowledgeBaseFilePaths.defaultExpectation = &StorageMockListKnowledgeBaseFilePathsExpectation{}
	}

	if mmListKnowledgeBaseFilePaths.defaultExpectation.params != nil {
		mmListKnowledgeBaseFilePaths.mock.t.Fatalf("StorageMock.ListKnowledgeBaseFilePaths mock is already set by Expect")
	}

	if mmListKnowledgeBaseFilePaths.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFilePaths.defaultExpectation.paramPtrs = &StorageMockListKnowledgeBaseFilePathsParamPtrs{}
	}
	mmListKnowledgeBaseFilePaths.defaultExpectation.paramPtrs.ctx = &ctx
	mmListKnowledgeBaseFilePaths.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListKnowledgeBaseFilePaths
}

// ExpectKbUIDParam2 sets up expected param kbUID for Storage.ListKnowledgeBaseFilePaths
func (mmListKnowledgeBaseFilePaths *mStorageMockListKnowledgeBaseFilePaths) ExpectKbUIDParam2(kbUID types.KBUIDType) *mStorageMockListKnowledgeBaseFilePaths {
	if mmListKnowledgeBaseFilePaths.mock.funcListKnowledgeBaseFilePaths != nil {
		mmListKnowledgeBaseFilePaths.mock.t.Fatalf("StorageMock.ListKnowledgeBaseFilePaths mock is already set by Set")
	}

	if mmListKnowledgeBaseFilePaths.defaultExpectation == nil {
		mmListKnowledgeBaseFilePaths.defaultExpectation = &StorageMockListKnowledgeBaseFilePathsExpectation{}
	}

	if mmListKnowledgeBaseFilePaths.defaultExpectation.params != nil {
		mmListKnowledgeBaseFilePaths.mock.t.Fatalf("StorageMock.ListKnowledgeBaseFilePaths mock is already set by Expect")
	}

	if mmListKnowledgeBaseFilePaths.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFilePaths.defaultExpectation.paramPtrs = &StorageMockListKnowledgeBaseFilePathsParamPtrs{}
	}
	mmListKnowledgeBaseFilePaths.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmListKnowledgeBaseFilePaths.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmListKnowledgeBaseFilePaths
}

// Inspect accepts an inspector function that has same arguments as the Storage.ListKnowledgeBaseFilePaths
func (mmListKnowledgeBaseFilePaths *mStorageMockListKnowledgeBaseFilePaths) Inspect(f func(ctx context.Context, kbUID types.KBUIDType)) *mStorageMockListKnowledgeBaseFilePaths {
	if mmListKnowledgeBaseFilePaths.mock.inspectFuncListKnowledgeBaseFilePaths != nil {
		mmListKnowledgeBaseFilePaths.mock.t.Fatalf("Inspect function is already set for StorageMock.ListKnowledgeBaseFilePaths")
	}

	mmListKnowledgeBaseFilePaths.mock.inspectFuncListKnowledgeBaseFilePaths = f

	return mmListKnowledgeBaseFilePaths
}

// Return sets up results that will be returned by Storage.ListKnowledgeBaseFilePaths
func (mmListKnowledgeBaseFilePaths *mStorageMockListKnowledgeBaseFilePaths) Return(sa1 []string, err error) *StorageMock {
	if mmListKnowledgeBaseFilePaths.mock.funcListKnowledgeBaseFilePaths != nil {
		mmListKnowledgeBaseFilePaths.mock.t.Fatalf("StorageMock.ListKnowledgeBaseFilePaths mock is already set by Set")
	}

	if mmListKnowledgeBaseFilePaths.defaultExpectation == nil {
		mmListKnowledgeBaseFilePaths.defaultExpectation = &StorageMockListKnowledgeBaseFilePathsExpectation{mock: mmListKnowledgeBaseFilePaths.mock}
	}
	mmListKnowledgeBaseFilePaths.defaultExpectation.results = &StorageMockListKnowledgeBaseFilePathsResults{sa1, err}
	mmListKnowledgeBaseFilePaths.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBaseFilePaths.mock
}

// Set uses given function f to mock the Storage.ListKnowledgeBaseFilePaths method
func (mmListKnowledgeBaseFilePaths *mStorageMockListKnowledgeBaseFilePaths) Set(f func(ctx context.Context, kbUID types.KBUIDType) (sa1 []string, err error)) *StorageMock {
	if mmListKnowledgeBaseFilePaths.defaultExpectation != nil {
		mmListKnowledgeBaseFilePaths.mock.t.Fatalf("Default expectation is already set for the Storage.ListKnowledgeBaseFilePaths method")
	}

	if len(mmListKnowledgeBaseFilePaths.expectations) > 0 {
		mmListKnowledgeBaseFilePaths.mock.t.Fatalf("Some expectations are already set for the Storage.ListKnowledgeBaseFilePaths method")
	}

	mmListKnowledgeBaseFilePaths.mock.funcListKnowledgeBaseFilePaths = f
	mmListKnowledgeBaseFilePaths.mock.funcListKnowledgeBaseFilePathsOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBaseFilePaths.mock
}

// When sets expectation for the Storage.ListKnowledgeBaseFilePaths which will trigger the result defined by the following
// Then helper
func (mmListKnowledgeBaseFilePaths *mStorageMockListKnowledgeBaseFilePaths) When(ctx context.Context, kbUID types.KBUIDType) *StorageMockListKnowledgeBaseFilePathsExpectation {
	if mmListKnowledgeBaseFilePaths.mock.funcListKnowledgeBaseFilePaths != nil {
		mmListKnowledgeBaseFilePaths.mock.t.Fatalf("StorageMock.ListKnowledgeBaseFilePaths mock is already set by Set")
	}

	expectation := &StorageMockListKnowledgeBaseFilePathsExpectation{
		mock:               mmListKnowledgeBaseFilePaths.mock,
		params:             &StorageMockListKnowledgeBaseFilePathsParams{ctx, kbUID},
		expectationOrigins: StorageMockListKnowledgeBaseFilePathsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListKnowledgeBaseFilePaths.expectations = append(mmListKnowledgeBaseFilePaths.expectations, expectation)
	return expectation
}

// Then sets up Storage.ListKnowledgeBaseFilePaths return parameters for the expectation previously defined by the When method
func (e *StorageMockListKnowledgeBaseFilePathsExpectation) Then(sa1 []string, err error) *StorageMock {
	e.results = &StorageMockListKnowledgeBaseFilePathsResults{sa1, err}
	return e.mock
}

// Times sets number of times Storage.ListKnowledgeBaseFilePaths should be invoked
func (mmListKnowledgeBaseFilePaths *mStorageMockListKnowledgeBaseFilePaths) Times(n uint64) *mStorageMockListKnowledgeBaseFilePaths {
	if n == 0 {
		mmListKnowledgeBaseFilePaths.mock.t.Fatalf("Times of StorageMock.ListKnowledgeBaseFilePaths mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListKnowledgeBaseFilePaths.expectedInvocations, n)
	mmListKnowledgeBaseFilePaths.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBaseFilePaths
}

func (mmListKnowledgeBaseFilePaths *mStorageMockListKnowledgeBaseFilePaths) invocationsDone() bool {
	if len(mmListKnowledgeBaseFilePaths.expectations) == 0 && mmListKnowledgeBaseFilePaths.defaultExpectation == nil && mmListKnowledgeBaseFilePaths.mock.funcListKnowledgeBaseFilePaths == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBaseFilePaths.mock.afterListKnowledgeBaseFilePathsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBaseFilePaths.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListKnowledgeBaseFilePaths implements mm_object.Storage
func (mmListKnowledgeBaseFilePaths *StorageMock) ListKnowledgeBaseFilePaths(ctx context.Context, kbUID types.KBUIDType) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmListKnowledgeBaseFilePaths.beforeListKnowledgeBaseFilePathsCounter, 1)
	defer mm_atomic.AddUint64(&mmListKnowledgeBaseFilePaths.afterListKnowledgeBaseFilePathsCounter, 1)

	mmListKnowledgeBaseFilePaths.t.Helper()

	if mmListKnowledgeBaseFilePaths.inspectFuncListKnowledgeBaseFilePaths != nil {
		mmListKnowledgeBaseFilePaths.inspectFuncListKnowledgeBaseFilePaths(ctx, kbUID)
	}

	mm_params := StorageMockListKnowledgeBaseFilePathsParams{ctx, kbUID}

	// Record call args
	mmListKnowledgeBaseFilePaths.ListKnowledgeBaseFilePathsMock.mutex.Lock()
	mmListKnowledgeBaseFilePaths.ListKnowledgeBaseFilePathsMock.callArgs = append(mmListKnowledgeBaseFilePaths.ListKnowledgeBaseFilePathsMock.callArgs, &mm_params)
	mmListKnowledgeBaseFilePaths.ListKnowledgeBaseFilePathsMock.mutex.Unlock()

	for _, e := range mmListKnowledgeBaseFilePaths.ListKnowledgeBaseFilePathsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmListKnowledgeBaseFilePaths.ListKnowledgeBaseFilePathsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListKnowledgeBaseFilePaths.ListKnowledgeBaseFilePathsMock.defaultExpectation.Counter, 1)
		mm_want := mmListKnowledgeBaseFilePaths.ListKnowledgeBaseFilePathsMock.defaultExpectation.params
		mm_want_ptrs := mmListKnowledgeBaseFilePaths.ListKnowledgeBaseFilePathsMock.defaultExpectation.paramPtrs

		mm_got := StorageMockListKnowledgeBaseFilePathsParams{ctx, kbUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListKnowledgeBaseFilePaths.t.Errorf("StorageMock.ListKnowledgeBaseFilePaths got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBaseFilePaths.ListKnowledgeBaseFilePathsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmListKnowledgeBaseFilePaths.t.Errorf("StorageMock.ListKnowledgeBaseFilePaths got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBaseFilePaths.ListKnowledgeBaseFilePathsMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListKnowledgeBaseFilePaths.t.Errorf("StorageMock.ListKnowledgeBaseFilePaths got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListKnowledgeBaseFilePaths.ListKnowledgeBaseFilePathsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListKnowledgeBaseFilePaths.ListKnowledgeBaseFilePathsMock.defaultExpectation.results
		if mm_results == nil {
			mmListKnowledgeBaseFilePaths.t.Fatal("No results are set for the StorageMock.ListKnowledgeBaseFilePaths")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmListKnowledgeBaseFilePaths.funcListKnowledgeBaseFilePaths != nil {
		return mmListKnowledgeBaseFilePaths.funcListKnowledgeBaseFilePaths(ctx, kbUID)
	}
	mmListKnowledgeBaseFilePaths.t.Fatalf("Unexpected call to StorageMock.ListKnowledgeBaseFilePaths. %v %v", ctx, kbUID)
	return
}

// ListKnowledgeBaseFilePathsAfterCounter returns a count of finished StorageMock.ListKnowledgeBaseFilePaths invocations
func (mmListKnowledgeBaseFilePaths *StorageMock) ListKnowledgeBaseFilePathsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBaseFilePaths.afterListKnowledgeBaseFilePathsCounter)
}

// ListKnowledgeBaseFilePathsBeforeCounter returns a count of StorageMock.ListKnowledgeBaseFilePaths invocations
func (mmListKnowledgeBaseFilePaths *StorageMock) ListKnowledgeBaseFilePathsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBaseFilePaths.beforeListKnowledgeBaseFilePathsCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.ListKnowledgeBaseFilePaths.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListKnowledgeBaseFilePaths *mStorageMockListKnowledgeBaseFilePaths) Calls() []*StorageMockListKnowledgeBaseFilePathsParams {
	mmListKnowledgeBaseFilePaths.mutex.RLock()

	argCopy := make([]*StorageMockListKnowledgeBaseFilePathsParams, len(mmListKnowledgeBaseFilePaths.callArgs))
	copy(argCopy, mmListKnowledgeBaseFilePaths.callArgs)

	mmListKnowledgeBaseFilePaths.mutex.RUnlock()

	return argCopy
}

// MinimockListKnowledgeBaseFilePathsDone returns true if the count of the ListKnowledgeBaseFilePaths invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockListKnowledgeBaseFilePathsDone() bool {
	if m.ListKnowledgeBaseFilePathsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListKnowledgeBaseFilePathsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListKnowledgeBaseFilePathsMock.invocationsDone()
}

// MinimockListKnowledgeBaseFilePathsInspect logs each unmet expectation
func (m *StorageMock) MinimockListKnowledgeBaseFilePathsInspect() {
	for _, e := range m.ListKnowledgeBaseFilePathsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.ListKnowledgeBaseFilePaths at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListKnowledgeBaseFilePathsCounter := mm_atomic.LoadUint64(&m.afterListKnowledgeBaseFilePathsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListKnowledgeBaseFilePathsMock.defaultExpectation != nil && afterListKnowledgeBaseFilePathsCounter < 1 {
		if m.ListKnowledgeBaseFilePathsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.ListKnowledgeBaseFilePaths at\n%s", m.ListKnowledgeBaseFilePathsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.ListKnowledgeBaseFilePaths at\n%s with params: %#v", m.ListKnowledgeBaseFilePathsMock.defaultExpectation.expectationOrigins.origin, *m.ListKnowledgeBaseFilePathsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListKnowledgeBaseFilePaths != nil && afterListKnowledgeBaseFilePathsCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.ListKnowledgeBaseFilePaths at\n%s", m.funcListKnowledgeBaseFilePathsOrigin)
	}

	if !m.ListKnowledgeBaseFilePathsMock.invocationsDone() && afterListKnowledgeBaseFilePathsCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.ListKnowledgeBaseFilePaths at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListKnowledgeBaseFilePathsMock.expectedInvocations), m.ListKnowledgeBaseFilePathsMock.expectedInvocationsOrigin, afterListKnowledgeBaseFilePathsCounter)
	}
}

type mStorageMockListTextChunksByFileUID struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockListTextChunksByFileUIDExpectation
	expectations       []*StorageMockListTextChunksByFileUIDExpectation

	callArgs []*StorageMockListTextChunksByFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockListTextChunksByFileUIDExpectation specifies expectation struct of the Storage.ListTextChunksByFileUID
type StorageMockListTextChunksByFileUIDExpectation struct {
	mock               *StorageMock
	params             *StorageMockListTextChunksByFileUIDParams
	paramPtrs          *StorageMockListTextChunksByFileUIDParamPtrs
	expectationOrigins StorageMockListTextChunksByFileUIDExpectationOrigins
	results            *StorageMockListTextChunksByFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockListTextChunksByFileUIDParams contains parameters of the Storage.ListTextChunksByFileUID
type StorageMockListTextChunksByFileUIDParams struct {
	ctx     context.Context
	kbUID   types.KBUIDType
	fileUID types.FileUIDType
}

// StorageMockListTextChunksByFileUIDParamPtrs contains pointers to parameters of the Storage.ListTextChunksByFileUID
type StorageMockListTextChunksByFileUIDParamPtrs struct {
	ctx     *context.Context
	kbUID   *types.KBUIDType
	fileUID *types.FileUIDType
}

// StorageMockListTextChunksByFileUIDResults contains results of the Storage.ListTextChunksByFileUID
type StorageMockListTextChunksByFileUIDResults struct {
	sa1 []string
	err error
}

// StorageMockListTextChunksByFileUIDOrigins contains origins of expectations of the Storage.ListTextChunksByFileUID
type StorageMockListTextChunksByFileUIDExpectationOrigins struct {
	origin        string
	originCtx     string
	originKbUID   string
	originFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListTextChunksByFileUID *mStorageMockListTextChunksByFileUID) Optional() *mStorageMockListTextChunksByFileUID {
	mmListTextChunksByFileUID.optional = true
	return mmListTextChunksByFileUID
}

// Expect sets up expected params for Storage.ListTextChunksByFileUID
func (mmListTextChunksByFileUID *mStorageMockListTextChunksByFileUID) Expect(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType) *mStorageMockListTextChunksByFileUID {
	if mmListTextChunksByFileUID.mock.funcListTextChunksByFileUID != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("StorageMock.ListTextChunksByFileUID mock is already set by Set")
	}

	if mmListTextChunksByFileUID.defaultExpectation == nil {
		mmListTextChunksByFileUID.defaultExpectation = &StorageMockListTextChunksByFileUIDExpectation{}
	}

	if mmListTextChunksByFileUID.defaultExpectation.paramPtrs != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("StorageMock.ListTextChunksByFileUID mock is already set by ExpectParams functions")
	}

	mmListTextChunksByFileUID.defaultExpectation.params = &StorageMockListTextChunksByFileUIDParams{ctx, kbUID, fileUID}
	mmListTextChunksByFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListTextChunksByFileUID.expectations {
		if minimock.Equal(e.params, mmListTextChunksByFileUID.defaultExpectation.params) {
			mmListTextChunksByFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListTextChunksByFileUID.defaultExpectation.params)
		}
	}

	return mmListTextChunksByFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Storage.ListTextChunksByFileUID
func (mmListTextChunksByFileUID *mStorageMockListTextChunksByFileUID) ExpectCtxParam1(ctx context.Context) *mStorageMockListTextChunksByFileUID {
	if mmListTextChunksByFileUID.mock.funcListTextChunksByFileUID != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("StorageMock.ListTextChunksByFileUID mock is already set by Set")
	}

	if mmListTextChunksByFileUID.defaultExpectation == nil {
		mmListTextChunksByFileUID.defaultExpectation = &StorageMockListTextChunksByFileUIDExpectation{}
	}

	if mmListTextChunksByFileUID.defaultExpectation.params != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("StorageMock.ListTextChunksByFileUID mock is already set by Expect")
	}

	if mmListTextChunksByFileUID.defaultExpectation.paramPtrs == nil {
		mmListTextChunksByFileUID.defaultExpectation.paramPtrs = &StorageMockListTextChunksByFileUIDParamPtrs{}
	}
	mmListTextChunksByFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmListTextChunksByFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListTextChunksByFileUID
}

// ExpectKbUIDParam2 sets up expected param kbUID for Storage.ListTextChunksByFileUID
func (mmListTextChunksByFileUID *mStorageMockListTextChunksByFileUID) ExpectKbUIDParam2(kbUID types.KBUIDType) *mStorageMockListTextChunksByFileUID {
	if mmListTextChunksByFileUID.mock.funcListTextChunksByFileUID != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("StorageMock.ListTextChunksByFileUID mock is already set by Set")
	}

	if mmListTextChunksByFileUID.defaultExpectation == nil {
		mmListTextChunksByFileUID.defaultExpectation = &StorageMockListTextChunksByFileUIDExpectation{}
	}

	if mmListTextChunksByFileUID.defaultExpectation.params != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("StorageMock.ListTextChunksByFileUID mock is already set by Expect")
	}

	if mmListTextChunksByFileUID.defaultExpectation.paramPtrs == nil {
		mmListTextChunksByFileUID.defaultExpectation.paramPtrs = &StorageMockListTextChunksByFileUIDParamPtrs{}
	}
	mmListTextChunksByFileUID.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmListTextChunksByFileUID.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmListTextChunksByFileUID
}

// ExpectFileUIDParam3 sets up expected param fileUID for Storage.ListTextChunksByFileUID
func (mmListTextChunksByFileUID *mStorageMockListTextChunksByFileUID) ExpectFileUIDParam3(fileUID types.FileUIDType) *mStorageMockListTextChunksByFileUID {
	if mmListTextChunksByFileUID.mock.funcListTextChunksByFileUID != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("StorageMock.ListTextChunksByFileUID mock is already set by Set")
	}

	if mmListTextChunksByFileUID.defaultExpectation == nil {
		mmListTextChunksByFileUID.defaultExpectation = &StorageMockListTextChunksByFileUIDExpectation{}
	}

	if mmListTextChunksByFileUID.defaultExpectation.params != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("StorageMock.ListTextChunksByFileUID mock is already set by Expect")
	}

	if mmListTextChunksByFileUID.defaultExpectation.paramPtrs == nil {
		mmListTextChunksByFileUID.defaultExpectation.paramPtrs = &StorageMockListTextChunksByFileUIDParamPtrs{}
	}
	mmListTextChunksByFileUID.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmListTextChunksByFileUID.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmListTextChunksByFileUID
}

// Inspect accepts an inspector function that has same arguments as the Storage.ListTextChunksByFileUID
func (mmListTextChunksByFileUID *mStorageMockListTextChunksByFileUID) Inspect(f func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType)) *mStorageMockListTextChunksByFileUID {
	if mmListTextChunksByFileUID.mock.inspectFuncListTextChunksByFileUID != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("Inspect function is already set for StorageMock.ListTextChunksByFileUID")
	}

	mmListTextChunksByFileUID.mock.inspectFuncListTextChunksByFileUID = f

	return mmListTextChunksByFileUID
}

// Return sets up results that will be returned by Storage.ListTextChunksByFileUID
func (mmListTextChunksByFileUID *mStorageMockListTextChunksByFileUID) Return(sa1 []string, err error) *StorageMock {
	if mmListTextChunksByFileUID.mock.funcListTextChunksByFileUID != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("StorageMock.ListTextChunksByFileUID mock is already set by Set")
	}

	if mmListTextChunksByFileUID.defaultExpectation == nil {
		mmListTextChunksByFileUID.defaultExpectation = &StorageMockListTextChunksByFileUIDExpectation{mock: mmListTextChunksByFileUID.mock}
	}
	mmListTextChunksByFileUID.defaultExpectation.results = &StorageMockListTextChunksByFileUIDResults{sa1, err}
	mmListTextChunksByFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListTextChunksByFileUID.mock
}

// Set uses given function f to mock the Storage.ListTextChunksByFileUID method
func (mmListTextChunksByFileUID *mStorageMockListTextChunksByFileUID) Set(f func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType) (sa1 []string, err error)) *StorageMock {
	if mmListTextChunksByFileUID.defaultExpectation != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("Default expectation is already set for the Storage.ListTextChunksByFileUID method")
	}

	if len(mmListTextChunksByFileUID.expectations) > 0 {
		mmListTextChunksByFileUID.mock.t.Fatalf("Some expectations are already set for the Storage.ListTextChunksByFileUID method")
	}

	mmListTextChunksByFileUID.mock.funcListTextChunksByFileUID = f
	mmListTextChunksByFileUID.mock.funcListTextChunksByFileUIDOrigin = minimock.CallerInfo(1)
	return mmListTextChunksByFileUID.mock
}

// When sets expectation for the Storage.ListTextChunksByFileUID which will trigger the result defined by the following
// Then helper
func (mmListTextChunksByFileUID *mStorageMockListTextChunksByFileUID) When(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType) *StorageMockListTextChunksByFileUIDExpectation {
	if mmListTextChunksByFileUID.mock.funcListTextChunksByFileUID != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("StorageMock.ListTextChunksByFileUID mock is already set by Set")
	}

	expectation := &StorageMockListTextChunksByFileUIDExpectation{
		mock:               mmListTextChunksByFileUID.mock,
		params:             &StorageMockListTextChunksByFileUIDParams{ctx, kbUID, fileUID},
		expectationOrigins: StorageMockListTextChunksByFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListTextChunksByFileUID.expectations = append(mmListTextChunksByFileUID.expectations, expectation)
	return expectation
}

// Then sets up Storage.ListTextChunksByFileUID return parameters for the expectation previously defined by the When method
func (e *StorageMockListTextChunksByFileUIDExpectation) Then(sa1 []string, err error) *StorageMock {
	e.results = &StorageMockListTextChunksByFileUIDResults{sa1, err}
	return e.mock
}

// Times sets number of times Storage.ListTextChunksByFileUID should be invoked
func (mmListTextChunksByFileUID *mStorageMockListTextChunksByFileUID) Times(n uint64) *mStorageMockListTextChunksByFileUID {
	if n == 0 {
		mmListTextChunksByFileUID.mock.t.Fatalf("Times of StorageMock.ListTextChunksByFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListTextChunksByFileUID.expectedInvocations, n)
	mmListTextChunksByFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListTextChunksByFileUID
}

func (mmListTextChunksByFileUID *mStorageMockListTextChunksByFileUID) invocationsDone() bool {
	if len(mmListTextChunksByFileUID.expectations) == 0 && mmListTextChunksByFileUID.defaultExpectation == nil && mmListTextChunksByFileUID.mock.funcListTextChunksByFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListTextChunksByFileUID.mock.afterListTextChunksByFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListTextChunksByFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListTextChunksByFileUID implements mm_object.Storage
func (mmListTextChunksByFileUID *StorageMock) ListTextChunksByFileUID(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmListTextChunksByFileUID.beforeListTextChunksByFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmListTextChunksByFileUID.afterListTextChunksByFileUIDCounter, 1)

	mmListTextChunksByFileUID.t.Helper()

	if mmListTextChunksByFileUID.inspectFuncListTextChunksByFileUID != nil {
		mmListTextChunksByFileUID.inspectFuncListTextChunksByFileUID(ctx, kbUID, fileUID)
	}

	mm_params := StorageMockListTextChunksByFileUIDParams{ctx, kbUID, fileUID}

	// Record call args
	mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.mutex.Lock()
	mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.callArgs = append(mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.callArgs, &mm_params)
	mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.mutex.Unlock()

	for _, e := range mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.defaultExpectation.paramPtrs

		mm_got := StorageMockListTextChunksByFileUIDParams{ctx, kbUID, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListTextChunksByFileUID.t.Errorf("StorageMock.ListTextChunksByFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmListTextChunksByFileUID.t.Errorf("StorageMock.ListTextChunksByFileUID got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmListTextChunksByFileUID.t.Errorf("StorageMock.ListTextChunksByFileUID got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListTextChunksByFileUID.t.Errorf("StorageMock.ListTextChunksByFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmListTextChunksByFileUID.t.Fatal("No results are set for the StorageMock.ListTextChunksByFileUID")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmListTextChunksByFileUID.funcListTextChunksByFileUID != nil {
		return mmListTextChunksByFileUID.funcListTextChunksByFileUID(ctx, kbUID, fileUID)
	}
	mmListTextChunksByFileUID.t.Fatalf("Unexpected call to StorageMock.ListTextChunksByFileUID. %v %v %v", ctx, kbUID, fileUID)
	return
}

// ListTextChunksByFileUIDAfterCounter returns a count of finished StorageMock.ListTextChunksByFileUID invocations
func (mmListTextChunksByFileUID *StorageMock) ListTextChunksByFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTextChunksByFileUID.afterListTextChunksByFileUIDCounter)
}

// ListTextChunksByFileUIDBeforeCounter returns a count of StorageMock.ListTextChunksByFileUID invocations
func (mmListTextChunksByFileUID *StorageMock) ListTextChunksByFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTextChunksByFileUID.beforeListTextChunksByFileUIDCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.ListTextChunksByFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListTextChunksByFileUID *mStorageMockListTextChunksByFileUID) Calls() []*StorageMockListTextChunksByFileUIDParams {
	mmListTextChunksByFileUID.mutex.RLock()

	argCopy := make([]*StorageMockListTextChunksByFileUIDParams, len(mmListTextChunksByFileUID.callArgs))
	copy(argCopy, mmListTextChunksByFileUID.callArgs)

	mmListTextChunksByFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockListTextChunksByFileUIDDone returns true if the count of the ListTextChunksByFileUID invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockListTextChunksByFileUIDDone() bool {
	if m.ListTextChunksByFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListTextChunksByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListTextChunksByFileUIDMock.invocationsDone()
}

// MinimockListTextChunksByFileUIDInspect logs each unmet expectation
func (m *StorageMock) MinimockListTextChunksByFileUIDInspect() {
	for _, e := range m.ListTextChunksByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.ListTextChunksByFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListTextChunksByFileUIDCounter := mm_atomic.LoadUint64(&m.afterListTextChunksByFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListTextChunksByFileUIDMock.defaultExpectation != nil && afterListTextChunksByFileUIDCounter < 1 {
		if m.ListTextChunksByFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.ListTextChunksByFileUID at\n%s", m.ListTextChunksByFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.ListTextChunksByFileUID at\n%s with params: %#v", m.ListTextChunksByFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.ListTextChunksByFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListTextChunksByFileUID != nil && afterListTextChunksByFileUIDCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.ListTextChunksByFileUID at\n%s", m.funcListTextChunksByFileUIDOrigin)
	}

	if !m.ListTextChunksByFileUIDMock.invocationsDone() && afterListTextChunksByFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.ListTextChunksByFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListTextChunksByFileUIDMock.expectedInvocations), m.ListTextChunksByFileUIDMock.expectedInvocationsOrigin, afterListTextChunksByFileUIDCounter)
	}
}

type mStorageMockSaveConvertedFile struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockSaveConvertedFileExpectation
	expectations       []*StorageMockSaveConvertedFileExpectation

	callArgs []*StorageMockSaveConvertedFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockSaveConvertedFileExpectation specifies expectation struct of the Storage.SaveConvertedFile
type StorageMockSaveConvertedFileExpectation struct {
	mock               *StorageMock
	params             *StorageMockSaveConvertedFileParams
	paramPtrs          *StorageMockSaveConvertedFileParamPtrs
	expectationOrigins StorageMockSaveConvertedFileExpectationOrigins
	results            *StorageMockSaveConvertedFileResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockSaveConvertedFileParams contains parameters of the Storage.SaveConvertedFile
type StorageMockSaveConvertedFileParams struct {
	ctx              context.Context
	kbUID            types.KBUIDType
	fileUID          types.FileUIDType
	convertedFileUID types.ConvertedFileUIDType
	fileExt          string
	content          []byte
}

// StorageMockSaveConvertedFileParamPtrs contains pointers to parameters of the Storage.SaveConvertedFile
type StorageMockSaveConvertedFileParamPtrs struct {
	ctx              *context.Context
	kbUID            *types.KBUIDType
	fileUID          *types.FileUIDType
	convertedFileUID *types.ConvertedFileUIDType
	fileExt          *string
	content          *[]byte
}

// StorageMockSaveConvertedFileResults contains results of the Storage.SaveConvertedFile
type StorageMockSaveConvertedFileResults struct {
	path string
	err  error
}

// StorageMockSaveConvertedFileOrigins contains origins of expectations of the Storage.SaveConvertedFile
type StorageMockSaveConvertedFileExpectationOrigins struct {
	origin                 string
	originCtx              string
	originKbUID            string
	originFileUID          string
	originConvertedFileUID string
	originFileExt          string
	originContent          string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSaveConvertedFile *mStorageMockSaveConvertedFile) Optional() *mStorageMockSaveConvertedFile {
	mmSaveConvertedFile.optional = true
	return mmSaveConvertedFile
}

// Expect sets up expected params for Storage.SaveConvertedFile
func (mmSaveConvertedFile *mStorageMockSaveConvertedFile) Expect(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, convertedFileUID types.ConvertedFileUIDType, fileExt string, content []byte) *mStorageMockSaveConvertedFile {
	if mmSaveConvertedFile.mock.funcSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("StorageMock.SaveConvertedFile mock is already set by Set")
	}

	if mmSaveConvertedFile.defaultExpectation == nil {
		mmSaveConvertedFile.defaultExpectation = &StorageMockSaveConvertedFileExpectation{}
	}

	if mmSaveConvertedFile.defaultExpectation.paramPtrs != nil {
		mmSaveConvertedFile.mock.t.Fatalf("StorageMock.SaveConvertedFile mock is already set by ExpectParams functions")
	}

	mmSaveConvertedFile.defaultExpectation.params = &StorageMockSaveConvertedFileParams{ctx, kbUID, fileUID, convertedFileUID, fileExt, content}
	mmSaveConvertedFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSaveConvertedFile.expectations {
		if minimock.Equal(e.params, mmSaveConvertedFile.defaultExpectation.params) {
			mmSaveConvertedFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveConvertedFile.defaultExpectation.params)
		}
	}

	return mmSaveConvertedFile
}

// ExpectCtxParam1 sets up expected param ctx for Storage.SaveConvertedFile
func (mmSaveConvertedFile *mStorageMockSaveConvertedFile) ExpectCtxParam1(ctx context.Context) *mStorageMockSaveConvertedFile {
	if mmSaveConvertedFile.mock.funcSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("StorageMock.SaveConvertedFile mock is already set by Set")
	}

	if mmSaveConvertedFile.defaultExpectation == nil {
		mmSaveConvertedFile.defaultExpectation = &StorageMockSaveConvertedFileExpectation{}
	}

	if mmSaveConvertedFile.defaultExpectation.params != nil {
		mmSaveConvertedFile.mock.t.Fatalf("StorageMock.SaveConvertedFile mock is already set by Expect")
	}

	if mmSaveConvertedFile.defaultExpectation.paramPtrs == nil {
		mmSaveConvertedFile.defaultExpectation.paramPtrs = &StorageMockSaveConvertedFileParamPtrs{}
	}
	mmSaveConvertedFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmSaveConvertedFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSaveConvertedFile
}

// ExpectKbUIDParam2 sets up expected param kbUID for Storage.SaveConvertedFile
func (mmSaveConvertedFile *mStorageMockSaveConvertedFile) ExpectKbUIDParam2(kbUID types.KBUIDType) *mStorageMockSaveConvertedFile {
	if mmSaveConvertedFile.mock.funcSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("StorageMock.SaveConvertedFile mock is already set by Set")
	}

	if mmSaveConvertedFile.defaultExpectation == nil {
		mmSaveConvertedFile.defaultExpectation = &StorageMockSaveConvertedFileExpectation{}
	}

	if mmSaveConvertedFile.defaultExpectation.params != nil {
		mmSaveConvertedFile.mock.t.Fatalf("StorageMock.SaveConvertedFile mock is already set by Expect")
	}

	if mmSaveConvertedFile.defaultExpectation.paramPtrs == nil {
		mmSaveConvertedFile.defaultExpectation.paramPtrs = &StorageMockSaveConvertedFileParamPtrs{}
	}
	mmSaveConvertedFile.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmSaveConvertedFile.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmSaveConvertedFile
}

// ExpectFileUIDParam3 sets up expected param fileUID for Storage.SaveConvertedFile
func (mmSaveConvertedFile *mStorageMockSaveConvertedFile) ExpectFileUIDParam3(fileUID types.FileUIDType) *mStorageMockSaveConvertedFile {
	if mmSaveConvertedFile.mock.funcSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("StorageMock.SaveConvertedFile mock is already set by Set")
	}

	if mmSaveConvertedFile.defaultExpectation == nil {
		mmSaveConvertedFile.defaultExpectation = &StorageMockSaveConvertedFileExpectation{}
	}

	if mmSaveConvertedFile.defaultExpectation.params != nil {
		mmSaveConvertedFile.mock.t.Fatalf("StorageMock.SaveConvertedFile mock is already set by Expect")
	}

	if mmSaveConvertedFile.defaultExpectation.paramPtrs == nil {
		mmSaveConvertedFile.defaultExpectation.paramPtrs = &StorageMockSaveConvertedFileParamPtrs{}
	}
	mmSaveConvertedFile.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmSaveConvertedFile.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmSaveConvertedFile
}

// ExpectConvertedFileUIDParam4 sets up expected param convertedFileUID for Storage.SaveConvertedFile
func (mmSaveConvertedFile *mStorageMockSaveConvertedFile) ExpectConvertedFileUIDParam4(convertedFileUID types.ConvertedFileUIDType) *mStorageMockSaveConvertedFile {
	if mmSaveConvertedFile.mock.funcSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("StorageMock.SaveConvertedFile mock is already set by Set")
	}

	if mmSaveConvertedFile.defaultExpectation == nil {
		mmSaveConvertedFile.defaultExpectation = &StorageMockSaveConvertedFileExpectation{}
	}

	if mmSaveConvertedFile.defaultExpectation.params != nil {
		mmSaveConvertedFile.mock.t.Fatalf("StorageMock.SaveConvertedFile mock is already set by Expect")
	}

	if mmSaveConvertedFile.defaultExpectation.paramPtrs == nil {
		mmSaveConvertedFile.defaultExpectation.paramPtrs = &StorageMockSaveConvertedFileParamPtrs{}
	}
	mmSaveConvertedFile.defaultExpectation.paramPtrs.convertedFileUID = &convertedFileUID
	mmSaveConvertedFile.defaultExpectation.expectationOrigins.originConvertedFileUID = minimock.CallerInfo(1)

	return mmSaveConvertedFile
}

// ExpectFileExtParam5 sets up expected param fileExt for Storage.SaveConvertedFile
func (mmSaveConvertedFile *mStorageMockSaveConvertedFile) ExpectFileExtParam5(fileExt string) *mStorageMockSaveConvertedFile {
	if mmSaveConvertedFile.mock.funcSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("StorageMock.SaveConvertedFile mock is already set by Set")
	}

	if mmSaveConvertedFile.defaultExpectation == nil {
		mmSaveConvertedFile.defaultExpectation = &StorageMockSaveConvertedFileExpectation{}
	}

	if mmSaveConvertedFile.defaultExpectation.params != nil {
		mmSaveConvertedFile.mock.t.Fatalf("StorageMock.SaveConvertedFile mock is already set by Expect")
	}

	if mmSaveConvertedFile.defaultExpectation.paramPtrs == nil {
		mmSaveConvertedFile.defaultExpectation.paramPtrs = &StorageMockSaveConvertedFileParamPtrs{}
	}
	mmSaveConvertedFile.defaultExpectation.paramPtrs.fileExt = &fileExt
	mmSaveConvertedFile.defaultExpectation.expectationOrigins.originFileExt = minimock.CallerInfo(1)

	return mmSaveConvertedFile
}

// ExpectContentParam6 sets up expected param content for Storage.SaveConvertedFile
func (mmSaveConvertedFile *mStorageMockSaveConvertedFile) ExpectContentParam6(content []byte) *mStorageMockSaveConvertedFile {
	if mmSaveConvertedFile.mock.funcSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("StorageMock.SaveConvertedFile mock is already set by Set")
	}

	if mmSaveConvertedFile.defaultExpectation == nil {
		mmSaveConvertedFile.defaultExpectation = &StorageMockSaveConvertedFileExpectation{}
	}

	if mmSaveConvertedFile.defaultExpectation.params != nil {
		mmSaveConvertedFile.mock.t.Fatalf("StorageMock.SaveConvertedFile mock is already set by Expect")
	}

	if mmSaveConvertedFile.defaultExpectation.paramPtrs == nil {
		mmSaveConvertedFile.defaultExpectation.paramPtrs = &StorageMockSaveConvertedFileParamPtrs{}
	}
	mmSaveConvertedFile.defaultExpectation.paramPtrs.content = &content
	mmSaveConvertedFile.defaultExpectation.expectationOrigins.originContent = minimock.CallerInfo(1)

	return mmSaveConvertedFile
}

// Inspect accepts an inspector function that has same arguments as the Storage.SaveConvertedFile
func (mmSaveConvertedFile *mStorageMockSaveConvertedFile) Inspect(f func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, convertedFileUID types.ConvertedFileUIDType, fileExt string, content []byte)) *mStorageMockSaveConvertedFile {
	if mmSaveConvertedFile.mock.inspectFuncSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("Inspect function is already set for StorageMock.SaveConvertedFile")
	}

	mmSaveConvertedFile.mock.inspectFuncSaveConvertedFile = f

	return mmSaveConvertedFile
}

// Return sets up results that will be returned by Storage.SaveConvertedFile
func (mmSaveConvertedFile *mStorageMockSaveConvertedFile) Return(path string, err error) *StorageMock {
	if mmSaveConvertedFile.mock.funcSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("StorageMock.SaveConvertedFile mock is already set by Set")
	}

	if mmSaveConvertedFile.defaultExpectation == nil {
		mmSaveConvertedFile.defaultExpectation = &StorageMockSaveConvertedFileExpectation{mock: mmSaveConvertedFile.mock}
	}
	mmSaveConvertedFile.defaultExpectation.results = &StorageMockSaveConvertedFileResults{path, err}
	mmSaveConvertedFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSaveConvertedFile.mock
}

// Set uses given function f to mock the Storage.SaveConvertedFile method
func (mmSaveConvertedFile *mStorageMockSaveConvertedFile) Set(f func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, convertedFileUID types.ConvertedFileUIDType, fileExt string, content []byte) (path string, err error)) *StorageMock {
	if mmSaveConvertedFile.defaultExpectation != nil {
		mmSaveConvertedFile.mock.t.Fatalf("Default expectation is already set for the Storage.SaveConvertedFile method")
	}

	if len(mmSaveConvertedFile.expectations) > 0 {
		mmSaveConvertedFile.mock.t.Fatalf("Some expectations are already set for the Storage.SaveConvertedFile method")
	}

	mmSaveConvertedFile.mock.funcSaveConvertedFile = f
	mmSaveConvertedFile.mock.funcSaveConvertedFileOrigin = minimock.CallerInfo(1)
	return mmSaveConvertedFile.mock
}

// When sets expectation for the Storage.SaveConvertedFile which will trigger the result defined by the following
// Then helper
func (mmSaveConvertedFile *mStorageMockSaveConvertedFile) When(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, convertedFileUID types.ConvertedFileUIDType, fileExt string, content []byte) *StorageMockSaveConvertedFileExpectation {
	if mmSaveConvertedFile.mock.funcSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("StorageMock.SaveConvertedFile mock is already set by Set")
	}

	expectation := &StorageMockSaveConvertedFileExpectation{
		mock:               mmSaveConvertedFile.mock,
		params:             &StorageMockSaveConvertedFileParams{ctx, kbUID, fileUID, convertedFileUID, fileExt, content},
		expectationOrigins: StorageMockSaveConvertedFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSaveConvertedFile.expectations = append(mmSaveConvertedFile.expectations, expectation)
	return expectation
}

// Then sets up Storage.SaveConvertedFile return parameters for the expectation previously defined by the When method
func (e *StorageMockSaveConvertedFileExpectation) Then(path string, err error) *StorageMock {
	e.results = &StorageMockSaveConvertedFileResults{path, err}
	return e.mock
}

// Times sets number of times Storage.SaveConvertedFile should be invoked
func (mmSaveConvertedFile *mStorageMockSaveConvertedFile) Times(n uint64) *mStorageMockSaveConvertedFile {
	if n == 0 {
		mmSaveConvertedFile.mock.t.Fatalf("Times of StorageMock.SaveConvertedFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSaveConvertedFile.expectedInvocations, n)
	mmSaveConvertedFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSaveConvertedFile
}

func (mmSaveConvertedFile *mStorageMockSaveConvertedFile) invocationsDone() bool {
	if len(mmSaveConvertedFile.expectations) == 0 && mmSaveConvertedFile.defaultExpectation == nil && mmSaveConvertedFile.mock.funcSaveConvertedFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSaveConvertedFile.mock.afterSaveConvertedFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSaveConvertedFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SaveConvertedFile implements mm_object.Storage
func (mmSaveConvertedFile *StorageMock) SaveConvertedFile(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, convertedFileUID types.ConvertedFileUIDType, fileExt string, content []byte) (path string, err error) {
	mm_atomic.AddUint64(&mmSaveConvertedFile.beforeSaveConvertedFileCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveConvertedFile.afterSaveConvertedFileCounter, 1)

	mmSaveConvertedFile.t.Helper()

	if mmSaveConvertedFile.inspectFuncSaveConvertedFile != nil {
		mmSaveConvertedFile.inspectFuncSaveConvertedFile(ctx, kbUID, fileUID, convertedFileUID, fileExt, content)
	}

	mm_params := StorageMockSaveConvertedFileParams{ctx, kbUID, fileUID, convertedFileUID, fileExt, content}

	// Record call args
	mmSaveConvertedFile.SaveConvertedFileMock.mutex.Lock()
	mmSaveConvertedFile.SaveConvertedFileMock.callArgs = append(mmSaveConvertedFile.SaveConvertedFileMock.callArgs, &mm_params)
	mmSaveConvertedFile.SaveConvertedFileMock.mutex.Unlock()

	for _, e := range mmSaveConvertedFile.SaveConvertedFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.path, e.results.err
		}
	}

	if mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.params
		mm_want_ptrs := mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.paramPtrs

		mm_got := StorageMockSaveConvertedFileParams{ctx, kbUID, fileUID, convertedFileUID, fileExt, content}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSaveConvertedFile.t.Errorf("StorageMock.SaveConvertedFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmSaveConvertedFile.t.Errorf("StorageMock.SaveConvertedFile got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmSaveConvertedFile.t.Errorf("StorageMock.SaveConvertedFile got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

			if mm_want_ptrs.convertedFileUID != nil && !minimock.Equal(*mm_want_ptrs.convertedFileUID, mm_got.convertedFileUID) {
				mmSaveConvertedFile.t.Errorf("StorageMock.SaveConvertedFile got unexpected parameter convertedFileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.expectationOrigins.originConvertedFileUID, *mm_want_ptrs.convertedFileUID, mm_got.convertedFileUID, minimock.Diff(*mm_want_ptrs.convertedFileUID, mm_got.convertedFileUID))
			}

			if mm_want_ptrs.fileExt != nil && !minimock.Equal(*mm_want_ptrs.fileExt, mm_got.fileExt) {
				mmSaveConvertedFile.t.Errorf("StorageMock.SaveConvertedFile got unexpected parameter fileExt, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.expectationOrigins.originFileExt, *mm_want_ptrs.fileExt, mm_got.fileExt, minimock.Diff(*mm_want_ptrs.fileExt, mm_got.fileExt))
			}

			if mm_want_ptrs.content != nil && !minimock.Equal(*mm_want_ptrs.content, mm_got.content) {
				mmSaveConvertedFile.t.Errorf("StorageMock.SaveConvertedFile got unexpected parameter content, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.expectationOrigins.originContent, *mm_want_ptrs.content, mm_got.content, minimock.Diff(*mm_want_ptrs.content, mm_got.content))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveConvertedFile.t.Errorf("StorageMock.SaveConvertedFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveConvertedFile.t.Fatal("No results are set for the StorageMock.SaveConvertedFile")
		}
		return (*mm_results).path, (*mm_results).err
	}
	if mmSaveConvertedFile.funcSaveConvertedFile != nil {
		return mmSaveConvertedFile.funcSaveConvertedFile(ctx, kbUID, fileUID, convertedFileUID, fileExt, content)
	}
	mmSaveConvertedFile.t.Fatalf("Unexpected call to StorageMock.SaveConvertedFile. %v %v %v %v %v %v", ctx, kbUID, fileUID, convertedFileUID, fileExt, content)
	return
}

// SaveConvertedFileAfterCounter returns a count of finished StorageMock.SaveConvertedFile invocations
func (mmSaveConvertedFile *StorageMock) SaveConvertedFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveConvertedFile.afterSaveConvertedFileCounter)
}

// SaveConvertedFileBeforeCounter returns a count of StorageMock.SaveConvertedFile invocations
func (mmSaveConvertedFile *StorageMock) SaveConvertedFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveConvertedFile.beforeSaveConvertedFileCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.SaveConvertedFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveConvertedFile *mStorageMockSaveConvertedFile) Calls() []*StorageMockSaveConvertedFileParams {
	mmSaveConvertedFile.mutex.RLock()

	argCopy := make([]*StorageMockSaveConvertedFileParams, len(mmSaveConvertedFile.callArgs))
	copy(argCopy, mmSaveConvertedFile.callArgs)

	mmSaveConvertedFile.mutex.RUnlock()

	return argCopy
}

// MinimockSaveConvertedFileDone returns true if the count of the SaveConvertedFile invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockSaveConvertedFileDone() bool {
	if m.SaveConvertedFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SaveConvertedFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SaveConvertedFileMock.invocationsDone()
}

// MinimockSaveConvertedFileInspect logs each unmet expectation
func (m *StorageMock) MinimockSaveConvertedFileInspect() {
	for _, e := range m.SaveConvertedFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.SaveConvertedFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSaveConvertedFileCounter := mm_atomic.LoadUint64(&m.afterSaveConvertedFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SaveConvertedFileMock.defaultExpectation != nil && afterSaveConvertedFileCounter < 1 {
		if m.SaveConvertedFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.SaveConvertedFile at\n%s", m.SaveConvertedFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.SaveConvertedFile at\n%s with params: %#v", m.SaveConvertedFileMock.defaultExpectation.expectationOrigins.origin, *m.SaveConvertedFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveConvertedFile != nil && afterSaveConvertedFileCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.SaveConvertedFile at\n%s", m.funcSaveConvertedFileOrigin)
	}

	if !m.SaveConvertedFileMock.invocationsDone() && afterSaveConvertedFileCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.SaveConvertedFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SaveConvertedFileMock.expectedInvocations), m.SaveConvertedFileMock.expectedInvocationsOrigin, afterSaveConvertedFileCounter)
	}
}

type mStorageMockUploadBase64File struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockUploadBase64FileExpectation
	expectations       []*StorageMockUploadBase64FileExpectation

	callArgs []*StorageMockUploadBase64FileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockUploadBase64FileExpectation specifies expectation struct of the Storage.UploadBase64File
type StorageMockUploadBase64FileExpectation struct {
	mock               *StorageMock
	params             *StorageMockUploadBase64FileParams
	paramPtrs          *StorageMockUploadBase64FileParamPtrs
	expectationOrigins StorageMockUploadBase64FileExpectationOrigins
	results            *StorageMockUploadBase64FileResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockUploadBase64FileParams contains parameters of the Storage.UploadBase64File
type StorageMockUploadBase64FileParams struct {
	ctx           context.Context
	bucket        string
	filePath      string
	base64Content string
	fileMimeType  string
}

// StorageMockUploadBase64FileParamPtrs contains pointers to parameters of the Storage.UploadBase64File
type StorageMockUploadBase64FileParamPtrs struct {
	ctx           *context.Context
	bucket        *string
	filePath      *string
	base64Content *string
	fileMimeType  *string
}

// StorageMockUploadBase64FileResults contains results of the Storage.UploadBase64File
type StorageMockUploadBase64FileResults struct {
	err error
}

// StorageMockUploadBase64FileOrigins contains origins of expectations of the Storage.UploadBase64File
type StorageMockUploadBase64FileExpectationOrigins struct {
	origin              string
	originCtx           string
	originBucket        string
	originFilePath      string
	originBase64Content string
	originFileMimeType  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUploadBase64File *mStorageMockUploadBase64File) Optional() *mStorageMockUploadBase64File {
	mmUploadBase64File.optional = true
	return mmUploadBase64File
}

// Expect sets up expected params for Storage.UploadBase64File
func (mmUploadBase64File *mStorageMockUploadBase64File) Expect(ctx context.Context, bucket string, filePath string, base64Content string, fileMimeType string) *mStorageMockUploadBase64File {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("StorageMock.UploadBase64File mock is already set by Set")
	}

	if mmUploadBase64File.defaultExpectation == nil {
		mmUploadBase64File.defaultExpectation = &StorageMockUploadBase64FileExpectation{}
	}

	if mmUploadBase64File.defaultExpectation.paramPtrs != nil {
		mmUploadBase64File.mock.t.Fatalf("StorageMock.UploadBase64File mock is already set by ExpectParams functions")
	}

	mmUploadBase64File.defaultExpectation.params = &StorageMockUploadBase64FileParams{ctx, bucket, filePath, base64Content, fileMimeType}
	mmUploadBase64File.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUploadBase64File.expectations {
		if minimock.Equal(e.params, mmUploadBase64File.defaultExpectation.params) {
			mmUploadBase64File.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUploadBase64File.defaultExpectation.params)
		}
	}

	return mmUploadBase64File
}

// ExpectCtxParam1 sets up expected param ctx for Storage.UploadBase64File
func (mmUploadBase64File *mStorageMockUploadBase64File) ExpectCtxParam1(ctx context.Context) *mStorageMockUploadBase64File {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("StorageMock.UploadBase64File mock is already set by Set")
	}

	if mmUploadBase64File.defaultExpectation == nil {
		mmUploadBase64File.defaultExpectation = &StorageMockUploadBase64FileExpectation{}
	}

	if mmUploadBase64File.defaultExpectation.params != nil {
		mmUploadBase64File.mock.t.Fatalf("StorageMock.UploadBase64File mock is already set by Expect")
	}

	if mmUploadBase64File.defaultExpectation.paramPtrs == nil {
		mmUploadBase64File.defaultExpectation.paramPtrs = &StorageMockUploadBase64FileParamPtrs{}
	}
	mmUploadBase64File.defaultExpectation.paramPtrs.ctx = &ctx
	mmUploadBase64File.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUploadBase64File
}

// ExpectBucketParam2 sets up expected param bucket for Storage.UploadBase64File
func (mmUploadBase64File *mStorageMockUploadBase64File) ExpectBucketParam2(bucket string) *mStorageMockUploadBase64File {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("StorageMock.UploadBase64File mock is already set by Set")
	}

	if mmUploadBase64File.defaultExpectation == nil {
		mmUploadBase64File.defaultExpectation = &StorageMockUploadBase64FileExpectation{}
	}

	if mmUploadBase64File.defaultExpectation.params != nil {
		mmUploadBase64File.mock.t.Fatalf("StorageMock.UploadBase64File mock is already set by Expect")
	}

	if mmUploadBase64File.defaultExpectation.paramPtrs == nil {
		mmUploadBase64File.defaultExpectation.paramPtrs = &StorageMockUploadBase64FileParamPtrs{}
	}
	mmUploadBase64File.defaultExpectation.paramPtrs.bucket = &bucket
	mmUploadBase64File.defaultExpectation.expectationOrigins.originBucket = minimock.CallerInfo(1)

	return mmUploadBase64File
}

// ExpectFilePathParam3 sets up expected param filePath for Storage.UploadBase64File
func (mmUploadBase64File *mStorageMockUploadBase64File) ExpectFilePathParam3(filePath string) *mStorageMockUploadBase64File {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("StorageMock.UploadBase64File mock is already set by Set")
	}

	if mmUploadBase64File.defaultExpectation == nil {
		mmUploadBase64File.defaultExpectation = &StorageMockUploadBase64FileExpectation{}
	}

	if mmUploadBase64File.defaultExpectation.params != nil {
		mmUploadBase64File.mock.t.Fatalf("StorageMock.UploadBase64File mock is already set by Expect")
	}

	if mmUploadBase64File.defaultExpectation.paramPtrs == nil {
		mmUploadBase64File.defaultExpectation.paramPtrs = &StorageMockUploadBase64FileParamPtrs{}
	}
	mmUploadBase64File.defaultExpectation.paramPtrs.filePath = &filePath
	mmUploadBase64File.defaultExpectation.expectationOrigins.originFilePath = minimock.CallerInfo(1)

	return mmUploadBase64File
}

// ExpectBase64ContentParam4 sets up expected param base64Content for Storage.UploadBase64File
func (mmUploadBase64File *mStorageMockUploadBase64File) ExpectBase64ContentParam4(base64Content string) *mStorageMockUploadBase64File {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("StorageMock.UploadBase64File mock is already set by Set")
	}

	if mmUploadBase64File.defaultExpectation == nil {
		mmUploadBase64File.defaultExpectation = &StorageMockUploadBase64FileExpectation{}
	}

	if mmUploadBase64File.defaultExpectation.params != nil {
		mmUploadBase64File.mock.t.Fatalf("StorageMock.UploadBase64File mock is already set by Expect")
	}

	if mmUploadBase64File.defaultExpectation.paramPtrs == nil {
		mmUploadBase64File.defaultExpectation.paramPtrs = &StorageMockUploadBase64FileParamPtrs{}
	}
	mmUploadBase64File.defaultExpectation.paramPtrs.base64Content = &base64Content
	mmUploadBase64File.defaultExpectation.expectationOrigins.originBase64Content = minimock.CallerInfo(1)

	return mmUploadBase64File
}

// ExpectFileMimeTypeParam5 sets up expected param fileMimeType for Storage.UploadBase64File
func (mmUploadBase64File *mStorageMockUploadBase64File) ExpectFileMimeTypeParam5(fileMimeType string) *mStorageMockUploadBase64File {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("StorageMock.UploadBase64File mock is already set by Set")
	}

	if mmUploadBase64File.defaultExpectation == nil {
		mmUploadBase64File.defaultExpectation = &StorageMockUploadBase64FileExpectation{}
	}

	if mmUploadBase64File.defaultExpectation.params != nil {
		mmUploadBase64File.mock.t.Fatalf("StorageMock.UploadBase64File mock is already set by Expect")
	}

	if mmUploadBase64File.defaultExpectation.paramPtrs == nil {
		mmUploadBase64File.defaultExpectation.paramPtrs = &StorageMockUploadBase64FileParamPtrs{}
	}
	mmUploadBase64File.defaultExpectation.paramPtrs.fileMimeType = &fileMimeType
	mmUploadBase64File.defaultExpectation.expectationOrigins.originFileMimeType = minimock.CallerInfo(1)

	return mmUploadBase64File
}

// Inspect accepts an inspector function that has same arguments as the Storage.UploadBase64File
func (mmUploadBase64File *mStorageMockUploadBase64File) Inspect(f func(ctx context.Context, bucket string, filePath string, base64Content string, fileMimeType string)) *mStorageMockUploadBase64File {
	if mmUploadBase64File.mock.inspectFuncUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("Inspect function is already set for StorageMock.UploadBase64File")
	}

	mmUploadBase64File.mock.inspectFuncUploadBase64File = f

	return mmUploadBase64File
}

// Return sets up results that will be returned by Storage.UploadBase64File
func (mmUploadBase64File *mStorageMockUploadBase64File) Return(err error) *StorageMock {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("StorageMock.UploadBase64File mock is already set by Set")
	}

	if mmUploadBase64File.defaultExpectation == nil {
		mmUploadBase64File.defaultExpectation = &StorageMockUploadBase64FileExpectation{mock: mmUploadBase64File.mock}
	}
	mmUploadBase64File.defaultExpectation.results = &StorageMockUploadBase64FileResults{err}
	mmUploadBase64File.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUploadBase64File.mock
}

// Set uses given function f to mock the Storage.UploadBase64File method
func (mmUploadBase64File *mStorageMockUploadBase64File) Set(f func(ctx context.Context, bucket string, filePath string, base64Content string, fileMimeType string) (err error)) *StorageMock {
	if mmUploadBase64File.defaultExpectation != nil {
		mmUploadBase64File.mock.t.Fatalf("Default expectation is already set for the Storage.UploadBase64File method")
	}

	if len(mmUploadBase64File.expectations) > 0 {
		mmUploadBase64File.mock.t.Fatalf("Some expectations are already set for the Storage.UploadBase64File method")
	}

	mmUploadBase64File.mock.funcUploadBase64File = f
	mmUploadBase64File.mock.funcUploadBase64FileOrigin = minimock.CallerInfo(1)
	return mmUploadBase64File.mock
}

// When sets expectation for the Storage.UploadBase64File which will trigger the result defined by the following
// Then helper
func (mmUploadBase64File *mStorageMockUploadBase64File) When(ctx context.Context, bucket string, filePath string, base64Content string, fileMimeType string) *StorageMockUploadBase64FileExpectation {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("StorageMock.UploadBase64File mock is already set by Set")
	}

	expectation := &StorageMockUploadBase64FileExpectation{
		mock:               mmUploadBase64File.mock,
		params:             &StorageMockUploadBase64FileParams{ctx, bucket, filePath, base64Content, fileMimeType},
		expectationOrigins: StorageMockUploadBase64FileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUploadBase64File.expectations = append(mmUploadBase64File.expectations, expectation)
	return expectation
}

// Then sets up Storage.UploadBase64File return parameters for the expectation previously defined by the When method
func (e *StorageMockUploadBase64FileExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockUploadBase64FileResults{err}
	return e.mock
}

// Times sets number of times Storage.UploadBase64File should be invoked
func (mmUploadBase64File *mStorageMockUploadBase64File) Times(n uint64) *mStorageMockUploadBase64File {
	if n == 0 {
		mmUploadBase64File.mock.t.Fatalf("Times of StorageMock.UploadBase64File mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUploadBase64File.expectedInvocations, n)
	mmUploadBase64File.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUploadBase64File
}

func (mmUploadBase64File *mStorageMockUploadBase64File) invocationsDone() bool {
	if len(mmUploadBase64File.expectations) == 0 && mmUploadBase64File.defaultExpectation == nil && mmUploadBase64File.mock.funcUploadBase64File == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUploadBase64File.mock.afterUploadBase64FileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUploadBase64File.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UploadBase64File implements mm_object.Storage
func (mmUploadBase64File *StorageMock) UploadBase64File(ctx context.Context, bucket string, filePath string, base64Content string, fileMimeType string) (err error) {
	mm_atomic.AddUint64(&mmUploadBase64File.beforeUploadBase64FileCounter, 1)
	defer mm_atomic.AddUint64(&mmUploadBase64File.afterUploadBase64FileCounter, 1)

	mmUploadBase64File.t.Helper()

	if mmUploadBase64File.inspectFuncUploadBase64File != nil {
		mmUploadBase64File.inspectFuncUploadBase64File(ctx, bucket, filePath, base64Content, fileMimeType)
	}

	mm_params := StorageMockUploadBase64FileParams{ctx, bucket, filePath, base64Content, fileMimeType}

	// Record call args
	mmUploadBase64File.UploadBase64FileMock.mutex.Lock()
	mmUploadBase64File.UploadBase64FileMock.callArgs = append(mmUploadBase64File.UploadBase64FileMock.callArgs, &mm_params)
	mmUploadBase64File.UploadBase64FileMock.mutex.Unlock()

	for _, e := range mmUploadBase64File.UploadBase64FileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUploadBase64File.UploadBase64FileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUploadBase64File.UploadBase64FileMock.defaultExpectation.Counter, 1)
		mm_want := mmUploadBase64File.UploadBase64FileMock.defaultExpectation.params
		mm_want_ptrs := mmUploadBase64File.UploadBase64FileMock.defaultExpectation.paramPtrs

		mm_got := StorageMockUploadBase64FileParams{ctx, bucket, filePath, base64Content, fileMimeType}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUploadBase64File.t.Errorf("StorageMock.UploadBase64File got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadBase64File.UploadBase64FileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.bucket != nil && !minimock.Equal(*mm_want_ptrs.bucket, mm_got.bucket) {
				mmUploadBase64File.t.Errorf("StorageMock.UploadBase64File got unexpected parameter bucket, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadBase64File.UploadBase64FileMock.defaultExpectation.expectationOrigins.originBucket, *mm_want_ptrs.bucket, mm_got.bucket, minimock.Diff(*mm_want_ptrs.bucket, mm_got.bucket))
			}

			if mm_want_ptrs.filePath != nil && !minimock.Equal(*mm_want_ptrs.filePath, mm_got.filePath) {
				mmUploadBase64File.t.Errorf("StorageMock.UploadBase64File got unexpected parameter filePath, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadBase64File.UploadBase64FileMock.defaultExpectation.expectationOrigins.originFilePath, *mm_want_ptrs.filePath, mm_got.filePath, minimock.Diff(*mm_want_ptrs.filePath, mm_got.filePath))
			}

			if mm_want_ptrs.base64Content != nil && !minimock.Equal(*mm_want_ptrs.base64Content, mm_got.base64Content) {
				mmUploadBase64File.t.Errorf("StorageMock.UploadBase64File got unexpected parameter base64Content, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadBase64File.UploadBase64FileMock.defaultExpectation.expectationOrigins.originBase64Content, *mm_want_ptrs.base64Content, mm_got.base64Content, minimock.Diff(*mm_want_ptrs.base64Content, mm_got.base64Content))
			}

			if mm_want_ptrs.fileMimeType != nil && !minimock.Equal(*mm_want_ptrs.fileMimeType, mm_got.fileMimeType) {
				mmUploadBase64File.t.Errorf("StorageMock.UploadBase64File got unexpected parameter fileMimeType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadBase64File.UploadBase64FileMock.defaultExpectation.expectationOrigins.originFileMimeType, *mm_want_ptrs.fileMimeType, mm_got.fileMimeType, minimock.Diff(*mm_want_ptrs.fileMimeType, mm_got.fileMimeType))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUploadBase64File.t.Errorf("StorageMock.UploadBase64File got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUploadBase64File.UploadBase64FileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUploadBase64File.UploadBase64FileMock.defaultExpectation.results
		if mm_results == nil {
			mmUploadBase64File.t.Fatal("No results are set for the StorageMock.UploadBase64File")
		}
		return (*mm_results).err
	}
	if mmUploadBase64File.funcUploadBase64File != nil {
		return mmUploadBase64File.funcUploadBase64File(ctx, bucket, filePath, base64Content, fileMimeType)
	}
	mmUploadBase64File.t.Fatalf("Unexpected call to StorageMock.UploadBase64File. %v %v %v %v %v", ctx, bucket, filePath, base64Content, fileMimeType)
	return
}

// UploadBase64FileAfterCounter returns a count of finished StorageMock.UploadBase64File invocations
func (mmUploadBase64File *StorageMock) UploadBase64FileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadBase64File.afterUploadBase64FileCounter)
}

// UploadBase64FileBeforeCounter returns a count of StorageMock.UploadBase64File invocations
func (mmUploadBase64File *StorageMock) UploadBase64FileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadBase64File.beforeUploadBase64FileCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.UploadBase64File.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUploadBase64File *mStorageMockUploadBase64File) Calls() []*StorageMockUploadBase64FileParams {
	mmUploadBase64File.mutex.RLock()

	argCopy := make([]*StorageMockUploadBase64FileParams, len(mmUploadBase64File.callArgs))
	copy(argCopy, mmUploadBase64File.callArgs)

	mmUploadBase64File.mutex.RUnlock()

	return argCopy
}

// MinimockUploadBase64FileDone returns true if the count of the UploadBase64File invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockUploadBase64FileDone() bool {
	if m.UploadBase64FileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UploadBase64FileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UploadBase64FileMock.invocationsDone()
}

// MinimockUploadBase64FileInspect logs each unmet expectation
func (m *StorageMock) MinimockUploadBase64FileInspect() {
	for _, e := range m.UploadBase64FileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.UploadBase64File at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUploadBase64FileCounter := mm_atomic.LoadUint64(&m.afterUploadBase64FileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UploadBase64FileMock.defaultExpectation != nil && afterUploadBase64FileCounter < 1 {
		if m.UploadBase64FileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.UploadBase64File at\n%s", m.UploadBase64FileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.UploadBase64File at\n%s with params: %#v", m.UploadBase64FileMock.defaultExpectation.expectationOrigins.origin, *m.UploadBase64FileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUploadBase64File != nil && afterUploadBase64FileCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.UploadBase64File at\n%s", m.funcUploadBase64FileOrigin)
	}

	if !m.UploadBase64FileMock.invocationsDone() && afterUploadBase64FileCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.UploadBase64File at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UploadBase64FileMock.expectedInvocations), m.UploadBase64FileMock.expectedInvocationsOrigin, afterUploadBase64FileCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDeleteFileInspect()

			m.MinimockGetBucketInspect()

			m.MinimockGetFileInspect()

			m.MinimockGetFileMetadataInspect()

			m.MinimockGetPresignedURLForDownloadInspect()

			m.MinimockGetPresignedURLForUploadInspect()

			m.MinimockListConvertedFilesByFileUIDInspect()

			m.MinimockListFilePathsWithPrefixInspect()

			m.MinimockListKnowledgeBaseFilePathsInspect()

			m.MinimockListTextChunksByFileUIDInspect()

			m.MinimockSaveConvertedFileInspect()

			m.MinimockUploadBase64FileInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeleteFileDone() &&
		m.MinimockGetBucketDone() &&
		m.MinimockGetFileDone() &&
		m.MinimockGetFileMetadataDone() &&
		m.MinimockGetPresignedURLForDownloadDone() &&
		m.MinimockGetPresignedURLForUploadDone() &&
		m.MinimockListConvertedFilesByFileUIDDone() &&
		m.MinimockListFilePathsWithPrefixDone() &&
		m.MinimockListKnowledgeBaseFilePathsDone() &&
		m.MinimockListTextChunksByFileUIDDone() &&
		m.MinimockSaveConvertedFileDone() &&
		m.MinimockUploadBase64FileDone()
}
