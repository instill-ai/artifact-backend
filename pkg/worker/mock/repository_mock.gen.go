// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mock

import (
	"context"
	"net/url"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_repository "github.com/instill-ai/artifact-backend/pkg/repository"
	"github.com/instill-ai/artifact-backend/pkg/types"
	"github.com/instill-ai/artifact-backend/pkg/utils"
	artifactpb "github.com/instill-ai/protogen-go/artifact/artifact/v1alpha"
	"github.com/minio/minio-go/v7"
	"gorm.io/gorm"
)

// RepositoryMock implements mm_repository.Repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCheckFileUIDMetadata          func(ctx context.Context, collectionID string) (b1 bool, err error)
	funcCheckFileUIDMetadataOrigin    string
	inspectFuncCheckFileUIDMetadata   func(ctx context.Context, collectionID string)
	afterCheckFileUIDMetadataCounter  uint64
	beforeCheckFileUIDMetadataCounter uint64
	CheckFileUIDMetadataMock          mRepositoryMockCheckFileUIDMetadata

	funcCreateCollection          func(ctx context.Context, id string) (err error)
	funcCreateCollectionOrigin    string
	inspectFuncCreateCollection   func(ctx context.Context, id string)
	afterCreateCollectionCounter  uint64
	beforeCreateCollectionCounter uint64
	CreateCollectionMock          mRepositoryMockCreateCollection

	funcCreateConvertedFileWithDestination          func(ctx context.Context, cf mm_repository.ConvertedFileModel) (cp1 *mm_repository.ConvertedFileModel, err error)
	funcCreateConvertedFileWithDestinationOrigin    string
	inspectFuncCreateConvertedFileWithDestination   func(ctx context.Context, cf mm_repository.ConvertedFileModel)
	afterCreateConvertedFileWithDestinationCounter  uint64
	beforeCreateConvertedFileWithDestinationCounter uint64
	CreateConvertedFileWithDestinationMock          mRepositoryMockCreateConvertedFileWithDestination

	funcCreateEmbeddings          func(ctx context.Context, embeddings []mm_repository.EmbeddingModel, externalServiceCall func([]mm_repository.EmbeddingModel) error) (ea1 []mm_repository.EmbeddingModel, err error)
	funcCreateEmbeddingsOrigin    string
	inspectFuncCreateEmbeddings   func(ctx context.Context, embeddings []mm_repository.EmbeddingModel, externalServiceCall func([]mm_repository.EmbeddingModel) error)
	afterCreateEmbeddingsCounter  uint64
	beforeCreateEmbeddingsCounter uint64
	CreateEmbeddingsMock          mRepositoryMockCreateEmbeddings

	funcCreateKnowledgeBase          func(ctx context.Context, kb mm_repository.KnowledgeBaseModel, externalService func(kbUID types.KBUIDType) error) (kp1 *mm_repository.KnowledgeBaseModel, err error)
	funcCreateKnowledgeBaseOrigin    string
	inspectFuncCreateKnowledgeBase   func(ctx context.Context, kb mm_repository.KnowledgeBaseModel, externalService func(kbUID types.KBUIDType) error)
	afterCreateKnowledgeBaseCounter  uint64
	beforeCreateKnowledgeBaseCounter uint64
	CreateKnowledgeBaseMock          mRepositoryMockCreateKnowledgeBase

	funcCreateKnowledgeBaseFile          func(ctx context.Context, kb mm_repository.KnowledgeBaseFileModel, externalServiceCall func(fileUID string) error) (kp1 *mm_repository.KnowledgeBaseFileModel, err error)
	funcCreateKnowledgeBaseFileOrigin    string
	inspectFuncCreateKnowledgeBaseFile   func(ctx context.Context, kb mm_repository.KnowledgeBaseFileModel, externalServiceCall func(fileUID string) error)
	afterCreateKnowledgeBaseFileCounter  uint64
	beforeCreateKnowledgeBaseFileCounter uint64
	CreateKnowledgeBaseFileMock          mRepositoryMockCreateKnowledgeBaseFile

	funcCreateObject          func(ctx context.Context, obj mm_repository.ObjectModel) (op1 *mm_repository.ObjectModel, err error)
	funcCreateObjectOrigin    string
	inspectFuncCreateObject   func(ctx context.Context, obj mm_repository.ObjectModel)
	afterCreateObjectCounter  uint64
	beforeCreateObjectCounter uint64
	CreateObjectMock          mRepositoryMockCreateObject

	funcCreateTextChunks          func(ctx context.Context, textChunks []*mm_repository.TextChunkModel) (err error)
	funcCreateTextChunksOrigin    string
	inspectFuncCreateTextChunks   func(ctx context.Context, textChunks []*mm_repository.TextChunkModel)
	afterCreateTextChunksCounter  uint64
	beforeCreateTextChunksCounter uint64
	CreateTextChunksMock          mRepositoryMockCreateTextChunks

	funcDeleteAllConvertedFilesInKb          func(ctx context.Context, kbUID types.KBUIDType) (err error)
	funcDeleteAllConvertedFilesInKbOrigin    string
	inspectFuncDeleteAllConvertedFilesInKb   func(ctx context.Context, kbUID types.KBUIDType)
	afterDeleteAllConvertedFilesInKbCounter  uint64
	beforeDeleteAllConvertedFilesInKbCounter uint64
	DeleteAllConvertedFilesInKbMock          mRepositoryMockDeleteAllConvertedFilesInKb

	funcDeleteAllKnowledgeBaseFiles          func(ctx context.Context, kbUID string) (err error)
	funcDeleteAllKnowledgeBaseFilesOrigin    string
	inspectFuncDeleteAllKnowledgeBaseFiles   func(ctx context.Context, kbUID string)
	afterDeleteAllKnowledgeBaseFilesCounter  uint64
	beforeDeleteAllKnowledgeBaseFilesCounter uint64
	DeleteAllKnowledgeBaseFilesMock          mRepositoryMockDeleteAllKnowledgeBaseFiles

	funcDeleteAndCreateEmbeddings          func(ctx context.Context, fileUID types.FileUIDType, embeddings []mm_repository.EmbeddingModel, externalServiceCall func([]mm_repository.EmbeddingModel) error) (ea1 []mm_repository.EmbeddingModel, err error)
	funcDeleteAndCreateEmbeddingsOrigin    string
	inspectFuncDeleteAndCreateEmbeddings   func(ctx context.Context, fileUID types.FileUIDType, embeddings []mm_repository.EmbeddingModel, externalServiceCall func([]mm_repository.EmbeddingModel) error)
	afterDeleteAndCreateEmbeddingsCounter  uint64
	beforeDeleteAndCreateEmbeddingsCounter uint64
	DeleteAndCreateEmbeddingsMock          mRepositoryMockDeleteAndCreateEmbeddings

	funcDeleteAndCreateTextChunks          func(ctx context.Context, fileUID types.FileUIDType, textChunks []*mm_repository.TextChunkModel, externalServiceCall func(chunkUIDs []string) (destinations map[string]string, _ error)) (tpa1 []*mm_repository.TextChunkModel, err error)
	funcDeleteAndCreateTextChunksOrigin    string
	inspectFuncDeleteAndCreateTextChunks   func(ctx context.Context, fileUID types.FileUIDType, textChunks []*mm_repository.TextChunkModel, externalServiceCall func(chunkUIDs []string) (destinations map[string]string, _ error))
	afterDeleteAndCreateTextChunksCounter  uint64
	beforeDeleteAndCreateTextChunksCounter uint64
	DeleteAndCreateTextChunksMock          mRepositoryMockDeleteAndCreateTextChunks

	funcDeleteChatCacheMetadata          func(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType) (err error)
	funcDeleteChatCacheMetadataOrigin    string
	inspectFuncDeleteChatCacheMetadata   func(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType)
	afterDeleteChatCacheMetadataCounter  uint64
	beforeDeleteChatCacheMetadataCounter uint64
	DeleteChatCacheMetadataMock          mRepositoryMockDeleteChatCacheMetadata

	funcDeleteConvertedFile          func(ctx context.Context, uid types.ConvertedFileUIDType) (err error)
	funcDeleteConvertedFileOrigin    string
	inspectFuncDeleteConvertedFile   func(ctx context.Context, uid types.ConvertedFileUIDType)
	afterDeleteConvertedFileCounter  uint64
	beforeDeleteConvertedFileCounter uint64
	DeleteConvertedFileMock          mRepositoryMockDeleteConvertedFile

	funcDeleteEmbeddingsByKBFileUID          func(ctx context.Context, kbFileUID types.FileUIDType) (err error)
	funcDeleteEmbeddingsByKBFileUIDOrigin    string
	inspectFuncDeleteEmbeddingsByKBFileUID   func(ctx context.Context, kbFileUID types.FileUIDType)
	afterDeleteEmbeddingsByKBFileUIDCounter  uint64
	beforeDeleteEmbeddingsByKBFileUIDCounter uint64
	DeleteEmbeddingsByKBFileUIDMock          mRepositoryMockDeleteEmbeddingsByKBFileUID

	funcDeleteEmbeddingsWithFileUID          func(ctx context.Context, collID string, fileUID types.FileUIDType) (err error)
	funcDeleteEmbeddingsWithFileUIDOrigin    string
	inspectFuncDeleteEmbeddingsWithFileUID   func(ctx context.Context, collID string, fileUID types.FileUIDType)
	afterDeleteEmbeddingsWithFileUIDCounter  uint64
	beforeDeleteEmbeddingsWithFileUIDCounter uint64
	DeleteEmbeddingsWithFileUIDMock          mRepositoryMockDeleteEmbeddingsWithFileUID

	funcDeleteFile          func(ctx context.Context, bucket string, filePath string) (err error)
	funcDeleteFileOrigin    string
	inspectFuncDeleteFile   func(ctx context.Context, bucket string, filePath string)
	afterDeleteFileCounter  uint64
	beforeDeleteFileCounter uint64
	DeleteFileMock          mRepositoryMockDeleteFile

	funcDeleteKnowledgeBase          func(ctx context.Context, ownerUID string, kbID string) (kp1 *mm_repository.KnowledgeBaseModel, err error)
	funcDeleteKnowledgeBaseOrigin    string
	inspectFuncDeleteKnowledgeBase   func(ctx context.Context, ownerUID string, kbID string)
	afterDeleteKnowledgeBaseCounter  uint64
	beforeDeleteKnowledgeBaseCounter uint64
	DeleteKnowledgeBaseMock          mRepositoryMockDeleteKnowledgeBase

	funcDeleteKnowledgeBaseFile          func(ctx context.Context, fileUID string) (err error)
	funcDeleteKnowledgeBaseFileOrigin    string
	inspectFuncDeleteKnowledgeBaseFile   func(ctx context.Context, fileUID string)
	afterDeleteKnowledgeBaseFileCounter  uint64
	beforeDeleteKnowledgeBaseFileCounter uint64
	DeleteKnowledgeBaseFileMock          mRepositoryMockDeleteKnowledgeBaseFile

	funcDeleteKnowledgeBaseFileAndDecreaseUsage          func(ctx context.Context, fileUID types.FileUIDType) (err error)
	funcDeleteKnowledgeBaseFileAndDecreaseUsageOrigin    string
	inspectFuncDeleteKnowledgeBaseFileAndDecreaseUsage   func(ctx context.Context, fileUID types.FileUIDType)
	afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter  uint64
	beforeDeleteKnowledgeBaseFileAndDecreaseUsageCounter uint64
	DeleteKnowledgeBaseFileAndDecreaseUsageMock          mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage

	funcDeleteObject          func(ctx context.Context, uid types.ObjectUIDType) (err error)
	funcDeleteObjectOrigin    string
	inspectFuncDeleteObject   func(ctx context.Context, uid types.ObjectUIDType)
	afterDeleteObjectCounter  uint64
	beforeDeleteObjectCounter uint64
	DeleteObjectMock          mRepositoryMockDeleteObject

	funcDeleteObjectURL          func(ctx context.Context, uid types.ObjectURLUIDType) (err error)
	funcDeleteObjectURLOrigin    string
	inspectFuncDeleteObjectURL   func(ctx context.Context, uid types.ObjectURLUIDType)
	afterDeleteObjectURLCounter  uint64
	beforeDeleteObjectURLCounter uint64
	DeleteObjectURLMock          mRepositoryMockDeleteObjectURL

	funcDeleteRepositoryTag          func(ctx context.Context, s1 string) (err error)
	funcDeleteRepositoryTagOrigin    string
	inspectFuncDeleteRepositoryTag   func(ctx context.Context, s1 string)
	afterDeleteRepositoryTagCounter  uint64
	beforeDeleteRepositoryTagCounter uint64
	DeleteRepositoryTagMock          mRepositoryMockDeleteRepositoryTag

	funcDropCollection          func(ctx context.Context, id string) (err error)
	funcDropCollectionOrigin    string
	inspectFuncDropCollection   func(ctx context.Context, id string)
	afterDropCollectionCounter  uint64
	beforeDropCollectionCounter uint64
	DropCollectionMock          mRepositoryMockDropCollection

	funcFlushCollection          func(ctx context.Context, collectionID string) (err error)
	funcFlushCollectionOrigin    string
	inspectFuncFlushCollection   func(ctx context.Context, collectionID string)
	afterFlushCollectionCounter  uint64
	beforeFlushCollectionCounter uint64
	FlushCollectionMock          mRepositoryMockFlushCollection

	funcGetAllConvertedFilesByFileUID          func(ctx context.Context, fileUID types.FileUIDType) (ca1 []mm_repository.ConvertedFileModel, err error)
	funcGetAllConvertedFilesByFileUIDOrigin    string
	inspectFuncGetAllConvertedFilesByFileUID   func(ctx context.Context, fileUID types.FileUIDType)
	afterGetAllConvertedFilesByFileUIDCounter  uint64
	beforeGetAllConvertedFilesByFileUIDCounter uint64
	GetAllConvertedFilesByFileUIDMock          mRepositoryMockGetAllConvertedFilesByFileUID

	funcGetChatCacheMetadata          func(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType) (cp1 *mm_repository.ChatCacheMetadata, err error)
	funcGetChatCacheMetadataOrigin    string
	inspectFuncGetChatCacheMetadata   func(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType)
	afterGetChatCacheMetadataCounter  uint64
	beforeGetChatCacheMetadataCounter uint64
	GetChatCacheMetadataMock          mRepositoryMockGetChatCacheMetadata

	funcGetConvertedFileByFileUID          func(ctx context.Context, fileUID types.FileUIDType) (cp1 *mm_repository.ConvertedFileModel, err error)
	funcGetConvertedFileByFileUIDOrigin    string
	inspectFuncGetConvertedFileByFileUID   func(ctx context.Context, fileUID types.FileUIDType)
	afterGetConvertedFileByFileUIDCounter  uint64
	beforeGetConvertedFileByFileUIDCounter uint64
	GetConvertedFileByFileUIDMock          mRepositoryMockGetConvertedFileByFileUID

	funcGetConvertedFileByFileUIDAndType          func(ctx context.Context, fileUID types.FileUIDType, convertedType artifactpb.ConvertedFileType) (cp1 *mm_repository.ConvertedFileModel, err error)
	funcGetConvertedFileByFileUIDAndTypeOrigin    string
	inspectFuncGetConvertedFileByFileUIDAndType   func(ctx context.Context, fileUID types.FileUIDType, convertedType artifactpb.ConvertedFileType)
	afterGetConvertedFileByFileUIDAndTypeCounter  uint64
	beforeGetConvertedFileByFileUIDAndTypeCounter uint64
	GetConvertedFileByFileUIDAndTypeMock          mRepositoryMockGetConvertedFileByFileUIDAndType

	funcGetCountFilesByListKnowledgeBaseUID          func(ctx context.Context, kbUIDs []types.KBUIDType) (m1 map[types.KBUIDType]int64, err error)
	funcGetCountFilesByListKnowledgeBaseUIDOrigin    string
	inspectFuncGetCountFilesByListKnowledgeBaseUID   func(ctx context.Context, kbUIDs []types.KBUIDType)
	afterGetCountFilesByListKnowledgeBaseUIDCounter  uint64
	beforeGetCountFilesByListKnowledgeBaseUIDCounter uint64
	GetCountFilesByListKnowledgeBaseUIDMock          mRepositoryMockGetCountFilesByListKnowledgeBaseUID

	funcGetFile          func(ctx context.Context, bucket string, filePath string) (ba1 []byte, err error)
	funcGetFileOrigin    string
	inspectFuncGetFile   func(ctx context.Context, bucket string, filePath string)
	afterGetFileCounter  uint64
	beforeGetFileCounter uint64
	GetFileMock          mRepositoryMockGetFile

	funcGetFileMetadata          func(ctx context.Context, bucket string, filePath string) (op1 *minio.ObjectInfo, err error)
	funcGetFileMetadataOrigin    string
	inspectFuncGetFileMetadata   func(ctx context.Context, bucket string, filePath string)
	afterGetFileMetadataCounter  uint64
	beforeGetFileMetadataCounter uint64
	GetFileMetadataMock          mRepositoryMockGetFileMetadata

	funcGetFilesTotalTokens func(ctx context.Context, sources map[types.FileUIDType]struct {
		SourceTable types.SourceTableType
		SourceUID   types.SourceUIDType
	}) (m1 map[types.FileUIDType]int, err error)
	funcGetFilesTotalTokensOrigin  string
	inspectFuncGetFilesTotalTokens func(ctx context.Context, sources map[types.FileUIDType]struct {
		SourceTable types.SourceTableType
		SourceUID   types.SourceUIDType
	})
	afterGetFilesTotalTokensCounter  uint64
	beforeGetFilesTotalTokensCounter uint64
	GetFilesTotalTokensMock          mRepositoryMockGetFilesTotalTokens

	funcGetKnowledgeBaseByOwnerAndKbID          func(ctx context.Context, ownerUID types.OwnerUIDType, kbID string) (kp1 *mm_repository.KnowledgeBaseModel, err error)
	funcGetKnowledgeBaseByOwnerAndKbIDOrigin    string
	inspectFuncGetKnowledgeBaseByOwnerAndKbID   func(ctx context.Context, ownerUID types.OwnerUIDType, kbID string)
	afterGetKnowledgeBaseByOwnerAndKbIDCounter  uint64
	beforeGetKnowledgeBaseByOwnerAndKbIDCounter uint64
	GetKnowledgeBaseByOwnerAndKbIDMock          mRepositoryMockGetKnowledgeBaseByOwnerAndKbID

	funcGetKnowledgeBaseByUID          func(ctx context.Context, k1 types.KBUIDType) (kp1 *mm_repository.KnowledgeBaseModel, err error)
	funcGetKnowledgeBaseByUIDOrigin    string
	inspectFuncGetKnowledgeBaseByUID   func(ctx context.Context, k1 types.KBUIDType)
	afterGetKnowledgeBaseByUIDCounter  uint64
	beforeGetKnowledgeBaseByUIDCounter uint64
	GetKnowledgeBaseByUIDMock          mRepositoryMockGetKnowledgeBaseByUID

	funcGetKnowledgeBaseCountByOwner          func(ctx context.Context, ownerUID string, catalogType artifactpb.CatalogType) (i1 int64, err error)
	funcGetKnowledgeBaseCountByOwnerOrigin    string
	inspectFuncGetKnowledgeBaseCountByOwner   func(ctx context.Context, ownerUID string, catalogType artifactpb.CatalogType)
	afterGetKnowledgeBaseCountByOwnerCounter  uint64
	beforeGetKnowledgeBaseCountByOwnerCounter uint64
	GetKnowledgeBaseCountByOwnerMock          mRepositoryMockGetKnowledgeBaseCountByOwner

	funcGetKnowledgeBaseFilesByFileUIDs          func(ctx context.Context, fileUIDs []types.FileUIDType, columns ...string) (ka1 []mm_repository.KnowledgeBaseFileModel, err error)
	funcGetKnowledgeBaseFilesByFileUIDsOrigin    string
	inspectFuncGetKnowledgeBaseFilesByFileUIDs   func(ctx context.Context, fileUIDs []types.FileUIDType, columns ...string)
	afterGetKnowledgeBaseFilesByFileUIDsCounter  uint64
	beforeGetKnowledgeBaseFilesByFileUIDsCounter uint64
	GetKnowledgeBaseFilesByFileUIDsMock          mRepositoryMockGetKnowledgeBaseFilesByFileUIDs

	funcGetKnowledgeBasesByUIDs          func(ctx context.Context, kbUIDs []types.KBUIDType) (ka1 []mm_repository.KnowledgeBaseModel, err error)
	funcGetKnowledgeBasesByUIDsOrigin    string
	inspectFuncGetKnowledgeBasesByUIDs   func(ctx context.Context, kbUIDs []types.KBUIDType)
	afterGetKnowledgeBasesByUIDsCounter  uint64
	beforeGetKnowledgeBasesByUIDsCounter uint64
	GetKnowledgeBasesByUIDsMock          mRepositoryMockGetKnowledgeBasesByUIDs

	funcGetKnowledgebaseFileByKBUIDAndFileID          func(ctx context.Context, kbUID types.KBUIDType, fileID string) (kp1 *mm_repository.KnowledgeBaseFileModel, err error)
	funcGetKnowledgebaseFileByKBUIDAndFileIDOrigin    string
	inspectFuncGetKnowledgebaseFileByKBUIDAndFileID   func(ctx context.Context, kbUID types.KBUIDType, fileID string)
	afterGetKnowledgebaseFileByKBUIDAndFileIDCounter  uint64
	beforeGetKnowledgebaseFileByKBUIDAndFileIDCounter uint64
	GetKnowledgebaseFileByKBUIDAndFileIDMock          mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID

	funcGetObjectByUID          func(ctx context.Context, uid types.ObjectUIDType) (op1 *mm_repository.ObjectModel, err error)
	funcGetObjectByUIDOrigin    string
	inspectFuncGetObjectByUID   func(ctx context.Context, uid types.ObjectUIDType)
	afterGetObjectByUIDCounter  uint64
	beforeGetObjectByUIDCounter uint64
	GetObjectByUIDMock          mRepositoryMockGetObjectByUID

	funcGetObjectDownloadURL          func(ctx context.Context, objectUID types.ObjectUIDType) (op1 *mm_repository.ObjectURLModel, err error)
	funcGetObjectDownloadURLOrigin    string
	inspectFuncGetObjectDownloadURL   func(ctx context.Context, objectUID types.ObjectUIDType)
	afterGetObjectDownloadURLCounter  uint64
	beforeGetObjectDownloadURLCounter uint64
	GetObjectDownloadURLMock          mRepositoryMockGetObjectDownloadURL

	funcGetObjectURLByEncodedURLPath          func(ctx context.Context, encodedURLPath string) (op1 *mm_repository.ObjectURLModel, err error)
	funcGetObjectURLByEncodedURLPathOrigin    string
	inspectFuncGetObjectURLByEncodedURLPath   func(ctx context.Context, encodedURLPath string)
	afterGetObjectURLByEncodedURLPathCounter  uint64
	beforeGetObjectURLByEncodedURLPathCounter uint64
	GetObjectURLByEncodedURLPathMock          mRepositoryMockGetObjectURLByEncodedURLPath

	funcGetObjectURLByUID          func(ctx context.Context, uid types.ObjectURLUIDType) (op1 *mm_repository.ObjectURLModel, err error)
	funcGetObjectURLByUIDOrigin    string
	inspectFuncGetObjectURLByUID   func(ctx context.Context, uid types.ObjectURLUIDType)
	afterGetObjectURLByUIDCounter  uint64
	beforeGetObjectURLByUIDCounter uint64
	GetObjectURLByUIDMock          mRepositoryMockGetObjectURLByUID

	funcGetObjectURLCountByObject          func(ctx context.Context, objectUID types.ObjectUIDType) (i1 int64, err error)
	funcGetObjectURLCountByObjectOrigin    string
	inspectFuncGetObjectURLCountByObject   func(ctx context.Context, objectUID types.ObjectUIDType)
	afterGetObjectURLCountByObjectCounter  uint64
	beforeGetObjectURLCountByObjectCounter uint64
	GetObjectURLCountByObjectMock          mRepositoryMockGetObjectURLCountByObject

	funcGetObjectUploadURL          func(ctx context.Context, objectUID types.ObjectUIDType) (op1 *mm_repository.ObjectURLModel, err error)
	funcGetObjectUploadURLOrigin    string
	inspectFuncGetObjectUploadURL   func(ctx context.Context, objectUID types.ObjectUIDType)
	afterGetObjectUploadURLCounter  uint64
	beforeGetObjectUploadURLCounter uint64
	GetObjectUploadURLMock          mRepositoryMockGetObjectUploadURL

	funcGetPresignedURLForDownload          func(ctx context.Context, namespaceUUID types.NamespaceUIDType, objectUUID types.ObjectUIDType, filename string, contentType string, urlExpiration time.Duration) (up1 *url.URL, err error)
	funcGetPresignedURLForDownloadOrigin    string
	inspectFuncGetPresignedURLForDownload   func(ctx context.Context, namespaceUUID types.NamespaceUIDType, objectUUID types.ObjectUIDType, filename string, contentType string, urlExpiration time.Duration)
	afterGetPresignedURLForDownloadCounter  uint64
	beforeGetPresignedURLForDownloadCounter uint64
	GetPresignedURLForDownloadMock          mRepositoryMockGetPresignedURLForDownload

	funcGetPresignedURLForUpload          func(ctx context.Context, namespaceUUID types.NamespaceUIDType, objectUUID types.ObjectUIDType, filename string, urlExpiration time.Duration) (up1 *url.URL, err error)
	funcGetPresignedURLForUploadOrigin    string
	inspectFuncGetPresignedURLForUpload   func(ctx context.Context, namespaceUUID types.NamespaceUIDType, objectUUID types.ObjectUIDType, filename string, urlExpiration time.Duration)
	afterGetPresignedURLForUploadCounter  uint64
	beforeGetPresignedURLForUploadCounter uint64
	GetPresignedURLForUploadMock          mRepositoryMockGetPresignedURLForUpload

	funcGetRepositoryTag          func(ctx context.Context, r1 utils.RepositoryTagName) (tp1 *types.Tag, err error)
	funcGetRepositoryTagOrigin    string
	inspectFuncGetRepositoryTag   func(ctx context.Context, r1 utils.RepositoryTagName)
	afterGetRepositoryTagCounter  uint64
	beforeGetRepositoryTagCounter uint64
	GetRepositoryTagMock          mRepositoryMockGetRepositoryTag

	funcGetSourceByFileUID          func(ctx context.Context, fileUID types.FileUIDType) (sp1 *mm_repository.SourceMeta, err error)
	funcGetSourceByFileUIDOrigin    string
	inspectFuncGetSourceByFileUID   func(ctx context.Context, fileUID types.FileUIDType)
	afterGetSourceByFileUIDCounter  uint64
	beforeGetSourceByFileUIDCounter uint64
	GetSourceByFileUIDMock          mRepositoryMockGetSourceByFileUID

	funcGetSourceTableAndUIDByFileUIDs func(ctx context.Context, files []mm_repository.KnowledgeBaseFileModel) (m1 map[types.FileUIDType]struct {
		SourceTable string
		SourceUID   types.SourceUIDType
	}, err error)
	funcGetSourceTableAndUIDByFileUIDsOrigin    string
	inspectFuncGetSourceTableAndUIDByFileUIDs   func(ctx context.Context, files []mm_repository.KnowledgeBaseFileModel)
	afterGetSourceTableAndUIDByFileUIDsCounter  uint64
	beforeGetSourceTableAndUIDByFileUIDsCounter uint64
	GetSourceTableAndUIDByFileUIDsMock          mRepositoryMockGetSourceTableAndUIDByFileUIDs

	funcGetTextChunksBySource          func(ctx context.Context, sourceTable string, sourceUID types.SourceUIDType) (ta1 []mm_repository.TextChunkModel, err error)
	funcGetTextChunksBySourceOrigin    string
	inspectFuncGetTextChunksBySource   func(ctx context.Context, sourceTable string, sourceUID types.SourceUIDType)
	afterGetTextChunksBySourceCounter  uint64
	beforeGetTextChunksBySourceCounter uint64
	GetTextChunksBySourceMock          mRepositoryMockGetTextChunksBySource

	funcGetTextChunksByUIDs          func(ctx context.Context, chunkUIDs []types.TextChunkUIDType) (ta1 []mm_repository.TextChunkModel, err error)
	funcGetTextChunksByUIDsOrigin    string
	inspectFuncGetTextChunksByUIDs   func(ctx context.Context, chunkUIDs []types.TextChunkUIDType)
	afterGetTextChunksByUIDsCounter  uint64
	beforeGetTextChunksByUIDsCounter uint64
	GetTextChunksByUIDsMock          mRepositoryMockGetTextChunksByUIDs

	funcGetTotalTextChunksBySources func(ctx context.Context, sources map[types.FileUIDType]struct {
		SourceTable types.SourceTableType
		SourceUID   types.SourceUIDType
	}) (m1 map[types.FileUIDType]int, err error)
	funcGetTotalTextChunksBySourcesOrigin  string
	inspectFuncGetTotalTextChunksBySources func(ctx context.Context, sources map[types.FileUIDType]struct {
		SourceTable types.SourceTableType
		SourceUID   types.SourceUIDType
	})
	afterGetTotalTextChunksBySourcesCounter  uint64
	beforeGetTotalTextChunksBySourcesCounter uint64
	GetTotalTextChunksBySourcesMock          mRepositoryMockGetTotalTextChunksBySources

	funcGetTotalTokensByListKBUIDs          func(ctx context.Context, kbUIDs []types.KBUIDType) (m1 map[types.KBUIDType]int, err error)
	funcGetTotalTokensByListKBUIDsOrigin    string
	inspectFuncGetTotalTokensByListKBUIDs   func(ctx context.Context, kbUIDs []types.KBUIDType)
	afterGetTotalTokensByListKBUIDsCounter  uint64
	beforeGetTotalTokensByListKBUIDsCounter uint64
	GetTotalTokensByListKBUIDsMock          mRepositoryMockGetTotalTokensByListKBUIDs

	funcHardDeleteConvertedFileByFileUID          func(ctx context.Context, fileUID types.FileUIDType) (err error)
	funcHardDeleteConvertedFileByFileUIDOrigin    string
	inspectFuncHardDeleteConvertedFileByFileUID   func(ctx context.Context, fileUID types.FileUIDType)
	afterHardDeleteConvertedFileByFileUIDCounter  uint64
	beforeHardDeleteConvertedFileByFileUIDCounter uint64
	HardDeleteConvertedFileByFileUIDMock          mRepositoryMockHardDeleteConvertedFileByFileUID

	funcHardDeleteEmbeddingsByKBFileUID          func(ctx context.Context, kbFileUID types.FileUIDType) (err error)
	funcHardDeleteEmbeddingsByKBFileUIDOrigin    string
	inspectFuncHardDeleteEmbeddingsByKBFileUID   func(ctx context.Context, kbFileUID types.FileUIDType)
	afterHardDeleteEmbeddingsByKBFileUIDCounter  uint64
	beforeHardDeleteEmbeddingsByKBFileUIDCounter uint64
	HardDeleteEmbeddingsByKBFileUIDMock          mRepositoryMockHardDeleteEmbeddingsByKBFileUID

	funcHardDeleteEmbeddingsByKBUID          func(ctx context.Context, kbUID types.KBUIDType) (err error)
	funcHardDeleteEmbeddingsByKBUIDOrigin    string
	inspectFuncHardDeleteEmbeddingsByKBUID   func(ctx context.Context, kbUID types.KBUIDType)
	afterHardDeleteEmbeddingsByKBUIDCounter  uint64
	beforeHardDeleteEmbeddingsByKBUIDCounter uint64
	HardDeleteEmbeddingsByKBUIDMock          mRepositoryMockHardDeleteEmbeddingsByKBUID

	funcHardDeleteTextChunksByKBFileUID          func(ctx context.Context, kbFileUID types.FileUIDType) (err error)
	funcHardDeleteTextChunksByKBFileUIDOrigin    string
	inspectFuncHardDeleteTextChunksByKBFileUID   func(ctx context.Context, kbFileUID types.FileUIDType)
	afterHardDeleteTextChunksByKBFileUIDCounter  uint64
	beforeHardDeleteTextChunksByKBFileUIDCounter uint64
	HardDeleteTextChunksByKBFileUIDMock          mRepositoryMockHardDeleteTextChunksByKBFileUID

	funcHardDeleteTextChunksByKBUID          func(ctx context.Context, kbUID types.KBUIDType) (err error)
	funcHardDeleteTextChunksByKBUIDOrigin    string
	inspectFuncHardDeleteTextChunksByKBUID   func(ctx context.Context, kbUID types.KBUIDType)
	afterHardDeleteTextChunksByKBUIDCounter  uint64
	beforeHardDeleteTextChunksByKBUIDCounter uint64
	HardDeleteTextChunksByKBUIDMock          mRepositoryMockHardDeleteTextChunksByKBUID

	funcIncreaseKnowledgeBaseUsage          func(ctx context.Context, tx *gorm.DB, kbUID string, amount int) (err error)
	funcIncreaseKnowledgeBaseUsageOrigin    string
	inspectFuncIncreaseKnowledgeBaseUsage   func(ctx context.Context, tx *gorm.DB, kbUID string, amount int)
	afterIncreaseKnowledgeBaseUsageCounter  uint64
	beforeIncreaseKnowledgeBaseUsageCounter uint64
	IncreaseKnowledgeBaseUsageMock          mRepositoryMockIncreaseKnowledgeBaseUsage

	funcInsertVectorsInCollection          func(ctx context.Context, collID string, embeddings []mm_repository.VectorEmbedding) (err error)
	funcInsertVectorsInCollectionOrigin    string
	inspectFuncInsertVectorsInCollection   func(ctx context.Context, collID string, embeddings []mm_repository.VectorEmbedding)
	afterInsertVectorsInCollectionCounter  uint64
	beforeInsertVectorsInCollectionCounter uint64
	InsertVectorsInCollectionMock          mRepositoryMockInsertVectorsInCollection

	funcListAllObjectURLs          func(ctx context.Context, namespaceUID types.NamespaceUIDType, objectUID types.ObjectUIDType) (oa1 []mm_repository.ObjectURLModel, err error)
	funcListAllObjectURLsOrigin    string
	inspectFuncListAllObjectURLs   func(ctx context.Context, namespaceUID types.NamespaceUIDType, objectUID types.ObjectUIDType)
	afterListAllObjectURLsCounter  uint64
	beforeListAllObjectURLsCounter uint64
	ListAllObjectURLsMock          mRepositoryMockListAllObjectURLs

	funcListAllObjects          func(ctx context.Context, namespaceUID types.NamespaceUIDType, creatorUID types.CreatorUIDType) (oa1 []mm_repository.ObjectModel, err error)
	funcListAllObjectsOrigin    string
	inspectFuncListAllObjects   func(ctx context.Context, namespaceUID types.NamespaceUIDType, creatorUID types.CreatorUIDType)
	afterListAllObjectsCounter  uint64
	beforeListAllObjectsCounter uint64
	ListAllObjectsMock          mRepositoryMockListAllObjects

	funcListConvertedFilesByFileUID          func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType) (sa1 []string, err error)
	funcListConvertedFilesByFileUIDOrigin    string
	inspectFuncListConvertedFilesByFileUID   func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType)
	afterListConvertedFilesByFileUIDCounter  uint64
	beforeListConvertedFilesByFileUIDCounter uint64
	ListConvertedFilesByFileUIDMock          mRepositoryMockListConvertedFilesByFileUID

	funcListEmbeddingsByKBFileUID          func(ctx context.Context, kbFileUID types.FileUIDType) (ea1 []mm_repository.EmbeddingModel, err error)
	funcListEmbeddingsByKBFileUIDOrigin    string
	inspectFuncListEmbeddingsByKBFileUID   func(ctx context.Context, kbFileUID types.FileUIDType)
	afterListEmbeddingsByKBFileUIDCounter  uint64
	beforeListEmbeddingsByKBFileUIDCounter uint64
	ListEmbeddingsByKBFileUIDMock          mRepositoryMockListEmbeddingsByKBFileUID

	funcListFilePathsWithPrefix          func(ctx context.Context, bucket string, prefix string) (sa1 []string, err error)
	funcListFilePathsWithPrefixOrigin    string
	inspectFuncListFilePathsWithPrefix   func(ctx context.Context, bucket string, prefix string)
	afterListFilePathsWithPrefixCounter  uint64
	beforeListFilePathsWithPrefixCounter uint64
	ListFilePathsWithPrefixMock          mRepositoryMockListFilePathsWithPrefix

	funcListKnowledgeBaseFilePaths          func(ctx context.Context, kbUID types.KBUIDType) (sa1 []string, err error)
	funcListKnowledgeBaseFilePathsOrigin    string
	inspectFuncListKnowledgeBaseFilePaths   func(ctx context.Context, kbUID types.KBUIDType)
	afterListKnowledgeBaseFilePathsCounter  uint64
	beforeListKnowledgeBaseFilePathsCounter uint64
	ListKnowledgeBaseFilePathsMock          mRepositoryMockListKnowledgeBaseFilePaths

	funcListKnowledgeBaseFiles          func(ctx context.Context, k1 mm_repository.KnowledgeBaseFileListParams) (kp1 *mm_repository.KnowledgeBaseFileList, err error)
	funcListKnowledgeBaseFilesOrigin    string
	inspectFuncListKnowledgeBaseFiles   func(ctx context.Context, k1 mm_repository.KnowledgeBaseFileListParams)
	afterListKnowledgeBaseFilesCounter  uint64
	beforeListKnowledgeBaseFilesCounter uint64
	ListKnowledgeBaseFilesMock          mRepositoryMockListKnowledgeBaseFiles

	funcListKnowledgeBases          func(ctx context.Context, ownerUID string) (ka1 []mm_repository.KnowledgeBaseModel, err error)
	funcListKnowledgeBasesOrigin    string
	inspectFuncListKnowledgeBases   func(ctx context.Context, ownerUID string)
	afterListKnowledgeBasesCounter  uint64
	beforeListKnowledgeBasesCounter uint64
	ListKnowledgeBasesMock          mRepositoryMockListKnowledgeBases

	funcListKnowledgeBasesByCatalogType          func(ctx context.Context, ownerUID string, catalogType artifactpb.CatalogType) (ka1 []mm_repository.KnowledgeBaseModel, err error)
	funcListKnowledgeBasesByCatalogTypeOrigin    string
	inspectFuncListKnowledgeBasesByCatalogType   func(ctx context.Context, ownerUID string, catalogType artifactpb.CatalogType)
	afterListKnowledgeBasesByCatalogTypeCounter  uint64
	beforeListKnowledgeBasesByCatalogTypeCounter uint64
	ListKnowledgeBasesByCatalogTypeMock          mRepositoryMockListKnowledgeBasesByCatalogType

	funcListTextChunksByFileUID          func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType) (sa1 []string, err error)
	funcListTextChunksByFileUIDOrigin    string
	inspectFuncListTextChunksByFileUID   func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType)
	afterListTextChunksByFileUIDCounter  uint64
	beforeListTextChunksByFileUIDCounter uint64
	ListTextChunksByFileUIDMock          mRepositoryMockListTextChunksByFileUID

	funcListTextChunksByKBFileUID          func(ctx context.Context, kbFileUID types.FileUIDType) (ta1 []mm_repository.TextChunkModel, err error)
	funcListTextChunksByKBFileUIDOrigin    string
	inspectFuncListTextChunksByKBFileUID   func(ctx context.Context, kbFileUID types.FileUIDType)
	afterListTextChunksByKBFileUIDCounter  uint64
	beforeListTextChunksByKBFileUIDCounter uint64
	ListTextChunksByKBFileUIDMock          mRepositoryMockListTextChunksByKBFileUID

	funcProcessKnowledgeBaseFiles          func(ctx context.Context, fileUIDs []string, requester types.RequesterUIDType) (ka1 []mm_repository.KnowledgeBaseFileModel, err error)
	funcProcessKnowledgeBaseFilesOrigin    string
	inspectFuncProcessKnowledgeBaseFiles   func(ctx context.Context, fileUIDs []string, requester types.RequesterUIDType)
	afterProcessKnowledgeBaseFilesCounter  uint64
	beforeProcessKnowledgeBaseFilesCounter uint64
	ProcessKnowledgeBaseFilesMock          mRepositoryMockProcessKnowledgeBaseFiles

	funcSaveConvertedFile          func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, convertedFileUID types.ConvertedFileUIDType, fileExt string, content []byte) (path string, err error)
	funcSaveConvertedFileOrigin    string
	inspectFuncSaveConvertedFile   func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, convertedFileUID types.ConvertedFileUIDType, fileExt string, content []byte)
	afterSaveConvertedFileCounter  uint64
	beforeSaveConvertedFileCounter uint64
	SaveConvertedFileMock          mRepositoryMockSaveConvertedFile

	funcSetChatCacheMetadata          func(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType, metadata *mm_repository.ChatCacheMetadata, ttl time.Duration) (err error)
	funcSetChatCacheMetadataOrigin    string
	inspectFuncSetChatCacheMetadata   func(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType, metadata *mm_repository.ChatCacheMetadata, ttl time.Duration)
	afterSetChatCacheMetadataCounter  uint64
	beforeSetChatCacheMetadataCounter uint64
	SetChatCacheMetadataMock          mRepositoryMockSetChatCacheMetadata

	funcSimilarVectorsInCollection          func(ctx context.Context, s1 mm_repository.SimilarVectorSearchParam) (saa1 [][]mm_repository.SimilarVectorEmbedding, err error)
	funcSimilarVectorsInCollectionOrigin    string
	inspectFuncSimilarVectorsInCollection   func(ctx context.Context, s1 mm_repository.SimilarVectorSearchParam)
	afterSimilarVectorsInCollectionCounter  uint64
	beforeSimilarVectorsInCollectionCounter uint64
	SimilarVectorsInCollectionMock          mRepositoryMockSimilarVectorsInCollection

	funcUpdateConvertedFile          func(ctx context.Context, uid types.ConvertedFileUIDType, update map[string]any) (err error)
	funcUpdateConvertedFileOrigin    string
	inspectFuncUpdateConvertedFile   func(ctx context.Context, uid types.ConvertedFileUIDType, update map[string]any)
	afterUpdateConvertedFileCounter  uint64
	beforeUpdateConvertedFileCounter uint64
	UpdateConvertedFileMock          mRepositoryMockUpdateConvertedFile

	funcUpdateKnowledgeBase          func(ctx context.Context, id string, ownerUID string, kb mm_repository.KnowledgeBaseModel) (kp1 *mm_repository.KnowledgeBaseModel, err error)
	funcUpdateKnowledgeBaseOrigin    string
	inspectFuncUpdateKnowledgeBase   func(ctx context.Context, id string, ownerUID string, kb mm_repository.KnowledgeBaseModel)
	afterUpdateKnowledgeBaseCounter  uint64
	beforeUpdateKnowledgeBaseCounter uint64
	UpdateKnowledgeBaseMock          mRepositoryMockUpdateKnowledgeBase

	funcUpdateKnowledgeBaseFile          func(ctx context.Context, fileUID string, updateMap map[string]any) (kp1 *mm_repository.KnowledgeBaseFileModel, err error)
	funcUpdateKnowledgeBaseFileOrigin    string
	inspectFuncUpdateKnowledgeBaseFile   func(ctx context.Context, fileUID string, updateMap map[string]any)
	afterUpdateKnowledgeBaseFileCounter  uint64
	beforeUpdateKnowledgeBaseFileCounter uint64
	UpdateKnowledgeBaseFileMock          mRepositoryMockUpdateKnowledgeBaseFile

	funcUpdateKnowledgeFileMetadata          func(ctx context.Context, fileUID types.FileUIDType, e1 mm_repository.ExtraMetaData) (err error)
	funcUpdateKnowledgeFileMetadataOrigin    string
	inspectFuncUpdateKnowledgeFileMetadata   func(ctx context.Context, fileUID types.FileUIDType, e1 mm_repository.ExtraMetaData)
	afterUpdateKnowledgeFileMetadataCounter  uint64
	beforeUpdateKnowledgeFileMetadataCounter uint64
	UpdateKnowledgeFileMetadataMock          mRepositoryMockUpdateKnowledgeFileMetadata

	funcUpdateObject          func(ctx context.Context, obj mm_repository.ObjectModel) (op1 *mm_repository.ObjectModel, err error)
	funcUpdateObjectOrigin    string
	inspectFuncUpdateObject   func(ctx context.Context, obj mm_repository.ObjectModel)
	afterUpdateObjectCounter  uint64
	beforeUpdateObjectCounter uint64
	UpdateObjectMock          mRepositoryMockUpdateObject

	funcUpdateObjectByUpdateMap          func(ctx context.Context, objUID types.ObjectUIDType, updateMap map[string]any) (op1 *mm_repository.ObjectModel, err error)
	funcUpdateObjectByUpdateMapOrigin    string
	inspectFuncUpdateObjectByUpdateMap   func(ctx context.Context, objUID types.ObjectUIDType, updateMap map[string]any)
	afterUpdateObjectByUpdateMapCounter  uint64
	beforeUpdateObjectByUpdateMapCounter uint64
	UpdateObjectByUpdateMapMock          mRepositoryMockUpdateObjectByUpdateMap

	funcUpdateTextChunk          func(ctx context.Context, chunkUID string, updates map[string]any) (tp1 *mm_repository.TextChunkModel, err error)
	funcUpdateTextChunkOrigin    string
	inspectFuncUpdateTextChunk   func(ctx context.Context, chunkUID string, updates map[string]any)
	afterUpdateTextChunkCounter  uint64
	beforeUpdateTextChunkCounter uint64
	UpdateTextChunkMock          mRepositoryMockUpdateTextChunk

	funcUpdateTextChunkDestinations          func(ctx context.Context, destinations map[string]string) (err error)
	funcUpdateTextChunkDestinationsOrigin    string
	inspectFuncUpdateTextChunkDestinations   func(ctx context.Context, destinations map[string]string)
	afterUpdateTextChunkDestinationsCounter  uint64
	beforeUpdateTextChunkDestinationsCounter uint64
	UpdateTextChunkDestinationsMock          mRepositoryMockUpdateTextChunkDestinations

	funcUploadBase64File          func(ctx context.Context, bucket string, filePath string, base64Content string, fileMimeType string) (err error)
	funcUploadBase64FileOrigin    string
	inspectFuncUploadBase64File   func(ctx context.Context, bucket string, filePath string, base64Content string, fileMimeType string)
	afterUploadBase64FileCounter  uint64
	beforeUploadBase64FileCounter uint64
	UploadBase64FileMock          mRepositoryMockUploadBase64File

	funcUpsertRepositoryTag          func(ctx context.Context, tp1 *types.Tag) (tp2 *types.Tag, err error)
	funcUpsertRepositoryTagOrigin    string
	inspectFuncUpsertRepositoryTag   func(ctx context.Context, tp1 *types.Tag)
	afterUpsertRepositoryTagCounter  uint64
	beforeUpsertRepositoryTagCounter uint64
	UpsertRepositoryTagMock          mRepositoryMockUpsertRepositoryTag
}

// NewRepositoryMock returns a mock for mm_repository.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckFileUIDMetadataMock = mRepositoryMockCheckFileUIDMetadata{mock: m}
	m.CheckFileUIDMetadataMock.callArgs = []*RepositoryMockCheckFileUIDMetadataParams{}

	m.CreateCollectionMock = mRepositoryMockCreateCollection{mock: m}
	m.CreateCollectionMock.callArgs = []*RepositoryMockCreateCollectionParams{}

	m.CreateConvertedFileWithDestinationMock = mRepositoryMockCreateConvertedFileWithDestination{mock: m}
	m.CreateConvertedFileWithDestinationMock.callArgs = []*RepositoryMockCreateConvertedFileWithDestinationParams{}

	m.CreateEmbeddingsMock = mRepositoryMockCreateEmbeddings{mock: m}
	m.CreateEmbeddingsMock.callArgs = []*RepositoryMockCreateEmbeddingsParams{}

	m.CreateKnowledgeBaseMock = mRepositoryMockCreateKnowledgeBase{mock: m}
	m.CreateKnowledgeBaseMock.callArgs = []*RepositoryMockCreateKnowledgeBaseParams{}

	m.CreateKnowledgeBaseFileMock = mRepositoryMockCreateKnowledgeBaseFile{mock: m}
	m.CreateKnowledgeBaseFileMock.callArgs = []*RepositoryMockCreateKnowledgeBaseFileParams{}

	m.CreateObjectMock = mRepositoryMockCreateObject{mock: m}
	m.CreateObjectMock.callArgs = []*RepositoryMockCreateObjectParams{}

	m.CreateTextChunksMock = mRepositoryMockCreateTextChunks{mock: m}
	m.CreateTextChunksMock.callArgs = []*RepositoryMockCreateTextChunksParams{}

	m.DeleteAllConvertedFilesInKbMock = mRepositoryMockDeleteAllConvertedFilesInKb{mock: m}
	m.DeleteAllConvertedFilesInKbMock.callArgs = []*RepositoryMockDeleteAllConvertedFilesInKbParams{}

	m.DeleteAllKnowledgeBaseFilesMock = mRepositoryMockDeleteAllKnowledgeBaseFiles{mock: m}
	m.DeleteAllKnowledgeBaseFilesMock.callArgs = []*RepositoryMockDeleteAllKnowledgeBaseFilesParams{}

	m.DeleteAndCreateEmbeddingsMock = mRepositoryMockDeleteAndCreateEmbeddings{mock: m}
	m.DeleteAndCreateEmbeddingsMock.callArgs = []*RepositoryMockDeleteAndCreateEmbeddingsParams{}

	m.DeleteAndCreateTextChunksMock = mRepositoryMockDeleteAndCreateTextChunks{mock: m}
	m.DeleteAndCreateTextChunksMock.callArgs = []*RepositoryMockDeleteAndCreateTextChunksParams{}

	m.DeleteChatCacheMetadataMock = mRepositoryMockDeleteChatCacheMetadata{mock: m}
	m.DeleteChatCacheMetadataMock.callArgs = []*RepositoryMockDeleteChatCacheMetadataParams{}

	m.DeleteConvertedFileMock = mRepositoryMockDeleteConvertedFile{mock: m}
	m.DeleteConvertedFileMock.callArgs = []*RepositoryMockDeleteConvertedFileParams{}

	m.DeleteEmbeddingsByKBFileUIDMock = mRepositoryMockDeleteEmbeddingsByKBFileUID{mock: m}
	m.DeleteEmbeddingsByKBFileUIDMock.callArgs = []*RepositoryMockDeleteEmbeddingsByKBFileUIDParams{}

	m.DeleteEmbeddingsWithFileUIDMock = mRepositoryMockDeleteEmbeddingsWithFileUID{mock: m}
	m.DeleteEmbeddingsWithFileUIDMock.callArgs = []*RepositoryMockDeleteEmbeddingsWithFileUIDParams{}

	m.DeleteFileMock = mRepositoryMockDeleteFile{mock: m}
	m.DeleteFileMock.callArgs = []*RepositoryMockDeleteFileParams{}

	m.DeleteKnowledgeBaseMock = mRepositoryMockDeleteKnowledgeBase{mock: m}
	m.DeleteKnowledgeBaseMock.callArgs = []*RepositoryMockDeleteKnowledgeBaseParams{}

	m.DeleteKnowledgeBaseFileMock = mRepositoryMockDeleteKnowledgeBaseFile{mock: m}
	m.DeleteKnowledgeBaseFileMock.callArgs = []*RepositoryMockDeleteKnowledgeBaseFileParams{}

	m.DeleteKnowledgeBaseFileAndDecreaseUsageMock = mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage{mock: m}
	m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.callArgs = []*RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParams{}

	m.DeleteObjectMock = mRepositoryMockDeleteObject{mock: m}
	m.DeleteObjectMock.callArgs = []*RepositoryMockDeleteObjectParams{}

	m.DeleteObjectURLMock = mRepositoryMockDeleteObjectURL{mock: m}
	m.DeleteObjectURLMock.callArgs = []*RepositoryMockDeleteObjectURLParams{}

	m.DeleteRepositoryTagMock = mRepositoryMockDeleteRepositoryTag{mock: m}
	m.DeleteRepositoryTagMock.callArgs = []*RepositoryMockDeleteRepositoryTagParams{}

	m.DropCollectionMock = mRepositoryMockDropCollection{mock: m}
	m.DropCollectionMock.callArgs = []*RepositoryMockDropCollectionParams{}

	m.FlushCollectionMock = mRepositoryMockFlushCollection{mock: m}
	m.FlushCollectionMock.callArgs = []*RepositoryMockFlushCollectionParams{}

	m.GetAllConvertedFilesByFileUIDMock = mRepositoryMockGetAllConvertedFilesByFileUID{mock: m}
	m.GetAllConvertedFilesByFileUIDMock.callArgs = []*RepositoryMockGetAllConvertedFilesByFileUIDParams{}

	m.GetChatCacheMetadataMock = mRepositoryMockGetChatCacheMetadata{mock: m}
	m.GetChatCacheMetadataMock.callArgs = []*RepositoryMockGetChatCacheMetadataParams{}

	m.GetConvertedFileByFileUIDMock = mRepositoryMockGetConvertedFileByFileUID{mock: m}
	m.GetConvertedFileByFileUIDMock.callArgs = []*RepositoryMockGetConvertedFileByFileUIDParams{}

	m.GetConvertedFileByFileUIDAndTypeMock = mRepositoryMockGetConvertedFileByFileUIDAndType{mock: m}
	m.GetConvertedFileByFileUIDAndTypeMock.callArgs = []*RepositoryMockGetConvertedFileByFileUIDAndTypeParams{}

	m.GetCountFilesByListKnowledgeBaseUIDMock = mRepositoryMockGetCountFilesByListKnowledgeBaseUID{mock: m}
	m.GetCountFilesByListKnowledgeBaseUIDMock.callArgs = []*RepositoryMockGetCountFilesByListKnowledgeBaseUIDParams{}

	m.GetFileMock = mRepositoryMockGetFile{mock: m}
	m.GetFileMock.callArgs = []*RepositoryMockGetFileParams{}

	m.GetFileMetadataMock = mRepositoryMockGetFileMetadata{mock: m}
	m.GetFileMetadataMock.callArgs = []*RepositoryMockGetFileMetadataParams{}

	m.GetFilesTotalTokensMock = mRepositoryMockGetFilesTotalTokens{mock: m}
	m.GetFilesTotalTokensMock.callArgs = []*RepositoryMockGetFilesTotalTokensParams{}

	m.GetKnowledgeBaseByOwnerAndKbIDMock = mRepositoryMockGetKnowledgeBaseByOwnerAndKbID{mock: m}
	m.GetKnowledgeBaseByOwnerAndKbIDMock.callArgs = []*RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParams{}

	m.GetKnowledgeBaseByUIDMock = mRepositoryMockGetKnowledgeBaseByUID{mock: m}
	m.GetKnowledgeBaseByUIDMock.callArgs = []*RepositoryMockGetKnowledgeBaseByUIDParams{}

	m.GetKnowledgeBaseCountByOwnerMock = mRepositoryMockGetKnowledgeBaseCountByOwner{mock: m}
	m.GetKnowledgeBaseCountByOwnerMock.callArgs = []*RepositoryMockGetKnowledgeBaseCountByOwnerParams{}

	m.GetKnowledgeBaseFilesByFileUIDsMock = mRepositoryMockGetKnowledgeBaseFilesByFileUIDs{mock: m}
	m.GetKnowledgeBaseFilesByFileUIDsMock.callArgs = []*RepositoryMockGetKnowledgeBaseFilesByFileUIDsParams{}

	m.GetKnowledgeBasesByUIDsMock = mRepositoryMockGetKnowledgeBasesByUIDs{mock: m}
	m.GetKnowledgeBasesByUIDsMock.callArgs = []*RepositoryMockGetKnowledgeBasesByUIDsParams{}

	m.GetKnowledgebaseFileByKBUIDAndFileIDMock = mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID{mock: m}
	m.GetKnowledgebaseFileByKBUIDAndFileIDMock.callArgs = []*RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParams{}

	m.GetObjectByUIDMock = mRepositoryMockGetObjectByUID{mock: m}
	m.GetObjectByUIDMock.callArgs = []*RepositoryMockGetObjectByUIDParams{}

	m.GetObjectDownloadURLMock = mRepositoryMockGetObjectDownloadURL{mock: m}
	m.GetObjectDownloadURLMock.callArgs = []*RepositoryMockGetObjectDownloadURLParams{}

	m.GetObjectURLByEncodedURLPathMock = mRepositoryMockGetObjectURLByEncodedURLPath{mock: m}
	m.GetObjectURLByEncodedURLPathMock.callArgs = []*RepositoryMockGetObjectURLByEncodedURLPathParams{}

	m.GetObjectURLByUIDMock = mRepositoryMockGetObjectURLByUID{mock: m}
	m.GetObjectURLByUIDMock.callArgs = []*RepositoryMockGetObjectURLByUIDParams{}

	m.GetObjectURLCountByObjectMock = mRepositoryMockGetObjectURLCountByObject{mock: m}
	m.GetObjectURLCountByObjectMock.callArgs = []*RepositoryMockGetObjectURLCountByObjectParams{}

	m.GetObjectUploadURLMock = mRepositoryMockGetObjectUploadURL{mock: m}
	m.GetObjectUploadURLMock.callArgs = []*RepositoryMockGetObjectUploadURLParams{}

	m.GetPresignedURLForDownloadMock = mRepositoryMockGetPresignedURLForDownload{mock: m}
	m.GetPresignedURLForDownloadMock.callArgs = []*RepositoryMockGetPresignedURLForDownloadParams{}

	m.GetPresignedURLForUploadMock = mRepositoryMockGetPresignedURLForUpload{mock: m}
	m.GetPresignedURLForUploadMock.callArgs = []*RepositoryMockGetPresignedURLForUploadParams{}

	m.GetRepositoryTagMock = mRepositoryMockGetRepositoryTag{mock: m}
	m.GetRepositoryTagMock.callArgs = []*RepositoryMockGetRepositoryTagParams{}

	m.GetSourceByFileUIDMock = mRepositoryMockGetSourceByFileUID{mock: m}
	m.GetSourceByFileUIDMock.callArgs = []*RepositoryMockGetSourceByFileUIDParams{}

	m.GetSourceTableAndUIDByFileUIDsMock = mRepositoryMockGetSourceTableAndUIDByFileUIDs{mock: m}
	m.GetSourceTableAndUIDByFileUIDsMock.callArgs = []*RepositoryMockGetSourceTableAndUIDByFileUIDsParams{}

	m.GetTextChunksBySourceMock = mRepositoryMockGetTextChunksBySource{mock: m}
	m.GetTextChunksBySourceMock.callArgs = []*RepositoryMockGetTextChunksBySourceParams{}

	m.GetTextChunksByUIDsMock = mRepositoryMockGetTextChunksByUIDs{mock: m}
	m.GetTextChunksByUIDsMock.callArgs = []*RepositoryMockGetTextChunksByUIDsParams{}

	m.GetTotalTextChunksBySourcesMock = mRepositoryMockGetTotalTextChunksBySources{mock: m}
	m.GetTotalTextChunksBySourcesMock.callArgs = []*RepositoryMockGetTotalTextChunksBySourcesParams{}

	m.GetTotalTokensByListKBUIDsMock = mRepositoryMockGetTotalTokensByListKBUIDs{mock: m}
	m.GetTotalTokensByListKBUIDsMock.callArgs = []*RepositoryMockGetTotalTokensByListKBUIDsParams{}

	m.HardDeleteConvertedFileByFileUIDMock = mRepositoryMockHardDeleteConvertedFileByFileUID{mock: m}
	m.HardDeleteConvertedFileByFileUIDMock.callArgs = []*RepositoryMockHardDeleteConvertedFileByFileUIDParams{}

	m.HardDeleteEmbeddingsByKBFileUIDMock = mRepositoryMockHardDeleteEmbeddingsByKBFileUID{mock: m}
	m.HardDeleteEmbeddingsByKBFileUIDMock.callArgs = []*RepositoryMockHardDeleteEmbeddingsByKBFileUIDParams{}

	m.HardDeleteEmbeddingsByKBUIDMock = mRepositoryMockHardDeleteEmbeddingsByKBUID{mock: m}
	m.HardDeleteEmbeddingsByKBUIDMock.callArgs = []*RepositoryMockHardDeleteEmbeddingsByKBUIDParams{}

	m.HardDeleteTextChunksByKBFileUIDMock = mRepositoryMockHardDeleteTextChunksByKBFileUID{mock: m}
	m.HardDeleteTextChunksByKBFileUIDMock.callArgs = []*RepositoryMockHardDeleteTextChunksByKBFileUIDParams{}

	m.HardDeleteTextChunksByKBUIDMock = mRepositoryMockHardDeleteTextChunksByKBUID{mock: m}
	m.HardDeleteTextChunksByKBUIDMock.callArgs = []*RepositoryMockHardDeleteTextChunksByKBUIDParams{}

	m.IncreaseKnowledgeBaseUsageMock = mRepositoryMockIncreaseKnowledgeBaseUsage{mock: m}
	m.IncreaseKnowledgeBaseUsageMock.callArgs = []*RepositoryMockIncreaseKnowledgeBaseUsageParams{}

	m.InsertVectorsInCollectionMock = mRepositoryMockInsertVectorsInCollection{mock: m}
	m.InsertVectorsInCollectionMock.callArgs = []*RepositoryMockInsertVectorsInCollectionParams{}

	m.ListAllObjectURLsMock = mRepositoryMockListAllObjectURLs{mock: m}
	m.ListAllObjectURLsMock.callArgs = []*RepositoryMockListAllObjectURLsParams{}

	m.ListAllObjectsMock = mRepositoryMockListAllObjects{mock: m}
	m.ListAllObjectsMock.callArgs = []*RepositoryMockListAllObjectsParams{}

	m.ListConvertedFilesByFileUIDMock = mRepositoryMockListConvertedFilesByFileUID{mock: m}
	m.ListConvertedFilesByFileUIDMock.callArgs = []*RepositoryMockListConvertedFilesByFileUIDParams{}

	m.ListEmbeddingsByKBFileUIDMock = mRepositoryMockListEmbeddingsByKBFileUID{mock: m}
	m.ListEmbeddingsByKBFileUIDMock.callArgs = []*RepositoryMockListEmbeddingsByKBFileUIDParams{}

	m.ListFilePathsWithPrefixMock = mRepositoryMockListFilePathsWithPrefix{mock: m}
	m.ListFilePathsWithPrefixMock.callArgs = []*RepositoryMockListFilePathsWithPrefixParams{}

	m.ListKnowledgeBaseFilePathsMock = mRepositoryMockListKnowledgeBaseFilePaths{mock: m}
	m.ListKnowledgeBaseFilePathsMock.callArgs = []*RepositoryMockListKnowledgeBaseFilePathsParams{}

	m.ListKnowledgeBaseFilesMock = mRepositoryMockListKnowledgeBaseFiles{mock: m}
	m.ListKnowledgeBaseFilesMock.callArgs = []*RepositoryMockListKnowledgeBaseFilesParams{}

	m.ListKnowledgeBasesMock = mRepositoryMockListKnowledgeBases{mock: m}
	m.ListKnowledgeBasesMock.callArgs = []*RepositoryMockListKnowledgeBasesParams{}

	m.ListKnowledgeBasesByCatalogTypeMock = mRepositoryMockListKnowledgeBasesByCatalogType{mock: m}
	m.ListKnowledgeBasesByCatalogTypeMock.callArgs = []*RepositoryMockListKnowledgeBasesByCatalogTypeParams{}

	m.ListTextChunksByFileUIDMock = mRepositoryMockListTextChunksByFileUID{mock: m}
	m.ListTextChunksByFileUIDMock.callArgs = []*RepositoryMockListTextChunksByFileUIDParams{}

	m.ListTextChunksByKBFileUIDMock = mRepositoryMockListTextChunksByKBFileUID{mock: m}
	m.ListTextChunksByKBFileUIDMock.callArgs = []*RepositoryMockListTextChunksByKBFileUIDParams{}

	m.ProcessKnowledgeBaseFilesMock = mRepositoryMockProcessKnowledgeBaseFiles{mock: m}
	m.ProcessKnowledgeBaseFilesMock.callArgs = []*RepositoryMockProcessKnowledgeBaseFilesParams{}

	m.SaveConvertedFileMock = mRepositoryMockSaveConvertedFile{mock: m}
	m.SaveConvertedFileMock.callArgs = []*RepositoryMockSaveConvertedFileParams{}

	m.SetChatCacheMetadataMock = mRepositoryMockSetChatCacheMetadata{mock: m}
	m.SetChatCacheMetadataMock.callArgs = []*RepositoryMockSetChatCacheMetadataParams{}

	m.SimilarVectorsInCollectionMock = mRepositoryMockSimilarVectorsInCollection{mock: m}
	m.SimilarVectorsInCollectionMock.callArgs = []*RepositoryMockSimilarVectorsInCollectionParams{}

	m.UpdateConvertedFileMock = mRepositoryMockUpdateConvertedFile{mock: m}
	m.UpdateConvertedFileMock.callArgs = []*RepositoryMockUpdateConvertedFileParams{}

	m.UpdateKnowledgeBaseMock = mRepositoryMockUpdateKnowledgeBase{mock: m}
	m.UpdateKnowledgeBaseMock.callArgs = []*RepositoryMockUpdateKnowledgeBaseParams{}

	m.UpdateKnowledgeBaseFileMock = mRepositoryMockUpdateKnowledgeBaseFile{mock: m}
	m.UpdateKnowledgeBaseFileMock.callArgs = []*RepositoryMockUpdateKnowledgeBaseFileParams{}

	m.UpdateKnowledgeFileMetadataMock = mRepositoryMockUpdateKnowledgeFileMetadata{mock: m}
	m.UpdateKnowledgeFileMetadataMock.callArgs = []*RepositoryMockUpdateKnowledgeFileMetadataParams{}

	m.UpdateObjectMock = mRepositoryMockUpdateObject{mock: m}
	m.UpdateObjectMock.callArgs = []*RepositoryMockUpdateObjectParams{}

	m.UpdateObjectByUpdateMapMock = mRepositoryMockUpdateObjectByUpdateMap{mock: m}
	m.UpdateObjectByUpdateMapMock.callArgs = []*RepositoryMockUpdateObjectByUpdateMapParams{}

	m.UpdateTextChunkMock = mRepositoryMockUpdateTextChunk{mock: m}
	m.UpdateTextChunkMock.callArgs = []*RepositoryMockUpdateTextChunkParams{}

	m.UpdateTextChunkDestinationsMock = mRepositoryMockUpdateTextChunkDestinations{mock: m}
	m.UpdateTextChunkDestinationsMock.callArgs = []*RepositoryMockUpdateTextChunkDestinationsParams{}

	m.UploadBase64FileMock = mRepositoryMockUploadBase64File{mock: m}
	m.UploadBase64FileMock.callArgs = []*RepositoryMockUploadBase64FileParams{}

	m.UpsertRepositoryTagMock = mRepositoryMockUpsertRepositoryTag{mock: m}
	m.UpsertRepositoryTagMock.callArgs = []*RepositoryMockUpsertRepositoryTagParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockCheckFileUIDMetadata struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCheckFileUIDMetadataExpectation
	expectations       []*RepositoryMockCheckFileUIDMetadataExpectation

	callArgs []*RepositoryMockCheckFileUIDMetadataParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCheckFileUIDMetadataExpectation specifies expectation struct of the Repository.CheckFileUIDMetadata
type RepositoryMockCheckFileUIDMetadataExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCheckFileUIDMetadataParams
	paramPtrs          *RepositoryMockCheckFileUIDMetadataParamPtrs
	expectationOrigins RepositoryMockCheckFileUIDMetadataExpectationOrigins
	results            *RepositoryMockCheckFileUIDMetadataResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCheckFileUIDMetadataParams contains parameters of the Repository.CheckFileUIDMetadata
type RepositoryMockCheckFileUIDMetadataParams struct {
	ctx          context.Context
	collectionID string
}

// RepositoryMockCheckFileUIDMetadataParamPtrs contains pointers to parameters of the Repository.CheckFileUIDMetadata
type RepositoryMockCheckFileUIDMetadataParamPtrs struct {
	ctx          *context.Context
	collectionID *string
}

// RepositoryMockCheckFileUIDMetadataResults contains results of the Repository.CheckFileUIDMetadata
type RepositoryMockCheckFileUIDMetadataResults struct {
	b1  bool
	err error
}

// RepositoryMockCheckFileUIDMetadataOrigins contains origins of expectations of the Repository.CheckFileUIDMetadata
type RepositoryMockCheckFileUIDMetadataExpectationOrigins struct {
	origin             string
	originCtx          string
	originCollectionID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckFileUIDMetadata *mRepositoryMockCheckFileUIDMetadata) Optional() *mRepositoryMockCheckFileUIDMetadata {
	mmCheckFileUIDMetadata.optional = true
	return mmCheckFileUIDMetadata
}

// Expect sets up expected params for Repository.CheckFileUIDMetadata
func (mmCheckFileUIDMetadata *mRepositoryMockCheckFileUIDMetadata) Expect(ctx context.Context, collectionID string) *mRepositoryMockCheckFileUIDMetadata {
	if mmCheckFileUIDMetadata.mock.funcCheckFileUIDMetadata != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("RepositoryMock.CheckFileUIDMetadata mock is already set by Set")
	}

	if mmCheckFileUIDMetadata.defaultExpectation == nil {
		mmCheckFileUIDMetadata.defaultExpectation = &RepositoryMockCheckFileUIDMetadataExpectation{}
	}

	if mmCheckFileUIDMetadata.defaultExpectation.paramPtrs != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("RepositoryMock.CheckFileUIDMetadata mock is already set by ExpectParams functions")
	}

	mmCheckFileUIDMetadata.defaultExpectation.params = &RepositoryMockCheckFileUIDMetadataParams{ctx, collectionID}
	mmCheckFileUIDMetadata.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckFileUIDMetadata.expectations {
		if minimock.Equal(e.params, mmCheckFileUIDMetadata.defaultExpectation.params) {
			mmCheckFileUIDMetadata.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckFileUIDMetadata.defaultExpectation.params)
		}
	}

	return mmCheckFileUIDMetadata
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CheckFileUIDMetadata
func (mmCheckFileUIDMetadata *mRepositoryMockCheckFileUIDMetadata) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCheckFileUIDMetadata {
	if mmCheckFileUIDMetadata.mock.funcCheckFileUIDMetadata != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("RepositoryMock.CheckFileUIDMetadata mock is already set by Set")
	}

	if mmCheckFileUIDMetadata.defaultExpectation == nil {
		mmCheckFileUIDMetadata.defaultExpectation = &RepositoryMockCheckFileUIDMetadataExpectation{}
	}

	if mmCheckFileUIDMetadata.defaultExpectation.params != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("RepositoryMock.CheckFileUIDMetadata mock is already set by Expect")
	}

	if mmCheckFileUIDMetadata.defaultExpectation.paramPtrs == nil {
		mmCheckFileUIDMetadata.defaultExpectation.paramPtrs = &RepositoryMockCheckFileUIDMetadataParamPtrs{}
	}
	mmCheckFileUIDMetadata.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckFileUIDMetadata.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckFileUIDMetadata
}

// ExpectCollectionIDParam2 sets up expected param collectionID for Repository.CheckFileUIDMetadata
func (mmCheckFileUIDMetadata *mRepositoryMockCheckFileUIDMetadata) ExpectCollectionIDParam2(collectionID string) *mRepositoryMockCheckFileUIDMetadata {
	if mmCheckFileUIDMetadata.mock.funcCheckFileUIDMetadata != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("RepositoryMock.CheckFileUIDMetadata mock is already set by Set")
	}

	if mmCheckFileUIDMetadata.defaultExpectation == nil {
		mmCheckFileUIDMetadata.defaultExpectation = &RepositoryMockCheckFileUIDMetadataExpectation{}
	}

	if mmCheckFileUIDMetadata.defaultExpectation.params != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("RepositoryMock.CheckFileUIDMetadata mock is already set by Expect")
	}

	if mmCheckFileUIDMetadata.defaultExpectation.paramPtrs == nil {
		mmCheckFileUIDMetadata.defaultExpectation.paramPtrs = &RepositoryMockCheckFileUIDMetadataParamPtrs{}
	}
	mmCheckFileUIDMetadata.defaultExpectation.paramPtrs.collectionID = &collectionID
	mmCheckFileUIDMetadata.defaultExpectation.expectationOrigins.originCollectionID = minimock.CallerInfo(1)

	return mmCheckFileUIDMetadata
}

// Inspect accepts an inspector function that has same arguments as the Repository.CheckFileUIDMetadata
func (mmCheckFileUIDMetadata *mRepositoryMockCheckFileUIDMetadata) Inspect(f func(ctx context.Context, collectionID string)) *mRepositoryMockCheckFileUIDMetadata {
	if mmCheckFileUIDMetadata.mock.inspectFuncCheckFileUIDMetadata != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CheckFileUIDMetadata")
	}

	mmCheckFileUIDMetadata.mock.inspectFuncCheckFileUIDMetadata = f

	return mmCheckFileUIDMetadata
}

// Return sets up results that will be returned by Repository.CheckFileUIDMetadata
func (mmCheckFileUIDMetadata *mRepositoryMockCheckFileUIDMetadata) Return(b1 bool, err error) *RepositoryMock {
	if mmCheckFileUIDMetadata.mock.funcCheckFileUIDMetadata != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("RepositoryMock.CheckFileUIDMetadata mock is already set by Set")
	}

	if mmCheckFileUIDMetadata.defaultExpectation == nil {
		mmCheckFileUIDMetadata.defaultExpectation = &RepositoryMockCheckFileUIDMetadataExpectation{mock: mmCheckFileUIDMetadata.mock}
	}
	mmCheckFileUIDMetadata.defaultExpectation.results = &RepositoryMockCheckFileUIDMetadataResults{b1, err}
	mmCheckFileUIDMetadata.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckFileUIDMetadata.mock
}

// Set uses given function f to mock the Repository.CheckFileUIDMetadata method
func (mmCheckFileUIDMetadata *mRepositoryMockCheckFileUIDMetadata) Set(f func(ctx context.Context, collectionID string) (b1 bool, err error)) *RepositoryMock {
	if mmCheckFileUIDMetadata.defaultExpectation != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("Default expectation is already set for the Repository.CheckFileUIDMetadata method")
	}

	if len(mmCheckFileUIDMetadata.expectations) > 0 {
		mmCheckFileUIDMetadata.mock.t.Fatalf("Some expectations are already set for the Repository.CheckFileUIDMetadata method")
	}

	mmCheckFileUIDMetadata.mock.funcCheckFileUIDMetadata = f
	mmCheckFileUIDMetadata.mock.funcCheckFileUIDMetadataOrigin = minimock.CallerInfo(1)
	return mmCheckFileUIDMetadata.mock
}

// When sets expectation for the Repository.CheckFileUIDMetadata which will trigger the result defined by the following
// Then helper
func (mmCheckFileUIDMetadata *mRepositoryMockCheckFileUIDMetadata) When(ctx context.Context, collectionID string) *RepositoryMockCheckFileUIDMetadataExpectation {
	if mmCheckFileUIDMetadata.mock.funcCheckFileUIDMetadata != nil {
		mmCheckFileUIDMetadata.mock.t.Fatalf("RepositoryMock.CheckFileUIDMetadata mock is already set by Set")
	}

	expectation := &RepositoryMockCheckFileUIDMetadataExpectation{
		mock:               mmCheckFileUIDMetadata.mock,
		params:             &RepositoryMockCheckFileUIDMetadataParams{ctx, collectionID},
		expectationOrigins: RepositoryMockCheckFileUIDMetadataExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckFileUIDMetadata.expectations = append(mmCheckFileUIDMetadata.expectations, expectation)
	return expectation
}

// Then sets up Repository.CheckFileUIDMetadata return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCheckFileUIDMetadataExpectation) Then(b1 bool, err error) *RepositoryMock {
	e.results = &RepositoryMockCheckFileUIDMetadataResults{b1, err}
	return e.mock
}

// Times sets number of times Repository.CheckFileUIDMetadata should be invoked
func (mmCheckFileUIDMetadata *mRepositoryMockCheckFileUIDMetadata) Times(n uint64) *mRepositoryMockCheckFileUIDMetadata {
	if n == 0 {
		mmCheckFileUIDMetadata.mock.t.Fatalf("Times of RepositoryMock.CheckFileUIDMetadata mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckFileUIDMetadata.expectedInvocations, n)
	mmCheckFileUIDMetadata.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckFileUIDMetadata
}

func (mmCheckFileUIDMetadata *mRepositoryMockCheckFileUIDMetadata) invocationsDone() bool {
	if len(mmCheckFileUIDMetadata.expectations) == 0 && mmCheckFileUIDMetadata.defaultExpectation == nil && mmCheckFileUIDMetadata.mock.funcCheckFileUIDMetadata == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckFileUIDMetadata.mock.afterCheckFileUIDMetadataCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckFileUIDMetadata.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckFileUIDMetadata implements mm_repository.Repository
func (mmCheckFileUIDMetadata *RepositoryMock) CheckFileUIDMetadata(ctx context.Context, collectionID string) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmCheckFileUIDMetadata.beforeCheckFileUIDMetadataCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckFileUIDMetadata.afterCheckFileUIDMetadataCounter, 1)

	mmCheckFileUIDMetadata.t.Helper()

	if mmCheckFileUIDMetadata.inspectFuncCheckFileUIDMetadata != nil {
		mmCheckFileUIDMetadata.inspectFuncCheckFileUIDMetadata(ctx, collectionID)
	}

	mm_params := RepositoryMockCheckFileUIDMetadataParams{ctx, collectionID}

	// Record call args
	mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.mutex.Lock()
	mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.callArgs = append(mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.callArgs, &mm_params)
	mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.mutex.Unlock()

	for _, e := range mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.defaultExpectation.params
		mm_want_ptrs := mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCheckFileUIDMetadataParams{ctx, collectionID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckFileUIDMetadata.t.Errorf("RepositoryMock.CheckFileUIDMetadata got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.collectionID != nil && !minimock.Equal(*mm_want_ptrs.collectionID, mm_got.collectionID) {
				mmCheckFileUIDMetadata.t.Errorf("RepositoryMock.CheckFileUIDMetadata got unexpected parameter collectionID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.defaultExpectation.expectationOrigins.originCollectionID, *mm_want_ptrs.collectionID, mm_got.collectionID, minimock.Diff(*mm_want_ptrs.collectionID, mm_got.collectionID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckFileUIDMetadata.t.Errorf("RepositoryMock.CheckFileUIDMetadata got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckFileUIDMetadata.CheckFileUIDMetadataMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckFileUIDMetadata.t.Fatal("No results are set for the RepositoryMock.CheckFileUIDMetadata")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmCheckFileUIDMetadata.funcCheckFileUIDMetadata != nil {
		return mmCheckFileUIDMetadata.funcCheckFileUIDMetadata(ctx, collectionID)
	}
	mmCheckFileUIDMetadata.t.Fatalf("Unexpected call to RepositoryMock.CheckFileUIDMetadata. %v %v", ctx, collectionID)
	return
}

// CheckFileUIDMetadataAfterCounter returns a count of finished RepositoryMock.CheckFileUIDMetadata invocations
func (mmCheckFileUIDMetadata *RepositoryMock) CheckFileUIDMetadataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckFileUIDMetadata.afterCheckFileUIDMetadataCounter)
}

// CheckFileUIDMetadataBeforeCounter returns a count of RepositoryMock.CheckFileUIDMetadata invocations
func (mmCheckFileUIDMetadata *RepositoryMock) CheckFileUIDMetadataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckFileUIDMetadata.beforeCheckFileUIDMetadataCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CheckFileUIDMetadata.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckFileUIDMetadata *mRepositoryMockCheckFileUIDMetadata) Calls() []*RepositoryMockCheckFileUIDMetadataParams {
	mmCheckFileUIDMetadata.mutex.RLock()

	argCopy := make([]*RepositoryMockCheckFileUIDMetadataParams, len(mmCheckFileUIDMetadata.callArgs))
	copy(argCopy, mmCheckFileUIDMetadata.callArgs)

	mmCheckFileUIDMetadata.mutex.RUnlock()

	return argCopy
}

// MinimockCheckFileUIDMetadataDone returns true if the count of the CheckFileUIDMetadata invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCheckFileUIDMetadataDone() bool {
	if m.CheckFileUIDMetadataMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckFileUIDMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckFileUIDMetadataMock.invocationsDone()
}

// MinimockCheckFileUIDMetadataInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCheckFileUIDMetadataInspect() {
	for _, e := range m.CheckFileUIDMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CheckFileUIDMetadata at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckFileUIDMetadataCounter := mm_atomic.LoadUint64(&m.afterCheckFileUIDMetadataCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckFileUIDMetadataMock.defaultExpectation != nil && afterCheckFileUIDMetadataCounter < 1 {
		if m.CheckFileUIDMetadataMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CheckFileUIDMetadata at\n%s", m.CheckFileUIDMetadataMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CheckFileUIDMetadata at\n%s with params: %#v", m.CheckFileUIDMetadataMock.defaultExpectation.expectationOrigins.origin, *m.CheckFileUIDMetadataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckFileUIDMetadata != nil && afterCheckFileUIDMetadataCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CheckFileUIDMetadata at\n%s", m.funcCheckFileUIDMetadataOrigin)
	}

	if !m.CheckFileUIDMetadataMock.invocationsDone() && afterCheckFileUIDMetadataCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CheckFileUIDMetadata at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckFileUIDMetadataMock.expectedInvocations), m.CheckFileUIDMetadataMock.expectedInvocationsOrigin, afterCheckFileUIDMetadataCounter)
	}
}

type mRepositoryMockCreateCollection struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateCollectionExpectation
	expectations       []*RepositoryMockCreateCollectionExpectation

	callArgs []*RepositoryMockCreateCollectionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateCollectionExpectation specifies expectation struct of the Repository.CreateCollection
type RepositoryMockCreateCollectionExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateCollectionParams
	paramPtrs          *RepositoryMockCreateCollectionParamPtrs
	expectationOrigins RepositoryMockCreateCollectionExpectationOrigins
	results            *RepositoryMockCreateCollectionResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateCollectionParams contains parameters of the Repository.CreateCollection
type RepositoryMockCreateCollectionParams struct {
	ctx context.Context
	id  string
}

// RepositoryMockCreateCollectionParamPtrs contains pointers to parameters of the Repository.CreateCollection
type RepositoryMockCreateCollectionParamPtrs struct {
	ctx *context.Context
	id  *string
}

// RepositoryMockCreateCollectionResults contains results of the Repository.CreateCollection
type RepositoryMockCreateCollectionResults struct {
	err error
}

// RepositoryMockCreateCollectionOrigins contains origins of expectations of the Repository.CreateCollection
type RepositoryMockCreateCollectionExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateCollection *mRepositoryMockCreateCollection) Optional() *mRepositoryMockCreateCollection {
	mmCreateCollection.optional = true
	return mmCreateCollection
}

// Expect sets up expected params for Repository.CreateCollection
func (mmCreateCollection *mRepositoryMockCreateCollection) Expect(ctx context.Context, id string) *mRepositoryMockCreateCollection {
	if mmCreateCollection.mock.funcCreateCollection != nil {
		mmCreateCollection.mock.t.Fatalf("RepositoryMock.CreateCollection mock is already set by Set")
	}

	if mmCreateCollection.defaultExpectation == nil {
		mmCreateCollection.defaultExpectation = &RepositoryMockCreateCollectionExpectation{}
	}

	if mmCreateCollection.defaultExpectation.paramPtrs != nil {
		mmCreateCollection.mock.t.Fatalf("RepositoryMock.CreateCollection mock is already set by ExpectParams functions")
	}

	mmCreateCollection.defaultExpectation.params = &RepositoryMockCreateCollectionParams{ctx, id}
	mmCreateCollection.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateCollection.expectations {
		if minimock.Equal(e.params, mmCreateCollection.defaultExpectation.params) {
			mmCreateCollection.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateCollection.defaultExpectation.params)
		}
	}

	return mmCreateCollection
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateCollection
func (mmCreateCollection *mRepositoryMockCreateCollection) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateCollection {
	if mmCreateCollection.mock.funcCreateCollection != nil {
		mmCreateCollection.mock.t.Fatalf("RepositoryMock.CreateCollection mock is already set by Set")
	}

	if mmCreateCollection.defaultExpectation == nil {
		mmCreateCollection.defaultExpectation = &RepositoryMockCreateCollectionExpectation{}
	}

	if mmCreateCollection.defaultExpectation.params != nil {
		mmCreateCollection.mock.t.Fatalf("RepositoryMock.CreateCollection mock is already set by Expect")
	}

	if mmCreateCollection.defaultExpectation.paramPtrs == nil {
		mmCreateCollection.defaultExpectation.paramPtrs = &RepositoryMockCreateCollectionParamPtrs{}
	}
	mmCreateCollection.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateCollection.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateCollection
}

// ExpectIdParam2 sets up expected param id for Repository.CreateCollection
func (mmCreateCollection *mRepositoryMockCreateCollection) ExpectIdParam2(id string) *mRepositoryMockCreateCollection {
	if mmCreateCollection.mock.funcCreateCollection != nil {
		mmCreateCollection.mock.t.Fatalf("RepositoryMock.CreateCollection mock is already set by Set")
	}

	if mmCreateCollection.defaultExpectation == nil {
		mmCreateCollection.defaultExpectation = &RepositoryMockCreateCollectionExpectation{}
	}

	if mmCreateCollection.defaultExpectation.params != nil {
		mmCreateCollection.mock.t.Fatalf("RepositoryMock.CreateCollection mock is already set by Expect")
	}

	if mmCreateCollection.defaultExpectation.paramPtrs == nil {
		mmCreateCollection.defaultExpectation.paramPtrs = &RepositoryMockCreateCollectionParamPtrs{}
	}
	mmCreateCollection.defaultExpectation.paramPtrs.id = &id
	mmCreateCollection.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmCreateCollection
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateCollection
func (mmCreateCollection *mRepositoryMockCreateCollection) Inspect(f func(ctx context.Context, id string)) *mRepositoryMockCreateCollection {
	if mmCreateCollection.mock.inspectFuncCreateCollection != nil {
		mmCreateCollection.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateCollection")
	}

	mmCreateCollection.mock.inspectFuncCreateCollection = f

	return mmCreateCollection
}

// Return sets up results that will be returned by Repository.CreateCollection
func (mmCreateCollection *mRepositoryMockCreateCollection) Return(err error) *RepositoryMock {
	if mmCreateCollection.mock.funcCreateCollection != nil {
		mmCreateCollection.mock.t.Fatalf("RepositoryMock.CreateCollection mock is already set by Set")
	}

	if mmCreateCollection.defaultExpectation == nil {
		mmCreateCollection.defaultExpectation = &RepositoryMockCreateCollectionExpectation{mock: mmCreateCollection.mock}
	}
	mmCreateCollection.defaultExpectation.results = &RepositoryMockCreateCollectionResults{err}
	mmCreateCollection.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateCollection.mock
}

// Set uses given function f to mock the Repository.CreateCollection method
func (mmCreateCollection *mRepositoryMockCreateCollection) Set(f func(ctx context.Context, id string) (err error)) *RepositoryMock {
	if mmCreateCollection.defaultExpectation != nil {
		mmCreateCollection.mock.t.Fatalf("Default expectation is already set for the Repository.CreateCollection method")
	}

	if len(mmCreateCollection.expectations) > 0 {
		mmCreateCollection.mock.t.Fatalf("Some expectations are already set for the Repository.CreateCollection method")
	}

	mmCreateCollection.mock.funcCreateCollection = f
	mmCreateCollection.mock.funcCreateCollectionOrigin = minimock.CallerInfo(1)
	return mmCreateCollection.mock
}

// When sets expectation for the Repository.CreateCollection which will trigger the result defined by the following
// Then helper
func (mmCreateCollection *mRepositoryMockCreateCollection) When(ctx context.Context, id string) *RepositoryMockCreateCollectionExpectation {
	if mmCreateCollection.mock.funcCreateCollection != nil {
		mmCreateCollection.mock.t.Fatalf("RepositoryMock.CreateCollection mock is already set by Set")
	}

	expectation := &RepositoryMockCreateCollectionExpectation{
		mock:               mmCreateCollection.mock,
		params:             &RepositoryMockCreateCollectionParams{ctx, id},
		expectationOrigins: RepositoryMockCreateCollectionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateCollection.expectations = append(mmCreateCollection.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateCollection return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateCollectionExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreateCollectionResults{err}
	return e.mock
}

// Times sets number of times Repository.CreateCollection should be invoked
func (mmCreateCollection *mRepositoryMockCreateCollection) Times(n uint64) *mRepositoryMockCreateCollection {
	if n == 0 {
		mmCreateCollection.mock.t.Fatalf("Times of RepositoryMock.CreateCollection mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateCollection.expectedInvocations, n)
	mmCreateCollection.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateCollection
}

func (mmCreateCollection *mRepositoryMockCreateCollection) invocationsDone() bool {
	if len(mmCreateCollection.expectations) == 0 && mmCreateCollection.defaultExpectation == nil && mmCreateCollection.mock.funcCreateCollection == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateCollection.mock.afterCreateCollectionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateCollection.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateCollection implements mm_repository.Repository
func (mmCreateCollection *RepositoryMock) CreateCollection(ctx context.Context, id string) (err error) {
	mm_atomic.AddUint64(&mmCreateCollection.beforeCreateCollectionCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateCollection.afterCreateCollectionCounter, 1)

	mmCreateCollection.t.Helper()

	if mmCreateCollection.inspectFuncCreateCollection != nil {
		mmCreateCollection.inspectFuncCreateCollection(ctx, id)
	}

	mm_params := RepositoryMockCreateCollectionParams{ctx, id}

	// Record call args
	mmCreateCollection.CreateCollectionMock.mutex.Lock()
	mmCreateCollection.CreateCollectionMock.callArgs = append(mmCreateCollection.CreateCollectionMock.callArgs, &mm_params)
	mmCreateCollection.CreateCollectionMock.mutex.Unlock()

	for _, e := range mmCreateCollection.CreateCollectionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateCollection.CreateCollectionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateCollection.CreateCollectionMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateCollection.CreateCollectionMock.defaultExpectation.params
		mm_want_ptrs := mmCreateCollection.CreateCollectionMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateCollectionParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateCollection.t.Errorf("RepositoryMock.CreateCollection got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCollection.CreateCollectionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmCreateCollection.t.Errorf("RepositoryMock.CreateCollection got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCollection.CreateCollectionMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateCollection.t.Errorf("RepositoryMock.CreateCollection got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateCollection.CreateCollectionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateCollection.CreateCollectionMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateCollection.t.Fatal("No results are set for the RepositoryMock.CreateCollection")
		}
		return (*mm_results).err
	}
	if mmCreateCollection.funcCreateCollection != nil {
		return mmCreateCollection.funcCreateCollection(ctx, id)
	}
	mmCreateCollection.t.Fatalf("Unexpected call to RepositoryMock.CreateCollection. %v %v", ctx, id)
	return
}

// CreateCollectionAfterCounter returns a count of finished RepositoryMock.CreateCollection invocations
func (mmCreateCollection *RepositoryMock) CreateCollectionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCollection.afterCreateCollectionCounter)
}

// CreateCollectionBeforeCounter returns a count of RepositoryMock.CreateCollection invocations
func (mmCreateCollection *RepositoryMock) CreateCollectionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCollection.beforeCreateCollectionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateCollection.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateCollection *mRepositoryMockCreateCollection) Calls() []*RepositoryMockCreateCollectionParams {
	mmCreateCollection.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateCollectionParams, len(mmCreateCollection.callArgs))
	copy(argCopy, mmCreateCollection.callArgs)

	mmCreateCollection.mutex.RUnlock()

	return argCopy
}

// MinimockCreateCollectionDone returns true if the count of the CreateCollection invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateCollectionDone() bool {
	if m.CreateCollectionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateCollectionMock.invocationsDone()
}

// MinimockCreateCollectionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateCollectionInspect() {
	for _, e := range m.CreateCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateCollection at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCollectionCounter := mm_atomic.LoadUint64(&m.afterCreateCollectionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateCollectionMock.defaultExpectation != nil && afterCreateCollectionCounter < 1 {
		if m.CreateCollectionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateCollection at\n%s", m.CreateCollectionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateCollection at\n%s with params: %#v", m.CreateCollectionMock.defaultExpectation.expectationOrigins.origin, *m.CreateCollectionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateCollection != nil && afterCreateCollectionCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateCollection at\n%s", m.funcCreateCollectionOrigin)
	}

	if !m.CreateCollectionMock.invocationsDone() && afterCreateCollectionCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateCollection at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateCollectionMock.expectedInvocations), m.CreateCollectionMock.expectedInvocationsOrigin, afterCreateCollectionCounter)
	}
}

type mRepositoryMockCreateConvertedFileWithDestination struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateConvertedFileWithDestinationExpectation
	expectations       []*RepositoryMockCreateConvertedFileWithDestinationExpectation

	callArgs []*RepositoryMockCreateConvertedFileWithDestinationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateConvertedFileWithDestinationExpectation specifies expectation struct of the Repository.CreateConvertedFileWithDestination
type RepositoryMockCreateConvertedFileWithDestinationExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateConvertedFileWithDestinationParams
	paramPtrs          *RepositoryMockCreateConvertedFileWithDestinationParamPtrs
	expectationOrigins RepositoryMockCreateConvertedFileWithDestinationExpectationOrigins
	results            *RepositoryMockCreateConvertedFileWithDestinationResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateConvertedFileWithDestinationParams contains parameters of the Repository.CreateConvertedFileWithDestination
type RepositoryMockCreateConvertedFileWithDestinationParams struct {
	ctx context.Context
	cf  mm_repository.ConvertedFileModel
}

// RepositoryMockCreateConvertedFileWithDestinationParamPtrs contains pointers to parameters of the Repository.CreateConvertedFileWithDestination
type RepositoryMockCreateConvertedFileWithDestinationParamPtrs struct {
	ctx *context.Context
	cf  *mm_repository.ConvertedFileModel
}

// RepositoryMockCreateConvertedFileWithDestinationResults contains results of the Repository.CreateConvertedFileWithDestination
type RepositoryMockCreateConvertedFileWithDestinationResults struct {
	cp1 *mm_repository.ConvertedFileModel
	err error
}

// RepositoryMockCreateConvertedFileWithDestinationOrigins contains origins of expectations of the Repository.CreateConvertedFileWithDestination
type RepositoryMockCreateConvertedFileWithDestinationExpectationOrigins struct {
	origin    string
	originCtx string
	originCf  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateConvertedFileWithDestination *mRepositoryMockCreateConvertedFileWithDestination) Optional() *mRepositoryMockCreateConvertedFileWithDestination {
	mmCreateConvertedFileWithDestination.optional = true
	return mmCreateConvertedFileWithDestination
}

// Expect sets up expected params for Repository.CreateConvertedFileWithDestination
func (mmCreateConvertedFileWithDestination *mRepositoryMockCreateConvertedFileWithDestination) Expect(ctx context.Context, cf mm_repository.ConvertedFileModel) *mRepositoryMockCreateConvertedFileWithDestination {
	if mmCreateConvertedFileWithDestination.mock.funcCreateConvertedFileWithDestination != nil {
		mmCreateConvertedFileWithDestination.mock.t.Fatalf("RepositoryMock.CreateConvertedFileWithDestination mock is already set by Set")
	}

	if mmCreateConvertedFileWithDestination.defaultExpectation == nil {
		mmCreateConvertedFileWithDestination.defaultExpectation = &RepositoryMockCreateConvertedFileWithDestinationExpectation{}
	}

	if mmCreateConvertedFileWithDestination.defaultExpectation.paramPtrs != nil {
		mmCreateConvertedFileWithDestination.mock.t.Fatalf("RepositoryMock.CreateConvertedFileWithDestination mock is already set by ExpectParams functions")
	}

	mmCreateConvertedFileWithDestination.defaultExpectation.params = &RepositoryMockCreateConvertedFileWithDestinationParams{ctx, cf}
	mmCreateConvertedFileWithDestination.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateConvertedFileWithDestination.expectations {
		if minimock.Equal(e.params, mmCreateConvertedFileWithDestination.defaultExpectation.params) {
			mmCreateConvertedFileWithDestination.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateConvertedFileWithDestination.defaultExpectation.params)
		}
	}

	return mmCreateConvertedFileWithDestination
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateConvertedFileWithDestination
func (mmCreateConvertedFileWithDestination *mRepositoryMockCreateConvertedFileWithDestination) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateConvertedFileWithDestination {
	if mmCreateConvertedFileWithDestination.mock.funcCreateConvertedFileWithDestination != nil {
		mmCreateConvertedFileWithDestination.mock.t.Fatalf("RepositoryMock.CreateConvertedFileWithDestination mock is already set by Set")
	}

	if mmCreateConvertedFileWithDestination.defaultExpectation == nil {
		mmCreateConvertedFileWithDestination.defaultExpectation = &RepositoryMockCreateConvertedFileWithDestinationExpectation{}
	}

	if mmCreateConvertedFileWithDestination.defaultExpectation.params != nil {
		mmCreateConvertedFileWithDestination.mock.t.Fatalf("RepositoryMock.CreateConvertedFileWithDestination mock is already set by Expect")
	}

	if mmCreateConvertedFileWithDestination.defaultExpectation.paramPtrs == nil {
		mmCreateConvertedFileWithDestination.defaultExpectation.paramPtrs = &RepositoryMockCreateConvertedFileWithDestinationParamPtrs{}
	}
	mmCreateConvertedFileWithDestination.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateConvertedFileWithDestination.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateConvertedFileWithDestination
}

// ExpectCfParam2 sets up expected param cf for Repository.CreateConvertedFileWithDestination
func (mmCreateConvertedFileWithDestination *mRepositoryMockCreateConvertedFileWithDestination) ExpectCfParam2(cf mm_repository.ConvertedFileModel) *mRepositoryMockCreateConvertedFileWithDestination {
	if mmCreateConvertedFileWithDestination.mock.funcCreateConvertedFileWithDestination != nil {
		mmCreateConvertedFileWithDestination.mock.t.Fatalf("RepositoryMock.CreateConvertedFileWithDestination mock is already set by Set")
	}

	if mmCreateConvertedFileWithDestination.defaultExpectation == nil {
		mmCreateConvertedFileWithDestination.defaultExpectation = &RepositoryMockCreateConvertedFileWithDestinationExpectation{}
	}

	if mmCreateConvertedFileWithDestination.defaultExpectation.params != nil {
		mmCreateConvertedFileWithDestination.mock.t.Fatalf("RepositoryMock.CreateConvertedFileWithDestination mock is already set by Expect")
	}

	if mmCreateConvertedFileWithDestination.defaultExpectation.paramPtrs == nil {
		mmCreateConvertedFileWithDestination.defaultExpectation.paramPtrs = &RepositoryMockCreateConvertedFileWithDestinationParamPtrs{}
	}
	mmCreateConvertedFileWithDestination.defaultExpectation.paramPtrs.cf = &cf
	mmCreateConvertedFileWithDestination.defaultExpectation.expectationOrigins.originCf = minimock.CallerInfo(1)

	return mmCreateConvertedFileWithDestination
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateConvertedFileWithDestination
func (mmCreateConvertedFileWithDestination *mRepositoryMockCreateConvertedFileWithDestination) Inspect(f func(ctx context.Context, cf mm_repository.ConvertedFileModel)) *mRepositoryMockCreateConvertedFileWithDestination {
	if mmCreateConvertedFileWithDestination.mock.inspectFuncCreateConvertedFileWithDestination != nil {
		mmCreateConvertedFileWithDestination.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateConvertedFileWithDestination")
	}

	mmCreateConvertedFileWithDestination.mock.inspectFuncCreateConvertedFileWithDestination = f

	return mmCreateConvertedFileWithDestination
}

// Return sets up results that will be returned by Repository.CreateConvertedFileWithDestination
func (mmCreateConvertedFileWithDestination *mRepositoryMockCreateConvertedFileWithDestination) Return(cp1 *mm_repository.ConvertedFileModel, err error) *RepositoryMock {
	if mmCreateConvertedFileWithDestination.mock.funcCreateConvertedFileWithDestination != nil {
		mmCreateConvertedFileWithDestination.mock.t.Fatalf("RepositoryMock.CreateConvertedFileWithDestination mock is already set by Set")
	}

	if mmCreateConvertedFileWithDestination.defaultExpectation == nil {
		mmCreateConvertedFileWithDestination.defaultExpectation = &RepositoryMockCreateConvertedFileWithDestinationExpectation{mock: mmCreateConvertedFileWithDestination.mock}
	}
	mmCreateConvertedFileWithDestination.defaultExpectation.results = &RepositoryMockCreateConvertedFileWithDestinationResults{cp1, err}
	mmCreateConvertedFileWithDestination.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateConvertedFileWithDestination.mock
}

// Set uses given function f to mock the Repository.CreateConvertedFileWithDestination method
func (mmCreateConvertedFileWithDestination *mRepositoryMockCreateConvertedFileWithDestination) Set(f func(ctx context.Context, cf mm_repository.ConvertedFileModel) (cp1 *mm_repository.ConvertedFileModel, err error)) *RepositoryMock {
	if mmCreateConvertedFileWithDestination.defaultExpectation != nil {
		mmCreateConvertedFileWithDestination.mock.t.Fatalf("Default expectation is already set for the Repository.CreateConvertedFileWithDestination method")
	}

	if len(mmCreateConvertedFileWithDestination.expectations) > 0 {
		mmCreateConvertedFileWithDestination.mock.t.Fatalf("Some expectations are already set for the Repository.CreateConvertedFileWithDestination method")
	}

	mmCreateConvertedFileWithDestination.mock.funcCreateConvertedFileWithDestination = f
	mmCreateConvertedFileWithDestination.mock.funcCreateConvertedFileWithDestinationOrigin = minimock.CallerInfo(1)
	return mmCreateConvertedFileWithDestination.mock
}

// When sets expectation for the Repository.CreateConvertedFileWithDestination which will trigger the result defined by the following
// Then helper
func (mmCreateConvertedFileWithDestination *mRepositoryMockCreateConvertedFileWithDestination) When(ctx context.Context, cf mm_repository.ConvertedFileModel) *RepositoryMockCreateConvertedFileWithDestinationExpectation {
	if mmCreateConvertedFileWithDestination.mock.funcCreateConvertedFileWithDestination != nil {
		mmCreateConvertedFileWithDestination.mock.t.Fatalf("RepositoryMock.CreateConvertedFileWithDestination mock is already set by Set")
	}

	expectation := &RepositoryMockCreateConvertedFileWithDestinationExpectation{
		mock:               mmCreateConvertedFileWithDestination.mock,
		params:             &RepositoryMockCreateConvertedFileWithDestinationParams{ctx, cf},
		expectationOrigins: RepositoryMockCreateConvertedFileWithDestinationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateConvertedFileWithDestination.expectations = append(mmCreateConvertedFileWithDestination.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateConvertedFileWithDestination return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateConvertedFileWithDestinationExpectation) Then(cp1 *mm_repository.ConvertedFileModel, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateConvertedFileWithDestinationResults{cp1, err}
	return e.mock
}

// Times sets number of times Repository.CreateConvertedFileWithDestination should be invoked
func (mmCreateConvertedFileWithDestination *mRepositoryMockCreateConvertedFileWithDestination) Times(n uint64) *mRepositoryMockCreateConvertedFileWithDestination {
	if n == 0 {
		mmCreateConvertedFileWithDestination.mock.t.Fatalf("Times of RepositoryMock.CreateConvertedFileWithDestination mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateConvertedFileWithDestination.expectedInvocations, n)
	mmCreateConvertedFileWithDestination.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateConvertedFileWithDestination
}

func (mmCreateConvertedFileWithDestination *mRepositoryMockCreateConvertedFileWithDestination) invocationsDone() bool {
	if len(mmCreateConvertedFileWithDestination.expectations) == 0 && mmCreateConvertedFileWithDestination.defaultExpectation == nil && mmCreateConvertedFileWithDestination.mock.funcCreateConvertedFileWithDestination == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateConvertedFileWithDestination.mock.afterCreateConvertedFileWithDestinationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateConvertedFileWithDestination.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateConvertedFileWithDestination implements mm_repository.Repository
func (mmCreateConvertedFileWithDestination *RepositoryMock) CreateConvertedFileWithDestination(ctx context.Context, cf mm_repository.ConvertedFileModel) (cp1 *mm_repository.ConvertedFileModel, err error) {
	mm_atomic.AddUint64(&mmCreateConvertedFileWithDestination.beforeCreateConvertedFileWithDestinationCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateConvertedFileWithDestination.afterCreateConvertedFileWithDestinationCounter, 1)

	mmCreateConvertedFileWithDestination.t.Helper()

	if mmCreateConvertedFileWithDestination.inspectFuncCreateConvertedFileWithDestination != nil {
		mmCreateConvertedFileWithDestination.inspectFuncCreateConvertedFileWithDestination(ctx, cf)
	}

	mm_params := RepositoryMockCreateConvertedFileWithDestinationParams{ctx, cf}

	// Record call args
	mmCreateConvertedFileWithDestination.CreateConvertedFileWithDestinationMock.mutex.Lock()
	mmCreateConvertedFileWithDestination.CreateConvertedFileWithDestinationMock.callArgs = append(mmCreateConvertedFileWithDestination.CreateConvertedFileWithDestinationMock.callArgs, &mm_params)
	mmCreateConvertedFileWithDestination.CreateConvertedFileWithDestinationMock.mutex.Unlock()

	for _, e := range mmCreateConvertedFileWithDestination.CreateConvertedFileWithDestinationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCreateConvertedFileWithDestination.CreateConvertedFileWithDestinationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateConvertedFileWithDestination.CreateConvertedFileWithDestinationMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateConvertedFileWithDestination.CreateConvertedFileWithDestinationMock.defaultExpectation.params
		mm_want_ptrs := mmCreateConvertedFileWithDestination.CreateConvertedFileWithDestinationMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateConvertedFileWithDestinationParams{ctx, cf}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateConvertedFileWithDestination.t.Errorf("RepositoryMock.CreateConvertedFileWithDestination got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateConvertedFileWithDestination.CreateConvertedFileWithDestinationMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cf != nil && !minimock.Equal(*mm_want_ptrs.cf, mm_got.cf) {
				mmCreateConvertedFileWithDestination.t.Errorf("RepositoryMock.CreateConvertedFileWithDestination got unexpected parameter cf, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateConvertedFileWithDestination.CreateConvertedFileWithDestinationMock.defaultExpectation.expectationOrigins.originCf, *mm_want_ptrs.cf, mm_got.cf, minimock.Diff(*mm_want_ptrs.cf, mm_got.cf))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateConvertedFileWithDestination.t.Errorf("RepositoryMock.CreateConvertedFileWithDestination got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateConvertedFileWithDestination.CreateConvertedFileWithDestinationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateConvertedFileWithDestination.CreateConvertedFileWithDestinationMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateConvertedFileWithDestination.t.Fatal("No results are set for the RepositoryMock.CreateConvertedFileWithDestination")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCreateConvertedFileWithDestination.funcCreateConvertedFileWithDestination != nil {
		return mmCreateConvertedFileWithDestination.funcCreateConvertedFileWithDestination(ctx, cf)
	}
	mmCreateConvertedFileWithDestination.t.Fatalf("Unexpected call to RepositoryMock.CreateConvertedFileWithDestination. %v %v", ctx, cf)
	return
}

// CreateConvertedFileWithDestinationAfterCounter returns a count of finished RepositoryMock.CreateConvertedFileWithDestination invocations
func (mmCreateConvertedFileWithDestination *RepositoryMock) CreateConvertedFileWithDestinationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateConvertedFileWithDestination.afterCreateConvertedFileWithDestinationCounter)
}

// CreateConvertedFileWithDestinationBeforeCounter returns a count of RepositoryMock.CreateConvertedFileWithDestination invocations
func (mmCreateConvertedFileWithDestination *RepositoryMock) CreateConvertedFileWithDestinationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateConvertedFileWithDestination.beforeCreateConvertedFileWithDestinationCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateConvertedFileWithDestination.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateConvertedFileWithDestination *mRepositoryMockCreateConvertedFileWithDestination) Calls() []*RepositoryMockCreateConvertedFileWithDestinationParams {
	mmCreateConvertedFileWithDestination.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateConvertedFileWithDestinationParams, len(mmCreateConvertedFileWithDestination.callArgs))
	copy(argCopy, mmCreateConvertedFileWithDestination.callArgs)

	mmCreateConvertedFileWithDestination.mutex.RUnlock()

	return argCopy
}

// MinimockCreateConvertedFileWithDestinationDone returns true if the count of the CreateConvertedFileWithDestination invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateConvertedFileWithDestinationDone() bool {
	if m.CreateConvertedFileWithDestinationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateConvertedFileWithDestinationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateConvertedFileWithDestinationMock.invocationsDone()
}

// MinimockCreateConvertedFileWithDestinationInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateConvertedFileWithDestinationInspect() {
	for _, e := range m.CreateConvertedFileWithDestinationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateConvertedFileWithDestination at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateConvertedFileWithDestinationCounter := mm_atomic.LoadUint64(&m.afterCreateConvertedFileWithDestinationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateConvertedFileWithDestinationMock.defaultExpectation != nil && afterCreateConvertedFileWithDestinationCounter < 1 {
		if m.CreateConvertedFileWithDestinationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateConvertedFileWithDestination at\n%s", m.CreateConvertedFileWithDestinationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateConvertedFileWithDestination at\n%s with params: %#v", m.CreateConvertedFileWithDestinationMock.defaultExpectation.expectationOrigins.origin, *m.CreateConvertedFileWithDestinationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateConvertedFileWithDestination != nil && afterCreateConvertedFileWithDestinationCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateConvertedFileWithDestination at\n%s", m.funcCreateConvertedFileWithDestinationOrigin)
	}

	if !m.CreateConvertedFileWithDestinationMock.invocationsDone() && afterCreateConvertedFileWithDestinationCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateConvertedFileWithDestination at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateConvertedFileWithDestinationMock.expectedInvocations), m.CreateConvertedFileWithDestinationMock.expectedInvocationsOrigin, afterCreateConvertedFileWithDestinationCounter)
	}
}

type mRepositoryMockCreateEmbeddings struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateEmbeddingsExpectation
	expectations       []*RepositoryMockCreateEmbeddingsExpectation

	callArgs []*RepositoryMockCreateEmbeddingsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateEmbeddingsExpectation specifies expectation struct of the Repository.CreateEmbeddings
type RepositoryMockCreateEmbeddingsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateEmbeddingsParams
	paramPtrs          *RepositoryMockCreateEmbeddingsParamPtrs
	expectationOrigins RepositoryMockCreateEmbeddingsExpectationOrigins
	results            *RepositoryMockCreateEmbeddingsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateEmbeddingsParams contains parameters of the Repository.CreateEmbeddings
type RepositoryMockCreateEmbeddingsParams struct {
	ctx                 context.Context
	embeddings          []mm_repository.EmbeddingModel
	externalServiceCall func([]mm_repository.EmbeddingModel) error
}

// RepositoryMockCreateEmbeddingsParamPtrs contains pointers to parameters of the Repository.CreateEmbeddings
type RepositoryMockCreateEmbeddingsParamPtrs struct {
	ctx                 *context.Context
	embeddings          *[]mm_repository.EmbeddingModel
	externalServiceCall *func([]mm_repository.EmbeddingModel) error
}

// RepositoryMockCreateEmbeddingsResults contains results of the Repository.CreateEmbeddings
type RepositoryMockCreateEmbeddingsResults struct {
	ea1 []mm_repository.EmbeddingModel
	err error
}

// RepositoryMockCreateEmbeddingsOrigins contains origins of expectations of the Repository.CreateEmbeddings
type RepositoryMockCreateEmbeddingsExpectationOrigins struct {
	origin                    string
	originCtx                 string
	originEmbeddings          string
	originExternalServiceCall string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateEmbeddings *mRepositoryMockCreateEmbeddings) Optional() *mRepositoryMockCreateEmbeddings {
	mmCreateEmbeddings.optional = true
	return mmCreateEmbeddings
}

// Expect sets up expected params for Repository.CreateEmbeddings
func (mmCreateEmbeddings *mRepositoryMockCreateEmbeddings) Expect(ctx context.Context, embeddings []mm_repository.EmbeddingModel, externalServiceCall func([]mm_repository.EmbeddingModel) error) *mRepositoryMockCreateEmbeddings {
	if mmCreateEmbeddings.mock.funcCreateEmbeddings != nil {
		mmCreateEmbeddings.mock.t.Fatalf("RepositoryMock.CreateEmbeddings mock is already set by Set")
	}

	if mmCreateEmbeddings.defaultExpectation == nil {
		mmCreateEmbeddings.defaultExpectation = &RepositoryMockCreateEmbeddingsExpectation{}
	}

	if mmCreateEmbeddings.defaultExpectation.paramPtrs != nil {
		mmCreateEmbeddings.mock.t.Fatalf("RepositoryMock.CreateEmbeddings mock is already set by ExpectParams functions")
	}

	mmCreateEmbeddings.defaultExpectation.params = &RepositoryMockCreateEmbeddingsParams{ctx, embeddings, externalServiceCall}
	mmCreateEmbeddings.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateEmbeddings.expectations {
		if minimock.Equal(e.params, mmCreateEmbeddings.defaultExpectation.params) {
			mmCreateEmbeddings.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateEmbeddings.defaultExpectation.params)
		}
	}

	return mmCreateEmbeddings
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateEmbeddings
func (mmCreateEmbeddings *mRepositoryMockCreateEmbeddings) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateEmbeddings {
	if mmCreateEmbeddings.mock.funcCreateEmbeddings != nil {
		mmCreateEmbeddings.mock.t.Fatalf("RepositoryMock.CreateEmbeddings mock is already set by Set")
	}

	if mmCreateEmbeddings.defaultExpectation == nil {
		mmCreateEmbeddings.defaultExpectation = &RepositoryMockCreateEmbeddingsExpectation{}
	}

	if mmCreateEmbeddings.defaultExpectation.params != nil {
		mmCreateEmbeddings.mock.t.Fatalf("RepositoryMock.CreateEmbeddings mock is already set by Expect")
	}

	if mmCreateEmbeddings.defaultExpectation.paramPtrs == nil {
		mmCreateEmbeddings.defaultExpectation.paramPtrs = &RepositoryMockCreateEmbeddingsParamPtrs{}
	}
	mmCreateEmbeddings.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateEmbeddings.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateEmbeddings
}

// ExpectEmbeddingsParam2 sets up expected param embeddings for Repository.CreateEmbeddings
func (mmCreateEmbeddings *mRepositoryMockCreateEmbeddings) ExpectEmbeddingsParam2(embeddings []mm_repository.EmbeddingModel) *mRepositoryMockCreateEmbeddings {
	if mmCreateEmbeddings.mock.funcCreateEmbeddings != nil {
		mmCreateEmbeddings.mock.t.Fatalf("RepositoryMock.CreateEmbeddings mock is already set by Set")
	}

	if mmCreateEmbeddings.defaultExpectation == nil {
		mmCreateEmbeddings.defaultExpectation = &RepositoryMockCreateEmbeddingsExpectation{}
	}

	if mmCreateEmbeddings.defaultExpectation.params != nil {
		mmCreateEmbeddings.mock.t.Fatalf("RepositoryMock.CreateEmbeddings mock is already set by Expect")
	}

	if mmCreateEmbeddings.defaultExpectation.paramPtrs == nil {
		mmCreateEmbeddings.defaultExpectation.paramPtrs = &RepositoryMockCreateEmbeddingsParamPtrs{}
	}
	mmCreateEmbeddings.defaultExpectation.paramPtrs.embeddings = &embeddings
	mmCreateEmbeddings.defaultExpectation.expectationOrigins.originEmbeddings = minimock.CallerInfo(1)

	return mmCreateEmbeddings
}

// ExpectExternalServiceCallParam3 sets up expected param externalServiceCall for Repository.CreateEmbeddings
func (mmCreateEmbeddings *mRepositoryMockCreateEmbeddings) ExpectExternalServiceCallParam3(externalServiceCall func([]mm_repository.EmbeddingModel) error) *mRepositoryMockCreateEmbeddings {
	if mmCreateEmbeddings.mock.funcCreateEmbeddings != nil {
		mmCreateEmbeddings.mock.t.Fatalf("RepositoryMock.CreateEmbeddings mock is already set by Set")
	}

	if mmCreateEmbeddings.defaultExpectation == nil {
		mmCreateEmbeddings.defaultExpectation = &RepositoryMockCreateEmbeddingsExpectation{}
	}

	if mmCreateEmbeddings.defaultExpectation.params != nil {
		mmCreateEmbeddings.mock.t.Fatalf("RepositoryMock.CreateEmbeddings mock is already set by Expect")
	}

	if mmCreateEmbeddings.defaultExpectation.paramPtrs == nil {
		mmCreateEmbeddings.defaultExpectation.paramPtrs = &RepositoryMockCreateEmbeddingsParamPtrs{}
	}
	mmCreateEmbeddings.defaultExpectation.paramPtrs.externalServiceCall = &externalServiceCall
	mmCreateEmbeddings.defaultExpectation.expectationOrigins.originExternalServiceCall = minimock.CallerInfo(1)

	return mmCreateEmbeddings
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateEmbeddings
func (mmCreateEmbeddings *mRepositoryMockCreateEmbeddings) Inspect(f func(ctx context.Context, embeddings []mm_repository.EmbeddingModel, externalServiceCall func([]mm_repository.EmbeddingModel) error)) *mRepositoryMockCreateEmbeddings {
	if mmCreateEmbeddings.mock.inspectFuncCreateEmbeddings != nil {
		mmCreateEmbeddings.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateEmbeddings")
	}

	mmCreateEmbeddings.mock.inspectFuncCreateEmbeddings = f

	return mmCreateEmbeddings
}

// Return sets up results that will be returned by Repository.CreateEmbeddings
func (mmCreateEmbeddings *mRepositoryMockCreateEmbeddings) Return(ea1 []mm_repository.EmbeddingModel, err error) *RepositoryMock {
	if mmCreateEmbeddings.mock.funcCreateEmbeddings != nil {
		mmCreateEmbeddings.mock.t.Fatalf("RepositoryMock.CreateEmbeddings mock is already set by Set")
	}

	if mmCreateEmbeddings.defaultExpectation == nil {
		mmCreateEmbeddings.defaultExpectation = &RepositoryMockCreateEmbeddingsExpectation{mock: mmCreateEmbeddings.mock}
	}
	mmCreateEmbeddings.defaultExpectation.results = &RepositoryMockCreateEmbeddingsResults{ea1, err}
	mmCreateEmbeddings.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateEmbeddings.mock
}

// Set uses given function f to mock the Repository.CreateEmbeddings method
func (mmCreateEmbeddings *mRepositoryMockCreateEmbeddings) Set(f func(ctx context.Context, embeddings []mm_repository.EmbeddingModel, externalServiceCall func([]mm_repository.EmbeddingModel) error) (ea1 []mm_repository.EmbeddingModel, err error)) *RepositoryMock {
	if mmCreateEmbeddings.defaultExpectation != nil {
		mmCreateEmbeddings.mock.t.Fatalf("Default expectation is already set for the Repository.CreateEmbeddings method")
	}

	if len(mmCreateEmbeddings.expectations) > 0 {
		mmCreateEmbeddings.mock.t.Fatalf("Some expectations are already set for the Repository.CreateEmbeddings method")
	}

	mmCreateEmbeddings.mock.funcCreateEmbeddings = f
	mmCreateEmbeddings.mock.funcCreateEmbeddingsOrigin = minimock.CallerInfo(1)
	return mmCreateEmbeddings.mock
}

// When sets expectation for the Repository.CreateEmbeddings which will trigger the result defined by the following
// Then helper
func (mmCreateEmbeddings *mRepositoryMockCreateEmbeddings) When(ctx context.Context, embeddings []mm_repository.EmbeddingModel, externalServiceCall func([]mm_repository.EmbeddingModel) error) *RepositoryMockCreateEmbeddingsExpectation {
	if mmCreateEmbeddings.mock.funcCreateEmbeddings != nil {
		mmCreateEmbeddings.mock.t.Fatalf("RepositoryMock.CreateEmbeddings mock is already set by Set")
	}

	expectation := &RepositoryMockCreateEmbeddingsExpectation{
		mock:               mmCreateEmbeddings.mock,
		params:             &RepositoryMockCreateEmbeddingsParams{ctx, embeddings, externalServiceCall},
		expectationOrigins: RepositoryMockCreateEmbeddingsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateEmbeddings.expectations = append(mmCreateEmbeddings.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateEmbeddings return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateEmbeddingsExpectation) Then(ea1 []mm_repository.EmbeddingModel, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateEmbeddingsResults{ea1, err}
	return e.mock
}

// Times sets number of times Repository.CreateEmbeddings should be invoked
func (mmCreateEmbeddings *mRepositoryMockCreateEmbeddings) Times(n uint64) *mRepositoryMockCreateEmbeddings {
	if n == 0 {
		mmCreateEmbeddings.mock.t.Fatalf("Times of RepositoryMock.CreateEmbeddings mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateEmbeddings.expectedInvocations, n)
	mmCreateEmbeddings.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateEmbeddings
}

func (mmCreateEmbeddings *mRepositoryMockCreateEmbeddings) invocationsDone() bool {
	if len(mmCreateEmbeddings.expectations) == 0 && mmCreateEmbeddings.defaultExpectation == nil && mmCreateEmbeddings.mock.funcCreateEmbeddings == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateEmbeddings.mock.afterCreateEmbeddingsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateEmbeddings.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateEmbeddings implements mm_repository.Repository
func (mmCreateEmbeddings *RepositoryMock) CreateEmbeddings(ctx context.Context, embeddings []mm_repository.EmbeddingModel, externalServiceCall func([]mm_repository.EmbeddingModel) error) (ea1 []mm_repository.EmbeddingModel, err error) {
	mm_atomic.AddUint64(&mmCreateEmbeddings.beforeCreateEmbeddingsCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateEmbeddings.afterCreateEmbeddingsCounter, 1)

	mmCreateEmbeddings.t.Helper()

	if mmCreateEmbeddings.inspectFuncCreateEmbeddings != nil {
		mmCreateEmbeddings.inspectFuncCreateEmbeddings(ctx, embeddings, externalServiceCall)
	}

	mm_params := RepositoryMockCreateEmbeddingsParams{ctx, embeddings, externalServiceCall}

	// Record call args
	mmCreateEmbeddings.CreateEmbeddingsMock.mutex.Lock()
	mmCreateEmbeddings.CreateEmbeddingsMock.callArgs = append(mmCreateEmbeddings.CreateEmbeddingsMock.callArgs, &mm_params)
	mmCreateEmbeddings.CreateEmbeddingsMock.mutex.Unlock()

	for _, e := range mmCreateEmbeddings.CreateEmbeddingsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1, e.results.err
		}
	}

	if mmCreateEmbeddings.CreateEmbeddingsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateEmbeddings.CreateEmbeddingsMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateEmbeddings.CreateEmbeddingsMock.defaultExpectation.params
		mm_want_ptrs := mmCreateEmbeddings.CreateEmbeddingsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateEmbeddingsParams{ctx, embeddings, externalServiceCall}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateEmbeddings.t.Errorf("RepositoryMock.CreateEmbeddings got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateEmbeddings.CreateEmbeddingsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.embeddings != nil && !minimock.Equal(*mm_want_ptrs.embeddings, mm_got.embeddings) {
				mmCreateEmbeddings.t.Errorf("RepositoryMock.CreateEmbeddings got unexpected parameter embeddings, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateEmbeddings.CreateEmbeddingsMock.defaultExpectation.expectationOrigins.originEmbeddings, *mm_want_ptrs.embeddings, mm_got.embeddings, minimock.Diff(*mm_want_ptrs.embeddings, mm_got.embeddings))
			}

			if mm_want_ptrs.externalServiceCall != nil && !minimock.Equal(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall) {
				mmCreateEmbeddings.t.Errorf("RepositoryMock.CreateEmbeddings got unexpected parameter externalServiceCall, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateEmbeddings.CreateEmbeddingsMock.defaultExpectation.expectationOrigins.originExternalServiceCall, *mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall, minimock.Diff(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateEmbeddings.t.Errorf("RepositoryMock.CreateEmbeddings got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateEmbeddings.CreateEmbeddingsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateEmbeddings.CreateEmbeddingsMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateEmbeddings.t.Fatal("No results are set for the RepositoryMock.CreateEmbeddings")
		}
		return (*mm_results).ea1, (*mm_results).err
	}
	if mmCreateEmbeddings.funcCreateEmbeddings != nil {
		return mmCreateEmbeddings.funcCreateEmbeddings(ctx, embeddings, externalServiceCall)
	}
	mmCreateEmbeddings.t.Fatalf("Unexpected call to RepositoryMock.CreateEmbeddings. %v %v %v", ctx, embeddings, externalServiceCall)
	return
}

// CreateEmbeddingsAfterCounter returns a count of finished RepositoryMock.CreateEmbeddings invocations
func (mmCreateEmbeddings *RepositoryMock) CreateEmbeddingsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateEmbeddings.afterCreateEmbeddingsCounter)
}

// CreateEmbeddingsBeforeCounter returns a count of RepositoryMock.CreateEmbeddings invocations
func (mmCreateEmbeddings *RepositoryMock) CreateEmbeddingsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateEmbeddings.beforeCreateEmbeddingsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateEmbeddings.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateEmbeddings *mRepositoryMockCreateEmbeddings) Calls() []*RepositoryMockCreateEmbeddingsParams {
	mmCreateEmbeddings.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateEmbeddingsParams, len(mmCreateEmbeddings.callArgs))
	copy(argCopy, mmCreateEmbeddings.callArgs)

	mmCreateEmbeddings.mutex.RUnlock()

	return argCopy
}

// MinimockCreateEmbeddingsDone returns true if the count of the CreateEmbeddings invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateEmbeddingsDone() bool {
	if m.CreateEmbeddingsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateEmbeddingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateEmbeddingsMock.invocationsDone()
}

// MinimockCreateEmbeddingsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateEmbeddingsInspect() {
	for _, e := range m.CreateEmbeddingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateEmbeddings at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateEmbeddingsCounter := mm_atomic.LoadUint64(&m.afterCreateEmbeddingsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateEmbeddingsMock.defaultExpectation != nil && afterCreateEmbeddingsCounter < 1 {
		if m.CreateEmbeddingsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateEmbeddings at\n%s", m.CreateEmbeddingsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateEmbeddings at\n%s with params: %#v", m.CreateEmbeddingsMock.defaultExpectation.expectationOrigins.origin, *m.CreateEmbeddingsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateEmbeddings != nil && afterCreateEmbeddingsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateEmbeddings at\n%s", m.funcCreateEmbeddingsOrigin)
	}

	if !m.CreateEmbeddingsMock.invocationsDone() && afterCreateEmbeddingsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateEmbeddings at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateEmbeddingsMock.expectedInvocations), m.CreateEmbeddingsMock.expectedInvocationsOrigin, afterCreateEmbeddingsCounter)
	}
}

type mRepositoryMockCreateKnowledgeBase struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateKnowledgeBaseExpectation
	expectations       []*RepositoryMockCreateKnowledgeBaseExpectation

	callArgs []*RepositoryMockCreateKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateKnowledgeBaseExpectation specifies expectation struct of the Repository.CreateKnowledgeBase
type RepositoryMockCreateKnowledgeBaseExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateKnowledgeBaseParams
	paramPtrs          *RepositoryMockCreateKnowledgeBaseParamPtrs
	expectationOrigins RepositoryMockCreateKnowledgeBaseExpectationOrigins
	results            *RepositoryMockCreateKnowledgeBaseResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateKnowledgeBaseParams contains parameters of the Repository.CreateKnowledgeBase
type RepositoryMockCreateKnowledgeBaseParams struct {
	ctx             context.Context
	kb              mm_repository.KnowledgeBaseModel
	externalService func(kbUID types.KBUIDType) error
}

// RepositoryMockCreateKnowledgeBaseParamPtrs contains pointers to parameters of the Repository.CreateKnowledgeBase
type RepositoryMockCreateKnowledgeBaseParamPtrs struct {
	ctx             *context.Context
	kb              *mm_repository.KnowledgeBaseModel
	externalService *func(kbUID types.KBUIDType) error
}

// RepositoryMockCreateKnowledgeBaseResults contains results of the Repository.CreateKnowledgeBase
type RepositoryMockCreateKnowledgeBaseResults struct {
	kp1 *mm_repository.KnowledgeBaseModel
	err error
}

// RepositoryMockCreateKnowledgeBaseOrigins contains origins of expectations of the Repository.CreateKnowledgeBase
type RepositoryMockCreateKnowledgeBaseExpectationOrigins struct {
	origin                string
	originCtx             string
	originKb              string
	originExternalService string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) Optional() *mRepositoryMockCreateKnowledgeBase {
	mmCreateKnowledgeBase.optional = true
	return mmCreateKnowledgeBase
}

// Expect sets up expected params for Repository.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) Expect(ctx context.Context, kb mm_repository.KnowledgeBaseModel, externalService func(kbUID types.KBUIDType) error) *mRepositoryMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmCreateKnowledgeBase.defaultExpectation.params = &RepositoryMockCreateKnowledgeBaseParams{ctx, kb, externalService}
	mmCreateKnowledgeBase.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmCreateKnowledgeBase.defaultExpectation.params) {
			mmCreateKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmCreateKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.params != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBase mock is already set by Expect")
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockCreateKnowledgeBaseParamPtrs{}
	}
	mmCreateKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateKnowledgeBase.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateKnowledgeBase
}

// ExpectKbParam2 sets up expected param kb for Repository.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) ExpectKbParam2(kb mm_repository.KnowledgeBaseModel) *mRepositoryMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.params != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBase mock is already set by Expect")
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockCreateKnowledgeBaseParamPtrs{}
	}
	mmCreateKnowledgeBase.defaultExpectation.paramPtrs.kb = &kb
	mmCreateKnowledgeBase.defaultExpectation.expectationOrigins.originKb = minimock.CallerInfo(1)

	return mmCreateKnowledgeBase
}

// ExpectExternalServiceParam3 sets up expected param externalService for Repository.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) ExpectExternalServiceParam3(externalService func(kbUID types.KBUIDType) error) *mRepositoryMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.params != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBase mock is already set by Expect")
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockCreateKnowledgeBaseParamPtrs{}
	}
	mmCreateKnowledgeBase.defaultExpectation.paramPtrs.externalService = &externalService
	mmCreateKnowledgeBase.defaultExpectation.expectationOrigins.originExternalService = minimock.CallerInfo(1)

	return mmCreateKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) Inspect(f func(ctx context.Context, kb mm_repository.KnowledgeBaseModel, externalService func(kbUID types.KBUIDType) error)) *mRepositoryMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.inspectFuncCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateKnowledgeBase")
	}

	mmCreateKnowledgeBase.mock.inspectFuncCreateKnowledgeBase = f

	return mmCreateKnowledgeBase
}

// Return sets up results that will be returned by Repository.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) Return(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &RepositoryMockCreateKnowledgeBaseExpectation{mock: mmCreateKnowledgeBase.mock}
	}
	mmCreateKnowledgeBase.defaultExpectation.results = &RepositoryMockCreateKnowledgeBaseResults{kp1, err}
	mmCreateKnowledgeBase.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateKnowledgeBase.mock
}

// Set uses given function f to mock the Repository.CreateKnowledgeBase method
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) Set(f func(ctx context.Context, kb mm_repository.KnowledgeBaseModel, externalService func(kbUID types.KBUIDType) error) (kp1 *mm_repository.KnowledgeBaseModel, err error)) *RepositoryMock {
	if mmCreateKnowledgeBase.defaultExpectation != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the Repository.CreateKnowledgeBase method")
	}

	if len(mmCreateKnowledgeBase.expectations) > 0 {
		mmCreateKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the Repository.CreateKnowledgeBase method")
	}

	mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase = f
	mmCreateKnowledgeBase.mock.funcCreateKnowledgeBaseOrigin = minimock.CallerInfo(1)
	return mmCreateKnowledgeBase.mock
}

// When sets expectation for the Repository.CreateKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) When(ctx context.Context, kb mm_repository.KnowledgeBaseModel, externalService func(kbUID types.KBUIDType) error) *RepositoryMockCreateKnowledgeBaseExpectation {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBase mock is already set by Set")
	}

	expectation := &RepositoryMockCreateKnowledgeBaseExpectation{
		mock:               mmCreateKnowledgeBase.mock,
		params:             &RepositoryMockCreateKnowledgeBaseParams{ctx, kb, externalService},
		expectationOrigins: RepositoryMockCreateKnowledgeBaseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateKnowledgeBase.expectations = append(mmCreateKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateKnowledgeBaseExpectation) Then(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateKnowledgeBaseResults{kp1, err}
	return e.mock
}

// Times sets number of times Repository.CreateKnowledgeBase should be invoked
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) Times(n uint64) *mRepositoryMockCreateKnowledgeBase {
	if n == 0 {
		mmCreateKnowledgeBase.mock.t.Fatalf("Times of RepositoryMock.CreateKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateKnowledgeBase.expectedInvocations, n)
	mmCreateKnowledgeBase.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateKnowledgeBase
}

func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) invocationsDone() bool {
	if len(mmCreateKnowledgeBase.expectations) == 0 && mmCreateKnowledgeBase.defaultExpectation == nil && mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateKnowledgeBase.mock.afterCreateKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateKnowledgeBase implements mm_repository.Repository
func (mmCreateKnowledgeBase *RepositoryMock) CreateKnowledgeBase(ctx context.Context, kb mm_repository.KnowledgeBaseModel, externalService func(kbUID types.KBUIDType) error) (kp1 *mm_repository.KnowledgeBaseModel, err error) {
	mm_atomic.AddUint64(&mmCreateKnowledgeBase.beforeCreateKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateKnowledgeBase.afterCreateKnowledgeBaseCounter, 1)

	mmCreateKnowledgeBase.t.Helper()

	if mmCreateKnowledgeBase.inspectFuncCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.inspectFuncCreateKnowledgeBase(ctx, kb, externalService)
	}

	mm_params := RepositoryMockCreateKnowledgeBaseParams{ctx, kb, externalService}

	// Record call args
	mmCreateKnowledgeBase.CreateKnowledgeBaseMock.mutex.Lock()
	mmCreateKnowledgeBase.CreateKnowledgeBaseMock.callArgs = append(mmCreateKnowledgeBase.CreateKnowledgeBaseMock.callArgs, &mm_params)
	mmCreateKnowledgeBase.CreateKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmCreateKnowledgeBase.CreateKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateKnowledgeBaseParams{ctx, kb, externalService}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateKnowledgeBase.t.Errorf("RepositoryMock.CreateKnowledgeBase got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kb != nil && !minimock.Equal(*mm_want_ptrs.kb, mm_got.kb) {
				mmCreateKnowledgeBase.t.Errorf("RepositoryMock.CreateKnowledgeBase got unexpected parameter kb, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.expectationOrigins.originKb, *mm_want_ptrs.kb, mm_got.kb, minimock.Diff(*mm_want_ptrs.kb, mm_got.kb))
			}

			if mm_want_ptrs.externalService != nil && !minimock.Equal(*mm_want_ptrs.externalService, mm_got.externalService) {
				mmCreateKnowledgeBase.t.Errorf("RepositoryMock.CreateKnowledgeBase got unexpected parameter externalService, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.expectationOrigins.originExternalService, *mm_want_ptrs.externalService, mm_got.externalService, minimock.Diff(*mm_want_ptrs.externalService, mm_got.externalService))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateKnowledgeBase.t.Errorf("RepositoryMock.CreateKnowledgeBase got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateKnowledgeBase.t.Fatal("No results are set for the RepositoryMock.CreateKnowledgeBase")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmCreateKnowledgeBase.funcCreateKnowledgeBase != nil {
		return mmCreateKnowledgeBase.funcCreateKnowledgeBase(ctx, kb, externalService)
	}
	mmCreateKnowledgeBase.t.Fatalf("Unexpected call to RepositoryMock.CreateKnowledgeBase. %v %v %v", ctx, kb, externalService)
	return
}

// CreateKnowledgeBaseAfterCounter returns a count of finished RepositoryMock.CreateKnowledgeBase invocations
func (mmCreateKnowledgeBase *RepositoryMock) CreateKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateKnowledgeBase.afterCreateKnowledgeBaseCounter)
}

// CreateKnowledgeBaseBeforeCounter returns a count of RepositoryMock.CreateKnowledgeBase invocations
func (mmCreateKnowledgeBase *RepositoryMock) CreateKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateKnowledgeBase.beforeCreateKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateKnowledgeBase *mRepositoryMockCreateKnowledgeBase) Calls() []*RepositoryMockCreateKnowledgeBaseParams {
	mmCreateKnowledgeBase.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateKnowledgeBaseParams, len(mmCreateKnowledgeBase.callArgs))
	copy(argCopy, mmCreateKnowledgeBase.callArgs)

	mmCreateKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockCreateKnowledgeBaseDone returns true if the count of the CreateKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateKnowledgeBaseDone() bool {
	if m.CreateKnowledgeBaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateKnowledgeBaseMock.invocationsDone()
}

// MinimockCreateKnowledgeBaseInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateKnowledgeBaseInspect() {
	for _, e := range m.CreateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateKnowledgeBase at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterCreateKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateKnowledgeBaseMock.defaultExpectation != nil && afterCreateKnowledgeBaseCounter < 1 {
		if m.CreateKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateKnowledgeBase at\n%s", m.CreateKnowledgeBaseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateKnowledgeBase at\n%s with params: %#v", m.CreateKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *m.CreateKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateKnowledgeBase != nil && afterCreateKnowledgeBaseCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateKnowledgeBase at\n%s", m.funcCreateKnowledgeBaseOrigin)
	}

	if !m.CreateKnowledgeBaseMock.invocationsDone() && afterCreateKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateKnowledgeBase at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateKnowledgeBaseMock.expectedInvocations), m.CreateKnowledgeBaseMock.expectedInvocationsOrigin, afterCreateKnowledgeBaseCounter)
	}
}

type mRepositoryMockCreateKnowledgeBaseFile struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateKnowledgeBaseFileExpectation
	expectations       []*RepositoryMockCreateKnowledgeBaseFileExpectation

	callArgs []*RepositoryMockCreateKnowledgeBaseFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateKnowledgeBaseFileExpectation specifies expectation struct of the Repository.CreateKnowledgeBaseFile
type RepositoryMockCreateKnowledgeBaseFileExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateKnowledgeBaseFileParams
	paramPtrs          *RepositoryMockCreateKnowledgeBaseFileParamPtrs
	expectationOrigins RepositoryMockCreateKnowledgeBaseFileExpectationOrigins
	results            *RepositoryMockCreateKnowledgeBaseFileResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateKnowledgeBaseFileParams contains parameters of the Repository.CreateKnowledgeBaseFile
type RepositoryMockCreateKnowledgeBaseFileParams struct {
	ctx                 context.Context
	kb                  mm_repository.KnowledgeBaseFileModel
	externalServiceCall func(fileUID string) error
}

// RepositoryMockCreateKnowledgeBaseFileParamPtrs contains pointers to parameters of the Repository.CreateKnowledgeBaseFile
type RepositoryMockCreateKnowledgeBaseFileParamPtrs struct {
	ctx                 *context.Context
	kb                  *mm_repository.KnowledgeBaseFileModel
	externalServiceCall *func(fileUID string) error
}

// RepositoryMockCreateKnowledgeBaseFileResults contains results of the Repository.CreateKnowledgeBaseFile
type RepositoryMockCreateKnowledgeBaseFileResults struct {
	kp1 *mm_repository.KnowledgeBaseFileModel
	err error
}

// RepositoryMockCreateKnowledgeBaseFileOrigins contains origins of expectations of the Repository.CreateKnowledgeBaseFile
type RepositoryMockCreateKnowledgeBaseFileExpectationOrigins struct {
	origin                    string
	originCtx                 string
	originKb                  string
	originExternalServiceCall string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateKnowledgeBaseFile *mRepositoryMockCreateKnowledgeBaseFile) Optional() *mRepositoryMockCreateKnowledgeBaseFile {
	mmCreateKnowledgeBaseFile.optional = true
	return mmCreateKnowledgeBaseFile
}

// Expect sets up expected params for Repository.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryMockCreateKnowledgeBaseFile) Expect(ctx context.Context, kb mm_repository.KnowledgeBaseFileModel, externalServiceCall func(fileUID string) error) *mRepositoryMockCreateKnowledgeBaseFile {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation = &RepositoryMockCreateKnowledgeBaseFileExpectation{}
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBaseFile mock is already set by ExpectParams functions")
	}

	mmCreateKnowledgeBaseFile.defaultExpectation.params = &RepositoryMockCreateKnowledgeBaseFileParams{ctx, kb, externalServiceCall}
	mmCreateKnowledgeBaseFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateKnowledgeBaseFile.expectations {
		if minimock.Equal(e.params, mmCreateKnowledgeBaseFile.defaultExpectation.params) {
			mmCreateKnowledgeBaseFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateKnowledgeBaseFile.defaultExpectation.params)
		}
	}

	return mmCreateKnowledgeBaseFile
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryMockCreateKnowledgeBaseFile) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateKnowledgeBaseFile {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation = &RepositoryMockCreateKnowledgeBaseFileExpectation{}
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryMockCreateKnowledgeBaseFileParamPtrs{}
	}
	mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateKnowledgeBaseFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateKnowledgeBaseFile
}

// ExpectKbParam2 sets up expected param kb for Repository.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryMockCreateKnowledgeBaseFile) ExpectKbParam2(kb mm_repository.KnowledgeBaseFileModel) *mRepositoryMockCreateKnowledgeBaseFile {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation = &RepositoryMockCreateKnowledgeBaseFileExpectation{}
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryMockCreateKnowledgeBaseFileParamPtrs{}
	}
	mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs.kb = &kb
	mmCreateKnowledgeBaseFile.defaultExpectation.expectationOrigins.originKb = minimock.CallerInfo(1)

	return mmCreateKnowledgeBaseFile
}

// ExpectExternalServiceCallParam3 sets up expected param externalServiceCall for Repository.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryMockCreateKnowledgeBaseFile) ExpectExternalServiceCallParam3(externalServiceCall func(fileUID string) error) *mRepositoryMockCreateKnowledgeBaseFile {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation = &RepositoryMockCreateKnowledgeBaseFileExpectation{}
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryMockCreateKnowledgeBaseFileParamPtrs{}
	}
	mmCreateKnowledgeBaseFile.defaultExpectation.paramPtrs.externalServiceCall = &externalServiceCall
	mmCreateKnowledgeBaseFile.defaultExpectation.expectationOrigins.originExternalServiceCall = minimock.CallerInfo(1)

	return mmCreateKnowledgeBaseFile
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryMockCreateKnowledgeBaseFile) Inspect(f func(ctx context.Context, kb mm_repository.KnowledgeBaseFileModel, externalServiceCall func(fileUID string) error)) *mRepositoryMockCreateKnowledgeBaseFile {
	if mmCreateKnowledgeBaseFile.mock.inspectFuncCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateKnowledgeBaseFile")
	}

	mmCreateKnowledgeBaseFile.mock.inspectFuncCreateKnowledgeBaseFile = f

	return mmCreateKnowledgeBaseFile
}

// Return sets up results that will be returned by Repository.CreateKnowledgeBaseFile
func (mmCreateKnowledgeBaseFile *mRepositoryMockCreateKnowledgeBaseFile) Return(kp1 *mm_repository.KnowledgeBaseFileModel, err error) *RepositoryMock {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	if mmCreateKnowledgeBaseFile.defaultExpectation == nil {
		mmCreateKnowledgeBaseFile.defaultExpectation = &RepositoryMockCreateKnowledgeBaseFileExpectation{mock: mmCreateKnowledgeBaseFile.mock}
	}
	mmCreateKnowledgeBaseFile.defaultExpectation.results = &RepositoryMockCreateKnowledgeBaseFileResults{kp1, err}
	mmCreateKnowledgeBaseFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateKnowledgeBaseFile.mock
}

// Set uses given function f to mock the Repository.CreateKnowledgeBaseFile method
func (mmCreateKnowledgeBaseFile *mRepositoryMockCreateKnowledgeBaseFile) Set(f func(ctx context.Context, kb mm_repository.KnowledgeBaseFileModel, externalServiceCall func(fileUID string) error) (kp1 *mm_repository.KnowledgeBaseFileModel, err error)) *RepositoryMock {
	if mmCreateKnowledgeBaseFile.defaultExpectation != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("Default expectation is already set for the Repository.CreateKnowledgeBaseFile method")
	}

	if len(mmCreateKnowledgeBaseFile.expectations) > 0 {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("Some expectations are already set for the Repository.CreateKnowledgeBaseFile method")
	}

	mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile = f
	mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFileOrigin = minimock.CallerInfo(1)
	return mmCreateKnowledgeBaseFile.mock
}

// When sets expectation for the Repository.CreateKnowledgeBaseFile which will trigger the result defined by the following
// Then helper
func (mmCreateKnowledgeBaseFile *mRepositoryMockCreateKnowledgeBaseFile) When(ctx context.Context, kb mm_repository.KnowledgeBaseFileModel, externalServiceCall func(fileUID string) error) *RepositoryMockCreateKnowledgeBaseFileExpectation {
	if mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.CreateKnowledgeBaseFile mock is already set by Set")
	}

	expectation := &RepositoryMockCreateKnowledgeBaseFileExpectation{
		mock:               mmCreateKnowledgeBaseFile.mock,
		params:             &RepositoryMockCreateKnowledgeBaseFileParams{ctx, kb, externalServiceCall},
		expectationOrigins: RepositoryMockCreateKnowledgeBaseFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateKnowledgeBaseFile.expectations = append(mmCreateKnowledgeBaseFile.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateKnowledgeBaseFile return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateKnowledgeBaseFileExpectation) Then(kp1 *mm_repository.KnowledgeBaseFileModel, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateKnowledgeBaseFileResults{kp1, err}
	return e.mock
}

// Times sets number of times Repository.CreateKnowledgeBaseFile should be invoked
func (mmCreateKnowledgeBaseFile *mRepositoryMockCreateKnowledgeBaseFile) Times(n uint64) *mRepositoryMockCreateKnowledgeBaseFile {
	if n == 0 {
		mmCreateKnowledgeBaseFile.mock.t.Fatalf("Times of RepositoryMock.CreateKnowledgeBaseFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateKnowledgeBaseFile.expectedInvocations, n)
	mmCreateKnowledgeBaseFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateKnowledgeBaseFile
}

func (mmCreateKnowledgeBaseFile *mRepositoryMockCreateKnowledgeBaseFile) invocationsDone() bool {
	if len(mmCreateKnowledgeBaseFile.expectations) == 0 && mmCreateKnowledgeBaseFile.defaultExpectation == nil && mmCreateKnowledgeBaseFile.mock.funcCreateKnowledgeBaseFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateKnowledgeBaseFile.mock.afterCreateKnowledgeBaseFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateKnowledgeBaseFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateKnowledgeBaseFile implements mm_repository.Repository
func (mmCreateKnowledgeBaseFile *RepositoryMock) CreateKnowledgeBaseFile(ctx context.Context, kb mm_repository.KnowledgeBaseFileModel, externalServiceCall func(fileUID string) error) (kp1 *mm_repository.KnowledgeBaseFileModel, err error) {
	mm_atomic.AddUint64(&mmCreateKnowledgeBaseFile.beforeCreateKnowledgeBaseFileCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateKnowledgeBaseFile.afterCreateKnowledgeBaseFileCounter, 1)

	mmCreateKnowledgeBaseFile.t.Helper()

	if mmCreateKnowledgeBaseFile.inspectFuncCreateKnowledgeBaseFile != nil {
		mmCreateKnowledgeBaseFile.inspectFuncCreateKnowledgeBaseFile(ctx, kb, externalServiceCall)
	}

	mm_params := RepositoryMockCreateKnowledgeBaseFileParams{ctx, kb, externalServiceCall}

	// Record call args
	mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.mutex.Lock()
	mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.callArgs = append(mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.callArgs, &mm_params)
	mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.mutex.Unlock()

	for _, e := range mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation.params
		mm_want_ptrs := mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateKnowledgeBaseFileParams{ctx, kb, externalServiceCall}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateKnowledgeBaseFile.t.Errorf("RepositoryMock.CreateKnowledgeBaseFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kb != nil && !minimock.Equal(*mm_want_ptrs.kb, mm_got.kb) {
				mmCreateKnowledgeBaseFile.t.Errorf("RepositoryMock.CreateKnowledgeBaseFile got unexpected parameter kb, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation.expectationOrigins.originKb, *mm_want_ptrs.kb, mm_got.kb, minimock.Diff(*mm_want_ptrs.kb, mm_got.kb))
			}

			if mm_want_ptrs.externalServiceCall != nil && !minimock.Equal(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall) {
				mmCreateKnowledgeBaseFile.t.Errorf("RepositoryMock.CreateKnowledgeBaseFile got unexpected parameter externalServiceCall, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation.expectationOrigins.originExternalServiceCall, *mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall, minimock.Diff(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateKnowledgeBaseFile.t.Errorf("RepositoryMock.CreateKnowledgeBaseFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateKnowledgeBaseFile.CreateKnowledgeBaseFileMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateKnowledgeBaseFile.t.Fatal("No results are set for the RepositoryMock.CreateKnowledgeBaseFile")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmCreateKnowledgeBaseFile.funcCreateKnowledgeBaseFile != nil {
		return mmCreateKnowledgeBaseFile.funcCreateKnowledgeBaseFile(ctx, kb, externalServiceCall)
	}
	mmCreateKnowledgeBaseFile.t.Fatalf("Unexpected call to RepositoryMock.CreateKnowledgeBaseFile. %v %v %v", ctx, kb, externalServiceCall)
	return
}

// CreateKnowledgeBaseFileAfterCounter returns a count of finished RepositoryMock.CreateKnowledgeBaseFile invocations
func (mmCreateKnowledgeBaseFile *RepositoryMock) CreateKnowledgeBaseFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateKnowledgeBaseFile.afterCreateKnowledgeBaseFileCounter)
}

// CreateKnowledgeBaseFileBeforeCounter returns a count of RepositoryMock.CreateKnowledgeBaseFile invocations
func (mmCreateKnowledgeBaseFile *RepositoryMock) CreateKnowledgeBaseFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateKnowledgeBaseFile.beforeCreateKnowledgeBaseFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateKnowledgeBaseFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateKnowledgeBaseFile *mRepositoryMockCreateKnowledgeBaseFile) Calls() []*RepositoryMockCreateKnowledgeBaseFileParams {
	mmCreateKnowledgeBaseFile.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateKnowledgeBaseFileParams, len(mmCreateKnowledgeBaseFile.callArgs))
	copy(argCopy, mmCreateKnowledgeBaseFile.callArgs)

	mmCreateKnowledgeBaseFile.mutex.RUnlock()

	return argCopy
}

// MinimockCreateKnowledgeBaseFileDone returns true if the count of the CreateKnowledgeBaseFile invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateKnowledgeBaseFileDone() bool {
	if m.CreateKnowledgeBaseFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateKnowledgeBaseFileMock.invocationsDone()
}

// MinimockCreateKnowledgeBaseFileInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateKnowledgeBaseFileInspect() {
	for _, e := range m.CreateKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateKnowledgeBaseFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateKnowledgeBaseFileCounter := mm_atomic.LoadUint64(&m.afterCreateKnowledgeBaseFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateKnowledgeBaseFileMock.defaultExpectation != nil && afterCreateKnowledgeBaseFileCounter < 1 {
		if m.CreateKnowledgeBaseFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateKnowledgeBaseFile at\n%s", m.CreateKnowledgeBaseFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateKnowledgeBaseFile at\n%s with params: %#v", m.CreateKnowledgeBaseFileMock.defaultExpectation.expectationOrigins.origin, *m.CreateKnowledgeBaseFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateKnowledgeBaseFile != nil && afterCreateKnowledgeBaseFileCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateKnowledgeBaseFile at\n%s", m.funcCreateKnowledgeBaseFileOrigin)
	}

	if !m.CreateKnowledgeBaseFileMock.invocationsDone() && afterCreateKnowledgeBaseFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateKnowledgeBaseFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateKnowledgeBaseFileMock.expectedInvocations), m.CreateKnowledgeBaseFileMock.expectedInvocationsOrigin, afterCreateKnowledgeBaseFileCounter)
	}
}

type mRepositoryMockCreateObject struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateObjectExpectation
	expectations       []*RepositoryMockCreateObjectExpectation

	callArgs []*RepositoryMockCreateObjectParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateObjectExpectation specifies expectation struct of the Repository.CreateObject
type RepositoryMockCreateObjectExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateObjectParams
	paramPtrs          *RepositoryMockCreateObjectParamPtrs
	expectationOrigins RepositoryMockCreateObjectExpectationOrigins
	results            *RepositoryMockCreateObjectResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateObjectParams contains parameters of the Repository.CreateObject
type RepositoryMockCreateObjectParams struct {
	ctx context.Context
	obj mm_repository.ObjectModel
}

// RepositoryMockCreateObjectParamPtrs contains pointers to parameters of the Repository.CreateObject
type RepositoryMockCreateObjectParamPtrs struct {
	ctx *context.Context
	obj *mm_repository.ObjectModel
}

// RepositoryMockCreateObjectResults contains results of the Repository.CreateObject
type RepositoryMockCreateObjectResults struct {
	op1 *mm_repository.ObjectModel
	err error
}

// RepositoryMockCreateObjectOrigins contains origins of expectations of the Repository.CreateObject
type RepositoryMockCreateObjectExpectationOrigins struct {
	origin    string
	originCtx string
	originObj string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateObject *mRepositoryMockCreateObject) Optional() *mRepositoryMockCreateObject {
	mmCreateObject.optional = true
	return mmCreateObject
}

// Expect sets up expected params for Repository.CreateObject
func (mmCreateObject *mRepositoryMockCreateObject) Expect(ctx context.Context, obj mm_repository.ObjectModel) *mRepositoryMockCreateObject {
	if mmCreateObject.mock.funcCreateObject != nil {
		mmCreateObject.mock.t.Fatalf("RepositoryMock.CreateObject mock is already set by Set")
	}

	if mmCreateObject.defaultExpectation == nil {
		mmCreateObject.defaultExpectation = &RepositoryMockCreateObjectExpectation{}
	}

	if mmCreateObject.defaultExpectation.paramPtrs != nil {
		mmCreateObject.mock.t.Fatalf("RepositoryMock.CreateObject mock is already set by ExpectParams functions")
	}

	mmCreateObject.defaultExpectation.params = &RepositoryMockCreateObjectParams{ctx, obj}
	mmCreateObject.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateObject.expectations {
		if minimock.Equal(e.params, mmCreateObject.defaultExpectation.params) {
			mmCreateObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateObject.defaultExpectation.params)
		}
	}

	return mmCreateObject
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateObject
func (mmCreateObject *mRepositoryMockCreateObject) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateObject {
	if mmCreateObject.mock.funcCreateObject != nil {
		mmCreateObject.mock.t.Fatalf("RepositoryMock.CreateObject mock is already set by Set")
	}

	if mmCreateObject.defaultExpectation == nil {
		mmCreateObject.defaultExpectation = &RepositoryMockCreateObjectExpectation{}
	}

	if mmCreateObject.defaultExpectation.params != nil {
		mmCreateObject.mock.t.Fatalf("RepositoryMock.CreateObject mock is already set by Expect")
	}

	if mmCreateObject.defaultExpectation.paramPtrs == nil {
		mmCreateObject.defaultExpectation.paramPtrs = &RepositoryMockCreateObjectParamPtrs{}
	}
	mmCreateObject.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateObject.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateObject
}

// ExpectObjParam2 sets up expected param obj for Repository.CreateObject
func (mmCreateObject *mRepositoryMockCreateObject) ExpectObjParam2(obj mm_repository.ObjectModel) *mRepositoryMockCreateObject {
	if mmCreateObject.mock.funcCreateObject != nil {
		mmCreateObject.mock.t.Fatalf("RepositoryMock.CreateObject mock is already set by Set")
	}

	if mmCreateObject.defaultExpectation == nil {
		mmCreateObject.defaultExpectation = &RepositoryMockCreateObjectExpectation{}
	}

	if mmCreateObject.defaultExpectation.params != nil {
		mmCreateObject.mock.t.Fatalf("RepositoryMock.CreateObject mock is already set by Expect")
	}

	if mmCreateObject.defaultExpectation.paramPtrs == nil {
		mmCreateObject.defaultExpectation.paramPtrs = &RepositoryMockCreateObjectParamPtrs{}
	}
	mmCreateObject.defaultExpectation.paramPtrs.obj = &obj
	mmCreateObject.defaultExpectation.expectationOrigins.originObj = minimock.CallerInfo(1)

	return mmCreateObject
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateObject
func (mmCreateObject *mRepositoryMockCreateObject) Inspect(f func(ctx context.Context, obj mm_repository.ObjectModel)) *mRepositoryMockCreateObject {
	if mmCreateObject.mock.inspectFuncCreateObject != nil {
		mmCreateObject.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateObject")
	}

	mmCreateObject.mock.inspectFuncCreateObject = f

	return mmCreateObject
}

// Return sets up results that will be returned by Repository.CreateObject
func (mmCreateObject *mRepositoryMockCreateObject) Return(op1 *mm_repository.ObjectModel, err error) *RepositoryMock {
	if mmCreateObject.mock.funcCreateObject != nil {
		mmCreateObject.mock.t.Fatalf("RepositoryMock.CreateObject mock is already set by Set")
	}

	if mmCreateObject.defaultExpectation == nil {
		mmCreateObject.defaultExpectation = &RepositoryMockCreateObjectExpectation{mock: mmCreateObject.mock}
	}
	mmCreateObject.defaultExpectation.results = &RepositoryMockCreateObjectResults{op1, err}
	mmCreateObject.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateObject.mock
}

// Set uses given function f to mock the Repository.CreateObject method
func (mmCreateObject *mRepositoryMockCreateObject) Set(f func(ctx context.Context, obj mm_repository.ObjectModel) (op1 *mm_repository.ObjectModel, err error)) *RepositoryMock {
	if mmCreateObject.defaultExpectation != nil {
		mmCreateObject.mock.t.Fatalf("Default expectation is already set for the Repository.CreateObject method")
	}

	if len(mmCreateObject.expectations) > 0 {
		mmCreateObject.mock.t.Fatalf("Some expectations are already set for the Repository.CreateObject method")
	}

	mmCreateObject.mock.funcCreateObject = f
	mmCreateObject.mock.funcCreateObjectOrigin = minimock.CallerInfo(1)
	return mmCreateObject.mock
}

// When sets expectation for the Repository.CreateObject which will trigger the result defined by the following
// Then helper
func (mmCreateObject *mRepositoryMockCreateObject) When(ctx context.Context, obj mm_repository.ObjectModel) *RepositoryMockCreateObjectExpectation {
	if mmCreateObject.mock.funcCreateObject != nil {
		mmCreateObject.mock.t.Fatalf("RepositoryMock.CreateObject mock is already set by Set")
	}

	expectation := &RepositoryMockCreateObjectExpectation{
		mock:               mmCreateObject.mock,
		params:             &RepositoryMockCreateObjectParams{ctx, obj},
		expectationOrigins: RepositoryMockCreateObjectExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateObject.expectations = append(mmCreateObject.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateObject return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateObjectExpectation) Then(op1 *mm_repository.ObjectModel, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateObjectResults{op1, err}
	return e.mock
}

// Times sets number of times Repository.CreateObject should be invoked
func (mmCreateObject *mRepositoryMockCreateObject) Times(n uint64) *mRepositoryMockCreateObject {
	if n == 0 {
		mmCreateObject.mock.t.Fatalf("Times of RepositoryMock.CreateObject mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateObject.expectedInvocations, n)
	mmCreateObject.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateObject
}

func (mmCreateObject *mRepositoryMockCreateObject) invocationsDone() bool {
	if len(mmCreateObject.expectations) == 0 && mmCreateObject.defaultExpectation == nil && mmCreateObject.mock.funcCreateObject == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateObject.mock.afterCreateObjectCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateObject.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateObject implements mm_repository.Repository
func (mmCreateObject *RepositoryMock) CreateObject(ctx context.Context, obj mm_repository.ObjectModel) (op1 *mm_repository.ObjectModel, err error) {
	mm_atomic.AddUint64(&mmCreateObject.beforeCreateObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateObject.afterCreateObjectCounter, 1)

	mmCreateObject.t.Helper()

	if mmCreateObject.inspectFuncCreateObject != nil {
		mmCreateObject.inspectFuncCreateObject(ctx, obj)
	}

	mm_params := RepositoryMockCreateObjectParams{ctx, obj}

	// Record call args
	mmCreateObject.CreateObjectMock.mutex.Lock()
	mmCreateObject.CreateObjectMock.callArgs = append(mmCreateObject.CreateObjectMock.callArgs, &mm_params)
	mmCreateObject.CreateObjectMock.mutex.Unlock()

	for _, e := range mmCreateObject.CreateObjectMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmCreateObject.CreateObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateObject.CreateObjectMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateObject.CreateObjectMock.defaultExpectation.params
		mm_want_ptrs := mmCreateObject.CreateObjectMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateObjectParams{ctx, obj}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateObject.t.Errorf("RepositoryMock.CreateObject got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateObject.CreateObjectMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.obj != nil && !minimock.Equal(*mm_want_ptrs.obj, mm_got.obj) {
				mmCreateObject.t.Errorf("RepositoryMock.CreateObject got unexpected parameter obj, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateObject.CreateObjectMock.defaultExpectation.expectationOrigins.originObj, *mm_want_ptrs.obj, mm_got.obj, minimock.Diff(*mm_want_ptrs.obj, mm_got.obj))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateObject.t.Errorf("RepositoryMock.CreateObject got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateObject.CreateObjectMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateObject.CreateObjectMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateObject.t.Fatal("No results are set for the RepositoryMock.CreateObject")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmCreateObject.funcCreateObject != nil {
		return mmCreateObject.funcCreateObject(ctx, obj)
	}
	mmCreateObject.t.Fatalf("Unexpected call to RepositoryMock.CreateObject. %v %v", ctx, obj)
	return
}

// CreateObjectAfterCounter returns a count of finished RepositoryMock.CreateObject invocations
func (mmCreateObject *RepositoryMock) CreateObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateObject.afterCreateObjectCounter)
}

// CreateObjectBeforeCounter returns a count of RepositoryMock.CreateObject invocations
func (mmCreateObject *RepositoryMock) CreateObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateObject.beforeCreateObjectCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateObject *mRepositoryMockCreateObject) Calls() []*RepositoryMockCreateObjectParams {
	mmCreateObject.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateObjectParams, len(mmCreateObject.callArgs))
	copy(argCopy, mmCreateObject.callArgs)

	mmCreateObject.mutex.RUnlock()

	return argCopy
}

// MinimockCreateObjectDone returns true if the count of the CreateObject invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateObjectDone() bool {
	if m.CreateObjectMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateObjectMock.invocationsDone()
}

// MinimockCreateObjectInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateObjectInspect() {
	for _, e := range m.CreateObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateObject at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateObjectCounter := mm_atomic.LoadUint64(&m.afterCreateObjectCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateObjectMock.defaultExpectation != nil && afterCreateObjectCounter < 1 {
		if m.CreateObjectMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateObject at\n%s", m.CreateObjectMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateObject at\n%s with params: %#v", m.CreateObjectMock.defaultExpectation.expectationOrigins.origin, *m.CreateObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateObject != nil && afterCreateObjectCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateObject at\n%s", m.funcCreateObjectOrigin)
	}

	if !m.CreateObjectMock.invocationsDone() && afterCreateObjectCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateObject at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateObjectMock.expectedInvocations), m.CreateObjectMock.expectedInvocationsOrigin, afterCreateObjectCounter)
	}
}

type mRepositoryMockCreateTextChunks struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateTextChunksExpectation
	expectations       []*RepositoryMockCreateTextChunksExpectation

	callArgs []*RepositoryMockCreateTextChunksParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateTextChunksExpectation specifies expectation struct of the Repository.CreateTextChunks
type RepositoryMockCreateTextChunksExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateTextChunksParams
	paramPtrs          *RepositoryMockCreateTextChunksParamPtrs
	expectationOrigins RepositoryMockCreateTextChunksExpectationOrigins
	results            *RepositoryMockCreateTextChunksResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateTextChunksParams contains parameters of the Repository.CreateTextChunks
type RepositoryMockCreateTextChunksParams struct {
	ctx        context.Context
	textChunks []*mm_repository.TextChunkModel
}

// RepositoryMockCreateTextChunksParamPtrs contains pointers to parameters of the Repository.CreateTextChunks
type RepositoryMockCreateTextChunksParamPtrs struct {
	ctx        *context.Context
	textChunks *[]*mm_repository.TextChunkModel
}

// RepositoryMockCreateTextChunksResults contains results of the Repository.CreateTextChunks
type RepositoryMockCreateTextChunksResults struct {
	err error
}

// RepositoryMockCreateTextChunksOrigins contains origins of expectations of the Repository.CreateTextChunks
type RepositoryMockCreateTextChunksExpectationOrigins struct {
	origin           string
	originCtx        string
	originTextChunks string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateTextChunks *mRepositoryMockCreateTextChunks) Optional() *mRepositoryMockCreateTextChunks {
	mmCreateTextChunks.optional = true
	return mmCreateTextChunks
}

// Expect sets up expected params for Repository.CreateTextChunks
func (mmCreateTextChunks *mRepositoryMockCreateTextChunks) Expect(ctx context.Context, textChunks []*mm_repository.TextChunkModel) *mRepositoryMockCreateTextChunks {
	if mmCreateTextChunks.mock.funcCreateTextChunks != nil {
		mmCreateTextChunks.mock.t.Fatalf("RepositoryMock.CreateTextChunks mock is already set by Set")
	}

	if mmCreateTextChunks.defaultExpectation == nil {
		mmCreateTextChunks.defaultExpectation = &RepositoryMockCreateTextChunksExpectation{}
	}

	if mmCreateTextChunks.defaultExpectation.paramPtrs != nil {
		mmCreateTextChunks.mock.t.Fatalf("RepositoryMock.CreateTextChunks mock is already set by ExpectParams functions")
	}

	mmCreateTextChunks.defaultExpectation.params = &RepositoryMockCreateTextChunksParams{ctx, textChunks}
	mmCreateTextChunks.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateTextChunks.expectations {
		if minimock.Equal(e.params, mmCreateTextChunks.defaultExpectation.params) {
			mmCreateTextChunks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateTextChunks.defaultExpectation.params)
		}
	}

	return mmCreateTextChunks
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateTextChunks
func (mmCreateTextChunks *mRepositoryMockCreateTextChunks) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateTextChunks {
	if mmCreateTextChunks.mock.funcCreateTextChunks != nil {
		mmCreateTextChunks.mock.t.Fatalf("RepositoryMock.CreateTextChunks mock is already set by Set")
	}

	if mmCreateTextChunks.defaultExpectation == nil {
		mmCreateTextChunks.defaultExpectation = &RepositoryMockCreateTextChunksExpectation{}
	}

	if mmCreateTextChunks.defaultExpectation.params != nil {
		mmCreateTextChunks.mock.t.Fatalf("RepositoryMock.CreateTextChunks mock is already set by Expect")
	}

	if mmCreateTextChunks.defaultExpectation.paramPtrs == nil {
		mmCreateTextChunks.defaultExpectation.paramPtrs = &RepositoryMockCreateTextChunksParamPtrs{}
	}
	mmCreateTextChunks.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateTextChunks.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateTextChunks
}

// ExpectTextChunksParam2 sets up expected param textChunks for Repository.CreateTextChunks
func (mmCreateTextChunks *mRepositoryMockCreateTextChunks) ExpectTextChunksParam2(textChunks []*mm_repository.TextChunkModel) *mRepositoryMockCreateTextChunks {
	if mmCreateTextChunks.mock.funcCreateTextChunks != nil {
		mmCreateTextChunks.mock.t.Fatalf("RepositoryMock.CreateTextChunks mock is already set by Set")
	}

	if mmCreateTextChunks.defaultExpectation == nil {
		mmCreateTextChunks.defaultExpectation = &RepositoryMockCreateTextChunksExpectation{}
	}

	if mmCreateTextChunks.defaultExpectation.params != nil {
		mmCreateTextChunks.mock.t.Fatalf("RepositoryMock.CreateTextChunks mock is already set by Expect")
	}

	if mmCreateTextChunks.defaultExpectation.paramPtrs == nil {
		mmCreateTextChunks.defaultExpectation.paramPtrs = &RepositoryMockCreateTextChunksParamPtrs{}
	}
	mmCreateTextChunks.defaultExpectation.paramPtrs.textChunks = &textChunks
	mmCreateTextChunks.defaultExpectation.expectationOrigins.originTextChunks = minimock.CallerInfo(1)

	return mmCreateTextChunks
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateTextChunks
func (mmCreateTextChunks *mRepositoryMockCreateTextChunks) Inspect(f func(ctx context.Context, textChunks []*mm_repository.TextChunkModel)) *mRepositoryMockCreateTextChunks {
	if mmCreateTextChunks.mock.inspectFuncCreateTextChunks != nil {
		mmCreateTextChunks.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateTextChunks")
	}

	mmCreateTextChunks.mock.inspectFuncCreateTextChunks = f

	return mmCreateTextChunks
}

// Return sets up results that will be returned by Repository.CreateTextChunks
func (mmCreateTextChunks *mRepositoryMockCreateTextChunks) Return(err error) *RepositoryMock {
	if mmCreateTextChunks.mock.funcCreateTextChunks != nil {
		mmCreateTextChunks.mock.t.Fatalf("RepositoryMock.CreateTextChunks mock is already set by Set")
	}

	if mmCreateTextChunks.defaultExpectation == nil {
		mmCreateTextChunks.defaultExpectation = &RepositoryMockCreateTextChunksExpectation{mock: mmCreateTextChunks.mock}
	}
	mmCreateTextChunks.defaultExpectation.results = &RepositoryMockCreateTextChunksResults{err}
	mmCreateTextChunks.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateTextChunks.mock
}

// Set uses given function f to mock the Repository.CreateTextChunks method
func (mmCreateTextChunks *mRepositoryMockCreateTextChunks) Set(f func(ctx context.Context, textChunks []*mm_repository.TextChunkModel) (err error)) *RepositoryMock {
	if mmCreateTextChunks.defaultExpectation != nil {
		mmCreateTextChunks.mock.t.Fatalf("Default expectation is already set for the Repository.CreateTextChunks method")
	}

	if len(mmCreateTextChunks.expectations) > 0 {
		mmCreateTextChunks.mock.t.Fatalf("Some expectations are already set for the Repository.CreateTextChunks method")
	}

	mmCreateTextChunks.mock.funcCreateTextChunks = f
	mmCreateTextChunks.mock.funcCreateTextChunksOrigin = minimock.CallerInfo(1)
	return mmCreateTextChunks.mock
}

// When sets expectation for the Repository.CreateTextChunks which will trigger the result defined by the following
// Then helper
func (mmCreateTextChunks *mRepositoryMockCreateTextChunks) When(ctx context.Context, textChunks []*mm_repository.TextChunkModel) *RepositoryMockCreateTextChunksExpectation {
	if mmCreateTextChunks.mock.funcCreateTextChunks != nil {
		mmCreateTextChunks.mock.t.Fatalf("RepositoryMock.CreateTextChunks mock is already set by Set")
	}

	expectation := &RepositoryMockCreateTextChunksExpectation{
		mock:               mmCreateTextChunks.mock,
		params:             &RepositoryMockCreateTextChunksParams{ctx, textChunks},
		expectationOrigins: RepositoryMockCreateTextChunksExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateTextChunks.expectations = append(mmCreateTextChunks.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateTextChunks return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateTextChunksExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreateTextChunksResults{err}
	return e.mock
}

// Times sets number of times Repository.CreateTextChunks should be invoked
func (mmCreateTextChunks *mRepositoryMockCreateTextChunks) Times(n uint64) *mRepositoryMockCreateTextChunks {
	if n == 0 {
		mmCreateTextChunks.mock.t.Fatalf("Times of RepositoryMock.CreateTextChunks mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateTextChunks.expectedInvocations, n)
	mmCreateTextChunks.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateTextChunks
}

func (mmCreateTextChunks *mRepositoryMockCreateTextChunks) invocationsDone() bool {
	if len(mmCreateTextChunks.expectations) == 0 && mmCreateTextChunks.defaultExpectation == nil && mmCreateTextChunks.mock.funcCreateTextChunks == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateTextChunks.mock.afterCreateTextChunksCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateTextChunks.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateTextChunks implements mm_repository.Repository
func (mmCreateTextChunks *RepositoryMock) CreateTextChunks(ctx context.Context, textChunks []*mm_repository.TextChunkModel) (err error) {
	mm_atomic.AddUint64(&mmCreateTextChunks.beforeCreateTextChunksCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateTextChunks.afterCreateTextChunksCounter, 1)

	mmCreateTextChunks.t.Helper()

	if mmCreateTextChunks.inspectFuncCreateTextChunks != nil {
		mmCreateTextChunks.inspectFuncCreateTextChunks(ctx, textChunks)
	}

	mm_params := RepositoryMockCreateTextChunksParams{ctx, textChunks}

	// Record call args
	mmCreateTextChunks.CreateTextChunksMock.mutex.Lock()
	mmCreateTextChunks.CreateTextChunksMock.callArgs = append(mmCreateTextChunks.CreateTextChunksMock.callArgs, &mm_params)
	mmCreateTextChunks.CreateTextChunksMock.mutex.Unlock()

	for _, e := range mmCreateTextChunks.CreateTextChunksMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateTextChunks.CreateTextChunksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateTextChunks.CreateTextChunksMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateTextChunks.CreateTextChunksMock.defaultExpectation.params
		mm_want_ptrs := mmCreateTextChunks.CreateTextChunksMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateTextChunksParams{ctx, textChunks}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateTextChunks.t.Errorf("RepositoryMock.CreateTextChunks got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateTextChunks.CreateTextChunksMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.textChunks != nil && !minimock.Equal(*mm_want_ptrs.textChunks, mm_got.textChunks) {
				mmCreateTextChunks.t.Errorf("RepositoryMock.CreateTextChunks got unexpected parameter textChunks, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateTextChunks.CreateTextChunksMock.defaultExpectation.expectationOrigins.originTextChunks, *mm_want_ptrs.textChunks, mm_got.textChunks, minimock.Diff(*mm_want_ptrs.textChunks, mm_got.textChunks))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateTextChunks.t.Errorf("RepositoryMock.CreateTextChunks got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateTextChunks.CreateTextChunksMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateTextChunks.CreateTextChunksMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateTextChunks.t.Fatal("No results are set for the RepositoryMock.CreateTextChunks")
		}
		return (*mm_results).err
	}
	if mmCreateTextChunks.funcCreateTextChunks != nil {
		return mmCreateTextChunks.funcCreateTextChunks(ctx, textChunks)
	}
	mmCreateTextChunks.t.Fatalf("Unexpected call to RepositoryMock.CreateTextChunks. %v %v", ctx, textChunks)
	return
}

// CreateTextChunksAfterCounter returns a count of finished RepositoryMock.CreateTextChunks invocations
func (mmCreateTextChunks *RepositoryMock) CreateTextChunksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTextChunks.afterCreateTextChunksCounter)
}

// CreateTextChunksBeforeCounter returns a count of RepositoryMock.CreateTextChunks invocations
func (mmCreateTextChunks *RepositoryMock) CreateTextChunksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTextChunks.beforeCreateTextChunksCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateTextChunks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateTextChunks *mRepositoryMockCreateTextChunks) Calls() []*RepositoryMockCreateTextChunksParams {
	mmCreateTextChunks.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateTextChunksParams, len(mmCreateTextChunks.callArgs))
	copy(argCopy, mmCreateTextChunks.callArgs)

	mmCreateTextChunks.mutex.RUnlock()

	return argCopy
}

// MinimockCreateTextChunksDone returns true if the count of the CreateTextChunks invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateTextChunksDone() bool {
	if m.CreateTextChunksMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateTextChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateTextChunksMock.invocationsDone()
}

// MinimockCreateTextChunksInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateTextChunksInspect() {
	for _, e := range m.CreateTextChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateTextChunks at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateTextChunksCounter := mm_atomic.LoadUint64(&m.afterCreateTextChunksCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateTextChunksMock.defaultExpectation != nil && afterCreateTextChunksCounter < 1 {
		if m.CreateTextChunksMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateTextChunks at\n%s", m.CreateTextChunksMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateTextChunks at\n%s with params: %#v", m.CreateTextChunksMock.defaultExpectation.expectationOrigins.origin, *m.CreateTextChunksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateTextChunks != nil && afterCreateTextChunksCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateTextChunks at\n%s", m.funcCreateTextChunksOrigin)
	}

	if !m.CreateTextChunksMock.invocationsDone() && afterCreateTextChunksCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateTextChunks at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateTextChunksMock.expectedInvocations), m.CreateTextChunksMock.expectedInvocationsOrigin, afterCreateTextChunksCounter)
	}
}

type mRepositoryMockDeleteAllConvertedFilesInKb struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteAllConvertedFilesInKbExpectation
	expectations       []*RepositoryMockDeleteAllConvertedFilesInKbExpectation

	callArgs []*RepositoryMockDeleteAllConvertedFilesInKbParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteAllConvertedFilesInKbExpectation specifies expectation struct of the Repository.DeleteAllConvertedFilesInKb
type RepositoryMockDeleteAllConvertedFilesInKbExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteAllConvertedFilesInKbParams
	paramPtrs          *RepositoryMockDeleteAllConvertedFilesInKbParamPtrs
	expectationOrigins RepositoryMockDeleteAllConvertedFilesInKbExpectationOrigins
	results            *RepositoryMockDeleteAllConvertedFilesInKbResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteAllConvertedFilesInKbParams contains parameters of the Repository.DeleteAllConvertedFilesInKb
type RepositoryMockDeleteAllConvertedFilesInKbParams struct {
	ctx   context.Context
	kbUID types.KBUIDType
}

// RepositoryMockDeleteAllConvertedFilesInKbParamPtrs contains pointers to parameters of the Repository.DeleteAllConvertedFilesInKb
type RepositoryMockDeleteAllConvertedFilesInKbParamPtrs struct {
	ctx   *context.Context
	kbUID *types.KBUIDType
}

// RepositoryMockDeleteAllConvertedFilesInKbResults contains results of the Repository.DeleteAllConvertedFilesInKb
type RepositoryMockDeleteAllConvertedFilesInKbResults struct {
	err error
}

// RepositoryMockDeleteAllConvertedFilesInKbOrigins contains origins of expectations of the Repository.DeleteAllConvertedFilesInKb
type RepositoryMockDeleteAllConvertedFilesInKbExpectationOrigins struct {
	origin      string
	originCtx   string
	originKbUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteAllConvertedFilesInKb *mRepositoryMockDeleteAllConvertedFilesInKb) Optional() *mRepositoryMockDeleteAllConvertedFilesInKb {
	mmDeleteAllConvertedFilesInKb.optional = true
	return mmDeleteAllConvertedFilesInKb
}

// Expect sets up expected params for Repository.DeleteAllConvertedFilesInKb
func (mmDeleteAllConvertedFilesInKb *mRepositoryMockDeleteAllConvertedFilesInKb) Expect(ctx context.Context, kbUID types.KBUIDType) *mRepositoryMockDeleteAllConvertedFilesInKb {
	if mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKb != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryMock.DeleteAllConvertedFilesInKb mock is already set by Set")
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation == nil {
		mmDeleteAllConvertedFilesInKb.defaultExpectation = &RepositoryMockDeleteAllConvertedFilesInKbExpectation{}
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation.paramPtrs != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryMock.DeleteAllConvertedFilesInKb mock is already set by ExpectParams functions")
	}

	mmDeleteAllConvertedFilesInKb.defaultExpectation.params = &RepositoryMockDeleteAllConvertedFilesInKbParams{ctx, kbUID}
	mmDeleteAllConvertedFilesInKb.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteAllConvertedFilesInKb.expectations {
		if minimock.Equal(e.params, mmDeleteAllConvertedFilesInKb.defaultExpectation.params) {
			mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteAllConvertedFilesInKb.defaultExpectation.params)
		}
	}

	return mmDeleteAllConvertedFilesInKb
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteAllConvertedFilesInKb
func (mmDeleteAllConvertedFilesInKb *mRepositoryMockDeleteAllConvertedFilesInKb) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteAllConvertedFilesInKb {
	if mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKb != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryMock.DeleteAllConvertedFilesInKb mock is already set by Set")
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation == nil {
		mmDeleteAllConvertedFilesInKb.defaultExpectation = &RepositoryMockDeleteAllConvertedFilesInKbExpectation{}
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation.params != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryMock.DeleteAllConvertedFilesInKb mock is already set by Expect")
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation.paramPtrs == nil {
		mmDeleteAllConvertedFilesInKb.defaultExpectation.paramPtrs = &RepositoryMockDeleteAllConvertedFilesInKbParamPtrs{}
	}
	mmDeleteAllConvertedFilesInKb.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteAllConvertedFilesInKb.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteAllConvertedFilesInKb
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.DeleteAllConvertedFilesInKb
func (mmDeleteAllConvertedFilesInKb *mRepositoryMockDeleteAllConvertedFilesInKb) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockDeleteAllConvertedFilesInKb {
	if mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKb != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryMock.DeleteAllConvertedFilesInKb mock is already set by Set")
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation == nil {
		mmDeleteAllConvertedFilesInKb.defaultExpectation = &RepositoryMockDeleteAllConvertedFilesInKbExpectation{}
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation.params != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryMock.DeleteAllConvertedFilesInKb mock is already set by Expect")
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation.paramPtrs == nil {
		mmDeleteAllConvertedFilesInKb.defaultExpectation.paramPtrs = &RepositoryMockDeleteAllConvertedFilesInKbParamPtrs{}
	}
	mmDeleteAllConvertedFilesInKb.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmDeleteAllConvertedFilesInKb.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmDeleteAllConvertedFilesInKb
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteAllConvertedFilesInKb
func (mmDeleteAllConvertedFilesInKb *mRepositoryMockDeleteAllConvertedFilesInKb) Inspect(f func(ctx context.Context, kbUID types.KBUIDType)) *mRepositoryMockDeleteAllConvertedFilesInKb {
	if mmDeleteAllConvertedFilesInKb.mock.inspectFuncDeleteAllConvertedFilesInKb != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteAllConvertedFilesInKb")
	}

	mmDeleteAllConvertedFilesInKb.mock.inspectFuncDeleteAllConvertedFilesInKb = f

	return mmDeleteAllConvertedFilesInKb
}

// Return sets up results that will be returned by Repository.DeleteAllConvertedFilesInKb
func (mmDeleteAllConvertedFilesInKb *mRepositoryMockDeleteAllConvertedFilesInKb) Return(err error) *RepositoryMock {
	if mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKb != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryMock.DeleteAllConvertedFilesInKb mock is already set by Set")
	}

	if mmDeleteAllConvertedFilesInKb.defaultExpectation == nil {
		mmDeleteAllConvertedFilesInKb.defaultExpectation = &RepositoryMockDeleteAllConvertedFilesInKbExpectation{mock: mmDeleteAllConvertedFilesInKb.mock}
	}
	mmDeleteAllConvertedFilesInKb.defaultExpectation.results = &RepositoryMockDeleteAllConvertedFilesInKbResults{err}
	mmDeleteAllConvertedFilesInKb.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteAllConvertedFilesInKb.mock
}

// Set uses given function f to mock the Repository.DeleteAllConvertedFilesInKb method
func (mmDeleteAllConvertedFilesInKb *mRepositoryMockDeleteAllConvertedFilesInKb) Set(f func(ctx context.Context, kbUID types.KBUIDType) (err error)) *RepositoryMock {
	if mmDeleteAllConvertedFilesInKb.defaultExpectation != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteAllConvertedFilesInKb method")
	}

	if len(mmDeleteAllConvertedFilesInKb.expectations) > 0 {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteAllConvertedFilesInKb method")
	}

	mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKb = f
	mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKbOrigin = minimock.CallerInfo(1)
	return mmDeleteAllConvertedFilesInKb.mock
}

// When sets expectation for the Repository.DeleteAllConvertedFilesInKb which will trigger the result defined by the following
// Then helper
func (mmDeleteAllConvertedFilesInKb *mRepositoryMockDeleteAllConvertedFilesInKb) When(ctx context.Context, kbUID types.KBUIDType) *RepositoryMockDeleteAllConvertedFilesInKbExpectation {
	if mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKb != nil {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("RepositoryMock.DeleteAllConvertedFilesInKb mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteAllConvertedFilesInKbExpectation{
		mock:               mmDeleteAllConvertedFilesInKb.mock,
		params:             &RepositoryMockDeleteAllConvertedFilesInKbParams{ctx, kbUID},
		expectationOrigins: RepositoryMockDeleteAllConvertedFilesInKbExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteAllConvertedFilesInKb.expectations = append(mmDeleteAllConvertedFilesInKb.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteAllConvertedFilesInKb return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteAllConvertedFilesInKbExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteAllConvertedFilesInKbResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteAllConvertedFilesInKb should be invoked
func (mmDeleteAllConvertedFilesInKb *mRepositoryMockDeleteAllConvertedFilesInKb) Times(n uint64) *mRepositoryMockDeleteAllConvertedFilesInKb {
	if n == 0 {
		mmDeleteAllConvertedFilesInKb.mock.t.Fatalf("Times of RepositoryMock.DeleteAllConvertedFilesInKb mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteAllConvertedFilesInKb.expectedInvocations, n)
	mmDeleteAllConvertedFilesInKb.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteAllConvertedFilesInKb
}

func (mmDeleteAllConvertedFilesInKb *mRepositoryMockDeleteAllConvertedFilesInKb) invocationsDone() bool {
	if len(mmDeleteAllConvertedFilesInKb.expectations) == 0 && mmDeleteAllConvertedFilesInKb.defaultExpectation == nil && mmDeleteAllConvertedFilesInKb.mock.funcDeleteAllConvertedFilesInKb == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteAllConvertedFilesInKb.mock.afterDeleteAllConvertedFilesInKbCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteAllConvertedFilesInKb.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteAllConvertedFilesInKb implements mm_repository.Repository
func (mmDeleteAllConvertedFilesInKb *RepositoryMock) DeleteAllConvertedFilesInKb(ctx context.Context, kbUID types.KBUIDType) (err error) {
	mm_atomic.AddUint64(&mmDeleteAllConvertedFilesInKb.beforeDeleteAllConvertedFilesInKbCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteAllConvertedFilesInKb.afterDeleteAllConvertedFilesInKbCounter, 1)

	mmDeleteAllConvertedFilesInKb.t.Helper()

	if mmDeleteAllConvertedFilesInKb.inspectFuncDeleteAllConvertedFilesInKb != nil {
		mmDeleteAllConvertedFilesInKb.inspectFuncDeleteAllConvertedFilesInKb(ctx, kbUID)
	}

	mm_params := RepositoryMockDeleteAllConvertedFilesInKbParams{ctx, kbUID}

	// Record call args
	mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.mutex.Lock()
	mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.callArgs = append(mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.callArgs, &mm_params)
	mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.mutex.Unlock()

	for _, e := range mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteAllConvertedFilesInKbParams{ctx, kbUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteAllConvertedFilesInKb.t.Errorf("RepositoryMock.DeleteAllConvertedFilesInKb got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmDeleteAllConvertedFilesInKb.t.Errorf("RepositoryMock.DeleteAllConvertedFilesInKb got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteAllConvertedFilesInKb.t.Errorf("RepositoryMock.DeleteAllConvertedFilesInKb got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteAllConvertedFilesInKb.DeleteAllConvertedFilesInKbMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteAllConvertedFilesInKb.t.Fatal("No results are set for the RepositoryMock.DeleteAllConvertedFilesInKb")
		}
		return (*mm_results).err
	}
	if mmDeleteAllConvertedFilesInKb.funcDeleteAllConvertedFilesInKb != nil {
		return mmDeleteAllConvertedFilesInKb.funcDeleteAllConvertedFilesInKb(ctx, kbUID)
	}
	mmDeleteAllConvertedFilesInKb.t.Fatalf("Unexpected call to RepositoryMock.DeleteAllConvertedFilesInKb. %v %v", ctx, kbUID)
	return
}

// DeleteAllConvertedFilesInKbAfterCounter returns a count of finished RepositoryMock.DeleteAllConvertedFilesInKb invocations
func (mmDeleteAllConvertedFilesInKb *RepositoryMock) DeleteAllConvertedFilesInKbAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAllConvertedFilesInKb.afterDeleteAllConvertedFilesInKbCounter)
}

// DeleteAllConvertedFilesInKbBeforeCounter returns a count of RepositoryMock.DeleteAllConvertedFilesInKb invocations
func (mmDeleteAllConvertedFilesInKb *RepositoryMock) DeleteAllConvertedFilesInKbBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAllConvertedFilesInKb.beforeDeleteAllConvertedFilesInKbCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteAllConvertedFilesInKb.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteAllConvertedFilesInKb *mRepositoryMockDeleteAllConvertedFilesInKb) Calls() []*RepositoryMockDeleteAllConvertedFilesInKbParams {
	mmDeleteAllConvertedFilesInKb.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteAllConvertedFilesInKbParams, len(mmDeleteAllConvertedFilesInKb.callArgs))
	copy(argCopy, mmDeleteAllConvertedFilesInKb.callArgs)

	mmDeleteAllConvertedFilesInKb.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteAllConvertedFilesInKbDone returns true if the count of the DeleteAllConvertedFilesInKb invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteAllConvertedFilesInKbDone() bool {
	if m.DeleteAllConvertedFilesInKbMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteAllConvertedFilesInKbMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteAllConvertedFilesInKbMock.invocationsDone()
}

// MinimockDeleteAllConvertedFilesInKbInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteAllConvertedFilesInKbInspect() {
	for _, e := range m.DeleteAllConvertedFilesInKbMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteAllConvertedFilesInKb at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteAllConvertedFilesInKbCounter := mm_atomic.LoadUint64(&m.afterDeleteAllConvertedFilesInKbCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteAllConvertedFilesInKbMock.defaultExpectation != nil && afterDeleteAllConvertedFilesInKbCounter < 1 {
		if m.DeleteAllConvertedFilesInKbMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteAllConvertedFilesInKb at\n%s", m.DeleteAllConvertedFilesInKbMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteAllConvertedFilesInKb at\n%s with params: %#v", m.DeleteAllConvertedFilesInKbMock.defaultExpectation.expectationOrigins.origin, *m.DeleteAllConvertedFilesInKbMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteAllConvertedFilesInKb != nil && afterDeleteAllConvertedFilesInKbCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteAllConvertedFilesInKb at\n%s", m.funcDeleteAllConvertedFilesInKbOrigin)
	}

	if !m.DeleteAllConvertedFilesInKbMock.invocationsDone() && afterDeleteAllConvertedFilesInKbCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteAllConvertedFilesInKb at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteAllConvertedFilesInKbMock.expectedInvocations), m.DeleteAllConvertedFilesInKbMock.expectedInvocationsOrigin, afterDeleteAllConvertedFilesInKbCounter)
	}
}

type mRepositoryMockDeleteAllKnowledgeBaseFiles struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteAllKnowledgeBaseFilesExpectation
	expectations       []*RepositoryMockDeleteAllKnowledgeBaseFilesExpectation

	callArgs []*RepositoryMockDeleteAllKnowledgeBaseFilesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteAllKnowledgeBaseFilesExpectation specifies expectation struct of the Repository.DeleteAllKnowledgeBaseFiles
type RepositoryMockDeleteAllKnowledgeBaseFilesExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteAllKnowledgeBaseFilesParams
	paramPtrs          *RepositoryMockDeleteAllKnowledgeBaseFilesParamPtrs
	expectationOrigins RepositoryMockDeleteAllKnowledgeBaseFilesExpectationOrigins
	results            *RepositoryMockDeleteAllKnowledgeBaseFilesResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteAllKnowledgeBaseFilesParams contains parameters of the Repository.DeleteAllKnowledgeBaseFiles
type RepositoryMockDeleteAllKnowledgeBaseFilesParams struct {
	ctx   context.Context
	kbUID string
}

// RepositoryMockDeleteAllKnowledgeBaseFilesParamPtrs contains pointers to parameters of the Repository.DeleteAllKnowledgeBaseFiles
type RepositoryMockDeleteAllKnowledgeBaseFilesParamPtrs struct {
	ctx   *context.Context
	kbUID *string
}

// RepositoryMockDeleteAllKnowledgeBaseFilesResults contains results of the Repository.DeleteAllKnowledgeBaseFiles
type RepositoryMockDeleteAllKnowledgeBaseFilesResults struct {
	err error
}

// RepositoryMockDeleteAllKnowledgeBaseFilesOrigins contains origins of expectations of the Repository.DeleteAllKnowledgeBaseFiles
type RepositoryMockDeleteAllKnowledgeBaseFilesExpectationOrigins struct {
	origin      string
	originCtx   string
	originKbUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryMockDeleteAllKnowledgeBaseFiles) Optional() *mRepositoryMockDeleteAllKnowledgeBaseFiles {
	mmDeleteAllKnowledgeBaseFiles.optional = true
	return mmDeleteAllKnowledgeBaseFiles
}

// Expect sets up expected params for Repository.DeleteAllKnowledgeBaseFiles
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryMockDeleteAllKnowledgeBaseFiles) Expect(ctx context.Context, kbUID string) *mRepositoryMockDeleteAllKnowledgeBaseFiles {
	if mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFiles != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.DeleteAllKnowledgeBaseFiles mock is already set by Set")
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation == nil {
		mmDeleteAllKnowledgeBaseFiles.defaultExpectation = &RepositoryMockDeleteAllKnowledgeBaseFilesExpectation{}
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation.paramPtrs != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.DeleteAllKnowledgeBaseFiles mock is already set by ExpectParams functions")
	}

	mmDeleteAllKnowledgeBaseFiles.defaultExpectation.params = &RepositoryMockDeleteAllKnowledgeBaseFilesParams{ctx, kbUID}
	mmDeleteAllKnowledgeBaseFiles.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteAllKnowledgeBaseFiles.expectations {
		if minimock.Equal(e.params, mmDeleteAllKnowledgeBaseFiles.defaultExpectation.params) {
			mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteAllKnowledgeBaseFiles.defaultExpectation.params)
		}
	}

	return mmDeleteAllKnowledgeBaseFiles
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteAllKnowledgeBaseFiles
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryMockDeleteAllKnowledgeBaseFiles) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteAllKnowledgeBaseFiles {
	if mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFiles != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.DeleteAllKnowledgeBaseFiles mock is already set by Set")
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation == nil {
		mmDeleteAllKnowledgeBaseFiles.defaultExpectation = &RepositoryMockDeleteAllKnowledgeBaseFilesExpectation{}
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.DeleteAllKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmDeleteAllKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryMockDeleteAllKnowledgeBaseFilesParamPtrs{}
	}
	mmDeleteAllKnowledgeBaseFiles.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteAllKnowledgeBaseFiles.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteAllKnowledgeBaseFiles
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.DeleteAllKnowledgeBaseFiles
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryMockDeleteAllKnowledgeBaseFiles) ExpectKbUIDParam2(kbUID string) *mRepositoryMockDeleteAllKnowledgeBaseFiles {
	if mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFiles != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.DeleteAllKnowledgeBaseFiles mock is already set by Set")
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation == nil {
		mmDeleteAllKnowledgeBaseFiles.defaultExpectation = &RepositoryMockDeleteAllKnowledgeBaseFilesExpectation{}
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.DeleteAllKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmDeleteAllKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryMockDeleteAllKnowledgeBaseFilesParamPtrs{}
	}
	mmDeleteAllKnowledgeBaseFiles.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmDeleteAllKnowledgeBaseFiles.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmDeleteAllKnowledgeBaseFiles
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteAllKnowledgeBaseFiles
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryMockDeleteAllKnowledgeBaseFiles) Inspect(f func(ctx context.Context, kbUID string)) *mRepositoryMockDeleteAllKnowledgeBaseFiles {
	if mmDeleteAllKnowledgeBaseFiles.mock.inspectFuncDeleteAllKnowledgeBaseFiles != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteAllKnowledgeBaseFiles")
	}

	mmDeleteAllKnowledgeBaseFiles.mock.inspectFuncDeleteAllKnowledgeBaseFiles = f

	return mmDeleteAllKnowledgeBaseFiles
}

// Return sets up results that will be returned by Repository.DeleteAllKnowledgeBaseFiles
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryMockDeleteAllKnowledgeBaseFiles) Return(err error) *RepositoryMock {
	if mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFiles != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.DeleteAllKnowledgeBaseFiles mock is already set by Set")
	}

	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation == nil {
		mmDeleteAllKnowledgeBaseFiles.defaultExpectation = &RepositoryMockDeleteAllKnowledgeBaseFilesExpectation{mock: mmDeleteAllKnowledgeBaseFiles.mock}
	}
	mmDeleteAllKnowledgeBaseFiles.defaultExpectation.results = &RepositoryMockDeleteAllKnowledgeBaseFilesResults{err}
	mmDeleteAllKnowledgeBaseFiles.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteAllKnowledgeBaseFiles.mock
}

// Set uses given function f to mock the Repository.DeleteAllKnowledgeBaseFiles method
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryMockDeleteAllKnowledgeBaseFiles) Set(f func(ctx context.Context, kbUID string) (err error)) *RepositoryMock {
	if mmDeleteAllKnowledgeBaseFiles.defaultExpectation != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteAllKnowledgeBaseFiles method")
	}

	if len(mmDeleteAllKnowledgeBaseFiles.expectations) > 0 {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteAllKnowledgeBaseFiles method")
	}

	mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFiles = f
	mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFilesOrigin = minimock.CallerInfo(1)
	return mmDeleteAllKnowledgeBaseFiles.mock
}

// When sets expectation for the Repository.DeleteAllKnowledgeBaseFiles which will trigger the result defined by the following
// Then helper
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryMockDeleteAllKnowledgeBaseFiles) When(ctx context.Context, kbUID string) *RepositoryMockDeleteAllKnowledgeBaseFilesExpectation {
	if mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFiles != nil {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.DeleteAllKnowledgeBaseFiles mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteAllKnowledgeBaseFilesExpectation{
		mock:               mmDeleteAllKnowledgeBaseFiles.mock,
		params:             &RepositoryMockDeleteAllKnowledgeBaseFilesParams{ctx, kbUID},
		expectationOrigins: RepositoryMockDeleteAllKnowledgeBaseFilesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteAllKnowledgeBaseFiles.expectations = append(mmDeleteAllKnowledgeBaseFiles.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteAllKnowledgeBaseFiles return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteAllKnowledgeBaseFilesExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteAllKnowledgeBaseFilesResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteAllKnowledgeBaseFiles should be invoked
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryMockDeleteAllKnowledgeBaseFiles) Times(n uint64) *mRepositoryMockDeleteAllKnowledgeBaseFiles {
	if n == 0 {
		mmDeleteAllKnowledgeBaseFiles.mock.t.Fatalf("Times of RepositoryMock.DeleteAllKnowledgeBaseFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteAllKnowledgeBaseFiles.expectedInvocations, n)
	mmDeleteAllKnowledgeBaseFiles.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteAllKnowledgeBaseFiles
}

func (mmDeleteAllKnowledgeBaseFiles *mRepositoryMockDeleteAllKnowledgeBaseFiles) invocationsDone() bool {
	if len(mmDeleteAllKnowledgeBaseFiles.expectations) == 0 && mmDeleteAllKnowledgeBaseFiles.defaultExpectation == nil && mmDeleteAllKnowledgeBaseFiles.mock.funcDeleteAllKnowledgeBaseFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteAllKnowledgeBaseFiles.mock.afterDeleteAllKnowledgeBaseFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteAllKnowledgeBaseFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteAllKnowledgeBaseFiles implements mm_repository.Repository
func (mmDeleteAllKnowledgeBaseFiles *RepositoryMock) DeleteAllKnowledgeBaseFiles(ctx context.Context, kbUID string) (err error) {
	mm_atomic.AddUint64(&mmDeleteAllKnowledgeBaseFiles.beforeDeleteAllKnowledgeBaseFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteAllKnowledgeBaseFiles.afterDeleteAllKnowledgeBaseFilesCounter, 1)

	mmDeleteAllKnowledgeBaseFiles.t.Helper()

	if mmDeleteAllKnowledgeBaseFiles.inspectFuncDeleteAllKnowledgeBaseFiles != nil {
		mmDeleteAllKnowledgeBaseFiles.inspectFuncDeleteAllKnowledgeBaseFiles(ctx, kbUID)
	}

	mm_params := RepositoryMockDeleteAllKnowledgeBaseFilesParams{ctx, kbUID}

	// Record call args
	mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.mutex.Lock()
	mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.callArgs = append(mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.callArgs, &mm_params)
	mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.mutex.Unlock()

	for _, e := range mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteAllKnowledgeBaseFilesParams{ctx, kbUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteAllKnowledgeBaseFiles.t.Errorf("RepositoryMock.DeleteAllKnowledgeBaseFiles got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmDeleteAllKnowledgeBaseFiles.t.Errorf("RepositoryMock.DeleteAllKnowledgeBaseFiles got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteAllKnowledgeBaseFiles.t.Errorf("RepositoryMock.DeleteAllKnowledgeBaseFiles got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteAllKnowledgeBaseFiles.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteAllKnowledgeBaseFiles.t.Fatal("No results are set for the RepositoryMock.DeleteAllKnowledgeBaseFiles")
		}
		return (*mm_results).err
	}
	if mmDeleteAllKnowledgeBaseFiles.funcDeleteAllKnowledgeBaseFiles != nil {
		return mmDeleteAllKnowledgeBaseFiles.funcDeleteAllKnowledgeBaseFiles(ctx, kbUID)
	}
	mmDeleteAllKnowledgeBaseFiles.t.Fatalf("Unexpected call to RepositoryMock.DeleteAllKnowledgeBaseFiles. %v %v", ctx, kbUID)
	return
}

// DeleteAllKnowledgeBaseFilesAfterCounter returns a count of finished RepositoryMock.DeleteAllKnowledgeBaseFiles invocations
func (mmDeleteAllKnowledgeBaseFiles *RepositoryMock) DeleteAllKnowledgeBaseFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAllKnowledgeBaseFiles.afterDeleteAllKnowledgeBaseFilesCounter)
}

// DeleteAllKnowledgeBaseFilesBeforeCounter returns a count of RepositoryMock.DeleteAllKnowledgeBaseFiles invocations
func (mmDeleteAllKnowledgeBaseFiles *RepositoryMock) DeleteAllKnowledgeBaseFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAllKnowledgeBaseFiles.beforeDeleteAllKnowledgeBaseFilesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteAllKnowledgeBaseFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteAllKnowledgeBaseFiles *mRepositoryMockDeleteAllKnowledgeBaseFiles) Calls() []*RepositoryMockDeleteAllKnowledgeBaseFilesParams {
	mmDeleteAllKnowledgeBaseFiles.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteAllKnowledgeBaseFilesParams, len(mmDeleteAllKnowledgeBaseFiles.callArgs))
	copy(argCopy, mmDeleteAllKnowledgeBaseFiles.callArgs)

	mmDeleteAllKnowledgeBaseFiles.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteAllKnowledgeBaseFilesDone returns true if the count of the DeleteAllKnowledgeBaseFiles invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteAllKnowledgeBaseFilesDone() bool {
	if m.DeleteAllKnowledgeBaseFilesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteAllKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteAllKnowledgeBaseFilesMock.invocationsDone()
}

// MinimockDeleteAllKnowledgeBaseFilesInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteAllKnowledgeBaseFilesInspect() {
	for _, e := range m.DeleteAllKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteAllKnowledgeBaseFiles at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteAllKnowledgeBaseFilesCounter := mm_atomic.LoadUint64(&m.afterDeleteAllKnowledgeBaseFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteAllKnowledgeBaseFilesMock.defaultExpectation != nil && afterDeleteAllKnowledgeBaseFilesCounter < 1 {
		if m.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteAllKnowledgeBaseFiles at\n%s", m.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteAllKnowledgeBaseFiles at\n%s with params: %#v", m.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.origin, *m.DeleteAllKnowledgeBaseFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteAllKnowledgeBaseFiles != nil && afterDeleteAllKnowledgeBaseFilesCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteAllKnowledgeBaseFiles at\n%s", m.funcDeleteAllKnowledgeBaseFilesOrigin)
	}

	if !m.DeleteAllKnowledgeBaseFilesMock.invocationsDone() && afterDeleteAllKnowledgeBaseFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteAllKnowledgeBaseFiles at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteAllKnowledgeBaseFilesMock.expectedInvocations), m.DeleteAllKnowledgeBaseFilesMock.expectedInvocationsOrigin, afterDeleteAllKnowledgeBaseFilesCounter)
	}
}

type mRepositoryMockDeleteAndCreateEmbeddings struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteAndCreateEmbeddingsExpectation
	expectations       []*RepositoryMockDeleteAndCreateEmbeddingsExpectation

	callArgs []*RepositoryMockDeleteAndCreateEmbeddingsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteAndCreateEmbeddingsExpectation specifies expectation struct of the Repository.DeleteAndCreateEmbeddings
type RepositoryMockDeleteAndCreateEmbeddingsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteAndCreateEmbeddingsParams
	paramPtrs          *RepositoryMockDeleteAndCreateEmbeddingsParamPtrs
	expectationOrigins RepositoryMockDeleteAndCreateEmbeddingsExpectationOrigins
	results            *RepositoryMockDeleteAndCreateEmbeddingsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteAndCreateEmbeddingsParams contains parameters of the Repository.DeleteAndCreateEmbeddings
type RepositoryMockDeleteAndCreateEmbeddingsParams struct {
	ctx                 context.Context
	fileUID             types.FileUIDType
	embeddings          []mm_repository.EmbeddingModel
	externalServiceCall func([]mm_repository.EmbeddingModel) error
}

// RepositoryMockDeleteAndCreateEmbeddingsParamPtrs contains pointers to parameters of the Repository.DeleteAndCreateEmbeddings
type RepositoryMockDeleteAndCreateEmbeddingsParamPtrs struct {
	ctx                 *context.Context
	fileUID             *types.FileUIDType
	embeddings          *[]mm_repository.EmbeddingModel
	externalServiceCall *func([]mm_repository.EmbeddingModel) error
}

// RepositoryMockDeleteAndCreateEmbeddingsResults contains results of the Repository.DeleteAndCreateEmbeddings
type RepositoryMockDeleteAndCreateEmbeddingsResults struct {
	ea1 []mm_repository.EmbeddingModel
	err error
}

// RepositoryMockDeleteAndCreateEmbeddingsOrigins contains origins of expectations of the Repository.DeleteAndCreateEmbeddings
type RepositoryMockDeleteAndCreateEmbeddingsExpectationOrigins struct {
	origin                    string
	originCtx                 string
	originFileUID             string
	originEmbeddings          string
	originExternalServiceCall string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteAndCreateEmbeddings *mRepositoryMockDeleteAndCreateEmbeddings) Optional() *mRepositoryMockDeleteAndCreateEmbeddings {
	mmDeleteAndCreateEmbeddings.optional = true
	return mmDeleteAndCreateEmbeddings
}

// Expect sets up expected params for Repository.DeleteAndCreateEmbeddings
func (mmDeleteAndCreateEmbeddings *mRepositoryMockDeleteAndCreateEmbeddings) Expect(ctx context.Context, fileUID types.FileUIDType, embeddings []mm_repository.EmbeddingModel, externalServiceCall func([]mm_repository.EmbeddingModel) error) *mRepositoryMockDeleteAndCreateEmbeddings {
	if mmDeleteAndCreateEmbeddings.mock.funcDeleteAndCreateEmbeddings != nil {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("RepositoryMock.DeleteAndCreateEmbeddings mock is already set by Set")
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation == nil {
		mmDeleteAndCreateEmbeddings.defaultExpectation = &RepositoryMockDeleteAndCreateEmbeddingsExpectation{}
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation.paramPtrs != nil {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("RepositoryMock.DeleteAndCreateEmbeddings mock is already set by ExpectParams functions")
	}

	mmDeleteAndCreateEmbeddings.defaultExpectation.params = &RepositoryMockDeleteAndCreateEmbeddingsParams{ctx, fileUID, embeddings, externalServiceCall}
	mmDeleteAndCreateEmbeddings.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteAndCreateEmbeddings.expectations {
		if minimock.Equal(e.params, mmDeleteAndCreateEmbeddings.defaultExpectation.params) {
			mmDeleteAndCreateEmbeddings.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteAndCreateEmbeddings.defaultExpectation.params)
		}
	}

	return mmDeleteAndCreateEmbeddings
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteAndCreateEmbeddings
func (mmDeleteAndCreateEmbeddings *mRepositoryMockDeleteAndCreateEmbeddings) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteAndCreateEmbeddings {
	if mmDeleteAndCreateEmbeddings.mock.funcDeleteAndCreateEmbeddings != nil {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("RepositoryMock.DeleteAndCreateEmbeddings mock is already set by Set")
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation == nil {
		mmDeleteAndCreateEmbeddings.defaultExpectation = &RepositoryMockDeleteAndCreateEmbeddingsExpectation{}
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation.params != nil {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("RepositoryMock.DeleteAndCreateEmbeddings mock is already set by Expect")
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateEmbeddings.defaultExpectation.paramPtrs = &RepositoryMockDeleteAndCreateEmbeddingsParamPtrs{}
	}
	mmDeleteAndCreateEmbeddings.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteAndCreateEmbeddings.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteAndCreateEmbeddings
}

// ExpectFileUIDParam2 sets up expected param fileUID for Repository.DeleteAndCreateEmbeddings
func (mmDeleteAndCreateEmbeddings *mRepositoryMockDeleteAndCreateEmbeddings) ExpectFileUIDParam2(fileUID types.FileUIDType) *mRepositoryMockDeleteAndCreateEmbeddings {
	if mmDeleteAndCreateEmbeddings.mock.funcDeleteAndCreateEmbeddings != nil {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("RepositoryMock.DeleteAndCreateEmbeddings mock is already set by Set")
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation == nil {
		mmDeleteAndCreateEmbeddings.defaultExpectation = &RepositoryMockDeleteAndCreateEmbeddingsExpectation{}
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation.params != nil {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("RepositoryMock.DeleteAndCreateEmbeddings mock is already set by Expect")
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateEmbeddings.defaultExpectation.paramPtrs = &RepositoryMockDeleteAndCreateEmbeddingsParamPtrs{}
	}
	mmDeleteAndCreateEmbeddings.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmDeleteAndCreateEmbeddings.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmDeleteAndCreateEmbeddings
}

// ExpectEmbeddingsParam3 sets up expected param embeddings for Repository.DeleteAndCreateEmbeddings
func (mmDeleteAndCreateEmbeddings *mRepositoryMockDeleteAndCreateEmbeddings) ExpectEmbeddingsParam3(embeddings []mm_repository.EmbeddingModel) *mRepositoryMockDeleteAndCreateEmbeddings {
	if mmDeleteAndCreateEmbeddings.mock.funcDeleteAndCreateEmbeddings != nil {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("RepositoryMock.DeleteAndCreateEmbeddings mock is already set by Set")
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation == nil {
		mmDeleteAndCreateEmbeddings.defaultExpectation = &RepositoryMockDeleteAndCreateEmbeddingsExpectation{}
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation.params != nil {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("RepositoryMock.DeleteAndCreateEmbeddings mock is already set by Expect")
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateEmbeddings.defaultExpectation.paramPtrs = &RepositoryMockDeleteAndCreateEmbeddingsParamPtrs{}
	}
	mmDeleteAndCreateEmbeddings.defaultExpectation.paramPtrs.embeddings = &embeddings
	mmDeleteAndCreateEmbeddings.defaultExpectation.expectationOrigins.originEmbeddings = minimock.CallerInfo(1)

	return mmDeleteAndCreateEmbeddings
}

// ExpectExternalServiceCallParam4 sets up expected param externalServiceCall for Repository.DeleteAndCreateEmbeddings
func (mmDeleteAndCreateEmbeddings *mRepositoryMockDeleteAndCreateEmbeddings) ExpectExternalServiceCallParam4(externalServiceCall func([]mm_repository.EmbeddingModel) error) *mRepositoryMockDeleteAndCreateEmbeddings {
	if mmDeleteAndCreateEmbeddings.mock.funcDeleteAndCreateEmbeddings != nil {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("RepositoryMock.DeleteAndCreateEmbeddings mock is already set by Set")
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation == nil {
		mmDeleteAndCreateEmbeddings.defaultExpectation = &RepositoryMockDeleteAndCreateEmbeddingsExpectation{}
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation.params != nil {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("RepositoryMock.DeleteAndCreateEmbeddings mock is already set by Expect")
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateEmbeddings.defaultExpectation.paramPtrs = &RepositoryMockDeleteAndCreateEmbeddingsParamPtrs{}
	}
	mmDeleteAndCreateEmbeddings.defaultExpectation.paramPtrs.externalServiceCall = &externalServiceCall
	mmDeleteAndCreateEmbeddings.defaultExpectation.expectationOrigins.originExternalServiceCall = minimock.CallerInfo(1)

	return mmDeleteAndCreateEmbeddings
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteAndCreateEmbeddings
func (mmDeleteAndCreateEmbeddings *mRepositoryMockDeleteAndCreateEmbeddings) Inspect(f func(ctx context.Context, fileUID types.FileUIDType, embeddings []mm_repository.EmbeddingModel, externalServiceCall func([]mm_repository.EmbeddingModel) error)) *mRepositoryMockDeleteAndCreateEmbeddings {
	if mmDeleteAndCreateEmbeddings.mock.inspectFuncDeleteAndCreateEmbeddings != nil {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteAndCreateEmbeddings")
	}

	mmDeleteAndCreateEmbeddings.mock.inspectFuncDeleteAndCreateEmbeddings = f

	return mmDeleteAndCreateEmbeddings
}

// Return sets up results that will be returned by Repository.DeleteAndCreateEmbeddings
func (mmDeleteAndCreateEmbeddings *mRepositoryMockDeleteAndCreateEmbeddings) Return(ea1 []mm_repository.EmbeddingModel, err error) *RepositoryMock {
	if mmDeleteAndCreateEmbeddings.mock.funcDeleteAndCreateEmbeddings != nil {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("RepositoryMock.DeleteAndCreateEmbeddings mock is already set by Set")
	}

	if mmDeleteAndCreateEmbeddings.defaultExpectation == nil {
		mmDeleteAndCreateEmbeddings.defaultExpectation = &RepositoryMockDeleteAndCreateEmbeddingsExpectation{mock: mmDeleteAndCreateEmbeddings.mock}
	}
	mmDeleteAndCreateEmbeddings.defaultExpectation.results = &RepositoryMockDeleteAndCreateEmbeddingsResults{ea1, err}
	mmDeleteAndCreateEmbeddings.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteAndCreateEmbeddings.mock
}

// Set uses given function f to mock the Repository.DeleteAndCreateEmbeddings method
func (mmDeleteAndCreateEmbeddings *mRepositoryMockDeleteAndCreateEmbeddings) Set(f func(ctx context.Context, fileUID types.FileUIDType, embeddings []mm_repository.EmbeddingModel, externalServiceCall func([]mm_repository.EmbeddingModel) error) (ea1 []mm_repository.EmbeddingModel, err error)) *RepositoryMock {
	if mmDeleteAndCreateEmbeddings.defaultExpectation != nil {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteAndCreateEmbeddings method")
	}

	if len(mmDeleteAndCreateEmbeddings.expectations) > 0 {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteAndCreateEmbeddings method")
	}

	mmDeleteAndCreateEmbeddings.mock.funcDeleteAndCreateEmbeddings = f
	mmDeleteAndCreateEmbeddings.mock.funcDeleteAndCreateEmbeddingsOrigin = minimock.CallerInfo(1)
	return mmDeleteAndCreateEmbeddings.mock
}

// When sets expectation for the Repository.DeleteAndCreateEmbeddings which will trigger the result defined by the following
// Then helper
func (mmDeleteAndCreateEmbeddings *mRepositoryMockDeleteAndCreateEmbeddings) When(ctx context.Context, fileUID types.FileUIDType, embeddings []mm_repository.EmbeddingModel, externalServiceCall func([]mm_repository.EmbeddingModel) error) *RepositoryMockDeleteAndCreateEmbeddingsExpectation {
	if mmDeleteAndCreateEmbeddings.mock.funcDeleteAndCreateEmbeddings != nil {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("RepositoryMock.DeleteAndCreateEmbeddings mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteAndCreateEmbeddingsExpectation{
		mock:               mmDeleteAndCreateEmbeddings.mock,
		params:             &RepositoryMockDeleteAndCreateEmbeddingsParams{ctx, fileUID, embeddings, externalServiceCall},
		expectationOrigins: RepositoryMockDeleteAndCreateEmbeddingsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteAndCreateEmbeddings.expectations = append(mmDeleteAndCreateEmbeddings.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteAndCreateEmbeddings return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteAndCreateEmbeddingsExpectation) Then(ea1 []mm_repository.EmbeddingModel, err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteAndCreateEmbeddingsResults{ea1, err}
	return e.mock
}

// Times sets number of times Repository.DeleteAndCreateEmbeddings should be invoked
func (mmDeleteAndCreateEmbeddings *mRepositoryMockDeleteAndCreateEmbeddings) Times(n uint64) *mRepositoryMockDeleteAndCreateEmbeddings {
	if n == 0 {
		mmDeleteAndCreateEmbeddings.mock.t.Fatalf("Times of RepositoryMock.DeleteAndCreateEmbeddings mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteAndCreateEmbeddings.expectedInvocations, n)
	mmDeleteAndCreateEmbeddings.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteAndCreateEmbeddings
}

func (mmDeleteAndCreateEmbeddings *mRepositoryMockDeleteAndCreateEmbeddings) invocationsDone() bool {
	if len(mmDeleteAndCreateEmbeddings.expectations) == 0 && mmDeleteAndCreateEmbeddings.defaultExpectation == nil && mmDeleteAndCreateEmbeddings.mock.funcDeleteAndCreateEmbeddings == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteAndCreateEmbeddings.mock.afterDeleteAndCreateEmbeddingsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteAndCreateEmbeddings.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteAndCreateEmbeddings implements mm_repository.Repository
func (mmDeleteAndCreateEmbeddings *RepositoryMock) DeleteAndCreateEmbeddings(ctx context.Context, fileUID types.FileUIDType, embeddings []mm_repository.EmbeddingModel, externalServiceCall func([]mm_repository.EmbeddingModel) error) (ea1 []mm_repository.EmbeddingModel, err error) {
	mm_atomic.AddUint64(&mmDeleteAndCreateEmbeddings.beforeDeleteAndCreateEmbeddingsCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteAndCreateEmbeddings.afterDeleteAndCreateEmbeddingsCounter, 1)

	mmDeleteAndCreateEmbeddings.t.Helper()

	if mmDeleteAndCreateEmbeddings.inspectFuncDeleteAndCreateEmbeddings != nil {
		mmDeleteAndCreateEmbeddings.inspectFuncDeleteAndCreateEmbeddings(ctx, fileUID, embeddings, externalServiceCall)
	}

	mm_params := RepositoryMockDeleteAndCreateEmbeddingsParams{ctx, fileUID, embeddings, externalServiceCall}

	// Record call args
	mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.mutex.Lock()
	mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.callArgs = append(mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.callArgs, &mm_params)
	mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.mutex.Unlock()

	for _, e := range mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1, e.results.err
		}
	}

	if mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteAndCreateEmbeddingsParams{ctx, fileUID, embeddings, externalServiceCall}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteAndCreateEmbeddings.t.Errorf("RepositoryMock.DeleteAndCreateEmbeddings got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmDeleteAndCreateEmbeddings.t.Errorf("RepositoryMock.DeleteAndCreateEmbeddings got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

			if mm_want_ptrs.embeddings != nil && !minimock.Equal(*mm_want_ptrs.embeddings, mm_got.embeddings) {
				mmDeleteAndCreateEmbeddings.t.Errorf("RepositoryMock.DeleteAndCreateEmbeddings got unexpected parameter embeddings, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.defaultExpectation.expectationOrigins.originEmbeddings, *mm_want_ptrs.embeddings, mm_got.embeddings, minimock.Diff(*mm_want_ptrs.embeddings, mm_got.embeddings))
			}

			if mm_want_ptrs.externalServiceCall != nil && !minimock.Equal(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall) {
				mmDeleteAndCreateEmbeddings.t.Errorf("RepositoryMock.DeleteAndCreateEmbeddings got unexpected parameter externalServiceCall, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.defaultExpectation.expectationOrigins.originExternalServiceCall, *mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall, minimock.Diff(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteAndCreateEmbeddings.t.Errorf("RepositoryMock.DeleteAndCreateEmbeddings got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteAndCreateEmbeddings.DeleteAndCreateEmbeddingsMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteAndCreateEmbeddings.t.Fatal("No results are set for the RepositoryMock.DeleteAndCreateEmbeddings")
		}
		return (*mm_results).ea1, (*mm_results).err
	}
	if mmDeleteAndCreateEmbeddings.funcDeleteAndCreateEmbeddings != nil {
		return mmDeleteAndCreateEmbeddings.funcDeleteAndCreateEmbeddings(ctx, fileUID, embeddings, externalServiceCall)
	}
	mmDeleteAndCreateEmbeddings.t.Fatalf("Unexpected call to RepositoryMock.DeleteAndCreateEmbeddings. %v %v %v %v", ctx, fileUID, embeddings, externalServiceCall)
	return
}

// DeleteAndCreateEmbeddingsAfterCounter returns a count of finished RepositoryMock.DeleteAndCreateEmbeddings invocations
func (mmDeleteAndCreateEmbeddings *RepositoryMock) DeleteAndCreateEmbeddingsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAndCreateEmbeddings.afterDeleteAndCreateEmbeddingsCounter)
}

// DeleteAndCreateEmbeddingsBeforeCounter returns a count of RepositoryMock.DeleteAndCreateEmbeddings invocations
func (mmDeleteAndCreateEmbeddings *RepositoryMock) DeleteAndCreateEmbeddingsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAndCreateEmbeddings.beforeDeleteAndCreateEmbeddingsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteAndCreateEmbeddings.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteAndCreateEmbeddings *mRepositoryMockDeleteAndCreateEmbeddings) Calls() []*RepositoryMockDeleteAndCreateEmbeddingsParams {
	mmDeleteAndCreateEmbeddings.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteAndCreateEmbeddingsParams, len(mmDeleteAndCreateEmbeddings.callArgs))
	copy(argCopy, mmDeleteAndCreateEmbeddings.callArgs)

	mmDeleteAndCreateEmbeddings.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteAndCreateEmbeddingsDone returns true if the count of the DeleteAndCreateEmbeddings invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteAndCreateEmbeddingsDone() bool {
	if m.DeleteAndCreateEmbeddingsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteAndCreateEmbeddingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteAndCreateEmbeddingsMock.invocationsDone()
}

// MinimockDeleteAndCreateEmbeddingsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteAndCreateEmbeddingsInspect() {
	for _, e := range m.DeleteAndCreateEmbeddingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteAndCreateEmbeddings at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteAndCreateEmbeddingsCounter := mm_atomic.LoadUint64(&m.afterDeleteAndCreateEmbeddingsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteAndCreateEmbeddingsMock.defaultExpectation != nil && afterDeleteAndCreateEmbeddingsCounter < 1 {
		if m.DeleteAndCreateEmbeddingsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteAndCreateEmbeddings at\n%s", m.DeleteAndCreateEmbeddingsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteAndCreateEmbeddings at\n%s with params: %#v", m.DeleteAndCreateEmbeddingsMock.defaultExpectation.expectationOrigins.origin, *m.DeleteAndCreateEmbeddingsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteAndCreateEmbeddings != nil && afterDeleteAndCreateEmbeddingsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteAndCreateEmbeddings at\n%s", m.funcDeleteAndCreateEmbeddingsOrigin)
	}

	if !m.DeleteAndCreateEmbeddingsMock.invocationsDone() && afterDeleteAndCreateEmbeddingsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteAndCreateEmbeddings at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteAndCreateEmbeddingsMock.expectedInvocations), m.DeleteAndCreateEmbeddingsMock.expectedInvocationsOrigin, afterDeleteAndCreateEmbeddingsCounter)
	}
}

type mRepositoryMockDeleteAndCreateTextChunks struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteAndCreateTextChunksExpectation
	expectations       []*RepositoryMockDeleteAndCreateTextChunksExpectation

	callArgs []*RepositoryMockDeleteAndCreateTextChunksParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteAndCreateTextChunksExpectation specifies expectation struct of the Repository.DeleteAndCreateTextChunks
type RepositoryMockDeleteAndCreateTextChunksExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteAndCreateTextChunksParams
	paramPtrs          *RepositoryMockDeleteAndCreateTextChunksParamPtrs
	expectationOrigins RepositoryMockDeleteAndCreateTextChunksExpectationOrigins
	results            *RepositoryMockDeleteAndCreateTextChunksResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteAndCreateTextChunksParams contains parameters of the Repository.DeleteAndCreateTextChunks
type RepositoryMockDeleteAndCreateTextChunksParams struct {
	ctx                 context.Context
	fileUID             types.FileUIDType
	textChunks          []*mm_repository.TextChunkModel
	externalServiceCall func(chunkUIDs []string) (destinations map[string]string, _ error)
}

// RepositoryMockDeleteAndCreateTextChunksParamPtrs contains pointers to parameters of the Repository.DeleteAndCreateTextChunks
type RepositoryMockDeleteAndCreateTextChunksParamPtrs struct {
	ctx                 *context.Context
	fileUID             *types.FileUIDType
	textChunks          *[]*mm_repository.TextChunkModel
	externalServiceCall *func(chunkUIDs []string) (destinations map[string]string, _ error)
}

// RepositoryMockDeleteAndCreateTextChunksResults contains results of the Repository.DeleteAndCreateTextChunks
type RepositoryMockDeleteAndCreateTextChunksResults struct {
	tpa1 []*mm_repository.TextChunkModel
	err  error
}

// RepositoryMockDeleteAndCreateTextChunksOrigins contains origins of expectations of the Repository.DeleteAndCreateTextChunks
type RepositoryMockDeleteAndCreateTextChunksExpectationOrigins struct {
	origin                    string
	originCtx                 string
	originFileUID             string
	originTextChunks          string
	originExternalServiceCall string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteAndCreateTextChunks *mRepositoryMockDeleteAndCreateTextChunks) Optional() *mRepositoryMockDeleteAndCreateTextChunks {
	mmDeleteAndCreateTextChunks.optional = true
	return mmDeleteAndCreateTextChunks
}

// Expect sets up expected params for Repository.DeleteAndCreateTextChunks
func (mmDeleteAndCreateTextChunks *mRepositoryMockDeleteAndCreateTextChunks) Expect(ctx context.Context, fileUID types.FileUIDType, textChunks []*mm_repository.TextChunkModel, externalServiceCall func(chunkUIDs []string) (destinations map[string]string, _ error)) *mRepositoryMockDeleteAndCreateTextChunks {
	if mmDeleteAndCreateTextChunks.mock.funcDeleteAndCreateTextChunks != nil {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("RepositoryMock.DeleteAndCreateTextChunks mock is already set by Set")
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation == nil {
		mmDeleteAndCreateTextChunks.defaultExpectation = &RepositoryMockDeleteAndCreateTextChunksExpectation{}
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation.paramPtrs != nil {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("RepositoryMock.DeleteAndCreateTextChunks mock is already set by ExpectParams functions")
	}

	mmDeleteAndCreateTextChunks.defaultExpectation.params = &RepositoryMockDeleteAndCreateTextChunksParams{ctx, fileUID, textChunks, externalServiceCall}
	mmDeleteAndCreateTextChunks.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteAndCreateTextChunks.expectations {
		if minimock.Equal(e.params, mmDeleteAndCreateTextChunks.defaultExpectation.params) {
			mmDeleteAndCreateTextChunks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteAndCreateTextChunks.defaultExpectation.params)
		}
	}

	return mmDeleteAndCreateTextChunks
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteAndCreateTextChunks
func (mmDeleteAndCreateTextChunks *mRepositoryMockDeleteAndCreateTextChunks) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteAndCreateTextChunks {
	if mmDeleteAndCreateTextChunks.mock.funcDeleteAndCreateTextChunks != nil {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("RepositoryMock.DeleteAndCreateTextChunks mock is already set by Set")
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation == nil {
		mmDeleteAndCreateTextChunks.defaultExpectation = &RepositoryMockDeleteAndCreateTextChunksExpectation{}
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation.params != nil {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("RepositoryMock.DeleteAndCreateTextChunks mock is already set by Expect")
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateTextChunks.defaultExpectation.paramPtrs = &RepositoryMockDeleteAndCreateTextChunksParamPtrs{}
	}
	mmDeleteAndCreateTextChunks.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteAndCreateTextChunks.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteAndCreateTextChunks
}

// ExpectFileUIDParam2 sets up expected param fileUID for Repository.DeleteAndCreateTextChunks
func (mmDeleteAndCreateTextChunks *mRepositoryMockDeleteAndCreateTextChunks) ExpectFileUIDParam2(fileUID types.FileUIDType) *mRepositoryMockDeleteAndCreateTextChunks {
	if mmDeleteAndCreateTextChunks.mock.funcDeleteAndCreateTextChunks != nil {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("RepositoryMock.DeleteAndCreateTextChunks mock is already set by Set")
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation == nil {
		mmDeleteAndCreateTextChunks.defaultExpectation = &RepositoryMockDeleteAndCreateTextChunksExpectation{}
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation.params != nil {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("RepositoryMock.DeleteAndCreateTextChunks mock is already set by Expect")
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateTextChunks.defaultExpectation.paramPtrs = &RepositoryMockDeleteAndCreateTextChunksParamPtrs{}
	}
	mmDeleteAndCreateTextChunks.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmDeleteAndCreateTextChunks.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmDeleteAndCreateTextChunks
}

// ExpectTextChunksParam3 sets up expected param textChunks for Repository.DeleteAndCreateTextChunks
func (mmDeleteAndCreateTextChunks *mRepositoryMockDeleteAndCreateTextChunks) ExpectTextChunksParam3(textChunks []*mm_repository.TextChunkModel) *mRepositoryMockDeleteAndCreateTextChunks {
	if mmDeleteAndCreateTextChunks.mock.funcDeleteAndCreateTextChunks != nil {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("RepositoryMock.DeleteAndCreateTextChunks mock is already set by Set")
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation == nil {
		mmDeleteAndCreateTextChunks.defaultExpectation = &RepositoryMockDeleteAndCreateTextChunksExpectation{}
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation.params != nil {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("RepositoryMock.DeleteAndCreateTextChunks mock is already set by Expect")
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateTextChunks.defaultExpectation.paramPtrs = &RepositoryMockDeleteAndCreateTextChunksParamPtrs{}
	}
	mmDeleteAndCreateTextChunks.defaultExpectation.paramPtrs.textChunks = &textChunks
	mmDeleteAndCreateTextChunks.defaultExpectation.expectationOrigins.originTextChunks = minimock.CallerInfo(1)

	return mmDeleteAndCreateTextChunks
}

// ExpectExternalServiceCallParam4 sets up expected param externalServiceCall for Repository.DeleteAndCreateTextChunks
func (mmDeleteAndCreateTextChunks *mRepositoryMockDeleteAndCreateTextChunks) ExpectExternalServiceCallParam4(externalServiceCall func(chunkUIDs []string) (destinations map[string]string, _ error)) *mRepositoryMockDeleteAndCreateTextChunks {
	if mmDeleteAndCreateTextChunks.mock.funcDeleteAndCreateTextChunks != nil {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("RepositoryMock.DeleteAndCreateTextChunks mock is already set by Set")
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation == nil {
		mmDeleteAndCreateTextChunks.defaultExpectation = &RepositoryMockDeleteAndCreateTextChunksExpectation{}
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation.params != nil {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("RepositoryMock.DeleteAndCreateTextChunks mock is already set by Expect")
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation.paramPtrs == nil {
		mmDeleteAndCreateTextChunks.defaultExpectation.paramPtrs = &RepositoryMockDeleteAndCreateTextChunksParamPtrs{}
	}
	mmDeleteAndCreateTextChunks.defaultExpectation.paramPtrs.externalServiceCall = &externalServiceCall
	mmDeleteAndCreateTextChunks.defaultExpectation.expectationOrigins.originExternalServiceCall = minimock.CallerInfo(1)

	return mmDeleteAndCreateTextChunks
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteAndCreateTextChunks
func (mmDeleteAndCreateTextChunks *mRepositoryMockDeleteAndCreateTextChunks) Inspect(f func(ctx context.Context, fileUID types.FileUIDType, textChunks []*mm_repository.TextChunkModel, externalServiceCall func(chunkUIDs []string) (destinations map[string]string, _ error))) *mRepositoryMockDeleteAndCreateTextChunks {
	if mmDeleteAndCreateTextChunks.mock.inspectFuncDeleteAndCreateTextChunks != nil {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteAndCreateTextChunks")
	}

	mmDeleteAndCreateTextChunks.mock.inspectFuncDeleteAndCreateTextChunks = f

	return mmDeleteAndCreateTextChunks
}

// Return sets up results that will be returned by Repository.DeleteAndCreateTextChunks
func (mmDeleteAndCreateTextChunks *mRepositoryMockDeleteAndCreateTextChunks) Return(tpa1 []*mm_repository.TextChunkModel, err error) *RepositoryMock {
	if mmDeleteAndCreateTextChunks.mock.funcDeleteAndCreateTextChunks != nil {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("RepositoryMock.DeleteAndCreateTextChunks mock is already set by Set")
	}

	if mmDeleteAndCreateTextChunks.defaultExpectation == nil {
		mmDeleteAndCreateTextChunks.defaultExpectation = &RepositoryMockDeleteAndCreateTextChunksExpectation{mock: mmDeleteAndCreateTextChunks.mock}
	}
	mmDeleteAndCreateTextChunks.defaultExpectation.results = &RepositoryMockDeleteAndCreateTextChunksResults{tpa1, err}
	mmDeleteAndCreateTextChunks.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteAndCreateTextChunks.mock
}

// Set uses given function f to mock the Repository.DeleteAndCreateTextChunks method
func (mmDeleteAndCreateTextChunks *mRepositoryMockDeleteAndCreateTextChunks) Set(f func(ctx context.Context, fileUID types.FileUIDType, textChunks []*mm_repository.TextChunkModel, externalServiceCall func(chunkUIDs []string) (destinations map[string]string, _ error)) (tpa1 []*mm_repository.TextChunkModel, err error)) *RepositoryMock {
	if mmDeleteAndCreateTextChunks.defaultExpectation != nil {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteAndCreateTextChunks method")
	}

	if len(mmDeleteAndCreateTextChunks.expectations) > 0 {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteAndCreateTextChunks method")
	}

	mmDeleteAndCreateTextChunks.mock.funcDeleteAndCreateTextChunks = f
	mmDeleteAndCreateTextChunks.mock.funcDeleteAndCreateTextChunksOrigin = minimock.CallerInfo(1)
	return mmDeleteAndCreateTextChunks.mock
}

// When sets expectation for the Repository.DeleteAndCreateTextChunks which will trigger the result defined by the following
// Then helper
func (mmDeleteAndCreateTextChunks *mRepositoryMockDeleteAndCreateTextChunks) When(ctx context.Context, fileUID types.FileUIDType, textChunks []*mm_repository.TextChunkModel, externalServiceCall func(chunkUIDs []string) (destinations map[string]string, _ error)) *RepositoryMockDeleteAndCreateTextChunksExpectation {
	if mmDeleteAndCreateTextChunks.mock.funcDeleteAndCreateTextChunks != nil {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("RepositoryMock.DeleteAndCreateTextChunks mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteAndCreateTextChunksExpectation{
		mock:               mmDeleteAndCreateTextChunks.mock,
		params:             &RepositoryMockDeleteAndCreateTextChunksParams{ctx, fileUID, textChunks, externalServiceCall},
		expectationOrigins: RepositoryMockDeleteAndCreateTextChunksExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteAndCreateTextChunks.expectations = append(mmDeleteAndCreateTextChunks.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteAndCreateTextChunks return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteAndCreateTextChunksExpectation) Then(tpa1 []*mm_repository.TextChunkModel, err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteAndCreateTextChunksResults{tpa1, err}
	return e.mock
}

// Times sets number of times Repository.DeleteAndCreateTextChunks should be invoked
func (mmDeleteAndCreateTextChunks *mRepositoryMockDeleteAndCreateTextChunks) Times(n uint64) *mRepositoryMockDeleteAndCreateTextChunks {
	if n == 0 {
		mmDeleteAndCreateTextChunks.mock.t.Fatalf("Times of RepositoryMock.DeleteAndCreateTextChunks mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteAndCreateTextChunks.expectedInvocations, n)
	mmDeleteAndCreateTextChunks.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteAndCreateTextChunks
}

func (mmDeleteAndCreateTextChunks *mRepositoryMockDeleteAndCreateTextChunks) invocationsDone() bool {
	if len(mmDeleteAndCreateTextChunks.expectations) == 0 && mmDeleteAndCreateTextChunks.defaultExpectation == nil && mmDeleteAndCreateTextChunks.mock.funcDeleteAndCreateTextChunks == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteAndCreateTextChunks.mock.afterDeleteAndCreateTextChunksCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteAndCreateTextChunks.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteAndCreateTextChunks implements mm_repository.Repository
func (mmDeleteAndCreateTextChunks *RepositoryMock) DeleteAndCreateTextChunks(ctx context.Context, fileUID types.FileUIDType, textChunks []*mm_repository.TextChunkModel, externalServiceCall func(chunkUIDs []string) (destinations map[string]string, _ error)) (tpa1 []*mm_repository.TextChunkModel, err error) {
	mm_atomic.AddUint64(&mmDeleteAndCreateTextChunks.beforeDeleteAndCreateTextChunksCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteAndCreateTextChunks.afterDeleteAndCreateTextChunksCounter, 1)

	mmDeleteAndCreateTextChunks.t.Helper()

	if mmDeleteAndCreateTextChunks.inspectFuncDeleteAndCreateTextChunks != nil {
		mmDeleteAndCreateTextChunks.inspectFuncDeleteAndCreateTextChunks(ctx, fileUID, textChunks, externalServiceCall)
	}

	mm_params := RepositoryMockDeleteAndCreateTextChunksParams{ctx, fileUID, textChunks, externalServiceCall}

	// Record call args
	mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.mutex.Lock()
	mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.callArgs = append(mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.callArgs, &mm_params)
	mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.mutex.Unlock()

	for _, e := range mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tpa1, e.results.err
		}
	}

	if mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteAndCreateTextChunksParams{ctx, fileUID, textChunks, externalServiceCall}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteAndCreateTextChunks.t.Errorf("RepositoryMock.DeleteAndCreateTextChunks got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmDeleteAndCreateTextChunks.t.Errorf("RepositoryMock.DeleteAndCreateTextChunks got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

			if mm_want_ptrs.textChunks != nil && !minimock.Equal(*mm_want_ptrs.textChunks, mm_got.textChunks) {
				mmDeleteAndCreateTextChunks.t.Errorf("RepositoryMock.DeleteAndCreateTextChunks got unexpected parameter textChunks, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.defaultExpectation.expectationOrigins.originTextChunks, *mm_want_ptrs.textChunks, mm_got.textChunks, minimock.Diff(*mm_want_ptrs.textChunks, mm_got.textChunks))
			}

			if mm_want_ptrs.externalServiceCall != nil && !minimock.Equal(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall) {
				mmDeleteAndCreateTextChunks.t.Errorf("RepositoryMock.DeleteAndCreateTextChunks got unexpected parameter externalServiceCall, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.defaultExpectation.expectationOrigins.originExternalServiceCall, *mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall, minimock.Diff(*mm_want_ptrs.externalServiceCall, mm_got.externalServiceCall))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteAndCreateTextChunks.t.Errorf("RepositoryMock.DeleteAndCreateTextChunks got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteAndCreateTextChunks.DeleteAndCreateTextChunksMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteAndCreateTextChunks.t.Fatal("No results are set for the RepositoryMock.DeleteAndCreateTextChunks")
		}
		return (*mm_results).tpa1, (*mm_results).err
	}
	if mmDeleteAndCreateTextChunks.funcDeleteAndCreateTextChunks != nil {
		return mmDeleteAndCreateTextChunks.funcDeleteAndCreateTextChunks(ctx, fileUID, textChunks, externalServiceCall)
	}
	mmDeleteAndCreateTextChunks.t.Fatalf("Unexpected call to RepositoryMock.DeleteAndCreateTextChunks. %v %v %v %v", ctx, fileUID, textChunks, externalServiceCall)
	return
}

// DeleteAndCreateTextChunksAfterCounter returns a count of finished RepositoryMock.DeleteAndCreateTextChunks invocations
func (mmDeleteAndCreateTextChunks *RepositoryMock) DeleteAndCreateTextChunksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAndCreateTextChunks.afterDeleteAndCreateTextChunksCounter)
}

// DeleteAndCreateTextChunksBeforeCounter returns a count of RepositoryMock.DeleteAndCreateTextChunks invocations
func (mmDeleteAndCreateTextChunks *RepositoryMock) DeleteAndCreateTextChunksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAndCreateTextChunks.beforeDeleteAndCreateTextChunksCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteAndCreateTextChunks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteAndCreateTextChunks *mRepositoryMockDeleteAndCreateTextChunks) Calls() []*RepositoryMockDeleteAndCreateTextChunksParams {
	mmDeleteAndCreateTextChunks.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteAndCreateTextChunksParams, len(mmDeleteAndCreateTextChunks.callArgs))
	copy(argCopy, mmDeleteAndCreateTextChunks.callArgs)

	mmDeleteAndCreateTextChunks.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteAndCreateTextChunksDone returns true if the count of the DeleteAndCreateTextChunks invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteAndCreateTextChunksDone() bool {
	if m.DeleteAndCreateTextChunksMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteAndCreateTextChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteAndCreateTextChunksMock.invocationsDone()
}

// MinimockDeleteAndCreateTextChunksInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteAndCreateTextChunksInspect() {
	for _, e := range m.DeleteAndCreateTextChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteAndCreateTextChunks at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteAndCreateTextChunksCounter := mm_atomic.LoadUint64(&m.afterDeleteAndCreateTextChunksCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteAndCreateTextChunksMock.defaultExpectation != nil && afterDeleteAndCreateTextChunksCounter < 1 {
		if m.DeleteAndCreateTextChunksMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteAndCreateTextChunks at\n%s", m.DeleteAndCreateTextChunksMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteAndCreateTextChunks at\n%s with params: %#v", m.DeleteAndCreateTextChunksMock.defaultExpectation.expectationOrigins.origin, *m.DeleteAndCreateTextChunksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteAndCreateTextChunks != nil && afterDeleteAndCreateTextChunksCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteAndCreateTextChunks at\n%s", m.funcDeleteAndCreateTextChunksOrigin)
	}

	if !m.DeleteAndCreateTextChunksMock.invocationsDone() && afterDeleteAndCreateTextChunksCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteAndCreateTextChunks at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteAndCreateTextChunksMock.expectedInvocations), m.DeleteAndCreateTextChunksMock.expectedInvocationsOrigin, afterDeleteAndCreateTextChunksCounter)
	}
}

type mRepositoryMockDeleteChatCacheMetadata struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteChatCacheMetadataExpectation
	expectations       []*RepositoryMockDeleteChatCacheMetadataExpectation

	callArgs []*RepositoryMockDeleteChatCacheMetadataParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteChatCacheMetadataExpectation specifies expectation struct of the Repository.DeleteChatCacheMetadata
type RepositoryMockDeleteChatCacheMetadataExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteChatCacheMetadataParams
	paramPtrs          *RepositoryMockDeleteChatCacheMetadataParamPtrs
	expectationOrigins RepositoryMockDeleteChatCacheMetadataExpectationOrigins
	results            *RepositoryMockDeleteChatCacheMetadataResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteChatCacheMetadataParams contains parameters of the Repository.DeleteChatCacheMetadata
type RepositoryMockDeleteChatCacheMetadataParams struct {
	ctx      context.Context
	kbUID    types.KBUIDType
	fileUIDs []types.FileUIDType
}

// RepositoryMockDeleteChatCacheMetadataParamPtrs contains pointers to parameters of the Repository.DeleteChatCacheMetadata
type RepositoryMockDeleteChatCacheMetadataParamPtrs struct {
	ctx      *context.Context
	kbUID    *types.KBUIDType
	fileUIDs *[]types.FileUIDType
}

// RepositoryMockDeleteChatCacheMetadataResults contains results of the Repository.DeleteChatCacheMetadata
type RepositoryMockDeleteChatCacheMetadataResults struct {
	err error
}

// RepositoryMockDeleteChatCacheMetadataOrigins contains origins of expectations of the Repository.DeleteChatCacheMetadata
type RepositoryMockDeleteChatCacheMetadataExpectationOrigins struct {
	origin         string
	originCtx      string
	originKbUID    string
	originFileUIDs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteChatCacheMetadata *mRepositoryMockDeleteChatCacheMetadata) Optional() *mRepositoryMockDeleteChatCacheMetadata {
	mmDeleteChatCacheMetadata.optional = true
	return mmDeleteChatCacheMetadata
}

// Expect sets up expected params for Repository.DeleteChatCacheMetadata
func (mmDeleteChatCacheMetadata *mRepositoryMockDeleteChatCacheMetadata) Expect(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType) *mRepositoryMockDeleteChatCacheMetadata {
	if mmDeleteChatCacheMetadata.mock.funcDeleteChatCacheMetadata != nil {
		mmDeleteChatCacheMetadata.mock.t.Fatalf("RepositoryMock.DeleteChatCacheMetadata mock is already set by Set")
	}

	if mmDeleteChatCacheMetadata.defaultExpectation == nil {
		mmDeleteChatCacheMetadata.defaultExpectation = &RepositoryMockDeleteChatCacheMetadataExpectation{}
	}

	if mmDeleteChatCacheMetadata.defaultExpectation.paramPtrs != nil {
		mmDeleteChatCacheMetadata.mock.t.Fatalf("RepositoryMock.DeleteChatCacheMetadata mock is already set by ExpectParams functions")
	}

	mmDeleteChatCacheMetadata.defaultExpectation.params = &RepositoryMockDeleteChatCacheMetadataParams{ctx, kbUID, fileUIDs}
	mmDeleteChatCacheMetadata.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteChatCacheMetadata.expectations {
		if minimock.Equal(e.params, mmDeleteChatCacheMetadata.defaultExpectation.params) {
			mmDeleteChatCacheMetadata.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChatCacheMetadata.defaultExpectation.params)
		}
	}

	return mmDeleteChatCacheMetadata
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteChatCacheMetadata
func (mmDeleteChatCacheMetadata *mRepositoryMockDeleteChatCacheMetadata) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteChatCacheMetadata {
	if mmDeleteChatCacheMetadata.mock.funcDeleteChatCacheMetadata != nil {
		mmDeleteChatCacheMetadata.mock.t.Fatalf("RepositoryMock.DeleteChatCacheMetadata mock is already set by Set")
	}

	if mmDeleteChatCacheMetadata.defaultExpectation == nil {
		mmDeleteChatCacheMetadata.defaultExpectation = &RepositoryMockDeleteChatCacheMetadataExpectation{}
	}

	if mmDeleteChatCacheMetadata.defaultExpectation.params != nil {
		mmDeleteChatCacheMetadata.mock.t.Fatalf("RepositoryMock.DeleteChatCacheMetadata mock is already set by Expect")
	}

	if mmDeleteChatCacheMetadata.defaultExpectation.paramPtrs == nil {
		mmDeleteChatCacheMetadata.defaultExpectation.paramPtrs = &RepositoryMockDeleteChatCacheMetadataParamPtrs{}
	}
	mmDeleteChatCacheMetadata.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteChatCacheMetadata.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteChatCacheMetadata
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.DeleteChatCacheMetadata
func (mmDeleteChatCacheMetadata *mRepositoryMockDeleteChatCacheMetadata) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockDeleteChatCacheMetadata {
	if mmDeleteChatCacheMetadata.mock.funcDeleteChatCacheMetadata != nil {
		mmDeleteChatCacheMetadata.mock.t.Fatalf("RepositoryMock.DeleteChatCacheMetadata mock is already set by Set")
	}

	if mmDeleteChatCacheMetadata.defaultExpectation == nil {
		mmDeleteChatCacheMetadata.defaultExpectation = &RepositoryMockDeleteChatCacheMetadataExpectation{}
	}

	if mmDeleteChatCacheMetadata.defaultExpectation.params != nil {
		mmDeleteChatCacheMetadata.mock.t.Fatalf("RepositoryMock.DeleteChatCacheMetadata mock is already set by Expect")
	}

	if mmDeleteChatCacheMetadata.defaultExpectation.paramPtrs == nil {
		mmDeleteChatCacheMetadata.defaultExpectation.paramPtrs = &RepositoryMockDeleteChatCacheMetadataParamPtrs{}
	}
	mmDeleteChatCacheMetadata.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmDeleteChatCacheMetadata.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmDeleteChatCacheMetadata
}

// ExpectFileUIDsParam3 sets up expected param fileUIDs for Repository.DeleteChatCacheMetadata
func (mmDeleteChatCacheMetadata *mRepositoryMockDeleteChatCacheMetadata) ExpectFileUIDsParam3(fileUIDs []types.FileUIDType) *mRepositoryMockDeleteChatCacheMetadata {
	if mmDeleteChatCacheMetadata.mock.funcDeleteChatCacheMetadata != nil {
		mmDeleteChatCacheMetadata.mock.t.Fatalf("RepositoryMock.DeleteChatCacheMetadata mock is already set by Set")
	}

	if mmDeleteChatCacheMetadata.defaultExpectation == nil {
		mmDeleteChatCacheMetadata.defaultExpectation = &RepositoryMockDeleteChatCacheMetadataExpectation{}
	}

	if mmDeleteChatCacheMetadata.defaultExpectation.params != nil {
		mmDeleteChatCacheMetadata.mock.t.Fatalf("RepositoryMock.DeleteChatCacheMetadata mock is already set by Expect")
	}

	if mmDeleteChatCacheMetadata.defaultExpectation.paramPtrs == nil {
		mmDeleteChatCacheMetadata.defaultExpectation.paramPtrs = &RepositoryMockDeleteChatCacheMetadataParamPtrs{}
	}
	mmDeleteChatCacheMetadata.defaultExpectation.paramPtrs.fileUIDs = &fileUIDs
	mmDeleteChatCacheMetadata.defaultExpectation.expectationOrigins.originFileUIDs = minimock.CallerInfo(1)

	return mmDeleteChatCacheMetadata
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteChatCacheMetadata
func (mmDeleteChatCacheMetadata *mRepositoryMockDeleteChatCacheMetadata) Inspect(f func(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType)) *mRepositoryMockDeleteChatCacheMetadata {
	if mmDeleteChatCacheMetadata.mock.inspectFuncDeleteChatCacheMetadata != nil {
		mmDeleteChatCacheMetadata.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteChatCacheMetadata")
	}

	mmDeleteChatCacheMetadata.mock.inspectFuncDeleteChatCacheMetadata = f

	return mmDeleteChatCacheMetadata
}

// Return sets up results that will be returned by Repository.DeleteChatCacheMetadata
func (mmDeleteChatCacheMetadata *mRepositoryMockDeleteChatCacheMetadata) Return(err error) *RepositoryMock {
	if mmDeleteChatCacheMetadata.mock.funcDeleteChatCacheMetadata != nil {
		mmDeleteChatCacheMetadata.mock.t.Fatalf("RepositoryMock.DeleteChatCacheMetadata mock is already set by Set")
	}

	if mmDeleteChatCacheMetadata.defaultExpectation == nil {
		mmDeleteChatCacheMetadata.defaultExpectation = &RepositoryMockDeleteChatCacheMetadataExpectation{mock: mmDeleteChatCacheMetadata.mock}
	}
	mmDeleteChatCacheMetadata.defaultExpectation.results = &RepositoryMockDeleteChatCacheMetadataResults{err}
	mmDeleteChatCacheMetadata.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteChatCacheMetadata.mock
}

// Set uses given function f to mock the Repository.DeleteChatCacheMetadata method
func (mmDeleteChatCacheMetadata *mRepositoryMockDeleteChatCacheMetadata) Set(f func(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType) (err error)) *RepositoryMock {
	if mmDeleteChatCacheMetadata.defaultExpectation != nil {
		mmDeleteChatCacheMetadata.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteChatCacheMetadata method")
	}

	if len(mmDeleteChatCacheMetadata.expectations) > 0 {
		mmDeleteChatCacheMetadata.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteChatCacheMetadata method")
	}

	mmDeleteChatCacheMetadata.mock.funcDeleteChatCacheMetadata = f
	mmDeleteChatCacheMetadata.mock.funcDeleteChatCacheMetadataOrigin = minimock.CallerInfo(1)
	return mmDeleteChatCacheMetadata.mock
}

// When sets expectation for the Repository.DeleteChatCacheMetadata which will trigger the result defined by the following
// Then helper
func (mmDeleteChatCacheMetadata *mRepositoryMockDeleteChatCacheMetadata) When(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType) *RepositoryMockDeleteChatCacheMetadataExpectation {
	if mmDeleteChatCacheMetadata.mock.funcDeleteChatCacheMetadata != nil {
		mmDeleteChatCacheMetadata.mock.t.Fatalf("RepositoryMock.DeleteChatCacheMetadata mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteChatCacheMetadataExpectation{
		mock:               mmDeleteChatCacheMetadata.mock,
		params:             &RepositoryMockDeleteChatCacheMetadataParams{ctx, kbUID, fileUIDs},
		expectationOrigins: RepositoryMockDeleteChatCacheMetadataExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteChatCacheMetadata.expectations = append(mmDeleteChatCacheMetadata.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteChatCacheMetadata return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteChatCacheMetadataExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteChatCacheMetadataResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteChatCacheMetadata should be invoked
func (mmDeleteChatCacheMetadata *mRepositoryMockDeleteChatCacheMetadata) Times(n uint64) *mRepositoryMockDeleteChatCacheMetadata {
	if n == 0 {
		mmDeleteChatCacheMetadata.mock.t.Fatalf("Times of RepositoryMock.DeleteChatCacheMetadata mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteChatCacheMetadata.expectedInvocations, n)
	mmDeleteChatCacheMetadata.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteChatCacheMetadata
}

func (mmDeleteChatCacheMetadata *mRepositoryMockDeleteChatCacheMetadata) invocationsDone() bool {
	if len(mmDeleteChatCacheMetadata.expectations) == 0 && mmDeleteChatCacheMetadata.defaultExpectation == nil && mmDeleteChatCacheMetadata.mock.funcDeleteChatCacheMetadata == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteChatCacheMetadata.mock.afterDeleteChatCacheMetadataCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteChatCacheMetadata.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteChatCacheMetadata implements mm_repository.Repository
func (mmDeleteChatCacheMetadata *RepositoryMock) DeleteChatCacheMetadata(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType) (err error) {
	mm_atomic.AddUint64(&mmDeleteChatCacheMetadata.beforeDeleteChatCacheMetadataCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChatCacheMetadata.afterDeleteChatCacheMetadataCounter, 1)

	mmDeleteChatCacheMetadata.t.Helper()

	if mmDeleteChatCacheMetadata.inspectFuncDeleteChatCacheMetadata != nil {
		mmDeleteChatCacheMetadata.inspectFuncDeleteChatCacheMetadata(ctx, kbUID, fileUIDs)
	}

	mm_params := RepositoryMockDeleteChatCacheMetadataParams{ctx, kbUID, fileUIDs}

	// Record call args
	mmDeleteChatCacheMetadata.DeleteChatCacheMetadataMock.mutex.Lock()
	mmDeleteChatCacheMetadata.DeleteChatCacheMetadataMock.callArgs = append(mmDeleteChatCacheMetadata.DeleteChatCacheMetadataMock.callArgs, &mm_params)
	mmDeleteChatCacheMetadata.DeleteChatCacheMetadataMock.mutex.Unlock()

	for _, e := range mmDeleteChatCacheMetadata.DeleteChatCacheMetadataMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChatCacheMetadata.DeleteChatCacheMetadataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChatCacheMetadata.DeleteChatCacheMetadataMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChatCacheMetadata.DeleteChatCacheMetadataMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteChatCacheMetadata.DeleteChatCacheMetadataMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteChatCacheMetadataParams{ctx, kbUID, fileUIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteChatCacheMetadata.t.Errorf("RepositoryMock.DeleteChatCacheMetadata got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteChatCacheMetadata.DeleteChatCacheMetadataMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmDeleteChatCacheMetadata.t.Errorf("RepositoryMock.DeleteChatCacheMetadata got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteChatCacheMetadata.DeleteChatCacheMetadataMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.fileUIDs != nil && !minimock.Equal(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs) {
				mmDeleteChatCacheMetadata.t.Errorf("RepositoryMock.DeleteChatCacheMetadata got unexpected parameter fileUIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteChatCacheMetadata.DeleteChatCacheMetadataMock.defaultExpectation.expectationOrigins.originFileUIDs, *mm_want_ptrs.fileUIDs, mm_got.fileUIDs, minimock.Diff(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChatCacheMetadata.t.Errorf("RepositoryMock.DeleteChatCacheMetadata got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteChatCacheMetadata.DeleteChatCacheMetadataMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChatCacheMetadata.DeleteChatCacheMetadataMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChatCacheMetadata.t.Fatal("No results are set for the RepositoryMock.DeleteChatCacheMetadata")
		}
		return (*mm_results).err
	}
	if mmDeleteChatCacheMetadata.funcDeleteChatCacheMetadata != nil {
		return mmDeleteChatCacheMetadata.funcDeleteChatCacheMetadata(ctx, kbUID, fileUIDs)
	}
	mmDeleteChatCacheMetadata.t.Fatalf("Unexpected call to RepositoryMock.DeleteChatCacheMetadata. %v %v %v", ctx, kbUID, fileUIDs)
	return
}

// DeleteChatCacheMetadataAfterCounter returns a count of finished RepositoryMock.DeleteChatCacheMetadata invocations
func (mmDeleteChatCacheMetadata *RepositoryMock) DeleteChatCacheMetadataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChatCacheMetadata.afterDeleteChatCacheMetadataCounter)
}

// DeleteChatCacheMetadataBeforeCounter returns a count of RepositoryMock.DeleteChatCacheMetadata invocations
func (mmDeleteChatCacheMetadata *RepositoryMock) DeleteChatCacheMetadataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChatCacheMetadata.beforeDeleteChatCacheMetadataCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteChatCacheMetadata.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChatCacheMetadata *mRepositoryMockDeleteChatCacheMetadata) Calls() []*RepositoryMockDeleteChatCacheMetadataParams {
	mmDeleteChatCacheMetadata.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteChatCacheMetadataParams, len(mmDeleteChatCacheMetadata.callArgs))
	copy(argCopy, mmDeleteChatCacheMetadata.callArgs)

	mmDeleteChatCacheMetadata.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChatCacheMetadataDone returns true if the count of the DeleteChatCacheMetadata invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteChatCacheMetadataDone() bool {
	if m.DeleteChatCacheMetadataMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteChatCacheMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteChatCacheMetadataMock.invocationsDone()
}

// MinimockDeleteChatCacheMetadataInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteChatCacheMetadataInspect() {
	for _, e := range m.DeleteChatCacheMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteChatCacheMetadata at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteChatCacheMetadataCounter := mm_atomic.LoadUint64(&m.afterDeleteChatCacheMetadataCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatCacheMetadataMock.defaultExpectation != nil && afterDeleteChatCacheMetadataCounter < 1 {
		if m.DeleteChatCacheMetadataMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteChatCacheMetadata at\n%s", m.DeleteChatCacheMetadataMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteChatCacheMetadata at\n%s with params: %#v", m.DeleteChatCacheMetadataMock.defaultExpectation.expectationOrigins.origin, *m.DeleteChatCacheMetadataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChatCacheMetadata != nil && afterDeleteChatCacheMetadataCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteChatCacheMetadata at\n%s", m.funcDeleteChatCacheMetadataOrigin)
	}

	if !m.DeleteChatCacheMetadataMock.invocationsDone() && afterDeleteChatCacheMetadataCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteChatCacheMetadata at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteChatCacheMetadataMock.expectedInvocations), m.DeleteChatCacheMetadataMock.expectedInvocationsOrigin, afterDeleteChatCacheMetadataCounter)
	}
}

type mRepositoryMockDeleteConvertedFile struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteConvertedFileExpectation
	expectations       []*RepositoryMockDeleteConvertedFileExpectation

	callArgs []*RepositoryMockDeleteConvertedFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteConvertedFileExpectation specifies expectation struct of the Repository.DeleteConvertedFile
type RepositoryMockDeleteConvertedFileExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteConvertedFileParams
	paramPtrs          *RepositoryMockDeleteConvertedFileParamPtrs
	expectationOrigins RepositoryMockDeleteConvertedFileExpectationOrigins
	results            *RepositoryMockDeleteConvertedFileResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteConvertedFileParams contains parameters of the Repository.DeleteConvertedFile
type RepositoryMockDeleteConvertedFileParams struct {
	ctx context.Context
	uid types.ConvertedFileUIDType
}

// RepositoryMockDeleteConvertedFileParamPtrs contains pointers to parameters of the Repository.DeleteConvertedFile
type RepositoryMockDeleteConvertedFileParamPtrs struct {
	ctx *context.Context
	uid *types.ConvertedFileUIDType
}

// RepositoryMockDeleteConvertedFileResults contains results of the Repository.DeleteConvertedFile
type RepositoryMockDeleteConvertedFileResults struct {
	err error
}

// RepositoryMockDeleteConvertedFileOrigins contains origins of expectations of the Repository.DeleteConvertedFile
type RepositoryMockDeleteConvertedFileExpectationOrigins struct {
	origin    string
	originCtx string
	originUid string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteConvertedFile *mRepositoryMockDeleteConvertedFile) Optional() *mRepositoryMockDeleteConvertedFile {
	mmDeleteConvertedFile.optional = true
	return mmDeleteConvertedFile
}

// Expect sets up expected params for Repository.DeleteConvertedFile
func (mmDeleteConvertedFile *mRepositoryMockDeleteConvertedFile) Expect(ctx context.Context, uid types.ConvertedFileUIDType) *mRepositoryMockDeleteConvertedFile {
	if mmDeleteConvertedFile.mock.funcDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryMock.DeleteConvertedFile mock is already set by Set")
	}

	if mmDeleteConvertedFile.defaultExpectation == nil {
		mmDeleteConvertedFile.defaultExpectation = &RepositoryMockDeleteConvertedFileExpectation{}
	}

	if mmDeleteConvertedFile.defaultExpectation.paramPtrs != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryMock.DeleteConvertedFile mock is already set by ExpectParams functions")
	}

	mmDeleteConvertedFile.defaultExpectation.params = &RepositoryMockDeleteConvertedFileParams{ctx, uid}
	mmDeleteConvertedFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteConvertedFile.expectations {
		if minimock.Equal(e.params, mmDeleteConvertedFile.defaultExpectation.params) {
			mmDeleteConvertedFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteConvertedFile.defaultExpectation.params)
		}
	}

	return mmDeleteConvertedFile
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteConvertedFile
func (mmDeleteConvertedFile *mRepositoryMockDeleteConvertedFile) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteConvertedFile {
	if mmDeleteConvertedFile.mock.funcDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryMock.DeleteConvertedFile mock is already set by Set")
	}

	if mmDeleteConvertedFile.defaultExpectation == nil {
		mmDeleteConvertedFile.defaultExpectation = &RepositoryMockDeleteConvertedFileExpectation{}
	}

	if mmDeleteConvertedFile.defaultExpectation.params != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryMock.DeleteConvertedFile mock is already set by Expect")
	}

	if mmDeleteConvertedFile.defaultExpectation.paramPtrs == nil {
		mmDeleteConvertedFile.defaultExpectation.paramPtrs = &RepositoryMockDeleteConvertedFileParamPtrs{}
	}
	mmDeleteConvertedFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteConvertedFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteConvertedFile
}

// ExpectUidParam2 sets up expected param uid for Repository.DeleteConvertedFile
func (mmDeleteConvertedFile *mRepositoryMockDeleteConvertedFile) ExpectUidParam2(uid types.ConvertedFileUIDType) *mRepositoryMockDeleteConvertedFile {
	if mmDeleteConvertedFile.mock.funcDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryMock.DeleteConvertedFile mock is already set by Set")
	}

	if mmDeleteConvertedFile.defaultExpectation == nil {
		mmDeleteConvertedFile.defaultExpectation = &RepositoryMockDeleteConvertedFileExpectation{}
	}

	if mmDeleteConvertedFile.defaultExpectation.params != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryMock.DeleteConvertedFile mock is already set by Expect")
	}

	if mmDeleteConvertedFile.defaultExpectation.paramPtrs == nil {
		mmDeleteConvertedFile.defaultExpectation.paramPtrs = &RepositoryMockDeleteConvertedFileParamPtrs{}
	}
	mmDeleteConvertedFile.defaultExpectation.paramPtrs.uid = &uid
	mmDeleteConvertedFile.defaultExpectation.expectationOrigins.originUid = minimock.CallerInfo(1)

	return mmDeleteConvertedFile
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteConvertedFile
func (mmDeleteConvertedFile *mRepositoryMockDeleteConvertedFile) Inspect(f func(ctx context.Context, uid types.ConvertedFileUIDType)) *mRepositoryMockDeleteConvertedFile {
	if mmDeleteConvertedFile.mock.inspectFuncDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteConvertedFile")
	}

	mmDeleteConvertedFile.mock.inspectFuncDeleteConvertedFile = f

	return mmDeleteConvertedFile
}

// Return sets up results that will be returned by Repository.DeleteConvertedFile
func (mmDeleteConvertedFile *mRepositoryMockDeleteConvertedFile) Return(err error) *RepositoryMock {
	if mmDeleteConvertedFile.mock.funcDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryMock.DeleteConvertedFile mock is already set by Set")
	}

	if mmDeleteConvertedFile.defaultExpectation == nil {
		mmDeleteConvertedFile.defaultExpectation = &RepositoryMockDeleteConvertedFileExpectation{mock: mmDeleteConvertedFile.mock}
	}
	mmDeleteConvertedFile.defaultExpectation.results = &RepositoryMockDeleteConvertedFileResults{err}
	mmDeleteConvertedFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteConvertedFile.mock
}

// Set uses given function f to mock the Repository.DeleteConvertedFile method
func (mmDeleteConvertedFile *mRepositoryMockDeleteConvertedFile) Set(f func(ctx context.Context, uid types.ConvertedFileUIDType) (err error)) *RepositoryMock {
	if mmDeleteConvertedFile.defaultExpectation != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteConvertedFile method")
	}

	if len(mmDeleteConvertedFile.expectations) > 0 {
		mmDeleteConvertedFile.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteConvertedFile method")
	}

	mmDeleteConvertedFile.mock.funcDeleteConvertedFile = f
	mmDeleteConvertedFile.mock.funcDeleteConvertedFileOrigin = minimock.CallerInfo(1)
	return mmDeleteConvertedFile.mock
}

// When sets expectation for the Repository.DeleteConvertedFile which will trigger the result defined by the following
// Then helper
func (mmDeleteConvertedFile *mRepositoryMockDeleteConvertedFile) When(ctx context.Context, uid types.ConvertedFileUIDType) *RepositoryMockDeleteConvertedFileExpectation {
	if mmDeleteConvertedFile.mock.funcDeleteConvertedFile != nil {
		mmDeleteConvertedFile.mock.t.Fatalf("RepositoryMock.DeleteConvertedFile mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteConvertedFileExpectation{
		mock:               mmDeleteConvertedFile.mock,
		params:             &RepositoryMockDeleteConvertedFileParams{ctx, uid},
		expectationOrigins: RepositoryMockDeleteConvertedFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteConvertedFile.expectations = append(mmDeleteConvertedFile.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteConvertedFile return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteConvertedFileExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteConvertedFileResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteConvertedFile should be invoked
func (mmDeleteConvertedFile *mRepositoryMockDeleteConvertedFile) Times(n uint64) *mRepositoryMockDeleteConvertedFile {
	if n == 0 {
		mmDeleteConvertedFile.mock.t.Fatalf("Times of RepositoryMock.DeleteConvertedFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteConvertedFile.expectedInvocations, n)
	mmDeleteConvertedFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteConvertedFile
}

func (mmDeleteConvertedFile *mRepositoryMockDeleteConvertedFile) invocationsDone() bool {
	if len(mmDeleteConvertedFile.expectations) == 0 && mmDeleteConvertedFile.defaultExpectation == nil && mmDeleteConvertedFile.mock.funcDeleteConvertedFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteConvertedFile.mock.afterDeleteConvertedFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteConvertedFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteConvertedFile implements mm_repository.Repository
func (mmDeleteConvertedFile *RepositoryMock) DeleteConvertedFile(ctx context.Context, uid types.ConvertedFileUIDType) (err error) {
	mm_atomic.AddUint64(&mmDeleteConvertedFile.beforeDeleteConvertedFileCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteConvertedFile.afterDeleteConvertedFileCounter, 1)

	mmDeleteConvertedFile.t.Helper()

	if mmDeleteConvertedFile.inspectFuncDeleteConvertedFile != nil {
		mmDeleteConvertedFile.inspectFuncDeleteConvertedFile(ctx, uid)
	}

	mm_params := RepositoryMockDeleteConvertedFileParams{ctx, uid}

	// Record call args
	mmDeleteConvertedFile.DeleteConvertedFileMock.mutex.Lock()
	mmDeleteConvertedFile.DeleteConvertedFileMock.callArgs = append(mmDeleteConvertedFile.DeleteConvertedFileMock.callArgs, &mm_params)
	mmDeleteConvertedFile.DeleteConvertedFileMock.mutex.Unlock()

	for _, e := range mmDeleteConvertedFile.DeleteConvertedFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteConvertedFileParams{ctx, uid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteConvertedFile.t.Errorf("RepositoryMock.DeleteConvertedFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmDeleteConvertedFile.t.Errorf("RepositoryMock.DeleteConvertedFile got unexpected parameter uid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation.expectationOrigins.originUid, *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteConvertedFile.t.Errorf("RepositoryMock.DeleteConvertedFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteConvertedFile.DeleteConvertedFileMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteConvertedFile.t.Fatal("No results are set for the RepositoryMock.DeleteConvertedFile")
		}
		return (*mm_results).err
	}
	if mmDeleteConvertedFile.funcDeleteConvertedFile != nil {
		return mmDeleteConvertedFile.funcDeleteConvertedFile(ctx, uid)
	}
	mmDeleteConvertedFile.t.Fatalf("Unexpected call to RepositoryMock.DeleteConvertedFile. %v %v", ctx, uid)
	return
}

// DeleteConvertedFileAfterCounter returns a count of finished RepositoryMock.DeleteConvertedFile invocations
func (mmDeleteConvertedFile *RepositoryMock) DeleteConvertedFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteConvertedFile.afterDeleteConvertedFileCounter)
}

// DeleteConvertedFileBeforeCounter returns a count of RepositoryMock.DeleteConvertedFile invocations
func (mmDeleteConvertedFile *RepositoryMock) DeleteConvertedFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteConvertedFile.beforeDeleteConvertedFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteConvertedFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteConvertedFile *mRepositoryMockDeleteConvertedFile) Calls() []*RepositoryMockDeleteConvertedFileParams {
	mmDeleteConvertedFile.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteConvertedFileParams, len(mmDeleteConvertedFile.callArgs))
	copy(argCopy, mmDeleteConvertedFile.callArgs)

	mmDeleteConvertedFile.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteConvertedFileDone returns true if the count of the DeleteConvertedFile invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteConvertedFileDone() bool {
	if m.DeleteConvertedFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteConvertedFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteConvertedFileMock.invocationsDone()
}

// MinimockDeleteConvertedFileInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteConvertedFileInspect() {
	for _, e := range m.DeleteConvertedFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteConvertedFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteConvertedFileCounter := mm_atomic.LoadUint64(&m.afterDeleteConvertedFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteConvertedFileMock.defaultExpectation != nil && afterDeleteConvertedFileCounter < 1 {
		if m.DeleteConvertedFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteConvertedFile at\n%s", m.DeleteConvertedFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteConvertedFile at\n%s with params: %#v", m.DeleteConvertedFileMock.defaultExpectation.expectationOrigins.origin, *m.DeleteConvertedFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteConvertedFile != nil && afterDeleteConvertedFileCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteConvertedFile at\n%s", m.funcDeleteConvertedFileOrigin)
	}

	if !m.DeleteConvertedFileMock.invocationsDone() && afterDeleteConvertedFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteConvertedFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteConvertedFileMock.expectedInvocations), m.DeleteConvertedFileMock.expectedInvocationsOrigin, afterDeleteConvertedFileCounter)
	}
}

type mRepositoryMockDeleteEmbeddingsByKBFileUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteEmbeddingsByKBFileUIDExpectation
	expectations       []*RepositoryMockDeleteEmbeddingsByKBFileUIDExpectation

	callArgs []*RepositoryMockDeleteEmbeddingsByKBFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteEmbeddingsByKBFileUIDExpectation specifies expectation struct of the Repository.DeleteEmbeddingsByKBFileUID
type RepositoryMockDeleteEmbeddingsByKBFileUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteEmbeddingsByKBFileUIDParams
	paramPtrs          *RepositoryMockDeleteEmbeddingsByKBFileUIDParamPtrs
	expectationOrigins RepositoryMockDeleteEmbeddingsByKBFileUIDExpectationOrigins
	results            *RepositoryMockDeleteEmbeddingsByKBFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteEmbeddingsByKBFileUIDParams contains parameters of the Repository.DeleteEmbeddingsByKBFileUID
type RepositoryMockDeleteEmbeddingsByKBFileUIDParams struct {
	ctx       context.Context
	kbFileUID types.FileUIDType
}

// RepositoryMockDeleteEmbeddingsByKBFileUIDParamPtrs contains pointers to parameters of the Repository.DeleteEmbeddingsByKBFileUID
type RepositoryMockDeleteEmbeddingsByKBFileUIDParamPtrs struct {
	ctx       *context.Context
	kbFileUID *types.FileUIDType
}

// RepositoryMockDeleteEmbeddingsByKBFileUIDResults contains results of the Repository.DeleteEmbeddingsByKBFileUID
type RepositoryMockDeleteEmbeddingsByKBFileUIDResults struct {
	err error
}

// RepositoryMockDeleteEmbeddingsByKBFileUIDOrigins contains origins of expectations of the Repository.DeleteEmbeddingsByKBFileUID
type RepositoryMockDeleteEmbeddingsByKBFileUIDExpectationOrigins struct {
	origin          string
	originCtx       string
	originKbFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteEmbeddingsByKBFileUID *mRepositoryMockDeleteEmbeddingsByKBFileUID) Optional() *mRepositoryMockDeleteEmbeddingsByKBFileUID {
	mmDeleteEmbeddingsByKBFileUID.optional = true
	return mmDeleteEmbeddingsByKBFileUID
}

// Expect sets up expected params for Repository.DeleteEmbeddingsByKBFileUID
func (mmDeleteEmbeddingsByKBFileUID *mRepositoryMockDeleteEmbeddingsByKBFileUID) Expect(ctx context.Context, kbFileUID types.FileUIDType) *mRepositoryMockDeleteEmbeddingsByKBFileUID {
	if mmDeleteEmbeddingsByKBFileUID.mock.funcDeleteEmbeddingsByKBFileUID != nil {
		mmDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsByKBFileUID mock is already set by Set")
	}

	if mmDeleteEmbeddingsByKBFileUID.defaultExpectation == nil {
		mmDeleteEmbeddingsByKBFileUID.defaultExpectation = &RepositoryMockDeleteEmbeddingsByKBFileUIDExpectation{}
	}

	if mmDeleteEmbeddingsByKBFileUID.defaultExpectation.paramPtrs != nil {
		mmDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsByKBFileUID mock is already set by ExpectParams functions")
	}

	mmDeleteEmbeddingsByKBFileUID.defaultExpectation.params = &RepositoryMockDeleteEmbeddingsByKBFileUIDParams{ctx, kbFileUID}
	mmDeleteEmbeddingsByKBFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteEmbeddingsByKBFileUID.expectations {
		if minimock.Equal(e.params, mmDeleteEmbeddingsByKBFileUID.defaultExpectation.params) {
			mmDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteEmbeddingsByKBFileUID.defaultExpectation.params)
		}
	}

	return mmDeleteEmbeddingsByKBFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteEmbeddingsByKBFileUID
func (mmDeleteEmbeddingsByKBFileUID *mRepositoryMockDeleteEmbeddingsByKBFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteEmbeddingsByKBFileUID {
	if mmDeleteEmbeddingsByKBFileUID.mock.funcDeleteEmbeddingsByKBFileUID != nil {
		mmDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsByKBFileUID mock is already set by Set")
	}

	if mmDeleteEmbeddingsByKBFileUID.defaultExpectation == nil {
		mmDeleteEmbeddingsByKBFileUID.defaultExpectation = &RepositoryMockDeleteEmbeddingsByKBFileUIDExpectation{}
	}

	if mmDeleteEmbeddingsByKBFileUID.defaultExpectation.params != nil {
		mmDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsByKBFileUID mock is already set by Expect")
	}

	if mmDeleteEmbeddingsByKBFileUID.defaultExpectation.paramPtrs == nil {
		mmDeleteEmbeddingsByKBFileUID.defaultExpectation.paramPtrs = &RepositoryMockDeleteEmbeddingsByKBFileUIDParamPtrs{}
	}
	mmDeleteEmbeddingsByKBFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteEmbeddingsByKBFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteEmbeddingsByKBFileUID
}

// ExpectKbFileUIDParam2 sets up expected param kbFileUID for Repository.DeleteEmbeddingsByKBFileUID
func (mmDeleteEmbeddingsByKBFileUID *mRepositoryMockDeleteEmbeddingsByKBFileUID) ExpectKbFileUIDParam2(kbFileUID types.FileUIDType) *mRepositoryMockDeleteEmbeddingsByKBFileUID {
	if mmDeleteEmbeddingsByKBFileUID.mock.funcDeleteEmbeddingsByKBFileUID != nil {
		mmDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsByKBFileUID mock is already set by Set")
	}

	if mmDeleteEmbeddingsByKBFileUID.defaultExpectation == nil {
		mmDeleteEmbeddingsByKBFileUID.defaultExpectation = &RepositoryMockDeleteEmbeddingsByKBFileUIDExpectation{}
	}

	if mmDeleteEmbeddingsByKBFileUID.defaultExpectation.params != nil {
		mmDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsByKBFileUID mock is already set by Expect")
	}

	if mmDeleteEmbeddingsByKBFileUID.defaultExpectation.paramPtrs == nil {
		mmDeleteEmbeddingsByKBFileUID.defaultExpectation.paramPtrs = &RepositoryMockDeleteEmbeddingsByKBFileUIDParamPtrs{}
	}
	mmDeleteEmbeddingsByKBFileUID.defaultExpectation.paramPtrs.kbFileUID = &kbFileUID
	mmDeleteEmbeddingsByKBFileUID.defaultExpectation.expectationOrigins.originKbFileUID = minimock.CallerInfo(1)

	return mmDeleteEmbeddingsByKBFileUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteEmbeddingsByKBFileUID
func (mmDeleteEmbeddingsByKBFileUID *mRepositoryMockDeleteEmbeddingsByKBFileUID) Inspect(f func(ctx context.Context, kbFileUID types.FileUIDType)) *mRepositoryMockDeleteEmbeddingsByKBFileUID {
	if mmDeleteEmbeddingsByKBFileUID.mock.inspectFuncDeleteEmbeddingsByKBFileUID != nil {
		mmDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteEmbeddingsByKBFileUID")
	}

	mmDeleteEmbeddingsByKBFileUID.mock.inspectFuncDeleteEmbeddingsByKBFileUID = f

	return mmDeleteEmbeddingsByKBFileUID
}

// Return sets up results that will be returned by Repository.DeleteEmbeddingsByKBFileUID
func (mmDeleteEmbeddingsByKBFileUID *mRepositoryMockDeleteEmbeddingsByKBFileUID) Return(err error) *RepositoryMock {
	if mmDeleteEmbeddingsByKBFileUID.mock.funcDeleteEmbeddingsByKBFileUID != nil {
		mmDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsByKBFileUID mock is already set by Set")
	}

	if mmDeleteEmbeddingsByKBFileUID.defaultExpectation == nil {
		mmDeleteEmbeddingsByKBFileUID.defaultExpectation = &RepositoryMockDeleteEmbeddingsByKBFileUIDExpectation{mock: mmDeleteEmbeddingsByKBFileUID.mock}
	}
	mmDeleteEmbeddingsByKBFileUID.defaultExpectation.results = &RepositoryMockDeleteEmbeddingsByKBFileUIDResults{err}
	mmDeleteEmbeddingsByKBFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteEmbeddingsByKBFileUID.mock
}

// Set uses given function f to mock the Repository.DeleteEmbeddingsByKBFileUID method
func (mmDeleteEmbeddingsByKBFileUID *mRepositoryMockDeleteEmbeddingsByKBFileUID) Set(f func(ctx context.Context, kbFileUID types.FileUIDType) (err error)) *RepositoryMock {
	if mmDeleteEmbeddingsByKBFileUID.defaultExpectation != nil {
		mmDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteEmbeddingsByKBFileUID method")
	}

	if len(mmDeleteEmbeddingsByKBFileUID.expectations) > 0 {
		mmDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteEmbeddingsByKBFileUID method")
	}

	mmDeleteEmbeddingsByKBFileUID.mock.funcDeleteEmbeddingsByKBFileUID = f
	mmDeleteEmbeddingsByKBFileUID.mock.funcDeleteEmbeddingsByKBFileUIDOrigin = minimock.CallerInfo(1)
	return mmDeleteEmbeddingsByKBFileUID.mock
}

// When sets expectation for the Repository.DeleteEmbeddingsByKBFileUID which will trigger the result defined by the following
// Then helper
func (mmDeleteEmbeddingsByKBFileUID *mRepositoryMockDeleteEmbeddingsByKBFileUID) When(ctx context.Context, kbFileUID types.FileUIDType) *RepositoryMockDeleteEmbeddingsByKBFileUIDExpectation {
	if mmDeleteEmbeddingsByKBFileUID.mock.funcDeleteEmbeddingsByKBFileUID != nil {
		mmDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsByKBFileUID mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteEmbeddingsByKBFileUIDExpectation{
		mock:               mmDeleteEmbeddingsByKBFileUID.mock,
		params:             &RepositoryMockDeleteEmbeddingsByKBFileUIDParams{ctx, kbFileUID},
		expectationOrigins: RepositoryMockDeleteEmbeddingsByKBFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteEmbeddingsByKBFileUID.expectations = append(mmDeleteEmbeddingsByKBFileUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteEmbeddingsByKBFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteEmbeddingsByKBFileUIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteEmbeddingsByKBFileUIDResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteEmbeddingsByKBFileUID should be invoked
func (mmDeleteEmbeddingsByKBFileUID *mRepositoryMockDeleteEmbeddingsByKBFileUID) Times(n uint64) *mRepositoryMockDeleteEmbeddingsByKBFileUID {
	if n == 0 {
		mmDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("Times of RepositoryMock.DeleteEmbeddingsByKBFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteEmbeddingsByKBFileUID.expectedInvocations, n)
	mmDeleteEmbeddingsByKBFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteEmbeddingsByKBFileUID
}

func (mmDeleteEmbeddingsByKBFileUID *mRepositoryMockDeleteEmbeddingsByKBFileUID) invocationsDone() bool {
	if len(mmDeleteEmbeddingsByKBFileUID.expectations) == 0 && mmDeleteEmbeddingsByKBFileUID.defaultExpectation == nil && mmDeleteEmbeddingsByKBFileUID.mock.funcDeleteEmbeddingsByKBFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteEmbeddingsByKBFileUID.mock.afterDeleteEmbeddingsByKBFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteEmbeddingsByKBFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteEmbeddingsByKBFileUID implements mm_repository.Repository
func (mmDeleteEmbeddingsByKBFileUID *RepositoryMock) DeleteEmbeddingsByKBFileUID(ctx context.Context, kbFileUID types.FileUIDType) (err error) {
	mm_atomic.AddUint64(&mmDeleteEmbeddingsByKBFileUID.beforeDeleteEmbeddingsByKBFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteEmbeddingsByKBFileUID.afterDeleteEmbeddingsByKBFileUIDCounter, 1)

	mmDeleteEmbeddingsByKBFileUID.t.Helper()

	if mmDeleteEmbeddingsByKBFileUID.inspectFuncDeleteEmbeddingsByKBFileUID != nil {
		mmDeleteEmbeddingsByKBFileUID.inspectFuncDeleteEmbeddingsByKBFileUID(ctx, kbFileUID)
	}

	mm_params := RepositoryMockDeleteEmbeddingsByKBFileUIDParams{ctx, kbFileUID}

	// Record call args
	mmDeleteEmbeddingsByKBFileUID.DeleteEmbeddingsByKBFileUIDMock.mutex.Lock()
	mmDeleteEmbeddingsByKBFileUID.DeleteEmbeddingsByKBFileUIDMock.callArgs = append(mmDeleteEmbeddingsByKBFileUID.DeleteEmbeddingsByKBFileUIDMock.callArgs, &mm_params)
	mmDeleteEmbeddingsByKBFileUID.DeleteEmbeddingsByKBFileUIDMock.mutex.Unlock()

	for _, e := range mmDeleteEmbeddingsByKBFileUID.DeleteEmbeddingsByKBFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteEmbeddingsByKBFileUID.DeleteEmbeddingsByKBFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteEmbeddingsByKBFileUID.DeleteEmbeddingsByKBFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteEmbeddingsByKBFileUID.DeleteEmbeddingsByKBFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteEmbeddingsByKBFileUID.DeleteEmbeddingsByKBFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteEmbeddingsByKBFileUIDParams{ctx, kbFileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteEmbeddingsByKBFileUID.t.Errorf("RepositoryMock.DeleteEmbeddingsByKBFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteEmbeddingsByKBFileUID.DeleteEmbeddingsByKBFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbFileUID != nil && !minimock.Equal(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID) {
				mmDeleteEmbeddingsByKBFileUID.t.Errorf("RepositoryMock.DeleteEmbeddingsByKBFileUID got unexpected parameter kbFileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteEmbeddingsByKBFileUID.DeleteEmbeddingsByKBFileUIDMock.defaultExpectation.expectationOrigins.originKbFileUID, *mm_want_ptrs.kbFileUID, mm_got.kbFileUID, minimock.Diff(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteEmbeddingsByKBFileUID.t.Errorf("RepositoryMock.DeleteEmbeddingsByKBFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteEmbeddingsByKBFileUID.DeleteEmbeddingsByKBFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteEmbeddingsByKBFileUID.DeleteEmbeddingsByKBFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteEmbeddingsByKBFileUID.t.Fatal("No results are set for the RepositoryMock.DeleteEmbeddingsByKBFileUID")
		}
		return (*mm_results).err
	}
	if mmDeleteEmbeddingsByKBFileUID.funcDeleteEmbeddingsByKBFileUID != nil {
		return mmDeleteEmbeddingsByKBFileUID.funcDeleteEmbeddingsByKBFileUID(ctx, kbFileUID)
	}
	mmDeleteEmbeddingsByKBFileUID.t.Fatalf("Unexpected call to RepositoryMock.DeleteEmbeddingsByKBFileUID. %v %v", ctx, kbFileUID)
	return
}

// DeleteEmbeddingsByKBFileUIDAfterCounter returns a count of finished RepositoryMock.DeleteEmbeddingsByKBFileUID invocations
func (mmDeleteEmbeddingsByKBFileUID *RepositoryMock) DeleteEmbeddingsByKBFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEmbeddingsByKBFileUID.afterDeleteEmbeddingsByKBFileUIDCounter)
}

// DeleteEmbeddingsByKBFileUIDBeforeCounter returns a count of RepositoryMock.DeleteEmbeddingsByKBFileUID invocations
func (mmDeleteEmbeddingsByKBFileUID *RepositoryMock) DeleteEmbeddingsByKBFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEmbeddingsByKBFileUID.beforeDeleteEmbeddingsByKBFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteEmbeddingsByKBFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteEmbeddingsByKBFileUID *mRepositoryMockDeleteEmbeddingsByKBFileUID) Calls() []*RepositoryMockDeleteEmbeddingsByKBFileUIDParams {
	mmDeleteEmbeddingsByKBFileUID.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteEmbeddingsByKBFileUIDParams, len(mmDeleteEmbeddingsByKBFileUID.callArgs))
	copy(argCopy, mmDeleteEmbeddingsByKBFileUID.callArgs)

	mmDeleteEmbeddingsByKBFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteEmbeddingsByKBFileUIDDone returns true if the count of the DeleteEmbeddingsByKBFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteEmbeddingsByKBFileUIDDone() bool {
	if m.DeleteEmbeddingsByKBFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteEmbeddingsByKBFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteEmbeddingsByKBFileUIDMock.invocationsDone()
}

// MinimockDeleteEmbeddingsByKBFileUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteEmbeddingsByKBFileUIDInspect() {
	for _, e := range m.DeleteEmbeddingsByKBFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteEmbeddingsByKBFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteEmbeddingsByKBFileUIDCounter := mm_atomic.LoadUint64(&m.afterDeleteEmbeddingsByKBFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteEmbeddingsByKBFileUIDMock.defaultExpectation != nil && afterDeleteEmbeddingsByKBFileUIDCounter < 1 {
		if m.DeleteEmbeddingsByKBFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteEmbeddingsByKBFileUID at\n%s", m.DeleteEmbeddingsByKBFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteEmbeddingsByKBFileUID at\n%s with params: %#v", m.DeleteEmbeddingsByKBFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.DeleteEmbeddingsByKBFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteEmbeddingsByKBFileUID != nil && afterDeleteEmbeddingsByKBFileUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteEmbeddingsByKBFileUID at\n%s", m.funcDeleteEmbeddingsByKBFileUIDOrigin)
	}

	if !m.DeleteEmbeddingsByKBFileUIDMock.invocationsDone() && afterDeleteEmbeddingsByKBFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteEmbeddingsByKBFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteEmbeddingsByKBFileUIDMock.expectedInvocations), m.DeleteEmbeddingsByKBFileUIDMock.expectedInvocationsOrigin, afterDeleteEmbeddingsByKBFileUIDCounter)
	}
}

type mRepositoryMockDeleteEmbeddingsWithFileUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteEmbeddingsWithFileUIDExpectation
	expectations       []*RepositoryMockDeleteEmbeddingsWithFileUIDExpectation

	callArgs []*RepositoryMockDeleteEmbeddingsWithFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteEmbeddingsWithFileUIDExpectation specifies expectation struct of the Repository.DeleteEmbeddingsWithFileUID
type RepositoryMockDeleteEmbeddingsWithFileUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteEmbeddingsWithFileUIDParams
	paramPtrs          *RepositoryMockDeleteEmbeddingsWithFileUIDParamPtrs
	expectationOrigins RepositoryMockDeleteEmbeddingsWithFileUIDExpectationOrigins
	results            *RepositoryMockDeleteEmbeddingsWithFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteEmbeddingsWithFileUIDParams contains parameters of the Repository.DeleteEmbeddingsWithFileUID
type RepositoryMockDeleteEmbeddingsWithFileUIDParams struct {
	ctx     context.Context
	collID  string
	fileUID types.FileUIDType
}

// RepositoryMockDeleteEmbeddingsWithFileUIDParamPtrs contains pointers to parameters of the Repository.DeleteEmbeddingsWithFileUID
type RepositoryMockDeleteEmbeddingsWithFileUIDParamPtrs struct {
	ctx     *context.Context
	collID  *string
	fileUID *types.FileUIDType
}

// RepositoryMockDeleteEmbeddingsWithFileUIDResults contains results of the Repository.DeleteEmbeddingsWithFileUID
type RepositoryMockDeleteEmbeddingsWithFileUIDResults struct {
	err error
}

// RepositoryMockDeleteEmbeddingsWithFileUIDOrigins contains origins of expectations of the Repository.DeleteEmbeddingsWithFileUID
type RepositoryMockDeleteEmbeddingsWithFileUIDExpectationOrigins struct {
	origin        string
	originCtx     string
	originCollID  string
	originFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteEmbeddingsWithFileUID *mRepositoryMockDeleteEmbeddingsWithFileUID) Optional() *mRepositoryMockDeleteEmbeddingsWithFileUID {
	mmDeleteEmbeddingsWithFileUID.optional = true
	return mmDeleteEmbeddingsWithFileUID
}

// Expect sets up expected params for Repository.DeleteEmbeddingsWithFileUID
func (mmDeleteEmbeddingsWithFileUID *mRepositoryMockDeleteEmbeddingsWithFileUID) Expect(ctx context.Context, collID string, fileUID types.FileUIDType) *mRepositoryMockDeleteEmbeddingsWithFileUID {
	if mmDeleteEmbeddingsWithFileUID.mock.funcDeleteEmbeddingsWithFileUID != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsWithFileUID mock is already set by Set")
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation == nil {
		mmDeleteEmbeddingsWithFileUID.defaultExpectation = &RepositoryMockDeleteEmbeddingsWithFileUIDExpectation{}
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsWithFileUID mock is already set by ExpectParams functions")
	}

	mmDeleteEmbeddingsWithFileUID.defaultExpectation.params = &RepositoryMockDeleteEmbeddingsWithFileUIDParams{ctx, collID, fileUID}
	mmDeleteEmbeddingsWithFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteEmbeddingsWithFileUID.expectations {
		if minimock.Equal(e.params, mmDeleteEmbeddingsWithFileUID.defaultExpectation.params) {
			mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteEmbeddingsWithFileUID.defaultExpectation.params)
		}
	}

	return mmDeleteEmbeddingsWithFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteEmbeddingsWithFileUID
func (mmDeleteEmbeddingsWithFileUID *mRepositoryMockDeleteEmbeddingsWithFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteEmbeddingsWithFileUID {
	if mmDeleteEmbeddingsWithFileUID.mock.funcDeleteEmbeddingsWithFileUID != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsWithFileUID mock is already set by Set")
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation == nil {
		mmDeleteEmbeddingsWithFileUID.defaultExpectation = &RepositoryMockDeleteEmbeddingsWithFileUIDExpectation{}
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation.params != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsWithFileUID mock is already set by Expect")
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs == nil {
		mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs = &RepositoryMockDeleteEmbeddingsWithFileUIDParamPtrs{}
	}
	mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteEmbeddingsWithFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteEmbeddingsWithFileUID
}

// ExpectCollIDParam2 sets up expected param collID for Repository.DeleteEmbeddingsWithFileUID
func (mmDeleteEmbeddingsWithFileUID *mRepositoryMockDeleteEmbeddingsWithFileUID) ExpectCollIDParam2(collID string) *mRepositoryMockDeleteEmbeddingsWithFileUID {
	if mmDeleteEmbeddingsWithFileUID.mock.funcDeleteEmbeddingsWithFileUID != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsWithFileUID mock is already set by Set")
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation == nil {
		mmDeleteEmbeddingsWithFileUID.defaultExpectation = &RepositoryMockDeleteEmbeddingsWithFileUIDExpectation{}
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation.params != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsWithFileUID mock is already set by Expect")
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs == nil {
		mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs = &RepositoryMockDeleteEmbeddingsWithFileUIDParamPtrs{}
	}
	mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs.collID = &collID
	mmDeleteEmbeddingsWithFileUID.defaultExpectation.expectationOrigins.originCollID = minimock.CallerInfo(1)

	return mmDeleteEmbeddingsWithFileUID
}

// ExpectFileUIDParam3 sets up expected param fileUID for Repository.DeleteEmbeddingsWithFileUID
func (mmDeleteEmbeddingsWithFileUID *mRepositoryMockDeleteEmbeddingsWithFileUID) ExpectFileUIDParam3(fileUID types.FileUIDType) *mRepositoryMockDeleteEmbeddingsWithFileUID {
	if mmDeleteEmbeddingsWithFileUID.mock.funcDeleteEmbeddingsWithFileUID != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsWithFileUID mock is already set by Set")
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation == nil {
		mmDeleteEmbeddingsWithFileUID.defaultExpectation = &RepositoryMockDeleteEmbeddingsWithFileUIDExpectation{}
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation.params != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsWithFileUID mock is already set by Expect")
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs == nil {
		mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs = &RepositoryMockDeleteEmbeddingsWithFileUIDParamPtrs{}
	}
	mmDeleteEmbeddingsWithFileUID.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmDeleteEmbeddingsWithFileUID.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmDeleteEmbeddingsWithFileUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteEmbeddingsWithFileUID
func (mmDeleteEmbeddingsWithFileUID *mRepositoryMockDeleteEmbeddingsWithFileUID) Inspect(f func(ctx context.Context, collID string, fileUID types.FileUIDType)) *mRepositoryMockDeleteEmbeddingsWithFileUID {
	if mmDeleteEmbeddingsWithFileUID.mock.inspectFuncDeleteEmbeddingsWithFileUID != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteEmbeddingsWithFileUID")
	}

	mmDeleteEmbeddingsWithFileUID.mock.inspectFuncDeleteEmbeddingsWithFileUID = f

	return mmDeleteEmbeddingsWithFileUID
}

// Return sets up results that will be returned by Repository.DeleteEmbeddingsWithFileUID
func (mmDeleteEmbeddingsWithFileUID *mRepositoryMockDeleteEmbeddingsWithFileUID) Return(err error) *RepositoryMock {
	if mmDeleteEmbeddingsWithFileUID.mock.funcDeleteEmbeddingsWithFileUID != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsWithFileUID mock is already set by Set")
	}

	if mmDeleteEmbeddingsWithFileUID.defaultExpectation == nil {
		mmDeleteEmbeddingsWithFileUID.defaultExpectation = &RepositoryMockDeleteEmbeddingsWithFileUIDExpectation{mock: mmDeleteEmbeddingsWithFileUID.mock}
	}
	mmDeleteEmbeddingsWithFileUID.defaultExpectation.results = &RepositoryMockDeleteEmbeddingsWithFileUIDResults{err}
	mmDeleteEmbeddingsWithFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteEmbeddingsWithFileUID.mock
}

// Set uses given function f to mock the Repository.DeleteEmbeddingsWithFileUID method
func (mmDeleteEmbeddingsWithFileUID *mRepositoryMockDeleteEmbeddingsWithFileUID) Set(f func(ctx context.Context, collID string, fileUID types.FileUIDType) (err error)) *RepositoryMock {
	if mmDeleteEmbeddingsWithFileUID.defaultExpectation != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteEmbeddingsWithFileUID method")
	}

	if len(mmDeleteEmbeddingsWithFileUID.expectations) > 0 {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteEmbeddingsWithFileUID method")
	}

	mmDeleteEmbeddingsWithFileUID.mock.funcDeleteEmbeddingsWithFileUID = f
	mmDeleteEmbeddingsWithFileUID.mock.funcDeleteEmbeddingsWithFileUIDOrigin = minimock.CallerInfo(1)
	return mmDeleteEmbeddingsWithFileUID.mock
}

// When sets expectation for the Repository.DeleteEmbeddingsWithFileUID which will trigger the result defined by the following
// Then helper
func (mmDeleteEmbeddingsWithFileUID *mRepositoryMockDeleteEmbeddingsWithFileUID) When(ctx context.Context, collID string, fileUID types.FileUIDType) *RepositoryMockDeleteEmbeddingsWithFileUIDExpectation {
	if mmDeleteEmbeddingsWithFileUID.mock.funcDeleteEmbeddingsWithFileUID != nil {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("RepositoryMock.DeleteEmbeddingsWithFileUID mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteEmbeddingsWithFileUIDExpectation{
		mock:               mmDeleteEmbeddingsWithFileUID.mock,
		params:             &RepositoryMockDeleteEmbeddingsWithFileUIDParams{ctx, collID, fileUID},
		expectationOrigins: RepositoryMockDeleteEmbeddingsWithFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteEmbeddingsWithFileUID.expectations = append(mmDeleteEmbeddingsWithFileUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteEmbeddingsWithFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteEmbeddingsWithFileUIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteEmbeddingsWithFileUIDResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteEmbeddingsWithFileUID should be invoked
func (mmDeleteEmbeddingsWithFileUID *mRepositoryMockDeleteEmbeddingsWithFileUID) Times(n uint64) *mRepositoryMockDeleteEmbeddingsWithFileUID {
	if n == 0 {
		mmDeleteEmbeddingsWithFileUID.mock.t.Fatalf("Times of RepositoryMock.DeleteEmbeddingsWithFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteEmbeddingsWithFileUID.expectedInvocations, n)
	mmDeleteEmbeddingsWithFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteEmbeddingsWithFileUID
}

func (mmDeleteEmbeddingsWithFileUID *mRepositoryMockDeleteEmbeddingsWithFileUID) invocationsDone() bool {
	if len(mmDeleteEmbeddingsWithFileUID.expectations) == 0 && mmDeleteEmbeddingsWithFileUID.defaultExpectation == nil && mmDeleteEmbeddingsWithFileUID.mock.funcDeleteEmbeddingsWithFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteEmbeddingsWithFileUID.mock.afterDeleteEmbeddingsWithFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteEmbeddingsWithFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteEmbeddingsWithFileUID implements mm_repository.Repository
func (mmDeleteEmbeddingsWithFileUID *RepositoryMock) DeleteEmbeddingsWithFileUID(ctx context.Context, collID string, fileUID types.FileUIDType) (err error) {
	mm_atomic.AddUint64(&mmDeleteEmbeddingsWithFileUID.beforeDeleteEmbeddingsWithFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteEmbeddingsWithFileUID.afterDeleteEmbeddingsWithFileUIDCounter, 1)

	mmDeleteEmbeddingsWithFileUID.t.Helper()

	if mmDeleteEmbeddingsWithFileUID.inspectFuncDeleteEmbeddingsWithFileUID != nil {
		mmDeleteEmbeddingsWithFileUID.inspectFuncDeleteEmbeddingsWithFileUID(ctx, collID, fileUID)
	}

	mm_params := RepositoryMockDeleteEmbeddingsWithFileUIDParams{ctx, collID, fileUID}

	// Record call args
	mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.mutex.Lock()
	mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.callArgs = append(mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.callArgs, &mm_params)
	mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.mutex.Unlock()

	for _, e := range mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteEmbeddingsWithFileUIDParams{ctx, collID, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteEmbeddingsWithFileUID.t.Errorf("RepositoryMock.DeleteEmbeddingsWithFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.collID != nil && !minimock.Equal(*mm_want_ptrs.collID, mm_got.collID) {
				mmDeleteEmbeddingsWithFileUID.t.Errorf("RepositoryMock.DeleteEmbeddingsWithFileUID got unexpected parameter collID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.expectationOrigins.originCollID, *mm_want_ptrs.collID, mm_got.collID, minimock.Diff(*mm_want_ptrs.collID, mm_got.collID))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmDeleteEmbeddingsWithFileUID.t.Errorf("RepositoryMock.DeleteEmbeddingsWithFileUID got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteEmbeddingsWithFileUID.t.Errorf("RepositoryMock.DeleteEmbeddingsWithFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteEmbeddingsWithFileUID.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteEmbeddingsWithFileUID.t.Fatal("No results are set for the RepositoryMock.DeleteEmbeddingsWithFileUID")
		}
		return (*mm_results).err
	}
	if mmDeleteEmbeddingsWithFileUID.funcDeleteEmbeddingsWithFileUID != nil {
		return mmDeleteEmbeddingsWithFileUID.funcDeleteEmbeddingsWithFileUID(ctx, collID, fileUID)
	}
	mmDeleteEmbeddingsWithFileUID.t.Fatalf("Unexpected call to RepositoryMock.DeleteEmbeddingsWithFileUID. %v %v %v", ctx, collID, fileUID)
	return
}

// DeleteEmbeddingsWithFileUIDAfterCounter returns a count of finished RepositoryMock.DeleteEmbeddingsWithFileUID invocations
func (mmDeleteEmbeddingsWithFileUID *RepositoryMock) DeleteEmbeddingsWithFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEmbeddingsWithFileUID.afterDeleteEmbeddingsWithFileUIDCounter)
}

// DeleteEmbeddingsWithFileUIDBeforeCounter returns a count of RepositoryMock.DeleteEmbeddingsWithFileUID invocations
func (mmDeleteEmbeddingsWithFileUID *RepositoryMock) DeleteEmbeddingsWithFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEmbeddingsWithFileUID.beforeDeleteEmbeddingsWithFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteEmbeddingsWithFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteEmbeddingsWithFileUID *mRepositoryMockDeleteEmbeddingsWithFileUID) Calls() []*RepositoryMockDeleteEmbeddingsWithFileUIDParams {
	mmDeleteEmbeddingsWithFileUID.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteEmbeddingsWithFileUIDParams, len(mmDeleteEmbeddingsWithFileUID.callArgs))
	copy(argCopy, mmDeleteEmbeddingsWithFileUID.callArgs)

	mmDeleteEmbeddingsWithFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteEmbeddingsWithFileUIDDone returns true if the count of the DeleteEmbeddingsWithFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteEmbeddingsWithFileUIDDone() bool {
	if m.DeleteEmbeddingsWithFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteEmbeddingsWithFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteEmbeddingsWithFileUIDMock.invocationsDone()
}

// MinimockDeleteEmbeddingsWithFileUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteEmbeddingsWithFileUIDInspect() {
	for _, e := range m.DeleteEmbeddingsWithFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteEmbeddingsWithFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteEmbeddingsWithFileUIDCounter := mm_atomic.LoadUint64(&m.afterDeleteEmbeddingsWithFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteEmbeddingsWithFileUIDMock.defaultExpectation != nil && afterDeleteEmbeddingsWithFileUIDCounter < 1 {
		if m.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteEmbeddingsWithFileUID at\n%s", m.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteEmbeddingsWithFileUID at\n%s with params: %#v", m.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.DeleteEmbeddingsWithFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteEmbeddingsWithFileUID != nil && afterDeleteEmbeddingsWithFileUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteEmbeddingsWithFileUID at\n%s", m.funcDeleteEmbeddingsWithFileUIDOrigin)
	}

	if !m.DeleteEmbeddingsWithFileUIDMock.invocationsDone() && afterDeleteEmbeddingsWithFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteEmbeddingsWithFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteEmbeddingsWithFileUIDMock.expectedInvocations), m.DeleteEmbeddingsWithFileUIDMock.expectedInvocationsOrigin, afterDeleteEmbeddingsWithFileUIDCounter)
	}
}

type mRepositoryMockDeleteFile struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteFileExpectation
	expectations       []*RepositoryMockDeleteFileExpectation

	callArgs []*RepositoryMockDeleteFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteFileExpectation specifies expectation struct of the Repository.DeleteFile
type RepositoryMockDeleteFileExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteFileParams
	paramPtrs          *RepositoryMockDeleteFileParamPtrs
	expectationOrigins RepositoryMockDeleteFileExpectationOrigins
	results            *RepositoryMockDeleteFileResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteFileParams contains parameters of the Repository.DeleteFile
type RepositoryMockDeleteFileParams struct {
	ctx      context.Context
	bucket   string
	filePath string
}

// RepositoryMockDeleteFileParamPtrs contains pointers to parameters of the Repository.DeleteFile
type RepositoryMockDeleteFileParamPtrs struct {
	ctx      *context.Context
	bucket   *string
	filePath *string
}

// RepositoryMockDeleteFileResults contains results of the Repository.DeleteFile
type RepositoryMockDeleteFileResults struct {
	err error
}

// RepositoryMockDeleteFileOrigins contains origins of expectations of the Repository.DeleteFile
type RepositoryMockDeleteFileExpectationOrigins struct {
	origin         string
	originCtx      string
	originBucket   string
	originFilePath string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteFile *mRepositoryMockDeleteFile) Optional() *mRepositoryMockDeleteFile {
	mmDeleteFile.optional = true
	return mmDeleteFile
}

// Expect sets up expected params for Repository.DeleteFile
func (mmDeleteFile *mRepositoryMockDeleteFile) Expect(ctx context.Context, bucket string, filePath string) *mRepositoryMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("RepositoryMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &RepositoryMockDeleteFileExpectation{}
	}

	if mmDeleteFile.defaultExpectation.paramPtrs != nil {
		mmDeleteFile.mock.t.Fatalf("RepositoryMock.DeleteFile mock is already set by ExpectParams functions")
	}

	mmDeleteFile.defaultExpectation.params = &RepositoryMockDeleteFileParams{ctx, bucket, filePath}
	mmDeleteFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteFile.expectations {
		if minimock.Equal(e.params, mmDeleteFile.defaultExpectation.params) {
			mmDeleteFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteFile.defaultExpectation.params)
		}
	}

	return mmDeleteFile
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteFile
func (mmDeleteFile *mRepositoryMockDeleteFile) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("RepositoryMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &RepositoryMockDeleteFileExpectation{}
	}

	if mmDeleteFile.defaultExpectation.params != nil {
		mmDeleteFile.mock.t.Fatalf("RepositoryMock.DeleteFile mock is already set by Expect")
	}

	if mmDeleteFile.defaultExpectation.paramPtrs == nil {
		mmDeleteFile.defaultExpectation.paramPtrs = &RepositoryMockDeleteFileParamPtrs{}
	}
	mmDeleteFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteFile
}

// ExpectBucketParam2 sets up expected param bucket for Repository.DeleteFile
func (mmDeleteFile *mRepositoryMockDeleteFile) ExpectBucketParam2(bucket string) *mRepositoryMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("RepositoryMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &RepositoryMockDeleteFileExpectation{}
	}

	if mmDeleteFile.defaultExpectation.params != nil {
		mmDeleteFile.mock.t.Fatalf("RepositoryMock.DeleteFile mock is already set by Expect")
	}

	if mmDeleteFile.defaultExpectation.paramPtrs == nil {
		mmDeleteFile.defaultExpectation.paramPtrs = &RepositoryMockDeleteFileParamPtrs{}
	}
	mmDeleteFile.defaultExpectation.paramPtrs.bucket = &bucket
	mmDeleteFile.defaultExpectation.expectationOrigins.originBucket = minimock.CallerInfo(1)

	return mmDeleteFile
}

// ExpectFilePathParam3 sets up expected param filePath for Repository.DeleteFile
func (mmDeleteFile *mRepositoryMockDeleteFile) ExpectFilePathParam3(filePath string) *mRepositoryMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("RepositoryMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &RepositoryMockDeleteFileExpectation{}
	}

	if mmDeleteFile.defaultExpectation.params != nil {
		mmDeleteFile.mock.t.Fatalf("RepositoryMock.DeleteFile mock is already set by Expect")
	}

	if mmDeleteFile.defaultExpectation.paramPtrs == nil {
		mmDeleteFile.defaultExpectation.paramPtrs = &RepositoryMockDeleteFileParamPtrs{}
	}
	mmDeleteFile.defaultExpectation.paramPtrs.filePath = &filePath
	mmDeleteFile.defaultExpectation.expectationOrigins.originFilePath = minimock.CallerInfo(1)

	return mmDeleteFile
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteFile
func (mmDeleteFile *mRepositoryMockDeleteFile) Inspect(f func(ctx context.Context, bucket string, filePath string)) *mRepositoryMockDeleteFile {
	if mmDeleteFile.mock.inspectFuncDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteFile")
	}

	mmDeleteFile.mock.inspectFuncDeleteFile = f

	return mmDeleteFile
}

// Return sets up results that will be returned by Repository.DeleteFile
func (mmDeleteFile *mRepositoryMockDeleteFile) Return(err error) *RepositoryMock {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("RepositoryMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &RepositoryMockDeleteFileExpectation{mock: mmDeleteFile.mock}
	}
	mmDeleteFile.defaultExpectation.results = &RepositoryMockDeleteFileResults{err}
	mmDeleteFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteFile.mock
}

// Set uses given function f to mock the Repository.DeleteFile method
func (mmDeleteFile *mRepositoryMockDeleteFile) Set(f func(ctx context.Context, bucket string, filePath string) (err error)) *RepositoryMock {
	if mmDeleteFile.defaultExpectation != nil {
		mmDeleteFile.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteFile method")
	}

	if len(mmDeleteFile.expectations) > 0 {
		mmDeleteFile.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteFile method")
	}

	mmDeleteFile.mock.funcDeleteFile = f
	mmDeleteFile.mock.funcDeleteFileOrigin = minimock.CallerInfo(1)
	return mmDeleteFile.mock
}

// When sets expectation for the Repository.DeleteFile which will trigger the result defined by the following
// Then helper
func (mmDeleteFile *mRepositoryMockDeleteFile) When(ctx context.Context, bucket string, filePath string) *RepositoryMockDeleteFileExpectation {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("RepositoryMock.DeleteFile mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteFileExpectation{
		mock:               mmDeleteFile.mock,
		params:             &RepositoryMockDeleteFileParams{ctx, bucket, filePath},
		expectationOrigins: RepositoryMockDeleteFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteFile.expectations = append(mmDeleteFile.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteFile return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteFileExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteFileResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteFile should be invoked
func (mmDeleteFile *mRepositoryMockDeleteFile) Times(n uint64) *mRepositoryMockDeleteFile {
	if n == 0 {
		mmDeleteFile.mock.t.Fatalf("Times of RepositoryMock.DeleteFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteFile.expectedInvocations, n)
	mmDeleteFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteFile
}

func (mmDeleteFile *mRepositoryMockDeleteFile) invocationsDone() bool {
	if len(mmDeleteFile.expectations) == 0 && mmDeleteFile.defaultExpectation == nil && mmDeleteFile.mock.funcDeleteFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteFile.mock.afterDeleteFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteFile implements mm_repository.Repository
func (mmDeleteFile *RepositoryMock) DeleteFile(ctx context.Context, bucket string, filePath string) (err error) {
	mm_atomic.AddUint64(&mmDeleteFile.beforeDeleteFileCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteFile.afterDeleteFileCounter, 1)

	mmDeleteFile.t.Helper()

	if mmDeleteFile.inspectFuncDeleteFile != nil {
		mmDeleteFile.inspectFuncDeleteFile(ctx, bucket, filePath)
	}

	mm_params := RepositoryMockDeleteFileParams{ctx, bucket, filePath}

	// Record call args
	mmDeleteFile.DeleteFileMock.mutex.Lock()
	mmDeleteFile.DeleteFileMock.callArgs = append(mmDeleteFile.DeleteFileMock.callArgs, &mm_params)
	mmDeleteFile.DeleteFileMock.mutex.Unlock()

	for _, e := range mmDeleteFile.DeleteFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteFile.DeleteFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteFile.DeleteFileMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteFile.DeleteFileMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteFile.DeleteFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteFileParams{ctx, bucket, filePath}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteFile.t.Errorf("RepositoryMock.DeleteFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFile.DeleteFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.bucket != nil && !minimock.Equal(*mm_want_ptrs.bucket, mm_got.bucket) {
				mmDeleteFile.t.Errorf("RepositoryMock.DeleteFile got unexpected parameter bucket, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFile.DeleteFileMock.defaultExpectation.expectationOrigins.originBucket, *mm_want_ptrs.bucket, mm_got.bucket, minimock.Diff(*mm_want_ptrs.bucket, mm_got.bucket))
			}

			if mm_want_ptrs.filePath != nil && !minimock.Equal(*mm_want_ptrs.filePath, mm_got.filePath) {
				mmDeleteFile.t.Errorf("RepositoryMock.DeleteFile got unexpected parameter filePath, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFile.DeleteFileMock.defaultExpectation.expectationOrigins.originFilePath, *mm_want_ptrs.filePath, mm_got.filePath, minimock.Diff(*mm_want_ptrs.filePath, mm_got.filePath))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteFile.t.Errorf("RepositoryMock.DeleteFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteFile.DeleteFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteFile.DeleteFileMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteFile.t.Fatal("No results are set for the RepositoryMock.DeleteFile")
		}
		return (*mm_results).err
	}
	if mmDeleteFile.funcDeleteFile != nil {
		return mmDeleteFile.funcDeleteFile(ctx, bucket, filePath)
	}
	mmDeleteFile.t.Fatalf("Unexpected call to RepositoryMock.DeleteFile. %v %v %v", ctx, bucket, filePath)
	return
}

// DeleteFileAfterCounter returns a count of finished RepositoryMock.DeleteFile invocations
func (mmDeleteFile *RepositoryMock) DeleteFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFile.afterDeleteFileCounter)
}

// DeleteFileBeforeCounter returns a count of RepositoryMock.DeleteFile invocations
func (mmDeleteFile *RepositoryMock) DeleteFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFile.beforeDeleteFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteFile *mRepositoryMockDeleteFile) Calls() []*RepositoryMockDeleteFileParams {
	mmDeleteFile.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteFileParams, len(mmDeleteFile.callArgs))
	copy(argCopy, mmDeleteFile.callArgs)

	mmDeleteFile.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteFileDone returns true if the count of the DeleteFile invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteFileDone() bool {
	if m.DeleteFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteFileMock.invocationsDone()
}

// MinimockDeleteFileInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteFileInspect() {
	for _, e := range m.DeleteFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteFileCounter := mm_atomic.LoadUint64(&m.afterDeleteFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFileMock.defaultExpectation != nil && afterDeleteFileCounter < 1 {
		if m.DeleteFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteFile at\n%s", m.DeleteFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteFile at\n%s with params: %#v", m.DeleteFileMock.defaultExpectation.expectationOrigins.origin, *m.DeleteFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFile != nil && afterDeleteFileCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteFile at\n%s", m.funcDeleteFileOrigin)
	}

	if !m.DeleteFileMock.invocationsDone() && afterDeleteFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteFileMock.expectedInvocations), m.DeleteFileMock.expectedInvocationsOrigin, afterDeleteFileCounter)
	}
}

type mRepositoryMockDeleteKnowledgeBase struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteKnowledgeBaseExpectation
	expectations       []*RepositoryMockDeleteKnowledgeBaseExpectation

	callArgs []*RepositoryMockDeleteKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteKnowledgeBaseExpectation specifies expectation struct of the Repository.DeleteKnowledgeBase
type RepositoryMockDeleteKnowledgeBaseExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteKnowledgeBaseParams
	paramPtrs          *RepositoryMockDeleteKnowledgeBaseParamPtrs
	expectationOrigins RepositoryMockDeleteKnowledgeBaseExpectationOrigins
	results            *RepositoryMockDeleteKnowledgeBaseResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteKnowledgeBaseParams contains parameters of the Repository.DeleteKnowledgeBase
type RepositoryMockDeleteKnowledgeBaseParams struct {
	ctx      context.Context
	ownerUID string
	kbID     string
}

// RepositoryMockDeleteKnowledgeBaseParamPtrs contains pointers to parameters of the Repository.DeleteKnowledgeBase
type RepositoryMockDeleteKnowledgeBaseParamPtrs struct {
	ctx      *context.Context
	ownerUID *string
	kbID     *string
}

// RepositoryMockDeleteKnowledgeBaseResults contains results of the Repository.DeleteKnowledgeBase
type RepositoryMockDeleteKnowledgeBaseResults struct {
	kp1 *mm_repository.KnowledgeBaseModel
	err error
}

// RepositoryMockDeleteKnowledgeBaseOrigins contains origins of expectations of the Repository.DeleteKnowledgeBase
type RepositoryMockDeleteKnowledgeBaseExpectationOrigins struct {
	origin         string
	originCtx      string
	originOwnerUID string
	originKbID     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) Optional() *mRepositoryMockDeleteKnowledgeBase {
	mmDeleteKnowledgeBase.optional = true
	return mmDeleteKnowledgeBase
}

// Expect sets up expected params for Repository.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) Expect(ctx context.Context, ownerUID string, kbID string) *mRepositoryMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmDeleteKnowledgeBase.defaultExpectation.params = &RepositoryMockDeleteKnowledgeBaseParams{ctx, ownerUID, kbID}
	mmDeleteKnowledgeBase.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmDeleteKnowledgeBase.defaultExpectation.params) {
			mmDeleteKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmDeleteKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.params != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBase mock is already set by Expect")
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockDeleteKnowledgeBaseParamPtrs{}
	}
	mmDeleteKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteKnowledgeBase.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteKnowledgeBase
}

// ExpectOwnerUIDParam2 sets up expected param ownerUID for Repository.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) ExpectOwnerUIDParam2(ownerUID string) *mRepositoryMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.params != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBase mock is already set by Expect")
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockDeleteKnowledgeBaseParamPtrs{}
	}
	mmDeleteKnowledgeBase.defaultExpectation.paramPtrs.ownerUID = &ownerUID
	mmDeleteKnowledgeBase.defaultExpectation.expectationOrigins.originOwnerUID = minimock.CallerInfo(1)

	return mmDeleteKnowledgeBase
}

// ExpectKbIDParam3 sets up expected param kbID for Repository.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) ExpectKbIDParam3(kbID string) *mRepositoryMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.params != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBase mock is already set by Expect")
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockDeleteKnowledgeBaseParamPtrs{}
	}
	mmDeleteKnowledgeBase.defaultExpectation.paramPtrs.kbID = &kbID
	mmDeleteKnowledgeBase.defaultExpectation.expectationOrigins.originKbID = minimock.CallerInfo(1)

	return mmDeleteKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) Inspect(f func(ctx context.Context, ownerUID string, kbID string)) *mRepositoryMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.inspectFuncDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteKnowledgeBase")
	}

	mmDeleteKnowledgeBase.mock.inspectFuncDeleteKnowledgeBase = f

	return mmDeleteKnowledgeBase
}

// Return sets up results that will be returned by Repository.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) Return(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseExpectation{mock: mmDeleteKnowledgeBase.mock}
	}
	mmDeleteKnowledgeBase.defaultExpectation.results = &RepositoryMockDeleteKnowledgeBaseResults{kp1, err}
	mmDeleteKnowledgeBase.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBase.mock
}

// Set uses given function f to mock the Repository.DeleteKnowledgeBase method
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) Set(f func(ctx context.Context, ownerUID string, kbID string) (kp1 *mm_repository.KnowledgeBaseModel, err error)) *RepositoryMock {
	if mmDeleteKnowledgeBase.defaultExpectation != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteKnowledgeBase method")
	}

	if len(mmDeleteKnowledgeBase.expectations) > 0 {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteKnowledgeBase method")
	}

	mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase = f
	mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBaseOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBase.mock
}

// When sets expectation for the Repository.DeleteKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) When(ctx context.Context, ownerUID string, kbID string) *RepositoryMockDeleteKnowledgeBaseExpectation {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBase mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteKnowledgeBaseExpectation{
		mock:               mmDeleteKnowledgeBase.mock,
		params:             &RepositoryMockDeleteKnowledgeBaseParams{ctx, ownerUID, kbID},
		expectationOrigins: RepositoryMockDeleteKnowledgeBaseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteKnowledgeBase.expectations = append(mmDeleteKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteKnowledgeBaseExpectation) Then(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteKnowledgeBaseResults{kp1, err}
	return e.mock
}

// Times sets number of times Repository.DeleteKnowledgeBase should be invoked
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) Times(n uint64) *mRepositoryMockDeleteKnowledgeBase {
	if n == 0 {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Times of RepositoryMock.DeleteKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteKnowledgeBase.expectedInvocations, n)
	mmDeleteKnowledgeBase.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBase
}

func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) invocationsDone() bool {
	if len(mmDeleteKnowledgeBase.expectations) == 0 && mmDeleteKnowledgeBase.defaultExpectation == nil && mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.mock.afterDeleteKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteKnowledgeBase implements mm_repository.Repository
func (mmDeleteKnowledgeBase *RepositoryMock) DeleteKnowledgeBase(ctx context.Context, ownerUID string, kbID string) (kp1 *mm_repository.KnowledgeBaseModel, err error) {
	mm_atomic.AddUint64(&mmDeleteKnowledgeBase.beforeDeleteKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteKnowledgeBase.afterDeleteKnowledgeBaseCounter, 1)

	mmDeleteKnowledgeBase.t.Helper()

	if mmDeleteKnowledgeBase.inspectFuncDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.inspectFuncDeleteKnowledgeBase(ctx, ownerUID, kbID)
	}

	mm_params := RepositoryMockDeleteKnowledgeBaseParams{ctx, ownerUID, kbID}

	// Record call args
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.mutex.Lock()
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.callArgs = append(mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.callArgs, &mm_params)
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteKnowledgeBaseParams{ctx, ownerUID, kbID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteKnowledgeBase.t.Errorf("RepositoryMock.DeleteKnowledgeBase got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmDeleteKnowledgeBase.t.Errorf("RepositoryMock.DeleteKnowledgeBase got unexpected parameter ownerUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.expectationOrigins.originOwnerUID, *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

			if mm_want_ptrs.kbID != nil && !minimock.Equal(*mm_want_ptrs.kbID, mm_got.kbID) {
				mmDeleteKnowledgeBase.t.Errorf("RepositoryMock.DeleteKnowledgeBase got unexpected parameter kbID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.expectationOrigins.originKbID, *mm_want_ptrs.kbID, mm_got.kbID, minimock.Diff(*mm_want_ptrs.kbID, mm_got.kbID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteKnowledgeBase.t.Errorf("RepositoryMock.DeleteKnowledgeBase got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteKnowledgeBase.t.Fatal("No results are set for the RepositoryMock.DeleteKnowledgeBase")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmDeleteKnowledgeBase.funcDeleteKnowledgeBase != nil {
		return mmDeleteKnowledgeBase.funcDeleteKnowledgeBase(ctx, ownerUID, kbID)
	}
	mmDeleteKnowledgeBase.t.Fatalf("Unexpected call to RepositoryMock.DeleteKnowledgeBase. %v %v %v", ctx, ownerUID, kbID)
	return
}

// DeleteKnowledgeBaseAfterCounter returns a count of finished RepositoryMock.DeleteKnowledgeBase invocations
func (mmDeleteKnowledgeBase *RepositoryMock) DeleteKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.afterDeleteKnowledgeBaseCounter)
}

// DeleteKnowledgeBaseBeforeCounter returns a count of RepositoryMock.DeleteKnowledgeBase invocations
func (mmDeleteKnowledgeBase *RepositoryMock) DeleteKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.beforeDeleteKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteKnowledgeBase *mRepositoryMockDeleteKnowledgeBase) Calls() []*RepositoryMockDeleteKnowledgeBaseParams {
	mmDeleteKnowledgeBase.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteKnowledgeBaseParams, len(mmDeleteKnowledgeBase.callArgs))
	copy(argCopy, mmDeleteKnowledgeBase.callArgs)

	mmDeleteKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteKnowledgeBaseDone returns true if the count of the DeleteKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteKnowledgeBaseDone() bool {
	if m.DeleteKnowledgeBaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteKnowledgeBaseMock.invocationsDone()
}

// MinimockDeleteKnowledgeBaseInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteKnowledgeBaseInspect() {
	for _, e := range m.DeleteKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBase at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterDeleteKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteKnowledgeBaseMock.defaultExpectation != nil && afterDeleteKnowledgeBaseCounter < 1 {
		if m.DeleteKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBase at\n%s", m.DeleteKnowledgeBaseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBase at\n%s with params: %#v", m.DeleteKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *m.DeleteKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteKnowledgeBase != nil && afterDeleteKnowledgeBaseCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBase at\n%s", m.funcDeleteKnowledgeBaseOrigin)
	}

	if !m.DeleteKnowledgeBaseMock.invocationsDone() && afterDeleteKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteKnowledgeBase at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteKnowledgeBaseMock.expectedInvocations), m.DeleteKnowledgeBaseMock.expectedInvocationsOrigin, afterDeleteKnowledgeBaseCounter)
	}
}

type mRepositoryMockDeleteKnowledgeBaseFile struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteKnowledgeBaseFileExpectation
	expectations       []*RepositoryMockDeleteKnowledgeBaseFileExpectation

	callArgs []*RepositoryMockDeleteKnowledgeBaseFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteKnowledgeBaseFileExpectation specifies expectation struct of the Repository.DeleteKnowledgeBaseFile
type RepositoryMockDeleteKnowledgeBaseFileExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteKnowledgeBaseFileParams
	paramPtrs          *RepositoryMockDeleteKnowledgeBaseFileParamPtrs
	expectationOrigins RepositoryMockDeleteKnowledgeBaseFileExpectationOrigins
	results            *RepositoryMockDeleteKnowledgeBaseFileResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteKnowledgeBaseFileParams contains parameters of the Repository.DeleteKnowledgeBaseFile
type RepositoryMockDeleteKnowledgeBaseFileParams struct {
	ctx     context.Context
	fileUID string
}

// RepositoryMockDeleteKnowledgeBaseFileParamPtrs contains pointers to parameters of the Repository.DeleteKnowledgeBaseFile
type RepositoryMockDeleteKnowledgeBaseFileParamPtrs struct {
	ctx     *context.Context
	fileUID *string
}

// RepositoryMockDeleteKnowledgeBaseFileResults contains results of the Repository.DeleteKnowledgeBaseFile
type RepositoryMockDeleteKnowledgeBaseFileResults struct {
	err error
}

// RepositoryMockDeleteKnowledgeBaseFileOrigins contains origins of expectations of the Repository.DeleteKnowledgeBaseFile
type RepositoryMockDeleteKnowledgeBaseFileExpectationOrigins struct {
	origin        string
	originCtx     string
	originFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteKnowledgeBaseFile *mRepositoryMockDeleteKnowledgeBaseFile) Optional() *mRepositoryMockDeleteKnowledgeBaseFile {
	mmDeleteKnowledgeBaseFile.optional = true
	return mmDeleteKnowledgeBaseFile
}

// Expect sets up expected params for Repository.DeleteKnowledgeBaseFile
func (mmDeleteKnowledgeBaseFile *mRepositoryMockDeleteKnowledgeBaseFile) Expect(ctx context.Context, fileUID string) *mRepositoryMockDeleteKnowledgeBaseFile {
	if mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFile mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseFileExpectation{}
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFile mock is already set by ExpectParams functions")
	}

	mmDeleteKnowledgeBaseFile.defaultExpectation.params = &RepositoryMockDeleteKnowledgeBaseFileParams{ctx, fileUID}
	mmDeleteKnowledgeBaseFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteKnowledgeBaseFile.expectations {
		if minimock.Equal(e.params, mmDeleteKnowledgeBaseFile.defaultExpectation.params) {
			mmDeleteKnowledgeBaseFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteKnowledgeBaseFile.defaultExpectation.params)
		}
	}

	return mmDeleteKnowledgeBaseFile
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteKnowledgeBaseFile
func (mmDeleteKnowledgeBaseFile *mRepositoryMockDeleteKnowledgeBaseFile) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteKnowledgeBaseFile {
	if mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFile mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseFileExpectation{}
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation.params != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFile mock is already set by Expect")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryMockDeleteKnowledgeBaseFileParamPtrs{}
	}
	mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteKnowledgeBaseFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteKnowledgeBaseFile
}

// ExpectFileUIDParam2 sets up expected param fileUID for Repository.DeleteKnowledgeBaseFile
func (mmDeleteKnowledgeBaseFile *mRepositoryMockDeleteKnowledgeBaseFile) ExpectFileUIDParam2(fileUID string) *mRepositoryMockDeleteKnowledgeBaseFile {
	if mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFile mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseFileExpectation{}
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation.params != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFile mock is already set by Expect")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryMockDeleteKnowledgeBaseFileParamPtrs{}
	}
	mmDeleteKnowledgeBaseFile.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmDeleteKnowledgeBaseFile.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmDeleteKnowledgeBaseFile
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteKnowledgeBaseFile
func (mmDeleteKnowledgeBaseFile *mRepositoryMockDeleteKnowledgeBaseFile) Inspect(f func(ctx context.Context, fileUID string)) *mRepositoryMockDeleteKnowledgeBaseFile {
	if mmDeleteKnowledgeBaseFile.mock.inspectFuncDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteKnowledgeBaseFile")
	}

	mmDeleteKnowledgeBaseFile.mock.inspectFuncDeleteKnowledgeBaseFile = f

	return mmDeleteKnowledgeBaseFile
}

// Return sets up results that will be returned by Repository.DeleteKnowledgeBaseFile
func (mmDeleteKnowledgeBaseFile *mRepositoryMockDeleteKnowledgeBaseFile) Return(err error) *RepositoryMock {
	if mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFile mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFile.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFile.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseFileExpectation{mock: mmDeleteKnowledgeBaseFile.mock}
	}
	mmDeleteKnowledgeBaseFile.defaultExpectation.results = &RepositoryMockDeleteKnowledgeBaseFileResults{err}
	mmDeleteKnowledgeBaseFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBaseFile.mock
}

// Set uses given function f to mock the Repository.DeleteKnowledgeBaseFile method
func (mmDeleteKnowledgeBaseFile *mRepositoryMockDeleteKnowledgeBaseFile) Set(f func(ctx context.Context, fileUID string) (err error)) *RepositoryMock {
	if mmDeleteKnowledgeBaseFile.defaultExpectation != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteKnowledgeBaseFile method")
	}

	if len(mmDeleteKnowledgeBaseFile.expectations) > 0 {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteKnowledgeBaseFile method")
	}

	mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile = f
	mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFileOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBaseFile.mock
}

// When sets expectation for the Repository.DeleteKnowledgeBaseFile which will trigger the result defined by the following
// Then helper
func (mmDeleteKnowledgeBaseFile *mRepositoryMockDeleteKnowledgeBaseFile) When(ctx context.Context, fileUID string) *RepositoryMockDeleteKnowledgeBaseFileExpectation {
	if mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFile mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteKnowledgeBaseFileExpectation{
		mock:               mmDeleteKnowledgeBaseFile.mock,
		params:             &RepositoryMockDeleteKnowledgeBaseFileParams{ctx, fileUID},
		expectationOrigins: RepositoryMockDeleteKnowledgeBaseFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteKnowledgeBaseFile.expectations = append(mmDeleteKnowledgeBaseFile.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteKnowledgeBaseFile return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteKnowledgeBaseFileExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteKnowledgeBaseFileResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteKnowledgeBaseFile should be invoked
func (mmDeleteKnowledgeBaseFile *mRepositoryMockDeleteKnowledgeBaseFile) Times(n uint64) *mRepositoryMockDeleteKnowledgeBaseFile {
	if n == 0 {
		mmDeleteKnowledgeBaseFile.mock.t.Fatalf("Times of RepositoryMock.DeleteKnowledgeBaseFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteKnowledgeBaseFile.expectedInvocations, n)
	mmDeleteKnowledgeBaseFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBaseFile
}

func (mmDeleteKnowledgeBaseFile *mRepositoryMockDeleteKnowledgeBaseFile) invocationsDone() bool {
	if len(mmDeleteKnowledgeBaseFile.expectations) == 0 && mmDeleteKnowledgeBaseFile.defaultExpectation == nil && mmDeleteKnowledgeBaseFile.mock.funcDeleteKnowledgeBaseFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFile.mock.afterDeleteKnowledgeBaseFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteKnowledgeBaseFile implements mm_repository.Repository
func (mmDeleteKnowledgeBaseFile *RepositoryMock) DeleteKnowledgeBaseFile(ctx context.Context, fileUID string) (err error) {
	mm_atomic.AddUint64(&mmDeleteKnowledgeBaseFile.beforeDeleteKnowledgeBaseFileCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteKnowledgeBaseFile.afterDeleteKnowledgeBaseFileCounter, 1)

	mmDeleteKnowledgeBaseFile.t.Helper()

	if mmDeleteKnowledgeBaseFile.inspectFuncDeleteKnowledgeBaseFile != nil {
		mmDeleteKnowledgeBaseFile.inspectFuncDeleteKnowledgeBaseFile(ctx, fileUID)
	}

	mm_params := RepositoryMockDeleteKnowledgeBaseFileParams{ctx, fileUID}

	// Record call args
	mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.mutex.Lock()
	mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.callArgs = append(mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.callArgs, &mm_params)
	mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.mutex.Unlock()

	for _, e := range mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteKnowledgeBaseFileParams{ctx, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteKnowledgeBaseFile.t.Errorf("RepositoryMock.DeleteKnowledgeBaseFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmDeleteKnowledgeBaseFile.t.Errorf("RepositoryMock.DeleteKnowledgeBaseFile got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteKnowledgeBaseFile.t.Errorf("RepositoryMock.DeleteKnowledgeBaseFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteKnowledgeBaseFile.DeleteKnowledgeBaseFileMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteKnowledgeBaseFile.t.Fatal("No results are set for the RepositoryMock.DeleteKnowledgeBaseFile")
		}
		return (*mm_results).err
	}
	if mmDeleteKnowledgeBaseFile.funcDeleteKnowledgeBaseFile != nil {
		return mmDeleteKnowledgeBaseFile.funcDeleteKnowledgeBaseFile(ctx, fileUID)
	}
	mmDeleteKnowledgeBaseFile.t.Fatalf("Unexpected call to RepositoryMock.DeleteKnowledgeBaseFile. %v %v", ctx, fileUID)
	return
}

// DeleteKnowledgeBaseFileAfterCounter returns a count of finished RepositoryMock.DeleteKnowledgeBaseFile invocations
func (mmDeleteKnowledgeBaseFile *RepositoryMock) DeleteKnowledgeBaseFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFile.afterDeleteKnowledgeBaseFileCounter)
}

// DeleteKnowledgeBaseFileBeforeCounter returns a count of RepositoryMock.DeleteKnowledgeBaseFile invocations
func (mmDeleteKnowledgeBaseFile *RepositoryMock) DeleteKnowledgeBaseFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFile.beforeDeleteKnowledgeBaseFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteKnowledgeBaseFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteKnowledgeBaseFile *mRepositoryMockDeleteKnowledgeBaseFile) Calls() []*RepositoryMockDeleteKnowledgeBaseFileParams {
	mmDeleteKnowledgeBaseFile.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteKnowledgeBaseFileParams, len(mmDeleteKnowledgeBaseFile.callArgs))
	copy(argCopy, mmDeleteKnowledgeBaseFile.callArgs)

	mmDeleteKnowledgeBaseFile.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteKnowledgeBaseFileDone returns true if the count of the DeleteKnowledgeBaseFile invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteKnowledgeBaseFileDone() bool {
	if m.DeleteKnowledgeBaseFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteKnowledgeBaseFileMock.invocationsDone()
}

// MinimockDeleteKnowledgeBaseFileInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteKnowledgeBaseFileInspect() {
	for _, e := range m.DeleteKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBaseFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteKnowledgeBaseFileCounter := mm_atomic.LoadUint64(&m.afterDeleteKnowledgeBaseFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteKnowledgeBaseFileMock.defaultExpectation != nil && afterDeleteKnowledgeBaseFileCounter < 1 {
		if m.DeleteKnowledgeBaseFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBaseFile at\n%s", m.DeleteKnowledgeBaseFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBaseFile at\n%s with params: %#v", m.DeleteKnowledgeBaseFileMock.defaultExpectation.expectationOrigins.origin, *m.DeleteKnowledgeBaseFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteKnowledgeBaseFile != nil && afterDeleteKnowledgeBaseFileCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBaseFile at\n%s", m.funcDeleteKnowledgeBaseFileOrigin)
	}

	if !m.DeleteKnowledgeBaseFileMock.invocationsDone() && afterDeleteKnowledgeBaseFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteKnowledgeBaseFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteKnowledgeBaseFileMock.expectedInvocations), m.DeleteKnowledgeBaseFileMock.expectedInvocationsOrigin, afterDeleteKnowledgeBaseFileCounter)
	}
}

type mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation
	expectations       []*RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation

	callArgs []*RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation specifies expectation struct of the Repository.DeleteKnowledgeBaseFileAndDecreaseUsage
type RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParams
	paramPtrs          *RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParamPtrs
	expectationOrigins RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectationOrigins
	results            *RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParams contains parameters of the Repository.DeleteKnowledgeBaseFileAndDecreaseUsage
type RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParams struct {
	ctx     context.Context
	fileUID types.FileUIDType
}

// RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParamPtrs contains pointers to parameters of the Repository.DeleteKnowledgeBaseFileAndDecreaseUsage
type RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParamPtrs struct {
	ctx     *context.Context
	fileUID *types.FileUIDType
}

// RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageResults contains results of the Repository.DeleteKnowledgeBaseFileAndDecreaseUsage
type RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageResults struct {
	err error
}

// RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageOrigins contains origins of expectations of the Repository.DeleteKnowledgeBaseFileAndDecreaseUsage
type RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectationOrigins struct {
	origin        string
	originCtx     string
	originFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage) Optional() *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage {
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.optional = true
	return mmDeleteKnowledgeBaseFileAndDecreaseUsage
}

// Expect sets up expected params for Repository.DeleteKnowledgeBaseFileAndDecreaseUsage
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage) Expect(ctx context.Context, fileUID types.FileUIDType) *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage {
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation{}
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.paramPtrs != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by ExpectParams functions")
	}

	mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.params = &RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParams{ctx, fileUID}
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectations {
		if minimock.Equal(e.params, mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.params) {
			mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.params)
		}
	}

	return mmDeleteKnowledgeBaseFileAndDecreaseUsage
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteKnowledgeBaseFileAndDecreaseUsage
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage {
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation{}
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.params != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by Expect")
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.paramPtrs = &RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParamPtrs{}
	}
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteKnowledgeBaseFileAndDecreaseUsage
}

// ExpectFileUIDParam2 sets up expected param fileUID for Repository.DeleteKnowledgeBaseFileAndDecreaseUsage
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage) ExpectFileUIDParam2(fileUID types.FileUIDType) *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage {
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation{}
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.params != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by Expect")
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.paramPtrs = &RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParamPtrs{}
	}
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmDeleteKnowledgeBaseFileAndDecreaseUsage
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteKnowledgeBaseFileAndDecreaseUsage
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage) Inspect(f func(ctx context.Context, fileUID types.FileUIDType)) *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage {
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.inspectFuncDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage")
	}

	mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.inspectFuncDeleteKnowledgeBaseFileAndDecreaseUsage = f

	return mmDeleteKnowledgeBaseFileAndDecreaseUsage
}

// Return sets up results that will be returned by Repository.DeleteKnowledgeBaseFileAndDecreaseUsage
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage) Return(err error) *RepositoryMock {
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by Set")
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation == nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation = &RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation{mock: mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock}
	}
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.results = &RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageResults{err}
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock
}

// Set uses given function f to mock the Repository.DeleteKnowledgeBaseFileAndDecreaseUsage method
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage) Set(f func(ctx context.Context, fileUID types.FileUIDType) (err error)) *RepositoryMock {
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteKnowledgeBaseFileAndDecreaseUsage method")
	}

	if len(mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectations) > 0 {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteKnowledgeBaseFileAndDecreaseUsage method")
	}

	mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsage = f
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsageOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock
}

// When sets expectation for the Repository.DeleteKnowledgeBaseFileAndDecreaseUsage which will trigger the result defined by the following
// Then helper
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage) When(ctx context.Context, fileUID types.FileUIDType) *RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation {
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation{
		mock:               mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock,
		params:             &RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParams{ctx, fileUID},
		expectationOrigins: RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectations = append(mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteKnowledgeBaseFileAndDecreaseUsage return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteKnowledgeBaseFileAndDecreaseUsage should be invoked
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage) Times(n uint64) *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage {
	if n == 0 {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.t.Fatalf("Times of RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectedInvocations, n)
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBaseFileAndDecreaseUsage
}

func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage) invocationsDone() bool {
	if len(mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectations) == 0 && mmDeleteKnowledgeBaseFileAndDecreaseUsage.defaultExpectation == nil && mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.funcDeleteKnowledgeBaseFileAndDecreaseUsage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.mock.afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteKnowledgeBaseFileAndDecreaseUsage implements mm_repository.Repository
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *RepositoryMock) DeleteKnowledgeBaseFileAndDecreaseUsage(ctx context.Context, fileUID types.FileUIDType) (err error) {
	mm_atomic.AddUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.beforeDeleteKnowledgeBaseFileAndDecreaseUsageCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter, 1)

	mmDeleteKnowledgeBaseFileAndDecreaseUsage.t.Helper()

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.inspectFuncDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		mmDeleteKnowledgeBaseFileAndDecreaseUsage.inspectFuncDeleteKnowledgeBaseFileAndDecreaseUsage(ctx, fileUID)
	}

	mm_params := RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParams{ctx, fileUID}

	// Record call args
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.mutex.Lock()
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.callArgs = append(mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.callArgs, &mm_params)
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.mutex.Unlock()

	for _, e := range mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParams{ctx, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteKnowledgeBaseFileAndDecreaseUsage.t.Errorf("RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmDeleteKnowledgeBaseFileAndDecreaseUsage.t.Errorf("RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteKnowledgeBaseFileAndDecreaseUsage.t.Errorf("RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteKnowledgeBaseFileAndDecreaseUsage.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteKnowledgeBaseFileAndDecreaseUsage.t.Fatal("No results are set for the RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage")
		}
		return (*mm_results).err
	}
	if mmDeleteKnowledgeBaseFileAndDecreaseUsage.funcDeleteKnowledgeBaseFileAndDecreaseUsage != nil {
		return mmDeleteKnowledgeBaseFileAndDecreaseUsage.funcDeleteKnowledgeBaseFileAndDecreaseUsage(ctx, fileUID)
	}
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.t.Fatalf("Unexpected call to RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage. %v %v", ctx, fileUID)
	return
}

// DeleteKnowledgeBaseFileAndDecreaseUsageAfterCounter returns a count of finished RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage invocations
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *RepositoryMock) DeleteKnowledgeBaseFileAndDecreaseUsageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter)
}

// DeleteKnowledgeBaseFileAndDecreaseUsageBeforeCounter returns a count of RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage invocations
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *RepositoryMock) DeleteKnowledgeBaseFileAndDecreaseUsageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBaseFileAndDecreaseUsage.beforeDeleteKnowledgeBaseFileAndDecreaseUsageCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteKnowledgeBaseFileAndDecreaseUsage *mRepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsage) Calls() []*RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParams {
	mmDeleteKnowledgeBaseFileAndDecreaseUsage.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteKnowledgeBaseFileAndDecreaseUsageParams, len(mmDeleteKnowledgeBaseFileAndDecreaseUsage.callArgs))
	copy(argCopy, mmDeleteKnowledgeBaseFileAndDecreaseUsage.callArgs)

	mmDeleteKnowledgeBaseFileAndDecreaseUsage.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteKnowledgeBaseFileAndDecreaseUsageDone returns true if the count of the DeleteKnowledgeBaseFileAndDecreaseUsage invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteKnowledgeBaseFileAndDecreaseUsageDone() bool {
	if m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.invocationsDone()
}

// MinimockDeleteKnowledgeBaseFileAndDecreaseUsageInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteKnowledgeBaseFileAndDecreaseUsageInspect() {
	for _, e := range m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter := mm_atomic.LoadUint64(&m.afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation != nil && afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter < 1 {
		if m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage at\n%s", m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage at\n%s with params: %#v", m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.expectationOrigins.origin, *m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteKnowledgeBaseFileAndDecreaseUsage != nil && afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage at\n%s", m.funcDeleteKnowledgeBaseFileAndDecreaseUsageOrigin)
	}

	if !m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.invocationsDone() && afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteKnowledgeBaseFileAndDecreaseUsage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.expectedInvocations), m.DeleteKnowledgeBaseFileAndDecreaseUsageMock.expectedInvocationsOrigin, afterDeleteKnowledgeBaseFileAndDecreaseUsageCounter)
	}
}

type mRepositoryMockDeleteObject struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteObjectExpectation
	expectations       []*RepositoryMockDeleteObjectExpectation

	callArgs []*RepositoryMockDeleteObjectParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteObjectExpectation specifies expectation struct of the Repository.DeleteObject
type RepositoryMockDeleteObjectExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteObjectParams
	paramPtrs          *RepositoryMockDeleteObjectParamPtrs
	expectationOrigins RepositoryMockDeleteObjectExpectationOrigins
	results            *RepositoryMockDeleteObjectResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteObjectParams contains parameters of the Repository.DeleteObject
type RepositoryMockDeleteObjectParams struct {
	ctx context.Context
	uid types.ObjectUIDType
}

// RepositoryMockDeleteObjectParamPtrs contains pointers to parameters of the Repository.DeleteObject
type RepositoryMockDeleteObjectParamPtrs struct {
	ctx *context.Context
	uid *types.ObjectUIDType
}

// RepositoryMockDeleteObjectResults contains results of the Repository.DeleteObject
type RepositoryMockDeleteObjectResults struct {
	err error
}

// RepositoryMockDeleteObjectOrigins contains origins of expectations of the Repository.DeleteObject
type RepositoryMockDeleteObjectExpectationOrigins struct {
	origin    string
	originCtx string
	originUid string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteObject *mRepositoryMockDeleteObject) Optional() *mRepositoryMockDeleteObject {
	mmDeleteObject.optional = true
	return mmDeleteObject
}

// Expect sets up expected params for Repository.DeleteObject
func (mmDeleteObject *mRepositoryMockDeleteObject) Expect(ctx context.Context, uid types.ObjectUIDType) *mRepositoryMockDeleteObject {
	if mmDeleteObject.mock.funcDeleteObject != nil {
		mmDeleteObject.mock.t.Fatalf("RepositoryMock.DeleteObject mock is already set by Set")
	}

	if mmDeleteObject.defaultExpectation == nil {
		mmDeleteObject.defaultExpectation = &RepositoryMockDeleteObjectExpectation{}
	}

	if mmDeleteObject.defaultExpectation.paramPtrs != nil {
		mmDeleteObject.mock.t.Fatalf("RepositoryMock.DeleteObject mock is already set by ExpectParams functions")
	}

	mmDeleteObject.defaultExpectation.params = &RepositoryMockDeleteObjectParams{ctx, uid}
	mmDeleteObject.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteObject.expectations {
		if minimock.Equal(e.params, mmDeleteObject.defaultExpectation.params) {
			mmDeleteObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteObject.defaultExpectation.params)
		}
	}

	return mmDeleteObject
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteObject
func (mmDeleteObject *mRepositoryMockDeleteObject) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteObject {
	if mmDeleteObject.mock.funcDeleteObject != nil {
		mmDeleteObject.mock.t.Fatalf("RepositoryMock.DeleteObject mock is already set by Set")
	}

	if mmDeleteObject.defaultExpectation == nil {
		mmDeleteObject.defaultExpectation = &RepositoryMockDeleteObjectExpectation{}
	}

	if mmDeleteObject.defaultExpectation.params != nil {
		mmDeleteObject.mock.t.Fatalf("RepositoryMock.DeleteObject mock is already set by Expect")
	}

	if mmDeleteObject.defaultExpectation.paramPtrs == nil {
		mmDeleteObject.defaultExpectation.paramPtrs = &RepositoryMockDeleteObjectParamPtrs{}
	}
	mmDeleteObject.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteObject.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteObject
}

// ExpectUidParam2 sets up expected param uid for Repository.DeleteObject
func (mmDeleteObject *mRepositoryMockDeleteObject) ExpectUidParam2(uid types.ObjectUIDType) *mRepositoryMockDeleteObject {
	if mmDeleteObject.mock.funcDeleteObject != nil {
		mmDeleteObject.mock.t.Fatalf("RepositoryMock.DeleteObject mock is already set by Set")
	}

	if mmDeleteObject.defaultExpectation == nil {
		mmDeleteObject.defaultExpectation = &RepositoryMockDeleteObjectExpectation{}
	}

	if mmDeleteObject.defaultExpectation.params != nil {
		mmDeleteObject.mock.t.Fatalf("RepositoryMock.DeleteObject mock is already set by Expect")
	}

	if mmDeleteObject.defaultExpectation.paramPtrs == nil {
		mmDeleteObject.defaultExpectation.paramPtrs = &RepositoryMockDeleteObjectParamPtrs{}
	}
	mmDeleteObject.defaultExpectation.paramPtrs.uid = &uid
	mmDeleteObject.defaultExpectation.expectationOrigins.originUid = minimock.CallerInfo(1)

	return mmDeleteObject
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteObject
func (mmDeleteObject *mRepositoryMockDeleteObject) Inspect(f func(ctx context.Context, uid types.ObjectUIDType)) *mRepositoryMockDeleteObject {
	if mmDeleteObject.mock.inspectFuncDeleteObject != nil {
		mmDeleteObject.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteObject")
	}

	mmDeleteObject.mock.inspectFuncDeleteObject = f

	return mmDeleteObject
}

// Return sets up results that will be returned by Repository.DeleteObject
func (mmDeleteObject *mRepositoryMockDeleteObject) Return(err error) *RepositoryMock {
	if mmDeleteObject.mock.funcDeleteObject != nil {
		mmDeleteObject.mock.t.Fatalf("RepositoryMock.DeleteObject mock is already set by Set")
	}

	if mmDeleteObject.defaultExpectation == nil {
		mmDeleteObject.defaultExpectation = &RepositoryMockDeleteObjectExpectation{mock: mmDeleteObject.mock}
	}
	mmDeleteObject.defaultExpectation.results = &RepositoryMockDeleteObjectResults{err}
	mmDeleteObject.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteObject.mock
}

// Set uses given function f to mock the Repository.DeleteObject method
func (mmDeleteObject *mRepositoryMockDeleteObject) Set(f func(ctx context.Context, uid types.ObjectUIDType) (err error)) *RepositoryMock {
	if mmDeleteObject.defaultExpectation != nil {
		mmDeleteObject.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteObject method")
	}

	if len(mmDeleteObject.expectations) > 0 {
		mmDeleteObject.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteObject method")
	}

	mmDeleteObject.mock.funcDeleteObject = f
	mmDeleteObject.mock.funcDeleteObjectOrigin = minimock.CallerInfo(1)
	return mmDeleteObject.mock
}

// When sets expectation for the Repository.DeleteObject which will trigger the result defined by the following
// Then helper
func (mmDeleteObject *mRepositoryMockDeleteObject) When(ctx context.Context, uid types.ObjectUIDType) *RepositoryMockDeleteObjectExpectation {
	if mmDeleteObject.mock.funcDeleteObject != nil {
		mmDeleteObject.mock.t.Fatalf("RepositoryMock.DeleteObject mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteObjectExpectation{
		mock:               mmDeleteObject.mock,
		params:             &RepositoryMockDeleteObjectParams{ctx, uid},
		expectationOrigins: RepositoryMockDeleteObjectExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteObject.expectations = append(mmDeleteObject.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteObject return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteObjectExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteObjectResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteObject should be invoked
func (mmDeleteObject *mRepositoryMockDeleteObject) Times(n uint64) *mRepositoryMockDeleteObject {
	if n == 0 {
		mmDeleteObject.mock.t.Fatalf("Times of RepositoryMock.DeleteObject mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteObject.expectedInvocations, n)
	mmDeleteObject.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteObject
}

func (mmDeleteObject *mRepositoryMockDeleteObject) invocationsDone() bool {
	if len(mmDeleteObject.expectations) == 0 && mmDeleteObject.defaultExpectation == nil && mmDeleteObject.mock.funcDeleteObject == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteObject.mock.afterDeleteObjectCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteObject.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteObject implements mm_repository.Repository
func (mmDeleteObject *RepositoryMock) DeleteObject(ctx context.Context, uid types.ObjectUIDType) (err error) {
	mm_atomic.AddUint64(&mmDeleteObject.beforeDeleteObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteObject.afterDeleteObjectCounter, 1)

	mmDeleteObject.t.Helper()

	if mmDeleteObject.inspectFuncDeleteObject != nil {
		mmDeleteObject.inspectFuncDeleteObject(ctx, uid)
	}

	mm_params := RepositoryMockDeleteObjectParams{ctx, uid}

	// Record call args
	mmDeleteObject.DeleteObjectMock.mutex.Lock()
	mmDeleteObject.DeleteObjectMock.callArgs = append(mmDeleteObject.DeleteObjectMock.callArgs, &mm_params)
	mmDeleteObject.DeleteObjectMock.mutex.Unlock()

	for _, e := range mmDeleteObject.DeleteObjectMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteObject.DeleteObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteObject.DeleteObjectMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteObject.DeleteObjectMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteObject.DeleteObjectMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteObjectParams{ctx, uid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteObject.t.Errorf("RepositoryMock.DeleteObject got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteObject.DeleteObjectMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmDeleteObject.t.Errorf("RepositoryMock.DeleteObject got unexpected parameter uid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteObject.DeleteObjectMock.defaultExpectation.expectationOrigins.originUid, *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteObject.t.Errorf("RepositoryMock.DeleteObject got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteObject.DeleteObjectMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteObject.DeleteObjectMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteObject.t.Fatal("No results are set for the RepositoryMock.DeleteObject")
		}
		return (*mm_results).err
	}
	if mmDeleteObject.funcDeleteObject != nil {
		return mmDeleteObject.funcDeleteObject(ctx, uid)
	}
	mmDeleteObject.t.Fatalf("Unexpected call to RepositoryMock.DeleteObject. %v %v", ctx, uid)
	return
}

// DeleteObjectAfterCounter returns a count of finished RepositoryMock.DeleteObject invocations
func (mmDeleteObject *RepositoryMock) DeleteObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteObject.afterDeleteObjectCounter)
}

// DeleteObjectBeforeCounter returns a count of RepositoryMock.DeleteObject invocations
func (mmDeleteObject *RepositoryMock) DeleteObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteObject.beforeDeleteObjectCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteObject *mRepositoryMockDeleteObject) Calls() []*RepositoryMockDeleteObjectParams {
	mmDeleteObject.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteObjectParams, len(mmDeleteObject.callArgs))
	copy(argCopy, mmDeleteObject.callArgs)

	mmDeleteObject.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteObjectDone returns true if the count of the DeleteObject invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteObjectDone() bool {
	if m.DeleteObjectMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteObjectMock.invocationsDone()
}

// MinimockDeleteObjectInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteObjectInspect() {
	for _, e := range m.DeleteObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteObject at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteObjectCounter := mm_atomic.LoadUint64(&m.afterDeleteObjectCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteObjectMock.defaultExpectation != nil && afterDeleteObjectCounter < 1 {
		if m.DeleteObjectMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteObject at\n%s", m.DeleteObjectMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteObject at\n%s with params: %#v", m.DeleteObjectMock.defaultExpectation.expectationOrigins.origin, *m.DeleteObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteObject != nil && afterDeleteObjectCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteObject at\n%s", m.funcDeleteObjectOrigin)
	}

	if !m.DeleteObjectMock.invocationsDone() && afterDeleteObjectCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteObject at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteObjectMock.expectedInvocations), m.DeleteObjectMock.expectedInvocationsOrigin, afterDeleteObjectCounter)
	}
}

type mRepositoryMockDeleteObjectURL struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteObjectURLExpectation
	expectations       []*RepositoryMockDeleteObjectURLExpectation

	callArgs []*RepositoryMockDeleteObjectURLParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteObjectURLExpectation specifies expectation struct of the Repository.DeleteObjectURL
type RepositoryMockDeleteObjectURLExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteObjectURLParams
	paramPtrs          *RepositoryMockDeleteObjectURLParamPtrs
	expectationOrigins RepositoryMockDeleteObjectURLExpectationOrigins
	results            *RepositoryMockDeleteObjectURLResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteObjectURLParams contains parameters of the Repository.DeleteObjectURL
type RepositoryMockDeleteObjectURLParams struct {
	ctx context.Context
	uid types.ObjectURLUIDType
}

// RepositoryMockDeleteObjectURLParamPtrs contains pointers to parameters of the Repository.DeleteObjectURL
type RepositoryMockDeleteObjectURLParamPtrs struct {
	ctx *context.Context
	uid *types.ObjectURLUIDType
}

// RepositoryMockDeleteObjectURLResults contains results of the Repository.DeleteObjectURL
type RepositoryMockDeleteObjectURLResults struct {
	err error
}

// RepositoryMockDeleteObjectURLOrigins contains origins of expectations of the Repository.DeleteObjectURL
type RepositoryMockDeleteObjectURLExpectationOrigins struct {
	origin    string
	originCtx string
	originUid string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteObjectURL *mRepositoryMockDeleteObjectURL) Optional() *mRepositoryMockDeleteObjectURL {
	mmDeleteObjectURL.optional = true
	return mmDeleteObjectURL
}

// Expect sets up expected params for Repository.DeleteObjectURL
func (mmDeleteObjectURL *mRepositoryMockDeleteObjectURL) Expect(ctx context.Context, uid types.ObjectURLUIDType) *mRepositoryMockDeleteObjectURL {
	if mmDeleteObjectURL.mock.funcDeleteObjectURL != nil {
		mmDeleteObjectURL.mock.t.Fatalf("RepositoryMock.DeleteObjectURL mock is already set by Set")
	}

	if mmDeleteObjectURL.defaultExpectation == nil {
		mmDeleteObjectURL.defaultExpectation = &RepositoryMockDeleteObjectURLExpectation{}
	}

	if mmDeleteObjectURL.defaultExpectation.paramPtrs != nil {
		mmDeleteObjectURL.mock.t.Fatalf("RepositoryMock.DeleteObjectURL mock is already set by ExpectParams functions")
	}

	mmDeleteObjectURL.defaultExpectation.params = &RepositoryMockDeleteObjectURLParams{ctx, uid}
	mmDeleteObjectURL.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteObjectURL.expectations {
		if minimock.Equal(e.params, mmDeleteObjectURL.defaultExpectation.params) {
			mmDeleteObjectURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteObjectURL.defaultExpectation.params)
		}
	}

	return mmDeleteObjectURL
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteObjectURL
func (mmDeleteObjectURL *mRepositoryMockDeleteObjectURL) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteObjectURL {
	if mmDeleteObjectURL.mock.funcDeleteObjectURL != nil {
		mmDeleteObjectURL.mock.t.Fatalf("RepositoryMock.DeleteObjectURL mock is already set by Set")
	}

	if mmDeleteObjectURL.defaultExpectation == nil {
		mmDeleteObjectURL.defaultExpectation = &RepositoryMockDeleteObjectURLExpectation{}
	}

	if mmDeleteObjectURL.defaultExpectation.params != nil {
		mmDeleteObjectURL.mock.t.Fatalf("RepositoryMock.DeleteObjectURL mock is already set by Expect")
	}

	if mmDeleteObjectURL.defaultExpectation.paramPtrs == nil {
		mmDeleteObjectURL.defaultExpectation.paramPtrs = &RepositoryMockDeleteObjectURLParamPtrs{}
	}
	mmDeleteObjectURL.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteObjectURL.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteObjectURL
}

// ExpectUidParam2 sets up expected param uid for Repository.DeleteObjectURL
func (mmDeleteObjectURL *mRepositoryMockDeleteObjectURL) ExpectUidParam2(uid types.ObjectURLUIDType) *mRepositoryMockDeleteObjectURL {
	if mmDeleteObjectURL.mock.funcDeleteObjectURL != nil {
		mmDeleteObjectURL.mock.t.Fatalf("RepositoryMock.DeleteObjectURL mock is already set by Set")
	}

	if mmDeleteObjectURL.defaultExpectation == nil {
		mmDeleteObjectURL.defaultExpectation = &RepositoryMockDeleteObjectURLExpectation{}
	}

	if mmDeleteObjectURL.defaultExpectation.params != nil {
		mmDeleteObjectURL.mock.t.Fatalf("RepositoryMock.DeleteObjectURL mock is already set by Expect")
	}

	if mmDeleteObjectURL.defaultExpectation.paramPtrs == nil {
		mmDeleteObjectURL.defaultExpectation.paramPtrs = &RepositoryMockDeleteObjectURLParamPtrs{}
	}
	mmDeleteObjectURL.defaultExpectation.paramPtrs.uid = &uid
	mmDeleteObjectURL.defaultExpectation.expectationOrigins.originUid = minimock.CallerInfo(1)

	return mmDeleteObjectURL
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteObjectURL
func (mmDeleteObjectURL *mRepositoryMockDeleteObjectURL) Inspect(f func(ctx context.Context, uid types.ObjectURLUIDType)) *mRepositoryMockDeleteObjectURL {
	if mmDeleteObjectURL.mock.inspectFuncDeleteObjectURL != nil {
		mmDeleteObjectURL.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteObjectURL")
	}

	mmDeleteObjectURL.mock.inspectFuncDeleteObjectURL = f

	return mmDeleteObjectURL
}

// Return sets up results that will be returned by Repository.DeleteObjectURL
func (mmDeleteObjectURL *mRepositoryMockDeleteObjectURL) Return(err error) *RepositoryMock {
	if mmDeleteObjectURL.mock.funcDeleteObjectURL != nil {
		mmDeleteObjectURL.mock.t.Fatalf("RepositoryMock.DeleteObjectURL mock is already set by Set")
	}

	if mmDeleteObjectURL.defaultExpectation == nil {
		mmDeleteObjectURL.defaultExpectation = &RepositoryMockDeleteObjectURLExpectation{mock: mmDeleteObjectURL.mock}
	}
	mmDeleteObjectURL.defaultExpectation.results = &RepositoryMockDeleteObjectURLResults{err}
	mmDeleteObjectURL.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteObjectURL.mock
}

// Set uses given function f to mock the Repository.DeleteObjectURL method
func (mmDeleteObjectURL *mRepositoryMockDeleteObjectURL) Set(f func(ctx context.Context, uid types.ObjectURLUIDType) (err error)) *RepositoryMock {
	if mmDeleteObjectURL.defaultExpectation != nil {
		mmDeleteObjectURL.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteObjectURL method")
	}

	if len(mmDeleteObjectURL.expectations) > 0 {
		mmDeleteObjectURL.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteObjectURL method")
	}

	mmDeleteObjectURL.mock.funcDeleteObjectURL = f
	mmDeleteObjectURL.mock.funcDeleteObjectURLOrigin = minimock.CallerInfo(1)
	return mmDeleteObjectURL.mock
}

// When sets expectation for the Repository.DeleteObjectURL which will trigger the result defined by the following
// Then helper
func (mmDeleteObjectURL *mRepositoryMockDeleteObjectURL) When(ctx context.Context, uid types.ObjectURLUIDType) *RepositoryMockDeleteObjectURLExpectation {
	if mmDeleteObjectURL.mock.funcDeleteObjectURL != nil {
		mmDeleteObjectURL.mock.t.Fatalf("RepositoryMock.DeleteObjectURL mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteObjectURLExpectation{
		mock:               mmDeleteObjectURL.mock,
		params:             &RepositoryMockDeleteObjectURLParams{ctx, uid},
		expectationOrigins: RepositoryMockDeleteObjectURLExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteObjectURL.expectations = append(mmDeleteObjectURL.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteObjectURL return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteObjectURLExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteObjectURLResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteObjectURL should be invoked
func (mmDeleteObjectURL *mRepositoryMockDeleteObjectURL) Times(n uint64) *mRepositoryMockDeleteObjectURL {
	if n == 0 {
		mmDeleteObjectURL.mock.t.Fatalf("Times of RepositoryMock.DeleteObjectURL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteObjectURL.expectedInvocations, n)
	mmDeleteObjectURL.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteObjectURL
}

func (mmDeleteObjectURL *mRepositoryMockDeleteObjectURL) invocationsDone() bool {
	if len(mmDeleteObjectURL.expectations) == 0 && mmDeleteObjectURL.defaultExpectation == nil && mmDeleteObjectURL.mock.funcDeleteObjectURL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteObjectURL.mock.afterDeleteObjectURLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteObjectURL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteObjectURL implements mm_repository.Repository
func (mmDeleteObjectURL *RepositoryMock) DeleteObjectURL(ctx context.Context, uid types.ObjectURLUIDType) (err error) {
	mm_atomic.AddUint64(&mmDeleteObjectURL.beforeDeleteObjectURLCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteObjectURL.afterDeleteObjectURLCounter, 1)

	mmDeleteObjectURL.t.Helper()

	if mmDeleteObjectURL.inspectFuncDeleteObjectURL != nil {
		mmDeleteObjectURL.inspectFuncDeleteObjectURL(ctx, uid)
	}

	mm_params := RepositoryMockDeleteObjectURLParams{ctx, uid}

	// Record call args
	mmDeleteObjectURL.DeleteObjectURLMock.mutex.Lock()
	mmDeleteObjectURL.DeleteObjectURLMock.callArgs = append(mmDeleteObjectURL.DeleteObjectURLMock.callArgs, &mm_params)
	mmDeleteObjectURL.DeleteObjectURLMock.mutex.Unlock()

	for _, e := range mmDeleteObjectURL.DeleteObjectURLMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteObjectURL.DeleteObjectURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteObjectURL.DeleteObjectURLMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteObjectURL.DeleteObjectURLMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteObjectURL.DeleteObjectURLMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteObjectURLParams{ctx, uid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteObjectURL.t.Errorf("RepositoryMock.DeleteObjectURL got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteObjectURL.DeleteObjectURLMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmDeleteObjectURL.t.Errorf("RepositoryMock.DeleteObjectURL got unexpected parameter uid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteObjectURL.DeleteObjectURLMock.defaultExpectation.expectationOrigins.originUid, *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteObjectURL.t.Errorf("RepositoryMock.DeleteObjectURL got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteObjectURL.DeleteObjectURLMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteObjectURL.DeleteObjectURLMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteObjectURL.t.Fatal("No results are set for the RepositoryMock.DeleteObjectURL")
		}
		return (*mm_results).err
	}
	if mmDeleteObjectURL.funcDeleteObjectURL != nil {
		return mmDeleteObjectURL.funcDeleteObjectURL(ctx, uid)
	}
	mmDeleteObjectURL.t.Fatalf("Unexpected call to RepositoryMock.DeleteObjectURL. %v %v", ctx, uid)
	return
}

// DeleteObjectURLAfterCounter returns a count of finished RepositoryMock.DeleteObjectURL invocations
func (mmDeleteObjectURL *RepositoryMock) DeleteObjectURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteObjectURL.afterDeleteObjectURLCounter)
}

// DeleteObjectURLBeforeCounter returns a count of RepositoryMock.DeleteObjectURL invocations
func (mmDeleteObjectURL *RepositoryMock) DeleteObjectURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteObjectURL.beforeDeleteObjectURLCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteObjectURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteObjectURL *mRepositoryMockDeleteObjectURL) Calls() []*RepositoryMockDeleteObjectURLParams {
	mmDeleteObjectURL.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteObjectURLParams, len(mmDeleteObjectURL.callArgs))
	copy(argCopy, mmDeleteObjectURL.callArgs)

	mmDeleteObjectURL.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteObjectURLDone returns true if the count of the DeleteObjectURL invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteObjectURLDone() bool {
	if m.DeleteObjectURLMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteObjectURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteObjectURLMock.invocationsDone()
}

// MinimockDeleteObjectURLInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteObjectURLInspect() {
	for _, e := range m.DeleteObjectURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteObjectURL at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteObjectURLCounter := mm_atomic.LoadUint64(&m.afterDeleteObjectURLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteObjectURLMock.defaultExpectation != nil && afterDeleteObjectURLCounter < 1 {
		if m.DeleteObjectURLMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteObjectURL at\n%s", m.DeleteObjectURLMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteObjectURL at\n%s with params: %#v", m.DeleteObjectURLMock.defaultExpectation.expectationOrigins.origin, *m.DeleteObjectURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteObjectURL != nil && afterDeleteObjectURLCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteObjectURL at\n%s", m.funcDeleteObjectURLOrigin)
	}

	if !m.DeleteObjectURLMock.invocationsDone() && afterDeleteObjectURLCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteObjectURL at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteObjectURLMock.expectedInvocations), m.DeleteObjectURLMock.expectedInvocationsOrigin, afterDeleteObjectURLCounter)
	}
}

type mRepositoryMockDeleteRepositoryTag struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteRepositoryTagExpectation
	expectations       []*RepositoryMockDeleteRepositoryTagExpectation

	callArgs []*RepositoryMockDeleteRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteRepositoryTagExpectation specifies expectation struct of the Repository.DeleteRepositoryTag
type RepositoryMockDeleteRepositoryTagExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteRepositoryTagParams
	paramPtrs          *RepositoryMockDeleteRepositoryTagParamPtrs
	expectationOrigins RepositoryMockDeleteRepositoryTagExpectationOrigins
	results            *RepositoryMockDeleteRepositoryTagResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteRepositoryTagParams contains parameters of the Repository.DeleteRepositoryTag
type RepositoryMockDeleteRepositoryTagParams struct {
	ctx context.Context
	s1  string
}

// RepositoryMockDeleteRepositoryTagParamPtrs contains pointers to parameters of the Repository.DeleteRepositoryTag
type RepositoryMockDeleteRepositoryTagParamPtrs struct {
	ctx *context.Context
	s1  *string
}

// RepositoryMockDeleteRepositoryTagResults contains results of the Repository.DeleteRepositoryTag
type RepositoryMockDeleteRepositoryTagResults struct {
	err error
}

// RepositoryMockDeleteRepositoryTagOrigins contains origins of expectations of the Repository.DeleteRepositoryTag
type RepositoryMockDeleteRepositoryTagExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) Optional() *mRepositoryMockDeleteRepositoryTag {
	mmDeleteRepositoryTag.optional = true
	return mmDeleteRepositoryTag
}

// Expect sets up expected params for Repository.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) Expect(ctx context.Context, s1 string) *mRepositoryMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &RepositoryMockDeleteRepositoryTagExpectation{}
	}

	if mmDeleteRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryMock.DeleteRepositoryTag mock is already set by ExpectParams functions")
	}

	mmDeleteRepositoryTag.defaultExpectation.params = &RepositoryMockDeleteRepositoryTagParams{ctx, s1}
	mmDeleteRepositoryTag.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteRepositoryTag.expectations {
		if minimock.Equal(e.params, mmDeleteRepositoryTag.defaultExpectation.params) {
			mmDeleteRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteRepositoryTag.defaultExpectation.params)
		}
	}

	return mmDeleteRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &RepositoryMockDeleteRepositoryTagExpectation{}
	}

	if mmDeleteRepositoryTag.defaultExpectation.params != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryMock.DeleteRepositoryTag mock is already set by Expect")
	}

	if mmDeleteRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmDeleteRepositoryTag.defaultExpectation.paramPtrs = &RepositoryMockDeleteRepositoryTagParamPtrs{}
	}
	mmDeleteRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteRepositoryTag.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteRepositoryTag
}

// ExpectS1Param2 sets up expected param s1 for Repository.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) ExpectS1Param2(s1 string) *mRepositoryMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &RepositoryMockDeleteRepositoryTagExpectation{}
	}

	if mmDeleteRepositoryTag.defaultExpectation.params != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryMock.DeleteRepositoryTag mock is already set by Expect")
	}

	if mmDeleteRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmDeleteRepositoryTag.defaultExpectation.paramPtrs = &RepositoryMockDeleteRepositoryTagParamPtrs{}
	}
	mmDeleteRepositoryTag.defaultExpectation.paramPtrs.s1 = &s1
	mmDeleteRepositoryTag.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmDeleteRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) Inspect(f func(ctx context.Context, s1 string)) *mRepositoryMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.inspectFuncDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteRepositoryTag")
	}

	mmDeleteRepositoryTag.mock.inspectFuncDeleteRepositoryTag = f

	return mmDeleteRepositoryTag
}

// Return sets up results that will be returned by Repository.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) Return(err error) *RepositoryMock {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &RepositoryMockDeleteRepositoryTagExpectation{mock: mmDeleteRepositoryTag.mock}
	}
	mmDeleteRepositoryTag.defaultExpectation.results = &RepositoryMockDeleteRepositoryTagResults{err}
	mmDeleteRepositoryTag.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteRepositoryTag.mock
}

// Set uses given function f to mock the Repository.DeleteRepositoryTag method
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) Set(f func(ctx context.Context, s1 string) (err error)) *RepositoryMock {
	if mmDeleteRepositoryTag.defaultExpectation != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteRepositoryTag method")
	}

	if len(mmDeleteRepositoryTag.expectations) > 0 {
		mmDeleteRepositoryTag.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteRepositoryTag method")
	}

	mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag = f
	mmDeleteRepositoryTag.mock.funcDeleteRepositoryTagOrigin = minimock.CallerInfo(1)
	return mmDeleteRepositoryTag.mock
}

// When sets expectation for the Repository.DeleteRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) When(ctx context.Context, s1 string) *RepositoryMockDeleteRepositoryTagExpectation {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryMock.DeleteRepositoryTag mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteRepositoryTagExpectation{
		mock:               mmDeleteRepositoryTag.mock,
		params:             &RepositoryMockDeleteRepositoryTagParams{ctx, s1},
		expectationOrigins: RepositoryMockDeleteRepositoryTagExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteRepositoryTag.expectations = append(mmDeleteRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteRepositoryTag return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteRepositoryTagExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteRepositoryTagResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteRepositoryTag should be invoked
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) Times(n uint64) *mRepositoryMockDeleteRepositoryTag {
	if n == 0 {
		mmDeleteRepositoryTag.mock.t.Fatalf("Times of RepositoryMock.DeleteRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteRepositoryTag.expectedInvocations, n)
	mmDeleteRepositoryTag.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteRepositoryTag
}

func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) invocationsDone() bool {
	if len(mmDeleteRepositoryTag.expectations) == 0 && mmDeleteRepositoryTag.defaultExpectation == nil && mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteRepositoryTag.mock.afterDeleteRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteRepositoryTag implements mm_repository.Repository
func (mmDeleteRepositoryTag *RepositoryMock) DeleteRepositoryTag(ctx context.Context, s1 string) (err error) {
	mm_atomic.AddUint64(&mmDeleteRepositoryTag.beforeDeleteRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteRepositoryTag.afterDeleteRepositoryTagCounter, 1)

	mmDeleteRepositoryTag.t.Helper()

	if mmDeleteRepositoryTag.inspectFuncDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.inspectFuncDeleteRepositoryTag(ctx, s1)
	}

	mm_params := RepositoryMockDeleteRepositoryTagParams{ctx, s1}

	// Record call args
	mmDeleteRepositoryTag.DeleteRepositoryTagMock.mutex.Lock()
	mmDeleteRepositoryTag.DeleteRepositoryTagMock.callArgs = append(mmDeleteRepositoryTag.DeleteRepositoryTagMock.callArgs, &mm_params)
	mmDeleteRepositoryTag.DeleteRepositoryTagMock.mutex.Unlock()

	for _, e := range mmDeleteRepositoryTag.DeleteRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteRepositoryTagParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteRepositoryTag.t.Errorf("RepositoryMock.DeleteRepositoryTag got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmDeleteRepositoryTag.t.Errorf("RepositoryMock.DeleteRepositoryTag got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteRepositoryTag.t.Errorf("RepositoryMock.DeleteRepositoryTag got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteRepositoryTag.t.Fatal("No results are set for the RepositoryMock.DeleteRepositoryTag")
		}
		return (*mm_results).err
	}
	if mmDeleteRepositoryTag.funcDeleteRepositoryTag != nil {
		return mmDeleteRepositoryTag.funcDeleteRepositoryTag(ctx, s1)
	}
	mmDeleteRepositoryTag.t.Fatalf("Unexpected call to RepositoryMock.DeleteRepositoryTag. %v %v", ctx, s1)
	return
}

// DeleteRepositoryTagAfterCounter returns a count of finished RepositoryMock.DeleteRepositoryTag invocations
func (mmDeleteRepositoryTag *RepositoryMock) DeleteRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRepositoryTag.afterDeleteRepositoryTagCounter)
}

// DeleteRepositoryTagBeforeCounter returns a count of RepositoryMock.DeleteRepositoryTag invocations
func (mmDeleteRepositoryTag *RepositoryMock) DeleteRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRepositoryTag.beforeDeleteRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) Calls() []*RepositoryMockDeleteRepositoryTagParams {
	mmDeleteRepositoryTag.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteRepositoryTagParams, len(mmDeleteRepositoryTag.callArgs))
	copy(argCopy, mmDeleteRepositoryTag.callArgs)

	mmDeleteRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteRepositoryTagDone returns true if the count of the DeleteRepositoryTag invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteRepositoryTagDone() bool {
	if m.DeleteRepositoryTagMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteRepositoryTagMock.invocationsDone()
}

// MinimockDeleteRepositoryTagInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteRepositoryTagInspect() {
	for _, e := range m.DeleteRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteRepositoryTag at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterDeleteRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteRepositoryTagMock.defaultExpectation != nil && afterDeleteRepositoryTagCounter < 1 {
		if m.DeleteRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteRepositoryTag at\n%s", m.DeleteRepositoryTagMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteRepositoryTag at\n%s with params: %#v", m.DeleteRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *m.DeleteRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteRepositoryTag != nil && afterDeleteRepositoryTagCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteRepositoryTag at\n%s", m.funcDeleteRepositoryTagOrigin)
	}

	if !m.DeleteRepositoryTagMock.invocationsDone() && afterDeleteRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteRepositoryTag at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteRepositoryTagMock.expectedInvocations), m.DeleteRepositoryTagMock.expectedInvocationsOrigin, afterDeleteRepositoryTagCounter)
	}
}

type mRepositoryMockDropCollection struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDropCollectionExpectation
	expectations       []*RepositoryMockDropCollectionExpectation

	callArgs []*RepositoryMockDropCollectionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDropCollectionExpectation specifies expectation struct of the Repository.DropCollection
type RepositoryMockDropCollectionExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDropCollectionParams
	paramPtrs          *RepositoryMockDropCollectionParamPtrs
	expectationOrigins RepositoryMockDropCollectionExpectationOrigins
	results            *RepositoryMockDropCollectionResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDropCollectionParams contains parameters of the Repository.DropCollection
type RepositoryMockDropCollectionParams struct {
	ctx context.Context
	id  string
}

// RepositoryMockDropCollectionParamPtrs contains pointers to parameters of the Repository.DropCollection
type RepositoryMockDropCollectionParamPtrs struct {
	ctx *context.Context
	id  *string
}

// RepositoryMockDropCollectionResults contains results of the Repository.DropCollection
type RepositoryMockDropCollectionResults struct {
	err error
}

// RepositoryMockDropCollectionOrigins contains origins of expectations of the Repository.DropCollection
type RepositoryMockDropCollectionExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDropCollection *mRepositoryMockDropCollection) Optional() *mRepositoryMockDropCollection {
	mmDropCollection.optional = true
	return mmDropCollection
}

// Expect sets up expected params for Repository.DropCollection
func (mmDropCollection *mRepositoryMockDropCollection) Expect(ctx context.Context, id string) *mRepositoryMockDropCollection {
	if mmDropCollection.mock.funcDropCollection != nil {
		mmDropCollection.mock.t.Fatalf("RepositoryMock.DropCollection mock is already set by Set")
	}

	if mmDropCollection.defaultExpectation == nil {
		mmDropCollection.defaultExpectation = &RepositoryMockDropCollectionExpectation{}
	}

	if mmDropCollection.defaultExpectation.paramPtrs != nil {
		mmDropCollection.mock.t.Fatalf("RepositoryMock.DropCollection mock is already set by ExpectParams functions")
	}

	mmDropCollection.defaultExpectation.params = &RepositoryMockDropCollectionParams{ctx, id}
	mmDropCollection.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDropCollection.expectations {
		if minimock.Equal(e.params, mmDropCollection.defaultExpectation.params) {
			mmDropCollection.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDropCollection.defaultExpectation.params)
		}
	}

	return mmDropCollection
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DropCollection
func (mmDropCollection *mRepositoryMockDropCollection) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDropCollection {
	if mmDropCollection.mock.funcDropCollection != nil {
		mmDropCollection.mock.t.Fatalf("RepositoryMock.DropCollection mock is already set by Set")
	}

	if mmDropCollection.defaultExpectation == nil {
		mmDropCollection.defaultExpectation = &RepositoryMockDropCollectionExpectation{}
	}

	if mmDropCollection.defaultExpectation.params != nil {
		mmDropCollection.mock.t.Fatalf("RepositoryMock.DropCollection mock is already set by Expect")
	}

	if mmDropCollection.defaultExpectation.paramPtrs == nil {
		mmDropCollection.defaultExpectation.paramPtrs = &RepositoryMockDropCollectionParamPtrs{}
	}
	mmDropCollection.defaultExpectation.paramPtrs.ctx = &ctx
	mmDropCollection.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDropCollection
}

// ExpectIdParam2 sets up expected param id for Repository.DropCollection
func (mmDropCollection *mRepositoryMockDropCollection) ExpectIdParam2(id string) *mRepositoryMockDropCollection {
	if mmDropCollection.mock.funcDropCollection != nil {
		mmDropCollection.mock.t.Fatalf("RepositoryMock.DropCollection mock is already set by Set")
	}

	if mmDropCollection.defaultExpectation == nil {
		mmDropCollection.defaultExpectation = &RepositoryMockDropCollectionExpectation{}
	}

	if mmDropCollection.defaultExpectation.params != nil {
		mmDropCollection.mock.t.Fatalf("RepositoryMock.DropCollection mock is already set by Expect")
	}

	if mmDropCollection.defaultExpectation.paramPtrs == nil {
		mmDropCollection.defaultExpectation.paramPtrs = &RepositoryMockDropCollectionParamPtrs{}
	}
	mmDropCollection.defaultExpectation.paramPtrs.id = &id
	mmDropCollection.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDropCollection
}

// Inspect accepts an inspector function that has same arguments as the Repository.DropCollection
func (mmDropCollection *mRepositoryMockDropCollection) Inspect(f func(ctx context.Context, id string)) *mRepositoryMockDropCollection {
	if mmDropCollection.mock.inspectFuncDropCollection != nil {
		mmDropCollection.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DropCollection")
	}

	mmDropCollection.mock.inspectFuncDropCollection = f

	return mmDropCollection
}

// Return sets up results that will be returned by Repository.DropCollection
func (mmDropCollection *mRepositoryMockDropCollection) Return(err error) *RepositoryMock {
	if mmDropCollection.mock.funcDropCollection != nil {
		mmDropCollection.mock.t.Fatalf("RepositoryMock.DropCollection mock is already set by Set")
	}

	if mmDropCollection.defaultExpectation == nil {
		mmDropCollection.defaultExpectation = &RepositoryMockDropCollectionExpectation{mock: mmDropCollection.mock}
	}
	mmDropCollection.defaultExpectation.results = &RepositoryMockDropCollectionResults{err}
	mmDropCollection.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDropCollection.mock
}

// Set uses given function f to mock the Repository.DropCollection method
func (mmDropCollection *mRepositoryMockDropCollection) Set(f func(ctx context.Context, id string) (err error)) *RepositoryMock {
	if mmDropCollection.defaultExpectation != nil {
		mmDropCollection.mock.t.Fatalf("Default expectation is already set for the Repository.DropCollection method")
	}

	if len(mmDropCollection.expectations) > 0 {
		mmDropCollection.mock.t.Fatalf("Some expectations are already set for the Repository.DropCollection method")
	}

	mmDropCollection.mock.funcDropCollection = f
	mmDropCollection.mock.funcDropCollectionOrigin = minimock.CallerInfo(1)
	return mmDropCollection.mock
}

// When sets expectation for the Repository.DropCollection which will trigger the result defined by the following
// Then helper
func (mmDropCollection *mRepositoryMockDropCollection) When(ctx context.Context, id string) *RepositoryMockDropCollectionExpectation {
	if mmDropCollection.mock.funcDropCollection != nil {
		mmDropCollection.mock.t.Fatalf("RepositoryMock.DropCollection mock is already set by Set")
	}

	expectation := &RepositoryMockDropCollectionExpectation{
		mock:               mmDropCollection.mock,
		params:             &RepositoryMockDropCollectionParams{ctx, id},
		expectationOrigins: RepositoryMockDropCollectionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDropCollection.expectations = append(mmDropCollection.expectations, expectation)
	return expectation
}

// Then sets up Repository.DropCollection return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDropCollectionExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDropCollectionResults{err}
	return e.mock
}

// Times sets number of times Repository.DropCollection should be invoked
func (mmDropCollection *mRepositoryMockDropCollection) Times(n uint64) *mRepositoryMockDropCollection {
	if n == 0 {
		mmDropCollection.mock.t.Fatalf("Times of RepositoryMock.DropCollection mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDropCollection.expectedInvocations, n)
	mmDropCollection.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDropCollection
}

func (mmDropCollection *mRepositoryMockDropCollection) invocationsDone() bool {
	if len(mmDropCollection.expectations) == 0 && mmDropCollection.defaultExpectation == nil && mmDropCollection.mock.funcDropCollection == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDropCollection.mock.afterDropCollectionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDropCollection.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DropCollection implements mm_repository.Repository
func (mmDropCollection *RepositoryMock) DropCollection(ctx context.Context, id string) (err error) {
	mm_atomic.AddUint64(&mmDropCollection.beforeDropCollectionCounter, 1)
	defer mm_atomic.AddUint64(&mmDropCollection.afterDropCollectionCounter, 1)

	mmDropCollection.t.Helper()

	if mmDropCollection.inspectFuncDropCollection != nil {
		mmDropCollection.inspectFuncDropCollection(ctx, id)
	}

	mm_params := RepositoryMockDropCollectionParams{ctx, id}

	// Record call args
	mmDropCollection.DropCollectionMock.mutex.Lock()
	mmDropCollection.DropCollectionMock.callArgs = append(mmDropCollection.DropCollectionMock.callArgs, &mm_params)
	mmDropCollection.DropCollectionMock.mutex.Unlock()

	for _, e := range mmDropCollection.DropCollectionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDropCollection.DropCollectionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDropCollection.DropCollectionMock.defaultExpectation.Counter, 1)
		mm_want := mmDropCollection.DropCollectionMock.defaultExpectation.params
		mm_want_ptrs := mmDropCollection.DropCollectionMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDropCollectionParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDropCollection.t.Errorf("RepositoryMock.DropCollection got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDropCollection.DropCollectionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDropCollection.t.Errorf("RepositoryMock.DropCollection got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDropCollection.DropCollectionMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDropCollection.t.Errorf("RepositoryMock.DropCollection got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDropCollection.DropCollectionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDropCollection.DropCollectionMock.defaultExpectation.results
		if mm_results == nil {
			mmDropCollection.t.Fatal("No results are set for the RepositoryMock.DropCollection")
		}
		return (*mm_results).err
	}
	if mmDropCollection.funcDropCollection != nil {
		return mmDropCollection.funcDropCollection(ctx, id)
	}
	mmDropCollection.t.Fatalf("Unexpected call to RepositoryMock.DropCollection. %v %v", ctx, id)
	return
}

// DropCollectionAfterCounter returns a count of finished RepositoryMock.DropCollection invocations
func (mmDropCollection *RepositoryMock) DropCollectionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDropCollection.afterDropCollectionCounter)
}

// DropCollectionBeforeCounter returns a count of RepositoryMock.DropCollection invocations
func (mmDropCollection *RepositoryMock) DropCollectionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDropCollection.beforeDropCollectionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DropCollection.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDropCollection *mRepositoryMockDropCollection) Calls() []*RepositoryMockDropCollectionParams {
	mmDropCollection.mutex.RLock()

	argCopy := make([]*RepositoryMockDropCollectionParams, len(mmDropCollection.callArgs))
	copy(argCopy, mmDropCollection.callArgs)

	mmDropCollection.mutex.RUnlock()

	return argCopy
}

// MinimockDropCollectionDone returns true if the count of the DropCollection invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDropCollectionDone() bool {
	if m.DropCollectionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DropCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DropCollectionMock.invocationsDone()
}

// MinimockDropCollectionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDropCollectionInspect() {
	for _, e := range m.DropCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DropCollection at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDropCollectionCounter := mm_atomic.LoadUint64(&m.afterDropCollectionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DropCollectionMock.defaultExpectation != nil && afterDropCollectionCounter < 1 {
		if m.DropCollectionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DropCollection at\n%s", m.DropCollectionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DropCollection at\n%s with params: %#v", m.DropCollectionMock.defaultExpectation.expectationOrigins.origin, *m.DropCollectionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDropCollection != nil && afterDropCollectionCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DropCollection at\n%s", m.funcDropCollectionOrigin)
	}

	if !m.DropCollectionMock.invocationsDone() && afterDropCollectionCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DropCollection at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DropCollectionMock.expectedInvocations), m.DropCollectionMock.expectedInvocationsOrigin, afterDropCollectionCounter)
	}
}

type mRepositoryMockFlushCollection struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockFlushCollectionExpectation
	expectations       []*RepositoryMockFlushCollectionExpectation

	callArgs []*RepositoryMockFlushCollectionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockFlushCollectionExpectation specifies expectation struct of the Repository.FlushCollection
type RepositoryMockFlushCollectionExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockFlushCollectionParams
	paramPtrs          *RepositoryMockFlushCollectionParamPtrs
	expectationOrigins RepositoryMockFlushCollectionExpectationOrigins
	results            *RepositoryMockFlushCollectionResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockFlushCollectionParams contains parameters of the Repository.FlushCollection
type RepositoryMockFlushCollectionParams struct {
	ctx          context.Context
	collectionID string
}

// RepositoryMockFlushCollectionParamPtrs contains pointers to parameters of the Repository.FlushCollection
type RepositoryMockFlushCollectionParamPtrs struct {
	ctx          *context.Context
	collectionID *string
}

// RepositoryMockFlushCollectionResults contains results of the Repository.FlushCollection
type RepositoryMockFlushCollectionResults struct {
	err error
}

// RepositoryMockFlushCollectionOrigins contains origins of expectations of the Repository.FlushCollection
type RepositoryMockFlushCollectionExpectationOrigins struct {
	origin             string
	originCtx          string
	originCollectionID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFlushCollection *mRepositoryMockFlushCollection) Optional() *mRepositoryMockFlushCollection {
	mmFlushCollection.optional = true
	return mmFlushCollection
}

// Expect sets up expected params for Repository.FlushCollection
func (mmFlushCollection *mRepositoryMockFlushCollection) Expect(ctx context.Context, collectionID string) *mRepositoryMockFlushCollection {
	if mmFlushCollection.mock.funcFlushCollection != nil {
		mmFlushCollection.mock.t.Fatalf("RepositoryMock.FlushCollection mock is already set by Set")
	}

	if mmFlushCollection.defaultExpectation == nil {
		mmFlushCollection.defaultExpectation = &RepositoryMockFlushCollectionExpectation{}
	}

	if mmFlushCollection.defaultExpectation.paramPtrs != nil {
		mmFlushCollection.mock.t.Fatalf("RepositoryMock.FlushCollection mock is already set by ExpectParams functions")
	}

	mmFlushCollection.defaultExpectation.params = &RepositoryMockFlushCollectionParams{ctx, collectionID}
	mmFlushCollection.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFlushCollection.expectations {
		if minimock.Equal(e.params, mmFlushCollection.defaultExpectation.params) {
			mmFlushCollection.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFlushCollection.defaultExpectation.params)
		}
	}

	return mmFlushCollection
}

// ExpectCtxParam1 sets up expected param ctx for Repository.FlushCollection
func (mmFlushCollection *mRepositoryMockFlushCollection) ExpectCtxParam1(ctx context.Context) *mRepositoryMockFlushCollection {
	if mmFlushCollection.mock.funcFlushCollection != nil {
		mmFlushCollection.mock.t.Fatalf("RepositoryMock.FlushCollection mock is already set by Set")
	}

	if mmFlushCollection.defaultExpectation == nil {
		mmFlushCollection.defaultExpectation = &RepositoryMockFlushCollectionExpectation{}
	}

	if mmFlushCollection.defaultExpectation.params != nil {
		mmFlushCollection.mock.t.Fatalf("RepositoryMock.FlushCollection mock is already set by Expect")
	}

	if mmFlushCollection.defaultExpectation.paramPtrs == nil {
		mmFlushCollection.defaultExpectation.paramPtrs = &RepositoryMockFlushCollectionParamPtrs{}
	}
	mmFlushCollection.defaultExpectation.paramPtrs.ctx = &ctx
	mmFlushCollection.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFlushCollection
}

// ExpectCollectionIDParam2 sets up expected param collectionID for Repository.FlushCollection
func (mmFlushCollection *mRepositoryMockFlushCollection) ExpectCollectionIDParam2(collectionID string) *mRepositoryMockFlushCollection {
	if mmFlushCollection.mock.funcFlushCollection != nil {
		mmFlushCollection.mock.t.Fatalf("RepositoryMock.FlushCollection mock is already set by Set")
	}

	if mmFlushCollection.defaultExpectation == nil {
		mmFlushCollection.defaultExpectation = &RepositoryMockFlushCollectionExpectation{}
	}

	if mmFlushCollection.defaultExpectation.params != nil {
		mmFlushCollection.mock.t.Fatalf("RepositoryMock.FlushCollection mock is already set by Expect")
	}

	if mmFlushCollection.defaultExpectation.paramPtrs == nil {
		mmFlushCollection.defaultExpectation.paramPtrs = &RepositoryMockFlushCollectionParamPtrs{}
	}
	mmFlushCollection.defaultExpectation.paramPtrs.collectionID = &collectionID
	mmFlushCollection.defaultExpectation.expectationOrigins.originCollectionID = minimock.CallerInfo(1)

	return mmFlushCollection
}

// Inspect accepts an inspector function that has same arguments as the Repository.FlushCollection
func (mmFlushCollection *mRepositoryMockFlushCollection) Inspect(f func(ctx context.Context, collectionID string)) *mRepositoryMockFlushCollection {
	if mmFlushCollection.mock.inspectFuncFlushCollection != nil {
		mmFlushCollection.mock.t.Fatalf("Inspect function is already set for RepositoryMock.FlushCollection")
	}

	mmFlushCollection.mock.inspectFuncFlushCollection = f

	return mmFlushCollection
}

// Return sets up results that will be returned by Repository.FlushCollection
func (mmFlushCollection *mRepositoryMockFlushCollection) Return(err error) *RepositoryMock {
	if mmFlushCollection.mock.funcFlushCollection != nil {
		mmFlushCollection.mock.t.Fatalf("RepositoryMock.FlushCollection mock is already set by Set")
	}

	if mmFlushCollection.defaultExpectation == nil {
		mmFlushCollection.defaultExpectation = &RepositoryMockFlushCollectionExpectation{mock: mmFlushCollection.mock}
	}
	mmFlushCollection.defaultExpectation.results = &RepositoryMockFlushCollectionResults{err}
	mmFlushCollection.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFlushCollection.mock
}

// Set uses given function f to mock the Repository.FlushCollection method
func (mmFlushCollection *mRepositoryMockFlushCollection) Set(f func(ctx context.Context, collectionID string) (err error)) *RepositoryMock {
	if mmFlushCollection.defaultExpectation != nil {
		mmFlushCollection.mock.t.Fatalf("Default expectation is already set for the Repository.FlushCollection method")
	}

	if len(mmFlushCollection.expectations) > 0 {
		mmFlushCollection.mock.t.Fatalf("Some expectations are already set for the Repository.FlushCollection method")
	}

	mmFlushCollection.mock.funcFlushCollection = f
	mmFlushCollection.mock.funcFlushCollectionOrigin = minimock.CallerInfo(1)
	return mmFlushCollection.mock
}

// When sets expectation for the Repository.FlushCollection which will trigger the result defined by the following
// Then helper
func (mmFlushCollection *mRepositoryMockFlushCollection) When(ctx context.Context, collectionID string) *RepositoryMockFlushCollectionExpectation {
	if mmFlushCollection.mock.funcFlushCollection != nil {
		mmFlushCollection.mock.t.Fatalf("RepositoryMock.FlushCollection mock is already set by Set")
	}

	expectation := &RepositoryMockFlushCollectionExpectation{
		mock:               mmFlushCollection.mock,
		params:             &RepositoryMockFlushCollectionParams{ctx, collectionID},
		expectationOrigins: RepositoryMockFlushCollectionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFlushCollection.expectations = append(mmFlushCollection.expectations, expectation)
	return expectation
}

// Then sets up Repository.FlushCollection return parameters for the expectation previously defined by the When method
func (e *RepositoryMockFlushCollectionExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockFlushCollectionResults{err}
	return e.mock
}

// Times sets number of times Repository.FlushCollection should be invoked
func (mmFlushCollection *mRepositoryMockFlushCollection) Times(n uint64) *mRepositoryMockFlushCollection {
	if n == 0 {
		mmFlushCollection.mock.t.Fatalf("Times of RepositoryMock.FlushCollection mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFlushCollection.expectedInvocations, n)
	mmFlushCollection.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFlushCollection
}

func (mmFlushCollection *mRepositoryMockFlushCollection) invocationsDone() bool {
	if len(mmFlushCollection.expectations) == 0 && mmFlushCollection.defaultExpectation == nil && mmFlushCollection.mock.funcFlushCollection == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFlushCollection.mock.afterFlushCollectionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFlushCollection.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FlushCollection implements mm_repository.Repository
func (mmFlushCollection *RepositoryMock) FlushCollection(ctx context.Context, collectionID string) (err error) {
	mm_atomic.AddUint64(&mmFlushCollection.beforeFlushCollectionCounter, 1)
	defer mm_atomic.AddUint64(&mmFlushCollection.afterFlushCollectionCounter, 1)

	mmFlushCollection.t.Helper()

	if mmFlushCollection.inspectFuncFlushCollection != nil {
		mmFlushCollection.inspectFuncFlushCollection(ctx, collectionID)
	}

	mm_params := RepositoryMockFlushCollectionParams{ctx, collectionID}

	// Record call args
	mmFlushCollection.FlushCollectionMock.mutex.Lock()
	mmFlushCollection.FlushCollectionMock.callArgs = append(mmFlushCollection.FlushCollectionMock.callArgs, &mm_params)
	mmFlushCollection.FlushCollectionMock.mutex.Unlock()

	for _, e := range mmFlushCollection.FlushCollectionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmFlushCollection.FlushCollectionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFlushCollection.FlushCollectionMock.defaultExpectation.Counter, 1)
		mm_want := mmFlushCollection.FlushCollectionMock.defaultExpectation.params
		mm_want_ptrs := mmFlushCollection.FlushCollectionMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockFlushCollectionParams{ctx, collectionID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFlushCollection.t.Errorf("RepositoryMock.FlushCollection got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFlushCollection.FlushCollectionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.collectionID != nil && !minimock.Equal(*mm_want_ptrs.collectionID, mm_got.collectionID) {
				mmFlushCollection.t.Errorf("RepositoryMock.FlushCollection got unexpected parameter collectionID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFlushCollection.FlushCollectionMock.defaultExpectation.expectationOrigins.originCollectionID, *mm_want_ptrs.collectionID, mm_got.collectionID, minimock.Diff(*mm_want_ptrs.collectionID, mm_got.collectionID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFlushCollection.t.Errorf("RepositoryMock.FlushCollection got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFlushCollection.FlushCollectionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFlushCollection.FlushCollectionMock.defaultExpectation.results
		if mm_results == nil {
			mmFlushCollection.t.Fatal("No results are set for the RepositoryMock.FlushCollection")
		}
		return (*mm_results).err
	}
	if mmFlushCollection.funcFlushCollection != nil {
		return mmFlushCollection.funcFlushCollection(ctx, collectionID)
	}
	mmFlushCollection.t.Fatalf("Unexpected call to RepositoryMock.FlushCollection. %v %v", ctx, collectionID)
	return
}

// FlushCollectionAfterCounter returns a count of finished RepositoryMock.FlushCollection invocations
func (mmFlushCollection *RepositoryMock) FlushCollectionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFlushCollection.afterFlushCollectionCounter)
}

// FlushCollectionBeforeCounter returns a count of RepositoryMock.FlushCollection invocations
func (mmFlushCollection *RepositoryMock) FlushCollectionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFlushCollection.beforeFlushCollectionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.FlushCollection.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFlushCollection *mRepositoryMockFlushCollection) Calls() []*RepositoryMockFlushCollectionParams {
	mmFlushCollection.mutex.RLock()

	argCopy := make([]*RepositoryMockFlushCollectionParams, len(mmFlushCollection.callArgs))
	copy(argCopy, mmFlushCollection.callArgs)

	mmFlushCollection.mutex.RUnlock()

	return argCopy
}

// MinimockFlushCollectionDone returns true if the count of the FlushCollection invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockFlushCollectionDone() bool {
	if m.FlushCollectionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FlushCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FlushCollectionMock.invocationsDone()
}

// MinimockFlushCollectionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockFlushCollectionInspect() {
	for _, e := range m.FlushCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.FlushCollection at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFlushCollectionCounter := mm_atomic.LoadUint64(&m.afterFlushCollectionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FlushCollectionMock.defaultExpectation != nil && afterFlushCollectionCounter < 1 {
		if m.FlushCollectionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.FlushCollection at\n%s", m.FlushCollectionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.FlushCollection at\n%s with params: %#v", m.FlushCollectionMock.defaultExpectation.expectationOrigins.origin, *m.FlushCollectionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFlushCollection != nil && afterFlushCollectionCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.FlushCollection at\n%s", m.funcFlushCollectionOrigin)
	}

	if !m.FlushCollectionMock.invocationsDone() && afterFlushCollectionCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.FlushCollection at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FlushCollectionMock.expectedInvocations), m.FlushCollectionMock.expectedInvocationsOrigin, afterFlushCollectionCounter)
	}
}

type mRepositoryMockGetAllConvertedFilesByFileUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetAllConvertedFilesByFileUIDExpectation
	expectations       []*RepositoryMockGetAllConvertedFilesByFileUIDExpectation

	callArgs []*RepositoryMockGetAllConvertedFilesByFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetAllConvertedFilesByFileUIDExpectation specifies expectation struct of the Repository.GetAllConvertedFilesByFileUID
type RepositoryMockGetAllConvertedFilesByFileUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetAllConvertedFilesByFileUIDParams
	paramPtrs          *RepositoryMockGetAllConvertedFilesByFileUIDParamPtrs
	expectationOrigins RepositoryMockGetAllConvertedFilesByFileUIDExpectationOrigins
	results            *RepositoryMockGetAllConvertedFilesByFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetAllConvertedFilesByFileUIDParams contains parameters of the Repository.GetAllConvertedFilesByFileUID
type RepositoryMockGetAllConvertedFilesByFileUIDParams struct {
	ctx     context.Context
	fileUID types.FileUIDType
}

// RepositoryMockGetAllConvertedFilesByFileUIDParamPtrs contains pointers to parameters of the Repository.GetAllConvertedFilesByFileUID
type RepositoryMockGetAllConvertedFilesByFileUIDParamPtrs struct {
	ctx     *context.Context
	fileUID *types.FileUIDType
}

// RepositoryMockGetAllConvertedFilesByFileUIDResults contains results of the Repository.GetAllConvertedFilesByFileUID
type RepositoryMockGetAllConvertedFilesByFileUIDResults struct {
	ca1 []mm_repository.ConvertedFileModel
	err error
}

// RepositoryMockGetAllConvertedFilesByFileUIDOrigins contains origins of expectations of the Repository.GetAllConvertedFilesByFileUID
type RepositoryMockGetAllConvertedFilesByFileUIDExpectationOrigins struct {
	origin        string
	originCtx     string
	originFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAllConvertedFilesByFileUID *mRepositoryMockGetAllConvertedFilesByFileUID) Optional() *mRepositoryMockGetAllConvertedFilesByFileUID {
	mmGetAllConvertedFilesByFileUID.optional = true
	return mmGetAllConvertedFilesByFileUID
}

// Expect sets up expected params for Repository.GetAllConvertedFilesByFileUID
func (mmGetAllConvertedFilesByFileUID *mRepositoryMockGetAllConvertedFilesByFileUID) Expect(ctx context.Context, fileUID types.FileUIDType) *mRepositoryMockGetAllConvertedFilesByFileUID {
	if mmGetAllConvertedFilesByFileUID.mock.funcGetAllConvertedFilesByFileUID != nil {
		mmGetAllConvertedFilesByFileUID.mock.t.Fatalf("RepositoryMock.GetAllConvertedFilesByFileUID mock is already set by Set")
	}

	if mmGetAllConvertedFilesByFileUID.defaultExpectation == nil {
		mmGetAllConvertedFilesByFileUID.defaultExpectation = &RepositoryMockGetAllConvertedFilesByFileUIDExpectation{}
	}

	if mmGetAllConvertedFilesByFileUID.defaultExpectation.paramPtrs != nil {
		mmGetAllConvertedFilesByFileUID.mock.t.Fatalf("RepositoryMock.GetAllConvertedFilesByFileUID mock is already set by ExpectParams functions")
	}

	mmGetAllConvertedFilesByFileUID.defaultExpectation.params = &RepositoryMockGetAllConvertedFilesByFileUIDParams{ctx, fileUID}
	mmGetAllConvertedFilesByFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetAllConvertedFilesByFileUID.expectations {
		if minimock.Equal(e.params, mmGetAllConvertedFilesByFileUID.defaultExpectation.params) {
			mmGetAllConvertedFilesByFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAllConvertedFilesByFileUID.defaultExpectation.params)
		}
	}

	return mmGetAllConvertedFilesByFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetAllConvertedFilesByFileUID
func (mmGetAllConvertedFilesByFileUID *mRepositoryMockGetAllConvertedFilesByFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetAllConvertedFilesByFileUID {
	if mmGetAllConvertedFilesByFileUID.mock.funcGetAllConvertedFilesByFileUID != nil {
		mmGetAllConvertedFilesByFileUID.mock.t.Fatalf("RepositoryMock.GetAllConvertedFilesByFileUID mock is already set by Set")
	}

	if mmGetAllConvertedFilesByFileUID.defaultExpectation == nil {
		mmGetAllConvertedFilesByFileUID.defaultExpectation = &RepositoryMockGetAllConvertedFilesByFileUIDExpectation{}
	}

	if mmGetAllConvertedFilesByFileUID.defaultExpectation.params != nil {
		mmGetAllConvertedFilesByFileUID.mock.t.Fatalf("RepositoryMock.GetAllConvertedFilesByFileUID mock is already set by Expect")
	}

	if mmGetAllConvertedFilesByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetAllConvertedFilesByFileUID.defaultExpectation.paramPtrs = &RepositoryMockGetAllConvertedFilesByFileUIDParamPtrs{}
	}
	mmGetAllConvertedFilesByFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetAllConvertedFilesByFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetAllConvertedFilesByFileUID
}

// ExpectFileUIDParam2 sets up expected param fileUID for Repository.GetAllConvertedFilesByFileUID
func (mmGetAllConvertedFilesByFileUID *mRepositoryMockGetAllConvertedFilesByFileUID) ExpectFileUIDParam2(fileUID types.FileUIDType) *mRepositoryMockGetAllConvertedFilesByFileUID {
	if mmGetAllConvertedFilesByFileUID.mock.funcGetAllConvertedFilesByFileUID != nil {
		mmGetAllConvertedFilesByFileUID.mock.t.Fatalf("RepositoryMock.GetAllConvertedFilesByFileUID mock is already set by Set")
	}

	if mmGetAllConvertedFilesByFileUID.defaultExpectation == nil {
		mmGetAllConvertedFilesByFileUID.defaultExpectation = &RepositoryMockGetAllConvertedFilesByFileUIDExpectation{}
	}

	if mmGetAllConvertedFilesByFileUID.defaultExpectation.params != nil {
		mmGetAllConvertedFilesByFileUID.mock.t.Fatalf("RepositoryMock.GetAllConvertedFilesByFileUID mock is already set by Expect")
	}

	if mmGetAllConvertedFilesByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetAllConvertedFilesByFileUID.defaultExpectation.paramPtrs = &RepositoryMockGetAllConvertedFilesByFileUIDParamPtrs{}
	}
	mmGetAllConvertedFilesByFileUID.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmGetAllConvertedFilesByFileUID.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmGetAllConvertedFilesByFileUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetAllConvertedFilesByFileUID
func (mmGetAllConvertedFilesByFileUID *mRepositoryMockGetAllConvertedFilesByFileUID) Inspect(f func(ctx context.Context, fileUID types.FileUIDType)) *mRepositoryMockGetAllConvertedFilesByFileUID {
	if mmGetAllConvertedFilesByFileUID.mock.inspectFuncGetAllConvertedFilesByFileUID != nil {
		mmGetAllConvertedFilesByFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetAllConvertedFilesByFileUID")
	}

	mmGetAllConvertedFilesByFileUID.mock.inspectFuncGetAllConvertedFilesByFileUID = f

	return mmGetAllConvertedFilesByFileUID
}

// Return sets up results that will be returned by Repository.GetAllConvertedFilesByFileUID
func (mmGetAllConvertedFilesByFileUID *mRepositoryMockGetAllConvertedFilesByFileUID) Return(ca1 []mm_repository.ConvertedFileModel, err error) *RepositoryMock {
	if mmGetAllConvertedFilesByFileUID.mock.funcGetAllConvertedFilesByFileUID != nil {
		mmGetAllConvertedFilesByFileUID.mock.t.Fatalf("RepositoryMock.GetAllConvertedFilesByFileUID mock is already set by Set")
	}

	if mmGetAllConvertedFilesByFileUID.defaultExpectation == nil {
		mmGetAllConvertedFilesByFileUID.defaultExpectation = &RepositoryMockGetAllConvertedFilesByFileUIDExpectation{mock: mmGetAllConvertedFilesByFileUID.mock}
	}
	mmGetAllConvertedFilesByFileUID.defaultExpectation.results = &RepositoryMockGetAllConvertedFilesByFileUIDResults{ca1, err}
	mmGetAllConvertedFilesByFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAllConvertedFilesByFileUID.mock
}

// Set uses given function f to mock the Repository.GetAllConvertedFilesByFileUID method
func (mmGetAllConvertedFilesByFileUID *mRepositoryMockGetAllConvertedFilesByFileUID) Set(f func(ctx context.Context, fileUID types.FileUIDType) (ca1 []mm_repository.ConvertedFileModel, err error)) *RepositoryMock {
	if mmGetAllConvertedFilesByFileUID.defaultExpectation != nil {
		mmGetAllConvertedFilesByFileUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetAllConvertedFilesByFileUID method")
	}

	if len(mmGetAllConvertedFilesByFileUID.expectations) > 0 {
		mmGetAllConvertedFilesByFileUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetAllConvertedFilesByFileUID method")
	}

	mmGetAllConvertedFilesByFileUID.mock.funcGetAllConvertedFilesByFileUID = f
	mmGetAllConvertedFilesByFileUID.mock.funcGetAllConvertedFilesByFileUIDOrigin = minimock.CallerInfo(1)
	return mmGetAllConvertedFilesByFileUID.mock
}

// When sets expectation for the Repository.GetAllConvertedFilesByFileUID which will trigger the result defined by the following
// Then helper
func (mmGetAllConvertedFilesByFileUID *mRepositoryMockGetAllConvertedFilesByFileUID) When(ctx context.Context, fileUID types.FileUIDType) *RepositoryMockGetAllConvertedFilesByFileUIDExpectation {
	if mmGetAllConvertedFilesByFileUID.mock.funcGetAllConvertedFilesByFileUID != nil {
		mmGetAllConvertedFilesByFileUID.mock.t.Fatalf("RepositoryMock.GetAllConvertedFilesByFileUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetAllConvertedFilesByFileUIDExpectation{
		mock:               mmGetAllConvertedFilesByFileUID.mock,
		params:             &RepositoryMockGetAllConvertedFilesByFileUIDParams{ctx, fileUID},
		expectationOrigins: RepositoryMockGetAllConvertedFilesByFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetAllConvertedFilesByFileUID.expectations = append(mmGetAllConvertedFilesByFileUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetAllConvertedFilesByFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetAllConvertedFilesByFileUIDExpectation) Then(ca1 []mm_repository.ConvertedFileModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetAllConvertedFilesByFileUIDResults{ca1, err}
	return e.mock
}

// Times sets number of times Repository.GetAllConvertedFilesByFileUID should be invoked
func (mmGetAllConvertedFilesByFileUID *mRepositoryMockGetAllConvertedFilesByFileUID) Times(n uint64) *mRepositoryMockGetAllConvertedFilesByFileUID {
	if n == 0 {
		mmGetAllConvertedFilesByFileUID.mock.t.Fatalf("Times of RepositoryMock.GetAllConvertedFilesByFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAllConvertedFilesByFileUID.expectedInvocations, n)
	mmGetAllConvertedFilesByFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAllConvertedFilesByFileUID
}

func (mmGetAllConvertedFilesByFileUID *mRepositoryMockGetAllConvertedFilesByFileUID) invocationsDone() bool {
	if len(mmGetAllConvertedFilesByFileUID.expectations) == 0 && mmGetAllConvertedFilesByFileUID.defaultExpectation == nil && mmGetAllConvertedFilesByFileUID.mock.funcGetAllConvertedFilesByFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAllConvertedFilesByFileUID.mock.afterGetAllConvertedFilesByFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAllConvertedFilesByFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAllConvertedFilesByFileUID implements mm_repository.Repository
func (mmGetAllConvertedFilesByFileUID *RepositoryMock) GetAllConvertedFilesByFileUID(ctx context.Context, fileUID types.FileUIDType) (ca1 []mm_repository.ConvertedFileModel, err error) {
	mm_atomic.AddUint64(&mmGetAllConvertedFilesByFileUID.beforeGetAllConvertedFilesByFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAllConvertedFilesByFileUID.afterGetAllConvertedFilesByFileUIDCounter, 1)

	mmGetAllConvertedFilesByFileUID.t.Helper()

	if mmGetAllConvertedFilesByFileUID.inspectFuncGetAllConvertedFilesByFileUID != nil {
		mmGetAllConvertedFilesByFileUID.inspectFuncGetAllConvertedFilesByFileUID(ctx, fileUID)
	}

	mm_params := RepositoryMockGetAllConvertedFilesByFileUIDParams{ctx, fileUID}

	// Record call args
	mmGetAllConvertedFilesByFileUID.GetAllConvertedFilesByFileUIDMock.mutex.Lock()
	mmGetAllConvertedFilesByFileUID.GetAllConvertedFilesByFileUIDMock.callArgs = append(mmGetAllConvertedFilesByFileUID.GetAllConvertedFilesByFileUIDMock.callArgs, &mm_params)
	mmGetAllConvertedFilesByFileUID.GetAllConvertedFilesByFileUIDMock.mutex.Unlock()

	for _, e := range mmGetAllConvertedFilesByFileUID.GetAllConvertedFilesByFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.err
		}
	}

	if mmGetAllConvertedFilesByFileUID.GetAllConvertedFilesByFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAllConvertedFilesByFileUID.GetAllConvertedFilesByFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAllConvertedFilesByFileUID.GetAllConvertedFilesByFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetAllConvertedFilesByFileUID.GetAllConvertedFilesByFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetAllConvertedFilesByFileUIDParams{ctx, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAllConvertedFilesByFileUID.t.Errorf("RepositoryMock.GetAllConvertedFilesByFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAllConvertedFilesByFileUID.GetAllConvertedFilesByFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmGetAllConvertedFilesByFileUID.t.Errorf("RepositoryMock.GetAllConvertedFilesByFileUID got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAllConvertedFilesByFileUID.GetAllConvertedFilesByFileUIDMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAllConvertedFilesByFileUID.t.Errorf("RepositoryMock.GetAllConvertedFilesByFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetAllConvertedFilesByFileUID.GetAllConvertedFilesByFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAllConvertedFilesByFileUID.GetAllConvertedFilesByFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAllConvertedFilesByFileUID.t.Fatal("No results are set for the RepositoryMock.GetAllConvertedFilesByFileUID")
		}
		return (*mm_results).ca1, (*mm_results).err
	}
	if mmGetAllConvertedFilesByFileUID.funcGetAllConvertedFilesByFileUID != nil {
		return mmGetAllConvertedFilesByFileUID.funcGetAllConvertedFilesByFileUID(ctx, fileUID)
	}
	mmGetAllConvertedFilesByFileUID.t.Fatalf("Unexpected call to RepositoryMock.GetAllConvertedFilesByFileUID. %v %v", ctx, fileUID)
	return
}

// GetAllConvertedFilesByFileUIDAfterCounter returns a count of finished RepositoryMock.GetAllConvertedFilesByFileUID invocations
func (mmGetAllConvertedFilesByFileUID *RepositoryMock) GetAllConvertedFilesByFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllConvertedFilesByFileUID.afterGetAllConvertedFilesByFileUIDCounter)
}

// GetAllConvertedFilesByFileUIDBeforeCounter returns a count of RepositoryMock.GetAllConvertedFilesByFileUID invocations
func (mmGetAllConvertedFilesByFileUID *RepositoryMock) GetAllConvertedFilesByFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllConvertedFilesByFileUID.beforeGetAllConvertedFilesByFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetAllConvertedFilesByFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAllConvertedFilesByFileUID *mRepositoryMockGetAllConvertedFilesByFileUID) Calls() []*RepositoryMockGetAllConvertedFilesByFileUIDParams {
	mmGetAllConvertedFilesByFileUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetAllConvertedFilesByFileUIDParams, len(mmGetAllConvertedFilesByFileUID.callArgs))
	copy(argCopy, mmGetAllConvertedFilesByFileUID.callArgs)

	mmGetAllConvertedFilesByFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllConvertedFilesByFileUIDDone returns true if the count of the GetAllConvertedFilesByFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetAllConvertedFilesByFileUIDDone() bool {
	if m.GetAllConvertedFilesByFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAllConvertedFilesByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAllConvertedFilesByFileUIDMock.invocationsDone()
}

// MinimockGetAllConvertedFilesByFileUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetAllConvertedFilesByFileUIDInspect() {
	for _, e := range m.GetAllConvertedFilesByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetAllConvertedFilesByFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetAllConvertedFilesByFileUIDCounter := mm_atomic.LoadUint64(&m.afterGetAllConvertedFilesByFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllConvertedFilesByFileUIDMock.defaultExpectation != nil && afterGetAllConvertedFilesByFileUIDCounter < 1 {
		if m.GetAllConvertedFilesByFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetAllConvertedFilesByFileUID at\n%s", m.GetAllConvertedFilesByFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetAllConvertedFilesByFileUID at\n%s with params: %#v", m.GetAllConvertedFilesByFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetAllConvertedFilesByFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAllConvertedFilesByFileUID != nil && afterGetAllConvertedFilesByFileUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetAllConvertedFilesByFileUID at\n%s", m.funcGetAllConvertedFilesByFileUIDOrigin)
	}

	if !m.GetAllConvertedFilesByFileUIDMock.invocationsDone() && afterGetAllConvertedFilesByFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetAllConvertedFilesByFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAllConvertedFilesByFileUIDMock.expectedInvocations), m.GetAllConvertedFilesByFileUIDMock.expectedInvocationsOrigin, afterGetAllConvertedFilesByFileUIDCounter)
	}
}

type mRepositoryMockGetChatCacheMetadata struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetChatCacheMetadataExpectation
	expectations       []*RepositoryMockGetChatCacheMetadataExpectation

	callArgs []*RepositoryMockGetChatCacheMetadataParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetChatCacheMetadataExpectation specifies expectation struct of the Repository.GetChatCacheMetadata
type RepositoryMockGetChatCacheMetadataExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetChatCacheMetadataParams
	paramPtrs          *RepositoryMockGetChatCacheMetadataParamPtrs
	expectationOrigins RepositoryMockGetChatCacheMetadataExpectationOrigins
	results            *RepositoryMockGetChatCacheMetadataResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetChatCacheMetadataParams contains parameters of the Repository.GetChatCacheMetadata
type RepositoryMockGetChatCacheMetadataParams struct {
	ctx      context.Context
	kbUID    types.KBUIDType
	fileUIDs []types.FileUIDType
}

// RepositoryMockGetChatCacheMetadataParamPtrs contains pointers to parameters of the Repository.GetChatCacheMetadata
type RepositoryMockGetChatCacheMetadataParamPtrs struct {
	ctx      *context.Context
	kbUID    *types.KBUIDType
	fileUIDs *[]types.FileUIDType
}

// RepositoryMockGetChatCacheMetadataResults contains results of the Repository.GetChatCacheMetadata
type RepositoryMockGetChatCacheMetadataResults struct {
	cp1 *mm_repository.ChatCacheMetadata
	err error
}

// RepositoryMockGetChatCacheMetadataOrigins contains origins of expectations of the Repository.GetChatCacheMetadata
type RepositoryMockGetChatCacheMetadataExpectationOrigins struct {
	origin         string
	originCtx      string
	originKbUID    string
	originFileUIDs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetChatCacheMetadata *mRepositoryMockGetChatCacheMetadata) Optional() *mRepositoryMockGetChatCacheMetadata {
	mmGetChatCacheMetadata.optional = true
	return mmGetChatCacheMetadata
}

// Expect sets up expected params for Repository.GetChatCacheMetadata
func (mmGetChatCacheMetadata *mRepositoryMockGetChatCacheMetadata) Expect(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType) *mRepositoryMockGetChatCacheMetadata {
	if mmGetChatCacheMetadata.mock.funcGetChatCacheMetadata != nil {
		mmGetChatCacheMetadata.mock.t.Fatalf("RepositoryMock.GetChatCacheMetadata mock is already set by Set")
	}

	if mmGetChatCacheMetadata.defaultExpectation == nil {
		mmGetChatCacheMetadata.defaultExpectation = &RepositoryMockGetChatCacheMetadataExpectation{}
	}

	if mmGetChatCacheMetadata.defaultExpectation.paramPtrs != nil {
		mmGetChatCacheMetadata.mock.t.Fatalf("RepositoryMock.GetChatCacheMetadata mock is already set by ExpectParams functions")
	}

	mmGetChatCacheMetadata.defaultExpectation.params = &RepositoryMockGetChatCacheMetadataParams{ctx, kbUID, fileUIDs}
	mmGetChatCacheMetadata.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetChatCacheMetadata.expectations {
		if minimock.Equal(e.params, mmGetChatCacheMetadata.defaultExpectation.params) {
			mmGetChatCacheMetadata.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChatCacheMetadata.defaultExpectation.params)
		}
	}

	return mmGetChatCacheMetadata
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetChatCacheMetadata
func (mmGetChatCacheMetadata *mRepositoryMockGetChatCacheMetadata) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetChatCacheMetadata {
	if mmGetChatCacheMetadata.mock.funcGetChatCacheMetadata != nil {
		mmGetChatCacheMetadata.mock.t.Fatalf("RepositoryMock.GetChatCacheMetadata mock is already set by Set")
	}

	if mmGetChatCacheMetadata.defaultExpectation == nil {
		mmGetChatCacheMetadata.defaultExpectation = &RepositoryMockGetChatCacheMetadataExpectation{}
	}

	if mmGetChatCacheMetadata.defaultExpectation.params != nil {
		mmGetChatCacheMetadata.mock.t.Fatalf("RepositoryMock.GetChatCacheMetadata mock is already set by Expect")
	}

	if mmGetChatCacheMetadata.defaultExpectation.paramPtrs == nil {
		mmGetChatCacheMetadata.defaultExpectation.paramPtrs = &RepositoryMockGetChatCacheMetadataParamPtrs{}
	}
	mmGetChatCacheMetadata.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetChatCacheMetadata.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetChatCacheMetadata
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.GetChatCacheMetadata
func (mmGetChatCacheMetadata *mRepositoryMockGetChatCacheMetadata) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockGetChatCacheMetadata {
	if mmGetChatCacheMetadata.mock.funcGetChatCacheMetadata != nil {
		mmGetChatCacheMetadata.mock.t.Fatalf("RepositoryMock.GetChatCacheMetadata mock is already set by Set")
	}

	if mmGetChatCacheMetadata.defaultExpectation == nil {
		mmGetChatCacheMetadata.defaultExpectation = &RepositoryMockGetChatCacheMetadataExpectation{}
	}

	if mmGetChatCacheMetadata.defaultExpectation.params != nil {
		mmGetChatCacheMetadata.mock.t.Fatalf("RepositoryMock.GetChatCacheMetadata mock is already set by Expect")
	}

	if mmGetChatCacheMetadata.defaultExpectation.paramPtrs == nil {
		mmGetChatCacheMetadata.defaultExpectation.paramPtrs = &RepositoryMockGetChatCacheMetadataParamPtrs{}
	}
	mmGetChatCacheMetadata.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmGetChatCacheMetadata.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmGetChatCacheMetadata
}

// ExpectFileUIDsParam3 sets up expected param fileUIDs for Repository.GetChatCacheMetadata
func (mmGetChatCacheMetadata *mRepositoryMockGetChatCacheMetadata) ExpectFileUIDsParam3(fileUIDs []types.FileUIDType) *mRepositoryMockGetChatCacheMetadata {
	if mmGetChatCacheMetadata.mock.funcGetChatCacheMetadata != nil {
		mmGetChatCacheMetadata.mock.t.Fatalf("RepositoryMock.GetChatCacheMetadata mock is already set by Set")
	}

	if mmGetChatCacheMetadata.defaultExpectation == nil {
		mmGetChatCacheMetadata.defaultExpectation = &RepositoryMockGetChatCacheMetadataExpectation{}
	}

	if mmGetChatCacheMetadata.defaultExpectation.params != nil {
		mmGetChatCacheMetadata.mock.t.Fatalf("RepositoryMock.GetChatCacheMetadata mock is already set by Expect")
	}

	if mmGetChatCacheMetadata.defaultExpectation.paramPtrs == nil {
		mmGetChatCacheMetadata.defaultExpectation.paramPtrs = &RepositoryMockGetChatCacheMetadataParamPtrs{}
	}
	mmGetChatCacheMetadata.defaultExpectation.paramPtrs.fileUIDs = &fileUIDs
	mmGetChatCacheMetadata.defaultExpectation.expectationOrigins.originFileUIDs = minimock.CallerInfo(1)

	return mmGetChatCacheMetadata
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetChatCacheMetadata
func (mmGetChatCacheMetadata *mRepositoryMockGetChatCacheMetadata) Inspect(f func(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType)) *mRepositoryMockGetChatCacheMetadata {
	if mmGetChatCacheMetadata.mock.inspectFuncGetChatCacheMetadata != nil {
		mmGetChatCacheMetadata.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetChatCacheMetadata")
	}

	mmGetChatCacheMetadata.mock.inspectFuncGetChatCacheMetadata = f

	return mmGetChatCacheMetadata
}

// Return sets up results that will be returned by Repository.GetChatCacheMetadata
func (mmGetChatCacheMetadata *mRepositoryMockGetChatCacheMetadata) Return(cp1 *mm_repository.ChatCacheMetadata, err error) *RepositoryMock {
	if mmGetChatCacheMetadata.mock.funcGetChatCacheMetadata != nil {
		mmGetChatCacheMetadata.mock.t.Fatalf("RepositoryMock.GetChatCacheMetadata mock is already set by Set")
	}

	if mmGetChatCacheMetadata.defaultExpectation == nil {
		mmGetChatCacheMetadata.defaultExpectation = &RepositoryMockGetChatCacheMetadataExpectation{mock: mmGetChatCacheMetadata.mock}
	}
	mmGetChatCacheMetadata.defaultExpectation.results = &RepositoryMockGetChatCacheMetadataResults{cp1, err}
	mmGetChatCacheMetadata.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetChatCacheMetadata.mock
}

// Set uses given function f to mock the Repository.GetChatCacheMetadata method
func (mmGetChatCacheMetadata *mRepositoryMockGetChatCacheMetadata) Set(f func(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType) (cp1 *mm_repository.ChatCacheMetadata, err error)) *RepositoryMock {
	if mmGetChatCacheMetadata.defaultExpectation != nil {
		mmGetChatCacheMetadata.mock.t.Fatalf("Default expectation is already set for the Repository.GetChatCacheMetadata method")
	}

	if len(mmGetChatCacheMetadata.expectations) > 0 {
		mmGetChatCacheMetadata.mock.t.Fatalf("Some expectations are already set for the Repository.GetChatCacheMetadata method")
	}

	mmGetChatCacheMetadata.mock.funcGetChatCacheMetadata = f
	mmGetChatCacheMetadata.mock.funcGetChatCacheMetadataOrigin = minimock.CallerInfo(1)
	return mmGetChatCacheMetadata.mock
}

// When sets expectation for the Repository.GetChatCacheMetadata which will trigger the result defined by the following
// Then helper
func (mmGetChatCacheMetadata *mRepositoryMockGetChatCacheMetadata) When(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType) *RepositoryMockGetChatCacheMetadataExpectation {
	if mmGetChatCacheMetadata.mock.funcGetChatCacheMetadata != nil {
		mmGetChatCacheMetadata.mock.t.Fatalf("RepositoryMock.GetChatCacheMetadata mock is already set by Set")
	}

	expectation := &RepositoryMockGetChatCacheMetadataExpectation{
		mock:               mmGetChatCacheMetadata.mock,
		params:             &RepositoryMockGetChatCacheMetadataParams{ctx, kbUID, fileUIDs},
		expectationOrigins: RepositoryMockGetChatCacheMetadataExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetChatCacheMetadata.expectations = append(mmGetChatCacheMetadata.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetChatCacheMetadata return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetChatCacheMetadataExpectation) Then(cp1 *mm_repository.ChatCacheMetadata, err error) *RepositoryMock {
	e.results = &RepositoryMockGetChatCacheMetadataResults{cp1, err}
	return e.mock
}

// Times sets number of times Repository.GetChatCacheMetadata should be invoked
func (mmGetChatCacheMetadata *mRepositoryMockGetChatCacheMetadata) Times(n uint64) *mRepositoryMockGetChatCacheMetadata {
	if n == 0 {
		mmGetChatCacheMetadata.mock.t.Fatalf("Times of RepositoryMock.GetChatCacheMetadata mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetChatCacheMetadata.expectedInvocations, n)
	mmGetChatCacheMetadata.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetChatCacheMetadata
}

func (mmGetChatCacheMetadata *mRepositoryMockGetChatCacheMetadata) invocationsDone() bool {
	if len(mmGetChatCacheMetadata.expectations) == 0 && mmGetChatCacheMetadata.defaultExpectation == nil && mmGetChatCacheMetadata.mock.funcGetChatCacheMetadata == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetChatCacheMetadata.mock.afterGetChatCacheMetadataCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetChatCacheMetadata.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetChatCacheMetadata implements mm_repository.Repository
func (mmGetChatCacheMetadata *RepositoryMock) GetChatCacheMetadata(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType) (cp1 *mm_repository.ChatCacheMetadata, err error) {
	mm_atomic.AddUint64(&mmGetChatCacheMetadata.beforeGetChatCacheMetadataCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChatCacheMetadata.afterGetChatCacheMetadataCounter, 1)

	mmGetChatCacheMetadata.t.Helper()

	if mmGetChatCacheMetadata.inspectFuncGetChatCacheMetadata != nil {
		mmGetChatCacheMetadata.inspectFuncGetChatCacheMetadata(ctx, kbUID, fileUIDs)
	}

	mm_params := RepositoryMockGetChatCacheMetadataParams{ctx, kbUID, fileUIDs}

	// Record call args
	mmGetChatCacheMetadata.GetChatCacheMetadataMock.mutex.Lock()
	mmGetChatCacheMetadata.GetChatCacheMetadataMock.callArgs = append(mmGetChatCacheMetadata.GetChatCacheMetadataMock.callArgs, &mm_params)
	mmGetChatCacheMetadata.GetChatCacheMetadataMock.mutex.Unlock()

	for _, e := range mmGetChatCacheMetadata.GetChatCacheMetadataMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetChatCacheMetadata.GetChatCacheMetadataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChatCacheMetadata.GetChatCacheMetadataMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChatCacheMetadata.GetChatCacheMetadataMock.defaultExpectation.params
		mm_want_ptrs := mmGetChatCacheMetadata.GetChatCacheMetadataMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetChatCacheMetadataParams{ctx, kbUID, fileUIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetChatCacheMetadata.t.Errorf("RepositoryMock.GetChatCacheMetadata got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChatCacheMetadata.GetChatCacheMetadataMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmGetChatCacheMetadata.t.Errorf("RepositoryMock.GetChatCacheMetadata got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChatCacheMetadata.GetChatCacheMetadataMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.fileUIDs != nil && !minimock.Equal(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs) {
				mmGetChatCacheMetadata.t.Errorf("RepositoryMock.GetChatCacheMetadata got unexpected parameter fileUIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChatCacheMetadata.GetChatCacheMetadataMock.defaultExpectation.expectationOrigins.originFileUIDs, *mm_want_ptrs.fileUIDs, mm_got.fileUIDs, minimock.Diff(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChatCacheMetadata.t.Errorf("RepositoryMock.GetChatCacheMetadata got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetChatCacheMetadata.GetChatCacheMetadataMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChatCacheMetadata.GetChatCacheMetadataMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChatCacheMetadata.t.Fatal("No results are set for the RepositoryMock.GetChatCacheMetadata")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetChatCacheMetadata.funcGetChatCacheMetadata != nil {
		return mmGetChatCacheMetadata.funcGetChatCacheMetadata(ctx, kbUID, fileUIDs)
	}
	mmGetChatCacheMetadata.t.Fatalf("Unexpected call to RepositoryMock.GetChatCacheMetadata. %v %v %v", ctx, kbUID, fileUIDs)
	return
}

// GetChatCacheMetadataAfterCounter returns a count of finished RepositoryMock.GetChatCacheMetadata invocations
func (mmGetChatCacheMetadata *RepositoryMock) GetChatCacheMetadataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatCacheMetadata.afterGetChatCacheMetadataCounter)
}

// GetChatCacheMetadataBeforeCounter returns a count of RepositoryMock.GetChatCacheMetadata invocations
func (mmGetChatCacheMetadata *RepositoryMock) GetChatCacheMetadataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatCacheMetadata.beforeGetChatCacheMetadataCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetChatCacheMetadata.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChatCacheMetadata *mRepositoryMockGetChatCacheMetadata) Calls() []*RepositoryMockGetChatCacheMetadataParams {
	mmGetChatCacheMetadata.mutex.RLock()

	argCopy := make([]*RepositoryMockGetChatCacheMetadataParams, len(mmGetChatCacheMetadata.callArgs))
	copy(argCopy, mmGetChatCacheMetadata.callArgs)

	mmGetChatCacheMetadata.mutex.RUnlock()

	return argCopy
}

// MinimockGetChatCacheMetadataDone returns true if the count of the GetChatCacheMetadata invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetChatCacheMetadataDone() bool {
	if m.GetChatCacheMetadataMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetChatCacheMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetChatCacheMetadataMock.invocationsDone()
}

// MinimockGetChatCacheMetadataInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetChatCacheMetadataInspect() {
	for _, e := range m.GetChatCacheMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetChatCacheMetadata at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetChatCacheMetadataCounter := mm_atomic.LoadUint64(&m.afterGetChatCacheMetadataCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatCacheMetadataMock.defaultExpectation != nil && afterGetChatCacheMetadataCounter < 1 {
		if m.GetChatCacheMetadataMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetChatCacheMetadata at\n%s", m.GetChatCacheMetadataMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetChatCacheMetadata at\n%s with params: %#v", m.GetChatCacheMetadataMock.defaultExpectation.expectationOrigins.origin, *m.GetChatCacheMetadataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChatCacheMetadata != nil && afterGetChatCacheMetadataCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetChatCacheMetadata at\n%s", m.funcGetChatCacheMetadataOrigin)
	}

	if !m.GetChatCacheMetadataMock.invocationsDone() && afterGetChatCacheMetadataCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetChatCacheMetadata at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetChatCacheMetadataMock.expectedInvocations), m.GetChatCacheMetadataMock.expectedInvocationsOrigin, afterGetChatCacheMetadataCounter)
	}
}

type mRepositoryMockGetConvertedFileByFileUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetConvertedFileByFileUIDExpectation
	expectations       []*RepositoryMockGetConvertedFileByFileUIDExpectation

	callArgs []*RepositoryMockGetConvertedFileByFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetConvertedFileByFileUIDExpectation specifies expectation struct of the Repository.GetConvertedFileByFileUID
type RepositoryMockGetConvertedFileByFileUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetConvertedFileByFileUIDParams
	paramPtrs          *RepositoryMockGetConvertedFileByFileUIDParamPtrs
	expectationOrigins RepositoryMockGetConvertedFileByFileUIDExpectationOrigins
	results            *RepositoryMockGetConvertedFileByFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetConvertedFileByFileUIDParams contains parameters of the Repository.GetConvertedFileByFileUID
type RepositoryMockGetConvertedFileByFileUIDParams struct {
	ctx     context.Context
	fileUID types.FileUIDType
}

// RepositoryMockGetConvertedFileByFileUIDParamPtrs contains pointers to parameters of the Repository.GetConvertedFileByFileUID
type RepositoryMockGetConvertedFileByFileUIDParamPtrs struct {
	ctx     *context.Context
	fileUID *types.FileUIDType
}

// RepositoryMockGetConvertedFileByFileUIDResults contains results of the Repository.GetConvertedFileByFileUID
type RepositoryMockGetConvertedFileByFileUIDResults struct {
	cp1 *mm_repository.ConvertedFileModel
	err error
}

// RepositoryMockGetConvertedFileByFileUIDOrigins contains origins of expectations of the Repository.GetConvertedFileByFileUID
type RepositoryMockGetConvertedFileByFileUIDExpectationOrigins struct {
	origin        string
	originCtx     string
	originFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetConvertedFileByFileUID *mRepositoryMockGetConvertedFileByFileUID) Optional() *mRepositoryMockGetConvertedFileByFileUID {
	mmGetConvertedFileByFileUID.optional = true
	return mmGetConvertedFileByFileUID
}

// Expect sets up expected params for Repository.GetConvertedFileByFileUID
func (mmGetConvertedFileByFileUID *mRepositoryMockGetConvertedFileByFileUID) Expect(ctx context.Context, fileUID types.FileUIDType) *mRepositoryMockGetConvertedFileByFileUID {
	if mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUID mock is already set by Set")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation == nil {
		mmGetConvertedFileByFileUID.defaultExpectation = &RepositoryMockGetConvertedFileByFileUIDExpectation{}
	}

	if mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUID mock is already set by ExpectParams functions")
	}

	mmGetConvertedFileByFileUID.defaultExpectation.params = &RepositoryMockGetConvertedFileByFileUIDParams{ctx, fileUID}
	mmGetConvertedFileByFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetConvertedFileByFileUID.expectations {
		if minimock.Equal(e.params, mmGetConvertedFileByFileUID.defaultExpectation.params) {
			mmGetConvertedFileByFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetConvertedFileByFileUID.defaultExpectation.params)
		}
	}

	return mmGetConvertedFileByFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetConvertedFileByFileUID
func (mmGetConvertedFileByFileUID *mRepositoryMockGetConvertedFileByFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetConvertedFileByFileUID {
	if mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUID mock is already set by Set")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation == nil {
		mmGetConvertedFileByFileUID.defaultExpectation = &RepositoryMockGetConvertedFileByFileUIDExpectation{}
	}

	if mmGetConvertedFileByFileUID.defaultExpectation.params != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUID mock is already set by Expect")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs = &RepositoryMockGetConvertedFileByFileUIDParamPtrs{}
	}
	mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetConvertedFileByFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetConvertedFileByFileUID
}

// ExpectFileUIDParam2 sets up expected param fileUID for Repository.GetConvertedFileByFileUID
func (mmGetConvertedFileByFileUID *mRepositoryMockGetConvertedFileByFileUID) ExpectFileUIDParam2(fileUID types.FileUIDType) *mRepositoryMockGetConvertedFileByFileUID {
	if mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUID mock is already set by Set")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation == nil {
		mmGetConvertedFileByFileUID.defaultExpectation = &RepositoryMockGetConvertedFileByFileUIDExpectation{}
	}

	if mmGetConvertedFileByFileUID.defaultExpectation.params != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUID mock is already set by Expect")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs = &RepositoryMockGetConvertedFileByFileUIDParamPtrs{}
	}
	mmGetConvertedFileByFileUID.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmGetConvertedFileByFileUID.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmGetConvertedFileByFileUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetConvertedFileByFileUID
func (mmGetConvertedFileByFileUID *mRepositoryMockGetConvertedFileByFileUID) Inspect(f func(ctx context.Context, fileUID types.FileUIDType)) *mRepositoryMockGetConvertedFileByFileUID {
	if mmGetConvertedFileByFileUID.mock.inspectFuncGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetConvertedFileByFileUID")
	}

	mmGetConvertedFileByFileUID.mock.inspectFuncGetConvertedFileByFileUID = f

	return mmGetConvertedFileByFileUID
}

// Return sets up results that will be returned by Repository.GetConvertedFileByFileUID
func (mmGetConvertedFileByFileUID *mRepositoryMockGetConvertedFileByFileUID) Return(cp1 *mm_repository.ConvertedFileModel, err error) *RepositoryMock {
	if mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUID mock is already set by Set")
	}

	if mmGetConvertedFileByFileUID.defaultExpectation == nil {
		mmGetConvertedFileByFileUID.defaultExpectation = &RepositoryMockGetConvertedFileByFileUIDExpectation{mock: mmGetConvertedFileByFileUID.mock}
	}
	mmGetConvertedFileByFileUID.defaultExpectation.results = &RepositoryMockGetConvertedFileByFileUIDResults{cp1, err}
	mmGetConvertedFileByFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetConvertedFileByFileUID.mock
}

// Set uses given function f to mock the Repository.GetConvertedFileByFileUID method
func (mmGetConvertedFileByFileUID *mRepositoryMockGetConvertedFileByFileUID) Set(f func(ctx context.Context, fileUID types.FileUIDType) (cp1 *mm_repository.ConvertedFileModel, err error)) *RepositoryMock {
	if mmGetConvertedFileByFileUID.defaultExpectation != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetConvertedFileByFileUID method")
	}

	if len(mmGetConvertedFileByFileUID.expectations) > 0 {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetConvertedFileByFileUID method")
	}

	mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID = f
	mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUIDOrigin = minimock.CallerInfo(1)
	return mmGetConvertedFileByFileUID.mock
}

// When sets expectation for the Repository.GetConvertedFileByFileUID which will trigger the result defined by the following
// Then helper
func (mmGetConvertedFileByFileUID *mRepositoryMockGetConvertedFileByFileUID) When(ctx context.Context, fileUID types.FileUIDType) *RepositoryMockGetConvertedFileByFileUIDExpectation {
	if mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetConvertedFileByFileUIDExpectation{
		mock:               mmGetConvertedFileByFileUID.mock,
		params:             &RepositoryMockGetConvertedFileByFileUIDParams{ctx, fileUID},
		expectationOrigins: RepositoryMockGetConvertedFileByFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetConvertedFileByFileUID.expectations = append(mmGetConvertedFileByFileUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetConvertedFileByFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetConvertedFileByFileUIDExpectation) Then(cp1 *mm_repository.ConvertedFileModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetConvertedFileByFileUIDResults{cp1, err}
	return e.mock
}

// Times sets number of times Repository.GetConvertedFileByFileUID should be invoked
func (mmGetConvertedFileByFileUID *mRepositoryMockGetConvertedFileByFileUID) Times(n uint64) *mRepositoryMockGetConvertedFileByFileUID {
	if n == 0 {
		mmGetConvertedFileByFileUID.mock.t.Fatalf("Times of RepositoryMock.GetConvertedFileByFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetConvertedFileByFileUID.expectedInvocations, n)
	mmGetConvertedFileByFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetConvertedFileByFileUID
}

func (mmGetConvertedFileByFileUID *mRepositoryMockGetConvertedFileByFileUID) invocationsDone() bool {
	if len(mmGetConvertedFileByFileUID.expectations) == 0 && mmGetConvertedFileByFileUID.defaultExpectation == nil && mmGetConvertedFileByFileUID.mock.funcGetConvertedFileByFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetConvertedFileByFileUID.mock.afterGetConvertedFileByFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetConvertedFileByFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetConvertedFileByFileUID implements mm_repository.Repository
func (mmGetConvertedFileByFileUID *RepositoryMock) GetConvertedFileByFileUID(ctx context.Context, fileUID types.FileUIDType) (cp1 *mm_repository.ConvertedFileModel, err error) {
	mm_atomic.AddUint64(&mmGetConvertedFileByFileUID.beforeGetConvertedFileByFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetConvertedFileByFileUID.afterGetConvertedFileByFileUIDCounter, 1)

	mmGetConvertedFileByFileUID.t.Helper()

	if mmGetConvertedFileByFileUID.inspectFuncGetConvertedFileByFileUID != nil {
		mmGetConvertedFileByFileUID.inspectFuncGetConvertedFileByFileUID(ctx, fileUID)
	}

	mm_params := RepositoryMockGetConvertedFileByFileUIDParams{ctx, fileUID}

	// Record call args
	mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.mutex.Lock()
	mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.callArgs = append(mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.callArgs, &mm_params)
	mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.mutex.Unlock()

	for _, e := range mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetConvertedFileByFileUIDParams{ctx, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetConvertedFileByFileUID.t.Errorf("RepositoryMock.GetConvertedFileByFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmGetConvertedFileByFileUID.t.Errorf("RepositoryMock.GetConvertedFileByFileUID got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetConvertedFileByFileUID.t.Errorf("RepositoryMock.GetConvertedFileByFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetConvertedFileByFileUID.GetConvertedFileByFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetConvertedFileByFileUID.t.Fatal("No results are set for the RepositoryMock.GetConvertedFileByFileUID")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetConvertedFileByFileUID.funcGetConvertedFileByFileUID != nil {
		return mmGetConvertedFileByFileUID.funcGetConvertedFileByFileUID(ctx, fileUID)
	}
	mmGetConvertedFileByFileUID.t.Fatalf("Unexpected call to RepositoryMock.GetConvertedFileByFileUID. %v %v", ctx, fileUID)
	return
}

// GetConvertedFileByFileUIDAfterCounter returns a count of finished RepositoryMock.GetConvertedFileByFileUID invocations
func (mmGetConvertedFileByFileUID *RepositoryMock) GetConvertedFileByFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConvertedFileByFileUID.afterGetConvertedFileByFileUIDCounter)
}

// GetConvertedFileByFileUIDBeforeCounter returns a count of RepositoryMock.GetConvertedFileByFileUID invocations
func (mmGetConvertedFileByFileUID *RepositoryMock) GetConvertedFileByFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConvertedFileByFileUID.beforeGetConvertedFileByFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetConvertedFileByFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetConvertedFileByFileUID *mRepositoryMockGetConvertedFileByFileUID) Calls() []*RepositoryMockGetConvertedFileByFileUIDParams {
	mmGetConvertedFileByFileUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetConvertedFileByFileUIDParams, len(mmGetConvertedFileByFileUID.callArgs))
	copy(argCopy, mmGetConvertedFileByFileUID.callArgs)

	mmGetConvertedFileByFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetConvertedFileByFileUIDDone returns true if the count of the GetConvertedFileByFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetConvertedFileByFileUIDDone() bool {
	if m.GetConvertedFileByFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetConvertedFileByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetConvertedFileByFileUIDMock.invocationsDone()
}

// MinimockGetConvertedFileByFileUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetConvertedFileByFileUIDInspect() {
	for _, e := range m.GetConvertedFileByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetConvertedFileByFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetConvertedFileByFileUIDCounter := mm_atomic.LoadUint64(&m.afterGetConvertedFileByFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetConvertedFileByFileUIDMock.defaultExpectation != nil && afterGetConvertedFileByFileUIDCounter < 1 {
		if m.GetConvertedFileByFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetConvertedFileByFileUID at\n%s", m.GetConvertedFileByFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetConvertedFileByFileUID at\n%s with params: %#v", m.GetConvertedFileByFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetConvertedFileByFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetConvertedFileByFileUID != nil && afterGetConvertedFileByFileUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetConvertedFileByFileUID at\n%s", m.funcGetConvertedFileByFileUIDOrigin)
	}

	if !m.GetConvertedFileByFileUIDMock.invocationsDone() && afterGetConvertedFileByFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetConvertedFileByFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetConvertedFileByFileUIDMock.expectedInvocations), m.GetConvertedFileByFileUIDMock.expectedInvocationsOrigin, afterGetConvertedFileByFileUIDCounter)
	}
}

type mRepositoryMockGetConvertedFileByFileUIDAndType struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetConvertedFileByFileUIDAndTypeExpectation
	expectations       []*RepositoryMockGetConvertedFileByFileUIDAndTypeExpectation

	callArgs []*RepositoryMockGetConvertedFileByFileUIDAndTypeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetConvertedFileByFileUIDAndTypeExpectation specifies expectation struct of the Repository.GetConvertedFileByFileUIDAndType
type RepositoryMockGetConvertedFileByFileUIDAndTypeExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetConvertedFileByFileUIDAndTypeParams
	paramPtrs          *RepositoryMockGetConvertedFileByFileUIDAndTypeParamPtrs
	expectationOrigins RepositoryMockGetConvertedFileByFileUIDAndTypeExpectationOrigins
	results            *RepositoryMockGetConvertedFileByFileUIDAndTypeResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetConvertedFileByFileUIDAndTypeParams contains parameters of the Repository.GetConvertedFileByFileUIDAndType
type RepositoryMockGetConvertedFileByFileUIDAndTypeParams struct {
	ctx           context.Context
	fileUID       types.FileUIDType
	convertedType artifactpb.ConvertedFileType
}

// RepositoryMockGetConvertedFileByFileUIDAndTypeParamPtrs contains pointers to parameters of the Repository.GetConvertedFileByFileUIDAndType
type RepositoryMockGetConvertedFileByFileUIDAndTypeParamPtrs struct {
	ctx           *context.Context
	fileUID       *types.FileUIDType
	convertedType *artifactpb.ConvertedFileType
}

// RepositoryMockGetConvertedFileByFileUIDAndTypeResults contains results of the Repository.GetConvertedFileByFileUIDAndType
type RepositoryMockGetConvertedFileByFileUIDAndTypeResults struct {
	cp1 *mm_repository.ConvertedFileModel
	err error
}

// RepositoryMockGetConvertedFileByFileUIDAndTypeOrigins contains origins of expectations of the Repository.GetConvertedFileByFileUIDAndType
type RepositoryMockGetConvertedFileByFileUIDAndTypeExpectationOrigins struct {
	origin              string
	originCtx           string
	originFileUID       string
	originConvertedType string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetConvertedFileByFileUIDAndType *mRepositoryMockGetConvertedFileByFileUIDAndType) Optional() *mRepositoryMockGetConvertedFileByFileUIDAndType {
	mmGetConvertedFileByFileUIDAndType.optional = true
	return mmGetConvertedFileByFileUIDAndType
}

// Expect sets up expected params for Repository.GetConvertedFileByFileUIDAndType
func (mmGetConvertedFileByFileUIDAndType *mRepositoryMockGetConvertedFileByFileUIDAndType) Expect(ctx context.Context, fileUID types.FileUIDType, convertedType artifactpb.ConvertedFileType) *mRepositoryMockGetConvertedFileByFileUIDAndType {
	if mmGetConvertedFileByFileUIDAndType.mock.funcGetConvertedFileByFileUIDAndType != nil {
		mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUIDAndType mock is already set by Set")
	}

	if mmGetConvertedFileByFileUIDAndType.defaultExpectation == nil {
		mmGetConvertedFileByFileUIDAndType.defaultExpectation = &RepositoryMockGetConvertedFileByFileUIDAndTypeExpectation{}
	}

	if mmGetConvertedFileByFileUIDAndType.defaultExpectation.paramPtrs != nil {
		mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUIDAndType mock is already set by ExpectParams functions")
	}

	mmGetConvertedFileByFileUIDAndType.defaultExpectation.params = &RepositoryMockGetConvertedFileByFileUIDAndTypeParams{ctx, fileUID, convertedType}
	mmGetConvertedFileByFileUIDAndType.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetConvertedFileByFileUIDAndType.expectations {
		if minimock.Equal(e.params, mmGetConvertedFileByFileUIDAndType.defaultExpectation.params) {
			mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetConvertedFileByFileUIDAndType.defaultExpectation.params)
		}
	}

	return mmGetConvertedFileByFileUIDAndType
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetConvertedFileByFileUIDAndType
func (mmGetConvertedFileByFileUIDAndType *mRepositoryMockGetConvertedFileByFileUIDAndType) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetConvertedFileByFileUIDAndType {
	if mmGetConvertedFileByFileUIDAndType.mock.funcGetConvertedFileByFileUIDAndType != nil {
		mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUIDAndType mock is already set by Set")
	}

	if mmGetConvertedFileByFileUIDAndType.defaultExpectation == nil {
		mmGetConvertedFileByFileUIDAndType.defaultExpectation = &RepositoryMockGetConvertedFileByFileUIDAndTypeExpectation{}
	}

	if mmGetConvertedFileByFileUIDAndType.defaultExpectation.params != nil {
		mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUIDAndType mock is already set by Expect")
	}

	if mmGetConvertedFileByFileUIDAndType.defaultExpectation.paramPtrs == nil {
		mmGetConvertedFileByFileUIDAndType.defaultExpectation.paramPtrs = &RepositoryMockGetConvertedFileByFileUIDAndTypeParamPtrs{}
	}
	mmGetConvertedFileByFileUIDAndType.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetConvertedFileByFileUIDAndType.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetConvertedFileByFileUIDAndType
}

// ExpectFileUIDParam2 sets up expected param fileUID for Repository.GetConvertedFileByFileUIDAndType
func (mmGetConvertedFileByFileUIDAndType *mRepositoryMockGetConvertedFileByFileUIDAndType) ExpectFileUIDParam2(fileUID types.FileUIDType) *mRepositoryMockGetConvertedFileByFileUIDAndType {
	if mmGetConvertedFileByFileUIDAndType.mock.funcGetConvertedFileByFileUIDAndType != nil {
		mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUIDAndType mock is already set by Set")
	}

	if mmGetConvertedFileByFileUIDAndType.defaultExpectation == nil {
		mmGetConvertedFileByFileUIDAndType.defaultExpectation = &RepositoryMockGetConvertedFileByFileUIDAndTypeExpectation{}
	}

	if mmGetConvertedFileByFileUIDAndType.defaultExpectation.params != nil {
		mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUIDAndType mock is already set by Expect")
	}

	if mmGetConvertedFileByFileUIDAndType.defaultExpectation.paramPtrs == nil {
		mmGetConvertedFileByFileUIDAndType.defaultExpectation.paramPtrs = &RepositoryMockGetConvertedFileByFileUIDAndTypeParamPtrs{}
	}
	mmGetConvertedFileByFileUIDAndType.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmGetConvertedFileByFileUIDAndType.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmGetConvertedFileByFileUIDAndType
}

// ExpectConvertedTypeParam3 sets up expected param convertedType for Repository.GetConvertedFileByFileUIDAndType
func (mmGetConvertedFileByFileUIDAndType *mRepositoryMockGetConvertedFileByFileUIDAndType) ExpectConvertedTypeParam3(convertedType artifactpb.ConvertedFileType) *mRepositoryMockGetConvertedFileByFileUIDAndType {
	if mmGetConvertedFileByFileUIDAndType.mock.funcGetConvertedFileByFileUIDAndType != nil {
		mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUIDAndType mock is already set by Set")
	}

	if mmGetConvertedFileByFileUIDAndType.defaultExpectation == nil {
		mmGetConvertedFileByFileUIDAndType.defaultExpectation = &RepositoryMockGetConvertedFileByFileUIDAndTypeExpectation{}
	}

	if mmGetConvertedFileByFileUIDAndType.defaultExpectation.params != nil {
		mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUIDAndType mock is already set by Expect")
	}

	if mmGetConvertedFileByFileUIDAndType.defaultExpectation.paramPtrs == nil {
		mmGetConvertedFileByFileUIDAndType.defaultExpectation.paramPtrs = &RepositoryMockGetConvertedFileByFileUIDAndTypeParamPtrs{}
	}
	mmGetConvertedFileByFileUIDAndType.defaultExpectation.paramPtrs.convertedType = &convertedType
	mmGetConvertedFileByFileUIDAndType.defaultExpectation.expectationOrigins.originConvertedType = minimock.CallerInfo(1)

	return mmGetConvertedFileByFileUIDAndType
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetConvertedFileByFileUIDAndType
func (mmGetConvertedFileByFileUIDAndType *mRepositoryMockGetConvertedFileByFileUIDAndType) Inspect(f func(ctx context.Context, fileUID types.FileUIDType, convertedType artifactpb.ConvertedFileType)) *mRepositoryMockGetConvertedFileByFileUIDAndType {
	if mmGetConvertedFileByFileUIDAndType.mock.inspectFuncGetConvertedFileByFileUIDAndType != nil {
		mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetConvertedFileByFileUIDAndType")
	}

	mmGetConvertedFileByFileUIDAndType.mock.inspectFuncGetConvertedFileByFileUIDAndType = f

	return mmGetConvertedFileByFileUIDAndType
}

// Return sets up results that will be returned by Repository.GetConvertedFileByFileUIDAndType
func (mmGetConvertedFileByFileUIDAndType *mRepositoryMockGetConvertedFileByFileUIDAndType) Return(cp1 *mm_repository.ConvertedFileModel, err error) *RepositoryMock {
	if mmGetConvertedFileByFileUIDAndType.mock.funcGetConvertedFileByFileUIDAndType != nil {
		mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUIDAndType mock is already set by Set")
	}

	if mmGetConvertedFileByFileUIDAndType.defaultExpectation == nil {
		mmGetConvertedFileByFileUIDAndType.defaultExpectation = &RepositoryMockGetConvertedFileByFileUIDAndTypeExpectation{mock: mmGetConvertedFileByFileUIDAndType.mock}
	}
	mmGetConvertedFileByFileUIDAndType.defaultExpectation.results = &RepositoryMockGetConvertedFileByFileUIDAndTypeResults{cp1, err}
	mmGetConvertedFileByFileUIDAndType.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetConvertedFileByFileUIDAndType.mock
}

// Set uses given function f to mock the Repository.GetConvertedFileByFileUIDAndType method
func (mmGetConvertedFileByFileUIDAndType *mRepositoryMockGetConvertedFileByFileUIDAndType) Set(f func(ctx context.Context, fileUID types.FileUIDType, convertedType artifactpb.ConvertedFileType) (cp1 *mm_repository.ConvertedFileModel, err error)) *RepositoryMock {
	if mmGetConvertedFileByFileUIDAndType.defaultExpectation != nil {
		mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("Default expectation is already set for the Repository.GetConvertedFileByFileUIDAndType method")
	}

	if len(mmGetConvertedFileByFileUIDAndType.expectations) > 0 {
		mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("Some expectations are already set for the Repository.GetConvertedFileByFileUIDAndType method")
	}

	mmGetConvertedFileByFileUIDAndType.mock.funcGetConvertedFileByFileUIDAndType = f
	mmGetConvertedFileByFileUIDAndType.mock.funcGetConvertedFileByFileUIDAndTypeOrigin = minimock.CallerInfo(1)
	return mmGetConvertedFileByFileUIDAndType.mock
}

// When sets expectation for the Repository.GetConvertedFileByFileUIDAndType which will trigger the result defined by the following
// Then helper
func (mmGetConvertedFileByFileUIDAndType *mRepositoryMockGetConvertedFileByFileUIDAndType) When(ctx context.Context, fileUID types.FileUIDType, convertedType artifactpb.ConvertedFileType) *RepositoryMockGetConvertedFileByFileUIDAndTypeExpectation {
	if mmGetConvertedFileByFileUIDAndType.mock.funcGetConvertedFileByFileUIDAndType != nil {
		mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("RepositoryMock.GetConvertedFileByFileUIDAndType mock is already set by Set")
	}

	expectation := &RepositoryMockGetConvertedFileByFileUIDAndTypeExpectation{
		mock:               mmGetConvertedFileByFileUIDAndType.mock,
		params:             &RepositoryMockGetConvertedFileByFileUIDAndTypeParams{ctx, fileUID, convertedType},
		expectationOrigins: RepositoryMockGetConvertedFileByFileUIDAndTypeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetConvertedFileByFileUIDAndType.expectations = append(mmGetConvertedFileByFileUIDAndType.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetConvertedFileByFileUIDAndType return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetConvertedFileByFileUIDAndTypeExpectation) Then(cp1 *mm_repository.ConvertedFileModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetConvertedFileByFileUIDAndTypeResults{cp1, err}
	return e.mock
}

// Times sets number of times Repository.GetConvertedFileByFileUIDAndType should be invoked
func (mmGetConvertedFileByFileUIDAndType *mRepositoryMockGetConvertedFileByFileUIDAndType) Times(n uint64) *mRepositoryMockGetConvertedFileByFileUIDAndType {
	if n == 0 {
		mmGetConvertedFileByFileUIDAndType.mock.t.Fatalf("Times of RepositoryMock.GetConvertedFileByFileUIDAndType mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetConvertedFileByFileUIDAndType.expectedInvocations, n)
	mmGetConvertedFileByFileUIDAndType.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetConvertedFileByFileUIDAndType
}

func (mmGetConvertedFileByFileUIDAndType *mRepositoryMockGetConvertedFileByFileUIDAndType) invocationsDone() bool {
	if len(mmGetConvertedFileByFileUIDAndType.expectations) == 0 && mmGetConvertedFileByFileUIDAndType.defaultExpectation == nil && mmGetConvertedFileByFileUIDAndType.mock.funcGetConvertedFileByFileUIDAndType == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetConvertedFileByFileUIDAndType.mock.afterGetConvertedFileByFileUIDAndTypeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetConvertedFileByFileUIDAndType.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetConvertedFileByFileUIDAndType implements mm_repository.Repository
func (mmGetConvertedFileByFileUIDAndType *RepositoryMock) GetConvertedFileByFileUIDAndType(ctx context.Context, fileUID types.FileUIDType, convertedType artifactpb.ConvertedFileType) (cp1 *mm_repository.ConvertedFileModel, err error) {
	mm_atomic.AddUint64(&mmGetConvertedFileByFileUIDAndType.beforeGetConvertedFileByFileUIDAndTypeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetConvertedFileByFileUIDAndType.afterGetConvertedFileByFileUIDAndTypeCounter, 1)

	mmGetConvertedFileByFileUIDAndType.t.Helper()

	if mmGetConvertedFileByFileUIDAndType.inspectFuncGetConvertedFileByFileUIDAndType != nil {
		mmGetConvertedFileByFileUIDAndType.inspectFuncGetConvertedFileByFileUIDAndType(ctx, fileUID, convertedType)
	}

	mm_params := RepositoryMockGetConvertedFileByFileUIDAndTypeParams{ctx, fileUID, convertedType}

	// Record call args
	mmGetConvertedFileByFileUIDAndType.GetConvertedFileByFileUIDAndTypeMock.mutex.Lock()
	mmGetConvertedFileByFileUIDAndType.GetConvertedFileByFileUIDAndTypeMock.callArgs = append(mmGetConvertedFileByFileUIDAndType.GetConvertedFileByFileUIDAndTypeMock.callArgs, &mm_params)
	mmGetConvertedFileByFileUIDAndType.GetConvertedFileByFileUIDAndTypeMock.mutex.Unlock()

	for _, e := range mmGetConvertedFileByFileUIDAndType.GetConvertedFileByFileUIDAndTypeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetConvertedFileByFileUIDAndType.GetConvertedFileByFileUIDAndTypeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetConvertedFileByFileUIDAndType.GetConvertedFileByFileUIDAndTypeMock.defaultExpectation.Counter, 1)
		mm_want := mmGetConvertedFileByFileUIDAndType.GetConvertedFileByFileUIDAndTypeMock.defaultExpectation.params
		mm_want_ptrs := mmGetConvertedFileByFileUIDAndType.GetConvertedFileByFileUIDAndTypeMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetConvertedFileByFileUIDAndTypeParams{ctx, fileUID, convertedType}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetConvertedFileByFileUIDAndType.t.Errorf("RepositoryMock.GetConvertedFileByFileUIDAndType got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetConvertedFileByFileUIDAndType.GetConvertedFileByFileUIDAndTypeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmGetConvertedFileByFileUIDAndType.t.Errorf("RepositoryMock.GetConvertedFileByFileUIDAndType got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetConvertedFileByFileUIDAndType.GetConvertedFileByFileUIDAndTypeMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

			if mm_want_ptrs.convertedType != nil && !minimock.Equal(*mm_want_ptrs.convertedType, mm_got.convertedType) {
				mmGetConvertedFileByFileUIDAndType.t.Errorf("RepositoryMock.GetConvertedFileByFileUIDAndType got unexpected parameter convertedType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetConvertedFileByFileUIDAndType.GetConvertedFileByFileUIDAndTypeMock.defaultExpectation.expectationOrigins.originConvertedType, *mm_want_ptrs.convertedType, mm_got.convertedType, minimock.Diff(*mm_want_ptrs.convertedType, mm_got.convertedType))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetConvertedFileByFileUIDAndType.t.Errorf("RepositoryMock.GetConvertedFileByFileUIDAndType got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetConvertedFileByFileUIDAndType.GetConvertedFileByFileUIDAndTypeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetConvertedFileByFileUIDAndType.GetConvertedFileByFileUIDAndTypeMock.defaultExpectation.results
		if mm_results == nil {
			mmGetConvertedFileByFileUIDAndType.t.Fatal("No results are set for the RepositoryMock.GetConvertedFileByFileUIDAndType")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetConvertedFileByFileUIDAndType.funcGetConvertedFileByFileUIDAndType != nil {
		return mmGetConvertedFileByFileUIDAndType.funcGetConvertedFileByFileUIDAndType(ctx, fileUID, convertedType)
	}
	mmGetConvertedFileByFileUIDAndType.t.Fatalf("Unexpected call to RepositoryMock.GetConvertedFileByFileUIDAndType. %v %v %v", ctx, fileUID, convertedType)
	return
}

// GetConvertedFileByFileUIDAndTypeAfterCounter returns a count of finished RepositoryMock.GetConvertedFileByFileUIDAndType invocations
func (mmGetConvertedFileByFileUIDAndType *RepositoryMock) GetConvertedFileByFileUIDAndTypeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConvertedFileByFileUIDAndType.afterGetConvertedFileByFileUIDAndTypeCounter)
}

// GetConvertedFileByFileUIDAndTypeBeforeCounter returns a count of RepositoryMock.GetConvertedFileByFileUIDAndType invocations
func (mmGetConvertedFileByFileUIDAndType *RepositoryMock) GetConvertedFileByFileUIDAndTypeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConvertedFileByFileUIDAndType.beforeGetConvertedFileByFileUIDAndTypeCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetConvertedFileByFileUIDAndType.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetConvertedFileByFileUIDAndType *mRepositoryMockGetConvertedFileByFileUIDAndType) Calls() []*RepositoryMockGetConvertedFileByFileUIDAndTypeParams {
	mmGetConvertedFileByFileUIDAndType.mutex.RLock()

	argCopy := make([]*RepositoryMockGetConvertedFileByFileUIDAndTypeParams, len(mmGetConvertedFileByFileUIDAndType.callArgs))
	copy(argCopy, mmGetConvertedFileByFileUIDAndType.callArgs)

	mmGetConvertedFileByFileUIDAndType.mutex.RUnlock()

	return argCopy
}

// MinimockGetConvertedFileByFileUIDAndTypeDone returns true if the count of the GetConvertedFileByFileUIDAndType invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetConvertedFileByFileUIDAndTypeDone() bool {
	if m.GetConvertedFileByFileUIDAndTypeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetConvertedFileByFileUIDAndTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetConvertedFileByFileUIDAndTypeMock.invocationsDone()
}

// MinimockGetConvertedFileByFileUIDAndTypeInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetConvertedFileByFileUIDAndTypeInspect() {
	for _, e := range m.GetConvertedFileByFileUIDAndTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetConvertedFileByFileUIDAndType at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetConvertedFileByFileUIDAndTypeCounter := mm_atomic.LoadUint64(&m.afterGetConvertedFileByFileUIDAndTypeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetConvertedFileByFileUIDAndTypeMock.defaultExpectation != nil && afterGetConvertedFileByFileUIDAndTypeCounter < 1 {
		if m.GetConvertedFileByFileUIDAndTypeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetConvertedFileByFileUIDAndType at\n%s", m.GetConvertedFileByFileUIDAndTypeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetConvertedFileByFileUIDAndType at\n%s with params: %#v", m.GetConvertedFileByFileUIDAndTypeMock.defaultExpectation.expectationOrigins.origin, *m.GetConvertedFileByFileUIDAndTypeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetConvertedFileByFileUIDAndType != nil && afterGetConvertedFileByFileUIDAndTypeCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetConvertedFileByFileUIDAndType at\n%s", m.funcGetConvertedFileByFileUIDAndTypeOrigin)
	}

	if !m.GetConvertedFileByFileUIDAndTypeMock.invocationsDone() && afterGetConvertedFileByFileUIDAndTypeCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetConvertedFileByFileUIDAndType at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetConvertedFileByFileUIDAndTypeMock.expectedInvocations), m.GetConvertedFileByFileUIDAndTypeMock.expectedInvocationsOrigin, afterGetConvertedFileByFileUIDAndTypeCounter)
	}
}

type mRepositoryMockGetCountFilesByListKnowledgeBaseUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetCountFilesByListKnowledgeBaseUIDExpectation
	expectations       []*RepositoryMockGetCountFilesByListKnowledgeBaseUIDExpectation

	callArgs []*RepositoryMockGetCountFilesByListKnowledgeBaseUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetCountFilesByListKnowledgeBaseUIDExpectation specifies expectation struct of the Repository.GetCountFilesByListKnowledgeBaseUID
type RepositoryMockGetCountFilesByListKnowledgeBaseUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetCountFilesByListKnowledgeBaseUIDParams
	paramPtrs          *RepositoryMockGetCountFilesByListKnowledgeBaseUIDParamPtrs
	expectationOrigins RepositoryMockGetCountFilesByListKnowledgeBaseUIDExpectationOrigins
	results            *RepositoryMockGetCountFilesByListKnowledgeBaseUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetCountFilesByListKnowledgeBaseUIDParams contains parameters of the Repository.GetCountFilesByListKnowledgeBaseUID
type RepositoryMockGetCountFilesByListKnowledgeBaseUIDParams struct {
	ctx    context.Context
	kbUIDs []types.KBUIDType
}

// RepositoryMockGetCountFilesByListKnowledgeBaseUIDParamPtrs contains pointers to parameters of the Repository.GetCountFilesByListKnowledgeBaseUID
type RepositoryMockGetCountFilesByListKnowledgeBaseUIDParamPtrs struct {
	ctx    *context.Context
	kbUIDs *[]types.KBUIDType
}

// RepositoryMockGetCountFilesByListKnowledgeBaseUIDResults contains results of the Repository.GetCountFilesByListKnowledgeBaseUID
type RepositoryMockGetCountFilesByListKnowledgeBaseUIDResults struct {
	m1  map[types.KBUIDType]int64
	err error
}

// RepositoryMockGetCountFilesByListKnowledgeBaseUIDOrigins contains origins of expectations of the Repository.GetCountFilesByListKnowledgeBaseUID
type RepositoryMockGetCountFilesByListKnowledgeBaseUIDExpectationOrigins struct {
	origin       string
	originCtx    string
	originKbUIDs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryMockGetCountFilesByListKnowledgeBaseUID) Optional() *mRepositoryMockGetCountFilesByListKnowledgeBaseUID {
	mmGetCountFilesByListKnowledgeBaseUID.optional = true
	return mmGetCountFilesByListKnowledgeBaseUID
}

// Expect sets up expected params for Repository.GetCountFilesByListKnowledgeBaseUID
func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryMockGetCountFilesByListKnowledgeBaseUID) Expect(ctx context.Context, kbUIDs []types.KBUIDType) *mRepositoryMockGetCountFilesByListKnowledgeBaseUID {
	if mmGetCountFilesByListKnowledgeBaseUID.mock.funcGetCountFilesByListKnowledgeBaseUID != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("RepositoryMock.GetCountFilesByListKnowledgeBaseUID mock is already set by Set")
	}

	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation == nil {
		mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation = &RepositoryMockGetCountFilesByListKnowledgeBaseUIDExpectation{}
	}

	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.paramPtrs != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("RepositoryMock.GetCountFilesByListKnowledgeBaseUID mock is already set by ExpectParams functions")
	}

	mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.params = &RepositoryMockGetCountFilesByListKnowledgeBaseUIDParams{ctx, kbUIDs}
	mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCountFilesByListKnowledgeBaseUID.expectations {
		if minimock.Equal(e.params, mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.params) {
			mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.params)
		}
	}

	return mmGetCountFilesByListKnowledgeBaseUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetCountFilesByListKnowledgeBaseUID
func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryMockGetCountFilesByListKnowledgeBaseUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetCountFilesByListKnowledgeBaseUID {
	if mmGetCountFilesByListKnowledgeBaseUID.mock.funcGetCountFilesByListKnowledgeBaseUID != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("RepositoryMock.GetCountFilesByListKnowledgeBaseUID mock is already set by Set")
	}

	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation == nil {
		mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation = &RepositoryMockGetCountFilesByListKnowledgeBaseUIDExpectation{}
	}

	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.params != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("RepositoryMock.GetCountFilesByListKnowledgeBaseUID mock is already set by Expect")
	}

	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.paramPtrs == nil {
		mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.paramPtrs = &RepositoryMockGetCountFilesByListKnowledgeBaseUIDParamPtrs{}
	}
	mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetCountFilesByListKnowledgeBaseUID
}

// ExpectKbUIDsParam2 sets up expected param kbUIDs for Repository.GetCountFilesByListKnowledgeBaseUID
func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryMockGetCountFilesByListKnowledgeBaseUID) ExpectKbUIDsParam2(kbUIDs []types.KBUIDType) *mRepositoryMockGetCountFilesByListKnowledgeBaseUID {
	if mmGetCountFilesByListKnowledgeBaseUID.mock.funcGetCountFilesByListKnowledgeBaseUID != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("RepositoryMock.GetCountFilesByListKnowledgeBaseUID mock is already set by Set")
	}

	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation == nil {
		mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation = &RepositoryMockGetCountFilesByListKnowledgeBaseUIDExpectation{}
	}

	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.params != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("RepositoryMock.GetCountFilesByListKnowledgeBaseUID mock is already set by Expect")
	}

	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.paramPtrs == nil {
		mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.paramPtrs = &RepositoryMockGetCountFilesByListKnowledgeBaseUIDParamPtrs{}
	}
	mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.paramPtrs.kbUIDs = &kbUIDs
	mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.expectationOrigins.originKbUIDs = minimock.CallerInfo(1)

	return mmGetCountFilesByListKnowledgeBaseUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetCountFilesByListKnowledgeBaseUID
func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryMockGetCountFilesByListKnowledgeBaseUID) Inspect(f func(ctx context.Context, kbUIDs []types.KBUIDType)) *mRepositoryMockGetCountFilesByListKnowledgeBaseUID {
	if mmGetCountFilesByListKnowledgeBaseUID.mock.inspectFuncGetCountFilesByListKnowledgeBaseUID != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetCountFilesByListKnowledgeBaseUID")
	}

	mmGetCountFilesByListKnowledgeBaseUID.mock.inspectFuncGetCountFilesByListKnowledgeBaseUID = f

	return mmGetCountFilesByListKnowledgeBaseUID
}

// Return sets up results that will be returned by Repository.GetCountFilesByListKnowledgeBaseUID
func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryMockGetCountFilesByListKnowledgeBaseUID) Return(m1 map[types.KBUIDType]int64, err error) *RepositoryMock {
	if mmGetCountFilesByListKnowledgeBaseUID.mock.funcGetCountFilesByListKnowledgeBaseUID != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("RepositoryMock.GetCountFilesByListKnowledgeBaseUID mock is already set by Set")
	}

	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation == nil {
		mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation = &RepositoryMockGetCountFilesByListKnowledgeBaseUIDExpectation{mock: mmGetCountFilesByListKnowledgeBaseUID.mock}
	}
	mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.results = &RepositoryMockGetCountFilesByListKnowledgeBaseUIDResults{m1, err}
	mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCountFilesByListKnowledgeBaseUID.mock
}

// Set uses given function f to mock the Repository.GetCountFilesByListKnowledgeBaseUID method
func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryMockGetCountFilesByListKnowledgeBaseUID) Set(f func(ctx context.Context, kbUIDs []types.KBUIDType) (m1 map[types.KBUIDType]int64, err error)) *RepositoryMock {
	if mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetCountFilesByListKnowledgeBaseUID method")
	}

	if len(mmGetCountFilesByListKnowledgeBaseUID.expectations) > 0 {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetCountFilesByListKnowledgeBaseUID method")
	}

	mmGetCountFilesByListKnowledgeBaseUID.mock.funcGetCountFilesByListKnowledgeBaseUID = f
	mmGetCountFilesByListKnowledgeBaseUID.mock.funcGetCountFilesByListKnowledgeBaseUIDOrigin = minimock.CallerInfo(1)
	return mmGetCountFilesByListKnowledgeBaseUID.mock
}

// When sets expectation for the Repository.GetCountFilesByListKnowledgeBaseUID which will trigger the result defined by the following
// Then helper
func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryMockGetCountFilesByListKnowledgeBaseUID) When(ctx context.Context, kbUIDs []types.KBUIDType) *RepositoryMockGetCountFilesByListKnowledgeBaseUIDExpectation {
	if mmGetCountFilesByListKnowledgeBaseUID.mock.funcGetCountFilesByListKnowledgeBaseUID != nil {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("RepositoryMock.GetCountFilesByListKnowledgeBaseUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetCountFilesByListKnowledgeBaseUIDExpectation{
		mock:               mmGetCountFilesByListKnowledgeBaseUID.mock,
		params:             &RepositoryMockGetCountFilesByListKnowledgeBaseUIDParams{ctx, kbUIDs},
		expectationOrigins: RepositoryMockGetCountFilesByListKnowledgeBaseUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCountFilesByListKnowledgeBaseUID.expectations = append(mmGetCountFilesByListKnowledgeBaseUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetCountFilesByListKnowledgeBaseUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetCountFilesByListKnowledgeBaseUIDExpectation) Then(m1 map[types.KBUIDType]int64, err error) *RepositoryMock {
	e.results = &RepositoryMockGetCountFilesByListKnowledgeBaseUIDResults{m1, err}
	return e.mock
}

// Times sets number of times Repository.GetCountFilesByListKnowledgeBaseUID should be invoked
func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryMockGetCountFilesByListKnowledgeBaseUID) Times(n uint64) *mRepositoryMockGetCountFilesByListKnowledgeBaseUID {
	if n == 0 {
		mmGetCountFilesByListKnowledgeBaseUID.mock.t.Fatalf("Times of RepositoryMock.GetCountFilesByListKnowledgeBaseUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCountFilesByListKnowledgeBaseUID.expectedInvocations, n)
	mmGetCountFilesByListKnowledgeBaseUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCountFilesByListKnowledgeBaseUID
}

func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryMockGetCountFilesByListKnowledgeBaseUID) invocationsDone() bool {
	if len(mmGetCountFilesByListKnowledgeBaseUID.expectations) == 0 && mmGetCountFilesByListKnowledgeBaseUID.defaultExpectation == nil && mmGetCountFilesByListKnowledgeBaseUID.mock.funcGetCountFilesByListKnowledgeBaseUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCountFilesByListKnowledgeBaseUID.mock.afterGetCountFilesByListKnowledgeBaseUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCountFilesByListKnowledgeBaseUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCountFilesByListKnowledgeBaseUID implements mm_repository.Repository
func (mmGetCountFilesByListKnowledgeBaseUID *RepositoryMock) GetCountFilesByListKnowledgeBaseUID(ctx context.Context, kbUIDs []types.KBUIDType) (m1 map[types.KBUIDType]int64, err error) {
	mm_atomic.AddUint64(&mmGetCountFilesByListKnowledgeBaseUID.beforeGetCountFilesByListKnowledgeBaseUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCountFilesByListKnowledgeBaseUID.afterGetCountFilesByListKnowledgeBaseUIDCounter, 1)

	mmGetCountFilesByListKnowledgeBaseUID.t.Helper()

	if mmGetCountFilesByListKnowledgeBaseUID.inspectFuncGetCountFilesByListKnowledgeBaseUID != nil {
		mmGetCountFilesByListKnowledgeBaseUID.inspectFuncGetCountFilesByListKnowledgeBaseUID(ctx, kbUIDs)
	}

	mm_params := RepositoryMockGetCountFilesByListKnowledgeBaseUIDParams{ctx, kbUIDs}

	// Record call args
	mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.mutex.Lock()
	mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.callArgs = append(mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.callArgs, &mm_params)
	mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.mutex.Unlock()

	for _, e := range mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetCountFilesByListKnowledgeBaseUIDParams{ctx, kbUIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCountFilesByListKnowledgeBaseUID.t.Errorf("RepositoryMock.GetCountFilesByListKnowledgeBaseUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUIDs != nil && !minimock.Equal(*mm_want_ptrs.kbUIDs, mm_got.kbUIDs) {
				mmGetCountFilesByListKnowledgeBaseUID.t.Errorf("RepositoryMock.GetCountFilesByListKnowledgeBaseUID got unexpected parameter kbUIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.defaultExpectation.expectationOrigins.originKbUIDs, *mm_want_ptrs.kbUIDs, mm_got.kbUIDs, minimock.Diff(*mm_want_ptrs.kbUIDs, mm_got.kbUIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCountFilesByListKnowledgeBaseUID.t.Errorf("RepositoryMock.GetCountFilesByListKnowledgeBaseUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCountFilesByListKnowledgeBaseUID.GetCountFilesByListKnowledgeBaseUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCountFilesByListKnowledgeBaseUID.t.Fatal("No results are set for the RepositoryMock.GetCountFilesByListKnowledgeBaseUID")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetCountFilesByListKnowledgeBaseUID.funcGetCountFilesByListKnowledgeBaseUID != nil {
		return mmGetCountFilesByListKnowledgeBaseUID.funcGetCountFilesByListKnowledgeBaseUID(ctx, kbUIDs)
	}
	mmGetCountFilesByListKnowledgeBaseUID.t.Fatalf("Unexpected call to RepositoryMock.GetCountFilesByListKnowledgeBaseUID. %v %v", ctx, kbUIDs)
	return
}

// GetCountFilesByListKnowledgeBaseUIDAfterCounter returns a count of finished RepositoryMock.GetCountFilesByListKnowledgeBaseUID invocations
func (mmGetCountFilesByListKnowledgeBaseUID *RepositoryMock) GetCountFilesByListKnowledgeBaseUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCountFilesByListKnowledgeBaseUID.afterGetCountFilesByListKnowledgeBaseUIDCounter)
}

// GetCountFilesByListKnowledgeBaseUIDBeforeCounter returns a count of RepositoryMock.GetCountFilesByListKnowledgeBaseUID invocations
func (mmGetCountFilesByListKnowledgeBaseUID *RepositoryMock) GetCountFilesByListKnowledgeBaseUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCountFilesByListKnowledgeBaseUID.beforeGetCountFilesByListKnowledgeBaseUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetCountFilesByListKnowledgeBaseUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCountFilesByListKnowledgeBaseUID *mRepositoryMockGetCountFilesByListKnowledgeBaseUID) Calls() []*RepositoryMockGetCountFilesByListKnowledgeBaseUIDParams {
	mmGetCountFilesByListKnowledgeBaseUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetCountFilesByListKnowledgeBaseUIDParams, len(mmGetCountFilesByListKnowledgeBaseUID.callArgs))
	copy(argCopy, mmGetCountFilesByListKnowledgeBaseUID.callArgs)

	mmGetCountFilesByListKnowledgeBaseUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetCountFilesByListKnowledgeBaseUIDDone returns true if the count of the GetCountFilesByListKnowledgeBaseUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetCountFilesByListKnowledgeBaseUIDDone() bool {
	if m.GetCountFilesByListKnowledgeBaseUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCountFilesByListKnowledgeBaseUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCountFilesByListKnowledgeBaseUIDMock.invocationsDone()
}

// MinimockGetCountFilesByListKnowledgeBaseUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetCountFilesByListKnowledgeBaseUIDInspect() {
	for _, e := range m.GetCountFilesByListKnowledgeBaseUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetCountFilesByListKnowledgeBaseUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCountFilesByListKnowledgeBaseUIDCounter := mm_atomic.LoadUint64(&m.afterGetCountFilesByListKnowledgeBaseUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCountFilesByListKnowledgeBaseUIDMock.defaultExpectation != nil && afterGetCountFilesByListKnowledgeBaseUIDCounter < 1 {
		if m.GetCountFilesByListKnowledgeBaseUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetCountFilesByListKnowledgeBaseUID at\n%s", m.GetCountFilesByListKnowledgeBaseUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetCountFilesByListKnowledgeBaseUID at\n%s with params: %#v", m.GetCountFilesByListKnowledgeBaseUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetCountFilesByListKnowledgeBaseUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCountFilesByListKnowledgeBaseUID != nil && afterGetCountFilesByListKnowledgeBaseUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetCountFilesByListKnowledgeBaseUID at\n%s", m.funcGetCountFilesByListKnowledgeBaseUIDOrigin)
	}

	if !m.GetCountFilesByListKnowledgeBaseUIDMock.invocationsDone() && afterGetCountFilesByListKnowledgeBaseUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetCountFilesByListKnowledgeBaseUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCountFilesByListKnowledgeBaseUIDMock.expectedInvocations), m.GetCountFilesByListKnowledgeBaseUIDMock.expectedInvocationsOrigin, afterGetCountFilesByListKnowledgeBaseUIDCounter)
	}
}

type mRepositoryMockGetFile struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetFileExpectation
	expectations       []*RepositoryMockGetFileExpectation

	callArgs []*RepositoryMockGetFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetFileExpectation specifies expectation struct of the Repository.GetFile
type RepositoryMockGetFileExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetFileParams
	paramPtrs          *RepositoryMockGetFileParamPtrs
	expectationOrigins RepositoryMockGetFileExpectationOrigins
	results            *RepositoryMockGetFileResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetFileParams contains parameters of the Repository.GetFile
type RepositoryMockGetFileParams struct {
	ctx      context.Context
	bucket   string
	filePath string
}

// RepositoryMockGetFileParamPtrs contains pointers to parameters of the Repository.GetFile
type RepositoryMockGetFileParamPtrs struct {
	ctx      *context.Context
	bucket   *string
	filePath *string
}

// RepositoryMockGetFileResults contains results of the Repository.GetFile
type RepositoryMockGetFileResults struct {
	ba1 []byte
	err error
}

// RepositoryMockGetFileOrigins contains origins of expectations of the Repository.GetFile
type RepositoryMockGetFileExpectationOrigins struct {
	origin         string
	originCtx      string
	originBucket   string
	originFilePath string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFile *mRepositoryMockGetFile) Optional() *mRepositoryMockGetFile {
	mmGetFile.optional = true
	return mmGetFile
}

// Expect sets up expected params for Repository.GetFile
func (mmGetFile *mRepositoryMockGetFile) Expect(ctx context.Context, bucket string, filePath string) *mRepositoryMockGetFile {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("RepositoryMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &RepositoryMockGetFileExpectation{}
	}

	if mmGetFile.defaultExpectation.paramPtrs != nil {
		mmGetFile.mock.t.Fatalf("RepositoryMock.GetFile mock is already set by ExpectParams functions")
	}

	mmGetFile.defaultExpectation.params = &RepositoryMockGetFileParams{ctx, bucket, filePath}
	mmGetFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetFile.expectations {
		if minimock.Equal(e.params, mmGetFile.defaultExpectation.params) {
			mmGetFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFile.defaultExpectation.params)
		}
	}

	return mmGetFile
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetFile
func (mmGetFile *mRepositoryMockGetFile) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetFile {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("RepositoryMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &RepositoryMockGetFileExpectation{}
	}

	if mmGetFile.defaultExpectation.params != nil {
		mmGetFile.mock.t.Fatalf("RepositoryMock.GetFile mock is already set by Expect")
	}

	if mmGetFile.defaultExpectation.paramPtrs == nil {
		mmGetFile.defaultExpectation.paramPtrs = &RepositoryMockGetFileParamPtrs{}
	}
	mmGetFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetFile
}

// ExpectBucketParam2 sets up expected param bucket for Repository.GetFile
func (mmGetFile *mRepositoryMockGetFile) ExpectBucketParam2(bucket string) *mRepositoryMockGetFile {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("RepositoryMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &RepositoryMockGetFileExpectation{}
	}

	if mmGetFile.defaultExpectation.params != nil {
		mmGetFile.mock.t.Fatalf("RepositoryMock.GetFile mock is already set by Expect")
	}

	if mmGetFile.defaultExpectation.paramPtrs == nil {
		mmGetFile.defaultExpectation.paramPtrs = &RepositoryMockGetFileParamPtrs{}
	}
	mmGetFile.defaultExpectation.paramPtrs.bucket = &bucket
	mmGetFile.defaultExpectation.expectationOrigins.originBucket = minimock.CallerInfo(1)

	return mmGetFile
}

// ExpectFilePathParam3 sets up expected param filePath for Repository.GetFile
func (mmGetFile *mRepositoryMockGetFile) ExpectFilePathParam3(filePath string) *mRepositoryMockGetFile {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("RepositoryMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &RepositoryMockGetFileExpectation{}
	}

	if mmGetFile.defaultExpectation.params != nil {
		mmGetFile.mock.t.Fatalf("RepositoryMock.GetFile mock is already set by Expect")
	}

	if mmGetFile.defaultExpectation.paramPtrs == nil {
		mmGetFile.defaultExpectation.paramPtrs = &RepositoryMockGetFileParamPtrs{}
	}
	mmGetFile.defaultExpectation.paramPtrs.filePath = &filePath
	mmGetFile.defaultExpectation.expectationOrigins.originFilePath = minimock.CallerInfo(1)

	return mmGetFile
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetFile
func (mmGetFile *mRepositoryMockGetFile) Inspect(f func(ctx context.Context, bucket string, filePath string)) *mRepositoryMockGetFile {
	if mmGetFile.mock.inspectFuncGetFile != nil {
		mmGetFile.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetFile")
	}

	mmGetFile.mock.inspectFuncGetFile = f

	return mmGetFile
}

// Return sets up results that will be returned by Repository.GetFile
func (mmGetFile *mRepositoryMockGetFile) Return(ba1 []byte, err error) *RepositoryMock {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("RepositoryMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &RepositoryMockGetFileExpectation{mock: mmGetFile.mock}
	}
	mmGetFile.defaultExpectation.results = &RepositoryMockGetFileResults{ba1, err}
	mmGetFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetFile.mock
}

// Set uses given function f to mock the Repository.GetFile method
func (mmGetFile *mRepositoryMockGetFile) Set(f func(ctx context.Context, bucket string, filePath string) (ba1 []byte, err error)) *RepositoryMock {
	if mmGetFile.defaultExpectation != nil {
		mmGetFile.mock.t.Fatalf("Default expectation is already set for the Repository.GetFile method")
	}

	if len(mmGetFile.expectations) > 0 {
		mmGetFile.mock.t.Fatalf("Some expectations are already set for the Repository.GetFile method")
	}

	mmGetFile.mock.funcGetFile = f
	mmGetFile.mock.funcGetFileOrigin = minimock.CallerInfo(1)
	return mmGetFile.mock
}

// When sets expectation for the Repository.GetFile which will trigger the result defined by the following
// Then helper
func (mmGetFile *mRepositoryMockGetFile) When(ctx context.Context, bucket string, filePath string) *RepositoryMockGetFileExpectation {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("RepositoryMock.GetFile mock is already set by Set")
	}

	expectation := &RepositoryMockGetFileExpectation{
		mock:               mmGetFile.mock,
		params:             &RepositoryMockGetFileParams{ctx, bucket, filePath},
		expectationOrigins: RepositoryMockGetFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetFile.expectations = append(mmGetFile.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetFile return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetFileExpectation) Then(ba1 []byte, err error) *RepositoryMock {
	e.results = &RepositoryMockGetFileResults{ba1, err}
	return e.mock
}

// Times sets number of times Repository.GetFile should be invoked
func (mmGetFile *mRepositoryMockGetFile) Times(n uint64) *mRepositoryMockGetFile {
	if n == 0 {
		mmGetFile.mock.t.Fatalf("Times of RepositoryMock.GetFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFile.expectedInvocations, n)
	mmGetFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetFile
}

func (mmGetFile *mRepositoryMockGetFile) invocationsDone() bool {
	if len(mmGetFile.expectations) == 0 && mmGetFile.defaultExpectation == nil && mmGetFile.mock.funcGetFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFile.mock.afterGetFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFile implements mm_repository.Repository
func (mmGetFile *RepositoryMock) GetFile(ctx context.Context, bucket string, filePath string) (ba1 []byte, err error) {
	mm_atomic.AddUint64(&mmGetFile.beforeGetFileCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFile.afterGetFileCounter, 1)

	mmGetFile.t.Helper()

	if mmGetFile.inspectFuncGetFile != nil {
		mmGetFile.inspectFuncGetFile(ctx, bucket, filePath)
	}

	mm_params := RepositoryMockGetFileParams{ctx, bucket, filePath}

	// Record call args
	mmGetFile.GetFileMock.mutex.Lock()
	mmGetFile.GetFileMock.callArgs = append(mmGetFile.GetFileMock.callArgs, &mm_params)
	mmGetFile.GetFileMock.mutex.Unlock()

	for _, e := range mmGetFile.GetFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ba1, e.results.err
		}
	}

	if mmGetFile.GetFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFile.GetFileMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFile.GetFileMock.defaultExpectation.params
		mm_want_ptrs := mmGetFile.GetFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetFileParams{ctx, bucket, filePath}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFile.t.Errorf("RepositoryMock.GetFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFile.GetFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.bucket != nil && !minimock.Equal(*mm_want_ptrs.bucket, mm_got.bucket) {
				mmGetFile.t.Errorf("RepositoryMock.GetFile got unexpected parameter bucket, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFile.GetFileMock.defaultExpectation.expectationOrigins.originBucket, *mm_want_ptrs.bucket, mm_got.bucket, minimock.Diff(*mm_want_ptrs.bucket, mm_got.bucket))
			}

			if mm_want_ptrs.filePath != nil && !minimock.Equal(*mm_want_ptrs.filePath, mm_got.filePath) {
				mmGetFile.t.Errorf("RepositoryMock.GetFile got unexpected parameter filePath, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFile.GetFileMock.defaultExpectation.expectationOrigins.originFilePath, *mm_want_ptrs.filePath, mm_got.filePath, minimock.Diff(*mm_want_ptrs.filePath, mm_got.filePath))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFile.t.Errorf("RepositoryMock.GetFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetFile.GetFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFile.GetFileMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFile.t.Fatal("No results are set for the RepositoryMock.GetFile")
		}
		return (*mm_results).ba1, (*mm_results).err
	}
	if mmGetFile.funcGetFile != nil {
		return mmGetFile.funcGetFile(ctx, bucket, filePath)
	}
	mmGetFile.t.Fatalf("Unexpected call to RepositoryMock.GetFile. %v %v %v", ctx, bucket, filePath)
	return
}

// GetFileAfterCounter returns a count of finished RepositoryMock.GetFile invocations
func (mmGetFile *RepositoryMock) GetFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFile.afterGetFileCounter)
}

// GetFileBeforeCounter returns a count of RepositoryMock.GetFile invocations
func (mmGetFile *RepositoryMock) GetFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFile.beforeGetFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFile *mRepositoryMockGetFile) Calls() []*RepositoryMockGetFileParams {
	mmGetFile.mutex.RLock()

	argCopy := make([]*RepositoryMockGetFileParams, len(mmGetFile.callArgs))
	copy(argCopy, mmGetFile.callArgs)

	mmGetFile.mutex.RUnlock()

	return argCopy
}

// MinimockGetFileDone returns true if the count of the GetFile invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetFileDone() bool {
	if m.GetFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFileMock.invocationsDone()
}

// MinimockGetFileInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetFileInspect() {
	for _, e := range m.GetFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetFileCounter := mm_atomic.LoadUint64(&m.afterGetFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFileMock.defaultExpectation != nil && afterGetFileCounter < 1 {
		if m.GetFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetFile at\n%s", m.GetFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetFile at\n%s with params: %#v", m.GetFileMock.defaultExpectation.expectationOrigins.origin, *m.GetFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFile != nil && afterGetFileCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetFile at\n%s", m.funcGetFileOrigin)
	}

	if !m.GetFileMock.invocationsDone() && afterGetFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetFileMock.expectedInvocations), m.GetFileMock.expectedInvocationsOrigin, afterGetFileCounter)
	}
}

type mRepositoryMockGetFileMetadata struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetFileMetadataExpectation
	expectations       []*RepositoryMockGetFileMetadataExpectation

	callArgs []*RepositoryMockGetFileMetadataParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetFileMetadataExpectation specifies expectation struct of the Repository.GetFileMetadata
type RepositoryMockGetFileMetadataExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetFileMetadataParams
	paramPtrs          *RepositoryMockGetFileMetadataParamPtrs
	expectationOrigins RepositoryMockGetFileMetadataExpectationOrigins
	results            *RepositoryMockGetFileMetadataResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetFileMetadataParams contains parameters of the Repository.GetFileMetadata
type RepositoryMockGetFileMetadataParams struct {
	ctx      context.Context
	bucket   string
	filePath string
}

// RepositoryMockGetFileMetadataParamPtrs contains pointers to parameters of the Repository.GetFileMetadata
type RepositoryMockGetFileMetadataParamPtrs struct {
	ctx      *context.Context
	bucket   *string
	filePath *string
}

// RepositoryMockGetFileMetadataResults contains results of the Repository.GetFileMetadata
type RepositoryMockGetFileMetadataResults struct {
	op1 *minio.ObjectInfo
	err error
}

// RepositoryMockGetFileMetadataOrigins contains origins of expectations of the Repository.GetFileMetadata
type RepositoryMockGetFileMetadataExpectationOrigins struct {
	origin         string
	originCtx      string
	originBucket   string
	originFilePath string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFileMetadata *mRepositoryMockGetFileMetadata) Optional() *mRepositoryMockGetFileMetadata {
	mmGetFileMetadata.optional = true
	return mmGetFileMetadata
}

// Expect sets up expected params for Repository.GetFileMetadata
func (mmGetFileMetadata *mRepositoryMockGetFileMetadata) Expect(ctx context.Context, bucket string, filePath string) *mRepositoryMockGetFileMetadata {
	if mmGetFileMetadata.mock.funcGetFileMetadata != nil {
		mmGetFileMetadata.mock.t.Fatalf("RepositoryMock.GetFileMetadata mock is already set by Set")
	}

	if mmGetFileMetadata.defaultExpectation == nil {
		mmGetFileMetadata.defaultExpectation = &RepositoryMockGetFileMetadataExpectation{}
	}

	if mmGetFileMetadata.defaultExpectation.paramPtrs != nil {
		mmGetFileMetadata.mock.t.Fatalf("RepositoryMock.GetFileMetadata mock is already set by ExpectParams functions")
	}

	mmGetFileMetadata.defaultExpectation.params = &RepositoryMockGetFileMetadataParams{ctx, bucket, filePath}
	mmGetFileMetadata.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetFileMetadata.expectations {
		if minimock.Equal(e.params, mmGetFileMetadata.defaultExpectation.params) {
			mmGetFileMetadata.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFileMetadata.defaultExpectation.params)
		}
	}

	return mmGetFileMetadata
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetFileMetadata
func (mmGetFileMetadata *mRepositoryMockGetFileMetadata) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetFileMetadata {
	if mmGetFileMetadata.mock.funcGetFileMetadata != nil {
		mmGetFileMetadata.mock.t.Fatalf("RepositoryMock.GetFileMetadata mock is already set by Set")
	}

	if mmGetFileMetadata.defaultExpectation == nil {
		mmGetFileMetadata.defaultExpectation = &RepositoryMockGetFileMetadataExpectation{}
	}

	if mmGetFileMetadata.defaultExpectation.params != nil {
		mmGetFileMetadata.mock.t.Fatalf("RepositoryMock.GetFileMetadata mock is already set by Expect")
	}

	if mmGetFileMetadata.defaultExpectation.paramPtrs == nil {
		mmGetFileMetadata.defaultExpectation.paramPtrs = &RepositoryMockGetFileMetadataParamPtrs{}
	}
	mmGetFileMetadata.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetFileMetadata.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetFileMetadata
}

// ExpectBucketParam2 sets up expected param bucket for Repository.GetFileMetadata
func (mmGetFileMetadata *mRepositoryMockGetFileMetadata) ExpectBucketParam2(bucket string) *mRepositoryMockGetFileMetadata {
	if mmGetFileMetadata.mock.funcGetFileMetadata != nil {
		mmGetFileMetadata.mock.t.Fatalf("RepositoryMock.GetFileMetadata mock is already set by Set")
	}

	if mmGetFileMetadata.defaultExpectation == nil {
		mmGetFileMetadata.defaultExpectation = &RepositoryMockGetFileMetadataExpectation{}
	}

	if mmGetFileMetadata.defaultExpectation.params != nil {
		mmGetFileMetadata.mock.t.Fatalf("RepositoryMock.GetFileMetadata mock is already set by Expect")
	}

	if mmGetFileMetadata.defaultExpectation.paramPtrs == nil {
		mmGetFileMetadata.defaultExpectation.paramPtrs = &RepositoryMockGetFileMetadataParamPtrs{}
	}
	mmGetFileMetadata.defaultExpectation.paramPtrs.bucket = &bucket
	mmGetFileMetadata.defaultExpectation.expectationOrigins.originBucket = minimock.CallerInfo(1)

	return mmGetFileMetadata
}

// ExpectFilePathParam3 sets up expected param filePath for Repository.GetFileMetadata
func (mmGetFileMetadata *mRepositoryMockGetFileMetadata) ExpectFilePathParam3(filePath string) *mRepositoryMockGetFileMetadata {
	if mmGetFileMetadata.mock.funcGetFileMetadata != nil {
		mmGetFileMetadata.mock.t.Fatalf("RepositoryMock.GetFileMetadata mock is already set by Set")
	}

	if mmGetFileMetadata.defaultExpectation == nil {
		mmGetFileMetadata.defaultExpectation = &RepositoryMockGetFileMetadataExpectation{}
	}

	if mmGetFileMetadata.defaultExpectation.params != nil {
		mmGetFileMetadata.mock.t.Fatalf("RepositoryMock.GetFileMetadata mock is already set by Expect")
	}

	if mmGetFileMetadata.defaultExpectation.paramPtrs == nil {
		mmGetFileMetadata.defaultExpectation.paramPtrs = &RepositoryMockGetFileMetadataParamPtrs{}
	}
	mmGetFileMetadata.defaultExpectation.paramPtrs.filePath = &filePath
	mmGetFileMetadata.defaultExpectation.expectationOrigins.originFilePath = minimock.CallerInfo(1)

	return mmGetFileMetadata
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetFileMetadata
func (mmGetFileMetadata *mRepositoryMockGetFileMetadata) Inspect(f func(ctx context.Context, bucket string, filePath string)) *mRepositoryMockGetFileMetadata {
	if mmGetFileMetadata.mock.inspectFuncGetFileMetadata != nil {
		mmGetFileMetadata.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetFileMetadata")
	}

	mmGetFileMetadata.mock.inspectFuncGetFileMetadata = f

	return mmGetFileMetadata
}

// Return sets up results that will be returned by Repository.GetFileMetadata
func (mmGetFileMetadata *mRepositoryMockGetFileMetadata) Return(op1 *minio.ObjectInfo, err error) *RepositoryMock {
	if mmGetFileMetadata.mock.funcGetFileMetadata != nil {
		mmGetFileMetadata.mock.t.Fatalf("RepositoryMock.GetFileMetadata mock is already set by Set")
	}

	if mmGetFileMetadata.defaultExpectation == nil {
		mmGetFileMetadata.defaultExpectation = &RepositoryMockGetFileMetadataExpectation{mock: mmGetFileMetadata.mock}
	}
	mmGetFileMetadata.defaultExpectation.results = &RepositoryMockGetFileMetadataResults{op1, err}
	mmGetFileMetadata.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetFileMetadata.mock
}

// Set uses given function f to mock the Repository.GetFileMetadata method
func (mmGetFileMetadata *mRepositoryMockGetFileMetadata) Set(f func(ctx context.Context, bucket string, filePath string) (op1 *minio.ObjectInfo, err error)) *RepositoryMock {
	if mmGetFileMetadata.defaultExpectation != nil {
		mmGetFileMetadata.mock.t.Fatalf("Default expectation is already set for the Repository.GetFileMetadata method")
	}

	if len(mmGetFileMetadata.expectations) > 0 {
		mmGetFileMetadata.mock.t.Fatalf("Some expectations are already set for the Repository.GetFileMetadata method")
	}

	mmGetFileMetadata.mock.funcGetFileMetadata = f
	mmGetFileMetadata.mock.funcGetFileMetadataOrigin = minimock.CallerInfo(1)
	return mmGetFileMetadata.mock
}

// When sets expectation for the Repository.GetFileMetadata which will trigger the result defined by the following
// Then helper
func (mmGetFileMetadata *mRepositoryMockGetFileMetadata) When(ctx context.Context, bucket string, filePath string) *RepositoryMockGetFileMetadataExpectation {
	if mmGetFileMetadata.mock.funcGetFileMetadata != nil {
		mmGetFileMetadata.mock.t.Fatalf("RepositoryMock.GetFileMetadata mock is already set by Set")
	}

	expectation := &RepositoryMockGetFileMetadataExpectation{
		mock:               mmGetFileMetadata.mock,
		params:             &RepositoryMockGetFileMetadataParams{ctx, bucket, filePath},
		expectationOrigins: RepositoryMockGetFileMetadataExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetFileMetadata.expectations = append(mmGetFileMetadata.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetFileMetadata return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetFileMetadataExpectation) Then(op1 *minio.ObjectInfo, err error) *RepositoryMock {
	e.results = &RepositoryMockGetFileMetadataResults{op1, err}
	return e.mock
}

// Times sets number of times Repository.GetFileMetadata should be invoked
func (mmGetFileMetadata *mRepositoryMockGetFileMetadata) Times(n uint64) *mRepositoryMockGetFileMetadata {
	if n == 0 {
		mmGetFileMetadata.mock.t.Fatalf("Times of RepositoryMock.GetFileMetadata mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFileMetadata.expectedInvocations, n)
	mmGetFileMetadata.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetFileMetadata
}

func (mmGetFileMetadata *mRepositoryMockGetFileMetadata) invocationsDone() bool {
	if len(mmGetFileMetadata.expectations) == 0 && mmGetFileMetadata.defaultExpectation == nil && mmGetFileMetadata.mock.funcGetFileMetadata == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFileMetadata.mock.afterGetFileMetadataCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFileMetadata.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFileMetadata implements mm_repository.Repository
func (mmGetFileMetadata *RepositoryMock) GetFileMetadata(ctx context.Context, bucket string, filePath string) (op1 *minio.ObjectInfo, err error) {
	mm_atomic.AddUint64(&mmGetFileMetadata.beforeGetFileMetadataCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFileMetadata.afterGetFileMetadataCounter, 1)

	mmGetFileMetadata.t.Helper()

	if mmGetFileMetadata.inspectFuncGetFileMetadata != nil {
		mmGetFileMetadata.inspectFuncGetFileMetadata(ctx, bucket, filePath)
	}

	mm_params := RepositoryMockGetFileMetadataParams{ctx, bucket, filePath}

	// Record call args
	mmGetFileMetadata.GetFileMetadataMock.mutex.Lock()
	mmGetFileMetadata.GetFileMetadataMock.callArgs = append(mmGetFileMetadata.GetFileMetadataMock.callArgs, &mm_params)
	mmGetFileMetadata.GetFileMetadataMock.mutex.Unlock()

	for _, e := range mmGetFileMetadata.GetFileMetadataMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetFileMetadata.GetFileMetadataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFileMetadata.GetFileMetadataMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFileMetadata.GetFileMetadataMock.defaultExpectation.params
		mm_want_ptrs := mmGetFileMetadata.GetFileMetadataMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetFileMetadataParams{ctx, bucket, filePath}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFileMetadata.t.Errorf("RepositoryMock.GetFileMetadata got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFileMetadata.GetFileMetadataMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.bucket != nil && !minimock.Equal(*mm_want_ptrs.bucket, mm_got.bucket) {
				mmGetFileMetadata.t.Errorf("RepositoryMock.GetFileMetadata got unexpected parameter bucket, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFileMetadata.GetFileMetadataMock.defaultExpectation.expectationOrigins.originBucket, *mm_want_ptrs.bucket, mm_got.bucket, minimock.Diff(*mm_want_ptrs.bucket, mm_got.bucket))
			}

			if mm_want_ptrs.filePath != nil && !minimock.Equal(*mm_want_ptrs.filePath, mm_got.filePath) {
				mmGetFileMetadata.t.Errorf("RepositoryMock.GetFileMetadata got unexpected parameter filePath, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFileMetadata.GetFileMetadataMock.defaultExpectation.expectationOrigins.originFilePath, *mm_want_ptrs.filePath, mm_got.filePath, minimock.Diff(*mm_want_ptrs.filePath, mm_got.filePath))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFileMetadata.t.Errorf("RepositoryMock.GetFileMetadata got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetFileMetadata.GetFileMetadataMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFileMetadata.GetFileMetadataMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFileMetadata.t.Fatal("No results are set for the RepositoryMock.GetFileMetadata")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetFileMetadata.funcGetFileMetadata != nil {
		return mmGetFileMetadata.funcGetFileMetadata(ctx, bucket, filePath)
	}
	mmGetFileMetadata.t.Fatalf("Unexpected call to RepositoryMock.GetFileMetadata. %v %v %v", ctx, bucket, filePath)
	return
}

// GetFileMetadataAfterCounter returns a count of finished RepositoryMock.GetFileMetadata invocations
func (mmGetFileMetadata *RepositoryMock) GetFileMetadataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFileMetadata.afterGetFileMetadataCounter)
}

// GetFileMetadataBeforeCounter returns a count of RepositoryMock.GetFileMetadata invocations
func (mmGetFileMetadata *RepositoryMock) GetFileMetadataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFileMetadata.beforeGetFileMetadataCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetFileMetadata.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFileMetadata *mRepositoryMockGetFileMetadata) Calls() []*RepositoryMockGetFileMetadataParams {
	mmGetFileMetadata.mutex.RLock()

	argCopy := make([]*RepositoryMockGetFileMetadataParams, len(mmGetFileMetadata.callArgs))
	copy(argCopy, mmGetFileMetadata.callArgs)

	mmGetFileMetadata.mutex.RUnlock()

	return argCopy
}

// MinimockGetFileMetadataDone returns true if the count of the GetFileMetadata invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetFileMetadataDone() bool {
	if m.GetFileMetadataMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFileMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFileMetadataMock.invocationsDone()
}

// MinimockGetFileMetadataInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetFileMetadataInspect() {
	for _, e := range m.GetFileMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetFileMetadata at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetFileMetadataCounter := mm_atomic.LoadUint64(&m.afterGetFileMetadataCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFileMetadataMock.defaultExpectation != nil && afterGetFileMetadataCounter < 1 {
		if m.GetFileMetadataMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetFileMetadata at\n%s", m.GetFileMetadataMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetFileMetadata at\n%s with params: %#v", m.GetFileMetadataMock.defaultExpectation.expectationOrigins.origin, *m.GetFileMetadataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFileMetadata != nil && afterGetFileMetadataCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetFileMetadata at\n%s", m.funcGetFileMetadataOrigin)
	}

	if !m.GetFileMetadataMock.invocationsDone() && afterGetFileMetadataCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetFileMetadata at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetFileMetadataMock.expectedInvocations), m.GetFileMetadataMock.expectedInvocationsOrigin, afterGetFileMetadataCounter)
	}
}

type mRepositoryMockGetFilesTotalTokens struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetFilesTotalTokensExpectation
	expectations       []*RepositoryMockGetFilesTotalTokensExpectation

	callArgs []*RepositoryMockGetFilesTotalTokensParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetFilesTotalTokensExpectation specifies expectation struct of the Repository.GetFilesTotalTokens
type RepositoryMockGetFilesTotalTokensExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetFilesTotalTokensParams
	paramPtrs          *RepositoryMockGetFilesTotalTokensParamPtrs
	expectationOrigins RepositoryMockGetFilesTotalTokensExpectationOrigins
	results            *RepositoryMockGetFilesTotalTokensResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetFilesTotalTokensParams contains parameters of the Repository.GetFilesTotalTokens
type RepositoryMockGetFilesTotalTokensParams struct {
	ctx     context.Context
	sources map[types.FileUIDType]struct {
		SourceTable types.SourceTableType
		SourceUID   types.SourceUIDType
	}
}

// RepositoryMockGetFilesTotalTokensParamPtrs contains pointers to parameters of the Repository.GetFilesTotalTokens
type RepositoryMockGetFilesTotalTokensParamPtrs struct {
	ctx     *context.Context
	sources *map[types.FileUIDType]struct {
		SourceTable types.SourceTableType
		SourceUID   types.SourceUIDType
	}
}

// RepositoryMockGetFilesTotalTokensResults contains results of the Repository.GetFilesTotalTokens
type RepositoryMockGetFilesTotalTokensResults struct {
	m1  map[types.FileUIDType]int
	err error
}

// RepositoryMockGetFilesTotalTokensOrigins contains origins of expectations of the Repository.GetFilesTotalTokens
type RepositoryMockGetFilesTotalTokensExpectationOrigins struct {
	origin        string
	originCtx     string
	originSources string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFilesTotalTokens *mRepositoryMockGetFilesTotalTokens) Optional() *mRepositoryMockGetFilesTotalTokens {
	mmGetFilesTotalTokens.optional = true
	return mmGetFilesTotalTokens
}

// Expect sets up expected params for Repository.GetFilesTotalTokens
func (mmGetFilesTotalTokens *mRepositoryMockGetFilesTotalTokens) Expect(ctx context.Context, sources map[types.FileUIDType]struct {
	SourceTable types.SourceTableType
	SourceUID   types.SourceUIDType
}) *mRepositoryMockGetFilesTotalTokens {
	if mmGetFilesTotalTokens.mock.funcGetFilesTotalTokens != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryMock.GetFilesTotalTokens mock is already set by Set")
	}

	if mmGetFilesTotalTokens.defaultExpectation == nil {
		mmGetFilesTotalTokens.defaultExpectation = &RepositoryMockGetFilesTotalTokensExpectation{}
	}

	if mmGetFilesTotalTokens.defaultExpectation.paramPtrs != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryMock.GetFilesTotalTokens mock is already set by ExpectParams functions")
	}

	mmGetFilesTotalTokens.defaultExpectation.params = &RepositoryMockGetFilesTotalTokensParams{ctx, sources}
	mmGetFilesTotalTokens.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetFilesTotalTokens.expectations {
		if minimock.Equal(e.params, mmGetFilesTotalTokens.defaultExpectation.params) {
			mmGetFilesTotalTokens.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFilesTotalTokens.defaultExpectation.params)
		}
	}

	return mmGetFilesTotalTokens
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetFilesTotalTokens
func (mmGetFilesTotalTokens *mRepositoryMockGetFilesTotalTokens) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetFilesTotalTokens {
	if mmGetFilesTotalTokens.mock.funcGetFilesTotalTokens != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryMock.GetFilesTotalTokens mock is already set by Set")
	}

	if mmGetFilesTotalTokens.defaultExpectation == nil {
		mmGetFilesTotalTokens.defaultExpectation = &RepositoryMockGetFilesTotalTokensExpectation{}
	}

	if mmGetFilesTotalTokens.defaultExpectation.params != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryMock.GetFilesTotalTokens mock is already set by Expect")
	}

	if mmGetFilesTotalTokens.defaultExpectation.paramPtrs == nil {
		mmGetFilesTotalTokens.defaultExpectation.paramPtrs = &RepositoryMockGetFilesTotalTokensParamPtrs{}
	}
	mmGetFilesTotalTokens.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetFilesTotalTokens.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetFilesTotalTokens
}

// ExpectSourcesParam2 sets up expected param sources for Repository.GetFilesTotalTokens
func (mmGetFilesTotalTokens *mRepositoryMockGetFilesTotalTokens) ExpectSourcesParam2(sources map[types.FileUIDType]struct {
	SourceTable types.SourceTableType
	SourceUID   types.SourceUIDType
}) *mRepositoryMockGetFilesTotalTokens {
	if mmGetFilesTotalTokens.mock.funcGetFilesTotalTokens != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryMock.GetFilesTotalTokens mock is already set by Set")
	}

	if mmGetFilesTotalTokens.defaultExpectation == nil {
		mmGetFilesTotalTokens.defaultExpectation = &RepositoryMockGetFilesTotalTokensExpectation{}
	}

	if mmGetFilesTotalTokens.defaultExpectation.params != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryMock.GetFilesTotalTokens mock is already set by Expect")
	}

	if mmGetFilesTotalTokens.defaultExpectation.paramPtrs == nil {
		mmGetFilesTotalTokens.defaultExpectation.paramPtrs = &RepositoryMockGetFilesTotalTokensParamPtrs{}
	}
	mmGetFilesTotalTokens.defaultExpectation.paramPtrs.sources = &sources
	mmGetFilesTotalTokens.defaultExpectation.expectationOrigins.originSources = minimock.CallerInfo(1)

	return mmGetFilesTotalTokens
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetFilesTotalTokens
func (mmGetFilesTotalTokens *mRepositoryMockGetFilesTotalTokens) Inspect(f func(ctx context.Context, sources map[types.FileUIDType]struct {
	SourceTable types.SourceTableType
	SourceUID   types.SourceUIDType
})) *mRepositoryMockGetFilesTotalTokens {
	if mmGetFilesTotalTokens.mock.inspectFuncGetFilesTotalTokens != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetFilesTotalTokens")
	}

	mmGetFilesTotalTokens.mock.inspectFuncGetFilesTotalTokens = f

	return mmGetFilesTotalTokens
}

// Return sets up results that will be returned by Repository.GetFilesTotalTokens
func (mmGetFilesTotalTokens *mRepositoryMockGetFilesTotalTokens) Return(m1 map[types.FileUIDType]int, err error) *RepositoryMock {
	if mmGetFilesTotalTokens.mock.funcGetFilesTotalTokens != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryMock.GetFilesTotalTokens mock is already set by Set")
	}

	if mmGetFilesTotalTokens.defaultExpectation == nil {
		mmGetFilesTotalTokens.defaultExpectation = &RepositoryMockGetFilesTotalTokensExpectation{mock: mmGetFilesTotalTokens.mock}
	}
	mmGetFilesTotalTokens.defaultExpectation.results = &RepositoryMockGetFilesTotalTokensResults{m1, err}
	mmGetFilesTotalTokens.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetFilesTotalTokens.mock
}

// Set uses given function f to mock the Repository.GetFilesTotalTokens method
func (mmGetFilesTotalTokens *mRepositoryMockGetFilesTotalTokens) Set(f func(ctx context.Context, sources map[types.FileUIDType]struct {
	SourceTable types.SourceTableType
	SourceUID   types.SourceUIDType
}) (m1 map[types.FileUIDType]int, err error)) *RepositoryMock {
	if mmGetFilesTotalTokens.defaultExpectation != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("Default expectation is already set for the Repository.GetFilesTotalTokens method")
	}

	if len(mmGetFilesTotalTokens.expectations) > 0 {
		mmGetFilesTotalTokens.mock.t.Fatalf("Some expectations are already set for the Repository.GetFilesTotalTokens method")
	}

	mmGetFilesTotalTokens.mock.funcGetFilesTotalTokens = f
	mmGetFilesTotalTokens.mock.funcGetFilesTotalTokensOrigin = minimock.CallerInfo(1)
	return mmGetFilesTotalTokens.mock
}

// When sets expectation for the Repository.GetFilesTotalTokens which will trigger the result defined by the following
// Then helper
func (mmGetFilesTotalTokens *mRepositoryMockGetFilesTotalTokens) When(ctx context.Context, sources map[types.FileUIDType]struct {
	SourceTable types.SourceTableType
	SourceUID   types.SourceUIDType
}) *RepositoryMockGetFilesTotalTokensExpectation {
	if mmGetFilesTotalTokens.mock.funcGetFilesTotalTokens != nil {
		mmGetFilesTotalTokens.mock.t.Fatalf("RepositoryMock.GetFilesTotalTokens mock is already set by Set")
	}

	expectation := &RepositoryMockGetFilesTotalTokensExpectation{
		mock:               mmGetFilesTotalTokens.mock,
		params:             &RepositoryMockGetFilesTotalTokensParams{ctx, sources},
		expectationOrigins: RepositoryMockGetFilesTotalTokensExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetFilesTotalTokens.expectations = append(mmGetFilesTotalTokens.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetFilesTotalTokens return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetFilesTotalTokensExpectation) Then(m1 map[types.FileUIDType]int, err error) *RepositoryMock {
	e.results = &RepositoryMockGetFilesTotalTokensResults{m1, err}
	return e.mock
}

// Times sets number of times Repository.GetFilesTotalTokens should be invoked
func (mmGetFilesTotalTokens *mRepositoryMockGetFilesTotalTokens) Times(n uint64) *mRepositoryMockGetFilesTotalTokens {
	if n == 0 {
		mmGetFilesTotalTokens.mock.t.Fatalf("Times of RepositoryMock.GetFilesTotalTokens mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFilesTotalTokens.expectedInvocations, n)
	mmGetFilesTotalTokens.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetFilesTotalTokens
}

func (mmGetFilesTotalTokens *mRepositoryMockGetFilesTotalTokens) invocationsDone() bool {
	if len(mmGetFilesTotalTokens.expectations) == 0 && mmGetFilesTotalTokens.defaultExpectation == nil && mmGetFilesTotalTokens.mock.funcGetFilesTotalTokens == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFilesTotalTokens.mock.afterGetFilesTotalTokensCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFilesTotalTokens.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFilesTotalTokens implements mm_repository.Repository
func (mmGetFilesTotalTokens *RepositoryMock) GetFilesTotalTokens(ctx context.Context, sources map[types.FileUIDType]struct {
	SourceTable types.SourceTableType
	SourceUID   types.SourceUIDType
}) (m1 map[types.FileUIDType]int, err error) {
	mm_atomic.AddUint64(&mmGetFilesTotalTokens.beforeGetFilesTotalTokensCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFilesTotalTokens.afterGetFilesTotalTokensCounter, 1)

	mmGetFilesTotalTokens.t.Helper()

	if mmGetFilesTotalTokens.inspectFuncGetFilesTotalTokens != nil {
		mmGetFilesTotalTokens.inspectFuncGetFilesTotalTokens(ctx, sources)
	}

	mm_params := RepositoryMockGetFilesTotalTokensParams{ctx, sources}

	// Record call args
	mmGetFilesTotalTokens.GetFilesTotalTokensMock.mutex.Lock()
	mmGetFilesTotalTokens.GetFilesTotalTokensMock.callArgs = append(mmGetFilesTotalTokens.GetFilesTotalTokensMock.callArgs, &mm_params)
	mmGetFilesTotalTokens.GetFilesTotalTokensMock.mutex.Unlock()

	for _, e := range mmGetFilesTotalTokens.GetFilesTotalTokensMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetFilesTotalTokens.GetFilesTotalTokensMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFilesTotalTokens.GetFilesTotalTokensMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFilesTotalTokens.GetFilesTotalTokensMock.defaultExpectation.params
		mm_want_ptrs := mmGetFilesTotalTokens.GetFilesTotalTokensMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetFilesTotalTokensParams{ctx, sources}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFilesTotalTokens.t.Errorf("RepositoryMock.GetFilesTotalTokens got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFilesTotalTokens.GetFilesTotalTokensMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sources != nil && !minimock.Equal(*mm_want_ptrs.sources, mm_got.sources) {
				mmGetFilesTotalTokens.t.Errorf("RepositoryMock.GetFilesTotalTokens got unexpected parameter sources, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFilesTotalTokens.GetFilesTotalTokensMock.defaultExpectation.expectationOrigins.originSources, *mm_want_ptrs.sources, mm_got.sources, minimock.Diff(*mm_want_ptrs.sources, mm_got.sources))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFilesTotalTokens.t.Errorf("RepositoryMock.GetFilesTotalTokens got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetFilesTotalTokens.GetFilesTotalTokensMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFilesTotalTokens.GetFilesTotalTokensMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFilesTotalTokens.t.Fatal("No results are set for the RepositoryMock.GetFilesTotalTokens")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetFilesTotalTokens.funcGetFilesTotalTokens != nil {
		return mmGetFilesTotalTokens.funcGetFilesTotalTokens(ctx, sources)
	}
	mmGetFilesTotalTokens.t.Fatalf("Unexpected call to RepositoryMock.GetFilesTotalTokens. %v %v", ctx, sources)
	return
}

// GetFilesTotalTokensAfterCounter returns a count of finished RepositoryMock.GetFilesTotalTokens invocations
func (mmGetFilesTotalTokens *RepositoryMock) GetFilesTotalTokensAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFilesTotalTokens.afterGetFilesTotalTokensCounter)
}

// GetFilesTotalTokensBeforeCounter returns a count of RepositoryMock.GetFilesTotalTokens invocations
func (mmGetFilesTotalTokens *RepositoryMock) GetFilesTotalTokensBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFilesTotalTokens.beforeGetFilesTotalTokensCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetFilesTotalTokens.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFilesTotalTokens *mRepositoryMockGetFilesTotalTokens) Calls() []*RepositoryMockGetFilesTotalTokensParams {
	mmGetFilesTotalTokens.mutex.RLock()

	argCopy := make([]*RepositoryMockGetFilesTotalTokensParams, len(mmGetFilesTotalTokens.callArgs))
	copy(argCopy, mmGetFilesTotalTokens.callArgs)

	mmGetFilesTotalTokens.mutex.RUnlock()

	return argCopy
}

// MinimockGetFilesTotalTokensDone returns true if the count of the GetFilesTotalTokens invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetFilesTotalTokensDone() bool {
	if m.GetFilesTotalTokensMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFilesTotalTokensMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFilesTotalTokensMock.invocationsDone()
}

// MinimockGetFilesTotalTokensInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetFilesTotalTokensInspect() {
	for _, e := range m.GetFilesTotalTokensMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetFilesTotalTokens at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetFilesTotalTokensCounter := mm_atomic.LoadUint64(&m.afterGetFilesTotalTokensCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFilesTotalTokensMock.defaultExpectation != nil && afterGetFilesTotalTokensCounter < 1 {
		if m.GetFilesTotalTokensMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetFilesTotalTokens at\n%s", m.GetFilesTotalTokensMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetFilesTotalTokens at\n%s with params: %#v", m.GetFilesTotalTokensMock.defaultExpectation.expectationOrigins.origin, *m.GetFilesTotalTokensMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFilesTotalTokens != nil && afterGetFilesTotalTokensCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetFilesTotalTokens at\n%s", m.funcGetFilesTotalTokensOrigin)
	}

	if !m.GetFilesTotalTokensMock.invocationsDone() && afterGetFilesTotalTokensCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetFilesTotalTokens at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetFilesTotalTokensMock.expectedInvocations), m.GetFilesTotalTokensMock.expectedInvocationsOrigin, afterGetFilesTotalTokensCounter)
	}
}

type mRepositoryMockGetKnowledgeBaseByOwnerAndKbID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectation
	expectations       []*RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectation

	callArgs []*RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectation specifies expectation struct of the Repository.GetKnowledgeBaseByOwnerAndKbID
type RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParams
	paramPtrs          *RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParamPtrs
	expectationOrigins RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectationOrigins
	results            *RepositoryMockGetKnowledgeBaseByOwnerAndKbIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParams contains parameters of the Repository.GetKnowledgeBaseByOwnerAndKbID
type RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParams struct {
	ctx      context.Context
	ownerUID types.OwnerUIDType
	kbID     string
}

// RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParamPtrs contains pointers to parameters of the Repository.GetKnowledgeBaseByOwnerAndKbID
type RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParamPtrs struct {
	ctx      *context.Context
	ownerUID *types.OwnerUIDType
	kbID     *string
}

// RepositoryMockGetKnowledgeBaseByOwnerAndKbIDResults contains results of the Repository.GetKnowledgeBaseByOwnerAndKbID
type RepositoryMockGetKnowledgeBaseByOwnerAndKbIDResults struct {
	kp1 *mm_repository.KnowledgeBaseModel
	err error
}

// RepositoryMockGetKnowledgeBaseByOwnerAndKbIDOrigins contains origins of expectations of the Repository.GetKnowledgeBaseByOwnerAndKbID
type RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectationOrigins struct {
	origin         string
	originCtx      string
	originOwnerUID string
	originKbID     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID) Optional() *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID {
	mmGetKnowledgeBaseByOwnerAndKbID.optional = true
	return mmGetKnowledgeBaseByOwnerAndKbID
}

// Expect sets up expected params for Repository.GetKnowledgeBaseByOwnerAndKbID
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID) Expect(ctx context.Context, ownerUID types.OwnerUIDType, kbID string) *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID {
	if mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation = &RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectation{}
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.params = &RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParams{ctx, ownerUID, kbID}
	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetKnowledgeBaseByOwnerAndKbID.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.params) {
			mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBaseByOwnerAndKbID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetKnowledgeBaseByOwnerAndKbID
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID {
	if mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation = &RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectation{}
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.params != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Expect")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParamPtrs{}
	}
	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseByOwnerAndKbID
}

// ExpectOwnerUIDParam2 sets up expected param ownerUID for Repository.GetKnowledgeBaseByOwnerAndKbID
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID) ExpectOwnerUIDParam2(ownerUID types.OwnerUIDType) *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID {
	if mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation = &RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectation{}
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.params != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Expect")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParamPtrs{}
	}
	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs.ownerUID = &ownerUID
	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.expectationOrigins.originOwnerUID = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseByOwnerAndKbID
}

// ExpectKbIDParam3 sets up expected param kbID for Repository.GetKnowledgeBaseByOwnerAndKbID
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID) ExpectKbIDParam3(kbID string) *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID {
	if mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation = &RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectation{}
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.params != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Expect")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParamPtrs{}
	}
	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.paramPtrs.kbID = &kbID
	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.expectationOrigins.originKbID = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseByOwnerAndKbID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetKnowledgeBaseByOwnerAndKbID
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID) Inspect(f func(ctx context.Context, ownerUID types.OwnerUIDType, kbID string)) *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID {
	if mmGetKnowledgeBaseByOwnerAndKbID.mock.inspectFuncGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetKnowledgeBaseByOwnerAndKbID")
	}

	mmGetKnowledgeBaseByOwnerAndKbID.mock.inspectFuncGetKnowledgeBaseByOwnerAndKbID = f

	return mmGetKnowledgeBaseByOwnerAndKbID
}

// Return sets up results that will be returned by Repository.GetKnowledgeBaseByOwnerAndKbID
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID) Return(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	if mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation == nil {
		mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation = &RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectation{mock: mmGetKnowledgeBaseByOwnerAndKbID.mock}
	}
	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.results = &RepositoryMockGetKnowledgeBaseByOwnerAndKbIDResults{kp1, err}
	mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseByOwnerAndKbID.mock
}

// Set uses given function f to mock the Repository.GetKnowledgeBaseByOwnerAndKbID method
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID) Set(f func(ctx context.Context, ownerUID types.OwnerUIDType, kbID string) (kp1 *mm_repository.KnowledgeBaseModel, err error)) *RepositoryMock {
	if mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("Default expectation is already set for the Repository.GetKnowledgeBaseByOwnerAndKbID method")
	}

	if len(mmGetKnowledgeBaseByOwnerAndKbID.expectations) > 0 {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("Some expectations are already set for the Repository.GetKnowledgeBaseByOwnerAndKbID method")
	}

	mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID = f
	mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbIDOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseByOwnerAndKbID.mock
}

// When sets expectation for the Repository.GetKnowledgeBaseByOwnerAndKbID which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID) When(ctx context.Context, ownerUID types.OwnerUIDType, kbID string) *RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectation {
	if mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByOwnerAndKbID mock is already set by Set")
	}

	expectation := &RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectation{
		mock:               mmGetKnowledgeBaseByOwnerAndKbID.mock,
		params:             &RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParams{ctx, ownerUID, kbID},
		expectationOrigins: RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetKnowledgeBaseByOwnerAndKbID.expectations = append(mmGetKnowledgeBaseByOwnerAndKbID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetKnowledgeBaseByOwnerAndKbID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetKnowledgeBaseByOwnerAndKbIDExpectation) Then(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetKnowledgeBaseByOwnerAndKbIDResults{kp1, err}
	return e.mock
}

// Times sets number of times Repository.GetKnowledgeBaseByOwnerAndKbID should be invoked
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID) Times(n uint64) *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID {
	if n == 0 {
		mmGetKnowledgeBaseByOwnerAndKbID.mock.t.Fatalf("Times of RepositoryMock.GetKnowledgeBaseByOwnerAndKbID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBaseByOwnerAndKbID.expectedInvocations, n)
	mmGetKnowledgeBaseByOwnerAndKbID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseByOwnerAndKbID
}

func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID) invocationsDone() bool {
	if len(mmGetKnowledgeBaseByOwnerAndKbID.expectations) == 0 && mmGetKnowledgeBaseByOwnerAndKbID.defaultExpectation == nil && mmGetKnowledgeBaseByOwnerAndKbID.mock.funcGetKnowledgeBaseByOwnerAndKbID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseByOwnerAndKbID.mock.afterGetKnowledgeBaseByOwnerAndKbIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseByOwnerAndKbID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBaseByOwnerAndKbID implements mm_repository.Repository
func (mmGetKnowledgeBaseByOwnerAndKbID *RepositoryMock) GetKnowledgeBaseByOwnerAndKbID(ctx context.Context, ownerUID types.OwnerUIDType, kbID string) (kp1 *mm_repository.KnowledgeBaseModel, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBaseByOwnerAndKbID.beforeGetKnowledgeBaseByOwnerAndKbIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBaseByOwnerAndKbID.afterGetKnowledgeBaseByOwnerAndKbIDCounter, 1)

	mmGetKnowledgeBaseByOwnerAndKbID.t.Helper()

	if mmGetKnowledgeBaseByOwnerAndKbID.inspectFuncGetKnowledgeBaseByOwnerAndKbID != nil {
		mmGetKnowledgeBaseByOwnerAndKbID.inspectFuncGetKnowledgeBaseByOwnerAndKbID(ctx, ownerUID, kbID)
	}

	mm_params := RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParams{ctx, ownerUID, kbID}

	// Record call args
	mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.mutex.Lock()
	mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.callArgs = append(mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.callArgs, &mm_params)
	mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParams{ctx, ownerUID, kbID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBaseByOwnerAndKbID.t.Errorf("RepositoryMock.GetKnowledgeBaseByOwnerAndKbID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmGetKnowledgeBaseByOwnerAndKbID.t.Errorf("RepositoryMock.GetKnowledgeBaseByOwnerAndKbID got unexpected parameter ownerUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.expectationOrigins.originOwnerUID, *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

			if mm_want_ptrs.kbID != nil && !minimock.Equal(*mm_want_ptrs.kbID, mm_got.kbID) {
				mmGetKnowledgeBaseByOwnerAndKbID.t.Errorf("RepositoryMock.GetKnowledgeBaseByOwnerAndKbID got unexpected parameter kbID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.expectationOrigins.originKbID, *mm_want_ptrs.kbID, mm_got.kbID, minimock.Diff(*mm_want_ptrs.kbID, mm_got.kbID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBaseByOwnerAndKbID.t.Errorf("RepositoryMock.GetKnowledgeBaseByOwnerAndKbID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBaseByOwnerAndKbID.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBaseByOwnerAndKbID.t.Fatal("No results are set for the RepositoryMock.GetKnowledgeBaseByOwnerAndKbID")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmGetKnowledgeBaseByOwnerAndKbID.funcGetKnowledgeBaseByOwnerAndKbID != nil {
		return mmGetKnowledgeBaseByOwnerAndKbID.funcGetKnowledgeBaseByOwnerAndKbID(ctx, ownerUID, kbID)
	}
	mmGetKnowledgeBaseByOwnerAndKbID.t.Fatalf("Unexpected call to RepositoryMock.GetKnowledgeBaseByOwnerAndKbID. %v %v %v", ctx, ownerUID, kbID)
	return
}

// GetKnowledgeBaseByOwnerAndKbIDAfterCounter returns a count of finished RepositoryMock.GetKnowledgeBaseByOwnerAndKbID invocations
func (mmGetKnowledgeBaseByOwnerAndKbID *RepositoryMock) GetKnowledgeBaseByOwnerAndKbIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseByOwnerAndKbID.afterGetKnowledgeBaseByOwnerAndKbIDCounter)
}

// GetKnowledgeBaseByOwnerAndKbIDBeforeCounter returns a count of RepositoryMock.GetKnowledgeBaseByOwnerAndKbID invocations
func (mmGetKnowledgeBaseByOwnerAndKbID *RepositoryMock) GetKnowledgeBaseByOwnerAndKbIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseByOwnerAndKbID.beforeGetKnowledgeBaseByOwnerAndKbIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetKnowledgeBaseByOwnerAndKbID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBaseByOwnerAndKbID *mRepositoryMockGetKnowledgeBaseByOwnerAndKbID) Calls() []*RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParams {
	mmGetKnowledgeBaseByOwnerAndKbID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetKnowledgeBaseByOwnerAndKbIDParams, len(mmGetKnowledgeBaseByOwnerAndKbID.callArgs))
	copy(argCopy, mmGetKnowledgeBaseByOwnerAndKbID.callArgs)

	mmGetKnowledgeBaseByOwnerAndKbID.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBaseByOwnerAndKbIDDone returns true if the count of the GetKnowledgeBaseByOwnerAndKbID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetKnowledgeBaseByOwnerAndKbIDDone() bool {
	if m.GetKnowledgeBaseByOwnerAndKbIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetKnowledgeBaseByOwnerAndKbIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBaseByOwnerAndKbIDMock.invocationsDone()
}

// MinimockGetKnowledgeBaseByOwnerAndKbIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetKnowledgeBaseByOwnerAndKbIDInspect() {
	for _, e := range m.GetKnowledgeBaseByOwnerAndKbIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByOwnerAndKbID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetKnowledgeBaseByOwnerAndKbIDCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBaseByOwnerAndKbIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation != nil && afterGetKnowledgeBaseByOwnerAndKbIDCounter < 1 {
		if m.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByOwnerAndKbID at\n%s", m.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByOwnerAndKbID at\n%s with params: %#v", m.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.expectationOrigins.origin, *m.GetKnowledgeBaseByOwnerAndKbIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBaseByOwnerAndKbID != nil && afterGetKnowledgeBaseByOwnerAndKbIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByOwnerAndKbID at\n%s", m.funcGetKnowledgeBaseByOwnerAndKbIDOrigin)
	}

	if !m.GetKnowledgeBaseByOwnerAndKbIDMock.invocationsDone() && afterGetKnowledgeBaseByOwnerAndKbIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetKnowledgeBaseByOwnerAndKbID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBaseByOwnerAndKbIDMock.expectedInvocations), m.GetKnowledgeBaseByOwnerAndKbIDMock.expectedInvocationsOrigin, afterGetKnowledgeBaseByOwnerAndKbIDCounter)
	}
}

type mRepositoryMockGetKnowledgeBaseByUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetKnowledgeBaseByUIDExpectation
	expectations       []*RepositoryMockGetKnowledgeBaseByUIDExpectation

	callArgs []*RepositoryMockGetKnowledgeBaseByUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetKnowledgeBaseByUIDExpectation specifies expectation struct of the Repository.GetKnowledgeBaseByUID
type RepositoryMockGetKnowledgeBaseByUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetKnowledgeBaseByUIDParams
	paramPtrs          *RepositoryMockGetKnowledgeBaseByUIDParamPtrs
	expectationOrigins RepositoryMockGetKnowledgeBaseByUIDExpectationOrigins
	results            *RepositoryMockGetKnowledgeBaseByUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetKnowledgeBaseByUIDParams contains parameters of the Repository.GetKnowledgeBaseByUID
type RepositoryMockGetKnowledgeBaseByUIDParams struct {
	ctx context.Context
	k1  types.KBUIDType
}

// RepositoryMockGetKnowledgeBaseByUIDParamPtrs contains pointers to parameters of the Repository.GetKnowledgeBaseByUID
type RepositoryMockGetKnowledgeBaseByUIDParamPtrs struct {
	ctx *context.Context
	k1  *types.KBUIDType
}

// RepositoryMockGetKnowledgeBaseByUIDResults contains results of the Repository.GetKnowledgeBaseByUID
type RepositoryMockGetKnowledgeBaseByUIDResults struct {
	kp1 *mm_repository.KnowledgeBaseModel
	err error
}

// RepositoryMockGetKnowledgeBaseByUIDOrigins contains origins of expectations of the Repository.GetKnowledgeBaseByUID
type RepositoryMockGetKnowledgeBaseByUIDExpectationOrigins struct {
	origin    string
	originCtx string
	originK1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetKnowledgeBaseByUID *mRepositoryMockGetKnowledgeBaseByUID) Optional() *mRepositoryMockGetKnowledgeBaseByUID {
	mmGetKnowledgeBaseByUID.optional = true
	return mmGetKnowledgeBaseByUID
}

// Expect sets up expected params for Repository.GetKnowledgeBaseByUID
func (mmGetKnowledgeBaseByUID *mRepositoryMockGetKnowledgeBaseByUID) Expect(ctx context.Context, k1 types.KBUIDType) *mRepositoryMockGetKnowledgeBaseByUID {
	if mmGetKnowledgeBaseByUID.mock.funcGetKnowledgeBaseByUID != nil {
		mmGetKnowledgeBaseByUID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByUID.defaultExpectation == nil {
		mmGetKnowledgeBaseByUID.defaultExpectation = &RepositoryMockGetKnowledgeBaseByUIDExpectation{}
	}

	if mmGetKnowledgeBaseByUID.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBaseByUID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUID mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBaseByUID.defaultExpectation.params = &RepositoryMockGetKnowledgeBaseByUIDParams{ctx, k1}
	mmGetKnowledgeBaseByUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetKnowledgeBaseByUID.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBaseByUID.defaultExpectation.params) {
			mmGetKnowledgeBaseByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBaseByUID.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBaseByUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetKnowledgeBaseByUID
func (mmGetKnowledgeBaseByUID *mRepositoryMockGetKnowledgeBaseByUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetKnowledgeBaseByUID {
	if mmGetKnowledgeBaseByUID.mock.funcGetKnowledgeBaseByUID != nil {
		mmGetKnowledgeBaseByUID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByUID.defaultExpectation == nil {
		mmGetKnowledgeBaseByUID.defaultExpectation = &RepositoryMockGetKnowledgeBaseByUIDExpectation{}
	}

	if mmGetKnowledgeBaseByUID.defaultExpectation.params != nil {
		mmGetKnowledgeBaseByUID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUID mock is already set by Expect")
	}

	if mmGetKnowledgeBaseByUID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseByUID.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseByUIDParamPtrs{}
	}
	mmGetKnowledgeBaseByUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetKnowledgeBaseByUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseByUID
}

// ExpectK1Param2 sets up expected param k1 for Repository.GetKnowledgeBaseByUID
func (mmGetKnowledgeBaseByUID *mRepositoryMockGetKnowledgeBaseByUID) ExpectK1Param2(k1 types.KBUIDType) *mRepositoryMockGetKnowledgeBaseByUID {
	if mmGetKnowledgeBaseByUID.mock.funcGetKnowledgeBaseByUID != nil {
		mmGetKnowledgeBaseByUID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByUID.defaultExpectation == nil {
		mmGetKnowledgeBaseByUID.defaultExpectation = &RepositoryMockGetKnowledgeBaseByUIDExpectation{}
	}

	if mmGetKnowledgeBaseByUID.defaultExpectation.params != nil {
		mmGetKnowledgeBaseByUID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUID mock is already set by Expect")
	}

	if mmGetKnowledgeBaseByUID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseByUID.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseByUIDParamPtrs{}
	}
	mmGetKnowledgeBaseByUID.defaultExpectation.paramPtrs.k1 = &k1
	mmGetKnowledgeBaseByUID.defaultExpectation.expectationOrigins.originK1 = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseByUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetKnowledgeBaseByUID
func (mmGetKnowledgeBaseByUID *mRepositoryMockGetKnowledgeBaseByUID) Inspect(f func(ctx context.Context, k1 types.KBUIDType)) *mRepositoryMockGetKnowledgeBaseByUID {
	if mmGetKnowledgeBaseByUID.mock.inspectFuncGetKnowledgeBaseByUID != nil {
		mmGetKnowledgeBaseByUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetKnowledgeBaseByUID")
	}

	mmGetKnowledgeBaseByUID.mock.inspectFuncGetKnowledgeBaseByUID = f

	return mmGetKnowledgeBaseByUID
}

// Return sets up results that will be returned by Repository.GetKnowledgeBaseByUID
func (mmGetKnowledgeBaseByUID *mRepositoryMockGetKnowledgeBaseByUID) Return(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	if mmGetKnowledgeBaseByUID.mock.funcGetKnowledgeBaseByUID != nil {
		mmGetKnowledgeBaseByUID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUID mock is already set by Set")
	}

	if mmGetKnowledgeBaseByUID.defaultExpectation == nil {
		mmGetKnowledgeBaseByUID.defaultExpectation = &RepositoryMockGetKnowledgeBaseByUIDExpectation{mock: mmGetKnowledgeBaseByUID.mock}
	}
	mmGetKnowledgeBaseByUID.defaultExpectation.results = &RepositoryMockGetKnowledgeBaseByUIDResults{kp1, err}
	mmGetKnowledgeBaseByUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseByUID.mock
}

// Set uses given function f to mock the Repository.GetKnowledgeBaseByUID method
func (mmGetKnowledgeBaseByUID *mRepositoryMockGetKnowledgeBaseByUID) Set(f func(ctx context.Context, k1 types.KBUIDType) (kp1 *mm_repository.KnowledgeBaseModel, err error)) *RepositoryMock {
	if mmGetKnowledgeBaseByUID.defaultExpectation != nil {
		mmGetKnowledgeBaseByUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetKnowledgeBaseByUID method")
	}

	if len(mmGetKnowledgeBaseByUID.expectations) > 0 {
		mmGetKnowledgeBaseByUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetKnowledgeBaseByUID method")
	}

	mmGetKnowledgeBaseByUID.mock.funcGetKnowledgeBaseByUID = f
	mmGetKnowledgeBaseByUID.mock.funcGetKnowledgeBaseByUIDOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseByUID.mock
}

// When sets expectation for the Repository.GetKnowledgeBaseByUID which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBaseByUID *mRepositoryMockGetKnowledgeBaseByUID) When(ctx context.Context, k1 types.KBUIDType) *RepositoryMockGetKnowledgeBaseByUIDExpectation {
	if mmGetKnowledgeBaseByUID.mock.funcGetKnowledgeBaseByUID != nil {
		mmGetKnowledgeBaseByUID.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseByUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetKnowledgeBaseByUIDExpectation{
		mock:               mmGetKnowledgeBaseByUID.mock,
		params:             &RepositoryMockGetKnowledgeBaseByUIDParams{ctx, k1},
		expectationOrigins: RepositoryMockGetKnowledgeBaseByUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetKnowledgeBaseByUID.expectations = append(mmGetKnowledgeBaseByUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetKnowledgeBaseByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetKnowledgeBaseByUIDExpectation) Then(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetKnowledgeBaseByUIDResults{kp1, err}
	return e.mock
}

// Times sets number of times Repository.GetKnowledgeBaseByUID should be invoked
func (mmGetKnowledgeBaseByUID *mRepositoryMockGetKnowledgeBaseByUID) Times(n uint64) *mRepositoryMockGetKnowledgeBaseByUID {
	if n == 0 {
		mmGetKnowledgeBaseByUID.mock.t.Fatalf("Times of RepositoryMock.GetKnowledgeBaseByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBaseByUID.expectedInvocations, n)
	mmGetKnowledgeBaseByUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseByUID
}

func (mmGetKnowledgeBaseByUID *mRepositoryMockGetKnowledgeBaseByUID) invocationsDone() bool {
	if len(mmGetKnowledgeBaseByUID.expectations) == 0 && mmGetKnowledgeBaseByUID.defaultExpectation == nil && mmGetKnowledgeBaseByUID.mock.funcGetKnowledgeBaseByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseByUID.mock.afterGetKnowledgeBaseByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBaseByUID implements mm_repository.Repository
func (mmGetKnowledgeBaseByUID *RepositoryMock) GetKnowledgeBaseByUID(ctx context.Context, k1 types.KBUIDType) (kp1 *mm_repository.KnowledgeBaseModel, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBaseByUID.beforeGetKnowledgeBaseByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBaseByUID.afterGetKnowledgeBaseByUIDCounter, 1)

	mmGetKnowledgeBaseByUID.t.Helper()

	if mmGetKnowledgeBaseByUID.inspectFuncGetKnowledgeBaseByUID != nil {
		mmGetKnowledgeBaseByUID.inspectFuncGetKnowledgeBaseByUID(ctx, k1)
	}

	mm_params := RepositoryMockGetKnowledgeBaseByUIDParams{ctx, k1}

	// Record call args
	mmGetKnowledgeBaseByUID.GetKnowledgeBaseByUIDMock.mutex.Lock()
	mmGetKnowledgeBaseByUID.GetKnowledgeBaseByUIDMock.callArgs = append(mmGetKnowledgeBaseByUID.GetKnowledgeBaseByUIDMock.callArgs, &mm_params)
	mmGetKnowledgeBaseByUID.GetKnowledgeBaseByUIDMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBaseByUID.GetKnowledgeBaseByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmGetKnowledgeBaseByUID.GetKnowledgeBaseByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBaseByUID.GetKnowledgeBaseByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBaseByUID.GetKnowledgeBaseByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBaseByUID.GetKnowledgeBaseByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetKnowledgeBaseByUIDParams{ctx, k1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBaseByUID.t.Errorf("RepositoryMock.GetKnowledgeBaseByUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseByUID.GetKnowledgeBaseByUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.k1 != nil && !minimock.Equal(*mm_want_ptrs.k1, mm_got.k1) {
				mmGetKnowledgeBaseByUID.t.Errorf("RepositoryMock.GetKnowledgeBaseByUID got unexpected parameter k1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseByUID.GetKnowledgeBaseByUIDMock.defaultExpectation.expectationOrigins.originK1, *mm_want_ptrs.k1, mm_got.k1, minimock.Diff(*mm_want_ptrs.k1, mm_got.k1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBaseByUID.t.Errorf("RepositoryMock.GetKnowledgeBaseByUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetKnowledgeBaseByUID.GetKnowledgeBaseByUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBaseByUID.GetKnowledgeBaseByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBaseByUID.t.Fatal("No results are set for the RepositoryMock.GetKnowledgeBaseByUID")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmGetKnowledgeBaseByUID.funcGetKnowledgeBaseByUID != nil {
		return mmGetKnowledgeBaseByUID.funcGetKnowledgeBaseByUID(ctx, k1)
	}
	mmGetKnowledgeBaseByUID.t.Fatalf("Unexpected call to RepositoryMock.GetKnowledgeBaseByUID. %v %v", ctx, k1)
	return
}

// GetKnowledgeBaseByUIDAfterCounter returns a count of finished RepositoryMock.GetKnowledgeBaseByUID invocations
func (mmGetKnowledgeBaseByUID *RepositoryMock) GetKnowledgeBaseByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseByUID.afterGetKnowledgeBaseByUIDCounter)
}

// GetKnowledgeBaseByUIDBeforeCounter returns a count of RepositoryMock.GetKnowledgeBaseByUID invocations
func (mmGetKnowledgeBaseByUID *RepositoryMock) GetKnowledgeBaseByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseByUID.beforeGetKnowledgeBaseByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetKnowledgeBaseByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBaseByUID *mRepositoryMockGetKnowledgeBaseByUID) Calls() []*RepositoryMockGetKnowledgeBaseByUIDParams {
	mmGetKnowledgeBaseByUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetKnowledgeBaseByUIDParams, len(mmGetKnowledgeBaseByUID.callArgs))
	copy(argCopy, mmGetKnowledgeBaseByUID.callArgs)

	mmGetKnowledgeBaseByUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBaseByUIDDone returns true if the count of the GetKnowledgeBaseByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetKnowledgeBaseByUIDDone() bool {
	if m.GetKnowledgeBaseByUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetKnowledgeBaseByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBaseByUIDMock.invocationsDone()
}

// MinimockGetKnowledgeBaseByUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetKnowledgeBaseByUIDInspect() {
	for _, e := range m.GetKnowledgeBaseByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetKnowledgeBaseByUIDCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBaseByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBaseByUIDMock.defaultExpectation != nil && afterGetKnowledgeBaseByUIDCounter < 1 {
		if m.GetKnowledgeBaseByUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByUID at\n%s", m.GetKnowledgeBaseByUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByUID at\n%s with params: %#v", m.GetKnowledgeBaseByUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetKnowledgeBaseByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBaseByUID != nil && afterGetKnowledgeBaseByUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseByUID at\n%s", m.funcGetKnowledgeBaseByUIDOrigin)
	}

	if !m.GetKnowledgeBaseByUIDMock.invocationsDone() && afterGetKnowledgeBaseByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetKnowledgeBaseByUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBaseByUIDMock.expectedInvocations), m.GetKnowledgeBaseByUIDMock.expectedInvocationsOrigin, afterGetKnowledgeBaseByUIDCounter)
	}
}

type mRepositoryMockGetKnowledgeBaseCountByOwner struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetKnowledgeBaseCountByOwnerExpectation
	expectations       []*RepositoryMockGetKnowledgeBaseCountByOwnerExpectation

	callArgs []*RepositoryMockGetKnowledgeBaseCountByOwnerParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetKnowledgeBaseCountByOwnerExpectation specifies expectation struct of the Repository.GetKnowledgeBaseCountByOwner
type RepositoryMockGetKnowledgeBaseCountByOwnerExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetKnowledgeBaseCountByOwnerParams
	paramPtrs          *RepositoryMockGetKnowledgeBaseCountByOwnerParamPtrs
	expectationOrigins RepositoryMockGetKnowledgeBaseCountByOwnerExpectationOrigins
	results            *RepositoryMockGetKnowledgeBaseCountByOwnerResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetKnowledgeBaseCountByOwnerParams contains parameters of the Repository.GetKnowledgeBaseCountByOwner
type RepositoryMockGetKnowledgeBaseCountByOwnerParams struct {
	ctx         context.Context
	ownerUID    string
	catalogType artifactpb.CatalogType
}

// RepositoryMockGetKnowledgeBaseCountByOwnerParamPtrs contains pointers to parameters of the Repository.GetKnowledgeBaseCountByOwner
type RepositoryMockGetKnowledgeBaseCountByOwnerParamPtrs struct {
	ctx         *context.Context
	ownerUID    *string
	catalogType *artifactpb.CatalogType
}

// RepositoryMockGetKnowledgeBaseCountByOwnerResults contains results of the Repository.GetKnowledgeBaseCountByOwner
type RepositoryMockGetKnowledgeBaseCountByOwnerResults struct {
	i1  int64
	err error
}

// RepositoryMockGetKnowledgeBaseCountByOwnerOrigins contains origins of expectations of the Repository.GetKnowledgeBaseCountByOwner
type RepositoryMockGetKnowledgeBaseCountByOwnerExpectationOrigins struct {
	origin            string
	originCtx         string
	originOwnerUID    string
	originCatalogType string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetKnowledgeBaseCountByOwner *mRepositoryMockGetKnowledgeBaseCountByOwner) Optional() *mRepositoryMockGetKnowledgeBaseCountByOwner {
	mmGetKnowledgeBaseCountByOwner.optional = true
	return mmGetKnowledgeBaseCountByOwner
}

// Expect sets up expected params for Repository.GetKnowledgeBaseCountByOwner
func (mmGetKnowledgeBaseCountByOwner *mRepositoryMockGetKnowledgeBaseCountByOwner) Expect(ctx context.Context, ownerUID string, catalogType artifactpb.CatalogType) *mRepositoryMockGetKnowledgeBaseCountByOwner {
	if mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseCountByOwner mock is already set by Set")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation = &RepositoryMockGetKnowledgeBaseCountByOwnerExpectation{}
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseCountByOwner mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBaseCountByOwner.defaultExpectation.params = &RepositoryMockGetKnowledgeBaseCountByOwnerParams{ctx, ownerUID, catalogType}
	mmGetKnowledgeBaseCountByOwner.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetKnowledgeBaseCountByOwner.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBaseCountByOwner.defaultExpectation.params) {
			mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBaseCountByOwner.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBaseCountByOwner
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetKnowledgeBaseCountByOwner
func (mmGetKnowledgeBaseCountByOwner *mRepositoryMockGetKnowledgeBaseCountByOwner) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetKnowledgeBaseCountByOwner {
	if mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseCountByOwner mock is already set by Set")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation = &RepositoryMockGetKnowledgeBaseCountByOwnerExpectation{}
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation.params != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseCountByOwner mock is already set by Expect")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseCountByOwnerParamPtrs{}
	}
	mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetKnowledgeBaseCountByOwner.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseCountByOwner
}

// ExpectOwnerUIDParam2 sets up expected param ownerUID for Repository.GetKnowledgeBaseCountByOwner
func (mmGetKnowledgeBaseCountByOwner *mRepositoryMockGetKnowledgeBaseCountByOwner) ExpectOwnerUIDParam2(ownerUID string) *mRepositoryMockGetKnowledgeBaseCountByOwner {
	if mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseCountByOwner mock is already set by Set")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation = &RepositoryMockGetKnowledgeBaseCountByOwnerExpectation{}
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation.params != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseCountByOwner mock is already set by Expect")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseCountByOwnerParamPtrs{}
	}
	mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs.ownerUID = &ownerUID
	mmGetKnowledgeBaseCountByOwner.defaultExpectation.expectationOrigins.originOwnerUID = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseCountByOwner
}

// ExpectCatalogTypeParam3 sets up expected param catalogType for Repository.GetKnowledgeBaseCountByOwner
func (mmGetKnowledgeBaseCountByOwner *mRepositoryMockGetKnowledgeBaseCountByOwner) ExpectCatalogTypeParam3(catalogType artifactpb.CatalogType) *mRepositoryMockGetKnowledgeBaseCountByOwner {
	if mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseCountByOwner mock is already set by Set")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation = &RepositoryMockGetKnowledgeBaseCountByOwnerExpectation{}
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation.params != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseCountByOwner mock is already set by Expect")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseCountByOwnerParamPtrs{}
	}
	mmGetKnowledgeBaseCountByOwner.defaultExpectation.paramPtrs.catalogType = &catalogType
	mmGetKnowledgeBaseCountByOwner.defaultExpectation.expectationOrigins.originCatalogType = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseCountByOwner
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetKnowledgeBaseCountByOwner
func (mmGetKnowledgeBaseCountByOwner *mRepositoryMockGetKnowledgeBaseCountByOwner) Inspect(f func(ctx context.Context, ownerUID string, catalogType artifactpb.CatalogType)) *mRepositoryMockGetKnowledgeBaseCountByOwner {
	if mmGetKnowledgeBaseCountByOwner.mock.inspectFuncGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetKnowledgeBaseCountByOwner")
	}

	mmGetKnowledgeBaseCountByOwner.mock.inspectFuncGetKnowledgeBaseCountByOwner = f

	return mmGetKnowledgeBaseCountByOwner
}

// Return sets up results that will be returned by Repository.GetKnowledgeBaseCountByOwner
func (mmGetKnowledgeBaseCountByOwner *mRepositoryMockGetKnowledgeBaseCountByOwner) Return(i1 int64, err error) *RepositoryMock {
	if mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseCountByOwner mock is already set by Set")
	}

	if mmGetKnowledgeBaseCountByOwner.defaultExpectation == nil {
		mmGetKnowledgeBaseCountByOwner.defaultExpectation = &RepositoryMockGetKnowledgeBaseCountByOwnerExpectation{mock: mmGetKnowledgeBaseCountByOwner.mock}
	}
	mmGetKnowledgeBaseCountByOwner.defaultExpectation.results = &RepositoryMockGetKnowledgeBaseCountByOwnerResults{i1, err}
	mmGetKnowledgeBaseCountByOwner.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseCountByOwner.mock
}

// Set uses given function f to mock the Repository.GetKnowledgeBaseCountByOwner method
func (mmGetKnowledgeBaseCountByOwner *mRepositoryMockGetKnowledgeBaseCountByOwner) Set(f func(ctx context.Context, ownerUID string, catalogType artifactpb.CatalogType) (i1 int64, err error)) *RepositoryMock {
	if mmGetKnowledgeBaseCountByOwner.defaultExpectation != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("Default expectation is already set for the Repository.GetKnowledgeBaseCountByOwner method")
	}

	if len(mmGetKnowledgeBaseCountByOwner.expectations) > 0 {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("Some expectations are already set for the Repository.GetKnowledgeBaseCountByOwner method")
	}

	mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner = f
	mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwnerOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseCountByOwner.mock
}

// When sets expectation for the Repository.GetKnowledgeBaseCountByOwner which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBaseCountByOwner *mRepositoryMockGetKnowledgeBaseCountByOwner) When(ctx context.Context, ownerUID string, catalogType artifactpb.CatalogType) *RepositoryMockGetKnowledgeBaseCountByOwnerExpectation {
	if mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseCountByOwner mock is already set by Set")
	}

	expectation := &RepositoryMockGetKnowledgeBaseCountByOwnerExpectation{
		mock:               mmGetKnowledgeBaseCountByOwner.mock,
		params:             &RepositoryMockGetKnowledgeBaseCountByOwnerParams{ctx, ownerUID, catalogType},
		expectationOrigins: RepositoryMockGetKnowledgeBaseCountByOwnerExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetKnowledgeBaseCountByOwner.expectations = append(mmGetKnowledgeBaseCountByOwner.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetKnowledgeBaseCountByOwner return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetKnowledgeBaseCountByOwnerExpectation) Then(i1 int64, err error) *RepositoryMock {
	e.results = &RepositoryMockGetKnowledgeBaseCountByOwnerResults{i1, err}
	return e.mock
}

// Times sets number of times Repository.GetKnowledgeBaseCountByOwner should be invoked
func (mmGetKnowledgeBaseCountByOwner *mRepositoryMockGetKnowledgeBaseCountByOwner) Times(n uint64) *mRepositoryMockGetKnowledgeBaseCountByOwner {
	if n == 0 {
		mmGetKnowledgeBaseCountByOwner.mock.t.Fatalf("Times of RepositoryMock.GetKnowledgeBaseCountByOwner mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBaseCountByOwner.expectedInvocations, n)
	mmGetKnowledgeBaseCountByOwner.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseCountByOwner
}

func (mmGetKnowledgeBaseCountByOwner *mRepositoryMockGetKnowledgeBaseCountByOwner) invocationsDone() bool {
	if len(mmGetKnowledgeBaseCountByOwner.expectations) == 0 && mmGetKnowledgeBaseCountByOwner.defaultExpectation == nil && mmGetKnowledgeBaseCountByOwner.mock.funcGetKnowledgeBaseCountByOwner == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseCountByOwner.mock.afterGetKnowledgeBaseCountByOwnerCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseCountByOwner.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBaseCountByOwner implements mm_repository.Repository
func (mmGetKnowledgeBaseCountByOwner *RepositoryMock) GetKnowledgeBaseCountByOwner(ctx context.Context, ownerUID string, catalogType artifactpb.CatalogType) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBaseCountByOwner.beforeGetKnowledgeBaseCountByOwnerCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBaseCountByOwner.afterGetKnowledgeBaseCountByOwnerCounter, 1)

	mmGetKnowledgeBaseCountByOwner.t.Helper()

	if mmGetKnowledgeBaseCountByOwner.inspectFuncGetKnowledgeBaseCountByOwner != nil {
		mmGetKnowledgeBaseCountByOwner.inspectFuncGetKnowledgeBaseCountByOwner(ctx, ownerUID, catalogType)
	}

	mm_params := RepositoryMockGetKnowledgeBaseCountByOwnerParams{ctx, ownerUID, catalogType}

	// Record call args
	mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.mutex.Lock()
	mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.callArgs = append(mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.callArgs, &mm_params)
	mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetKnowledgeBaseCountByOwnerParams{ctx, ownerUID, catalogType}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBaseCountByOwner.t.Errorf("RepositoryMock.GetKnowledgeBaseCountByOwner got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmGetKnowledgeBaseCountByOwner.t.Errorf("RepositoryMock.GetKnowledgeBaseCountByOwner got unexpected parameter ownerUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.expectationOrigins.originOwnerUID, *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

			if mm_want_ptrs.catalogType != nil && !minimock.Equal(*mm_want_ptrs.catalogType, mm_got.catalogType) {
				mmGetKnowledgeBaseCountByOwner.t.Errorf("RepositoryMock.GetKnowledgeBaseCountByOwner got unexpected parameter catalogType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.expectationOrigins.originCatalogType, *mm_want_ptrs.catalogType, mm_got.catalogType, minimock.Diff(*mm_want_ptrs.catalogType, mm_got.catalogType))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBaseCountByOwner.t.Errorf("RepositoryMock.GetKnowledgeBaseCountByOwner got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBaseCountByOwner.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBaseCountByOwner.t.Fatal("No results are set for the RepositoryMock.GetKnowledgeBaseCountByOwner")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetKnowledgeBaseCountByOwner.funcGetKnowledgeBaseCountByOwner != nil {
		return mmGetKnowledgeBaseCountByOwner.funcGetKnowledgeBaseCountByOwner(ctx, ownerUID, catalogType)
	}
	mmGetKnowledgeBaseCountByOwner.t.Fatalf("Unexpected call to RepositoryMock.GetKnowledgeBaseCountByOwner. %v %v %v", ctx, ownerUID, catalogType)
	return
}

// GetKnowledgeBaseCountByOwnerAfterCounter returns a count of finished RepositoryMock.GetKnowledgeBaseCountByOwner invocations
func (mmGetKnowledgeBaseCountByOwner *RepositoryMock) GetKnowledgeBaseCountByOwnerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseCountByOwner.afterGetKnowledgeBaseCountByOwnerCounter)
}

// GetKnowledgeBaseCountByOwnerBeforeCounter returns a count of RepositoryMock.GetKnowledgeBaseCountByOwner invocations
func (mmGetKnowledgeBaseCountByOwner *RepositoryMock) GetKnowledgeBaseCountByOwnerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseCountByOwner.beforeGetKnowledgeBaseCountByOwnerCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetKnowledgeBaseCountByOwner.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBaseCountByOwner *mRepositoryMockGetKnowledgeBaseCountByOwner) Calls() []*RepositoryMockGetKnowledgeBaseCountByOwnerParams {
	mmGetKnowledgeBaseCountByOwner.mutex.RLock()

	argCopy := make([]*RepositoryMockGetKnowledgeBaseCountByOwnerParams, len(mmGetKnowledgeBaseCountByOwner.callArgs))
	copy(argCopy, mmGetKnowledgeBaseCountByOwner.callArgs)

	mmGetKnowledgeBaseCountByOwner.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBaseCountByOwnerDone returns true if the count of the GetKnowledgeBaseCountByOwner invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetKnowledgeBaseCountByOwnerDone() bool {
	if m.GetKnowledgeBaseCountByOwnerMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetKnowledgeBaseCountByOwnerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBaseCountByOwnerMock.invocationsDone()
}

// MinimockGetKnowledgeBaseCountByOwnerInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetKnowledgeBaseCountByOwnerInspect() {
	for _, e := range m.GetKnowledgeBaseCountByOwnerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseCountByOwner at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetKnowledgeBaseCountByOwnerCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBaseCountByOwnerCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBaseCountByOwnerMock.defaultExpectation != nil && afterGetKnowledgeBaseCountByOwnerCounter < 1 {
		if m.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseCountByOwner at\n%s", m.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseCountByOwner at\n%s with params: %#v", m.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.expectationOrigins.origin, *m.GetKnowledgeBaseCountByOwnerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBaseCountByOwner != nil && afterGetKnowledgeBaseCountByOwnerCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseCountByOwner at\n%s", m.funcGetKnowledgeBaseCountByOwnerOrigin)
	}

	if !m.GetKnowledgeBaseCountByOwnerMock.invocationsDone() && afterGetKnowledgeBaseCountByOwnerCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetKnowledgeBaseCountByOwner at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBaseCountByOwnerMock.expectedInvocations), m.GetKnowledgeBaseCountByOwnerMock.expectedInvocationsOrigin, afterGetKnowledgeBaseCountByOwnerCounter)
	}
}

type mRepositoryMockGetKnowledgeBaseFilesByFileUIDs struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectation
	expectations       []*RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectation

	callArgs []*RepositoryMockGetKnowledgeBaseFilesByFileUIDsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectation specifies expectation struct of the Repository.GetKnowledgeBaseFilesByFileUIDs
type RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetKnowledgeBaseFilesByFileUIDsParams
	paramPtrs          *RepositoryMockGetKnowledgeBaseFilesByFileUIDsParamPtrs
	expectationOrigins RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectationOrigins
	results            *RepositoryMockGetKnowledgeBaseFilesByFileUIDsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetKnowledgeBaseFilesByFileUIDsParams contains parameters of the Repository.GetKnowledgeBaseFilesByFileUIDs
type RepositoryMockGetKnowledgeBaseFilesByFileUIDsParams struct {
	ctx      context.Context
	fileUIDs []types.FileUIDType
	columns  []string
}

// RepositoryMockGetKnowledgeBaseFilesByFileUIDsParamPtrs contains pointers to parameters of the Repository.GetKnowledgeBaseFilesByFileUIDs
type RepositoryMockGetKnowledgeBaseFilesByFileUIDsParamPtrs struct {
	ctx      *context.Context
	fileUIDs *[]types.FileUIDType
	columns  *[]string
}

// RepositoryMockGetKnowledgeBaseFilesByFileUIDsResults contains results of the Repository.GetKnowledgeBaseFilesByFileUIDs
type RepositoryMockGetKnowledgeBaseFilesByFileUIDsResults struct {
	ka1 []mm_repository.KnowledgeBaseFileModel
	err error
}

// RepositoryMockGetKnowledgeBaseFilesByFileUIDsOrigins contains origins of expectations of the Repository.GetKnowledgeBaseFilesByFileUIDs
type RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectationOrigins struct {
	origin         string
	originCtx      string
	originFileUIDs string
	originColumns  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs) Optional() *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs {
	mmGetKnowledgeBaseFilesByFileUIDs.optional = true
	return mmGetKnowledgeBaseFilesByFileUIDs
}

// Expect sets up expected params for Repository.GetKnowledgeBaseFilesByFileUIDs
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs) Expect(ctx context.Context, fileUIDs []types.FileUIDType, columns ...string) *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs {
	if mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectation{}
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.params = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsParams{ctx, fileUIDs, columns}
	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetKnowledgeBaseFilesByFileUIDs.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.params) {
			mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBaseFilesByFileUIDs
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetKnowledgeBaseFilesByFileUIDs
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs {
	if mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectation{}
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.params != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Expect")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsParamPtrs{}
	}
	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseFilesByFileUIDs
}

// ExpectFileUIDsParam2 sets up expected param fileUIDs for Repository.GetKnowledgeBaseFilesByFileUIDs
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs) ExpectFileUIDsParam2(fileUIDs []types.FileUIDType) *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs {
	if mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectation{}
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.params != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Expect")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsParamPtrs{}
	}
	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs.fileUIDs = &fileUIDs
	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.expectationOrigins.originFileUIDs = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseFilesByFileUIDs
}

// ExpectColumnsParam3 sets up expected param columns for Repository.GetKnowledgeBaseFilesByFileUIDs
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs) ExpectColumnsParam3(columns ...string) *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs {
	if mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectation{}
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.params != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Expect")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsParamPtrs{}
	}
	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.paramPtrs.columns = &columns
	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.expectationOrigins.originColumns = minimock.CallerInfo(1)

	return mmGetKnowledgeBaseFilesByFileUIDs
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetKnowledgeBaseFilesByFileUIDs
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs) Inspect(f func(ctx context.Context, fileUIDs []types.FileUIDType, columns ...string)) *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs {
	if mmGetKnowledgeBaseFilesByFileUIDs.mock.inspectFuncGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetKnowledgeBaseFilesByFileUIDs")
	}

	mmGetKnowledgeBaseFilesByFileUIDs.mock.inspectFuncGetKnowledgeBaseFilesByFileUIDs = f

	return mmGetKnowledgeBaseFilesByFileUIDs
}

// Return sets up results that will be returned by Repository.GetKnowledgeBaseFilesByFileUIDs
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs) Return(ka1 []mm_repository.KnowledgeBaseFileModel, err error) *RepositoryMock {
	if mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation == nil {
		mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectation{mock: mmGetKnowledgeBaseFilesByFileUIDs.mock}
	}
	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.results = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsResults{ka1, err}
	mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseFilesByFileUIDs.mock
}

// Set uses given function f to mock the Repository.GetKnowledgeBaseFilesByFileUIDs method
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs) Set(f func(ctx context.Context, fileUIDs []types.FileUIDType, columns ...string) (ka1 []mm_repository.KnowledgeBaseFileModel, err error)) *RepositoryMock {
	if mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("Default expectation is already set for the Repository.GetKnowledgeBaseFilesByFileUIDs method")
	}

	if len(mmGetKnowledgeBaseFilesByFileUIDs.expectations) > 0 {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("Some expectations are already set for the Repository.GetKnowledgeBaseFilesByFileUIDs method")
	}

	mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs = f
	mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDsOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseFilesByFileUIDs.mock
}

// When sets expectation for the Repository.GetKnowledgeBaseFilesByFileUIDs which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs) When(ctx context.Context, fileUIDs []types.FileUIDType, columns ...string) *RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectation {
	if mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDs mock is already set by Set")
	}

	expectation := &RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectation{
		mock:               mmGetKnowledgeBaseFilesByFileUIDs.mock,
		params:             &RepositoryMockGetKnowledgeBaseFilesByFileUIDsParams{ctx, fileUIDs, columns},
		expectationOrigins: RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetKnowledgeBaseFilesByFileUIDs.expectations = append(mmGetKnowledgeBaseFilesByFileUIDs.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetKnowledgeBaseFilesByFileUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetKnowledgeBaseFilesByFileUIDsExpectation) Then(ka1 []mm_repository.KnowledgeBaseFileModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetKnowledgeBaseFilesByFileUIDsResults{ka1, err}
	return e.mock
}

// Times sets number of times Repository.GetKnowledgeBaseFilesByFileUIDs should be invoked
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs) Times(n uint64) *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs {
	if n == 0 {
		mmGetKnowledgeBaseFilesByFileUIDs.mock.t.Fatalf("Times of RepositoryMock.GetKnowledgeBaseFilesByFileUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBaseFilesByFileUIDs.expectedInvocations, n)
	mmGetKnowledgeBaseFilesByFileUIDs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBaseFilesByFileUIDs
}

func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs) invocationsDone() bool {
	if len(mmGetKnowledgeBaseFilesByFileUIDs.expectations) == 0 && mmGetKnowledgeBaseFilesByFileUIDs.defaultExpectation == nil && mmGetKnowledgeBaseFilesByFileUIDs.mock.funcGetKnowledgeBaseFilesByFileUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseFilesByFileUIDs.mock.afterGetKnowledgeBaseFilesByFileUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBaseFilesByFileUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBaseFilesByFileUIDs implements mm_repository.Repository
func (mmGetKnowledgeBaseFilesByFileUIDs *RepositoryMock) GetKnowledgeBaseFilesByFileUIDs(ctx context.Context, fileUIDs []types.FileUIDType, columns ...string) (ka1 []mm_repository.KnowledgeBaseFileModel, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBaseFilesByFileUIDs.beforeGetKnowledgeBaseFilesByFileUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBaseFilesByFileUIDs.afterGetKnowledgeBaseFilesByFileUIDsCounter, 1)

	mmGetKnowledgeBaseFilesByFileUIDs.t.Helper()

	if mmGetKnowledgeBaseFilesByFileUIDs.inspectFuncGetKnowledgeBaseFilesByFileUIDs != nil {
		mmGetKnowledgeBaseFilesByFileUIDs.inspectFuncGetKnowledgeBaseFilesByFileUIDs(ctx, fileUIDs, columns...)
	}

	mm_params := RepositoryMockGetKnowledgeBaseFilesByFileUIDsParams{ctx, fileUIDs, columns}

	// Record call args
	mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.mutex.Lock()
	mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.callArgs = append(mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.callArgs, &mm_params)
	mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetKnowledgeBaseFilesByFileUIDsParams{ctx, fileUIDs, columns}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBaseFilesByFileUIDs.t.Errorf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDs got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUIDs != nil && !minimock.Equal(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs) {
				mmGetKnowledgeBaseFilesByFileUIDs.t.Errorf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDs got unexpected parameter fileUIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.expectationOrigins.originFileUIDs, *mm_want_ptrs.fileUIDs, mm_got.fileUIDs, minimock.Diff(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs))
			}

			if mm_want_ptrs.columns != nil && !minimock.Equal(*mm_want_ptrs.columns, mm_got.columns) {
				mmGetKnowledgeBaseFilesByFileUIDs.t.Errorf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDs got unexpected parameter columns, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.expectationOrigins.originColumns, *mm_want_ptrs.columns, mm_got.columns, minimock.Diff(*mm_want_ptrs.columns, mm_got.columns))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBaseFilesByFileUIDs.t.Errorf("RepositoryMock.GetKnowledgeBaseFilesByFileUIDs got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBaseFilesByFileUIDs.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBaseFilesByFileUIDs.t.Fatal("No results are set for the RepositoryMock.GetKnowledgeBaseFilesByFileUIDs")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmGetKnowledgeBaseFilesByFileUIDs.funcGetKnowledgeBaseFilesByFileUIDs != nil {
		return mmGetKnowledgeBaseFilesByFileUIDs.funcGetKnowledgeBaseFilesByFileUIDs(ctx, fileUIDs, columns...)
	}
	mmGetKnowledgeBaseFilesByFileUIDs.t.Fatalf("Unexpected call to RepositoryMock.GetKnowledgeBaseFilesByFileUIDs. %v %v %v", ctx, fileUIDs, columns)
	return
}

// GetKnowledgeBaseFilesByFileUIDsAfterCounter returns a count of finished RepositoryMock.GetKnowledgeBaseFilesByFileUIDs invocations
func (mmGetKnowledgeBaseFilesByFileUIDs *RepositoryMock) GetKnowledgeBaseFilesByFileUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseFilesByFileUIDs.afterGetKnowledgeBaseFilesByFileUIDsCounter)
}

// GetKnowledgeBaseFilesByFileUIDsBeforeCounter returns a count of RepositoryMock.GetKnowledgeBaseFilesByFileUIDs invocations
func (mmGetKnowledgeBaseFilesByFileUIDs *RepositoryMock) GetKnowledgeBaseFilesByFileUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBaseFilesByFileUIDs.beforeGetKnowledgeBaseFilesByFileUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetKnowledgeBaseFilesByFileUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBaseFilesByFileUIDs *mRepositoryMockGetKnowledgeBaseFilesByFileUIDs) Calls() []*RepositoryMockGetKnowledgeBaseFilesByFileUIDsParams {
	mmGetKnowledgeBaseFilesByFileUIDs.mutex.RLock()

	argCopy := make([]*RepositoryMockGetKnowledgeBaseFilesByFileUIDsParams, len(mmGetKnowledgeBaseFilesByFileUIDs.callArgs))
	copy(argCopy, mmGetKnowledgeBaseFilesByFileUIDs.callArgs)

	mmGetKnowledgeBaseFilesByFileUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBaseFilesByFileUIDsDone returns true if the count of the GetKnowledgeBaseFilesByFileUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetKnowledgeBaseFilesByFileUIDsDone() bool {
	if m.GetKnowledgeBaseFilesByFileUIDsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetKnowledgeBaseFilesByFileUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBaseFilesByFileUIDsMock.invocationsDone()
}

// MinimockGetKnowledgeBaseFilesByFileUIDsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetKnowledgeBaseFilesByFileUIDsInspect() {
	for _, e := range m.GetKnowledgeBaseFilesByFileUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseFilesByFileUIDs at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetKnowledgeBaseFilesByFileUIDsCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBaseFilesByFileUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation != nil && afterGetKnowledgeBaseFilesByFileUIDsCounter < 1 {
		if m.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseFilesByFileUIDs at\n%s", m.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseFilesByFileUIDs at\n%s with params: %#v", m.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.expectationOrigins.origin, *m.GetKnowledgeBaseFilesByFileUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBaseFilesByFileUIDs != nil && afterGetKnowledgeBaseFilesByFileUIDsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBaseFilesByFileUIDs at\n%s", m.funcGetKnowledgeBaseFilesByFileUIDsOrigin)
	}

	if !m.GetKnowledgeBaseFilesByFileUIDsMock.invocationsDone() && afterGetKnowledgeBaseFilesByFileUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetKnowledgeBaseFilesByFileUIDs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBaseFilesByFileUIDsMock.expectedInvocations), m.GetKnowledgeBaseFilesByFileUIDsMock.expectedInvocationsOrigin, afterGetKnowledgeBaseFilesByFileUIDsCounter)
	}
}

type mRepositoryMockGetKnowledgeBasesByUIDs struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetKnowledgeBasesByUIDsExpectation
	expectations       []*RepositoryMockGetKnowledgeBasesByUIDsExpectation

	callArgs []*RepositoryMockGetKnowledgeBasesByUIDsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetKnowledgeBasesByUIDsExpectation specifies expectation struct of the Repository.GetKnowledgeBasesByUIDs
type RepositoryMockGetKnowledgeBasesByUIDsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetKnowledgeBasesByUIDsParams
	paramPtrs          *RepositoryMockGetKnowledgeBasesByUIDsParamPtrs
	expectationOrigins RepositoryMockGetKnowledgeBasesByUIDsExpectationOrigins
	results            *RepositoryMockGetKnowledgeBasesByUIDsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetKnowledgeBasesByUIDsParams contains parameters of the Repository.GetKnowledgeBasesByUIDs
type RepositoryMockGetKnowledgeBasesByUIDsParams struct {
	ctx    context.Context
	kbUIDs []types.KBUIDType
}

// RepositoryMockGetKnowledgeBasesByUIDsParamPtrs contains pointers to parameters of the Repository.GetKnowledgeBasesByUIDs
type RepositoryMockGetKnowledgeBasesByUIDsParamPtrs struct {
	ctx    *context.Context
	kbUIDs *[]types.KBUIDType
}

// RepositoryMockGetKnowledgeBasesByUIDsResults contains results of the Repository.GetKnowledgeBasesByUIDs
type RepositoryMockGetKnowledgeBasesByUIDsResults struct {
	ka1 []mm_repository.KnowledgeBaseModel
	err error
}

// RepositoryMockGetKnowledgeBasesByUIDsOrigins contains origins of expectations of the Repository.GetKnowledgeBasesByUIDs
type RepositoryMockGetKnowledgeBasesByUIDsExpectationOrigins struct {
	origin       string
	originCtx    string
	originKbUIDs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetKnowledgeBasesByUIDs *mRepositoryMockGetKnowledgeBasesByUIDs) Optional() *mRepositoryMockGetKnowledgeBasesByUIDs {
	mmGetKnowledgeBasesByUIDs.optional = true
	return mmGetKnowledgeBasesByUIDs
}

// Expect sets up expected params for Repository.GetKnowledgeBasesByUIDs
func (mmGetKnowledgeBasesByUIDs *mRepositoryMockGetKnowledgeBasesByUIDs) Expect(ctx context.Context, kbUIDs []types.KBUIDType) *mRepositoryMockGetKnowledgeBasesByUIDs {
	if mmGetKnowledgeBasesByUIDs.mock.funcGetKnowledgeBasesByUIDs != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBasesByUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBasesByUIDs.defaultExpectation == nil {
		mmGetKnowledgeBasesByUIDs.defaultExpectation = &RepositoryMockGetKnowledgeBasesByUIDsExpectation{}
	}

	if mmGetKnowledgeBasesByUIDs.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBasesByUIDs mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBasesByUIDs.defaultExpectation.params = &RepositoryMockGetKnowledgeBasesByUIDsParams{ctx, kbUIDs}
	mmGetKnowledgeBasesByUIDs.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetKnowledgeBasesByUIDs.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBasesByUIDs.defaultExpectation.params) {
			mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBasesByUIDs.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBasesByUIDs
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetKnowledgeBasesByUIDs
func (mmGetKnowledgeBasesByUIDs *mRepositoryMockGetKnowledgeBasesByUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetKnowledgeBasesByUIDs {
	if mmGetKnowledgeBasesByUIDs.mock.funcGetKnowledgeBasesByUIDs != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBasesByUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBasesByUIDs.defaultExpectation == nil {
		mmGetKnowledgeBasesByUIDs.defaultExpectation = &RepositoryMockGetKnowledgeBasesByUIDsExpectation{}
	}

	if mmGetKnowledgeBasesByUIDs.defaultExpectation.params != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBasesByUIDs mock is already set by Expect")
	}

	if mmGetKnowledgeBasesByUIDs.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBasesByUIDs.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBasesByUIDsParamPtrs{}
	}
	mmGetKnowledgeBasesByUIDs.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetKnowledgeBasesByUIDs.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetKnowledgeBasesByUIDs
}

// ExpectKbUIDsParam2 sets up expected param kbUIDs for Repository.GetKnowledgeBasesByUIDs
func (mmGetKnowledgeBasesByUIDs *mRepositoryMockGetKnowledgeBasesByUIDs) ExpectKbUIDsParam2(kbUIDs []types.KBUIDType) *mRepositoryMockGetKnowledgeBasesByUIDs {
	if mmGetKnowledgeBasesByUIDs.mock.funcGetKnowledgeBasesByUIDs != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBasesByUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBasesByUIDs.defaultExpectation == nil {
		mmGetKnowledgeBasesByUIDs.defaultExpectation = &RepositoryMockGetKnowledgeBasesByUIDsExpectation{}
	}

	if mmGetKnowledgeBasesByUIDs.defaultExpectation.params != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBasesByUIDs mock is already set by Expect")
	}

	if mmGetKnowledgeBasesByUIDs.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBasesByUIDs.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgeBasesByUIDsParamPtrs{}
	}
	mmGetKnowledgeBasesByUIDs.defaultExpectation.paramPtrs.kbUIDs = &kbUIDs
	mmGetKnowledgeBasesByUIDs.defaultExpectation.expectationOrigins.originKbUIDs = minimock.CallerInfo(1)

	return mmGetKnowledgeBasesByUIDs
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetKnowledgeBasesByUIDs
func (mmGetKnowledgeBasesByUIDs *mRepositoryMockGetKnowledgeBasesByUIDs) Inspect(f func(ctx context.Context, kbUIDs []types.KBUIDType)) *mRepositoryMockGetKnowledgeBasesByUIDs {
	if mmGetKnowledgeBasesByUIDs.mock.inspectFuncGetKnowledgeBasesByUIDs != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetKnowledgeBasesByUIDs")
	}

	mmGetKnowledgeBasesByUIDs.mock.inspectFuncGetKnowledgeBasesByUIDs = f

	return mmGetKnowledgeBasesByUIDs
}

// Return sets up results that will be returned by Repository.GetKnowledgeBasesByUIDs
func (mmGetKnowledgeBasesByUIDs *mRepositoryMockGetKnowledgeBasesByUIDs) Return(ka1 []mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	if mmGetKnowledgeBasesByUIDs.mock.funcGetKnowledgeBasesByUIDs != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBasesByUIDs mock is already set by Set")
	}

	if mmGetKnowledgeBasesByUIDs.defaultExpectation == nil {
		mmGetKnowledgeBasesByUIDs.defaultExpectation = &RepositoryMockGetKnowledgeBasesByUIDsExpectation{mock: mmGetKnowledgeBasesByUIDs.mock}
	}
	mmGetKnowledgeBasesByUIDs.defaultExpectation.results = &RepositoryMockGetKnowledgeBasesByUIDsResults{ka1, err}
	mmGetKnowledgeBasesByUIDs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBasesByUIDs.mock
}

// Set uses given function f to mock the Repository.GetKnowledgeBasesByUIDs method
func (mmGetKnowledgeBasesByUIDs *mRepositoryMockGetKnowledgeBasesByUIDs) Set(f func(ctx context.Context, kbUIDs []types.KBUIDType) (ka1 []mm_repository.KnowledgeBaseModel, err error)) *RepositoryMock {
	if mmGetKnowledgeBasesByUIDs.defaultExpectation != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("Default expectation is already set for the Repository.GetKnowledgeBasesByUIDs method")
	}

	if len(mmGetKnowledgeBasesByUIDs.expectations) > 0 {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("Some expectations are already set for the Repository.GetKnowledgeBasesByUIDs method")
	}

	mmGetKnowledgeBasesByUIDs.mock.funcGetKnowledgeBasesByUIDs = f
	mmGetKnowledgeBasesByUIDs.mock.funcGetKnowledgeBasesByUIDsOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBasesByUIDs.mock
}

// When sets expectation for the Repository.GetKnowledgeBasesByUIDs which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBasesByUIDs *mRepositoryMockGetKnowledgeBasesByUIDs) When(ctx context.Context, kbUIDs []types.KBUIDType) *RepositoryMockGetKnowledgeBasesByUIDsExpectation {
	if mmGetKnowledgeBasesByUIDs.mock.funcGetKnowledgeBasesByUIDs != nil {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("RepositoryMock.GetKnowledgeBasesByUIDs mock is already set by Set")
	}

	expectation := &RepositoryMockGetKnowledgeBasesByUIDsExpectation{
		mock:               mmGetKnowledgeBasesByUIDs.mock,
		params:             &RepositoryMockGetKnowledgeBasesByUIDsParams{ctx, kbUIDs},
		expectationOrigins: RepositoryMockGetKnowledgeBasesByUIDsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetKnowledgeBasesByUIDs.expectations = append(mmGetKnowledgeBasesByUIDs.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetKnowledgeBasesByUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetKnowledgeBasesByUIDsExpectation) Then(ka1 []mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetKnowledgeBasesByUIDsResults{ka1, err}
	return e.mock
}

// Times sets number of times Repository.GetKnowledgeBasesByUIDs should be invoked
func (mmGetKnowledgeBasesByUIDs *mRepositoryMockGetKnowledgeBasesByUIDs) Times(n uint64) *mRepositoryMockGetKnowledgeBasesByUIDs {
	if n == 0 {
		mmGetKnowledgeBasesByUIDs.mock.t.Fatalf("Times of RepositoryMock.GetKnowledgeBasesByUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBasesByUIDs.expectedInvocations, n)
	mmGetKnowledgeBasesByUIDs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBasesByUIDs
}

func (mmGetKnowledgeBasesByUIDs *mRepositoryMockGetKnowledgeBasesByUIDs) invocationsDone() bool {
	if len(mmGetKnowledgeBasesByUIDs.expectations) == 0 && mmGetKnowledgeBasesByUIDs.defaultExpectation == nil && mmGetKnowledgeBasesByUIDs.mock.funcGetKnowledgeBasesByUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBasesByUIDs.mock.afterGetKnowledgeBasesByUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBasesByUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBasesByUIDs implements mm_repository.Repository
func (mmGetKnowledgeBasesByUIDs *RepositoryMock) GetKnowledgeBasesByUIDs(ctx context.Context, kbUIDs []types.KBUIDType) (ka1 []mm_repository.KnowledgeBaseModel, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBasesByUIDs.beforeGetKnowledgeBasesByUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBasesByUIDs.afterGetKnowledgeBasesByUIDsCounter, 1)

	mmGetKnowledgeBasesByUIDs.t.Helper()

	if mmGetKnowledgeBasesByUIDs.inspectFuncGetKnowledgeBasesByUIDs != nil {
		mmGetKnowledgeBasesByUIDs.inspectFuncGetKnowledgeBasesByUIDs(ctx, kbUIDs)
	}

	mm_params := RepositoryMockGetKnowledgeBasesByUIDsParams{ctx, kbUIDs}

	// Record call args
	mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.mutex.Lock()
	mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.callArgs = append(mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.callArgs, &mm_params)
	mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetKnowledgeBasesByUIDsParams{ctx, kbUIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBasesByUIDs.t.Errorf("RepositoryMock.GetKnowledgeBasesByUIDs got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUIDs != nil && !minimock.Equal(*mm_want_ptrs.kbUIDs, mm_got.kbUIDs) {
				mmGetKnowledgeBasesByUIDs.t.Errorf("RepositoryMock.GetKnowledgeBasesByUIDs got unexpected parameter kbUIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.defaultExpectation.expectationOrigins.originKbUIDs, *mm_want_ptrs.kbUIDs, mm_got.kbUIDs, minimock.Diff(*mm_want_ptrs.kbUIDs, mm_got.kbUIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBasesByUIDs.t.Errorf("RepositoryMock.GetKnowledgeBasesByUIDs got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBasesByUIDs.GetKnowledgeBasesByUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBasesByUIDs.t.Fatal("No results are set for the RepositoryMock.GetKnowledgeBasesByUIDs")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmGetKnowledgeBasesByUIDs.funcGetKnowledgeBasesByUIDs != nil {
		return mmGetKnowledgeBasesByUIDs.funcGetKnowledgeBasesByUIDs(ctx, kbUIDs)
	}
	mmGetKnowledgeBasesByUIDs.t.Fatalf("Unexpected call to RepositoryMock.GetKnowledgeBasesByUIDs. %v %v", ctx, kbUIDs)
	return
}

// GetKnowledgeBasesByUIDsAfterCounter returns a count of finished RepositoryMock.GetKnowledgeBasesByUIDs invocations
func (mmGetKnowledgeBasesByUIDs *RepositoryMock) GetKnowledgeBasesByUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBasesByUIDs.afterGetKnowledgeBasesByUIDsCounter)
}

// GetKnowledgeBasesByUIDsBeforeCounter returns a count of RepositoryMock.GetKnowledgeBasesByUIDs invocations
func (mmGetKnowledgeBasesByUIDs *RepositoryMock) GetKnowledgeBasesByUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBasesByUIDs.beforeGetKnowledgeBasesByUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetKnowledgeBasesByUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBasesByUIDs *mRepositoryMockGetKnowledgeBasesByUIDs) Calls() []*RepositoryMockGetKnowledgeBasesByUIDsParams {
	mmGetKnowledgeBasesByUIDs.mutex.RLock()

	argCopy := make([]*RepositoryMockGetKnowledgeBasesByUIDsParams, len(mmGetKnowledgeBasesByUIDs.callArgs))
	copy(argCopy, mmGetKnowledgeBasesByUIDs.callArgs)

	mmGetKnowledgeBasesByUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBasesByUIDsDone returns true if the count of the GetKnowledgeBasesByUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetKnowledgeBasesByUIDsDone() bool {
	if m.GetKnowledgeBasesByUIDsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetKnowledgeBasesByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBasesByUIDsMock.invocationsDone()
}

// MinimockGetKnowledgeBasesByUIDsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetKnowledgeBasesByUIDsInspect() {
	for _, e := range m.GetKnowledgeBasesByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBasesByUIDs at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetKnowledgeBasesByUIDsCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBasesByUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBasesByUIDsMock.defaultExpectation != nil && afterGetKnowledgeBasesByUIDsCounter < 1 {
		if m.GetKnowledgeBasesByUIDsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBasesByUIDs at\n%s", m.GetKnowledgeBasesByUIDsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBasesByUIDs at\n%s with params: %#v", m.GetKnowledgeBasesByUIDsMock.defaultExpectation.expectationOrigins.origin, *m.GetKnowledgeBasesByUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBasesByUIDs != nil && afterGetKnowledgeBasesByUIDsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetKnowledgeBasesByUIDs at\n%s", m.funcGetKnowledgeBasesByUIDsOrigin)
	}

	if !m.GetKnowledgeBasesByUIDsMock.invocationsDone() && afterGetKnowledgeBasesByUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetKnowledgeBasesByUIDs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBasesByUIDsMock.expectedInvocations), m.GetKnowledgeBasesByUIDsMock.expectedInvocationsOrigin, afterGetKnowledgeBasesByUIDsCounter)
	}
}

type mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectation
	expectations       []*RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectation

	callArgs []*RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectation specifies expectation struct of the Repository.GetKnowledgebaseFileByKBUIDAndFileID
type RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParams
	paramPtrs          *RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParamPtrs
	expectationOrigins RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectationOrigins
	results            *RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParams contains parameters of the Repository.GetKnowledgebaseFileByKBUIDAndFileID
type RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParams struct {
	ctx    context.Context
	kbUID  types.KBUIDType
	fileID string
}

// RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParamPtrs contains pointers to parameters of the Repository.GetKnowledgebaseFileByKBUIDAndFileID
type RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParamPtrs struct {
	ctx    *context.Context
	kbUID  *types.KBUIDType
	fileID *string
}

// RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDResults contains results of the Repository.GetKnowledgebaseFileByKBUIDAndFileID
type RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDResults struct {
	kp1 *mm_repository.KnowledgeBaseFileModel
	err error
}

// RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDOrigins contains origins of expectations of the Repository.GetKnowledgebaseFileByKBUIDAndFileID
type RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectationOrigins struct {
	origin       string
	originCtx    string
	originKbUID  string
	originFileID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetKnowledgebaseFileByKBUIDAndFileID *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID) Optional() *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID {
	mmGetKnowledgebaseFileByKBUIDAndFileID.optional = true
	return mmGetKnowledgebaseFileByKBUIDAndFileID
}

// Expect sets up expected params for Repository.GetKnowledgebaseFileByKBUIDAndFileID
func (mmGetKnowledgebaseFileByKBUIDAndFileID *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID) Expect(ctx context.Context, kbUID types.KBUIDType, fileID string) *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID {
	if mmGetKnowledgebaseFileByKBUIDAndFileID.mock.funcGetKnowledgebaseFileByKBUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID mock is already set by Set")
	}

	if mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation == nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation = &RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectation{}
	}

	if mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID mock is already set by ExpectParams functions")
	}

	mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.params = &RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParams{ctx, kbUID, fileID}
	mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetKnowledgebaseFileByKBUIDAndFileID.expectations {
		if minimock.Equal(e.params, mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.params) {
			mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.params)
		}
	}

	return mmGetKnowledgebaseFileByKBUIDAndFileID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetKnowledgebaseFileByKBUIDAndFileID
func (mmGetKnowledgebaseFileByKBUIDAndFileID *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID {
	if mmGetKnowledgebaseFileByKBUIDAndFileID.mock.funcGetKnowledgebaseFileByKBUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID mock is already set by Set")
	}

	if mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation == nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation = &RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectation{}
	}

	if mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.params != nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID mock is already set by Expect")
	}

	if mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParamPtrs{}
	}
	mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetKnowledgebaseFileByKBUIDAndFileID
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.GetKnowledgebaseFileByKBUIDAndFileID
func (mmGetKnowledgebaseFileByKBUIDAndFileID *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID {
	if mmGetKnowledgebaseFileByKBUIDAndFileID.mock.funcGetKnowledgebaseFileByKBUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID mock is already set by Set")
	}

	if mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation == nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation = &RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectation{}
	}

	if mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.params != nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID mock is already set by Expect")
	}

	if mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParamPtrs{}
	}
	mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmGetKnowledgebaseFileByKBUIDAndFileID
}

// ExpectFileIDParam3 sets up expected param fileID for Repository.GetKnowledgebaseFileByKBUIDAndFileID
func (mmGetKnowledgebaseFileByKBUIDAndFileID *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID) ExpectFileIDParam3(fileID string) *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID {
	if mmGetKnowledgebaseFileByKBUIDAndFileID.mock.funcGetKnowledgebaseFileByKBUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID mock is already set by Set")
	}

	if mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation == nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation = &RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectation{}
	}

	if mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.params != nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID mock is already set by Expect")
	}

	if mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.paramPtrs = &RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParamPtrs{}
	}
	mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.paramPtrs.fileID = &fileID
	mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.expectationOrigins.originFileID = minimock.CallerInfo(1)

	return mmGetKnowledgebaseFileByKBUIDAndFileID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetKnowledgebaseFileByKBUIDAndFileID
func (mmGetKnowledgebaseFileByKBUIDAndFileID *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID) Inspect(f func(ctx context.Context, kbUID types.KBUIDType, fileID string)) *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID {
	if mmGetKnowledgebaseFileByKBUIDAndFileID.mock.inspectFuncGetKnowledgebaseFileByKBUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID")
	}

	mmGetKnowledgebaseFileByKBUIDAndFileID.mock.inspectFuncGetKnowledgebaseFileByKBUIDAndFileID = f

	return mmGetKnowledgebaseFileByKBUIDAndFileID
}

// Return sets up results that will be returned by Repository.GetKnowledgebaseFileByKBUIDAndFileID
func (mmGetKnowledgebaseFileByKBUIDAndFileID *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID) Return(kp1 *mm_repository.KnowledgeBaseFileModel, err error) *RepositoryMock {
	if mmGetKnowledgebaseFileByKBUIDAndFileID.mock.funcGetKnowledgebaseFileByKBUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID mock is already set by Set")
	}

	if mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation == nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation = &RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectation{mock: mmGetKnowledgebaseFileByKBUIDAndFileID.mock}
	}
	mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.results = &RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDResults{kp1, err}
	mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgebaseFileByKBUIDAndFileID.mock
}

// Set uses given function f to mock the Repository.GetKnowledgebaseFileByKBUIDAndFileID method
func (mmGetKnowledgebaseFileByKBUIDAndFileID *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID) Set(f func(ctx context.Context, kbUID types.KBUIDType, fileID string) (kp1 *mm_repository.KnowledgeBaseFileModel, err error)) *RepositoryMock {
	if mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation != nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("Default expectation is already set for the Repository.GetKnowledgebaseFileByKBUIDAndFileID method")
	}

	if len(mmGetKnowledgebaseFileByKBUIDAndFileID.expectations) > 0 {
		mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("Some expectations are already set for the Repository.GetKnowledgebaseFileByKBUIDAndFileID method")
	}

	mmGetKnowledgebaseFileByKBUIDAndFileID.mock.funcGetKnowledgebaseFileByKBUIDAndFileID = f
	mmGetKnowledgebaseFileByKBUIDAndFileID.mock.funcGetKnowledgebaseFileByKBUIDAndFileIDOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgebaseFileByKBUIDAndFileID.mock
}

// When sets expectation for the Repository.GetKnowledgebaseFileByKBUIDAndFileID which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgebaseFileByKBUIDAndFileID *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID) When(ctx context.Context, kbUID types.KBUIDType, fileID string) *RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectation {
	if mmGetKnowledgebaseFileByKBUIDAndFileID.mock.funcGetKnowledgebaseFileByKBUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID mock is already set by Set")
	}

	expectation := &RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectation{
		mock:               mmGetKnowledgebaseFileByKBUIDAndFileID.mock,
		params:             &RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParams{ctx, kbUID, fileID},
		expectationOrigins: RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetKnowledgebaseFileByKBUIDAndFileID.expectations = append(mmGetKnowledgebaseFileByKBUIDAndFileID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetKnowledgebaseFileByKBUIDAndFileID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDExpectation) Then(kp1 *mm_repository.KnowledgeBaseFileModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDResults{kp1, err}
	return e.mock
}

// Times sets number of times Repository.GetKnowledgebaseFileByKBUIDAndFileID should be invoked
func (mmGetKnowledgebaseFileByKBUIDAndFileID *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID) Times(n uint64) *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID {
	if n == 0 {
		mmGetKnowledgebaseFileByKBUIDAndFileID.mock.t.Fatalf("Times of RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgebaseFileByKBUIDAndFileID.expectedInvocations, n)
	mmGetKnowledgebaseFileByKBUIDAndFileID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgebaseFileByKBUIDAndFileID
}

func (mmGetKnowledgebaseFileByKBUIDAndFileID *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID) invocationsDone() bool {
	if len(mmGetKnowledgebaseFileByKBUIDAndFileID.expectations) == 0 && mmGetKnowledgebaseFileByKBUIDAndFileID.defaultExpectation == nil && mmGetKnowledgebaseFileByKBUIDAndFileID.mock.funcGetKnowledgebaseFileByKBUIDAndFileID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgebaseFileByKBUIDAndFileID.mock.afterGetKnowledgebaseFileByKBUIDAndFileIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgebaseFileByKBUIDAndFileID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgebaseFileByKBUIDAndFileID implements mm_repository.Repository
func (mmGetKnowledgebaseFileByKBUIDAndFileID *RepositoryMock) GetKnowledgebaseFileByKBUIDAndFileID(ctx context.Context, kbUID types.KBUIDType, fileID string) (kp1 *mm_repository.KnowledgeBaseFileModel, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgebaseFileByKBUIDAndFileID.beforeGetKnowledgebaseFileByKBUIDAndFileIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgebaseFileByKBUIDAndFileID.afterGetKnowledgebaseFileByKBUIDAndFileIDCounter, 1)

	mmGetKnowledgebaseFileByKBUIDAndFileID.t.Helper()

	if mmGetKnowledgebaseFileByKBUIDAndFileID.inspectFuncGetKnowledgebaseFileByKBUIDAndFileID != nil {
		mmGetKnowledgebaseFileByKBUIDAndFileID.inspectFuncGetKnowledgebaseFileByKBUIDAndFileID(ctx, kbUID, fileID)
	}

	mm_params := RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParams{ctx, kbUID, fileID}

	// Record call args
	mmGetKnowledgebaseFileByKBUIDAndFileID.GetKnowledgebaseFileByKBUIDAndFileIDMock.mutex.Lock()
	mmGetKnowledgebaseFileByKBUIDAndFileID.GetKnowledgebaseFileByKBUIDAndFileIDMock.callArgs = append(mmGetKnowledgebaseFileByKBUIDAndFileID.GetKnowledgebaseFileByKBUIDAndFileIDMock.callArgs, &mm_params)
	mmGetKnowledgebaseFileByKBUIDAndFileID.GetKnowledgebaseFileByKBUIDAndFileIDMock.mutex.Unlock()

	for _, e := range mmGetKnowledgebaseFileByKBUIDAndFileID.GetKnowledgebaseFileByKBUIDAndFileIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmGetKnowledgebaseFileByKBUIDAndFileID.GetKnowledgebaseFileByKBUIDAndFileIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgebaseFileByKBUIDAndFileID.GetKnowledgebaseFileByKBUIDAndFileIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgebaseFileByKBUIDAndFileID.GetKnowledgebaseFileByKBUIDAndFileIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgebaseFileByKBUIDAndFileID.GetKnowledgebaseFileByKBUIDAndFileIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParams{ctx, kbUID, fileID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgebaseFileByKBUIDAndFileID.t.Errorf("RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgebaseFileByKBUIDAndFileID.GetKnowledgebaseFileByKBUIDAndFileIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmGetKnowledgebaseFileByKBUIDAndFileID.t.Errorf("RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgebaseFileByKBUIDAndFileID.GetKnowledgebaseFileByKBUIDAndFileIDMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.fileID != nil && !minimock.Equal(*mm_want_ptrs.fileID, mm_got.fileID) {
				mmGetKnowledgebaseFileByKBUIDAndFileID.t.Errorf("RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID got unexpected parameter fileID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgebaseFileByKBUIDAndFileID.GetKnowledgebaseFileByKBUIDAndFileIDMock.defaultExpectation.expectationOrigins.originFileID, *mm_want_ptrs.fileID, mm_got.fileID, minimock.Diff(*mm_want_ptrs.fileID, mm_got.fileID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgebaseFileByKBUIDAndFileID.t.Errorf("RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetKnowledgebaseFileByKBUIDAndFileID.GetKnowledgebaseFileByKBUIDAndFileIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgebaseFileByKBUIDAndFileID.GetKnowledgebaseFileByKBUIDAndFileIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgebaseFileByKBUIDAndFileID.t.Fatal("No results are set for the RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmGetKnowledgebaseFileByKBUIDAndFileID.funcGetKnowledgebaseFileByKBUIDAndFileID != nil {
		return mmGetKnowledgebaseFileByKBUIDAndFileID.funcGetKnowledgebaseFileByKBUIDAndFileID(ctx, kbUID, fileID)
	}
	mmGetKnowledgebaseFileByKBUIDAndFileID.t.Fatalf("Unexpected call to RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID. %v %v %v", ctx, kbUID, fileID)
	return
}

// GetKnowledgebaseFileByKBUIDAndFileIDAfterCounter returns a count of finished RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID invocations
func (mmGetKnowledgebaseFileByKBUIDAndFileID *RepositoryMock) GetKnowledgebaseFileByKBUIDAndFileIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgebaseFileByKBUIDAndFileID.afterGetKnowledgebaseFileByKBUIDAndFileIDCounter)
}

// GetKnowledgebaseFileByKBUIDAndFileIDBeforeCounter returns a count of RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID invocations
func (mmGetKnowledgebaseFileByKBUIDAndFileID *RepositoryMock) GetKnowledgebaseFileByKBUIDAndFileIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgebaseFileByKBUIDAndFileID.beforeGetKnowledgebaseFileByKBUIDAndFileIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgebaseFileByKBUIDAndFileID *mRepositoryMockGetKnowledgebaseFileByKBUIDAndFileID) Calls() []*RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParams {
	mmGetKnowledgebaseFileByKBUIDAndFileID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetKnowledgebaseFileByKBUIDAndFileIDParams, len(mmGetKnowledgebaseFileByKBUIDAndFileID.callArgs))
	copy(argCopy, mmGetKnowledgebaseFileByKBUIDAndFileID.callArgs)

	mmGetKnowledgebaseFileByKBUIDAndFileID.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgebaseFileByKBUIDAndFileIDDone returns true if the count of the GetKnowledgebaseFileByKBUIDAndFileID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetKnowledgebaseFileByKBUIDAndFileIDDone() bool {
	if m.GetKnowledgebaseFileByKBUIDAndFileIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetKnowledgebaseFileByKBUIDAndFileIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgebaseFileByKBUIDAndFileIDMock.invocationsDone()
}

// MinimockGetKnowledgebaseFileByKBUIDAndFileIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetKnowledgebaseFileByKBUIDAndFileIDInspect() {
	for _, e := range m.GetKnowledgebaseFileByKBUIDAndFileIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetKnowledgebaseFileByKBUIDAndFileIDCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgebaseFileByKBUIDAndFileIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgebaseFileByKBUIDAndFileIDMock.defaultExpectation != nil && afterGetKnowledgebaseFileByKBUIDAndFileIDCounter < 1 {
		if m.GetKnowledgebaseFileByKBUIDAndFileIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID at\n%s", m.GetKnowledgebaseFileByKBUIDAndFileIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID at\n%s with params: %#v", m.GetKnowledgebaseFileByKBUIDAndFileIDMock.defaultExpectation.expectationOrigins.origin, *m.GetKnowledgebaseFileByKBUIDAndFileIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgebaseFileByKBUIDAndFileID != nil && afterGetKnowledgebaseFileByKBUIDAndFileIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID at\n%s", m.funcGetKnowledgebaseFileByKBUIDAndFileIDOrigin)
	}

	if !m.GetKnowledgebaseFileByKBUIDAndFileIDMock.invocationsDone() && afterGetKnowledgebaseFileByKBUIDAndFileIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetKnowledgebaseFileByKBUIDAndFileID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgebaseFileByKBUIDAndFileIDMock.expectedInvocations), m.GetKnowledgebaseFileByKBUIDAndFileIDMock.expectedInvocationsOrigin, afterGetKnowledgebaseFileByKBUIDAndFileIDCounter)
	}
}

type mRepositoryMockGetObjectByUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetObjectByUIDExpectation
	expectations       []*RepositoryMockGetObjectByUIDExpectation

	callArgs []*RepositoryMockGetObjectByUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetObjectByUIDExpectation specifies expectation struct of the Repository.GetObjectByUID
type RepositoryMockGetObjectByUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetObjectByUIDParams
	paramPtrs          *RepositoryMockGetObjectByUIDParamPtrs
	expectationOrigins RepositoryMockGetObjectByUIDExpectationOrigins
	results            *RepositoryMockGetObjectByUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetObjectByUIDParams contains parameters of the Repository.GetObjectByUID
type RepositoryMockGetObjectByUIDParams struct {
	ctx context.Context
	uid types.ObjectUIDType
}

// RepositoryMockGetObjectByUIDParamPtrs contains pointers to parameters of the Repository.GetObjectByUID
type RepositoryMockGetObjectByUIDParamPtrs struct {
	ctx *context.Context
	uid *types.ObjectUIDType
}

// RepositoryMockGetObjectByUIDResults contains results of the Repository.GetObjectByUID
type RepositoryMockGetObjectByUIDResults struct {
	op1 *mm_repository.ObjectModel
	err error
}

// RepositoryMockGetObjectByUIDOrigins contains origins of expectations of the Repository.GetObjectByUID
type RepositoryMockGetObjectByUIDExpectationOrigins struct {
	origin    string
	originCtx string
	originUid string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetObjectByUID *mRepositoryMockGetObjectByUID) Optional() *mRepositoryMockGetObjectByUID {
	mmGetObjectByUID.optional = true
	return mmGetObjectByUID
}

// Expect sets up expected params for Repository.GetObjectByUID
func (mmGetObjectByUID *mRepositoryMockGetObjectByUID) Expect(ctx context.Context, uid types.ObjectUIDType) *mRepositoryMockGetObjectByUID {
	if mmGetObjectByUID.mock.funcGetObjectByUID != nil {
		mmGetObjectByUID.mock.t.Fatalf("RepositoryMock.GetObjectByUID mock is already set by Set")
	}

	if mmGetObjectByUID.defaultExpectation == nil {
		mmGetObjectByUID.defaultExpectation = &RepositoryMockGetObjectByUIDExpectation{}
	}

	if mmGetObjectByUID.defaultExpectation.paramPtrs != nil {
		mmGetObjectByUID.mock.t.Fatalf("RepositoryMock.GetObjectByUID mock is already set by ExpectParams functions")
	}

	mmGetObjectByUID.defaultExpectation.params = &RepositoryMockGetObjectByUIDParams{ctx, uid}
	mmGetObjectByUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetObjectByUID.expectations {
		if minimock.Equal(e.params, mmGetObjectByUID.defaultExpectation.params) {
			mmGetObjectByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetObjectByUID.defaultExpectation.params)
		}
	}

	return mmGetObjectByUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetObjectByUID
func (mmGetObjectByUID *mRepositoryMockGetObjectByUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetObjectByUID {
	if mmGetObjectByUID.mock.funcGetObjectByUID != nil {
		mmGetObjectByUID.mock.t.Fatalf("RepositoryMock.GetObjectByUID mock is already set by Set")
	}

	if mmGetObjectByUID.defaultExpectation == nil {
		mmGetObjectByUID.defaultExpectation = &RepositoryMockGetObjectByUIDExpectation{}
	}

	if mmGetObjectByUID.defaultExpectation.params != nil {
		mmGetObjectByUID.mock.t.Fatalf("RepositoryMock.GetObjectByUID mock is already set by Expect")
	}

	if mmGetObjectByUID.defaultExpectation.paramPtrs == nil {
		mmGetObjectByUID.defaultExpectation.paramPtrs = &RepositoryMockGetObjectByUIDParamPtrs{}
	}
	mmGetObjectByUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetObjectByUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetObjectByUID
}

// ExpectUidParam2 sets up expected param uid for Repository.GetObjectByUID
func (mmGetObjectByUID *mRepositoryMockGetObjectByUID) ExpectUidParam2(uid types.ObjectUIDType) *mRepositoryMockGetObjectByUID {
	if mmGetObjectByUID.mock.funcGetObjectByUID != nil {
		mmGetObjectByUID.mock.t.Fatalf("RepositoryMock.GetObjectByUID mock is already set by Set")
	}

	if mmGetObjectByUID.defaultExpectation == nil {
		mmGetObjectByUID.defaultExpectation = &RepositoryMockGetObjectByUIDExpectation{}
	}

	if mmGetObjectByUID.defaultExpectation.params != nil {
		mmGetObjectByUID.mock.t.Fatalf("RepositoryMock.GetObjectByUID mock is already set by Expect")
	}

	if mmGetObjectByUID.defaultExpectation.paramPtrs == nil {
		mmGetObjectByUID.defaultExpectation.paramPtrs = &RepositoryMockGetObjectByUIDParamPtrs{}
	}
	mmGetObjectByUID.defaultExpectation.paramPtrs.uid = &uid
	mmGetObjectByUID.defaultExpectation.expectationOrigins.originUid = minimock.CallerInfo(1)

	return mmGetObjectByUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetObjectByUID
func (mmGetObjectByUID *mRepositoryMockGetObjectByUID) Inspect(f func(ctx context.Context, uid types.ObjectUIDType)) *mRepositoryMockGetObjectByUID {
	if mmGetObjectByUID.mock.inspectFuncGetObjectByUID != nil {
		mmGetObjectByUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetObjectByUID")
	}

	mmGetObjectByUID.mock.inspectFuncGetObjectByUID = f

	return mmGetObjectByUID
}

// Return sets up results that will be returned by Repository.GetObjectByUID
func (mmGetObjectByUID *mRepositoryMockGetObjectByUID) Return(op1 *mm_repository.ObjectModel, err error) *RepositoryMock {
	if mmGetObjectByUID.mock.funcGetObjectByUID != nil {
		mmGetObjectByUID.mock.t.Fatalf("RepositoryMock.GetObjectByUID mock is already set by Set")
	}

	if mmGetObjectByUID.defaultExpectation == nil {
		mmGetObjectByUID.defaultExpectation = &RepositoryMockGetObjectByUIDExpectation{mock: mmGetObjectByUID.mock}
	}
	mmGetObjectByUID.defaultExpectation.results = &RepositoryMockGetObjectByUIDResults{op1, err}
	mmGetObjectByUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetObjectByUID.mock
}

// Set uses given function f to mock the Repository.GetObjectByUID method
func (mmGetObjectByUID *mRepositoryMockGetObjectByUID) Set(f func(ctx context.Context, uid types.ObjectUIDType) (op1 *mm_repository.ObjectModel, err error)) *RepositoryMock {
	if mmGetObjectByUID.defaultExpectation != nil {
		mmGetObjectByUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetObjectByUID method")
	}

	if len(mmGetObjectByUID.expectations) > 0 {
		mmGetObjectByUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetObjectByUID method")
	}

	mmGetObjectByUID.mock.funcGetObjectByUID = f
	mmGetObjectByUID.mock.funcGetObjectByUIDOrigin = minimock.CallerInfo(1)
	return mmGetObjectByUID.mock
}

// When sets expectation for the Repository.GetObjectByUID which will trigger the result defined by the following
// Then helper
func (mmGetObjectByUID *mRepositoryMockGetObjectByUID) When(ctx context.Context, uid types.ObjectUIDType) *RepositoryMockGetObjectByUIDExpectation {
	if mmGetObjectByUID.mock.funcGetObjectByUID != nil {
		mmGetObjectByUID.mock.t.Fatalf("RepositoryMock.GetObjectByUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetObjectByUIDExpectation{
		mock:               mmGetObjectByUID.mock,
		params:             &RepositoryMockGetObjectByUIDParams{ctx, uid},
		expectationOrigins: RepositoryMockGetObjectByUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetObjectByUID.expectations = append(mmGetObjectByUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetObjectByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetObjectByUIDExpectation) Then(op1 *mm_repository.ObjectModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetObjectByUIDResults{op1, err}
	return e.mock
}

// Times sets number of times Repository.GetObjectByUID should be invoked
func (mmGetObjectByUID *mRepositoryMockGetObjectByUID) Times(n uint64) *mRepositoryMockGetObjectByUID {
	if n == 0 {
		mmGetObjectByUID.mock.t.Fatalf("Times of RepositoryMock.GetObjectByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetObjectByUID.expectedInvocations, n)
	mmGetObjectByUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetObjectByUID
}

func (mmGetObjectByUID *mRepositoryMockGetObjectByUID) invocationsDone() bool {
	if len(mmGetObjectByUID.expectations) == 0 && mmGetObjectByUID.defaultExpectation == nil && mmGetObjectByUID.mock.funcGetObjectByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetObjectByUID.mock.afterGetObjectByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetObjectByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetObjectByUID implements mm_repository.Repository
func (mmGetObjectByUID *RepositoryMock) GetObjectByUID(ctx context.Context, uid types.ObjectUIDType) (op1 *mm_repository.ObjectModel, err error) {
	mm_atomic.AddUint64(&mmGetObjectByUID.beforeGetObjectByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetObjectByUID.afterGetObjectByUIDCounter, 1)

	mmGetObjectByUID.t.Helper()

	if mmGetObjectByUID.inspectFuncGetObjectByUID != nil {
		mmGetObjectByUID.inspectFuncGetObjectByUID(ctx, uid)
	}

	mm_params := RepositoryMockGetObjectByUIDParams{ctx, uid}

	// Record call args
	mmGetObjectByUID.GetObjectByUIDMock.mutex.Lock()
	mmGetObjectByUID.GetObjectByUIDMock.callArgs = append(mmGetObjectByUID.GetObjectByUIDMock.callArgs, &mm_params)
	mmGetObjectByUID.GetObjectByUIDMock.mutex.Unlock()

	for _, e := range mmGetObjectByUID.GetObjectByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetObjectByUID.GetObjectByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetObjectByUID.GetObjectByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetObjectByUID.GetObjectByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetObjectByUID.GetObjectByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetObjectByUIDParams{ctx, uid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetObjectByUID.t.Errorf("RepositoryMock.GetObjectByUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectByUID.GetObjectByUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmGetObjectByUID.t.Errorf("RepositoryMock.GetObjectByUID got unexpected parameter uid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectByUID.GetObjectByUIDMock.defaultExpectation.expectationOrigins.originUid, *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetObjectByUID.t.Errorf("RepositoryMock.GetObjectByUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetObjectByUID.GetObjectByUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetObjectByUID.GetObjectByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetObjectByUID.t.Fatal("No results are set for the RepositoryMock.GetObjectByUID")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetObjectByUID.funcGetObjectByUID != nil {
		return mmGetObjectByUID.funcGetObjectByUID(ctx, uid)
	}
	mmGetObjectByUID.t.Fatalf("Unexpected call to RepositoryMock.GetObjectByUID. %v %v", ctx, uid)
	return
}

// GetObjectByUIDAfterCounter returns a count of finished RepositoryMock.GetObjectByUID invocations
func (mmGetObjectByUID *RepositoryMock) GetObjectByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectByUID.afterGetObjectByUIDCounter)
}

// GetObjectByUIDBeforeCounter returns a count of RepositoryMock.GetObjectByUID invocations
func (mmGetObjectByUID *RepositoryMock) GetObjectByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectByUID.beforeGetObjectByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetObjectByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetObjectByUID *mRepositoryMockGetObjectByUID) Calls() []*RepositoryMockGetObjectByUIDParams {
	mmGetObjectByUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetObjectByUIDParams, len(mmGetObjectByUID.callArgs))
	copy(argCopy, mmGetObjectByUID.callArgs)

	mmGetObjectByUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetObjectByUIDDone returns true if the count of the GetObjectByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetObjectByUIDDone() bool {
	if m.GetObjectByUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetObjectByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetObjectByUIDMock.invocationsDone()
}

// MinimockGetObjectByUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetObjectByUIDInspect() {
	for _, e := range m.GetObjectByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetObjectByUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetObjectByUIDCounter := mm_atomic.LoadUint64(&m.afterGetObjectByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetObjectByUIDMock.defaultExpectation != nil && afterGetObjectByUIDCounter < 1 {
		if m.GetObjectByUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetObjectByUID at\n%s", m.GetObjectByUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetObjectByUID at\n%s with params: %#v", m.GetObjectByUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetObjectByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetObjectByUID != nil && afterGetObjectByUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetObjectByUID at\n%s", m.funcGetObjectByUIDOrigin)
	}

	if !m.GetObjectByUIDMock.invocationsDone() && afterGetObjectByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetObjectByUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetObjectByUIDMock.expectedInvocations), m.GetObjectByUIDMock.expectedInvocationsOrigin, afterGetObjectByUIDCounter)
	}
}

type mRepositoryMockGetObjectDownloadURL struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetObjectDownloadURLExpectation
	expectations       []*RepositoryMockGetObjectDownloadURLExpectation

	callArgs []*RepositoryMockGetObjectDownloadURLParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetObjectDownloadURLExpectation specifies expectation struct of the Repository.GetObjectDownloadURL
type RepositoryMockGetObjectDownloadURLExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetObjectDownloadURLParams
	paramPtrs          *RepositoryMockGetObjectDownloadURLParamPtrs
	expectationOrigins RepositoryMockGetObjectDownloadURLExpectationOrigins
	results            *RepositoryMockGetObjectDownloadURLResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetObjectDownloadURLParams contains parameters of the Repository.GetObjectDownloadURL
type RepositoryMockGetObjectDownloadURLParams struct {
	ctx       context.Context
	objectUID types.ObjectUIDType
}

// RepositoryMockGetObjectDownloadURLParamPtrs contains pointers to parameters of the Repository.GetObjectDownloadURL
type RepositoryMockGetObjectDownloadURLParamPtrs struct {
	ctx       *context.Context
	objectUID *types.ObjectUIDType
}

// RepositoryMockGetObjectDownloadURLResults contains results of the Repository.GetObjectDownloadURL
type RepositoryMockGetObjectDownloadURLResults struct {
	op1 *mm_repository.ObjectURLModel
	err error
}

// RepositoryMockGetObjectDownloadURLOrigins contains origins of expectations of the Repository.GetObjectDownloadURL
type RepositoryMockGetObjectDownloadURLExpectationOrigins struct {
	origin          string
	originCtx       string
	originObjectUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetObjectDownloadURL *mRepositoryMockGetObjectDownloadURL) Optional() *mRepositoryMockGetObjectDownloadURL {
	mmGetObjectDownloadURL.optional = true
	return mmGetObjectDownloadURL
}

// Expect sets up expected params for Repository.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mRepositoryMockGetObjectDownloadURL) Expect(ctx context.Context, objectUID types.ObjectUIDType) *mRepositoryMockGetObjectDownloadURL {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("RepositoryMock.GetObjectDownloadURL mock is already set by Set")
	}

	if mmGetObjectDownloadURL.defaultExpectation == nil {
		mmGetObjectDownloadURL.defaultExpectation = &RepositoryMockGetObjectDownloadURLExpectation{}
	}

	if mmGetObjectDownloadURL.defaultExpectation.paramPtrs != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("RepositoryMock.GetObjectDownloadURL mock is already set by ExpectParams functions")
	}

	mmGetObjectDownloadURL.defaultExpectation.params = &RepositoryMockGetObjectDownloadURLParams{ctx, objectUID}
	mmGetObjectDownloadURL.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetObjectDownloadURL.expectations {
		if minimock.Equal(e.params, mmGetObjectDownloadURL.defaultExpectation.params) {
			mmGetObjectDownloadURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetObjectDownloadURL.defaultExpectation.params)
		}
	}

	return mmGetObjectDownloadURL
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mRepositoryMockGetObjectDownloadURL) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetObjectDownloadURL {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("RepositoryMock.GetObjectDownloadURL mock is already set by Set")
	}

	if mmGetObjectDownloadURL.defaultExpectation == nil {
		mmGetObjectDownloadURL.defaultExpectation = &RepositoryMockGetObjectDownloadURLExpectation{}
	}

	if mmGetObjectDownloadURL.defaultExpectation.params != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("RepositoryMock.GetObjectDownloadURL mock is already set by Expect")
	}

	if mmGetObjectDownloadURL.defaultExpectation.paramPtrs == nil {
		mmGetObjectDownloadURL.defaultExpectation.paramPtrs = &RepositoryMockGetObjectDownloadURLParamPtrs{}
	}
	mmGetObjectDownloadURL.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetObjectDownloadURL.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetObjectDownloadURL
}

// ExpectObjectUIDParam2 sets up expected param objectUID for Repository.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mRepositoryMockGetObjectDownloadURL) ExpectObjectUIDParam2(objectUID types.ObjectUIDType) *mRepositoryMockGetObjectDownloadURL {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("RepositoryMock.GetObjectDownloadURL mock is already set by Set")
	}

	if mmGetObjectDownloadURL.defaultExpectation == nil {
		mmGetObjectDownloadURL.defaultExpectation = &RepositoryMockGetObjectDownloadURLExpectation{}
	}

	if mmGetObjectDownloadURL.defaultExpectation.params != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("RepositoryMock.GetObjectDownloadURL mock is already set by Expect")
	}

	if mmGetObjectDownloadURL.defaultExpectation.paramPtrs == nil {
		mmGetObjectDownloadURL.defaultExpectation.paramPtrs = &RepositoryMockGetObjectDownloadURLParamPtrs{}
	}
	mmGetObjectDownloadURL.defaultExpectation.paramPtrs.objectUID = &objectUID
	mmGetObjectDownloadURL.defaultExpectation.expectationOrigins.originObjectUID = minimock.CallerInfo(1)

	return mmGetObjectDownloadURL
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mRepositoryMockGetObjectDownloadURL) Inspect(f func(ctx context.Context, objectUID types.ObjectUIDType)) *mRepositoryMockGetObjectDownloadURL {
	if mmGetObjectDownloadURL.mock.inspectFuncGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetObjectDownloadURL")
	}

	mmGetObjectDownloadURL.mock.inspectFuncGetObjectDownloadURL = f

	return mmGetObjectDownloadURL
}

// Return sets up results that will be returned by Repository.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mRepositoryMockGetObjectDownloadURL) Return(op1 *mm_repository.ObjectURLModel, err error) *RepositoryMock {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("RepositoryMock.GetObjectDownloadURL mock is already set by Set")
	}

	if mmGetObjectDownloadURL.defaultExpectation == nil {
		mmGetObjectDownloadURL.defaultExpectation = &RepositoryMockGetObjectDownloadURLExpectation{mock: mmGetObjectDownloadURL.mock}
	}
	mmGetObjectDownloadURL.defaultExpectation.results = &RepositoryMockGetObjectDownloadURLResults{op1, err}
	mmGetObjectDownloadURL.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetObjectDownloadURL.mock
}

// Set uses given function f to mock the Repository.GetObjectDownloadURL method
func (mmGetObjectDownloadURL *mRepositoryMockGetObjectDownloadURL) Set(f func(ctx context.Context, objectUID types.ObjectUIDType) (op1 *mm_repository.ObjectURLModel, err error)) *RepositoryMock {
	if mmGetObjectDownloadURL.defaultExpectation != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("Default expectation is already set for the Repository.GetObjectDownloadURL method")
	}

	if len(mmGetObjectDownloadURL.expectations) > 0 {
		mmGetObjectDownloadURL.mock.t.Fatalf("Some expectations are already set for the Repository.GetObjectDownloadURL method")
	}

	mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL = f
	mmGetObjectDownloadURL.mock.funcGetObjectDownloadURLOrigin = minimock.CallerInfo(1)
	return mmGetObjectDownloadURL.mock
}

// When sets expectation for the Repository.GetObjectDownloadURL which will trigger the result defined by the following
// Then helper
func (mmGetObjectDownloadURL *mRepositoryMockGetObjectDownloadURL) When(ctx context.Context, objectUID types.ObjectUIDType) *RepositoryMockGetObjectDownloadURLExpectation {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("RepositoryMock.GetObjectDownloadURL mock is already set by Set")
	}

	expectation := &RepositoryMockGetObjectDownloadURLExpectation{
		mock:               mmGetObjectDownloadURL.mock,
		params:             &RepositoryMockGetObjectDownloadURLParams{ctx, objectUID},
		expectationOrigins: RepositoryMockGetObjectDownloadURLExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetObjectDownloadURL.expectations = append(mmGetObjectDownloadURL.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetObjectDownloadURL return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetObjectDownloadURLExpectation) Then(op1 *mm_repository.ObjectURLModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetObjectDownloadURLResults{op1, err}
	return e.mock
}

// Times sets number of times Repository.GetObjectDownloadURL should be invoked
func (mmGetObjectDownloadURL *mRepositoryMockGetObjectDownloadURL) Times(n uint64) *mRepositoryMockGetObjectDownloadURL {
	if n == 0 {
		mmGetObjectDownloadURL.mock.t.Fatalf("Times of RepositoryMock.GetObjectDownloadURL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetObjectDownloadURL.expectedInvocations, n)
	mmGetObjectDownloadURL.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetObjectDownloadURL
}

func (mmGetObjectDownloadURL *mRepositoryMockGetObjectDownloadURL) invocationsDone() bool {
	if len(mmGetObjectDownloadURL.expectations) == 0 && mmGetObjectDownloadURL.defaultExpectation == nil && mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetObjectDownloadURL.mock.afterGetObjectDownloadURLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetObjectDownloadURL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetObjectDownloadURL implements mm_repository.Repository
func (mmGetObjectDownloadURL *RepositoryMock) GetObjectDownloadURL(ctx context.Context, objectUID types.ObjectUIDType) (op1 *mm_repository.ObjectURLModel, err error) {
	mm_atomic.AddUint64(&mmGetObjectDownloadURL.beforeGetObjectDownloadURLCounter, 1)
	defer mm_atomic.AddUint64(&mmGetObjectDownloadURL.afterGetObjectDownloadURLCounter, 1)

	mmGetObjectDownloadURL.t.Helper()

	if mmGetObjectDownloadURL.inspectFuncGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.inspectFuncGetObjectDownloadURL(ctx, objectUID)
	}

	mm_params := RepositoryMockGetObjectDownloadURLParams{ctx, objectUID}

	// Record call args
	mmGetObjectDownloadURL.GetObjectDownloadURLMock.mutex.Lock()
	mmGetObjectDownloadURL.GetObjectDownloadURLMock.callArgs = append(mmGetObjectDownloadURL.GetObjectDownloadURLMock.callArgs, &mm_params)
	mmGetObjectDownloadURL.GetObjectDownloadURLMock.mutex.Unlock()

	for _, e := range mmGetObjectDownloadURL.GetObjectDownloadURLMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.Counter, 1)
		mm_want := mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.params
		mm_want_ptrs := mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetObjectDownloadURLParams{ctx, objectUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetObjectDownloadURL.t.Errorf("RepositoryMock.GetObjectDownloadURL got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmGetObjectDownloadURL.t.Errorf("RepositoryMock.GetObjectDownloadURL got unexpected parameter objectUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.expectationOrigins.originObjectUID, *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetObjectDownloadURL.t.Errorf("RepositoryMock.GetObjectDownloadURL got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.results
		if mm_results == nil {
			mmGetObjectDownloadURL.t.Fatal("No results are set for the RepositoryMock.GetObjectDownloadURL")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetObjectDownloadURL.funcGetObjectDownloadURL != nil {
		return mmGetObjectDownloadURL.funcGetObjectDownloadURL(ctx, objectUID)
	}
	mmGetObjectDownloadURL.t.Fatalf("Unexpected call to RepositoryMock.GetObjectDownloadURL. %v %v", ctx, objectUID)
	return
}

// GetObjectDownloadURLAfterCounter returns a count of finished RepositoryMock.GetObjectDownloadURL invocations
func (mmGetObjectDownloadURL *RepositoryMock) GetObjectDownloadURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectDownloadURL.afterGetObjectDownloadURLCounter)
}

// GetObjectDownloadURLBeforeCounter returns a count of RepositoryMock.GetObjectDownloadURL invocations
func (mmGetObjectDownloadURL *RepositoryMock) GetObjectDownloadURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectDownloadURL.beforeGetObjectDownloadURLCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetObjectDownloadURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetObjectDownloadURL *mRepositoryMockGetObjectDownloadURL) Calls() []*RepositoryMockGetObjectDownloadURLParams {
	mmGetObjectDownloadURL.mutex.RLock()

	argCopy := make([]*RepositoryMockGetObjectDownloadURLParams, len(mmGetObjectDownloadURL.callArgs))
	copy(argCopy, mmGetObjectDownloadURL.callArgs)

	mmGetObjectDownloadURL.mutex.RUnlock()

	return argCopy
}

// MinimockGetObjectDownloadURLDone returns true if the count of the GetObjectDownloadURL invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetObjectDownloadURLDone() bool {
	if m.GetObjectDownloadURLMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetObjectDownloadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetObjectDownloadURLMock.invocationsDone()
}

// MinimockGetObjectDownloadURLInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetObjectDownloadURLInspect() {
	for _, e := range m.GetObjectDownloadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetObjectDownloadURL at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetObjectDownloadURLCounter := mm_atomic.LoadUint64(&m.afterGetObjectDownloadURLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetObjectDownloadURLMock.defaultExpectation != nil && afterGetObjectDownloadURLCounter < 1 {
		if m.GetObjectDownloadURLMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetObjectDownloadURL at\n%s", m.GetObjectDownloadURLMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetObjectDownloadURL at\n%s with params: %#v", m.GetObjectDownloadURLMock.defaultExpectation.expectationOrigins.origin, *m.GetObjectDownloadURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetObjectDownloadURL != nil && afterGetObjectDownloadURLCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetObjectDownloadURL at\n%s", m.funcGetObjectDownloadURLOrigin)
	}

	if !m.GetObjectDownloadURLMock.invocationsDone() && afterGetObjectDownloadURLCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetObjectDownloadURL at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetObjectDownloadURLMock.expectedInvocations), m.GetObjectDownloadURLMock.expectedInvocationsOrigin, afterGetObjectDownloadURLCounter)
	}
}

type mRepositoryMockGetObjectURLByEncodedURLPath struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetObjectURLByEncodedURLPathExpectation
	expectations       []*RepositoryMockGetObjectURLByEncodedURLPathExpectation

	callArgs []*RepositoryMockGetObjectURLByEncodedURLPathParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetObjectURLByEncodedURLPathExpectation specifies expectation struct of the Repository.GetObjectURLByEncodedURLPath
type RepositoryMockGetObjectURLByEncodedURLPathExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetObjectURLByEncodedURLPathParams
	paramPtrs          *RepositoryMockGetObjectURLByEncodedURLPathParamPtrs
	expectationOrigins RepositoryMockGetObjectURLByEncodedURLPathExpectationOrigins
	results            *RepositoryMockGetObjectURLByEncodedURLPathResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetObjectURLByEncodedURLPathParams contains parameters of the Repository.GetObjectURLByEncodedURLPath
type RepositoryMockGetObjectURLByEncodedURLPathParams struct {
	ctx            context.Context
	encodedURLPath string
}

// RepositoryMockGetObjectURLByEncodedURLPathParamPtrs contains pointers to parameters of the Repository.GetObjectURLByEncodedURLPath
type RepositoryMockGetObjectURLByEncodedURLPathParamPtrs struct {
	ctx            *context.Context
	encodedURLPath *string
}

// RepositoryMockGetObjectURLByEncodedURLPathResults contains results of the Repository.GetObjectURLByEncodedURLPath
type RepositoryMockGetObjectURLByEncodedURLPathResults struct {
	op1 *mm_repository.ObjectURLModel
	err error
}

// RepositoryMockGetObjectURLByEncodedURLPathOrigins contains origins of expectations of the Repository.GetObjectURLByEncodedURLPath
type RepositoryMockGetObjectURLByEncodedURLPathExpectationOrigins struct {
	origin               string
	originCtx            string
	originEncodedURLPath string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetObjectURLByEncodedURLPath *mRepositoryMockGetObjectURLByEncodedURLPath) Optional() *mRepositoryMockGetObjectURLByEncodedURLPath {
	mmGetObjectURLByEncodedURLPath.optional = true
	return mmGetObjectURLByEncodedURLPath
}

// Expect sets up expected params for Repository.GetObjectURLByEncodedURLPath
func (mmGetObjectURLByEncodedURLPath *mRepositoryMockGetObjectURLByEncodedURLPath) Expect(ctx context.Context, encodedURLPath string) *mRepositoryMockGetObjectURLByEncodedURLPath {
	if mmGetObjectURLByEncodedURLPath.mock.funcGetObjectURLByEncodedURLPath != nil {
		mmGetObjectURLByEncodedURLPath.mock.t.Fatalf("RepositoryMock.GetObjectURLByEncodedURLPath mock is already set by Set")
	}

	if mmGetObjectURLByEncodedURLPath.defaultExpectation == nil {
		mmGetObjectURLByEncodedURLPath.defaultExpectation = &RepositoryMockGetObjectURLByEncodedURLPathExpectation{}
	}

	if mmGetObjectURLByEncodedURLPath.defaultExpectation.paramPtrs != nil {
		mmGetObjectURLByEncodedURLPath.mock.t.Fatalf("RepositoryMock.GetObjectURLByEncodedURLPath mock is already set by ExpectParams functions")
	}

	mmGetObjectURLByEncodedURLPath.defaultExpectation.params = &RepositoryMockGetObjectURLByEncodedURLPathParams{ctx, encodedURLPath}
	mmGetObjectURLByEncodedURLPath.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetObjectURLByEncodedURLPath.expectations {
		if minimock.Equal(e.params, mmGetObjectURLByEncodedURLPath.defaultExpectation.params) {
			mmGetObjectURLByEncodedURLPath.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetObjectURLByEncodedURLPath.defaultExpectation.params)
		}
	}

	return mmGetObjectURLByEncodedURLPath
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetObjectURLByEncodedURLPath
func (mmGetObjectURLByEncodedURLPath *mRepositoryMockGetObjectURLByEncodedURLPath) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetObjectURLByEncodedURLPath {
	if mmGetObjectURLByEncodedURLPath.mock.funcGetObjectURLByEncodedURLPath != nil {
		mmGetObjectURLByEncodedURLPath.mock.t.Fatalf("RepositoryMock.GetObjectURLByEncodedURLPath mock is already set by Set")
	}

	if mmGetObjectURLByEncodedURLPath.defaultExpectation == nil {
		mmGetObjectURLByEncodedURLPath.defaultExpectation = &RepositoryMockGetObjectURLByEncodedURLPathExpectation{}
	}

	if mmGetObjectURLByEncodedURLPath.defaultExpectation.params != nil {
		mmGetObjectURLByEncodedURLPath.mock.t.Fatalf("RepositoryMock.GetObjectURLByEncodedURLPath mock is already set by Expect")
	}

	if mmGetObjectURLByEncodedURLPath.defaultExpectation.paramPtrs == nil {
		mmGetObjectURLByEncodedURLPath.defaultExpectation.paramPtrs = &RepositoryMockGetObjectURLByEncodedURLPathParamPtrs{}
	}
	mmGetObjectURLByEncodedURLPath.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetObjectURLByEncodedURLPath.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetObjectURLByEncodedURLPath
}

// ExpectEncodedURLPathParam2 sets up expected param encodedURLPath for Repository.GetObjectURLByEncodedURLPath
func (mmGetObjectURLByEncodedURLPath *mRepositoryMockGetObjectURLByEncodedURLPath) ExpectEncodedURLPathParam2(encodedURLPath string) *mRepositoryMockGetObjectURLByEncodedURLPath {
	if mmGetObjectURLByEncodedURLPath.mock.funcGetObjectURLByEncodedURLPath != nil {
		mmGetObjectURLByEncodedURLPath.mock.t.Fatalf("RepositoryMock.GetObjectURLByEncodedURLPath mock is already set by Set")
	}

	if mmGetObjectURLByEncodedURLPath.defaultExpectation == nil {
		mmGetObjectURLByEncodedURLPath.defaultExpectation = &RepositoryMockGetObjectURLByEncodedURLPathExpectation{}
	}

	if mmGetObjectURLByEncodedURLPath.defaultExpectation.params != nil {
		mmGetObjectURLByEncodedURLPath.mock.t.Fatalf("RepositoryMock.GetObjectURLByEncodedURLPath mock is already set by Expect")
	}

	if mmGetObjectURLByEncodedURLPath.defaultExpectation.paramPtrs == nil {
		mmGetObjectURLByEncodedURLPath.defaultExpectation.paramPtrs = &RepositoryMockGetObjectURLByEncodedURLPathParamPtrs{}
	}
	mmGetObjectURLByEncodedURLPath.defaultExpectation.paramPtrs.encodedURLPath = &encodedURLPath
	mmGetObjectURLByEncodedURLPath.defaultExpectation.expectationOrigins.originEncodedURLPath = minimock.CallerInfo(1)

	return mmGetObjectURLByEncodedURLPath
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetObjectURLByEncodedURLPath
func (mmGetObjectURLByEncodedURLPath *mRepositoryMockGetObjectURLByEncodedURLPath) Inspect(f func(ctx context.Context, encodedURLPath string)) *mRepositoryMockGetObjectURLByEncodedURLPath {
	if mmGetObjectURLByEncodedURLPath.mock.inspectFuncGetObjectURLByEncodedURLPath != nil {
		mmGetObjectURLByEncodedURLPath.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetObjectURLByEncodedURLPath")
	}

	mmGetObjectURLByEncodedURLPath.mock.inspectFuncGetObjectURLByEncodedURLPath = f

	return mmGetObjectURLByEncodedURLPath
}

// Return sets up results that will be returned by Repository.GetObjectURLByEncodedURLPath
func (mmGetObjectURLByEncodedURLPath *mRepositoryMockGetObjectURLByEncodedURLPath) Return(op1 *mm_repository.ObjectURLModel, err error) *RepositoryMock {
	if mmGetObjectURLByEncodedURLPath.mock.funcGetObjectURLByEncodedURLPath != nil {
		mmGetObjectURLByEncodedURLPath.mock.t.Fatalf("RepositoryMock.GetObjectURLByEncodedURLPath mock is already set by Set")
	}

	if mmGetObjectURLByEncodedURLPath.defaultExpectation == nil {
		mmGetObjectURLByEncodedURLPath.defaultExpectation = &RepositoryMockGetObjectURLByEncodedURLPathExpectation{mock: mmGetObjectURLByEncodedURLPath.mock}
	}
	mmGetObjectURLByEncodedURLPath.defaultExpectation.results = &RepositoryMockGetObjectURLByEncodedURLPathResults{op1, err}
	mmGetObjectURLByEncodedURLPath.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetObjectURLByEncodedURLPath.mock
}

// Set uses given function f to mock the Repository.GetObjectURLByEncodedURLPath method
func (mmGetObjectURLByEncodedURLPath *mRepositoryMockGetObjectURLByEncodedURLPath) Set(f func(ctx context.Context, encodedURLPath string) (op1 *mm_repository.ObjectURLModel, err error)) *RepositoryMock {
	if mmGetObjectURLByEncodedURLPath.defaultExpectation != nil {
		mmGetObjectURLByEncodedURLPath.mock.t.Fatalf("Default expectation is already set for the Repository.GetObjectURLByEncodedURLPath method")
	}

	if len(mmGetObjectURLByEncodedURLPath.expectations) > 0 {
		mmGetObjectURLByEncodedURLPath.mock.t.Fatalf("Some expectations are already set for the Repository.GetObjectURLByEncodedURLPath method")
	}

	mmGetObjectURLByEncodedURLPath.mock.funcGetObjectURLByEncodedURLPath = f
	mmGetObjectURLByEncodedURLPath.mock.funcGetObjectURLByEncodedURLPathOrigin = minimock.CallerInfo(1)
	return mmGetObjectURLByEncodedURLPath.mock
}

// When sets expectation for the Repository.GetObjectURLByEncodedURLPath which will trigger the result defined by the following
// Then helper
func (mmGetObjectURLByEncodedURLPath *mRepositoryMockGetObjectURLByEncodedURLPath) When(ctx context.Context, encodedURLPath string) *RepositoryMockGetObjectURLByEncodedURLPathExpectation {
	if mmGetObjectURLByEncodedURLPath.mock.funcGetObjectURLByEncodedURLPath != nil {
		mmGetObjectURLByEncodedURLPath.mock.t.Fatalf("RepositoryMock.GetObjectURLByEncodedURLPath mock is already set by Set")
	}

	expectation := &RepositoryMockGetObjectURLByEncodedURLPathExpectation{
		mock:               mmGetObjectURLByEncodedURLPath.mock,
		params:             &RepositoryMockGetObjectURLByEncodedURLPathParams{ctx, encodedURLPath},
		expectationOrigins: RepositoryMockGetObjectURLByEncodedURLPathExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetObjectURLByEncodedURLPath.expectations = append(mmGetObjectURLByEncodedURLPath.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetObjectURLByEncodedURLPath return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetObjectURLByEncodedURLPathExpectation) Then(op1 *mm_repository.ObjectURLModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetObjectURLByEncodedURLPathResults{op1, err}
	return e.mock
}

// Times sets number of times Repository.GetObjectURLByEncodedURLPath should be invoked
func (mmGetObjectURLByEncodedURLPath *mRepositoryMockGetObjectURLByEncodedURLPath) Times(n uint64) *mRepositoryMockGetObjectURLByEncodedURLPath {
	if n == 0 {
		mmGetObjectURLByEncodedURLPath.mock.t.Fatalf("Times of RepositoryMock.GetObjectURLByEncodedURLPath mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetObjectURLByEncodedURLPath.expectedInvocations, n)
	mmGetObjectURLByEncodedURLPath.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetObjectURLByEncodedURLPath
}

func (mmGetObjectURLByEncodedURLPath *mRepositoryMockGetObjectURLByEncodedURLPath) invocationsDone() bool {
	if len(mmGetObjectURLByEncodedURLPath.expectations) == 0 && mmGetObjectURLByEncodedURLPath.defaultExpectation == nil && mmGetObjectURLByEncodedURLPath.mock.funcGetObjectURLByEncodedURLPath == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetObjectURLByEncodedURLPath.mock.afterGetObjectURLByEncodedURLPathCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetObjectURLByEncodedURLPath.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetObjectURLByEncodedURLPath implements mm_repository.Repository
func (mmGetObjectURLByEncodedURLPath *RepositoryMock) GetObjectURLByEncodedURLPath(ctx context.Context, encodedURLPath string) (op1 *mm_repository.ObjectURLModel, err error) {
	mm_atomic.AddUint64(&mmGetObjectURLByEncodedURLPath.beforeGetObjectURLByEncodedURLPathCounter, 1)
	defer mm_atomic.AddUint64(&mmGetObjectURLByEncodedURLPath.afterGetObjectURLByEncodedURLPathCounter, 1)

	mmGetObjectURLByEncodedURLPath.t.Helper()

	if mmGetObjectURLByEncodedURLPath.inspectFuncGetObjectURLByEncodedURLPath != nil {
		mmGetObjectURLByEncodedURLPath.inspectFuncGetObjectURLByEncodedURLPath(ctx, encodedURLPath)
	}

	mm_params := RepositoryMockGetObjectURLByEncodedURLPathParams{ctx, encodedURLPath}

	// Record call args
	mmGetObjectURLByEncodedURLPath.GetObjectURLByEncodedURLPathMock.mutex.Lock()
	mmGetObjectURLByEncodedURLPath.GetObjectURLByEncodedURLPathMock.callArgs = append(mmGetObjectURLByEncodedURLPath.GetObjectURLByEncodedURLPathMock.callArgs, &mm_params)
	mmGetObjectURLByEncodedURLPath.GetObjectURLByEncodedURLPathMock.mutex.Unlock()

	for _, e := range mmGetObjectURLByEncodedURLPath.GetObjectURLByEncodedURLPathMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetObjectURLByEncodedURLPath.GetObjectURLByEncodedURLPathMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetObjectURLByEncodedURLPath.GetObjectURLByEncodedURLPathMock.defaultExpectation.Counter, 1)
		mm_want := mmGetObjectURLByEncodedURLPath.GetObjectURLByEncodedURLPathMock.defaultExpectation.params
		mm_want_ptrs := mmGetObjectURLByEncodedURLPath.GetObjectURLByEncodedURLPathMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetObjectURLByEncodedURLPathParams{ctx, encodedURLPath}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetObjectURLByEncodedURLPath.t.Errorf("RepositoryMock.GetObjectURLByEncodedURLPath got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectURLByEncodedURLPath.GetObjectURLByEncodedURLPathMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.encodedURLPath != nil && !minimock.Equal(*mm_want_ptrs.encodedURLPath, mm_got.encodedURLPath) {
				mmGetObjectURLByEncodedURLPath.t.Errorf("RepositoryMock.GetObjectURLByEncodedURLPath got unexpected parameter encodedURLPath, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectURLByEncodedURLPath.GetObjectURLByEncodedURLPathMock.defaultExpectation.expectationOrigins.originEncodedURLPath, *mm_want_ptrs.encodedURLPath, mm_got.encodedURLPath, minimock.Diff(*mm_want_ptrs.encodedURLPath, mm_got.encodedURLPath))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetObjectURLByEncodedURLPath.t.Errorf("RepositoryMock.GetObjectURLByEncodedURLPath got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetObjectURLByEncodedURLPath.GetObjectURLByEncodedURLPathMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetObjectURLByEncodedURLPath.GetObjectURLByEncodedURLPathMock.defaultExpectation.results
		if mm_results == nil {
			mmGetObjectURLByEncodedURLPath.t.Fatal("No results are set for the RepositoryMock.GetObjectURLByEncodedURLPath")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetObjectURLByEncodedURLPath.funcGetObjectURLByEncodedURLPath != nil {
		return mmGetObjectURLByEncodedURLPath.funcGetObjectURLByEncodedURLPath(ctx, encodedURLPath)
	}
	mmGetObjectURLByEncodedURLPath.t.Fatalf("Unexpected call to RepositoryMock.GetObjectURLByEncodedURLPath. %v %v", ctx, encodedURLPath)
	return
}

// GetObjectURLByEncodedURLPathAfterCounter returns a count of finished RepositoryMock.GetObjectURLByEncodedURLPath invocations
func (mmGetObjectURLByEncodedURLPath *RepositoryMock) GetObjectURLByEncodedURLPathAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectURLByEncodedURLPath.afterGetObjectURLByEncodedURLPathCounter)
}

// GetObjectURLByEncodedURLPathBeforeCounter returns a count of RepositoryMock.GetObjectURLByEncodedURLPath invocations
func (mmGetObjectURLByEncodedURLPath *RepositoryMock) GetObjectURLByEncodedURLPathBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectURLByEncodedURLPath.beforeGetObjectURLByEncodedURLPathCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetObjectURLByEncodedURLPath.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetObjectURLByEncodedURLPath *mRepositoryMockGetObjectURLByEncodedURLPath) Calls() []*RepositoryMockGetObjectURLByEncodedURLPathParams {
	mmGetObjectURLByEncodedURLPath.mutex.RLock()

	argCopy := make([]*RepositoryMockGetObjectURLByEncodedURLPathParams, len(mmGetObjectURLByEncodedURLPath.callArgs))
	copy(argCopy, mmGetObjectURLByEncodedURLPath.callArgs)

	mmGetObjectURLByEncodedURLPath.mutex.RUnlock()

	return argCopy
}

// MinimockGetObjectURLByEncodedURLPathDone returns true if the count of the GetObjectURLByEncodedURLPath invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetObjectURLByEncodedURLPathDone() bool {
	if m.GetObjectURLByEncodedURLPathMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetObjectURLByEncodedURLPathMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetObjectURLByEncodedURLPathMock.invocationsDone()
}

// MinimockGetObjectURLByEncodedURLPathInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetObjectURLByEncodedURLPathInspect() {
	for _, e := range m.GetObjectURLByEncodedURLPathMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetObjectURLByEncodedURLPath at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetObjectURLByEncodedURLPathCounter := mm_atomic.LoadUint64(&m.afterGetObjectURLByEncodedURLPathCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetObjectURLByEncodedURLPathMock.defaultExpectation != nil && afterGetObjectURLByEncodedURLPathCounter < 1 {
		if m.GetObjectURLByEncodedURLPathMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetObjectURLByEncodedURLPath at\n%s", m.GetObjectURLByEncodedURLPathMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetObjectURLByEncodedURLPath at\n%s with params: %#v", m.GetObjectURLByEncodedURLPathMock.defaultExpectation.expectationOrigins.origin, *m.GetObjectURLByEncodedURLPathMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetObjectURLByEncodedURLPath != nil && afterGetObjectURLByEncodedURLPathCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetObjectURLByEncodedURLPath at\n%s", m.funcGetObjectURLByEncodedURLPathOrigin)
	}

	if !m.GetObjectURLByEncodedURLPathMock.invocationsDone() && afterGetObjectURLByEncodedURLPathCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetObjectURLByEncodedURLPath at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetObjectURLByEncodedURLPathMock.expectedInvocations), m.GetObjectURLByEncodedURLPathMock.expectedInvocationsOrigin, afterGetObjectURLByEncodedURLPathCounter)
	}
}

type mRepositoryMockGetObjectURLByUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetObjectURLByUIDExpectation
	expectations       []*RepositoryMockGetObjectURLByUIDExpectation

	callArgs []*RepositoryMockGetObjectURLByUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetObjectURLByUIDExpectation specifies expectation struct of the Repository.GetObjectURLByUID
type RepositoryMockGetObjectURLByUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetObjectURLByUIDParams
	paramPtrs          *RepositoryMockGetObjectURLByUIDParamPtrs
	expectationOrigins RepositoryMockGetObjectURLByUIDExpectationOrigins
	results            *RepositoryMockGetObjectURLByUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetObjectURLByUIDParams contains parameters of the Repository.GetObjectURLByUID
type RepositoryMockGetObjectURLByUIDParams struct {
	ctx context.Context
	uid types.ObjectURLUIDType
}

// RepositoryMockGetObjectURLByUIDParamPtrs contains pointers to parameters of the Repository.GetObjectURLByUID
type RepositoryMockGetObjectURLByUIDParamPtrs struct {
	ctx *context.Context
	uid *types.ObjectURLUIDType
}

// RepositoryMockGetObjectURLByUIDResults contains results of the Repository.GetObjectURLByUID
type RepositoryMockGetObjectURLByUIDResults struct {
	op1 *mm_repository.ObjectURLModel
	err error
}

// RepositoryMockGetObjectURLByUIDOrigins contains origins of expectations of the Repository.GetObjectURLByUID
type RepositoryMockGetObjectURLByUIDExpectationOrigins struct {
	origin    string
	originCtx string
	originUid string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetObjectURLByUID *mRepositoryMockGetObjectURLByUID) Optional() *mRepositoryMockGetObjectURLByUID {
	mmGetObjectURLByUID.optional = true
	return mmGetObjectURLByUID
}

// Expect sets up expected params for Repository.GetObjectURLByUID
func (mmGetObjectURLByUID *mRepositoryMockGetObjectURLByUID) Expect(ctx context.Context, uid types.ObjectURLUIDType) *mRepositoryMockGetObjectURLByUID {
	if mmGetObjectURLByUID.mock.funcGetObjectURLByUID != nil {
		mmGetObjectURLByUID.mock.t.Fatalf("RepositoryMock.GetObjectURLByUID mock is already set by Set")
	}

	if mmGetObjectURLByUID.defaultExpectation == nil {
		mmGetObjectURLByUID.defaultExpectation = &RepositoryMockGetObjectURLByUIDExpectation{}
	}

	if mmGetObjectURLByUID.defaultExpectation.paramPtrs != nil {
		mmGetObjectURLByUID.mock.t.Fatalf("RepositoryMock.GetObjectURLByUID mock is already set by ExpectParams functions")
	}

	mmGetObjectURLByUID.defaultExpectation.params = &RepositoryMockGetObjectURLByUIDParams{ctx, uid}
	mmGetObjectURLByUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetObjectURLByUID.expectations {
		if minimock.Equal(e.params, mmGetObjectURLByUID.defaultExpectation.params) {
			mmGetObjectURLByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetObjectURLByUID.defaultExpectation.params)
		}
	}

	return mmGetObjectURLByUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetObjectURLByUID
func (mmGetObjectURLByUID *mRepositoryMockGetObjectURLByUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetObjectURLByUID {
	if mmGetObjectURLByUID.mock.funcGetObjectURLByUID != nil {
		mmGetObjectURLByUID.mock.t.Fatalf("RepositoryMock.GetObjectURLByUID mock is already set by Set")
	}

	if mmGetObjectURLByUID.defaultExpectation == nil {
		mmGetObjectURLByUID.defaultExpectation = &RepositoryMockGetObjectURLByUIDExpectation{}
	}

	if mmGetObjectURLByUID.defaultExpectation.params != nil {
		mmGetObjectURLByUID.mock.t.Fatalf("RepositoryMock.GetObjectURLByUID mock is already set by Expect")
	}

	if mmGetObjectURLByUID.defaultExpectation.paramPtrs == nil {
		mmGetObjectURLByUID.defaultExpectation.paramPtrs = &RepositoryMockGetObjectURLByUIDParamPtrs{}
	}
	mmGetObjectURLByUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetObjectURLByUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetObjectURLByUID
}

// ExpectUidParam2 sets up expected param uid for Repository.GetObjectURLByUID
func (mmGetObjectURLByUID *mRepositoryMockGetObjectURLByUID) ExpectUidParam2(uid types.ObjectURLUIDType) *mRepositoryMockGetObjectURLByUID {
	if mmGetObjectURLByUID.mock.funcGetObjectURLByUID != nil {
		mmGetObjectURLByUID.mock.t.Fatalf("RepositoryMock.GetObjectURLByUID mock is already set by Set")
	}

	if mmGetObjectURLByUID.defaultExpectation == nil {
		mmGetObjectURLByUID.defaultExpectation = &RepositoryMockGetObjectURLByUIDExpectation{}
	}

	if mmGetObjectURLByUID.defaultExpectation.params != nil {
		mmGetObjectURLByUID.mock.t.Fatalf("RepositoryMock.GetObjectURLByUID mock is already set by Expect")
	}

	if mmGetObjectURLByUID.defaultExpectation.paramPtrs == nil {
		mmGetObjectURLByUID.defaultExpectation.paramPtrs = &RepositoryMockGetObjectURLByUIDParamPtrs{}
	}
	mmGetObjectURLByUID.defaultExpectation.paramPtrs.uid = &uid
	mmGetObjectURLByUID.defaultExpectation.expectationOrigins.originUid = minimock.CallerInfo(1)

	return mmGetObjectURLByUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetObjectURLByUID
func (mmGetObjectURLByUID *mRepositoryMockGetObjectURLByUID) Inspect(f func(ctx context.Context, uid types.ObjectURLUIDType)) *mRepositoryMockGetObjectURLByUID {
	if mmGetObjectURLByUID.mock.inspectFuncGetObjectURLByUID != nil {
		mmGetObjectURLByUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetObjectURLByUID")
	}

	mmGetObjectURLByUID.mock.inspectFuncGetObjectURLByUID = f

	return mmGetObjectURLByUID
}

// Return sets up results that will be returned by Repository.GetObjectURLByUID
func (mmGetObjectURLByUID *mRepositoryMockGetObjectURLByUID) Return(op1 *mm_repository.ObjectURLModel, err error) *RepositoryMock {
	if mmGetObjectURLByUID.mock.funcGetObjectURLByUID != nil {
		mmGetObjectURLByUID.mock.t.Fatalf("RepositoryMock.GetObjectURLByUID mock is already set by Set")
	}

	if mmGetObjectURLByUID.defaultExpectation == nil {
		mmGetObjectURLByUID.defaultExpectation = &RepositoryMockGetObjectURLByUIDExpectation{mock: mmGetObjectURLByUID.mock}
	}
	mmGetObjectURLByUID.defaultExpectation.results = &RepositoryMockGetObjectURLByUIDResults{op1, err}
	mmGetObjectURLByUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetObjectURLByUID.mock
}

// Set uses given function f to mock the Repository.GetObjectURLByUID method
func (mmGetObjectURLByUID *mRepositoryMockGetObjectURLByUID) Set(f func(ctx context.Context, uid types.ObjectURLUIDType) (op1 *mm_repository.ObjectURLModel, err error)) *RepositoryMock {
	if mmGetObjectURLByUID.defaultExpectation != nil {
		mmGetObjectURLByUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetObjectURLByUID method")
	}

	if len(mmGetObjectURLByUID.expectations) > 0 {
		mmGetObjectURLByUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetObjectURLByUID method")
	}

	mmGetObjectURLByUID.mock.funcGetObjectURLByUID = f
	mmGetObjectURLByUID.mock.funcGetObjectURLByUIDOrigin = minimock.CallerInfo(1)
	return mmGetObjectURLByUID.mock
}

// When sets expectation for the Repository.GetObjectURLByUID which will trigger the result defined by the following
// Then helper
func (mmGetObjectURLByUID *mRepositoryMockGetObjectURLByUID) When(ctx context.Context, uid types.ObjectURLUIDType) *RepositoryMockGetObjectURLByUIDExpectation {
	if mmGetObjectURLByUID.mock.funcGetObjectURLByUID != nil {
		mmGetObjectURLByUID.mock.t.Fatalf("RepositoryMock.GetObjectURLByUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetObjectURLByUIDExpectation{
		mock:               mmGetObjectURLByUID.mock,
		params:             &RepositoryMockGetObjectURLByUIDParams{ctx, uid},
		expectationOrigins: RepositoryMockGetObjectURLByUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetObjectURLByUID.expectations = append(mmGetObjectURLByUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetObjectURLByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetObjectURLByUIDExpectation) Then(op1 *mm_repository.ObjectURLModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetObjectURLByUIDResults{op1, err}
	return e.mock
}

// Times sets number of times Repository.GetObjectURLByUID should be invoked
func (mmGetObjectURLByUID *mRepositoryMockGetObjectURLByUID) Times(n uint64) *mRepositoryMockGetObjectURLByUID {
	if n == 0 {
		mmGetObjectURLByUID.mock.t.Fatalf("Times of RepositoryMock.GetObjectURLByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetObjectURLByUID.expectedInvocations, n)
	mmGetObjectURLByUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetObjectURLByUID
}

func (mmGetObjectURLByUID *mRepositoryMockGetObjectURLByUID) invocationsDone() bool {
	if len(mmGetObjectURLByUID.expectations) == 0 && mmGetObjectURLByUID.defaultExpectation == nil && mmGetObjectURLByUID.mock.funcGetObjectURLByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetObjectURLByUID.mock.afterGetObjectURLByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetObjectURLByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetObjectURLByUID implements mm_repository.Repository
func (mmGetObjectURLByUID *RepositoryMock) GetObjectURLByUID(ctx context.Context, uid types.ObjectURLUIDType) (op1 *mm_repository.ObjectURLModel, err error) {
	mm_atomic.AddUint64(&mmGetObjectURLByUID.beforeGetObjectURLByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetObjectURLByUID.afterGetObjectURLByUIDCounter, 1)

	mmGetObjectURLByUID.t.Helper()

	if mmGetObjectURLByUID.inspectFuncGetObjectURLByUID != nil {
		mmGetObjectURLByUID.inspectFuncGetObjectURLByUID(ctx, uid)
	}

	mm_params := RepositoryMockGetObjectURLByUIDParams{ctx, uid}

	// Record call args
	mmGetObjectURLByUID.GetObjectURLByUIDMock.mutex.Lock()
	mmGetObjectURLByUID.GetObjectURLByUIDMock.callArgs = append(mmGetObjectURLByUID.GetObjectURLByUIDMock.callArgs, &mm_params)
	mmGetObjectURLByUID.GetObjectURLByUIDMock.mutex.Unlock()

	for _, e := range mmGetObjectURLByUID.GetObjectURLByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetObjectURLByUID.GetObjectURLByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetObjectURLByUID.GetObjectURLByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetObjectURLByUID.GetObjectURLByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetObjectURLByUID.GetObjectURLByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetObjectURLByUIDParams{ctx, uid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetObjectURLByUID.t.Errorf("RepositoryMock.GetObjectURLByUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectURLByUID.GetObjectURLByUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmGetObjectURLByUID.t.Errorf("RepositoryMock.GetObjectURLByUID got unexpected parameter uid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectURLByUID.GetObjectURLByUIDMock.defaultExpectation.expectationOrigins.originUid, *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetObjectURLByUID.t.Errorf("RepositoryMock.GetObjectURLByUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetObjectURLByUID.GetObjectURLByUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetObjectURLByUID.GetObjectURLByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetObjectURLByUID.t.Fatal("No results are set for the RepositoryMock.GetObjectURLByUID")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetObjectURLByUID.funcGetObjectURLByUID != nil {
		return mmGetObjectURLByUID.funcGetObjectURLByUID(ctx, uid)
	}
	mmGetObjectURLByUID.t.Fatalf("Unexpected call to RepositoryMock.GetObjectURLByUID. %v %v", ctx, uid)
	return
}

// GetObjectURLByUIDAfterCounter returns a count of finished RepositoryMock.GetObjectURLByUID invocations
func (mmGetObjectURLByUID *RepositoryMock) GetObjectURLByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectURLByUID.afterGetObjectURLByUIDCounter)
}

// GetObjectURLByUIDBeforeCounter returns a count of RepositoryMock.GetObjectURLByUID invocations
func (mmGetObjectURLByUID *RepositoryMock) GetObjectURLByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectURLByUID.beforeGetObjectURLByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetObjectURLByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetObjectURLByUID *mRepositoryMockGetObjectURLByUID) Calls() []*RepositoryMockGetObjectURLByUIDParams {
	mmGetObjectURLByUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetObjectURLByUIDParams, len(mmGetObjectURLByUID.callArgs))
	copy(argCopy, mmGetObjectURLByUID.callArgs)

	mmGetObjectURLByUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetObjectURLByUIDDone returns true if the count of the GetObjectURLByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetObjectURLByUIDDone() bool {
	if m.GetObjectURLByUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetObjectURLByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetObjectURLByUIDMock.invocationsDone()
}

// MinimockGetObjectURLByUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetObjectURLByUIDInspect() {
	for _, e := range m.GetObjectURLByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetObjectURLByUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetObjectURLByUIDCounter := mm_atomic.LoadUint64(&m.afterGetObjectURLByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetObjectURLByUIDMock.defaultExpectation != nil && afterGetObjectURLByUIDCounter < 1 {
		if m.GetObjectURLByUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetObjectURLByUID at\n%s", m.GetObjectURLByUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetObjectURLByUID at\n%s with params: %#v", m.GetObjectURLByUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetObjectURLByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetObjectURLByUID != nil && afterGetObjectURLByUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetObjectURLByUID at\n%s", m.funcGetObjectURLByUIDOrigin)
	}

	if !m.GetObjectURLByUIDMock.invocationsDone() && afterGetObjectURLByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetObjectURLByUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetObjectURLByUIDMock.expectedInvocations), m.GetObjectURLByUIDMock.expectedInvocationsOrigin, afterGetObjectURLByUIDCounter)
	}
}

type mRepositoryMockGetObjectURLCountByObject struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetObjectURLCountByObjectExpectation
	expectations       []*RepositoryMockGetObjectURLCountByObjectExpectation

	callArgs []*RepositoryMockGetObjectURLCountByObjectParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetObjectURLCountByObjectExpectation specifies expectation struct of the Repository.GetObjectURLCountByObject
type RepositoryMockGetObjectURLCountByObjectExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetObjectURLCountByObjectParams
	paramPtrs          *RepositoryMockGetObjectURLCountByObjectParamPtrs
	expectationOrigins RepositoryMockGetObjectURLCountByObjectExpectationOrigins
	results            *RepositoryMockGetObjectURLCountByObjectResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetObjectURLCountByObjectParams contains parameters of the Repository.GetObjectURLCountByObject
type RepositoryMockGetObjectURLCountByObjectParams struct {
	ctx       context.Context
	objectUID types.ObjectUIDType
}

// RepositoryMockGetObjectURLCountByObjectParamPtrs contains pointers to parameters of the Repository.GetObjectURLCountByObject
type RepositoryMockGetObjectURLCountByObjectParamPtrs struct {
	ctx       *context.Context
	objectUID *types.ObjectUIDType
}

// RepositoryMockGetObjectURLCountByObjectResults contains results of the Repository.GetObjectURLCountByObject
type RepositoryMockGetObjectURLCountByObjectResults struct {
	i1  int64
	err error
}

// RepositoryMockGetObjectURLCountByObjectOrigins contains origins of expectations of the Repository.GetObjectURLCountByObject
type RepositoryMockGetObjectURLCountByObjectExpectationOrigins struct {
	origin          string
	originCtx       string
	originObjectUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetObjectURLCountByObject *mRepositoryMockGetObjectURLCountByObject) Optional() *mRepositoryMockGetObjectURLCountByObject {
	mmGetObjectURLCountByObject.optional = true
	return mmGetObjectURLCountByObject
}

// Expect sets up expected params for Repository.GetObjectURLCountByObject
func (mmGetObjectURLCountByObject *mRepositoryMockGetObjectURLCountByObject) Expect(ctx context.Context, objectUID types.ObjectUIDType) *mRepositoryMockGetObjectURLCountByObject {
	if mmGetObjectURLCountByObject.mock.funcGetObjectURLCountByObject != nil {
		mmGetObjectURLCountByObject.mock.t.Fatalf("RepositoryMock.GetObjectURLCountByObject mock is already set by Set")
	}

	if mmGetObjectURLCountByObject.defaultExpectation == nil {
		mmGetObjectURLCountByObject.defaultExpectation = &RepositoryMockGetObjectURLCountByObjectExpectation{}
	}

	if mmGetObjectURLCountByObject.defaultExpectation.paramPtrs != nil {
		mmGetObjectURLCountByObject.mock.t.Fatalf("RepositoryMock.GetObjectURLCountByObject mock is already set by ExpectParams functions")
	}

	mmGetObjectURLCountByObject.defaultExpectation.params = &RepositoryMockGetObjectURLCountByObjectParams{ctx, objectUID}
	mmGetObjectURLCountByObject.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetObjectURLCountByObject.expectations {
		if minimock.Equal(e.params, mmGetObjectURLCountByObject.defaultExpectation.params) {
			mmGetObjectURLCountByObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetObjectURLCountByObject.defaultExpectation.params)
		}
	}

	return mmGetObjectURLCountByObject
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetObjectURLCountByObject
func (mmGetObjectURLCountByObject *mRepositoryMockGetObjectURLCountByObject) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetObjectURLCountByObject {
	if mmGetObjectURLCountByObject.mock.funcGetObjectURLCountByObject != nil {
		mmGetObjectURLCountByObject.mock.t.Fatalf("RepositoryMock.GetObjectURLCountByObject mock is already set by Set")
	}

	if mmGetObjectURLCountByObject.defaultExpectation == nil {
		mmGetObjectURLCountByObject.defaultExpectation = &RepositoryMockGetObjectURLCountByObjectExpectation{}
	}

	if mmGetObjectURLCountByObject.defaultExpectation.params != nil {
		mmGetObjectURLCountByObject.mock.t.Fatalf("RepositoryMock.GetObjectURLCountByObject mock is already set by Expect")
	}

	if mmGetObjectURLCountByObject.defaultExpectation.paramPtrs == nil {
		mmGetObjectURLCountByObject.defaultExpectation.paramPtrs = &RepositoryMockGetObjectURLCountByObjectParamPtrs{}
	}
	mmGetObjectURLCountByObject.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetObjectURLCountByObject.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetObjectURLCountByObject
}

// ExpectObjectUIDParam2 sets up expected param objectUID for Repository.GetObjectURLCountByObject
func (mmGetObjectURLCountByObject *mRepositoryMockGetObjectURLCountByObject) ExpectObjectUIDParam2(objectUID types.ObjectUIDType) *mRepositoryMockGetObjectURLCountByObject {
	if mmGetObjectURLCountByObject.mock.funcGetObjectURLCountByObject != nil {
		mmGetObjectURLCountByObject.mock.t.Fatalf("RepositoryMock.GetObjectURLCountByObject mock is already set by Set")
	}

	if mmGetObjectURLCountByObject.defaultExpectation == nil {
		mmGetObjectURLCountByObject.defaultExpectation = &RepositoryMockGetObjectURLCountByObjectExpectation{}
	}

	if mmGetObjectURLCountByObject.defaultExpectation.params != nil {
		mmGetObjectURLCountByObject.mock.t.Fatalf("RepositoryMock.GetObjectURLCountByObject mock is already set by Expect")
	}

	if mmGetObjectURLCountByObject.defaultExpectation.paramPtrs == nil {
		mmGetObjectURLCountByObject.defaultExpectation.paramPtrs = &RepositoryMockGetObjectURLCountByObjectParamPtrs{}
	}
	mmGetObjectURLCountByObject.defaultExpectation.paramPtrs.objectUID = &objectUID
	mmGetObjectURLCountByObject.defaultExpectation.expectationOrigins.originObjectUID = minimock.CallerInfo(1)

	return mmGetObjectURLCountByObject
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetObjectURLCountByObject
func (mmGetObjectURLCountByObject *mRepositoryMockGetObjectURLCountByObject) Inspect(f func(ctx context.Context, objectUID types.ObjectUIDType)) *mRepositoryMockGetObjectURLCountByObject {
	if mmGetObjectURLCountByObject.mock.inspectFuncGetObjectURLCountByObject != nil {
		mmGetObjectURLCountByObject.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetObjectURLCountByObject")
	}

	mmGetObjectURLCountByObject.mock.inspectFuncGetObjectURLCountByObject = f

	return mmGetObjectURLCountByObject
}

// Return sets up results that will be returned by Repository.GetObjectURLCountByObject
func (mmGetObjectURLCountByObject *mRepositoryMockGetObjectURLCountByObject) Return(i1 int64, err error) *RepositoryMock {
	if mmGetObjectURLCountByObject.mock.funcGetObjectURLCountByObject != nil {
		mmGetObjectURLCountByObject.mock.t.Fatalf("RepositoryMock.GetObjectURLCountByObject mock is already set by Set")
	}

	if mmGetObjectURLCountByObject.defaultExpectation == nil {
		mmGetObjectURLCountByObject.defaultExpectation = &RepositoryMockGetObjectURLCountByObjectExpectation{mock: mmGetObjectURLCountByObject.mock}
	}
	mmGetObjectURLCountByObject.defaultExpectation.results = &RepositoryMockGetObjectURLCountByObjectResults{i1, err}
	mmGetObjectURLCountByObject.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetObjectURLCountByObject.mock
}

// Set uses given function f to mock the Repository.GetObjectURLCountByObject method
func (mmGetObjectURLCountByObject *mRepositoryMockGetObjectURLCountByObject) Set(f func(ctx context.Context, objectUID types.ObjectUIDType) (i1 int64, err error)) *RepositoryMock {
	if mmGetObjectURLCountByObject.defaultExpectation != nil {
		mmGetObjectURLCountByObject.mock.t.Fatalf("Default expectation is already set for the Repository.GetObjectURLCountByObject method")
	}

	if len(mmGetObjectURLCountByObject.expectations) > 0 {
		mmGetObjectURLCountByObject.mock.t.Fatalf("Some expectations are already set for the Repository.GetObjectURLCountByObject method")
	}

	mmGetObjectURLCountByObject.mock.funcGetObjectURLCountByObject = f
	mmGetObjectURLCountByObject.mock.funcGetObjectURLCountByObjectOrigin = minimock.CallerInfo(1)
	return mmGetObjectURLCountByObject.mock
}

// When sets expectation for the Repository.GetObjectURLCountByObject which will trigger the result defined by the following
// Then helper
func (mmGetObjectURLCountByObject *mRepositoryMockGetObjectURLCountByObject) When(ctx context.Context, objectUID types.ObjectUIDType) *RepositoryMockGetObjectURLCountByObjectExpectation {
	if mmGetObjectURLCountByObject.mock.funcGetObjectURLCountByObject != nil {
		mmGetObjectURLCountByObject.mock.t.Fatalf("RepositoryMock.GetObjectURLCountByObject mock is already set by Set")
	}

	expectation := &RepositoryMockGetObjectURLCountByObjectExpectation{
		mock:               mmGetObjectURLCountByObject.mock,
		params:             &RepositoryMockGetObjectURLCountByObjectParams{ctx, objectUID},
		expectationOrigins: RepositoryMockGetObjectURLCountByObjectExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetObjectURLCountByObject.expectations = append(mmGetObjectURLCountByObject.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetObjectURLCountByObject return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetObjectURLCountByObjectExpectation) Then(i1 int64, err error) *RepositoryMock {
	e.results = &RepositoryMockGetObjectURLCountByObjectResults{i1, err}
	return e.mock
}

// Times sets number of times Repository.GetObjectURLCountByObject should be invoked
func (mmGetObjectURLCountByObject *mRepositoryMockGetObjectURLCountByObject) Times(n uint64) *mRepositoryMockGetObjectURLCountByObject {
	if n == 0 {
		mmGetObjectURLCountByObject.mock.t.Fatalf("Times of RepositoryMock.GetObjectURLCountByObject mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetObjectURLCountByObject.expectedInvocations, n)
	mmGetObjectURLCountByObject.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetObjectURLCountByObject
}

func (mmGetObjectURLCountByObject *mRepositoryMockGetObjectURLCountByObject) invocationsDone() bool {
	if len(mmGetObjectURLCountByObject.expectations) == 0 && mmGetObjectURLCountByObject.defaultExpectation == nil && mmGetObjectURLCountByObject.mock.funcGetObjectURLCountByObject == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetObjectURLCountByObject.mock.afterGetObjectURLCountByObjectCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetObjectURLCountByObject.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetObjectURLCountByObject implements mm_repository.Repository
func (mmGetObjectURLCountByObject *RepositoryMock) GetObjectURLCountByObject(ctx context.Context, objectUID types.ObjectUIDType) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetObjectURLCountByObject.beforeGetObjectURLCountByObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmGetObjectURLCountByObject.afterGetObjectURLCountByObjectCounter, 1)

	mmGetObjectURLCountByObject.t.Helper()

	if mmGetObjectURLCountByObject.inspectFuncGetObjectURLCountByObject != nil {
		mmGetObjectURLCountByObject.inspectFuncGetObjectURLCountByObject(ctx, objectUID)
	}

	mm_params := RepositoryMockGetObjectURLCountByObjectParams{ctx, objectUID}

	// Record call args
	mmGetObjectURLCountByObject.GetObjectURLCountByObjectMock.mutex.Lock()
	mmGetObjectURLCountByObject.GetObjectURLCountByObjectMock.callArgs = append(mmGetObjectURLCountByObject.GetObjectURLCountByObjectMock.callArgs, &mm_params)
	mmGetObjectURLCountByObject.GetObjectURLCountByObjectMock.mutex.Unlock()

	for _, e := range mmGetObjectURLCountByObject.GetObjectURLCountByObjectMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetObjectURLCountByObject.GetObjectURLCountByObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetObjectURLCountByObject.GetObjectURLCountByObjectMock.defaultExpectation.Counter, 1)
		mm_want := mmGetObjectURLCountByObject.GetObjectURLCountByObjectMock.defaultExpectation.params
		mm_want_ptrs := mmGetObjectURLCountByObject.GetObjectURLCountByObjectMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetObjectURLCountByObjectParams{ctx, objectUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetObjectURLCountByObject.t.Errorf("RepositoryMock.GetObjectURLCountByObject got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectURLCountByObject.GetObjectURLCountByObjectMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmGetObjectURLCountByObject.t.Errorf("RepositoryMock.GetObjectURLCountByObject got unexpected parameter objectUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectURLCountByObject.GetObjectURLCountByObjectMock.defaultExpectation.expectationOrigins.originObjectUID, *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetObjectURLCountByObject.t.Errorf("RepositoryMock.GetObjectURLCountByObject got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetObjectURLCountByObject.GetObjectURLCountByObjectMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetObjectURLCountByObject.GetObjectURLCountByObjectMock.defaultExpectation.results
		if mm_results == nil {
			mmGetObjectURLCountByObject.t.Fatal("No results are set for the RepositoryMock.GetObjectURLCountByObject")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetObjectURLCountByObject.funcGetObjectURLCountByObject != nil {
		return mmGetObjectURLCountByObject.funcGetObjectURLCountByObject(ctx, objectUID)
	}
	mmGetObjectURLCountByObject.t.Fatalf("Unexpected call to RepositoryMock.GetObjectURLCountByObject. %v %v", ctx, objectUID)
	return
}

// GetObjectURLCountByObjectAfterCounter returns a count of finished RepositoryMock.GetObjectURLCountByObject invocations
func (mmGetObjectURLCountByObject *RepositoryMock) GetObjectURLCountByObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectURLCountByObject.afterGetObjectURLCountByObjectCounter)
}

// GetObjectURLCountByObjectBeforeCounter returns a count of RepositoryMock.GetObjectURLCountByObject invocations
func (mmGetObjectURLCountByObject *RepositoryMock) GetObjectURLCountByObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectURLCountByObject.beforeGetObjectURLCountByObjectCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetObjectURLCountByObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetObjectURLCountByObject *mRepositoryMockGetObjectURLCountByObject) Calls() []*RepositoryMockGetObjectURLCountByObjectParams {
	mmGetObjectURLCountByObject.mutex.RLock()

	argCopy := make([]*RepositoryMockGetObjectURLCountByObjectParams, len(mmGetObjectURLCountByObject.callArgs))
	copy(argCopy, mmGetObjectURLCountByObject.callArgs)

	mmGetObjectURLCountByObject.mutex.RUnlock()

	return argCopy
}

// MinimockGetObjectURLCountByObjectDone returns true if the count of the GetObjectURLCountByObject invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetObjectURLCountByObjectDone() bool {
	if m.GetObjectURLCountByObjectMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetObjectURLCountByObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetObjectURLCountByObjectMock.invocationsDone()
}

// MinimockGetObjectURLCountByObjectInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetObjectURLCountByObjectInspect() {
	for _, e := range m.GetObjectURLCountByObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetObjectURLCountByObject at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetObjectURLCountByObjectCounter := mm_atomic.LoadUint64(&m.afterGetObjectURLCountByObjectCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetObjectURLCountByObjectMock.defaultExpectation != nil && afterGetObjectURLCountByObjectCounter < 1 {
		if m.GetObjectURLCountByObjectMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetObjectURLCountByObject at\n%s", m.GetObjectURLCountByObjectMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetObjectURLCountByObject at\n%s with params: %#v", m.GetObjectURLCountByObjectMock.defaultExpectation.expectationOrigins.origin, *m.GetObjectURLCountByObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetObjectURLCountByObject != nil && afterGetObjectURLCountByObjectCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetObjectURLCountByObject at\n%s", m.funcGetObjectURLCountByObjectOrigin)
	}

	if !m.GetObjectURLCountByObjectMock.invocationsDone() && afterGetObjectURLCountByObjectCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetObjectURLCountByObject at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetObjectURLCountByObjectMock.expectedInvocations), m.GetObjectURLCountByObjectMock.expectedInvocationsOrigin, afterGetObjectURLCountByObjectCounter)
	}
}

type mRepositoryMockGetObjectUploadURL struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetObjectUploadURLExpectation
	expectations       []*RepositoryMockGetObjectUploadURLExpectation

	callArgs []*RepositoryMockGetObjectUploadURLParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetObjectUploadURLExpectation specifies expectation struct of the Repository.GetObjectUploadURL
type RepositoryMockGetObjectUploadURLExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetObjectUploadURLParams
	paramPtrs          *RepositoryMockGetObjectUploadURLParamPtrs
	expectationOrigins RepositoryMockGetObjectUploadURLExpectationOrigins
	results            *RepositoryMockGetObjectUploadURLResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetObjectUploadURLParams contains parameters of the Repository.GetObjectUploadURL
type RepositoryMockGetObjectUploadURLParams struct {
	ctx       context.Context
	objectUID types.ObjectUIDType
}

// RepositoryMockGetObjectUploadURLParamPtrs contains pointers to parameters of the Repository.GetObjectUploadURL
type RepositoryMockGetObjectUploadURLParamPtrs struct {
	ctx       *context.Context
	objectUID *types.ObjectUIDType
}

// RepositoryMockGetObjectUploadURLResults contains results of the Repository.GetObjectUploadURL
type RepositoryMockGetObjectUploadURLResults struct {
	op1 *mm_repository.ObjectURLModel
	err error
}

// RepositoryMockGetObjectUploadURLOrigins contains origins of expectations of the Repository.GetObjectUploadURL
type RepositoryMockGetObjectUploadURLExpectationOrigins struct {
	origin          string
	originCtx       string
	originObjectUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetObjectUploadURL *mRepositoryMockGetObjectUploadURL) Optional() *mRepositoryMockGetObjectUploadURL {
	mmGetObjectUploadURL.optional = true
	return mmGetObjectUploadURL
}

// Expect sets up expected params for Repository.GetObjectUploadURL
func (mmGetObjectUploadURL *mRepositoryMockGetObjectUploadURL) Expect(ctx context.Context, objectUID types.ObjectUIDType) *mRepositoryMockGetObjectUploadURL {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("RepositoryMock.GetObjectUploadURL mock is already set by Set")
	}

	if mmGetObjectUploadURL.defaultExpectation == nil {
		mmGetObjectUploadURL.defaultExpectation = &RepositoryMockGetObjectUploadURLExpectation{}
	}

	if mmGetObjectUploadURL.defaultExpectation.paramPtrs != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("RepositoryMock.GetObjectUploadURL mock is already set by ExpectParams functions")
	}

	mmGetObjectUploadURL.defaultExpectation.params = &RepositoryMockGetObjectUploadURLParams{ctx, objectUID}
	mmGetObjectUploadURL.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetObjectUploadURL.expectations {
		if minimock.Equal(e.params, mmGetObjectUploadURL.defaultExpectation.params) {
			mmGetObjectUploadURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetObjectUploadURL.defaultExpectation.params)
		}
	}

	return mmGetObjectUploadURL
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetObjectUploadURL
func (mmGetObjectUploadURL *mRepositoryMockGetObjectUploadURL) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetObjectUploadURL {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("RepositoryMock.GetObjectUploadURL mock is already set by Set")
	}

	if mmGetObjectUploadURL.defaultExpectation == nil {
		mmGetObjectUploadURL.defaultExpectation = &RepositoryMockGetObjectUploadURLExpectation{}
	}

	if mmGetObjectUploadURL.defaultExpectation.params != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("RepositoryMock.GetObjectUploadURL mock is already set by Expect")
	}

	if mmGetObjectUploadURL.defaultExpectation.paramPtrs == nil {
		mmGetObjectUploadURL.defaultExpectation.paramPtrs = &RepositoryMockGetObjectUploadURLParamPtrs{}
	}
	mmGetObjectUploadURL.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetObjectUploadURL.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetObjectUploadURL
}

// ExpectObjectUIDParam2 sets up expected param objectUID for Repository.GetObjectUploadURL
func (mmGetObjectUploadURL *mRepositoryMockGetObjectUploadURL) ExpectObjectUIDParam2(objectUID types.ObjectUIDType) *mRepositoryMockGetObjectUploadURL {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("RepositoryMock.GetObjectUploadURL mock is already set by Set")
	}

	if mmGetObjectUploadURL.defaultExpectation == nil {
		mmGetObjectUploadURL.defaultExpectation = &RepositoryMockGetObjectUploadURLExpectation{}
	}

	if mmGetObjectUploadURL.defaultExpectation.params != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("RepositoryMock.GetObjectUploadURL mock is already set by Expect")
	}

	if mmGetObjectUploadURL.defaultExpectation.paramPtrs == nil {
		mmGetObjectUploadURL.defaultExpectation.paramPtrs = &RepositoryMockGetObjectUploadURLParamPtrs{}
	}
	mmGetObjectUploadURL.defaultExpectation.paramPtrs.objectUID = &objectUID
	mmGetObjectUploadURL.defaultExpectation.expectationOrigins.originObjectUID = minimock.CallerInfo(1)

	return mmGetObjectUploadURL
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetObjectUploadURL
func (mmGetObjectUploadURL *mRepositoryMockGetObjectUploadURL) Inspect(f func(ctx context.Context, objectUID types.ObjectUIDType)) *mRepositoryMockGetObjectUploadURL {
	if mmGetObjectUploadURL.mock.inspectFuncGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetObjectUploadURL")
	}

	mmGetObjectUploadURL.mock.inspectFuncGetObjectUploadURL = f

	return mmGetObjectUploadURL
}

// Return sets up results that will be returned by Repository.GetObjectUploadURL
func (mmGetObjectUploadURL *mRepositoryMockGetObjectUploadURL) Return(op1 *mm_repository.ObjectURLModel, err error) *RepositoryMock {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("RepositoryMock.GetObjectUploadURL mock is already set by Set")
	}

	if mmGetObjectUploadURL.defaultExpectation == nil {
		mmGetObjectUploadURL.defaultExpectation = &RepositoryMockGetObjectUploadURLExpectation{mock: mmGetObjectUploadURL.mock}
	}
	mmGetObjectUploadURL.defaultExpectation.results = &RepositoryMockGetObjectUploadURLResults{op1, err}
	mmGetObjectUploadURL.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetObjectUploadURL.mock
}

// Set uses given function f to mock the Repository.GetObjectUploadURL method
func (mmGetObjectUploadURL *mRepositoryMockGetObjectUploadURL) Set(f func(ctx context.Context, objectUID types.ObjectUIDType) (op1 *mm_repository.ObjectURLModel, err error)) *RepositoryMock {
	if mmGetObjectUploadURL.defaultExpectation != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("Default expectation is already set for the Repository.GetObjectUploadURL method")
	}

	if len(mmGetObjectUploadURL.expectations) > 0 {
		mmGetObjectUploadURL.mock.t.Fatalf("Some expectations are already set for the Repository.GetObjectUploadURL method")
	}

	mmGetObjectUploadURL.mock.funcGetObjectUploadURL = f
	mmGetObjectUploadURL.mock.funcGetObjectUploadURLOrigin = minimock.CallerInfo(1)
	return mmGetObjectUploadURL.mock
}

// When sets expectation for the Repository.GetObjectUploadURL which will trigger the result defined by the following
// Then helper
func (mmGetObjectUploadURL *mRepositoryMockGetObjectUploadURL) When(ctx context.Context, objectUID types.ObjectUIDType) *RepositoryMockGetObjectUploadURLExpectation {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("RepositoryMock.GetObjectUploadURL mock is already set by Set")
	}

	expectation := &RepositoryMockGetObjectUploadURLExpectation{
		mock:               mmGetObjectUploadURL.mock,
		params:             &RepositoryMockGetObjectUploadURLParams{ctx, objectUID},
		expectationOrigins: RepositoryMockGetObjectUploadURLExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetObjectUploadURL.expectations = append(mmGetObjectUploadURL.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetObjectUploadURL return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetObjectUploadURLExpectation) Then(op1 *mm_repository.ObjectURLModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetObjectUploadURLResults{op1, err}
	return e.mock
}

// Times sets number of times Repository.GetObjectUploadURL should be invoked
func (mmGetObjectUploadURL *mRepositoryMockGetObjectUploadURL) Times(n uint64) *mRepositoryMockGetObjectUploadURL {
	if n == 0 {
		mmGetObjectUploadURL.mock.t.Fatalf("Times of RepositoryMock.GetObjectUploadURL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetObjectUploadURL.expectedInvocations, n)
	mmGetObjectUploadURL.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetObjectUploadURL
}

func (mmGetObjectUploadURL *mRepositoryMockGetObjectUploadURL) invocationsDone() bool {
	if len(mmGetObjectUploadURL.expectations) == 0 && mmGetObjectUploadURL.defaultExpectation == nil && mmGetObjectUploadURL.mock.funcGetObjectUploadURL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetObjectUploadURL.mock.afterGetObjectUploadURLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetObjectUploadURL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetObjectUploadURL implements mm_repository.Repository
func (mmGetObjectUploadURL *RepositoryMock) GetObjectUploadURL(ctx context.Context, objectUID types.ObjectUIDType) (op1 *mm_repository.ObjectURLModel, err error) {
	mm_atomic.AddUint64(&mmGetObjectUploadURL.beforeGetObjectUploadURLCounter, 1)
	defer mm_atomic.AddUint64(&mmGetObjectUploadURL.afterGetObjectUploadURLCounter, 1)

	mmGetObjectUploadURL.t.Helper()

	if mmGetObjectUploadURL.inspectFuncGetObjectUploadURL != nil {
		mmGetObjectUploadURL.inspectFuncGetObjectUploadURL(ctx, objectUID)
	}

	mm_params := RepositoryMockGetObjectUploadURLParams{ctx, objectUID}

	// Record call args
	mmGetObjectUploadURL.GetObjectUploadURLMock.mutex.Lock()
	mmGetObjectUploadURL.GetObjectUploadURLMock.callArgs = append(mmGetObjectUploadURL.GetObjectUploadURLMock.callArgs, &mm_params)
	mmGetObjectUploadURL.GetObjectUploadURLMock.mutex.Unlock()

	for _, e := range mmGetObjectUploadURL.GetObjectUploadURLMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.Counter, 1)
		mm_want := mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.params
		mm_want_ptrs := mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetObjectUploadURLParams{ctx, objectUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetObjectUploadURL.t.Errorf("RepositoryMock.GetObjectUploadURL got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmGetObjectUploadURL.t.Errorf("RepositoryMock.GetObjectUploadURL got unexpected parameter objectUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.expectationOrigins.originObjectUID, *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetObjectUploadURL.t.Errorf("RepositoryMock.GetObjectUploadURL got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.results
		if mm_results == nil {
			mmGetObjectUploadURL.t.Fatal("No results are set for the RepositoryMock.GetObjectUploadURL")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetObjectUploadURL.funcGetObjectUploadURL != nil {
		return mmGetObjectUploadURL.funcGetObjectUploadURL(ctx, objectUID)
	}
	mmGetObjectUploadURL.t.Fatalf("Unexpected call to RepositoryMock.GetObjectUploadURL. %v %v", ctx, objectUID)
	return
}

// GetObjectUploadURLAfterCounter returns a count of finished RepositoryMock.GetObjectUploadURL invocations
func (mmGetObjectUploadURL *RepositoryMock) GetObjectUploadURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectUploadURL.afterGetObjectUploadURLCounter)
}

// GetObjectUploadURLBeforeCounter returns a count of RepositoryMock.GetObjectUploadURL invocations
func (mmGetObjectUploadURL *RepositoryMock) GetObjectUploadURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectUploadURL.beforeGetObjectUploadURLCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetObjectUploadURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetObjectUploadURL *mRepositoryMockGetObjectUploadURL) Calls() []*RepositoryMockGetObjectUploadURLParams {
	mmGetObjectUploadURL.mutex.RLock()

	argCopy := make([]*RepositoryMockGetObjectUploadURLParams, len(mmGetObjectUploadURL.callArgs))
	copy(argCopy, mmGetObjectUploadURL.callArgs)

	mmGetObjectUploadURL.mutex.RUnlock()

	return argCopy
}

// MinimockGetObjectUploadURLDone returns true if the count of the GetObjectUploadURL invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetObjectUploadURLDone() bool {
	if m.GetObjectUploadURLMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetObjectUploadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetObjectUploadURLMock.invocationsDone()
}

// MinimockGetObjectUploadURLInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetObjectUploadURLInspect() {
	for _, e := range m.GetObjectUploadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetObjectUploadURL at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetObjectUploadURLCounter := mm_atomic.LoadUint64(&m.afterGetObjectUploadURLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetObjectUploadURLMock.defaultExpectation != nil && afterGetObjectUploadURLCounter < 1 {
		if m.GetObjectUploadURLMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetObjectUploadURL at\n%s", m.GetObjectUploadURLMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetObjectUploadURL at\n%s with params: %#v", m.GetObjectUploadURLMock.defaultExpectation.expectationOrigins.origin, *m.GetObjectUploadURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetObjectUploadURL != nil && afterGetObjectUploadURLCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetObjectUploadURL at\n%s", m.funcGetObjectUploadURLOrigin)
	}

	if !m.GetObjectUploadURLMock.invocationsDone() && afterGetObjectUploadURLCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetObjectUploadURL at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetObjectUploadURLMock.expectedInvocations), m.GetObjectUploadURLMock.expectedInvocationsOrigin, afterGetObjectUploadURLCounter)
	}
}

type mRepositoryMockGetPresignedURLForDownload struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetPresignedURLForDownloadExpectation
	expectations       []*RepositoryMockGetPresignedURLForDownloadExpectation

	callArgs []*RepositoryMockGetPresignedURLForDownloadParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetPresignedURLForDownloadExpectation specifies expectation struct of the Repository.GetPresignedURLForDownload
type RepositoryMockGetPresignedURLForDownloadExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetPresignedURLForDownloadParams
	paramPtrs          *RepositoryMockGetPresignedURLForDownloadParamPtrs
	expectationOrigins RepositoryMockGetPresignedURLForDownloadExpectationOrigins
	results            *RepositoryMockGetPresignedURLForDownloadResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetPresignedURLForDownloadParams contains parameters of the Repository.GetPresignedURLForDownload
type RepositoryMockGetPresignedURLForDownloadParams struct {
	ctx           context.Context
	namespaceUUID types.NamespaceUIDType
	objectUUID    types.ObjectUIDType
	filename      string
	contentType   string
	urlExpiration time.Duration
}

// RepositoryMockGetPresignedURLForDownloadParamPtrs contains pointers to parameters of the Repository.GetPresignedURLForDownload
type RepositoryMockGetPresignedURLForDownloadParamPtrs struct {
	ctx           *context.Context
	namespaceUUID *types.NamespaceUIDType
	objectUUID    *types.ObjectUIDType
	filename      *string
	contentType   *string
	urlExpiration *time.Duration
}

// RepositoryMockGetPresignedURLForDownloadResults contains results of the Repository.GetPresignedURLForDownload
type RepositoryMockGetPresignedURLForDownloadResults struct {
	up1 *url.URL
	err error
}

// RepositoryMockGetPresignedURLForDownloadOrigins contains origins of expectations of the Repository.GetPresignedURLForDownload
type RepositoryMockGetPresignedURLForDownloadExpectationOrigins struct {
	origin              string
	originCtx           string
	originNamespaceUUID string
	originObjectUUID    string
	originFilename      string
	originContentType   string
	originUrlExpiration string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPresignedURLForDownload *mRepositoryMockGetPresignedURLForDownload) Optional() *mRepositoryMockGetPresignedURLForDownload {
	mmGetPresignedURLForDownload.optional = true
	return mmGetPresignedURLForDownload
}

// Expect sets up expected params for Repository.GetPresignedURLForDownload
func (mmGetPresignedURLForDownload *mRepositoryMockGetPresignedURLForDownload) Expect(ctx context.Context, namespaceUUID types.NamespaceUIDType, objectUUID types.ObjectUIDType, filename string, contentType string, urlExpiration time.Duration) *mRepositoryMockGetPresignedURLForDownload {
	if mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForDownload mock is already set by Set")
	}

	if mmGetPresignedURLForDownload.defaultExpectation == nil {
		mmGetPresignedURLForDownload.defaultExpectation = &RepositoryMockGetPresignedURLForDownloadExpectation{}
	}

	if mmGetPresignedURLForDownload.defaultExpectation.paramPtrs != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForDownload mock is already set by ExpectParams functions")
	}

	mmGetPresignedURLForDownload.defaultExpectation.params = &RepositoryMockGetPresignedURLForDownloadParams{ctx, namespaceUUID, objectUUID, filename, contentType, urlExpiration}
	mmGetPresignedURLForDownload.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPresignedURLForDownload.expectations {
		if minimock.Equal(e.params, mmGetPresignedURLForDownload.defaultExpectation.params) {
			mmGetPresignedURLForDownload.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPresignedURLForDownload.defaultExpectation.params)
		}
	}

	return mmGetPresignedURLForDownload
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetPresignedURLForDownload
func (mmGetPresignedURLForDownload *mRepositoryMockGetPresignedURLForDownload) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetPresignedURLForDownload {
	if mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForDownload mock is already set by Set")
	}

	if mmGetPresignedURLForDownload.defaultExpectation == nil {
		mmGetPresignedURLForDownload.defaultExpectation = &RepositoryMockGetPresignedURLForDownloadExpectation{}
	}

	if mmGetPresignedURLForDownload.defaultExpectation.params != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForDownload mock is already set by Expect")
	}

	if mmGetPresignedURLForDownload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForDownload.defaultExpectation.paramPtrs = &RepositoryMockGetPresignedURLForDownloadParamPtrs{}
	}
	mmGetPresignedURLForDownload.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPresignedURLForDownload.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPresignedURLForDownload
}

// ExpectNamespaceUUIDParam2 sets up expected param namespaceUUID for Repository.GetPresignedURLForDownload
func (mmGetPresignedURLForDownload *mRepositoryMockGetPresignedURLForDownload) ExpectNamespaceUUIDParam2(namespaceUUID types.NamespaceUIDType) *mRepositoryMockGetPresignedURLForDownload {
	if mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForDownload mock is already set by Set")
	}

	if mmGetPresignedURLForDownload.defaultExpectation == nil {
		mmGetPresignedURLForDownload.defaultExpectation = &RepositoryMockGetPresignedURLForDownloadExpectation{}
	}

	if mmGetPresignedURLForDownload.defaultExpectation.params != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForDownload mock is already set by Expect")
	}

	if mmGetPresignedURLForDownload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForDownload.defaultExpectation.paramPtrs = &RepositoryMockGetPresignedURLForDownloadParamPtrs{}
	}
	mmGetPresignedURLForDownload.defaultExpectation.paramPtrs.namespaceUUID = &namespaceUUID
	mmGetPresignedURLForDownload.defaultExpectation.expectationOrigins.originNamespaceUUID = minimock.CallerInfo(1)

	return mmGetPresignedURLForDownload
}

// ExpectObjectUUIDParam3 sets up expected param objectUUID for Repository.GetPresignedURLForDownload
func (mmGetPresignedURLForDownload *mRepositoryMockGetPresignedURLForDownload) ExpectObjectUUIDParam3(objectUUID types.ObjectUIDType) *mRepositoryMockGetPresignedURLForDownload {
	if mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForDownload mock is already set by Set")
	}

	if mmGetPresignedURLForDownload.defaultExpectation == nil {
		mmGetPresignedURLForDownload.defaultExpectation = &RepositoryMockGetPresignedURLForDownloadExpectation{}
	}

	if mmGetPresignedURLForDownload.defaultExpectation.params != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForDownload mock is already set by Expect")
	}

	if mmGetPresignedURLForDownload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForDownload.defaultExpectation.paramPtrs = &RepositoryMockGetPresignedURLForDownloadParamPtrs{}
	}
	mmGetPresignedURLForDownload.defaultExpectation.paramPtrs.objectUUID = &objectUUID
	mmGetPresignedURLForDownload.defaultExpectation.expectationOrigins.originObjectUUID = minimock.CallerInfo(1)

	return mmGetPresignedURLForDownload
}

// ExpectFilenameParam4 sets up expected param filename for Repository.GetPresignedURLForDownload
func (mmGetPresignedURLForDownload *mRepositoryMockGetPresignedURLForDownload) ExpectFilenameParam4(filename string) *mRepositoryMockGetPresignedURLForDownload {
	if mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForDownload mock is already set by Set")
	}

	if mmGetPresignedURLForDownload.defaultExpectation == nil {
		mmGetPresignedURLForDownload.defaultExpectation = &RepositoryMockGetPresignedURLForDownloadExpectation{}
	}

	if mmGetPresignedURLForDownload.defaultExpectation.params != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForDownload mock is already set by Expect")
	}

	if mmGetPresignedURLForDownload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForDownload.defaultExpectation.paramPtrs = &RepositoryMockGetPresignedURLForDownloadParamPtrs{}
	}
	mmGetPresignedURLForDownload.defaultExpectation.paramPtrs.filename = &filename
	mmGetPresignedURLForDownload.defaultExpectation.expectationOrigins.originFilename = minimock.CallerInfo(1)

	return mmGetPresignedURLForDownload
}

// ExpectContentTypeParam5 sets up expected param contentType for Repository.GetPresignedURLForDownload
func (mmGetPresignedURLForDownload *mRepositoryMockGetPresignedURLForDownload) ExpectContentTypeParam5(contentType string) *mRepositoryMockGetPresignedURLForDownload {
	if mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForDownload mock is already set by Set")
	}

	if mmGetPresignedURLForDownload.defaultExpectation == nil {
		mmGetPresignedURLForDownload.defaultExpectation = &RepositoryMockGetPresignedURLForDownloadExpectation{}
	}

	if mmGetPresignedURLForDownload.defaultExpectation.params != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForDownload mock is already set by Expect")
	}

	if mmGetPresignedURLForDownload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForDownload.defaultExpectation.paramPtrs = &RepositoryMockGetPresignedURLForDownloadParamPtrs{}
	}
	mmGetPresignedURLForDownload.defaultExpectation.paramPtrs.contentType = &contentType
	mmGetPresignedURLForDownload.defaultExpectation.expectationOrigins.originContentType = minimock.CallerInfo(1)

	return mmGetPresignedURLForDownload
}

// ExpectUrlExpirationParam6 sets up expected param urlExpiration for Repository.GetPresignedURLForDownload
func (mmGetPresignedURLForDownload *mRepositoryMockGetPresignedURLForDownload) ExpectUrlExpirationParam6(urlExpiration time.Duration) *mRepositoryMockGetPresignedURLForDownload {
	if mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForDownload mock is already set by Set")
	}

	if mmGetPresignedURLForDownload.defaultExpectation == nil {
		mmGetPresignedURLForDownload.defaultExpectation = &RepositoryMockGetPresignedURLForDownloadExpectation{}
	}

	if mmGetPresignedURLForDownload.defaultExpectation.params != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForDownload mock is already set by Expect")
	}

	if mmGetPresignedURLForDownload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForDownload.defaultExpectation.paramPtrs = &RepositoryMockGetPresignedURLForDownloadParamPtrs{}
	}
	mmGetPresignedURLForDownload.defaultExpectation.paramPtrs.urlExpiration = &urlExpiration
	mmGetPresignedURLForDownload.defaultExpectation.expectationOrigins.originUrlExpiration = minimock.CallerInfo(1)

	return mmGetPresignedURLForDownload
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetPresignedURLForDownload
func (mmGetPresignedURLForDownload *mRepositoryMockGetPresignedURLForDownload) Inspect(f func(ctx context.Context, namespaceUUID types.NamespaceUIDType, objectUUID types.ObjectUIDType, filename string, contentType string, urlExpiration time.Duration)) *mRepositoryMockGetPresignedURLForDownload {
	if mmGetPresignedURLForDownload.mock.inspectFuncGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetPresignedURLForDownload")
	}

	mmGetPresignedURLForDownload.mock.inspectFuncGetPresignedURLForDownload = f

	return mmGetPresignedURLForDownload
}

// Return sets up results that will be returned by Repository.GetPresignedURLForDownload
func (mmGetPresignedURLForDownload *mRepositoryMockGetPresignedURLForDownload) Return(up1 *url.URL, err error) *RepositoryMock {
	if mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForDownload mock is already set by Set")
	}

	if mmGetPresignedURLForDownload.defaultExpectation == nil {
		mmGetPresignedURLForDownload.defaultExpectation = &RepositoryMockGetPresignedURLForDownloadExpectation{mock: mmGetPresignedURLForDownload.mock}
	}
	mmGetPresignedURLForDownload.defaultExpectation.results = &RepositoryMockGetPresignedURLForDownloadResults{up1, err}
	mmGetPresignedURLForDownload.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPresignedURLForDownload.mock
}

// Set uses given function f to mock the Repository.GetPresignedURLForDownload method
func (mmGetPresignedURLForDownload *mRepositoryMockGetPresignedURLForDownload) Set(f func(ctx context.Context, namespaceUUID types.NamespaceUIDType, objectUUID types.ObjectUIDType, filename string, contentType string, urlExpiration time.Duration) (up1 *url.URL, err error)) *RepositoryMock {
	if mmGetPresignedURLForDownload.defaultExpectation != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("Default expectation is already set for the Repository.GetPresignedURLForDownload method")
	}

	if len(mmGetPresignedURLForDownload.expectations) > 0 {
		mmGetPresignedURLForDownload.mock.t.Fatalf("Some expectations are already set for the Repository.GetPresignedURLForDownload method")
	}

	mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload = f
	mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownloadOrigin = minimock.CallerInfo(1)
	return mmGetPresignedURLForDownload.mock
}

// When sets expectation for the Repository.GetPresignedURLForDownload which will trigger the result defined by the following
// Then helper
func (mmGetPresignedURLForDownload *mRepositoryMockGetPresignedURLForDownload) When(ctx context.Context, namespaceUUID types.NamespaceUIDType, objectUUID types.ObjectUIDType, filename string, contentType string, urlExpiration time.Duration) *RepositoryMockGetPresignedURLForDownloadExpectation {
	if mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForDownload mock is already set by Set")
	}

	expectation := &RepositoryMockGetPresignedURLForDownloadExpectation{
		mock:               mmGetPresignedURLForDownload.mock,
		params:             &RepositoryMockGetPresignedURLForDownloadParams{ctx, namespaceUUID, objectUUID, filename, contentType, urlExpiration},
		expectationOrigins: RepositoryMockGetPresignedURLForDownloadExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPresignedURLForDownload.expectations = append(mmGetPresignedURLForDownload.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetPresignedURLForDownload return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetPresignedURLForDownloadExpectation) Then(up1 *url.URL, err error) *RepositoryMock {
	e.results = &RepositoryMockGetPresignedURLForDownloadResults{up1, err}
	return e.mock
}

// Times sets number of times Repository.GetPresignedURLForDownload should be invoked
func (mmGetPresignedURLForDownload *mRepositoryMockGetPresignedURLForDownload) Times(n uint64) *mRepositoryMockGetPresignedURLForDownload {
	if n == 0 {
		mmGetPresignedURLForDownload.mock.t.Fatalf("Times of RepositoryMock.GetPresignedURLForDownload mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPresignedURLForDownload.expectedInvocations, n)
	mmGetPresignedURLForDownload.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPresignedURLForDownload
}

func (mmGetPresignedURLForDownload *mRepositoryMockGetPresignedURLForDownload) invocationsDone() bool {
	if len(mmGetPresignedURLForDownload.expectations) == 0 && mmGetPresignedURLForDownload.defaultExpectation == nil && mmGetPresignedURLForDownload.mock.funcGetPresignedURLForDownload == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPresignedURLForDownload.mock.afterGetPresignedURLForDownloadCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPresignedURLForDownload.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPresignedURLForDownload implements mm_repository.Repository
func (mmGetPresignedURLForDownload *RepositoryMock) GetPresignedURLForDownload(ctx context.Context, namespaceUUID types.NamespaceUIDType, objectUUID types.ObjectUIDType, filename string, contentType string, urlExpiration time.Duration) (up1 *url.URL, err error) {
	mm_atomic.AddUint64(&mmGetPresignedURLForDownload.beforeGetPresignedURLForDownloadCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPresignedURLForDownload.afterGetPresignedURLForDownloadCounter, 1)

	mmGetPresignedURLForDownload.t.Helper()

	if mmGetPresignedURLForDownload.inspectFuncGetPresignedURLForDownload != nil {
		mmGetPresignedURLForDownload.inspectFuncGetPresignedURLForDownload(ctx, namespaceUUID, objectUUID, filename, contentType, urlExpiration)
	}

	mm_params := RepositoryMockGetPresignedURLForDownloadParams{ctx, namespaceUUID, objectUUID, filename, contentType, urlExpiration}

	// Record call args
	mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.mutex.Lock()
	mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.callArgs = append(mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.callArgs, &mm_params)
	mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.mutex.Unlock()

	for _, e := range mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.params
		mm_want_ptrs := mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetPresignedURLForDownloadParams{ctx, namespaceUUID, objectUUID, filename, contentType, urlExpiration}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPresignedURLForDownload.t.Errorf("RepositoryMock.GetPresignedURLForDownload got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.namespaceUUID != nil && !minimock.Equal(*mm_want_ptrs.namespaceUUID, mm_got.namespaceUUID) {
				mmGetPresignedURLForDownload.t.Errorf("RepositoryMock.GetPresignedURLForDownload got unexpected parameter namespaceUUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.expectationOrigins.originNamespaceUUID, *mm_want_ptrs.namespaceUUID, mm_got.namespaceUUID, minimock.Diff(*mm_want_ptrs.namespaceUUID, mm_got.namespaceUUID))
			}

			if mm_want_ptrs.objectUUID != nil && !minimock.Equal(*mm_want_ptrs.objectUUID, mm_got.objectUUID) {
				mmGetPresignedURLForDownload.t.Errorf("RepositoryMock.GetPresignedURLForDownload got unexpected parameter objectUUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.expectationOrigins.originObjectUUID, *mm_want_ptrs.objectUUID, mm_got.objectUUID, minimock.Diff(*mm_want_ptrs.objectUUID, mm_got.objectUUID))
			}

			if mm_want_ptrs.filename != nil && !minimock.Equal(*mm_want_ptrs.filename, mm_got.filename) {
				mmGetPresignedURLForDownload.t.Errorf("RepositoryMock.GetPresignedURLForDownload got unexpected parameter filename, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.expectationOrigins.originFilename, *mm_want_ptrs.filename, mm_got.filename, minimock.Diff(*mm_want_ptrs.filename, mm_got.filename))
			}

			if mm_want_ptrs.contentType != nil && !minimock.Equal(*mm_want_ptrs.contentType, mm_got.contentType) {
				mmGetPresignedURLForDownload.t.Errorf("RepositoryMock.GetPresignedURLForDownload got unexpected parameter contentType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.expectationOrigins.originContentType, *mm_want_ptrs.contentType, mm_got.contentType, minimock.Diff(*mm_want_ptrs.contentType, mm_got.contentType))
			}

			if mm_want_ptrs.urlExpiration != nil && !minimock.Equal(*mm_want_ptrs.urlExpiration, mm_got.urlExpiration) {
				mmGetPresignedURLForDownload.t.Errorf("RepositoryMock.GetPresignedURLForDownload got unexpected parameter urlExpiration, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.expectationOrigins.originUrlExpiration, *mm_want_ptrs.urlExpiration, mm_got.urlExpiration, minimock.Diff(*mm_want_ptrs.urlExpiration, mm_got.urlExpiration))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPresignedURLForDownload.t.Errorf("RepositoryMock.GetPresignedURLForDownload got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPresignedURLForDownload.GetPresignedURLForDownloadMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPresignedURLForDownload.t.Fatal("No results are set for the RepositoryMock.GetPresignedURLForDownload")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetPresignedURLForDownload.funcGetPresignedURLForDownload != nil {
		return mmGetPresignedURLForDownload.funcGetPresignedURLForDownload(ctx, namespaceUUID, objectUUID, filename, contentType, urlExpiration)
	}
	mmGetPresignedURLForDownload.t.Fatalf("Unexpected call to RepositoryMock.GetPresignedURLForDownload. %v %v %v %v %v %v", ctx, namespaceUUID, objectUUID, filename, contentType, urlExpiration)
	return
}

// GetPresignedURLForDownloadAfterCounter returns a count of finished RepositoryMock.GetPresignedURLForDownload invocations
func (mmGetPresignedURLForDownload *RepositoryMock) GetPresignedURLForDownloadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPresignedURLForDownload.afterGetPresignedURLForDownloadCounter)
}

// GetPresignedURLForDownloadBeforeCounter returns a count of RepositoryMock.GetPresignedURLForDownload invocations
func (mmGetPresignedURLForDownload *RepositoryMock) GetPresignedURLForDownloadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPresignedURLForDownload.beforeGetPresignedURLForDownloadCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetPresignedURLForDownload.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPresignedURLForDownload *mRepositoryMockGetPresignedURLForDownload) Calls() []*RepositoryMockGetPresignedURLForDownloadParams {
	mmGetPresignedURLForDownload.mutex.RLock()

	argCopy := make([]*RepositoryMockGetPresignedURLForDownloadParams, len(mmGetPresignedURLForDownload.callArgs))
	copy(argCopy, mmGetPresignedURLForDownload.callArgs)

	mmGetPresignedURLForDownload.mutex.RUnlock()

	return argCopy
}

// MinimockGetPresignedURLForDownloadDone returns true if the count of the GetPresignedURLForDownload invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetPresignedURLForDownloadDone() bool {
	if m.GetPresignedURLForDownloadMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPresignedURLForDownloadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPresignedURLForDownloadMock.invocationsDone()
}

// MinimockGetPresignedURLForDownloadInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetPresignedURLForDownloadInspect() {
	for _, e := range m.GetPresignedURLForDownloadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetPresignedURLForDownload at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPresignedURLForDownloadCounter := mm_atomic.LoadUint64(&m.afterGetPresignedURLForDownloadCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPresignedURLForDownloadMock.defaultExpectation != nil && afterGetPresignedURLForDownloadCounter < 1 {
		if m.GetPresignedURLForDownloadMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetPresignedURLForDownload at\n%s", m.GetPresignedURLForDownloadMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetPresignedURLForDownload at\n%s with params: %#v", m.GetPresignedURLForDownloadMock.defaultExpectation.expectationOrigins.origin, *m.GetPresignedURLForDownloadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPresignedURLForDownload != nil && afterGetPresignedURLForDownloadCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetPresignedURLForDownload at\n%s", m.funcGetPresignedURLForDownloadOrigin)
	}

	if !m.GetPresignedURLForDownloadMock.invocationsDone() && afterGetPresignedURLForDownloadCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetPresignedURLForDownload at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPresignedURLForDownloadMock.expectedInvocations), m.GetPresignedURLForDownloadMock.expectedInvocationsOrigin, afterGetPresignedURLForDownloadCounter)
	}
}

type mRepositoryMockGetPresignedURLForUpload struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetPresignedURLForUploadExpectation
	expectations       []*RepositoryMockGetPresignedURLForUploadExpectation

	callArgs []*RepositoryMockGetPresignedURLForUploadParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetPresignedURLForUploadExpectation specifies expectation struct of the Repository.GetPresignedURLForUpload
type RepositoryMockGetPresignedURLForUploadExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetPresignedURLForUploadParams
	paramPtrs          *RepositoryMockGetPresignedURLForUploadParamPtrs
	expectationOrigins RepositoryMockGetPresignedURLForUploadExpectationOrigins
	results            *RepositoryMockGetPresignedURLForUploadResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetPresignedURLForUploadParams contains parameters of the Repository.GetPresignedURLForUpload
type RepositoryMockGetPresignedURLForUploadParams struct {
	ctx           context.Context
	namespaceUUID types.NamespaceUIDType
	objectUUID    types.ObjectUIDType
	filename      string
	urlExpiration time.Duration
}

// RepositoryMockGetPresignedURLForUploadParamPtrs contains pointers to parameters of the Repository.GetPresignedURLForUpload
type RepositoryMockGetPresignedURLForUploadParamPtrs struct {
	ctx           *context.Context
	namespaceUUID *types.NamespaceUIDType
	objectUUID    *types.ObjectUIDType
	filename      *string
	urlExpiration *time.Duration
}

// RepositoryMockGetPresignedURLForUploadResults contains results of the Repository.GetPresignedURLForUpload
type RepositoryMockGetPresignedURLForUploadResults struct {
	up1 *url.URL
	err error
}

// RepositoryMockGetPresignedURLForUploadOrigins contains origins of expectations of the Repository.GetPresignedURLForUpload
type RepositoryMockGetPresignedURLForUploadExpectationOrigins struct {
	origin              string
	originCtx           string
	originNamespaceUUID string
	originObjectUUID    string
	originFilename      string
	originUrlExpiration string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPresignedURLForUpload *mRepositoryMockGetPresignedURLForUpload) Optional() *mRepositoryMockGetPresignedURLForUpload {
	mmGetPresignedURLForUpload.optional = true
	return mmGetPresignedURLForUpload
}

// Expect sets up expected params for Repository.GetPresignedURLForUpload
func (mmGetPresignedURLForUpload *mRepositoryMockGetPresignedURLForUpload) Expect(ctx context.Context, namespaceUUID types.NamespaceUIDType, objectUUID types.ObjectUIDType, filename string, urlExpiration time.Duration) *mRepositoryMockGetPresignedURLForUpload {
	if mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForUpload mock is already set by Set")
	}

	if mmGetPresignedURLForUpload.defaultExpectation == nil {
		mmGetPresignedURLForUpload.defaultExpectation = &RepositoryMockGetPresignedURLForUploadExpectation{}
	}

	if mmGetPresignedURLForUpload.defaultExpectation.paramPtrs != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForUpload mock is already set by ExpectParams functions")
	}

	mmGetPresignedURLForUpload.defaultExpectation.params = &RepositoryMockGetPresignedURLForUploadParams{ctx, namespaceUUID, objectUUID, filename, urlExpiration}
	mmGetPresignedURLForUpload.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPresignedURLForUpload.expectations {
		if minimock.Equal(e.params, mmGetPresignedURLForUpload.defaultExpectation.params) {
			mmGetPresignedURLForUpload.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPresignedURLForUpload.defaultExpectation.params)
		}
	}

	return mmGetPresignedURLForUpload
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetPresignedURLForUpload
func (mmGetPresignedURLForUpload *mRepositoryMockGetPresignedURLForUpload) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetPresignedURLForUpload {
	if mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForUpload mock is already set by Set")
	}

	if mmGetPresignedURLForUpload.defaultExpectation == nil {
		mmGetPresignedURLForUpload.defaultExpectation = &RepositoryMockGetPresignedURLForUploadExpectation{}
	}

	if mmGetPresignedURLForUpload.defaultExpectation.params != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForUpload mock is already set by Expect")
	}

	if mmGetPresignedURLForUpload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForUpload.defaultExpectation.paramPtrs = &RepositoryMockGetPresignedURLForUploadParamPtrs{}
	}
	mmGetPresignedURLForUpload.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPresignedURLForUpload.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPresignedURLForUpload
}

// ExpectNamespaceUUIDParam2 sets up expected param namespaceUUID for Repository.GetPresignedURLForUpload
func (mmGetPresignedURLForUpload *mRepositoryMockGetPresignedURLForUpload) ExpectNamespaceUUIDParam2(namespaceUUID types.NamespaceUIDType) *mRepositoryMockGetPresignedURLForUpload {
	if mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForUpload mock is already set by Set")
	}

	if mmGetPresignedURLForUpload.defaultExpectation == nil {
		mmGetPresignedURLForUpload.defaultExpectation = &RepositoryMockGetPresignedURLForUploadExpectation{}
	}

	if mmGetPresignedURLForUpload.defaultExpectation.params != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForUpload mock is already set by Expect")
	}

	if mmGetPresignedURLForUpload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForUpload.defaultExpectation.paramPtrs = &RepositoryMockGetPresignedURLForUploadParamPtrs{}
	}
	mmGetPresignedURLForUpload.defaultExpectation.paramPtrs.namespaceUUID = &namespaceUUID
	mmGetPresignedURLForUpload.defaultExpectation.expectationOrigins.originNamespaceUUID = minimock.CallerInfo(1)

	return mmGetPresignedURLForUpload
}

// ExpectObjectUUIDParam3 sets up expected param objectUUID for Repository.GetPresignedURLForUpload
func (mmGetPresignedURLForUpload *mRepositoryMockGetPresignedURLForUpload) ExpectObjectUUIDParam3(objectUUID types.ObjectUIDType) *mRepositoryMockGetPresignedURLForUpload {
	if mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForUpload mock is already set by Set")
	}

	if mmGetPresignedURLForUpload.defaultExpectation == nil {
		mmGetPresignedURLForUpload.defaultExpectation = &RepositoryMockGetPresignedURLForUploadExpectation{}
	}

	if mmGetPresignedURLForUpload.defaultExpectation.params != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForUpload mock is already set by Expect")
	}

	if mmGetPresignedURLForUpload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForUpload.defaultExpectation.paramPtrs = &RepositoryMockGetPresignedURLForUploadParamPtrs{}
	}
	mmGetPresignedURLForUpload.defaultExpectation.paramPtrs.objectUUID = &objectUUID
	mmGetPresignedURLForUpload.defaultExpectation.expectationOrigins.originObjectUUID = minimock.CallerInfo(1)

	return mmGetPresignedURLForUpload
}

// ExpectFilenameParam4 sets up expected param filename for Repository.GetPresignedURLForUpload
func (mmGetPresignedURLForUpload *mRepositoryMockGetPresignedURLForUpload) ExpectFilenameParam4(filename string) *mRepositoryMockGetPresignedURLForUpload {
	if mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForUpload mock is already set by Set")
	}

	if mmGetPresignedURLForUpload.defaultExpectation == nil {
		mmGetPresignedURLForUpload.defaultExpectation = &RepositoryMockGetPresignedURLForUploadExpectation{}
	}

	if mmGetPresignedURLForUpload.defaultExpectation.params != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForUpload mock is already set by Expect")
	}

	if mmGetPresignedURLForUpload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForUpload.defaultExpectation.paramPtrs = &RepositoryMockGetPresignedURLForUploadParamPtrs{}
	}
	mmGetPresignedURLForUpload.defaultExpectation.paramPtrs.filename = &filename
	mmGetPresignedURLForUpload.defaultExpectation.expectationOrigins.originFilename = minimock.CallerInfo(1)

	return mmGetPresignedURLForUpload
}

// ExpectUrlExpirationParam5 sets up expected param urlExpiration for Repository.GetPresignedURLForUpload
func (mmGetPresignedURLForUpload *mRepositoryMockGetPresignedURLForUpload) ExpectUrlExpirationParam5(urlExpiration time.Duration) *mRepositoryMockGetPresignedURLForUpload {
	if mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForUpload mock is already set by Set")
	}

	if mmGetPresignedURLForUpload.defaultExpectation == nil {
		mmGetPresignedURLForUpload.defaultExpectation = &RepositoryMockGetPresignedURLForUploadExpectation{}
	}

	if mmGetPresignedURLForUpload.defaultExpectation.params != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForUpload mock is already set by Expect")
	}

	if mmGetPresignedURLForUpload.defaultExpectation.paramPtrs == nil {
		mmGetPresignedURLForUpload.defaultExpectation.paramPtrs = &RepositoryMockGetPresignedURLForUploadParamPtrs{}
	}
	mmGetPresignedURLForUpload.defaultExpectation.paramPtrs.urlExpiration = &urlExpiration
	mmGetPresignedURLForUpload.defaultExpectation.expectationOrigins.originUrlExpiration = minimock.CallerInfo(1)

	return mmGetPresignedURLForUpload
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetPresignedURLForUpload
func (mmGetPresignedURLForUpload *mRepositoryMockGetPresignedURLForUpload) Inspect(f func(ctx context.Context, namespaceUUID types.NamespaceUIDType, objectUUID types.ObjectUIDType, filename string, urlExpiration time.Duration)) *mRepositoryMockGetPresignedURLForUpload {
	if mmGetPresignedURLForUpload.mock.inspectFuncGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetPresignedURLForUpload")
	}

	mmGetPresignedURLForUpload.mock.inspectFuncGetPresignedURLForUpload = f

	return mmGetPresignedURLForUpload
}

// Return sets up results that will be returned by Repository.GetPresignedURLForUpload
func (mmGetPresignedURLForUpload *mRepositoryMockGetPresignedURLForUpload) Return(up1 *url.URL, err error) *RepositoryMock {
	if mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForUpload mock is already set by Set")
	}

	if mmGetPresignedURLForUpload.defaultExpectation == nil {
		mmGetPresignedURLForUpload.defaultExpectation = &RepositoryMockGetPresignedURLForUploadExpectation{mock: mmGetPresignedURLForUpload.mock}
	}
	mmGetPresignedURLForUpload.defaultExpectation.results = &RepositoryMockGetPresignedURLForUploadResults{up1, err}
	mmGetPresignedURLForUpload.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPresignedURLForUpload.mock
}

// Set uses given function f to mock the Repository.GetPresignedURLForUpload method
func (mmGetPresignedURLForUpload *mRepositoryMockGetPresignedURLForUpload) Set(f func(ctx context.Context, namespaceUUID types.NamespaceUIDType, objectUUID types.ObjectUIDType, filename string, urlExpiration time.Duration) (up1 *url.URL, err error)) *RepositoryMock {
	if mmGetPresignedURLForUpload.defaultExpectation != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("Default expectation is already set for the Repository.GetPresignedURLForUpload method")
	}

	if len(mmGetPresignedURLForUpload.expectations) > 0 {
		mmGetPresignedURLForUpload.mock.t.Fatalf("Some expectations are already set for the Repository.GetPresignedURLForUpload method")
	}

	mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload = f
	mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUploadOrigin = minimock.CallerInfo(1)
	return mmGetPresignedURLForUpload.mock
}

// When sets expectation for the Repository.GetPresignedURLForUpload which will trigger the result defined by the following
// Then helper
func (mmGetPresignedURLForUpload *mRepositoryMockGetPresignedURLForUpload) When(ctx context.Context, namespaceUUID types.NamespaceUIDType, objectUUID types.ObjectUIDType, filename string, urlExpiration time.Duration) *RepositoryMockGetPresignedURLForUploadExpectation {
	if mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.mock.t.Fatalf("RepositoryMock.GetPresignedURLForUpload mock is already set by Set")
	}

	expectation := &RepositoryMockGetPresignedURLForUploadExpectation{
		mock:               mmGetPresignedURLForUpload.mock,
		params:             &RepositoryMockGetPresignedURLForUploadParams{ctx, namespaceUUID, objectUUID, filename, urlExpiration},
		expectationOrigins: RepositoryMockGetPresignedURLForUploadExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPresignedURLForUpload.expectations = append(mmGetPresignedURLForUpload.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetPresignedURLForUpload return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetPresignedURLForUploadExpectation) Then(up1 *url.URL, err error) *RepositoryMock {
	e.results = &RepositoryMockGetPresignedURLForUploadResults{up1, err}
	return e.mock
}

// Times sets number of times Repository.GetPresignedURLForUpload should be invoked
func (mmGetPresignedURLForUpload *mRepositoryMockGetPresignedURLForUpload) Times(n uint64) *mRepositoryMockGetPresignedURLForUpload {
	if n == 0 {
		mmGetPresignedURLForUpload.mock.t.Fatalf("Times of RepositoryMock.GetPresignedURLForUpload mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPresignedURLForUpload.expectedInvocations, n)
	mmGetPresignedURLForUpload.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPresignedURLForUpload
}

func (mmGetPresignedURLForUpload *mRepositoryMockGetPresignedURLForUpload) invocationsDone() bool {
	if len(mmGetPresignedURLForUpload.expectations) == 0 && mmGetPresignedURLForUpload.defaultExpectation == nil && mmGetPresignedURLForUpload.mock.funcGetPresignedURLForUpload == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPresignedURLForUpload.mock.afterGetPresignedURLForUploadCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPresignedURLForUpload.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPresignedURLForUpload implements mm_repository.Repository
func (mmGetPresignedURLForUpload *RepositoryMock) GetPresignedURLForUpload(ctx context.Context, namespaceUUID types.NamespaceUIDType, objectUUID types.ObjectUIDType, filename string, urlExpiration time.Duration) (up1 *url.URL, err error) {
	mm_atomic.AddUint64(&mmGetPresignedURLForUpload.beforeGetPresignedURLForUploadCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPresignedURLForUpload.afterGetPresignedURLForUploadCounter, 1)

	mmGetPresignedURLForUpload.t.Helper()

	if mmGetPresignedURLForUpload.inspectFuncGetPresignedURLForUpload != nil {
		mmGetPresignedURLForUpload.inspectFuncGetPresignedURLForUpload(ctx, namespaceUUID, objectUUID, filename, urlExpiration)
	}

	mm_params := RepositoryMockGetPresignedURLForUploadParams{ctx, namespaceUUID, objectUUID, filename, urlExpiration}

	// Record call args
	mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.mutex.Lock()
	mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.callArgs = append(mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.callArgs, &mm_params)
	mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.mutex.Unlock()

	for _, e := range mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.params
		mm_want_ptrs := mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetPresignedURLForUploadParams{ctx, namespaceUUID, objectUUID, filename, urlExpiration}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPresignedURLForUpload.t.Errorf("RepositoryMock.GetPresignedURLForUpload got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.namespaceUUID != nil && !minimock.Equal(*mm_want_ptrs.namespaceUUID, mm_got.namespaceUUID) {
				mmGetPresignedURLForUpload.t.Errorf("RepositoryMock.GetPresignedURLForUpload got unexpected parameter namespaceUUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.expectationOrigins.originNamespaceUUID, *mm_want_ptrs.namespaceUUID, mm_got.namespaceUUID, minimock.Diff(*mm_want_ptrs.namespaceUUID, mm_got.namespaceUUID))
			}

			if mm_want_ptrs.objectUUID != nil && !minimock.Equal(*mm_want_ptrs.objectUUID, mm_got.objectUUID) {
				mmGetPresignedURLForUpload.t.Errorf("RepositoryMock.GetPresignedURLForUpload got unexpected parameter objectUUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.expectationOrigins.originObjectUUID, *mm_want_ptrs.objectUUID, mm_got.objectUUID, minimock.Diff(*mm_want_ptrs.objectUUID, mm_got.objectUUID))
			}

			if mm_want_ptrs.filename != nil && !minimock.Equal(*mm_want_ptrs.filename, mm_got.filename) {
				mmGetPresignedURLForUpload.t.Errorf("RepositoryMock.GetPresignedURLForUpload got unexpected parameter filename, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.expectationOrigins.originFilename, *mm_want_ptrs.filename, mm_got.filename, minimock.Diff(*mm_want_ptrs.filename, mm_got.filename))
			}

			if mm_want_ptrs.urlExpiration != nil && !minimock.Equal(*mm_want_ptrs.urlExpiration, mm_got.urlExpiration) {
				mmGetPresignedURLForUpload.t.Errorf("RepositoryMock.GetPresignedURLForUpload got unexpected parameter urlExpiration, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.expectationOrigins.originUrlExpiration, *mm_want_ptrs.urlExpiration, mm_got.urlExpiration, minimock.Diff(*mm_want_ptrs.urlExpiration, mm_got.urlExpiration))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPresignedURLForUpload.t.Errorf("RepositoryMock.GetPresignedURLForUpload got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPresignedURLForUpload.GetPresignedURLForUploadMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPresignedURLForUpload.t.Fatal("No results are set for the RepositoryMock.GetPresignedURLForUpload")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetPresignedURLForUpload.funcGetPresignedURLForUpload != nil {
		return mmGetPresignedURLForUpload.funcGetPresignedURLForUpload(ctx, namespaceUUID, objectUUID, filename, urlExpiration)
	}
	mmGetPresignedURLForUpload.t.Fatalf("Unexpected call to RepositoryMock.GetPresignedURLForUpload. %v %v %v %v %v", ctx, namespaceUUID, objectUUID, filename, urlExpiration)
	return
}

// GetPresignedURLForUploadAfterCounter returns a count of finished RepositoryMock.GetPresignedURLForUpload invocations
func (mmGetPresignedURLForUpload *RepositoryMock) GetPresignedURLForUploadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPresignedURLForUpload.afterGetPresignedURLForUploadCounter)
}

// GetPresignedURLForUploadBeforeCounter returns a count of RepositoryMock.GetPresignedURLForUpload invocations
func (mmGetPresignedURLForUpload *RepositoryMock) GetPresignedURLForUploadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPresignedURLForUpload.beforeGetPresignedURLForUploadCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetPresignedURLForUpload.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPresignedURLForUpload *mRepositoryMockGetPresignedURLForUpload) Calls() []*RepositoryMockGetPresignedURLForUploadParams {
	mmGetPresignedURLForUpload.mutex.RLock()

	argCopy := make([]*RepositoryMockGetPresignedURLForUploadParams, len(mmGetPresignedURLForUpload.callArgs))
	copy(argCopy, mmGetPresignedURLForUpload.callArgs)

	mmGetPresignedURLForUpload.mutex.RUnlock()

	return argCopy
}

// MinimockGetPresignedURLForUploadDone returns true if the count of the GetPresignedURLForUpload invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetPresignedURLForUploadDone() bool {
	if m.GetPresignedURLForUploadMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPresignedURLForUploadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPresignedURLForUploadMock.invocationsDone()
}

// MinimockGetPresignedURLForUploadInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetPresignedURLForUploadInspect() {
	for _, e := range m.GetPresignedURLForUploadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetPresignedURLForUpload at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPresignedURLForUploadCounter := mm_atomic.LoadUint64(&m.afterGetPresignedURLForUploadCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPresignedURLForUploadMock.defaultExpectation != nil && afterGetPresignedURLForUploadCounter < 1 {
		if m.GetPresignedURLForUploadMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetPresignedURLForUpload at\n%s", m.GetPresignedURLForUploadMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetPresignedURLForUpload at\n%s with params: %#v", m.GetPresignedURLForUploadMock.defaultExpectation.expectationOrigins.origin, *m.GetPresignedURLForUploadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPresignedURLForUpload != nil && afterGetPresignedURLForUploadCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetPresignedURLForUpload at\n%s", m.funcGetPresignedURLForUploadOrigin)
	}

	if !m.GetPresignedURLForUploadMock.invocationsDone() && afterGetPresignedURLForUploadCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetPresignedURLForUpload at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPresignedURLForUploadMock.expectedInvocations), m.GetPresignedURLForUploadMock.expectedInvocationsOrigin, afterGetPresignedURLForUploadCounter)
	}
}

type mRepositoryMockGetRepositoryTag struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetRepositoryTagExpectation
	expectations       []*RepositoryMockGetRepositoryTagExpectation

	callArgs []*RepositoryMockGetRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetRepositoryTagExpectation specifies expectation struct of the Repository.GetRepositoryTag
type RepositoryMockGetRepositoryTagExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetRepositoryTagParams
	paramPtrs          *RepositoryMockGetRepositoryTagParamPtrs
	expectationOrigins RepositoryMockGetRepositoryTagExpectationOrigins
	results            *RepositoryMockGetRepositoryTagResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetRepositoryTagParams contains parameters of the Repository.GetRepositoryTag
type RepositoryMockGetRepositoryTagParams struct {
	ctx context.Context
	r1  utils.RepositoryTagName
}

// RepositoryMockGetRepositoryTagParamPtrs contains pointers to parameters of the Repository.GetRepositoryTag
type RepositoryMockGetRepositoryTagParamPtrs struct {
	ctx *context.Context
	r1  *utils.RepositoryTagName
}

// RepositoryMockGetRepositoryTagResults contains results of the Repository.GetRepositoryTag
type RepositoryMockGetRepositoryTagResults struct {
	tp1 *types.Tag
	err error
}

// RepositoryMockGetRepositoryTagOrigins contains origins of expectations of the Repository.GetRepositoryTag
type RepositoryMockGetRepositoryTagExpectationOrigins struct {
	origin    string
	originCtx string
	originR1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) Optional() *mRepositoryMockGetRepositoryTag {
	mmGetRepositoryTag.optional = true
	return mmGetRepositoryTag
}

// Expect sets up expected params for Repository.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) Expect(ctx context.Context, r1 utils.RepositoryTagName) *mRepositoryMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by ExpectParams functions")
	}

	mmGetRepositoryTag.defaultExpectation.params = &RepositoryMockGetRepositoryTagParams{ctx, r1}
	mmGetRepositoryTag.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetRepositoryTag.expectations {
		if minimock.Equal(e.params, mmGetRepositoryTag.defaultExpectation.params) {
			mmGetRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRepositoryTag.defaultExpectation.params)
		}
	}

	return mmGetRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.params != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by Expect")
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmGetRepositoryTag.defaultExpectation.paramPtrs = &RepositoryMockGetRepositoryTagParamPtrs{}
	}
	mmGetRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetRepositoryTag.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetRepositoryTag
}

// ExpectR1Param2 sets up expected param r1 for Repository.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) ExpectR1Param2(r1 utils.RepositoryTagName) *mRepositoryMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.params != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by Expect")
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmGetRepositoryTag.defaultExpectation.paramPtrs = &RepositoryMockGetRepositoryTagParamPtrs{}
	}
	mmGetRepositoryTag.defaultExpectation.paramPtrs.r1 = &r1
	mmGetRepositoryTag.defaultExpectation.expectationOrigins.originR1 = minimock.CallerInfo(1)

	return mmGetRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) Inspect(f func(ctx context.Context, r1 utils.RepositoryTagName)) *mRepositoryMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.inspectFuncGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetRepositoryTag")
	}

	mmGetRepositoryTag.mock.inspectFuncGetRepositoryTag = f

	return mmGetRepositoryTag
}

// Return sets up results that will be returned by Repository.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) Return(tp1 *types.Tag, err error) *RepositoryMock {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryMockGetRepositoryTagExpectation{mock: mmGetRepositoryTag.mock}
	}
	mmGetRepositoryTag.defaultExpectation.results = &RepositoryMockGetRepositoryTagResults{tp1, err}
	mmGetRepositoryTag.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetRepositoryTag.mock
}

// Set uses given function f to mock the Repository.GetRepositoryTag method
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) Set(f func(ctx context.Context, r1 utils.RepositoryTagName) (tp1 *types.Tag, err error)) *RepositoryMock {
	if mmGetRepositoryTag.defaultExpectation != nil {
		mmGetRepositoryTag.mock.t.Fatalf("Default expectation is already set for the Repository.GetRepositoryTag method")
	}

	if len(mmGetRepositoryTag.expectations) > 0 {
		mmGetRepositoryTag.mock.t.Fatalf("Some expectations are already set for the Repository.GetRepositoryTag method")
	}

	mmGetRepositoryTag.mock.funcGetRepositoryTag = f
	mmGetRepositoryTag.mock.funcGetRepositoryTagOrigin = minimock.CallerInfo(1)
	return mmGetRepositoryTag.mock
}

// When sets expectation for the Repository.GetRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) When(ctx context.Context, r1 utils.RepositoryTagName) *RepositoryMockGetRepositoryTagExpectation {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by Set")
	}

	expectation := &RepositoryMockGetRepositoryTagExpectation{
		mock:               mmGetRepositoryTag.mock,
		params:             &RepositoryMockGetRepositoryTagParams{ctx, r1},
		expectationOrigins: RepositoryMockGetRepositoryTagExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetRepositoryTag.expectations = append(mmGetRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetRepositoryTag return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetRepositoryTagExpectation) Then(tp1 *types.Tag, err error) *RepositoryMock {
	e.results = &RepositoryMockGetRepositoryTagResults{tp1, err}
	return e.mock
}

// Times sets number of times Repository.GetRepositoryTag should be invoked
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) Times(n uint64) *mRepositoryMockGetRepositoryTag {
	if n == 0 {
		mmGetRepositoryTag.mock.t.Fatalf("Times of RepositoryMock.GetRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRepositoryTag.expectedInvocations, n)
	mmGetRepositoryTag.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetRepositoryTag
}

func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) invocationsDone() bool {
	if len(mmGetRepositoryTag.expectations) == 0 && mmGetRepositoryTag.defaultExpectation == nil && mmGetRepositoryTag.mock.funcGetRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRepositoryTag.mock.afterGetRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRepositoryTag implements mm_repository.Repository
func (mmGetRepositoryTag *RepositoryMock) GetRepositoryTag(ctx context.Context, r1 utils.RepositoryTagName) (tp1 *types.Tag, err error) {
	mm_atomic.AddUint64(&mmGetRepositoryTag.beforeGetRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRepositoryTag.afterGetRepositoryTagCounter, 1)

	mmGetRepositoryTag.t.Helper()

	if mmGetRepositoryTag.inspectFuncGetRepositoryTag != nil {
		mmGetRepositoryTag.inspectFuncGetRepositoryTag(ctx, r1)
	}

	mm_params := RepositoryMockGetRepositoryTagParams{ctx, r1}

	// Record call args
	mmGetRepositoryTag.GetRepositoryTagMock.mutex.Lock()
	mmGetRepositoryTag.GetRepositoryTagMock.callArgs = append(mmGetRepositoryTag.GetRepositoryTagMock.callArgs, &mm_params)
	mmGetRepositoryTag.GetRepositoryTagMock.mutex.Unlock()

	for _, e := range mmGetRepositoryTag.GetRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp1, e.results.err
		}
	}

	if mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetRepositoryTagParams{ctx, r1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetRepositoryTag.t.Errorf("RepositoryMock.GetRepositoryTag got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.r1 != nil && !minimock.Equal(*mm_want_ptrs.r1, mm_got.r1) {
				mmGetRepositoryTag.t.Errorf("RepositoryMock.GetRepositoryTag got unexpected parameter r1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.expectationOrigins.originR1, *mm_want_ptrs.r1, mm_got.r1, minimock.Diff(*mm_want_ptrs.r1, mm_got.r1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRepositoryTag.t.Errorf("RepositoryMock.GetRepositoryTag got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRepositoryTag.t.Fatal("No results are set for the RepositoryMock.GetRepositoryTag")
		}
		return (*mm_results).tp1, (*mm_results).err
	}
	if mmGetRepositoryTag.funcGetRepositoryTag != nil {
		return mmGetRepositoryTag.funcGetRepositoryTag(ctx, r1)
	}
	mmGetRepositoryTag.t.Fatalf("Unexpected call to RepositoryMock.GetRepositoryTag. %v %v", ctx, r1)
	return
}

// GetRepositoryTagAfterCounter returns a count of finished RepositoryMock.GetRepositoryTag invocations
func (mmGetRepositoryTag *RepositoryMock) GetRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRepositoryTag.afterGetRepositoryTagCounter)
}

// GetRepositoryTagBeforeCounter returns a count of RepositoryMock.GetRepositoryTag invocations
func (mmGetRepositoryTag *RepositoryMock) GetRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRepositoryTag.beforeGetRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) Calls() []*RepositoryMockGetRepositoryTagParams {
	mmGetRepositoryTag.mutex.RLock()

	argCopy := make([]*RepositoryMockGetRepositoryTagParams, len(mmGetRepositoryTag.callArgs))
	copy(argCopy, mmGetRepositoryTag.callArgs)

	mmGetRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockGetRepositoryTagDone returns true if the count of the GetRepositoryTag invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetRepositoryTagDone() bool {
	if m.GetRepositoryTagMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRepositoryTagMock.invocationsDone()
}

// MinimockGetRepositoryTagInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetRepositoryTagInspect() {
	for _, e := range m.GetRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetRepositoryTag at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterGetRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRepositoryTagMock.defaultExpectation != nil && afterGetRepositoryTagCounter < 1 {
		if m.GetRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetRepositoryTag at\n%s", m.GetRepositoryTagMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetRepositoryTag at\n%s with params: %#v", m.GetRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *m.GetRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRepositoryTag != nil && afterGetRepositoryTagCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetRepositoryTag at\n%s", m.funcGetRepositoryTagOrigin)
	}

	if !m.GetRepositoryTagMock.invocationsDone() && afterGetRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetRepositoryTag at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetRepositoryTagMock.expectedInvocations), m.GetRepositoryTagMock.expectedInvocationsOrigin, afterGetRepositoryTagCounter)
	}
}

type mRepositoryMockGetSourceByFileUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetSourceByFileUIDExpectation
	expectations       []*RepositoryMockGetSourceByFileUIDExpectation

	callArgs []*RepositoryMockGetSourceByFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetSourceByFileUIDExpectation specifies expectation struct of the Repository.GetSourceByFileUID
type RepositoryMockGetSourceByFileUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetSourceByFileUIDParams
	paramPtrs          *RepositoryMockGetSourceByFileUIDParamPtrs
	expectationOrigins RepositoryMockGetSourceByFileUIDExpectationOrigins
	results            *RepositoryMockGetSourceByFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetSourceByFileUIDParams contains parameters of the Repository.GetSourceByFileUID
type RepositoryMockGetSourceByFileUIDParams struct {
	ctx     context.Context
	fileUID types.FileUIDType
}

// RepositoryMockGetSourceByFileUIDParamPtrs contains pointers to parameters of the Repository.GetSourceByFileUID
type RepositoryMockGetSourceByFileUIDParamPtrs struct {
	ctx     *context.Context
	fileUID *types.FileUIDType
}

// RepositoryMockGetSourceByFileUIDResults contains results of the Repository.GetSourceByFileUID
type RepositoryMockGetSourceByFileUIDResults struct {
	sp1 *mm_repository.SourceMeta
	err error
}

// RepositoryMockGetSourceByFileUIDOrigins contains origins of expectations of the Repository.GetSourceByFileUID
type RepositoryMockGetSourceByFileUIDExpectationOrigins struct {
	origin        string
	originCtx     string
	originFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetSourceByFileUID *mRepositoryMockGetSourceByFileUID) Optional() *mRepositoryMockGetSourceByFileUID {
	mmGetSourceByFileUID.optional = true
	return mmGetSourceByFileUID
}

// Expect sets up expected params for Repository.GetSourceByFileUID
func (mmGetSourceByFileUID *mRepositoryMockGetSourceByFileUID) Expect(ctx context.Context, fileUID types.FileUIDType) *mRepositoryMockGetSourceByFileUID {
	if mmGetSourceByFileUID.mock.funcGetSourceByFileUID != nil {
		mmGetSourceByFileUID.mock.t.Fatalf("RepositoryMock.GetSourceByFileUID mock is already set by Set")
	}

	if mmGetSourceByFileUID.defaultExpectation == nil {
		mmGetSourceByFileUID.defaultExpectation = &RepositoryMockGetSourceByFileUIDExpectation{}
	}

	if mmGetSourceByFileUID.defaultExpectation.paramPtrs != nil {
		mmGetSourceByFileUID.mock.t.Fatalf("RepositoryMock.GetSourceByFileUID mock is already set by ExpectParams functions")
	}

	mmGetSourceByFileUID.defaultExpectation.params = &RepositoryMockGetSourceByFileUIDParams{ctx, fileUID}
	mmGetSourceByFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetSourceByFileUID.expectations {
		if minimock.Equal(e.params, mmGetSourceByFileUID.defaultExpectation.params) {
			mmGetSourceByFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSourceByFileUID.defaultExpectation.params)
		}
	}

	return mmGetSourceByFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetSourceByFileUID
func (mmGetSourceByFileUID *mRepositoryMockGetSourceByFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetSourceByFileUID {
	if mmGetSourceByFileUID.mock.funcGetSourceByFileUID != nil {
		mmGetSourceByFileUID.mock.t.Fatalf("RepositoryMock.GetSourceByFileUID mock is already set by Set")
	}

	if mmGetSourceByFileUID.defaultExpectation == nil {
		mmGetSourceByFileUID.defaultExpectation = &RepositoryMockGetSourceByFileUIDExpectation{}
	}

	if mmGetSourceByFileUID.defaultExpectation.params != nil {
		mmGetSourceByFileUID.mock.t.Fatalf("RepositoryMock.GetSourceByFileUID mock is already set by Expect")
	}

	if mmGetSourceByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetSourceByFileUID.defaultExpectation.paramPtrs = &RepositoryMockGetSourceByFileUIDParamPtrs{}
	}
	mmGetSourceByFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetSourceByFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetSourceByFileUID
}

// ExpectFileUIDParam2 sets up expected param fileUID for Repository.GetSourceByFileUID
func (mmGetSourceByFileUID *mRepositoryMockGetSourceByFileUID) ExpectFileUIDParam2(fileUID types.FileUIDType) *mRepositoryMockGetSourceByFileUID {
	if mmGetSourceByFileUID.mock.funcGetSourceByFileUID != nil {
		mmGetSourceByFileUID.mock.t.Fatalf("RepositoryMock.GetSourceByFileUID mock is already set by Set")
	}

	if mmGetSourceByFileUID.defaultExpectation == nil {
		mmGetSourceByFileUID.defaultExpectation = &RepositoryMockGetSourceByFileUIDExpectation{}
	}

	if mmGetSourceByFileUID.defaultExpectation.params != nil {
		mmGetSourceByFileUID.mock.t.Fatalf("RepositoryMock.GetSourceByFileUID mock is already set by Expect")
	}

	if mmGetSourceByFileUID.defaultExpectation.paramPtrs == nil {
		mmGetSourceByFileUID.defaultExpectation.paramPtrs = &RepositoryMockGetSourceByFileUIDParamPtrs{}
	}
	mmGetSourceByFileUID.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmGetSourceByFileUID.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmGetSourceByFileUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetSourceByFileUID
func (mmGetSourceByFileUID *mRepositoryMockGetSourceByFileUID) Inspect(f func(ctx context.Context, fileUID types.FileUIDType)) *mRepositoryMockGetSourceByFileUID {
	if mmGetSourceByFileUID.mock.inspectFuncGetSourceByFileUID != nil {
		mmGetSourceByFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetSourceByFileUID")
	}

	mmGetSourceByFileUID.mock.inspectFuncGetSourceByFileUID = f

	return mmGetSourceByFileUID
}

// Return sets up results that will be returned by Repository.GetSourceByFileUID
func (mmGetSourceByFileUID *mRepositoryMockGetSourceByFileUID) Return(sp1 *mm_repository.SourceMeta, err error) *RepositoryMock {
	if mmGetSourceByFileUID.mock.funcGetSourceByFileUID != nil {
		mmGetSourceByFileUID.mock.t.Fatalf("RepositoryMock.GetSourceByFileUID mock is already set by Set")
	}

	if mmGetSourceByFileUID.defaultExpectation == nil {
		mmGetSourceByFileUID.defaultExpectation = &RepositoryMockGetSourceByFileUIDExpectation{mock: mmGetSourceByFileUID.mock}
	}
	mmGetSourceByFileUID.defaultExpectation.results = &RepositoryMockGetSourceByFileUIDResults{sp1, err}
	mmGetSourceByFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetSourceByFileUID.mock
}

// Set uses given function f to mock the Repository.GetSourceByFileUID method
func (mmGetSourceByFileUID *mRepositoryMockGetSourceByFileUID) Set(f func(ctx context.Context, fileUID types.FileUIDType) (sp1 *mm_repository.SourceMeta, err error)) *RepositoryMock {
	if mmGetSourceByFileUID.defaultExpectation != nil {
		mmGetSourceByFileUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetSourceByFileUID method")
	}

	if len(mmGetSourceByFileUID.expectations) > 0 {
		mmGetSourceByFileUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetSourceByFileUID method")
	}

	mmGetSourceByFileUID.mock.funcGetSourceByFileUID = f
	mmGetSourceByFileUID.mock.funcGetSourceByFileUIDOrigin = minimock.CallerInfo(1)
	return mmGetSourceByFileUID.mock
}

// When sets expectation for the Repository.GetSourceByFileUID which will trigger the result defined by the following
// Then helper
func (mmGetSourceByFileUID *mRepositoryMockGetSourceByFileUID) When(ctx context.Context, fileUID types.FileUIDType) *RepositoryMockGetSourceByFileUIDExpectation {
	if mmGetSourceByFileUID.mock.funcGetSourceByFileUID != nil {
		mmGetSourceByFileUID.mock.t.Fatalf("RepositoryMock.GetSourceByFileUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetSourceByFileUIDExpectation{
		mock:               mmGetSourceByFileUID.mock,
		params:             &RepositoryMockGetSourceByFileUIDParams{ctx, fileUID},
		expectationOrigins: RepositoryMockGetSourceByFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetSourceByFileUID.expectations = append(mmGetSourceByFileUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetSourceByFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetSourceByFileUIDExpectation) Then(sp1 *mm_repository.SourceMeta, err error) *RepositoryMock {
	e.results = &RepositoryMockGetSourceByFileUIDResults{sp1, err}
	return e.mock
}

// Times sets number of times Repository.GetSourceByFileUID should be invoked
func (mmGetSourceByFileUID *mRepositoryMockGetSourceByFileUID) Times(n uint64) *mRepositoryMockGetSourceByFileUID {
	if n == 0 {
		mmGetSourceByFileUID.mock.t.Fatalf("Times of RepositoryMock.GetSourceByFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetSourceByFileUID.expectedInvocations, n)
	mmGetSourceByFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetSourceByFileUID
}

func (mmGetSourceByFileUID *mRepositoryMockGetSourceByFileUID) invocationsDone() bool {
	if len(mmGetSourceByFileUID.expectations) == 0 && mmGetSourceByFileUID.defaultExpectation == nil && mmGetSourceByFileUID.mock.funcGetSourceByFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetSourceByFileUID.mock.afterGetSourceByFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetSourceByFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetSourceByFileUID implements mm_repository.Repository
func (mmGetSourceByFileUID *RepositoryMock) GetSourceByFileUID(ctx context.Context, fileUID types.FileUIDType) (sp1 *mm_repository.SourceMeta, err error) {
	mm_atomic.AddUint64(&mmGetSourceByFileUID.beforeGetSourceByFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSourceByFileUID.afterGetSourceByFileUIDCounter, 1)

	mmGetSourceByFileUID.t.Helper()

	if mmGetSourceByFileUID.inspectFuncGetSourceByFileUID != nil {
		mmGetSourceByFileUID.inspectFuncGetSourceByFileUID(ctx, fileUID)
	}

	mm_params := RepositoryMockGetSourceByFileUIDParams{ctx, fileUID}

	// Record call args
	mmGetSourceByFileUID.GetSourceByFileUIDMock.mutex.Lock()
	mmGetSourceByFileUID.GetSourceByFileUIDMock.callArgs = append(mmGetSourceByFileUID.GetSourceByFileUIDMock.callArgs, &mm_params)
	mmGetSourceByFileUID.GetSourceByFileUIDMock.mutex.Unlock()

	for _, e := range mmGetSourceByFileUID.GetSourceByFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGetSourceByFileUID.GetSourceByFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSourceByFileUID.GetSourceByFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSourceByFileUID.GetSourceByFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetSourceByFileUID.GetSourceByFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetSourceByFileUIDParams{ctx, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetSourceByFileUID.t.Errorf("RepositoryMock.GetSourceByFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetSourceByFileUID.GetSourceByFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmGetSourceByFileUID.t.Errorf("RepositoryMock.GetSourceByFileUID got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetSourceByFileUID.GetSourceByFileUIDMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSourceByFileUID.t.Errorf("RepositoryMock.GetSourceByFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetSourceByFileUID.GetSourceByFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSourceByFileUID.GetSourceByFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSourceByFileUID.t.Fatal("No results are set for the RepositoryMock.GetSourceByFileUID")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGetSourceByFileUID.funcGetSourceByFileUID != nil {
		return mmGetSourceByFileUID.funcGetSourceByFileUID(ctx, fileUID)
	}
	mmGetSourceByFileUID.t.Fatalf("Unexpected call to RepositoryMock.GetSourceByFileUID. %v %v", ctx, fileUID)
	return
}

// GetSourceByFileUIDAfterCounter returns a count of finished RepositoryMock.GetSourceByFileUID invocations
func (mmGetSourceByFileUID *RepositoryMock) GetSourceByFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSourceByFileUID.afterGetSourceByFileUIDCounter)
}

// GetSourceByFileUIDBeforeCounter returns a count of RepositoryMock.GetSourceByFileUID invocations
func (mmGetSourceByFileUID *RepositoryMock) GetSourceByFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSourceByFileUID.beforeGetSourceByFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetSourceByFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSourceByFileUID *mRepositoryMockGetSourceByFileUID) Calls() []*RepositoryMockGetSourceByFileUIDParams {
	mmGetSourceByFileUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetSourceByFileUIDParams, len(mmGetSourceByFileUID.callArgs))
	copy(argCopy, mmGetSourceByFileUID.callArgs)

	mmGetSourceByFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetSourceByFileUIDDone returns true if the count of the GetSourceByFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetSourceByFileUIDDone() bool {
	if m.GetSourceByFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetSourceByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetSourceByFileUIDMock.invocationsDone()
}

// MinimockGetSourceByFileUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetSourceByFileUIDInspect() {
	for _, e := range m.GetSourceByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetSourceByFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetSourceByFileUIDCounter := mm_atomic.LoadUint64(&m.afterGetSourceByFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetSourceByFileUIDMock.defaultExpectation != nil && afterGetSourceByFileUIDCounter < 1 {
		if m.GetSourceByFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetSourceByFileUID at\n%s", m.GetSourceByFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetSourceByFileUID at\n%s with params: %#v", m.GetSourceByFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetSourceByFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSourceByFileUID != nil && afterGetSourceByFileUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetSourceByFileUID at\n%s", m.funcGetSourceByFileUIDOrigin)
	}

	if !m.GetSourceByFileUIDMock.invocationsDone() && afterGetSourceByFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetSourceByFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetSourceByFileUIDMock.expectedInvocations), m.GetSourceByFileUIDMock.expectedInvocationsOrigin, afterGetSourceByFileUIDCounter)
	}
}

type mRepositoryMockGetSourceTableAndUIDByFileUIDs struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetSourceTableAndUIDByFileUIDsExpectation
	expectations       []*RepositoryMockGetSourceTableAndUIDByFileUIDsExpectation

	callArgs []*RepositoryMockGetSourceTableAndUIDByFileUIDsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetSourceTableAndUIDByFileUIDsExpectation specifies expectation struct of the Repository.GetSourceTableAndUIDByFileUIDs
type RepositoryMockGetSourceTableAndUIDByFileUIDsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetSourceTableAndUIDByFileUIDsParams
	paramPtrs          *RepositoryMockGetSourceTableAndUIDByFileUIDsParamPtrs
	expectationOrigins RepositoryMockGetSourceTableAndUIDByFileUIDsExpectationOrigins
	results            *RepositoryMockGetSourceTableAndUIDByFileUIDsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetSourceTableAndUIDByFileUIDsParams contains parameters of the Repository.GetSourceTableAndUIDByFileUIDs
type RepositoryMockGetSourceTableAndUIDByFileUIDsParams struct {
	ctx   context.Context
	files []mm_repository.KnowledgeBaseFileModel
}

// RepositoryMockGetSourceTableAndUIDByFileUIDsParamPtrs contains pointers to parameters of the Repository.GetSourceTableAndUIDByFileUIDs
type RepositoryMockGetSourceTableAndUIDByFileUIDsParamPtrs struct {
	ctx   *context.Context
	files *[]mm_repository.KnowledgeBaseFileModel
}

// RepositoryMockGetSourceTableAndUIDByFileUIDsResults contains results of the Repository.GetSourceTableAndUIDByFileUIDs
type RepositoryMockGetSourceTableAndUIDByFileUIDsResults struct {
	m1 map[types.FileUIDType]struct {
		SourceTable string
		SourceUID   types.SourceUIDType
	}
	err error
}

// RepositoryMockGetSourceTableAndUIDByFileUIDsOrigins contains origins of expectations of the Repository.GetSourceTableAndUIDByFileUIDs
type RepositoryMockGetSourceTableAndUIDByFileUIDsExpectationOrigins struct {
	origin      string
	originCtx   string
	originFiles string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryMockGetSourceTableAndUIDByFileUIDs) Optional() *mRepositoryMockGetSourceTableAndUIDByFileUIDs {
	mmGetSourceTableAndUIDByFileUIDs.optional = true
	return mmGetSourceTableAndUIDByFileUIDs
}

// Expect sets up expected params for Repository.GetSourceTableAndUIDByFileUIDs
func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryMockGetSourceTableAndUIDByFileUIDs) Expect(ctx context.Context, files []mm_repository.KnowledgeBaseFileModel) *mRepositoryMockGetSourceTableAndUIDByFileUIDs {
	if mmGetSourceTableAndUIDByFileUIDs.mock.funcGetSourceTableAndUIDByFileUIDs != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("RepositoryMock.GetSourceTableAndUIDByFileUIDs mock is already set by Set")
	}

	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation == nil {
		mmGetSourceTableAndUIDByFileUIDs.defaultExpectation = &RepositoryMockGetSourceTableAndUIDByFileUIDsExpectation{}
	}

	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.paramPtrs != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("RepositoryMock.GetSourceTableAndUIDByFileUIDs mock is already set by ExpectParams functions")
	}

	mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.params = &RepositoryMockGetSourceTableAndUIDByFileUIDsParams{ctx, files}
	mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetSourceTableAndUIDByFileUIDs.expectations {
		if minimock.Equal(e.params, mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.params) {
			mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.params)
		}
	}

	return mmGetSourceTableAndUIDByFileUIDs
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetSourceTableAndUIDByFileUIDs
func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryMockGetSourceTableAndUIDByFileUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetSourceTableAndUIDByFileUIDs {
	if mmGetSourceTableAndUIDByFileUIDs.mock.funcGetSourceTableAndUIDByFileUIDs != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("RepositoryMock.GetSourceTableAndUIDByFileUIDs mock is already set by Set")
	}

	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation == nil {
		mmGetSourceTableAndUIDByFileUIDs.defaultExpectation = &RepositoryMockGetSourceTableAndUIDByFileUIDsExpectation{}
	}

	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.params != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("RepositoryMock.GetSourceTableAndUIDByFileUIDs mock is already set by Expect")
	}

	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.paramPtrs == nil {
		mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.paramPtrs = &RepositoryMockGetSourceTableAndUIDByFileUIDsParamPtrs{}
	}
	mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetSourceTableAndUIDByFileUIDs
}

// ExpectFilesParam2 sets up expected param files for Repository.GetSourceTableAndUIDByFileUIDs
func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryMockGetSourceTableAndUIDByFileUIDs) ExpectFilesParam2(files []mm_repository.KnowledgeBaseFileModel) *mRepositoryMockGetSourceTableAndUIDByFileUIDs {
	if mmGetSourceTableAndUIDByFileUIDs.mock.funcGetSourceTableAndUIDByFileUIDs != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("RepositoryMock.GetSourceTableAndUIDByFileUIDs mock is already set by Set")
	}

	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation == nil {
		mmGetSourceTableAndUIDByFileUIDs.defaultExpectation = &RepositoryMockGetSourceTableAndUIDByFileUIDsExpectation{}
	}

	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.params != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("RepositoryMock.GetSourceTableAndUIDByFileUIDs mock is already set by Expect")
	}

	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.paramPtrs == nil {
		mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.paramPtrs = &RepositoryMockGetSourceTableAndUIDByFileUIDsParamPtrs{}
	}
	mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.paramPtrs.files = &files
	mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.expectationOrigins.originFiles = minimock.CallerInfo(1)

	return mmGetSourceTableAndUIDByFileUIDs
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetSourceTableAndUIDByFileUIDs
func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryMockGetSourceTableAndUIDByFileUIDs) Inspect(f func(ctx context.Context, files []mm_repository.KnowledgeBaseFileModel)) *mRepositoryMockGetSourceTableAndUIDByFileUIDs {
	if mmGetSourceTableAndUIDByFileUIDs.mock.inspectFuncGetSourceTableAndUIDByFileUIDs != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetSourceTableAndUIDByFileUIDs")
	}

	mmGetSourceTableAndUIDByFileUIDs.mock.inspectFuncGetSourceTableAndUIDByFileUIDs = f

	return mmGetSourceTableAndUIDByFileUIDs
}

// Return sets up results that will be returned by Repository.GetSourceTableAndUIDByFileUIDs
func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryMockGetSourceTableAndUIDByFileUIDs) Return(m1 map[types.FileUIDType]struct {
	SourceTable string
	SourceUID   types.SourceUIDType
}, err error) *RepositoryMock {
	if mmGetSourceTableAndUIDByFileUIDs.mock.funcGetSourceTableAndUIDByFileUIDs != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("RepositoryMock.GetSourceTableAndUIDByFileUIDs mock is already set by Set")
	}

	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation == nil {
		mmGetSourceTableAndUIDByFileUIDs.defaultExpectation = &RepositoryMockGetSourceTableAndUIDByFileUIDsExpectation{mock: mmGetSourceTableAndUIDByFileUIDs.mock}
	}
	mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.results = &RepositoryMockGetSourceTableAndUIDByFileUIDsResults{m1, err}
	mmGetSourceTableAndUIDByFileUIDs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetSourceTableAndUIDByFileUIDs.mock
}

// Set uses given function f to mock the Repository.GetSourceTableAndUIDByFileUIDs method
func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryMockGetSourceTableAndUIDByFileUIDs) Set(f func(ctx context.Context, files []mm_repository.KnowledgeBaseFileModel) (m1 map[types.FileUIDType]struct {
	SourceTable string
	SourceUID   types.SourceUIDType
}, err error)) *RepositoryMock {
	if mmGetSourceTableAndUIDByFileUIDs.defaultExpectation != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("Default expectation is already set for the Repository.GetSourceTableAndUIDByFileUIDs method")
	}

	if len(mmGetSourceTableAndUIDByFileUIDs.expectations) > 0 {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("Some expectations are already set for the Repository.GetSourceTableAndUIDByFileUIDs method")
	}

	mmGetSourceTableAndUIDByFileUIDs.mock.funcGetSourceTableAndUIDByFileUIDs = f
	mmGetSourceTableAndUIDByFileUIDs.mock.funcGetSourceTableAndUIDByFileUIDsOrigin = minimock.CallerInfo(1)
	return mmGetSourceTableAndUIDByFileUIDs.mock
}

// When sets expectation for the Repository.GetSourceTableAndUIDByFileUIDs which will trigger the result defined by the following
// Then helper
func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryMockGetSourceTableAndUIDByFileUIDs) When(ctx context.Context, files []mm_repository.KnowledgeBaseFileModel) *RepositoryMockGetSourceTableAndUIDByFileUIDsExpectation {
	if mmGetSourceTableAndUIDByFileUIDs.mock.funcGetSourceTableAndUIDByFileUIDs != nil {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("RepositoryMock.GetSourceTableAndUIDByFileUIDs mock is already set by Set")
	}

	expectation := &RepositoryMockGetSourceTableAndUIDByFileUIDsExpectation{
		mock:               mmGetSourceTableAndUIDByFileUIDs.mock,
		params:             &RepositoryMockGetSourceTableAndUIDByFileUIDsParams{ctx, files},
		expectationOrigins: RepositoryMockGetSourceTableAndUIDByFileUIDsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetSourceTableAndUIDByFileUIDs.expectations = append(mmGetSourceTableAndUIDByFileUIDs.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetSourceTableAndUIDByFileUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetSourceTableAndUIDByFileUIDsExpectation) Then(m1 map[types.FileUIDType]struct {
	SourceTable string
	SourceUID   types.SourceUIDType
}, err error) *RepositoryMock {
	e.results = &RepositoryMockGetSourceTableAndUIDByFileUIDsResults{m1, err}
	return e.mock
}

// Times sets number of times Repository.GetSourceTableAndUIDByFileUIDs should be invoked
func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryMockGetSourceTableAndUIDByFileUIDs) Times(n uint64) *mRepositoryMockGetSourceTableAndUIDByFileUIDs {
	if n == 0 {
		mmGetSourceTableAndUIDByFileUIDs.mock.t.Fatalf("Times of RepositoryMock.GetSourceTableAndUIDByFileUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetSourceTableAndUIDByFileUIDs.expectedInvocations, n)
	mmGetSourceTableAndUIDByFileUIDs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetSourceTableAndUIDByFileUIDs
}

func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryMockGetSourceTableAndUIDByFileUIDs) invocationsDone() bool {
	if len(mmGetSourceTableAndUIDByFileUIDs.expectations) == 0 && mmGetSourceTableAndUIDByFileUIDs.defaultExpectation == nil && mmGetSourceTableAndUIDByFileUIDs.mock.funcGetSourceTableAndUIDByFileUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetSourceTableAndUIDByFileUIDs.mock.afterGetSourceTableAndUIDByFileUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetSourceTableAndUIDByFileUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetSourceTableAndUIDByFileUIDs implements mm_repository.Repository
func (mmGetSourceTableAndUIDByFileUIDs *RepositoryMock) GetSourceTableAndUIDByFileUIDs(ctx context.Context, files []mm_repository.KnowledgeBaseFileModel) (m1 map[types.FileUIDType]struct {
	SourceTable string
	SourceUID   types.SourceUIDType
}, err error) {
	mm_atomic.AddUint64(&mmGetSourceTableAndUIDByFileUIDs.beforeGetSourceTableAndUIDByFileUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSourceTableAndUIDByFileUIDs.afterGetSourceTableAndUIDByFileUIDsCounter, 1)

	mmGetSourceTableAndUIDByFileUIDs.t.Helper()

	if mmGetSourceTableAndUIDByFileUIDs.inspectFuncGetSourceTableAndUIDByFileUIDs != nil {
		mmGetSourceTableAndUIDByFileUIDs.inspectFuncGetSourceTableAndUIDByFileUIDs(ctx, files)
	}

	mm_params := RepositoryMockGetSourceTableAndUIDByFileUIDsParams{ctx, files}

	// Record call args
	mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.mutex.Lock()
	mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.callArgs = append(mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.callArgs, &mm_params)
	mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.mutex.Unlock()

	for _, e := range mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetSourceTableAndUIDByFileUIDsParams{ctx, files}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetSourceTableAndUIDByFileUIDs.t.Errorf("RepositoryMock.GetSourceTableAndUIDByFileUIDs got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.files != nil && !minimock.Equal(*mm_want_ptrs.files, mm_got.files) {
				mmGetSourceTableAndUIDByFileUIDs.t.Errorf("RepositoryMock.GetSourceTableAndUIDByFileUIDs got unexpected parameter files, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.defaultExpectation.expectationOrigins.originFiles, *mm_want_ptrs.files, mm_got.files, minimock.Diff(*mm_want_ptrs.files, mm_got.files))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSourceTableAndUIDByFileUIDs.t.Errorf("RepositoryMock.GetSourceTableAndUIDByFileUIDs got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSourceTableAndUIDByFileUIDs.GetSourceTableAndUIDByFileUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSourceTableAndUIDByFileUIDs.t.Fatal("No results are set for the RepositoryMock.GetSourceTableAndUIDByFileUIDs")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetSourceTableAndUIDByFileUIDs.funcGetSourceTableAndUIDByFileUIDs != nil {
		return mmGetSourceTableAndUIDByFileUIDs.funcGetSourceTableAndUIDByFileUIDs(ctx, files)
	}
	mmGetSourceTableAndUIDByFileUIDs.t.Fatalf("Unexpected call to RepositoryMock.GetSourceTableAndUIDByFileUIDs. %v %v", ctx, files)
	return
}

// GetSourceTableAndUIDByFileUIDsAfterCounter returns a count of finished RepositoryMock.GetSourceTableAndUIDByFileUIDs invocations
func (mmGetSourceTableAndUIDByFileUIDs *RepositoryMock) GetSourceTableAndUIDByFileUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSourceTableAndUIDByFileUIDs.afterGetSourceTableAndUIDByFileUIDsCounter)
}

// GetSourceTableAndUIDByFileUIDsBeforeCounter returns a count of RepositoryMock.GetSourceTableAndUIDByFileUIDs invocations
func (mmGetSourceTableAndUIDByFileUIDs *RepositoryMock) GetSourceTableAndUIDByFileUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSourceTableAndUIDByFileUIDs.beforeGetSourceTableAndUIDByFileUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetSourceTableAndUIDByFileUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSourceTableAndUIDByFileUIDs *mRepositoryMockGetSourceTableAndUIDByFileUIDs) Calls() []*RepositoryMockGetSourceTableAndUIDByFileUIDsParams {
	mmGetSourceTableAndUIDByFileUIDs.mutex.RLock()

	argCopy := make([]*RepositoryMockGetSourceTableAndUIDByFileUIDsParams, len(mmGetSourceTableAndUIDByFileUIDs.callArgs))
	copy(argCopy, mmGetSourceTableAndUIDByFileUIDs.callArgs)

	mmGetSourceTableAndUIDByFileUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockGetSourceTableAndUIDByFileUIDsDone returns true if the count of the GetSourceTableAndUIDByFileUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetSourceTableAndUIDByFileUIDsDone() bool {
	if m.GetSourceTableAndUIDByFileUIDsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetSourceTableAndUIDByFileUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetSourceTableAndUIDByFileUIDsMock.invocationsDone()
}

// MinimockGetSourceTableAndUIDByFileUIDsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetSourceTableAndUIDByFileUIDsInspect() {
	for _, e := range m.GetSourceTableAndUIDByFileUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetSourceTableAndUIDByFileUIDs at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetSourceTableAndUIDByFileUIDsCounter := mm_atomic.LoadUint64(&m.afterGetSourceTableAndUIDByFileUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetSourceTableAndUIDByFileUIDsMock.defaultExpectation != nil && afterGetSourceTableAndUIDByFileUIDsCounter < 1 {
		if m.GetSourceTableAndUIDByFileUIDsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetSourceTableAndUIDByFileUIDs at\n%s", m.GetSourceTableAndUIDByFileUIDsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetSourceTableAndUIDByFileUIDs at\n%s with params: %#v", m.GetSourceTableAndUIDByFileUIDsMock.defaultExpectation.expectationOrigins.origin, *m.GetSourceTableAndUIDByFileUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSourceTableAndUIDByFileUIDs != nil && afterGetSourceTableAndUIDByFileUIDsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetSourceTableAndUIDByFileUIDs at\n%s", m.funcGetSourceTableAndUIDByFileUIDsOrigin)
	}

	if !m.GetSourceTableAndUIDByFileUIDsMock.invocationsDone() && afterGetSourceTableAndUIDByFileUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetSourceTableAndUIDByFileUIDs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetSourceTableAndUIDByFileUIDsMock.expectedInvocations), m.GetSourceTableAndUIDByFileUIDsMock.expectedInvocationsOrigin, afterGetSourceTableAndUIDByFileUIDsCounter)
	}
}

type mRepositoryMockGetTextChunksBySource struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetTextChunksBySourceExpectation
	expectations       []*RepositoryMockGetTextChunksBySourceExpectation

	callArgs []*RepositoryMockGetTextChunksBySourceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetTextChunksBySourceExpectation specifies expectation struct of the Repository.GetTextChunksBySource
type RepositoryMockGetTextChunksBySourceExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetTextChunksBySourceParams
	paramPtrs          *RepositoryMockGetTextChunksBySourceParamPtrs
	expectationOrigins RepositoryMockGetTextChunksBySourceExpectationOrigins
	results            *RepositoryMockGetTextChunksBySourceResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetTextChunksBySourceParams contains parameters of the Repository.GetTextChunksBySource
type RepositoryMockGetTextChunksBySourceParams struct {
	ctx         context.Context
	sourceTable string
	sourceUID   types.SourceUIDType
}

// RepositoryMockGetTextChunksBySourceParamPtrs contains pointers to parameters of the Repository.GetTextChunksBySource
type RepositoryMockGetTextChunksBySourceParamPtrs struct {
	ctx         *context.Context
	sourceTable *string
	sourceUID   *types.SourceUIDType
}

// RepositoryMockGetTextChunksBySourceResults contains results of the Repository.GetTextChunksBySource
type RepositoryMockGetTextChunksBySourceResults struct {
	ta1 []mm_repository.TextChunkModel
	err error
}

// RepositoryMockGetTextChunksBySourceOrigins contains origins of expectations of the Repository.GetTextChunksBySource
type RepositoryMockGetTextChunksBySourceExpectationOrigins struct {
	origin            string
	originCtx         string
	originSourceTable string
	originSourceUID   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetTextChunksBySource *mRepositoryMockGetTextChunksBySource) Optional() *mRepositoryMockGetTextChunksBySource {
	mmGetTextChunksBySource.optional = true
	return mmGetTextChunksBySource
}

// Expect sets up expected params for Repository.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryMockGetTextChunksBySource) Expect(ctx context.Context, sourceTable string, sourceUID types.SourceUIDType) *mRepositoryMockGetTextChunksBySource {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryMock.GetTextChunksBySource mock is already set by Set")
	}

	if mmGetTextChunksBySource.defaultExpectation == nil {
		mmGetTextChunksBySource.defaultExpectation = &RepositoryMockGetTextChunksBySourceExpectation{}
	}

	if mmGetTextChunksBySource.defaultExpectation.paramPtrs != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryMock.GetTextChunksBySource mock is already set by ExpectParams functions")
	}

	mmGetTextChunksBySource.defaultExpectation.params = &RepositoryMockGetTextChunksBySourceParams{ctx, sourceTable, sourceUID}
	mmGetTextChunksBySource.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetTextChunksBySource.expectations {
		if minimock.Equal(e.params, mmGetTextChunksBySource.defaultExpectation.params) {
			mmGetTextChunksBySource.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTextChunksBySource.defaultExpectation.params)
		}
	}

	return mmGetTextChunksBySource
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryMockGetTextChunksBySource) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetTextChunksBySource {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryMock.GetTextChunksBySource mock is already set by Set")
	}

	if mmGetTextChunksBySource.defaultExpectation == nil {
		mmGetTextChunksBySource.defaultExpectation = &RepositoryMockGetTextChunksBySourceExpectation{}
	}

	if mmGetTextChunksBySource.defaultExpectation.params != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryMock.GetTextChunksBySource mock is already set by Expect")
	}

	if mmGetTextChunksBySource.defaultExpectation.paramPtrs == nil {
		mmGetTextChunksBySource.defaultExpectation.paramPtrs = &RepositoryMockGetTextChunksBySourceParamPtrs{}
	}
	mmGetTextChunksBySource.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetTextChunksBySource.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetTextChunksBySource
}

// ExpectSourceTableParam2 sets up expected param sourceTable for Repository.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryMockGetTextChunksBySource) ExpectSourceTableParam2(sourceTable string) *mRepositoryMockGetTextChunksBySource {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryMock.GetTextChunksBySource mock is already set by Set")
	}

	if mmGetTextChunksBySource.defaultExpectation == nil {
		mmGetTextChunksBySource.defaultExpectation = &RepositoryMockGetTextChunksBySourceExpectation{}
	}

	if mmGetTextChunksBySource.defaultExpectation.params != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryMock.GetTextChunksBySource mock is already set by Expect")
	}

	if mmGetTextChunksBySource.defaultExpectation.paramPtrs == nil {
		mmGetTextChunksBySource.defaultExpectation.paramPtrs = &RepositoryMockGetTextChunksBySourceParamPtrs{}
	}
	mmGetTextChunksBySource.defaultExpectation.paramPtrs.sourceTable = &sourceTable
	mmGetTextChunksBySource.defaultExpectation.expectationOrigins.originSourceTable = minimock.CallerInfo(1)

	return mmGetTextChunksBySource
}

// ExpectSourceUIDParam3 sets up expected param sourceUID for Repository.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryMockGetTextChunksBySource) ExpectSourceUIDParam3(sourceUID types.SourceUIDType) *mRepositoryMockGetTextChunksBySource {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryMock.GetTextChunksBySource mock is already set by Set")
	}

	if mmGetTextChunksBySource.defaultExpectation == nil {
		mmGetTextChunksBySource.defaultExpectation = &RepositoryMockGetTextChunksBySourceExpectation{}
	}

	if mmGetTextChunksBySource.defaultExpectation.params != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryMock.GetTextChunksBySource mock is already set by Expect")
	}

	if mmGetTextChunksBySource.defaultExpectation.paramPtrs == nil {
		mmGetTextChunksBySource.defaultExpectation.paramPtrs = &RepositoryMockGetTextChunksBySourceParamPtrs{}
	}
	mmGetTextChunksBySource.defaultExpectation.paramPtrs.sourceUID = &sourceUID
	mmGetTextChunksBySource.defaultExpectation.expectationOrigins.originSourceUID = minimock.CallerInfo(1)

	return mmGetTextChunksBySource
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryMockGetTextChunksBySource) Inspect(f func(ctx context.Context, sourceTable string, sourceUID types.SourceUIDType)) *mRepositoryMockGetTextChunksBySource {
	if mmGetTextChunksBySource.mock.inspectFuncGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetTextChunksBySource")
	}

	mmGetTextChunksBySource.mock.inspectFuncGetTextChunksBySource = f

	return mmGetTextChunksBySource
}

// Return sets up results that will be returned by Repository.GetTextChunksBySource
func (mmGetTextChunksBySource *mRepositoryMockGetTextChunksBySource) Return(ta1 []mm_repository.TextChunkModel, err error) *RepositoryMock {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryMock.GetTextChunksBySource mock is already set by Set")
	}

	if mmGetTextChunksBySource.defaultExpectation == nil {
		mmGetTextChunksBySource.defaultExpectation = &RepositoryMockGetTextChunksBySourceExpectation{mock: mmGetTextChunksBySource.mock}
	}
	mmGetTextChunksBySource.defaultExpectation.results = &RepositoryMockGetTextChunksBySourceResults{ta1, err}
	mmGetTextChunksBySource.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetTextChunksBySource.mock
}

// Set uses given function f to mock the Repository.GetTextChunksBySource method
func (mmGetTextChunksBySource *mRepositoryMockGetTextChunksBySource) Set(f func(ctx context.Context, sourceTable string, sourceUID types.SourceUIDType) (ta1 []mm_repository.TextChunkModel, err error)) *RepositoryMock {
	if mmGetTextChunksBySource.defaultExpectation != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("Default expectation is already set for the Repository.GetTextChunksBySource method")
	}

	if len(mmGetTextChunksBySource.expectations) > 0 {
		mmGetTextChunksBySource.mock.t.Fatalf("Some expectations are already set for the Repository.GetTextChunksBySource method")
	}

	mmGetTextChunksBySource.mock.funcGetTextChunksBySource = f
	mmGetTextChunksBySource.mock.funcGetTextChunksBySourceOrigin = minimock.CallerInfo(1)
	return mmGetTextChunksBySource.mock
}

// When sets expectation for the Repository.GetTextChunksBySource which will trigger the result defined by the following
// Then helper
func (mmGetTextChunksBySource *mRepositoryMockGetTextChunksBySource) When(ctx context.Context, sourceTable string, sourceUID types.SourceUIDType) *RepositoryMockGetTextChunksBySourceExpectation {
	if mmGetTextChunksBySource.mock.funcGetTextChunksBySource != nil {
		mmGetTextChunksBySource.mock.t.Fatalf("RepositoryMock.GetTextChunksBySource mock is already set by Set")
	}

	expectation := &RepositoryMockGetTextChunksBySourceExpectation{
		mock:               mmGetTextChunksBySource.mock,
		params:             &RepositoryMockGetTextChunksBySourceParams{ctx, sourceTable, sourceUID},
		expectationOrigins: RepositoryMockGetTextChunksBySourceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetTextChunksBySource.expectations = append(mmGetTextChunksBySource.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetTextChunksBySource return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetTextChunksBySourceExpectation) Then(ta1 []mm_repository.TextChunkModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetTextChunksBySourceResults{ta1, err}
	return e.mock
}

// Times sets number of times Repository.GetTextChunksBySource should be invoked
func (mmGetTextChunksBySource *mRepositoryMockGetTextChunksBySource) Times(n uint64) *mRepositoryMockGetTextChunksBySource {
	if n == 0 {
		mmGetTextChunksBySource.mock.t.Fatalf("Times of RepositoryMock.GetTextChunksBySource mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTextChunksBySource.expectedInvocations, n)
	mmGetTextChunksBySource.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetTextChunksBySource
}

func (mmGetTextChunksBySource *mRepositoryMockGetTextChunksBySource) invocationsDone() bool {
	if len(mmGetTextChunksBySource.expectations) == 0 && mmGetTextChunksBySource.defaultExpectation == nil && mmGetTextChunksBySource.mock.funcGetTextChunksBySource == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTextChunksBySource.mock.afterGetTextChunksBySourceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTextChunksBySource.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTextChunksBySource implements mm_repository.Repository
func (mmGetTextChunksBySource *RepositoryMock) GetTextChunksBySource(ctx context.Context, sourceTable string, sourceUID types.SourceUIDType) (ta1 []mm_repository.TextChunkModel, err error) {
	mm_atomic.AddUint64(&mmGetTextChunksBySource.beforeGetTextChunksBySourceCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTextChunksBySource.afterGetTextChunksBySourceCounter, 1)

	mmGetTextChunksBySource.t.Helper()

	if mmGetTextChunksBySource.inspectFuncGetTextChunksBySource != nil {
		mmGetTextChunksBySource.inspectFuncGetTextChunksBySource(ctx, sourceTable, sourceUID)
	}

	mm_params := RepositoryMockGetTextChunksBySourceParams{ctx, sourceTable, sourceUID}

	// Record call args
	mmGetTextChunksBySource.GetTextChunksBySourceMock.mutex.Lock()
	mmGetTextChunksBySource.GetTextChunksBySourceMock.callArgs = append(mmGetTextChunksBySource.GetTextChunksBySourceMock.callArgs, &mm_params)
	mmGetTextChunksBySource.GetTextChunksBySourceMock.mutex.Unlock()

	for _, e := range mmGetTextChunksBySource.GetTextChunksBySourceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ta1, e.results.err
		}
	}

	if mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation.params
		mm_want_ptrs := mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetTextChunksBySourceParams{ctx, sourceTable, sourceUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTextChunksBySource.t.Errorf("RepositoryMock.GetTextChunksBySource got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sourceTable != nil && !minimock.Equal(*mm_want_ptrs.sourceTable, mm_got.sourceTable) {
				mmGetTextChunksBySource.t.Errorf("RepositoryMock.GetTextChunksBySource got unexpected parameter sourceTable, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation.expectationOrigins.originSourceTable, *mm_want_ptrs.sourceTable, mm_got.sourceTable, minimock.Diff(*mm_want_ptrs.sourceTable, mm_got.sourceTable))
			}

			if mm_want_ptrs.sourceUID != nil && !minimock.Equal(*mm_want_ptrs.sourceUID, mm_got.sourceUID) {
				mmGetTextChunksBySource.t.Errorf("RepositoryMock.GetTextChunksBySource got unexpected parameter sourceUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation.expectationOrigins.originSourceUID, *mm_want_ptrs.sourceUID, mm_got.sourceUID, minimock.Diff(*mm_want_ptrs.sourceUID, mm_got.sourceUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTextChunksBySource.t.Errorf("RepositoryMock.GetTextChunksBySource got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTextChunksBySource.GetTextChunksBySourceMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTextChunksBySource.t.Fatal("No results are set for the RepositoryMock.GetTextChunksBySource")
		}
		return (*mm_results).ta1, (*mm_results).err
	}
	if mmGetTextChunksBySource.funcGetTextChunksBySource != nil {
		return mmGetTextChunksBySource.funcGetTextChunksBySource(ctx, sourceTable, sourceUID)
	}
	mmGetTextChunksBySource.t.Fatalf("Unexpected call to RepositoryMock.GetTextChunksBySource. %v %v %v", ctx, sourceTable, sourceUID)
	return
}

// GetTextChunksBySourceAfterCounter returns a count of finished RepositoryMock.GetTextChunksBySource invocations
func (mmGetTextChunksBySource *RepositoryMock) GetTextChunksBySourceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTextChunksBySource.afterGetTextChunksBySourceCounter)
}

// GetTextChunksBySourceBeforeCounter returns a count of RepositoryMock.GetTextChunksBySource invocations
func (mmGetTextChunksBySource *RepositoryMock) GetTextChunksBySourceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTextChunksBySource.beforeGetTextChunksBySourceCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetTextChunksBySource.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTextChunksBySource *mRepositoryMockGetTextChunksBySource) Calls() []*RepositoryMockGetTextChunksBySourceParams {
	mmGetTextChunksBySource.mutex.RLock()

	argCopy := make([]*RepositoryMockGetTextChunksBySourceParams, len(mmGetTextChunksBySource.callArgs))
	copy(argCopy, mmGetTextChunksBySource.callArgs)

	mmGetTextChunksBySource.mutex.RUnlock()

	return argCopy
}

// MinimockGetTextChunksBySourceDone returns true if the count of the GetTextChunksBySource invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetTextChunksBySourceDone() bool {
	if m.GetTextChunksBySourceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetTextChunksBySourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTextChunksBySourceMock.invocationsDone()
}

// MinimockGetTextChunksBySourceInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetTextChunksBySourceInspect() {
	for _, e := range m.GetTextChunksBySourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetTextChunksBySource at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetTextChunksBySourceCounter := mm_atomic.LoadUint64(&m.afterGetTextChunksBySourceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTextChunksBySourceMock.defaultExpectation != nil && afterGetTextChunksBySourceCounter < 1 {
		if m.GetTextChunksBySourceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetTextChunksBySource at\n%s", m.GetTextChunksBySourceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetTextChunksBySource at\n%s with params: %#v", m.GetTextChunksBySourceMock.defaultExpectation.expectationOrigins.origin, *m.GetTextChunksBySourceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTextChunksBySource != nil && afterGetTextChunksBySourceCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetTextChunksBySource at\n%s", m.funcGetTextChunksBySourceOrigin)
	}

	if !m.GetTextChunksBySourceMock.invocationsDone() && afterGetTextChunksBySourceCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetTextChunksBySource at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetTextChunksBySourceMock.expectedInvocations), m.GetTextChunksBySourceMock.expectedInvocationsOrigin, afterGetTextChunksBySourceCounter)
	}
}

type mRepositoryMockGetTextChunksByUIDs struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetTextChunksByUIDsExpectation
	expectations       []*RepositoryMockGetTextChunksByUIDsExpectation

	callArgs []*RepositoryMockGetTextChunksByUIDsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetTextChunksByUIDsExpectation specifies expectation struct of the Repository.GetTextChunksByUIDs
type RepositoryMockGetTextChunksByUIDsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetTextChunksByUIDsParams
	paramPtrs          *RepositoryMockGetTextChunksByUIDsParamPtrs
	expectationOrigins RepositoryMockGetTextChunksByUIDsExpectationOrigins
	results            *RepositoryMockGetTextChunksByUIDsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetTextChunksByUIDsParams contains parameters of the Repository.GetTextChunksByUIDs
type RepositoryMockGetTextChunksByUIDsParams struct {
	ctx       context.Context
	chunkUIDs []types.TextChunkUIDType
}

// RepositoryMockGetTextChunksByUIDsParamPtrs contains pointers to parameters of the Repository.GetTextChunksByUIDs
type RepositoryMockGetTextChunksByUIDsParamPtrs struct {
	ctx       *context.Context
	chunkUIDs *[]types.TextChunkUIDType
}

// RepositoryMockGetTextChunksByUIDsResults contains results of the Repository.GetTextChunksByUIDs
type RepositoryMockGetTextChunksByUIDsResults struct {
	ta1 []mm_repository.TextChunkModel
	err error
}

// RepositoryMockGetTextChunksByUIDsOrigins contains origins of expectations of the Repository.GetTextChunksByUIDs
type RepositoryMockGetTextChunksByUIDsExpectationOrigins struct {
	origin          string
	originCtx       string
	originChunkUIDs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetTextChunksByUIDs *mRepositoryMockGetTextChunksByUIDs) Optional() *mRepositoryMockGetTextChunksByUIDs {
	mmGetTextChunksByUIDs.optional = true
	return mmGetTextChunksByUIDs
}

// Expect sets up expected params for Repository.GetTextChunksByUIDs
func (mmGetTextChunksByUIDs *mRepositoryMockGetTextChunksByUIDs) Expect(ctx context.Context, chunkUIDs []types.TextChunkUIDType) *mRepositoryMockGetTextChunksByUIDs {
	if mmGetTextChunksByUIDs.mock.funcGetTextChunksByUIDs != nil {
		mmGetTextChunksByUIDs.mock.t.Fatalf("RepositoryMock.GetTextChunksByUIDs mock is already set by Set")
	}

	if mmGetTextChunksByUIDs.defaultExpectation == nil {
		mmGetTextChunksByUIDs.defaultExpectation = &RepositoryMockGetTextChunksByUIDsExpectation{}
	}

	if mmGetTextChunksByUIDs.defaultExpectation.paramPtrs != nil {
		mmGetTextChunksByUIDs.mock.t.Fatalf("RepositoryMock.GetTextChunksByUIDs mock is already set by ExpectParams functions")
	}

	mmGetTextChunksByUIDs.defaultExpectation.params = &RepositoryMockGetTextChunksByUIDsParams{ctx, chunkUIDs}
	mmGetTextChunksByUIDs.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetTextChunksByUIDs.expectations {
		if minimock.Equal(e.params, mmGetTextChunksByUIDs.defaultExpectation.params) {
			mmGetTextChunksByUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTextChunksByUIDs.defaultExpectation.params)
		}
	}

	return mmGetTextChunksByUIDs
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetTextChunksByUIDs
func (mmGetTextChunksByUIDs *mRepositoryMockGetTextChunksByUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetTextChunksByUIDs {
	if mmGetTextChunksByUIDs.mock.funcGetTextChunksByUIDs != nil {
		mmGetTextChunksByUIDs.mock.t.Fatalf("RepositoryMock.GetTextChunksByUIDs mock is already set by Set")
	}

	if mmGetTextChunksByUIDs.defaultExpectation == nil {
		mmGetTextChunksByUIDs.defaultExpectation = &RepositoryMockGetTextChunksByUIDsExpectation{}
	}

	if mmGetTextChunksByUIDs.defaultExpectation.params != nil {
		mmGetTextChunksByUIDs.mock.t.Fatalf("RepositoryMock.GetTextChunksByUIDs mock is already set by Expect")
	}

	if mmGetTextChunksByUIDs.defaultExpectation.paramPtrs == nil {
		mmGetTextChunksByUIDs.defaultExpectation.paramPtrs = &RepositoryMockGetTextChunksByUIDsParamPtrs{}
	}
	mmGetTextChunksByUIDs.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetTextChunksByUIDs.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetTextChunksByUIDs
}

// ExpectChunkUIDsParam2 sets up expected param chunkUIDs for Repository.GetTextChunksByUIDs
func (mmGetTextChunksByUIDs *mRepositoryMockGetTextChunksByUIDs) ExpectChunkUIDsParam2(chunkUIDs []types.TextChunkUIDType) *mRepositoryMockGetTextChunksByUIDs {
	if mmGetTextChunksByUIDs.mock.funcGetTextChunksByUIDs != nil {
		mmGetTextChunksByUIDs.mock.t.Fatalf("RepositoryMock.GetTextChunksByUIDs mock is already set by Set")
	}

	if mmGetTextChunksByUIDs.defaultExpectation == nil {
		mmGetTextChunksByUIDs.defaultExpectation = &RepositoryMockGetTextChunksByUIDsExpectation{}
	}

	if mmGetTextChunksByUIDs.defaultExpectation.params != nil {
		mmGetTextChunksByUIDs.mock.t.Fatalf("RepositoryMock.GetTextChunksByUIDs mock is already set by Expect")
	}

	if mmGetTextChunksByUIDs.defaultExpectation.paramPtrs == nil {
		mmGetTextChunksByUIDs.defaultExpectation.paramPtrs = &RepositoryMockGetTextChunksByUIDsParamPtrs{}
	}
	mmGetTextChunksByUIDs.defaultExpectation.paramPtrs.chunkUIDs = &chunkUIDs
	mmGetTextChunksByUIDs.defaultExpectation.expectationOrigins.originChunkUIDs = minimock.CallerInfo(1)

	return mmGetTextChunksByUIDs
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetTextChunksByUIDs
func (mmGetTextChunksByUIDs *mRepositoryMockGetTextChunksByUIDs) Inspect(f func(ctx context.Context, chunkUIDs []types.TextChunkUIDType)) *mRepositoryMockGetTextChunksByUIDs {
	if mmGetTextChunksByUIDs.mock.inspectFuncGetTextChunksByUIDs != nil {
		mmGetTextChunksByUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetTextChunksByUIDs")
	}

	mmGetTextChunksByUIDs.mock.inspectFuncGetTextChunksByUIDs = f

	return mmGetTextChunksByUIDs
}

// Return sets up results that will be returned by Repository.GetTextChunksByUIDs
func (mmGetTextChunksByUIDs *mRepositoryMockGetTextChunksByUIDs) Return(ta1 []mm_repository.TextChunkModel, err error) *RepositoryMock {
	if mmGetTextChunksByUIDs.mock.funcGetTextChunksByUIDs != nil {
		mmGetTextChunksByUIDs.mock.t.Fatalf("RepositoryMock.GetTextChunksByUIDs mock is already set by Set")
	}

	if mmGetTextChunksByUIDs.defaultExpectation == nil {
		mmGetTextChunksByUIDs.defaultExpectation = &RepositoryMockGetTextChunksByUIDsExpectation{mock: mmGetTextChunksByUIDs.mock}
	}
	mmGetTextChunksByUIDs.defaultExpectation.results = &RepositoryMockGetTextChunksByUIDsResults{ta1, err}
	mmGetTextChunksByUIDs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetTextChunksByUIDs.mock
}

// Set uses given function f to mock the Repository.GetTextChunksByUIDs method
func (mmGetTextChunksByUIDs *mRepositoryMockGetTextChunksByUIDs) Set(f func(ctx context.Context, chunkUIDs []types.TextChunkUIDType) (ta1 []mm_repository.TextChunkModel, err error)) *RepositoryMock {
	if mmGetTextChunksByUIDs.defaultExpectation != nil {
		mmGetTextChunksByUIDs.mock.t.Fatalf("Default expectation is already set for the Repository.GetTextChunksByUIDs method")
	}

	if len(mmGetTextChunksByUIDs.expectations) > 0 {
		mmGetTextChunksByUIDs.mock.t.Fatalf("Some expectations are already set for the Repository.GetTextChunksByUIDs method")
	}

	mmGetTextChunksByUIDs.mock.funcGetTextChunksByUIDs = f
	mmGetTextChunksByUIDs.mock.funcGetTextChunksByUIDsOrigin = minimock.CallerInfo(1)
	return mmGetTextChunksByUIDs.mock
}

// When sets expectation for the Repository.GetTextChunksByUIDs which will trigger the result defined by the following
// Then helper
func (mmGetTextChunksByUIDs *mRepositoryMockGetTextChunksByUIDs) When(ctx context.Context, chunkUIDs []types.TextChunkUIDType) *RepositoryMockGetTextChunksByUIDsExpectation {
	if mmGetTextChunksByUIDs.mock.funcGetTextChunksByUIDs != nil {
		mmGetTextChunksByUIDs.mock.t.Fatalf("RepositoryMock.GetTextChunksByUIDs mock is already set by Set")
	}

	expectation := &RepositoryMockGetTextChunksByUIDsExpectation{
		mock:               mmGetTextChunksByUIDs.mock,
		params:             &RepositoryMockGetTextChunksByUIDsParams{ctx, chunkUIDs},
		expectationOrigins: RepositoryMockGetTextChunksByUIDsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetTextChunksByUIDs.expectations = append(mmGetTextChunksByUIDs.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetTextChunksByUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetTextChunksByUIDsExpectation) Then(ta1 []mm_repository.TextChunkModel, err error) *RepositoryMock {
	e.results = &RepositoryMockGetTextChunksByUIDsResults{ta1, err}
	return e.mock
}

// Times sets number of times Repository.GetTextChunksByUIDs should be invoked
func (mmGetTextChunksByUIDs *mRepositoryMockGetTextChunksByUIDs) Times(n uint64) *mRepositoryMockGetTextChunksByUIDs {
	if n == 0 {
		mmGetTextChunksByUIDs.mock.t.Fatalf("Times of RepositoryMock.GetTextChunksByUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTextChunksByUIDs.expectedInvocations, n)
	mmGetTextChunksByUIDs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetTextChunksByUIDs
}

func (mmGetTextChunksByUIDs *mRepositoryMockGetTextChunksByUIDs) invocationsDone() bool {
	if len(mmGetTextChunksByUIDs.expectations) == 0 && mmGetTextChunksByUIDs.defaultExpectation == nil && mmGetTextChunksByUIDs.mock.funcGetTextChunksByUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTextChunksByUIDs.mock.afterGetTextChunksByUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTextChunksByUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTextChunksByUIDs implements mm_repository.Repository
func (mmGetTextChunksByUIDs *RepositoryMock) GetTextChunksByUIDs(ctx context.Context, chunkUIDs []types.TextChunkUIDType) (ta1 []mm_repository.TextChunkModel, err error) {
	mm_atomic.AddUint64(&mmGetTextChunksByUIDs.beforeGetTextChunksByUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTextChunksByUIDs.afterGetTextChunksByUIDsCounter, 1)

	mmGetTextChunksByUIDs.t.Helper()

	if mmGetTextChunksByUIDs.inspectFuncGetTextChunksByUIDs != nil {
		mmGetTextChunksByUIDs.inspectFuncGetTextChunksByUIDs(ctx, chunkUIDs)
	}

	mm_params := RepositoryMockGetTextChunksByUIDsParams{ctx, chunkUIDs}

	// Record call args
	mmGetTextChunksByUIDs.GetTextChunksByUIDsMock.mutex.Lock()
	mmGetTextChunksByUIDs.GetTextChunksByUIDsMock.callArgs = append(mmGetTextChunksByUIDs.GetTextChunksByUIDsMock.callArgs, &mm_params)
	mmGetTextChunksByUIDs.GetTextChunksByUIDsMock.mutex.Unlock()

	for _, e := range mmGetTextChunksByUIDs.GetTextChunksByUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ta1, e.results.err
		}
	}

	if mmGetTextChunksByUIDs.GetTextChunksByUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTextChunksByUIDs.GetTextChunksByUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTextChunksByUIDs.GetTextChunksByUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmGetTextChunksByUIDs.GetTextChunksByUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetTextChunksByUIDsParams{ctx, chunkUIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTextChunksByUIDs.t.Errorf("RepositoryMock.GetTextChunksByUIDs got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTextChunksByUIDs.GetTextChunksByUIDsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chunkUIDs != nil && !minimock.Equal(*mm_want_ptrs.chunkUIDs, mm_got.chunkUIDs) {
				mmGetTextChunksByUIDs.t.Errorf("RepositoryMock.GetTextChunksByUIDs got unexpected parameter chunkUIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTextChunksByUIDs.GetTextChunksByUIDsMock.defaultExpectation.expectationOrigins.originChunkUIDs, *mm_want_ptrs.chunkUIDs, mm_got.chunkUIDs, minimock.Diff(*mm_want_ptrs.chunkUIDs, mm_got.chunkUIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTextChunksByUIDs.t.Errorf("RepositoryMock.GetTextChunksByUIDs got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetTextChunksByUIDs.GetTextChunksByUIDsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTextChunksByUIDs.GetTextChunksByUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTextChunksByUIDs.t.Fatal("No results are set for the RepositoryMock.GetTextChunksByUIDs")
		}
		return (*mm_results).ta1, (*mm_results).err
	}
	if mmGetTextChunksByUIDs.funcGetTextChunksByUIDs != nil {
		return mmGetTextChunksByUIDs.funcGetTextChunksByUIDs(ctx, chunkUIDs)
	}
	mmGetTextChunksByUIDs.t.Fatalf("Unexpected call to RepositoryMock.GetTextChunksByUIDs. %v %v", ctx, chunkUIDs)
	return
}

// GetTextChunksByUIDsAfterCounter returns a count of finished RepositoryMock.GetTextChunksByUIDs invocations
func (mmGetTextChunksByUIDs *RepositoryMock) GetTextChunksByUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTextChunksByUIDs.afterGetTextChunksByUIDsCounter)
}

// GetTextChunksByUIDsBeforeCounter returns a count of RepositoryMock.GetTextChunksByUIDs invocations
func (mmGetTextChunksByUIDs *RepositoryMock) GetTextChunksByUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTextChunksByUIDs.beforeGetTextChunksByUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetTextChunksByUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTextChunksByUIDs *mRepositoryMockGetTextChunksByUIDs) Calls() []*RepositoryMockGetTextChunksByUIDsParams {
	mmGetTextChunksByUIDs.mutex.RLock()

	argCopy := make([]*RepositoryMockGetTextChunksByUIDsParams, len(mmGetTextChunksByUIDs.callArgs))
	copy(argCopy, mmGetTextChunksByUIDs.callArgs)

	mmGetTextChunksByUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockGetTextChunksByUIDsDone returns true if the count of the GetTextChunksByUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetTextChunksByUIDsDone() bool {
	if m.GetTextChunksByUIDsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetTextChunksByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTextChunksByUIDsMock.invocationsDone()
}

// MinimockGetTextChunksByUIDsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetTextChunksByUIDsInspect() {
	for _, e := range m.GetTextChunksByUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetTextChunksByUIDs at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetTextChunksByUIDsCounter := mm_atomic.LoadUint64(&m.afterGetTextChunksByUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTextChunksByUIDsMock.defaultExpectation != nil && afterGetTextChunksByUIDsCounter < 1 {
		if m.GetTextChunksByUIDsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetTextChunksByUIDs at\n%s", m.GetTextChunksByUIDsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetTextChunksByUIDs at\n%s with params: %#v", m.GetTextChunksByUIDsMock.defaultExpectation.expectationOrigins.origin, *m.GetTextChunksByUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTextChunksByUIDs != nil && afterGetTextChunksByUIDsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetTextChunksByUIDs at\n%s", m.funcGetTextChunksByUIDsOrigin)
	}

	if !m.GetTextChunksByUIDsMock.invocationsDone() && afterGetTextChunksByUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetTextChunksByUIDs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetTextChunksByUIDsMock.expectedInvocations), m.GetTextChunksByUIDsMock.expectedInvocationsOrigin, afterGetTextChunksByUIDsCounter)
	}
}

type mRepositoryMockGetTotalTextChunksBySources struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetTotalTextChunksBySourcesExpectation
	expectations       []*RepositoryMockGetTotalTextChunksBySourcesExpectation

	callArgs []*RepositoryMockGetTotalTextChunksBySourcesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetTotalTextChunksBySourcesExpectation specifies expectation struct of the Repository.GetTotalTextChunksBySources
type RepositoryMockGetTotalTextChunksBySourcesExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetTotalTextChunksBySourcesParams
	paramPtrs          *RepositoryMockGetTotalTextChunksBySourcesParamPtrs
	expectationOrigins RepositoryMockGetTotalTextChunksBySourcesExpectationOrigins
	results            *RepositoryMockGetTotalTextChunksBySourcesResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetTotalTextChunksBySourcesParams contains parameters of the Repository.GetTotalTextChunksBySources
type RepositoryMockGetTotalTextChunksBySourcesParams struct {
	ctx     context.Context
	sources map[types.FileUIDType]struct {
		SourceTable types.SourceTableType
		SourceUID   types.SourceUIDType
	}
}

// RepositoryMockGetTotalTextChunksBySourcesParamPtrs contains pointers to parameters of the Repository.GetTotalTextChunksBySources
type RepositoryMockGetTotalTextChunksBySourcesParamPtrs struct {
	ctx     *context.Context
	sources *map[types.FileUIDType]struct {
		SourceTable types.SourceTableType
		SourceUID   types.SourceUIDType
	}
}

// RepositoryMockGetTotalTextChunksBySourcesResults contains results of the Repository.GetTotalTextChunksBySources
type RepositoryMockGetTotalTextChunksBySourcesResults struct {
	m1  map[types.FileUIDType]int
	err error
}

// RepositoryMockGetTotalTextChunksBySourcesOrigins contains origins of expectations of the Repository.GetTotalTextChunksBySources
type RepositoryMockGetTotalTextChunksBySourcesExpectationOrigins struct {
	origin        string
	originCtx     string
	originSources string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetTotalTextChunksBySources *mRepositoryMockGetTotalTextChunksBySources) Optional() *mRepositoryMockGetTotalTextChunksBySources {
	mmGetTotalTextChunksBySources.optional = true
	return mmGetTotalTextChunksBySources
}

// Expect sets up expected params for Repository.GetTotalTextChunksBySources
func (mmGetTotalTextChunksBySources *mRepositoryMockGetTotalTextChunksBySources) Expect(ctx context.Context, sources map[types.FileUIDType]struct {
	SourceTable types.SourceTableType
	SourceUID   types.SourceUIDType
}) *mRepositoryMockGetTotalTextChunksBySources {
	if mmGetTotalTextChunksBySources.mock.funcGetTotalTextChunksBySources != nil {
		mmGetTotalTextChunksBySources.mock.t.Fatalf("RepositoryMock.GetTotalTextChunksBySources mock is already set by Set")
	}

	if mmGetTotalTextChunksBySources.defaultExpectation == nil {
		mmGetTotalTextChunksBySources.defaultExpectation = &RepositoryMockGetTotalTextChunksBySourcesExpectation{}
	}

	if mmGetTotalTextChunksBySources.defaultExpectation.paramPtrs != nil {
		mmGetTotalTextChunksBySources.mock.t.Fatalf("RepositoryMock.GetTotalTextChunksBySources mock is already set by ExpectParams functions")
	}

	mmGetTotalTextChunksBySources.defaultExpectation.params = &RepositoryMockGetTotalTextChunksBySourcesParams{ctx, sources}
	mmGetTotalTextChunksBySources.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetTotalTextChunksBySources.expectations {
		if minimock.Equal(e.params, mmGetTotalTextChunksBySources.defaultExpectation.params) {
			mmGetTotalTextChunksBySources.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTotalTextChunksBySources.defaultExpectation.params)
		}
	}

	return mmGetTotalTextChunksBySources
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetTotalTextChunksBySources
func (mmGetTotalTextChunksBySources *mRepositoryMockGetTotalTextChunksBySources) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetTotalTextChunksBySources {
	if mmGetTotalTextChunksBySources.mock.funcGetTotalTextChunksBySources != nil {
		mmGetTotalTextChunksBySources.mock.t.Fatalf("RepositoryMock.GetTotalTextChunksBySources mock is already set by Set")
	}

	if mmGetTotalTextChunksBySources.defaultExpectation == nil {
		mmGetTotalTextChunksBySources.defaultExpectation = &RepositoryMockGetTotalTextChunksBySourcesExpectation{}
	}

	if mmGetTotalTextChunksBySources.defaultExpectation.params != nil {
		mmGetTotalTextChunksBySources.mock.t.Fatalf("RepositoryMock.GetTotalTextChunksBySources mock is already set by Expect")
	}

	if mmGetTotalTextChunksBySources.defaultExpectation.paramPtrs == nil {
		mmGetTotalTextChunksBySources.defaultExpectation.paramPtrs = &RepositoryMockGetTotalTextChunksBySourcesParamPtrs{}
	}
	mmGetTotalTextChunksBySources.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetTotalTextChunksBySources.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetTotalTextChunksBySources
}

// ExpectSourcesParam2 sets up expected param sources for Repository.GetTotalTextChunksBySources
func (mmGetTotalTextChunksBySources *mRepositoryMockGetTotalTextChunksBySources) ExpectSourcesParam2(sources map[types.FileUIDType]struct {
	SourceTable types.SourceTableType
	SourceUID   types.SourceUIDType
}) *mRepositoryMockGetTotalTextChunksBySources {
	if mmGetTotalTextChunksBySources.mock.funcGetTotalTextChunksBySources != nil {
		mmGetTotalTextChunksBySources.mock.t.Fatalf("RepositoryMock.GetTotalTextChunksBySources mock is already set by Set")
	}

	if mmGetTotalTextChunksBySources.defaultExpectation == nil {
		mmGetTotalTextChunksBySources.defaultExpectation = &RepositoryMockGetTotalTextChunksBySourcesExpectation{}
	}

	if mmGetTotalTextChunksBySources.defaultExpectation.params != nil {
		mmGetTotalTextChunksBySources.mock.t.Fatalf("RepositoryMock.GetTotalTextChunksBySources mock is already set by Expect")
	}

	if mmGetTotalTextChunksBySources.defaultExpectation.paramPtrs == nil {
		mmGetTotalTextChunksBySources.defaultExpectation.paramPtrs = &RepositoryMockGetTotalTextChunksBySourcesParamPtrs{}
	}
	mmGetTotalTextChunksBySources.defaultExpectation.paramPtrs.sources = &sources
	mmGetTotalTextChunksBySources.defaultExpectation.expectationOrigins.originSources = minimock.CallerInfo(1)

	return mmGetTotalTextChunksBySources
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetTotalTextChunksBySources
func (mmGetTotalTextChunksBySources *mRepositoryMockGetTotalTextChunksBySources) Inspect(f func(ctx context.Context, sources map[types.FileUIDType]struct {
	SourceTable types.SourceTableType
	SourceUID   types.SourceUIDType
})) *mRepositoryMockGetTotalTextChunksBySources {
	if mmGetTotalTextChunksBySources.mock.inspectFuncGetTotalTextChunksBySources != nil {
		mmGetTotalTextChunksBySources.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetTotalTextChunksBySources")
	}

	mmGetTotalTextChunksBySources.mock.inspectFuncGetTotalTextChunksBySources = f

	return mmGetTotalTextChunksBySources
}

// Return sets up results that will be returned by Repository.GetTotalTextChunksBySources
func (mmGetTotalTextChunksBySources *mRepositoryMockGetTotalTextChunksBySources) Return(m1 map[types.FileUIDType]int, err error) *RepositoryMock {
	if mmGetTotalTextChunksBySources.mock.funcGetTotalTextChunksBySources != nil {
		mmGetTotalTextChunksBySources.mock.t.Fatalf("RepositoryMock.GetTotalTextChunksBySources mock is already set by Set")
	}

	if mmGetTotalTextChunksBySources.defaultExpectation == nil {
		mmGetTotalTextChunksBySources.defaultExpectation = &RepositoryMockGetTotalTextChunksBySourcesExpectation{mock: mmGetTotalTextChunksBySources.mock}
	}
	mmGetTotalTextChunksBySources.defaultExpectation.results = &RepositoryMockGetTotalTextChunksBySourcesResults{m1, err}
	mmGetTotalTextChunksBySources.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetTotalTextChunksBySources.mock
}

// Set uses given function f to mock the Repository.GetTotalTextChunksBySources method
func (mmGetTotalTextChunksBySources *mRepositoryMockGetTotalTextChunksBySources) Set(f func(ctx context.Context, sources map[types.FileUIDType]struct {
	SourceTable types.SourceTableType
	SourceUID   types.SourceUIDType
}) (m1 map[types.FileUIDType]int, err error)) *RepositoryMock {
	if mmGetTotalTextChunksBySources.defaultExpectation != nil {
		mmGetTotalTextChunksBySources.mock.t.Fatalf("Default expectation is already set for the Repository.GetTotalTextChunksBySources method")
	}

	if len(mmGetTotalTextChunksBySources.expectations) > 0 {
		mmGetTotalTextChunksBySources.mock.t.Fatalf("Some expectations are already set for the Repository.GetTotalTextChunksBySources method")
	}

	mmGetTotalTextChunksBySources.mock.funcGetTotalTextChunksBySources = f
	mmGetTotalTextChunksBySources.mock.funcGetTotalTextChunksBySourcesOrigin = minimock.CallerInfo(1)
	return mmGetTotalTextChunksBySources.mock
}

// When sets expectation for the Repository.GetTotalTextChunksBySources which will trigger the result defined by the following
// Then helper
func (mmGetTotalTextChunksBySources *mRepositoryMockGetTotalTextChunksBySources) When(ctx context.Context, sources map[types.FileUIDType]struct {
	SourceTable types.SourceTableType
	SourceUID   types.SourceUIDType
}) *RepositoryMockGetTotalTextChunksBySourcesExpectation {
	if mmGetTotalTextChunksBySources.mock.funcGetTotalTextChunksBySources != nil {
		mmGetTotalTextChunksBySources.mock.t.Fatalf("RepositoryMock.GetTotalTextChunksBySources mock is already set by Set")
	}

	expectation := &RepositoryMockGetTotalTextChunksBySourcesExpectation{
		mock:               mmGetTotalTextChunksBySources.mock,
		params:             &RepositoryMockGetTotalTextChunksBySourcesParams{ctx, sources},
		expectationOrigins: RepositoryMockGetTotalTextChunksBySourcesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetTotalTextChunksBySources.expectations = append(mmGetTotalTextChunksBySources.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetTotalTextChunksBySources return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetTotalTextChunksBySourcesExpectation) Then(m1 map[types.FileUIDType]int, err error) *RepositoryMock {
	e.results = &RepositoryMockGetTotalTextChunksBySourcesResults{m1, err}
	return e.mock
}

// Times sets number of times Repository.GetTotalTextChunksBySources should be invoked
func (mmGetTotalTextChunksBySources *mRepositoryMockGetTotalTextChunksBySources) Times(n uint64) *mRepositoryMockGetTotalTextChunksBySources {
	if n == 0 {
		mmGetTotalTextChunksBySources.mock.t.Fatalf("Times of RepositoryMock.GetTotalTextChunksBySources mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTotalTextChunksBySources.expectedInvocations, n)
	mmGetTotalTextChunksBySources.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetTotalTextChunksBySources
}

func (mmGetTotalTextChunksBySources *mRepositoryMockGetTotalTextChunksBySources) invocationsDone() bool {
	if len(mmGetTotalTextChunksBySources.expectations) == 0 && mmGetTotalTextChunksBySources.defaultExpectation == nil && mmGetTotalTextChunksBySources.mock.funcGetTotalTextChunksBySources == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTotalTextChunksBySources.mock.afterGetTotalTextChunksBySourcesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTotalTextChunksBySources.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTotalTextChunksBySources implements mm_repository.Repository
func (mmGetTotalTextChunksBySources *RepositoryMock) GetTotalTextChunksBySources(ctx context.Context, sources map[types.FileUIDType]struct {
	SourceTable types.SourceTableType
	SourceUID   types.SourceUIDType
}) (m1 map[types.FileUIDType]int, err error) {
	mm_atomic.AddUint64(&mmGetTotalTextChunksBySources.beforeGetTotalTextChunksBySourcesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTotalTextChunksBySources.afterGetTotalTextChunksBySourcesCounter, 1)

	mmGetTotalTextChunksBySources.t.Helper()

	if mmGetTotalTextChunksBySources.inspectFuncGetTotalTextChunksBySources != nil {
		mmGetTotalTextChunksBySources.inspectFuncGetTotalTextChunksBySources(ctx, sources)
	}

	mm_params := RepositoryMockGetTotalTextChunksBySourcesParams{ctx, sources}

	// Record call args
	mmGetTotalTextChunksBySources.GetTotalTextChunksBySourcesMock.mutex.Lock()
	mmGetTotalTextChunksBySources.GetTotalTextChunksBySourcesMock.callArgs = append(mmGetTotalTextChunksBySources.GetTotalTextChunksBySourcesMock.callArgs, &mm_params)
	mmGetTotalTextChunksBySources.GetTotalTextChunksBySourcesMock.mutex.Unlock()

	for _, e := range mmGetTotalTextChunksBySources.GetTotalTextChunksBySourcesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetTotalTextChunksBySources.GetTotalTextChunksBySourcesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTotalTextChunksBySources.GetTotalTextChunksBySourcesMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTotalTextChunksBySources.GetTotalTextChunksBySourcesMock.defaultExpectation.params
		mm_want_ptrs := mmGetTotalTextChunksBySources.GetTotalTextChunksBySourcesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetTotalTextChunksBySourcesParams{ctx, sources}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTotalTextChunksBySources.t.Errorf("RepositoryMock.GetTotalTextChunksBySources got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTotalTextChunksBySources.GetTotalTextChunksBySourcesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sources != nil && !minimock.Equal(*mm_want_ptrs.sources, mm_got.sources) {
				mmGetTotalTextChunksBySources.t.Errorf("RepositoryMock.GetTotalTextChunksBySources got unexpected parameter sources, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTotalTextChunksBySources.GetTotalTextChunksBySourcesMock.defaultExpectation.expectationOrigins.originSources, *mm_want_ptrs.sources, mm_got.sources, minimock.Diff(*mm_want_ptrs.sources, mm_got.sources))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTotalTextChunksBySources.t.Errorf("RepositoryMock.GetTotalTextChunksBySources got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetTotalTextChunksBySources.GetTotalTextChunksBySourcesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTotalTextChunksBySources.GetTotalTextChunksBySourcesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTotalTextChunksBySources.t.Fatal("No results are set for the RepositoryMock.GetTotalTextChunksBySources")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetTotalTextChunksBySources.funcGetTotalTextChunksBySources != nil {
		return mmGetTotalTextChunksBySources.funcGetTotalTextChunksBySources(ctx, sources)
	}
	mmGetTotalTextChunksBySources.t.Fatalf("Unexpected call to RepositoryMock.GetTotalTextChunksBySources. %v %v", ctx, sources)
	return
}

// GetTotalTextChunksBySourcesAfterCounter returns a count of finished RepositoryMock.GetTotalTextChunksBySources invocations
func (mmGetTotalTextChunksBySources *RepositoryMock) GetTotalTextChunksBySourcesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotalTextChunksBySources.afterGetTotalTextChunksBySourcesCounter)
}

// GetTotalTextChunksBySourcesBeforeCounter returns a count of RepositoryMock.GetTotalTextChunksBySources invocations
func (mmGetTotalTextChunksBySources *RepositoryMock) GetTotalTextChunksBySourcesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotalTextChunksBySources.beforeGetTotalTextChunksBySourcesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetTotalTextChunksBySources.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTotalTextChunksBySources *mRepositoryMockGetTotalTextChunksBySources) Calls() []*RepositoryMockGetTotalTextChunksBySourcesParams {
	mmGetTotalTextChunksBySources.mutex.RLock()

	argCopy := make([]*RepositoryMockGetTotalTextChunksBySourcesParams, len(mmGetTotalTextChunksBySources.callArgs))
	copy(argCopy, mmGetTotalTextChunksBySources.callArgs)

	mmGetTotalTextChunksBySources.mutex.RUnlock()

	return argCopy
}

// MinimockGetTotalTextChunksBySourcesDone returns true if the count of the GetTotalTextChunksBySources invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetTotalTextChunksBySourcesDone() bool {
	if m.GetTotalTextChunksBySourcesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetTotalTextChunksBySourcesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTotalTextChunksBySourcesMock.invocationsDone()
}

// MinimockGetTotalTextChunksBySourcesInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetTotalTextChunksBySourcesInspect() {
	for _, e := range m.GetTotalTextChunksBySourcesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetTotalTextChunksBySources at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetTotalTextChunksBySourcesCounter := mm_atomic.LoadUint64(&m.afterGetTotalTextChunksBySourcesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTotalTextChunksBySourcesMock.defaultExpectation != nil && afterGetTotalTextChunksBySourcesCounter < 1 {
		if m.GetTotalTextChunksBySourcesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetTotalTextChunksBySources at\n%s", m.GetTotalTextChunksBySourcesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetTotalTextChunksBySources at\n%s with params: %#v", m.GetTotalTextChunksBySourcesMock.defaultExpectation.expectationOrigins.origin, *m.GetTotalTextChunksBySourcesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTotalTextChunksBySources != nil && afterGetTotalTextChunksBySourcesCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetTotalTextChunksBySources at\n%s", m.funcGetTotalTextChunksBySourcesOrigin)
	}

	if !m.GetTotalTextChunksBySourcesMock.invocationsDone() && afterGetTotalTextChunksBySourcesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetTotalTextChunksBySources at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetTotalTextChunksBySourcesMock.expectedInvocations), m.GetTotalTextChunksBySourcesMock.expectedInvocationsOrigin, afterGetTotalTextChunksBySourcesCounter)
	}
}

type mRepositoryMockGetTotalTokensByListKBUIDs struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetTotalTokensByListKBUIDsExpectation
	expectations       []*RepositoryMockGetTotalTokensByListKBUIDsExpectation

	callArgs []*RepositoryMockGetTotalTokensByListKBUIDsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetTotalTokensByListKBUIDsExpectation specifies expectation struct of the Repository.GetTotalTokensByListKBUIDs
type RepositoryMockGetTotalTokensByListKBUIDsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetTotalTokensByListKBUIDsParams
	paramPtrs          *RepositoryMockGetTotalTokensByListKBUIDsParamPtrs
	expectationOrigins RepositoryMockGetTotalTokensByListKBUIDsExpectationOrigins
	results            *RepositoryMockGetTotalTokensByListKBUIDsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetTotalTokensByListKBUIDsParams contains parameters of the Repository.GetTotalTokensByListKBUIDs
type RepositoryMockGetTotalTokensByListKBUIDsParams struct {
	ctx    context.Context
	kbUIDs []types.KBUIDType
}

// RepositoryMockGetTotalTokensByListKBUIDsParamPtrs contains pointers to parameters of the Repository.GetTotalTokensByListKBUIDs
type RepositoryMockGetTotalTokensByListKBUIDsParamPtrs struct {
	ctx    *context.Context
	kbUIDs *[]types.KBUIDType
}

// RepositoryMockGetTotalTokensByListKBUIDsResults contains results of the Repository.GetTotalTokensByListKBUIDs
type RepositoryMockGetTotalTokensByListKBUIDsResults struct {
	m1  map[types.KBUIDType]int
	err error
}

// RepositoryMockGetTotalTokensByListKBUIDsOrigins contains origins of expectations of the Repository.GetTotalTokensByListKBUIDs
type RepositoryMockGetTotalTokensByListKBUIDsExpectationOrigins struct {
	origin       string
	originCtx    string
	originKbUIDs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetTotalTokensByListKBUIDs *mRepositoryMockGetTotalTokensByListKBUIDs) Optional() *mRepositoryMockGetTotalTokensByListKBUIDs {
	mmGetTotalTokensByListKBUIDs.optional = true
	return mmGetTotalTokensByListKBUIDs
}

// Expect sets up expected params for Repository.GetTotalTokensByListKBUIDs
func (mmGetTotalTokensByListKBUIDs *mRepositoryMockGetTotalTokensByListKBUIDs) Expect(ctx context.Context, kbUIDs []types.KBUIDType) *mRepositoryMockGetTotalTokensByListKBUIDs {
	if mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDs != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryMock.GetTotalTokensByListKBUIDs mock is already set by Set")
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation == nil {
		mmGetTotalTokensByListKBUIDs.defaultExpectation = &RepositoryMockGetTotalTokensByListKBUIDsExpectation{}
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation.paramPtrs != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryMock.GetTotalTokensByListKBUIDs mock is already set by ExpectParams functions")
	}

	mmGetTotalTokensByListKBUIDs.defaultExpectation.params = &RepositoryMockGetTotalTokensByListKBUIDsParams{ctx, kbUIDs}
	mmGetTotalTokensByListKBUIDs.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetTotalTokensByListKBUIDs.expectations {
		if minimock.Equal(e.params, mmGetTotalTokensByListKBUIDs.defaultExpectation.params) {
			mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTotalTokensByListKBUIDs.defaultExpectation.params)
		}
	}

	return mmGetTotalTokensByListKBUIDs
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetTotalTokensByListKBUIDs
func (mmGetTotalTokensByListKBUIDs *mRepositoryMockGetTotalTokensByListKBUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetTotalTokensByListKBUIDs {
	if mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDs != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryMock.GetTotalTokensByListKBUIDs mock is already set by Set")
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation == nil {
		mmGetTotalTokensByListKBUIDs.defaultExpectation = &RepositoryMockGetTotalTokensByListKBUIDsExpectation{}
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation.params != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryMock.GetTotalTokensByListKBUIDs mock is already set by Expect")
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation.paramPtrs == nil {
		mmGetTotalTokensByListKBUIDs.defaultExpectation.paramPtrs = &RepositoryMockGetTotalTokensByListKBUIDsParamPtrs{}
	}
	mmGetTotalTokensByListKBUIDs.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetTotalTokensByListKBUIDs.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetTotalTokensByListKBUIDs
}

// ExpectKbUIDsParam2 sets up expected param kbUIDs for Repository.GetTotalTokensByListKBUIDs
func (mmGetTotalTokensByListKBUIDs *mRepositoryMockGetTotalTokensByListKBUIDs) ExpectKbUIDsParam2(kbUIDs []types.KBUIDType) *mRepositoryMockGetTotalTokensByListKBUIDs {
	if mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDs != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryMock.GetTotalTokensByListKBUIDs mock is already set by Set")
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation == nil {
		mmGetTotalTokensByListKBUIDs.defaultExpectation = &RepositoryMockGetTotalTokensByListKBUIDsExpectation{}
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation.params != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryMock.GetTotalTokensByListKBUIDs mock is already set by Expect")
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation.paramPtrs == nil {
		mmGetTotalTokensByListKBUIDs.defaultExpectation.paramPtrs = &RepositoryMockGetTotalTokensByListKBUIDsParamPtrs{}
	}
	mmGetTotalTokensByListKBUIDs.defaultExpectation.paramPtrs.kbUIDs = &kbUIDs
	mmGetTotalTokensByListKBUIDs.defaultExpectation.expectationOrigins.originKbUIDs = minimock.CallerInfo(1)

	return mmGetTotalTokensByListKBUIDs
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetTotalTokensByListKBUIDs
func (mmGetTotalTokensByListKBUIDs *mRepositoryMockGetTotalTokensByListKBUIDs) Inspect(f func(ctx context.Context, kbUIDs []types.KBUIDType)) *mRepositoryMockGetTotalTokensByListKBUIDs {
	if mmGetTotalTokensByListKBUIDs.mock.inspectFuncGetTotalTokensByListKBUIDs != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetTotalTokensByListKBUIDs")
	}

	mmGetTotalTokensByListKBUIDs.mock.inspectFuncGetTotalTokensByListKBUIDs = f

	return mmGetTotalTokensByListKBUIDs
}

// Return sets up results that will be returned by Repository.GetTotalTokensByListKBUIDs
func (mmGetTotalTokensByListKBUIDs *mRepositoryMockGetTotalTokensByListKBUIDs) Return(m1 map[types.KBUIDType]int, err error) *RepositoryMock {
	if mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDs != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryMock.GetTotalTokensByListKBUIDs mock is already set by Set")
	}

	if mmGetTotalTokensByListKBUIDs.defaultExpectation == nil {
		mmGetTotalTokensByListKBUIDs.defaultExpectation = &RepositoryMockGetTotalTokensByListKBUIDsExpectation{mock: mmGetTotalTokensByListKBUIDs.mock}
	}
	mmGetTotalTokensByListKBUIDs.defaultExpectation.results = &RepositoryMockGetTotalTokensByListKBUIDsResults{m1, err}
	mmGetTotalTokensByListKBUIDs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetTotalTokensByListKBUIDs.mock
}

// Set uses given function f to mock the Repository.GetTotalTokensByListKBUIDs method
func (mmGetTotalTokensByListKBUIDs *mRepositoryMockGetTotalTokensByListKBUIDs) Set(f func(ctx context.Context, kbUIDs []types.KBUIDType) (m1 map[types.KBUIDType]int, err error)) *RepositoryMock {
	if mmGetTotalTokensByListKBUIDs.defaultExpectation != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("Default expectation is already set for the Repository.GetTotalTokensByListKBUIDs method")
	}

	if len(mmGetTotalTokensByListKBUIDs.expectations) > 0 {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("Some expectations are already set for the Repository.GetTotalTokensByListKBUIDs method")
	}

	mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDs = f
	mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDsOrigin = minimock.CallerInfo(1)
	return mmGetTotalTokensByListKBUIDs.mock
}

// When sets expectation for the Repository.GetTotalTokensByListKBUIDs which will trigger the result defined by the following
// Then helper
func (mmGetTotalTokensByListKBUIDs *mRepositoryMockGetTotalTokensByListKBUIDs) When(ctx context.Context, kbUIDs []types.KBUIDType) *RepositoryMockGetTotalTokensByListKBUIDsExpectation {
	if mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDs != nil {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("RepositoryMock.GetTotalTokensByListKBUIDs mock is already set by Set")
	}

	expectation := &RepositoryMockGetTotalTokensByListKBUIDsExpectation{
		mock:               mmGetTotalTokensByListKBUIDs.mock,
		params:             &RepositoryMockGetTotalTokensByListKBUIDsParams{ctx, kbUIDs},
		expectationOrigins: RepositoryMockGetTotalTokensByListKBUIDsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetTotalTokensByListKBUIDs.expectations = append(mmGetTotalTokensByListKBUIDs.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetTotalTokensByListKBUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetTotalTokensByListKBUIDsExpectation) Then(m1 map[types.KBUIDType]int, err error) *RepositoryMock {
	e.results = &RepositoryMockGetTotalTokensByListKBUIDsResults{m1, err}
	return e.mock
}

// Times sets number of times Repository.GetTotalTokensByListKBUIDs should be invoked
func (mmGetTotalTokensByListKBUIDs *mRepositoryMockGetTotalTokensByListKBUIDs) Times(n uint64) *mRepositoryMockGetTotalTokensByListKBUIDs {
	if n == 0 {
		mmGetTotalTokensByListKBUIDs.mock.t.Fatalf("Times of RepositoryMock.GetTotalTokensByListKBUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTotalTokensByListKBUIDs.expectedInvocations, n)
	mmGetTotalTokensByListKBUIDs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetTotalTokensByListKBUIDs
}

func (mmGetTotalTokensByListKBUIDs *mRepositoryMockGetTotalTokensByListKBUIDs) invocationsDone() bool {
	if len(mmGetTotalTokensByListKBUIDs.expectations) == 0 && mmGetTotalTokensByListKBUIDs.defaultExpectation == nil && mmGetTotalTokensByListKBUIDs.mock.funcGetTotalTokensByListKBUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTotalTokensByListKBUIDs.mock.afterGetTotalTokensByListKBUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTotalTokensByListKBUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTotalTokensByListKBUIDs implements mm_repository.Repository
func (mmGetTotalTokensByListKBUIDs *RepositoryMock) GetTotalTokensByListKBUIDs(ctx context.Context, kbUIDs []types.KBUIDType) (m1 map[types.KBUIDType]int, err error) {
	mm_atomic.AddUint64(&mmGetTotalTokensByListKBUIDs.beforeGetTotalTokensByListKBUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTotalTokensByListKBUIDs.afterGetTotalTokensByListKBUIDsCounter, 1)

	mmGetTotalTokensByListKBUIDs.t.Helper()

	if mmGetTotalTokensByListKBUIDs.inspectFuncGetTotalTokensByListKBUIDs != nil {
		mmGetTotalTokensByListKBUIDs.inspectFuncGetTotalTokensByListKBUIDs(ctx, kbUIDs)
	}

	mm_params := RepositoryMockGetTotalTokensByListKBUIDsParams{ctx, kbUIDs}

	// Record call args
	mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.mutex.Lock()
	mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.callArgs = append(mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.callArgs, &mm_params)
	mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.mutex.Unlock()

	for _, e := range mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetTotalTokensByListKBUIDsParams{ctx, kbUIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTotalTokensByListKBUIDs.t.Errorf("RepositoryMock.GetTotalTokensByListKBUIDs got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUIDs != nil && !minimock.Equal(*mm_want_ptrs.kbUIDs, mm_got.kbUIDs) {
				mmGetTotalTokensByListKBUIDs.t.Errorf("RepositoryMock.GetTotalTokensByListKBUIDs got unexpected parameter kbUIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.defaultExpectation.expectationOrigins.originKbUIDs, *mm_want_ptrs.kbUIDs, mm_got.kbUIDs, minimock.Diff(*mm_want_ptrs.kbUIDs, mm_got.kbUIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTotalTokensByListKBUIDs.t.Errorf("RepositoryMock.GetTotalTokensByListKBUIDs got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTotalTokensByListKBUIDs.GetTotalTokensByListKBUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTotalTokensByListKBUIDs.t.Fatal("No results are set for the RepositoryMock.GetTotalTokensByListKBUIDs")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetTotalTokensByListKBUIDs.funcGetTotalTokensByListKBUIDs != nil {
		return mmGetTotalTokensByListKBUIDs.funcGetTotalTokensByListKBUIDs(ctx, kbUIDs)
	}
	mmGetTotalTokensByListKBUIDs.t.Fatalf("Unexpected call to RepositoryMock.GetTotalTokensByListKBUIDs. %v %v", ctx, kbUIDs)
	return
}

// GetTotalTokensByListKBUIDsAfterCounter returns a count of finished RepositoryMock.GetTotalTokensByListKBUIDs invocations
func (mmGetTotalTokensByListKBUIDs *RepositoryMock) GetTotalTokensByListKBUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotalTokensByListKBUIDs.afterGetTotalTokensByListKBUIDsCounter)
}

// GetTotalTokensByListKBUIDsBeforeCounter returns a count of RepositoryMock.GetTotalTokensByListKBUIDs invocations
func (mmGetTotalTokensByListKBUIDs *RepositoryMock) GetTotalTokensByListKBUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotalTokensByListKBUIDs.beforeGetTotalTokensByListKBUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetTotalTokensByListKBUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTotalTokensByListKBUIDs *mRepositoryMockGetTotalTokensByListKBUIDs) Calls() []*RepositoryMockGetTotalTokensByListKBUIDsParams {
	mmGetTotalTokensByListKBUIDs.mutex.RLock()

	argCopy := make([]*RepositoryMockGetTotalTokensByListKBUIDsParams, len(mmGetTotalTokensByListKBUIDs.callArgs))
	copy(argCopy, mmGetTotalTokensByListKBUIDs.callArgs)

	mmGetTotalTokensByListKBUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockGetTotalTokensByListKBUIDsDone returns true if the count of the GetTotalTokensByListKBUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetTotalTokensByListKBUIDsDone() bool {
	if m.GetTotalTokensByListKBUIDsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetTotalTokensByListKBUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTotalTokensByListKBUIDsMock.invocationsDone()
}

// MinimockGetTotalTokensByListKBUIDsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetTotalTokensByListKBUIDsInspect() {
	for _, e := range m.GetTotalTokensByListKBUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetTotalTokensByListKBUIDs at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetTotalTokensByListKBUIDsCounter := mm_atomic.LoadUint64(&m.afterGetTotalTokensByListKBUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTotalTokensByListKBUIDsMock.defaultExpectation != nil && afterGetTotalTokensByListKBUIDsCounter < 1 {
		if m.GetTotalTokensByListKBUIDsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetTotalTokensByListKBUIDs at\n%s", m.GetTotalTokensByListKBUIDsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetTotalTokensByListKBUIDs at\n%s with params: %#v", m.GetTotalTokensByListKBUIDsMock.defaultExpectation.expectationOrigins.origin, *m.GetTotalTokensByListKBUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTotalTokensByListKBUIDs != nil && afterGetTotalTokensByListKBUIDsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetTotalTokensByListKBUIDs at\n%s", m.funcGetTotalTokensByListKBUIDsOrigin)
	}

	if !m.GetTotalTokensByListKBUIDsMock.invocationsDone() && afterGetTotalTokensByListKBUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetTotalTokensByListKBUIDs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetTotalTokensByListKBUIDsMock.expectedInvocations), m.GetTotalTokensByListKBUIDsMock.expectedInvocationsOrigin, afterGetTotalTokensByListKBUIDsCounter)
	}
}

type mRepositoryMockHardDeleteConvertedFileByFileUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockHardDeleteConvertedFileByFileUIDExpectation
	expectations       []*RepositoryMockHardDeleteConvertedFileByFileUIDExpectation

	callArgs []*RepositoryMockHardDeleteConvertedFileByFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockHardDeleteConvertedFileByFileUIDExpectation specifies expectation struct of the Repository.HardDeleteConvertedFileByFileUID
type RepositoryMockHardDeleteConvertedFileByFileUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockHardDeleteConvertedFileByFileUIDParams
	paramPtrs          *RepositoryMockHardDeleteConvertedFileByFileUIDParamPtrs
	expectationOrigins RepositoryMockHardDeleteConvertedFileByFileUIDExpectationOrigins
	results            *RepositoryMockHardDeleteConvertedFileByFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockHardDeleteConvertedFileByFileUIDParams contains parameters of the Repository.HardDeleteConvertedFileByFileUID
type RepositoryMockHardDeleteConvertedFileByFileUIDParams struct {
	ctx     context.Context
	fileUID types.FileUIDType
}

// RepositoryMockHardDeleteConvertedFileByFileUIDParamPtrs contains pointers to parameters of the Repository.HardDeleteConvertedFileByFileUID
type RepositoryMockHardDeleteConvertedFileByFileUIDParamPtrs struct {
	ctx     *context.Context
	fileUID *types.FileUIDType
}

// RepositoryMockHardDeleteConvertedFileByFileUIDResults contains results of the Repository.HardDeleteConvertedFileByFileUID
type RepositoryMockHardDeleteConvertedFileByFileUIDResults struct {
	err error
}

// RepositoryMockHardDeleteConvertedFileByFileUIDOrigins contains origins of expectations of the Repository.HardDeleteConvertedFileByFileUID
type RepositoryMockHardDeleteConvertedFileByFileUIDExpectationOrigins struct {
	origin        string
	originCtx     string
	originFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHardDeleteConvertedFileByFileUID *mRepositoryMockHardDeleteConvertedFileByFileUID) Optional() *mRepositoryMockHardDeleteConvertedFileByFileUID {
	mmHardDeleteConvertedFileByFileUID.optional = true
	return mmHardDeleteConvertedFileByFileUID
}

// Expect sets up expected params for Repository.HardDeleteConvertedFileByFileUID
func (mmHardDeleteConvertedFileByFileUID *mRepositoryMockHardDeleteConvertedFileByFileUID) Expect(ctx context.Context, fileUID types.FileUIDType) *mRepositoryMockHardDeleteConvertedFileByFileUID {
	if mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUID != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteConvertedFileByFileUID mock is already set by Set")
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation == nil {
		mmHardDeleteConvertedFileByFileUID.defaultExpectation = &RepositoryMockHardDeleteConvertedFileByFileUIDExpectation{}
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteConvertedFileByFileUID mock is already set by ExpectParams functions")
	}

	mmHardDeleteConvertedFileByFileUID.defaultExpectation.params = &RepositoryMockHardDeleteConvertedFileByFileUIDParams{ctx, fileUID}
	mmHardDeleteConvertedFileByFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHardDeleteConvertedFileByFileUID.expectations {
		if minimock.Equal(e.params, mmHardDeleteConvertedFileByFileUID.defaultExpectation.params) {
			mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHardDeleteConvertedFileByFileUID.defaultExpectation.params)
		}
	}

	return mmHardDeleteConvertedFileByFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.HardDeleteConvertedFileByFileUID
func (mmHardDeleteConvertedFileByFileUID *mRepositoryMockHardDeleteConvertedFileByFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockHardDeleteConvertedFileByFileUID {
	if mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUID != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteConvertedFileByFileUID mock is already set by Set")
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation == nil {
		mmHardDeleteConvertedFileByFileUID.defaultExpectation = &RepositoryMockHardDeleteConvertedFileByFileUIDExpectation{}
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation.params != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteConvertedFileByFileUID mock is already set by Expect")
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs = &RepositoryMockHardDeleteConvertedFileByFileUIDParamPtrs{}
	}
	mmHardDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmHardDeleteConvertedFileByFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmHardDeleteConvertedFileByFileUID
}

// ExpectFileUIDParam2 sets up expected param fileUID for Repository.HardDeleteConvertedFileByFileUID
func (mmHardDeleteConvertedFileByFileUID *mRepositoryMockHardDeleteConvertedFileByFileUID) ExpectFileUIDParam2(fileUID types.FileUIDType) *mRepositoryMockHardDeleteConvertedFileByFileUID {
	if mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUID != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteConvertedFileByFileUID mock is already set by Set")
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation == nil {
		mmHardDeleteConvertedFileByFileUID.defaultExpectation = &RepositoryMockHardDeleteConvertedFileByFileUIDExpectation{}
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation.params != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteConvertedFileByFileUID mock is already set by Expect")
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs = &RepositoryMockHardDeleteConvertedFileByFileUIDParamPtrs{}
	}
	mmHardDeleteConvertedFileByFileUID.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmHardDeleteConvertedFileByFileUID.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmHardDeleteConvertedFileByFileUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.HardDeleteConvertedFileByFileUID
func (mmHardDeleteConvertedFileByFileUID *mRepositoryMockHardDeleteConvertedFileByFileUID) Inspect(f func(ctx context.Context, fileUID types.FileUIDType)) *mRepositoryMockHardDeleteConvertedFileByFileUID {
	if mmHardDeleteConvertedFileByFileUID.mock.inspectFuncHardDeleteConvertedFileByFileUID != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.HardDeleteConvertedFileByFileUID")
	}

	mmHardDeleteConvertedFileByFileUID.mock.inspectFuncHardDeleteConvertedFileByFileUID = f

	return mmHardDeleteConvertedFileByFileUID
}

// Return sets up results that will be returned by Repository.HardDeleteConvertedFileByFileUID
func (mmHardDeleteConvertedFileByFileUID *mRepositoryMockHardDeleteConvertedFileByFileUID) Return(err error) *RepositoryMock {
	if mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUID != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteConvertedFileByFileUID mock is already set by Set")
	}

	if mmHardDeleteConvertedFileByFileUID.defaultExpectation == nil {
		mmHardDeleteConvertedFileByFileUID.defaultExpectation = &RepositoryMockHardDeleteConvertedFileByFileUIDExpectation{mock: mmHardDeleteConvertedFileByFileUID.mock}
	}
	mmHardDeleteConvertedFileByFileUID.defaultExpectation.results = &RepositoryMockHardDeleteConvertedFileByFileUIDResults{err}
	mmHardDeleteConvertedFileByFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHardDeleteConvertedFileByFileUID.mock
}

// Set uses given function f to mock the Repository.HardDeleteConvertedFileByFileUID method
func (mmHardDeleteConvertedFileByFileUID *mRepositoryMockHardDeleteConvertedFileByFileUID) Set(f func(ctx context.Context, fileUID types.FileUIDType) (err error)) *RepositoryMock {
	if mmHardDeleteConvertedFileByFileUID.defaultExpectation != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("Default expectation is already set for the Repository.HardDeleteConvertedFileByFileUID method")
	}

	if len(mmHardDeleteConvertedFileByFileUID.expectations) > 0 {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("Some expectations are already set for the Repository.HardDeleteConvertedFileByFileUID method")
	}

	mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUID = f
	mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUIDOrigin = minimock.CallerInfo(1)
	return mmHardDeleteConvertedFileByFileUID.mock
}

// When sets expectation for the Repository.HardDeleteConvertedFileByFileUID which will trigger the result defined by the following
// Then helper
func (mmHardDeleteConvertedFileByFileUID *mRepositoryMockHardDeleteConvertedFileByFileUID) When(ctx context.Context, fileUID types.FileUIDType) *RepositoryMockHardDeleteConvertedFileByFileUIDExpectation {
	if mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUID != nil {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteConvertedFileByFileUID mock is already set by Set")
	}

	expectation := &RepositoryMockHardDeleteConvertedFileByFileUIDExpectation{
		mock:               mmHardDeleteConvertedFileByFileUID.mock,
		params:             &RepositoryMockHardDeleteConvertedFileByFileUIDParams{ctx, fileUID},
		expectationOrigins: RepositoryMockHardDeleteConvertedFileByFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHardDeleteConvertedFileByFileUID.expectations = append(mmHardDeleteConvertedFileByFileUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.HardDeleteConvertedFileByFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockHardDeleteConvertedFileByFileUIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockHardDeleteConvertedFileByFileUIDResults{err}
	return e.mock
}

// Times sets number of times Repository.HardDeleteConvertedFileByFileUID should be invoked
func (mmHardDeleteConvertedFileByFileUID *mRepositoryMockHardDeleteConvertedFileByFileUID) Times(n uint64) *mRepositoryMockHardDeleteConvertedFileByFileUID {
	if n == 0 {
		mmHardDeleteConvertedFileByFileUID.mock.t.Fatalf("Times of RepositoryMock.HardDeleteConvertedFileByFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHardDeleteConvertedFileByFileUID.expectedInvocations, n)
	mmHardDeleteConvertedFileByFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHardDeleteConvertedFileByFileUID
}

func (mmHardDeleteConvertedFileByFileUID *mRepositoryMockHardDeleteConvertedFileByFileUID) invocationsDone() bool {
	if len(mmHardDeleteConvertedFileByFileUID.expectations) == 0 && mmHardDeleteConvertedFileByFileUID.defaultExpectation == nil && mmHardDeleteConvertedFileByFileUID.mock.funcHardDeleteConvertedFileByFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHardDeleteConvertedFileByFileUID.mock.afterHardDeleteConvertedFileByFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHardDeleteConvertedFileByFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HardDeleteConvertedFileByFileUID implements mm_repository.Repository
func (mmHardDeleteConvertedFileByFileUID *RepositoryMock) HardDeleteConvertedFileByFileUID(ctx context.Context, fileUID types.FileUIDType) (err error) {
	mm_atomic.AddUint64(&mmHardDeleteConvertedFileByFileUID.beforeHardDeleteConvertedFileByFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmHardDeleteConvertedFileByFileUID.afterHardDeleteConvertedFileByFileUIDCounter, 1)

	mmHardDeleteConvertedFileByFileUID.t.Helper()

	if mmHardDeleteConvertedFileByFileUID.inspectFuncHardDeleteConvertedFileByFileUID != nil {
		mmHardDeleteConvertedFileByFileUID.inspectFuncHardDeleteConvertedFileByFileUID(ctx, fileUID)
	}

	mm_params := RepositoryMockHardDeleteConvertedFileByFileUIDParams{ctx, fileUID}

	// Record call args
	mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.mutex.Lock()
	mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.callArgs = append(mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.callArgs, &mm_params)
	mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.mutex.Unlock()

	for _, e := range mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockHardDeleteConvertedFileByFileUIDParams{ctx, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHardDeleteConvertedFileByFileUID.t.Errorf("RepositoryMock.HardDeleteConvertedFileByFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmHardDeleteConvertedFileByFileUID.t.Errorf("RepositoryMock.HardDeleteConvertedFileByFileUID got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHardDeleteConvertedFileByFileUID.t.Errorf("RepositoryMock.HardDeleteConvertedFileByFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHardDeleteConvertedFileByFileUID.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmHardDeleteConvertedFileByFileUID.t.Fatal("No results are set for the RepositoryMock.HardDeleteConvertedFileByFileUID")
		}
		return (*mm_results).err
	}
	if mmHardDeleteConvertedFileByFileUID.funcHardDeleteConvertedFileByFileUID != nil {
		return mmHardDeleteConvertedFileByFileUID.funcHardDeleteConvertedFileByFileUID(ctx, fileUID)
	}
	mmHardDeleteConvertedFileByFileUID.t.Fatalf("Unexpected call to RepositoryMock.HardDeleteConvertedFileByFileUID. %v %v", ctx, fileUID)
	return
}

// HardDeleteConvertedFileByFileUIDAfterCounter returns a count of finished RepositoryMock.HardDeleteConvertedFileByFileUID invocations
func (mmHardDeleteConvertedFileByFileUID *RepositoryMock) HardDeleteConvertedFileByFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteConvertedFileByFileUID.afterHardDeleteConvertedFileByFileUIDCounter)
}

// HardDeleteConvertedFileByFileUIDBeforeCounter returns a count of RepositoryMock.HardDeleteConvertedFileByFileUID invocations
func (mmHardDeleteConvertedFileByFileUID *RepositoryMock) HardDeleteConvertedFileByFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteConvertedFileByFileUID.beforeHardDeleteConvertedFileByFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.HardDeleteConvertedFileByFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHardDeleteConvertedFileByFileUID *mRepositoryMockHardDeleteConvertedFileByFileUID) Calls() []*RepositoryMockHardDeleteConvertedFileByFileUIDParams {
	mmHardDeleteConvertedFileByFileUID.mutex.RLock()

	argCopy := make([]*RepositoryMockHardDeleteConvertedFileByFileUIDParams, len(mmHardDeleteConvertedFileByFileUID.callArgs))
	copy(argCopy, mmHardDeleteConvertedFileByFileUID.callArgs)

	mmHardDeleteConvertedFileByFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockHardDeleteConvertedFileByFileUIDDone returns true if the count of the HardDeleteConvertedFileByFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockHardDeleteConvertedFileByFileUIDDone() bool {
	if m.HardDeleteConvertedFileByFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HardDeleteConvertedFileByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HardDeleteConvertedFileByFileUIDMock.invocationsDone()
}

// MinimockHardDeleteConvertedFileByFileUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockHardDeleteConvertedFileByFileUIDInspect() {
	for _, e := range m.HardDeleteConvertedFileByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteConvertedFileByFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHardDeleteConvertedFileByFileUIDCounter := mm_atomic.LoadUint64(&m.afterHardDeleteConvertedFileByFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HardDeleteConvertedFileByFileUIDMock.defaultExpectation != nil && afterHardDeleteConvertedFileByFileUIDCounter < 1 {
		if m.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteConvertedFileByFileUID at\n%s", m.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteConvertedFileByFileUID at\n%s with params: %#v", m.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.HardDeleteConvertedFileByFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHardDeleteConvertedFileByFileUID != nil && afterHardDeleteConvertedFileByFileUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.HardDeleteConvertedFileByFileUID at\n%s", m.funcHardDeleteConvertedFileByFileUIDOrigin)
	}

	if !m.HardDeleteConvertedFileByFileUIDMock.invocationsDone() && afterHardDeleteConvertedFileByFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.HardDeleteConvertedFileByFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HardDeleteConvertedFileByFileUIDMock.expectedInvocations), m.HardDeleteConvertedFileByFileUIDMock.expectedInvocationsOrigin, afterHardDeleteConvertedFileByFileUIDCounter)
	}
}

type mRepositoryMockHardDeleteEmbeddingsByKBFileUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockHardDeleteEmbeddingsByKBFileUIDExpectation
	expectations       []*RepositoryMockHardDeleteEmbeddingsByKBFileUIDExpectation

	callArgs []*RepositoryMockHardDeleteEmbeddingsByKBFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockHardDeleteEmbeddingsByKBFileUIDExpectation specifies expectation struct of the Repository.HardDeleteEmbeddingsByKBFileUID
type RepositoryMockHardDeleteEmbeddingsByKBFileUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockHardDeleteEmbeddingsByKBFileUIDParams
	paramPtrs          *RepositoryMockHardDeleteEmbeddingsByKBFileUIDParamPtrs
	expectationOrigins RepositoryMockHardDeleteEmbeddingsByKBFileUIDExpectationOrigins
	results            *RepositoryMockHardDeleteEmbeddingsByKBFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockHardDeleteEmbeddingsByKBFileUIDParams contains parameters of the Repository.HardDeleteEmbeddingsByKBFileUID
type RepositoryMockHardDeleteEmbeddingsByKBFileUIDParams struct {
	ctx       context.Context
	kbFileUID types.FileUIDType
}

// RepositoryMockHardDeleteEmbeddingsByKBFileUIDParamPtrs contains pointers to parameters of the Repository.HardDeleteEmbeddingsByKBFileUID
type RepositoryMockHardDeleteEmbeddingsByKBFileUIDParamPtrs struct {
	ctx       *context.Context
	kbFileUID *types.FileUIDType
}

// RepositoryMockHardDeleteEmbeddingsByKBFileUIDResults contains results of the Repository.HardDeleteEmbeddingsByKBFileUID
type RepositoryMockHardDeleteEmbeddingsByKBFileUIDResults struct {
	err error
}

// RepositoryMockHardDeleteEmbeddingsByKBFileUIDOrigins contains origins of expectations of the Repository.HardDeleteEmbeddingsByKBFileUID
type RepositoryMockHardDeleteEmbeddingsByKBFileUIDExpectationOrigins struct {
	origin          string
	originCtx       string
	originKbFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHardDeleteEmbeddingsByKBFileUID *mRepositoryMockHardDeleteEmbeddingsByKBFileUID) Optional() *mRepositoryMockHardDeleteEmbeddingsByKBFileUID {
	mmHardDeleteEmbeddingsByKBFileUID.optional = true
	return mmHardDeleteEmbeddingsByKBFileUID
}

// Expect sets up expected params for Repository.HardDeleteEmbeddingsByKBFileUID
func (mmHardDeleteEmbeddingsByKBFileUID *mRepositoryMockHardDeleteEmbeddingsByKBFileUID) Expect(ctx context.Context, kbFileUID types.FileUIDType) *mRepositoryMockHardDeleteEmbeddingsByKBFileUID {
	if mmHardDeleteEmbeddingsByKBFileUID.mock.funcHardDeleteEmbeddingsByKBFileUID != nil {
		mmHardDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBFileUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation = &RepositoryMockHardDeleteEmbeddingsByKBFileUIDExpectation{}
	}

	if mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.paramPtrs != nil {
		mmHardDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBFileUID mock is already set by ExpectParams functions")
	}

	mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.params = &RepositoryMockHardDeleteEmbeddingsByKBFileUIDParams{ctx, kbFileUID}
	mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHardDeleteEmbeddingsByKBFileUID.expectations {
		if minimock.Equal(e.params, mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.params) {
			mmHardDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.params)
		}
	}

	return mmHardDeleteEmbeddingsByKBFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.HardDeleteEmbeddingsByKBFileUID
func (mmHardDeleteEmbeddingsByKBFileUID *mRepositoryMockHardDeleteEmbeddingsByKBFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockHardDeleteEmbeddingsByKBFileUID {
	if mmHardDeleteEmbeddingsByKBFileUID.mock.funcHardDeleteEmbeddingsByKBFileUID != nil {
		mmHardDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBFileUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation = &RepositoryMockHardDeleteEmbeddingsByKBFileUIDExpectation{}
	}

	if mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.params != nil {
		mmHardDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBFileUID mock is already set by Expect")
	}

	if mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.paramPtrs = &RepositoryMockHardDeleteEmbeddingsByKBFileUIDParamPtrs{}
	}
	mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmHardDeleteEmbeddingsByKBFileUID
}

// ExpectKbFileUIDParam2 sets up expected param kbFileUID for Repository.HardDeleteEmbeddingsByKBFileUID
func (mmHardDeleteEmbeddingsByKBFileUID *mRepositoryMockHardDeleteEmbeddingsByKBFileUID) ExpectKbFileUIDParam2(kbFileUID types.FileUIDType) *mRepositoryMockHardDeleteEmbeddingsByKBFileUID {
	if mmHardDeleteEmbeddingsByKBFileUID.mock.funcHardDeleteEmbeddingsByKBFileUID != nil {
		mmHardDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBFileUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation = &RepositoryMockHardDeleteEmbeddingsByKBFileUIDExpectation{}
	}

	if mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.params != nil {
		mmHardDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBFileUID mock is already set by Expect")
	}

	if mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.paramPtrs = &RepositoryMockHardDeleteEmbeddingsByKBFileUIDParamPtrs{}
	}
	mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.paramPtrs.kbFileUID = &kbFileUID
	mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.expectationOrigins.originKbFileUID = minimock.CallerInfo(1)

	return mmHardDeleteEmbeddingsByKBFileUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.HardDeleteEmbeddingsByKBFileUID
func (mmHardDeleteEmbeddingsByKBFileUID *mRepositoryMockHardDeleteEmbeddingsByKBFileUID) Inspect(f func(ctx context.Context, kbFileUID types.FileUIDType)) *mRepositoryMockHardDeleteEmbeddingsByKBFileUID {
	if mmHardDeleteEmbeddingsByKBFileUID.mock.inspectFuncHardDeleteEmbeddingsByKBFileUID != nil {
		mmHardDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.HardDeleteEmbeddingsByKBFileUID")
	}

	mmHardDeleteEmbeddingsByKBFileUID.mock.inspectFuncHardDeleteEmbeddingsByKBFileUID = f

	return mmHardDeleteEmbeddingsByKBFileUID
}

// Return sets up results that will be returned by Repository.HardDeleteEmbeddingsByKBFileUID
func (mmHardDeleteEmbeddingsByKBFileUID *mRepositoryMockHardDeleteEmbeddingsByKBFileUID) Return(err error) *RepositoryMock {
	if mmHardDeleteEmbeddingsByKBFileUID.mock.funcHardDeleteEmbeddingsByKBFileUID != nil {
		mmHardDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBFileUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation = &RepositoryMockHardDeleteEmbeddingsByKBFileUIDExpectation{mock: mmHardDeleteEmbeddingsByKBFileUID.mock}
	}
	mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.results = &RepositoryMockHardDeleteEmbeddingsByKBFileUIDResults{err}
	mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHardDeleteEmbeddingsByKBFileUID.mock
}

// Set uses given function f to mock the Repository.HardDeleteEmbeddingsByKBFileUID method
func (mmHardDeleteEmbeddingsByKBFileUID *mRepositoryMockHardDeleteEmbeddingsByKBFileUID) Set(f func(ctx context.Context, kbFileUID types.FileUIDType) (err error)) *RepositoryMock {
	if mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation != nil {
		mmHardDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("Default expectation is already set for the Repository.HardDeleteEmbeddingsByKBFileUID method")
	}

	if len(mmHardDeleteEmbeddingsByKBFileUID.expectations) > 0 {
		mmHardDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("Some expectations are already set for the Repository.HardDeleteEmbeddingsByKBFileUID method")
	}

	mmHardDeleteEmbeddingsByKBFileUID.mock.funcHardDeleteEmbeddingsByKBFileUID = f
	mmHardDeleteEmbeddingsByKBFileUID.mock.funcHardDeleteEmbeddingsByKBFileUIDOrigin = minimock.CallerInfo(1)
	return mmHardDeleteEmbeddingsByKBFileUID.mock
}

// When sets expectation for the Repository.HardDeleteEmbeddingsByKBFileUID which will trigger the result defined by the following
// Then helper
func (mmHardDeleteEmbeddingsByKBFileUID *mRepositoryMockHardDeleteEmbeddingsByKBFileUID) When(ctx context.Context, kbFileUID types.FileUIDType) *RepositoryMockHardDeleteEmbeddingsByKBFileUIDExpectation {
	if mmHardDeleteEmbeddingsByKBFileUID.mock.funcHardDeleteEmbeddingsByKBFileUID != nil {
		mmHardDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBFileUID mock is already set by Set")
	}

	expectation := &RepositoryMockHardDeleteEmbeddingsByKBFileUIDExpectation{
		mock:               mmHardDeleteEmbeddingsByKBFileUID.mock,
		params:             &RepositoryMockHardDeleteEmbeddingsByKBFileUIDParams{ctx, kbFileUID},
		expectationOrigins: RepositoryMockHardDeleteEmbeddingsByKBFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHardDeleteEmbeddingsByKBFileUID.expectations = append(mmHardDeleteEmbeddingsByKBFileUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.HardDeleteEmbeddingsByKBFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockHardDeleteEmbeddingsByKBFileUIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockHardDeleteEmbeddingsByKBFileUIDResults{err}
	return e.mock
}

// Times sets number of times Repository.HardDeleteEmbeddingsByKBFileUID should be invoked
func (mmHardDeleteEmbeddingsByKBFileUID *mRepositoryMockHardDeleteEmbeddingsByKBFileUID) Times(n uint64) *mRepositoryMockHardDeleteEmbeddingsByKBFileUID {
	if n == 0 {
		mmHardDeleteEmbeddingsByKBFileUID.mock.t.Fatalf("Times of RepositoryMock.HardDeleteEmbeddingsByKBFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHardDeleteEmbeddingsByKBFileUID.expectedInvocations, n)
	mmHardDeleteEmbeddingsByKBFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHardDeleteEmbeddingsByKBFileUID
}

func (mmHardDeleteEmbeddingsByKBFileUID *mRepositoryMockHardDeleteEmbeddingsByKBFileUID) invocationsDone() bool {
	if len(mmHardDeleteEmbeddingsByKBFileUID.expectations) == 0 && mmHardDeleteEmbeddingsByKBFileUID.defaultExpectation == nil && mmHardDeleteEmbeddingsByKBFileUID.mock.funcHardDeleteEmbeddingsByKBFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKBFileUID.mock.afterHardDeleteEmbeddingsByKBFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKBFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HardDeleteEmbeddingsByKBFileUID implements mm_repository.Repository
func (mmHardDeleteEmbeddingsByKBFileUID *RepositoryMock) HardDeleteEmbeddingsByKBFileUID(ctx context.Context, kbFileUID types.FileUIDType) (err error) {
	mm_atomic.AddUint64(&mmHardDeleteEmbeddingsByKBFileUID.beforeHardDeleteEmbeddingsByKBFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmHardDeleteEmbeddingsByKBFileUID.afterHardDeleteEmbeddingsByKBFileUIDCounter, 1)

	mmHardDeleteEmbeddingsByKBFileUID.t.Helper()

	if mmHardDeleteEmbeddingsByKBFileUID.inspectFuncHardDeleteEmbeddingsByKBFileUID != nil {
		mmHardDeleteEmbeddingsByKBFileUID.inspectFuncHardDeleteEmbeddingsByKBFileUID(ctx, kbFileUID)
	}

	mm_params := RepositoryMockHardDeleteEmbeddingsByKBFileUIDParams{ctx, kbFileUID}

	// Record call args
	mmHardDeleteEmbeddingsByKBFileUID.HardDeleteEmbeddingsByKBFileUIDMock.mutex.Lock()
	mmHardDeleteEmbeddingsByKBFileUID.HardDeleteEmbeddingsByKBFileUIDMock.callArgs = append(mmHardDeleteEmbeddingsByKBFileUID.HardDeleteEmbeddingsByKBFileUIDMock.callArgs, &mm_params)
	mmHardDeleteEmbeddingsByKBFileUID.HardDeleteEmbeddingsByKBFileUIDMock.mutex.Unlock()

	for _, e := range mmHardDeleteEmbeddingsByKBFileUID.HardDeleteEmbeddingsByKBFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHardDeleteEmbeddingsByKBFileUID.HardDeleteEmbeddingsByKBFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHardDeleteEmbeddingsByKBFileUID.HardDeleteEmbeddingsByKBFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmHardDeleteEmbeddingsByKBFileUID.HardDeleteEmbeddingsByKBFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmHardDeleteEmbeddingsByKBFileUID.HardDeleteEmbeddingsByKBFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockHardDeleteEmbeddingsByKBFileUIDParams{ctx, kbFileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHardDeleteEmbeddingsByKBFileUID.t.Errorf("RepositoryMock.HardDeleteEmbeddingsByKBFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHardDeleteEmbeddingsByKBFileUID.HardDeleteEmbeddingsByKBFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbFileUID != nil && !minimock.Equal(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID) {
				mmHardDeleteEmbeddingsByKBFileUID.t.Errorf("RepositoryMock.HardDeleteEmbeddingsByKBFileUID got unexpected parameter kbFileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHardDeleteEmbeddingsByKBFileUID.HardDeleteEmbeddingsByKBFileUIDMock.defaultExpectation.expectationOrigins.originKbFileUID, *mm_want_ptrs.kbFileUID, mm_got.kbFileUID, minimock.Diff(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHardDeleteEmbeddingsByKBFileUID.t.Errorf("RepositoryMock.HardDeleteEmbeddingsByKBFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHardDeleteEmbeddingsByKBFileUID.HardDeleteEmbeddingsByKBFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHardDeleteEmbeddingsByKBFileUID.HardDeleteEmbeddingsByKBFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmHardDeleteEmbeddingsByKBFileUID.t.Fatal("No results are set for the RepositoryMock.HardDeleteEmbeddingsByKBFileUID")
		}
		return (*mm_results).err
	}
	if mmHardDeleteEmbeddingsByKBFileUID.funcHardDeleteEmbeddingsByKBFileUID != nil {
		return mmHardDeleteEmbeddingsByKBFileUID.funcHardDeleteEmbeddingsByKBFileUID(ctx, kbFileUID)
	}
	mmHardDeleteEmbeddingsByKBFileUID.t.Fatalf("Unexpected call to RepositoryMock.HardDeleteEmbeddingsByKBFileUID. %v %v", ctx, kbFileUID)
	return
}

// HardDeleteEmbeddingsByKBFileUIDAfterCounter returns a count of finished RepositoryMock.HardDeleteEmbeddingsByKBFileUID invocations
func (mmHardDeleteEmbeddingsByKBFileUID *RepositoryMock) HardDeleteEmbeddingsByKBFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKBFileUID.afterHardDeleteEmbeddingsByKBFileUIDCounter)
}

// HardDeleteEmbeddingsByKBFileUIDBeforeCounter returns a count of RepositoryMock.HardDeleteEmbeddingsByKBFileUID invocations
func (mmHardDeleteEmbeddingsByKBFileUID *RepositoryMock) HardDeleteEmbeddingsByKBFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKBFileUID.beforeHardDeleteEmbeddingsByKBFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.HardDeleteEmbeddingsByKBFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHardDeleteEmbeddingsByKBFileUID *mRepositoryMockHardDeleteEmbeddingsByKBFileUID) Calls() []*RepositoryMockHardDeleteEmbeddingsByKBFileUIDParams {
	mmHardDeleteEmbeddingsByKBFileUID.mutex.RLock()

	argCopy := make([]*RepositoryMockHardDeleteEmbeddingsByKBFileUIDParams, len(mmHardDeleteEmbeddingsByKBFileUID.callArgs))
	copy(argCopy, mmHardDeleteEmbeddingsByKBFileUID.callArgs)

	mmHardDeleteEmbeddingsByKBFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockHardDeleteEmbeddingsByKBFileUIDDone returns true if the count of the HardDeleteEmbeddingsByKBFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockHardDeleteEmbeddingsByKBFileUIDDone() bool {
	if m.HardDeleteEmbeddingsByKBFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HardDeleteEmbeddingsByKBFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HardDeleteEmbeddingsByKBFileUIDMock.invocationsDone()
}

// MinimockHardDeleteEmbeddingsByKBFileUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockHardDeleteEmbeddingsByKBFileUIDInspect() {
	for _, e := range m.HardDeleteEmbeddingsByKBFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteEmbeddingsByKBFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHardDeleteEmbeddingsByKBFileUIDCounter := mm_atomic.LoadUint64(&m.afterHardDeleteEmbeddingsByKBFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HardDeleteEmbeddingsByKBFileUIDMock.defaultExpectation != nil && afterHardDeleteEmbeddingsByKBFileUIDCounter < 1 {
		if m.HardDeleteEmbeddingsByKBFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteEmbeddingsByKBFileUID at\n%s", m.HardDeleteEmbeddingsByKBFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteEmbeddingsByKBFileUID at\n%s with params: %#v", m.HardDeleteEmbeddingsByKBFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.HardDeleteEmbeddingsByKBFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHardDeleteEmbeddingsByKBFileUID != nil && afterHardDeleteEmbeddingsByKBFileUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.HardDeleteEmbeddingsByKBFileUID at\n%s", m.funcHardDeleteEmbeddingsByKBFileUIDOrigin)
	}

	if !m.HardDeleteEmbeddingsByKBFileUIDMock.invocationsDone() && afterHardDeleteEmbeddingsByKBFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.HardDeleteEmbeddingsByKBFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HardDeleteEmbeddingsByKBFileUIDMock.expectedInvocations), m.HardDeleteEmbeddingsByKBFileUIDMock.expectedInvocationsOrigin, afterHardDeleteEmbeddingsByKBFileUIDCounter)
	}
}

type mRepositoryMockHardDeleteEmbeddingsByKBUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockHardDeleteEmbeddingsByKBUIDExpectation
	expectations       []*RepositoryMockHardDeleteEmbeddingsByKBUIDExpectation

	callArgs []*RepositoryMockHardDeleteEmbeddingsByKBUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockHardDeleteEmbeddingsByKBUIDExpectation specifies expectation struct of the Repository.HardDeleteEmbeddingsByKBUID
type RepositoryMockHardDeleteEmbeddingsByKBUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockHardDeleteEmbeddingsByKBUIDParams
	paramPtrs          *RepositoryMockHardDeleteEmbeddingsByKBUIDParamPtrs
	expectationOrigins RepositoryMockHardDeleteEmbeddingsByKBUIDExpectationOrigins
	results            *RepositoryMockHardDeleteEmbeddingsByKBUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockHardDeleteEmbeddingsByKBUIDParams contains parameters of the Repository.HardDeleteEmbeddingsByKBUID
type RepositoryMockHardDeleteEmbeddingsByKBUIDParams struct {
	ctx   context.Context
	kbUID types.KBUIDType
}

// RepositoryMockHardDeleteEmbeddingsByKBUIDParamPtrs contains pointers to parameters of the Repository.HardDeleteEmbeddingsByKBUID
type RepositoryMockHardDeleteEmbeddingsByKBUIDParamPtrs struct {
	ctx   *context.Context
	kbUID *types.KBUIDType
}

// RepositoryMockHardDeleteEmbeddingsByKBUIDResults contains results of the Repository.HardDeleteEmbeddingsByKBUID
type RepositoryMockHardDeleteEmbeddingsByKBUIDResults struct {
	err error
}

// RepositoryMockHardDeleteEmbeddingsByKBUIDOrigins contains origins of expectations of the Repository.HardDeleteEmbeddingsByKBUID
type RepositoryMockHardDeleteEmbeddingsByKBUIDExpectationOrigins struct {
	origin      string
	originCtx   string
	originKbUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHardDeleteEmbeddingsByKBUID *mRepositoryMockHardDeleteEmbeddingsByKBUID) Optional() *mRepositoryMockHardDeleteEmbeddingsByKBUID {
	mmHardDeleteEmbeddingsByKBUID.optional = true
	return mmHardDeleteEmbeddingsByKBUID
}

// Expect sets up expected params for Repository.HardDeleteEmbeddingsByKBUID
func (mmHardDeleteEmbeddingsByKBUID *mRepositoryMockHardDeleteEmbeddingsByKBUID) Expect(ctx context.Context, kbUID types.KBUIDType) *mRepositoryMockHardDeleteEmbeddingsByKBUID {
	if mmHardDeleteEmbeddingsByKBUID.mock.funcHardDeleteEmbeddingsByKBUID != nil {
		mmHardDeleteEmbeddingsByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKBUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKBUID.defaultExpectation = &RepositoryMockHardDeleteEmbeddingsByKBUIDExpectation{}
	}

	if mmHardDeleteEmbeddingsByKBUID.defaultExpectation.paramPtrs != nil {
		mmHardDeleteEmbeddingsByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBUID mock is already set by ExpectParams functions")
	}

	mmHardDeleteEmbeddingsByKBUID.defaultExpectation.params = &RepositoryMockHardDeleteEmbeddingsByKBUIDParams{ctx, kbUID}
	mmHardDeleteEmbeddingsByKBUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHardDeleteEmbeddingsByKBUID.expectations {
		if minimock.Equal(e.params, mmHardDeleteEmbeddingsByKBUID.defaultExpectation.params) {
			mmHardDeleteEmbeddingsByKBUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHardDeleteEmbeddingsByKBUID.defaultExpectation.params)
		}
	}

	return mmHardDeleteEmbeddingsByKBUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.HardDeleteEmbeddingsByKBUID
func (mmHardDeleteEmbeddingsByKBUID *mRepositoryMockHardDeleteEmbeddingsByKBUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockHardDeleteEmbeddingsByKBUID {
	if mmHardDeleteEmbeddingsByKBUID.mock.funcHardDeleteEmbeddingsByKBUID != nil {
		mmHardDeleteEmbeddingsByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKBUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKBUID.defaultExpectation = &RepositoryMockHardDeleteEmbeddingsByKBUIDExpectation{}
	}

	if mmHardDeleteEmbeddingsByKBUID.defaultExpectation.params != nil {
		mmHardDeleteEmbeddingsByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBUID mock is already set by Expect")
	}

	if mmHardDeleteEmbeddingsByKBUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteEmbeddingsByKBUID.defaultExpectation.paramPtrs = &RepositoryMockHardDeleteEmbeddingsByKBUIDParamPtrs{}
	}
	mmHardDeleteEmbeddingsByKBUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmHardDeleteEmbeddingsByKBUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmHardDeleteEmbeddingsByKBUID
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.HardDeleteEmbeddingsByKBUID
func (mmHardDeleteEmbeddingsByKBUID *mRepositoryMockHardDeleteEmbeddingsByKBUID) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockHardDeleteEmbeddingsByKBUID {
	if mmHardDeleteEmbeddingsByKBUID.mock.funcHardDeleteEmbeddingsByKBUID != nil {
		mmHardDeleteEmbeddingsByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKBUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKBUID.defaultExpectation = &RepositoryMockHardDeleteEmbeddingsByKBUIDExpectation{}
	}

	if mmHardDeleteEmbeddingsByKBUID.defaultExpectation.params != nil {
		mmHardDeleteEmbeddingsByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBUID mock is already set by Expect")
	}

	if mmHardDeleteEmbeddingsByKBUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteEmbeddingsByKBUID.defaultExpectation.paramPtrs = &RepositoryMockHardDeleteEmbeddingsByKBUIDParamPtrs{}
	}
	mmHardDeleteEmbeddingsByKBUID.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmHardDeleteEmbeddingsByKBUID.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmHardDeleteEmbeddingsByKBUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.HardDeleteEmbeddingsByKBUID
func (mmHardDeleteEmbeddingsByKBUID *mRepositoryMockHardDeleteEmbeddingsByKBUID) Inspect(f func(ctx context.Context, kbUID types.KBUIDType)) *mRepositoryMockHardDeleteEmbeddingsByKBUID {
	if mmHardDeleteEmbeddingsByKBUID.mock.inspectFuncHardDeleteEmbeddingsByKBUID != nil {
		mmHardDeleteEmbeddingsByKBUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.HardDeleteEmbeddingsByKBUID")
	}

	mmHardDeleteEmbeddingsByKBUID.mock.inspectFuncHardDeleteEmbeddingsByKBUID = f

	return mmHardDeleteEmbeddingsByKBUID
}

// Return sets up results that will be returned by Repository.HardDeleteEmbeddingsByKBUID
func (mmHardDeleteEmbeddingsByKBUID *mRepositoryMockHardDeleteEmbeddingsByKBUID) Return(err error) *RepositoryMock {
	if mmHardDeleteEmbeddingsByKBUID.mock.funcHardDeleteEmbeddingsByKBUID != nil {
		mmHardDeleteEmbeddingsByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBUID mock is already set by Set")
	}

	if mmHardDeleteEmbeddingsByKBUID.defaultExpectation == nil {
		mmHardDeleteEmbeddingsByKBUID.defaultExpectation = &RepositoryMockHardDeleteEmbeddingsByKBUIDExpectation{mock: mmHardDeleteEmbeddingsByKBUID.mock}
	}
	mmHardDeleteEmbeddingsByKBUID.defaultExpectation.results = &RepositoryMockHardDeleteEmbeddingsByKBUIDResults{err}
	mmHardDeleteEmbeddingsByKBUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHardDeleteEmbeddingsByKBUID.mock
}

// Set uses given function f to mock the Repository.HardDeleteEmbeddingsByKBUID method
func (mmHardDeleteEmbeddingsByKBUID *mRepositoryMockHardDeleteEmbeddingsByKBUID) Set(f func(ctx context.Context, kbUID types.KBUIDType) (err error)) *RepositoryMock {
	if mmHardDeleteEmbeddingsByKBUID.defaultExpectation != nil {
		mmHardDeleteEmbeddingsByKBUID.mock.t.Fatalf("Default expectation is already set for the Repository.HardDeleteEmbeddingsByKBUID method")
	}

	if len(mmHardDeleteEmbeddingsByKBUID.expectations) > 0 {
		mmHardDeleteEmbeddingsByKBUID.mock.t.Fatalf("Some expectations are already set for the Repository.HardDeleteEmbeddingsByKBUID method")
	}

	mmHardDeleteEmbeddingsByKBUID.mock.funcHardDeleteEmbeddingsByKBUID = f
	mmHardDeleteEmbeddingsByKBUID.mock.funcHardDeleteEmbeddingsByKBUIDOrigin = minimock.CallerInfo(1)
	return mmHardDeleteEmbeddingsByKBUID.mock
}

// When sets expectation for the Repository.HardDeleteEmbeddingsByKBUID which will trigger the result defined by the following
// Then helper
func (mmHardDeleteEmbeddingsByKBUID *mRepositoryMockHardDeleteEmbeddingsByKBUID) When(ctx context.Context, kbUID types.KBUIDType) *RepositoryMockHardDeleteEmbeddingsByKBUIDExpectation {
	if mmHardDeleteEmbeddingsByKBUID.mock.funcHardDeleteEmbeddingsByKBUID != nil {
		mmHardDeleteEmbeddingsByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteEmbeddingsByKBUID mock is already set by Set")
	}

	expectation := &RepositoryMockHardDeleteEmbeddingsByKBUIDExpectation{
		mock:               mmHardDeleteEmbeddingsByKBUID.mock,
		params:             &RepositoryMockHardDeleteEmbeddingsByKBUIDParams{ctx, kbUID},
		expectationOrigins: RepositoryMockHardDeleteEmbeddingsByKBUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHardDeleteEmbeddingsByKBUID.expectations = append(mmHardDeleteEmbeddingsByKBUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.HardDeleteEmbeddingsByKBUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockHardDeleteEmbeddingsByKBUIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockHardDeleteEmbeddingsByKBUIDResults{err}
	return e.mock
}

// Times sets number of times Repository.HardDeleteEmbeddingsByKBUID should be invoked
func (mmHardDeleteEmbeddingsByKBUID *mRepositoryMockHardDeleteEmbeddingsByKBUID) Times(n uint64) *mRepositoryMockHardDeleteEmbeddingsByKBUID {
	if n == 0 {
		mmHardDeleteEmbeddingsByKBUID.mock.t.Fatalf("Times of RepositoryMock.HardDeleteEmbeddingsByKBUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHardDeleteEmbeddingsByKBUID.expectedInvocations, n)
	mmHardDeleteEmbeddingsByKBUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHardDeleteEmbeddingsByKBUID
}

func (mmHardDeleteEmbeddingsByKBUID *mRepositoryMockHardDeleteEmbeddingsByKBUID) invocationsDone() bool {
	if len(mmHardDeleteEmbeddingsByKBUID.expectations) == 0 && mmHardDeleteEmbeddingsByKBUID.defaultExpectation == nil && mmHardDeleteEmbeddingsByKBUID.mock.funcHardDeleteEmbeddingsByKBUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKBUID.mock.afterHardDeleteEmbeddingsByKBUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKBUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HardDeleteEmbeddingsByKBUID implements mm_repository.Repository
func (mmHardDeleteEmbeddingsByKBUID *RepositoryMock) HardDeleteEmbeddingsByKBUID(ctx context.Context, kbUID types.KBUIDType) (err error) {
	mm_atomic.AddUint64(&mmHardDeleteEmbeddingsByKBUID.beforeHardDeleteEmbeddingsByKBUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmHardDeleteEmbeddingsByKBUID.afterHardDeleteEmbeddingsByKBUIDCounter, 1)

	mmHardDeleteEmbeddingsByKBUID.t.Helper()

	if mmHardDeleteEmbeddingsByKBUID.inspectFuncHardDeleteEmbeddingsByKBUID != nil {
		mmHardDeleteEmbeddingsByKBUID.inspectFuncHardDeleteEmbeddingsByKBUID(ctx, kbUID)
	}

	mm_params := RepositoryMockHardDeleteEmbeddingsByKBUIDParams{ctx, kbUID}

	// Record call args
	mmHardDeleteEmbeddingsByKBUID.HardDeleteEmbeddingsByKBUIDMock.mutex.Lock()
	mmHardDeleteEmbeddingsByKBUID.HardDeleteEmbeddingsByKBUIDMock.callArgs = append(mmHardDeleteEmbeddingsByKBUID.HardDeleteEmbeddingsByKBUIDMock.callArgs, &mm_params)
	mmHardDeleteEmbeddingsByKBUID.HardDeleteEmbeddingsByKBUIDMock.mutex.Unlock()

	for _, e := range mmHardDeleteEmbeddingsByKBUID.HardDeleteEmbeddingsByKBUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHardDeleteEmbeddingsByKBUID.HardDeleteEmbeddingsByKBUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHardDeleteEmbeddingsByKBUID.HardDeleteEmbeddingsByKBUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmHardDeleteEmbeddingsByKBUID.HardDeleteEmbeddingsByKBUIDMock.defaultExpectation.params
		mm_want_ptrs := mmHardDeleteEmbeddingsByKBUID.HardDeleteEmbeddingsByKBUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockHardDeleteEmbeddingsByKBUIDParams{ctx, kbUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHardDeleteEmbeddingsByKBUID.t.Errorf("RepositoryMock.HardDeleteEmbeddingsByKBUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHardDeleteEmbeddingsByKBUID.HardDeleteEmbeddingsByKBUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmHardDeleteEmbeddingsByKBUID.t.Errorf("RepositoryMock.HardDeleteEmbeddingsByKBUID got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHardDeleteEmbeddingsByKBUID.HardDeleteEmbeddingsByKBUIDMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHardDeleteEmbeddingsByKBUID.t.Errorf("RepositoryMock.HardDeleteEmbeddingsByKBUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHardDeleteEmbeddingsByKBUID.HardDeleteEmbeddingsByKBUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHardDeleteEmbeddingsByKBUID.HardDeleteEmbeddingsByKBUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmHardDeleteEmbeddingsByKBUID.t.Fatal("No results are set for the RepositoryMock.HardDeleteEmbeddingsByKBUID")
		}
		return (*mm_results).err
	}
	if mmHardDeleteEmbeddingsByKBUID.funcHardDeleteEmbeddingsByKBUID != nil {
		return mmHardDeleteEmbeddingsByKBUID.funcHardDeleteEmbeddingsByKBUID(ctx, kbUID)
	}
	mmHardDeleteEmbeddingsByKBUID.t.Fatalf("Unexpected call to RepositoryMock.HardDeleteEmbeddingsByKBUID. %v %v", ctx, kbUID)
	return
}

// HardDeleteEmbeddingsByKBUIDAfterCounter returns a count of finished RepositoryMock.HardDeleteEmbeddingsByKBUID invocations
func (mmHardDeleteEmbeddingsByKBUID *RepositoryMock) HardDeleteEmbeddingsByKBUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKBUID.afterHardDeleteEmbeddingsByKBUIDCounter)
}

// HardDeleteEmbeddingsByKBUIDBeforeCounter returns a count of RepositoryMock.HardDeleteEmbeddingsByKBUID invocations
func (mmHardDeleteEmbeddingsByKBUID *RepositoryMock) HardDeleteEmbeddingsByKBUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteEmbeddingsByKBUID.beforeHardDeleteEmbeddingsByKBUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.HardDeleteEmbeddingsByKBUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHardDeleteEmbeddingsByKBUID *mRepositoryMockHardDeleteEmbeddingsByKBUID) Calls() []*RepositoryMockHardDeleteEmbeddingsByKBUIDParams {
	mmHardDeleteEmbeddingsByKBUID.mutex.RLock()

	argCopy := make([]*RepositoryMockHardDeleteEmbeddingsByKBUIDParams, len(mmHardDeleteEmbeddingsByKBUID.callArgs))
	copy(argCopy, mmHardDeleteEmbeddingsByKBUID.callArgs)

	mmHardDeleteEmbeddingsByKBUID.mutex.RUnlock()

	return argCopy
}

// MinimockHardDeleteEmbeddingsByKBUIDDone returns true if the count of the HardDeleteEmbeddingsByKBUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockHardDeleteEmbeddingsByKBUIDDone() bool {
	if m.HardDeleteEmbeddingsByKBUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HardDeleteEmbeddingsByKBUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HardDeleteEmbeddingsByKBUIDMock.invocationsDone()
}

// MinimockHardDeleteEmbeddingsByKBUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockHardDeleteEmbeddingsByKBUIDInspect() {
	for _, e := range m.HardDeleteEmbeddingsByKBUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteEmbeddingsByKBUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHardDeleteEmbeddingsByKBUIDCounter := mm_atomic.LoadUint64(&m.afterHardDeleteEmbeddingsByKBUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HardDeleteEmbeddingsByKBUIDMock.defaultExpectation != nil && afterHardDeleteEmbeddingsByKBUIDCounter < 1 {
		if m.HardDeleteEmbeddingsByKBUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteEmbeddingsByKBUID at\n%s", m.HardDeleteEmbeddingsByKBUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteEmbeddingsByKBUID at\n%s with params: %#v", m.HardDeleteEmbeddingsByKBUIDMock.defaultExpectation.expectationOrigins.origin, *m.HardDeleteEmbeddingsByKBUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHardDeleteEmbeddingsByKBUID != nil && afterHardDeleteEmbeddingsByKBUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.HardDeleteEmbeddingsByKBUID at\n%s", m.funcHardDeleteEmbeddingsByKBUIDOrigin)
	}

	if !m.HardDeleteEmbeddingsByKBUIDMock.invocationsDone() && afterHardDeleteEmbeddingsByKBUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.HardDeleteEmbeddingsByKBUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HardDeleteEmbeddingsByKBUIDMock.expectedInvocations), m.HardDeleteEmbeddingsByKBUIDMock.expectedInvocationsOrigin, afterHardDeleteEmbeddingsByKBUIDCounter)
	}
}

type mRepositoryMockHardDeleteTextChunksByKBFileUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockHardDeleteTextChunksByKBFileUIDExpectation
	expectations       []*RepositoryMockHardDeleteTextChunksByKBFileUIDExpectation

	callArgs []*RepositoryMockHardDeleteTextChunksByKBFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockHardDeleteTextChunksByKBFileUIDExpectation specifies expectation struct of the Repository.HardDeleteTextChunksByKBFileUID
type RepositoryMockHardDeleteTextChunksByKBFileUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockHardDeleteTextChunksByKBFileUIDParams
	paramPtrs          *RepositoryMockHardDeleteTextChunksByKBFileUIDParamPtrs
	expectationOrigins RepositoryMockHardDeleteTextChunksByKBFileUIDExpectationOrigins
	results            *RepositoryMockHardDeleteTextChunksByKBFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockHardDeleteTextChunksByKBFileUIDParams contains parameters of the Repository.HardDeleteTextChunksByKBFileUID
type RepositoryMockHardDeleteTextChunksByKBFileUIDParams struct {
	ctx       context.Context
	kbFileUID types.FileUIDType
}

// RepositoryMockHardDeleteTextChunksByKBFileUIDParamPtrs contains pointers to parameters of the Repository.HardDeleteTextChunksByKBFileUID
type RepositoryMockHardDeleteTextChunksByKBFileUIDParamPtrs struct {
	ctx       *context.Context
	kbFileUID *types.FileUIDType
}

// RepositoryMockHardDeleteTextChunksByKBFileUIDResults contains results of the Repository.HardDeleteTextChunksByKBFileUID
type RepositoryMockHardDeleteTextChunksByKBFileUIDResults struct {
	err error
}

// RepositoryMockHardDeleteTextChunksByKBFileUIDOrigins contains origins of expectations of the Repository.HardDeleteTextChunksByKBFileUID
type RepositoryMockHardDeleteTextChunksByKBFileUIDExpectationOrigins struct {
	origin          string
	originCtx       string
	originKbFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHardDeleteTextChunksByKBFileUID *mRepositoryMockHardDeleteTextChunksByKBFileUID) Optional() *mRepositoryMockHardDeleteTextChunksByKBFileUID {
	mmHardDeleteTextChunksByKBFileUID.optional = true
	return mmHardDeleteTextChunksByKBFileUID
}

// Expect sets up expected params for Repository.HardDeleteTextChunksByKBFileUID
func (mmHardDeleteTextChunksByKBFileUID *mRepositoryMockHardDeleteTextChunksByKBFileUID) Expect(ctx context.Context, kbFileUID types.FileUIDType) *mRepositoryMockHardDeleteTextChunksByKBFileUID {
	if mmHardDeleteTextChunksByKBFileUID.mock.funcHardDeleteTextChunksByKBFileUID != nil {
		mmHardDeleteTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBFileUID mock is already set by Set")
	}

	if mmHardDeleteTextChunksByKBFileUID.defaultExpectation == nil {
		mmHardDeleteTextChunksByKBFileUID.defaultExpectation = &RepositoryMockHardDeleteTextChunksByKBFileUIDExpectation{}
	}

	if mmHardDeleteTextChunksByKBFileUID.defaultExpectation.paramPtrs != nil {
		mmHardDeleteTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBFileUID mock is already set by ExpectParams functions")
	}

	mmHardDeleteTextChunksByKBFileUID.defaultExpectation.params = &RepositoryMockHardDeleteTextChunksByKBFileUIDParams{ctx, kbFileUID}
	mmHardDeleteTextChunksByKBFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHardDeleteTextChunksByKBFileUID.expectations {
		if minimock.Equal(e.params, mmHardDeleteTextChunksByKBFileUID.defaultExpectation.params) {
			mmHardDeleteTextChunksByKBFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHardDeleteTextChunksByKBFileUID.defaultExpectation.params)
		}
	}

	return mmHardDeleteTextChunksByKBFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.HardDeleteTextChunksByKBFileUID
func (mmHardDeleteTextChunksByKBFileUID *mRepositoryMockHardDeleteTextChunksByKBFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockHardDeleteTextChunksByKBFileUID {
	if mmHardDeleteTextChunksByKBFileUID.mock.funcHardDeleteTextChunksByKBFileUID != nil {
		mmHardDeleteTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBFileUID mock is already set by Set")
	}

	if mmHardDeleteTextChunksByKBFileUID.defaultExpectation == nil {
		mmHardDeleteTextChunksByKBFileUID.defaultExpectation = &RepositoryMockHardDeleteTextChunksByKBFileUIDExpectation{}
	}

	if mmHardDeleteTextChunksByKBFileUID.defaultExpectation.params != nil {
		mmHardDeleteTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBFileUID mock is already set by Expect")
	}

	if mmHardDeleteTextChunksByKBFileUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteTextChunksByKBFileUID.defaultExpectation.paramPtrs = &RepositoryMockHardDeleteTextChunksByKBFileUIDParamPtrs{}
	}
	mmHardDeleteTextChunksByKBFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmHardDeleteTextChunksByKBFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmHardDeleteTextChunksByKBFileUID
}

// ExpectKbFileUIDParam2 sets up expected param kbFileUID for Repository.HardDeleteTextChunksByKBFileUID
func (mmHardDeleteTextChunksByKBFileUID *mRepositoryMockHardDeleteTextChunksByKBFileUID) ExpectKbFileUIDParam2(kbFileUID types.FileUIDType) *mRepositoryMockHardDeleteTextChunksByKBFileUID {
	if mmHardDeleteTextChunksByKBFileUID.mock.funcHardDeleteTextChunksByKBFileUID != nil {
		mmHardDeleteTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBFileUID mock is already set by Set")
	}

	if mmHardDeleteTextChunksByKBFileUID.defaultExpectation == nil {
		mmHardDeleteTextChunksByKBFileUID.defaultExpectation = &RepositoryMockHardDeleteTextChunksByKBFileUIDExpectation{}
	}

	if mmHardDeleteTextChunksByKBFileUID.defaultExpectation.params != nil {
		mmHardDeleteTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBFileUID mock is already set by Expect")
	}

	if mmHardDeleteTextChunksByKBFileUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteTextChunksByKBFileUID.defaultExpectation.paramPtrs = &RepositoryMockHardDeleteTextChunksByKBFileUIDParamPtrs{}
	}
	mmHardDeleteTextChunksByKBFileUID.defaultExpectation.paramPtrs.kbFileUID = &kbFileUID
	mmHardDeleteTextChunksByKBFileUID.defaultExpectation.expectationOrigins.originKbFileUID = minimock.CallerInfo(1)

	return mmHardDeleteTextChunksByKBFileUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.HardDeleteTextChunksByKBFileUID
func (mmHardDeleteTextChunksByKBFileUID *mRepositoryMockHardDeleteTextChunksByKBFileUID) Inspect(f func(ctx context.Context, kbFileUID types.FileUIDType)) *mRepositoryMockHardDeleteTextChunksByKBFileUID {
	if mmHardDeleteTextChunksByKBFileUID.mock.inspectFuncHardDeleteTextChunksByKBFileUID != nil {
		mmHardDeleteTextChunksByKBFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.HardDeleteTextChunksByKBFileUID")
	}

	mmHardDeleteTextChunksByKBFileUID.mock.inspectFuncHardDeleteTextChunksByKBFileUID = f

	return mmHardDeleteTextChunksByKBFileUID
}

// Return sets up results that will be returned by Repository.HardDeleteTextChunksByKBFileUID
func (mmHardDeleteTextChunksByKBFileUID *mRepositoryMockHardDeleteTextChunksByKBFileUID) Return(err error) *RepositoryMock {
	if mmHardDeleteTextChunksByKBFileUID.mock.funcHardDeleteTextChunksByKBFileUID != nil {
		mmHardDeleteTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBFileUID mock is already set by Set")
	}

	if mmHardDeleteTextChunksByKBFileUID.defaultExpectation == nil {
		mmHardDeleteTextChunksByKBFileUID.defaultExpectation = &RepositoryMockHardDeleteTextChunksByKBFileUIDExpectation{mock: mmHardDeleteTextChunksByKBFileUID.mock}
	}
	mmHardDeleteTextChunksByKBFileUID.defaultExpectation.results = &RepositoryMockHardDeleteTextChunksByKBFileUIDResults{err}
	mmHardDeleteTextChunksByKBFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHardDeleteTextChunksByKBFileUID.mock
}

// Set uses given function f to mock the Repository.HardDeleteTextChunksByKBFileUID method
func (mmHardDeleteTextChunksByKBFileUID *mRepositoryMockHardDeleteTextChunksByKBFileUID) Set(f func(ctx context.Context, kbFileUID types.FileUIDType) (err error)) *RepositoryMock {
	if mmHardDeleteTextChunksByKBFileUID.defaultExpectation != nil {
		mmHardDeleteTextChunksByKBFileUID.mock.t.Fatalf("Default expectation is already set for the Repository.HardDeleteTextChunksByKBFileUID method")
	}

	if len(mmHardDeleteTextChunksByKBFileUID.expectations) > 0 {
		mmHardDeleteTextChunksByKBFileUID.mock.t.Fatalf("Some expectations are already set for the Repository.HardDeleteTextChunksByKBFileUID method")
	}

	mmHardDeleteTextChunksByKBFileUID.mock.funcHardDeleteTextChunksByKBFileUID = f
	mmHardDeleteTextChunksByKBFileUID.mock.funcHardDeleteTextChunksByKBFileUIDOrigin = minimock.CallerInfo(1)
	return mmHardDeleteTextChunksByKBFileUID.mock
}

// When sets expectation for the Repository.HardDeleteTextChunksByKBFileUID which will trigger the result defined by the following
// Then helper
func (mmHardDeleteTextChunksByKBFileUID *mRepositoryMockHardDeleteTextChunksByKBFileUID) When(ctx context.Context, kbFileUID types.FileUIDType) *RepositoryMockHardDeleteTextChunksByKBFileUIDExpectation {
	if mmHardDeleteTextChunksByKBFileUID.mock.funcHardDeleteTextChunksByKBFileUID != nil {
		mmHardDeleteTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBFileUID mock is already set by Set")
	}

	expectation := &RepositoryMockHardDeleteTextChunksByKBFileUIDExpectation{
		mock:               mmHardDeleteTextChunksByKBFileUID.mock,
		params:             &RepositoryMockHardDeleteTextChunksByKBFileUIDParams{ctx, kbFileUID},
		expectationOrigins: RepositoryMockHardDeleteTextChunksByKBFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHardDeleteTextChunksByKBFileUID.expectations = append(mmHardDeleteTextChunksByKBFileUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.HardDeleteTextChunksByKBFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockHardDeleteTextChunksByKBFileUIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockHardDeleteTextChunksByKBFileUIDResults{err}
	return e.mock
}

// Times sets number of times Repository.HardDeleteTextChunksByKBFileUID should be invoked
func (mmHardDeleteTextChunksByKBFileUID *mRepositoryMockHardDeleteTextChunksByKBFileUID) Times(n uint64) *mRepositoryMockHardDeleteTextChunksByKBFileUID {
	if n == 0 {
		mmHardDeleteTextChunksByKBFileUID.mock.t.Fatalf("Times of RepositoryMock.HardDeleteTextChunksByKBFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHardDeleteTextChunksByKBFileUID.expectedInvocations, n)
	mmHardDeleteTextChunksByKBFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHardDeleteTextChunksByKBFileUID
}

func (mmHardDeleteTextChunksByKBFileUID *mRepositoryMockHardDeleteTextChunksByKBFileUID) invocationsDone() bool {
	if len(mmHardDeleteTextChunksByKBFileUID.expectations) == 0 && mmHardDeleteTextChunksByKBFileUID.defaultExpectation == nil && mmHardDeleteTextChunksByKBFileUID.mock.funcHardDeleteTextChunksByKBFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHardDeleteTextChunksByKBFileUID.mock.afterHardDeleteTextChunksByKBFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHardDeleteTextChunksByKBFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HardDeleteTextChunksByKBFileUID implements mm_repository.Repository
func (mmHardDeleteTextChunksByKBFileUID *RepositoryMock) HardDeleteTextChunksByKBFileUID(ctx context.Context, kbFileUID types.FileUIDType) (err error) {
	mm_atomic.AddUint64(&mmHardDeleteTextChunksByKBFileUID.beforeHardDeleteTextChunksByKBFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmHardDeleteTextChunksByKBFileUID.afterHardDeleteTextChunksByKBFileUIDCounter, 1)

	mmHardDeleteTextChunksByKBFileUID.t.Helper()

	if mmHardDeleteTextChunksByKBFileUID.inspectFuncHardDeleteTextChunksByKBFileUID != nil {
		mmHardDeleteTextChunksByKBFileUID.inspectFuncHardDeleteTextChunksByKBFileUID(ctx, kbFileUID)
	}

	mm_params := RepositoryMockHardDeleteTextChunksByKBFileUIDParams{ctx, kbFileUID}

	// Record call args
	mmHardDeleteTextChunksByKBFileUID.HardDeleteTextChunksByKBFileUIDMock.mutex.Lock()
	mmHardDeleteTextChunksByKBFileUID.HardDeleteTextChunksByKBFileUIDMock.callArgs = append(mmHardDeleteTextChunksByKBFileUID.HardDeleteTextChunksByKBFileUIDMock.callArgs, &mm_params)
	mmHardDeleteTextChunksByKBFileUID.HardDeleteTextChunksByKBFileUIDMock.mutex.Unlock()

	for _, e := range mmHardDeleteTextChunksByKBFileUID.HardDeleteTextChunksByKBFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHardDeleteTextChunksByKBFileUID.HardDeleteTextChunksByKBFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHardDeleteTextChunksByKBFileUID.HardDeleteTextChunksByKBFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmHardDeleteTextChunksByKBFileUID.HardDeleteTextChunksByKBFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmHardDeleteTextChunksByKBFileUID.HardDeleteTextChunksByKBFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockHardDeleteTextChunksByKBFileUIDParams{ctx, kbFileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHardDeleteTextChunksByKBFileUID.t.Errorf("RepositoryMock.HardDeleteTextChunksByKBFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHardDeleteTextChunksByKBFileUID.HardDeleteTextChunksByKBFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbFileUID != nil && !minimock.Equal(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID) {
				mmHardDeleteTextChunksByKBFileUID.t.Errorf("RepositoryMock.HardDeleteTextChunksByKBFileUID got unexpected parameter kbFileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHardDeleteTextChunksByKBFileUID.HardDeleteTextChunksByKBFileUIDMock.defaultExpectation.expectationOrigins.originKbFileUID, *mm_want_ptrs.kbFileUID, mm_got.kbFileUID, minimock.Diff(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHardDeleteTextChunksByKBFileUID.t.Errorf("RepositoryMock.HardDeleteTextChunksByKBFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHardDeleteTextChunksByKBFileUID.HardDeleteTextChunksByKBFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHardDeleteTextChunksByKBFileUID.HardDeleteTextChunksByKBFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmHardDeleteTextChunksByKBFileUID.t.Fatal("No results are set for the RepositoryMock.HardDeleteTextChunksByKBFileUID")
		}
		return (*mm_results).err
	}
	if mmHardDeleteTextChunksByKBFileUID.funcHardDeleteTextChunksByKBFileUID != nil {
		return mmHardDeleteTextChunksByKBFileUID.funcHardDeleteTextChunksByKBFileUID(ctx, kbFileUID)
	}
	mmHardDeleteTextChunksByKBFileUID.t.Fatalf("Unexpected call to RepositoryMock.HardDeleteTextChunksByKBFileUID. %v %v", ctx, kbFileUID)
	return
}

// HardDeleteTextChunksByKBFileUIDAfterCounter returns a count of finished RepositoryMock.HardDeleteTextChunksByKBFileUID invocations
func (mmHardDeleteTextChunksByKBFileUID *RepositoryMock) HardDeleteTextChunksByKBFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteTextChunksByKBFileUID.afterHardDeleteTextChunksByKBFileUIDCounter)
}

// HardDeleteTextChunksByKBFileUIDBeforeCounter returns a count of RepositoryMock.HardDeleteTextChunksByKBFileUID invocations
func (mmHardDeleteTextChunksByKBFileUID *RepositoryMock) HardDeleteTextChunksByKBFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteTextChunksByKBFileUID.beforeHardDeleteTextChunksByKBFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.HardDeleteTextChunksByKBFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHardDeleteTextChunksByKBFileUID *mRepositoryMockHardDeleteTextChunksByKBFileUID) Calls() []*RepositoryMockHardDeleteTextChunksByKBFileUIDParams {
	mmHardDeleteTextChunksByKBFileUID.mutex.RLock()

	argCopy := make([]*RepositoryMockHardDeleteTextChunksByKBFileUIDParams, len(mmHardDeleteTextChunksByKBFileUID.callArgs))
	copy(argCopy, mmHardDeleteTextChunksByKBFileUID.callArgs)

	mmHardDeleteTextChunksByKBFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockHardDeleteTextChunksByKBFileUIDDone returns true if the count of the HardDeleteTextChunksByKBFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockHardDeleteTextChunksByKBFileUIDDone() bool {
	if m.HardDeleteTextChunksByKBFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HardDeleteTextChunksByKBFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HardDeleteTextChunksByKBFileUIDMock.invocationsDone()
}

// MinimockHardDeleteTextChunksByKBFileUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockHardDeleteTextChunksByKBFileUIDInspect() {
	for _, e := range m.HardDeleteTextChunksByKBFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteTextChunksByKBFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHardDeleteTextChunksByKBFileUIDCounter := mm_atomic.LoadUint64(&m.afterHardDeleteTextChunksByKBFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HardDeleteTextChunksByKBFileUIDMock.defaultExpectation != nil && afterHardDeleteTextChunksByKBFileUIDCounter < 1 {
		if m.HardDeleteTextChunksByKBFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteTextChunksByKBFileUID at\n%s", m.HardDeleteTextChunksByKBFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteTextChunksByKBFileUID at\n%s with params: %#v", m.HardDeleteTextChunksByKBFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.HardDeleteTextChunksByKBFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHardDeleteTextChunksByKBFileUID != nil && afterHardDeleteTextChunksByKBFileUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.HardDeleteTextChunksByKBFileUID at\n%s", m.funcHardDeleteTextChunksByKBFileUIDOrigin)
	}

	if !m.HardDeleteTextChunksByKBFileUIDMock.invocationsDone() && afterHardDeleteTextChunksByKBFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.HardDeleteTextChunksByKBFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HardDeleteTextChunksByKBFileUIDMock.expectedInvocations), m.HardDeleteTextChunksByKBFileUIDMock.expectedInvocationsOrigin, afterHardDeleteTextChunksByKBFileUIDCounter)
	}
}

type mRepositoryMockHardDeleteTextChunksByKBUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockHardDeleteTextChunksByKBUIDExpectation
	expectations       []*RepositoryMockHardDeleteTextChunksByKBUIDExpectation

	callArgs []*RepositoryMockHardDeleteTextChunksByKBUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockHardDeleteTextChunksByKBUIDExpectation specifies expectation struct of the Repository.HardDeleteTextChunksByKBUID
type RepositoryMockHardDeleteTextChunksByKBUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockHardDeleteTextChunksByKBUIDParams
	paramPtrs          *RepositoryMockHardDeleteTextChunksByKBUIDParamPtrs
	expectationOrigins RepositoryMockHardDeleteTextChunksByKBUIDExpectationOrigins
	results            *RepositoryMockHardDeleteTextChunksByKBUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockHardDeleteTextChunksByKBUIDParams contains parameters of the Repository.HardDeleteTextChunksByKBUID
type RepositoryMockHardDeleteTextChunksByKBUIDParams struct {
	ctx   context.Context
	kbUID types.KBUIDType
}

// RepositoryMockHardDeleteTextChunksByKBUIDParamPtrs contains pointers to parameters of the Repository.HardDeleteTextChunksByKBUID
type RepositoryMockHardDeleteTextChunksByKBUIDParamPtrs struct {
	ctx   *context.Context
	kbUID *types.KBUIDType
}

// RepositoryMockHardDeleteTextChunksByKBUIDResults contains results of the Repository.HardDeleteTextChunksByKBUID
type RepositoryMockHardDeleteTextChunksByKBUIDResults struct {
	err error
}

// RepositoryMockHardDeleteTextChunksByKBUIDOrigins contains origins of expectations of the Repository.HardDeleteTextChunksByKBUID
type RepositoryMockHardDeleteTextChunksByKBUIDExpectationOrigins struct {
	origin      string
	originCtx   string
	originKbUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHardDeleteTextChunksByKBUID *mRepositoryMockHardDeleteTextChunksByKBUID) Optional() *mRepositoryMockHardDeleteTextChunksByKBUID {
	mmHardDeleteTextChunksByKBUID.optional = true
	return mmHardDeleteTextChunksByKBUID
}

// Expect sets up expected params for Repository.HardDeleteTextChunksByKBUID
func (mmHardDeleteTextChunksByKBUID *mRepositoryMockHardDeleteTextChunksByKBUID) Expect(ctx context.Context, kbUID types.KBUIDType) *mRepositoryMockHardDeleteTextChunksByKBUID {
	if mmHardDeleteTextChunksByKBUID.mock.funcHardDeleteTextChunksByKBUID != nil {
		mmHardDeleteTextChunksByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBUID mock is already set by Set")
	}

	if mmHardDeleteTextChunksByKBUID.defaultExpectation == nil {
		mmHardDeleteTextChunksByKBUID.defaultExpectation = &RepositoryMockHardDeleteTextChunksByKBUIDExpectation{}
	}

	if mmHardDeleteTextChunksByKBUID.defaultExpectation.paramPtrs != nil {
		mmHardDeleteTextChunksByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBUID mock is already set by ExpectParams functions")
	}

	mmHardDeleteTextChunksByKBUID.defaultExpectation.params = &RepositoryMockHardDeleteTextChunksByKBUIDParams{ctx, kbUID}
	mmHardDeleteTextChunksByKBUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHardDeleteTextChunksByKBUID.expectations {
		if minimock.Equal(e.params, mmHardDeleteTextChunksByKBUID.defaultExpectation.params) {
			mmHardDeleteTextChunksByKBUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHardDeleteTextChunksByKBUID.defaultExpectation.params)
		}
	}

	return mmHardDeleteTextChunksByKBUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.HardDeleteTextChunksByKBUID
func (mmHardDeleteTextChunksByKBUID *mRepositoryMockHardDeleteTextChunksByKBUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockHardDeleteTextChunksByKBUID {
	if mmHardDeleteTextChunksByKBUID.mock.funcHardDeleteTextChunksByKBUID != nil {
		mmHardDeleteTextChunksByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBUID mock is already set by Set")
	}

	if mmHardDeleteTextChunksByKBUID.defaultExpectation == nil {
		mmHardDeleteTextChunksByKBUID.defaultExpectation = &RepositoryMockHardDeleteTextChunksByKBUIDExpectation{}
	}

	if mmHardDeleteTextChunksByKBUID.defaultExpectation.params != nil {
		mmHardDeleteTextChunksByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBUID mock is already set by Expect")
	}

	if mmHardDeleteTextChunksByKBUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteTextChunksByKBUID.defaultExpectation.paramPtrs = &RepositoryMockHardDeleteTextChunksByKBUIDParamPtrs{}
	}
	mmHardDeleteTextChunksByKBUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmHardDeleteTextChunksByKBUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmHardDeleteTextChunksByKBUID
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.HardDeleteTextChunksByKBUID
func (mmHardDeleteTextChunksByKBUID *mRepositoryMockHardDeleteTextChunksByKBUID) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockHardDeleteTextChunksByKBUID {
	if mmHardDeleteTextChunksByKBUID.mock.funcHardDeleteTextChunksByKBUID != nil {
		mmHardDeleteTextChunksByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBUID mock is already set by Set")
	}

	if mmHardDeleteTextChunksByKBUID.defaultExpectation == nil {
		mmHardDeleteTextChunksByKBUID.defaultExpectation = &RepositoryMockHardDeleteTextChunksByKBUIDExpectation{}
	}

	if mmHardDeleteTextChunksByKBUID.defaultExpectation.params != nil {
		mmHardDeleteTextChunksByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBUID mock is already set by Expect")
	}

	if mmHardDeleteTextChunksByKBUID.defaultExpectation.paramPtrs == nil {
		mmHardDeleteTextChunksByKBUID.defaultExpectation.paramPtrs = &RepositoryMockHardDeleteTextChunksByKBUIDParamPtrs{}
	}
	mmHardDeleteTextChunksByKBUID.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmHardDeleteTextChunksByKBUID.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmHardDeleteTextChunksByKBUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.HardDeleteTextChunksByKBUID
func (mmHardDeleteTextChunksByKBUID *mRepositoryMockHardDeleteTextChunksByKBUID) Inspect(f func(ctx context.Context, kbUID types.KBUIDType)) *mRepositoryMockHardDeleteTextChunksByKBUID {
	if mmHardDeleteTextChunksByKBUID.mock.inspectFuncHardDeleteTextChunksByKBUID != nil {
		mmHardDeleteTextChunksByKBUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.HardDeleteTextChunksByKBUID")
	}

	mmHardDeleteTextChunksByKBUID.mock.inspectFuncHardDeleteTextChunksByKBUID = f

	return mmHardDeleteTextChunksByKBUID
}

// Return sets up results that will be returned by Repository.HardDeleteTextChunksByKBUID
func (mmHardDeleteTextChunksByKBUID *mRepositoryMockHardDeleteTextChunksByKBUID) Return(err error) *RepositoryMock {
	if mmHardDeleteTextChunksByKBUID.mock.funcHardDeleteTextChunksByKBUID != nil {
		mmHardDeleteTextChunksByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBUID mock is already set by Set")
	}

	if mmHardDeleteTextChunksByKBUID.defaultExpectation == nil {
		mmHardDeleteTextChunksByKBUID.defaultExpectation = &RepositoryMockHardDeleteTextChunksByKBUIDExpectation{mock: mmHardDeleteTextChunksByKBUID.mock}
	}
	mmHardDeleteTextChunksByKBUID.defaultExpectation.results = &RepositoryMockHardDeleteTextChunksByKBUIDResults{err}
	mmHardDeleteTextChunksByKBUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHardDeleteTextChunksByKBUID.mock
}

// Set uses given function f to mock the Repository.HardDeleteTextChunksByKBUID method
func (mmHardDeleteTextChunksByKBUID *mRepositoryMockHardDeleteTextChunksByKBUID) Set(f func(ctx context.Context, kbUID types.KBUIDType) (err error)) *RepositoryMock {
	if mmHardDeleteTextChunksByKBUID.defaultExpectation != nil {
		mmHardDeleteTextChunksByKBUID.mock.t.Fatalf("Default expectation is already set for the Repository.HardDeleteTextChunksByKBUID method")
	}

	if len(mmHardDeleteTextChunksByKBUID.expectations) > 0 {
		mmHardDeleteTextChunksByKBUID.mock.t.Fatalf("Some expectations are already set for the Repository.HardDeleteTextChunksByKBUID method")
	}

	mmHardDeleteTextChunksByKBUID.mock.funcHardDeleteTextChunksByKBUID = f
	mmHardDeleteTextChunksByKBUID.mock.funcHardDeleteTextChunksByKBUIDOrigin = minimock.CallerInfo(1)
	return mmHardDeleteTextChunksByKBUID.mock
}

// When sets expectation for the Repository.HardDeleteTextChunksByKBUID which will trigger the result defined by the following
// Then helper
func (mmHardDeleteTextChunksByKBUID *mRepositoryMockHardDeleteTextChunksByKBUID) When(ctx context.Context, kbUID types.KBUIDType) *RepositoryMockHardDeleteTextChunksByKBUIDExpectation {
	if mmHardDeleteTextChunksByKBUID.mock.funcHardDeleteTextChunksByKBUID != nil {
		mmHardDeleteTextChunksByKBUID.mock.t.Fatalf("RepositoryMock.HardDeleteTextChunksByKBUID mock is already set by Set")
	}

	expectation := &RepositoryMockHardDeleteTextChunksByKBUIDExpectation{
		mock:               mmHardDeleteTextChunksByKBUID.mock,
		params:             &RepositoryMockHardDeleteTextChunksByKBUIDParams{ctx, kbUID},
		expectationOrigins: RepositoryMockHardDeleteTextChunksByKBUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHardDeleteTextChunksByKBUID.expectations = append(mmHardDeleteTextChunksByKBUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.HardDeleteTextChunksByKBUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockHardDeleteTextChunksByKBUIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockHardDeleteTextChunksByKBUIDResults{err}
	return e.mock
}

// Times sets number of times Repository.HardDeleteTextChunksByKBUID should be invoked
func (mmHardDeleteTextChunksByKBUID *mRepositoryMockHardDeleteTextChunksByKBUID) Times(n uint64) *mRepositoryMockHardDeleteTextChunksByKBUID {
	if n == 0 {
		mmHardDeleteTextChunksByKBUID.mock.t.Fatalf("Times of RepositoryMock.HardDeleteTextChunksByKBUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHardDeleteTextChunksByKBUID.expectedInvocations, n)
	mmHardDeleteTextChunksByKBUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHardDeleteTextChunksByKBUID
}

func (mmHardDeleteTextChunksByKBUID *mRepositoryMockHardDeleteTextChunksByKBUID) invocationsDone() bool {
	if len(mmHardDeleteTextChunksByKBUID.expectations) == 0 && mmHardDeleteTextChunksByKBUID.defaultExpectation == nil && mmHardDeleteTextChunksByKBUID.mock.funcHardDeleteTextChunksByKBUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHardDeleteTextChunksByKBUID.mock.afterHardDeleteTextChunksByKBUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHardDeleteTextChunksByKBUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HardDeleteTextChunksByKBUID implements mm_repository.Repository
func (mmHardDeleteTextChunksByKBUID *RepositoryMock) HardDeleteTextChunksByKBUID(ctx context.Context, kbUID types.KBUIDType) (err error) {
	mm_atomic.AddUint64(&mmHardDeleteTextChunksByKBUID.beforeHardDeleteTextChunksByKBUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmHardDeleteTextChunksByKBUID.afterHardDeleteTextChunksByKBUIDCounter, 1)

	mmHardDeleteTextChunksByKBUID.t.Helper()

	if mmHardDeleteTextChunksByKBUID.inspectFuncHardDeleteTextChunksByKBUID != nil {
		mmHardDeleteTextChunksByKBUID.inspectFuncHardDeleteTextChunksByKBUID(ctx, kbUID)
	}

	mm_params := RepositoryMockHardDeleteTextChunksByKBUIDParams{ctx, kbUID}

	// Record call args
	mmHardDeleteTextChunksByKBUID.HardDeleteTextChunksByKBUIDMock.mutex.Lock()
	mmHardDeleteTextChunksByKBUID.HardDeleteTextChunksByKBUIDMock.callArgs = append(mmHardDeleteTextChunksByKBUID.HardDeleteTextChunksByKBUIDMock.callArgs, &mm_params)
	mmHardDeleteTextChunksByKBUID.HardDeleteTextChunksByKBUIDMock.mutex.Unlock()

	for _, e := range mmHardDeleteTextChunksByKBUID.HardDeleteTextChunksByKBUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHardDeleteTextChunksByKBUID.HardDeleteTextChunksByKBUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHardDeleteTextChunksByKBUID.HardDeleteTextChunksByKBUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmHardDeleteTextChunksByKBUID.HardDeleteTextChunksByKBUIDMock.defaultExpectation.params
		mm_want_ptrs := mmHardDeleteTextChunksByKBUID.HardDeleteTextChunksByKBUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockHardDeleteTextChunksByKBUIDParams{ctx, kbUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHardDeleteTextChunksByKBUID.t.Errorf("RepositoryMock.HardDeleteTextChunksByKBUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHardDeleteTextChunksByKBUID.HardDeleteTextChunksByKBUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmHardDeleteTextChunksByKBUID.t.Errorf("RepositoryMock.HardDeleteTextChunksByKBUID got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHardDeleteTextChunksByKBUID.HardDeleteTextChunksByKBUIDMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHardDeleteTextChunksByKBUID.t.Errorf("RepositoryMock.HardDeleteTextChunksByKBUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHardDeleteTextChunksByKBUID.HardDeleteTextChunksByKBUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHardDeleteTextChunksByKBUID.HardDeleteTextChunksByKBUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmHardDeleteTextChunksByKBUID.t.Fatal("No results are set for the RepositoryMock.HardDeleteTextChunksByKBUID")
		}
		return (*mm_results).err
	}
	if mmHardDeleteTextChunksByKBUID.funcHardDeleteTextChunksByKBUID != nil {
		return mmHardDeleteTextChunksByKBUID.funcHardDeleteTextChunksByKBUID(ctx, kbUID)
	}
	mmHardDeleteTextChunksByKBUID.t.Fatalf("Unexpected call to RepositoryMock.HardDeleteTextChunksByKBUID. %v %v", ctx, kbUID)
	return
}

// HardDeleteTextChunksByKBUIDAfterCounter returns a count of finished RepositoryMock.HardDeleteTextChunksByKBUID invocations
func (mmHardDeleteTextChunksByKBUID *RepositoryMock) HardDeleteTextChunksByKBUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteTextChunksByKBUID.afterHardDeleteTextChunksByKBUIDCounter)
}

// HardDeleteTextChunksByKBUIDBeforeCounter returns a count of RepositoryMock.HardDeleteTextChunksByKBUID invocations
func (mmHardDeleteTextChunksByKBUID *RepositoryMock) HardDeleteTextChunksByKBUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHardDeleteTextChunksByKBUID.beforeHardDeleteTextChunksByKBUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.HardDeleteTextChunksByKBUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHardDeleteTextChunksByKBUID *mRepositoryMockHardDeleteTextChunksByKBUID) Calls() []*RepositoryMockHardDeleteTextChunksByKBUIDParams {
	mmHardDeleteTextChunksByKBUID.mutex.RLock()

	argCopy := make([]*RepositoryMockHardDeleteTextChunksByKBUIDParams, len(mmHardDeleteTextChunksByKBUID.callArgs))
	copy(argCopy, mmHardDeleteTextChunksByKBUID.callArgs)

	mmHardDeleteTextChunksByKBUID.mutex.RUnlock()

	return argCopy
}

// MinimockHardDeleteTextChunksByKBUIDDone returns true if the count of the HardDeleteTextChunksByKBUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockHardDeleteTextChunksByKBUIDDone() bool {
	if m.HardDeleteTextChunksByKBUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HardDeleteTextChunksByKBUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HardDeleteTextChunksByKBUIDMock.invocationsDone()
}

// MinimockHardDeleteTextChunksByKBUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockHardDeleteTextChunksByKBUIDInspect() {
	for _, e := range m.HardDeleteTextChunksByKBUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteTextChunksByKBUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHardDeleteTextChunksByKBUIDCounter := mm_atomic.LoadUint64(&m.afterHardDeleteTextChunksByKBUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HardDeleteTextChunksByKBUIDMock.defaultExpectation != nil && afterHardDeleteTextChunksByKBUIDCounter < 1 {
		if m.HardDeleteTextChunksByKBUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteTextChunksByKBUID at\n%s", m.HardDeleteTextChunksByKBUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.HardDeleteTextChunksByKBUID at\n%s with params: %#v", m.HardDeleteTextChunksByKBUIDMock.defaultExpectation.expectationOrigins.origin, *m.HardDeleteTextChunksByKBUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHardDeleteTextChunksByKBUID != nil && afterHardDeleteTextChunksByKBUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.HardDeleteTextChunksByKBUID at\n%s", m.funcHardDeleteTextChunksByKBUIDOrigin)
	}

	if !m.HardDeleteTextChunksByKBUIDMock.invocationsDone() && afterHardDeleteTextChunksByKBUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.HardDeleteTextChunksByKBUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HardDeleteTextChunksByKBUIDMock.expectedInvocations), m.HardDeleteTextChunksByKBUIDMock.expectedInvocationsOrigin, afterHardDeleteTextChunksByKBUIDCounter)
	}
}

type mRepositoryMockIncreaseKnowledgeBaseUsage struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockIncreaseKnowledgeBaseUsageExpectation
	expectations       []*RepositoryMockIncreaseKnowledgeBaseUsageExpectation

	callArgs []*RepositoryMockIncreaseKnowledgeBaseUsageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockIncreaseKnowledgeBaseUsageExpectation specifies expectation struct of the Repository.IncreaseKnowledgeBaseUsage
type RepositoryMockIncreaseKnowledgeBaseUsageExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockIncreaseKnowledgeBaseUsageParams
	paramPtrs          *RepositoryMockIncreaseKnowledgeBaseUsageParamPtrs
	expectationOrigins RepositoryMockIncreaseKnowledgeBaseUsageExpectationOrigins
	results            *RepositoryMockIncreaseKnowledgeBaseUsageResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockIncreaseKnowledgeBaseUsageParams contains parameters of the Repository.IncreaseKnowledgeBaseUsage
type RepositoryMockIncreaseKnowledgeBaseUsageParams struct {
	ctx    context.Context
	tx     *gorm.DB
	kbUID  string
	amount int
}

// RepositoryMockIncreaseKnowledgeBaseUsageParamPtrs contains pointers to parameters of the Repository.IncreaseKnowledgeBaseUsage
type RepositoryMockIncreaseKnowledgeBaseUsageParamPtrs struct {
	ctx    *context.Context
	tx     **gorm.DB
	kbUID  *string
	amount *int
}

// RepositoryMockIncreaseKnowledgeBaseUsageResults contains results of the Repository.IncreaseKnowledgeBaseUsage
type RepositoryMockIncreaseKnowledgeBaseUsageResults struct {
	err error
}

// RepositoryMockIncreaseKnowledgeBaseUsageOrigins contains origins of expectations of the Repository.IncreaseKnowledgeBaseUsage
type RepositoryMockIncreaseKnowledgeBaseUsageExpectationOrigins struct {
	origin       string
	originCtx    string
	originTx     string
	originKbUID  string
	originAmount string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIncreaseKnowledgeBaseUsage *mRepositoryMockIncreaseKnowledgeBaseUsage) Optional() *mRepositoryMockIncreaseKnowledgeBaseUsage {
	mmIncreaseKnowledgeBaseUsage.optional = true
	return mmIncreaseKnowledgeBaseUsage
}

// Expect sets up expected params for Repository.IncreaseKnowledgeBaseUsage
func (mmIncreaseKnowledgeBaseUsage *mRepositoryMockIncreaseKnowledgeBaseUsage) Expect(ctx context.Context, tx *gorm.DB, kbUID string, amount int) *mRepositoryMockIncreaseKnowledgeBaseUsage {
	if mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryMock.IncreaseKnowledgeBaseUsage mock is already set by Set")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation = &RepositoryMockIncreaseKnowledgeBaseUsageExpectation{}
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryMock.IncreaseKnowledgeBaseUsage mock is already set by ExpectParams functions")
	}

	mmIncreaseKnowledgeBaseUsage.defaultExpectation.params = &RepositoryMockIncreaseKnowledgeBaseUsageParams{ctx, tx, kbUID, amount}
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIncreaseKnowledgeBaseUsage.expectations {
		if minimock.Equal(e.params, mmIncreaseKnowledgeBaseUsage.defaultExpectation.params) {
			mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIncreaseKnowledgeBaseUsage.defaultExpectation.params)
		}
	}

	return mmIncreaseKnowledgeBaseUsage
}

// ExpectCtxParam1 sets up expected param ctx for Repository.IncreaseKnowledgeBaseUsage
func (mmIncreaseKnowledgeBaseUsage *mRepositoryMockIncreaseKnowledgeBaseUsage) ExpectCtxParam1(ctx context.Context) *mRepositoryMockIncreaseKnowledgeBaseUsage {
	if mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryMock.IncreaseKnowledgeBaseUsage mock is already set by Set")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation = &RepositoryMockIncreaseKnowledgeBaseUsageExpectation{}
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.params != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryMock.IncreaseKnowledgeBaseUsage mock is already set by Expect")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs = &RepositoryMockIncreaseKnowledgeBaseUsageParamPtrs{}
	}
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs.ctx = &ctx
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmIncreaseKnowledgeBaseUsage
}

// ExpectTxParam2 sets up expected param tx for Repository.IncreaseKnowledgeBaseUsage
func (mmIncreaseKnowledgeBaseUsage *mRepositoryMockIncreaseKnowledgeBaseUsage) ExpectTxParam2(tx *gorm.DB) *mRepositoryMockIncreaseKnowledgeBaseUsage {
	if mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryMock.IncreaseKnowledgeBaseUsage mock is already set by Set")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation = &RepositoryMockIncreaseKnowledgeBaseUsageExpectation{}
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.params != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryMock.IncreaseKnowledgeBaseUsage mock is already set by Expect")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs = &RepositoryMockIncreaseKnowledgeBaseUsageParamPtrs{}
	}
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs.tx = &tx
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.expectationOrigins.originTx = minimock.CallerInfo(1)

	return mmIncreaseKnowledgeBaseUsage
}

// ExpectKbUIDParam3 sets up expected param kbUID for Repository.IncreaseKnowledgeBaseUsage
func (mmIncreaseKnowledgeBaseUsage *mRepositoryMockIncreaseKnowledgeBaseUsage) ExpectKbUIDParam3(kbUID string) *mRepositoryMockIncreaseKnowledgeBaseUsage {
	if mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryMock.IncreaseKnowledgeBaseUsage mock is already set by Set")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation = &RepositoryMockIncreaseKnowledgeBaseUsageExpectation{}
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.params != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryMock.IncreaseKnowledgeBaseUsage mock is already set by Expect")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs = &RepositoryMockIncreaseKnowledgeBaseUsageParamPtrs{}
	}
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmIncreaseKnowledgeBaseUsage
}

// ExpectAmountParam4 sets up expected param amount for Repository.IncreaseKnowledgeBaseUsage
func (mmIncreaseKnowledgeBaseUsage *mRepositoryMockIncreaseKnowledgeBaseUsage) ExpectAmountParam4(amount int) *mRepositoryMockIncreaseKnowledgeBaseUsage {
	if mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryMock.IncreaseKnowledgeBaseUsage mock is already set by Set")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation = &RepositoryMockIncreaseKnowledgeBaseUsageExpectation{}
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.params != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryMock.IncreaseKnowledgeBaseUsage mock is already set by Expect")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs = &RepositoryMockIncreaseKnowledgeBaseUsageParamPtrs{}
	}
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.paramPtrs.amount = &amount
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.expectationOrigins.originAmount = minimock.CallerInfo(1)

	return mmIncreaseKnowledgeBaseUsage
}

// Inspect accepts an inspector function that has same arguments as the Repository.IncreaseKnowledgeBaseUsage
func (mmIncreaseKnowledgeBaseUsage *mRepositoryMockIncreaseKnowledgeBaseUsage) Inspect(f func(ctx context.Context, tx *gorm.DB, kbUID string, amount int)) *mRepositoryMockIncreaseKnowledgeBaseUsage {
	if mmIncreaseKnowledgeBaseUsage.mock.inspectFuncIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("Inspect function is already set for RepositoryMock.IncreaseKnowledgeBaseUsage")
	}

	mmIncreaseKnowledgeBaseUsage.mock.inspectFuncIncreaseKnowledgeBaseUsage = f

	return mmIncreaseKnowledgeBaseUsage
}

// Return sets up results that will be returned by Repository.IncreaseKnowledgeBaseUsage
func (mmIncreaseKnowledgeBaseUsage *mRepositoryMockIncreaseKnowledgeBaseUsage) Return(err error) *RepositoryMock {
	if mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryMock.IncreaseKnowledgeBaseUsage mock is already set by Set")
	}

	if mmIncreaseKnowledgeBaseUsage.defaultExpectation == nil {
		mmIncreaseKnowledgeBaseUsage.defaultExpectation = &RepositoryMockIncreaseKnowledgeBaseUsageExpectation{mock: mmIncreaseKnowledgeBaseUsage.mock}
	}
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.results = &RepositoryMockIncreaseKnowledgeBaseUsageResults{err}
	mmIncreaseKnowledgeBaseUsage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIncreaseKnowledgeBaseUsage.mock
}

// Set uses given function f to mock the Repository.IncreaseKnowledgeBaseUsage method
func (mmIncreaseKnowledgeBaseUsage *mRepositoryMockIncreaseKnowledgeBaseUsage) Set(f func(ctx context.Context, tx *gorm.DB, kbUID string, amount int) (err error)) *RepositoryMock {
	if mmIncreaseKnowledgeBaseUsage.defaultExpectation != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("Default expectation is already set for the Repository.IncreaseKnowledgeBaseUsage method")
	}

	if len(mmIncreaseKnowledgeBaseUsage.expectations) > 0 {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("Some expectations are already set for the Repository.IncreaseKnowledgeBaseUsage method")
	}

	mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage = f
	mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsageOrigin = minimock.CallerInfo(1)
	return mmIncreaseKnowledgeBaseUsage.mock
}

// When sets expectation for the Repository.IncreaseKnowledgeBaseUsage which will trigger the result defined by the following
// Then helper
func (mmIncreaseKnowledgeBaseUsage *mRepositoryMockIncreaseKnowledgeBaseUsage) When(ctx context.Context, tx *gorm.DB, kbUID string, amount int) *RepositoryMockIncreaseKnowledgeBaseUsageExpectation {
	if mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("RepositoryMock.IncreaseKnowledgeBaseUsage mock is already set by Set")
	}

	expectation := &RepositoryMockIncreaseKnowledgeBaseUsageExpectation{
		mock:               mmIncreaseKnowledgeBaseUsage.mock,
		params:             &RepositoryMockIncreaseKnowledgeBaseUsageParams{ctx, tx, kbUID, amount},
		expectationOrigins: RepositoryMockIncreaseKnowledgeBaseUsageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIncreaseKnowledgeBaseUsage.expectations = append(mmIncreaseKnowledgeBaseUsage.expectations, expectation)
	return expectation
}

// Then sets up Repository.IncreaseKnowledgeBaseUsage return parameters for the expectation previously defined by the When method
func (e *RepositoryMockIncreaseKnowledgeBaseUsageExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockIncreaseKnowledgeBaseUsageResults{err}
	return e.mock
}

// Times sets number of times Repository.IncreaseKnowledgeBaseUsage should be invoked
func (mmIncreaseKnowledgeBaseUsage *mRepositoryMockIncreaseKnowledgeBaseUsage) Times(n uint64) *mRepositoryMockIncreaseKnowledgeBaseUsage {
	if n == 0 {
		mmIncreaseKnowledgeBaseUsage.mock.t.Fatalf("Times of RepositoryMock.IncreaseKnowledgeBaseUsage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIncreaseKnowledgeBaseUsage.expectedInvocations, n)
	mmIncreaseKnowledgeBaseUsage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIncreaseKnowledgeBaseUsage
}

func (mmIncreaseKnowledgeBaseUsage *mRepositoryMockIncreaseKnowledgeBaseUsage) invocationsDone() bool {
	if len(mmIncreaseKnowledgeBaseUsage.expectations) == 0 && mmIncreaseKnowledgeBaseUsage.defaultExpectation == nil && mmIncreaseKnowledgeBaseUsage.mock.funcIncreaseKnowledgeBaseUsage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIncreaseKnowledgeBaseUsage.mock.afterIncreaseKnowledgeBaseUsageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIncreaseKnowledgeBaseUsage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IncreaseKnowledgeBaseUsage implements mm_repository.Repository
func (mmIncreaseKnowledgeBaseUsage *RepositoryMock) IncreaseKnowledgeBaseUsage(ctx context.Context, tx *gorm.DB, kbUID string, amount int) (err error) {
	mm_atomic.AddUint64(&mmIncreaseKnowledgeBaseUsage.beforeIncreaseKnowledgeBaseUsageCounter, 1)
	defer mm_atomic.AddUint64(&mmIncreaseKnowledgeBaseUsage.afterIncreaseKnowledgeBaseUsageCounter, 1)

	mmIncreaseKnowledgeBaseUsage.t.Helper()

	if mmIncreaseKnowledgeBaseUsage.inspectFuncIncreaseKnowledgeBaseUsage != nil {
		mmIncreaseKnowledgeBaseUsage.inspectFuncIncreaseKnowledgeBaseUsage(ctx, tx, kbUID, amount)
	}

	mm_params := RepositoryMockIncreaseKnowledgeBaseUsageParams{ctx, tx, kbUID, amount}

	// Record call args
	mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.mutex.Lock()
	mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.callArgs = append(mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.callArgs, &mm_params)
	mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.mutex.Unlock()

	for _, e := range mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation.Counter, 1)
		mm_want := mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation.params
		mm_want_ptrs := mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockIncreaseKnowledgeBaseUsageParams{ctx, tx, kbUID, amount}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmIncreaseKnowledgeBaseUsage.t.Errorf("RepositoryMock.IncreaseKnowledgeBaseUsage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tx != nil && !minimock.Equal(*mm_want_ptrs.tx, mm_got.tx) {
				mmIncreaseKnowledgeBaseUsage.t.Errorf("RepositoryMock.IncreaseKnowledgeBaseUsage got unexpected parameter tx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation.expectationOrigins.originTx, *mm_want_ptrs.tx, mm_got.tx, minimock.Diff(*mm_want_ptrs.tx, mm_got.tx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmIncreaseKnowledgeBaseUsage.t.Errorf("RepositoryMock.IncreaseKnowledgeBaseUsage got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.amount != nil && !minimock.Equal(*mm_want_ptrs.amount, mm_got.amount) {
				mmIncreaseKnowledgeBaseUsage.t.Errorf("RepositoryMock.IncreaseKnowledgeBaseUsage got unexpected parameter amount, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation.expectationOrigins.originAmount, *mm_want_ptrs.amount, mm_got.amount, minimock.Diff(*mm_want_ptrs.amount, mm_got.amount))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIncreaseKnowledgeBaseUsage.t.Errorf("RepositoryMock.IncreaseKnowledgeBaseUsage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIncreaseKnowledgeBaseUsage.IncreaseKnowledgeBaseUsageMock.defaultExpectation.results
		if mm_results == nil {
			mmIncreaseKnowledgeBaseUsage.t.Fatal("No results are set for the RepositoryMock.IncreaseKnowledgeBaseUsage")
		}
		return (*mm_results).err
	}
	if mmIncreaseKnowledgeBaseUsage.funcIncreaseKnowledgeBaseUsage != nil {
		return mmIncreaseKnowledgeBaseUsage.funcIncreaseKnowledgeBaseUsage(ctx, tx, kbUID, amount)
	}
	mmIncreaseKnowledgeBaseUsage.t.Fatalf("Unexpected call to RepositoryMock.IncreaseKnowledgeBaseUsage. %v %v %v %v", ctx, tx, kbUID, amount)
	return
}

// IncreaseKnowledgeBaseUsageAfterCounter returns a count of finished RepositoryMock.IncreaseKnowledgeBaseUsage invocations
func (mmIncreaseKnowledgeBaseUsage *RepositoryMock) IncreaseKnowledgeBaseUsageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIncreaseKnowledgeBaseUsage.afterIncreaseKnowledgeBaseUsageCounter)
}

// IncreaseKnowledgeBaseUsageBeforeCounter returns a count of RepositoryMock.IncreaseKnowledgeBaseUsage invocations
func (mmIncreaseKnowledgeBaseUsage *RepositoryMock) IncreaseKnowledgeBaseUsageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIncreaseKnowledgeBaseUsage.beforeIncreaseKnowledgeBaseUsageCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.IncreaseKnowledgeBaseUsage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIncreaseKnowledgeBaseUsage *mRepositoryMockIncreaseKnowledgeBaseUsage) Calls() []*RepositoryMockIncreaseKnowledgeBaseUsageParams {
	mmIncreaseKnowledgeBaseUsage.mutex.RLock()

	argCopy := make([]*RepositoryMockIncreaseKnowledgeBaseUsageParams, len(mmIncreaseKnowledgeBaseUsage.callArgs))
	copy(argCopy, mmIncreaseKnowledgeBaseUsage.callArgs)

	mmIncreaseKnowledgeBaseUsage.mutex.RUnlock()

	return argCopy
}

// MinimockIncreaseKnowledgeBaseUsageDone returns true if the count of the IncreaseKnowledgeBaseUsage invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockIncreaseKnowledgeBaseUsageDone() bool {
	if m.IncreaseKnowledgeBaseUsageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IncreaseKnowledgeBaseUsageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IncreaseKnowledgeBaseUsageMock.invocationsDone()
}

// MinimockIncreaseKnowledgeBaseUsageInspect logs each unmet expectation
func (m *RepositoryMock) MinimockIncreaseKnowledgeBaseUsageInspect() {
	for _, e := range m.IncreaseKnowledgeBaseUsageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.IncreaseKnowledgeBaseUsage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIncreaseKnowledgeBaseUsageCounter := mm_atomic.LoadUint64(&m.afterIncreaseKnowledgeBaseUsageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IncreaseKnowledgeBaseUsageMock.defaultExpectation != nil && afterIncreaseKnowledgeBaseUsageCounter < 1 {
		if m.IncreaseKnowledgeBaseUsageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.IncreaseKnowledgeBaseUsage at\n%s", m.IncreaseKnowledgeBaseUsageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.IncreaseKnowledgeBaseUsage at\n%s with params: %#v", m.IncreaseKnowledgeBaseUsageMock.defaultExpectation.expectationOrigins.origin, *m.IncreaseKnowledgeBaseUsageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIncreaseKnowledgeBaseUsage != nil && afterIncreaseKnowledgeBaseUsageCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.IncreaseKnowledgeBaseUsage at\n%s", m.funcIncreaseKnowledgeBaseUsageOrigin)
	}

	if !m.IncreaseKnowledgeBaseUsageMock.invocationsDone() && afterIncreaseKnowledgeBaseUsageCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.IncreaseKnowledgeBaseUsage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IncreaseKnowledgeBaseUsageMock.expectedInvocations), m.IncreaseKnowledgeBaseUsageMock.expectedInvocationsOrigin, afterIncreaseKnowledgeBaseUsageCounter)
	}
}

type mRepositoryMockInsertVectorsInCollection struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockInsertVectorsInCollectionExpectation
	expectations       []*RepositoryMockInsertVectorsInCollectionExpectation

	callArgs []*RepositoryMockInsertVectorsInCollectionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockInsertVectorsInCollectionExpectation specifies expectation struct of the Repository.InsertVectorsInCollection
type RepositoryMockInsertVectorsInCollectionExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockInsertVectorsInCollectionParams
	paramPtrs          *RepositoryMockInsertVectorsInCollectionParamPtrs
	expectationOrigins RepositoryMockInsertVectorsInCollectionExpectationOrigins
	results            *RepositoryMockInsertVectorsInCollectionResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockInsertVectorsInCollectionParams contains parameters of the Repository.InsertVectorsInCollection
type RepositoryMockInsertVectorsInCollectionParams struct {
	ctx        context.Context
	collID     string
	embeddings []mm_repository.VectorEmbedding
}

// RepositoryMockInsertVectorsInCollectionParamPtrs contains pointers to parameters of the Repository.InsertVectorsInCollection
type RepositoryMockInsertVectorsInCollectionParamPtrs struct {
	ctx        *context.Context
	collID     *string
	embeddings *[]mm_repository.VectorEmbedding
}

// RepositoryMockInsertVectorsInCollectionResults contains results of the Repository.InsertVectorsInCollection
type RepositoryMockInsertVectorsInCollectionResults struct {
	err error
}

// RepositoryMockInsertVectorsInCollectionOrigins contains origins of expectations of the Repository.InsertVectorsInCollection
type RepositoryMockInsertVectorsInCollectionExpectationOrigins struct {
	origin           string
	originCtx        string
	originCollID     string
	originEmbeddings string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInsertVectorsInCollection *mRepositoryMockInsertVectorsInCollection) Optional() *mRepositoryMockInsertVectorsInCollection {
	mmInsertVectorsInCollection.optional = true
	return mmInsertVectorsInCollection
}

// Expect sets up expected params for Repository.InsertVectorsInCollection
func (mmInsertVectorsInCollection *mRepositoryMockInsertVectorsInCollection) Expect(ctx context.Context, collID string, embeddings []mm_repository.VectorEmbedding) *mRepositoryMockInsertVectorsInCollection {
	if mmInsertVectorsInCollection.mock.funcInsertVectorsInCollection != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("RepositoryMock.InsertVectorsInCollection mock is already set by Set")
	}

	if mmInsertVectorsInCollection.defaultExpectation == nil {
		mmInsertVectorsInCollection.defaultExpectation = &RepositoryMockInsertVectorsInCollectionExpectation{}
	}

	if mmInsertVectorsInCollection.defaultExpectation.paramPtrs != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("RepositoryMock.InsertVectorsInCollection mock is already set by ExpectParams functions")
	}

	mmInsertVectorsInCollection.defaultExpectation.params = &RepositoryMockInsertVectorsInCollectionParams{ctx, collID, embeddings}
	mmInsertVectorsInCollection.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmInsertVectorsInCollection.expectations {
		if minimock.Equal(e.params, mmInsertVectorsInCollection.defaultExpectation.params) {
			mmInsertVectorsInCollection.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInsertVectorsInCollection.defaultExpectation.params)
		}
	}

	return mmInsertVectorsInCollection
}

// ExpectCtxParam1 sets up expected param ctx for Repository.InsertVectorsInCollection
func (mmInsertVectorsInCollection *mRepositoryMockInsertVectorsInCollection) ExpectCtxParam1(ctx context.Context) *mRepositoryMockInsertVectorsInCollection {
	if mmInsertVectorsInCollection.mock.funcInsertVectorsInCollection != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("RepositoryMock.InsertVectorsInCollection mock is already set by Set")
	}

	if mmInsertVectorsInCollection.defaultExpectation == nil {
		mmInsertVectorsInCollection.defaultExpectation = &RepositoryMockInsertVectorsInCollectionExpectation{}
	}

	if mmInsertVectorsInCollection.defaultExpectation.params != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("RepositoryMock.InsertVectorsInCollection mock is already set by Expect")
	}

	if mmInsertVectorsInCollection.defaultExpectation.paramPtrs == nil {
		mmInsertVectorsInCollection.defaultExpectation.paramPtrs = &RepositoryMockInsertVectorsInCollectionParamPtrs{}
	}
	mmInsertVectorsInCollection.defaultExpectation.paramPtrs.ctx = &ctx
	mmInsertVectorsInCollection.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmInsertVectorsInCollection
}

// ExpectCollIDParam2 sets up expected param collID for Repository.InsertVectorsInCollection
func (mmInsertVectorsInCollection *mRepositoryMockInsertVectorsInCollection) ExpectCollIDParam2(collID string) *mRepositoryMockInsertVectorsInCollection {
	if mmInsertVectorsInCollection.mock.funcInsertVectorsInCollection != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("RepositoryMock.InsertVectorsInCollection mock is already set by Set")
	}

	if mmInsertVectorsInCollection.defaultExpectation == nil {
		mmInsertVectorsInCollection.defaultExpectation = &RepositoryMockInsertVectorsInCollectionExpectation{}
	}

	if mmInsertVectorsInCollection.defaultExpectation.params != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("RepositoryMock.InsertVectorsInCollection mock is already set by Expect")
	}

	if mmInsertVectorsInCollection.defaultExpectation.paramPtrs == nil {
		mmInsertVectorsInCollection.defaultExpectation.paramPtrs = &RepositoryMockInsertVectorsInCollectionParamPtrs{}
	}
	mmInsertVectorsInCollection.defaultExpectation.paramPtrs.collID = &collID
	mmInsertVectorsInCollection.defaultExpectation.expectationOrigins.originCollID = minimock.CallerInfo(1)

	return mmInsertVectorsInCollection
}

// ExpectEmbeddingsParam3 sets up expected param embeddings for Repository.InsertVectorsInCollection
func (mmInsertVectorsInCollection *mRepositoryMockInsertVectorsInCollection) ExpectEmbeddingsParam3(embeddings []mm_repository.VectorEmbedding) *mRepositoryMockInsertVectorsInCollection {
	if mmInsertVectorsInCollection.mock.funcInsertVectorsInCollection != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("RepositoryMock.InsertVectorsInCollection mock is already set by Set")
	}

	if mmInsertVectorsInCollection.defaultExpectation == nil {
		mmInsertVectorsInCollection.defaultExpectation = &RepositoryMockInsertVectorsInCollectionExpectation{}
	}

	if mmInsertVectorsInCollection.defaultExpectation.params != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("RepositoryMock.InsertVectorsInCollection mock is already set by Expect")
	}

	if mmInsertVectorsInCollection.defaultExpectation.paramPtrs == nil {
		mmInsertVectorsInCollection.defaultExpectation.paramPtrs = &RepositoryMockInsertVectorsInCollectionParamPtrs{}
	}
	mmInsertVectorsInCollection.defaultExpectation.paramPtrs.embeddings = &embeddings
	mmInsertVectorsInCollection.defaultExpectation.expectationOrigins.originEmbeddings = minimock.CallerInfo(1)

	return mmInsertVectorsInCollection
}

// Inspect accepts an inspector function that has same arguments as the Repository.InsertVectorsInCollection
func (mmInsertVectorsInCollection *mRepositoryMockInsertVectorsInCollection) Inspect(f func(ctx context.Context, collID string, embeddings []mm_repository.VectorEmbedding)) *mRepositoryMockInsertVectorsInCollection {
	if mmInsertVectorsInCollection.mock.inspectFuncInsertVectorsInCollection != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("Inspect function is already set for RepositoryMock.InsertVectorsInCollection")
	}

	mmInsertVectorsInCollection.mock.inspectFuncInsertVectorsInCollection = f

	return mmInsertVectorsInCollection
}

// Return sets up results that will be returned by Repository.InsertVectorsInCollection
func (mmInsertVectorsInCollection *mRepositoryMockInsertVectorsInCollection) Return(err error) *RepositoryMock {
	if mmInsertVectorsInCollection.mock.funcInsertVectorsInCollection != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("RepositoryMock.InsertVectorsInCollection mock is already set by Set")
	}

	if mmInsertVectorsInCollection.defaultExpectation == nil {
		mmInsertVectorsInCollection.defaultExpectation = &RepositoryMockInsertVectorsInCollectionExpectation{mock: mmInsertVectorsInCollection.mock}
	}
	mmInsertVectorsInCollection.defaultExpectation.results = &RepositoryMockInsertVectorsInCollectionResults{err}
	mmInsertVectorsInCollection.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInsertVectorsInCollection.mock
}

// Set uses given function f to mock the Repository.InsertVectorsInCollection method
func (mmInsertVectorsInCollection *mRepositoryMockInsertVectorsInCollection) Set(f func(ctx context.Context, collID string, embeddings []mm_repository.VectorEmbedding) (err error)) *RepositoryMock {
	if mmInsertVectorsInCollection.defaultExpectation != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("Default expectation is already set for the Repository.InsertVectorsInCollection method")
	}

	if len(mmInsertVectorsInCollection.expectations) > 0 {
		mmInsertVectorsInCollection.mock.t.Fatalf("Some expectations are already set for the Repository.InsertVectorsInCollection method")
	}

	mmInsertVectorsInCollection.mock.funcInsertVectorsInCollection = f
	mmInsertVectorsInCollection.mock.funcInsertVectorsInCollectionOrigin = minimock.CallerInfo(1)
	return mmInsertVectorsInCollection.mock
}

// When sets expectation for the Repository.InsertVectorsInCollection which will trigger the result defined by the following
// Then helper
func (mmInsertVectorsInCollection *mRepositoryMockInsertVectorsInCollection) When(ctx context.Context, collID string, embeddings []mm_repository.VectorEmbedding) *RepositoryMockInsertVectorsInCollectionExpectation {
	if mmInsertVectorsInCollection.mock.funcInsertVectorsInCollection != nil {
		mmInsertVectorsInCollection.mock.t.Fatalf("RepositoryMock.InsertVectorsInCollection mock is already set by Set")
	}

	expectation := &RepositoryMockInsertVectorsInCollectionExpectation{
		mock:               mmInsertVectorsInCollection.mock,
		params:             &RepositoryMockInsertVectorsInCollectionParams{ctx, collID, embeddings},
		expectationOrigins: RepositoryMockInsertVectorsInCollectionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmInsertVectorsInCollection.expectations = append(mmInsertVectorsInCollection.expectations, expectation)
	return expectation
}

// Then sets up Repository.InsertVectorsInCollection return parameters for the expectation previously defined by the When method
func (e *RepositoryMockInsertVectorsInCollectionExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockInsertVectorsInCollectionResults{err}
	return e.mock
}

// Times sets number of times Repository.InsertVectorsInCollection should be invoked
func (mmInsertVectorsInCollection *mRepositoryMockInsertVectorsInCollection) Times(n uint64) *mRepositoryMockInsertVectorsInCollection {
	if n == 0 {
		mmInsertVectorsInCollection.mock.t.Fatalf("Times of RepositoryMock.InsertVectorsInCollection mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInsertVectorsInCollection.expectedInvocations, n)
	mmInsertVectorsInCollection.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInsertVectorsInCollection
}

func (mmInsertVectorsInCollection *mRepositoryMockInsertVectorsInCollection) invocationsDone() bool {
	if len(mmInsertVectorsInCollection.expectations) == 0 && mmInsertVectorsInCollection.defaultExpectation == nil && mmInsertVectorsInCollection.mock.funcInsertVectorsInCollection == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInsertVectorsInCollection.mock.afterInsertVectorsInCollectionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInsertVectorsInCollection.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// InsertVectorsInCollection implements mm_repository.Repository
func (mmInsertVectorsInCollection *RepositoryMock) InsertVectorsInCollection(ctx context.Context, collID string, embeddings []mm_repository.VectorEmbedding) (err error) {
	mm_atomic.AddUint64(&mmInsertVectorsInCollection.beforeInsertVectorsInCollectionCounter, 1)
	defer mm_atomic.AddUint64(&mmInsertVectorsInCollection.afterInsertVectorsInCollectionCounter, 1)

	mmInsertVectorsInCollection.t.Helper()

	if mmInsertVectorsInCollection.inspectFuncInsertVectorsInCollection != nil {
		mmInsertVectorsInCollection.inspectFuncInsertVectorsInCollection(ctx, collID, embeddings)
	}

	mm_params := RepositoryMockInsertVectorsInCollectionParams{ctx, collID, embeddings}

	// Record call args
	mmInsertVectorsInCollection.InsertVectorsInCollectionMock.mutex.Lock()
	mmInsertVectorsInCollection.InsertVectorsInCollectionMock.callArgs = append(mmInsertVectorsInCollection.InsertVectorsInCollectionMock.callArgs, &mm_params)
	mmInsertVectorsInCollection.InsertVectorsInCollectionMock.mutex.Unlock()

	for _, e := range mmInsertVectorsInCollection.InsertVectorsInCollectionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmInsertVectorsInCollection.InsertVectorsInCollectionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInsertVectorsInCollection.InsertVectorsInCollectionMock.defaultExpectation.Counter, 1)
		mm_want := mmInsertVectorsInCollection.InsertVectorsInCollectionMock.defaultExpectation.params
		mm_want_ptrs := mmInsertVectorsInCollection.InsertVectorsInCollectionMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockInsertVectorsInCollectionParams{ctx, collID, embeddings}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmInsertVectorsInCollection.t.Errorf("RepositoryMock.InsertVectorsInCollection got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInsertVectorsInCollection.InsertVectorsInCollectionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.collID != nil && !minimock.Equal(*mm_want_ptrs.collID, mm_got.collID) {
				mmInsertVectorsInCollection.t.Errorf("RepositoryMock.InsertVectorsInCollection got unexpected parameter collID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInsertVectorsInCollection.InsertVectorsInCollectionMock.defaultExpectation.expectationOrigins.originCollID, *mm_want_ptrs.collID, mm_got.collID, minimock.Diff(*mm_want_ptrs.collID, mm_got.collID))
			}

			if mm_want_ptrs.embeddings != nil && !minimock.Equal(*mm_want_ptrs.embeddings, mm_got.embeddings) {
				mmInsertVectorsInCollection.t.Errorf("RepositoryMock.InsertVectorsInCollection got unexpected parameter embeddings, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInsertVectorsInCollection.InsertVectorsInCollectionMock.defaultExpectation.expectationOrigins.originEmbeddings, *mm_want_ptrs.embeddings, mm_got.embeddings, minimock.Diff(*mm_want_ptrs.embeddings, mm_got.embeddings))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInsertVectorsInCollection.t.Errorf("RepositoryMock.InsertVectorsInCollection got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmInsertVectorsInCollection.InsertVectorsInCollectionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInsertVectorsInCollection.InsertVectorsInCollectionMock.defaultExpectation.results
		if mm_results == nil {
			mmInsertVectorsInCollection.t.Fatal("No results are set for the RepositoryMock.InsertVectorsInCollection")
		}
		return (*mm_results).err
	}
	if mmInsertVectorsInCollection.funcInsertVectorsInCollection != nil {
		return mmInsertVectorsInCollection.funcInsertVectorsInCollection(ctx, collID, embeddings)
	}
	mmInsertVectorsInCollection.t.Fatalf("Unexpected call to RepositoryMock.InsertVectorsInCollection. %v %v %v", ctx, collID, embeddings)
	return
}

// InsertVectorsInCollectionAfterCounter returns a count of finished RepositoryMock.InsertVectorsInCollection invocations
func (mmInsertVectorsInCollection *RepositoryMock) InsertVectorsInCollectionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertVectorsInCollection.afterInsertVectorsInCollectionCounter)
}

// InsertVectorsInCollectionBeforeCounter returns a count of RepositoryMock.InsertVectorsInCollection invocations
func (mmInsertVectorsInCollection *RepositoryMock) InsertVectorsInCollectionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertVectorsInCollection.beforeInsertVectorsInCollectionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.InsertVectorsInCollection.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInsertVectorsInCollection *mRepositoryMockInsertVectorsInCollection) Calls() []*RepositoryMockInsertVectorsInCollectionParams {
	mmInsertVectorsInCollection.mutex.RLock()

	argCopy := make([]*RepositoryMockInsertVectorsInCollectionParams, len(mmInsertVectorsInCollection.callArgs))
	copy(argCopy, mmInsertVectorsInCollection.callArgs)

	mmInsertVectorsInCollection.mutex.RUnlock()

	return argCopy
}

// MinimockInsertVectorsInCollectionDone returns true if the count of the InsertVectorsInCollection invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockInsertVectorsInCollectionDone() bool {
	if m.InsertVectorsInCollectionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InsertVectorsInCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InsertVectorsInCollectionMock.invocationsDone()
}

// MinimockInsertVectorsInCollectionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockInsertVectorsInCollectionInspect() {
	for _, e := range m.InsertVectorsInCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.InsertVectorsInCollection at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterInsertVectorsInCollectionCounter := mm_atomic.LoadUint64(&m.afterInsertVectorsInCollectionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InsertVectorsInCollectionMock.defaultExpectation != nil && afterInsertVectorsInCollectionCounter < 1 {
		if m.InsertVectorsInCollectionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.InsertVectorsInCollection at\n%s", m.InsertVectorsInCollectionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.InsertVectorsInCollection at\n%s with params: %#v", m.InsertVectorsInCollectionMock.defaultExpectation.expectationOrigins.origin, *m.InsertVectorsInCollectionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertVectorsInCollection != nil && afterInsertVectorsInCollectionCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.InsertVectorsInCollection at\n%s", m.funcInsertVectorsInCollectionOrigin)
	}

	if !m.InsertVectorsInCollectionMock.invocationsDone() && afterInsertVectorsInCollectionCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.InsertVectorsInCollection at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InsertVectorsInCollectionMock.expectedInvocations), m.InsertVectorsInCollectionMock.expectedInvocationsOrigin, afterInsertVectorsInCollectionCounter)
	}
}

type mRepositoryMockListAllObjectURLs struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListAllObjectURLsExpectation
	expectations       []*RepositoryMockListAllObjectURLsExpectation

	callArgs []*RepositoryMockListAllObjectURLsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListAllObjectURLsExpectation specifies expectation struct of the Repository.ListAllObjectURLs
type RepositoryMockListAllObjectURLsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListAllObjectURLsParams
	paramPtrs          *RepositoryMockListAllObjectURLsParamPtrs
	expectationOrigins RepositoryMockListAllObjectURLsExpectationOrigins
	results            *RepositoryMockListAllObjectURLsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListAllObjectURLsParams contains parameters of the Repository.ListAllObjectURLs
type RepositoryMockListAllObjectURLsParams struct {
	ctx          context.Context
	namespaceUID types.NamespaceUIDType
	objectUID    types.ObjectUIDType
}

// RepositoryMockListAllObjectURLsParamPtrs contains pointers to parameters of the Repository.ListAllObjectURLs
type RepositoryMockListAllObjectURLsParamPtrs struct {
	ctx          *context.Context
	namespaceUID *types.NamespaceUIDType
	objectUID    *types.ObjectUIDType
}

// RepositoryMockListAllObjectURLsResults contains results of the Repository.ListAllObjectURLs
type RepositoryMockListAllObjectURLsResults struct {
	oa1 []mm_repository.ObjectURLModel
	err error
}

// RepositoryMockListAllObjectURLsOrigins contains origins of expectations of the Repository.ListAllObjectURLs
type RepositoryMockListAllObjectURLsExpectationOrigins struct {
	origin             string
	originCtx          string
	originNamespaceUID string
	originObjectUID    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListAllObjectURLs *mRepositoryMockListAllObjectURLs) Optional() *mRepositoryMockListAllObjectURLs {
	mmListAllObjectURLs.optional = true
	return mmListAllObjectURLs
}

// Expect sets up expected params for Repository.ListAllObjectURLs
func (mmListAllObjectURLs *mRepositoryMockListAllObjectURLs) Expect(ctx context.Context, namespaceUID types.NamespaceUIDType, objectUID types.ObjectUIDType) *mRepositoryMockListAllObjectURLs {
	if mmListAllObjectURLs.mock.funcListAllObjectURLs != nil {
		mmListAllObjectURLs.mock.t.Fatalf("RepositoryMock.ListAllObjectURLs mock is already set by Set")
	}

	if mmListAllObjectURLs.defaultExpectation == nil {
		mmListAllObjectURLs.defaultExpectation = &RepositoryMockListAllObjectURLsExpectation{}
	}

	if mmListAllObjectURLs.defaultExpectation.paramPtrs != nil {
		mmListAllObjectURLs.mock.t.Fatalf("RepositoryMock.ListAllObjectURLs mock is already set by ExpectParams functions")
	}

	mmListAllObjectURLs.defaultExpectation.params = &RepositoryMockListAllObjectURLsParams{ctx, namespaceUID, objectUID}
	mmListAllObjectURLs.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListAllObjectURLs.expectations {
		if minimock.Equal(e.params, mmListAllObjectURLs.defaultExpectation.params) {
			mmListAllObjectURLs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListAllObjectURLs.defaultExpectation.params)
		}
	}

	return mmListAllObjectURLs
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListAllObjectURLs
func (mmListAllObjectURLs *mRepositoryMockListAllObjectURLs) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListAllObjectURLs {
	if mmListAllObjectURLs.mock.funcListAllObjectURLs != nil {
		mmListAllObjectURLs.mock.t.Fatalf("RepositoryMock.ListAllObjectURLs mock is already set by Set")
	}

	if mmListAllObjectURLs.defaultExpectation == nil {
		mmListAllObjectURLs.defaultExpectation = &RepositoryMockListAllObjectURLsExpectation{}
	}

	if mmListAllObjectURLs.defaultExpectation.params != nil {
		mmListAllObjectURLs.mock.t.Fatalf("RepositoryMock.ListAllObjectURLs mock is already set by Expect")
	}

	if mmListAllObjectURLs.defaultExpectation.paramPtrs == nil {
		mmListAllObjectURLs.defaultExpectation.paramPtrs = &RepositoryMockListAllObjectURLsParamPtrs{}
	}
	mmListAllObjectURLs.defaultExpectation.paramPtrs.ctx = &ctx
	mmListAllObjectURLs.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListAllObjectURLs
}

// ExpectNamespaceUIDParam2 sets up expected param namespaceUID for Repository.ListAllObjectURLs
func (mmListAllObjectURLs *mRepositoryMockListAllObjectURLs) ExpectNamespaceUIDParam2(namespaceUID types.NamespaceUIDType) *mRepositoryMockListAllObjectURLs {
	if mmListAllObjectURLs.mock.funcListAllObjectURLs != nil {
		mmListAllObjectURLs.mock.t.Fatalf("RepositoryMock.ListAllObjectURLs mock is already set by Set")
	}

	if mmListAllObjectURLs.defaultExpectation == nil {
		mmListAllObjectURLs.defaultExpectation = &RepositoryMockListAllObjectURLsExpectation{}
	}

	if mmListAllObjectURLs.defaultExpectation.params != nil {
		mmListAllObjectURLs.mock.t.Fatalf("RepositoryMock.ListAllObjectURLs mock is already set by Expect")
	}

	if mmListAllObjectURLs.defaultExpectation.paramPtrs == nil {
		mmListAllObjectURLs.defaultExpectation.paramPtrs = &RepositoryMockListAllObjectURLsParamPtrs{}
	}
	mmListAllObjectURLs.defaultExpectation.paramPtrs.namespaceUID = &namespaceUID
	mmListAllObjectURLs.defaultExpectation.expectationOrigins.originNamespaceUID = minimock.CallerInfo(1)

	return mmListAllObjectURLs
}

// ExpectObjectUIDParam3 sets up expected param objectUID for Repository.ListAllObjectURLs
func (mmListAllObjectURLs *mRepositoryMockListAllObjectURLs) ExpectObjectUIDParam3(objectUID types.ObjectUIDType) *mRepositoryMockListAllObjectURLs {
	if mmListAllObjectURLs.mock.funcListAllObjectURLs != nil {
		mmListAllObjectURLs.mock.t.Fatalf("RepositoryMock.ListAllObjectURLs mock is already set by Set")
	}

	if mmListAllObjectURLs.defaultExpectation == nil {
		mmListAllObjectURLs.defaultExpectation = &RepositoryMockListAllObjectURLsExpectation{}
	}

	if mmListAllObjectURLs.defaultExpectation.params != nil {
		mmListAllObjectURLs.mock.t.Fatalf("RepositoryMock.ListAllObjectURLs mock is already set by Expect")
	}

	if mmListAllObjectURLs.defaultExpectation.paramPtrs == nil {
		mmListAllObjectURLs.defaultExpectation.paramPtrs = &RepositoryMockListAllObjectURLsParamPtrs{}
	}
	mmListAllObjectURLs.defaultExpectation.paramPtrs.objectUID = &objectUID
	mmListAllObjectURLs.defaultExpectation.expectationOrigins.originObjectUID = minimock.CallerInfo(1)

	return mmListAllObjectURLs
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListAllObjectURLs
func (mmListAllObjectURLs *mRepositoryMockListAllObjectURLs) Inspect(f func(ctx context.Context, namespaceUID types.NamespaceUIDType, objectUID types.ObjectUIDType)) *mRepositoryMockListAllObjectURLs {
	if mmListAllObjectURLs.mock.inspectFuncListAllObjectURLs != nil {
		mmListAllObjectURLs.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListAllObjectURLs")
	}

	mmListAllObjectURLs.mock.inspectFuncListAllObjectURLs = f

	return mmListAllObjectURLs
}

// Return sets up results that will be returned by Repository.ListAllObjectURLs
func (mmListAllObjectURLs *mRepositoryMockListAllObjectURLs) Return(oa1 []mm_repository.ObjectURLModel, err error) *RepositoryMock {
	if mmListAllObjectURLs.mock.funcListAllObjectURLs != nil {
		mmListAllObjectURLs.mock.t.Fatalf("RepositoryMock.ListAllObjectURLs mock is already set by Set")
	}

	if mmListAllObjectURLs.defaultExpectation == nil {
		mmListAllObjectURLs.defaultExpectation = &RepositoryMockListAllObjectURLsExpectation{mock: mmListAllObjectURLs.mock}
	}
	mmListAllObjectURLs.defaultExpectation.results = &RepositoryMockListAllObjectURLsResults{oa1, err}
	mmListAllObjectURLs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListAllObjectURLs.mock
}

// Set uses given function f to mock the Repository.ListAllObjectURLs method
func (mmListAllObjectURLs *mRepositoryMockListAllObjectURLs) Set(f func(ctx context.Context, namespaceUID types.NamespaceUIDType, objectUID types.ObjectUIDType) (oa1 []mm_repository.ObjectURLModel, err error)) *RepositoryMock {
	if mmListAllObjectURLs.defaultExpectation != nil {
		mmListAllObjectURLs.mock.t.Fatalf("Default expectation is already set for the Repository.ListAllObjectURLs method")
	}

	if len(mmListAllObjectURLs.expectations) > 0 {
		mmListAllObjectURLs.mock.t.Fatalf("Some expectations are already set for the Repository.ListAllObjectURLs method")
	}

	mmListAllObjectURLs.mock.funcListAllObjectURLs = f
	mmListAllObjectURLs.mock.funcListAllObjectURLsOrigin = minimock.CallerInfo(1)
	return mmListAllObjectURLs.mock
}

// When sets expectation for the Repository.ListAllObjectURLs which will trigger the result defined by the following
// Then helper
func (mmListAllObjectURLs *mRepositoryMockListAllObjectURLs) When(ctx context.Context, namespaceUID types.NamespaceUIDType, objectUID types.ObjectUIDType) *RepositoryMockListAllObjectURLsExpectation {
	if mmListAllObjectURLs.mock.funcListAllObjectURLs != nil {
		mmListAllObjectURLs.mock.t.Fatalf("RepositoryMock.ListAllObjectURLs mock is already set by Set")
	}

	expectation := &RepositoryMockListAllObjectURLsExpectation{
		mock:               mmListAllObjectURLs.mock,
		params:             &RepositoryMockListAllObjectURLsParams{ctx, namespaceUID, objectUID},
		expectationOrigins: RepositoryMockListAllObjectURLsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListAllObjectURLs.expectations = append(mmListAllObjectURLs.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListAllObjectURLs return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListAllObjectURLsExpectation) Then(oa1 []mm_repository.ObjectURLModel, err error) *RepositoryMock {
	e.results = &RepositoryMockListAllObjectURLsResults{oa1, err}
	return e.mock
}

// Times sets number of times Repository.ListAllObjectURLs should be invoked
func (mmListAllObjectURLs *mRepositoryMockListAllObjectURLs) Times(n uint64) *mRepositoryMockListAllObjectURLs {
	if n == 0 {
		mmListAllObjectURLs.mock.t.Fatalf("Times of RepositoryMock.ListAllObjectURLs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListAllObjectURLs.expectedInvocations, n)
	mmListAllObjectURLs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListAllObjectURLs
}

func (mmListAllObjectURLs *mRepositoryMockListAllObjectURLs) invocationsDone() bool {
	if len(mmListAllObjectURLs.expectations) == 0 && mmListAllObjectURLs.defaultExpectation == nil && mmListAllObjectURLs.mock.funcListAllObjectURLs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListAllObjectURLs.mock.afterListAllObjectURLsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListAllObjectURLs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListAllObjectURLs implements mm_repository.Repository
func (mmListAllObjectURLs *RepositoryMock) ListAllObjectURLs(ctx context.Context, namespaceUID types.NamespaceUIDType, objectUID types.ObjectUIDType) (oa1 []mm_repository.ObjectURLModel, err error) {
	mm_atomic.AddUint64(&mmListAllObjectURLs.beforeListAllObjectURLsCounter, 1)
	defer mm_atomic.AddUint64(&mmListAllObjectURLs.afterListAllObjectURLsCounter, 1)

	mmListAllObjectURLs.t.Helper()

	if mmListAllObjectURLs.inspectFuncListAllObjectURLs != nil {
		mmListAllObjectURLs.inspectFuncListAllObjectURLs(ctx, namespaceUID, objectUID)
	}

	mm_params := RepositoryMockListAllObjectURLsParams{ctx, namespaceUID, objectUID}

	// Record call args
	mmListAllObjectURLs.ListAllObjectURLsMock.mutex.Lock()
	mmListAllObjectURLs.ListAllObjectURLsMock.callArgs = append(mmListAllObjectURLs.ListAllObjectURLsMock.callArgs, &mm_params)
	mmListAllObjectURLs.ListAllObjectURLsMock.mutex.Unlock()

	for _, e := range mmListAllObjectURLs.ListAllObjectURLsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmListAllObjectURLs.ListAllObjectURLsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListAllObjectURLs.ListAllObjectURLsMock.defaultExpectation.Counter, 1)
		mm_want := mmListAllObjectURLs.ListAllObjectURLsMock.defaultExpectation.params
		mm_want_ptrs := mmListAllObjectURLs.ListAllObjectURLsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListAllObjectURLsParams{ctx, namespaceUID, objectUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListAllObjectURLs.t.Errorf("RepositoryMock.ListAllObjectURLs got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListAllObjectURLs.ListAllObjectURLsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.namespaceUID != nil && !minimock.Equal(*mm_want_ptrs.namespaceUID, mm_got.namespaceUID) {
				mmListAllObjectURLs.t.Errorf("RepositoryMock.ListAllObjectURLs got unexpected parameter namespaceUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListAllObjectURLs.ListAllObjectURLsMock.defaultExpectation.expectationOrigins.originNamespaceUID, *mm_want_ptrs.namespaceUID, mm_got.namespaceUID, minimock.Diff(*mm_want_ptrs.namespaceUID, mm_got.namespaceUID))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmListAllObjectURLs.t.Errorf("RepositoryMock.ListAllObjectURLs got unexpected parameter objectUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListAllObjectURLs.ListAllObjectURLsMock.defaultExpectation.expectationOrigins.originObjectUID, *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListAllObjectURLs.t.Errorf("RepositoryMock.ListAllObjectURLs got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListAllObjectURLs.ListAllObjectURLsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListAllObjectURLs.ListAllObjectURLsMock.defaultExpectation.results
		if mm_results == nil {
			mmListAllObjectURLs.t.Fatal("No results are set for the RepositoryMock.ListAllObjectURLs")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmListAllObjectURLs.funcListAllObjectURLs != nil {
		return mmListAllObjectURLs.funcListAllObjectURLs(ctx, namespaceUID, objectUID)
	}
	mmListAllObjectURLs.t.Fatalf("Unexpected call to RepositoryMock.ListAllObjectURLs. %v %v %v", ctx, namespaceUID, objectUID)
	return
}

// ListAllObjectURLsAfterCounter returns a count of finished RepositoryMock.ListAllObjectURLs invocations
func (mmListAllObjectURLs *RepositoryMock) ListAllObjectURLsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAllObjectURLs.afterListAllObjectURLsCounter)
}

// ListAllObjectURLsBeforeCounter returns a count of RepositoryMock.ListAllObjectURLs invocations
func (mmListAllObjectURLs *RepositoryMock) ListAllObjectURLsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAllObjectURLs.beforeListAllObjectURLsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListAllObjectURLs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListAllObjectURLs *mRepositoryMockListAllObjectURLs) Calls() []*RepositoryMockListAllObjectURLsParams {
	mmListAllObjectURLs.mutex.RLock()

	argCopy := make([]*RepositoryMockListAllObjectURLsParams, len(mmListAllObjectURLs.callArgs))
	copy(argCopy, mmListAllObjectURLs.callArgs)

	mmListAllObjectURLs.mutex.RUnlock()

	return argCopy
}

// MinimockListAllObjectURLsDone returns true if the count of the ListAllObjectURLs invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListAllObjectURLsDone() bool {
	if m.ListAllObjectURLsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListAllObjectURLsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListAllObjectURLsMock.invocationsDone()
}

// MinimockListAllObjectURLsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListAllObjectURLsInspect() {
	for _, e := range m.ListAllObjectURLsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListAllObjectURLs at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListAllObjectURLsCounter := mm_atomic.LoadUint64(&m.afterListAllObjectURLsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListAllObjectURLsMock.defaultExpectation != nil && afterListAllObjectURLsCounter < 1 {
		if m.ListAllObjectURLsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListAllObjectURLs at\n%s", m.ListAllObjectURLsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListAllObjectURLs at\n%s with params: %#v", m.ListAllObjectURLsMock.defaultExpectation.expectationOrigins.origin, *m.ListAllObjectURLsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListAllObjectURLs != nil && afterListAllObjectURLsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListAllObjectURLs at\n%s", m.funcListAllObjectURLsOrigin)
	}

	if !m.ListAllObjectURLsMock.invocationsDone() && afterListAllObjectURLsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListAllObjectURLs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListAllObjectURLsMock.expectedInvocations), m.ListAllObjectURLsMock.expectedInvocationsOrigin, afterListAllObjectURLsCounter)
	}
}

type mRepositoryMockListAllObjects struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListAllObjectsExpectation
	expectations       []*RepositoryMockListAllObjectsExpectation

	callArgs []*RepositoryMockListAllObjectsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListAllObjectsExpectation specifies expectation struct of the Repository.ListAllObjects
type RepositoryMockListAllObjectsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListAllObjectsParams
	paramPtrs          *RepositoryMockListAllObjectsParamPtrs
	expectationOrigins RepositoryMockListAllObjectsExpectationOrigins
	results            *RepositoryMockListAllObjectsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListAllObjectsParams contains parameters of the Repository.ListAllObjects
type RepositoryMockListAllObjectsParams struct {
	ctx          context.Context
	namespaceUID types.NamespaceUIDType
	creatorUID   types.CreatorUIDType
}

// RepositoryMockListAllObjectsParamPtrs contains pointers to parameters of the Repository.ListAllObjects
type RepositoryMockListAllObjectsParamPtrs struct {
	ctx          *context.Context
	namespaceUID *types.NamespaceUIDType
	creatorUID   *types.CreatorUIDType
}

// RepositoryMockListAllObjectsResults contains results of the Repository.ListAllObjects
type RepositoryMockListAllObjectsResults struct {
	oa1 []mm_repository.ObjectModel
	err error
}

// RepositoryMockListAllObjectsOrigins contains origins of expectations of the Repository.ListAllObjects
type RepositoryMockListAllObjectsExpectationOrigins struct {
	origin             string
	originCtx          string
	originNamespaceUID string
	originCreatorUID   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListAllObjects *mRepositoryMockListAllObjects) Optional() *mRepositoryMockListAllObjects {
	mmListAllObjects.optional = true
	return mmListAllObjects
}

// Expect sets up expected params for Repository.ListAllObjects
func (mmListAllObjects *mRepositoryMockListAllObjects) Expect(ctx context.Context, namespaceUID types.NamespaceUIDType, creatorUID types.CreatorUIDType) *mRepositoryMockListAllObjects {
	if mmListAllObjects.mock.funcListAllObjects != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryMock.ListAllObjects mock is already set by Set")
	}

	if mmListAllObjects.defaultExpectation == nil {
		mmListAllObjects.defaultExpectation = &RepositoryMockListAllObjectsExpectation{}
	}

	if mmListAllObjects.defaultExpectation.paramPtrs != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryMock.ListAllObjects mock is already set by ExpectParams functions")
	}

	mmListAllObjects.defaultExpectation.params = &RepositoryMockListAllObjectsParams{ctx, namespaceUID, creatorUID}
	mmListAllObjects.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListAllObjects.expectations {
		if minimock.Equal(e.params, mmListAllObjects.defaultExpectation.params) {
			mmListAllObjects.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListAllObjects.defaultExpectation.params)
		}
	}

	return mmListAllObjects
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListAllObjects
func (mmListAllObjects *mRepositoryMockListAllObjects) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListAllObjects {
	if mmListAllObjects.mock.funcListAllObjects != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryMock.ListAllObjects mock is already set by Set")
	}

	if mmListAllObjects.defaultExpectation == nil {
		mmListAllObjects.defaultExpectation = &RepositoryMockListAllObjectsExpectation{}
	}

	if mmListAllObjects.defaultExpectation.params != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryMock.ListAllObjects mock is already set by Expect")
	}

	if mmListAllObjects.defaultExpectation.paramPtrs == nil {
		mmListAllObjects.defaultExpectation.paramPtrs = &RepositoryMockListAllObjectsParamPtrs{}
	}
	mmListAllObjects.defaultExpectation.paramPtrs.ctx = &ctx
	mmListAllObjects.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListAllObjects
}

// ExpectNamespaceUIDParam2 sets up expected param namespaceUID for Repository.ListAllObjects
func (mmListAllObjects *mRepositoryMockListAllObjects) ExpectNamespaceUIDParam2(namespaceUID types.NamespaceUIDType) *mRepositoryMockListAllObjects {
	if mmListAllObjects.mock.funcListAllObjects != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryMock.ListAllObjects mock is already set by Set")
	}

	if mmListAllObjects.defaultExpectation == nil {
		mmListAllObjects.defaultExpectation = &RepositoryMockListAllObjectsExpectation{}
	}

	if mmListAllObjects.defaultExpectation.params != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryMock.ListAllObjects mock is already set by Expect")
	}

	if mmListAllObjects.defaultExpectation.paramPtrs == nil {
		mmListAllObjects.defaultExpectation.paramPtrs = &RepositoryMockListAllObjectsParamPtrs{}
	}
	mmListAllObjects.defaultExpectation.paramPtrs.namespaceUID = &namespaceUID
	mmListAllObjects.defaultExpectation.expectationOrigins.originNamespaceUID = minimock.CallerInfo(1)

	return mmListAllObjects
}

// ExpectCreatorUIDParam3 sets up expected param creatorUID for Repository.ListAllObjects
func (mmListAllObjects *mRepositoryMockListAllObjects) ExpectCreatorUIDParam3(creatorUID types.CreatorUIDType) *mRepositoryMockListAllObjects {
	if mmListAllObjects.mock.funcListAllObjects != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryMock.ListAllObjects mock is already set by Set")
	}

	if mmListAllObjects.defaultExpectation == nil {
		mmListAllObjects.defaultExpectation = &RepositoryMockListAllObjectsExpectation{}
	}

	if mmListAllObjects.defaultExpectation.params != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryMock.ListAllObjects mock is already set by Expect")
	}

	if mmListAllObjects.defaultExpectation.paramPtrs == nil {
		mmListAllObjects.defaultExpectation.paramPtrs = &RepositoryMockListAllObjectsParamPtrs{}
	}
	mmListAllObjects.defaultExpectation.paramPtrs.creatorUID = &creatorUID
	mmListAllObjects.defaultExpectation.expectationOrigins.originCreatorUID = minimock.CallerInfo(1)

	return mmListAllObjects
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListAllObjects
func (mmListAllObjects *mRepositoryMockListAllObjects) Inspect(f func(ctx context.Context, namespaceUID types.NamespaceUIDType, creatorUID types.CreatorUIDType)) *mRepositoryMockListAllObjects {
	if mmListAllObjects.mock.inspectFuncListAllObjects != nil {
		mmListAllObjects.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListAllObjects")
	}

	mmListAllObjects.mock.inspectFuncListAllObjects = f

	return mmListAllObjects
}

// Return sets up results that will be returned by Repository.ListAllObjects
func (mmListAllObjects *mRepositoryMockListAllObjects) Return(oa1 []mm_repository.ObjectModel, err error) *RepositoryMock {
	if mmListAllObjects.mock.funcListAllObjects != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryMock.ListAllObjects mock is already set by Set")
	}

	if mmListAllObjects.defaultExpectation == nil {
		mmListAllObjects.defaultExpectation = &RepositoryMockListAllObjectsExpectation{mock: mmListAllObjects.mock}
	}
	mmListAllObjects.defaultExpectation.results = &RepositoryMockListAllObjectsResults{oa1, err}
	mmListAllObjects.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListAllObjects.mock
}

// Set uses given function f to mock the Repository.ListAllObjects method
func (mmListAllObjects *mRepositoryMockListAllObjects) Set(f func(ctx context.Context, namespaceUID types.NamespaceUIDType, creatorUID types.CreatorUIDType) (oa1 []mm_repository.ObjectModel, err error)) *RepositoryMock {
	if mmListAllObjects.defaultExpectation != nil {
		mmListAllObjects.mock.t.Fatalf("Default expectation is already set for the Repository.ListAllObjects method")
	}

	if len(mmListAllObjects.expectations) > 0 {
		mmListAllObjects.mock.t.Fatalf("Some expectations are already set for the Repository.ListAllObjects method")
	}

	mmListAllObjects.mock.funcListAllObjects = f
	mmListAllObjects.mock.funcListAllObjectsOrigin = minimock.CallerInfo(1)
	return mmListAllObjects.mock
}

// When sets expectation for the Repository.ListAllObjects which will trigger the result defined by the following
// Then helper
func (mmListAllObjects *mRepositoryMockListAllObjects) When(ctx context.Context, namespaceUID types.NamespaceUIDType, creatorUID types.CreatorUIDType) *RepositoryMockListAllObjectsExpectation {
	if mmListAllObjects.mock.funcListAllObjects != nil {
		mmListAllObjects.mock.t.Fatalf("RepositoryMock.ListAllObjects mock is already set by Set")
	}

	expectation := &RepositoryMockListAllObjectsExpectation{
		mock:               mmListAllObjects.mock,
		params:             &RepositoryMockListAllObjectsParams{ctx, namespaceUID, creatorUID},
		expectationOrigins: RepositoryMockListAllObjectsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListAllObjects.expectations = append(mmListAllObjects.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListAllObjects return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListAllObjectsExpectation) Then(oa1 []mm_repository.ObjectModel, err error) *RepositoryMock {
	e.results = &RepositoryMockListAllObjectsResults{oa1, err}
	return e.mock
}

// Times sets number of times Repository.ListAllObjects should be invoked
func (mmListAllObjects *mRepositoryMockListAllObjects) Times(n uint64) *mRepositoryMockListAllObjects {
	if n == 0 {
		mmListAllObjects.mock.t.Fatalf("Times of RepositoryMock.ListAllObjects mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListAllObjects.expectedInvocations, n)
	mmListAllObjects.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListAllObjects
}

func (mmListAllObjects *mRepositoryMockListAllObjects) invocationsDone() bool {
	if len(mmListAllObjects.expectations) == 0 && mmListAllObjects.defaultExpectation == nil && mmListAllObjects.mock.funcListAllObjects == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListAllObjects.mock.afterListAllObjectsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListAllObjects.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListAllObjects implements mm_repository.Repository
func (mmListAllObjects *RepositoryMock) ListAllObjects(ctx context.Context, namespaceUID types.NamespaceUIDType, creatorUID types.CreatorUIDType) (oa1 []mm_repository.ObjectModel, err error) {
	mm_atomic.AddUint64(&mmListAllObjects.beforeListAllObjectsCounter, 1)
	defer mm_atomic.AddUint64(&mmListAllObjects.afterListAllObjectsCounter, 1)

	mmListAllObjects.t.Helper()

	if mmListAllObjects.inspectFuncListAllObjects != nil {
		mmListAllObjects.inspectFuncListAllObjects(ctx, namespaceUID, creatorUID)
	}

	mm_params := RepositoryMockListAllObjectsParams{ctx, namespaceUID, creatorUID}

	// Record call args
	mmListAllObjects.ListAllObjectsMock.mutex.Lock()
	mmListAllObjects.ListAllObjectsMock.callArgs = append(mmListAllObjects.ListAllObjectsMock.callArgs, &mm_params)
	mmListAllObjects.ListAllObjectsMock.mutex.Unlock()

	for _, e := range mmListAllObjects.ListAllObjectsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmListAllObjects.ListAllObjectsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListAllObjects.ListAllObjectsMock.defaultExpectation.Counter, 1)
		mm_want := mmListAllObjects.ListAllObjectsMock.defaultExpectation.params
		mm_want_ptrs := mmListAllObjects.ListAllObjectsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListAllObjectsParams{ctx, namespaceUID, creatorUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListAllObjects.t.Errorf("RepositoryMock.ListAllObjects got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListAllObjects.ListAllObjectsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.namespaceUID != nil && !minimock.Equal(*mm_want_ptrs.namespaceUID, mm_got.namespaceUID) {
				mmListAllObjects.t.Errorf("RepositoryMock.ListAllObjects got unexpected parameter namespaceUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListAllObjects.ListAllObjectsMock.defaultExpectation.expectationOrigins.originNamespaceUID, *mm_want_ptrs.namespaceUID, mm_got.namespaceUID, minimock.Diff(*mm_want_ptrs.namespaceUID, mm_got.namespaceUID))
			}

			if mm_want_ptrs.creatorUID != nil && !minimock.Equal(*mm_want_ptrs.creatorUID, mm_got.creatorUID) {
				mmListAllObjects.t.Errorf("RepositoryMock.ListAllObjects got unexpected parameter creatorUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListAllObjects.ListAllObjectsMock.defaultExpectation.expectationOrigins.originCreatorUID, *mm_want_ptrs.creatorUID, mm_got.creatorUID, minimock.Diff(*mm_want_ptrs.creatorUID, mm_got.creatorUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListAllObjects.t.Errorf("RepositoryMock.ListAllObjects got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListAllObjects.ListAllObjectsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListAllObjects.ListAllObjectsMock.defaultExpectation.results
		if mm_results == nil {
			mmListAllObjects.t.Fatal("No results are set for the RepositoryMock.ListAllObjects")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmListAllObjects.funcListAllObjects != nil {
		return mmListAllObjects.funcListAllObjects(ctx, namespaceUID, creatorUID)
	}
	mmListAllObjects.t.Fatalf("Unexpected call to RepositoryMock.ListAllObjects. %v %v %v", ctx, namespaceUID, creatorUID)
	return
}

// ListAllObjectsAfterCounter returns a count of finished RepositoryMock.ListAllObjects invocations
func (mmListAllObjects *RepositoryMock) ListAllObjectsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAllObjects.afterListAllObjectsCounter)
}

// ListAllObjectsBeforeCounter returns a count of RepositoryMock.ListAllObjects invocations
func (mmListAllObjects *RepositoryMock) ListAllObjectsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAllObjects.beforeListAllObjectsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListAllObjects.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListAllObjects *mRepositoryMockListAllObjects) Calls() []*RepositoryMockListAllObjectsParams {
	mmListAllObjects.mutex.RLock()

	argCopy := make([]*RepositoryMockListAllObjectsParams, len(mmListAllObjects.callArgs))
	copy(argCopy, mmListAllObjects.callArgs)

	mmListAllObjects.mutex.RUnlock()

	return argCopy
}

// MinimockListAllObjectsDone returns true if the count of the ListAllObjects invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListAllObjectsDone() bool {
	if m.ListAllObjectsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListAllObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListAllObjectsMock.invocationsDone()
}

// MinimockListAllObjectsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListAllObjectsInspect() {
	for _, e := range m.ListAllObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListAllObjects at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListAllObjectsCounter := mm_atomic.LoadUint64(&m.afterListAllObjectsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListAllObjectsMock.defaultExpectation != nil && afterListAllObjectsCounter < 1 {
		if m.ListAllObjectsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListAllObjects at\n%s", m.ListAllObjectsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListAllObjects at\n%s with params: %#v", m.ListAllObjectsMock.defaultExpectation.expectationOrigins.origin, *m.ListAllObjectsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListAllObjects != nil && afterListAllObjectsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListAllObjects at\n%s", m.funcListAllObjectsOrigin)
	}

	if !m.ListAllObjectsMock.invocationsDone() && afterListAllObjectsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListAllObjects at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListAllObjectsMock.expectedInvocations), m.ListAllObjectsMock.expectedInvocationsOrigin, afterListAllObjectsCounter)
	}
}

type mRepositoryMockListConvertedFilesByFileUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListConvertedFilesByFileUIDExpectation
	expectations       []*RepositoryMockListConvertedFilesByFileUIDExpectation

	callArgs []*RepositoryMockListConvertedFilesByFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListConvertedFilesByFileUIDExpectation specifies expectation struct of the Repository.ListConvertedFilesByFileUID
type RepositoryMockListConvertedFilesByFileUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListConvertedFilesByFileUIDParams
	paramPtrs          *RepositoryMockListConvertedFilesByFileUIDParamPtrs
	expectationOrigins RepositoryMockListConvertedFilesByFileUIDExpectationOrigins
	results            *RepositoryMockListConvertedFilesByFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListConvertedFilesByFileUIDParams contains parameters of the Repository.ListConvertedFilesByFileUID
type RepositoryMockListConvertedFilesByFileUIDParams struct {
	ctx     context.Context
	kbUID   types.KBUIDType
	fileUID types.FileUIDType
}

// RepositoryMockListConvertedFilesByFileUIDParamPtrs contains pointers to parameters of the Repository.ListConvertedFilesByFileUID
type RepositoryMockListConvertedFilesByFileUIDParamPtrs struct {
	ctx     *context.Context
	kbUID   *types.KBUIDType
	fileUID *types.FileUIDType
}

// RepositoryMockListConvertedFilesByFileUIDResults contains results of the Repository.ListConvertedFilesByFileUID
type RepositoryMockListConvertedFilesByFileUIDResults struct {
	sa1 []string
	err error
}

// RepositoryMockListConvertedFilesByFileUIDOrigins contains origins of expectations of the Repository.ListConvertedFilesByFileUID
type RepositoryMockListConvertedFilesByFileUIDExpectationOrigins struct {
	origin        string
	originCtx     string
	originKbUID   string
	originFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListConvertedFilesByFileUID *mRepositoryMockListConvertedFilesByFileUID) Optional() *mRepositoryMockListConvertedFilesByFileUID {
	mmListConvertedFilesByFileUID.optional = true
	return mmListConvertedFilesByFileUID
}

// Expect sets up expected params for Repository.ListConvertedFilesByFileUID
func (mmListConvertedFilesByFileUID *mRepositoryMockListConvertedFilesByFileUID) Expect(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType) *mRepositoryMockListConvertedFilesByFileUID {
	if mmListConvertedFilesByFileUID.mock.funcListConvertedFilesByFileUID != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("RepositoryMock.ListConvertedFilesByFileUID mock is already set by Set")
	}

	if mmListConvertedFilesByFileUID.defaultExpectation == nil {
		mmListConvertedFilesByFileUID.defaultExpectation = &RepositoryMockListConvertedFilesByFileUIDExpectation{}
	}

	if mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("RepositoryMock.ListConvertedFilesByFileUID mock is already set by ExpectParams functions")
	}

	mmListConvertedFilesByFileUID.defaultExpectation.params = &RepositoryMockListConvertedFilesByFileUIDParams{ctx, kbUID, fileUID}
	mmListConvertedFilesByFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListConvertedFilesByFileUID.expectations {
		if minimock.Equal(e.params, mmListConvertedFilesByFileUID.defaultExpectation.params) {
			mmListConvertedFilesByFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListConvertedFilesByFileUID.defaultExpectation.params)
		}
	}

	return mmListConvertedFilesByFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListConvertedFilesByFileUID
func (mmListConvertedFilesByFileUID *mRepositoryMockListConvertedFilesByFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListConvertedFilesByFileUID {
	if mmListConvertedFilesByFileUID.mock.funcListConvertedFilesByFileUID != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("RepositoryMock.ListConvertedFilesByFileUID mock is already set by Set")
	}

	if mmListConvertedFilesByFileUID.defaultExpectation == nil {
		mmListConvertedFilesByFileUID.defaultExpectation = &RepositoryMockListConvertedFilesByFileUIDExpectation{}
	}

	if mmListConvertedFilesByFileUID.defaultExpectation.params != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("RepositoryMock.ListConvertedFilesByFileUID mock is already set by Expect")
	}

	if mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs == nil {
		mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs = &RepositoryMockListConvertedFilesByFileUIDParamPtrs{}
	}
	mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmListConvertedFilesByFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListConvertedFilesByFileUID
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.ListConvertedFilesByFileUID
func (mmListConvertedFilesByFileUID *mRepositoryMockListConvertedFilesByFileUID) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockListConvertedFilesByFileUID {
	if mmListConvertedFilesByFileUID.mock.funcListConvertedFilesByFileUID != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("RepositoryMock.ListConvertedFilesByFileUID mock is already set by Set")
	}

	if mmListConvertedFilesByFileUID.defaultExpectation == nil {
		mmListConvertedFilesByFileUID.defaultExpectation = &RepositoryMockListConvertedFilesByFileUIDExpectation{}
	}

	if mmListConvertedFilesByFileUID.defaultExpectation.params != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("RepositoryMock.ListConvertedFilesByFileUID mock is already set by Expect")
	}

	if mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs == nil {
		mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs = &RepositoryMockListConvertedFilesByFileUIDParamPtrs{}
	}
	mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmListConvertedFilesByFileUID.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmListConvertedFilesByFileUID
}

// ExpectFileUIDParam3 sets up expected param fileUID for Repository.ListConvertedFilesByFileUID
func (mmListConvertedFilesByFileUID *mRepositoryMockListConvertedFilesByFileUID) ExpectFileUIDParam3(fileUID types.FileUIDType) *mRepositoryMockListConvertedFilesByFileUID {
	if mmListConvertedFilesByFileUID.mock.funcListConvertedFilesByFileUID != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("RepositoryMock.ListConvertedFilesByFileUID mock is already set by Set")
	}

	if mmListConvertedFilesByFileUID.defaultExpectation == nil {
		mmListConvertedFilesByFileUID.defaultExpectation = &RepositoryMockListConvertedFilesByFileUIDExpectation{}
	}

	if mmListConvertedFilesByFileUID.defaultExpectation.params != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("RepositoryMock.ListConvertedFilesByFileUID mock is already set by Expect")
	}

	if mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs == nil {
		mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs = &RepositoryMockListConvertedFilesByFileUIDParamPtrs{}
	}
	mmListConvertedFilesByFileUID.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmListConvertedFilesByFileUID.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmListConvertedFilesByFileUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListConvertedFilesByFileUID
func (mmListConvertedFilesByFileUID *mRepositoryMockListConvertedFilesByFileUID) Inspect(f func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType)) *mRepositoryMockListConvertedFilesByFileUID {
	if mmListConvertedFilesByFileUID.mock.inspectFuncListConvertedFilesByFileUID != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListConvertedFilesByFileUID")
	}

	mmListConvertedFilesByFileUID.mock.inspectFuncListConvertedFilesByFileUID = f

	return mmListConvertedFilesByFileUID
}

// Return sets up results that will be returned by Repository.ListConvertedFilesByFileUID
func (mmListConvertedFilesByFileUID *mRepositoryMockListConvertedFilesByFileUID) Return(sa1 []string, err error) *RepositoryMock {
	if mmListConvertedFilesByFileUID.mock.funcListConvertedFilesByFileUID != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("RepositoryMock.ListConvertedFilesByFileUID mock is already set by Set")
	}

	if mmListConvertedFilesByFileUID.defaultExpectation == nil {
		mmListConvertedFilesByFileUID.defaultExpectation = &RepositoryMockListConvertedFilesByFileUIDExpectation{mock: mmListConvertedFilesByFileUID.mock}
	}
	mmListConvertedFilesByFileUID.defaultExpectation.results = &RepositoryMockListConvertedFilesByFileUIDResults{sa1, err}
	mmListConvertedFilesByFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListConvertedFilesByFileUID.mock
}

// Set uses given function f to mock the Repository.ListConvertedFilesByFileUID method
func (mmListConvertedFilesByFileUID *mRepositoryMockListConvertedFilesByFileUID) Set(f func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType) (sa1 []string, err error)) *RepositoryMock {
	if mmListConvertedFilesByFileUID.defaultExpectation != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("Default expectation is already set for the Repository.ListConvertedFilesByFileUID method")
	}

	if len(mmListConvertedFilesByFileUID.expectations) > 0 {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("Some expectations are already set for the Repository.ListConvertedFilesByFileUID method")
	}

	mmListConvertedFilesByFileUID.mock.funcListConvertedFilesByFileUID = f
	mmListConvertedFilesByFileUID.mock.funcListConvertedFilesByFileUIDOrigin = minimock.CallerInfo(1)
	return mmListConvertedFilesByFileUID.mock
}

// When sets expectation for the Repository.ListConvertedFilesByFileUID which will trigger the result defined by the following
// Then helper
func (mmListConvertedFilesByFileUID *mRepositoryMockListConvertedFilesByFileUID) When(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType) *RepositoryMockListConvertedFilesByFileUIDExpectation {
	if mmListConvertedFilesByFileUID.mock.funcListConvertedFilesByFileUID != nil {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("RepositoryMock.ListConvertedFilesByFileUID mock is already set by Set")
	}

	expectation := &RepositoryMockListConvertedFilesByFileUIDExpectation{
		mock:               mmListConvertedFilesByFileUID.mock,
		params:             &RepositoryMockListConvertedFilesByFileUIDParams{ctx, kbUID, fileUID},
		expectationOrigins: RepositoryMockListConvertedFilesByFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListConvertedFilesByFileUID.expectations = append(mmListConvertedFilesByFileUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListConvertedFilesByFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListConvertedFilesByFileUIDExpectation) Then(sa1 []string, err error) *RepositoryMock {
	e.results = &RepositoryMockListConvertedFilesByFileUIDResults{sa1, err}
	return e.mock
}

// Times sets number of times Repository.ListConvertedFilesByFileUID should be invoked
func (mmListConvertedFilesByFileUID *mRepositoryMockListConvertedFilesByFileUID) Times(n uint64) *mRepositoryMockListConvertedFilesByFileUID {
	if n == 0 {
		mmListConvertedFilesByFileUID.mock.t.Fatalf("Times of RepositoryMock.ListConvertedFilesByFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListConvertedFilesByFileUID.expectedInvocations, n)
	mmListConvertedFilesByFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListConvertedFilesByFileUID
}

func (mmListConvertedFilesByFileUID *mRepositoryMockListConvertedFilesByFileUID) invocationsDone() bool {
	if len(mmListConvertedFilesByFileUID.expectations) == 0 && mmListConvertedFilesByFileUID.defaultExpectation == nil && mmListConvertedFilesByFileUID.mock.funcListConvertedFilesByFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListConvertedFilesByFileUID.mock.afterListConvertedFilesByFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListConvertedFilesByFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListConvertedFilesByFileUID implements mm_repository.Repository
func (mmListConvertedFilesByFileUID *RepositoryMock) ListConvertedFilesByFileUID(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmListConvertedFilesByFileUID.beforeListConvertedFilesByFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmListConvertedFilesByFileUID.afterListConvertedFilesByFileUIDCounter, 1)

	mmListConvertedFilesByFileUID.t.Helper()

	if mmListConvertedFilesByFileUID.inspectFuncListConvertedFilesByFileUID != nil {
		mmListConvertedFilesByFileUID.inspectFuncListConvertedFilesByFileUID(ctx, kbUID, fileUID)
	}

	mm_params := RepositoryMockListConvertedFilesByFileUIDParams{ctx, kbUID, fileUID}

	// Record call args
	mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.mutex.Lock()
	mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.callArgs = append(mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.callArgs, &mm_params)
	mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.mutex.Unlock()

	for _, e := range mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListConvertedFilesByFileUIDParams{ctx, kbUID, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListConvertedFilesByFileUID.t.Errorf("RepositoryMock.ListConvertedFilesByFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmListConvertedFilesByFileUID.t.Errorf("RepositoryMock.ListConvertedFilesByFileUID got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmListConvertedFilesByFileUID.t.Errorf("RepositoryMock.ListConvertedFilesByFileUID got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListConvertedFilesByFileUID.t.Errorf("RepositoryMock.ListConvertedFilesByFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListConvertedFilesByFileUID.ListConvertedFilesByFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmListConvertedFilesByFileUID.t.Fatal("No results are set for the RepositoryMock.ListConvertedFilesByFileUID")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmListConvertedFilesByFileUID.funcListConvertedFilesByFileUID != nil {
		return mmListConvertedFilesByFileUID.funcListConvertedFilesByFileUID(ctx, kbUID, fileUID)
	}
	mmListConvertedFilesByFileUID.t.Fatalf("Unexpected call to RepositoryMock.ListConvertedFilesByFileUID. %v %v %v", ctx, kbUID, fileUID)
	return
}

// ListConvertedFilesByFileUIDAfterCounter returns a count of finished RepositoryMock.ListConvertedFilesByFileUID invocations
func (mmListConvertedFilesByFileUID *RepositoryMock) ListConvertedFilesByFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListConvertedFilesByFileUID.afterListConvertedFilesByFileUIDCounter)
}

// ListConvertedFilesByFileUIDBeforeCounter returns a count of RepositoryMock.ListConvertedFilesByFileUID invocations
func (mmListConvertedFilesByFileUID *RepositoryMock) ListConvertedFilesByFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListConvertedFilesByFileUID.beforeListConvertedFilesByFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListConvertedFilesByFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListConvertedFilesByFileUID *mRepositoryMockListConvertedFilesByFileUID) Calls() []*RepositoryMockListConvertedFilesByFileUIDParams {
	mmListConvertedFilesByFileUID.mutex.RLock()

	argCopy := make([]*RepositoryMockListConvertedFilesByFileUIDParams, len(mmListConvertedFilesByFileUID.callArgs))
	copy(argCopy, mmListConvertedFilesByFileUID.callArgs)

	mmListConvertedFilesByFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockListConvertedFilesByFileUIDDone returns true if the count of the ListConvertedFilesByFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListConvertedFilesByFileUIDDone() bool {
	if m.ListConvertedFilesByFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListConvertedFilesByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListConvertedFilesByFileUIDMock.invocationsDone()
}

// MinimockListConvertedFilesByFileUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListConvertedFilesByFileUIDInspect() {
	for _, e := range m.ListConvertedFilesByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListConvertedFilesByFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListConvertedFilesByFileUIDCounter := mm_atomic.LoadUint64(&m.afterListConvertedFilesByFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListConvertedFilesByFileUIDMock.defaultExpectation != nil && afterListConvertedFilesByFileUIDCounter < 1 {
		if m.ListConvertedFilesByFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListConvertedFilesByFileUID at\n%s", m.ListConvertedFilesByFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListConvertedFilesByFileUID at\n%s with params: %#v", m.ListConvertedFilesByFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.ListConvertedFilesByFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListConvertedFilesByFileUID != nil && afterListConvertedFilesByFileUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListConvertedFilesByFileUID at\n%s", m.funcListConvertedFilesByFileUIDOrigin)
	}

	if !m.ListConvertedFilesByFileUIDMock.invocationsDone() && afterListConvertedFilesByFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListConvertedFilesByFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListConvertedFilesByFileUIDMock.expectedInvocations), m.ListConvertedFilesByFileUIDMock.expectedInvocationsOrigin, afterListConvertedFilesByFileUIDCounter)
	}
}

type mRepositoryMockListEmbeddingsByKBFileUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListEmbeddingsByKBFileUIDExpectation
	expectations       []*RepositoryMockListEmbeddingsByKBFileUIDExpectation

	callArgs []*RepositoryMockListEmbeddingsByKBFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListEmbeddingsByKBFileUIDExpectation specifies expectation struct of the Repository.ListEmbeddingsByKBFileUID
type RepositoryMockListEmbeddingsByKBFileUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListEmbeddingsByKBFileUIDParams
	paramPtrs          *RepositoryMockListEmbeddingsByKBFileUIDParamPtrs
	expectationOrigins RepositoryMockListEmbeddingsByKBFileUIDExpectationOrigins
	results            *RepositoryMockListEmbeddingsByKBFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListEmbeddingsByKBFileUIDParams contains parameters of the Repository.ListEmbeddingsByKBFileUID
type RepositoryMockListEmbeddingsByKBFileUIDParams struct {
	ctx       context.Context
	kbFileUID types.FileUIDType
}

// RepositoryMockListEmbeddingsByKBFileUIDParamPtrs contains pointers to parameters of the Repository.ListEmbeddingsByKBFileUID
type RepositoryMockListEmbeddingsByKBFileUIDParamPtrs struct {
	ctx       *context.Context
	kbFileUID *types.FileUIDType
}

// RepositoryMockListEmbeddingsByKBFileUIDResults contains results of the Repository.ListEmbeddingsByKBFileUID
type RepositoryMockListEmbeddingsByKBFileUIDResults struct {
	ea1 []mm_repository.EmbeddingModel
	err error
}

// RepositoryMockListEmbeddingsByKBFileUIDOrigins contains origins of expectations of the Repository.ListEmbeddingsByKBFileUID
type RepositoryMockListEmbeddingsByKBFileUIDExpectationOrigins struct {
	origin          string
	originCtx       string
	originKbFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListEmbeddingsByKBFileUID *mRepositoryMockListEmbeddingsByKBFileUID) Optional() *mRepositoryMockListEmbeddingsByKBFileUID {
	mmListEmbeddingsByKBFileUID.optional = true
	return mmListEmbeddingsByKBFileUID
}

// Expect sets up expected params for Repository.ListEmbeddingsByKBFileUID
func (mmListEmbeddingsByKBFileUID *mRepositoryMockListEmbeddingsByKBFileUID) Expect(ctx context.Context, kbFileUID types.FileUIDType) *mRepositoryMockListEmbeddingsByKBFileUID {
	if mmListEmbeddingsByKBFileUID.mock.funcListEmbeddingsByKBFileUID != nil {
		mmListEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.ListEmbeddingsByKBFileUID mock is already set by Set")
	}

	if mmListEmbeddingsByKBFileUID.defaultExpectation == nil {
		mmListEmbeddingsByKBFileUID.defaultExpectation = &RepositoryMockListEmbeddingsByKBFileUIDExpectation{}
	}

	if mmListEmbeddingsByKBFileUID.defaultExpectation.paramPtrs != nil {
		mmListEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.ListEmbeddingsByKBFileUID mock is already set by ExpectParams functions")
	}

	mmListEmbeddingsByKBFileUID.defaultExpectation.params = &RepositoryMockListEmbeddingsByKBFileUIDParams{ctx, kbFileUID}
	mmListEmbeddingsByKBFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListEmbeddingsByKBFileUID.expectations {
		if minimock.Equal(e.params, mmListEmbeddingsByKBFileUID.defaultExpectation.params) {
			mmListEmbeddingsByKBFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListEmbeddingsByKBFileUID.defaultExpectation.params)
		}
	}

	return mmListEmbeddingsByKBFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListEmbeddingsByKBFileUID
func (mmListEmbeddingsByKBFileUID *mRepositoryMockListEmbeddingsByKBFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListEmbeddingsByKBFileUID {
	if mmListEmbeddingsByKBFileUID.mock.funcListEmbeddingsByKBFileUID != nil {
		mmListEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.ListEmbeddingsByKBFileUID mock is already set by Set")
	}

	if mmListEmbeddingsByKBFileUID.defaultExpectation == nil {
		mmListEmbeddingsByKBFileUID.defaultExpectation = &RepositoryMockListEmbeddingsByKBFileUIDExpectation{}
	}

	if mmListEmbeddingsByKBFileUID.defaultExpectation.params != nil {
		mmListEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.ListEmbeddingsByKBFileUID mock is already set by Expect")
	}

	if mmListEmbeddingsByKBFileUID.defaultExpectation.paramPtrs == nil {
		mmListEmbeddingsByKBFileUID.defaultExpectation.paramPtrs = &RepositoryMockListEmbeddingsByKBFileUIDParamPtrs{}
	}
	mmListEmbeddingsByKBFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmListEmbeddingsByKBFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListEmbeddingsByKBFileUID
}

// ExpectKbFileUIDParam2 sets up expected param kbFileUID for Repository.ListEmbeddingsByKBFileUID
func (mmListEmbeddingsByKBFileUID *mRepositoryMockListEmbeddingsByKBFileUID) ExpectKbFileUIDParam2(kbFileUID types.FileUIDType) *mRepositoryMockListEmbeddingsByKBFileUID {
	if mmListEmbeddingsByKBFileUID.mock.funcListEmbeddingsByKBFileUID != nil {
		mmListEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.ListEmbeddingsByKBFileUID mock is already set by Set")
	}

	if mmListEmbeddingsByKBFileUID.defaultExpectation == nil {
		mmListEmbeddingsByKBFileUID.defaultExpectation = &RepositoryMockListEmbeddingsByKBFileUIDExpectation{}
	}

	if mmListEmbeddingsByKBFileUID.defaultExpectation.params != nil {
		mmListEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.ListEmbeddingsByKBFileUID mock is already set by Expect")
	}

	if mmListEmbeddingsByKBFileUID.defaultExpectation.paramPtrs == nil {
		mmListEmbeddingsByKBFileUID.defaultExpectation.paramPtrs = &RepositoryMockListEmbeddingsByKBFileUIDParamPtrs{}
	}
	mmListEmbeddingsByKBFileUID.defaultExpectation.paramPtrs.kbFileUID = &kbFileUID
	mmListEmbeddingsByKBFileUID.defaultExpectation.expectationOrigins.originKbFileUID = minimock.CallerInfo(1)

	return mmListEmbeddingsByKBFileUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListEmbeddingsByKBFileUID
func (mmListEmbeddingsByKBFileUID *mRepositoryMockListEmbeddingsByKBFileUID) Inspect(f func(ctx context.Context, kbFileUID types.FileUIDType)) *mRepositoryMockListEmbeddingsByKBFileUID {
	if mmListEmbeddingsByKBFileUID.mock.inspectFuncListEmbeddingsByKBFileUID != nil {
		mmListEmbeddingsByKBFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListEmbeddingsByKBFileUID")
	}

	mmListEmbeddingsByKBFileUID.mock.inspectFuncListEmbeddingsByKBFileUID = f

	return mmListEmbeddingsByKBFileUID
}

// Return sets up results that will be returned by Repository.ListEmbeddingsByKBFileUID
func (mmListEmbeddingsByKBFileUID *mRepositoryMockListEmbeddingsByKBFileUID) Return(ea1 []mm_repository.EmbeddingModel, err error) *RepositoryMock {
	if mmListEmbeddingsByKBFileUID.mock.funcListEmbeddingsByKBFileUID != nil {
		mmListEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.ListEmbeddingsByKBFileUID mock is already set by Set")
	}

	if mmListEmbeddingsByKBFileUID.defaultExpectation == nil {
		mmListEmbeddingsByKBFileUID.defaultExpectation = &RepositoryMockListEmbeddingsByKBFileUIDExpectation{mock: mmListEmbeddingsByKBFileUID.mock}
	}
	mmListEmbeddingsByKBFileUID.defaultExpectation.results = &RepositoryMockListEmbeddingsByKBFileUIDResults{ea1, err}
	mmListEmbeddingsByKBFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListEmbeddingsByKBFileUID.mock
}

// Set uses given function f to mock the Repository.ListEmbeddingsByKBFileUID method
func (mmListEmbeddingsByKBFileUID *mRepositoryMockListEmbeddingsByKBFileUID) Set(f func(ctx context.Context, kbFileUID types.FileUIDType) (ea1 []mm_repository.EmbeddingModel, err error)) *RepositoryMock {
	if mmListEmbeddingsByKBFileUID.defaultExpectation != nil {
		mmListEmbeddingsByKBFileUID.mock.t.Fatalf("Default expectation is already set for the Repository.ListEmbeddingsByKBFileUID method")
	}

	if len(mmListEmbeddingsByKBFileUID.expectations) > 0 {
		mmListEmbeddingsByKBFileUID.mock.t.Fatalf("Some expectations are already set for the Repository.ListEmbeddingsByKBFileUID method")
	}

	mmListEmbeddingsByKBFileUID.mock.funcListEmbeddingsByKBFileUID = f
	mmListEmbeddingsByKBFileUID.mock.funcListEmbeddingsByKBFileUIDOrigin = minimock.CallerInfo(1)
	return mmListEmbeddingsByKBFileUID.mock
}

// When sets expectation for the Repository.ListEmbeddingsByKBFileUID which will trigger the result defined by the following
// Then helper
func (mmListEmbeddingsByKBFileUID *mRepositoryMockListEmbeddingsByKBFileUID) When(ctx context.Context, kbFileUID types.FileUIDType) *RepositoryMockListEmbeddingsByKBFileUIDExpectation {
	if mmListEmbeddingsByKBFileUID.mock.funcListEmbeddingsByKBFileUID != nil {
		mmListEmbeddingsByKBFileUID.mock.t.Fatalf("RepositoryMock.ListEmbeddingsByKBFileUID mock is already set by Set")
	}

	expectation := &RepositoryMockListEmbeddingsByKBFileUIDExpectation{
		mock:               mmListEmbeddingsByKBFileUID.mock,
		params:             &RepositoryMockListEmbeddingsByKBFileUIDParams{ctx, kbFileUID},
		expectationOrigins: RepositoryMockListEmbeddingsByKBFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListEmbeddingsByKBFileUID.expectations = append(mmListEmbeddingsByKBFileUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListEmbeddingsByKBFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListEmbeddingsByKBFileUIDExpectation) Then(ea1 []mm_repository.EmbeddingModel, err error) *RepositoryMock {
	e.results = &RepositoryMockListEmbeddingsByKBFileUIDResults{ea1, err}
	return e.mock
}

// Times sets number of times Repository.ListEmbeddingsByKBFileUID should be invoked
func (mmListEmbeddingsByKBFileUID *mRepositoryMockListEmbeddingsByKBFileUID) Times(n uint64) *mRepositoryMockListEmbeddingsByKBFileUID {
	if n == 0 {
		mmListEmbeddingsByKBFileUID.mock.t.Fatalf("Times of RepositoryMock.ListEmbeddingsByKBFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListEmbeddingsByKBFileUID.expectedInvocations, n)
	mmListEmbeddingsByKBFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListEmbeddingsByKBFileUID
}

func (mmListEmbeddingsByKBFileUID *mRepositoryMockListEmbeddingsByKBFileUID) invocationsDone() bool {
	if len(mmListEmbeddingsByKBFileUID.expectations) == 0 && mmListEmbeddingsByKBFileUID.defaultExpectation == nil && mmListEmbeddingsByKBFileUID.mock.funcListEmbeddingsByKBFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListEmbeddingsByKBFileUID.mock.afterListEmbeddingsByKBFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListEmbeddingsByKBFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListEmbeddingsByKBFileUID implements mm_repository.Repository
func (mmListEmbeddingsByKBFileUID *RepositoryMock) ListEmbeddingsByKBFileUID(ctx context.Context, kbFileUID types.FileUIDType) (ea1 []mm_repository.EmbeddingModel, err error) {
	mm_atomic.AddUint64(&mmListEmbeddingsByKBFileUID.beforeListEmbeddingsByKBFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmListEmbeddingsByKBFileUID.afterListEmbeddingsByKBFileUIDCounter, 1)

	mmListEmbeddingsByKBFileUID.t.Helper()

	if mmListEmbeddingsByKBFileUID.inspectFuncListEmbeddingsByKBFileUID != nil {
		mmListEmbeddingsByKBFileUID.inspectFuncListEmbeddingsByKBFileUID(ctx, kbFileUID)
	}

	mm_params := RepositoryMockListEmbeddingsByKBFileUIDParams{ctx, kbFileUID}

	// Record call args
	mmListEmbeddingsByKBFileUID.ListEmbeddingsByKBFileUIDMock.mutex.Lock()
	mmListEmbeddingsByKBFileUID.ListEmbeddingsByKBFileUIDMock.callArgs = append(mmListEmbeddingsByKBFileUID.ListEmbeddingsByKBFileUIDMock.callArgs, &mm_params)
	mmListEmbeddingsByKBFileUID.ListEmbeddingsByKBFileUIDMock.mutex.Unlock()

	for _, e := range mmListEmbeddingsByKBFileUID.ListEmbeddingsByKBFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1, e.results.err
		}
	}

	if mmListEmbeddingsByKBFileUID.ListEmbeddingsByKBFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListEmbeddingsByKBFileUID.ListEmbeddingsByKBFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmListEmbeddingsByKBFileUID.ListEmbeddingsByKBFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmListEmbeddingsByKBFileUID.ListEmbeddingsByKBFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListEmbeddingsByKBFileUIDParams{ctx, kbFileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListEmbeddingsByKBFileUID.t.Errorf("RepositoryMock.ListEmbeddingsByKBFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListEmbeddingsByKBFileUID.ListEmbeddingsByKBFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbFileUID != nil && !minimock.Equal(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID) {
				mmListEmbeddingsByKBFileUID.t.Errorf("RepositoryMock.ListEmbeddingsByKBFileUID got unexpected parameter kbFileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListEmbeddingsByKBFileUID.ListEmbeddingsByKBFileUIDMock.defaultExpectation.expectationOrigins.originKbFileUID, *mm_want_ptrs.kbFileUID, mm_got.kbFileUID, minimock.Diff(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListEmbeddingsByKBFileUID.t.Errorf("RepositoryMock.ListEmbeddingsByKBFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListEmbeddingsByKBFileUID.ListEmbeddingsByKBFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListEmbeddingsByKBFileUID.ListEmbeddingsByKBFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmListEmbeddingsByKBFileUID.t.Fatal("No results are set for the RepositoryMock.ListEmbeddingsByKBFileUID")
		}
		return (*mm_results).ea1, (*mm_results).err
	}
	if mmListEmbeddingsByKBFileUID.funcListEmbeddingsByKBFileUID != nil {
		return mmListEmbeddingsByKBFileUID.funcListEmbeddingsByKBFileUID(ctx, kbFileUID)
	}
	mmListEmbeddingsByKBFileUID.t.Fatalf("Unexpected call to RepositoryMock.ListEmbeddingsByKBFileUID. %v %v", ctx, kbFileUID)
	return
}

// ListEmbeddingsByKBFileUIDAfterCounter returns a count of finished RepositoryMock.ListEmbeddingsByKBFileUID invocations
func (mmListEmbeddingsByKBFileUID *RepositoryMock) ListEmbeddingsByKBFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListEmbeddingsByKBFileUID.afterListEmbeddingsByKBFileUIDCounter)
}

// ListEmbeddingsByKBFileUIDBeforeCounter returns a count of RepositoryMock.ListEmbeddingsByKBFileUID invocations
func (mmListEmbeddingsByKBFileUID *RepositoryMock) ListEmbeddingsByKBFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListEmbeddingsByKBFileUID.beforeListEmbeddingsByKBFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListEmbeddingsByKBFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListEmbeddingsByKBFileUID *mRepositoryMockListEmbeddingsByKBFileUID) Calls() []*RepositoryMockListEmbeddingsByKBFileUIDParams {
	mmListEmbeddingsByKBFileUID.mutex.RLock()

	argCopy := make([]*RepositoryMockListEmbeddingsByKBFileUIDParams, len(mmListEmbeddingsByKBFileUID.callArgs))
	copy(argCopy, mmListEmbeddingsByKBFileUID.callArgs)

	mmListEmbeddingsByKBFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockListEmbeddingsByKBFileUIDDone returns true if the count of the ListEmbeddingsByKBFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListEmbeddingsByKBFileUIDDone() bool {
	if m.ListEmbeddingsByKBFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListEmbeddingsByKBFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListEmbeddingsByKBFileUIDMock.invocationsDone()
}

// MinimockListEmbeddingsByKBFileUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListEmbeddingsByKBFileUIDInspect() {
	for _, e := range m.ListEmbeddingsByKBFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListEmbeddingsByKBFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListEmbeddingsByKBFileUIDCounter := mm_atomic.LoadUint64(&m.afterListEmbeddingsByKBFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListEmbeddingsByKBFileUIDMock.defaultExpectation != nil && afterListEmbeddingsByKBFileUIDCounter < 1 {
		if m.ListEmbeddingsByKBFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListEmbeddingsByKBFileUID at\n%s", m.ListEmbeddingsByKBFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListEmbeddingsByKBFileUID at\n%s with params: %#v", m.ListEmbeddingsByKBFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.ListEmbeddingsByKBFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListEmbeddingsByKBFileUID != nil && afterListEmbeddingsByKBFileUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListEmbeddingsByKBFileUID at\n%s", m.funcListEmbeddingsByKBFileUIDOrigin)
	}

	if !m.ListEmbeddingsByKBFileUIDMock.invocationsDone() && afterListEmbeddingsByKBFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListEmbeddingsByKBFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListEmbeddingsByKBFileUIDMock.expectedInvocations), m.ListEmbeddingsByKBFileUIDMock.expectedInvocationsOrigin, afterListEmbeddingsByKBFileUIDCounter)
	}
}

type mRepositoryMockListFilePathsWithPrefix struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListFilePathsWithPrefixExpectation
	expectations       []*RepositoryMockListFilePathsWithPrefixExpectation

	callArgs []*RepositoryMockListFilePathsWithPrefixParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListFilePathsWithPrefixExpectation specifies expectation struct of the Repository.ListFilePathsWithPrefix
type RepositoryMockListFilePathsWithPrefixExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListFilePathsWithPrefixParams
	paramPtrs          *RepositoryMockListFilePathsWithPrefixParamPtrs
	expectationOrigins RepositoryMockListFilePathsWithPrefixExpectationOrigins
	results            *RepositoryMockListFilePathsWithPrefixResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListFilePathsWithPrefixParams contains parameters of the Repository.ListFilePathsWithPrefix
type RepositoryMockListFilePathsWithPrefixParams struct {
	ctx    context.Context
	bucket string
	prefix string
}

// RepositoryMockListFilePathsWithPrefixParamPtrs contains pointers to parameters of the Repository.ListFilePathsWithPrefix
type RepositoryMockListFilePathsWithPrefixParamPtrs struct {
	ctx    *context.Context
	bucket *string
	prefix *string
}

// RepositoryMockListFilePathsWithPrefixResults contains results of the Repository.ListFilePathsWithPrefix
type RepositoryMockListFilePathsWithPrefixResults struct {
	sa1 []string
	err error
}

// RepositoryMockListFilePathsWithPrefixOrigins contains origins of expectations of the Repository.ListFilePathsWithPrefix
type RepositoryMockListFilePathsWithPrefixExpectationOrigins struct {
	origin       string
	originCtx    string
	originBucket string
	originPrefix string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListFilePathsWithPrefix *mRepositoryMockListFilePathsWithPrefix) Optional() *mRepositoryMockListFilePathsWithPrefix {
	mmListFilePathsWithPrefix.optional = true
	return mmListFilePathsWithPrefix
}

// Expect sets up expected params for Repository.ListFilePathsWithPrefix
func (mmListFilePathsWithPrefix *mRepositoryMockListFilePathsWithPrefix) Expect(ctx context.Context, bucket string, prefix string) *mRepositoryMockListFilePathsWithPrefix {
	if mmListFilePathsWithPrefix.mock.funcListFilePathsWithPrefix != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("RepositoryMock.ListFilePathsWithPrefix mock is already set by Set")
	}

	if mmListFilePathsWithPrefix.defaultExpectation == nil {
		mmListFilePathsWithPrefix.defaultExpectation = &RepositoryMockListFilePathsWithPrefixExpectation{}
	}

	if mmListFilePathsWithPrefix.defaultExpectation.paramPtrs != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("RepositoryMock.ListFilePathsWithPrefix mock is already set by ExpectParams functions")
	}

	mmListFilePathsWithPrefix.defaultExpectation.params = &RepositoryMockListFilePathsWithPrefixParams{ctx, bucket, prefix}
	mmListFilePathsWithPrefix.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListFilePathsWithPrefix.expectations {
		if minimock.Equal(e.params, mmListFilePathsWithPrefix.defaultExpectation.params) {
			mmListFilePathsWithPrefix.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListFilePathsWithPrefix.defaultExpectation.params)
		}
	}

	return mmListFilePathsWithPrefix
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListFilePathsWithPrefix
func (mmListFilePathsWithPrefix *mRepositoryMockListFilePathsWithPrefix) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListFilePathsWithPrefix {
	if mmListFilePathsWithPrefix.mock.funcListFilePathsWithPrefix != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("RepositoryMock.ListFilePathsWithPrefix mock is already set by Set")
	}

	if mmListFilePathsWithPrefix.defaultExpectation == nil {
		mmListFilePathsWithPrefix.defaultExpectation = &RepositoryMockListFilePathsWithPrefixExpectation{}
	}

	if mmListFilePathsWithPrefix.defaultExpectation.params != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("RepositoryMock.ListFilePathsWithPrefix mock is already set by Expect")
	}

	if mmListFilePathsWithPrefix.defaultExpectation.paramPtrs == nil {
		mmListFilePathsWithPrefix.defaultExpectation.paramPtrs = &RepositoryMockListFilePathsWithPrefixParamPtrs{}
	}
	mmListFilePathsWithPrefix.defaultExpectation.paramPtrs.ctx = &ctx
	mmListFilePathsWithPrefix.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListFilePathsWithPrefix
}

// ExpectBucketParam2 sets up expected param bucket for Repository.ListFilePathsWithPrefix
func (mmListFilePathsWithPrefix *mRepositoryMockListFilePathsWithPrefix) ExpectBucketParam2(bucket string) *mRepositoryMockListFilePathsWithPrefix {
	if mmListFilePathsWithPrefix.mock.funcListFilePathsWithPrefix != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("RepositoryMock.ListFilePathsWithPrefix mock is already set by Set")
	}

	if mmListFilePathsWithPrefix.defaultExpectation == nil {
		mmListFilePathsWithPrefix.defaultExpectation = &RepositoryMockListFilePathsWithPrefixExpectation{}
	}

	if mmListFilePathsWithPrefix.defaultExpectation.params != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("RepositoryMock.ListFilePathsWithPrefix mock is already set by Expect")
	}

	if mmListFilePathsWithPrefix.defaultExpectation.paramPtrs == nil {
		mmListFilePathsWithPrefix.defaultExpectation.paramPtrs = &RepositoryMockListFilePathsWithPrefixParamPtrs{}
	}
	mmListFilePathsWithPrefix.defaultExpectation.paramPtrs.bucket = &bucket
	mmListFilePathsWithPrefix.defaultExpectation.expectationOrigins.originBucket = minimock.CallerInfo(1)

	return mmListFilePathsWithPrefix
}

// ExpectPrefixParam3 sets up expected param prefix for Repository.ListFilePathsWithPrefix
func (mmListFilePathsWithPrefix *mRepositoryMockListFilePathsWithPrefix) ExpectPrefixParam3(prefix string) *mRepositoryMockListFilePathsWithPrefix {
	if mmListFilePathsWithPrefix.mock.funcListFilePathsWithPrefix != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("RepositoryMock.ListFilePathsWithPrefix mock is already set by Set")
	}

	if mmListFilePathsWithPrefix.defaultExpectation == nil {
		mmListFilePathsWithPrefix.defaultExpectation = &RepositoryMockListFilePathsWithPrefixExpectation{}
	}

	if mmListFilePathsWithPrefix.defaultExpectation.params != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("RepositoryMock.ListFilePathsWithPrefix mock is already set by Expect")
	}

	if mmListFilePathsWithPrefix.defaultExpectation.paramPtrs == nil {
		mmListFilePathsWithPrefix.defaultExpectation.paramPtrs = &RepositoryMockListFilePathsWithPrefixParamPtrs{}
	}
	mmListFilePathsWithPrefix.defaultExpectation.paramPtrs.prefix = &prefix
	mmListFilePathsWithPrefix.defaultExpectation.expectationOrigins.originPrefix = minimock.CallerInfo(1)

	return mmListFilePathsWithPrefix
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListFilePathsWithPrefix
func (mmListFilePathsWithPrefix *mRepositoryMockListFilePathsWithPrefix) Inspect(f func(ctx context.Context, bucket string, prefix string)) *mRepositoryMockListFilePathsWithPrefix {
	if mmListFilePathsWithPrefix.mock.inspectFuncListFilePathsWithPrefix != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListFilePathsWithPrefix")
	}

	mmListFilePathsWithPrefix.mock.inspectFuncListFilePathsWithPrefix = f

	return mmListFilePathsWithPrefix
}

// Return sets up results that will be returned by Repository.ListFilePathsWithPrefix
func (mmListFilePathsWithPrefix *mRepositoryMockListFilePathsWithPrefix) Return(sa1 []string, err error) *RepositoryMock {
	if mmListFilePathsWithPrefix.mock.funcListFilePathsWithPrefix != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("RepositoryMock.ListFilePathsWithPrefix mock is already set by Set")
	}

	if mmListFilePathsWithPrefix.defaultExpectation == nil {
		mmListFilePathsWithPrefix.defaultExpectation = &RepositoryMockListFilePathsWithPrefixExpectation{mock: mmListFilePathsWithPrefix.mock}
	}
	mmListFilePathsWithPrefix.defaultExpectation.results = &RepositoryMockListFilePathsWithPrefixResults{sa1, err}
	mmListFilePathsWithPrefix.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListFilePathsWithPrefix.mock
}

// Set uses given function f to mock the Repository.ListFilePathsWithPrefix method
func (mmListFilePathsWithPrefix *mRepositoryMockListFilePathsWithPrefix) Set(f func(ctx context.Context, bucket string, prefix string) (sa1 []string, err error)) *RepositoryMock {
	if mmListFilePathsWithPrefix.defaultExpectation != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("Default expectation is already set for the Repository.ListFilePathsWithPrefix method")
	}

	if len(mmListFilePathsWithPrefix.expectations) > 0 {
		mmListFilePathsWithPrefix.mock.t.Fatalf("Some expectations are already set for the Repository.ListFilePathsWithPrefix method")
	}

	mmListFilePathsWithPrefix.mock.funcListFilePathsWithPrefix = f
	mmListFilePathsWithPrefix.mock.funcListFilePathsWithPrefixOrigin = minimock.CallerInfo(1)
	return mmListFilePathsWithPrefix.mock
}

// When sets expectation for the Repository.ListFilePathsWithPrefix which will trigger the result defined by the following
// Then helper
func (mmListFilePathsWithPrefix *mRepositoryMockListFilePathsWithPrefix) When(ctx context.Context, bucket string, prefix string) *RepositoryMockListFilePathsWithPrefixExpectation {
	if mmListFilePathsWithPrefix.mock.funcListFilePathsWithPrefix != nil {
		mmListFilePathsWithPrefix.mock.t.Fatalf("RepositoryMock.ListFilePathsWithPrefix mock is already set by Set")
	}

	expectation := &RepositoryMockListFilePathsWithPrefixExpectation{
		mock:               mmListFilePathsWithPrefix.mock,
		params:             &RepositoryMockListFilePathsWithPrefixParams{ctx, bucket, prefix},
		expectationOrigins: RepositoryMockListFilePathsWithPrefixExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListFilePathsWithPrefix.expectations = append(mmListFilePathsWithPrefix.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListFilePathsWithPrefix return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListFilePathsWithPrefixExpectation) Then(sa1 []string, err error) *RepositoryMock {
	e.results = &RepositoryMockListFilePathsWithPrefixResults{sa1, err}
	return e.mock
}

// Times sets number of times Repository.ListFilePathsWithPrefix should be invoked
func (mmListFilePathsWithPrefix *mRepositoryMockListFilePathsWithPrefix) Times(n uint64) *mRepositoryMockListFilePathsWithPrefix {
	if n == 0 {
		mmListFilePathsWithPrefix.mock.t.Fatalf("Times of RepositoryMock.ListFilePathsWithPrefix mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListFilePathsWithPrefix.expectedInvocations, n)
	mmListFilePathsWithPrefix.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListFilePathsWithPrefix
}

func (mmListFilePathsWithPrefix *mRepositoryMockListFilePathsWithPrefix) invocationsDone() bool {
	if len(mmListFilePathsWithPrefix.expectations) == 0 && mmListFilePathsWithPrefix.defaultExpectation == nil && mmListFilePathsWithPrefix.mock.funcListFilePathsWithPrefix == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListFilePathsWithPrefix.mock.afterListFilePathsWithPrefixCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListFilePathsWithPrefix.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListFilePathsWithPrefix implements mm_repository.Repository
func (mmListFilePathsWithPrefix *RepositoryMock) ListFilePathsWithPrefix(ctx context.Context, bucket string, prefix string) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmListFilePathsWithPrefix.beforeListFilePathsWithPrefixCounter, 1)
	defer mm_atomic.AddUint64(&mmListFilePathsWithPrefix.afterListFilePathsWithPrefixCounter, 1)

	mmListFilePathsWithPrefix.t.Helper()

	if mmListFilePathsWithPrefix.inspectFuncListFilePathsWithPrefix != nil {
		mmListFilePathsWithPrefix.inspectFuncListFilePathsWithPrefix(ctx, bucket, prefix)
	}

	mm_params := RepositoryMockListFilePathsWithPrefixParams{ctx, bucket, prefix}

	// Record call args
	mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.mutex.Lock()
	mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.callArgs = append(mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.callArgs, &mm_params)
	mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.mutex.Unlock()

	for _, e := range mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.defaultExpectation.Counter, 1)
		mm_want := mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.defaultExpectation.params
		mm_want_ptrs := mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListFilePathsWithPrefixParams{ctx, bucket, prefix}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListFilePathsWithPrefix.t.Errorf("RepositoryMock.ListFilePathsWithPrefix got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.bucket != nil && !minimock.Equal(*mm_want_ptrs.bucket, mm_got.bucket) {
				mmListFilePathsWithPrefix.t.Errorf("RepositoryMock.ListFilePathsWithPrefix got unexpected parameter bucket, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.defaultExpectation.expectationOrigins.originBucket, *mm_want_ptrs.bucket, mm_got.bucket, minimock.Diff(*mm_want_ptrs.bucket, mm_got.bucket))
			}

			if mm_want_ptrs.prefix != nil && !minimock.Equal(*mm_want_ptrs.prefix, mm_got.prefix) {
				mmListFilePathsWithPrefix.t.Errorf("RepositoryMock.ListFilePathsWithPrefix got unexpected parameter prefix, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.defaultExpectation.expectationOrigins.originPrefix, *mm_want_ptrs.prefix, mm_got.prefix, minimock.Diff(*mm_want_ptrs.prefix, mm_got.prefix))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListFilePathsWithPrefix.t.Errorf("RepositoryMock.ListFilePathsWithPrefix got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListFilePathsWithPrefix.ListFilePathsWithPrefixMock.defaultExpectation.results
		if mm_results == nil {
			mmListFilePathsWithPrefix.t.Fatal("No results are set for the RepositoryMock.ListFilePathsWithPrefix")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmListFilePathsWithPrefix.funcListFilePathsWithPrefix != nil {
		return mmListFilePathsWithPrefix.funcListFilePathsWithPrefix(ctx, bucket, prefix)
	}
	mmListFilePathsWithPrefix.t.Fatalf("Unexpected call to RepositoryMock.ListFilePathsWithPrefix. %v %v %v", ctx, bucket, prefix)
	return
}

// ListFilePathsWithPrefixAfterCounter returns a count of finished RepositoryMock.ListFilePathsWithPrefix invocations
func (mmListFilePathsWithPrefix *RepositoryMock) ListFilePathsWithPrefixAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListFilePathsWithPrefix.afterListFilePathsWithPrefixCounter)
}

// ListFilePathsWithPrefixBeforeCounter returns a count of RepositoryMock.ListFilePathsWithPrefix invocations
func (mmListFilePathsWithPrefix *RepositoryMock) ListFilePathsWithPrefixBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListFilePathsWithPrefix.beforeListFilePathsWithPrefixCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListFilePathsWithPrefix.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListFilePathsWithPrefix *mRepositoryMockListFilePathsWithPrefix) Calls() []*RepositoryMockListFilePathsWithPrefixParams {
	mmListFilePathsWithPrefix.mutex.RLock()

	argCopy := make([]*RepositoryMockListFilePathsWithPrefixParams, len(mmListFilePathsWithPrefix.callArgs))
	copy(argCopy, mmListFilePathsWithPrefix.callArgs)

	mmListFilePathsWithPrefix.mutex.RUnlock()

	return argCopy
}

// MinimockListFilePathsWithPrefixDone returns true if the count of the ListFilePathsWithPrefix invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListFilePathsWithPrefixDone() bool {
	if m.ListFilePathsWithPrefixMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListFilePathsWithPrefixMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListFilePathsWithPrefixMock.invocationsDone()
}

// MinimockListFilePathsWithPrefixInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListFilePathsWithPrefixInspect() {
	for _, e := range m.ListFilePathsWithPrefixMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListFilePathsWithPrefix at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListFilePathsWithPrefixCounter := mm_atomic.LoadUint64(&m.afterListFilePathsWithPrefixCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListFilePathsWithPrefixMock.defaultExpectation != nil && afterListFilePathsWithPrefixCounter < 1 {
		if m.ListFilePathsWithPrefixMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListFilePathsWithPrefix at\n%s", m.ListFilePathsWithPrefixMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListFilePathsWithPrefix at\n%s with params: %#v", m.ListFilePathsWithPrefixMock.defaultExpectation.expectationOrigins.origin, *m.ListFilePathsWithPrefixMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListFilePathsWithPrefix != nil && afterListFilePathsWithPrefixCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListFilePathsWithPrefix at\n%s", m.funcListFilePathsWithPrefixOrigin)
	}

	if !m.ListFilePathsWithPrefixMock.invocationsDone() && afterListFilePathsWithPrefixCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListFilePathsWithPrefix at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListFilePathsWithPrefixMock.expectedInvocations), m.ListFilePathsWithPrefixMock.expectedInvocationsOrigin, afterListFilePathsWithPrefixCounter)
	}
}

type mRepositoryMockListKnowledgeBaseFilePaths struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListKnowledgeBaseFilePathsExpectation
	expectations       []*RepositoryMockListKnowledgeBaseFilePathsExpectation

	callArgs []*RepositoryMockListKnowledgeBaseFilePathsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListKnowledgeBaseFilePathsExpectation specifies expectation struct of the Repository.ListKnowledgeBaseFilePaths
type RepositoryMockListKnowledgeBaseFilePathsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListKnowledgeBaseFilePathsParams
	paramPtrs          *RepositoryMockListKnowledgeBaseFilePathsParamPtrs
	expectationOrigins RepositoryMockListKnowledgeBaseFilePathsExpectationOrigins
	results            *RepositoryMockListKnowledgeBaseFilePathsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListKnowledgeBaseFilePathsParams contains parameters of the Repository.ListKnowledgeBaseFilePaths
type RepositoryMockListKnowledgeBaseFilePathsParams struct {
	ctx   context.Context
	kbUID types.KBUIDType
}

// RepositoryMockListKnowledgeBaseFilePathsParamPtrs contains pointers to parameters of the Repository.ListKnowledgeBaseFilePaths
type RepositoryMockListKnowledgeBaseFilePathsParamPtrs struct {
	ctx   *context.Context
	kbUID *types.KBUIDType
}

// RepositoryMockListKnowledgeBaseFilePathsResults contains results of the Repository.ListKnowledgeBaseFilePaths
type RepositoryMockListKnowledgeBaseFilePathsResults struct {
	sa1 []string
	err error
}

// RepositoryMockListKnowledgeBaseFilePathsOrigins contains origins of expectations of the Repository.ListKnowledgeBaseFilePaths
type RepositoryMockListKnowledgeBaseFilePathsExpectationOrigins struct {
	origin      string
	originCtx   string
	originKbUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListKnowledgeBaseFilePaths *mRepositoryMockListKnowledgeBaseFilePaths) Optional() *mRepositoryMockListKnowledgeBaseFilePaths {
	mmListKnowledgeBaseFilePaths.optional = true
	return mmListKnowledgeBaseFilePaths
}

// Expect sets up expected params for Repository.ListKnowledgeBaseFilePaths
func (mmListKnowledgeBaseFilePaths *mRepositoryMockListKnowledgeBaseFilePaths) Expect(ctx context.Context, kbUID types.KBUIDType) *mRepositoryMockListKnowledgeBaseFilePaths {
	if mmListKnowledgeBaseFilePaths.mock.funcListKnowledgeBaseFilePaths != nil {
		mmListKnowledgeBaseFilePaths.mock.t.Fatalf("RepositoryMock.ListKnowledgeBaseFilePaths mock is already set by Set")
	}

	if mmListKnowledgeBaseFilePaths.defaultExpectation == nil {
		mmListKnowledgeBaseFilePaths.defaultExpectation = &RepositoryMockListKnowledgeBaseFilePathsExpectation{}
	}

	if mmListKnowledgeBaseFilePaths.defaultExpectation.paramPtrs != nil {
		mmListKnowledgeBaseFilePaths.mock.t.Fatalf("RepositoryMock.ListKnowledgeBaseFilePaths mock is already set by ExpectParams functions")
	}

	mmListKnowledgeBaseFilePaths.defaultExpectation.params = &RepositoryMockListKnowledgeBaseFilePathsParams{ctx, kbUID}
	mmListKnowledgeBaseFilePaths.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListKnowledgeBaseFilePaths.expectations {
		if minimock.Equal(e.params, mmListKnowledgeBaseFilePaths.defaultExpectation.params) {
			mmListKnowledgeBaseFilePaths.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListKnowledgeBaseFilePaths.defaultExpectation.params)
		}
	}

	return mmListKnowledgeBaseFilePaths
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListKnowledgeBaseFilePaths
func (mmListKnowledgeBaseFilePaths *mRepositoryMockListKnowledgeBaseFilePaths) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListKnowledgeBaseFilePaths {
	if mmListKnowledgeBaseFilePaths.mock.funcListKnowledgeBaseFilePaths != nil {
		mmListKnowledgeBaseFilePaths.mock.t.Fatalf("RepositoryMock.ListKnowledgeBaseFilePaths mock is already set by Set")
	}

	if mmListKnowledgeBaseFilePaths.defaultExpectation == nil {
		mmListKnowledgeBaseFilePaths.defaultExpectation = &RepositoryMockListKnowledgeBaseFilePathsExpectation{}
	}

	if mmListKnowledgeBaseFilePaths.defaultExpectation.params != nil {
		mmListKnowledgeBaseFilePaths.mock.t.Fatalf("RepositoryMock.ListKnowledgeBaseFilePaths mock is already set by Expect")
	}

	if mmListKnowledgeBaseFilePaths.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFilePaths.defaultExpectation.paramPtrs = &RepositoryMockListKnowledgeBaseFilePathsParamPtrs{}
	}
	mmListKnowledgeBaseFilePaths.defaultExpectation.paramPtrs.ctx = &ctx
	mmListKnowledgeBaseFilePaths.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListKnowledgeBaseFilePaths
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.ListKnowledgeBaseFilePaths
func (mmListKnowledgeBaseFilePaths *mRepositoryMockListKnowledgeBaseFilePaths) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockListKnowledgeBaseFilePaths {
	if mmListKnowledgeBaseFilePaths.mock.funcListKnowledgeBaseFilePaths != nil {
		mmListKnowledgeBaseFilePaths.mock.t.Fatalf("RepositoryMock.ListKnowledgeBaseFilePaths mock is already set by Set")
	}

	if mmListKnowledgeBaseFilePaths.defaultExpectation == nil {
		mmListKnowledgeBaseFilePaths.defaultExpectation = &RepositoryMockListKnowledgeBaseFilePathsExpectation{}
	}

	if mmListKnowledgeBaseFilePaths.defaultExpectation.params != nil {
		mmListKnowledgeBaseFilePaths.mock.t.Fatalf("RepositoryMock.ListKnowledgeBaseFilePaths mock is already set by Expect")
	}

	if mmListKnowledgeBaseFilePaths.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFilePaths.defaultExpectation.paramPtrs = &RepositoryMockListKnowledgeBaseFilePathsParamPtrs{}
	}
	mmListKnowledgeBaseFilePaths.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmListKnowledgeBaseFilePaths.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmListKnowledgeBaseFilePaths
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListKnowledgeBaseFilePaths
func (mmListKnowledgeBaseFilePaths *mRepositoryMockListKnowledgeBaseFilePaths) Inspect(f func(ctx context.Context, kbUID types.KBUIDType)) *mRepositoryMockListKnowledgeBaseFilePaths {
	if mmListKnowledgeBaseFilePaths.mock.inspectFuncListKnowledgeBaseFilePaths != nil {
		mmListKnowledgeBaseFilePaths.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListKnowledgeBaseFilePaths")
	}

	mmListKnowledgeBaseFilePaths.mock.inspectFuncListKnowledgeBaseFilePaths = f

	return mmListKnowledgeBaseFilePaths
}

// Return sets up results that will be returned by Repository.ListKnowledgeBaseFilePaths
func (mmListKnowledgeBaseFilePaths *mRepositoryMockListKnowledgeBaseFilePaths) Return(sa1 []string, err error) *RepositoryMock {
	if mmListKnowledgeBaseFilePaths.mock.funcListKnowledgeBaseFilePaths != nil {
		mmListKnowledgeBaseFilePaths.mock.t.Fatalf("RepositoryMock.ListKnowledgeBaseFilePaths mock is already set by Set")
	}

	if mmListKnowledgeBaseFilePaths.defaultExpectation == nil {
		mmListKnowledgeBaseFilePaths.defaultExpectation = &RepositoryMockListKnowledgeBaseFilePathsExpectation{mock: mmListKnowledgeBaseFilePaths.mock}
	}
	mmListKnowledgeBaseFilePaths.defaultExpectation.results = &RepositoryMockListKnowledgeBaseFilePathsResults{sa1, err}
	mmListKnowledgeBaseFilePaths.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBaseFilePaths.mock
}

// Set uses given function f to mock the Repository.ListKnowledgeBaseFilePaths method
func (mmListKnowledgeBaseFilePaths *mRepositoryMockListKnowledgeBaseFilePaths) Set(f func(ctx context.Context, kbUID types.KBUIDType) (sa1 []string, err error)) *RepositoryMock {
	if mmListKnowledgeBaseFilePaths.defaultExpectation != nil {
		mmListKnowledgeBaseFilePaths.mock.t.Fatalf("Default expectation is already set for the Repository.ListKnowledgeBaseFilePaths method")
	}

	if len(mmListKnowledgeBaseFilePaths.expectations) > 0 {
		mmListKnowledgeBaseFilePaths.mock.t.Fatalf("Some expectations are already set for the Repository.ListKnowledgeBaseFilePaths method")
	}

	mmListKnowledgeBaseFilePaths.mock.funcListKnowledgeBaseFilePaths = f
	mmListKnowledgeBaseFilePaths.mock.funcListKnowledgeBaseFilePathsOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBaseFilePaths.mock
}

// When sets expectation for the Repository.ListKnowledgeBaseFilePaths which will trigger the result defined by the following
// Then helper
func (mmListKnowledgeBaseFilePaths *mRepositoryMockListKnowledgeBaseFilePaths) When(ctx context.Context, kbUID types.KBUIDType) *RepositoryMockListKnowledgeBaseFilePathsExpectation {
	if mmListKnowledgeBaseFilePaths.mock.funcListKnowledgeBaseFilePaths != nil {
		mmListKnowledgeBaseFilePaths.mock.t.Fatalf("RepositoryMock.ListKnowledgeBaseFilePaths mock is already set by Set")
	}

	expectation := &RepositoryMockListKnowledgeBaseFilePathsExpectation{
		mock:               mmListKnowledgeBaseFilePaths.mock,
		params:             &RepositoryMockListKnowledgeBaseFilePathsParams{ctx, kbUID},
		expectationOrigins: RepositoryMockListKnowledgeBaseFilePathsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListKnowledgeBaseFilePaths.expectations = append(mmListKnowledgeBaseFilePaths.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListKnowledgeBaseFilePaths return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListKnowledgeBaseFilePathsExpectation) Then(sa1 []string, err error) *RepositoryMock {
	e.results = &RepositoryMockListKnowledgeBaseFilePathsResults{sa1, err}
	return e.mock
}

// Times sets number of times Repository.ListKnowledgeBaseFilePaths should be invoked
func (mmListKnowledgeBaseFilePaths *mRepositoryMockListKnowledgeBaseFilePaths) Times(n uint64) *mRepositoryMockListKnowledgeBaseFilePaths {
	if n == 0 {
		mmListKnowledgeBaseFilePaths.mock.t.Fatalf("Times of RepositoryMock.ListKnowledgeBaseFilePaths mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListKnowledgeBaseFilePaths.expectedInvocations, n)
	mmListKnowledgeBaseFilePaths.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBaseFilePaths
}

func (mmListKnowledgeBaseFilePaths *mRepositoryMockListKnowledgeBaseFilePaths) invocationsDone() bool {
	if len(mmListKnowledgeBaseFilePaths.expectations) == 0 && mmListKnowledgeBaseFilePaths.defaultExpectation == nil && mmListKnowledgeBaseFilePaths.mock.funcListKnowledgeBaseFilePaths == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBaseFilePaths.mock.afterListKnowledgeBaseFilePathsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBaseFilePaths.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListKnowledgeBaseFilePaths implements mm_repository.Repository
func (mmListKnowledgeBaseFilePaths *RepositoryMock) ListKnowledgeBaseFilePaths(ctx context.Context, kbUID types.KBUIDType) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmListKnowledgeBaseFilePaths.beforeListKnowledgeBaseFilePathsCounter, 1)
	defer mm_atomic.AddUint64(&mmListKnowledgeBaseFilePaths.afterListKnowledgeBaseFilePathsCounter, 1)

	mmListKnowledgeBaseFilePaths.t.Helper()

	if mmListKnowledgeBaseFilePaths.inspectFuncListKnowledgeBaseFilePaths != nil {
		mmListKnowledgeBaseFilePaths.inspectFuncListKnowledgeBaseFilePaths(ctx, kbUID)
	}

	mm_params := RepositoryMockListKnowledgeBaseFilePathsParams{ctx, kbUID}

	// Record call args
	mmListKnowledgeBaseFilePaths.ListKnowledgeBaseFilePathsMock.mutex.Lock()
	mmListKnowledgeBaseFilePaths.ListKnowledgeBaseFilePathsMock.callArgs = append(mmListKnowledgeBaseFilePaths.ListKnowledgeBaseFilePathsMock.callArgs, &mm_params)
	mmListKnowledgeBaseFilePaths.ListKnowledgeBaseFilePathsMock.mutex.Unlock()

	for _, e := range mmListKnowledgeBaseFilePaths.ListKnowledgeBaseFilePathsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmListKnowledgeBaseFilePaths.ListKnowledgeBaseFilePathsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListKnowledgeBaseFilePaths.ListKnowledgeBaseFilePathsMock.defaultExpectation.Counter, 1)
		mm_want := mmListKnowledgeBaseFilePaths.ListKnowledgeBaseFilePathsMock.defaultExpectation.params
		mm_want_ptrs := mmListKnowledgeBaseFilePaths.ListKnowledgeBaseFilePathsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListKnowledgeBaseFilePathsParams{ctx, kbUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListKnowledgeBaseFilePaths.t.Errorf("RepositoryMock.ListKnowledgeBaseFilePaths got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBaseFilePaths.ListKnowledgeBaseFilePathsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmListKnowledgeBaseFilePaths.t.Errorf("RepositoryMock.ListKnowledgeBaseFilePaths got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBaseFilePaths.ListKnowledgeBaseFilePathsMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListKnowledgeBaseFilePaths.t.Errorf("RepositoryMock.ListKnowledgeBaseFilePaths got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListKnowledgeBaseFilePaths.ListKnowledgeBaseFilePathsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListKnowledgeBaseFilePaths.ListKnowledgeBaseFilePathsMock.defaultExpectation.results
		if mm_results == nil {
			mmListKnowledgeBaseFilePaths.t.Fatal("No results are set for the RepositoryMock.ListKnowledgeBaseFilePaths")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmListKnowledgeBaseFilePaths.funcListKnowledgeBaseFilePaths != nil {
		return mmListKnowledgeBaseFilePaths.funcListKnowledgeBaseFilePaths(ctx, kbUID)
	}
	mmListKnowledgeBaseFilePaths.t.Fatalf("Unexpected call to RepositoryMock.ListKnowledgeBaseFilePaths. %v %v", ctx, kbUID)
	return
}

// ListKnowledgeBaseFilePathsAfterCounter returns a count of finished RepositoryMock.ListKnowledgeBaseFilePaths invocations
func (mmListKnowledgeBaseFilePaths *RepositoryMock) ListKnowledgeBaseFilePathsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBaseFilePaths.afterListKnowledgeBaseFilePathsCounter)
}

// ListKnowledgeBaseFilePathsBeforeCounter returns a count of RepositoryMock.ListKnowledgeBaseFilePaths invocations
func (mmListKnowledgeBaseFilePaths *RepositoryMock) ListKnowledgeBaseFilePathsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBaseFilePaths.beforeListKnowledgeBaseFilePathsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListKnowledgeBaseFilePaths.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListKnowledgeBaseFilePaths *mRepositoryMockListKnowledgeBaseFilePaths) Calls() []*RepositoryMockListKnowledgeBaseFilePathsParams {
	mmListKnowledgeBaseFilePaths.mutex.RLock()

	argCopy := make([]*RepositoryMockListKnowledgeBaseFilePathsParams, len(mmListKnowledgeBaseFilePaths.callArgs))
	copy(argCopy, mmListKnowledgeBaseFilePaths.callArgs)

	mmListKnowledgeBaseFilePaths.mutex.RUnlock()

	return argCopy
}

// MinimockListKnowledgeBaseFilePathsDone returns true if the count of the ListKnowledgeBaseFilePaths invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListKnowledgeBaseFilePathsDone() bool {
	if m.ListKnowledgeBaseFilePathsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListKnowledgeBaseFilePathsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListKnowledgeBaseFilePathsMock.invocationsDone()
}

// MinimockListKnowledgeBaseFilePathsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListKnowledgeBaseFilePathsInspect() {
	for _, e := range m.ListKnowledgeBaseFilePathsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBaseFilePaths at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListKnowledgeBaseFilePathsCounter := mm_atomic.LoadUint64(&m.afterListKnowledgeBaseFilePathsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListKnowledgeBaseFilePathsMock.defaultExpectation != nil && afterListKnowledgeBaseFilePathsCounter < 1 {
		if m.ListKnowledgeBaseFilePathsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBaseFilePaths at\n%s", m.ListKnowledgeBaseFilePathsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBaseFilePaths at\n%s with params: %#v", m.ListKnowledgeBaseFilePathsMock.defaultExpectation.expectationOrigins.origin, *m.ListKnowledgeBaseFilePathsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListKnowledgeBaseFilePaths != nil && afterListKnowledgeBaseFilePathsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBaseFilePaths at\n%s", m.funcListKnowledgeBaseFilePathsOrigin)
	}

	if !m.ListKnowledgeBaseFilePathsMock.invocationsDone() && afterListKnowledgeBaseFilePathsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListKnowledgeBaseFilePaths at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListKnowledgeBaseFilePathsMock.expectedInvocations), m.ListKnowledgeBaseFilePathsMock.expectedInvocationsOrigin, afterListKnowledgeBaseFilePathsCounter)
	}
}

type mRepositoryMockListKnowledgeBaseFiles struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListKnowledgeBaseFilesExpectation
	expectations       []*RepositoryMockListKnowledgeBaseFilesExpectation

	callArgs []*RepositoryMockListKnowledgeBaseFilesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListKnowledgeBaseFilesExpectation specifies expectation struct of the Repository.ListKnowledgeBaseFiles
type RepositoryMockListKnowledgeBaseFilesExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListKnowledgeBaseFilesParams
	paramPtrs          *RepositoryMockListKnowledgeBaseFilesParamPtrs
	expectationOrigins RepositoryMockListKnowledgeBaseFilesExpectationOrigins
	results            *RepositoryMockListKnowledgeBaseFilesResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListKnowledgeBaseFilesParams contains parameters of the Repository.ListKnowledgeBaseFiles
type RepositoryMockListKnowledgeBaseFilesParams struct {
	ctx context.Context
	k1  mm_repository.KnowledgeBaseFileListParams
}

// RepositoryMockListKnowledgeBaseFilesParamPtrs contains pointers to parameters of the Repository.ListKnowledgeBaseFiles
type RepositoryMockListKnowledgeBaseFilesParamPtrs struct {
	ctx *context.Context
	k1  *mm_repository.KnowledgeBaseFileListParams
}

// RepositoryMockListKnowledgeBaseFilesResults contains results of the Repository.ListKnowledgeBaseFiles
type RepositoryMockListKnowledgeBaseFilesResults struct {
	kp1 *mm_repository.KnowledgeBaseFileList
	err error
}

// RepositoryMockListKnowledgeBaseFilesOrigins contains origins of expectations of the Repository.ListKnowledgeBaseFiles
type RepositoryMockListKnowledgeBaseFilesExpectationOrigins struct {
	origin    string
	originCtx string
	originK1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListKnowledgeBaseFiles *mRepositoryMockListKnowledgeBaseFiles) Optional() *mRepositoryMockListKnowledgeBaseFiles {
	mmListKnowledgeBaseFiles.optional = true
	return mmListKnowledgeBaseFiles
}

// Expect sets up expected params for Repository.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryMockListKnowledgeBaseFiles) Expect(ctx context.Context, k1 mm_repository.KnowledgeBaseFileListParams) *mRepositoryMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ListKnowledgeBaseFiles mock is already set by ExpectParams functions")
	}

	mmListKnowledgeBaseFiles.defaultExpectation.params = &RepositoryMockListKnowledgeBaseFilesParams{ctx, k1}
	mmListKnowledgeBaseFiles.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListKnowledgeBaseFiles.expectations {
		if minimock.Equal(e.params, mmListKnowledgeBaseFiles.defaultExpectation.params) {
			mmListKnowledgeBaseFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListKnowledgeBaseFiles.defaultExpectation.params)
		}
	}

	return mmListKnowledgeBaseFiles
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryMockListKnowledgeBaseFiles) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ListKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryMockListKnowledgeBaseFilesParamPtrs{}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs.ctx = &ctx
	mmListKnowledgeBaseFiles.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListKnowledgeBaseFiles
}

// ExpectK1Param2 sets up expected param k1 for Repository.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryMockListKnowledgeBaseFiles) ExpectK1Param2(k1 mm_repository.KnowledgeBaseFileListParams) *mRepositoryMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryMockListKnowledgeBaseFilesExpectation{}
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ListKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryMockListKnowledgeBaseFilesParamPtrs{}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.paramPtrs.k1 = &k1
	mmListKnowledgeBaseFiles.defaultExpectation.expectationOrigins.originK1 = minimock.CallerInfo(1)

	return mmListKnowledgeBaseFiles
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryMockListKnowledgeBaseFiles) Inspect(f func(ctx context.Context, k1 mm_repository.KnowledgeBaseFileListParams)) *mRepositoryMockListKnowledgeBaseFiles {
	if mmListKnowledgeBaseFiles.mock.inspectFuncListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListKnowledgeBaseFiles")
	}

	mmListKnowledgeBaseFiles.mock.inspectFuncListKnowledgeBaseFiles = f

	return mmListKnowledgeBaseFiles
}

// Return sets up results that will be returned by Repository.ListKnowledgeBaseFiles
func (mmListKnowledgeBaseFiles *mRepositoryMockListKnowledgeBaseFiles) Return(kp1 *mm_repository.KnowledgeBaseFileList, err error) *RepositoryMock {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	if mmListKnowledgeBaseFiles.defaultExpectation == nil {
		mmListKnowledgeBaseFiles.defaultExpectation = &RepositoryMockListKnowledgeBaseFilesExpectation{mock: mmListKnowledgeBaseFiles.mock}
	}
	mmListKnowledgeBaseFiles.defaultExpectation.results = &RepositoryMockListKnowledgeBaseFilesResults{kp1, err}
	mmListKnowledgeBaseFiles.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBaseFiles.mock
}

// Set uses given function f to mock the Repository.ListKnowledgeBaseFiles method
func (mmListKnowledgeBaseFiles *mRepositoryMockListKnowledgeBaseFiles) Set(f func(ctx context.Context, k1 mm_repository.KnowledgeBaseFileListParams) (kp1 *mm_repository.KnowledgeBaseFileList, err error)) *RepositoryMock {
	if mmListKnowledgeBaseFiles.defaultExpectation != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("Default expectation is already set for the Repository.ListKnowledgeBaseFiles method")
	}

	if len(mmListKnowledgeBaseFiles.expectations) > 0 {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("Some expectations are already set for the Repository.ListKnowledgeBaseFiles method")
	}

	mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles = f
	mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFilesOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBaseFiles.mock
}

// When sets expectation for the Repository.ListKnowledgeBaseFiles which will trigger the result defined by the following
// Then helper
func (mmListKnowledgeBaseFiles *mRepositoryMockListKnowledgeBaseFiles) When(ctx context.Context, k1 mm_repository.KnowledgeBaseFileListParams) *RepositoryMockListKnowledgeBaseFilesExpectation {
	if mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ListKnowledgeBaseFiles mock is already set by Set")
	}

	expectation := &RepositoryMockListKnowledgeBaseFilesExpectation{
		mock:               mmListKnowledgeBaseFiles.mock,
		params:             &RepositoryMockListKnowledgeBaseFilesParams{ctx, k1},
		expectationOrigins: RepositoryMockListKnowledgeBaseFilesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListKnowledgeBaseFiles.expectations = append(mmListKnowledgeBaseFiles.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListKnowledgeBaseFiles return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListKnowledgeBaseFilesExpectation) Then(kp1 *mm_repository.KnowledgeBaseFileList, err error) *RepositoryMock {
	e.results = &RepositoryMockListKnowledgeBaseFilesResults{kp1, err}
	return e.mock
}

// Times sets number of times Repository.ListKnowledgeBaseFiles should be invoked
func (mmListKnowledgeBaseFiles *mRepositoryMockListKnowledgeBaseFiles) Times(n uint64) *mRepositoryMockListKnowledgeBaseFiles {
	if n == 0 {
		mmListKnowledgeBaseFiles.mock.t.Fatalf("Times of RepositoryMock.ListKnowledgeBaseFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListKnowledgeBaseFiles.expectedInvocations, n)
	mmListKnowledgeBaseFiles.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBaseFiles
}

func (mmListKnowledgeBaseFiles *mRepositoryMockListKnowledgeBaseFiles) invocationsDone() bool {
	if len(mmListKnowledgeBaseFiles.expectations) == 0 && mmListKnowledgeBaseFiles.defaultExpectation == nil && mmListKnowledgeBaseFiles.mock.funcListKnowledgeBaseFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBaseFiles.mock.afterListKnowledgeBaseFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBaseFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListKnowledgeBaseFiles implements mm_repository.Repository
func (mmListKnowledgeBaseFiles *RepositoryMock) ListKnowledgeBaseFiles(ctx context.Context, k1 mm_repository.KnowledgeBaseFileListParams) (kp1 *mm_repository.KnowledgeBaseFileList, err error) {
	mm_atomic.AddUint64(&mmListKnowledgeBaseFiles.beforeListKnowledgeBaseFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmListKnowledgeBaseFiles.afterListKnowledgeBaseFilesCounter, 1)

	mmListKnowledgeBaseFiles.t.Helper()

	if mmListKnowledgeBaseFiles.inspectFuncListKnowledgeBaseFiles != nil {
		mmListKnowledgeBaseFiles.inspectFuncListKnowledgeBaseFiles(ctx, k1)
	}

	mm_params := RepositoryMockListKnowledgeBaseFilesParams{ctx, k1}

	// Record call args
	mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.mutex.Lock()
	mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.callArgs = append(mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.callArgs, &mm_params)
	mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.mutex.Unlock()

	for _, e := range mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.params
		mm_want_ptrs := mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListKnowledgeBaseFilesParams{ctx, k1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListKnowledgeBaseFiles.t.Errorf("RepositoryMock.ListKnowledgeBaseFiles got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.k1 != nil && !minimock.Equal(*mm_want_ptrs.k1, mm_got.k1) {
				mmListKnowledgeBaseFiles.t.Errorf("RepositoryMock.ListKnowledgeBaseFiles got unexpected parameter k1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.originK1, *mm_want_ptrs.k1, mm_got.k1, minimock.Diff(*mm_want_ptrs.k1, mm_got.k1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListKnowledgeBaseFiles.t.Errorf("RepositoryMock.ListKnowledgeBaseFiles got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListKnowledgeBaseFiles.ListKnowledgeBaseFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmListKnowledgeBaseFiles.t.Fatal("No results are set for the RepositoryMock.ListKnowledgeBaseFiles")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmListKnowledgeBaseFiles.funcListKnowledgeBaseFiles != nil {
		return mmListKnowledgeBaseFiles.funcListKnowledgeBaseFiles(ctx, k1)
	}
	mmListKnowledgeBaseFiles.t.Fatalf("Unexpected call to RepositoryMock.ListKnowledgeBaseFiles. %v %v", ctx, k1)
	return
}

// ListKnowledgeBaseFilesAfterCounter returns a count of finished RepositoryMock.ListKnowledgeBaseFiles invocations
func (mmListKnowledgeBaseFiles *RepositoryMock) ListKnowledgeBaseFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBaseFiles.afterListKnowledgeBaseFilesCounter)
}

// ListKnowledgeBaseFilesBeforeCounter returns a count of RepositoryMock.ListKnowledgeBaseFiles invocations
func (mmListKnowledgeBaseFiles *RepositoryMock) ListKnowledgeBaseFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBaseFiles.beforeListKnowledgeBaseFilesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListKnowledgeBaseFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListKnowledgeBaseFiles *mRepositoryMockListKnowledgeBaseFiles) Calls() []*RepositoryMockListKnowledgeBaseFilesParams {
	mmListKnowledgeBaseFiles.mutex.RLock()

	argCopy := make([]*RepositoryMockListKnowledgeBaseFilesParams, len(mmListKnowledgeBaseFiles.callArgs))
	copy(argCopy, mmListKnowledgeBaseFiles.callArgs)

	mmListKnowledgeBaseFiles.mutex.RUnlock()

	return argCopy
}

// MinimockListKnowledgeBaseFilesDone returns true if the count of the ListKnowledgeBaseFiles invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListKnowledgeBaseFilesDone() bool {
	if m.ListKnowledgeBaseFilesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListKnowledgeBaseFilesMock.invocationsDone()
}

// MinimockListKnowledgeBaseFilesInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListKnowledgeBaseFilesInspect() {
	for _, e := range m.ListKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBaseFiles at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListKnowledgeBaseFilesCounter := mm_atomic.LoadUint64(&m.afterListKnowledgeBaseFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListKnowledgeBaseFilesMock.defaultExpectation != nil && afterListKnowledgeBaseFilesCounter < 1 {
		if m.ListKnowledgeBaseFilesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBaseFiles at\n%s", m.ListKnowledgeBaseFilesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBaseFiles at\n%s with params: %#v", m.ListKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.origin, *m.ListKnowledgeBaseFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListKnowledgeBaseFiles != nil && afterListKnowledgeBaseFilesCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBaseFiles at\n%s", m.funcListKnowledgeBaseFilesOrigin)
	}

	if !m.ListKnowledgeBaseFilesMock.invocationsDone() && afterListKnowledgeBaseFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListKnowledgeBaseFiles at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListKnowledgeBaseFilesMock.expectedInvocations), m.ListKnowledgeBaseFilesMock.expectedInvocationsOrigin, afterListKnowledgeBaseFilesCounter)
	}
}

type mRepositoryMockListKnowledgeBases struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListKnowledgeBasesExpectation
	expectations       []*RepositoryMockListKnowledgeBasesExpectation

	callArgs []*RepositoryMockListKnowledgeBasesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListKnowledgeBasesExpectation specifies expectation struct of the Repository.ListKnowledgeBases
type RepositoryMockListKnowledgeBasesExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListKnowledgeBasesParams
	paramPtrs          *RepositoryMockListKnowledgeBasesParamPtrs
	expectationOrigins RepositoryMockListKnowledgeBasesExpectationOrigins
	results            *RepositoryMockListKnowledgeBasesResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListKnowledgeBasesParams contains parameters of the Repository.ListKnowledgeBases
type RepositoryMockListKnowledgeBasesParams struct {
	ctx      context.Context
	ownerUID string
}

// RepositoryMockListKnowledgeBasesParamPtrs contains pointers to parameters of the Repository.ListKnowledgeBases
type RepositoryMockListKnowledgeBasesParamPtrs struct {
	ctx      *context.Context
	ownerUID *string
}

// RepositoryMockListKnowledgeBasesResults contains results of the Repository.ListKnowledgeBases
type RepositoryMockListKnowledgeBasesResults struct {
	ka1 []mm_repository.KnowledgeBaseModel
	err error
}

// RepositoryMockListKnowledgeBasesOrigins contains origins of expectations of the Repository.ListKnowledgeBases
type RepositoryMockListKnowledgeBasesExpectationOrigins struct {
	origin         string
	originCtx      string
	originOwnerUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListKnowledgeBases *mRepositoryMockListKnowledgeBases) Optional() *mRepositoryMockListKnowledgeBases {
	mmListKnowledgeBases.optional = true
	return mmListKnowledgeBases
}

// Expect sets up expected params for Repository.ListKnowledgeBases
func (mmListKnowledgeBases *mRepositoryMockListKnowledgeBases) Expect(ctx context.Context, ownerUID string) *mRepositoryMockListKnowledgeBases {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryMock.ListKnowledgeBases mock is already set by Set")
	}

	if mmListKnowledgeBases.defaultExpectation == nil {
		mmListKnowledgeBases.defaultExpectation = &RepositoryMockListKnowledgeBasesExpectation{}
	}

	if mmListKnowledgeBases.defaultExpectation.paramPtrs != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryMock.ListKnowledgeBases mock is already set by ExpectParams functions")
	}

	mmListKnowledgeBases.defaultExpectation.params = &RepositoryMockListKnowledgeBasesParams{ctx, ownerUID}
	mmListKnowledgeBases.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListKnowledgeBases.expectations {
		if minimock.Equal(e.params, mmListKnowledgeBases.defaultExpectation.params) {
			mmListKnowledgeBases.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListKnowledgeBases.defaultExpectation.params)
		}
	}

	return mmListKnowledgeBases
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListKnowledgeBases
func (mmListKnowledgeBases *mRepositoryMockListKnowledgeBases) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListKnowledgeBases {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryMock.ListKnowledgeBases mock is already set by Set")
	}

	if mmListKnowledgeBases.defaultExpectation == nil {
		mmListKnowledgeBases.defaultExpectation = &RepositoryMockListKnowledgeBasesExpectation{}
	}

	if mmListKnowledgeBases.defaultExpectation.params != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryMock.ListKnowledgeBases mock is already set by Expect")
	}

	if mmListKnowledgeBases.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBases.defaultExpectation.paramPtrs = &RepositoryMockListKnowledgeBasesParamPtrs{}
	}
	mmListKnowledgeBases.defaultExpectation.paramPtrs.ctx = &ctx
	mmListKnowledgeBases.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListKnowledgeBases
}

// ExpectOwnerUIDParam2 sets up expected param ownerUID for Repository.ListKnowledgeBases
func (mmListKnowledgeBases *mRepositoryMockListKnowledgeBases) ExpectOwnerUIDParam2(ownerUID string) *mRepositoryMockListKnowledgeBases {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryMock.ListKnowledgeBases mock is already set by Set")
	}

	if mmListKnowledgeBases.defaultExpectation == nil {
		mmListKnowledgeBases.defaultExpectation = &RepositoryMockListKnowledgeBasesExpectation{}
	}

	if mmListKnowledgeBases.defaultExpectation.params != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryMock.ListKnowledgeBases mock is already set by Expect")
	}

	if mmListKnowledgeBases.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBases.defaultExpectation.paramPtrs = &RepositoryMockListKnowledgeBasesParamPtrs{}
	}
	mmListKnowledgeBases.defaultExpectation.paramPtrs.ownerUID = &ownerUID
	mmListKnowledgeBases.defaultExpectation.expectationOrigins.originOwnerUID = minimock.CallerInfo(1)

	return mmListKnowledgeBases
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListKnowledgeBases
func (mmListKnowledgeBases *mRepositoryMockListKnowledgeBases) Inspect(f func(ctx context.Context, ownerUID string)) *mRepositoryMockListKnowledgeBases {
	if mmListKnowledgeBases.mock.inspectFuncListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListKnowledgeBases")
	}

	mmListKnowledgeBases.mock.inspectFuncListKnowledgeBases = f

	return mmListKnowledgeBases
}

// Return sets up results that will be returned by Repository.ListKnowledgeBases
func (mmListKnowledgeBases *mRepositoryMockListKnowledgeBases) Return(ka1 []mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryMock.ListKnowledgeBases mock is already set by Set")
	}

	if mmListKnowledgeBases.defaultExpectation == nil {
		mmListKnowledgeBases.defaultExpectation = &RepositoryMockListKnowledgeBasesExpectation{mock: mmListKnowledgeBases.mock}
	}
	mmListKnowledgeBases.defaultExpectation.results = &RepositoryMockListKnowledgeBasesResults{ka1, err}
	mmListKnowledgeBases.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBases.mock
}

// Set uses given function f to mock the Repository.ListKnowledgeBases method
func (mmListKnowledgeBases *mRepositoryMockListKnowledgeBases) Set(f func(ctx context.Context, ownerUID string) (ka1 []mm_repository.KnowledgeBaseModel, err error)) *RepositoryMock {
	if mmListKnowledgeBases.defaultExpectation != nil {
		mmListKnowledgeBases.mock.t.Fatalf("Default expectation is already set for the Repository.ListKnowledgeBases method")
	}

	if len(mmListKnowledgeBases.expectations) > 0 {
		mmListKnowledgeBases.mock.t.Fatalf("Some expectations are already set for the Repository.ListKnowledgeBases method")
	}

	mmListKnowledgeBases.mock.funcListKnowledgeBases = f
	mmListKnowledgeBases.mock.funcListKnowledgeBasesOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBases.mock
}

// When sets expectation for the Repository.ListKnowledgeBases which will trigger the result defined by the following
// Then helper
func (mmListKnowledgeBases *mRepositoryMockListKnowledgeBases) When(ctx context.Context, ownerUID string) *RepositoryMockListKnowledgeBasesExpectation {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("RepositoryMock.ListKnowledgeBases mock is already set by Set")
	}

	expectation := &RepositoryMockListKnowledgeBasesExpectation{
		mock:               mmListKnowledgeBases.mock,
		params:             &RepositoryMockListKnowledgeBasesParams{ctx, ownerUID},
		expectationOrigins: RepositoryMockListKnowledgeBasesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListKnowledgeBases.expectations = append(mmListKnowledgeBases.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListKnowledgeBases return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListKnowledgeBasesExpectation) Then(ka1 []mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	e.results = &RepositoryMockListKnowledgeBasesResults{ka1, err}
	return e.mock
}

// Times sets number of times Repository.ListKnowledgeBases should be invoked
func (mmListKnowledgeBases *mRepositoryMockListKnowledgeBases) Times(n uint64) *mRepositoryMockListKnowledgeBases {
	if n == 0 {
		mmListKnowledgeBases.mock.t.Fatalf("Times of RepositoryMock.ListKnowledgeBases mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListKnowledgeBases.expectedInvocations, n)
	mmListKnowledgeBases.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBases
}

func (mmListKnowledgeBases *mRepositoryMockListKnowledgeBases) invocationsDone() bool {
	if len(mmListKnowledgeBases.expectations) == 0 && mmListKnowledgeBases.defaultExpectation == nil && mmListKnowledgeBases.mock.funcListKnowledgeBases == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBases.mock.afterListKnowledgeBasesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBases.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListKnowledgeBases implements mm_repository.Repository
func (mmListKnowledgeBases *RepositoryMock) ListKnowledgeBases(ctx context.Context, ownerUID string) (ka1 []mm_repository.KnowledgeBaseModel, err error) {
	mm_atomic.AddUint64(&mmListKnowledgeBases.beforeListKnowledgeBasesCounter, 1)
	defer mm_atomic.AddUint64(&mmListKnowledgeBases.afterListKnowledgeBasesCounter, 1)

	mmListKnowledgeBases.t.Helper()

	if mmListKnowledgeBases.inspectFuncListKnowledgeBases != nil {
		mmListKnowledgeBases.inspectFuncListKnowledgeBases(ctx, ownerUID)
	}

	mm_params := RepositoryMockListKnowledgeBasesParams{ctx, ownerUID}

	// Record call args
	mmListKnowledgeBases.ListKnowledgeBasesMock.mutex.Lock()
	mmListKnowledgeBases.ListKnowledgeBasesMock.callArgs = append(mmListKnowledgeBases.ListKnowledgeBasesMock.callArgs, &mm_params)
	mmListKnowledgeBases.ListKnowledgeBasesMock.mutex.Unlock()

	for _, e := range mmListKnowledgeBases.ListKnowledgeBasesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.Counter, 1)
		mm_want := mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.params
		mm_want_ptrs := mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListKnowledgeBasesParams{ctx, ownerUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListKnowledgeBases.t.Errorf("RepositoryMock.ListKnowledgeBases got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmListKnowledgeBases.t.Errorf("RepositoryMock.ListKnowledgeBases got unexpected parameter ownerUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.expectationOrigins.originOwnerUID, *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListKnowledgeBases.t.Errorf("RepositoryMock.ListKnowledgeBases got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.results
		if mm_results == nil {
			mmListKnowledgeBases.t.Fatal("No results are set for the RepositoryMock.ListKnowledgeBases")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmListKnowledgeBases.funcListKnowledgeBases != nil {
		return mmListKnowledgeBases.funcListKnowledgeBases(ctx, ownerUID)
	}
	mmListKnowledgeBases.t.Fatalf("Unexpected call to RepositoryMock.ListKnowledgeBases. %v %v", ctx, ownerUID)
	return
}

// ListKnowledgeBasesAfterCounter returns a count of finished RepositoryMock.ListKnowledgeBases invocations
func (mmListKnowledgeBases *RepositoryMock) ListKnowledgeBasesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBases.afterListKnowledgeBasesCounter)
}

// ListKnowledgeBasesBeforeCounter returns a count of RepositoryMock.ListKnowledgeBases invocations
func (mmListKnowledgeBases *RepositoryMock) ListKnowledgeBasesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBases.beforeListKnowledgeBasesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListKnowledgeBases.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListKnowledgeBases *mRepositoryMockListKnowledgeBases) Calls() []*RepositoryMockListKnowledgeBasesParams {
	mmListKnowledgeBases.mutex.RLock()

	argCopy := make([]*RepositoryMockListKnowledgeBasesParams, len(mmListKnowledgeBases.callArgs))
	copy(argCopy, mmListKnowledgeBases.callArgs)

	mmListKnowledgeBases.mutex.RUnlock()

	return argCopy
}

// MinimockListKnowledgeBasesDone returns true if the count of the ListKnowledgeBases invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListKnowledgeBasesDone() bool {
	if m.ListKnowledgeBasesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListKnowledgeBasesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListKnowledgeBasesMock.invocationsDone()
}

// MinimockListKnowledgeBasesInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListKnowledgeBasesInspect() {
	for _, e := range m.ListKnowledgeBasesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBases at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListKnowledgeBasesCounter := mm_atomic.LoadUint64(&m.afterListKnowledgeBasesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListKnowledgeBasesMock.defaultExpectation != nil && afterListKnowledgeBasesCounter < 1 {
		if m.ListKnowledgeBasesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBases at\n%s", m.ListKnowledgeBasesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBases at\n%s with params: %#v", m.ListKnowledgeBasesMock.defaultExpectation.expectationOrigins.origin, *m.ListKnowledgeBasesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListKnowledgeBases != nil && afterListKnowledgeBasesCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBases at\n%s", m.funcListKnowledgeBasesOrigin)
	}

	if !m.ListKnowledgeBasesMock.invocationsDone() && afterListKnowledgeBasesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListKnowledgeBases at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListKnowledgeBasesMock.expectedInvocations), m.ListKnowledgeBasesMock.expectedInvocationsOrigin, afterListKnowledgeBasesCounter)
	}
}

type mRepositoryMockListKnowledgeBasesByCatalogType struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListKnowledgeBasesByCatalogTypeExpectation
	expectations       []*RepositoryMockListKnowledgeBasesByCatalogTypeExpectation

	callArgs []*RepositoryMockListKnowledgeBasesByCatalogTypeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListKnowledgeBasesByCatalogTypeExpectation specifies expectation struct of the Repository.ListKnowledgeBasesByCatalogType
type RepositoryMockListKnowledgeBasesByCatalogTypeExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListKnowledgeBasesByCatalogTypeParams
	paramPtrs          *RepositoryMockListKnowledgeBasesByCatalogTypeParamPtrs
	expectationOrigins RepositoryMockListKnowledgeBasesByCatalogTypeExpectationOrigins
	results            *RepositoryMockListKnowledgeBasesByCatalogTypeResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListKnowledgeBasesByCatalogTypeParams contains parameters of the Repository.ListKnowledgeBasesByCatalogType
type RepositoryMockListKnowledgeBasesByCatalogTypeParams struct {
	ctx         context.Context
	ownerUID    string
	catalogType artifactpb.CatalogType
}

// RepositoryMockListKnowledgeBasesByCatalogTypeParamPtrs contains pointers to parameters of the Repository.ListKnowledgeBasesByCatalogType
type RepositoryMockListKnowledgeBasesByCatalogTypeParamPtrs struct {
	ctx         *context.Context
	ownerUID    *string
	catalogType *artifactpb.CatalogType
}

// RepositoryMockListKnowledgeBasesByCatalogTypeResults contains results of the Repository.ListKnowledgeBasesByCatalogType
type RepositoryMockListKnowledgeBasesByCatalogTypeResults struct {
	ka1 []mm_repository.KnowledgeBaseModel
	err error
}

// RepositoryMockListKnowledgeBasesByCatalogTypeOrigins contains origins of expectations of the Repository.ListKnowledgeBasesByCatalogType
type RepositoryMockListKnowledgeBasesByCatalogTypeExpectationOrigins struct {
	origin            string
	originCtx         string
	originOwnerUID    string
	originCatalogType string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListKnowledgeBasesByCatalogType *mRepositoryMockListKnowledgeBasesByCatalogType) Optional() *mRepositoryMockListKnowledgeBasesByCatalogType {
	mmListKnowledgeBasesByCatalogType.optional = true
	return mmListKnowledgeBasesByCatalogType
}

// Expect sets up expected params for Repository.ListKnowledgeBasesByCatalogType
func (mmListKnowledgeBasesByCatalogType *mRepositoryMockListKnowledgeBasesByCatalogType) Expect(ctx context.Context, ownerUID string, catalogType artifactpb.CatalogType) *mRepositoryMockListKnowledgeBasesByCatalogType {
	if mmListKnowledgeBasesByCatalogType.mock.funcListKnowledgeBasesByCatalogType != nil {
		mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByCatalogType mock is already set by Set")
	}

	if mmListKnowledgeBasesByCatalogType.defaultExpectation == nil {
		mmListKnowledgeBasesByCatalogType.defaultExpectation = &RepositoryMockListKnowledgeBasesByCatalogTypeExpectation{}
	}

	if mmListKnowledgeBasesByCatalogType.defaultExpectation.paramPtrs != nil {
		mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByCatalogType mock is already set by ExpectParams functions")
	}

	mmListKnowledgeBasesByCatalogType.defaultExpectation.params = &RepositoryMockListKnowledgeBasesByCatalogTypeParams{ctx, ownerUID, catalogType}
	mmListKnowledgeBasesByCatalogType.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListKnowledgeBasesByCatalogType.expectations {
		if minimock.Equal(e.params, mmListKnowledgeBasesByCatalogType.defaultExpectation.params) {
			mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListKnowledgeBasesByCatalogType.defaultExpectation.params)
		}
	}

	return mmListKnowledgeBasesByCatalogType
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListKnowledgeBasesByCatalogType
func (mmListKnowledgeBasesByCatalogType *mRepositoryMockListKnowledgeBasesByCatalogType) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListKnowledgeBasesByCatalogType {
	if mmListKnowledgeBasesByCatalogType.mock.funcListKnowledgeBasesByCatalogType != nil {
		mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByCatalogType mock is already set by Set")
	}

	if mmListKnowledgeBasesByCatalogType.defaultExpectation == nil {
		mmListKnowledgeBasesByCatalogType.defaultExpectation = &RepositoryMockListKnowledgeBasesByCatalogTypeExpectation{}
	}

	if mmListKnowledgeBasesByCatalogType.defaultExpectation.params != nil {
		mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByCatalogType mock is already set by Expect")
	}

	if mmListKnowledgeBasesByCatalogType.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBasesByCatalogType.defaultExpectation.paramPtrs = &RepositoryMockListKnowledgeBasesByCatalogTypeParamPtrs{}
	}
	mmListKnowledgeBasesByCatalogType.defaultExpectation.paramPtrs.ctx = &ctx
	mmListKnowledgeBasesByCatalogType.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListKnowledgeBasesByCatalogType
}

// ExpectOwnerUIDParam2 sets up expected param ownerUID for Repository.ListKnowledgeBasesByCatalogType
func (mmListKnowledgeBasesByCatalogType *mRepositoryMockListKnowledgeBasesByCatalogType) ExpectOwnerUIDParam2(ownerUID string) *mRepositoryMockListKnowledgeBasesByCatalogType {
	if mmListKnowledgeBasesByCatalogType.mock.funcListKnowledgeBasesByCatalogType != nil {
		mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByCatalogType mock is already set by Set")
	}

	if mmListKnowledgeBasesByCatalogType.defaultExpectation == nil {
		mmListKnowledgeBasesByCatalogType.defaultExpectation = &RepositoryMockListKnowledgeBasesByCatalogTypeExpectation{}
	}

	if mmListKnowledgeBasesByCatalogType.defaultExpectation.params != nil {
		mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByCatalogType mock is already set by Expect")
	}

	if mmListKnowledgeBasesByCatalogType.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBasesByCatalogType.defaultExpectation.paramPtrs = &RepositoryMockListKnowledgeBasesByCatalogTypeParamPtrs{}
	}
	mmListKnowledgeBasesByCatalogType.defaultExpectation.paramPtrs.ownerUID = &ownerUID
	mmListKnowledgeBasesByCatalogType.defaultExpectation.expectationOrigins.originOwnerUID = minimock.CallerInfo(1)

	return mmListKnowledgeBasesByCatalogType
}

// ExpectCatalogTypeParam3 sets up expected param catalogType for Repository.ListKnowledgeBasesByCatalogType
func (mmListKnowledgeBasesByCatalogType *mRepositoryMockListKnowledgeBasesByCatalogType) ExpectCatalogTypeParam3(catalogType artifactpb.CatalogType) *mRepositoryMockListKnowledgeBasesByCatalogType {
	if mmListKnowledgeBasesByCatalogType.mock.funcListKnowledgeBasesByCatalogType != nil {
		mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByCatalogType mock is already set by Set")
	}

	if mmListKnowledgeBasesByCatalogType.defaultExpectation == nil {
		mmListKnowledgeBasesByCatalogType.defaultExpectation = &RepositoryMockListKnowledgeBasesByCatalogTypeExpectation{}
	}

	if mmListKnowledgeBasesByCatalogType.defaultExpectation.params != nil {
		mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByCatalogType mock is already set by Expect")
	}

	if mmListKnowledgeBasesByCatalogType.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBasesByCatalogType.defaultExpectation.paramPtrs = &RepositoryMockListKnowledgeBasesByCatalogTypeParamPtrs{}
	}
	mmListKnowledgeBasesByCatalogType.defaultExpectation.paramPtrs.catalogType = &catalogType
	mmListKnowledgeBasesByCatalogType.defaultExpectation.expectationOrigins.originCatalogType = minimock.CallerInfo(1)

	return mmListKnowledgeBasesByCatalogType
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListKnowledgeBasesByCatalogType
func (mmListKnowledgeBasesByCatalogType *mRepositoryMockListKnowledgeBasesByCatalogType) Inspect(f func(ctx context.Context, ownerUID string, catalogType artifactpb.CatalogType)) *mRepositoryMockListKnowledgeBasesByCatalogType {
	if mmListKnowledgeBasesByCatalogType.mock.inspectFuncListKnowledgeBasesByCatalogType != nil {
		mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListKnowledgeBasesByCatalogType")
	}

	mmListKnowledgeBasesByCatalogType.mock.inspectFuncListKnowledgeBasesByCatalogType = f

	return mmListKnowledgeBasesByCatalogType
}

// Return sets up results that will be returned by Repository.ListKnowledgeBasesByCatalogType
func (mmListKnowledgeBasesByCatalogType *mRepositoryMockListKnowledgeBasesByCatalogType) Return(ka1 []mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	if mmListKnowledgeBasesByCatalogType.mock.funcListKnowledgeBasesByCatalogType != nil {
		mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByCatalogType mock is already set by Set")
	}

	if mmListKnowledgeBasesByCatalogType.defaultExpectation == nil {
		mmListKnowledgeBasesByCatalogType.defaultExpectation = &RepositoryMockListKnowledgeBasesByCatalogTypeExpectation{mock: mmListKnowledgeBasesByCatalogType.mock}
	}
	mmListKnowledgeBasesByCatalogType.defaultExpectation.results = &RepositoryMockListKnowledgeBasesByCatalogTypeResults{ka1, err}
	mmListKnowledgeBasesByCatalogType.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBasesByCatalogType.mock
}

// Set uses given function f to mock the Repository.ListKnowledgeBasesByCatalogType method
func (mmListKnowledgeBasesByCatalogType *mRepositoryMockListKnowledgeBasesByCatalogType) Set(f func(ctx context.Context, ownerUID string, catalogType artifactpb.CatalogType) (ka1 []mm_repository.KnowledgeBaseModel, err error)) *RepositoryMock {
	if mmListKnowledgeBasesByCatalogType.defaultExpectation != nil {
		mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("Default expectation is already set for the Repository.ListKnowledgeBasesByCatalogType method")
	}

	if len(mmListKnowledgeBasesByCatalogType.expectations) > 0 {
		mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("Some expectations are already set for the Repository.ListKnowledgeBasesByCatalogType method")
	}

	mmListKnowledgeBasesByCatalogType.mock.funcListKnowledgeBasesByCatalogType = f
	mmListKnowledgeBasesByCatalogType.mock.funcListKnowledgeBasesByCatalogTypeOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBasesByCatalogType.mock
}

// When sets expectation for the Repository.ListKnowledgeBasesByCatalogType which will trigger the result defined by the following
// Then helper
func (mmListKnowledgeBasesByCatalogType *mRepositoryMockListKnowledgeBasesByCatalogType) When(ctx context.Context, ownerUID string, catalogType artifactpb.CatalogType) *RepositoryMockListKnowledgeBasesByCatalogTypeExpectation {
	if mmListKnowledgeBasesByCatalogType.mock.funcListKnowledgeBasesByCatalogType != nil {
		mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("RepositoryMock.ListKnowledgeBasesByCatalogType mock is already set by Set")
	}

	expectation := &RepositoryMockListKnowledgeBasesByCatalogTypeExpectation{
		mock:               mmListKnowledgeBasesByCatalogType.mock,
		params:             &RepositoryMockListKnowledgeBasesByCatalogTypeParams{ctx, ownerUID, catalogType},
		expectationOrigins: RepositoryMockListKnowledgeBasesByCatalogTypeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListKnowledgeBasesByCatalogType.expectations = append(mmListKnowledgeBasesByCatalogType.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListKnowledgeBasesByCatalogType return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListKnowledgeBasesByCatalogTypeExpectation) Then(ka1 []mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	e.results = &RepositoryMockListKnowledgeBasesByCatalogTypeResults{ka1, err}
	return e.mock
}

// Times sets number of times Repository.ListKnowledgeBasesByCatalogType should be invoked
func (mmListKnowledgeBasesByCatalogType *mRepositoryMockListKnowledgeBasesByCatalogType) Times(n uint64) *mRepositoryMockListKnowledgeBasesByCatalogType {
	if n == 0 {
		mmListKnowledgeBasesByCatalogType.mock.t.Fatalf("Times of RepositoryMock.ListKnowledgeBasesByCatalogType mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListKnowledgeBasesByCatalogType.expectedInvocations, n)
	mmListKnowledgeBasesByCatalogType.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBasesByCatalogType
}

func (mmListKnowledgeBasesByCatalogType *mRepositoryMockListKnowledgeBasesByCatalogType) invocationsDone() bool {
	if len(mmListKnowledgeBasesByCatalogType.expectations) == 0 && mmListKnowledgeBasesByCatalogType.defaultExpectation == nil && mmListKnowledgeBasesByCatalogType.mock.funcListKnowledgeBasesByCatalogType == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBasesByCatalogType.mock.afterListKnowledgeBasesByCatalogTypeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBasesByCatalogType.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListKnowledgeBasesByCatalogType implements mm_repository.Repository
func (mmListKnowledgeBasesByCatalogType *RepositoryMock) ListKnowledgeBasesByCatalogType(ctx context.Context, ownerUID string, catalogType artifactpb.CatalogType) (ka1 []mm_repository.KnowledgeBaseModel, err error) {
	mm_atomic.AddUint64(&mmListKnowledgeBasesByCatalogType.beforeListKnowledgeBasesByCatalogTypeCounter, 1)
	defer mm_atomic.AddUint64(&mmListKnowledgeBasesByCatalogType.afterListKnowledgeBasesByCatalogTypeCounter, 1)

	mmListKnowledgeBasesByCatalogType.t.Helper()

	if mmListKnowledgeBasesByCatalogType.inspectFuncListKnowledgeBasesByCatalogType != nil {
		mmListKnowledgeBasesByCatalogType.inspectFuncListKnowledgeBasesByCatalogType(ctx, ownerUID, catalogType)
	}

	mm_params := RepositoryMockListKnowledgeBasesByCatalogTypeParams{ctx, ownerUID, catalogType}

	// Record call args
	mmListKnowledgeBasesByCatalogType.ListKnowledgeBasesByCatalogTypeMock.mutex.Lock()
	mmListKnowledgeBasesByCatalogType.ListKnowledgeBasesByCatalogTypeMock.callArgs = append(mmListKnowledgeBasesByCatalogType.ListKnowledgeBasesByCatalogTypeMock.callArgs, &mm_params)
	mmListKnowledgeBasesByCatalogType.ListKnowledgeBasesByCatalogTypeMock.mutex.Unlock()

	for _, e := range mmListKnowledgeBasesByCatalogType.ListKnowledgeBasesByCatalogTypeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmListKnowledgeBasesByCatalogType.ListKnowledgeBasesByCatalogTypeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListKnowledgeBasesByCatalogType.ListKnowledgeBasesByCatalogTypeMock.defaultExpectation.Counter, 1)
		mm_want := mmListKnowledgeBasesByCatalogType.ListKnowledgeBasesByCatalogTypeMock.defaultExpectation.params
		mm_want_ptrs := mmListKnowledgeBasesByCatalogType.ListKnowledgeBasesByCatalogTypeMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListKnowledgeBasesByCatalogTypeParams{ctx, ownerUID, catalogType}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListKnowledgeBasesByCatalogType.t.Errorf("RepositoryMock.ListKnowledgeBasesByCatalogType got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBasesByCatalogType.ListKnowledgeBasesByCatalogTypeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmListKnowledgeBasesByCatalogType.t.Errorf("RepositoryMock.ListKnowledgeBasesByCatalogType got unexpected parameter ownerUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBasesByCatalogType.ListKnowledgeBasesByCatalogTypeMock.defaultExpectation.expectationOrigins.originOwnerUID, *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

			if mm_want_ptrs.catalogType != nil && !minimock.Equal(*mm_want_ptrs.catalogType, mm_got.catalogType) {
				mmListKnowledgeBasesByCatalogType.t.Errorf("RepositoryMock.ListKnowledgeBasesByCatalogType got unexpected parameter catalogType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBasesByCatalogType.ListKnowledgeBasesByCatalogTypeMock.defaultExpectation.expectationOrigins.originCatalogType, *mm_want_ptrs.catalogType, mm_got.catalogType, minimock.Diff(*mm_want_ptrs.catalogType, mm_got.catalogType))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListKnowledgeBasesByCatalogType.t.Errorf("RepositoryMock.ListKnowledgeBasesByCatalogType got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListKnowledgeBasesByCatalogType.ListKnowledgeBasesByCatalogTypeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListKnowledgeBasesByCatalogType.ListKnowledgeBasesByCatalogTypeMock.defaultExpectation.results
		if mm_results == nil {
			mmListKnowledgeBasesByCatalogType.t.Fatal("No results are set for the RepositoryMock.ListKnowledgeBasesByCatalogType")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmListKnowledgeBasesByCatalogType.funcListKnowledgeBasesByCatalogType != nil {
		return mmListKnowledgeBasesByCatalogType.funcListKnowledgeBasesByCatalogType(ctx, ownerUID, catalogType)
	}
	mmListKnowledgeBasesByCatalogType.t.Fatalf("Unexpected call to RepositoryMock.ListKnowledgeBasesByCatalogType. %v %v %v", ctx, ownerUID, catalogType)
	return
}

// ListKnowledgeBasesByCatalogTypeAfterCounter returns a count of finished RepositoryMock.ListKnowledgeBasesByCatalogType invocations
func (mmListKnowledgeBasesByCatalogType *RepositoryMock) ListKnowledgeBasesByCatalogTypeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBasesByCatalogType.afterListKnowledgeBasesByCatalogTypeCounter)
}

// ListKnowledgeBasesByCatalogTypeBeforeCounter returns a count of RepositoryMock.ListKnowledgeBasesByCatalogType invocations
func (mmListKnowledgeBasesByCatalogType *RepositoryMock) ListKnowledgeBasesByCatalogTypeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBasesByCatalogType.beforeListKnowledgeBasesByCatalogTypeCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListKnowledgeBasesByCatalogType.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListKnowledgeBasesByCatalogType *mRepositoryMockListKnowledgeBasesByCatalogType) Calls() []*RepositoryMockListKnowledgeBasesByCatalogTypeParams {
	mmListKnowledgeBasesByCatalogType.mutex.RLock()

	argCopy := make([]*RepositoryMockListKnowledgeBasesByCatalogTypeParams, len(mmListKnowledgeBasesByCatalogType.callArgs))
	copy(argCopy, mmListKnowledgeBasesByCatalogType.callArgs)

	mmListKnowledgeBasesByCatalogType.mutex.RUnlock()

	return argCopy
}

// MinimockListKnowledgeBasesByCatalogTypeDone returns true if the count of the ListKnowledgeBasesByCatalogType invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListKnowledgeBasesByCatalogTypeDone() bool {
	if m.ListKnowledgeBasesByCatalogTypeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListKnowledgeBasesByCatalogTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListKnowledgeBasesByCatalogTypeMock.invocationsDone()
}

// MinimockListKnowledgeBasesByCatalogTypeInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListKnowledgeBasesByCatalogTypeInspect() {
	for _, e := range m.ListKnowledgeBasesByCatalogTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBasesByCatalogType at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListKnowledgeBasesByCatalogTypeCounter := mm_atomic.LoadUint64(&m.afterListKnowledgeBasesByCatalogTypeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListKnowledgeBasesByCatalogTypeMock.defaultExpectation != nil && afterListKnowledgeBasesByCatalogTypeCounter < 1 {
		if m.ListKnowledgeBasesByCatalogTypeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBasesByCatalogType at\n%s", m.ListKnowledgeBasesByCatalogTypeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBasesByCatalogType at\n%s with params: %#v", m.ListKnowledgeBasesByCatalogTypeMock.defaultExpectation.expectationOrigins.origin, *m.ListKnowledgeBasesByCatalogTypeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListKnowledgeBasesByCatalogType != nil && afterListKnowledgeBasesByCatalogTypeCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListKnowledgeBasesByCatalogType at\n%s", m.funcListKnowledgeBasesByCatalogTypeOrigin)
	}

	if !m.ListKnowledgeBasesByCatalogTypeMock.invocationsDone() && afterListKnowledgeBasesByCatalogTypeCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListKnowledgeBasesByCatalogType at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListKnowledgeBasesByCatalogTypeMock.expectedInvocations), m.ListKnowledgeBasesByCatalogTypeMock.expectedInvocationsOrigin, afterListKnowledgeBasesByCatalogTypeCounter)
	}
}

type mRepositoryMockListTextChunksByFileUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListTextChunksByFileUIDExpectation
	expectations       []*RepositoryMockListTextChunksByFileUIDExpectation

	callArgs []*RepositoryMockListTextChunksByFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListTextChunksByFileUIDExpectation specifies expectation struct of the Repository.ListTextChunksByFileUID
type RepositoryMockListTextChunksByFileUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListTextChunksByFileUIDParams
	paramPtrs          *RepositoryMockListTextChunksByFileUIDParamPtrs
	expectationOrigins RepositoryMockListTextChunksByFileUIDExpectationOrigins
	results            *RepositoryMockListTextChunksByFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListTextChunksByFileUIDParams contains parameters of the Repository.ListTextChunksByFileUID
type RepositoryMockListTextChunksByFileUIDParams struct {
	ctx     context.Context
	kbUID   types.KBUIDType
	fileUID types.FileUIDType
}

// RepositoryMockListTextChunksByFileUIDParamPtrs contains pointers to parameters of the Repository.ListTextChunksByFileUID
type RepositoryMockListTextChunksByFileUIDParamPtrs struct {
	ctx     *context.Context
	kbUID   *types.KBUIDType
	fileUID *types.FileUIDType
}

// RepositoryMockListTextChunksByFileUIDResults contains results of the Repository.ListTextChunksByFileUID
type RepositoryMockListTextChunksByFileUIDResults struct {
	sa1 []string
	err error
}

// RepositoryMockListTextChunksByFileUIDOrigins contains origins of expectations of the Repository.ListTextChunksByFileUID
type RepositoryMockListTextChunksByFileUIDExpectationOrigins struct {
	origin        string
	originCtx     string
	originKbUID   string
	originFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListTextChunksByFileUID *mRepositoryMockListTextChunksByFileUID) Optional() *mRepositoryMockListTextChunksByFileUID {
	mmListTextChunksByFileUID.optional = true
	return mmListTextChunksByFileUID
}

// Expect sets up expected params for Repository.ListTextChunksByFileUID
func (mmListTextChunksByFileUID *mRepositoryMockListTextChunksByFileUID) Expect(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType) *mRepositoryMockListTextChunksByFileUID {
	if mmListTextChunksByFileUID.mock.funcListTextChunksByFileUID != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("RepositoryMock.ListTextChunksByFileUID mock is already set by Set")
	}

	if mmListTextChunksByFileUID.defaultExpectation == nil {
		mmListTextChunksByFileUID.defaultExpectation = &RepositoryMockListTextChunksByFileUIDExpectation{}
	}

	if mmListTextChunksByFileUID.defaultExpectation.paramPtrs != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("RepositoryMock.ListTextChunksByFileUID mock is already set by ExpectParams functions")
	}

	mmListTextChunksByFileUID.defaultExpectation.params = &RepositoryMockListTextChunksByFileUIDParams{ctx, kbUID, fileUID}
	mmListTextChunksByFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListTextChunksByFileUID.expectations {
		if minimock.Equal(e.params, mmListTextChunksByFileUID.defaultExpectation.params) {
			mmListTextChunksByFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListTextChunksByFileUID.defaultExpectation.params)
		}
	}

	return mmListTextChunksByFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListTextChunksByFileUID
func (mmListTextChunksByFileUID *mRepositoryMockListTextChunksByFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListTextChunksByFileUID {
	if mmListTextChunksByFileUID.mock.funcListTextChunksByFileUID != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("RepositoryMock.ListTextChunksByFileUID mock is already set by Set")
	}

	if mmListTextChunksByFileUID.defaultExpectation == nil {
		mmListTextChunksByFileUID.defaultExpectation = &RepositoryMockListTextChunksByFileUIDExpectation{}
	}

	if mmListTextChunksByFileUID.defaultExpectation.params != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("RepositoryMock.ListTextChunksByFileUID mock is already set by Expect")
	}

	if mmListTextChunksByFileUID.defaultExpectation.paramPtrs == nil {
		mmListTextChunksByFileUID.defaultExpectation.paramPtrs = &RepositoryMockListTextChunksByFileUIDParamPtrs{}
	}
	mmListTextChunksByFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmListTextChunksByFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListTextChunksByFileUID
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.ListTextChunksByFileUID
func (mmListTextChunksByFileUID *mRepositoryMockListTextChunksByFileUID) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockListTextChunksByFileUID {
	if mmListTextChunksByFileUID.mock.funcListTextChunksByFileUID != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("RepositoryMock.ListTextChunksByFileUID mock is already set by Set")
	}

	if mmListTextChunksByFileUID.defaultExpectation == nil {
		mmListTextChunksByFileUID.defaultExpectation = &RepositoryMockListTextChunksByFileUIDExpectation{}
	}

	if mmListTextChunksByFileUID.defaultExpectation.params != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("RepositoryMock.ListTextChunksByFileUID mock is already set by Expect")
	}

	if mmListTextChunksByFileUID.defaultExpectation.paramPtrs == nil {
		mmListTextChunksByFileUID.defaultExpectation.paramPtrs = &RepositoryMockListTextChunksByFileUIDParamPtrs{}
	}
	mmListTextChunksByFileUID.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmListTextChunksByFileUID.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmListTextChunksByFileUID
}

// ExpectFileUIDParam3 sets up expected param fileUID for Repository.ListTextChunksByFileUID
func (mmListTextChunksByFileUID *mRepositoryMockListTextChunksByFileUID) ExpectFileUIDParam3(fileUID types.FileUIDType) *mRepositoryMockListTextChunksByFileUID {
	if mmListTextChunksByFileUID.mock.funcListTextChunksByFileUID != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("RepositoryMock.ListTextChunksByFileUID mock is already set by Set")
	}

	if mmListTextChunksByFileUID.defaultExpectation == nil {
		mmListTextChunksByFileUID.defaultExpectation = &RepositoryMockListTextChunksByFileUIDExpectation{}
	}

	if mmListTextChunksByFileUID.defaultExpectation.params != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("RepositoryMock.ListTextChunksByFileUID mock is already set by Expect")
	}

	if mmListTextChunksByFileUID.defaultExpectation.paramPtrs == nil {
		mmListTextChunksByFileUID.defaultExpectation.paramPtrs = &RepositoryMockListTextChunksByFileUIDParamPtrs{}
	}
	mmListTextChunksByFileUID.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmListTextChunksByFileUID.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmListTextChunksByFileUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListTextChunksByFileUID
func (mmListTextChunksByFileUID *mRepositoryMockListTextChunksByFileUID) Inspect(f func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType)) *mRepositoryMockListTextChunksByFileUID {
	if mmListTextChunksByFileUID.mock.inspectFuncListTextChunksByFileUID != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListTextChunksByFileUID")
	}

	mmListTextChunksByFileUID.mock.inspectFuncListTextChunksByFileUID = f

	return mmListTextChunksByFileUID
}

// Return sets up results that will be returned by Repository.ListTextChunksByFileUID
func (mmListTextChunksByFileUID *mRepositoryMockListTextChunksByFileUID) Return(sa1 []string, err error) *RepositoryMock {
	if mmListTextChunksByFileUID.mock.funcListTextChunksByFileUID != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("RepositoryMock.ListTextChunksByFileUID mock is already set by Set")
	}

	if mmListTextChunksByFileUID.defaultExpectation == nil {
		mmListTextChunksByFileUID.defaultExpectation = &RepositoryMockListTextChunksByFileUIDExpectation{mock: mmListTextChunksByFileUID.mock}
	}
	mmListTextChunksByFileUID.defaultExpectation.results = &RepositoryMockListTextChunksByFileUIDResults{sa1, err}
	mmListTextChunksByFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListTextChunksByFileUID.mock
}

// Set uses given function f to mock the Repository.ListTextChunksByFileUID method
func (mmListTextChunksByFileUID *mRepositoryMockListTextChunksByFileUID) Set(f func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType) (sa1 []string, err error)) *RepositoryMock {
	if mmListTextChunksByFileUID.defaultExpectation != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("Default expectation is already set for the Repository.ListTextChunksByFileUID method")
	}

	if len(mmListTextChunksByFileUID.expectations) > 0 {
		mmListTextChunksByFileUID.mock.t.Fatalf("Some expectations are already set for the Repository.ListTextChunksByFileUID method")
	}

	mmListTextChunksByFileUID.mock.funcListTextChunksByFileUID = f
	mmListTextChunksByFileUID.mock.funcListTextChunksByFileUIDOrigin = minimock.CallerInfo(1)
	return mmListTextChunksByFileUID.mock
}

// When sets expectation for the Repository.ListTextChunksByFileUID which will trigger the result defined by the following
// Then helper
func (mmListTextChunksByFileUID *mRepositoryMockListTextChunksByFileUID) When(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType) *RepositoryMockListTextChunksByFileUIDExpectation {
	if mmListTextChunksByFileUID.mock.funcListTextChunksByFileUID != nil {
		mmListTextChunksByFileUID.mock.t.Fatalf("RepositoryMock.ListTextChunksByFileUID mock is already set by Set")
	}

	expectation := &RepositoryMockListTextChunksByFileUIDExpectation{
		mock:               mmListTextChunksByFileUID.mock,
		params:             &RepositoryMockListTextChunksByFileUIDParams{ctx, kbUID, fileUID},
		expectationOrigins: RepositoryMockListTextChunksByFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListTextChunksByFileUID.expectations = append(mmListTextChunksByFileUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListTextChunksByFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListTextChunksByFileUIDExpectation) Then(sa1 []string, err error) *RepositoryMock {
	e.results = &RepositoryMockListTextChunksByFileUIDResults{sa1, err}
	return e.mock
}

// Times sets number of times Repository.ListTextChunksByFileUID should be invoked
func (mmListTextChunksByFileUID *mRepositoryMockListTextChunksByFileUID) Times(n uint64) *mRepositoryMockListTextChunksByFileUID {
	if n == 0 {
		mmListTextChunksByFileUID.mock.t.Fatalf("Times of RepositoryMock.ListTextChunksByFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListTextChunksByFileUID.expectedInvocations, n)
	mmListTextChunksByFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListTextChunksByFileUID
}

func (mmListTextChunksByFileUID *mRepositoryMockListTextChunksByFileUID) invocationsDone() bool {
	if len(mmListTextChunksByFileUID.expectations) == 0 && mmListTextChunksByFileUID.defaultExpectation == nil && mmListTextChunksByFileUID.mock.funcListTextChunksByFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListTextChunksByFileUID.mock.afterListTextChunksByFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListTextChunksByFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListTextChunksByFileUID implements mm_repository.Repository
func (mmListTextChunksByFileUID *RepositoryMock) ListTextChunksByFileUID(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmListTextChunksByFileUID.beforeListTextChunksByFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmListTextChunksByFileUID.afterListTextChunksByFileUIDCounter, 1)

	mmListTextChunksByFileUID.t.Helper()

	if mmListTextChunksByFileUID.inspectFuncListTextChunksByFileUID != nil {
		mmListTextChunksByFileUID.inspectFuncListTextChunksByFileUID(ctx, kbUID, fileUID)
	}

	mm_params := RepositoryMockListTextChunksByFileUIDParams{ctx, kbUID, fileUID}

	// Record call args
	mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.mutex.Lock()
	mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.callArgs = append(mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.callArgs, &mm_params)
	mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.mutex.Unlock()

	for _, e := range mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListTextChunksByFileUIDParams{ctx, kbUID, fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListTextChunksByFileUID.t.Errorf("RepositoryMock.ListTextChunksByFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmListTextChunksByFileUID.t.Errorf("RepositoryMock.ListTextChunksByFileUID got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmListTextChunksByFileUID.t.Errorf("RepositoryMock.ListTextChunksByFileUID got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListTextChunksByFileUID.t.Errorf("RepositoryMock.ListTextChunksByFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListTextChunksByFileUID.ListTextChunksByFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmListTextChunksByFileUID.t.Fatal("No results are set for the RepositoryMock.ListTextChunksByFileUID")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmListTextChunksByFileUID.funcListTextChunksByFileUID != nil {
		return mmListTextChunksByFileUID.funcListTextChunksByFileUID(ctx, kbUID, fileUID)
	}
	mmListTextChunksByFileUID.t.Fatalf("Unexpected call to RepositoryMock.ListTextChunksByFileUID. %v %v %v", ctx, kbUID, fileUID)
	return
}

// ListTextChunksByFileUIDAfterCounter returns a count of finished RepositoryMock.ListTextChunksByFileUID invocations
func (mmListTextChunksByFileUID *RepositoryMock) ListTextChunksByFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTextChunksByFileUID.afterListTextChunksByFileUIDCounter)
}

// ListTextChunksByFileUIDBeforeCounter returns a count of RepositoryMock.ListTextChunksByFileUID invocations
func (mmListTextChunksByFileUID *RepositoryMock) ListTextChunksByFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTextChunksByFileUID.beforeListTextChunksByFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListTextChunksByFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListTextChunksByFileUID *mRepositoryMockListTextChunksByFileUID) Calls() []*RepositoryMockListTextChunksByFileUIDParams {
	mmListTextChunksByFileUID.mutex.RLock()

	argCopy := make([]*RepositoryMockListTextChunksByFileUIDParams, len(mmListTextChunksByFileUID.callArgs))
	copy(argCopy, mmListTextChunksByFileUID.callArgs)

	mmListTextChunksByFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockListTextChunksByFileUIDDone returns true if the count of the ListTextChunksByFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListTextChunksByFileUIDDone() bool {
	if m.ListTextChunksByFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListTextChunksByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListTextChunksByFileUIDMock.invocationsDone()
}

// MinimockListTextChunksByFileUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListTextChunksByFileUIDInspect() {
	for _, e := range m.ListTextChunksByFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListTextChunksByFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListTextChunksByFileUIDCounter := mm_atomic.LoadUint64(&m.afterListTextChunksByFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListTextChunksByFileUIDMock.defaultExpectation != nil && afterListTextChunksByFileUIDCounter < 1 {
		if m.ListTextChunksByFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListTextChunksByFileUID at\n%s", m.ListTextChunksByFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListTextChunksByFileUID at\n%s with params: %#v", m.ListTextChunksByFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.ListTextChunksByFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListTextChunksByFileUID != nil && afterListTextChunksByFileUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListTextChunksByFileUID at\n%s", m.funcListTextChunksByFileUIDOrigin)
	}

	if !m.ListTextChunksByFileUIDMock.invocationsDone() && afterListTextChunksByFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListTextChunksByFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListTextChunksByFileUIDMock.expectedInvocations), m.ListTextChunksByFileUIDMock.expectedInvocationsOrigin, afterListTextChunksByFileUIDCounter)
	}
}

type mRepositoryMockListTextChunksByKBFileUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListTextChunksByKBFileUIDExpectation
	expectations       []*RepositoryMockListTextChunksByKBFileUIDExpectation

	callArgs []*RepositoryMockListTextChunksByKBFileUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListTextChunksByKBFileUIDExpectation specifies expectation struct of the Repository.ListTextChunksByKBFileUID
type RepositoryMockListTextChunksByKBFileUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListTextChunksByKBFileUIDParams
	paramPtrs          *RepositoryMockListTextChunksByKBFileUIDParamPtrs
	expectationOrigins RepositoryMockListTextChunksByKBFileUIDExpectationOrigins
	results            *RepositoryMockListTextChunksByKBFileUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListTextChunksByKBFileUIDParams contains parameters of the Repository.ListTextChunksByKBFileUID
type RepositoryMockListTextChunksByKBFileUIDParams struct {
	ctx       context.Context
	kbFileUID types.FileUIDType
}

// RepositoryMockListTextChunksByKBFileUIDParamPtrs contains pointers to parameters of the Repository.ListTextChunksByKBFileUID
type RepositoryMockListTextChunksByKBFileUIDParamPtrs struct {
	ctx       *context.Context
	kbFileUID *types.FileUIDType
}

// RepositoryMockListTextChunksByKBFileUIDResults contains results of the Repository.ListTextChunksByKBFileUID
type RepositoryMockListTextChunksByKBFileUIDResults struct {
	ta1 []mm_repository.TextChunkModel
	err error
}

// RepositoryMockListTextChunksByKBFileUIDOrigins contains origins of expectations of the Repository.ListTextChunksByKBFileUID
type RepositoryMockListTextChunksByKBFileUIDExpectationOrigins struct {
	origin          string
	originCtx       string
	originKbFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListTextChunksByKBFileUID *mRepositoryMockListTextChunksByKBFileUID) Optional() *mRepositoryMockListTextChunksByKBFileUID {
	mmListTextChunksByKBFileUID.optional = true
	return mmListTextChunksByKBFileUID
}

// Expect sets up expected params for Repository.ListTextChunksByKBFileUID
func (mmListTextChunksByKBFileUID *mRepositoryMockListTextChunksByKBFileUID) Expect(ctx context.Context, kbFileUID types.FileUIDType) *mRepositoryMockListTextChunksByKBFileUID {
	if mmListTextChunksByKBFileUID.mock.funcListTextChunksByKBFileUID != nil {
		mmListTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.ListTextChunksByKBFileUID mock is already set by Set")
	}

	if mmListTextChunksByKBFileUID.defaultExpectation == nil {
		mmListTextChunksByKBFileUID.defaultExpectation = &RepositoryMockListTextChunksByKBFileUIDExpectation{}
	}

	if mmListTextChunksByKBFileUID.defaultExpectation.paramPtrs != nil {
		mmListTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.ListTextChunksByKBFileUID mock is already set by ExpectParams functions")
	}

	mmListTextChunksByKBFileUID.defaultExpectation.params = &RepositoryMockListTextChunksByKBFileUIDParams{ctx, kbFileUID}
	mmListTextChunksByKBFileUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListTextChunksByKBFileUID.expectations {
		if minimock.Equal(e.params, mmListTextChunksByKBFileUID.defaultExpectation.params) {
			mmListTextChunksByKBFileUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListTextChunksByKBFileUID.defaultExpectation.params)
		}
	}

	return mmListTextChunksByKBFileUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListTextChunksByKBFileUID
func (mmListTextChunksByKBFileUID *mRepositoryMockListTextChunksByKBFileUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListTextChunksByKBFileUID {
	if mmListTextChunksByKBFileUID.mock.funcListTextChunksByKBFileUID != nil {
		mmListTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.ListTextChunksByKBFileUID mock is already set by Set")
	}

	if mmListTextChunksByKBFileUID.defaultExpectation == nil {
		mmListTextChunksByKBFileUID.defaultExpectation = &RepositoryMockListTextChunksByKBFileUIDExpectation{}
	}

	if mmListTextChunksByKBFileUID.defaultExpectation.params != nil {
		mmListTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.ListTextChunksByKBFileUID mock is already set by Expect")
	}

	if mmListTextChunksByKBFileUID.defaultExpectation.paramPtrs == nil {
		mmListTextChunksByKBFileUID.defaultExpectation.paramPtrs = &RepositoryMockListTextChunksByKBFileUIDParamPtrs{}
	}
	mmListTextChunksByKBFileUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmListTextChunksByKBFileUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListTextChunksByKBFileUID
}

// ExpectKbFileUIDParam2 sets up expected param kbFileUID for Repository.ListTextChunksByKBFileUID
func (mmListTextChunksByKBFileUID *mRepositoryMockListTextChunksByKBFileUID) ExpectKbFileUIDParam2(kbFileUID types.FileUIDType) *mRepositoryMockListTextChunksByKBFileUID {
	if mmListTextChunksByKBFileUID.mock.funcListTextChunksByKBFileUID != nil {
		mmListTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.ListTextChunksByKBFileUID mock is already set by Set")
	}

	if mmListTextChunksByKBFileUID.defaultExpectation == nil {
		mmListTextChunksByKBFileUID.defaultExpectation = &RepositoryMockListTextChunksByKBFileUIDExpectation{}
	}

	if mmListTextChunksByKBFileUID.defaultExpectation.params != nil {
		mmListTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.ListTextChunksByKBFileUID mock is already set by Expect")
	}

	if mmListTextChunksByKBFileUID.defaultExpectation.paramPtrs == nil {
		mmListTextChunksByKBFileUID.defaultExpectation.paramPtrs = &RepositoryMockListTextChunksByKBFileUIDParamPtrs{}
	}
	mmListTextChunksByKBFileUID.defaultExpectation.paramPtrs.kbFileUID = &kbFileUID
	mmListTextChunksByKBFileUID.defaultExpectation.expectationOrigins.originKbFileUID = minimock.CallerInfo(1)

	return mmListTextChunksByKBFileUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListTextChunksByKBFileUID
func (mmListTextChunksByKBFileUID *mRepositoryMockListTextChunksByKBFileUID) Inspect(f func(ctx context.Context, kbFileUID types.FileUIDType)) *mRepositoryMockListTextChunksByKBFileUID {
	if mmListTextChunksByKBFileUID.mock.inspectFuncListTextChunksByKBFileUID != nil {
		mmListTextChunksByKBFileUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListTextChunksByKBFileUID")
	}

	mmListTextChunksByKBFileUID.mock.inspectFuncListTextChunksByKBFileUID = f

	return mmListTextChunksByKBFileUID
}

// Return sets up results that will be returned by Repository.ListTextChunksByKBFileUID
func (mmListTextChunksByKBFileUID *mRepositoryMockListTextChunksByKBFileUID) Return(ta1 []mm_repository.TextChunkModel, err error) *RepositoryMock {
	if mmListTextChunksByKBFileUID.mock.funcListTextChunksByKBFileUID != nil {
		mmListTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.ListTextChunksByKBFileUID mock is already set by Set")
	}

	if mmListTextChunksByKBFileUID.defaultExpectation == nil {
		mmListTextChunksByKBFileUID.defaultExpectation = &RepositoryMockListTextChunksByKBFileUIDExpectation{mock: mmListTextChunksByKBFileUID.mock}
	}
	mmListTextChunksByKBFileUID.defaultExpectation.results = &RepositoryMockListTextChunksByKBFileUIDResults{ta1, err}
	mmListTextChunksByKBFileUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListTextChunksByKBFileUID.mock
}

// Set uses given function f to mock the Repository.ListTextChunksByKBFileUID method
func (mmListTextChunksByKBFileUID *mRepositoryMockListTextChunksByKBFileUID) Set(f func(ctx context.Context, kbFileUID types.FileUIDType) (ta1 []mm_repository.TextChunkModel, err error)) *RepositoryMock {
	if mmListTextChunksByKBFileUID.defaultExpectation != nil {
		mmListTextChunksByKBFileUID.mock.t.Fatalf("Default expectation is already set for the Repository.ListTextChunksByKBFileUID method")
	}

	if len(mmListTextChunksByKBFileUID.expectations) > 0 {
		mmListTextChunksByKBFileUID.mock.t.Fatalf("Some expectations are already set for the Repository.ListTextChunksByKBFileUID method")
	}

	mmListTextChunksByKBFileUID.mock.funcListTextChunksByKBFileUID = f
	mmListTextChunksByKBFileUID.mock.funcListTextChunksByKBFileUIDOrigin = minimock.CallerInfo(1)
	return mmListTextChunksByKBFileUID.mock
}

// When sets expectation for the Repository.ListTextChunksByKBFileUID which will trigger the result defined by the following
// Then helper
func (mmListTextChunksByKBFileUID *mRepositoryMockListTextChunksByKBFileUID) When(ctx context.Context, kbFileUID types.FileUIDType) *RepositoryMockListTextChunksByKBFileUIDExpectation {
	if mmListTextChunksByKBFileUID.mock.funcListTextChunksByKBFileUID != nil {
		mmListTextChunksByKBFileUID.mock.t.Fatalf("RepositoryMock.ListTextChunksByKBFileUID mock is already set by Set")
	}

	expectation := &RepositoryMockListTextChunksByKBFileUIDExpectation{
		mock:               mmListTextChunksByKBFileUID.mock,
		params:             &RepositoryMockListTextChunksByKBFileUIDParams{ctx, kbFileUID},
		expectationOrigins: RepositoryMockListTextChunksByKBFileUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListTextChunksByKBFileUID.expectations = append(mmListTextChunksByKBFileUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListTextChunksByKBFileUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListTextChunksByKBFileUIDExpectation) Then(ta1 []mm_repository.TextChunkModel, err error) *RepositoryMock {
	e.results = &RepositoryMockListTextChunksByKBFileUIDResults{ta1, err}
	return e.mock
}

// Times sets number of times Repository.ListTextChunksByKBFileUID should be invoked
func (mmListTextChunksByKBFileUID *mRepositoryMockListTextChunksByKBFileUID) Times(n uint64) *mRepositoryMockListTextChunksByKBFileUID {
	if n == 0 {
		mmListTextChunksByKBFileUID.mock.t.Fatalf("Times of RepositoryMock.ListTextChunksByKBFileUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListTextChunksByKBFileUID.expectedInvocations, n)
	mmListTextChunksByKBFileUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListTextChunksByKBFileUID
}

func (mmListTextChunksByKBFileUID *mRepositoryMockListTextChunksByKBFileUID) invocationsDone() bool {
	if len(mmListTextChunksByKBFileUID.expectations) == 0 && mmListTextChunksByKBFileUID.defaultExpectation == nil && mmListTextChunksByKBFileUID.mock.funcListTextChunksByKBFileUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListTextChunksByKBFileUID.mock.afterListTextChunksByKBFileUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListTextChunksByKBFileUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListTextChunksByKBFileUID implements mm_repository.Repository
func (mmListTextChunksByKBFileUID *RepositoryMock) ListTextChunksByKBFileUID(ctx context.Context, kbFileUID types.FileUIDType) (ta1 []mm_repository.TextChunkModel, err error) {
	mm_atomic.AddUint64(&mmListTextChunksByKBFileUID.beforeListTextChunksByKBFileUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmListTextChunksByKBFileUID.afterListTextChunksByKBFileUIDCounter, 1)

	mmListTextChunksByKBFileUID.t.Helper()

	if mmListTextChunksByKBFileUID.inspectFuncListTextChunksByKBFileUID != nil {
		mmListTextChunksByKBFileUID.inspectFuncListTextChunksByKBFileUID(ctx, kbFileUID)
	}

	mm_params := RepositoryMockListTextChunksByKBFileUIDParams{ctx, kbFileUID}

	// Record call args
	mmListTextChunksByKBFileUID.ListTextChunksByKBFileUIDMock.mutex.Lock()
	mmListTextChunksByKBFileUID.ListTextChunksByKBFileUIDMock.callArgs = append(mmListTextChunksByKBFileUID.ListTextChunksByKBFileUIDMock.callArgs, &mm_params)
	mmListTextChunksByKBFileUID.ListTextChunksByKBFileUIDMock.mutex.Unlock()

	for _, e := range mmListTextChunksByKBFileUID.ListTextChunksByKBFileUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ta1, e.results.err
		}
	}

	if mmListTextChunksByKBFileUID.ListTextChunksByKBFileUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListTextChunksByKBFileUID.ListTextChunksByKBFileUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmListTextChunksByKBFileUID.ListTextChunksByKBFileUIDMock.defaultExpectation.params
		mm_want_ptrs := mmListTextChunksByKBFileUID.ListTextChunksByKBFileUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListTextChunksByKBFileUIDParams{ctx, kbFileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListTextChunksByKBFileUID.t.Errorf("RepositoryMock.ListTextChunksByKBFileUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTextChunksByKBFileUID.ListTextChunksByKBFileUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbFileUID != nil && !minimock.Equal(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID) {
				mmListTextChunksByKBFileUID.t.Errorf("RepositoryMock.ListTextChunksByKBFileUID got unexpected parameter kbFileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTextChunksByKBFileUID.ListTextChunksByKBFileUIDMock.defaultExpectation.expectationOrigins.originKbFileUID, *mm_want_ptrs.kbFileUID, mm_got.kbFileUID, minimock.Diff(*mm_want_ptrs.kbFileUID, mm_got.kbFileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListTextChunksByKBFileUID.t.Errorf("RepositoryMock.ListTextChunksByKBFileUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListTextChunksByKBFileUID.ListTextChunksByKBFileUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListTextChunksByKBFileUID.ListTextChunksByKBFileUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmListTextChunksByKBFileUID.t.Fatal("No results are set for the RepositoryMock.ListTextChunksByKBFileUID")
		}
		return (*mm_results).ta1, (*mm_results).err
	}
	if mmListTextChunksByKBFileUID.funcListTextChunksByKBFileUID != nil {
		return mmListTextChunksByKBFileUID.funcListTextChunksByKBFileUID(ctx, kbFileUID)
	}
	mmListTextChunksByKBFileUID.t.Fatalf("Unexpected call to RepositoryMock.ListTextChunksByKBFileUID. %v %v", ctx, kbFileUID)
	return
}

// ListTextChunksByKBFileUIDAfterCounter returns a count of finished RepositoryMock.ListTextChunksByKBFileUID invocations
func (mmListTextChunksByKBFileUID *RepositoryMock) ListTextChunksByKBFileUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTextChunksByKBFileUID.afterListTextChunksByKBFileUIDCounter)
}

// ListTextChunksByKBFileUIDBeforeCounter returns a count of RepositoryMock.ListTextChunksByKBFileUID invocations
func (mmListTextChunksByKBFileUID *RepositoryMock) ListTextChunksByKBFileUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTextChunksByKBFileUID.beforeListTextChunksByKBFileUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListTextChunksByKBFileUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListTextChunksByKBFileUID *mRepositoryMockListTextChunksByKBFileUID) Calls() []*RepositoryMockListTextChunksByKBFileUIDParams {
	mmListTextChunksByKBFileUID.mutex.RLock()

	argCopy := make([]*RepositoryMockListTextChunksByKBFileUIDParams, len(mmListTextChunksByKBFileUID.callArgs))
	copy(argCopy, mmListTextChunksByKBFileUID.callArgs)

	mmListTextChunksByKBFileUID.mutex.RUnlock()

	return argCopy
}

// MinimockListTextChunksByKBFileUIDDone returns true if the count of the ListTextChunksByKBFileUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListTextChunksByKBFileUIDDone() bool {
	if m.ListTextChunksByKBFileUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListTextChunksByKBFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListTextChunksByKBFileUIDMock.invocationsDone()
}

// MinimockListTextChunksByKBFileUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListTextChunksByKBFileUIDInspect() {
	for _, e := range m.ListTextChunksByKBFileUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListTextChunksByKBFileUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListTextChunksByKBFileUIDCounter := mm_atomic.LoadUint64(&m.afterListTextChunksByKBFileUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListTextChunksByKBFileUIDMock.defaultExpectation != nil && afterListTextChunksByKBFileUIDCounter < 1 {
		if m.ListTextChunksByKBFileUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListTextChunksByKBFileUID at\n%s", m.ListTextChunksByKBFileUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListTextChunksByKBFileUID at\n%s with params: %#v", m.ListTextChunksByKBFileUIDMock.defaultExpectation.expectationOrigins.origin, *m.ListTextChunksByKBFileUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListTextChunksByKBFileUID != nil && afterListTextChunksByKBFileUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListTextChunksByKBFileUID at\n%s", m.funcListTextChunksByKBFileUIDOrigin)
	}

	if !m.ListTextChunksByKBFileUIDMock.invocationsDone() && afterListTextChunksByKBFileUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListTextChunksByKBFileUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListTextChunksByKBFileUIDMock.expectedInvocations), m.ListTextChunksByKBFileUIDMock.expectedInvocationsOrigin, afterListTextChunksByKBFileUIDCounter)
	}
}

type mRepositoryMockProcessKnowledgeBaseFiles struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockProcessKnowledgeBaseFilesExpectation
	expectations       []*RepositoryMockProcessKnowledgeBaseFilesExpectation

	callArgs []*RepositoryMockProcessKnowledgeBaseFilesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockProcessKnowledgeBaseFilesExpectation specifies expectation struct of the Repository.ProcessKnowledgeBaseFiles
type RepositoryMockProcessKnowledgeBaseFilesExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockProcessKnowledgeBaseFilesParams
	paramPtrs          *RepositoryMockProcessKnowledgeBaseFilesParamPtrs
	expectationOrigins RepositoryMockProcessKnowledgeBaseFilesExpectationOrigins
	results            *RepositoryMockProcessKnowledgeBaseFilesResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockProcessKnowledgeBaseFilesParams contains parameters of the Repository.ProcessKnowledgeBaseFiles
type RepositoryMockProcessKnowledgeBaseFilesParams struct {
	ctx       context.Context
	fileUIDs  []string
	requester types.RequesterUIDType
}

// RepositoryMockProcessKnowledgeBaseFilesParamPtrs contains pointers to parameters of the Repository.ProcessKnowledgeBaseFiles
type RepositoryMockProcessKnowledgeBaseFilesParamPtrs struct {
	ctx       *context.Context
	fileUIDs  *[]string
	requester *types.RequesterUIDType
}

// RepositoryMockProcessKnowledgeBaseFilesResults contains results of the Repository.ProcessKnowledgeBaseFiles
type RepositoryMockProcessKnowledgeBaseFilesResults struct {
	ka1 []mm_repository.KnowledgeBaseFileModel
	err error
}

// RepositoryMockProcessKnowledgeBaseFilesOrigins contains origins of expectations of the Repository.ProcessKnowledgeBaseFiles
type RepositoryMockProcessKnowledgeBaseFilesExpectationOrigins struct {
	origin          string
	originCtx       string
	originFileUIDs  string
	originRequester string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmProcessKnowledgeBaseFiles *mRepositoryMockProcessKnowledgeBaseFiles) Optional() *mRepositoryMockProcessKnowledgeBaseFiles {
	mmProcessKnowledgeBaseFiles.optional = true
	return mmProcessKnowledgeBaseFiles
}

// Expect sets up expected params for Repository.ProcessKnowledgeBaseFiles
func (mmProcessKnowledgeBaseFiles *mRepositoryMockProcessKnowledgeBaseFiles) Expect(ctx context.Context, fileUIDs []string, requester types.RequesterUIDType) *mRepositoryMockProcessKnowledgeBaseFiles {
	if mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ProcessKnowledgeBaseFiles mock is already set by Set")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation = &RepositoryMockProcessKnowledgeBaseFilesExpectation{}
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ProcessKnowledgeBaseFiles mock is already set by ExpectParams functions")
	}

	mmProcessKnowledgeBaseFiles.defaultExpectation.params = &RepositoryMockProcessKnowledgeBaseFilesParams{ctx, fileUIDs, requester}
	mmProcessKnowledgeBaseFiles.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmProcessKnowledgeBaseFiles.expectations {
		if minimock.Equal(e.params, mmProcessKnowledgeBaseFiles.defaultExpectation.params) {
			mmProcessKnowledgeBaseFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmProcessKnowledgeBaseFiles.defaultExpectation.params)
		}
	}

	return mmProcessKnowledgeBaseFiles
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ProcessKnowledgeBaseFiles
func (mmProcessKnowledgeBaseFiles *mRepositoryMockProcessKnowledgeBaseFiles) ExpectCtxParam1(ctx context.Context) *mRepositoryMockProcessKnowledgeBaseFiles {
	if mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ProcessKnowledgeBaseFiles mock is already set by Set")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation = &RepositoryMockProcessKnowledgeBaseFilesExpectation{}
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ProcessKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryMockProcessKnowledgeBaseFilesParamPtrs{}
	}
	mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs.ctx = &ctx
	mmProcessKnowledgeBaseFiles.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmProcessKnowledgeBaseFiles
}

// ExpectFileUIDsParam2 sets up expected param fileUIDs for Repository.ProcessKnowledgeBaseFiles
func (mmProcessKnowledgeBaseFiles *mRepositoryMockProcessKnowledgeBaseFiles) ExpectFileUIDsParam2(fileUIDs []string) *mRepositoryMockProcessKnowledgeBaseFiles {
	if mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ProcessKnowledgeBaseFiles mock is already set by Set")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation = &RepositoryMockProcessKnowledgeBaseFilesExpectation{}
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ProcessKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryMockProcessKnowledgeBaseFilesParamPtrs{}
	}
	mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs.fileUIDs = &fileUIDs
	mmProcessKnowledgeBaseFiles.defaultExpectation.expectationOrigins.originFileUIDs = minimock.CallerInfo(1)

	return mmProcessKnowledgeBaseFiles
}

// ExpectRequesterParam3 sets up expected param requester for Repository.ProcessKnowledgeBaseFiles
func (mmProcessKnowledgeBaseFiles *mRepositoryMockProcessKnowledgeBaseFiles) ExpectRequesterParam3(requester types.RequesterUIDType) *mRepositoryMockProcessKnowledgeBaseFiles {
	if mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ProcessKnowledgeBaseFiles mock is already set by Set")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation = &RepositoryMockProcessKnowledgeBaseFilesExpectation{}
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.params != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ProcessKnowledgeBaseFiles mock is already set by Expect")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs = &RepositoryMockProcessKnowledgeBaseFilesParamPtrs{}
	}
	mmProcessKnowledgeBaseFiles.defaultExpectation.paramPtrs.requester = &requester
	mmProcessKnowledgeBaseFiles.defaultExpectation.expectationOrigins.originRequester = minimock.CallerInfo(1)

	return mmProcessKnowledgeBaseFiles
}

// Inspect accepts an inspector function that has same arguments as the Repository.ProcessKnowledgeBaseFiles
func (mmProcessKnowledgeBaseFiles *mRepositoryMockProcessKnowledgeBaseFiles) Inspect(f func(ctx context.Context, fileUIDs []string, requester types.RequesterUIDType)) *mRepositoryMockProcessKnowledgeBaseFiles {
	if mmProcessKnowledgeBaseFiles.mock.inspectFuncProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ProcessKnowledgeBaseFiles")
	}

	mmProcessKnowledgeBaseFiles.mock.inspectFuncProcessKnowledgeBaseFiles = f

	return mmProcessKnowledgeBaseFiles
}

// Return sets up results that will be returned by Repository.ProcessKnowledgeBaseFiles
func (mmProcessKnowledgeBaseFiles *mRepositoryMockProcessKnowledgeBaseFiles) Return(ka1 []mm_repository.KnowledgeBaseFileModel, err error) *RepositoryMock {
	if mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ProcessKnowledgeBaseFiles mock is already set by Set")
	}

	if mmProcessKnowledgeBaseFiles.defaultExpectation == nil {
		mmProcessKnowledgeBaseFiles.defaultExpectation = &RepositoryMockProcessKnowledgeBaseFilesExpectation{mock: mmProcessKnowledgeBaseFiles.mock}
	}
	mmProcessKnowledgeBaseFiles.defaultExpectation.results = &RepositoryMockProcessKnowledgeBaseFilesResults{ka1, err}
	mmProcessKnowledgeBaseFiles.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmProcessKnowledgeBaseFiles.mock
}

// Set uses given function f to mock the Repository.ProcessKnowledgeBaseFiles method
func (mmProcessKnowledgeBaseFiles *mRepositoryMockProcessKnowledgeBaseFiles) Set(f func(ctx context.Context, fileUIDs []string, requester types.RequesterUIDType) (ka1 []mm_repository.KnowledgeBaseFileModel, err error)) *RepositoryMock {
	if mmProcessKnowledgeBaseFiles.defaultExpectation != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("Default expectation is already set for the Repository.ProcessKnowledgeBaseFiles method")
	}

	if len(mmProcessKnowledgeBaseFiles.expectations) > 0 {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("Some expectations are already set for the Repository.ProcessKnowledgeBaseFiles method")
	}

	mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles = f
	mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFilesOrigin = minimock.CallerInfo(1)
	return mmProcessKnowledgeBaseFiles.mock
}

// When sets expectation for the Repository.ProcessKnowledgeBaseFiles which will trigger the result defined by the following
// Then helper
func (mmProcessKnowledgeBaseFiles *mRepositoryMockProcessKnowledgeBaseFiles) When(ctx context.Context, fileUIDs []string, requester types.RequesterUIDType) *RepositoryMockProcessKnowledgeBaseFilesExpectation {
	if mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("RepositoryMock.ProcessKnowledgeBaseFiles mock is already set by Set")
	}

	expectation := &RepositoryMockProcessKnowledgeBaseFilesExpectation{
		mock:               mmProcessKnowledgeBaseFiles.mock,
		params:             &RepositoryMockProcessKnowledgeBaseFilesParams{ctx, fileUIDs, requester},
		expectationOrigins: RepositoryMockProcessKnowledgeBaseFilesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmProcessKnowledgeBaseFiles.expectations = append(mmProcessKnowledgeBaseFiles.expectations, expectation)
	return expectation
}

// Then sets up Repository.ProcessKnowledgeBaseFiles return parameters for the expectation previously defined by the When method
func (e *RepositoryMockProcessKnowledgeBaseFilesExpectation) Then(ka1 []mm_repository.KnowledgeBaseFileModel, err error) *RepositoryMock {
	e.results = &RepositoryMockProcessKnowledgeBaseFilesResults{ka1, err}
	return e.mock
}

// Times sets number of times Repository.ProcessKnowledgeBaseFiles should be invoked
func (mmProcessKnowledgeBaseFiles *mRepositoryMockProcessKnowledgeBaseFiles) Times(n uint64) *mRepositoryMockProcessKnowledgeBaseFiles {
	if n == 0 {
		mmProcessKnowledgeBaseFiles.mock.t.Fatalf("Times of RepositoryMock.ProcessKnowledgeBaseFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmProcessKnowledgeBaseFiles.expectedInvocations, n)
	mmProcessKnowledgeBaseFiles.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmProcessKnowledgeBaseFiles
}

func (mmProcessKnowledgeBaseFiles *mRepositoryMockProcessKnowledgeBaseFiles) invocationsDone() bool {
	if len(mmProcessKnowledgeBaseFiles.expectations) == 0 && mmProcessKnowledgeBaseFiles.defaultExpectation == nil && mmProcessKnowledgeBaseFiles.mock.funcProcessKnowledgeBaseFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmProcessKnowledgeBaseFiles.mock.afterProcessKnowledgeBaseFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmProcessKnowledgeBaseFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ProcessKnowledgeBaseFiles implements mm_repository.Repository
func (mmProcessKnowledgeBaseFiles *RepositoryMock) ProcessKnowledgeBaseFiles(ctx context.Context, fileUIDs []string, requester types.RequesterUIDType) (ka1 []mm_repository.KnowledgeBaseFileModel, err error) {
	mm_atomic.AddUint64(&mmProcessKnowledgeBaseFiles.beforeProcessKnowledgeBaseFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmProcessKnowledgeBaseFiles.afterProcessKnowledgeBaseFilesCounter, 1)

	mmProcessKnowledgeBaseFiles.t.Helper()

	if mmProcessKnowledgeBaseFiles.inspectFuncProcessKnowledgeBaseFiles != nil {
		mmProcessKnowledgeBaseFiles.inspectFuncProcessKnowledgeBaseFiles(ctx, fileUIDs, requester)
	}

	mm_params := RepositoryMockProcessKnowledgeBaseFilesParams{ctx, fileUIDs, requester}

	// Record call args
	mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.mutex.Lock()
	mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.callArgs = append(mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.callArgs, &mm_params)
	mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.mutex.Unlock()

	for _, e := range mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ka1, e.results.err
		}
	}

	if mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation.params
		mm_want_ptrs := mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockProcessKnowledgeBaseFilesParams{ctx, fileUIDs, requester}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmProcessKnowledgeBaseFiles.t.Errorf("RepositoryMock.ProcessKnowledgeBaseFiles got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUIDs != nil && !minimock.Equal(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs) {
				mmProcessKnowledgeBaseFiles.t.Errorf("RepositoryMock.ProcessKnowledgeBaseFiles got unexpected parameter fileUIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.originFileUIDs, *mm_want_ptrs.fileUIDs, mm_got.fileUIDs, minimock.Diff(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs))
			}

			if mm_want_ptrs.requester != nil && !minimock.Equal(*mm_want_ptrs.requester, mm_got.requester) {
				mmProcessKnowledgeBaseFiles.t.Errorf("RepositoryMock.ProcessKnowledgeBaseFiles got unexpected parameter requester, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.originRequester, *mm_want_ptrs.requester, mm_got.requester, minimock.Diff(*mm_want_ptrs.requester, mm_got.requester))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmProcessKnowledgeBaseFiles.t.Errorf("RepositoryMock.ProcessKnowledgeBaseFiles got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmProcessKnowledgeBaseFiles.ProcessKnowledgeBaseFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmProcessKnowledgeBaseFiles.t.Fatal("No results are set for the RepositoryMock.ProcessKnowledgeBaseFiles")
		}
		return (*mm_results).ka1, (*mm_results).err
	}
	if mmProcessKnowledgeBaseFiles.funcProcessKnowledgeBaseFiles != nil {
		return mmProcessKnowledgeBaseFiles.funcProcessKnowledgeBaseFiles(ctx, fileUIDs, requester)
	}
	mmProcessKnowledgeBaseFiles.t.Fatalf("Unexpected call to RepositoryMock.ProcessKnowledgeBaseFiles. %v %v %v", ctx, fileUIDs, requester)
	return
}

// ProcessKnowledgeBaseFilesAfterCounter returns a count of finished RepositoryMock.ProcessKnowledgeBaseFiles invocations
func (mmProcessKnowledgeBaseFiles *RepositoryMock) ProcessKnowledgeBaseFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessKnowledgeBaseFiles.afterProcessKnowledgeBaseFilesCounter)
}

// ProcessKnowledgeBaseFilesBeforeCounter returns a count of RepositoryMock.ProcessKnowledgeBaseFiles invocations
func (mmProcessKnowledgeBaseFiles *RepositoryMock) ProcessKnowledgeBaseFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessKnowledgeBaseFiles.beforeProcessKnowledgeBaseFilesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ProcessKnowledgeBaseFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmProcessKnowledgeBaseFiles *mRepositoryMockProcessKnowledgeBaseFiles) Calls() []*RepositoryMockProcessKnowledgeBaseFilesParams {
	mmProcessKnowledgeBaseFiles.mutex.RLock()

	argCopy := make([]*RepositoryMockProcessKnowledgeBaseFilesParams, len(mmProcessKnowledgeBaseFiles.callArgs))
	copy(argCopy, mmProcessKnowledgeBaseFiles.callArgs)

	mmProcessKnowledgeBaseFiles.mutex.RUnlock()

	return argCopy
}

// MinimockProcessKnowledgeBaseFilesDone returns true if the count of the ProcessKnowledgeBaseFiles invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockProcessKnowledgeBaseFilesDone() bool {
	if m.ProcessKnowledgeBaseFilesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ProcessKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ProcessKnowledgeBaseFilesMock.invocationsDone()
}

// MinimockProcessKnowledgeBaseFilesInspect logs each unmet expectation
func (m *RepositoryMock) MinimockProcessKnowledgeBaseFilesInspect() {
	for _, e := range m.ProcessKnowledgeBaseFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ProcessKnowledgeBaseFiles at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterProcessKnowledgeBaseFilesCounter := mm_atomic.LoadUint64(&m.afterProcessKnowledgeBaseFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ProcessKnowledgeBaseFilesMock.defaultExpectation != nil && afterProcessKnowledgeBaseFilesCounter < 1 {
		if m.ProcessKnowledgeBaseFilesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ProcessKnowledgeBaseFiles at\n%s", m.ProcessKnowledgeBaseFilesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ProcessKnowledgeBaseFiles at\n%s with params: %#v", m.ProcessKnowledgeBaseFilesMock.defaultExpectation.expectationOrigins.origin, *m.ProcessKnowledgeBaseFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProcessKnowledgeBaseFiles != nil && afterProcessKnowledgeBaseFilesCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ProcessKnowledgeBaseFiles at\n%s", m.funcProcessKnowledgeBaseFilesOrigin)
	}

	if !m.ProcessKnowledgeBaseFilesMock.invocationsDone() && afterProcessKnowledgeBaseFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ProcessKnowledgeBaseFiles at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ProcessKnowledgeBaseFilesMock.expectedInvocations), m.ProcessKnowledgeBaseFilesMock.expectedInvocationsOrigin, afterProcessKnowledgeBaseFilesCounter)
	}
}

type mRepositoryMockSaveConvertedFile struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockSaveConvertedFileExpectation
	expectations       []*RepositoryMockSaveConvertedFileExpectation

	callArgs []*RepositoryMockSaveConvertedFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockSaveConvertedFileExpectation specifies expectation struct of the Repository.SaveConvertedFile
type RepositoryMockSaveConvertedFileExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockSaveConvertedFileParams
	paramPtrs          *RepositoryMockSaveConvertedFileParamPtrs
	expectationOrigins RepositoryMockSaveConvertedFileExpectationOrigins
	results            *RepositoryMockSaveConvertedFileResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockSaveConvertedFileParams contains parameters of the Repository.SaveConvertedFile
type RepositoryMockSaveConvertedFileParams struct {
	ctx              context.Context
	kbUID            types.KBUIDType
	fileUID          types.FileUIDType
	convertedFileUID types.ConvertedFileUIDType
	fileExt          string
	content          []byte
}

// RepositoryMockSaveConvertedFileParamPtrs contains pointers to parameters of the Repository.SaveConvertedFile
type RepositoryMockSaveConvertedFileParamPtrs struct {
	ctx              *context.Context
	kbUID            *types.KBUIDType
	fileUID          *types.FileUIDType
	convertedFileUID *types.ConvertedFileUIDType
	fileExt          *string
	content          *[]byte
}

// RepositoryMockSaveConvertedFileResults contains results of the Repository.SaveConvertedFile
type RepositoryMockSaveConvertedFileResults struct {
	path string
	err  error
}

// RepositoryMockSaveConvertedFileOrigins contains origins of expectations of the Repository.SaveConvertedFile
type RepositoryMockSaveConvertedFileExpectationOrigins struct {
	origin                 string
	originCtx              string
	originKbUID            string
	originFileUID          string
	originConvertedFileUID string
	originFileExt          string
	originContent          string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSaveConvertedFile *mRepositoryMockSaveConvertedFile) Optional() *mRepositoryMockSaveConvertedFile {
	mmSaveConvertedFile.optional = true
	return mmSaveConvertedFile
}

// Expect sets up expected params for Repository.SaveConvertedFile
func (mmSaveConvertedFile *mRepositoryMockSaveConvertedFile) Expect(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, convertedFileUID types.ConvertedFileUIDType, fileExt string, content []byte) *mRepositoryMockSaveConvertedFile {
	if mmSaveConvertedFile.mock.funcSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("RepositoryMock.SaveConvertedFile mock is already set by Set")
	}

	if mmSaveConvertedFile.defaultExpectation == nil {
		mmSaveConvertedFile.defaultExpectation = &RepositoryMockSaveConvertedFileExpectation{}
	}

	if mmSaveConvertedFile.defaultExpectation.paramPtrs != nil {
		mmSaveConvertedFile.mock.t.Fatalf("RepositoryMock.SaveConvertedFile mock is already set by ExpectParams functions")
	}

	mmSaveConvertedFile.defaultExpectation.params = &RepositoryMockSaveConvertedFileParams{ctx, kbUID, fileUID, convertedFileUID, fileExt, content}
	mmSaveConvertedFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSaveConvertedFile.expectations {
		if minimock.Equal(e.params, mmSaveConvertedFile.defaultExpectation.params) {
			mmSaveConvertedFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveConvertedFile.defaultExpectation.params)
		}
	}

	return mmSaveConvertedFile
}

// ExpectCtxParam1 sets up expected param ctx for Repository.SaveConvertedFile
func (mmSaveConvertedFile *mRepositoryMockSaveConvertedFile) ExpectCtxParam1(ctx context.Context) *mRepositoryMockSaveConvertedFile {
	if mmSaveConvertedFile.mock.funcSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("RepositoryMock.SaveConvertedFile mock is already set by Set")
	}

	if mmSaveConvertedFile.defaultExpectation == nil {
		mmSaveConvertedFile.defaultExpectation = &RepositoryMockSaveConvertedFileExpectation{}
	}

	if mmSaveConvertedFile.defaultExpectation.params != nil {
		mmSaveConvertedFile.mock.t.Fatalf("RepositoryMock.SaveConvertedFile mock is already set by Expect")
	}

	if mmSaveConvertedFile.defaultExpectation.paramPtrs == nil {
		mmSaveConvertedFile.defaultExpectation.paramPtrs = &RepositoryMockSaveConvertedFileParamPtrs{}
	}
	mmSaveConvertedFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmSaveConvertedFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSaveConvertedFile
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.SaveConvertedFile
func (mmSaveConvertedFile *mRepositoryMockSaveConvertedFile) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockSaveConvertedFile {
	if mmSaveConvertedFile.mock.funcSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("RepositoryMock.SaveConvertedFile mock is already set by Set")
	}

	if mmSaveConvertedFile.defaultExpectation == nil {
		mmSaveConvertedFile.defaultExpectation = &RepositoryMockSaveConvertedFileExpectation{}
	}

	if mmSaveConvertedFile.defaultExpectation.params != nil {
		mmSaveConvertedFile.mock.t.Fatalf("RepositoryMock.SaveConvertedFile mock is already set by Expect")
	}

	if mmSaveConvertedFile.defaultExpectation.paramPtrs == nil {
		mmSaveConvertedFile.defaultExpectation.paramPtrs = &RepositoryMockSaveConvertedFileParamPtrs{}
	}
	mmSaveConvertedFile.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmSaveConvertedFile.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmSaveConvertedFile
}

// ExpectFileUIDParam3 sets up expected param fileUID for Repository.SaveConvertedFile
func (mmSaveConvertedFile *mRepositoryMockSaveConvertedFile) ExpectFileUIDParam3(fileUID types.FileUIDType) *mRepositoryMockSaveConvertedFile {
	if mmSaveConvertedFile.mock.funcSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("RepositoryMock.SaveConvertedFile mock is already set by Set")
	}

	if mmSaveConvertedFile.defaultExpectation == nil {
		mmSaveConvertedFile.defaultExpectation = &RepositoryMockSaveConvertedFileExpectation{}
	}

	if mmSaveConvertedFile.defaultExpectation.params != nil {
		mmSaveConvertedFile.mock.t.Fatalf("RepositoryMock.SaveConvertedFile mock is already set by Expect")
	}

	if mmSaveConvertedFile.defaultExpectation.paramPtrs == nil {
		mmSaveConvertedFile.defaultExpectation.paramPtrs = &RepositoryMockSaveConvertedFileParamPtrs{}
	}
	mmSaveConvertedFile.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmSaveConvertedFile.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmSaveConvertedFile
}

// ExpectConvertedFileUIDParam4 sets up expected param convertedFileUID for Repository.SaveConvertedFile
func (mmSaveConvertedFile *mRepositoryMockSaveConvertedFile) ExpectConvertedFileUIDParam4(convertedFileUID types.ConvertedFileUIDType) *mRepositoryMockSaveConvertedFile {
	if mmSaveConvertedFile.mock.funcSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("RepositoryMock.SaveConvertedFile mock is already set by Set")
	}

	if mmSaveConvertedFile.defaultExpectation == nil {
		mmSaveConvertedFile.defaultExpectation = &RepositoryMockSaveConvertedFileExpectation{}
	}

	if mmSaveConvertedFile.defaultExpectation.params != nil {
		mmSaveConvertedFile.mock.t.Fatalf("RepositoryMock.SaveConvertedFile mock is already set by Expect")
	}

	if mmSaveConvertedFile.defaultExpectation.paramPtrs == nil {
		mmSaveConvertedFile.defaultExpectation.paramPtrs = &RepositoryMockSaveConvertedFileParamPtrs{}
	}
	mmSaveConvertedFile.defaultExpectation.paramPtrs.convertedFileUID = &convertedFileUID
	mmSaveConvertedFile.defaultExpectation.expectationOrigins.originConvertedFileUID = minimock.CallerInfo(1)

	return mmSaveConvertedFile
}

// ExpectFileExtParam5 sets up expected param fileExt for Repository.SaveConvertedFile
func (mmSaveConvertedFile *mRepositoryMockSaveConvertedFile) ExpectFileExtParam5(fileExt string) *mRepositoryMockSaveConvertedFile {
	if mmSaveConvertedFile.mock.funcSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("RepositoryMock.SaveConvertedFile mock is already set by Set")
	}

	if mmSaveConvertedFile.defaultExpectation == nil {
		mmSaveConvertedFile.defaultExpectation = &RepositoryMockSaveConvertedFileExpectation{}
	}

	if mmSaveConvertedFile.defaultExpectation.params != nil {
		mmSaveConvertedFile.mock.t.Fatalf("RepositoryMock.SaveConvertedFile mock is already set by Expect")
	}

	if mmSaveConvertedFile.defaultExpectation.paramPtrs == nil {
		mmSaveConvertedFile.defaultExpectation.paramPtrs = &RepositoryMockSaveConvertedFileParamPtrs{}
	}
	mmSaveConvertedFile.defaultExpectation.paramPtrs.fileExt = &fileExt
	mmSaveConvertedFile.defaultExpectation.expectationOrigins.originFileExt = minimock.CallerInfo(1)

	return mmSaveConvertedFile
}

// ExpectContentParam6 sets up expected param content for Repository.SaveConvertedFile
func (mmSaveConvertedFile *mRepositoryMockSaveConvertedFile) ExpectContentParam6(content []byte) *mRepositoryMockSaveConvertedFile {
	if mmSaveConvertedFile.mock.funcSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("RepositoryMock.SaveConvertedFile mock is already set by Set")
	}

	if mmSaveConvertedFile.defaultExpectation == nil {
		mmSaveConvertedFile.defaultExpectation = &RepositoryMockSaveConvertedFileExpectation{}
	}

	if mmSaveConvertedFile.defaultExpectation.params != nil {
		mmSaveConvertedFile.mock.t.Fatalf("RepositoryMock.SaveConvertedFile mock is already set by Expect")
	}

	if mmSaveConvertedFile.defaultExpectation.paramPtrs == nil {
		mmSaveConvertedFile.defaultExpectation.paramPtrs = &RepositoryMockSaveConvertedFileParamPtrs{}
	}
	mmSaveConvertedFile.defaultExpectation.paramPtrs.content = &content
	mmSaveConvertedFile.defaultExpectation.expectationOrigins.originContent = minimock.CallerInfo(1)

	return mmSaveConvertedFile
}

// Inspect accepts an inspector function that has same arguments as the Repository.SaveConvertedFile
func (mmSaveConvertedFile *mRepositoryMockSaveConvertedFile) Inspect(f func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, convertedFileUID types.ConvertedFileUIDType, fileExt string, content []byte)) *mRepositoryMockSaveConvertedFile {
	if mmSaveConvertedFile.mock.inspectFuncSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("Inspect function is already set for RepositoryMock.SaveConvertedFile")
	}

	mmSaveConvertedFile.mock.inspectFuncSaveConvertedFile = f

	return mmSaveConvertedFile
}

// Return sets up results that will be returned by Repository.SaveConvertedFile
func (mmSaveConvertedFile *mRepositoryMockSaveConvertedFile) Return(path string, err error) *RepositoryMock {
	if mmSaveConvertedFile.mock.funcSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("RepositoryMock.SaveConvertedFile mock is already set by Set")
	}

	if mmSaveConvertedFile.defaultExpectation == nil {
		mmSaveConvertedFile.defaultExpectation = &RepositoryMockSaveConvertedFileExpectation{mock: mmSaveConvertedFile.mock}
	}
	mmSaveConvertedFile.defaultExpectation.results = &RepositoryMockSaveConvertedFileResults{path, err}
	mmSaveConvertedFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSaveConvertedFile.mock
}

// Set uses given function f to mock the Repository.SaveConvertedFile method
func (mmSaveConvertedFile *mRepositoryMockSaveConvertedFile) Set(f func(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, convertedFileUID types.ConvertedFileUIDType, fileExt string, content []byte) (path string, err error)) *RepositoryMock {
	if mmSaveConvertedFile.defaultExpectation != nil {
		mmSaveConvertedFile.mock.t.Fatalf("Default expectation is already set for the Repository.SaveConvertedFile method")
	}

	if len(mmSaveConvertedFile.expectations) > 0 {
		mmSaveConvertedFile.mock.t.Fatalf("Some expectations are already set for the Repository.SaveConvertedFile method")
	}

	mmSaveConvertedFile.mock.funcSaveConvertedFile = f
	mmSaveConvertedFile.mock.funcSaveConvertedFileOrigin = minimock.CallerInfo(1)
	return mmSaveConvertedFile.mock
}

// When sets expectation for the Repository.SaveConvertedFile which will trigger the result defined by the following
// Then helper
func (mmSaveConvertedFile *mRepositoryMockSaveConvertedFile) When(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, convertedFileUID types.ConvertedFileUIDType, fileExt string, content []byte) *RepositoryMockSaveConvertedFileExpectation {
	if mmSaveConvertedFile.mock.funcSaveConvertedFile != nil {
		mmSaveConvertedFile.mock.t.Fatalf("RepositoryMock.SaveConvertedFile mock is already set by Set")
	}

	expectation := &RepositoryMockSaveConvertedFileExpectation{
		mock:               mmSaveConvertedFile.mock,
		params:             &RepositoryMockSaveConvertedFileParams{ctx, kbUID, fileUID, convertedFileUID, fileExt, content},
		expectationOrigins: RepositoryMockSaveConvertedFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSaveConvertedFile.expectations = append(mmSaveConvertedFile.expectations, expectation)
	return expectation
}

// Then sets up Repository.SaveConvertedFile return parameters for the expectation previously defined by the When method
func (e *RepositoryMockSaveConvertedFileExpectation) Then(path string, err error) *RepositoryMock {
	e.results = &RepositoryMockSaveConvertedFileResults{path, err}
	return e.mock
}

// Times sets number of times Repository.SaveConvertedFile should be invoked
func (mmSaveConvertedFile *mRepositoryMockSaveConvertedFile) Times(n uint64) *mRepositoryMockSaveConvertedFile {
	if n == 0 {
		mmSaveConvertedFile.mock.t.Fatalf("Times of RepositoryMock.SaveConvertedFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSaveConvertedFile.expectedInvocations, n)
	mmSaveConvertedFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSaveConvertedFile
}

func (mmSaveConvertedFile *mRepositoryMockSaveConvertedFile) invocationsDone() bool {
	if len(mmSaveConvertedFile.expectations) == 0 && mmSaveConvertedFile.defaultExpectation == nil && mmSaveConvertedFile.mock.funcSaveConvertedFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSaveConvertedFile.mock.afterSaveConvertedFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSaveConvertedFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SaveConvertedFile implements mm_repository.Repository
func (mmSaveConvertedFile *RepositoryMock) SaveConvertedFile(ctx context.Context, kbUID types.KBUIDType, fileUID types.FileUIDType, convertedFileUID types.ConvertedFileUIDType, fileExt string, content []byte) (path string, err error) {
	mm_atomic.AddUint64(&mmSaveConvertedFile.beforeSaveConvertedFileCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveConvertedFile.afterSaveConvertedFileCounter, 1)

	mmSaveConvertedFile.t.Helper()

	if mmSaveConvertedFile.inspectFuncSaveConvertedFile != nil {
		mmSaveConvertedFile.inspectFuncSaveConvertedFile(ctx, kbUID, fileUID, convertedFileUID, fileExt, content)
	}

	mm_params := RepositoryMockSaveConvertedFileParams{ctx, kbUID, fileUID, convertedFileUID, fileExt, content}

	// Record call args
	mmSaveConvertedFile.SaveConvertedFileMock.mutex.Lock()
	mmSaveConvertedFile.SaveConvertedFileMock.callArgs = append(mmSaveConvertedFile.SaveConvertedFileMock.callArgs, &mm_params)
	mmSaveConvertedFile.SaveConvertedFileMock.mutex.Unlock()

	for _, e := range mmSaveConvertedFile.SaveConvertedFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.path, e.results.err
		}
	}

	if mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.params
		mm_want_ptrs := mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockSaveConvertedFileParams{ctx, kbUID, fileUID, convertedFileUID, fileExt, content}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSaveConvertedFile.t.Errorf("RepositoryMock.SaveConvertedFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmSaveConvertedFile.t.Errorf("RepositoryMock.SaveConvertedFile got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmSaveConvertedFile.t.Errorf("RepositoryMock.SaveConvertedFile got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

			if mm_want_ptrs.convertedFileUID != nil && !minimock.Equal(*mm_want_ptrs.convertedFileUID, mm_got.convertedFileUID) {
				mmSaveConvertedFile.t.Errorf("RepositoryMock.SaveConvertedFile got unexpected parameter convertedFileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.expectationOrigins.originConvertedFileUID, *mm_want_ptrs.convertedFileUID, mm_got.convertedFileUID, minimock.Diff(*mm_want_ptrs.convertedFileUID, mm_got.convertedFileUID))
			}

			if mm_want_ptrs.fileExt != nil && !minimock.Equal(*mm_want_ptrs.fileExt, mm_got.fileExt) {
				mmSaveConvertedFile.t.Errorf("RepositoryMock.SaveConvertedFile got unexpected parameter fileExt, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.expectationOrigins.originFileExt, *mm_want_ptrs.fileExt, mm_got.fileExt, minimock.Diff(*mm_want_ptrs.fileExt, mm_got.fileExt))
			}

			if mm_want_ptrs.content != nil && !minimock.Equal(*mm_want_ptrs.content, mm_got.content) {
				mmSaveConvertedFile.t.Errorf("RepositoryMock.SaveConvertedFile got unexpected parameter content, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.expectationOrigins.originContent, *mm_want_ptrs.content, mm_got.content, minimock.Diff(*mm_want_ptrs.content, mm_got.content))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveConvertedFile.t.Errorf("RepositoryMock.SaveConvertedFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveConvertedFile.SaveConvertedFileMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveConvertedFile.t.Fatal("No results are set for the RepositoryMock.SaveConvertedFile")
		}
		return (*mm_results).path, (*mm_results).err
	}
	if mmSaveConvertedFile.funcSaveConvertedFile != nil {
		return mmSaveConvertedFile.funcSaveConvertedFile(ctx, kbUID, fileUID, convertedFileUID, fileExt, content)
	}
	mmSaveConvertedFile.t.Fatalf("Unexpected call to RepositoryMock.SaveConvertedFile. %v %v %v %v %v %v", ctx, kbUID, fileUID, convertedFileUID, fileExt, content)
	return
}

// SaveConvertedFileAfterCounter returns a count of finished RepositoryMock.SaveConvertedFile invocations
func (mmSaveConvertedFile *RepositoryMock) SaveConvertedFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveConvertedFile.afterSaveConvertedFileCounter)
}

// SaveConvertedFileBeforeCounter returns a count of RepositoryMock.SaveConvertedFile invocations
func (mmSaveConvertedFile *RepositoryMock) SaveConvertedFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveConvertedFile.beforeSaveConvertedFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.SaveConvertedFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveConvertedFile *mRepositoryMockSaveConvertedFile) Calls() []*RepositoryMockSaveConvertedFileParams {
	mmSaveConvertedFile.mutex.RLock()

	argCopy := make([]*RepositoryMockSaveConvertedFileParams, len(mmSaveConvertedFile.callArgs))
	copy(argCopy, mmSaveConvertedFile.callArgs)

	mmSaveConvertedFile.mutex.RUnlock()

	return argCopy
}

// MinimockSaveConvertedFileDone returns true if the count of the SaveConvertedFile invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockSaveConvertedFileDone() bool {
	if m.SaveConvertedFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SaveConvertedFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SaveConvertedFileMock.invocationsDone()
}

// MinimockSaveConvertedFileInspect logs each unmet expectation
func (m *RepositoryMock) MinimockSaveConvertedFileInspect() {
	for _, e := range m.SaveConvertedFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.SaveConvertedFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSaveConvertedFileCounter := mm_atomic.LoadUint64(&m.afterSaveConvertedFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SaveConvertedFileMock.defaultExpectation != nil && afterSaveConvertedFileCounter < 1 {
		if m.SaveConvertedFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.SaveConvertedFile at\n%s", m.SaveConvertedFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.SaveConvertedFile at\n%s with params: %#v", m.SaveConvertedFileMock.defaultExpectation.expectationOrigins.origin, *m.SaveConvertedFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveConvertedFile != nil && afterSaveConvertedFileCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.SaveConvertedFile at\n%s", m.funcSaveConvertedFileOrigin)
	}

	if !m.SaveConvertedFileMock.invocationsDone() && afterSaveConvertedFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.SaveConvertedFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SaveConvertedFileMock.expectedInvocations), m.SaveConvertedFileMock.expectedInvocationsOrigin, afterSaveConvertedFileCounter)
	}
}

type mRepositoryMockSetChatCacheMetadata struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockSetChatCacheMetadataExpectation
	expectations       []*RepositoryMockSetChatCacheMetadataExpectation

	callArgs []*RepositoryMockSetChatCacheMetadataParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockSetChatCacheMetadataExpectation specifies expectation struct of the Repository.SetChatCacheMetadata
type RepositoryMockSetChatCacheMetadataExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockSetChatCacheMetadataParams
	paramPtrs          *RepositoryMockSetChatCacheMetadataParamPtrs
	expectationOrigins RepositoryMockSetChatCacheMetadataExpectationOrigins
	results            *RepositoryMockSetChatCacheMetadataResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockSetChatCacheMetadataParams contains parameters of the Repository.SetChatCacheMetadata
type RepositoryMockSetChatCacheMetadataParams struct {
	ctx      context.Context
	kbUID    types.KBUIDType
	fileUIDs []types.FileUIDType
	metadata *mm_repository.ChatCacheMetadata
	ttl      time.Duration
}

// RepositoryMockSetChatCacheMetadataParamPtrs contains pointers to parameters of the Repository.SetChatCacheMetadata
type RepositoryMockSetChatCacheMetadataParamPtrs struct {
	ctx      *context.Context
	kbUID    *types.KBUIDType
	fileUIDs *[]types.FileUIDType
	metadata **mm_repository.ChatCacheMetadata
	ttl      *time.Duration
}

// RepositoryMockSetChatCacheMetadataResults contains results of the Repository.SetChatCacheMetadata
type RepositoryMockSetChatCacheMetadataResults struct {
	err error
}

// RepositoryMockSetChatCacheMetadataOrigins contains origins of expectations of the Repository.SetChatCacheMetadata
type RepositoryMockSetChatCacheMetadataExpectationOrigins struct {
	origin         string
	originCtx      string
	originKbUID    string
	originFileUIDs string
	originMetadata string
	originTtl      string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetChatCacheMetadata *mRepositoryMockSetChatCacheMetadata) Optional() *mRepositoryMockSetChatCacheMetadata {
	mmSetChatCacheMetadata.optional = true
	return mmSetChatCacheMetadata
}

// Expect sets up expected params for Repository.SetChatCacheMetadata
func (mmSetChatCacheMetadata *mRepositoryMockSetChatCacheMetadata) Expect(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType, metadata *mm_repository.ChatCacheMetadata, ttl time.Duration) *mRepositoryMockSetChatCacheMetadata {
	if mmSetChatCacheMetadata.mock.funcSetChatCacheMetadata != nil {
		mmSetChatCacheMetadata.mock.t.Fatalf("RepositoryMock.SetChatCacheMetadata mock is already set by Set")
	}

	if mmSetChatCacheMetadata.defaultExpectation == nil {
		mmSetChatCacheMetadata.defaultExpectation = &RepositoryMockSetChatCacheMetadataExpectation{}
	}

	if mmSetChatCacheMetadata.defaultExpectation.paramPtrs != nil {
		mmSetChatCacheMetadata.mock.t.Fatalf("RepositoryMock.SetChatCacheMetadata mock is already set by ExpectParams functions")
	}

	mmSetChatCacheMetadata.defaultExpectation.params = &RepositoryMockSetChatCacheMetadataParams{ctx, kbUID, fileUIDs, metadata, ttl}
	mmSetChatCacheMetadata.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetChatCacheMetadata.expectations {
		if minimock.Equal(e.params, mmSetChatCacheMetadata.defaultExpectation.params) {
			mmSetChatCacheMetadata.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetChatCacheMetadata.defaultExpectation.params)
		}
	}

	return mmSetChatCacheMetadata
}

// ExpectCtxParam1 sets up expected param ctx for Repository.SetChatCacheMetadata
func (mmSetChatCacheMetadata *mRepositoryMockSetChatCacheMetadata) ExpectCtxParam1(ctx context.Context) *mRepositoryMockSetChatCacheMetadata {
	if mmSetChatCacheMetadata.mock.funcSetChatCacheMetadata != nil {
		mmSetChatCacheMetadata.mock.t.Fatalf("RepositoryMock.SetChatCacheMetadata mock is already set by Set")
	}

	if mmSetChatCacheMetadata.defaultExpectation == nil {
		mmSetChatCacheMetadata.defaultExpectation = &RepositoryMockSetChatCacheMetadataExpectation{}
	}

	if mmSetChatCacheMetadata.defaultExpectation.params != nil {
		mmSetChatCacheMetadata.mock.t.Fatalf("RepositoryMock.SetChatCacheMetadata mock is already set by Expect")
	}

	if mmSetChatCacheMetadata.defaultExpectation.paramPtrs == nil {
		mmSetChatCacheMetadata.defaultExpectation.paramPtrs = &RepositoryMockSetChatCacheMetadataParamPtrs{}
	}
	mmSetChatCacheMetadata.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetChatCacheMetadata.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetChatCacheMetadata
}

// ExpectKbUIDParam2 sets up expected param kbUID for Repository.SetChatCacheMetadata
func (mmSetChatCacheMetadata *mRepositoryMockSetChatCacheMetadata) ExpectKbUIDParam2(kbUID types.KBUIDType) *mRepositoryMockSetChatCacheMetadata {
	if mmSetChatCacheMetadata.mock.funcSetChatCacheMetadata != nil {
		mmSetChatCacheMetadata.mock.t.Fatalf("RepositoryMock.SetChatCacheMetadata mock is already set by Set")
	}

	if mmSetChatCacheMetadata.defaultExpectation == nil {
		mmSetChatCacheMetadata.defaultExpectation = &RepositoryMockSetChatCacheMetadataExpectation{}
	}

	if mmSetChatCacheMetadata.defaultExpectation.params != nil {
		mmSetChatCacheMetadata.mock.t.Fatalf("RepositoryMock.SetChatCacheMetadata mock is already set by Expect")
	}

	if mmSetChatCacheMetadata.defaultExpectation.paramPtrs == nil {
		mmSetChatCacheMetadata.defaultExpectation.paramPtrs = &RepositoryMockSetChatCacheMetadataParamPtrs{}
	}
	mmSetChatCacheMetadata.defaultExpectation.paramPtrs.kbUID = &kbUID
	mmSetChatCacheMetadata.defaultExpectation.expectationOrigins.originKbUID = minimock.CallerInfo(1)

	return mmSetChatCacheMetadata
}

// ExpectFileUIDsParam3 sets up expected param fileUIDs for Repository.SetChatCacheMetadata
func (mmSetChatCacheMetadata *mRepositoryMockSetChatCacheMetadata) ExpectFileUIDsParam3(fileUIDs []types.FileUIDType) *mRepositoryMockSetChatCacheMetadata {
	if mmSetChatCacheMetadata.mock.funcSetChatCacheMetadata != nil {
		mmSetChatCacheMetadata.mock.t.Fatalf("RepositoryMock.SetChatCacheMetadata mock is already set by Set")
	}

	if mmSetChatCacheMetadata.defaultExpectation == nil {
		mmSetChatCacheMetadata.defaultExpectation = &RepositoryMockSetChatCacheMetadataExpectation{}
	}

	if mmSetChatCacheMetadata.defaultExpectation.params != nil {
		mmSetChatCacheMetadata.mock.t.Fatalf("RepositoryMock.SetChatCacheMetadata mock is already set by Expect")
	}

	if mmSetChatCacheMetadata.defaultExpectation.paramPtrs == nil {
		mmSetChatCacheMetadata.defaultExpectation.paramPtrs = &RepositoryMockSetChatCacheMetadataParamPtrs{}
	}
	mmSetChatCacheMetadata.defaultExpectation.paramPtrs.fileUIDs = &fileUIDs
	mmSetChatCacheMetadata.defaultExpectation.expectationOrigins.originFileUIDs = minimock.CallerInfo(1)

	return mmSetChatCacheMetadata
}

// ExpectMetadataParam4 sets up expected param metadata for Repository.SetChatCacheMetadata
func (mmSetChatCacheMetadata *mRepositoryMockSetChatCacheMetadata) ExpectMetadataParam4(metadata *mm_repository.ChatCacheMetadata) *mRepositoryMockSetChatCacheMetadata {
	if mmSetChatCacheMetadata.mock.funcSetChatCacheMetadata != nil {
		mmSetChatCacheMetadata.mock.t.Fatalf("RepositoryMock.SetChatCacheMetadata mock is already set by Set")
	}

	if mmSetChatCacheMetadata.defaultExpectation == nil {
		mmSetChatCacheMetadata.defaultExpectation = &RepositoryMockSetChatCacheMetadataExpectation{}
	}

	if mmSetChatCacheMetadata.defaultExpectation.params != nil {
		mmSetChatCacheMetadata.mock.t.Fatalf("RepositoryMock.SetChatCacheMetadata mock is already set by Expect")
	}

	if mmSetChatCacheMetadata.defaultExpectation.paramPtrs == nil {
		mmSetChatCacheMetadata.defaultExpectation.paramPtrs = &RepositoryMockSetChatCacheMetadataParamPtrs{}
	}
	mmSetChatCacheMetadata.defaultExpectation.paramPtrs.metadata = &metadata
	mmSetChatCacheMetadata.defaultExpectation.expectationOrigins.originMetadata = minimock.CallerInfo(1)

	return mmSetChatCacheMetadata
}

// ExpectTtlParam5 sets up expected param ttl for Repository.SetChatCacheMetadata
func (mmSetChatCacheMetadata *mRepositoryMockSetChatCacheMetadata) ExpectTtlParam5(ttl time.Duration) *mRepositoryMockSetChatCacheMetadata {
	if mmSetChatCacheMetadata.mock.funcSetChatCacheMetadata != nil {
		mmSetChatCacheMetadata.mock.t.Fatalf("RepositoryMock.SetChatCacheMetadata mock is already set by Set")
	}

	if mmSetChatCacheMetadata.defaultExpectation == nil {
		mmSetChatCacheMetadata.defaultExpectation = &RepositoryMockSetChatCacheMetadataExpectation{}
	}

	if mmSetChatCacheMetadata.defaultExpectation.params != nil {
		mmSetChatCacheMetadata.mock.t.Fatalf("RepositoryMock.SetChatCacheMetadata mock is already set by Expect")
	}

	if mmSetChatCacheMetadata.defaultExpectation.paramPtrs == nil {
		mmSetChatCacheMetadata.defaultExpectation.paramPtrs = &RepositoryMockSetChatCacheMetadataParamPtrs{}
	}
	mmSetChatCacheMetadata.defaultExpectation.paramPtrs.ttl = &ttl
	mmSetChatCacheMetadata.defaultExpectation.expectationOrigins.originTtl = minimock.CallerInfo(1)

	return mmSetChatCacheMetadata
}

// Inspect accepts an inspector function that has same arguments as the Repository.SetChatCacheMetadata
func (mmSetChatCacheMetadata *mRepositoryMockSetChatCacheMetadata) Inspect(f func(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType, metadata *mm_repository.ChatCacheMetadata, ttl time.Duration)) *mRepositoryMockSetChatCacheMetadata {
	if mmSetChatCacheMetadata.mock.inspectFuncSetChatCacheMetadata != nil {
		mmSetChatCacheMetadata.mock.t.Fatalf("Inspect function is already set for RepositoryMock.SetChatCacheMetadata")
	}

	mmSetChatCacheMetadata.mock.inspectFuncSetChatCacheMetadata = f

	return mmSetChatCacheMetadata
}

// Return sets up results that will be returned by Repository.SetChatCacheMetadata
func (mmSetChatCacheMetadata *mRepositoryMockSetChatCacheMetadata) Return(err error) *RepositoryMock {
	if mmSetChatCacheMetadata.mock.funcSetChatCacheMetadata != nil {
		mmSetChatCacheMetadata.mock.t.Fatalf("RepositoryMock.SetChatCacheMetadata mock is already set by Set")
	}

	if mmSetChatCacheMetadata.defaultExpectation == nil {
		mmSetChatCacheMetadata.defaultExpectation = &RepositoryMockSetChatCacheMetadataExpectation{mock: mmSetChatCacheMetadata.mock}
	}
	mmSetChatCacheMetadata.defaultExpectation.results = &RepositoryMockSetChatCacheMetadataResults{err}
	mmSetChatCacheMetadata.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetChatCacheMetadata.mock
}

// Set uses given function f to mock the Repository.SetChatCacheMetadata method
func (mmSetChatCacheMetadata *mRepositoryMockSetChatCacheMetadata) Set(f func(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType, metadata *mm_repository.ChatCacheMetadata, ttl time.Duration) (err error)) *RepositoryMock {
	if mmSetChatCacheMetadata.defaultExpectation != nil {
		mmSetChatCacheMetadata.mock.t.Fatalf("Default expectation is already set for the Repository.SetChatCacheMetadata method")
	}

	if len(mmSetChatCacheMetadata.expectations) > 0 {
		mmSetChatCacheMetadata.mock.t.Fatalf("Some expectations are already set for the Repository.SetChatCacheMetadata method")
	}

	mmSetChatCacheMetadata.mock.funcSetChatCacheMetadata = f
	mmSetChatCacheMetadata.mock.funcSetChatCacheMetadataOrigin = minimock.CallerInfo(1)
	return mmSetChatCacheMetadata.mock
}

// When sets expectation for the Repository.SetChatCacheMetadata which will trigger the result defined by the following
// Then helper
func (mmSetChatCacheMetadata *mRepositoryMockSetChatCacheMetadata) When(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType, metadata *mm_repository.ChatCacheMetadata, ttl time.Duration) *RepositoryMockSetChatCacheMetadataExpectation {
	if mmSetChatCacheMetadata.mock.funcSetChatCacheMetadata != nil {
		mmSetChatCacheMetadata.mock.t.Fatalf("RepositoryMock.SetChatCacheMetadata mock is already set by Set")
	}

	expectation := &RepositoryMockSetChatCacheMetadataExpectation{
		mock:               mmSetChatCacheMetadata.mock,
		params:             &RepositoryMockSetChatCacheMetadataParams{ctx, kbUID, fileUIDs, metadata, ttl},
		expectationOrigins: RepositoryMockSetChatCacheMetadataExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetChatCacheMetadata.expectations = append(mmSetChatCacheMetadata.expectations, expectation)
	return expectation
}

// Then sets up Repository.SetChatCacheMetadata return parameters for the expectation previously defined by the When method
func (e *RepositoryMockSetChatCacheMetadataExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockSetChatCacheMetadataResults{err}
	return e.mock
}

// Times sets number of times Repository.SetChatCacheMetadata should be invoked
func (mmSetChatCacheMetadata *mRepositoryMockSetChatCacheMetadata) Times(n uint64) *mRepositoryMockSetChatCacheMetadata {
	if n == 0 {
		mmSetChatCacheMetadata.mock.t.Fatalf("Times of RepositoryMock.SetChatCacheMetadata mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetChatCacheMetadata.expectedInvocations, n)
	mmSetChatCacheMetadata.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetChatCacheMetadata
}

func (mmSetChatCacheMetadata *mRepositoryMockSetChatCacheMetadata) invocationsDone() bool {
	if len(mmSetChatCacheMetadata.expectations) == 0 && mmSetChatCacheMetadata.defaultExpectation == nil && mmSetChatCacheMetadata.mock.funcSetChatCacheMetadata == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetChatCacheMetadata.mock.afterSetChatCacheMetadataCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetChatCacheMetadata.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetChatCacheMetadata implements mm_repository.Repository
func (mmSetChatCacheMetadata *RepositoryMock) SetChatCacheMetadata(ctx context.Context, kbUID types.KBUIDType, fileUIDs []types.FileUIDType, metadata *mm_repository.ChatCacheMetadata, ttl time.Duration) (err error) {
	mm_atomic.AddUint64(&mmSetChatCacheMetadata.beforeSetChatCacheMetadataCounter, 1)
	defer mm_atomic.AddUint64(&mmSetChatCacheMetadata.afterSetChatCacheMetadataCounter, 1)

	mmSetChatCacheMetadata.t.Helper()

	if mmSetChatCacheMetadata.inspectFuncSetChatCacheMetadata != nil {
		mmSetChatCacheMetadata.inspectFuncSetChatCacheMetadata(ctx, kbUID, fileUIDs, metadata, ttl)
	}

	mm_params := RepositoryMockSetChatCacheMetadataParams{ctx, kbUID, fileUIDs, metadata, ttl}

	// Record call args
	mmSetChatCacheMetadata.SetChatCacheMetadataMock.mutex.Lock()
	mmSetChatCacheMetadata.SetChatCacheMetadataMock.callArgs = append(mmSetChatCacheMetadata.SetChatCacheMetadataMock.callArgs, &mm_params)
	mmSetChatCacheMetadata.SetChatCacheMetadataMock.mutex.Unlock()

	for _, e := range mmSetChatCacheMetadata.SetChatCacheMetadataMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetChatCacheMetadata.SetChatCacheMetadataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetChatCacheMetadata.SetChatCacheMetadataMock.defaultExpectation.Counter, 1)
		mm_want := mmSetChatCacheMetadata.SetChatCacheMetadataMock.defaultExpectation.params
		mm_want_ptrs := mmSetChatCacheMetadata.SetChatCacheMetadataMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockSetChatCacheMetadataParams{ctx, kbUID, fileUIDs, metadata, ttl}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetChatCacheMetadata.t.Errorf("RepositoryMock.SetChatCacheMetadata got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetChatCacheMetadata.SetChatCacheMetadataMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.kbUID != nil && !minimock.Equal(*mm_want_ptrs.kbUID, mm_got.kbUID) {
				mmSetChatCacheMetadata.t.Errorf("RepositoryMock.SetChatCacheMetadata got unexpected parameter kbUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetChatCacheMetadata.SetChatCacheMetadataMock.defaultExpectation.expectationOrigins.originKbUID, *mm_want_ptrs.kbUID, mm_got.kbUID, minimock.Diff(*mm_want_ptrs.kbUID, mm_got.kbUID))
			}

			if mm_want_ptrs.fileUIDs != nil && !minimock.Equal(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs) {
				mmSetChatCacheMetadata.t.Errorf("RepositoryMock.SetChatCacheMetadata got unexpected parameter fileUIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetChatCacheMetadata.SetChatCacheMetadataMock.defaultExpectation.expectationOrigins.originFileUIDs, *mm_want_ptrs.fileUIDs, mm_got.fileUIDs, minimock.Diff(*mm_want_ptrs.fileUIDs, mm_got.fileUIDs))
			}

			if mm_want_ptrs.metadata != nil && !minimock.Equal(*mm_want_ptrs.metadata, mm_got.metadata) {
				mmSetChatCacheMetadata.t.Errorf("RepositoryMock.SetChatCacheMetadata got unexpected parameter metadata, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetChatCacheMetadata.SetChatCacheMetadataMock.defaultExpectation.expectationOrigins.originMetadata, *mm_want_ptrs.metadata, mm_got.metadata, minimock.Diff(*mm_want_ptrs.metadata, mm_got.metadata))
			}

			if mm_want_ptrs.ttl != nil && !minimock.Equal(*mm_want_ptrs.ttl, mm_got.ttl) {
				mmSetChatCacheMetadata.t.Errorf("RepositoryMock.SetChatCacheMetadata got unexpected parameter ttl, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetChatCacheMetadata.SetChatCacheMetadataMock.defaultExpectation.expectationOrigins.originTtl, *mm_want_ptrs.ttl, mm_got.ttl, minimock.Diff(*mm_want_ptrs.ttl, mm_got.ttl))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetChatCacheMetadata.t.Errorf("RepositoryMock.SetChatCacheMetadata got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetChatCacheMetadata.SetChatCacheMetadataMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetChatCacheMetadata.SetChatCacheMetadataMock.defaultExpectation.results
		if mm_results == nil {
			mmSetChatCacheMetadata.t.Fatal("No results are set for the RepositoryMock.SetChatCacheMetadata")
		}
		return (*mm_results).err
	}
	if mmSetChatCacheMetadata.funcSetChatCacheMetadata != nil {
		return mmSetChatCacheMetadata.funcSetChatCacheMetadata(ctx, kbUID, fileUIDs, metadata, ttl)
	}
	mmSetChatCacheMetadata.t.Fatalf("Unexpected call to RepositoryMock.SetChatCacheMetadata. %v %v %v %v %v", ctx, kbUID, fileUIDs, metadata, ttl)
	return
}

// SetChatCacheMetadataAfterCounter returns a count of finished RepositoryMock.SetChatCacheMetadata invocations
func (mmSetChatCacheMetadata *RepositoryMock) SetChatCacheMetadataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetChatCacheMetadata.afterSetChatCacheMetadataCounter)
}

// SetChatCacheMetadataBeforeCounter returns a count of RepositoryMock.SetChatCacheMetadata invocations
func (mmSetChatCacheMetadata *RepositoryMock) SetChatCacheMetadataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetChatCacheMetadata.beforeSetChatCacheMetadataCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.SetChatCacheMetadata.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetChatCacheMetadata *mRepositoryMockSetChatCacheMetadata) Calls() []*RepositoryMockSetChatCacheMetadataParams {
	mmSetChatCacheMetadata.mutex.RLock()

	argCopy := make([]*RepositoryMockSetChatCacheMetadataParams, len(mmSetChatCacheMetadata.callArgs))
	copy(argCopy, mmSetChatCacheMetadata.callArgs)

	mmSetChatCacheMetadata.mutex.RUnlock()

	return argCopy
}

// MinimockSetChatCacheMetadataDone returns true if the count of the SetChatCacheMetadata invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockSetChatCacheMetadataDone() bool {
	if m.SetChatCacheMetadataMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetChatCacheMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetChatCacheMetadataMock.invocationsDone()
}

// MinimockSetChatCacheMetadataInspect logs each unmet expectation
func (m *RepositoryMock) MinimockSetChatCacheMetadataInspect() {
	for _, e := range m.SetChatCacheMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.SetChatCacheMetadata at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetChatCacheMetadataCounter := mm_atomic.LoadUint64(&m.afterSetChatCacheMetadataCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetChatCacheMetadataMock.defaultExpectation != nil && afterSetChatCacheMetadataCounter < 1 {
		if m.SetChatCacheMetadataMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.SetChatCacheMetadata at\n%s", m.SetChatCacheMetadataMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.SetChatCacheMetadata at\n%s with params: %#v", m.SetChatCacheMetadataMock.defaultExpectation.expectationOrigins.origin, *m.SetChatCacheMetadataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetChatCacheMetadata != nil && afterSetChatCacheMetadataCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.SetChatCacheMetadata at\n%s", m.funcSetChatCacheMetadataOrigin)
	}

	if !m.SetChatCacheMetadataMock.invocationsDone() && afterSetChatCacheMetadataCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.SetChatCacheMetadata at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetChatCacheMetadataMock.expectedInvocations), m.SetChatCacheMetadataMock.expectedInvocationsOrigin, afterSetChatCacheMetadataCounter)
	}
}

type mRepositoryMockSimilarVectorsInCollection struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockSimilarVectorsInCollectionExpectation
	expectations       []*RepositoryMockSimilarVectorsInCollectionExpectation

	callArgs []*RepositoryMockSimilarVectorsInCollectionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockSimilarVectorsInCollectionExpectation specifies expectation struct of the Repository.SimilarVectorsInCollection
type RepositoryMockSimilarVectorsInCollectionExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockSimilarVectorsInCollectionParams
	paramPtrs          *RepositoryMockSimilarVectorsInCollectionParamPtrs
	expectationOrigins RepositoryMockSimilarVectorsInCollectionExpectationOrigins
	results            *RepositoryMockSimilarVectorsInCollectionResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockSimilarVectorsInCollectionParams contains parameters of the Repository.SimilarVectorsInCollection
type RepositoryMockSimilarVectorsInCollectionParams struct {
	ctx context.Context
	s1  mm_repository.SimilarVectorSearchParam
}

// RepositoryMockSimilarVectorsInCollectionParamPtrs contains pointers to parameters of the Repository.SimilarVectorsInCollection
type RepositoryMockSimilarVectorsInCollectionParamPtrs struct {
	ctx *context.Context
	s1  *mm_repository.SimilarVectorSearchParam
}

// RepositoryMockSimilarVectorsInCollectionResults contains results of the Repository.SimilarVectorsInCollection
type RepositoryMockSimilarVectorsInCollectionResults struct {
	saa1 [][]mm_repository.SimilarVectorEmbedding
	err  error
}

// RepositoryMockSimilarVectorsInCollectionOrigins contains origins of expectations of the Repository.SimilarVectorsInCollection
type RepositoryMockSimilarVectorsInCollectionExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSimilarVectorsInCollection *mRepositoryMockSimilarVectorsInCollection) Optional() *mRepositoryMockSimilarVectorsInCollection {
	mmSimilarVectorsInCollection.optional = true
	return mmSimilarVectorsInCollection
}

// Expect sets up expected params for Repository.SimilarVectorsInCollection
func (mmSimilarVectorsInCollection *mRepositoryMockSimilarVectorsInCollection) Expect(ctx context.Context, s1 mm_repository.SimilarVectorSearchParam) *mRepositoryMockSimilarVectorsInCollection {
	if mmSimilarVectorsInCollection.mock.funcSimilarVectorsInCollection != nil {
		mmSimilarVectorsInCollection.mock.t.Fatalf("RepositoryMock.SimilarVectorsInCollection mock is already set by Set")
	}

	if mmSimilarVectorsInCollection.defaultExpectation == nil {
		mmSimilarVectorsInCollection.defaultExpectation = &RepositoryMockSimilarVectorsInCollectionExpectation{}
	}

	if mmSimilarVectorsInCollection.defaultExpectation.paramPtrs != nil {
		mmSimilarVectorsInCollection.mock.t.Fatalf("RepositoryMock.SimilarVectorsInCollection mock is already set by ExpectParams functions")
	}

	mmSimilarVectorsInCollection.defaultExpectation.params = &RepositoryMockSimilarVectorsInCollectionParams{ctx, s1}
	mmSimilarVectorsInCollection.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSimilarVectorsInCollection.expectations {
		if minimock.Equal(e.params, mmSimilarVectorsInCollection.defaultExpectation.params) {
			mmSimilarVectorsInCollection.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSimilarVectorsInCollection.defaultExpectation.params)
		}
	}

	return mmSimilarVectorsInCollection
}

// ExpectCtxParam1 sets up expected param ctx for Repository.SimilarVectorsInCollection
func (mmSimilarVectorsInCollection *mRepositoryMockSimilarVectorsInCollection) ExpectCtxParam1(ctx context.Context) *mRepositoryMockSimilarVectorsInCollection {
	if mmSimilarVectorsInCollection.mock.funcSimilarVectorsInCollection != nil {
		mmSimilarVectorsInCollection.mock.t.Fatalf("RepositoryMock.SimilarVectorsInCollection mock is already set by Set")
	}

	if mmSimilarVectorsInCollection.defaultExpectation == nil {
		mmSimilarVectorsInCollection.defaultExpectation = &RepositoryMockSimilarVectorsInCollectionExpectation{}
	}

	if mmSimilarVectorsInCollection.defaultExpectation.params != nil {
		mmSimilarVectorsInCollection.mock.t.Fatalf("RepositoryMock.SimilarVectorsInCollection mock is already set by Expect")
	}

	if mmSimilarVectorsInCollection.defaultExpectation.paramPtrs == nil {
		mmSimilarVectorsInCollection.defaultExpectation.paramPtrs = &RepositoryMockSimilarVectorsInCollectionParamPtrs{}
	}
	mmSimilarVectorsInCollection.defaultExpectation.paramPtrs.ctx = &ctx
	mmSimilarVectorsInCollection.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSimilarVectorsInCollection
}

// ExpectS1Param2 sets up expected param s1 for Repository.SimilarVectorsInCollection
func (mmSimilarVectorsInCollection *mRepositoryMockSimilarVectorsInCollection) ExpectS1Param2(s1 mm_repository.SimilarVectorSearchParam) *mRepositoryMockSimilarVectorsInCollection {
	if mmSimilarVectorsInCollection.mock.funcSimilarVectorsInCollection != nil {
		mmSimilarVectorsInCollection.mock.t.Fatalf("RepositoryMock.SimilarVectorsInCollection mock is already set by Set")
	}

	if mmSimilarVectorsInCollection.defaultExpectation == nil {
		mmSimilarVectorsInCollection.defaultExpectation = &RepositoryMockSimilarVectorsInCollectionExpectation{}
	}

	if mmSimilarVectorsInCollection.defaultExpectation.params != nil {
		mmSimilarVectorsInCollection.mock.t.Fatalf("RepositoryMock.SimilarVectorsInCollection mock is already set by Expect")
	}

	if mmSimilarVectorsInCollection.defaultExpectation.paramPtrs == nil {
		mmSimilarVectorsInCollection.defaultExpectation.paramPtrs = &RepositoryMockSimilarVectorsInCollectionParamPtrs{}
	}
	mmSimilarVectorsInCollection.defaultExpectation.paramPtrs.s1 = &s1
	mmSimilarVectorsInCollection.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmSimilarVectorsInCollection
}

// Inspect accepts an inspector function that has same arguments as the Repository.SimilarVectorsInCollection
func (mmSimilarVectorsInCollection *mRepositoryMockSimilarVectorsInCollection) Inspect(f func(ctx context.Context, s1 mm_repository.SimilarVectorSearchParam)) *mRepositoryMockSimilarVectorsInCollection {
	if mmSimilarVectorsInCollection.mock.inspectFuncSimilarVectorsInCollection != nil {
		mmSimilarVectorsInCollection.mock.t.Fatalf("Inspect function is already set for RepositoryMock.SimilarVectorsInCollection")
	}

	mmSimilarVectorsInCollection.mock.inspectFuncSimilarVectorsInCollection = f

	return mmSimilarVectorsInCollection
}

// Return sets up results that will be returned by Repository.SimilarVectorsInCollection
func (mmSimilarVectorsInCollection *mRepositoryMockSimilarVectorsInCollection) Return(saa1 [][]mm_repository.SimilarVectorEmbedding, err error) *RepositoryMock {
	if mmSimilarVectorsInCollection.mock.funcSimilarVectorsInCollection != nil {
		mmSimilarVectorsInCollection.mock.t.Fatalf("RepositoryMock.SimilarVectorsInCollection mock is already set by Set")
	}

	if mmSimilarVectorsInCollection.defaultExpectation == nil {
		mmSimilarVectorsInCollection.defaultExpectation = &RepositoryMockSimilarVectorsInCollectionExpectation{mock: mmSimilarVectorsInCollection.mock}
	}
	mmSimilarVectorsInCollection.defaultExpectation.results = &RepositoryMockSimilarVectorsInCollectionResults{saa1, err}
	mmSimilarVectorsInCollection.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSimilarVectorsInCollection.mock
}

// Set uses given function f to mock the Repository.SimilarVectorsInCollection method
func (mmSimilarVectorsInCollection *mRepositoryMockSimilarVectorsInCollection) Set(f func(ctx context.Context, s1 mm_repository.SimilarVectorSearchParam) (saa1 [][]mm_repository.SimilarVectorEmbedding, err error)) *RepositoryMock {
	if mmSimilarVectorsInCollection.defaultExpectation != nil {
		mmSimilarVectorsInCollection.mock.t.Fatalf("Default expectation is already set for the Repository.SimilarVectorsInCollection method")
	}

	if len(mmSimilarVectorsInCollection.expectations) > 0 {
		mmSimilarVectorsInCollection.mock.t.Fatalf("Some expectations are already set for the Repository.SimilarVectorsInCollection method")
	}

	mmSimilarVectorsInCollection.mock.funcSimilarVectorsInCollection = f
	mmSimilarVectorsInCollection.mock.funcSimilarVectorsInCollectionOrigin = minimock.CallerInfo(1)
	return mmSimilarVectorsInCollection.mock
}

// When sets expectation for the Repository.SimilarVectorsInCollection which will trigger the result defined by the following
// Then helper
func (mmSimilarVectorsInCollection *mRepositoryMockSimilarVectorsInCollection) When(ctx context.Context, s1 mm_repository.SimilarVectorSearchParam) *RepositoryMockSimilarVectorsInCollectionExpectation {
	if mmSimilarVectorsInCollection.mock.funcSimilarVectorsInCollection != nil {
		mmSimilarVectorsInCollection.mock.t.Fatalf("RepositoryMock.SimilarVectorsInCollection mock is already set by Set")
	}

	expectation := &RepositoryMockSimilarVectorsInCollectionExpectation{
		mock:               mmSimilarVectorsInCollection.mock,
		params:             &RepositoryMockSimilarVectorsInCollectionParams{ctx, s1},
		expectationOrigins: RepositoryMockSimilarVectorsInCollectionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSimilarVectorsInCollection.expectations = append(mmSimilarVectorsInCollection.expectations, expectation)
	return expectation
}

// Then sets up Repository.SimilarVectorsInCollection return parameters for the expectation previously defined by the When method
func (e *RepositoryMockSimilarVectorsInCollectionExpectation) Then(saa1 [][]mm_repository.SimilarVectorEmbedding, err error) *RepositoryMock {
	e.results = &RepositoryMockSimilarVectorsInCollectionResults{saa1, err}
	return e.mock
}

// Times sets number of times Repository.SimilarVectorsInCollection should be invoked
func (mmSimilarVectorsInCollection *mRepositoryMockSimilarVectorsInCollection) Times(n uint64) *mRepositoryMockSimilarVectorsInCollection {
	if n == 0 {
		mmSimilarVectorsInCollection.mock.t.Fatalf("Times of RepositoryMock.SimilarVectorsInCollection mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSimilarVectorsInCollection.expectedInvocations, n)
	mmSimilarVectorsInCollection.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSimilarVectorsInCollection
}

func (mmSimilarVectorsInCollection *mRepositoryMockSimilarVectorsInCollection) invocationsDone() bool {
	if len(mmSimilarVectorsInCollection.expectations) == 0 && mmSimilarVectorsInCollection.defaultExpectation == nil && mmSimilarVectorsInCollection.mock.funcSimilarVectorsInCollection == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSimilarVectorsInCollection.mock.afterSimilarVectorsInCollectionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSimilarVectorsInCollection.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SimilarVectorsInCollection implements mm_repository.Repository
func (mmSimilarVectorsInCollection *RepositoryMock) SimilarVectorsInCollection(ctx context.Context, s1 mm_repository.SimilarVectorSearchParam) (saa1 [][]mm_repository.SimilarVectorEmbedding, err error) {
	mm_atomic.AddUint64(&mmSimilarVectorsInCollection.beforeSimilarVectorsInCollectionCounter, 1)
	defer mm_atomic.AddUint64(&mmSimilarVectorsInCollection.afterSimilarVectorsInCollectionCounter, 1)

	mmSimilarVectorsInCollection.t.Helper()

	if mmSimilarVectorsInCollection.inspectFuncSimilarVectorsInCollection != nil {
		mmSimilarVectorsInCollection.inspectFuncSimilarVectorsInCollection(ctx, s1)
	}

	mm_params := RepositoryMockSimilarVectorsInCollectionParams{ctx, s1}

	// Record call args
	mmSimilarVectorsInCollection.SimilarVectorsInCollectionMock.mutex.Lock()
	mmSimilarVectorsInCollection.SimilarVectorsInCollectionMock.callArgs = append(mmSimilarVectorsInCollection.SimilarVectorsInCollectionMock.callArgs, &mm_params)
	mmSimilarVectorsInCollection.SimilarVectorsInCollectionMock.mutex.Unlock()

	for _, e := range mmSimilarVectorsInCollection.SimilarVectorsInCollectionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.saa1, e.results.err
		}
	}

	if mmSimilarVectorsInCollection.SimilarVectorsInCollectionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSimilarVectorsInCollection.SimilarVectorsInCollectionMock.defaultExpectation.Counter, 1)
		mm_want := mmSimilarVectorsInCollection.SimilarVectorsInCollectionMock.defaultExpectation.params
		mm_want_ptrs := mmSimilarVectorsInCollection.SimilarVectorsInCollectionMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockSimilarVectorsInCollectionParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSimilarVectorsInCollection.t.Errorf("RepositoryMock.SimilarVectorsInCollection got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSimilarVectorsInCollection.SimilarVectorsInCollectionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmSimilarVectorsInCollection.t.Errorf("RepositoryMock.SimilarVectorsInCollection got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSimilarVectorsInCollection.SimilarVectorsInCollectionMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSimilarVectorsInCollection.t.Errorf("RepositoryMock.SimilarVectorsInCollection got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSimilarVectorsInCollection.SimilarVectorsInCollectionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSimilarVectorsInCollection.SimilarVectorsInCollectionMock.defaultExpectation.results
		if mm_results == nil {
			mmSimilarVectorsInCollection.t.Fatal("No results are set for the RepositoryMock.SimilarVectorsInCollection")
		}
		return (*mm_results).saa1, (*mm_results).err
	}
	if mmSimilarVectorsInCollection.funcSimilarVectorsInCollection != nil {
		return mmSimilarVectorsInCollection.funcSimilarVectorsInCollection(ctx, s1)
	}
	mmSimilarVectorsInCollection.t.Fatalf("Unexpected call to RepositoryMock.SimilarVectorsInCollection. %v %v", ctx, s1)
	return
}

// SimilarVectorsInCollectionAfterCounter returns a count of finished RepositoryMock.SimilarVectorsInCollection invocations
func (mmSimilarVectorsInCollection *RepositoryMock) SimilarVectorsInCollectionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSimilarVectorsInCollection.afterSimilarVectorsInCollectionCounter)
}

// SimilarVectorsInCollectionBeforeCounter returns a count of RepositoryMock.SimilarVectorsInCollection invocations
func (mmSimilarVectorsInCollection *RepositoryMock) SimilarVectorsInCollectionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSimilarVectorsInCollection.beforeSimilarVectorsInCollectionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.SimilarVectorsInCollection.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSimilarVectorsInCollection *mRepositoryMockSimilarVectorsInCollection) Calls() []*RepositoryMockSimilarVectorsInCollectionParams {
	mmSimilarVectorsInCollection.mutex.RLock()

	argCopy := make([]*RepositoryMockSimilarVectorsInCollectionParams, len(mmSimilarVectorsInCollection.callArgs))
	copy(argCopy, mmSimilarVectorsInCollection.callArgs)

	mmSimilarVectorsInCollection.mutex.RUnlock()

	return argCopy
}

// MinimockSimilarVectorsInCollectionDone returns true if the count of the SimilarVectorsInCollection invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockSimilarVectorsInCollectionDone() bool {
	if m.SimilarVectorsInCollectionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SimilarVectorsInCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SimilarVectorsInCollectionMock.invocationsDone()
}

// MinimockSimilarVectorsInCollectionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockSimilarVectorsInCollectionInspect() {
	for _, e := range m.SimilarVectorsInCollectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.SimilarVectorsInCollection at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSimilarVectorsInCollectionCounter := mm_atomic.LoadUint64(&m.afterSimilarVectorsInCollectionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SimilarVectorsInCollectionMock.defaultExpectation != nil && afterSimilarVectorsInCollectionCounter < 1 {
		if m.SimilarVectorsInCollectionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.SimilarVectorsInCollection at\n%s", m.SimilarVectorsInCollectionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.SimilarVectorsInCollection at\n%s with params: %#v", m.SimilarVectorsInCollectionMock.defaultExpectation.expectationOrigins.origin, *m.SimilarVectorsInCollectionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSimilarVectorsInCollection != nil && afterSimilarVectorsInCollectionCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.SimilarVectorsInCollection at\n%s", m.funcSimilarVectorsInCollectionOrigin)
	}

	if !m.SimilarVectorsInCollectionMock.invocationsDone() && afterSimilarVectorsInCollectionCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.SimilarVectorsInCollection at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SimilarVectorsInCollectionMock.expectedInvocations), m.SimilarVectorsInCollectionMock.expectedInvocationsOrigin, afterSimilarVectorsInCollectionCounter)
	}
}

type mRepositoryMockUpdateConvertedFile struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateConvertedFileExpectation
	expectations       []*RepositoryMockUpdateConvertedFileExpectation

	callArgs []*RepositoryMockUpdateConvertedFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateConvertedFileExpectation specifies expectation struct of the Repository.UpdateConvertedFile
type RepositoryMockUpdateConvertedFileExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateConvertedFileParams
	paramPtrs          *RepositoryMockUpdateConvertedFileParamPtrs
	expectationOrigins RepositoryMockUpdateConvertedFileExpectationOrigins
	results            *RepositoryMockUpdateConvertedFileResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateConvertedFileParams contains parameters of the Repository.UpdateConvertedFile
type RepositoryMockUpdateConvertedFileParams struct {
	ctx    context.Context
	uid    types.ConvertedFileUIDType
	update map[string]any
}

// RepositoryMockUpdateConvertedFileParamPtrs contains pointers to parameters of the Repository.UpdateConvertedFile
type RepositoryMockUpdateConvertedFileParamPtrs struct {
	ctx    *context.Context
	uid    *types.ConvertedFileUIDType
	update *map[string]any
}

// RepositoryMockUpdateConvertedFileResults contains results of the Repository.UpdateConvertedFile
type RepositoryMockUpdateConvertedFileResults struct {
	err error
}

// RepositoryMockUpdateConvertedFileOrigins contains origins of expectations of the Repository.UpdateConvertedFile
type RepositoryMockUpdateConvertedFileExpectationOrigins struct {
	origin       string
	originCtx    string
	originUid    string
	originUpdate string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateConvertedFile *mRepositoryMockUpdateConvertedFile) Optional() *mRepositoryMockUpdateConvertedFile {
	mmUpdateConvertedFile.optional = true
	return mmUpdateConvertedFile
}

// Expect sets up expected params for Repository.UpdateConvertedFile
func (mmUpdateConvertedFile *mRepositoryMockUpdateConvertedFile) Expect(ctx context.Context, uid types.ConvertedFileUIDType, update map[string]any) *mRepositoryMockUpdateConvertedFile {
	if mmUpdateConvertedFile.mock.funcUpdateConvertedFile != nil {
		mmUpdateConvertedFile.mock.t.Fatalf("RepositoryMock.UpdateConvertedFile mock is already set by Set")
	}

	if mmUpdateConvertedFile.defaultExpectation == nil {
		mmUpdateConvertedFile.defaultExpectation = &RepositoryMockUpdateConvertedFileExpectation{}
	}

	if mmUpdateConvertedFile.defaultExpectation.paramPtrs != nil {
		mmUpdateConvertedFile.mock.t.Fatalf("RepositoryMock.UpdateConvertedFile mock is already set by ExpectParams functions")
	}

	mmUpdateConvertedFile.defaultExpectation.params = &RepositoryMockUpdateConvertedFileParams{ctx, uid, update}
	mmUpdateConvertedFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateConvertedFile.expectations {
		if minimock.Equal(e.params, mmUpdateConvertedFile.defaultExpectation.params) {
			mmUpdateConvertedFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateConvertedFile.defaultExpectation.params)
		}
	}

	return mmUpdateConvertedFile
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateConvertedFile
func (mmUpdateConvertedFile *mRepositoryMockUpdateConvertedFile) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateConvertedFile {
	if mmUpdateConvertedFile.mock.funcUpdateConvertedFile != nil {
		mmUpdateConvertedFile.mock.t.Fatalf("RepositoryMock.UpdateConvertedFile mock is already set by Set")
	}

	if mmUpdateConvertedFile.defaultExpectation == nil {
		mmUpdateConvertedFile.defaultExpectation = &RepositoryMockUpdateConvertedFileExpectation{}
	}

	if mmUpdateConvertedFile.defaultExpectation.params != nil {
		mmUpdateConvertedFile.mock.t.Fatalf("RepositoryMock.UpdateConvertedFile mock is already set by Expect")
	}

	if mmUpdateConvertedFile.defaultExpectation.paramPtrs == nil {
		mmUpdateConvertedFile.defaultExpectation.paramPtrs = &RepositoryMockUpdateConvertedFileParamPtrs{}
	}
	mmUpdateConvertedFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateConvertedFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateConvertedFile
}

// ExpectUidParam2 sets up expected param uid for Repository.UpdateConvertedFile
func (mmUpdateConvertedFile *mRepositoryMockUpdateConvertedFile) ExpectUidParam2(uid types.ConvertedFileUIDType) *mRepositoryMockUpdateConvertedFile {
	if mmUpdateConvertedFile.mock.funcUpdateConvertedFile != nil {
		mmUpdateConvertedFile.mock.t.Fatalf("RepositoryMock.UpdateConvertedFile mock is already set by Set")
	}

	if mmUpdateConvertedFile.defaultExpectation == nil {
		mmUpdateConvertedFile.defaultExpectation = &RepositoryMockUpdateConvertedFileExpectation{}
	}

	if mmUpdateConvertedFile.defaultExpectation.params != nil {
		mmUpdateConvertedFile.mock.t.Fatalf("RepositoryMock.UpdateConvertedFile mock is already set by Expect")
	}

	if mmUpdateConvertedFile.defaultExpectation.paramPtrs == nil {
		mmUpdateConvertedFile.defaultExpectation.paramPtrs = &RepositoryMockUpdateConvertedFileParamPtrs{}
	}
	mmUpdateConvertedFile.defaultExpectation.paramPtrs.uid = &uid
	mmUpdateConvertedFile.defaultExpectation.expectationOrigins.originUid = minimock.CallerInfo(1)

	return mmUpdateConvertedFile
}

// ExpectUpdateParam3 sets up expected param update for Repository.UpdateConvertedFile
func (mmUpdateConvertedFile *mRepositoryMockUpdateConvertedFile) ExpectUpdateParam3(update map[string]any) *mRepositoryMockUpdateConvertedFile {
	if mmUpdateConvertedFile.mock.funcUpdateConvertedFile != nil {
		mmUpdateConvertedFile.mock.t.Fatalf("RepositoryMock.UpdateConvertedFile mock is already set by Set")
	}

	if mmUpdateConvertedFile.defaultExpectation == nil {
		mmUpdateConvertedFile.defaultExpectation = &RepositoryMockUpdateConvertedFileExpectation{}
	}

	if mmUpdateConvertedFile.defaultExpectation.params != nil {
		mmUpdateConvertedFile.mock.t.Fatalf("RepositoryMock.UpdateConvertedFile mock is already set by Expect")
	}

	if mmUpdateConvertedFile.defaultExpectation.paramPtrs == nil {
		mmUpdateConvertedFile.defaultExpectation.paramPtrs = &RepositoryMockUpdateConvertedFileParamPtrs{}
	}
	mmUpdateConvertedFile.defaultExpectation.paramPtrs.update = &update
	mmUpdateConvertedFile.defaultExpectation.expectationOrigins.originUpdate = minimock.CallerInfo(1)

	return mmUpdateConvertedFile
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateConvertedFile
func (mmUpdateConvertedFile *mRepositoryMockUpdateConvertedFile) Inspect(f func(ctx context.Context, uid types.ConvertedFileUIDType, update map[string]any)) *mRepositoryMockUpdateConvertedFile {
	if mmUpdateConvertedFile.mock.inspectFuncUpdateConvertedFile != nil {
		mmUpdateConvertedFile.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateConvertedFile")
	}

	mmUpdateConvertedFile.mock.inspectFuncUpdateConvertedFile = f

	return mmUpdateConvertedFile
}

// Return sets up results that will be returned by Repository.UpdateConvertedFile
func (mmUpdateConvertedFile *mRepositoryMockUpdateConvertedFile) Return(err error) *RepositoryMock {
	if mmUpdateConvertedFile.mock.funcUpdateConvertedFile != nil {
		mmUpdateConvertedFile.mock.t.Fatalf("RepositoryMock.UpdateConvertedFile mock is already set by Set")
	}

	if mmUpdateConvertedFile.defaultExpectation == nil {
		mmUpdateConvertedFile.defaultExpectation = &RepositoryMockUpdateConvertedFileExpectation{mock: mmUpdateConvertedFile.mock}
	}
	mmUpdateConvertedFile.defaultExpectation.results = &RepositoryMockUpdateConvertedFileResults{err}
	mmUpdateConvertedFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateConvertedFile.mock
}

// Set uses given function f to mock the Repository.UpdateConvertedFile method
func (mmUpdateConvertedFile *mRepositoryMockUpdateConvertedFile) Set(f func(ctx context.Context, uid types.ConvertedFileUIDType, update map[string]any) (err error)) *RepositoryMock {
	if mmUpdateConvertedFile.defaultExpectation != nil {
		mmUpdateConvertedFile.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateConvertedFile method")
	}

	if len(mmUpdateConvertedFile.expectations) > 0 {
		mmUpdateConvertedFile.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateConvertedFile method")
	}

	mmUpdateConvertedFile.mock.funcUpdateConvertedFile = f
	mmUpdateConvertedFile.mock.funcUpdateConvertedFileOrigin = minimock.CallerInfo(1)
	return mmUpdateConvertedFile.mock
}

// When sets expectation for the Repository.UpdateConvertedFile which will trigger the result defined by the following
// Then helper
func (mmUpdateConvertedFile *mRepositoryMockUpdateConvertedFile) When(ctx context.Context, uid types.ConvertedFileUIDType, update map[string]any) *RepositoryMockUpdateConvertedFileExpectation {
	if mmUpdateConvertedFile.mock.funcUpdateConvertedFile != nil {
		mmUpdateConvertedFile.mock.t.Fatalf("RepositoryMock.UpdateConvertedFile mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateConvertedFileExpectation{
		mock:               mmUpdateConvertedFile.mock,
		params:             &RepositoryMockUpdateConvertedFileParams{ctx, uid, update},
		expectationOrigins: RepositoryMockUpdateConvertedFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateConvertedFile.expectations = append(mmUpdateConvertedFile.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateConvertedFile return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateConvertedFileExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateConvertedFileResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateConvertedFile should be invoked
func (mmUpdateConvertedFile *mRepositoryMockUpdateConvertedFile) Times(n uint64) *mRepositoryMockUpdateConvertedFile {
	if n == 0 {
		mmUpdateConvertedFile.mock.t.Fatalf("Times of RepositoryMock.UpdateConvertedFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateConvertedFile.expectedInvocations, n)
	mmUpdateConvertedFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateConvertedFile
}

func (mmUpdateConvertedFile *mRepositoryMockUpdateConvertedFile) invocationsDone() bool {
	if len(mmUpdateConvertedFile.expectations) == 0 && mmUpdateConvertedFile.defaultExpectation == nil && mmUpdateConvertedFile.mock.funcUpdateConvertedFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateConvertedFile.mock.afterUpdateConvertedFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateConvertedFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateConvertedFile implements mm_repository.Repository
func (mmUpdateConvertedFile *RepositoryMock) UpdateConvertedFile(ctx context.Context, uid types.ConvertedFileUIDType, update map[string]any) (err error) {
	mm_atomic.AddUint64(&mmUpdateConvertedFile.beforeUpdateConvertedFileCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateConvertedFile.afterUpdateConvertedFileCounter, 1)

	mmUpdateConvertedFile.t.Helper()

	if mmUpdateConvertedFile.inspectFuncUpdateConvertedFile != nil {
		mmUpdateConvertedFile.inspectFuncUpdateConvertedFile(ctx, uid, update)
	}

	mm_params := RepositoryMockUpdateConvertedFileParams{ctx, uid, update}

	// Record call args
	mmUpdateConvertedFile.UpdateConvertedFileMock.mutex.Lock()
	mmUpdateConvertedFile.UpdateConvertedFileMock.callArgs = append(mmUpdateConvertedFile.UpdateConvertedFileMock.callArgs, &mm_params)
	mmUpdateConvertedFile.UpdateConvertedFileMock.mutex.Unlock()

	for _, e := range mmUpdateConvertedFile.UpdateConvertedFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateConvertedFile.UpdateConvertedFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateConvertedFile.UpdateConvertedFileMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateConvertedFile.UpdateConvertedFileMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateConvertedFile.UpdateConvertedFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateConvertedFileParams{ctx, uid, update}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateConvertedFile.t.Errorf("RepositoryMock.UpdateConvertedFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateConvertedFile.UpdateConvertedFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmUpdateConvertedFile.t.Errorf("RepositoryMock.UpdateConvertedFile got unexpected parameter uid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateConvertedFile.UpdateConvertedFileMock.defaultExpectation.expectationOrigins.originUid, *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

			if mm_want_ptrs.update != nil && !minimock.Equal(*mm_want_ptrs.update, mm_got.update) {
				mmUpdateConvertedFile.t.Errorf("RepositoryMock.UpdateConvertedFile got unexpected parameter update, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateConvertedFile.UpdateConvertedFileMock.defaultExpectation.expectationOrigins.originUpdate, *mm_want_ptrs.update, mm_got.update, minimock.Diff(*mm_want_ptrs.update, mm_got.update))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateConvertedFile.t.Errorf("RepositoryMock.UpdateConvertedFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateConvertedFile.UpdateConvertedFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateConvertedFile.UpdateConvertedFileMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateConvertedFile.t.Fatal("No results are set for the RepositoryMock.UpdateConvertedFile")
		}
		return (*mm_results).err
	}
	if mmUpdateConvertedFile.funcUpdateConvertedFile != nil {
		return mmUpdateConvertedFile.funcUpdateConvertedFile(ctx, uid, update)
	}
	mmUpdateConvertedFile.t.Fatalf("Unexpected call to RepositoryMock.UpdateConvertedFile. %v %v %v", ctx, uid, update)
	return
}

// UpdateConvertedFileAfterCounter returns a count of finished RepositoryMock.UpdateConvertedFile invocations
func (mmUpdateConvertedFile *RepositoryMock) UpdateConvertedFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateConvertedFile.afterUpdateConvertedFileCounter)
}

// UpdateConvertedFileBeforeCounter returns a count of RepositoryMock.UpdateConvertedFile invocations
func (mmUpdateConvertedFile *RepositoryMock) UpdateConvertedFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateConvertedFile.beforeUpdateConvertedFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateConvertedFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateConvertedFile *mRepositoryMockUpdateConvertedFile) Calls() []*RepositoryMockUpdateConvertedFileParams {
	mmUpdateConvertedFile.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateConvertedFileParams, len(mmUpdateConvertedFile.callArgs))
	copy(argCopy, mmUpdateConvertedFile.callArgs)

	mmUpdateConvertedFile.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateConvertedFileDone returns true if the count of the UpdateConvertedFile invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateConvertedFileDone() bool {
	if m.UpdateConvertedFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateConvertedFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateConvertedFileMock.invocationsDone()
}

// MinimockUpdateConvertedFileInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateConvertedFileInspect() {
	for _, e := range m.UpdateConvertedFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateConvertedFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateConvertedFileCounter := mm_atomic.LoadUint64(&m.afterUpdateConvertedFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateConvertedFileMock.defaultExpectation != nil && afterUpdateConvertedFileCounter < 1 {
		if m.UpdateConvertedFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateConvertedFile at\n%s", m.UpdateConvertedFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateConvertedFile at\n%s with params: %#v", m.UpdateConvertedFileMock.defaultExpectation.expectationOrigins.origin, *m.UpdateConvertedFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateConvertedFile != nil && afterUpdateConvertedFileCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateConvertedFile at\n%s", m.funcUpdateConvertedFileOrigin)
	}

	if !m.UpdateConvertedFileMock.invocationsDone() && afterUpdateConvertedFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateConvertedFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateConvertedFileMock.expectedInvocations), m.UpdateConvertedFileMock.expectedInvocationsOrigin, afterUpdateConvertedFileCounter)
	}
}

type mRepositoryMockUpdateKnowledgeBase struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateKnowledgeBaseExpectation
	expectations       []*RepositoryMockUpdateKnowledgeBaseExpectation

	callArgs []*RepositoryMockUpdateKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateKnowledgeBaseExpectation specifies expectation struct of the Repository.UpdateKnowledgeBase
type RepositoryMockUpdateKnowledgeBaseExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateKnowledgeBaseParams
	paramPtrs          *RepositoryMockUpdateKnowledgeBaseParamPtrs
	expectationOrigins RepositoryMockUpdateKnowledgeBaseExpectationOrigins
	results            *RepositoryMockUpdateKnowledgeBaseResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateKnowledgeBaseParams contains parameters of the Repository.UpdateKnowledgeBase
type RepositoryMockUpdateKnowledgeBaseParams struct {
	ctx      context.Context
	id       string
	ownerUID string
	kb       mm_repository.KnowledgeBaseModel
}

// RepositoryMockUpdateKnowledgeBaseParamPtrs contains pointers to parameters of the Repository.UpdateKnowledgeBase
type RepositoryMockUpdateKnowledgeBaseParamPtrs struct {
	ctx      *context.Context
	id       *string
	ownerUID *string
	kb       *mm_repository.KnowledgeBaseModel
}

// RepositoryMockUpdateKnowledgeBaseResults contains results of the Repository.UpdateKnowledgeBase
type RepositoryMockUpdateKnowledgeBaseResults struct {
	kp1 *mm_repository.KnowledgeBaseModel
	err error
}

// RepositoryMockUpdateKnowledgeBaseOrigins contains origins of expectations of the Repository.UpdateKnowledgeBase
type RepositoryMockUpdateKnowledgeBaseExpectationOrigins struct {
	origin         string
	originCtx      string
	originId       string
	originOwnerUID string
	originKb       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) Optional() *mRepositoryMockUpdateKnowledgeBase {
	mmUpdateKnowledgeBase.optional = true
	return mmUpdateKnowledgeBase
}

// Expect sets up expected params for Repository.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) Expect(ctx context.Context, id string, ownerUID string, kb mm_repository.KnowledgeBaseModel) *mRepositoryMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmUpdateKnowledgeBase.defaultExpectation.params = &RepositoryMockUpdateKnowledgeBaseParams{ctx, id, ownerUID, kb}
	mmUpdateKnowledgeBase.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmUpdateKnowledgeBase.defaultExpectation.params) {
			mmUpdateKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmUpdateKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.params != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by Expect")
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseParamPtrs{}
	}
	mmUpdateKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateKnowledgeBase.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBase
}

// ExpectIdParam2 sets up expected param id for Repository.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) ExpectIdParam2(id string) *mRepositoryMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.params != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by Expect")
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseParamPtrs{}
	}
	mmUpdateKnowledgeBase.defaultExpectation.paramPtrs.id = &id
	mmUpdateKnowledgeBase.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBase
}

// ExpectOwnerUIDParam3 sets up expected param ownerUID for Repository.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) ExpectOwnerUIDParam3(ownerUID string) *mRepositoryMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.params != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by Expect")
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseParamPtrs{}
	}
	mmUpdateKnowledgeBase.defaultExpectation.paramPtrs.ownerUID = &ownerUID
	mmUpdateKnowledgeBase.defaultExpectation.expectationOrigins.originOwnerUID = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBase
}

// ExpectKbParam4 sets up expected param kb for Repository.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) ExpectKbParam4(kb mm_repository.KnowledgeBaseModel) *mRepositoryMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.params != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by Expect")
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBase.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseParamPtrs{}
	}
	mmUpdateKnowledgeBase.defaultExpectation.paramPtrs.kb = &kb
	mmUpdateKnowledgeBase.defaultExpectation.expectationOrigins.originKb = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) Inspect(f func(ctx context.Context, id string, ownerUID string, kb mm_repository.KnowledgeBaseModel)) *mRepositoryMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.inspectFuncUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateKnowledgeBase")
	}

	mmUpdateKnowledgeBase.mock.inspectFuncUpdateKnowledgeBase = f

	return mmUpdateKnowledgeBase
}

// Return sets up results that will be returned by Repository.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) Return(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseExpectation{mock: mmUpdateKnowledgeBase.mock}
	}
	mmUpdateKnowledgeBase.defaultExpectation.results = &RepositoryMockUpdateKnowledgeBaseResults{kp1, err}
	mmUpdateKnowledgeBase.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBase.mock
}

// Set uses given function f to mock the Repository.UpdateKnowledgeBase method
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) Set(f func(ctx context.Context, id string, ownerUID string, kb mm_repository.KnowledgeBaseModel) (kp1 *mm_repository.KnowledgeBaseModel, err error)) *RepositoryMock {
	if mmUpdateKnowledgeBase.defaultExpectation != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateKnowledgeBase method")
	}

	if len(mmUpdateKnowledgeBase.expectations) > 0 {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateKnowledgeBase method")
	}

	mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase = f
	mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBaseOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBase.mock
}

// When sets expectation for the Repository.UpdateKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) When(ctx context.Context, id string, ownerUID string, kb mm_repository.KnowledgeBaseModel) *RepositoryMockUpdateKnowledgeBaseExpectation {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBase mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateKnowledgeBaseExpectation{
		mock:               mmUpdateKnowledgeBase.mock,
		params:             &RepositoryMockUpdateKnowledgeBaseParams{ctx, id, ownerUID, kb},
		expectationOrigins: RepositoryMockUpdateKnowledgeBaseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateKnowledgeBase.expectations = append(mmUpdateKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateKnowledgeBaseExpectation) Then(kp1 *mm_repository.KnowledgeBaseModel, err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateKnowledgeBaseResults{kp1, err}
	return e.mock
}

// Times sets number of times Repository.UpdateKnowledgeBase should be invoked
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) Times(n uint64) *mRepositoryMockUpdateKnowledgeBase {
	if n == 0 {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Times of RepositoryMock.UpdateKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateKnowledgeBase.expectedInvocations, n)
	mmUpdateKnowledgeBase.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBase
}

func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) invocationsDone() bool {
	if len(mmUpdateKnowledgeBase.expectations) == 0 && mmUpdateKnowledgeBase.defaultExpectation == nil && mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.mock.afterUpdateKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateKnowledgeBase implements mm_repository.Repository
func (mmUpdateKnowledgeBase *RepositoryMock) UpdateKnowledgeBase(ctx context.Context, id string, ownerUID string, kb mm_repository.KnowledgeBaseModel) (kp1 *mm_repository.KnowledgeBaseModel, err error) {
	mm_atomic.AddUint64(&mmUpdateKnowledgeBase.beforeUpdateKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateKnowledgeBase.afterUpdateKnowledgeBaseCounter, 1)

	mmUpdateKnowledgeBase.t.Helper()

	if mmUpdateKnowledgeBase.inspectFuncUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.inspectFuncUpdateKnowledgeBase(ctx, id, ownerUID, kb)
	}

	mm_params := RepositoryMockUpdateKnowledgeBaseParams{ctx, id, ownerUID, kb}

	// Record call args
	mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.mutex.Lock()
	mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.callArgs = append(mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.callArgs, &mm_params)
	mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateKnowledgeBaseParams{ctx, id, ownerUID, kb}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateKnowledgeBase.t.Errorf("RepositoryMock.UpdateKnowledgeBase got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateKnowledgeBase.t.Errorf("RepositoryMock.UpdateKnowledgeBase got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmUpdateKnowledgeBase.t.Errorf("RepositoryMock.UpdateKnowledgeBase got unexpected parameter ownerUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.expectationOrigins.originOwnerUID, *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

			if mm_want_ptrs.kb != nil && !minimock.Equal(*mm_want_ptrs.kb, mm_got.kb) {
				mmUpdateKnowledgeBase.t.Errorf("RepositoryMock.UpdateKnowledgeBase got unexpected parameter kb, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.expectationOrigins.originKb, *mm_want_ptrs.kb, mm_got.kb, minimock.Diff(*mm_want_ptrs.kb, mm_got.kb))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateKnowledgeBase.t.Errorf("RepositoryMock.UpdateKnowledgeBase got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateKnowledgeBase.t.Fatal("No results are set for the RepositoryMock.UpdateKnowledgeBase")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmUpdateKnowledgeBase.funcUpdateKnowledgeBase != nil {
		return mmUpdateKnowledgeBase.funcUpdateKnowledgeBase(ctx, id, ownerUID, kb)
	}
	mmUpdateKnowledgeBase.t.Fatalf("Unexpected call to RepositoryMock.UpdateKnowledgeBase. %v %v %v %v", ctx, id, ownerUID, kb)
	return
}

// UpdateKnowledgeBaseAfterCounter returns a count of finished RepositoryMock.UpdateKnowledgeBase invocations
func (mmUpdateKnowledgeBase *RepositoryMock) UpdateKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.afterUpdateKnowledgeBaseCounter)
}

// UpdateKnowledgeBaseBeforeCounter returns a count of RepositoryMock.UpdateKnowledgeBase invocations
func (mmUpdateKnowledgeBase *RepositoryMock) UpdateKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.beforeUpdateKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateKnowledgeBase *mRepositoryMockUpdateKnowledgeBase) Calls() []*RepositoryMockUpdateKnowledgeBaseParams {
	mmUpdateKnowledgeBase.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateKnowledgeBaseParams, len(mmUpdateKnowledgeBase.callArgs))
	copy(argCopy, mmUpdateKnowledgeBase.callArgs)

	mmUpdateKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateKnowledgeBaseDone returns true if the count of the UpdateKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateKnowledgeBaseDone() bool {
	if m.UpdateKnowledgeBaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateKnowledgeBaseMock.invocationsDone()
}

// MinimockUpdateKnowledgeBaseInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateKnowledgeBaseInspect() {
	for _, e := range m.UpdateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBase at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterUpdateKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateKnowledgeBaseMock.defaultExpectation != nil && afterUpdateKnowledgeBaseCounter < 1 {
		if m.UpdateKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBase at\n%s", m.UpdateKnowledgeBaseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBase at\n%s with params: %#v", m.UpdateKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *m.UpdateKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateKnowledgeBase != nil && afterUpdateKnowledgeBaseCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBase at\n%s", m.funcUpdateKnowledgeBaseOrigin)
	}

	if !m.UpdateKnowledgeBaseMock.invocationsDone() && afterUpdateKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateKnowledgeBase at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateKnowledgeBaseMock.expectedInvocations), m.UpdateKnowledgeBaseMock.expectedInvocationsOrigin, afterUpdateKnowledgeBaseCounter)
	}
}

type mRepositoryMockUpdateKnowledgeBaseFile struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateKnowledgeBaseFileExpectation
	expectations       []*RepositoryMockUpdateKnowledgeBaseFileExpectation

	callArgs []*RepositoryMockUpdateKnowledgeBaseFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateKnowledgeBaseFileExpectation specifies expectation struct of the Repository.UpdateKnowledgeBaseFile
type RepositoryMockUpdateKnowledgeBaseFileExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateKnowledgeBaseFileParams
	paramPtrs          *RepositoryMockUpdateKnowledgeBaseFileParamPtrs
	expectationOrigins RepositoryMockUpdateKnowledgeBaseFileExpectationOrigins
	results            *RepositoryMockUpdateKnowledgeBaseFileResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateKnowledgeBaseFileParams contains parameters of the Repository.UpdateKnowledgeBaseFile
type RepositoryMockUpdateKnowledgeBaseFileParams struct {
	ctx       context.Context
	fileUID   string
	updateMap map[string]any
}

// RepositoryMockUpdateKnowledgeBaseFileParamPtrs contains pointers to parameters of the Repository.UpdateKnowledgeBaseFile
type RepositoryMockUpdateKnowledgeBaseFileParamPtrs struct {
	ctx       *context.Context
	fileUID   *string
	updateMap *map[string]any
}

// RepositoryMockUpdateKnowledgeBaseFileResults contains results of the Repository.UpdateKnowledgeBaseFile
type RepositoryMockUpdateKnowledgeBaseFileResults struct {
	kp1 *mm_repository.KnowledgeBaseFileModel
	err error
}

// RepositoryMockUpdateKnowledgeBaseFileOrigins contains origins of expectations of the Repository.UpdateKnowledgeBaseFile
type RepositoryMockUpdateKnowledgeBaseFileExpectationOrigins struct {
	origin          string
	originCtx       string
	originFileUID   string
	originUpdateMap string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateKnowledgeBaseFile *mRepositoryMockUpdateKnowledgeBaseFile) Optional() *mRepositoryMockUpdateKnowledgeBaseFile {
	mmUpdateKnowledgeBaseFile.optional = true
	return mmUpdateKnowledgeBaseFile
}

// Expect sets up expected params for Repository.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryMockUpdateKnowledgeBaseFile) Expect(ctx context.Context, fileUID string, updateMap map[string]any) *mRepositoryMockUpdateKnowledgeBaseFile {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseFileExpectation{}
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseFile mock is already set by ExpectParams functions")
	}

	mmUpdateKnowledgeBaseFile.defaultExpectation.params = &RepositoryMockUpdateKnowledgeBaseFileParams{ctx, fileUID, updateMap}
	mmUpdateKnowledgeBaseFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateKnowledgeBaseFile.expectations {
		if minimock.Equal(e.params, mmUpdateKnowledgeBaseFile.defaultExpectation.params) {
			mmUpdateKnowledgeBaseFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateKnowledgeBaseFile.defaultExpectation.params)
		}
	}

	return mmUpdateKnowledgeBaseFile
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryMockUpdateKnowledgeBaseFile) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateKnowledgeBaseFile {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseFileExpectation{}
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseFileParamPtrs{}
	}
	mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateKnowledgeBaseFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseFile
}

// ExpectFileUIDParam2 sets up expected param fileUID for Repository.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryMockUpdateKnowledgeBaseFile) ExpectFileUIDParam2(fileUID string) *mRepositoryMockUpdateKnowledgeBaseFile {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseFileExpectation{}
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseFileParamPtrs{}
	}
	mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmUpdateKnowledgeBaseFile.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseFile
}

// ExpectUpdateMapParam3 sets up expected param updateMap for Repository.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryMockUpdateKnowledgeBaseFile) ExpectUpdateMapParam3(updateMap map[string]any) *mRepositoryMockUpdateKnowledgeBaseFile {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseFileExpectation{}
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.params != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseFile mock is already set by Expect")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeBaseFileParamPtrs{}
	}
	mmUpdateKnowledgeBaseFile.defaultExpectation.paramPtrs.updateMap = &updateMap
	mmUpdateKnowledgeBaseFile.defaultExpectation.expectationOrigins.originUpdateMap = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBaseFile
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryMockUpdateKnowledgeBaseFile) Inspect(f func(ctx context.Context, fileUID string, updateMap map[string]any)) *mRepositoryMockUpdateKnowledgeBaseFile {
	if mmUpdateKnowledgeBaseFile.mock.inspectFuncUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateKnowledgeBaseFile")
	}

	mmUpdateKnowledgeBaseFile.mock.inspectFuncUpdateKnowledgeBaseFile = f

	return mmUpdateKnowledgeBaseFile
}

// Return sets up results that will be returned by Repository.UpdateKnowledgeBaseFile
func (mmUpdateKnowledgeBaseFile *mRepositoryMockUpdateKnowledgeBaseFile) Return(kp1 *mm_repository.KnowledgeBaseFileModel, err error) *RepositoryMock {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	if mmUpdateKnowledgeBaseFile.defaultExpectation == nil {
		mmUpdateKnowledgeBaseFile.defaultExpectation = &RepositoryMockUpdateKnowledgeBaseFileExpectation{mock: mmUpdateKnowledgeBaseFile.mock}
	}
	mmUpdateKnowledgeBaseFile.defaultExpectation.results = &RepositoryMockUpdateKnowledgeBaseFileResults{kp1, err}
	mmUpdateKnowledgeBaseFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBaseFile.mock
}

// Set uses given function f to mock the Repository.UpdateKnowledgeBaseFile method
func (mmUpdateKnowledgeBaseFile *mRepositoryMockUpdateKnowledgeBaseFile) Set(f func(ctx context.Context, fileUID string, updateMap map[string]any) (kp1 *mm_repository.KnowledgeBaseFileModel, err error)) *RepositoryMock {
	if mmUpdateKnowledgeBaseFile.defaultExpectation != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateKnowledgeBaseFile method")
	}

	if len(mmUpdateKnowledgeBaseFile.expectations) > 0 {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateKnowledgeBaseFile method")
	}

	mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile = f
	mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFileOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBaseFile.mock
}

// When sets expectation for the Repository.UpdateKnowledgeBaseFile which will trigger the result defined by the following
// Then helper
func (mmUpdateKnowledgeBaseFile *mRepositoryMockUpdateKnowledgeBaseFile) When(ctx context.Context, fileUID string, updateMap map[string]any) *RepositoryMockUpdateKnowledgeBaseFileExpectation {
	if mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeBaseFile mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateKnowledgeBaseFileExpectation{
		mock:               mmUpdateKnowledgeBaseFile.mock,
		params:             &RepositoryMockUpdateKnowledgeBaseFileParams{ctx, fileUID, updateMap},
		expectationOrigins: RepositoryMockUpdateKnowledgeBaseFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateKnowledgeBaseFile.expectations = append(mmUpdateKnowledgeBaseFile.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateKnowledgeBaseFile return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateKnowledgeBaseFileExpectation) Then(kp1 *mm_repository.KnowledgeBaseFileModel, err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateKnowledgeBaseFileResults{kp1, err}
	return e.mock
}

// Times sets number of times Repository.UpdateKnowledgeBaseFile should be invoked
func (mmUpdateKnowledgeBaseFile *mRepositoryMockUpdateKnowledgeBaseFile) Times(n uint64) *mRepositoryMockUpdateKnowledgeBaseFile {
	if n == 0 {
		mmUpdateKnowledgeBaseFile.mock.t.Fatalf("Times of RepositoryMock.UpdateKnowledgeBaseFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateKnowledgeBaseFile.expectedInvocations, n)
	mmUpdateKnowledgeBaseFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBaseFile
}

func (mmUpdateKnowledgeBaseFile *mRepositoryMockUpdateKnowledgeBaseFile) invocationsDone() bool {
	if len(mmUpdateKnowledgeBaseFile.expectations) == 0 && mmUpdateKnowledgeBaseFile.defaultExpectation == nil && mmUpdateKnowledgeBaseFile.mock.funcUpdateKnowledgeBaseFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseFile.mock.afterUpdateKnowledgeBaseFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateKnowledgeBaseFile implements mm_repository.Repository
func (mmUpdateKnowledgeBaseFile *RepositoryMock) UpdateKnowledgeBaseFile(ctx context.Context, fileUID string, updateMap map[string]any) (kp1 *mm_repository.KnowledgeBaseFileModel, err error) {
	mm_atomic.AddUint64(&mmUpdateKnowledgeBaseFile.beforeUpdateKnowledgeBaseFileCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateKnowledgeBaseFile.afterUpdateKnowledgeBaseFileCounter, 1)

	mmUpdateKnowledgeBaseFile.t.Helper()

	if mmUpdateKnowledgeBaseFile.inspectFuncUpdateKnowledgeBaseFile != nil {
		mmUpdateKnowledgeBaseFile.inspectFuncUpdateKnowledgeBaseFile(ctx, fileUID, updateMap)
	}

	mm_params := RepositoryMockUpdateKnowledgeBaseFileParams{ctx, fileUID, updateMap}

	// Record call args
	mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.mutex.Lock()
	mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.callArgs = append(mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.callArgs, &mm_params)
	mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.mutex.Unlock()

	for _, e := range mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateKnowledgeBaseFileParams{ctx, fileUID, updateMap}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateKnowledgeBaseFile.t.Errorf("RepositoryMock.UpdateKnowledgeBaseFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmUpdateKnowledgeBaseFile.t.Errorf("RepositoryMock.UpdateKnowledgeBaseFile got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

			if mm_want_ptrs.updateMap != nil && !minimock.Equal(*mm_want_ptrs.updateMap, mm_got.updateMap) {
				mmUpdateKnowledgeBaseFile.t.Errorf("RepositoryMock.UpdateKnowledgeBaseFile got unexpected parameter updateMap, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation.expectationOrigins.originUpdateMap, *mm_want_ptrs.updateMap, mm_got.updateMap, minimock.Diff(*mm_want_ptrs.updateMap, mm_got.updateMap))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateKnowledgeBaseFile.t.Errorf("RepositoryMock.UpdateKnowledgeBaseFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateKnowledgeBaseFile.UpdateKnowledgeBaseFileMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateKnowledgeBaseFile.t.Fatal("No results are set for the RepositoryMock.UpdateKnowledgeBaseFile")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmUpdateKnowledgeBaseFile.funcUpdateKnowledgeBaseFile != nil {
		return mmUpdateKnowledgeBaseFile.funcUpdateKnowledgeBaseFile(ctx, fileUID, updateMap)
	}
	mmUpdateKnowledgeBaseFile.t.Fatalf("Unexpected call to RepositoryMock.UpdateKnowledgeBaseFile. %v %v %v", ctx, fileUID, updateMap)
	return
}

// UpdateKnowledgeBaseFileAfterCounter returns a count of finished RepositoryMock.UpdateKnowledgeBaseFile invocations
func (mmUpdateKnowledgeBaseFile *RepositoryMock) UpdateKnowledgeBaseFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseFile.afterUpdateKnowledgeBaseFileCounter)
}

// UpdateKnowledgeBaseFileBeforeCounter returns a count of RepositoryMock.UpdateKnowledgeBaseFile invocations
func (mmUpdateKnowledgeBaseFile *RepositoryMock) UpdateKnowledgeBaseFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBaseFile.beforeUpdateKnowledgeBaseFileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateKnowledgeBaseFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateKnowledgeBaseFile *mRepositoryMockUpdateKnowledgeBaseFile) Calls() []*RepositoryMockUpdateKnowledgeBaseFileParams {
	mmUpdateKnowledgeBaseFile.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateKnowledgeBaseFileParams, len(mmUpdateKnowledgeBaseFile.callArgs))
	copy(argCopy, mmUpdateKnowledgeBaseFile.callArgs)

	mmUpdateKnowledgeBaseFile.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateKnowledgeBaseFileDone returns true if the count of the UpdateKnowledgeBaseFile invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateKnowledgeBaseFileDone() bool {
	if m.UpdateKnowledgeBaseFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateKnowledgeBaseFileMock.invocationsDone()
}

// MinimockUpdateKnowledgeBaseFileInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateKnowledgeBaseFileInspect() {
	for _, e := range m.UpdateKnowledgeBaseFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateKnowledgeBaseFileCounter := mm_atomic.LoadUint64(&m.afterUpdateKnowledgeBaseFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateKnowledgeBaseFileMock.defaultExpectation != nil && afterUpdateKnowledgeBaseFileCounter < 1 {
		if m.UpdateKnowledgeBaseFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseFile at\n%s", m.UpdateKnowledgeBaseFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseFile at\n%s with params: %#v", m.UpdateKnowledgeBaseFileMock.defaultExpectation.expectationOrigins.origin, *m.UpdateKnowledgeBaseFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateKnowledgeBaseFile != nil && afterUpdateKnowledgeBaseFileCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeBaseFile at\n%s", m.funcUpdateKnowledgeBaseFileOrigin)
	}

	if !m.UpdateKnowledgeBaseFileMock.invocationsDone() && afterUpdateKnowledgeBaseFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateKnowledgeBaseFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateKnowledgeBaseFileMock.expectedInvocations), m.UpdateKnowledgeBaseFileMock.expectedInvocationsOrigin, afterUpdateKnowledgeBaseFileCounter)
	}
}

type mRepositoryMockUpdateKnowledgeFileMetadata struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateKnowledgeFileMetadataExpectation
	expectations       []*RepositoryMockUpdateKnowledgeFileMetadataExpectation

	callArgs []*RepositoryMockUpdateKnowledgeFileMetadataParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateKnowledgeFileMetadataExpectation specifies expectation struct of the Repository.UpdateKnowledgeFileMetadata
type RepositoryMockUpdateKnowledgeFileMetadataExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateKnowledgeFileMetadataParams
	paramPtrs          *RepositoryMockUpdateKnowledgeFileMetadataParamPtrs
	expectationOrigins RepositoryMockUpdateKnowledgeFileMetadataExpectationOrigins
	results            *RepositoryMockUpdateKnowledgeFileMetadataResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateKnowledgeFileMetadataParams contains parameters of the Repository.UpdateKnowledgeFileMetadata
type RepositoryMockUpdateKnowledgeFileMetadataParams struct {
	ctx     context.Context
	fileUID types.FileUIDType
	e1      mm_repository.ExtraMetaData
}

// RepositoryMockUpdateKnowledgeFileMetadataParamPtrs contains pointers to parameters of the Repository.UpdateKnowledgeFileMetadata
type RepositoryMockUpdateKnowledgeFileMetadataParamPtrs struct {
	ctx     *context.Context
	fileUID *types.FileUIDType
	e1      *mm_repository.ExtraMetaData
}

// RepositoryMockUpdateKnowledgeFileMetadataResults contains results of the Repository.UpdateKnowledgeFileMetadata
type RepositoryMockUpdateKnowledgeFileMetadataResults struct {
	err error
}

// RepositoryMockUpdateKnowledgeFileMetadataOrigins contains origins of expectations of the Repository.UpdateKnowledgeFileMetadata
type RepositoryMockUpdateKnowledgeFileMetadataExpectationOrigins struct {
	origin        string
	originCtx     string
	originFileUID string
	originE1      string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateKnowledgeFileMetadata *mRepositoryMockUpdateKnowledgeFileMetadata) Optional() *mRepositoryMockUpdateKnowledgeFileMetadata {
	mmUpdateKnowledgeFileMetadata.optional = true
	return mmUpdateKnowledgeFileMetadata
}

// Expect sets up expected params for Repository.UpdateKnowledgeFileMetadata
func (mmUpdateKnowledgeFileMetadata *mRepositoryMockUpdateKnowledgeFileMetadata) Expect(ctx context.Context, fileUID types.FileUIDType, e1 mm_repository.ExtraMetaData) *mRepositoryMockUpdateKnowledgeFileMetadata {
	if mmUpdateKnowledgeFileMetadata.mock.funcUpdateKnowledgeFileMetadata != nil {
		mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileMetadata mock is already set by Set")
	}

	if mmUpdateKnowledgeFileMetadata.defaultExpectation == nil {
		mmUpdateKnowledgeFileMetadata.defaultExpectation = &RepositoryMockUpdateKnowledgeFileMetadataExpectation{}
	}

	if mmUpdateKnowledgeFileMetadata.defaultExpectation.paramPtrs != nil {
		mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileMetadata mock is already set by ExpectParams functions")
	}

	mmUpdateKnowledgeFileMetadata.defaultExpectation.params = &RepositoryMockUpdateKnowledgeFileMetadataParams{ctx, fileUID, e1}
	mmUpdateKnowledgeFileMetadata.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateKnowledgeFileMetadata.expectations {
		if minimock.Equal(e.params, mmUpdateKnowledgeFileMetadata.defaultExpectation.params) {
			mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateKnowledgeFileMetadata.defaultExpectation.params)
		}
	}

	return mmUpdateKnowledgeFileMetadata
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateKnowledgeFileMetadata
func (mmUpdateKnowledgeFileMetadata *mRepositoryMockUpdateKnowledgeFileMetadata) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateKnowledgeFileMetadata {
	if mmUpdateKnowledgeFileMetadata.mock.funcUpdateKnowledgeFileMetadata != nil {
		mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileMetadata mock is already set by Set")
	}

	if mmUpdateKnowledgeFileMetadata.defaultExpectation == nil {
		mmUpdateKnowledgeFileMetadata.defaultExpectation = &RepositoryMockUpdateKnowledgeFileMetadataExpectation{}
	}

	if mmUpdateKnowledgeFileMetadata.defaultExpectation.params != nil {
		mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileMetadata mock is already set by Expect")
	}

	if mmUpdateKnowledgeFileMetadata.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeFileMetadata.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeFileMetadataParamPtrs{}
	}
	mmUpdateKnowledgeFileMetadata.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateKnowledgeFileMetadata.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateKnowledgeFileMetadata
}

// ExpectFileUIDParam2 sets up expected param fileUID for Repository.UpdateKnowledgeFileMetadata
func (mmUpdateKnowledgeFileMetadata *mRepositoryMockUpdateKnowledgeFileMetadata) ExpectFileUIDParam2(fileUID types.FileUIDType) *mRepositoryMockUpdateKnowledgeFileMetadata {
	if mmUpdateKnowledgeFileMetadata.mock.funcUpdateKnowledgeFileMetadata != nil {
		mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileMetadata mock is already set by Set")
	}

	if mmUpdateKnowledgeFileMetadata.defaultExpectation == nil {
		mmUpdateKnowledgeFileMetadata.defaultExpectation = &RepositoryMockUpdateKnowledgeFileMetadataExpectation{}
	}

	if mmUpdateKnowledgeFileMetadata.defaultExpectation.params != nil {
		mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileMetadata mock is already set by Expect")
	}

	if mmUpdateKnowledgeFileMetadata.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeFileMetadata.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeFileMetadataParamPtrs{}
	}
	mmUpdateKnowledgeFileMetadata.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmUpdateKnowledgeFileMetadata.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmUpdateKnowledgeFileMetadata
}

// ExpectE1Param3 sets up expected param e1 for Repository.UpdateKnowledgeFileMetadata
func (mmUpdateKnowledgeFileMetadata *mRepositoryMockUpdateKnowledgeFileMetadata) ExpectE1Param3(e1 mm_repository.ExtraMetaData) *mRepositoryMockUpdateKnowledgeFileMetadata {
	if mmUpdateKnowledgeFileMetadata.mock.funcUpdateKnowledgeFileMetadata != nil {
		mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileMetadata mock is already set by Set")
	}

	if mmUpdateKnowledgeFileMetadata.defaultExpectation == nil {
		mmUpdateKnowledgeFileMetadata.defaultExpectation = &RepositoryMockUpdateKnowledgeFileMetadataExpectation{}
	}

	if mmUpdateKnowledgeFileMetadata.defaultExpectation.params != nil {
		mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileMetadata mock is already set by Expect")
	}

	if mmUpdateKnowledgeFileMetadata.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeFileMetadata.defaultExpectation.paramPtrs = &RepositoryMockUpdateKnowledgeFileMetadataParamPtrs{}
	}
	mmUpdateKnowledgeFileMetadata.defaultExpectation.paramPtrs.e1 = &e1
	mmUpdateKnowledgeFileMetadata.defaultExpectation.expectationOrigins.originE1 = minimock.CallerInfo(1)

	return mmUpdateKnowledgeFileMetadata
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateKnowledgeFileMetadata
func (mmUpdateKnowledgeFileMetadata *mRepositoryMockUpdateKnowledgeFileMetadata) Inspect(f func(ctx context.Context, fileUID types.FileUIDType, e1 mm_repository.ExtraMetaData)) *mRepositoryMockUpdateKnowledgeFileMetadata {
	if mmUpdateKnowledgeFileMetadata.mock.inspectFuncUpdateKnowledgeFileMetadata != nil {
		mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateKnowledgeFileMetadata")
	}

	mmUpdateKnowledgeFileMetadata.mock.inspectFuncUpdateKnowledgeFileMetadata = f

	return mmUpdateKnowledgeFileMetadata
}

// Return sets up results that will be returned by Repository.UpdateKnowledgeFileMetadata
func (mmUpdateKnowledgeFileMetadata *mRepositoryMockUpdateKnowledgeFileMetadata) Return(err error) *RepositoryMock {
	if mmUpdateKnowledgeFileMetadata.mock.funcUpdateKnowledgeFileMetadata != nil {
		mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileMetadata mock is already set by Set")
	}

	if mmUpdateKnowledgeFileMetadata.defaultExpectation == nil {
		mmUpdateKnowledgeFileMetadata.defaultExpectation = &RepositoryMockUpdateKnowledgeFileMetadataExpectation{mock: mmUpdateKnowledgeFileMetadata.mock}
	}
	mmUpdateKnowledgeFileMetadata.defaultExpectation.results = &RepositoryMockUpdateKnowledgeFileMetadataResults{err}
	mmUpdateKnowledgeFileMetadata.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeFileMetadata.mock
}

// Set uses given function f to mock the Repository.UpdateKnowledgeFileMetadata method
func (mmUpdateKnowledgeFileMetadata *mRepositoryMockUpdateKnowledgeFileMetadata) Set(f func(ctx context.Context, fileUID types.FileUIDType, e1 mm_repository.ExtraMetaData) (err error)) *RepositoryMock {
	if mmUpdateKnowledgeFileMetadata.defaultExpectation != nil {
		mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateKnowledgeFileMetadata method")
	}

	if len(mmUpdateKnowledgeFileMetadata.expectations) > 0 {
		mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateKnowledgeFileMetadata method")
	}

	mmUpdateKnowledgeFileMetadata.mock.funcUpdateKnowledgeFileMetadata = f
	mmUpdateKnowledgeFileMetadata.mock.funcUpdateKnowledgeFileMetadataOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeFileMetadata.mock
}

// When sets expectation for the Repository.UpdateKnowledgeFileMetadata which will trigger the result defined by the following
// Then helper
func (mmUpdateKnowledgeFileMetadata *mRepositoryMockUpdateKnowledgeFileMetadata) When(ctx context.Context, fileUID types.FileUIDType, e1 mm_repository.ExtraMetaData) *RepositoryMockUpdateKnowledgeFileMetadataExpectation {
	if mmUpdateKnowledgeFileMetadata.mock.funcUpdateKnowledgeFileMetadata != nil {
		mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("RepositoryMock.UpdateKnowledgeFileMetadata mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateKnowledgeFileMetadataExpectation{
		mock:               mmUpdateKnowledgeFileMetadata.mock,
		params:             &RepositoryMockUpdateKnowledgeFileMetadataParams{ctx, fileUID, e1},
		expectationOrigins: RepositoryMockUpdateKnowledgeFileMetadataExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateKnowledgeFileMetadata.expectations = append(mmUpdateKnowledgeFileMetadata.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateKnowledgeFileMetadata return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateKnowledgeFileMetadataExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateKnowledgeFileMetadataResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateKnowledgeFileMetadata should be invoked
func (mmUpdateKnowledgeFileMetadata *mRepositoryMockUpdateKnowledgeFileMetadata) Times(n uint64) *mRepositoryMockUpdateKnowledgeFileMetadata {
	if n == 0 {
		mmUpdateKnowledgeFileMetadata.mock.t.Fatalf("Times of RepositoryMock.UpdateKnowledgeFileMetadata mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateKnowledgeFileMetadata.expectedInvocations, n)
	mmUpdateKnowledgeFileMetadata.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeFileMetadata
}

func (mmUpdateKnowledgeFileMetadata *mRepositoryMockUpdateKnowledgeFileMetadata) invocationsDone() bool {
	if len(mmUpdateKnowledgeFileMetadata.expectations) == 0 && mmUpdateKnowledgeFileMetadata.defaultExpectation == nil && mmUpdateKnowledgeFileMetadata.mock.funcUpdateKnowledgeFileMetadata == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeFileMetadata.mock.afterUpdateKnowledgeFileMetadataCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeFileMetadata.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateKnowledgeFileMetadata implements mm_repository.Repository
func (mmUpdateKnowledgeFileMetadata *RepositoryMock) UpdateKnowledgeFileMetadata(ctx context.Context, fileUID types.FileUIDType, e1 mm_repository.ExtraMetaData) (err error) {
	mm_atomic.AddUint64(&mmUpdateKnowledgeFileMetadata.beforeUpdateKnowledgeFileMetadataCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateKnowledgeFileMetadata.afterUpdateKnowledgeFileMetadataCounter, 1)

	mmUpdateKnowledgeFileMetadata.t.Helper()

	if mmUpdateKnowledgeFileMetadata.inspectFuncUpdateKnowledgeFileMetadata != nil {
		mmUpdateKnowledgeFileMetadata.inspectFuncUpdateKnowledgeFileMetadata(ctx, fileUID, e1)
	}

	mm_params := RepositoryMockUpdateKnowledgeFileMetadataParams{ctx, fileUID, e1}

	// Record call args
	mmUpdateKnowledgeFileMetadata.UpdateKnowledgeFileMetadataMock.mutex.Lock()
	mmUpdateKnowledgeFileMetadata.UpdateKnowledgeFileMetadataMock.callArgs = append(mmUpdateKnowledgeFileMetadata.UpdateKnowledgeFileMetadataMock.callArgs, &mm_params)
	mmUpdateKnowledgeFileMetadata.UpdateKnowledgeFileMetadataMock.mutex.Unlock()

	for _, e := range mmUpdateKnowledgeFileMetadata.UpdateKnowledgeFileMetadataMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateKnowledgeFileMetadata.UpdateKnowledgeFileMetadataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateKnowledgeFileMetadata.UpdateKnowledgeFileMetadataMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateKnowledgeFileMetadata.UpdateKnowledgeFileMetadataMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateKnowledgeFileMetadata.UpdateKnowledgeFileMetadataMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateKnowledgeFileMetadataParams{ctx, fileUID, e1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateKnowledgeFileMetadata.t.Errorf("RepositoryMock.UpdateKnowledgeFileMetadata got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeFileMetadata.UpdateKnowledgeFileMetadataMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmUpdateKnowledgeFileMetadata.t.Errorf("RepositoryMock.UpdateKnowledgeFileMetadata got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeFileMetadata.UpdateKnowledgeFileMetadataMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

			if mm_want_ptrs.e1 != nil && !minimock.Equal(*mm_want_ptrs.e1, mm_got.e1) {
				mmUpdateKnowledgeFileMetadata.t.Errorf("RepositoryMock.UpdateKnowledgeFileMetadata got unexpected parameter e1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeFileMetadata.UpdateKnowledgeFileMetadataMock.defaultExpectation.expectationOrigins.originE1, *mm_want_ptrs.e1, mm_got.e1, minimock.Diff(*mm_want_ptrs.e1, mm_got.e1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateKnowledgeFileMetadata.t.Errorf("RepositoryMock.UpdateKnowledgeFileMetadata got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateKnowledgeFileMetadata.UpdateKnowledgeFileMetadataMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateKnowledgeFileMetadata.UpdateKnowledgeFileMetadataMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateKnowledgeFileMetadata.t.Fatal("No results are set for the RepositoryMock.UpdateKnowledgeFileMetadata")
		}
		return (*mm_results).err
	}
	if mmUpdateKnowledgeFileMetadata.funcUpdateKnowledgeFileMetadata != nil {
		return mmUpdateKnowledgeFileMetadata.funcUpdateKnowledgeFileMetadata(ctx, fileUID, e1)
	}
	mmUpdateKnowledgeFileMetadata.t.Fatalf("Unexpected call to RepositoryMock.UpdateKnowledgeFileMetadata. %v %v %v", ctx, fileUID, e1)
	return
}

// UpdateKnowledgeFileMetadataAfterCounter returns a count of finished RepositoryMock.UpdateKnowledgeFileMetadata invocations
func (mmUpdateKnowledgeFileMetadata *RepositoryMock) UpdateKnowledgeFileMetadataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeFileMetadata.afterUpdateKnowledgeFileMetadataCounter)
}

// UpdateKnowledgeFileMetadataBeforeCounter returns a count of RepositoryMock.UpdateKnowledgeFileMetadata invocations
func (mmUpdateKnowledgeFileMetadata *RepositoryMock) UpdateKnowledgeFileMetadataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeFileMetadata.beforeUpdateKnowledgeFileMetadataCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateKnowledgeFileMetadata.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateKnowledgeFileMetadata *mRepositoryMockUpdateKnowledgeFileMetadata) Calls() []*RepositoryMockUpdateKnowledgeFileMetadataParams {
	mmUpdateKnowledgeFileMetadata.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateKnowledgeFileMetadataParams, len(mmUpdateKnowledgeFileMetadata.callArgs))
	copy(argCopy, mmUpdateKnowledgeFileMetadata.callArgs)

	mmUpdateKnowledgeFileMetadata.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateKnowledgeFileMetadataDone returns true if the count of the UpdateKnowledgeFileMetadata invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateKnowledgeFileMetadataDone() bool {
	if m.UpdateKnowledgeFileMetadataMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateKnowledgeFileMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateKnowledgeFileMetadataMock.invocationsDone()
}

// MinimockUpdateKnowledgeFileMetadataInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateKnowledgeFileMetadataInspect() {
	for _, e := range m.UpdateKnowledgeFileMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeFileMetadata at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateKnowledgeFileMetadataCounter := mm_atomic.LoadUint64(&m.afterUpdateKnowledgeFileMetadataCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateKnowledgeFileMetadataMock.defaultExpectation != nil && afterUpdateKnowledgeFileMetadataCounter < 1 {
		if m.UpdateKnowledgeFileMetadataMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeFileMetadata at\n%s", m.UpdateKnowledgeFileMetadataMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeFileMetadata at\n%s with params: %#v", m.UpdateKnowledgeFileMetadataMock.defaultExpectation.expectationOrigins.origin, *m.UpdateKnowledgeFileMetadataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateKnowledgeFileMetadata != nil && afterUpdateKnowledgeFileMetadataCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateKnowledgeFileMetadata at\n%s", m.funcUpdateKnowledgeFileMetadataOrigin)
	}

	if !m.UpdateKnowledgeFileMetadataMock.invocationsDone() && afterUpdateKnowledgeFileMetadataCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateKnowledgeFileMetadata at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateKnowledgeFileMetadataMock.expectedInvocations), m.UpdateKnowledgeFileMetadataMock.expectedInvocationsOrigin, afterUpdateKnowledgeFileMetadataCounter)
	}
}

type mRepositoryMockUpdateObject struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateObjectExpectation
	expectations       []*RepositoryMockUpdateObjectExpectation

	callArgs []*RepositoryMockUpdateObjectParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateObjectExpectation specifies expectation struct of the Repository.UpdateObject
type RepositoryMockUpdateObjectExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateObjectParams
	paramPtrs          *RepositoryMockUpdateObjectParamPtrs
	expectationOrigins RepositoryMockUpdateObjectExpectationOrigins
	results            *RepositoryMockUpdateObjectResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateObjectParams contains parameters of the Repository.UpdateObject
type RepositoryMockUpdateObjectParams struct {
	ctx context.Context
	obj mm_repository.ObjectModel
}

// RepositoryMockUpdateObjectParamPtrs contains pointers to parameters of the Repository.UpdateObject
type RepositoryMockUpdateObjectParamPtrs struct {
	ctx *context.Context
	obj *mm_repository.ObjectModel
}

// RepositoryMockUpdateObjectResults contains results of the Repository.UpdateObject
type RepositoryMockUpdateObjectResults struct {
	op1 *mm_repository.ObjectModel
	err error
}

// RepositoryMockUpdateObjectOrigins contains origins of expectations of the Repository.UpdateObject
type RepositoryMockUpdateObjectExpectationOrigins struct {
	origin    string
	originCtx string
	originObj string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateObject *mRepositoryMockUpdateObject) Optional() *mRepositoryMockUpdateObject {
	mmUpdateObject.optional = true
	return mmUpdateObject
}

// Expect sets up expected params for Repository.UpdateObject
func (mmUpdateObject *mRepositoryMockUpdateObject) Expect(ctx context.Context, obj mm_repository.ObjectModel) *mRepositoryMockUpdateObject {
	if mmUpdateObject.mock.funcUpdateObject != nil {
		mmUpdateObject.mock.t.Fatalf("RepositoryMock.UpdateObject mock is already set by Set")
	}

	if mmUpdateObject.defaultExpectation == nil {
		mmUpdateObject.defaultExpectation = &RepositoryMockUpdateObjectExpectation{}
	}

	if mmUpdateObject.defaultExpectation.paramPtrs != nil {
		mmUpdateObject.mock.t.Fatalf("RepositoryMock.UpdateObject mock is already set by ExpectParams functions")
	}

	mmUpdateObject.defaultExpectation.params = &RepositoryMockUpdateObjectParams{ctx, obj}
	mmUpdateObject.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateObject.expectations {
		if minimock.Equal(e.params, mmUpdateObject.defaultExpectation.params) {
			mmUpdateObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateObject.defaultExpectation.params)
		}
	}

	return mmUpdateObject
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateObject
func (mmUpdateObject *mRepositoryMockUpdateObject) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateObject {
	if mmUpdateObject.mock.funcUpdateObject != nil {
		mmUpdateObject.mock.t.Fatalf("RepositoryMock.UpdateObject mock is already set by Set")
	}

	if mmUpdateObject.defaultExpectation == nil {
		mmUpdateObject.defaultExpectation = &RepositoryMockUpdateObjectExpectation{}
	}

	if mmUpdateObject.defaultExpectation.params != nil {
		mmUpdateObject.mock.t.Fatalf("RepositoryMock.UpdateObject mock is already set by Expect")
	}

	if mmUpdateObject.defaultExpectation.paramPtrs == nil {
		mmUpdateObject.defaultExpectation.paramPtrs = &RepositoryMockUpdateObjectParamPtrs{}
	}
	mmUpdateObject.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateObject.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateObject
}

// ExpectObjParam2 sets up expected param obj for Repository.UpdateObject
func (mmUpdateObject *mRepositoryMockUpdateObject) ExpectObjParam2(obj mm_repository.ObjectModel) *mRepositoryMockUpdateObject {
	if mmUpdateObject.mock.funcUpdateObject != nil {
		mmUpdateObject.mock.t.Fatalf("RepositoryMock.UpdateObject mock is already set by Set")
	}

	if mmUpdateObject.defaultExpectation == nil {
		mmUpdateObject.defaultExpectation = &RepositoryMockUpdateObjectExpectation{}
	}

	if mmUpdateObject.defaultExpectation.params != nil {
		mmUpdateObject.mock.t.Fatalf("RepositoryMock.UpdateObject mock is already set by Expect")
	}

	if mmUpdateObject.defaultExpectation.paramPtrs == nil {
		mmUpdateObject.defaultExpectation.paramPtrs = &RepositoryMockUpdateObjectParamPtrs{}
	}
	mmUpdateObject.defaultExpectation.paramPtrs.obj = &obj
	mmUpdateObject.defaultExpectation.expectationOrigins.originObj = minimock.CallerInfo(1)

	return mmUpdateObject
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateObject
func (mmUpdateObject *mRepositoryMockUpdateObject) Inspect(f func(ctx context.Context, obj mm_repository.ObjectModel)) *mRepositoryMockUpdateObject {
	if mmUpdateObject.mock.inspectFuncUpdateObject != nil {
		mmUpdateObject.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateObject")
	}

	mmUpdateObject.mock.inspectFuncUpdateObject = f

	return mmUpdateObject
}

// Return sets up results that will be returned by Repository.UpdateObject
func (mmUpdateObject *mRepositoryMockUpdateObject) Return(op1 *mm_repository.ObjectModel, err error) *RepositoryMock {
	if mmUpdateObject.mock.funcUpdateObject != nil {
		mmUpdateObject.mock.t.Fatalf("RepositoryMock.UpdateObject mock is already set by Set")
	}

	if mmUpdateObject.defaultExpectation == nil {
		mmUpdateObject.defaultExpectation = &RepositoryMockUpdateObjectExpectation{mock: mmUpdateObject.mock}
	}
	mmUpdateObject.defaultExpectation.results = &RepositoryMockUpdateObjectResults{op1, err}
	mmUpdateObject.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateObject.mock
}

// Set uses given function f to mock the Repository.UpdateObject method
func (mmUpdateObject *mRepositoryMockUpdateObject) Set(f func(ctx context.Context, obj mm_repository.ObjectModel) (op1 *mm_repository.ObjectModel, err error)) *RepositoryMock {
	if mmUpdateObject.defaultExpectation != nil {
		mmUpdateObject.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateObject method")
	}

	if len(mmUpdateObject.expectations) > 0 {
		mmUpdateObject.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateObject method")
	}

	mmUpdateObject.mock.funcUpdateObject = f
	mmUpdateObject.mock.funcUpdateObjectOrigin = minimock.CallerInfo(1)
	return mmUpdateObject.mock
}

// When sets expectation for the Repository.UpdateObject which will trigger the result defined by the following
// Then helper
func (mmUpdateObject *mRepositoryMockUpdateObject) When(ctx context.Context, obj mm_repository.ObjectModel) *RepositoryMockUpdateObjectExpectation {
	if mmUpdateObject.mock.funcUpdateObject != nil {
		mmUpdateObject.mock.t.Fatalf("RepositoryMock.UpdateObject mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateObjectExpectation{
		mock:               mmUpdateObject.mock,
		params:             &RepositoryMockUpdateObjectParams{ctx, obj},
		expectationOrigins: RepositoryMockUpdateObjectExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateObject.expectations = append(mmUpdateObject.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateObject return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateObjectExpectation) Then(op1 *mm_repository.ObjectModel, err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateObjectResults{op1, err}
	return e.mock
}

// Times sets number of times Repository.UpdateObject should be invoked
func (mmUpdateObject *mRepositoryMockUpdateObject) Times(n uint64) *mRepositoryMockUpdateObject {
	if n == 0 {
		mmUpdateObject.mock.t.Fatalf("Times of RepositoryMock.UpdateObject mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateObject.expectedInvocations, n)
	mmUpdateObject.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateObject
}

func (mmUpdateObject *mRepositoryMockUpdateObject) invocationsDone() bool {
	if len(mmUpdateObject.expectations) == 0 && mmUpdateObject.defaultExpectation == nil && mmUpdateObject.mock.funcUpdateObject == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateObject.mock.afterUpdateObjectCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateObject.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateObject implements mm_repository.Repository
func (mmUpdateObject *RepositoryMock) UpdateObject(ctx context.Context, obj mm_repository.ObjectModel) (op1 *mm_repository.ObjectModel, err error) {
	mm_atomic.AddUint64(&mmUpdateObject.beforeUpdateObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateObject.afterUpdateObjectCounter, 1)

	mmUpdateObject.t.Helper()

	if mmUpdateObject.inspectFuncUpdateObject != nil {
		mmUpdateObject.inspectFuncUpdateObject(ctx, obj)
	}

	mm_params := RepositoryMockUpdateObjectParams{ctx, obj}

	// Record call args
	mmUpdateObject.UpdateObjectMock.mutex.Lock()
	mmUpdateObject.UpdateObjectMock.callArgs = append(mmUpdateObject.UpdateObjectMock.callArgs, &mm_params)
	mmUpdateObject.UpdateObjectMock.mutex.Unlock()

	for _, e := range mmUpdateObject.UpdateObjectMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmUpdateObject.UpdateObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateObject.UpdateObjectMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateObject.UpdateObjectMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateObject.UpdateObjectMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateObjectParams{ctx, obj}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateObject.t.Errorf("RepositoryMock.UpdateObject got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateObject.UpdateObjectMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.obj != nil && !minimock.Equal(*mm_want_ptrs.obj, mm_got.obj) {
				mmUpdateObject.t.Errorf("RepositoryMock.UpdateObject got unexpected parameter obj, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateObject.UpdateObjectMock.defaultExpectation.expectationOrigins.originObj, *mm_want_ptrs.obj, mm_got.obj, minimock.Diff(*mm_want_ptrs.obj, mm_got.obj))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateObject.t.Errorf("RepositoryMock.UpdateObject got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateObject.UpdateObjectMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateObject.UpdateObjectMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateObject.t.Fatal("No results are set for the RepositoryMock.UpdateObject")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmUpdateObject.funcUpdateObject != nil {
		return mmUpdateObject.funcUpdateObject(ctx, obj)
	}
	mmUpdateObject.t.Fatalf("Unexpected call to RepositoryMock.UpdateObject. %v %v", ctx, obj)
	return
}

// UpdateObjectAfterCounter returns a count of finished RepositoryMock.UpdateObject invocations
func (mmUpdateObject *RepositoryMock) UpdateObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateObject.afterUpdateObjectCounter)
}

// UpdateObjectBeforeCounter returns a count of RepositoryMock.UpdateObject invocations
func (mmUpdateObject *RepositoryMock) UpdateObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateObject.beforeUpdateObjectCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateObject *mRepositoryMockUpdateObject) Calls() []*RepositoryMockUpdateObjectParams {
	mmUpdateObject.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateObjectParams, len(mmUpdateObject.callArgs))
	copy(argCopy, mmUpdateObject.callArgs)

	mmUpdateObject.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateObjectDone returns true if the count of the UpdateObject invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateObjectDone() bool {
	if m.UpdateObjectMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateObjectMock.invocationsDone()
}

// MinimockUpdateObjectInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateObjectInspect() {
	for _, e := range m.UpdateObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateObject at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateObjectCounter := mm_atomic.LoadUint64(&m.afterUpdateObjectCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateObjectMock.defaultExpectation != nil && afterUpdateObjectCounter < 1 {
		if m.UpdateObjectMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateObject at\n%s", m.UpdateObjectMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateObject at\n%s with params: %#v", m.UpdateObjectMock.defaultExpectation.expectationOrigins.origin, *m.UpdateObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateObject != nil && afterUpdateObjectCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateObject at\n%s", m.funcUpdateObjectOrigin)
	}

	if !m.UpdateObjectMock.invocationsDone() && afterUpdateObjectCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateObject at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateObjectMock.expectedInvocations), m.UpdateObjectMock.expectedInvocationsOrigin, afterUpdateObjectCounter)
	}
}

type mRepositoryMockUpdateObjectByUpdateMap struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateObjectByUpdateMapExpectation
	expectations       []*RepositoryMockUpdateObjectByUpdateMapExpectation

	callArgs []*RepositoryMockUpdateObjectByUpdateMapParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateObjectByUpdateMapExpectation specifies expectation struct of the Repository.UpdateObjectByUpdateMap
type RepositoryMockUpdateObjectByUpdateMapExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateObjectByUpdateMapParams
	paramPtrs          *RepositoryMockUpdateObjectByUpdateMapParamPtrs
	expectationOrigins RepositoryMockUpdateObjectByUpdateMapExpectationOrigins
	results            *RepositoryMockUpdateObjectByUpdateMapResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateObjectByUpdateMapParams contains parameters of the Repository.UpdateObjectByUpdateMap
type RepositoryMockUpdateObjectByUpdateMapParams struct {
	ctx       context.Context
	objUID    types.ObjectUIDType
	updateMap map[string]any
}

// RepositoryMockUpdateObjectByUpdateMapParamPtrs contains pointers to parameters of the Repository.UpdateObjectByUpdateMap
type RepositoryMockUpdateObjectByUpdateMapParamPtrs struct {
	ctx       *context.Context
	objUID    *types.ObjectUIDType
	updateMap *map[string]any
}

// RepositoryMockUpdateObjectByUpdateMapResults contains results of the Repository.UpdateObjectByUpdateMap
type RepositoryMockUpdateObjectByUpdateMapResults struct {
	op1 *mm_repository.ObjectModel
	err error
}

// RepositoryMockUpdateObjectByUpdateMapOrigins contains origins of expectations of the Repository.UpdateObjectByUpdateMap
type RepositoryMockUpdateObjectByUpdateMapExpectationOrigins struct {
	origin          string
	originCtx       string
	originObjUID    string
	originUpdateMap string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateObjectByUpdateMap *mRepositoryMockUpdateObjectByUpdateMap) Optional() *mRepositoryMockUpdateObjectByUpdateMap {
	mmUpdateObjectByUpdateMap.optional = true
	return mmUpdateObjectByUpdateMap
}

// Expect sets up expected params for Repository.UpdateObjectByUpdateMap
func (mmUpdateObjectByUpdateMap *mRepositoryMockUpdateObjectByUpdateMap) Expect(ctx context.Context, objUID types.ObjectUIDType, updateMap map[string]any) *mRepositoryMockUpdateObjectByUpdateMap {
	if mmUpdateObjectByUpdateMap.mock.funcUpdateObjectByUpdateMap != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateObjectByUpdateMap mock is already set by Set")
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation == nil {
		mmUpdateObjectByUpdateMap.defaultExpectation = &RepositoryMockUpdateObjectByUpdateMapExpectation{}
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateObjectByUpdateMap mock is already set by ExpectParams functions")
	}

	mmUpdateObjectByUpdateMap.defaultExpectation.params = &RepositoryMockUpdateObjectByUpdateMapParams{ctx, objUID, updateMap}
	mmUpdateObjectByUpdateMap.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateObjectByUpdateMap.expectations {
		if minimock.Equal(e.params, mmUpdateObjectByUpdateMap.defaultExpectation.params) {
			mmUpdateObjectByUpdateMap.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateObjectByUpdateMap.defaultExpectation.params)
		}
	}

	return mmUpdateObjectByUpdateMap
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateObjectByUpdateMap
func (mmUpdateObjectByUpdateMap *mRepositoryMockUpdateObjectByUpdateMap) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateObjectByUpdateMap {
	if mmUpdateObjectByUpdateMap.mock.funcUpdateObjectByUpdateMap != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateObjectByUpdateMap mock is already set by Set")
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation == nil {
		mmUpdateObjectByUpdateMap.defaultExpectation = &RepositoryMockUpdateObjectByUpdateMapExpectation{}
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation.params != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateObjectByUpdateMap mock is already set by Expect")
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs == nil {
		mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs = &RepositoryMockUpdateObjectByUpdateMapParamPtrs{}
	}
	mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateObjectByUpdateMap.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateObjectByUpdateMap
}

// ExpectObjUIDParam2 sets up expected param objUID for Repository.UpdateObjectByUpdateMap
func (mmUpdateObjectByUpdateMap *mRepositoryMockUpdateObjectByUpdateMap) ExpectObjUIDParam2(objUID types.ObjectUIDType) *mRepositoryMockUpdateObjectByUpdateMap {
	if mmUpdateObjectByUpdateMap.mock.funcUpdateObjectByUpdateMap != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateObjectByUpdateMap mock is already set by Set")
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation == nil {
		mmUpdateObjectByUpdateMap.defaultExpectation = &RepositoryMockUpdateObjectByUpdateMapExpectation{}
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation.params != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateObjectByUpdateMap mock is already set by Expect")
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs == nil {
		mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs = &RepositoryMockUpdateObjectByUpdateMapParamPtrs{}
	}
	mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs.objUID = &objUID
	mmUpdateObjectByUpdateMap.defaultExpectation.expectationOrigins.originObjUID = minimock.CallerInfo(1)

	return mmUpdateObjectByUpdateMap
}

// ExpectUpdateMapParam3 sets up expected param updateMap for Repository.UpdateObjectByUpdateMap
func (mmUpdateObjectByUpdateMap *mRepositoryMockUpdateObjectByUpdateMap) ExpectUpdateMapParam3(updateMap map[string]any) *mRepositoryMockUpdateObjectByUpdateMap {
	if mmUpdateObjectByUpdateMap.mock.funcUpdateObjectByUpdateMap != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateObjectByUpdateMap mock is already set by Set")
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation == nil {
		mmUpdateObjectByUpdateMap.defaultExpectation = &RepositoryMockUpdateObjectByUpdateMapExpectation{}
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation.params != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateObjectByUpdateMap mock is already set by Expect")
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs == nil {
		mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs = &RepositoryMockUpdateObjectByUpdateMapParamPtrs{}
	}
	mmUpdateObjectByUpdateMap.defaultExpectation.paramPtrs.updateMap = &updateMap
	mmUpdateObjectByUpdateMap.defaultExpectation.expectationOrigins.originUpdateMap = minimock.CallerInfo(1)

	return mmUpdateObjectByUpdateMap
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateObjectByUpdateMap
func (mmUpdateObjectByUpdateMap *mRepositoryMockUpdateObjectByUpdateMap) Inspect(f func(ctx context.Context, objUID types.ObjectUIDType, updateMap map[string]any)) *mRepositoryMockUpdateObjectByUpdateMap {
	if mmUpdateObjectByUpdateMap.mock.inspectFuncUpdateObjectByUpdateMap != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateObjectByUpdateMap")
	}

	mmUpdateObjectByUpdateMap.mock.inspectFuncUpdateObjectByUpdateMap = f

	return mmUpdateObjectByUpdateMap
}

// Return sets up results that will be returned by Repository.UpdateObjectByUpdateMap
func (mmUpdateObjectByUpdateMap *mRepositoryMockUpdateObjectByUpdateMap) Return(op1 *mm_repository.ObjectModel, err error) *RepositoryMock {
	if mmUpdateObjectByUpdateMap.mock.funcUpdateObjectByUpdateMap != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateObjectByUpdateMap mock is already set by Set")
	}

	if mmUpdateObjectByUpdateMap.defaultExpectation == nil {
		mmUpdateObjectByUpdateMap.defaultExpectation = &RepositoryMockUpdateObjectByUpdateMapExpectation{mock: mmUpdateObjectByUpdateMap.mock}
	}
	mmUpdateObjectByUpdateMap.defaultExpectation.results = &RepositoryMockUpdateObjectByUpdateMapResults{op1, err}
	mmUpdateObjectByUpdateMap.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateObjectByUpdateMap.mock
}

// Set uses given function f to mock the Repository.UpdateObjectByUpdateMap method
func (mmUpdateObjectByUpdateMap *mRepositoryMockUpdateObjectByUpdateMap) Set(f func(ctx context.Context, objUID types.ObjectUIDType, updateMap map[string]any) (op1 *mm_repository.ObjectModel, err error)) *RepositoryMock {
	if mmUpdateObjectByUpdateMap.defaultExpectation != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateObjectByUpdateMap method")
	}

	if len(mmUpdateObjectByUpdateMap.expectations) > 0 {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateObjectByUpdateMap method")
	}

	mmUpdateObjectByUpdateMap.mock.funcUpdateObjectByUpdateMap = f
	mmUpdateObjectByUpdateMap.mock.funcUpdateObjectByUpdateMapOrigin = minimock.CallerInfo(1)
	return mmUpdateObjectByUpdateMap.mock
}

// When sets expectation for the Repository.UpdateObjectByUpdateMap which will trigger the result defined by the following
// Then helper
func (mmUpdateObjectByUpdateMap *mRepositoryMockUpdateObjectByUpdateMap) When(ctx context.Context, objUID types.ObjectUIDType, updateMap map[string]any) *RepositoryMockUpdateObjectByUpdateMapExpectation {
	if mmUpdateObjectByUpdateMap.mock.funcUpdateObjectByUpdateMap != nil {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("RepositoryMock.UpdateObjectByUpdateMap mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateObjectByUpdateMapExpectation{
		mock:               mmUpdateObjectByUpdateMap.mock,
		params:             &RepositoryMockUpdateObjectByUpdateMapParams{ctx, objUID, updateMap},
		expectationOrigins: RepositoryMockUpdateObjectByUpdateMapExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateObjectByUpdateMap.expectations = append(mmUpdateObjectByUpdateMap.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateObjectByUpdateMap return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateObjectByUpdateMapExpectation) Then(op1 *mm_repository.ObjectModel, err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateObjectByUpdateMapResults{op1, err}
	return e.mock
}

// Times sets number of times Repository.UpdateObjectByUpdateMap should be invoked
func (mmUpdateObjectByUpdateMap *mRepositoryMockUpdateObjectByUpdateMap) Times(n uint64) *mRepositoryMockUpdateObjectByUpdateMap {
	if n == 0 {
		mmUpdateObjectByUpdateMap.mock.t.Fatalf("Times of RepositoryMock.UpdateObjectByUpdateMap mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateObjectByUpdateMap.expectedInvocations, n)
	mmUpdateObjectByUpdateMap.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateObjectByUpdateMap
}

func (mmUpdateObjectByUpdateMap *mRepositoryMockUpdateObjectByUpdateMap) invocationsDone() bool {
	if len(mmUpdateObjectByUpdateMap.expectations) == 0 && mmUpdateObjectByUpdateMap.defaultExpectation == nil && mmUpdateObjectByUpdateMap.mock.funcUpdateObjectByUpdateMap == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateObjectByUpdateMap.mock.afterUpdateObjectByUpdateMapCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateObjectByUpdateMap.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateObjectByUpdateMap implements mm_repository.Repository
func (mmUpdateObjectByUpdateMap *RepositoryMock) UpdateObjectByUpdateMap(ctx context.Context, objUID types.ObjectUIDType, updateMap map[string]any) (op1 *mm_repository.ObjectModel, err error) {
	mm_atomic.AddUint64(&mmUpdateObjectByUpdateMap.beforeUpdateObjectByUpdateMapCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateObjectByUpdateMap.afterUpdateObjectByUpdateMapCounter, 1)

	mmUpdateObjectByUpdateMap.t.Helper()

	if mmUpdateObjectByUpdateMap.inspectFuncUpdateObjectByUpdateMap != nil {
		mmUpdateObjectByUpdateMap.inspectFuncUpdateObjectByUpdateMap(ctx, objUID, updateMap)
	}

	mm_params := RepositoryMockUpdateObjectByUpdateMapParams{ctx, objUID, updateMap}

	// Record call args
	mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.mutex.Lock()
	mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.callArgs = append(mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.callArgs, &mm_params)
	mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.mutex.Unlock()

	for _, e := range mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateObjectByUpdateMapParams{ctx, objUID, updateMap}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateObjectByUpdateMap.t.Errorf("RepositoryMock.UpdateObjectByUpdateMap got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objUID != nil && !minimock.Equal(*mm_want_ptrs.objUID, mm_got.objUID) {
				mmUpdateObjectByUpdateMap.t.Errorf("RepositoryMock.UpdateObjectByUpdateMap got unexpected parameter objUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.defaultExpectation.expectationOrigins.originObjUID, *mm_want_ptrs.objUID, mm_got.objUID, minimock.Diff(*mm_want_ptrs.objUID, mm_got.objUID))
			}

			if mm_want_ptrs.updateMap != nil && !minimock.Equal(*mm_want_ptrs.updateMap, mm_got.updateMap) {
				mmUpdateObjectByUpdateMap.t.Errorf("RepositoryMock.UpdateObjectByUpdateMap got unexpected parameter updateMap, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.defaultExpectation.expectationOrigins.originUpdateMap, *mm_want_ptrs.updateMap, mm_got.updateMap, minimock.Diff(*mm_want_ptrs.updateMap, mm_got.updateMap))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateObjectByUpdateMap.t.Errorf("RepositoryMock.UpdateObjectByUpdateMap got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateObjectByUpdateMap.UpdateObjectByUpdateMapMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateObjectByUpdateMap.t.Fatal("No results are set for the RepositoryMock.UpdateObjectByUpdateMap")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmUpdateObjectByUpdateMap.funcUpdateObjectByUpdateMap != nil {
		return mmUpdateObjectByUpdateMap.funcUpdateObjectByUpdateMap(ctx, objUID, updateMap)
	}
	mmUpdateObjectByUpdateMap.t.Fatalf("Unexpected call to RepositoryMock.UpdateObjectByUpdateMap. %v %v %v", ctx, objUID, updateMap)
	return
}

// UpdateObjectByUpdateMapAfterCounter returns a count of finished RepositoryMock.UpdateObjectByUpdateMap invocations
func (mmUpdateObjectByUpdateMap *RepositoryMock) UpdateObjectByUpdateMapAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateObjectByUpdateMap.afterUpdateObjectByUpdateMapCounter)
}

// UpdateObjectByUpdateMapBeforeCounter returns a count of RepositoryMock.UpdateObjectByUpdateMap invocations
func (mmUpdateObjectByUpdateMap *RepositoryMock) UpdateObjectByUpdateMapBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateObjectByUpdateMap.beforeUpdateObjectByUpdateMapCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateObjectByUpdateMap.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateObjectByUpdateMap *mRepositoryMockUpdateObjectByUpdateMap) Calls() []*RepositoryMockUpdateObjectByUpdateMapParams {
	mmUpdateObjectByUpdateMap.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateObjectByUpdateMapParams, len(mmUpdateObjectByUpdateMap.callArgs))
	copy(argCopy, mmUpdateObjectByUpdateMap.callArgs)

	mmUpdateObjectByUpdateMap.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateObjectByUpdateMapDone returns true if the count of the UpdateObjectByUpdateMap invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateObjectByUpdateMapDone() bool {
	if m.UpdateObjectByUpdateMapMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateObjectByUpdateMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateObjectByUpdateMapMock.invocationsDone()
}

// MinimockUpdateObjectByUpdateMapInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateObjectByUpdateMapInspect() {
	for _, e := range m.UpdateObjectByUpdateMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateObjectByUpdateMap at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateObjectByUpdateMapCounter := mm_atomic.LoadUint64(&m.afterUpdateObjectByUpdateMapCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateObjectByUpdateMapMock.defaultExpectation != nil && afterUpdateObjectByUpdateMapCounter < 1 {
		if m.UpdateObjectByUpdateMapMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateObjectByUpdateMap at\n%s", m.UpdateObjectByUpdateMapMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateObjectByUpdateMap at\n%s with params: %#v", m.UpdateObjectByUpdateMapMock.defaultExpectation.expectationOrigins.origin, *m.UpdateObjectByUpdateMapMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateObjectByUpdateMap != nil && afterUpdateObjectByUpdateMapCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateObjectByUpdateMap at\n%s", m.funcUpdateObjectByUpdateMapOrigin)
	}

	if !m.UpdateObjectByUpdateMapMock.invocationsDone() && afterUpdateObjectByUpdateMapCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateObjectByUpdateMap at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateObjectByUpdateMapMock.expectedInvocations), m.UpdateObjectByUpdateMapMock.expectedInvocationsOrigin, afterUpdateObjectByUpdateMapCounter)
	}
}

type mRepositoryMockUpdateTextChunk struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateTextChunkExpectation
	expectations       []*RepositoryMockUpdateTextChunkExpectation

	callArgs []*RepositoryMockUpdateTextChunkParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateTextChunkExpectation specifies expectation struct of the Repository.UpdateTextChunk
type RepositoryMockUpdateTextChunkExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateTextChunkParams
	paramPtrs          *RepositoryMockUpdateTextChunkParamPtrs
	expectationOrigins RepositoryMockUpdateTextChunkExpectationOrigins
	results            *RepositoryMockUpdateTextChunkResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateTextChunkParams contains parameters of the Repository.UpdateTextChunk
type RepositoryMockUpdateTextChunkParams struct {
	ctx      context.Context
	chunkUID string
	updates  map[string]any
}

// RepositoryMockUpdateTextChunkParamPtrs contains pointers to parameters of the Repository.UpdateTextChunk
type RepositoryMockUpdateTextChunkParamPtrs struct {
	ctx      *context.Context
	chunkUID *string
	updates  *map[string]any
}

// RepositoryMockUpdateTextChunkResults contains results of the Repository.UpdateTextChunk
type RepositoryMockUpdateTextChunkResults struct {
	tp1 *mm_repository.TextChunkModel
	err error
}

// RepositoryMockUpdateTextChunkOrigins contains origins of expectations of the Repository.UpdateTextChunk
type RepositoryMockUpdateTextChunkExpectationOrigins struct {
	origin         string
	originCtx      string
	originChunkUID string
	originUpdates  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateTextChunk *mRepositoryMockUpdateTextChunk) Optional() *mRepositoryMockUpdateTextChunk {
	mmUpdateTextChunk.optional = true
	return mmUpdateTextChunk
}

// Expect sets up expected params for Repository.UpdateTextChunk
func (mmUpdateTextChunk *mRepositoryMockUpdateTextChunk) Expect(ctx context.Context, chunkUID string, updates map[string]any) *mRepositoryMockUpdateTextChunk {
	if mmUpdateTextChunk.mock.funcUpdateTextChunk != nil {
		mmUpdateTextChunk.mock.t.Fatalf("RepositoryMock.UpdateTextChunk mock is already set by Set")
	}

	if mmUpdateTextChunk.defaultExpectation == nil {
		mmUpdateTextChunk.defaultExpectation = &RepositoryMockUpdateTextChunkExpectation{}
	}

	if mmUpdateTextChunk.defaultExpectation.paramPtrs != nil {
		mmUpdateTextChunk.mock.t.Fatalf("RepositoryMock.UpdateTextChunk mock is already set by ExpectParams functions")
	}

	mmUpdateTextChunk.defaultExpectation.params = &RepositoryMockUpdateTextChunkParams{ctx, chunkUID, updates}
	mmUpdateTextChunk.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateTextChunk.expectations {
		if minimock.Equal(e.params, mmUpdateTextChunk.defaultExpectation.params) {
			mmUpdateTextChunk.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateTextChunk.defaultExpectation.params)
		}
	}

	return mmUpdateTextChunk
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateTextChunk
func (mmUpdateTextChunk *mRepositoryMockUpdateTextChunk) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateTextChunk {
	if mmUpdateTextChunk.mock.funcUpdateTextChunk != nil {
		mmUpdateTextChunk.mock.t.Fatalf("RepositoryMock.UpdateTextChunk mock is already set by Set")
	}

	if mmUpdateTextChunk.defaultExpectation == nil {
		mmUpdateTextChunk.defaultExpectation = &RepositoryMockUpdateTextChunkExpectation{}
	}

	if mmUpdateTextChunk.defaultExpectation.params != nil {
		mmUpdateTextChunk.mock.t.Fatalf("RepositoryMock.UpdateTextChunk mock is already set by Expect")
	}

	if mmUpdateTextChunk.defaultExpectation.paramPtrs == nil {
		mmUpdateTextChunk.defaultExpectation.paramPtrs = &RepositoryMockUpdateTextChunkParamPtrs{}
	}
	mmUpdateTextChunk.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateTextChunk.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateTextChunk
}

// ExpectChunkUIDParam2 sets up expected param chunkUID for Repository.UpdateTextChunk
func (mmUpdateTextChunk *mRepositoryMockUpdateTextChunk) ExpectChunkUIDParam2(chunkUID string) *mRepositoryMockUpdateTextChunk {
	if mmUpdateTextChunk.mock.funcUpdateTextChunk != nil {
		mmUpdateTextChunk.mock.t.Fatalf("RepositoryMock.UpdateTextChunk mock is already set by Set")
	}

	if mmUpdateTextChunk.defaultExpectation == nil {
		mmUpdateTextChunk.defaultExpectation = &RepositoryMockUpdateTextChunkExpectation{}
	}

	if mmUpdateTextChunk.defaultExpectation.params != nil {
		mmUpdateTextChunk.mock.t.Fatalf("RepositoryMock.UpdateTextChunk mock is already set by Expect")
	}

	if mmUpdateTextChunk.defaultExpectation.paramPtrs == nil {
		mmUpdateTextChunk.defaultExpectation.paramPtrs = &RepositoryMockUpdateTextChunkParamPtrs{}
	}
	mmUpdateTextChunk.defaultExpectation.paramPtrs.chunkUID = &chunkUID
	mmUpdateTextChunk.defaultExpectation.expectationOrigins.originChunkUID = minimock.CallerInfo(1)

	return mmUpdateTextChunk
}

// ExpectUpdatesParam3 sets up expected param updates for Repository.UpdateTextChunk
func (mmUpdateTextChunk *mRepositoryMockUpdateTextChunk) ExpectUpdatesParam3(updates map[string]any) *mRepositoryMockUpdateTextChunk {
	if mmUpdateTextChunk.mock.funcUpdateTextChunk != nil {
		mmUpdateTextChunk.mock.t.Fatalf("RepositoryMock.UpdateTextChunk mock is already set by Set")
	}

	if mmUpdateTextChunk.defaultExpectation == nil {
		mmUpdateTextChunk.defaultExpectation = &RepositoryMockUpdateTextChunkExpectation{}
	}

	if mmUpdateTextChunk.defaultExpectation.params != nil {
		mmUpdateTextChunk.mock.t.Fatalf("RepositoryMock.UpdateTextChunk mock is already set by Expect")
	}

	if mmUpdateTextChunk.defaultExpectation.paramPtrs == nil {
		mmUpdateTextChunk.defaultExpectation.paramPtrs = &RepositoryMockUpdateTextChunkParamPtrs{}
	}
	mmUpdateTextChunk.defaultExpectation.paramPtrs.updates = &updates
	mmUpdateTextChunk.defaultExpectation.expectationOrigins.originUpdates = minimock.CallerInfo(1)

	return mmUpdateTextChunk
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateTextChunk
func (mmUpdateTextChunk *mRepositoryMockUpdateTextChunk) Inspect(f func(ctx context.Context, chunkUID string, updates map[string]any)) *mRepositoryMockUpdateTextChunk {
	if mmUpdateTextChunk.mock.inspectFuncUpdateTextChunk != nil {
		mmUpdateTextChunk.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateTextChunk")
	}

	mmUpdateTextChunk.mock.inspectFuncUpdateTextChunk = f

	return mmUpdateTextChunk
}

// Return sets up results that will be returned by Repository.UpdateTextChunk
func (mmUpdateTextChunk *mRepositoryMockUpdateTextChunk) Return(tp1 *mm_repository.TextChunkModel, err error) *RepositoryMock {
	if mmUpdateTextChunk.mock.funcUpdateTextChunk != nil {
		mmUpdateTextChunk.mock.t.Fatalf("RepositoryMock.UpdateTextChunk mock is already set by Set")
	}

	if mmUpdateTextChunk.defaultExpectation == nil {
		mmUpdateTextChunk.defaultExpectation = &RepositoryMockUpdateTextChunkExpectation{mock: mmUpdateTextChunk.mock}
	}
	mmUpdateTextChunk.defaultExpectation.results = &RepositoryMockUpdateTextChunkResults{tp1, err}
	mmUpdateTextChunk.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateTextChunk.mock
}

// Set uses given function f to mock the Repository.UpdateTextChunk method
func (mmUpdateTextChunk *mRepositoryMockUpdateTextChunk) Set(f func(ctx context.Context, chunkUID string, updates map[string]any) (tp1 *mm_repository.TextChunkModel, err error)) *RepositoryMock {
	if mmUpdateTextChunk.defaultExpectation != nil {
		mmUpdateTextChunk.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateTextChunk method")
	}

	if len(mmUpdateTextChunk.expectations) > 0 {
		mmUpdateTextChunk.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateTextChunk method")
	}

	mmUpdateTextChunk.mock.funcUpdateTextChunk = f
	mmUpdateTextChunk.mock.funcUpdateTextChunkOrigin = minimock.CallerInfo(1)
	return mmUpdateTextChunk.mock
}

// When sets expectation for the Repository.UpdateTextChunk which will trigger the result defined by the following
// Then helper
func (mmUpdateTextChunk *mRepositoryMockUpdateTextChunk) When(ctx context.Context, chunkUID string, updates map[string]any) *RepositoryMockUpdateTextChunkExpectation {
	if mmUpdateTextChunk.mock.funcUpdateTextChunk != nil {
		mmUpdateTextChunk.mock.t.Fatalf("RepositoryMock.UpdateTextChunk mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateTextChunkExpectation{
		mock:               mmUpdateTextChunk.mock,
		params:             &RepositoryMockUpdateTextChunkParams{ctx, chunkUID, updates},
		expectationOrigins: RepositoryMockUpdateTextChunkExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateTextChunk.expectations = append(mmUpdateTextChunk.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateTextChunk return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateTextChunkExpectation) Then(tp1 *mm_repository.TextChunkModel, err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateTextChunkResults{tp1, err}
	return e.mock
}

// Times sets number of times Repository.UpdateTextChunk should be invoked
func (mmUpdateTextChunk *mRepositoryMockUpdateTextChunk) Times(n uint64) *mRepositoryMockUpdateTextChunk {
	if n == 0 {
		mmUpdateTextChunk.mock.t.Fatalf("Times of RepositoryMock.UpdateTextChunk mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateTextChunk.expectedInvocations, n)
	mmUpdateTextChunk.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateTextChunk
}

func (mmUpdateTextChunk *mRepositoryMockUpdateTextChunk) invocationsDone() bool {
	if len(mmUpdateTextChunk.expectations) == 0 && mmUpdateTextChunk.defaultExpectation == nil && mmUpdateTextChunk.mock.funcUpdateTextChunk == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateTextChunk.mock.afterUpdateTextChunkCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateTextChunk.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateTextChunk implements mm_repository.Repository
func (mmUpdateTextChunk *RepositoryMock) UpdateTextChunk(ctx context.Context, chunkUID string, updates map[string]any) (tp1 *mm_repository.TextChunkModel, err error) {
	mm_atomic.AddUint64(&mmUpdateTextChunk.beforeUpdateTextChunkCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateTextChunk.afterUpdateTextChunkCounter, 1)

	mmUpdateTextChunk.t.Helper()

	if mmUpdateTextChunk.inspectFuncUpdateTextChunk != nil {
		mmUpdateTextChunk.inspectFuncUpdateTextChunk(ctx, chunkUID, updates)
	}

	mm_params := RepositoryMockUpdateTextChunkParams{ctx, chunkUID, updates}

	// Record call args
	mmUpdateTextChunk.UpdateTextChunkMock.mutex.Lock()
	mmUpdateTextChunk.UpdateTextChunkMock.callArgs = append(mmUpdateTextChunk.UpdateTextChunkMock.callArgs, &mm_params)
	mmUpdateTextChunk.UpdateTextChunkMock.mutex.Unlock()

	for _, e := range mmUpdateTextChunk.UpdateTextChunkMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp1, e.results.err
		}
	}

	if mmUpdateTextChunk.UpdateTextChunkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateTextChunk.UpdateTextChunkMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateTextChunk.UpdateTextChunkMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateTextChunk.UpdateTextChunkMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateTextChunkParams{ctx, chunkUID, updates}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateTextChunk.t.Errorf("RepositoryMock.UpdateTextChunk got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateTextChunk.UpdateTextChunkMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chunkUID != nil && !minimock.Equal(*mm_want_ptrs.chunkUID, mm_got.chunkUID) {
				mmUpdateTextChunk.t.Errorf("RepositoryMock.UpdateTextChunk got unexpected parameter chunkUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateTextChunk.UpdateTextChunkMock.defaultExpectation.expectationOrigins.originChunkUID, *mm_want_ptrs.chunkUID, mm_got.chunkUID, minimock.Diff(*mm_want_ptrs.chunkUID, mm_got.chunkUID))
			}

			if mm_want_ptrs.updates != nil && !minimock.Equal(*mm_want_ptrs.updates, mm_got.updates) {
				mmUpdateTextChunk.t.Errorf("RepositoryMock.UpdateTextChunk got unexpected parameter updates, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateTextChunk.UpdateTextChunkMock.defaultExpectation.expectationOrigins.originUpdates, *mm_want_ptrs.updates, mm_got.updates, minimock.Diff(*mm_want_ptrs.updates, mm_got.updates))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateTextChunk.t.Errorf("RepositoryMock.UpdateTextChunk got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateTextChunk.UpdateTextChunkMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateTextChunk.UpdateTextChunkMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateTextChunk.t.Fatal("No results are set for the RepositoryMock.UpdateTextChunk")
		}
		return (*mm_results).tp1, (*mm_results).err
	}
	if mmUpdateTextChunk.funcUpdateTextChunk != nil {
		return mmUpdateTextChunk.funcUpdateTextChunk(ctx, chunkUID, updates)
	}
	mmUpdateTextChunk.t.Fatalf("Unexpected call to RepositoryMock.UpdateTextChunk. %v %v %v", ctx, chunkUID, updates)
	return
}

// UpdateTextChunkAfterCounter returns a count of finished RepositoryMock.UpdateTextChunk invocations
func (mmUpdateTextChunk *RepositoryMock) UpdateTextChunkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateTextChunk.afterUpdateTextChunkCounter)
}

// UpdateTextChunkBeforeCounter returns a count of RepositoryMock.UpdateTextChunk invocations
func (mmUpdateTextChunk *RepositoryMock) UpdateTextChunkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateTextChunk.beforeUpdateTextChunkCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateTextChunk.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateTextChunk *mRepositoryMockUpdateTextChunk) Calls() []*RepositoryMockUpdateTextChunkParams {
	mmUpdateTextChunk.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateTextChunkParams, len(mmUpdateTextChunk.callArgs))
	copy(argCopy, mmUpdateTextChunk.callArgs)

	mmUpdateTextChunk.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateTextChunkDone returns true if the count of the UpdateTextChunk invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateTextChunkDone() bool {
	if m.UpdateTextChunkMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateTextChunkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateTextChunkMock.invocationsDone()
}

// MinimockUpdateTextChunkInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateTextChunkInspect() {
	for _, e := range m.UpdateTextChunkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateTextChunk at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateTextChunkCounter := mm_atomic.LoadUint64(&m.afterUpdateTextChunkCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateTextChunkMock.defaultExpectation != nil && afterUpdateTextChunkCounter < 1 {
		if m.UpdateTextChunkMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateTextChunk at\n%s", m.UpdateTextChunkMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateTextChunk at\n%s with params: %#v", m.UpdateTextChunkMock.defaultExpectation.expectationOrigins.origin, *m.UpdateTextChunkMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateTextChunk != nil && afterUpdateTextChunkCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateTextChunk at\n%s", m.funcUpdateTextChunkOrigin)
	}

	if !m.UpdateTextChunkMock.invocationsDone() && afterUpdateTextChunkCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateTextChunk at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateTextChunkMock.expectedInvocations), m.UpdateTextChunkMock.expectedInvocationsOrigin, afterUpdateTextChunkCounter)
	}
}

type mRepositoryMockUpdateTextChunkDestinations struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateTextChunkDestinationsExpectation
	expectations       []*RepositoryMockUpdateTextChunkDestinationsExpectation

	callArgs []*RepositoryMockUpdateTextChunkDestinationsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateTextChunkDestinationsExpectation specifies expectation struct of the Repository.UpdateTextChunkDestinations
type RepositoryMockUpdateTextChunkDestinationsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateTextChunkDestinationsParams
	paramPtrs          *RepositoryMockUpdateTextChunkDestinationsParamPtrs
	expectationOrigins RepositoryMockUpdateTextChunkDestinationsExpectationOrigins
	results            *RepositoryMockUpdateTextChunkDestinationsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateTextChunkDestinationsParams contains parameters of the Repository.UpdateTextChunkDestinations
type RepositoryMockUpdateTextChunkDestinationsParams struct {
	ctx          context.Context
	destinations map[string]string
}

// RepositoryMockUpdateTextChunkDestinationsParamPtrs contains pointers to parameters of the Repository.UpdateTextChunkDestinations
type RepositoryMockUpdateTextChunkDestinationsParamPtrs struct {
	ctx          *context.Context
	destinations *map[string]string
}

// RepositoryMockUpdateTextChunkDestinationsResults contains results of the Repository.UpdateTextChunkDestinations
type RepositoryMockUpdateTextChunkDestinationsResults struct {
	err error
}

// RepositoryMockUpdateTextChunkDestinationsOrigins contains origins of expectations of the Repository.UpdateTextChunkDestinations
type RepositoryMockUpdateTextChunkDestinationsExpectationOrigins struct {
	origin             string
	originCtx          string
	originDestinations string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateTextChunkDestinations *mRepositoryMockUpdateTextChunkDestinations) Optional() *mRepositoryMockUpdateTextChunkDestinations {
	mmUpdateTextChunkDestinations.optional = true
	return mmUpdateTextChunkDestinations
}

// Expect sets up expected params for Repository.UpdateTextChunkDestinations
func (mmUpdateTextChunkDestinations *mRepositoryMockUpdateTextChunkDestinations) Expect(ctx context.Context, destinations map[string]string) *mRepositoryMockUpdateTextChunkDestinations {
	if mmUpdateTextChunkDestinations.mock.funcUpdateTextChunkDestinations != nil {
		mmUpdateTextChunkDestinations.mock.t.Fatalf("RepositoryMock.UpdateTextChunkDestinations mock is already set by Set")
	}

	if mmUpdateTextChunkDestinations.defaultExpectation == nil {
		mmUpdateTextChunkDestinations.defaultExpectation = &RepositoryMockUpdateTextChunkDestinationsExpectation{}
	}

	if mmUpdateTextChunkDestinations.defaultExpectation.paramPtrs != nil {
		mmUpdateTextChunkDestinations.mock.t.Fatalf("RepositoryMock.UpdateTextChunkDestinations mock is already set by ExpectParams functions")
	}

	mmUpdateTextChunkDestinations.defaultExpectation.params = &RepositoryMockUpdateTextChunkDestinationsParams{ctx, destinations}
	mmUpdateTextChunkDestinations.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateTextChunkDestinations.expectations {
		if minimock.Equal(e.params, mmUpdateTextChunkDestinations.defaultExpectation.params) {
			mmUpdateTextChunkDestinations.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateTextChunkDestinations.defaultExpectation.params)
		}
	}

	return mmUpdateTextChunkDestinations
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateTextChunkDestinations
func (mmUpdateTextChunkDestinations *mRepositoryMockUpdateTextChunkDestinations) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateTextChunkDestinations {
	if mmUpdateTextChunkDestinations.mock.funcUpdateTextChunkDestinations != nil {
		mmUpdateTextChunkDestinations.mock.t.Fatalf("RepositoryMock.UpdateTextChunkDestinations mock is already set by Set")
	}

	if mmUpdateTextChunkDestinations.defaultExpectation == nil {
		mmUpdateTextChunkDestinations.defaultExpectation = &RepositoryMockUpdateTextChunkDestinationsExpectation{}
	}

	if mmUpdateTextChunkDestinations.defaultExpectation.params != nil {
		mmUpdateTextChunkDestinations.mock.t.Fatalf("RepositoryMock.UpdateTextChunkDestinations mock is already set by Expect")
	}

	if mmUpdateTextChunkDestinations.defaultExpectation.paramPtrs == nil {
		mmUpdateTextChunkDestinations.defaultExpectation.paramPtrs = &RepositoryMockUpdateTextChunkDestinationsParamPtrs{}
	}
	mmUpdateTextChunkDestinations.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateTextChunkDestinations.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateTextChunkDestinations
}

// ExpectDestinationsParam2 sets up expected param destinations for Repository.UpdateTextChunkDestinations
func (mmUpdateTextChunkDestinations *mRepositoryMockUpdateTextChunkDestinations) ExpectDestinationsParam2(destinations map[string]string) *mRepositoryMockUpdateTextChunkDestinations {
	if mmUpdateTextChunkDestinations.mock.funcUpdateTextChunkDestinations != nil {
		mmUpdateTextChunkDestinations.mock.t.Fatalf("RepositoryMock.UpdateTextChunkDestinations mock is already set by Set")
	}

	if mmUpdateTextChunkDestinations.defaultExpectation == nil {
		mmUpdateTextChunkDestinations.defaultExpectation = &RepositoryMockUpdateTextChunkDestinationsExpectation{}
	}

	if mmUpdateTextChunkDestinations.defaultExpectation.params != nil {
		mmUpdateTextChunkDestinations.mock.t.Fatalf("RepositoryMock.UpdateTextChunkDestinations mock is already set by Expect")
	}

	if mmUpdateTextChunkDestinations.defaultExpectation.paramPtrs == nil {
		mmUpdateTextChunkDestinations.defaultExpectation.paramPtrs = &RepositoryMockUpdateTextChunkDestinationsParamPtrs{}
	}
	mmUpdateTextChunkDestinations.defaultExpectation.paramPtrs.destinations = &destinations
	mmUpdateTextChunkDestinations.defaultExpectation.expectationOrigins.originDestinations = minimock.CallerInfo(1)

	return mmUpdateTextChunkDestinations
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateTextChunkDestinations
func (mmUpdateTextChunkDestinations *mRepositoryMockUpdateTextChunkDestinations) Inspect(f func(ctx context.Context, destinations map[string]string)) *mRepositoryMockUpdateTextChunkDestinations {
	if mmUpdateTextChunkDestinations.mock.inspectFuncUpdateTextChunkDestinations != nil {
		mmUpdateTextChunkDestinations.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateTextChunkDestinations")
	}

	mmUpdateTextChunkDestinations.mock.inspectFuncUpdateTextChunkDestinations = f

	return mmUpdateTextChunkDestinations
}

// Return sets up results that will be returned by Repository.UpdateTextChunkDestinations
func (mmUpdateTextChunkDestinations *mRepositoryMockUpdateTextChunkDestinations) Return(err error) *RepositoryMock {
	if mmUpdateTextChunkDestinations.mock.funcUpdateTextChunkDestinations != nil {
		mmUpdateTextChunkDestinations.mock.t.Fatalf("RepositoryMock.UpdateTextChunkDestinations mock is already set by Set")
	}

	if mmUpdateTextChunkDestinations.defaultExpectation == nil {
		mmUpdateTextChunkDestinations.defaultExpectation = &RepositoryMockUpdateTextChunkDestinationsExpectation{mock: mmUpdateTextChunkDestinations.mock}
	}
	mmUpdateTextChunkDestinations.defaultExpectation.results = &RepositoryMockUpdateTextChunkDestinationsResults{err}
	mmUpdateTextChunkDestinations.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateTextChunkDestinations.mock
}

// Set uses given function f to mock the Repository.UpdateTextChunkDestinations method
func (mmUpdateTextChunkDestinations *mRepositoryMockUpdateTextChunkDestinations) Set(f func(ctx context.Context, destinations map[string]string) (err error)) *RepositoryMock {
	if mmUpdateTextChunkDestinations.defaultExpectation != nil {
		mmUpdateTextChunkDestinations.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateTextChunkDestinations method")
	}

	if len(mmUpdateTextChunkDestinations.expectations) > 0 {
		mmUpdateTextChunkDestinations.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateTextChunkDestinations method")
	}

	mmUpdateTextChunkDestinations.mock.funcUpdateTextChunkDestinations = f
	mmUpdateTextChunkDestinations.mock.funcUpdateTextChunkDestinationsOrigin = minimock.CallerInfo(1)
	return mmUpdateTextChunkDestinations.mock
}

// When sets expectation for the Repository.UpdateTextChunkDestinations which will trigger the result defined by the following
// Then helper
func (mmUpdateTextChunkDestinations *mRepositoryMockUpdateTextChunkDestinations) When(ctx context.Context, destinations map[string]string) *RepositoryMockUpdateTextChunkDestinationsExpectation {
	if mmUpdateTextChunkDestinations.mock.funcUpdateTextChunkDestinations != nil {
		mmUpdateTextChunkDestinations.mock.t.Fatalf("RepositoryMock.UpdateTextChunkDestinations mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateTextChunkDestinationsExpectation{
		mock:               mmUpdateTextChunkDestinations.mock,
		params:             &RepositoryMockUpdateTextChunkDestinationsParams{ctx, destinations},
		expectationOrigins: RepositoryMockUpdateTextChunkDestinationsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateTextChunkDestinations.expectations = append(mmUpdateTextChunkDestinations.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateTextChunkDestinations return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateTextChunkDestinationsExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateTextChunkDestinationsResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateTextChunkDestinations should be invoked
func (mmUpdateTextChunkDestinations *mRepositoryMockUpdateTextChunkDestinations) Times(n uint64) *mRepositoryMockUpdateTextChunkDestinations {
	if n == 0 {
		mmUpdateTextChunkDestinations.mock.t.Fatalf("Times of RepositoryMock.UpdateTextChunkDestinations mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateTextChunkDestinations.expectedInvocations, n)
	mmUpdateTextChunkDestinations.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateTextChunkDestinations
}

func (mmUpdateTextChunkDestinations *mRepositoryMockUpdateTextChunkDestinations) invocationsDone() bool {
	if len(mmUpdateTextChunkDestinations.expectations) == 0 && mmUpdateTextChunkDestinations.defaultExpectation == nil && mmUpdateTextChunkDestinations.mock.funcUpdateTextChunkDestinations == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateTextChunkDestinations.mock.afterUpdateTextChunkDestinationsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateTextChunkDestinations.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateTextChunkDestinations implements mm_repository.Repository
func (mmUpdateTextChunkDestinations *RepositoryMock) UpdateTextChunkDestinations(ctx context.Context, destinations map[string]string) (err error) {
	mm_atomic.AddUint64(&mmUpdateTextChunkDestinations.beforeUpdateTextChunkDestinationsCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateTextChunkDestinations.afterUpdateTextChunkDestinationsCounter, 1)

	mmUpdateTextChunkDestinations.t.Helper()

	if mmUpdateTextChunkDestinations.inspectFuncUpdateTextChunkDestinations != nil {
		mmUpdateTextChunkDestinations.inspectFuncUpdateTextChunkDestinations(ctx, destinations)
	}

	mm_params := RepositoryMockUpdateTextChunkDestinationsParams{ctx, destinations}

	// Record call args
	mmUpdateTextChunkDestinations.UpdateTextChunkDestinationsMock.mutex.Lock()
	mmUpdateTextChunkDestinations.UpdateTextChunkDestinationsMock.callArgs = append(mmUpdateTextChunkDestinations.UpdateTextChunkDestinationsMock.callArgs, &mm_params)
	mmUpdateTextChunkDestinations.UpdateTextChunkDestinationsMock.mutex.Unlock()

	for _, e := range mmUpdateTextChunkDestinations.UpdateTextChunkDestinationsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateTextChunkDestinations.UpdateTextChunkDestinationsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateTextChunkDestinations.UpdateTextChunkDestinationsMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateTextChunkDestinations.UpdateTextChunkDestinationsMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateTextChunkDestinations.UpdateTextChunkDestinationsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateTextChunkDestinationsParams{ctx, destinations}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateTextChunkDestinations.t.Errorf("RepositoryMock.UpdateTextChunkDestinations got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateTextChunkDestinations.UpdateTextChunkDestinationsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.destinations != nil && !minimock.Equal(*mm_want_ptrs.destinations, mm_got.destinations) {
				mmUpdateTextChunkDestinations.t.Errorf("RepositoryMock.UpdateTextChunkDestinations got unexpected parameter destinations, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateTextChunkDestinations.UpdateTextChunkDestinationsMock.defaultExpectation.expectationOrigins.originDestinations, *mm_want_ptrs.destinations, mm_got.destinations, minimock.Diff(*mm_want_ptrs.destinations, mm_got.destinations))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateTextChunkDestinations.t.Errorf("RepositoryMock.UpdateTextChunkDestinations got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateTextChunkDestinations.UpdateTextChunkDestinationsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateTextChunkDestinations.UpdateTextChunkDestinationsMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateTextChunkDestinations.t.Fatal("No results are set for the RepositoryMock.UpdateTextChunkDestinations")
		}
		return (*mm_results).err
	}
	if mmUpdateTextChunkDestinations.funcUpdateTextChunkDestinations != nil {
		return mmUpdateTextChunkDestinations.funcUpdateTextChunkDestinations(ctx, destinations)
	}
	mmUpdateTextChunkDestinations.t.Fatalf("Unexpected call to RepositoryMock.UpdateTextChunkDestinations. %v %v", ctx, destinations)
	return
}

// UpdateTextChunkDestinationsAfterCounter returns a count of finished RepositoryMock.UpdateTextChunkDestinations invocations
func (mmUpdateTextChunkDestinations *RepositoryMock) UpdateTextChunkDestinationsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateTextChunkDestinations.afterUpdateTextChunkDestinationsCounter)
}

// UpdateTextChunkDestinationsBeforeCounter returns a count of RepositoryMock.UpdateTextChunkDestinations invocations
func (mmUpdateTextChunkDestinations *RepositoryMock) UpdateTextChunkDestinationsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateTextChunkDestinations.beforeUpdateTextChunkDestinationsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateTextChunkDestinations.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateTextChunkDestinations *mRepositoryMockUpdateTextChunkDestinations) Calls() []*RepositoryMockUpdateTextChunkDestinationsParams {
	mmUpdateTextChunkDestinations.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateTextChunkDestinationsParams, len(mmUpdateTextChunkDestinations.callArgs))
	copy(argCopy, mmUpdateTextChunkDestinations.callArgs)

	mmUpdateTextChunkDestinations.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateTextChunkDestinationsDone returns true if the count of the UpdateTextChunkDestinations invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateTextChunkDestinationsDone() bool {
	if m.UpdateTextChunkDestinationsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateTextChunkDestinationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateTextChunkDestinationsMock.invocationsDone()
}

// MinimockUpdateTextChunkDestinationsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateTextChunkDestinationsInspect() {
	for _, e := range m.UpdateTextChunkDestinationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateTextChunkDestinations at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateTextChunkDestinationsCounter := mm_atomic.LoadUint64(&m.afterUpdateTextChunkDestinationsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateTextChunkDestinationsMock.defaultExpectation != nil && afterUpdateTextChunkDestinationsCounter < 1 {
		if m.UpdateTextChunkDestinationsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateTextChunkDestinations at\n%s", m.UpdateTextChunkDestinationsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateTextChunkDestinations at\n%s with params: %#v", m.UpdateTextChunkDestinationsMock.defaultExpectation.expectationOrigins.origin, *m.UpdateTextChunkDestinationsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateTextChunkDestinations != nil && afterUpdateTextChunkDestinationsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateTextChunkDestinations at\n%s", m.funcUpdateTextChunkDestinationsOrigin)
	}

	if !m.UpdateTextChunkDestinationsMock.invocationsDone() && afterUpdateTextChunkDestinationsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateTextChunkDestinations at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateTextChunkDestinationsMock.expectedInvocations), m.UpdateTextChunkDestinationsMock.expectedInvocationsOrigin, afterUpdateTextChunkDestinationsCounter)
	}
}

type mRepositoryMockUploadBase64File struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUploadBase64FileExpectation
	expectations       []*RepositoryMockUploadBase64FileExpectation

	callArgs []*RepositoryMockUploadBase64FileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUploadBase64FileExpectation specifies expectation struct of the Repository.UploadBase64File
type RepositoryMockUploadBase64FileExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUploadBase64FileParams
	paramPtrs          *RepositoryMockUploadBase64FileParamPtrs
	expectationOrigins RepositoryMockUploadBase64FileExpectationOrigins
	results            *RepositoryMockUploadBase64FileResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUploadBase64FileParams contains parameters of the Repository.UploadBase64File
type RepositoryMockUploadBase64FileParams struct {
	ctx           context.Context
	bucket        string
	filePath      string
	base64Content string
	fileMimeType  string
}

// RepositoryMockUploadBase64FileParamPtrs contains pointers to parameters of the Repository.UploadBase64File
type RepositoryMockUploadBase64FileParamPtrs struct {
	ctx           *context.Context
	bucket        *string
	filePath      *string
	base64Content *string
	fileMimeType  *string
}

// RepositoryMockUploadBase64FileResults contains results of the Repository.UploadBase64File
type RepositoryMockUploadBase64FileResults struct {
	err error
}

// RepositoryMockUploadBase64FileOrigins contains origins of expectations of the Repository.UploadBase64File
type RepositoryMockUploadBase64FileExpectationOrigins struct {
	origin              string
	originCtx           string
	originBucket        string
	originFilePath      string
	originBase64Content string
	originFileMimeType  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUploadBase64File *mRepositoryMockUploadBase64File) Optional() *mRepositoryMockUploadBase64File {
	mmUploadBase64File.optional = true
	return mmUploadBase64File
}

// Expect sets up expected params for Repository.UploadBase64File
func (mmUploadBase64File *mRepositoryMockUploadBase64File) Expect(ctx context.Context, bucket string, filePath string, base64Content string, fileMimeType string) *mRepositoryMockUploadBase64File {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("RepositoryMock.UploadBase64File mock is already set by Set")
	}

	if mmUploadBase64File.defaultExpectation == nil {
		mmUploadBase64File.defaultExpectation = &RepositoryMockUploadBase64FileExpectation{}
	}

	if mmUploadBase64File.defaultExpectation.paramPtrs != nil {
		mmUploadBase64File.mock.t.Fatalf("RepositoryMock.UploadBase64File mock is already set by ExpectParams functions")
	}

	mmUploadBase64File.defaultExpectation.params = &RepositoryMockUploadBase64FileParams{ctx, bucket, filePath, base64Content, fileMimeType}
	mmUploadBase64File.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUploadBase64File.expectations {
		if minimock.Equal(e.params, mmUploadBase64File.defaultExpectation.params) {
			mmUploadBase64File.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUploadBase64File.defaultExpectation.params)
		}
	}

	return mmUploadBase64File
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UploadBase64File
func (mmUploadBase64File *mRepositoryMockUploadBase64File) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUploadBase64File {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("RepositoryMock.UploadBase64File mock is already set by Set")
	}

	if mmUploadBase64File.defaultExpectation == nil {
		mmUploadBase64File.defaultExpectation = &RepositoryMockUploadBase64FileExpectation{}
	}

	if mmUploadBase64File.defaultExpectation.params != nil {
		mmUploadBase64File.mock.t.Fatalf("RepositoryMock.UploadBase64File mock is already set by Expect")
	}

	if mmUploadBase64File.defaultExpectation.paramPtrs == nil {
		mmUploadBase64File.defaultExpectation.paramPtrs = &RepositoryMockUploadBase64FileParamPtrs{}
	}
	mmUploadBase64File.defaultExpectation.paramPtrs.ctx = &ctx
	mmUploadBase64File.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUploadBase64File
}

// ExpectBucketParam2 sets up expected param bucket for Repository.UploadBase64File
func (mmUploadBase64File *mRepositoryMockUploadBase64File) ExpectBucketParam2(bucket string) *mRepositoryMockUploadBase64File {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("RepositoryMock.UploadBase64File mock is already set by Set")
	}

	if mmUploadBase64File.defaultExpectation == nil {
		mmUploadBase64File.defaultExpectation = &RepositoryMockUploadBase64FileExpectation{}
	}

	if mmUploadBase64File.defaultExpectation.params != nil {
		mmUploadBase64File.mock.t.Fatalf("RepositoryMock.UploadBase64File mock is already set by Expect")
	}

	if mmUploadBase64File.defaultExpectation.paramPtrs == nil {
		mmUploadBase64File.defaultExpectation.paramPtrs = &RepositoryMockUploadBase64FileParamPtrs{}
	}
	mmUploadBase64File.defaultExpectation.paramPtrs.bucket = &bucket
	mmUploadBase64File.defaultExpectation.expectationOrigins.originBucket = minimock.CallerInfo(1)

	return mmUploadBase64File
}

// ExpectFilePathParam3 sets up expected param filePath for Repository.UploadBase64File
func (mmUploadBase64File *mRepositoryMockUploadBase64File) ExpectFilePathParam3(filePath string) *mRepositoryMockUploadBase64File {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("RepositoryMock.UploadBase64File mock is already set by Set")
	}

	if mmUploadBase64File.defaultExpectation == nil {
		mmUploadBase64File.defaultExpectation = &RepositoryMockUploadBase64FileExpectation{}
	}

	if mmUploadBase64File.defaultExpectation.params != nil {
		mmUploadBase64File.mock.t.Fatalf("RepositoryMock.UploadBase64File mock is already set by Expect")
	}

	if mmUploadBase64File.defaultExpectation.paramPtrs == nil {
		mmUploadBase64File.defaultExpectation.paramPtrs = &RepositoryMockUploadBase64FileParamPtrs{}
	}
	mmUploadBase64File.defaultExpectation.paramPtrs.filePath = &filePath
	mmUploadBase64File.defaultExpectation.expectationOrigins.originFilePath = minimock.CallerInfo(1)

	return mmUploadBase64File
}

// ExpectBase64ContentParam4 sets up expected param base64Content for Repository.UploadBase64File
func (mmUploadBase64File *mRepositoryMockUploadBase64File) ExpectBase64ContentParam4(base64Content string) *mRepositoryMockUploadBase64File {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("RepositoryMock.UploadBase64File mock is already set by Set")
	}

	if mmUploadBase64File.defaultExpectation == nil {
		mmUploadBase64File.defaultExpectation = &RepositoryMockUploadBase64FileExpectation{}
	}

	if mmUploadBase64File.defaultExpectation.params != nil {
		mmUploadBase64File.mock.t.Fatalf("RepositoryMock.UploadBase64File mock is already set by Expect")
	}

	if mmUploadBase64File.defaultExpectation.paramPtrs == nil {
		mmUploadBase64File.defaultExpectation.paramPtrs = &RepositoryMockUploadBase64FileParamPtrs{}
	}
	mmUploadBase64File.defaultExpectation.paramPtrs.base64Content = &base64Content
	mmUploadBase64File.defaultExpectation.expectationOrigins.originBase64Content = minimock.CallerInfo(1)

	return mmUploadBase64File
}

// ExpectFileMimeTypeParam5 sets up expected param fileMimeType for Repository.UploadBase64File
func (mmUploadBase64File *mRepositoryMockUploadBase64File) ExpectFileMimeTypeParam5(fileMimeType string) *mRepositoryMockUploadBase64File {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("RepositoryMock.UploadBase64File mock is already set by Set")
	}

	if mmUploadBase64File.defaultExpectation == nil {
		mmUploadBase64File.defaultExpectation = &RepositoryMockUploadBase64FileExpectation{}
	}

	if mmUploadBase64File.defaultExpectation.params != nil {
		mmUploadBase64File.mock.t.Fatalf("RepositoryMock.UploadBase64File mock is already set by Expect")
	}

	if mmUploadBase64File.defaultExpectation.paramPtrs == nil {
		mmUploadBase64File.defaultExpectation.paramPtrs = &RepositoryMockUploadBase64FileParamPtrs{}
	}
	mmUploadBase64File.defaultExpectation.paramPtrs.fileMimeType = &fileMimeType
	mmUploadBase64File.defaultExpectation.expectationOrigins.originFileMimeType = minimock.CallerInfo(1)

	return mmUploadBase64File
}

// Inspect accepts an inspector function that has same arguments as the Repository.UploadBase64File
func (mmUploadBase64File *mRepositoryMockUploadBase64File) Inspect(f func(ctx context.Context, bucket string, filePath string, base64Content string, fileMimeType string)) *mRepositoryMockUploadBase64File {
	if mmUploadBase64File.mock.inspectFuncUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UploadBase64File")
	}

	mmUploadBase64File.mock.inspectFuncUploadBase64File = f

	return mmUploadBase64File
}

// Return sets up results that will be returned by Repository.UploadBase64File
func (mmUploadBase64File *mRepositoryMockUploadBase64File) Return(err error) *RepositoryMock {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("RepositoryMock.UploadBase64File mock is already set by Set")
	}

	if mmUploadBase64File.defaultExpectation == nil {
		mmUploadBase64File.defaultExpectation = &RepositoryMockUploadBase64FileExpectation{mock: mmUploadBase64File.mock}
	}
	mmUploadBase64File.defaultExpectation.results = &RepositoryMockUploadBase64FileResults{err}
	mmUploadBase64File.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUploadBase64File.mock
}

// Set uses given function f to mock the Repository.UploadBase64File method
func (mmUploadBase64File *mRepositoryMockUploadBase64File) Set(f func(ctx context.Context, bucket string, filePath string, base64Content string, fileMimeType string) (err error)) *RepositoryMock {
	if mmUploadBase64File.defaultExpectation != nil {
		mmUploadBase64File.mock.t.Fatalf("Default expectation is already set for the Repository.UploadBase64File method")
	}

	if len(mmUploadBase64File.expectations) > 0 {
		mmUploadBase64File.mock.t.Fatalf("Some expectations are already set for the Repository.UploadBase64File method")
	}

	mmUploadBase64File.mock.funcUploadBase64File = f
	mmUploadBase64File.mock.funcUploadBase64FileOrigin = minimock.CallerInfo(1)
	return mmUploadBase64File.mock
}

// When sets expectation for the Repository.UploadBase64File which will trigger the result defined by the following
// Then helper
func (mmUploadBase64File *mRepositoryMockUploadBase64File) When(ctx context.Context, bucket string, filePath string, base64Content string, fileMimeType string) *RepositoryMockUploadBase64FileExpectation {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("RepositoryMock.UploadBase64File mock is already set by Set")
	}

	expectation := &RepositoryMockUploadBase64FileExpectation{
		mock:               mmUploadBase64File.mock,
		params:             &RepositoryMockUploadBase64FileParams{ctx, bucket, filePath, base64Content, fileMimeType},
		expectationOrigins: RepositoryMockUploadBase64FileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUploadBase64File.expectations = append(mmUploadBase64File.expectations, expectation)
	return expectation
}

// Then sets up Repository.UploadBase64File return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUploadBase64FileExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUploadBase64FileResults{err}
	return e.mock
}

// Times sets number of times Repository.UploadBase64File should be invoked
func (mmUploadBase64File *mRepositoryMockUploadBase64File) Times(n uint64) *mRepositoryMockUploadBase64File {
	if n == 0 {
		mmUploadBase64File.mock.t.Fatalf("Times of RepositoryMock.UploadBase64File mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUploadBase64File.expectedInvocations, n)
	mmUploadBase64File.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUploadBase64File
}

func (mmUploadBase64File *mRepositoryMockUploadBase64File) invocationsDone() bool {
	if len(mmUploadBase64File.expectations) == 0 && mmUploadBase64File.defaultExpectation == nil && mmUploadBase64File.mock.funcUploadBase64File == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUploadBase64File.mock.afterUploadBase64FileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUploadBase64File.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UploadBase64File implements mm_repository.Repository
func (mmUploadBase64File *RepositoryMock) UploadBase64File(ctx context.Context, bucket string, filePath string, base64Content string, fileMimeType string) (err error) {
	mm_atomic.AddUint64(&mmUploadBase64File.beforeUploadBase64FileCounter, 1)
	defer mm_atomic.AddUint64(&mmUploadBase64File.afterUploadBase64FileCounter, 1)

	mmUploadBase64File.t.Helper()

	if mmUploadBase64File.inspectFuncUploadBase64File != nil {
		mmUploadBase64File.inspectFuncUploadBase64File(ctx, bucket, filePath, base64Content, fileMimeType)
	}

	mm_params := RepositoryMockUploadBase64FileParams{ctx, bucket, filePath, base64Content, fileMimeType}

	// Record call args
	mmUploadBase64File.UploadBase64FileMock.mutex.Lock()
	mmUploadBase64File.UploadBase64FileMock.callArgs = append(mmUploadBase64File.UploadBase64FileMock.callArgs, &mm_params)
	mmUploadBase64File.UploadBase64FileMock.mutex.Unlock()

	for _, e := range mmUploadBase64File.UploadBase64FileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUploadBase64File.UploadBase64FileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUploadBase64File.UploadBase64FileMock.defaultExpectation.Counter, 1)
		mm_want := mmUploadBase64File.UploadBase64FileMock.defaultExpectation.params
		mm_want_ptrs := mmUploadBase64File.UploadBase64FileMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUploadBase64FileParams{ctx, bucket, filePath, base64Content, fileMimeType}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUploadBase64File.t.Errorf("RepositoryMock.UploadBase64File got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadBase64File.UploadBase64FileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.bucket != nil && !minimock.Equal(*mm_want_ptrs.bucket, mm_got.bucket) {
				mmUploadBase64File.t.Errorf("RepositoryMock.UploadBase64File got unexpected parameter bucket, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadBase64File.UploadBase64FileMock.defaultExpectation.expectationOrigins.originBucket, *mm_want_ptrs.bucket, mm_got.bucket, minimock.Diff(*mm_want_ptrs.bucket, mm_got.bucket))
			}

			if mm_want_ptrs.filePath != nil && !minimock.Equal(*mm_want_ptrs.filePath, mm_got.filePath) {
				mmUploadBase64File.t.Errorf("RepositoryMock.UploadBase64File got unexpected parameter filePath, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadBase64File.UploadBase64FileMock.defaultExpectation.expectationOrigins.originFilePath, *mm_want_ptrs.filePath, mm_got.filePath, minimock.Diff(*mm_want_ptrs.filePath, mm_got.filePath))
			}

			if mm_want_ptrs.base64Content != nil && !minimock.Equal(*mm_want_ptrs.base64Content, mm_got.base64Content) {
				mmUploadBase64File.t.Errorf("RepositoryMock.UploadBase64File got unexpected parameter base64Content, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadBase64File.UploadBase64FileMock.defaultExpectation.expectationOrigins.originBase64Content, *mm_want_ptrs.base64Content, mm_got.base64Content, minimock.Diff(*mm_want_ptrs.base64Content, mm_got.base64Content))
			}

			if mm_want_ptrs.fileMimeType != nil && !minimock.Equal(*mm_want_ptrs.fileMimeType, mm_got.fileMimeType) {
				mmUploadBase64File.t.Errorf("RepositoryMock.UploadBase64File got unexpected parameter fileMimeType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadBase64File.UploadBase64FileMock.defaultExpectation.expectationOrigins.originFileMimeType, *mm_want_ptrs.fileMimeType, mm_got.fileMimeType, minimock.Diff(*mm_want_ptrs.fileMimeType, mm_got.fileMimeType))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUploadBase64File.t.Errorf("RepositoryMock.UploadBase64File got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUploadBase64File.UploadBase64FileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUploadBase64File.UploadBase64FileMock.defaultExpectation.results
		if mm_results == nil {
			mmUploadBase64File.t.Fatal("No results are set for the RepositoryMock.UploadBase64File")
		}
		return (*mm_results).err
	}
	if mmUploadBase64File.funcUploadBase64File != nil {
		return mmUploadBase64File.funcUploadBase64File(ctx, bucket, filePath, base64Content, fileMimeType)
	}
	mmUploadBase64File.t.Fatalf("Unexpected call to RepositoryMock.UploadBase64File. %v %v %v %v %v", ctx, bucket, filePath, base64Content, fileMimeType)
	return
}

// UploadBase64FileAfterCounter returns a count of finished RepositoryMock.UploadBase64File invocations
func (mmUploadBase64File *RepositoryMock) UploadBase64FileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadBase64File.afterUploadBase64FileCounter)
}

// UploadBase64FileBeforeCounter returns a count of RepositoryMock.UploadBase64File invocations
func (mmUploadBase64File *RepositoryMock) UploadBase64FileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadBase64File.beforeUploadBase64FileCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UploadBase64File.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUploadBase64File *mRepositoryMockUploadBase64File) Calls() []*RepositoryMockUploadBase64FileParams {
	mmUploadBase64File.mutex.RLock()

	argCopy := make([]*RepositoryMockUploadBase64FileParams, len(mmUploadBase64File.callArgs))
	copy(argCopy, mmUploadBase64File.callArgs)

	mmUploadBase64File.mutex.RUnlock()

	return argCopy
}

// MinimockUploadBase64FileDone returns true if the count of the UploadBase64File invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUploadBase64FileDone() bool {
	if m.UploadBase64FileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UploadBase64FileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UploadBase64FileMock.invocationsDone()
}

// MinimockUploadBase64FileInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUploadBase64FileInspect() {
	for _, e := range m.UploadBase64FileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UploadBase64File at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUploadBase64FileCounter := mm_atomic.LoadUint64(&m.afterUploadBase64FileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UploadBase64FileMock.defaultExpectation != nil && afterUploadBase64FileCounter < 1 {
		if m.UploadBase64FileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UploadBase64File at\n%s", m.UploadBase64FileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UploadBase64File at\n%s with params: %#v", m.UploadBase64FileMock.defaultExpectation.expectationOrigins.origin, *m.UploadBase64FileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUploadBase64File != nil && afterUploadBase64FileCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UploadBase64File at\n%s", m.funcUploadBase64FileOrigin)
	}

	if !m.UploadBase64FileMock.invocationsDone() && afterUploadBase64FileCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UploadBase64File at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UploadBase64FileMock.expectedInvocations), m.UploadBase64FileMock.expectedInvocationsOrigin, afterUploadBase64FileCounter)
	}
}

type mRepositoryMockUpsertRepositoryTag struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpsertRepositoryTagExpectation
	expectations       []*RepositoryMockUpsertRepositoryTagExpectation

	callArgs []*RepositoryMockUpsertRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpsertRepositoryTagExpectation specifies expectation struct of the Repository.UpsertRepositoryTag
type RepositoryMockUpsertRepositoryTagExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpsertRepositoryTagParams
	paramPtrs          *RepositoryMockUpsertRepositoryTagParamPtrs
	expectationOrigins RepositoryMockUpsertRepositoryTagExpectationOrigins
	results            *RepositoryMockUpsertRepositoryTagResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpsertRepositoryTagParams contains parameters of the Repository.UpsertRepositoryTag
type RepositoryMockUpsertRepositoryTagParams struct {
	ctx context.Context
	tp1 *types.Tag
}

// RepositoryMockUpsertRepositoryTagParamPtrs contains pointers to parameters of the Repository.UpsertRepositoryTag
type RepositoryMockUpsertRepositoryTagParamPtrs struct {
	ctx *context.Context
	tp1 **types.Tag
}

// RepositoryMockUpsertRepositoryTagResults contains results of the Repository.UpsertRepositoryTag
type RepositoryMockUpsertRepositoryTagResults struct {
	tp2 *types.Tag
	err error
}

// RepositoryMockUpsertRepositoryTagOrigins contains origins of expectations of the Repository.UpsertRepositoryTag
type RepositoryMockUpsertRepositoryTagExpectationOrigins struct {
	origin    string
	originCtx string
	originTp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) Optional() *mRepositoryMockUpsertRepositoryTag {
	mmUpsertRepositoryTag.optional = true
	return mmUpsertRepositoryTag
}

// Expect sets up expected params for Repository.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) Expect(ctx context.Context, tp1 *types.Tag) *mRepositoryMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryMockUpsertRepositoryTagExpectation{}
	}

	if mmUpsertRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by ExpectParams functions")
	}

	mmUpsertRepositoryTag.defaultExpectation.params = &RepositoryMockUpsertRepositoryTagParams{ctx, tp1}
	mmUpsertRepositoryTag.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpsertRepositoryTag.expectations {
		if minimock.Equal(e.params, mmUpsertRepositoryTag.defaultExpectation.params) {
			mmUpsertRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertRepositoryTag.defaultExpectation.params)
		}
	}

	return mmUpsertRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryMockUpsertRepositoryTagExpectation{}
	}

	if mmUpsertRepositoryTag.defaultExpectation.params != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by Expect")
	}

	if mmUpsertRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmUpsertRepositoryTag.defaultExpectation.paramPtrs = &RepositoryMockUpsertRepositoryTagParamPtrs{}
	}
	mmUpsertRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpsertRepositoryTag.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpsertRepositoryTag
}

// ExpectTp1Param2 sets up expected param tp1 for Repository.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) ExpectTp1Param2(tp1 *types.Tag) *mRepositoryMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryMockUpsertRepositoryTagExpectation{}
	}

	if mmUpsertRepositoryTag.defaultExpectation.params != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by Expect")
	}

	if mmUpsertRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmUpsertRepositoryTag.defaultExpectation.paramPtrs = &RepositoryMockUpsertRepositoryTagParamPtrs{}
	}
	mmUpsertRepositoryTag.defaultExpectation.paramPtrs.tp1 = &tp1
	mmUpsertRepositoryTag.defaultExpectation.expectationOrigins.originTp1 = minimock.CallerInfo(1)

	return mmUpsertRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) Inspect(f func(ctx context.Context, tp1 *types.Tag)) *mRepositoryMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.inspectFuncUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpsertRepositoryTag")
	}

	mmUpsertRepositoryTag.mock.inspectFuncUpsertRepositoryTag = f

	return mmUpsertRepositoryTag
}

// Return sets up results that will be returned by Repository.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) Return(tp2 *types.Tag, err error) *RepositoryMock {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryMockUpsertRepositoryTagExpectation{mock: mmUpsertRepositoryTag.mock}
	}
	mmUpsertRepositoryTag.defaultExpectation.results = &RepositoryMockUpsertRepositoryTagResults{tp2, err}
	mmUpsertRepositoryTag.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpsertRepositoryTag.mock
}

// Set uses given function f to mock the Repository.UpsertRepositoryTag method
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) Set(f func(ctx context.Context, tp1 *types.Tag) (tp2 *types.Tag, err error)) *RepositoryMock {
	if mmUpsertRepositoryTag.defaultExpectation != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("Default expectation is already set for the Repository.UpsertRepositoryTag method")
	}

	if len(mmUpsertRepositoryTag.expectations) > 0 {
		mmUpsertRepositoryTag.mock.t.Fatalf("Some expectations are already set for the Repository.UpsertRepositoryTag method")
	}

	mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag = f
	mmUpsertRepositoryTag.mock.funcUpsertRepositoryTagOrigin = minimock.CallerInfo(1)
	return mmUpsertRepositoryTag.mock
}

// When sets expectation for the Repository.UpsertRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) When(ctx context.Context, tp1 *types.Tag) *RepositoryMockUpsertRepositoryTagExpectation {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by Set")
	}

	expectation := &RepositoryMockUpsertRepositoryTagExpectation{
		mock:               mmUpsertRepositoryTag.mock,
		params:             &RepositoryMockUpsertRepositoryTagParams{ctx, tp1},
		expectationOrigins: RepositoryMockUpsertRepositoryTagExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpsertRepositoryTag.expectations = append(mmUpsertRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpsertRepositoryTag return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpsertRepositoryTagExpectation) Then(tp2 *types.Tag, err error) *RepositoryMock {
	e.results = &RepositoryMockUpsertRepositoryTagResults{tp2, err}
	return e.mock
}

// Times sets number of times Repository.UpsertRepositoryTag should be invoked
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) Times(n uint64) *mRepositoryMockUpsertRepositoryTag {
	if n == 0 {
		mmUpsertRepositoryTag.mock.t.Fatalf("Times of RepositoryMock.UpsertRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpsertRepositoryTag.expectedInvocations, n)
	mmUpsertRepositoryTag.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpsertRepositoryTag
}

func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) invocationsDone() bool {
	if len(mmUpsertRepositoryTag.expectations) == 0 && mmUpsertRepositoryTag.defaultExpectation == nil && mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpsertRepositoryTag.mock.afterUpsertRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpsertRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpsertRepositoryTag implements mm_repository.Repository
func (mmUpsertRepositoryTag *RepositoryMock) UpsertRepositoryTag(ctx context.Context, tp1 *types.Tag) (tp2 *types.Tag, err error) {
	mm_atomic.AddUint64(&mmUpsertRepositoryTag.beforeUpsertRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertRepositoryTag.afterUpsertRepositoryTagCounter, 1)

	mmUpsertRepositoryTag.t.Helper()

	if mmUpsertRepositoryTag.inspectFuncUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.inspectFuncUpsertRepositoryTag(ctx, tp1)
	}

	mm_params := RepositoryMockUpsertRepositoryTagParams{ctx, tp1}

	// Record call args
	mmUpsertRepositoryTag.UpsertRepositoryTagMock.mutex.Lock()
	mmUpsertRepositoryTag.UpsertRepositoryTagMock.callArgs = append(mmUpsertRepositoryTag.UpsertRepositoryTagMock.callArgs, &mm_params)
	mmUpsertRepositoryTag.UpsertRepositoryTagMock.mutex.Unlock()

	for _, e := range mmUpsertRepositoryTag.UpsertRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp2, e.results.err
		}
	}

	if mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpsertRepositoryTagParams{ctx, tp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpsertRepositoryTag.t.Errorf("RepositoryMock.UpsertRepositoryTag got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tp1 != nil && !minimock.Equal(*mm_want_ptrs.tp1, mm_got.tp1) {
				mmUpsertRepositoryTag.t.Errorf("RepositoryMock.UpsertRepositoryTag got unexpected parameter tp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.expectationOrigins.originTp1, *mm_want_ptrs.tp1, mm_got.tp1, minimock.Diff(*mm_want_ptrs.tp1, mm_got.tp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsertRepositoryTag.t.Errorf("RepositoryMock.UpsertRepositoryTag got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsertRepositoryTag.t.Fatal("No results are set for the RepositoryMock.UpsertRepositoryTag")
		}
		return (*mm_results).tp2, (*mm_results).err
	}
	if mmUpsertRepositoryTag.funcUpsertRepositoryTag != nil {
		return mmUpsertRepositoryTag.funcUpsertRepositoryTag(ctx, tp1)
	}
	mmUpsertRepositoryTag.t.Fatalf("Unexpected call to RepositoryMock.UpsertRepositoryTag. %v %v", ctx, tp1)
	return
}

// UpsertRepositoryTagAfterCounter returns a count of finished RepositoryMock.UpsertRepositoryTag invocations
func (mmUpsertRepositoryTag *RepositoryMock) UpsertRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertRepositoryTag.afterUpsertRepositoryTagCounter)
}

// UpsertRepositoryTagBeforeCounter returns a count of RepositoryMock.UpsertRepositoryTag invocations
func (mmUpsertRepositoryTag *RepositoryMock) UpsertRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertRepositoryTag.beforeUpsertRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpsertRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) Calls() []*RepositoryMockUpsertRepositoryTagParams {
	mmUpsertRepositoryTag.mutex.RLock()

	argCopy := make([]*RepositoryMockUpsertRepositoryTagParams, len(mmUpsertRepositoryTag.callArgs))
	copy(argCopy, mmUpsertRepositoryTag.callArgs)

	mmUpsertRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertRepositoryTagDone returns true if the count of the UpsertRepositoryTag invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpsertRepositoryTagDone() bool {
	if m.UpsertRepositoryTagMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpsertRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpsertRepositoryTagMock.invocationsDone()
}

// MinimockUpsertRepositoryTagInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpsertRepositoryTagInspect() {
	for _, e := range m.UpsertRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpsertRepositoryTag at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpsertRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterUpsertRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertRepositoryTagMock.defaultExpectation != nil && afterUpsertRepositoryTagCounter < 1 {
		if m.UpsertRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpsertRepositoryTag at\n%s", m.UpsertRepositoryTagMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpsertRepositoryTag at\n%s with params: %#v", m.UpsertRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *m.UpsertRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertRepositoryTag != nil && afterUpsertRepositoryTagCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpsertRepositoryTag at\n%s", m.funcUpsertRepositoryTagOrigin)
	}

	if !m.UpsertRepositoryTagMock.invocationsDone() && afterUpsertRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpsertRepositoryTag at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpsertRepositoryTagMock.expectedInvocations), m.UpsertRepositoryTagMock.expectedInvocationsOrigin, afterUpsertRepositoryTagCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCheckFileUIDMetadataInspect()

			m.MinimockCreateCollectionInspect()

			m.MinimockCreateConvertedFileWithDestinationInspect()

			m.MinimockCreateEmbeddingsInspect()

			m.MinimockCreateKnowledgeBaseInspect()

			m.MinimockCreateKnowledgeBaseFileInspect()

			m.MinimockCreateObjectInspect()

			m.MinimockCreateTextChunksInspect()

			m.MinimockDeleteAllConvertedFilesInKbInspect()

			m.MinimockDeleteAllKnowledgeBaseFilesInspect()

			m.MinimockDeleteAndCreateEmbeddingsInspect()

			m.MinimockDeleteAndCreateTextChunksInspect()

			m.MinimockDeleteChatCacheMetadataInspect()

			m.MinimockDeleteConvertedFileInspect()

			m.MinimockDeleteEmbeddingsByKBFileUIDInspect()

			m.MinimockDeleteEmbeddingsWithFileUIDInspect()

			m.MinimockDeleteFileInspect()

			m.MinimockDeleteKnowledgeBaseInspect()

			m.MinimockDeleteKnowledgeBaseFileInspect()

			m.MinimockDeleteKnowledgeBaseFileAndDecreaseUsageInspect()

			m.MinimockDeleteObjectInspect()

			m.MinimockDeleteObjectURLInspect()

			m.MinimockDeleteRepositoryTagInspect()

			m.MinimockDropCollectionInspect()

			m.MinimockFlushCollectionInspect()

			m.MinimockGetAllConvertedFilesByFileUIDInspect()

			m.MinimockGetChatCacheMetadataInspect()

			m.MinimockGetConvertedFileByFileUIDInspect()

			m.MinimockGetConvertedFileByFileUIDAndTypeInspect()

			m.MinimockGetCountFilesByListKnowledgeBaseUIDInspect()

			m.MinimockGetFileInspect()

			m.MinimockGetFileMetadataInspect()

			m.MinimockGetFilesTotalTokensInspect()

			m.MinimockGetKnowledgeBaseByOwnerAndKbIDInspect()

			m.MinimockGetKnowledgeBaseByUIDInspect()

			m.MinimockGetKnowledgeBaseCountByOwnerInspect()

			m.MinimockGetKnowledgeBaseFilesByFileUIDsInspect()

			m.MinimockGetKnowledgeBasesByUIDsInspect()

			m.MinimockGetKnowledgebaseFileByKBUIDAndFileIDInspect()

			m.MinimockGetObjectByUIDInspect()

			m.MinimockGetObjectDownloadURLInspect()

			m.MinimockGetObjectURLByEncodedURLPathInspect()

			m.MinimockGetObjectURLByUIDInspect()

			m.MinimockGetObjectURLCountByObjectInspect()

			m.MinimockGetObjectUploadURLInspect()

			m.MinimockGetPresignedURLForDownloadInspect()

			m.MinimockGetPresignedURLForUploadInspect()

			m.MinimockGetRepositoryTagInspect()

			m.MinimockGetSourceByFileUIDInspect()

			m.MinimockGetSourceTableAndUIDByFileUIDsInspect()

			m.MinimockGetTextChunksBySourceInspect()

			m.MinimockGetTextChunksByUIDsInspect()

			m.MinimockGetTotalTextChunksBySourcesInspect()

			m.MinimockGetTotalTokensByListKBUIDsInspect()

			m.MinimockHardDeleteConvertedFileByFileUIDInspect()

			m.MinimockHardDeleteEmbeddingsByKBFileUIDInspect()

			m.MinimockHardDeleteEmbeddingsByKBUIDInspect()

			m.MinimockHardDeleteTextChunksByKBFileUIDInspect()

			m.MinimockHardDeleteTextChunksByKBUIDInspect()

			m.MinimockIncreaseKnowledgeBaseUsageInspect()

			m.MinimockInsertVectorsInCollectionInspect()

			m.MinimockListAllObjectURLsInspect()

			m.MinimockListAllObjectsInspect()

			m.MinimockListConvertedFilesByFileUIDInspect()

			m.MinimockListEmbeddingsByKBFileUIDInspect()

			m.MinimockListFilePathsWithPrefixInspect()

			m.MinimockListKnowledgeBaseFilePathsInspect()

			m.MinimockListKnowledgeBaseFilesInspect()

			m.MinimockListKnowledgeBasesInspect()

			m.MinimockListKnowledgeBasesByCatalogTypeInspect()

			m.MinimockListTextChunksByFileUIDInspect()

			m.MinimockListTextChunksByKBFileUIDInspect()

			m.MinimockProcessKnowledgeBaseFilesInspect()

			m.MinimockSaveConvertedFileInspect()

			m.MinimockSetChatCacheMetadataInspect()

			m.MinimockSimilarVectorsInCollectionInspect()

			m.MinimockUpdateConvertedFileInspect()

			m.MinimockUpdateKnowledgeBaseInspect()

			m.MinimockUpdateKnowledgeBaseFileInspect()

			m.MinimockUpdateKnowledgeFileMetadataInspect()

			m.MinimockUpdateObjectInspect()

			m.MinimockUpdateObjectByUpdateMapInspect()

			m.MinimockUpdateTextChunkInspect()

			m.MinimockUpdateTextChunkDestinationsInspect()

			m.MinimockUploadBase64FileInspect()

			m.MinimockUpsertRepositoryTagInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckFileUIDMetadataDone() &&
		m.MinimockCreateCollectionDone() &&
		m.MinimockCreateConvertedFileWithDestinationDone() &&
		m.MinimockCreateEmbeddingsDone() &&
		m.MinimockCreateKnowledgeBaseDone() &&
		m.MinimockCreateKnowledgeBaseFileDone() &&
		m.MinimockCreateObjectDone() &&
		m.MinimockCreateTextChunksDone() &&
		m.MinimockDeleteAllConvertedFilesInKbDone() &&
		m.MinimockDeleteAllKnowledgeBaseFilesDone() &&
		m.MinimockDeleteAndCreateEmbeddingsDone() &&
		m.MinimockDeleteAndCreateTextChunksDone() &&
		m.MinimockDeleteChatCacheMetadataDone() &&
		m.MinimockDeleteConvertedFileDone() &&
		m.MinimockDeleteEmbeddingsByKBFileUIDDone() &&
		m.MinimockDeleteEmbeddingsWithFileUIDDone() &&
		m.MinimockDeleteFileDone() &&
		m.MinimockDeleteKnowledgeBaseDone() &&
		m.MinimockDeleteKnowledgeBaseFileDone() &&
		m.MinimockDeleteKnowledgeBaseFileAndDecreaseUsageDone() &&
		m.MinimockDeleteObjectDone() &&
		m.MinimockDeleteObjectURLDone() &&
		m.MinimockDeleteRepositoryTagDone() &&
		m.MinimockDropCollectionDone() &&
		m.MinimockFlushCollectionDone() &&
		m.MinimockGetAllConvertedFilesByFileUIDDone() &&
		m.MinimockGetChatCacheMetadataDone() &&
		m.MinimockGetConvertedFileByFileUIDDone() &&
		m.MinimockGetConvertedFileByFileUIDAndTypeDone() &&
		m.MinimockGetCountFilesByListKnowledgeBaseUIDDone() &&
		m.MinimockGetFileDone() &&
		m.MinimockGetFileMetadataDone() &&
		m.MinimockGetFilesTotalTokensDone() &&
		m.MinimockGetKnowledgeBaseByOwnerAndKbIDDone() &&
		m.MinimockGetKnowledgeBaseByUIDDone() &&
		m.MinimockGetKnowledgeBaseCountByOwnerDone() &&
		m.MinimockGetKnowledgeBaseFilesByFileUIDsDone() &&
		m.MinimockGetKnowledgeBasesByUIDsDone() &&
		m.MinimockGetKnowledgebaseFileByKBUIDAndFileIDDone() &&
		m.MinimockGetObjectByUIDDone() &&
		m.MinimockGetObjectDownloadURLDone() &&
		m.MinimockGetObjectURLByEncodedURLPathDone() &&
		m.MinimockGetObjectURLByUIDDone() &&
		m.MinimockGetObjectURLCountByObjectDone() &&
		m.MinimockGetObjectUploadURLDone() &&
		m.MinimockGetPresignedURLForDownloadDone() &&
		m.MinimockGetPresignedURLForUploadDone() &&
		m.MinimockGetRepositoryTagDone() &&
		m.MinimockGetSourceByFileUIDDone() &&
		m.MinimockGetSourceTableAndUIDByFileUIDsDone() &&
		m.MinimockGetTextChunksBySourceDone() &&
		m.MinimockGetTextChunksByUIDsDone() &&
		m.MinimockGetTotalTextChunksBySourcesDone() &&
		m.MinimockGetTotalTokensByListKBUIDsDone() &&
		m.MinimockHardDeleteConvertedFileByFileUIDDone() &&
		m.MinimockHardDeleteEmbeddingsByKBFileUIDDone() &&
		m.MinimockHardDeleteEmbeddingsByKBUIDDone() &&
		m.MinimockHardDeleteTextChunksByKBFileUIDDone() &&
		m.MinimockHardDeleteTextChunksByKBUIDDone() &&
		m.MinimockIncreaseKnowledgeBaseUsageDone() &&
		m.MinimockInsertVectorsInCollectionDone() &&
		m.MinimockListAllObjectURLsDone() &&
		m.MinimockListAllObjectsDone() &&
		m.MinimockListConvertedFilesByFileUIDDone() &&
		m.MinimockListEmbeddingsByKBFileUIDDone() &&
		m.MinimockListFilePathsWithPrefixDone() &&
		m.MinimockListKnowledgeBaseFilePathsDone() &&
		m.MinimockListKnowledgeBaseFilesDone() &&
		m.MinimockListKnowledgeBasesDone() &&
		m.MinimockListKnowledgeBasesByCatalogTypeDone() &&
		m.MinimockListTextChunksByFileUIDDone() &&
		m.MinimockListTextChunksByKBFileUIDDone() &&
		m.MinimockProcessKnowledgeBaseFilesDone() &&
		m.MinimockSaveConvertedFileDone() &&
		m.MinimockSetChatCacheMetadataDone() &&
		m.MinimockSimilarVectorsInCollectionDone() &&
		m.MinimockUpdateConvertedFileDone() &&
		m.MinimockUpdateKnowledgeBaseDone() &&
		m.MinimockUpdateKnowledgeBaseFileDone() &&
		m.MinimockUpdateKnowledgeFileMetadataDone() &&
		m.MinimockUpdateObjectDone() &&
		m.MinimockUpdateObjectByUpdateMapDone() &&
		m.MinimockUpdateTextChunkDone() &&
		m.MinimockUpdateTextChunkDestinationsDone() &&
		m.MinimockUploadBase64FileDone() &&
		m.MinimockUpsertRepositoryTagDone()
}
