// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_ai "github.com/instill-ai/artifact-backend/internal/ai"
	artifactpb "github.com/instill-ai/protogen-go/artifact/artifact/v1alpha"
)

// ProviderMock implements mm_ai.Provider
type ProviderMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcChatWithCache          func(ctx context.Context, cacheName string, prompt string) (cp1 *mm_ai.ChatResult, err error)
	funcChatWithCacheOrigin    string
	inspectFuncChatWithCache   func(ctx context.Context, cacheName string, prompt string)
	afterChatWithCacheCounter  uint64
	beforeChatWithCacheCounter uint64
	ChatWithCacheMock          mProviderMockChatWithCache

	funcChatWithFiles          func(ctx context.Context, files []mm_ai.FileContent, prompt string) (cp1 *mm_ai.ChatResult, err error)
	funcChatWithFilesOrigin    string
	inspectFuncChatWithFiles   func(ctx context.Context, files []mm_ai.FileContent, prompt string)
	afterChatWithFilesCounter  uint64
	beforeChatWithFilesCounter uint64
	ChatWithFilesMock          mProviderMockChatWithFiles

	funcClose          func() (err error)
	funcCloseOrigin    string
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mProviderMockClose

	funcConvertToMarkdownWithCache          func(ctx context.Context, cacheName string, prompt string) (cp1 *mm_ai.ConversionResult, err error)
	funcConvertToMarkdownWithCacheOrigin    string
	inspectFuncConvertToMarkdownWithCache   func(ctx context.Context, cacheName string, prompt string)
	afterConvertToMarkdownWithCacheCounter  uint64
	beforeConvertToMarkdownWithCacheCounter uint64
	ConvertToMarkdownWithCacheMock          mProviderMockConvertToMarkdownWithCache

	funcConvertToMarkdownWithoutCache          func(ctx context.Context, content []byte, fileType artifactpb.FileType, filename string, prompt string) (cp1 *mm_ai.ConversionResult, err error)
	funcConvertToMarkdownWithoutCacheOrigin    string
	inspectFuncConvertToMarkdownWithoutCache   func(ctx context.Context, content []byte, fileType artifactpb.FileType, filename string, prompt string)
	afterConvertToMarkdownWithoutCacheCounter  uint64
	beforeConvertToMarkdownWithoutCacheCounter uint64
	ConvertToMarkdownWithoutCacheMock          mProviderMockConvertToMarkdownWithoutCache

	funcCreateCache          func(ctx context.Context, files []mm_ai.FileContent, ttl time.Duration, systemInstruction string) (cp1 *mm_ai.CacheResult, err error)
	funcCreateCacheOrigin    string
	inspectFuncCreateCache   func(ctx context.Context, files []mm_ai.FileContent, ttl time.Duration, systemInstruction string)
	afterCreateCacheCounter  uint64
	beforeCreateCacheCounter uint64
	CreateCacheMock          mProviderMockCreateCache

	funcDeleteCache          func(ctx context.Context, cacheName string) (err error)
	funcDeleteCacheOrigin    string
	inspectFuncDeleteCache   func(ctx context.Context, cacheName string)
	afterDeleteCacheCounter  uint64
	beforeDeleteCacheCounter uint64
	DeleteCacheMock          mProviderMockDeleteCache

	funcEmbedTexts          func(ctx context.Context, texts []string, taskType string) (ep1 *mm_ai.EmbedResult, err error)
	funcEmbedTextsOrigin    string
	inspectFuncEmbedTexts   func(ctx context.Context, texts []string, taskType string)
	afterEmbedTextsCounter  uint64
	beforeEmbedTextsCounter uint64
	EmbedTextsMock          mProviderMockEmbedTexts

	funcGetCache          func(ctx context.Context, cacheName string) (cp1 *mm_ai.CacheResult, err error)
	funcGetCacheOrigin    string
	inspectFuncGetCache   func(ctx context.Context, cacheName string)
	afterGetCacheCounter  uint64
	beforeGetCacheCounter uint64
	GetCacheMock          mProviderMockGetCache

	funcGetEmbeddingDimensionality          func() (i1 int32)
	funcGetEmbeddingDimensionalityOrigin    string
	inspectFuncGetEmbeddingDimensionality   func()
	afterGetEmbeddingDimensionalityCounter  uint64
	beforeGetEmbeddingDimensionalityCounter uint64
	GetEmbeddingDimensionalityMock          mProviderMockGetEmbeddingDimensionality

	funcListCaches          func(ctx context.Context, options *mm_ai.CacheListOptions) (cp1 *mm_ai.CacheListResult, err error)
	funcListCachesOrigin    string
	inspectFuncListCaches   func(ctx context.Context, options *mm_ai.CacheListOptions)
	afterListCachesCounter  uint64
	beforeListCachesCounter uint64
	ListCachesMock          mProviderMockListCaches

	funcName          func() (s1 string)
	funcNameOrigin    string
	inspectFuncName   func()
	afterNameCounter  uint64
	beforeNameCounter uint64
	NameMock          mProviderMockName

	funcSupportsFileType          func(fileType artifactpb.FileType) (b1 bool)
	funcSupportsFileTypeOrigin    string
	inspectFuncSupportsFileType   func(fileType artifactpb.FileType)
	afterSupportsFileTypeCounter  uint64
	beforeSupportsFileTypeCounter uint64
	SupportsFileTypeMock          mProviderMockSupportsFileType

	funcUpdateCache          func(ctx context.Context, cacheName string, options *mm_ai.CacheUpdateOptions) (cp1 *mm_ai.CacheResult, err error)
	funcUpdateCacheOrigin    string
	inspectFuncUpdateCache   func(ctx context.Context, cacheName string, options *mm_ai.CacheUpdateOptions)
	afterUpdateCacheCounter  uint64
	beforeUpdateCacheCounter uint64
	UpdateCacheMock          mProviderMockUpdateCache
}

// NewProviderMock returns a mock for mm_ai.Provider
func NewProviderMock(t minimock.Tester) *ProviderMock {
	m := &ProviderMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ChatWithCacheMock = mProviderMockChatWithCache{mock: m}
	m.ChatWithCacheMock.callArgs = []*ProviderMockChatWithCacheParams{}

	m.ChatWithFilesMock = mProviderMockChatWithFiles{mock: m}
	m.ChatWithFilesMock.callArgs = []*ProviderMockChatWithFilesParams{}

	m.CloseMock = mProviderMockClose{mock: m}

	m.ConvertToMarkdownWithCacheMock = mProviderMockConvertToMarkdownWithCache{mock: m}
	m.ConvertToMarkdownWithCacheMock.callArgs = []*ProviderMockConvertToMarkdownWithCacheParams{}

	m.ConvertToMarkdownWithoutCacheMock = mProviderMockConvertToMarkdownWithoutCache{mock: m}
	m.ConvertToMarkdownWithoutCacheMock.callArgs = []*ProviderMockConvertToMarkdownWithoutCacheParams{}

	m.CreateCacheMock = mProviderMockCreateCache{mock: m}
	m.CreateCacheMock.callArgs = []*ProviderMockCreateCacheParams{}

	m.DeleteCacheMock = mProviderMockDeleteCache{mock: m}
	m.DeleteCacheMock.callArgs = []*ProviderMockDeleteCacheParams{}

	m.EmbedTextsMock = mProviderMockEmbedTexts{mock: m}
	m.EmbedTextsMock.callArgs = []*ProviderMockEmbedTextsParams{}

	m.GetCacheMock = mProviderMockGetCache{mock: m}
	m.GetCacheMock.callArgs = []*ProviderMockGetCacheParams{}

	m.GetEmbeddingDimensionalityMock = mProviderMockGetEmbeddingDimensionality{mock: m}

	m.ListCachesMock = mProviderMockListCaches{mock: m}
	m.ListCachesMock.callArgs = []*ProviderMockListCachesParams{}

	m.NameMock = mProviderMockName{mock: m}

	m.SupportsFileTypeMock = mProviderMockSupportsFileType{mock: m}
	m.SupportsFileTypeMock.callArgs = []*ProviderMockSupportsFileTypeParams{}

	m.UpdateCacheMock = mProviderMockUpdateCache{mock: m}
	m.UpdateCacheMock.callArgs = []*ProviderMockUpdateCacheParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mProviderMockChatWithCache struct {
	optional           bool
	mock               *ProviderMock
	defaultExpectation *ProviderMockChatWithCacheExpectation
	expectations       []*ProviderMockChatWithCacheExpectation

	callArgs []*ProviderMockChatWithCacheParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProviderMockChatWithCacheExpectation specifies expectation struct of the Provider.ChatWithCache
type ProviderMockChatWithCacheExpectation struct {
	mock               *ProviderMock
	params             *ProviderMockChatWithCacheParams
	paramPtrs          *ProviderMockChatWithCacheParamPtrs
	expectationOrigins ProviderMockChatWithCacheExpectationOrigins
	results            *ProviderMockChatWithCacheResults
	returnOrigin       string
	Counter            uint64
}

// ProviderMockChatWithCacheParams contains parameters of the Provider.ChatWithCache
type ProviderMockChatWithCacheParams struct {
	ctx       context.Context
	cacheName string
	prompt    string
}

// ProviderMockChatWithCacheParamPtrs contains pointers to parameters of the Provider.ChatWithCache
type ProviderMockChatWithCacheParamPtrs struct {
	ctx       *context.Context
	cacheName *string
	prompt    *string
}

// ProviderMockChatWithCacheResults contains results of the Provider.ChatWithCache
type ProviderMockChatWithCacheResults struct {
	cp1 *mm_ai.ChatResult
	err error
}

// ProviderMockChatWithCacheOrigins contains origins of expectations of the Provider.ChatWithCache
type ProviderMockChatWithCacheExpectationOrigins struct {
	origin          string
	originCtx       string
	originCacheName string
	originPrompt    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmChatWithCache *mProviderMockChatWithCache) Optional() *mProviderMockChatWithCache {
	mmChatWithCache.optional = true
	return mmChatWithCache
}

// Expect sets up expected params for Provider.ChatWithCache
func (mmChatWithCache *mProviderMockChatWithCache) Expect(ctx context.Context, cacheName string, prompt string) *mProviderMockChatWithCache {
	if mmChatWithCache.mock.funcChatWithCache != nil {
		mmChatWithCache.mock.t.Fatalf("ProviderMock.ChatWithCache mock is already set by Set")
	}

	if mmChatWithCache.defaultExpectation == nil {
		mmChatWithCache.defaultExpectation = &ProviderMockChatWithCacheExpectation{}
	}

	if mmChatWithCache.defaultExpectation.paramPtrs != nil {
		mmChatWithCache.mock.t.Fatalf("ProviderMock.ChatWithCache mock is already set by ExpectParams functions")
	}

	mmChatWithCache.defaultExpectation.params = &ProviderMockChatWithCacheParams{ctx, cacheName, prompt}
	mmChatWithCache.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmChatWithCache.expectations {
		if minimock.Equal(e.params, mmChatWithCache.defaultExpectation.params) {
			mmChatWithCache.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChatWithCache.defaultExpectation.params)
		}
	}

	return mmChatWithCache
}

// ExpectCtxParam1 sets up expected param ctx for Provider.ChatWithCache
func (mmChatWithCache *mProviderMockChatWithCache) ExpectCtxParam1(ctx context.Context) *mProviderMockChatWithCache {
	if mmChatWithCache.mock.funcChatWithCache != nil {
		mmChatWithCache.mock.t.Fatalf("ProviderMock.ChatWithCache mock is already set by Set")
	}

	if mmChatWithCache.defaultExpectation == nil {
		mmChatWithCache.defaultExpectation = &ProviderMockChatWithCacheExpectation{}
	}

	if mmChatWithCache.defaultExpectation.params != nil {
		mmChatWithCache.mock.t.Fatalf("ProviderMock.ChatWithCache mock is already set by Expect")
	}

	if mmChatWithCache.defaultExpectation.paramPtrs == nil {
		mmChatWithCache.defaultExpectation.paramPtrs = &ProviderMockChatWithCacheParamPtrs{}
	}
	mmChatWithCache.defaultExpectation.paramPtrs.ctx = &ctx
	mmChatWithCache.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmChatWithCache
}

// ExpectCacheNameParam2 sets up expected param cacheName for Provider.ChatWithCache
func (mmChatWithCache *mProviderMockChatWithCache) ExpectCacheNameParam2(cacheName string) *mProviderMockChatWithCache {
	if mmChatWithCache.mock.funcChatWithCache != nil {
		mmChatWithCache.mock.t.Fatalf("ProviderMock.ChatWithCache mock is already set by Set")
	}

	if mmChatWithCache.defaultExpectation == nil {
		mmChatWithCache.defaultExpectation = &ProviderMockChatWithCacheExpectation{}
	}

	if mmChatWithCache.defaultExpectation.params != nil {
		mmChatWithCache.mock.t.Fatalf("ProviderMock.ChatWithCache mock is already set by Expect")
	}

	if mmChatWithCache.defaultExpectation.paramPtrs == nil {
		mmChatWithCache.defaultExpectation.paramPtrs = &ProviderMockChatWithCacheParamPtrs{}
	}
	mmChatWithCache.defaultExpectation.paramPtrs.cacheName = &cacheName
	mmChatWithCache.defaultExpectation.expectationOrigins.originCacheName = minimock.CallerInfo(1)

	return mmChatWithCache
}

// ExpectPromptParam3 sets up expected param prompt for Provider.ChatWithCache
func (mmChatWithCache *mProviderMockChatWithCache) ExpectPromptParam3(prompt string) *mProviderMockChatWithCache {
	if mmChatWithCache.mock.funcChatWithCache != nil {
		mmChatWithCache.mock.t.Fatalf("ProviderMock.ChatWithCache mock is already set by Set")
	}

	if mmChatWithCache.defaultExpectation == nil {
		mmChatWithCache.defaultExpectation = &ProviderMockChatWithCacheExpectation{}
	}

	if mmChatWithCache.defaultExpectation.params != nil {
		mmChatWithCache.mock.t.Fatalf("ProviderMock.ChatWithCache mock is already set by Expect")
	}

	if mmChatWithCache.defaultExpectation.paramPtrs == nil {
		mmChatWithCache.defaultExpectation.paramPtrs = &ProviderMockChatWithCacheParamPtrs{}
	}
	mmChatWithCache.defaultExpectation.paramPtrs.prompt = &prompt
	mmChatWithCache.defaultExpectation.expectationOrigins.originPrompt = minimock.CallerInfo(1)

	return mmChatWithCache
}

// Inspect accepts an inspector function that has same arguments as the Provider.ChatWithCache
func (mmChatWithCache *mProviderMockChatWithCache) Inspect(f func(ctx context.Context, cacheName string, prompt string)) *mProviderMockChatWithCache {
	if mmChatWithCache.mock.inspectFuncChatWithCache != nil {
		mmChatWithCache.mock.t.Fatalf("Inspect function is already set for ProviderMock.ChatWithCache")
	}

	mmChatWithCache.mock.inspectFuncChatWithCache = f

	return mmChatWithCache
}

// Return sets up results that will be returned by Provider.ChatWithCache
func (mmChatWithCache *mProviderMockChatWithCache) Return(cp1 *mm_ai.ChatResult, err error) *ProviderMock {
	if mmChatWithCache.mock.funcChatWithCache != nil {
		mmChatWithCache.mock.t.Fatalf("ProviderMock.ChatWithCache mock is already set by Set")
	}

	if mmChatWithCache.defaultExpectation == nil {
		mmChatWithCache.defaultExpectation = &ProviderMockChatWithCacheExpectation{mock: mmChatWithCache.mock}
	}
	mmChatWithCache.defaultExpectation.results = &ProviderMockChatWithCacheResults{cp1, err}
	mmChatWithCache.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmChatWithCache.mock
}

// Set uses given function f to mock the Provider.ChatWithCache method
func (mmChatWithCache *mProviderMockChatWithCache) Set(f func(ctx context.Context, cacheName string, prompt string) (cp1 *mm_ai.ChatResult, err error)) *ProviderMock {
	if mmChatWithCache.defaultExpectation != nil {
		mmChatWithCache.mock.t.Fatalf("Default expectation is already set for the Provider.ChatWithCache method")
	}

	if len(mmChatWithCache.expectations) > 0 {
		mmChatWithCache.mock.t.Fatalf("Some expectations are already set for the Provider.ChatWithCache method")
	}

	mmChatWithCache.mock.funcChatWithCache = f
	mmChatWithCache.mock.funcChatWithCacheOrigin = minimock.CallerInfo(1)
	return mmChatWithCache.mock
}

// When sets expectation for the Provider.ChatWithCache which will trigger the result defined by the following
// Then helper
func (mmChatWithCache *mProviderMockChatWithCache) When(ctx context.Context, cacheName string, prompt string) *ProviderMockChatWithCacheExpectation {
	if mmChatWithCache.mock.funcChatWithCache != nil {
		mmChatWithCache.mock.t.Fatalf("ProviderMock.ChatWithCache mock is already set by Set")
	}

	expectation := &ProviderMockChatWithCacheExpectation{
		mock:               mmChatWithCache.mock,
		params:             &ProviderMockChatWithCacheParams{ctx, cacheName, prompt},
		expectationOrigins: ProviderMockChatWithCacheExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmChatWithCache.expectations = append(mmChatWithCache.expectations, expectation)
	return expectation
}

// Then sets up Provider.ChatWithCache return parameters for the expectation previously defined by the When method
func (e *ProviderMockChatWithCacheExpectation) Then(cp1 *mm_ai.ChatResult, err error) *ProviderMock {
	e.results = &ProviderMockChatWithCacheResults{cp1, err}
	return e.mock
}

// Times sets number of times Provider.ChatWithCache should be invoked
func (mmChatWithCache *mProviderMockChatWithCache) Times(n uint64) *mProviderMockChatWithCache {
	if n == 0 {
		mmChatWithCache.mock.t.Fatalf("Times of ProviderMock.ChatWithCache mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmChatWithCache.expectedInvocations, n)
	mmChatWithCache.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmChatWithCache
}

func (mmChatWithCache *mProviderMockChatWithCache) invocationsDone() bool {
	if len(mmChatWithCache.expectations) == 0 && mmChatWithCache.defaultExpectation == nil && mmChatWithCache.mock.funcChatWithCache == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmChatWithCache.mock.afterChatWithCacheCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmChatWithCache.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ChatWithCache implements mm_ai.Provider
func (mmChatWithCache *ProviderMock) ChatWithCache(ctx context.Context, cacheName string, prompt string) (cp1 *mm_ai.ChatResult, err error) {
	mm_atomic.AddUint64(&mmChatWithCache.beforeChatWithCacheCounter, 1)
	defer mm_atomic.AddUint64(&mmChatWithCache.afterChatWithCacheCounter, 1)

	mmChatWithCache.t.Helper()

	if mmChatWithCache.inspectFuncChatWithCache != nil {
		mmChatWithCache.inspectFuncChatWithCache(ctx, cacheName, prompt)
	}

	mm_params := ProviderMockChatWithCacheParams{ctx, cacheName, prompt}

	// Record call args
	mmChatWithCache.ChatWithCacheMock.mutex.Lock()
	mmChatWithCache.ChatWithCacheMock.callArgs = append(mmChatWithCache.ChatWithCacheMock.callArgs, &mm_params)
	mmChatWithCache.ChatWithCacheMock.mutex.Unlock()

	for _, e := range mmChatWithCache.ChatWithCacheMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmChatWithCache.ChatWithCacheMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChatWithCache.ChatWithCacheMock.defaultExpectation.Counter, 1)
		mm_want := mmChatWithCache.ChatWithCacheMock.defaultExpectation.params
		mm_want_ptrs := mmChatWithCache.ChatWithCacheMock.defaultExpectation.paramPtrs

		mm_got := ProviderMockChatWithCacheParams{ctx, cacheName, prompt}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmChatWithCache.t.Errorf("ProviderMock.ChatWithCache got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChatWithCache.ChatWithCacheMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cacheName != nil && !minimock.Equal(*mm_want_ptrs.cacheName, mm_got.cacheName) {
				mmChatWithCache.t.Errorf("ProviderMock.ChatWithCache got unexpected parameter cacheName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChatWithCache.ChatWithCacheMock.defaultExpectation.expectationOrigins.originCacheName, *mm_want_ptrs.cacheName, mm_got.cacheName, minimock.Diff(*mm_want_ptrs.cacheName, mm_got.cacheName))
			}

			if mm_want_ptrs.prompt != nil && !minimock.Equal(*mm_want_ptrs.prompt, mm_got.prompt) {
				mmChatWithCache.t.Errorf("ProviderMock.ChatWithCache got unexpected parameter prompt, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChatWithCache.ChatWithCacheMock.defaultExpectation.expectationOrigins.originPrompt, *mm_want_ptrs.prompt, mm_got.prompt, minimock.Diff(*mm_want_ptrs.prompt, mm_got.prompt))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChatWithCache.t.Errorf("ProviderMock.ChatWithCache got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmChatWithCache.ChatWithCacheMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChatWithCache.ChatWithCacheMock.defaultExpectation.results
		if mm_results == nil {
			mmChatWithCache.t.Fatal("No results are set for the ProviderMock.ChatWithCache")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmChatWithCache.funcChatWithCache != nil {
		return mmChatWithCache.funcChatWithCache(ctx, cacheName, prompt)
	}
	mmChatWithCache.t.Fatalf("Unexpected call to ProviderMock.ChatWithCache. %v %v %v", ctx, cacheName, prompt)
	return
}

// ChatWithCacheAfterCounter returns a count of finished ProviderMock.ChatWithCache invocations
func (mmChatWithCache *ProviderMock) ChatWithCacheAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChatWithCache.afterChatWithCacheCounter)
}

// ChatWithCacheBeforeCounter returns a count of ProviderMock.ChatWithCache invocations
func (mmChatWithCache *ProviderMock) ChatWithCacheBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChatWithCache.beforeChatWithCacheCounter)
}

// Calls returns a list of arguments used in each call to ProviderMock.ChatWithCache.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChatWithCache *mProviderMockChatWithCache) Calls() []*ProviderMockChatWithCacheParams {
	mmChatWithCache.mutex.RLock()

	argCopy := make([]*ProviderMockChatWithCacheParams, len(mmChatWithCache.callArgs))
	copy(argCopy, mmChatWithCache.callArgs)

	mmChatWithCache.mutex.RUnlock()

	return argCopy
}

// MinimockChatWithCacheDone returns true if the count of the ChatWithCache invocations corresponds
// the number of defined expectations
func (m *ProviderMock) MinimockChatWithCacheDone() bool {
	if m.ChatWithCacheMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ChatWithCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ChatWithCacheMock.invocationsDone()
}

// MinimockChatWithCacheInspect logs each unmet expectation
func (m *ProviderMock) MinimockChatWithCacheInspect() {
	for _, e := range m.ChatWithCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProviderMock.ChatWithCache at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterChatWithCacheCounter := mm_atomic.LoadUint64(&m.afterChatWithCacheCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ChatWithCacheMock.defaultExpectation != nil && afterChatWithCacheCounter < 1 {
		if m.ChatWithCacheMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ProviderMock.ChatWithCache at\n%s", m.ChatWithCacheMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ProviderMock.ChatWithCache at\n%s with params: %#v", m.ChatWithCacheMock.defaultExpectation.expectationOrigins.origin, *m.ChatWithCacheMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChatWithCache != nil && afterChatWithCacheCounter < 1 {
		m.t.Errorf("Expected call to ProviderMock.ChatWithCache at\n%s", m.funcChatWithCacheOrigin)
	}

	if !m.ChatWithCacheMock.invocationsDone() && afterChatWithCacheCounter > 0 {
		m.t.Errorf("Expected %d calls to ProviderMock.ChatWithCache at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ChatWithCacheMock.expectedInvocations), m.ChatWithCacheMock.expectedInvocationsOrigin, afterChatWithCacheCounter)
	}
}

type mProviderMockChatWithFiles struct {
	optional           bool
	mock               *ProviderMock
	defaultExpectation *ProviderMockChatWithFilesExpectation
	expectations       []*ProviderMockChatWithFilesExpectation

	callArgs []*ProviderMockChatWithFilesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProviderMockChatWithFilesExpectation specifies expectation struct of the Provider.ChatWithFiles
type ProviderMockChatWithFilesExpectation struct {
	mock               *ProviderMock
	params             *ProviderMockChatWithFilesParams
	paramPtrs          *ProviderMockChatWithFilesParamPtrs
	expectationOrigins ProviderMockChatWithFilesExpectationOrigins
	results            *ProviderMockChatWithFilesResults
	returnOrigin       string
	Counter            uint64
}

// ProviderMockChatWithFilesParams contains parameters of the Provider.ChatWithFiles
type ProviderMockChatWithFilesParams struct {
	ctx    context.Context
	files  []mm_ai.FileContent
	prompt string
}

// ProviderMockChatWithFilesParamPtrs contains pointers to parameters of the Provider.ChatWithFiles
type ProviderMockChatWithFilesParamPtrs struct {
	ctx    *context.Context
	files  *[]mm_ai.FileContent
	prompt *string
}

// ProviderMockChatWithFilesResults contains results of the Provider.ChatWithFiles
type ProviderMockChatWithFilesResults struct {
	cp1 *mm_ai.ChatResult
	err error
}

// ProviderMockChatWithFilesOrigins contains origins of expectations of the Provider.ChatWithFiles
type ProviderMockChatWithFilesExpectationOrigins struct {
	origin       string
	originCtx    string
	originFiles  string
	originPrompt string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmChatWithFiles *mProviderMockChatWithFiles) Optional() *mProviderMockChatWithFiles {
	mmChatWithFiles.optional = true
	return mmChatWithFiles
}

// Expect sets up expected params for Provider.ChatWithFiles
func (mmChatWithFiles *mProviderMockChatWithFiles) Expect(ctx context.Context, files []mm_ai.FileContent, prompt string) *mProviderMockChatWithFiles {
	if mmChatWithFiles.mock.funcChatWithFiles != nil {
		mmChatWithFiles.mock.t.Fatalf("ProviderMock.ChatWithFiles mock is already set by Set")
	}

	if mmChatWithFiles.defaultExpectation == nil {
		mmChatWithFiles.defaultExpectation = &ProviderMockChatWithFilesExpectation{}
	}

	if mmChatWithFiles.defaultExpectation.paramPtrs != nil {
		mmChatWithFiles.mock.t.Fatalf("ProviderMock.ChatWithFiles mock is already set by ExpectParams functions")
	}

	mmChatWithFiles.defaultExpectation.params = &ProviderMockChatWithFilesParams{ctx, files, prompt}
	mmChatWithFiles.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmChatWithFiles.expectations {
		if minimock.Equal(e.params, mmChatWithFiles.defaultExpectation.params) {
			mmChatWithFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChatWithFiles.defaultExpectation.params)
		}
	}

	return mmChatWithFiles
}

// ExpectCtxParam1 sets up expected param ctx for Provider.ChatWithFiles
func (mmChatWithFiles *mProviderMockChatWithFiles) ExpectCtxParam1(ctx context.Context) *mProviderMockChatWithFiles {
	if mmChatWithFiles.mock.funcChatWithFiles != nil {
		mmChatWithFiles.mock.t.Fatalf("ProviderMock.ChatWithFiles mock is already set by Set")
	}

	if mmChatWithFiles.defaultExpectation == nil {
		mmChatWithFiles.defaultExpectation = &ProviderMockChatWithFilesExpectation{}
	}

	if mmChatWithFiles.defaultExpectation.params != nil {
		mmChatWithFiles.mock.t.Fatalf("ProviderMock.ChatWithFiles mock is already set by Expect")
	}

	if mmChatWithFiles.defaultExpectation.paramPtrs == nil {
		mmChatWithFiles.defaultExpectation.paramPtrs = &ProviderMockChatWithFilesParamPtrs{}
	}
	mmChatWithFiles.defaultExpectation.paramPtrs.ctx = &ctx
	mmChatWithFiles.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmChatWithFiles
}

// ExpectFilesParam2 sets up expected param files for Provider.ChatWithFiles
func (mmChatWithFiles *mProviderMockChatWithFiles) ExpectFilesParam2(files []mm_ai.FileContent) *mProviderMockChatWithFiles {
	if mmChatWithFiles.mock.funcChatWithFiles != nil {
		mmChatWithFiles.mock.t.Fatalf("ProviderMock.ChatWithFiles mock is already set by Set")
	}

	if mmChatWithFiles.defaultExpectation == nil {
		mmChatWithFiles.defaultExpectation = &ProviderMockChatWithFilesExpectation{}
	}

	if mmChatWithFiles.defaultExpectation.params != nil {
		mmChatWithFiles.mock.t.Fatalf("ProviderMock.ChatWithFiles mock is already set by Expect")
	}

	if mmChatWithFiles.defaultExpectation.paramPtrs == nil {
		mmChatWithFiles.defaultExpectation.paramPtrs = &ProviderMockChatWithFilesParamPtrs{}
	}
	mmChatWithFiles.defaultExpectation.paramPtrs.files = &files
	mmChatWithFiles.defaultExpectation.expectationOrigins.originFiles = minimock.CallerInfo(1)

	return mmChatWithFiles
}

// ExpectPromptParam3 sets up expected param prompt for Provider.ChatWithFiles
func (mmChatWithFiles *mProviderMockChatWithFiles) ExpectPromptParam3(prompt string) *mProviderMockChatWithFiles {
	if mmChatWithFiles.mock.funcChatWithFiles != nil {
		mmChatWithFiles.mock.t.Fatalf("ProviderMock.ChatWithFiles mock is already set by Set")
	}

	if mmChatWithFiles.defaultExpectation == nil {
		mmChatWithFiles.defaultExpectation = &ProviderMockChatWithFilesExpectation{}
	}

	if mmChatWithFiles.defaultExpectation.params != nil {
		mmChatWithFiles.mock.t.Fatalf("ProviderMock.ChatWithFiles mock is already set by Expect")
	}

	if mmChatWithFiles.defaultExpectation.paramPtrs == nil {
		mmChatWithFiles.defaultExpectation.paramPtrs = &ProviderMockChatWithFilesParamPtrs{}
	}
	mmChatWithFiles.defaultExpectation.paramPtrs.prompt = &prompt
	mmChatWithFiles.defaultExpectation.expectationOrigins.originPrompt = minimock.CallerInfo(1)

	return mmChatWithFiles
}

// Inspect accepts an inspector function that has same arguments as the Provider.ChatWithFiles
func (mmChatWithFiles *mProviderMockChatWithFiles) Inspect(f func(ctx context.Context, files []mm_ai.FileContent, prompt string)) *mProviderMockChatWithFiles {
	if mmChatWithFiles.mock.inspectFuncChatWithFiles != nil {
		mmChatWithFiles.mock.t.Fatalf("Inspect function is already set for ProviderMock.ChatWithFiles")
	}

	mmChatWithFiles.mock.inspectFuncChatWithFiles = f

	return mmChatWithFiles
}

// Return sets up results that will be returned by Provider.ChatWithFiles
func (mmChatWithFiles *mProviderMockChatWithFiles) Return(cp1 *mm_ai.ChatResult, err error) *ProviderMock {
	if mmChatWithFiles.mock.funcChatWithFiles != nil {
		mmChatWithFiles.mock.t.Fatalf("ProviderMock.ChatWithFiles mock is already set by Set")
	}

	if mmChatWithFiles.defaultExpectation == nil {
		mmChatWithFiles.defaultExpectation = &ProviderMockChatWithFilesExpectation{mock: mmChatWithFiles.mock}
	}
	mmChatWithFiles.defaultExpectation.results = &ProviderMockChatWithFilesResults{cp1, err}
	mmChatWithFiles.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmChatWithFiles.mock
}

// Set uses given function f to mock the Provider.ChatWithFiles method
func (mmChatWithFiles *mProviderMockChatWithFiles) Set(f func(ctx context.Context, files []mm_ai.FileContent, prompt string) (cp1 *mm_ai.ChatResult, err error)) *ProviderMock {
	if mmChatWithFiles.defaultExpectation != nil {
		mmChatWithFiles.mock.t.Fatalf("Default expectation is already set for the Provider.ChatWithFiles method")
	}

	if len(mmChatWithFiles.expectations) > 0 {
		mmChatWithFiles.mock.t.Fatalf("Some expectations are already set for the Provider.ChatWithFiles method")
	}

	mmChatWithFiles.mock.funcChatWithFiles = f
	mmChatWithFiles.mock.funcChatWithFilesOrigin = minimock.CallerInfo(1)
	return mmChatWithFiles.mock
}

// When sets expectation for the Provider.ChatWithFiles which will trigger the result defined by the following
// Then helper
func (mmChatWithFiles *mProviderMockChatWithFiles) When(ctx context.Context, files []mm_ai.FileContent, prompt string) *ProviderMockChatWithFilesExpectation {
	if mmChatWithFiles.mock.funcChatWithFiles != nil {
		mmChatWithFiles.mock.t.Fatalf("ProviderMock.ChatWithFiles mock is already set by Set")
	}

	expectation := &ProviderMockChatWithFilesExpectation{
		mock:               mmChatWithFiles.mock,
		params:             &ProviderMockChatWithFilesParams{ctx, files, prompt},
		expectationOrigins: ProviderMockChatWithFilesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmChatWithFiles.expectations = append(mmChatWithFiles.expectations, expectation)
	return expectation
}

// Then sets up Provider.ChatWithFiles return parameters for the expectation previously defined by the When method
func (e *ProviderMockChatWithFilesExpectation) Then(cp1 *mm_ai.ChatResult, err error) *ProviderMock {
	e.results = &ProviderMockChatWithFilesResults{cp1, err}
	return e.mock
}

// Times sets number of times Provider.ChatWithFiles should be invoked
func (mmChatWithFiles *mProviderMockChatWithFiles) Times(n uint64) *mProviderMockChatWithFiles {
	if n == 0 {
		mmChatWithFiles.mock.t.Fatalf("Times of ProviderMock.ChatWithFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmChatWithFiles.expectedInvocations, n)
	mmChatWithFiles.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmChatWithFiles
}

func (mmChatWithFiles *mProviderMockChatWithFiles) invocationsDone() bool {
	if len(mmChatWithFiles.expectations) == 0 && mmChatWithFiles.defaultExpectation == nil && mmChatWithFiles.mock.funcChatWithFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmChatWithFiles.mock.afterChatWithFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmChatWithFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ChatWithFiles implements mm_ai.Provider
func (mmChatWithFiles *ProviderMock) ChatWithFiles(ctx context.Context, files []mm_ai.FileContent, prompt string) (cp1 *mm_ai.ChatResult, err error) {
	mm_atomic.AddUint64(&mmChatWithFiles.beforeChatWithFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmChatWithFiles.afterChatWithFilesCounter, 1)

	mmChatWithFiles.t.Helper()

	if mmChatWithFiles.inspectFuncChatWithFiles != nil {
		mmChatWithFiles.inspectFuncChatWithFiles(ctx, files, prompt)
	}

	mm_params := ProviderMockChatWithFilesParams{ctx, files, prompt}

	// Record call args
	mmChatWithFiles.ChatWithFilesMock.mutex.Lock()
	mmChatWithFiles.ChatWithFilesMock.callArgs = append(mmChatWithFiles.ChatWithFilesMock.callArgs, &mm_params)
	mmChatWithFiles.ChatWithFilesMock.mutex.Unlock()

	for _, e := range mmChatWithFiles.ChatWithFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmChatWithFiles.ChatWithFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChatWithFiles.ChatWithFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmChatWithFiles.ChatWithFilesMock.defaultExpectation.params
		mm_want_ptrs := mmChatWithFiles.ChatWithFilesMock.defaultExpectation.paramPtrs

		mm_got := ProviderMockChatWithFilesParams{ctx, files, prompt}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmChatWithFiles.t.Errorf("ProviderMock.ChatWithFiles got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChatWithFiles.ChatWithFilesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.files != nil && !minimock.Equal(*mm_want_ptrs.files, mm_got.files) {
				mmChatWithFiles.t.Errorf("ProviderMock.ChatWithFiles got unexpected parameter files, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChatWithFiles.ChatWithFilesMock.defaultExpectation.expectationOrigins.originFiles, *mm_want_ptrs.files, mm_got.files, minimock.Diff(*mm_want_ptrs.files, mm_got.files))
			}

			if mm_want_ptrs.prompt != nil && !minimock.Equal(*mm_want_ptrs.prompt, mm_got.prompt) {
				mmChatWithFiles.t.Errorf("ProviderMock.ChatWithFiles got unexpected parameter prompt, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChatWithFiles.ChatWithFilesMock.defaultExpectation.expectationOrigins.originPrompt, *mm_want_ptrs.prompt, mm_got.prompt, minimock.Diff(*mm_want_ptrs.prompt, mm_got.prompt))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChatWithFiles.t.Errorf("ProviderMock.ChatWithFiles got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmChatWithFiles.ChatWithFilesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChatWithFiles.ChatWithFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmChatWithFiles.t.Fatal("No results are set for the ProviderMock.ChatWithFiles")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmChatWithFiles.funcChatWithFiles != nil {
		return mmChatWithFiles.funcChatWithFiles(ctx, files, prompt)
	}
	mmChatWithFiles.t.Fatalf("Unexpected call to ProviderMock.ChatWithFiles. %v %v %v", ctx, files, prompt)
	return
}

// ChatWithFilesAfterCounter returns a count of finished ProviderMock.ChatWithFiles invocations
func (mmChatWithFiles *ProviderMock) ChatWithFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChatWithFiles.afterChatWithFilesCounter)
}

// ChatWithFilesBeforeCounter returns a count of ProviderMock.ChatWithFiles invocations
func (mmChatWithFiles *ProviderMock) ChatWithFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChatWithFiles.beforeChatWithFilesCounter)
}

// Calls returns a list of arguments used in each call to ProviderMock.ChatWithFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChatWithFiles *mProviderMockChatWithFiles) Calls() []*ProviderMockChatWithFilesParams {
	mmChatWithFiles.mutex.RLock()

	argCopy := make([]*ProviderMockChatWithFilesParams, len(mmChatWithFiles.callArgs))
	copy(argCopy, mmChatWithFiles.callArgs)

	mmChatWithFiles.mutex.RUnlock()

	return argCopy
}

// MinimockChatWithFilesDone returns true if the count of the ChatWithFiles invocations corresponds
// the number of defined expectations
func (m *ProviderMock) MinimockChatWithFilesDone() bool {
	if m.ChatWithFilesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ChatWithFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ChatWithFilesMock.invocationsDone()
}

// MinimockChatWithFilesInspect logs each unmet expectation
func (m *ProviderMock) MinimockChatWithFilesInspect() {
	for _, e := range m.ChatWithFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProviderMock.ChatWithFiles at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterChatWithFilesCounter := mm_atomic.LoadUint64(&m.afterChatWithFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ChatWithFilesMock.defaultExpectation != nil && afterChatWithFilesCounter < 1 {
		if m.ChatWithFilesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ProviderMock.ChatWithFiles at\n%s", m.ChatWithFilesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ProviderMock.ChatWithFiles at\n%s with params: %#v", m.ChatWithFilesMock.defaultExpectation.expectationOrigins.origin, *m.ChatWithFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChatWithFiles != nil && afterChatWithFilesCounter < 1 {
		m.t.Errorf("Expected call to ProviderMock.ChatWithFiles at\n%s", m.funcChatWithFilesOrigin)
	}

	if !m.ChatWithFilesMock.invocationsDone() && afterChatWithFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to ProviderMock.ChatWithFiles at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ChatWithFilesMock.expectedInvocations), m.ChatWithFilesMock.expectedInvocationsOrigin, afterChatWithFilesCounter)
	}
}

type mProviderMockClose struct {
	optional           bool
	mock               *ProviderMock
	defaultExpectation *ProviderMockCloseExpectation
	expectations       []*ProviderMockCloseExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProviderMockCloseExpectation specifies expectation struct of the Provider.Close
type ProviderMockCloseExpectation struct {
	mock *ProviderMock

	results      *ProviderMockCloseResults
	returnOrigin string
	Counter      uint64
}

// ProviderMockCloseResults contains results of the Provider.Close
type ProviderMockCloseResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClose *mProviderMockClose) Optional() *mProviderMockClose {
	mmClose.optional = true
	return mmClose
}

// Expect sets up expected params for Provider.Close
func (mmClose *mProviderMockClose) Expect() *mProviderMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ProviderMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ProviderMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the Provider.Close
func (mmClose *mProviderMockClose) Inspect(f func()) *mProviderMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for ProviderMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by Provider.Close
func (mmClose *mProviderMockClose) Return(err error) *ProviderMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ProviderMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ProviderMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &ProviderMockCloseResults{err}
	mmClose.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Set uses given function f to mock the Provider.Close method
func (mmClose *mProviderMockClose) Set(f func() (err error)) *ProviderMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the Provider.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the Provider.Close method")
	}

	mmClose.mock.funcClose = f
	mmClose.mock.funcCloseOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Times sets number of times Provider.Close should be invoked
func (mmClose *mProviderMockClose) Times(n uint64) *mProviderMockClose {
	if n == 0 {
		mmClose.mock.t.Fatalf("Times of ProviderMock.Close mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClose.expectedInvocations, n)
	mmClose.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClose
}

func (mmClose *mProviderMockClose) invocationsDone() bool {
	if len(mmClose.expectations) == 0 && mmClose.defaultExpectation == nil && mmClose.mock.funcClose == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClose.mock.afterCloseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClose.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Close implements mm_ai.Provider
func (mmClose *ProviderMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	mmClose.t.Helper()

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the ProviderMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to ProviderMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished ProviderMock.Close invocations
func (mmClose *ProviderMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of ProviderMock.Close invocations
func (mmClose *ProviderMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *ProviderMock) MinimockCloseDone() bool {
	if m.CloseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CloseMock.invocationsDone()
}

// MinimockCloseInspect logs each unmet expectation
func (m *ProviderMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ProviderMock.Close")
		}
	}

	afterCloseCounter := mm_atomic.LoadUint64(&m.afterCloseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to ProviderMock.Close at\n%s", m.CloseMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to ProviderMock.Close at\n%s", m.funcCloseOrigin)
	}

	if !m.CloseMock.invocationsDone() && afterCloseCounter > 0 {
		m.t.Errorf("Expected %d calls to ProviderMock.Close at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CloseMock.expectedInvocations), m.CloseMock.expectedInvocationsOrigin, afterCloseCounter)
	}
}

type mProviderMockConvertToMarkdownWithCache struct {
	optional           bool
	mock               *ProviderMock
	defaultExpectation *ProviderMockConvertToMarkdownWithCacheExpectation
	expectations       []*ProviderMockConvertToMarkdownWithCacheExpectation

	callArgs []*ProviderMockConvertToMarkdownWithCacheParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProviderMockConvertToMarkdownWithCacheExpectation specifies expectation struct of the Provider.ConvertToMarkdownWithCache
type ProviderMockConvertToMarkdownWithCacheExpectation struct {
	mock               *ProviderMock
	params             *ProviderMockConvertToMarkdownWithCacheParams
	paramPtrs          *ProviderMockConvertToMarkdownWithCacheParamPtrs
	expectationOrigins ProviderMockConvertToMarkdownWithCacheExpectationOrigins
	results            *ProviderMockConvertToMarkdownWithCacheResults
	returnOrigin       string
	Counter            uint64
}

// ProviderMockConvertToMarkdownWithCacheParams contains parameters of the Provider.ConvertToMarkdownWithCache
type ProviderMockConvertToMarkdownWithCacheParams struct {
	ctx       context.Context
	cacheName string
	prompt    string
}

// ProviderMockConvertToMarkdownWithCacheParamPtrs contains pointers to parameters of the Provider.ConvertToMarkdownWithCache
type ProviderMockConvertToMarkdownWithCacheParamPtrs struct {
	ctx       *context.Context
	cacheName *string
	prompt    *string
}

// ProviderMockConvertToMarkdownWithCacheResults contains results of the Provider.ConvertToMarkdownWithCache
type ProviderMockConvertToMarkdownWithCacheResults struct {
	cp1 *mm_ai.ConversionResult
	err error
}

// ProviderMockConvertToMarkdownWithCacheOrigins contains origins of expectations of the Provider.ConvertToMarkdownWithCache
type ProviderMockConvertToMarkdownWithCacheExpectationOrigins struct {
	origin          string
	originCtx       string
	originCacheName string
	originPrompt    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConvertToMarkdownWithCache *mProviderMockConvertToMarkdownWithCache) Optional() *mProviderMockConvertToMarkdownWithCache {
	mmConvertToMarkdownWithCache.optional = true
	return mmConvertToMarkdownWithCache
}

// Expect sets up expected params for Provider.ConvertToMarkdownWithCache
func (mmConvertToMarkdownWithCache *mProviderMockConvertToMarkdownWithCache) Expect(ctx context.Context, cacheName string, prompt string) *mProviderMockConvertToMarkdownWithCache {
	if mmConvertToMarkdownWithCache.mock.funcConvertToMarkdownWithCache != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithCache mock is already set by Set")
	}

	if mmConvertToMarkdownWithCache.defaultExpectation == nil {
		mmConvertToMarkdownWithCache.defaultExpectation = &ProviderMockConvertToMarkdownWithCacheExpectation{}
	}

	if mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithCache mock is already set by ExpectParams functions")
	}

	mmConvertToMarkdownWithCache.defaultExpectation.params = &ProviderMockConvertToMarkdownWithCacheParams{ctx, cacheName, prompt}
	mmConvertToMarkdownWithCache.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmConvertToMarkdownWithCache.expectations {
		if minimock.Equal(e.params, mmConvertToMarkdownWithCache.defaultExpectation.params) {
			mmConvertToMarkdownWithCache.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertToMarkdownWithCache.defaultExpectation.params)
		}
	}

	return mmConvertToMarkdownWithCache
}

// ExpectCtxParam1 sets up expected param ctx for Provider.ConvertToMarkdownWithCache
func (mmConvertToMarkdownWithCache *mProviderMockConvertToMarkdownWithCache) ExpectCtxParam1(ctx context.Context) *mProviderMockConvertToMarkdownWithCache {
	if mmConvertToMarkdownWithCache.mock.funcConvertToMarkdownWithCache != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithCache mock is already set by Set")
	}

	if mmConvertToMarkdownWithCache.defaultExpectation == nil {
		mmConvertToMarkdownWithCache.defaultExpectation = &ProviderMockConvertToMarkdownWithCacheExpectation{}
	}

	if mmConvertToMarkdownWithCache.defaultExpectation.params != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithCache mock is already set by Expect")
	}

	if mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs == nil {
		mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs = &ProviderMockConvertToMarkdownWithCacheParamPtrs{}
	}
	mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs.ctx = &ctx
	mmConvertToMarkdownWithCache.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmConvertToMarkdownWithCache
}

// ExpectCacheNameParam2 sets up expected param cacheName for Provider.ConvertToMarkdownWithCache
func (mmConvertToMarkdownWithCache *mProviderMockConvertToMarkdownWithCache) ExpectCacheNameParam2(cacheName string) *mProviderMockConvertToMarkdownWithCache {
	if mmConvertToMarkdownWithCache.mock.funcConvertToMarkdownWithCache != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithCache mock is already set by Set")
	}

	if mmConvertToMarkdownWithCache.defaultExpectation == nil {
		mmConvertToMarkdownWithCache.defaultExpectation = &ProviderMockConvertToMarkdownWithCacheExpectation{}
	}

	if mmConvertToMarkdownWithCache.defaultExpectation.params != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithCache mock is already set by Expect")
	}

	if mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs == nil {
		mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs = &ProviderMockConvertToMarkdownWithCacheParamPtrs{}
	}
	mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs.cacheName = &cacheName
	mmConvertToMarkdownWithCache.defaultExpectation.expectationOrigins.originCacheName = minimock.CallerInfo(1)

	return mmConvertToMarkdownWithCache
}

// ExpectPromptParam3 sets up expected param prompt for Provider.ConvertToMarkdownWithCache
func (mmConvertToMarkdownWithCache *mProviderMockConvertToMarkdownWithCache) ExpectPromptParam3(prompt string) *mProviderMockConvertToMarkdownWithCache {
	if mmConvertToMarkdownWithCache.mock.funcConvertToMarkdownWithCache != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithCache mock is already set by Set")
	}

	if mmConvertToMarkdownWithCache.defaultExpectation == nil {
		mmConvertToMarkdownWithCache.defaultExpectation = &ProviderMockConvertToMarkdownWithCacheExpectation{}
	}

	if mmConvertToMarkdownWithCache.defaultExpectation.params != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithCache mock is already set by Expect")
	}

	if mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs == nil {
		mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs = &ProviderMockConvertToMarkdownWithCacheParamPtrs{}
	}
	mmConvertToMarkdownWithCache.defaultExpectation.paramPtrs.prompt = &prompt
	mmConvertToMarkdownWithCache.defaultExpectation.expectationOrigins.originPrompt = minimock.CallerInfo(1)

	return mmConvertToMarkdownWithCache
}

// Inspect accepts an inspector function that has same arguments as the Provider.ConvertToMarkdownWithCache
func (mmConvertToMarkdownWithCache *mProviderMockConvertToMarkdownWithCache) Inspect(f func(ctx context.Context, cacheName string, prompt string)) *mProviderMockConvertToMarkdownWithCache {
	if mmConvertToMarkdownWithCache.mock.inspectFuncConvertToMarkdownWithCache != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("Inspect function is already set for ProviderMock.ConvertToMarkdownWithCache")
	}

	mmConvertToMarkdownWithCache.mock.inspectFuncConvertToMarkdownWithCache = f

	return mmConvertToMarkdownWithCache
}

// Return sets up results that will be returned by Provider.ConvertToMarkdownWithCache
func (mmConvertToMarkdownWithCache *mProviderMockConvertToMarkdownWithCache) Return(cp1 *mm_ai.ConversionResult, err error) *ProviderMock {
	if mmConvertToMarkdownWithCache.mock.funcConvertToMarkdownWithCache != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithCache mock is already set by Set")
	}

	if mmConvertToMarkdownWithCache.defaultExpectation == nil {
		mmConvertToMarkdownWithCache.defaultExpectation = &ProviderMockConvertToMarkdownWithCacheExpectation{mock: mmConvertToMarkdownWithCache.mock}
	}
	mmConvertToMarkdownWithCache.defaultExpectation.results = &ProviderMockConvertToMarkdownWithCacheResults{cp1, err}
	mmConvertToMarkdownWithCache.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmConvertToMarkdownWithCache.mock
}

// Set uses given function f to mock the Provider.ConvertToMarkdownWithCache method
func (mmConvertToMarkdownWithCache *mProviderMockConvertToMarkdownWithCache) Set(f func(ctx context.Context, cacheName string, prompt string) (cp1 *mm_ai.ConversionResult, err error)) *ProviderMock {
	if mmConvertToMarkdownWithCache.defaultExpectation != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("Default expectation is already set for the Provider.ConvertToMarkdownWithCache method")
	}

	if len(mmConvertToMarkdownWithCache.expectations) > 0 {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("Some expectations are already set for the Provider.ConvertToMarkdownWithCache method")
	}

	mmConvertToMarkdownWithCache.mock.funcConvertToMarkdownWithCache = f
	mmConvertToMarkdownWithCache.mock.funcConvertToMarkdownWithCacheOrigin = minimock.CallerInfo(1)
	return mmConvertToMarkdownWithCache.mock
}

// When sets expectation for the Provider.ConvertToMarkdownWithCache which will trigger the result defined by the following
// Then helper
func (mmConvertToMarkdownWithCache *mProviderMockConvertToMarkdownWithCache) When(ctx context.Context, cacheName string, prompt string) *ProviderMockConvertToMarkdownWithCacheExpectation {
	if mmConvertToMarkdownWithCache.mock.funcConvertToMarkdownWithCache != nil {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithCache mock is already set by Set")
	}

	expectation := &ProviderMockConvertToMarkdownWithCacheExpectation{
		mock:               mmConvertToMarkdownWithCache.mock,
		params:             &ProviderMockConvertToMarkdownWithCacheParams{ctx, cacheName, prompt},
		expectationOrigins: ProviderMockConvertToMarkdownWithCacheExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmConvertToMarkdownWithCache.expectations = append(mmConvertToMarkdownWithCache.expectations, expectation)
	return expectation
}

// Then sets up Provider.ConvertToMarkdownWithCache return parameters for the expectation previously defined by the When method
func (e *ProviderMockConvertToMarkdownWithCacheExpectation) Then(cp1 *mm_ai.ConversionResult, err error) *ProviderMock {
	e.results = &ProviderMockConvertToMarkdownWithCacheResults{cp1, err}
	return e.mock
}

// Times sets number of times Provider.ConvertToMarkdownWithCache should be invoked
func (mmConvertToMarkdownWithCache *mProviderMockConvertToMarkdownWithCache) Times(n uint64) *mProviderMockConvertToMarkdownWithCache {
	if n == 0 {
		mmConvertToMarkdownWithCache.mock.t.Fatalf("Times of ProviderMock.ConvertToMarkdownWithCache mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertToMarkdownWithCache.expectedInvocations, n)
	mmConvertToMarkdownWithCache.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmConvertToMarkdownWithCache
}

func (mmConvertToMarkdownWithCache *mProviderMockConvertToMarkdownWithCache) invocationsDone() bool {
	if len(mmConvertToMarkdownWithCache.expectations) == 0 && mmConvertToMarkdownWithCache.defaultExpectation == nil && mmConvertToMarkdownWithCache.mock.funcConvertToMarkdownWithCache == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertToMarkdownWithCache.mock.afterConvertToMarkdownWithCacheCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertToMarkdownWithCache.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertToMarkdownWithCache implements mm_ai.Provider
func (mmConvertToMarkdownWithCache *ProviderMock) ConvertToMarkdownWithCache(ctx context.Context, cacheName string, prompt string) (cp1 *mm_ai.ConversionResult, err error) {
	mm_atomic.AddUint64(&mmConvertToMarkdownWithCache.beforeConvertToMarkdownWithCacheCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertToMarkdownWithCache.afterConvertToMarkdownWithCacheCounter, 1)

	mmConvertToMarkdownWithCache.t.Helper()

	if mmConvertToMarkdownWithCache.inspectFuncConvertToMarkdownWithCache != nil {
		mmConvertToMarkdownWithCache.inspectFuncConvertToMarkdownWithCache(ctx, cacheName, prompt)
	}

	mm_params := ProviderMockConvertToMarkdownWithCacheParams{ctx, cacheName, prompt}

	// Record call args
	mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.mutex.Lock()
	mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.callArgs = append(mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.callArgs, &mm_params)
	mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.mutex.Unlock()

	for _, e := range mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.defaultExpectation.params
		mm_want_ptrs := mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.defaultExpectation.paramPtrs

		mm_got := ProviderMockConvertToMarkdownWithCacheParams{ctx, cacheName, prompt}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConvertToMarkdownWithCache.t.Errorf("ProviderMock.ConvertToMarkdownWithCache got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cacheName != nil && !minimock.Equal(*mm_want_ptrs.cacheName, mm_got.cacheName) {
				mmConvertToMarkdownWithCache.t.Errorf("ProviderMock.ConvertToMarkdownWithCache got unexpected parameter cacheName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.defaultExpectation.expectationOrigins.originCacheName, *mm_want_ptrs.cacheName, mm_got.cacheName, minimock.Diff(*mm_want_ptrs.cacheName, mm_got.cacheName))
			}

			if mm_want_ptrs.prompt != nil && !minimock.Equal(*mm_want_ptrs.prompt, mm_got.prompt) {
				mmConvertToMarkdownWithCache.t.Errorf("ProviderMock.ConvertToMarkdownWithCache got unexpected parameter prompt, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.defaultExpectation.expectationOrigins.originPrompt, *mm_want_ptrs.prompt, mm_got.prompt, minimock.Diff(*mm_want_ptrs.prompt, mm_got.prompt))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertToMarkdownWithCache.t.Errorf("ProviderMock.ConvertToMarkdownWithCache got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertToMarkdownWithCache.ConvertToMarkdownWithCacheMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertToMarkdownWithCache.t.Fatal("No results are set for the ProviderMock.ConvertToMarkdownWithCache")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmConvertToMarkdownWithCache.funcConvertToMarkdownWithCache != nil {
		return mmConvertToMarkdownWithCache.funcConvertToMarkdownWithCache(ctx, cacheName, prompt)
	}
	mmConvertToMarkdownWithCache.t.Fatalf("Unexpected call to ProviderMock.ConvertToMarkdownWithCache. %v %v %v", ctx, cacheName, prompt)
	return
}

// ConvertToMarkdownWithCacheAfterCounter returns a count of finished ProviderMock.ConvertToMarkdownWithCache invocations
func (mmConvertToMarkdownWithCache *ProviderMock) ConvertToMarkdownWithCacheAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertToMarkdownWithCache.afterConvertToMarkdownWithCacheCounter)
}

// ConvertToMarkdownWithCacheBeforeCounter returns a count of ProviderMock.ConvertToMarkdownWithCache invocations
func (mmConvertToMarkdownWithCache *ProviderMock) ConvertToMarkdownWithCacheBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertToMarkdownWithCache.beforeConvertToMarkdownWithCacheCounter)
}

// Calls returns a list of arguments used in each call to ProviderMock.ConvertToMarkdownWithCache.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertToMarkdownWithCache *mProviderMockConvertToMarkdownWithCache) Calls() []*ProviderMockConvertToMarkdownWithCacheParams {
	mmConvertToMarkdownWithCache.mutex.RLock()

	argCopy := make([]*ProviderMockConvertToMarkdownWithCacheParams, len(mmConvertToMarkdownWithCache.callArgs))
	copy(argCopy, mmConvertToMarkdownWithCache.callArgs)

	mmConvertToMarkdownWithCache.mutex.RUnlock()

	return argCopy
}

// MinimockConvertToMarkdownWithCacheDone returns true if the count of the ConvertToMarkdownWithCache invocations corresponds
// the number of defined expectations
func (m *ProviderMock) MinimockConvertToMarkdownWithCacheDone() bool {
	if m.ConvertToMarkdownWithCacheMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConvertToMarkdownWithCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertToMarkdownWithCacheMock.invocationsDone()
}

// MinimockConvertToMarkdownWithCacheInspect logs each unmet expectation
func (m *ProviderMock) MinimockConvertToMarkdownWithCacheInspect() {
	for _, e := range m.ConvertToMarkdownWithCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProviderMock.ConvertToMarkdownWithCache at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterConvertToMarkdownWithCacheCounter := mm_atomic.LoadUint64(&m.afterConvertToMarkdownWithCacheCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertToMarkdownWithCacheMock.defaultExpectation != nil && afterConvertToMarkdownWithCacheCounter < 1 {
		if m.ConvertToMarkdownWithCacheMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ProviderMock.ConvertToMarkdownWithCache at\n%s", m.ConvertToMarkdownWithCacheMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ProviderMock.ConvertToMarkdownWithCache at\n%s with params: %#v", m.ConvertToMarkdownWithCacheMock.defaultExpectation.expectationOrigins.origin, *m.ConvertToMarkdownWithCacheMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertToMarkdownWithCache != nil && afterConvertToMarkdownWithCacheCounter < 1 {
		m.t.Errorf("Expected call to ProviderMock.ConvertToMarkdownWithCache at\n%s", m.funcConvertToMarkdownWithCacheOrigin)
	}

	if !m.ConvertToMarkdownWithCacheMock.invocationsDone() && afterConvertToMarkdownWithCacheCounter > 0 {
		m.t.Errorf("Expected %d calls to ProviderMock.ConvertToMarkdownWithCache at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertToMarkdownWithCacheMock.expectedInvocations), m.ConvertToMarkdownWithCacheMock.expectedInvocationsOrigin, afterConvertToMarkdownWithCacheCounter)
	}
}

type mProviderMockConvertToMarkdownWithoutCache struct {
	optional           bool
	mock               *ProviderMock
	defaultExpectation *ProviderMockConvertToMarkdownWithoutCacheExpectation
	expectations       []*ProviderMockConvertToMarkdownWithoutCacheExpectation

	callArgs []*ProviderMockConvertToMarkdownWithoutCacheParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProviderMockConvertToMarkdownWithoutCacheExpectation specifies expectation struct of the Provider.ConvertToMarkdownWithoutCache
type ProviderMockConvertToMarkdownWithoutCacheExpectation struct {
	mock               *ProviderMock
	params             *ProviderMockConvertToMarkdownWithoutCacheParams
	paramPtrs          *ProviderMockConvertToMarkdownWithoutCacheParamPtrs
	expectationOrigins ProviderMockConvertToMarkdownWithoutCacheExpectationOrigins
	results            *ProviderMockConvertToMarkdownWithoutCacheResults
	returnOrigin       string
	Counter            uint64
}

// ProviderMockConvertToMarkdownWithoutCacheParams contains parameters of the Provider.ConvertToMarkdownWithoutCache
type ProviderMockConvertToMarkdownWithoutCacheParams struct {
	ctx      context.Context
	content  []byte
	fileType artifactpb.FileType
	filename string
	prompt   string
}

// ProviderMockConvertToMarkdownWithoutCacheParamPtrs contains pointers to parameters of the Provider.ConvertToMarkdownWithoutCache
type ProviderMockConvertToMarkdownWithoutCacheParamPtrs struct {
	ctx      *context.Context
	content  *[]byte
	fileType *artifactpb.FileType
	filename *string
	prompt   *string
}

// ProviderMockConvertToMarkdownWithoutCacheResults contains results of the Provider.ConvertToMarkdownWithoutCache
type ProviderMockConvertToMarkdownWithoutCacheResults struct {
	cp1 *mm_ai.ConversionResult
	err error
}

// ProviderMockConvertToMarkdownWithoutCacheOrigins contains origins of expectations of the Provider.ConvertToMarkdownWithoutCache
type ProviderMockConvertToMarkdownWithoutCacheExpectationOrigins struct {
	origin         string
	originCtx      string
	originContent  string
	originFileType string
	originFilename string
	originPrompt   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConvertToMarkdownWithoutCache *mProviderMockConvertToMarkdownWithoutCache) Optional() *mProviderMockConvertToMarkdownWithoutCache {
	mmConvertToMarkdownWithoutCache.optional = true
	return mmConvertToMarkdownWithoutCache
}

// Expect sets up expected params for Provider.ConvertToMarkdownWithoutCache
func (mmConvertToMarkdownWithoutCache *mProviderMockConvertToMarkdownWithoutCache) Expect(ctx context.Context, content []byte, fileType artifactpb.FileType, filename string, prompt string) *mProviderMockConvertToMarkdownWithoutCache {
	if mmConvertToMarkdownWithoutCache.mock.funcConvertToMarkdownWithoutCache != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithoutCache mock is already set by Set")
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation == nil {
		mmConvertToMarkdownWithoutCache.defaultExpectation = &ProviderMockConvertToMarkdownWithoutCacheExpectation{}
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithoutCache mock is already set by ExpectParams functions")
	}

	mmConvertToMarkdownWithoutCache.defaultExpectation.params = &ProviderMockConvertToMarkdownWithoutCacheParams{ctx, content, fileType, filename, prompt}
	mmConvertToMarkdownWithoutCache.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmConvertToMarkdownWithoutCache.expectations {
		if minimock.Equal(e.params, mmConvertToMarkdownWithoutCache.defaultExpectation.params) {
			mmConvertToMarkdownWithoutCache.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertToMarkdownWithoutCache.defaultExpectation.params)
		}
	}

	return mmConvertToMarkdownWithoutCache
}

// ExpectCtxParam1 sets up expected param ctx for Provider.ConvertToMarkdownWithoutCache
func (mmConvertToMarkdownWithoutCache *mProviderMockConvertToMarkdownWithoutCache) ExpectCtxParam1(ctx context.Context) *mProviderMockConvertToMarkdownWithoutCache {
	if mmConvertToMarkdownWithoutCache.mock.funcConvertToMarkdownWithoutCache != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithoutCache mock is already set by Set")
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation == nil {
		mmConvertToMarkdownWithoutCache.defaultExpectation = &ProviderMockConvertToMarkdownWithoutCacheExpectation{}
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation.params != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithoutCache mock is already set by Expect")
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs == nil {
		mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs = &ProviderMockConvertToMarkdownWithoutCacheParamPtrs{}
	}
	mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs.ctx = &ctx
	mmConvertToMarkdownWithoutCache.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmConvertToMarkdownWithoutCache
}

// ExpectContentParam2 sets up expected param content for Provider.ConvertToMarkdownWithoutCache
func (mmConvertToMarkdownWithoutCache *mProviderMockConvertToMarkdownWithoutCache) ExpectContentParam2(content []byte) *mProviderMockConvertToMarkdownWithoutCache {
	if mmConvertToMarkdownWithoutCache.mock.funcConvertToMarkdownWithoutCache != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithoutCache mock is already set by Set")
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation == nil {
		mmConvertToMarkdownWithoutCache.defaultExpectation = &ProviderMockConvertToMarkdownWithoutCacheExpectation{}
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation.params != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithoutCache mock is already set by Expect")
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs == nil {
		mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs = &ProviderMockConvertToMarkdownWithoutCacheParamPtrs{}
	}
	mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs.content = &content
	mmConvertToMarkdownWithoutCache.defaultExpectation.expectationOrigins.originContent = minimock.CallerInfo(1)

	return mmConvertToMarkdownWithoutCache
}

// ExpectFileTypeParam3 sets up expected param fileType for Provider.ConvertToMarkdownWithoutCache
func (mmConvertToMarkdownWithoutCache *mProviderMockConvertToMarkdownWithoutCache) ExpectFileTypeParam3(fileType artifactpb.FileType) *mProviderMockConvertToMarkdownWithoutCache {
	if mmConvertToMarkdownWithoutCache.mock.funcConvertToMarkdownWithoutCache != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithoutCache mock is already set by Set")
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation == nil {
		mmConvertToMarkdownWithoutCache.defaultExpectation = &ProviderMockConvertToMarkdownWithoutCacheExpectation{}
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation.params != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithoutCache mock is already set by Expect")
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs == nil {
		mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs = &ProviderMockConvertToMarkdownWithoutCacheParamPtrs{}
	}
	mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs.fileType = &fileType
	mmConvertToMarkdownWithoutCache.defaultExpectation.expectationOrigins.originFileType = minimock.CallerInfo(1)

	return mmConvertToMarkdownWithoutCache
}

// ExpectFilenameParam4 sets up expected param filename for Provider.ConvertToMarkdownWithoutCache
func (mmConvertToMarkdownWithoutCache *mProviderMockConvertToMarkdownWithoutCache) ExpectFilenameParam4(filename string) *mProviderMockConvertToMarkdownWithoutCache {
	if mmConvertToMarkdownWithoutCache.mock.funcConvertToMarkdownWithoutCache != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithoutCache mock is already set by Set")
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation == nil {
		mmConvertToMarkdownWithoutCache.defaultExpectation = &ProviderMockConvertToMarkdownWithoutCacheExpectation{}
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation.params != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithoutCache mock is already set by Expect")
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs == nil {
		mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs = &ProviderMockConvertToMarkdownWithoutCacheParamPtrs{}
	}
	mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs.filename = &filename
	mmConvertToMarkdownWithoutCache.defaultExpectation.expectationOrigins.originFilename = minimock.CallerInfo(1)

	return mmConvertToMarkdownWithoutCache
}

// ExpectPromptParam5 sets up expected param prompt for Provider.ConvertToMarkdownWithoutCache
func (mmConvertToMarkdownWithoutCache *mProviderMockConvertToMarkdownWithoutCache) ExpectPromptParam5(prompt string) *mProviderMockConvertToMarkdownWithoutCache {
	if mmConvertToMarkdownWithoutCache.mock.funcConvertToMarkdownWithoutCache != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithoutCache mock is already set by Set")
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation == nil {
		mmConvertToMarkdownWithoutCache.defaultExpectation = &ProviderMockConvertToMarkdownWithoutCacheExpectation{}
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation.params != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithoutCache mock is already set by Expect")
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs == nil {
		mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs = &ProviderMockConvertToMarkdownWithoutCacheParamPtrs{}
	}
	mmConvertToMarkdownWithoutCache.defaultExpectation.paramPtrs.prompt = &prompt
	mmConvertToMarkdownWithoutCache.defaultExpectation.expectationOrigins.originPrompt = minimock.CallerInfo(1)

	return mmConvertToMarkdownWithoutCache
}

// Inspect accepts an inspector function that has same arguments as the Provider.ConvertToMarkdownWithoutCache
func (mmConvertToMarkdownWithoutCache *mProviderMockConvertToMarkdownWithoutCache) Inspect(f func(ctx context.Context, content []byte, fileType artifactpb.FileType, filename string, prompt string)) *mProviderMockConvertToMarkdownWithoutCache {
	if mmConvertToMarkdownWithoutCache.mock.inspectFuncConvertToMarkdownWithoutCache != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("Inspect function is already set for ProviderMock.ConvertToMarkdownWithoutCache")
	}

	mmConvertToMarkdownWithoutCache.mock.inspectFuncConvertToMarkdownWithoutCache = f

	return mmConvertToMarkdownWithoutCache
}

// Return sets up results that will be returned by Provider.ConvertToMarkdownWithoutCache
func (mmConvertToMarkdownWithoutCache *mProviderMockConvertToMarkdownWithoutCache) Return(cp1 *mm_ai.ConversionResult, err error) *ProviderMock {
	if mmConvertToMarkdownWithoutCache.mock.funcConvertToMarkdownWithoutCache != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithoutCache mock is already set by Set")
	}

	if mmConvertToMarkdownWithoutCache.defaultExpectation == nil {
		mmConvertToMarkdownWithoutCache.defaultExpectation = &ProviderMockConvertToMarkdownWithoutCacheExpectation{mock: mmConvertToMarkdownWithoutCache.mock}
	}
	mmConvertToMarkdownWithoutCache.defaultExpectation.results = &ProviderMockConvertToMarkdownWithoutCacheResults{cp1, err}
	mmConvertToMarkdownWithoutCache.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmConvertToMarkdownWithoutCache.mock
}

// Set uses given function f to mock the Provider.ConvertToMarkdownWithoutCache method
func (mmConvertToMarkdownWithoutCache *mProviderMockConvertToMarkdownWithoutCache) Set(f func(ctx context.Context, content []byte, fileType artifactpb.FileType, filename string, prompt string) (cp1 *mm_ai.ConversionResult, err error)) *ProviderMock {
	if mmConvertToMarkdownWithoutCache.defaultExpectation != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("Default expectation is already set for the Provider.ConvertToMarkdownWithoutCache method")
	}

	if len(mmConvertToMarkdownWithoutCache.expectations) > 0 {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("Some expectations are already set for the Provider.ConvertToMarkdownWithoutCache method")
	}

	mmConvertToMarkdownWithoutCache.mock.funcConvertToMarkdownWithoutCache = f
	mmConvertToMarkdownWithoutCache.mock.funcConvertToMarkdownWithoutCacheOrigin = minimock.CallerInfo(1)
	return mmConvertToMarkdownWithoutCache.mock
}

// When sets expectation for the Provider.ConvertToMarkdownWithoutCache which will trigger the result defined by the following
// Then helper
func (mmConvertToMarkdownWithoutCache *mProviderMockConvertToMarkdownWithoutCache) When(ctx context.Context, content []byte, fileType artifactpb.FileType, filename string, prompt string) *ProviderMockConvertToMarkdownWithoutCacheExpectation {
	if mmConvertToMarkdownWithoutCache.mock.funcConvertToMarkdownWithoutCache != nil {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("ProviderMock.ConvertToMarkdownWithoutCache mock is already set by Set")
	}

	expectation := &ProviderMockConvertToMarkdownWithoutCacheExpectation{
		mock:               mmConvertToMarkdownWithoutCache.mock,
		params:             &ProviderMockConvertToMarkdownWithoutCacheParams{ctx, content, fileType, filename, prompt},
		expectationOrigins: ProviderMockConvertToMarkdownWithoutCacheExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmConvertToMarkdownWithoutCache.expectations = append(mmConvertToMarkdownWithoutCache.expectations, expectation)
	return expectation
}

// Then sets up Provider.ConvertToMarkdownWithoutCache return parameters for the expectation previously defined by the When method
func (e *ProviderMockConvertToMarkdownWithoutCacheExpectation) Then(cp1 *mm_ai.ConversionResult, err error) *ProviderMock {
	e.results = &ProviderMockConvertToMarkdownWithoutCacheResults{cp1, err}
	return e.mock
}

// Times sets number of times Provider.ConvertToMarkdownWithoutCache should be invoked
func (mmConvertToMarkdownWithoutCache *mProviderMockConvertToMarkdownWithoutCache) Times(n uint64) *mProviderMockConvertToMarkdownWithoutCache {
	if n == 0 {
		mmConvertToMarkdownWithoutCache.mock.t.Fatalf("Times of ProviderMock.ConvertToMarkdownWithoutCache mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertToMarkdownWithoutCache.expectedInvocations, n)
	mmConvertToMarkdownWithoutCache.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmConvertToMarkdownWithoutCache
}

func (mmConvertToMarkdownWithoutCache *mProviderMockConvertToMarkdownWithoutCache) invocationsDone() bool {
	if len(mmConvertToMarkdownWithoutCache.expectations) == 0 && mmConvertToMarkdownWithoutCache.defaultExpectation == nil && mmConvertToMarkdownWithoutCache.mock.funcConvertToMarkdownWithoutCache == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertToMarkdownWithoutCache.mock.afterConvertToMarkdownWithoutCacheCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertToMarkdownWithoutCache.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertToMarkdownWithoutCache implements mm_ai.Provider
func (mmConvertToMarkdownWithoutCache *ProviderMock) ConvertToMarkdownWithoutCache(ctx context.Context, content []byte, fileType artifactpb.FileType, filename string, prompt string) (cp1 *mm_ai.ConversionResult, err error) {
	mm_atomic.AddUint64(&mmConvertToMarkdownWithoutCache.beforeConvertToMarkdownWithoutCacheCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertToMarkdownWithoutCache.afterConvertToMarkdownWithoutCacheCounter, 1)

	mmConvertToMarkdownWithoutCache.t.Helper()

	if mmConvertToMarkdownWithoutCache.inspectFuncConvertToMarkdownWithoutCache != nil {
		mmConvertToMarkdownWithoutCache.inspectFuncConvertToMarkdownWithoutCache(ctx, content, fileType, filename, prompt)
	}

	mm_params := ProviderMockConvertToMarkdownWithoutCacheParams{ctx, content, fileType, filename, prompt}

	// Record call args
	mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.mutex.Lock()
	mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.callArgs = append(mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.callArgs, &mm_params)
	mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.mutex.Unlock()

	for _, e := range mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.defaultExpectation.params
		mm_want_ptrs := mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.defaultExpectation.paramPtrs

		mm_got := ProviderMockConvertToMarkdownWithoutCacheParams{ctx, content, fileType, filename, prompt}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConvertToMarkdownWithoutCache.t.Errorf("ProviderMock.ConvertToMarkdownWithoutCache got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.content != nil && !minimock.Equal(*mm_want_ptrs.content, mm_got.content) {
				mmConvertToMarkdownWithoutCache.t.Errorf("ProviderMock.ConvertToMarkdownWithoutCache got unexpected parameter content, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.defaultExpectation.expectationOrigins.originContent, *mm_want_ptrs.content, mm_got.content, minimock.Diff(*mm_want_ptrs.content, mm_got.content))
			}

			if mm_want_ptrs.fileType != nil && !minimock.Equal(*mm_want_ptrs.fileType, mm_got.fileType) {
				mmConvertToMarkdownWithoutCache.t.Errorf("ProviderMock.ConvertToMarkdownWithoutCache got unexpected parameter fileType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.defaultExpectation.expectationOrigins.originFileType, *mm_want_ptrs.fileType, mm_got.fileType, minimock.Diff(*mm_want_ptrs.fileType, mm_got.fileType))
			}

			if mm_want_ptrs.filename != nil && !minimock.Equal(*mm_want_ptrs.filename, mm_got.filename) {
				mmConvertToMarkdownWithoutCache.t.Errorf("ProviderMock.ConvertToMarkdownWithoutCache got unexpected parameter filename, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.defaultExpectation.expectationOrigins.originFilename, *mm_want_ptrs.filename, mm_got.filename, minimock.Diff(*mm_want_ptrs.filename, mm_got.filename))
			}

			if mm_want_ptrs.prompt != nil && !minimock.Equal(*mm_want_ptrs.prompt, mm_got.prompt) {
				mmConvertToMarkdownWithoutCache.t.Errorf("ProviderMock.ConvertToMarkdownWithoutCache got unexpected parameter prompt, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.defaultExpectation.expectationOrigins.originPrompt, *mm_want_ptrs.prompt, mm_got.prompt, minimock.Diff(*mm_want_ptrs.prompt, mm_got.prompt))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertToMarkdownWithoutCache.t.Errorf("ProviderMock.ConvertToMarkdownWithoutCache got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertToMarkdownWithoutCache.ConvertToMarkdownWithoutCacheMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertToMarkdownWithoutCache.t.Fatal("No results are set for the ProviderMock.ConvertToMarkdownWithoutCache")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmConvertToMarkdownWithoutCache.funcConvertToMarkdownWithoutCache != nil {
		return mmConvertToMarkdownWithoutCache.funcConvertToMarkdownWithoutCache(ctx, content, fileType, filename, prompt)
	}
	mmConvertToMarkdownWithoutCache.t.Fatalf("Unexpected call to ProviderMock.ConvertToMarkdownWithoutCache. %v %v %v %v %v", ctx, content, fileType, filename, prompt)
	return
}

// ConvertToMarkdownWithoutCacheAfterCounter returns a count of finished ProviderMock.ConvertToMarkdownWithoutCache invocations
func (mmConvertToMarkdownWithoutCache *ProviderMock) ConvertToMarkdownWithoutCacheAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertToMarkdownWithoutCache.afterConvertToMarkdownWithoutCacheCounter)
}

// ConvertToMarkdownWithoutCacheBeforeCounter returns a count of ProviderMock.ConvertToMarkdownWithoutCache invocations
func (mmConvertToMarkdownWithoutCache *ProviderMock) ConvertToMarkdownWithoutCacheBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertToMarkdownWithoutCache.beforeConvertToMarkdownWithoutCacheCounter)
}

// Calls returns a list of arguments used in each call to ProviderMock.ConvertToMarkdownWithoutCache.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertToMarkdownWithoutCache *mProviderMockConvertToMarkdownWithoutCache) Calls() []*ProviderMockConvertToMarkdownWithoutCacheParams {
	mmConvertToMarkdownWithoutCache.mutex.RLock()

	argCopy := make([]*ProviderMockConvertToMarkdownWithoutCacheParams, len(mmConvertToMarkdownWithoutCache.callArgs))
	copy(argCopy, mmConvertToMarkdownWithoutCache.callArgs)

	mmConvertToMarkdownWithoutCache.mutex.RUnlock()

	return argCopy
}

// MinimockConvertToMarkdownWithoutCacheDone returns true if the count of the ConvertToMarkdownWithoutCache invocations corresponds
// the number of defined expectations
func (m *ProviderMock) MinimockConvertToMarkdownWithoutCacheDone() bool {
	if m.ConvertToMarkdownWithoutCacheMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConvertToMarkdownWithoutCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertToMarkdownWithoutCacheMock.invocationsDone()
}

// MinimockConvertToMarkdownWithoutCacheInspect logs each unmet expectation
func (m *ProviderMock) MinimockConvertToMarkdownWithoutCacheInspect() {
	for _, e := range m.ConvertToMarkdownWithoutCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProviderMock.ConvertToMarkdownWithoutCache at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterConvertToMarkdownWithoutCacheCounter := mm_atomic.LoadUint64(&m.afterConvertToMarkdownWithoutCacheCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertToMarkdownWithoutCacheMock.defaultExpectation != nil && afterConvertToMarkdownWithoutCacheCounter < 1 {
		if m.ConvertToMarkdownWithoutCacheMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ProviderMock.ConvertToMarkdownWithoutCache at\n%s", m.ConvertToMarkdownWithoutCacheMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ProviderMock.ConvertToMarkdownWithoutCache at\n%s with params: %#v", m.ConvertToMarkdownWithoutCacheMock.defaultExpectation.expectationOrigins.origin, *m.ConvertToMarkdownWithoutCacheMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertToMarkdownWithoutCache != nil && afterConvertToMarkdownWithoutCacheCounter < 1 {
		m.t.Errorf("Expected call to ProviderMock.ConvertToMarkdownWithoutCache at\n%s", m.funcConvertToMarkdownWithoutCacheOrigin)
	}

	if !m.ConvertToMarkdownWithoutCacheMock.invocationsDone() && afterConvertToMarkdownWithoutCacheCounter > 0 {
		m.t.Errorf("Expected %d calls to ProviderMock.ConvertToMarkdownWithoutCache at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertToMarkdownWithoutCacheMock.expectedInvocations), m.ConvertToMarkdownWithoutCacheMock.expectedInvocationsOrigin, afterConvertToMarkdownWithoutCacheCounter)
	}
}

type mProviderMockCreateCache struct {
	optional           bool
	mock               *ProviderMock
	defaultExpectation *ProviderMockCreateCacheExpectation
	expectations       []*ProviderMockCreateCacheExpectation

	callArgs []*ProviderMockCreateCacheParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProviderMockCreateCacheExpectation specifies expectation struct of the Provider.CreateCache
type ProviderMockCreateCacheExpectation struct {
	mock               *ProviderMock
	params             *ProviderMockCreateCacheParams
	paramPtrs          *ProviderMockCreateCacheParamPtrs
	expectationOrigins ProviderMockCreateCacheExpectationOrigins
	results            *ProviderMockCreateCacheResults
	returnOrigin       string
	Counter            uint64
}

// ProviderMockCreateCacheParams contains parameters of the Provider.CreateCache
type ProviderMockCreateCacheParams struct {
	ctx               context.Context
	files             []mm_ai.FileContent
	ttl               time.Duration
	systemInstruction string
}

// ProviderMockCreateCacheParamPtrs contains pointers to parameters of the Provider.CreateCache
type ProviderMockCreateCacheParamPtrs struct {
	ctx               *context.Context
	files             *[]mm_ai.FileContent
	ttl               *time.Duration
	systemInstruction *string
}

// ProviderMockCreateCacheResults contains results of the Provider.CreateCache
type ProviderMockCreateCacheResults struct {
	cp1 *mm_ai.CacheResult
	err error
}

// ProviderMockCreateCacheOrigins contains origins of expectations of the Provider.CreateCache
type ProviderMockCreateCacheExpectationOrigins struct {
	origin                  string
	originCtx               string
	originFiles             string
	originTtl               string
	originSystemInstruction string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateCache *mProviderMockCreateCache) Optional() *mProviderMockCreateCache {
	mmCreateCache.optional = true
	return mmCreateCache
}

// Expect sets up expected params for Provider.CreateCache
func (mmCreateCache *mProviderMockCreateCache) Expect(ctx context.Context, files []mm_ai.FileContent, ttl time.Duration, systemInstruction string) *mProviderMockCreateCache {
	if mmCreateCache.mock.funcCreateCache != nil {
		mmCreateCache.mock.t.Fatalf("ProviderMock.CreateCache mock is already set by Set")
	}

	if mmCreateCache.defaultExpectation == nil {
		mmCreateCache.defaultExpectation = &ProviderMockCreateCacheExpectation{}
	}

	if mmCreateCache.defaultExpectation.paramPtrs != nil {
		mmCreateCache.mock.t.Fatalf("ProviderMock.CreateCache mock is already set by ExpectParams functions")
	}

	mmCreateCache.defaultExpectation.params = &ProviderMockCreateCacheParams{ctx, files, ttl, systemInstruction}
	mmCreateCache.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateCache.expectations {
		if minimock.Equal(e.params, mmCreateCache.defaultExpectation.params) {
			mmCreateCache.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateCache.defaultExpectation.params)
		}
	}

	return mmCreateCache
}

// ExpectCtxParam1 sets up expected param ctx for Provider.CreateCache
func (mmCreateCache *mProviderMockCreateCache) ExpectCtxParam1(ctx context.Context) *mProviderMockCreateCache {
	if mmCreateCache.mock.funcCreateCache != nil {
		mmCreateCache.mock.t.Fatalf("ProviderMock.CreateCache mock is already set by Set")
	}

	if mmCreateCache.defaultExpectation == nil {
		mmCreateCache.defaultExpectation = &ProviderMockCreateCacheExpectation{}
	}

	if mmCreateCache.defaultExpectation.params != nil {
		mmCreateCache.mock.t.Fatalf("ProviderMock.CreateCache mock is already set by Expect")
	}

	if mmCreateCache.defaultExpectation.paramPtrs == nil {
		mmCreateCache.defaultExpectation.paramPtrs = &ProviderMockCreateCacheParamPtrs{}
	}
	mmCreateCache.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateCache.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateCache
}

// ExpectFilesParam2 sets up expected param files for Provider.CreateCache
func (mmCreateCache *mProviderMockCreateCache) ExpectFilesParam2(files []mm_ai.FileContent) *mProviderMockCreateCache {
	if mmCreateCache.mock.funcCreateCache != nil {
		mmCreateCache.mock.t.Fatalf("ProviderMock.CreateCache mock is already set by Set")
	}

	if mmCreateCache.defaultExpectation == nil {
		mmCreateCache.defaultExpectation = &ProviderMockCreateCacheExpectation{}
	}

	if mmCreateCache.defaultExpectation.params != nil {
		mmCreateCache.mock.t.Fatalf("ProviderMock.CreateCache mock is already set by Expect")
	}

	if mmCreateCache.defaultExpectation.paramPtrs == nil {
		mmCreateCache.defaultExpectation.paramPtrs = &ProviderMockCreateCacheParamPtrs{}
	}
	mmCreateCache.defaultExpectation.paramPtrs.files = &files
	mmCreateCache.defaultExpectation.expectationOrigins.originFiles = minimock.CallerInfo(1)

	return mmCreateCache
}

// ExpectTtlParam3 sets up expected param ttl for Provider.CreateCache
func (mmCreateCache *mProviderMockCreateCache) ExpectTtlParam3(ttl time.Duration) *mProviderMockCreateCache {
	if mmCreateCache.mock.funcCreateCache != nil {
		mmCreateCache.mock.t.Fatalf("ProviderMock.CreateCache mock is already set by Set")
	}

	if mmCreateCache.defaultExpectation == nil {
		mmCreateCache.defaultExpectation = &ProviderMockCreateCacheExpectation{}
	}

	if mmCreateCache.defaultExpectation.params != nil {
		mmCreateCache.mock.t.Fatalf("ProviderMock.CreateCache mock is already set by Expect")
	}

	if mmCreateCache.defaultExpectation.paramPtrs == nil {
		mmCreateCache.defaultExpectation.paramPtrs = &ProviderMockCreateCacheParamPtrs{}
	}
	mmCreateCache.defaultExpectation.paramPtrs.ttl = &ttl
	mmCreateCache.defaultExpectation.expectationOrigins.originTtl = minimock.CallerInfo(1)

	return mmCreateCache
}

// ExpectSystemInstructionParam4 sets up expected param systemInstruction for Provider.CreateCache
func (mmCreateCache *mProviderMockCreateCache) ExpectSystemInstructionParam4(systemInstruction string) *mProviderMockCreateCache {
	if mmCreateCache.mock.funcCreateCache != nil {
		mmCreateCache.mock.t.Fatalf("ProviderMock.CreateCache mock is already set by Set")
	}

	if mmCreateCache.defaultExpectation == nil {
		mmCreateCache.defaultExpectation = &ProviderMockCreateCacheExpectation{}
	}

	if mmCreateCache.defaultExpectation.params != nil {
		mmCreateCache.mock.t.Fatalf("ProviderMock.CreateCache mock is already set by Expect")
	}

	if mmCreateCache.defaultExpectation.paramPtrs == nil {
		mmCreateCache.defaultExpectation.paramPtrs = &ProviderMockCreateCacheParamPtrs{}
	}
	mmCreateCache.defaultExpectation.paramPtrs.systemInstruction = &systemInstruction
	mmCreateCache.defaultExpectation.expectationOrigins.originSystemInstruction = minimock.CallerInfo(1)

	return mmCreateCache
}

// Inspect accepts an inspector function that has same arguments as the Provider.CreateCache
func (mmCreateCache *mProviderMockCreateCache) Inspect(f func(ctx context.Context, files []mm_ai.FileContent, ttl time.Duration, systemInstruction string)) *mProviderMockCreateCache {
	if mmCreateCache.mock.inspectFuncCreateCache != nil {
		mmCreateCache.mock.t.Fatalf("Inspect function is already set for ProviderMock.CreateCache")
	}

	mmCreateCache.mock.inspectFuncCreateCache = f

	return mmCreateCache
}

// Return sets up results that will be returned by Provider.CreateCache
func (mmCreateCache *mProviderMockCreateCache) Return(cp1 *mm_ai.CacheResult, err error) *ProviderMock {
	if mmCreateCache.mock.funcCreateCache != nil {
		mmCreateCache.mock.t.Fatalf("ProviderMock.CreateCache mock is already set by Set")
	}

	if mmCreateCache.defaultExpectation == nil {
		mmCreateCache.defaultExpectation = &ProviderMockCreateCacheExpectation{mock: mmCreateCache.mock}
	}
	mmCreateCache.defaultExpectation.results = &ProviderMockCreateCacheResults{cp1, err}
	mmCreateCache.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateCache.mock
}

// Set uses given function f to mock the Provider.CreateCache method
func (mmCreateCache *mProviderMockCreateCache) Set(f func(ctx context.Context, files []mm_ai.FileContent, ttl time.Duration, systemInstruction string) (cp1 *mm_ai.CacheResult, err error)) *ProviderMock {
	if mmCreateCache.defaultExpectation != nil {
		mmCreateCache.mock.t.Fatalf("Default expectation is already set for the Provider.CreateCache method")
	}

	if len(mmCreateCache.expectations) > 0 {
		mmCreateCache.mock.t.Fatalf("Some expectations are already set for the Provider.CreateCache method")
	}

	mmCreateCache.mock.funcCreateCache = f
	mmCreateCache.mock.funcCreateCacheOrigin = minimock.CallerInfo(1)
	return mmCreateCache.mock
}

// When sets expectation for the Provider.CreateCache which will trigger the result defined by the following
// Then helper
func (mmCreateCache *mProviderMockCreateCache) When(ctx context.Context, files []mm_ai.FileContent, ttl time.Duration, systemInstruction string) *ProviderMockCreateCacheExpectation {
	if mmCreateCache.mock.funcCreateCache != nil {
		mmCreateCache.mock.t.Fatalf("ProviderMock.CreateCache mock is already set by Set")
	}

	expectation := &ProviderMockCreateCacheExpectation{
		mock:               mmCreateCache.mock,
		params:             &ProviderMockCreateCacheParams{ctx, files, ttl, systemInstruction},
		expectationOrigins: ProviderMockCreateCacheExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateCache.expectations = append(mmCreateCache.expectations, expectation)
	return expectation
}

// Then sets up Provider.CreateCache return parameters for the expectation previously defined by the When method
func (e *ProviderMockCreateCacheExpectation) Then(cp1 *mm_ai.CacheResult, err error) *ProviderMock {
	e.results = &ProviderMockCreateCacheResults{cp1, err}
	return e.mock
}

// Times sets number of times Provider.CreateCache should be invoked
func (mmCreateCache *mProviderMockCreateCache) Times(n uint64) *mProviderMockCreateCache {
	if n == 0 {
		mmCreateCache.mock.t.Fatalf("Times of ProviderMock.CreateCache mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateCache.expectedInvocations, n)
	mmCreateCache.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateCache
}

func (mmCreateCache *mProviderMockCreateCache) invocationsDone() bool {
	if len(mmCreateCache.expectations) == 0 && mmCreateCache.defaultExpectation == nil && mmCreateCache.mock.funcCreateCache == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateCache.mock.afterCreateCacheCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateCache.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateCache implements mm_ai.Provider
func (mmCreateCache *ProviderMock) CreateCache(ctx context.Context, files []mm_ai.FileContent, ttl time.Duration, systemInstruction string) (cp1 *mm_ai.CacheResult, err error) {
	mm_atomic.AddUint64(&mmCreateCache.beforeCreateCacheCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateCache.afterCreateCacheCounter, 1)

	mmCreateCache.t.Helper()

	if mmCreateCache.inspectFuncCreateCache != nil {
		mmCreateCache.inspectFuncCreateCache(ctx, files, ttl, systemInstruction)
	}

	mm_params := ProviderMockCreateCacheParams{ctx, files, ttl, systemInstruction}

	// Record call args
	mmCreateCache.CreateCacheMock.mutex.Lock()
	mmCreateCache.CreateCacheMock.callArgs = append(mmCreateCache.CreateCacheMock.callArgs, &mm_params)
	mmCreateCache.CreateCacheMock.mutex.Unlock()

	for _, e := range mmCreateCache.CreateCacheMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCreateCache.CreateCacheMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateCache.CreateCacheMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateCache.CreateCacheMock.defaultExpectation.params
		mm_want_ptrs := mmCreateCache.CreateCacheMock.defaultExpectation.paramPtrs

		mm_got := ProviderMockCreateCacheParams{ctx, files, ttl, systemInstruction}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateCache.t.Errorf("ProviderMock.CreateCache got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCache.CreateCacheMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.files != nil && !minimock.Equal(*mm_want_ptrs.files, mm_got.files) {
				mmCreateCache.t.Errorf("ProviderMock.CreateCache got unexpected parameter files, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCache.CreateCacheMock.defaultExpectation.expectationOrigins.originFiles, *mm_want_ptrs.files, mm_got.files, minimock.Diff(*mm_want_ptrs.files, mm_got.files))
			}

			if mm_want_ptrs.ttl != nil && !minimock.Equal(*mm_want_ptrs.ttl, mm_got.ttl) {
				mmCreateCache.t.Errorf("ProviderMock.CreateCache got unexpected parameter ttl, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCache.CreateCacheMock.defaultExpectation.expectationOrigins.originTtl, *mm_want_ptrs.ttl, mm_got.ttl, minimock.Diff(*mm_want_ptrs.ttl, mm_got.ttl))
			}

			if mm_want_ptrs.systemInstruction != nil && !minimock.Equal(*mm_want_ptrs.systemInstruction, mm_got.systemInstruction) {
				mmCreateCache.t.Errorf("ProviderMock.CreateCache got unexpected parameter systemInstruction, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCache.CreateCacheMock.defaultExpectation.expectationOrigins.originSystemInstruction, *mm_want_ptrs.systemInstruction, mm_got.systemInstruction, minimock.Diff(*mm_want_ptrs.systemInstruction, mm_got.systemInstruction))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateCache.t.Errorf("ProviderMock.CreateCache got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateCache.CreateCacheMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateCache.CreateCacheMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateCache.t.Fatal("No results are set for the ProviderMock.CreateCache")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCreateCache.funcCreateCache != nil {
		return mmCreateCache.funcCreateCache(ctx, files, ttl, systemInstruction)
	}
	mmCreateCache.t.Fatalf("Unexpected call to ProviderMock.CreateCache. %v %v %v %v", ctx, files, ttl, systemInstruction)
	return
}

// CreateCacheAfterCounter returns a count of finished ProviderMock.CreateCache invocations
func (mmCreateCache *ProviderMock) CreateCacheAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCache.afterCreateCacheCounter)
}

// CreateCacheBeforeCounter returns a count of ProviderMock.CreateCache invocations
func (mmCreateCache *ProviderMock) CreateCacheBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCache.beforeCreateCacheCounter)
}

// Calls returns a list of arguments used in each call to ProviderMock.CreateCache.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateCache *mProviderMockCreateCache) Calls() []*ProviderMockCreateCacheParams {
	mmCreateCache.mutex.RLock()

	argCopy := make([]*ProviderMockCreateCacheParams, len(mmCreateCache.callArgs))
	copy(argCopy, mmCreateCache.callArgs)

	mmCreateCache.mutex.RUnlock()

	return argCopy
}

// MinimockCreateCacheDone returns true if the count of the CreateCache invocations corresponds
// the number of defined expectations
func (m *ProviderMock) MinimockCreateCacheDone() bool {
	if m.CreateCacheMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateCacheMock.invocationsDone()
}

// MinimockCreateCacheInspect logs each unmet expectation
func (m *ProviderMock) MinimockCreateCacheInspect() {
	for _, e := range m.CreateCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProviderMock.CreateCache at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCacheCounter := mm_atomic.LoadUint64(&m.afterCreateCacheCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateCacheMock.defaultExpectation != nil && afterCreateCacheCounter < 1 {
		if m.CreateCacheMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ProviderMock.CreateCache at\n%s", m.CreateCacheMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ProviderMock.CreateCache at\n%s with params: %#v", m.CreateCacheMock.defaultExpectation.expectationOrigins.origin, *m.CreateCacheMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateCache != nil && afterCreateCacheCounter < 1 {
		m.t.Errorf("Expected call to ProviderMock.CreateCache at\n%s", m.funcCreateCacheOrigin)
	}

	if !m.CreateCacheMock.invocationsDone() && afterCreateCacheCounter > 0 {
		m.t.Errorf("Expected %d calls to ProviderMock.CreateCache at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateCacheMock.expectedInvocations), m.CreateCacheMock.expectedInvocationsOrigin, afterCreateCacheCounter)
	}
}

type mProviderMockDeleteCache struct {
	optional           bool
	mock               *ProviderMock
	defaultExpectation *ProviderMockDeleteCacheExpectation
	expectations       []*ProviderMockDeleteCacheExpectation

	callArgs []*ProviderMockDeleteCacheParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProviderMockDeleteCacheExpectation specifies expectation struct of the Provider.DeleteCache
type ProviderMockDeleteCacheExpectation struct {
	mock               *ProviderMock
	params             *ProviderMockDeleteCacheParams
	paramPtrs          *ProviderMockDeleteCacheParamPtrs
	expectationOrigins ProviderMockDeleteCacheExpectationOrigins
	results            *ProviderMockDeleteCacheResults
	returnOrigin       string
	Counter            uint64
}

// ProviderMockDeleteCacheParams contains parameters of the Provider.DeleteCache
type ProviderMockDeleteCacheParams struct {
	ctx       context.Context
	cacheName string
}

// ProviderMockDeleteCacheParamPtrs contains pointers to parameters of the Provider.DeleteCache
type ProviderMockDeleteCacheParamPtrs struct {
	ctx       *context.Context
	cacheName *string
}

// ProviderMockDeleteCacheResults contains results of the Provider.DeleteCache
type ProviderMockDeleteCacheResults struct {
	err error
}

// ProviderMockDeleteCacheOrigins contains origins of expectations of the Provider.DeleteCache
type ProviderMockDeleteCacheExpectationOrigins struct {
	origin          string
	originCtx       string
	originCacheName string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteCache *mProviderMockDeleteCache) Optional() *mProviderMockDeleteCache {
	mmDeleteCache.optional = true
	return mmDeleteCache
}

// Expect sets up expected params for Provider.DeleteCache
func (mmDeleteCache *mProviderMockDeleteCache) Expect(ctx context.Context, cacheName string) *mProviderMockDeleteCache {
	if mmDeleteCache.mock.funcDeleteCache != nil {
		mmDeleteCache.mock.t.Fatalf("ProviderMock.DeleteCache mock is already set by Set")
	}

	if mmDeleteCache.defaultExpectation == nil {
		mmDeleteCache.defaultExpectation = &ProviderMockDeleteCacheExpectation{}
	}

	if mmDeleteCache.defaultExpectation.paramPtrs != nil {
		mmDeleteCache.mock.t.Fatalf("ProviderMock.DeleteCache mock is already set by ExpectParams functions")
	}

	mmDeleteCache.defaultExpectation.params = &ProviderMockDeleteCacheParams{ctx, cacheName}
	mmDeleteCache.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteCache.expectations {
		if minimock.Equal(e.params, mmDeleteCache.defaultExpectation.params) {
			mmDeleteCache.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteCache.defaultExpectation.params)
		}
	}

	return mmDeleteCache
}

// ExpectCtxParam1 sets up expected param ctx for Provider.DeleteCache
func (mmDeleteCache *mProviderMockDeleteCache) ExpectCtxParam1(ctx context.Context) *mProviderMockDeleteCache {
	if mmDeleteCache.mock.funcDeleteCache != nil {
		mmDeleteCache.mock.t.Fatalf("ProviderMock.DeleteCache mock is already set by Set")
	}

	if mmDeleteCache.defaultExpectation == nil {
		mmDeleteCache.defaultExpectation = &ProviderMockDeleteCacheExpectation{}
	}

	if mmDeleteCache.defaultExpectation.params != nil {
		mmDeleteCache.mock.t.Fatalf("ProviderMock.DeleteCache mock is already set by Expect")
	}

	if mmDeleteCache.defaultExpectation.paramPtrs == nil {
		mmDeleteCache.defaultExpectation.paramPtrs = &ProviderMockDeleteCacheParamPtrs{}
	}
	mmDeleteCache.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteCache.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteCache
}

// ExpectCacheNameParam2 sets up expected param cacheName for Provider.DeleteCache
func (mmDeleteCache *mProviderMockDeleteCache) ExpectCacheNameParam2(cacheName string) *mProviderMockDeleteCache {
	if mmDeleteCache.mock.funcDeleteCache != nil {
		mmDeleteCache.mock.t.Fatalf("ProviderMock.DeleteCache mock is already set by Set")
	}

	if mmDeleteCache.defaultExpectation == nil {
		mmDeleteCache.defaultExpectation = &ProviderMockDeleteCacheExpectation{}
	}

	if mmDeleteCache.defaultExpectation.params != nil {
		mmDeleteCache.mock.t.Fatalf("ProviderMock.DeleteCache mock is already set by Expect")
	}

	if mmDeleteCache.defaultExpectation.paramPtrs == nil {
		mmDeleteCache.defaultExpectation.paramPtrs = &ProviderMockDeleteCacheParamPtrs{}
	}
	mmDeleteCache.defaultExpectation.paramPtrs.cacheName = &cacheName
	mmDeleteCache.defaultExpectation.expectationOrigins.originCacheName = minimock.CallerInfo(1)

	return mmDeleteCache
}

// Inspect accepts an inspector function that has same arguments as the Provider.DeleteCache
func (mmDeleteCache *mProviderMockDeleteCache) Inspect(f func(ctx context.Context, cacheName string)) *mProviderMockDeleteCache {
	if mmDeleteCache.mock.inspectFuncDeleteCache != nil {
		mmDeleteCache.mock.t.Fatalf("Inspect function is already set for ProviderMock.DeleteCache")
	}

	mmDeleteCache.mock.inspectFuncDeleteCache = f

	return mmDeleteCache
}

// Return sets up results that will be returned by Provider.DeleteCache
func (mmDeleteCache *mProviderMockDeleteCache) Return(err error) *ProviderMock {
	if mmDeleteCache.mock.funcDeleteCache != nil {
		mmDeleteCache.mock.t.Fatalf("ProviderMock.DeleteCache mock is already set by Set")
	}

	if mmDeleteCache.defaultExpectation == nil {
		mmDeleteCache.defaultExpectation = &ProviderMockDeleteCacheExpectation{mock: mmDeleteCache.mock}
	}
	mmDeleteCache.defaultExpectation.results = &ProviderMockDeleteCacheResults{err}
	mmDeleteCache.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteCache.mock
}

// Set uses given function f to mock the Provider.DeleteCache method
func (mmDeleteCache *mProviderMockDeleteCache) Set(f func(ctx context.Context, cacheName string) (err error)) *ProviderMock {
	if mmDeleteCache.defaultExpectation != nil {
		mmDeleteCache.mock.t.Fatalf("Default expectation is already set for the Provider.DeleteCache method")
	}

	if len(mmDeleteCache.expectations) > 0 {
		mmDeleteCache.mock.t.Fatalf("Some expectations are already set for the Provider.DeleteCache method")
	}

	mmDeleteCache.mock.funcDeleteCache = f
	mmDeleteCache.mock.funcDeleteCacheOrigin = minimock.CallerInfo(1)
	return mmDeleteCache.mock
}

// When sets expectation for the Provider.DeleteCache which will trigger the result defined by the following
// Then helper
func (mmDeleteCache *mProviderMockDeleteCache) When(ctx context.Context, cacheName string) *ProviderMockDeleteCacheExpectation {
	if mmDeleteCache.mock.funcDeleteCache != nil {
		mmDeleteCache.mock.t.Fatalf("ProviderMock.DeleteCache mock is already set by Set")
	}

	expectation := &ProviderMockDeleteCacheExpectation{
		mock:               mmDeleteCache.mock,
		params:             &ProviderMockDeleteCacheParams{ctx, cacheName},
		expectationOrigins: ProviderMockDeleteCacheExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteCache.expectations = append(mmDeleteCache.expectations, expectation)
	return expectation
}

// Then sets up Provider.DeleteCache return parameters for the expectation previously defined by the When method
func (e *ProviderMockDeleteCacheExpectation) Then(err error) *ProviderMock {
	e.results = &ProviderMockDeleteCacheResults{err}
	return e.mock
}

// Times sets number of times Provider.DeleteCache should be invoked
func (mmDeleteCache *mProviderMockDeleteCache) Times(n uint64) *mProviderMockDeleteCache {
	if n == 0 {
		mmDeleteCache.mock.t.Fatalf("Times of ProviderMock.DeleteCache mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteCache.expectedInvocations, n)
	mmDeleteCache.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteCache
}

func (mmDeleteCache *mProviderMockDeleteCache) invocationsDone() bool {
	if len(mmDeleteCache.expectations) == 0 && mmDeleteCache.defaultExpectation == nil && mmDeleteCache.mock.funcDeleteCache == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteCache.mock.afterDeleteCacheCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteCache.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteCache implements mm_ai.Provider
func (mmDeleteCache *ProviderMock) DeleteCache(ctx context.Context, cacheName string) (err error) {
	mm_atomic.AddUint64(&mmDeleteCache.beforeDeleteCacheCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteCache.afterDeleteCacheCounter, 1)

	mmDeleteCache.t.Helper()

	if mmDeleteCache.inspectFuncDeleteCache != nil {
		mmDeleteCache.inspectFuncDeleteCache(ctx, cacheName)
	}

	mm_params := ProviderMockDeleteCacheParams{ctx, cacheName}

	// Record call args
	mmDeleteCache.DeleteCacheMock.mutex.Lock()
	mmDeleteCache.DeleteCacheMock.callArgs = append(mmDeleteCache.DeleteCacheMock.callArgs, &mm_params)
	mmDeleteCache.DeleteCacheMock.mutex.Unlock()

	for _, e := range mmDeleteCache.DeleteCacheMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteCache.DeleteCacheMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteCache.DeleteCacheMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteCache.DeleteCacheMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteCache.DeleteCacheMock.defaultExpectation.paramPtrs

		mm_got := ProviderMockDeleteCacheParams{ctx, cacheName}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteCache.t.Errorf("ProviderMock.DeleteCache got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCache.DeleteCacheMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cacheName != nil && !minimock.Equal(*mm_want_ptrs.cacheName, mm_got.cacheName) {
				mmDeleteCache.t.Errorf("ProviderMock.DeleteCache got unexpected parameter cacheName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCache.DeleteCacheMock.defaultExpectation.expectationOrigins.originCacheName, *mm_want_ptrs.cacheName, mm_got.cacheName, minimock.Diff(*mm_want_ptrs.cacheName, mm_got.cacheName))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteCache.t.Errorf("ProviderMock.DeleteCache got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteCache.DeleteCacheMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteCache.DeleteCacheMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteCache.t.Fatal("No results are set for the ProviderMock.DeleteCache")
		}
		return (*mm_results).err
	}
	if mmDeleteCache.funcDeleteCache != nil {
		return mmDeleteCache.funcDeleteCache(ctx, cacheName)
	}
	mmDeleteCache.t.Fatalf("Unexpected call to ProviderMock.DeleteCache. %v %v", ctx, cacheName)
	return
}

// DeleteCacheAfterCounter returns a count of finished ProviderMock.DeleteCache invocations
func (mmDeleteCache *ProviderMock) DeleteCacheAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCache.afterDeleteCacheCounter)
}

// DeleteCacheBeforeCounter returns a count of ProviderMock.DeleteCache invocations
func (mmDeleteCache *ProviderMock) DeleteCacheBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCache.beforeDeleteCacheCounter)
}

// Calls returns a list of arguments used in each call to ProviderMock.DeleteCache.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteCache *mProviderMockDeleteCache) Calls() []*ProviderMockDeleteCacheParams {
	mmDeleteCache.mutex.RLock()

	argCopy := make([]*ProviderMockDeleteCacheParams, len(mmDeleteCache.callArgs))
	copy(argCopy, mmDeleteCache.callArgs)

	mmDeleteCache.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCacheDone returns true if the count of the DeleteCache invocations corresponds
// the number of defined expectations
func (m *ProviderMock) MinimockDeleteCacheDone() bool {
	if m.DeleteCacheMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteCacheMock.invocationsDone()
}

// MinimockDeleteCacheInspect logs each unmet expectation
func (m *ProviderMock) MinimockDeleteCacheInspect() {
	for _, e := range m.DeleteCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProviderMock.DeleteCache at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCacheCounter := mm_atomic.LoadUint64(&m.afterDeleteCacheCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCacheMock.defaultExpectation != nil && afterDeleteCacheCounter < 1 {
		if m.DeleteCacheMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ProviderMock.DeleteCache at\n%s", m.DeleteCacheMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ProviderMock.DeleteCache at\n%s with params: %#v", m.DeleteCacheMock.defaultExpectation.expectationOrigins.origin, *m.DeleteCacheMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCache != nil && afterDeleteCacheCounter < 1 {
		m.t.Errorf("Expected call to ProviderMock.DeleteCache at\n%s", m.funcDeleteCacheOrigin)
	}

	if !m.DeleteCacheMock.invocationsDone() && afterDeleteCacheCounter > 0 {
		m.t.Errorf("Expected %d calls to ProviderMock.DeleteCache at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteCacheMock.expectedInvocations), m.DeleteCacheMock.expectedInvocationsOrigin, afterDeleteCacheCounter)
	}
}

type mProviderMockEmbedTexts struct {
	optional           bool
	mock               *ProviderMock
	defaultExpectation *ProviderMockEmbedTextsExpectation
	expectations       []*ProviderMockEmbedTextsExpectation

	callArgs []*ProviderMockEmbedTextsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProviderMockEmbedTextsExpectation specifies expectation struct of the Provider.EmbedTexts
type ProviderMockEmbedTextsExpectation struct {
	mock               *ProviderMock
	params             *ProviderMockEmbedTextsParams
	paramPtrs          *ProviderMockEmbedTextsParamPtrs
	expectationOrigins ProviderMockEmbedTextsExpectationOrigins
	results            *ProviderMockEmbedTextsResults
	returnOrigin       string
	Counter            uint64
}

// ProviderMockEmbedTextsParams contains parameters of the Provider.EmbedTexts
type ProviderMockEmbedTextsParams struct {
	ctx      context.Context
	texts    []string
	taskType string
}

// ProviderMockEmbedTextsParamPtrs contains pointers to parameters of the Provider.EmbedTexts
type ProviderMockEmbedTextsParamPtrs struct {
	ctx      *context.Context
	texts    *[]string
	taskType *string
}

// ProviderMockEmbedTextsResults contains results of the Provider.EmbedTexts
type ProviderMockEmbedTextsResults struct {
	ep1 *mm_ai.EmbedResult
	err error
}

// ProviderMockEmbedTextsOrigins contains origins of expectations of the Provider.EmbedTexts
type ProviderMockEmbedTextsExpectationOrigins struct {
	origin         string
	originCtx      string
	originTexts    string
	originTaskType string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmEmbedTexts *mProviderMockEmbedTexts) Optional() *mProviderMockEmbedTexts {
	mmEmbedTexts.optional = true
	return mmEmbedTexts
}

// Expect sets up expected params for Provider.EmbedTexts
func (mmEmbedTexts *mProviderMockEmbedTexts) Expect(ctx context.Context, texts []string, taskType string) *mProviderMockEmbedTexts {
	if mmEmbedTexts.mock.funcEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("ProviderMock.EmbedTexts mock is already set by Set")
	}

	if mmEmbedTexts.defaultExpectation == nil {
		mmEmbedTexts.defaultExpectation = &ProviderMockEmbedTextsExpectation{}
	}

	if mmEmbedTexts.defaultExpectation.paramPtrs != nil {
		mmEmbedTexts.mock.t.Fatalf("ProviderMock.EmbedTexts mock is already set by ExpectParams functions")
	}

	mmEmbedTexts.defaultExpectation.params = &ProviderMockEmbedTextsParams{ctx, texts, taskType}
	mmEmbedTexts.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmEmbedTexts.expectations {
		if minimock.Equal(e.params, mmEmbedTexts.defaultExpectation.params) {
			mmEmbedTexts.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEmbedTexts.defaultExpectation.params)
		}
	}

	return mmEmbedTexts
}

// ExpectCtxParam1 sets up expected param ctx for Provider.EmbedTexts
func (mmEmbedTexts *mProviderMockEmbedTexts) ExpectCtxParam1(ctx context.Context) *mProviderMockEmbedTexts {
	if mmEmbedTexts.mock.funcEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("ProviderMock.EmbedTexts mock is already set by Set")
	}

	if mmEmbedTexts.defaultExpectation == nil {
		mmEmbedTexts.defaultExpectation = &ProviderMockEmbedTextsExpectation{}
	}

	if mmEmbedTexts.defaultExpectation.params != nil {
		mmEmbedTexts.mock.t.Fatalf("ProviderMock.EmbedTexts mock is already set by Expect")
	}

	if mmEmbedTexts.defaultExpectation.paramPtrs == nil {
		mmEmbedTexts.defaultExpectation.paramPtrs = &ProviderMockEmbedTextsParamPtrs{}
	}
	mmEmbedTexts.defaultExpectation.paramPtrs.ctx = &ctx
	mmEmbedTexts.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmEmbedTexts
}

// ExpectTextsParam2 sets up expected param texts for Provider.EmbedTexts
func (mmEmbedTexts *mProviderMockEmbedTexts) ExpectTextsParam2(texts []string) *mProviderMockEmbedTexts {
	if mmEmbedTexts.mock.funcEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("ProviderMock.EmbedTexts mock is already set by Set")
	}

	if mmEmbedTexts.defaultExpectation == nil {
		mmEmbedTexts.defaultExpectation = &ProviderMockEmbedTextsExpectation{}
	}

	if mmEmbedTexts.defaultExpectation.params != nil {
		mmEmbedTexts.mock.t.Fatalf("ProviderMock.EmbedTexts mock is already set by Expect")
	}

	if mmEmbedTexts.defaultExpectation.paramPtrs == nil {
		mmEmbedTexts.defaultExpectation.paramPtrs = &ProviderMockEmbedTextsParamPtrs{}
	}
	mmEmbedTexts.defaultExpectation.paramPtrs.texts = &texts
	mmEmbedTexts.defaultExpectation.expectationOrigins.originTexts = minimock.CallerInfo(1)

	return mmEmbedTexts
}

// ExpectTaskTypeParam3 sets up expected param taskType for Provider.EmbedTexts
func (mmEmbedTexts *mProviderMockEmbedTexts) ExpectTaskTypeParam3(taskType string) *mProviderMockEmbedTexts {
	if mmEmbedTexts.mock.funcEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("ProviderMock.EmbedTexts mock is already set by Set")
	}

	if mmEmbedTexts.defaultExpectation == nil {
		mmEmbedTexts.defaultExpectation = &ProviderMockEmbedTextsExpectation{}
	}

	if mmEmbedTexts.defaultExpectation.params != nil {
		mmEmbedTexts.mock.t.Fatalf("ProviderMock.EmbedTexts mock is already set by Expect")
	}

	if mmEmbedTexts.defaultExpectation.paramPtrs == nil {
		mmEmbedTexts.defaultExpectation.paramPtrs = &ProviderMockEmbedTextsParamPtrs{}
	}
	mmEmbedTexts.defaultExpectation.paramPtrs.taskType = &taskType
	mmEmbedTexts.defaultExpectation.expectationOrigins.originTaskType = minimock.CallerInfo(1)

	return mmEmbedTexts
}

// Inspect accepts an inspector function that has same arguments as the Provider.EmbedTexts
func (mmEmbedTexts *mProviderMockEmbedTexts) Inspect(f func(ctx context.Context, texts []string, taskType string)) *mProviderMockEmbedTexts {
	if mmEmbedTexts.mock.inspectFuncEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("Inspect function is already set for ProviderMock.EmbedTexts")
	}

	mmEmbedTexts.mock.inspectFuncEmbedTexts = f

	return mmEmbedTexts
}

// Return sets up results that will be returned by Provider.EmbedTexts
func (mmEmbedTexts *mProviderMockEmbedTexts) Return(ep1 *mm_ai.EmbedResult, err error) *ProviderMock {
	if mmEmbedTexts.mock.funcEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("ProviderMock.EmbedTexts mock is already set by Set")
	}

	if mmEmbedTexts.defaultExpectation == nil {
		mmEmbedTexts.defaultExpectation = &ProviderMockEmbedTextsExpectation{mock: mmEmbedTexts.mock}
	}
	mmEmbedTexts.defaultExpectation.results = &ProviderMockEmbedTextsResults{ep1, err}
	mmEmbedTexts.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmEmbedTexts.mock
}

// Set uses given function f to mock the Provider.EmbedTexts method
func (mmEmbedTexts *mProviderMockEmbedTexts) Set(f func(ctx context.Context, texts []string, taskType string) (ep1 *mm_ai.EmbedResult, err error)) *ProviderMock {
	if mmEmbedTexts.defaultExpectation != nil {
		mmEmbedTexts.mock.t.Fatalf("Default expectation is already set for the Provider.EmbedTexts method")
	}

	if len(mmEmbedTexts.expectations) > 0 {
		mmEmbedTexts.mock.t.Fatalf("Some expectations are already set for the Provider.EmbedTexts method")
	}

	mmEmbedTexts.mock.funcEmbedTexts = f
	mmEmbedTexts.mock.funcEmbedTextsOrigin = minimock.CallerInfo(1)
	return mmEmbedTexts.mock
}

// When sets expectation for the Provider.EmbedTexts which will trigger the result defined by the following
// Then helper
func (mmEmbedTexts *mProviderMockEmbedTexts) When(ctx context.Context, texts []string, taskType string) *ProviderMockEmbedTextsExpectation {
	if mmEmbedTexts.mock.funcEmbedTexts != nil {
		mmEmbedTexts.mock.t.Fatalf("ProviderMock.EmbedTexts mock is already set by Set")
	}

	expectation := &ProviderMockEmbedTextsExpectation{
		mock:               mmEmbedTexts.mock,
		params:             &ProviderMockEmbedTextsParams{ctx, texts, taskType},
		expectationOrigins: ProviderMockEmbedTextsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmEmbedTexts.expectations = append(mmEmbedTexts.expectations, expectation)
	return expectation
}

// Then sets up Provider.EmbedTexts return parameters for the expectation previously defined by the When method
func (e *ProviderMockEmbedTextsExpectation) Then(ep1 *mm_ai.EmbedResult, err error) *ProviderMock {
	e.results = &ProviderMockEmbedTextsResults{ep1, err}
	return e.mock
}

// Times sets number of times Provider.EmbedTexts should be invoked
func (mmEmbedTexts *mProviderMockEmbedTexts) Times(n uint64) *mProviderMockEmbedTexts {
	if n == 0 {
		mmEmbedTexts.mock.t.Fatalf("Times of ProviderMock.EmbedTexts mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmEmbedTexts.expectedInvocations, n)
	mmEmbedTexts.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmEmbedTexts
}

func (mmEmbedTexts *mProviderMockEmbedTexts) invocationsDone() bool {
	if len(mmEmbedTexts.expectations) == 0 && mmEmbedTexts.defaultExpectation == nil && mmEmbedTexts.mock.funcEmbedTexts == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmEmbedTexts.mock.afterEmbedTextsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmEmbedTexts.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// EmbedTexts implements mm_ai.Provider
func (mmEmbedTexts *ProviderMock) EmbedTexts(ctx context.Context, texts []string, taskType string) (ep1 *mm_ai.EmbedResult, err error) {
	mm_atomic.AddUint64(&mmEmbedTexts.beforeEmbedTextsCounter, 1)
	defer mm_atomic.AddUint64(&mmEmbedTexts.afterEmbedTextsCounter, 1)

	mmEmbedTexts.t.Helper()

	if mmEmbedTexts.inspectFuncEmbedTexts != nil {
		mmEmbedTexts.inspectFuncEmbedTexts(ctx, texts, taskType)
	}

	mm_params := ProviderMockEmbedTextsParams{ctx, texts, taskType}

	// Record call args
	mmEmbedTexts.EmbedTextsMock.mutex.Lock()
	mmEmbedTexts.EmbedTextsMock.callArgs = append(mmEmbedTexts.EmbedTextsMock.callArgs, &mm_params)
	mmEmbedTexts.EmbedTextsMock.mutex.Unlock()

	for _, e := range mmEmbedTexts.EmbedTextsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ep1, e.results.err
		}
	}

	if mmEmbedTexts.EmbedTextsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEmbedTexts.EmbedTextsMock.defaultExpectation.Counter, 1)
		mm_want := mmEmbedTexts.EmbedTextsMock.defaultExpectation.params
		mm_want_ptrs := mmEmbedTexts.EmbedTextsMock.defaultExpectation.paramPtrs

		mm_got := ProviderMockEmbedTextsParams{ctx, texts, taskType}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmEmbedTexts.t.Errorf("ProviderMock.EmbedTexts got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEmbedTexts.EmbedTextsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.texts != nil && !minimock.Equal(*mm_want_ptrs.texts, mm_got.texts) {
				mmEmbedTexts.t.Errorf("ProviderMock.EmbedTexts got unexpected parameter texts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEmbedTexts.EmbedTextsMock.defaultExpectation.expectationOrigins.originTexts, *mm_want_ptrs.texts, mm_got.texts, minimock.Diff(*mm_want_ptrs.texts, mm_got.texts))
			}

			if mm_want_ptrs.taskType != nil && !minimock.Equal(*mm_want_ptrs.taskType, mm_got.taskType) {
				mmEmbedTexts.t.Errorf("ProviderMock.EmbedTexts got unexpected parameter taskType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEmbedTexts.EmbedTextsMock.defaultExpectation.expectationOrigins.originTaskType, *mm_want_ptrs.taskType, mm_got.taskType, minimock.Diff(*mm_want_ptrs.taskType, mm_got.taskType))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEmbedTexts.t.Errorf("ProviderMock.EmbedTexts got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmEmbedTexts.EmbedTextsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEmbedTexts.EmbedTextsMock.defaultExpectation.results
		if mm_results == nil {
			mmEmbedTexts.t.Fatal("No results are set for the ProviderMock.EmbedTexts")
		}
		return (*mm_results).ep1, (*mm_results).err
	}
	if mmEmbedTexts.funcEmbedTexts != nil {
		return mmEmbedTexts.funcEmbedTexts(ctx, texts, taskType)
	}
	mmEmbedTexts.t.Fatalf("Unexpected call to ProviderMock.EmbedTexts. %v %v %v", ctx, texts, taskType)
	return
}

// EmbedTextsAfterCounter returns a count of finished ProviderMock.EmbedTexts invocations
func (mmEmbedTexts *ProviderMock) EmbedTextsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEmbedTexts.afterEmbedTextsCounter)
}

// EmbedTextsBeforeCounter returns a count of ProviderMock.EmbedTexts invocations
func (mmEmbedTexts *ProviderMock) EmbedTextsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEmbedTexts.beforeEmbedTextsCounter)
}

// Calls returns a list of arguments used in each call to ProviderMock.EmbedTexts.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEmbedTexts *mProviderMockEmbedTexts) Calls() []*ProviderMockEmbedTextsParams {
	mmEmbedTexts.mutex.RLock()

	argCopy := make([]*ProviderMockEmbedTextsParams, len(mmEmbedTexts.callArgs))
	copy(argCopy, mmEmbedTexts.callArgs)

	mmEmbedTexts.mutex.RUnlock()

	return argCopy
}

// MinimockEmbedTextsDone returns true if the count of the EmbedTexts invocations corresponds
// the number of defined expectations
func (m *ProviderMock) MinimockEmbedTextsDone() bool {
	if m.EmbedTextsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.EmbedTextsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.EmbedTextsMock.invocationsDone()
}

// MinimockEmbedTextsInspect logs each unmet expectation
func (m *ProviderMock) MinimockEmbedTextsInspect() {
	for _, e := range m.EmbedTextsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProviderMock.EmbedTexts at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterEmbedTextsCounter := mm_atomic.LoadUint64(&m.afterEmbedTextsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.EmbedTextsMock.defaultExpectation != nil && afterEmbedTextsCounter < 1 {
		if m.EmbedTextsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ProviderMock.EmbedTexts at\n%s", m.EmbedTextsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ProviderMock.EmbedTexts at\n%s with params: %#v", m.EmbedTextsMock.defaultExpectation.expectationOrigins.origin, *m.EmbedTextsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEmbedTexts != nil && afterEmbedTextsCounter < 1 {
		m.t.Errorf("Expected call to ProviderMock.EmbedTexts at\n%s", m.funcEmbedTextsOrigin)
	}

	if !m.EmbedTextsMock.invocationsDone() && afterEmbedTextsCounter > 0 {
		m.t.Errorf("Expected %d calls to ProviderMock.EmbedTexts at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.EmbedTextsMock.expectedInvocations), m.EmbedTextsMock.expectedInvocationsOrigin, afterEmbedTextsCounter)
	}
}

type mProviderMockGetCache struct {
	optional           bool
	mock               *ProviderMock
	defaultExpectation *ProviderMockGetCacheExpectation
	expectations       []*ProviderMockGetCacheExpectation

	callArgs []*ProviderMockGetCacheParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProviderMockGetCacheExpectation specifies expectation struct of the Provider.GetCache
type ProviderMockGetCacheExpectation struct {
	mock               *ProviderMock
	params             *ProviderMockGetCacheParams
	paramPtrs          *ProviderMockGetCacheParamPtrs
	expectationOrigins ProviderMockGetCacheExpectationOrigins
	results            *ProviderMockGetCacheResults
	returnOrigin       string
	Counter            uint64
}

// ProviderMockGetCacheParams contains parameters of the Provider.GetCache
type ProviderMockGetCacheParams struct {
	ctx       context.Context
	cacheName string
}

// ProviderMockGetCacheParamPtrs contains pointers to parameters of the Provider.GetCache
type ProviderMockGetCacheParamPtrs struct {
	ctx       *context.Context
	cacheName *string
}

// ProviderMockGetCacheResults contains results of the Provider.GetCache
type ProviderMockGetCacheResults struct {
	cp1 *mm_ai.CacheResult
	err error
}

// ProviderMockGetCacheOrigins contains origins of expectations of the Provider.GetCache
type ProviderMockGetCacheExpectationOrigins struct {
	origin          string
	originCtx       string
	originCacheName string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCache *mProviderMockGetCache) Optional() *mProviderMockGetCache {
	mmGetCache.optional = true
	return mmGetCache
}

// Expect sets up expected params for Provider.GetCache
func (mmGetCache *mProviderMockGetCache) Expect(ctx context.Context, cacheName string) *mProviderMockGetCache {
	if mmGetCache.mock.funcGetCache != nil {
		mmGetCache.mock.t.Fatalf("ProviderMock.GetCache mock is already set by Set")
	}

	if mmGetCache.defaultExpectation == nil {
		mmGetCache.defaultExpectation = &ProviderMockGetCacheExpectation{}
	}

	if mmGetCache.defaultExpectation.paramPtrs != nil {
		mmGetCache.mock.t.Fatalf("ProviderMock.GetCache mock is already set by ExpectParams functions")
	}

	mmGetCache.defaultExpectation.params = &ProviderMockGetCacheParams{ctx, cacheName}
	mmGetCache.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCache.expectations {
		if minimock.Equal(e.params, mmGetCache.defaultExpectation.params) {
			mmGetCache.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCache.defaultExpectation.params)
		}
	}

	return mmGetCache
}

// ExpectCtxParam1 sets up expected param ctx for Provider.GetCache
func (mmGetCache *mProviderMockGetCache) ExpectCtxParam1(ctx context.Context) *mProviderMockGetCache {
	if mmGetCache.mock.funcGetCache != nil {
		mmGetCache.mock.t.Fatalf("ProviderMock.GetCache mock is already set by Set")
	}

	if mmGetCache.defaultExpectation == nil {
		mmGetCache.defaultExpectation = &ProviderMockGetCacheExpectation{}
	}

	if mmGetCache.defaultExpectation.params != nil {
		mmGetCache.mock.t.Fatalf("ProviderMock.GetCache mock is already set by Expect")
	}

	if mmGetCache.defaultExpectation.paramPtrs == nil {
		mmGetCache.defaultExpectation.paramPtrs = &ProviderMockGetCacheParamPtrs{}
	}
	mmGetCache.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetCache.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetCache
}

// ExpectCacheNameParam2 sets up expected param cacheName for Provider.GetCache
func (mmGetCache *mProviderMockGetCache) ExpectCacheNameParam2(cacheName string) *mProviderMockGetCache {
	if mmGetCache.mock.funcGetCache != nil {
		mmGetCache.mock.t.Fatalf("ProviderMock.GetCache mock is already set by Set")
	}

	if mmGetCache.defaultExpectation == nil {
		mmGetCache.defaultExpectation = &ProviderMockGetCacheExpectation{}
	}

	if mmGetCache.defaultExpectation.params != nil {
		mmGetCache.mock.t.Fatalf("ProviderMock.GetCache mock is already set by Expect")
	}

	if mmGetCache.defaultExpectation.paramPtrs == nil {
		mmGetCache.defaultExpectation.paramPtrs = &ProviderMockGetCacheParamPtrs{}
	}
	mmGetCache.defaultExpectation.paramPtrs.cacheName = &cacheName
	mmGetCache.defaultExpectation.expectationOrigins.originCacheName = minimock.CallerInfo(1)

	return mmGetCache
}

// Inspect accepts an inspector function that has same arguments as the Provider.GetCache
func (mmGetCache *mProviderMockGetCache) Inspect(f func(ctx context.Context, cacheName string)) *mProviderMockGetCache {
	if mmGetCache.mock.inspectFuncGetCache != nil {
		mmGetCache.mock.t.Fatalf("Inspect function is already set for ProviderMock.GetCache")
	}

	mmGetCache.mock.inspectFuncGetCache = f

	return mmGetCache
}

// Return sets up results that will be returned by Provider.GetCache
func (mmGetCache *mProviderMockGetCache) Return(cp1 *mm_ai.CacheResult, err error) *ProviderMock {
	if mmGetCache.mock.funcGetCache != nil {
		mmGetCache.mock.t.Fatalf("ProviderMock.GetCache mock is already set by Set")
	}

	if mmGetCache.defaultExpectation == nil {
		mmGetCache.defaultExpectation = &ProviderMockGetCacheExpectation{mock: mmGetCache.mock}
	}
	mmGetCache.defaultExpectation.results = &ProviderMockGetCacheResults{cp1, err}
	mmGetCache.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCache.mock
}

// Set uses given function f to mock the Provider.GetCache method
func (mmGetCache *mProviderMockGetCache) Set(f func(ctx context.Context, cacheName string) (cp1 *mm_ai.CacheResult, err error)) *ProviderMock {
	if mmGetCache.defaultExpectation != nil {
		mmGetCache.mock.t.Fatalf("Default expectation is already set for the Provider.GetCache method")
	}

	if len(mmGetCache.expectations) > 0 {
		mmGetCache.mock.t.Fatalf("Some expectations are already set for the Provider.GetCache method")
	}

	mmGetCache.mock.funcGetCache = f
	mmGetCache.mock.funcGetCacheOrigin = minimock.CallerInfo(1)
	return mmGetCache.mock
}

// When sets expectation for the Provider.GetCache which will trigger the result defined by the following
// Then helper
func (mmGetCache *mProviderMockGetCache) When(ctx context.Context, cacheName string) *ProviderMockGetCacheExpectation {
	if mmGetCache.mock.funcGetCache != nil {
		mmGetCache.mock.t.Fatalf("ProviderMock.GetCache mock is already set by Set")
	}

	expectation := &ProviderMockGetCacheExpectation{
		mock:               mmGetCache.mock,
		params:             &ProviderMockGetCacheParams{ctx, cacheName},
		expectationOrigins: ProviderMockGetCacheExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCache.expectations = append(mmGetCache.expectations, expectation)
	return expectation
}

// Then sets up Provider.GetCache return parameters for the expectation previously defined by the When method
func (e *ProviderMockGetCacheExpectation) Then(cp1 *mm_ai.CacheResult, err error) *ProviderMock {
	e.results = &ProviderMockGetCacheResults{cp1, err}
	return e.mock
}

// Times sets number of times Provider.GetCache should be invoked
func (mmGetCache *mProviderMockGetCache) Times(n uint64) *mProviderMockGetCache {
	if n == 0 {
		mmGetCache.mock.t.Fatalf("Times of ProviderMock.GetCache mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCache.expectedInvocations, n)
	mmGetCache.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCache
}

func (mmGetCache *mProviderMockGetCache) invocationsDone() bool {
	if len(mmGetCache.expectations) == 0 && mmGetCache.defaultExpectation == nil && mmGetCache.mock.funcGetCache == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCache.mock.afterGetCacheCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCache.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCache implements mm_ai.Provider
func (mmGetCache *ProviderMock) GetCache(ctx context.Context, cacheName string) (cp1 *mm_ai.CacheResult, err error) {
	mm_atomic.AddUint64(&mmGetCache.beforeGetCacheCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCache.afterGetCacheCounter, 1)

	mmGetCache.t.Helper()

	if mmGetCache.inspectFuncGetCache != nil {
		mmGetCache.inspectFuncGetCache(ctx, cacheName)
	}

	mm_params := ProviderMockGetCacheParams{ctx, cacheName}

	// Record call args
	mmGetCache.GetCacheMock.mutex.Lock()
	mmGetCache.GetCacheMock.callArgs = append(mmGetCache.GetCacheMock.callArgs, &mm_params)
	mmGetCache.GetCacheMock.mutex.Unlock()

	for _, e := range mmGetCache.GetCacheMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetCache.GetCacheMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCache.GetCacheMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCache.GetCacheMock.defaultExpectation.params
		mm_want_ptrs := mmGetCache.GetCacheMock.defaultExpectation.paramPtrs

		mm_got := ProviderMockGetCacheParams{ctx, cacheName}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCache.t.Errorf("ProviderMock.GetCache got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCache.GetCacheMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cacheName != nil && !minimock.Equal(*mm_want_ptrs.cacheName, mm_got.cacheName) {
				mmGetCache.t.Errorf("ProviderMock.GetCache got unexpected parameter cacheName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCache.GetCacheMock.defaultExpectation.expectationOrigins.originCacheName, *mm_want_ptrs.cacheName, mm_got.cacheName, minimock.Diff(*mm_want_ptrs.cacheName, mm_got.cacheName))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCache.t.Errorf("ProviderMock.GetCache got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCache.GetCacheMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCache.GetCacheMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCache.t.Fatal("No results are set for the ProviderMock.GetCache")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetCache.funcGetCache != nil {
		return mmGetCache.funcGetCache(ctx, cacheName)
	}
	mmGetCache.t.Fatalf("Unexpected call to ProviderMock.GetCache. %v %v", ctx, cacheName)
	return
}

// GetCacheAfterCounter returns a count of finished ProviderMock.GetCache invocations
func (mmGetCache *ProviderMock) GetCacheAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCache.afterGetCacheCounter)
}

// GetCacheBeforeCounter returns a count of ProviderMock.GetCache invocations
func (mmGetCache *ProviderMock) GetCacheBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCache.beforeGetCacheCounter)
}

// Calls returns a list of arguments used in each call to ProviderMock.GetCache.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCache *mProviderMockGetCache) Calls() []*ProviderMockGetCacheParams {
	mmGetCache.mutex.RLock()

	argCopy := make([]*ProviderMockGetCacheParams, len(mmGetCache.callArgs))
	copy(argCopy, mmGetCache.callArgs)

	mmGetCache.mutex.RUnlock()

	return argCopy
}

// MinimockGetCacheDone returns true if the count of the GetCache invocations corresponds
// the number of defined expectations
func (m *ProviderMock) MinimockGetCacheDone() bool {
	if m.GetCacheMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCacheMock.invocationsDone()
}

// MinimockGetCacheInspect logs each unmet expectation
func (m *ProviderMock) MinimockGetCacheInspect() {
	for _, e := range m.GetCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProviderMock.GetCache at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCacheCounter := mm_atomic.LoadUint64(&m.afterGetCacheCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCacheMock.defaultExpectation != nil && afterGetCacheCounter < 1 {
		if m.GetCacheMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ProviderMock.GetCache at\n%s", m.GetCacheMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ProviderMock.GetCache at\n%s with params: %#v", m.GetCacheMock.defaultExpectation.expectationOrigins.origin, *m.GetCacheMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCache != nil && afterGetCacheCounter < 1 {
		m.t.Errorf("Expected call to ProviderMock.GetCache at\n%s", m.funcGetCacheOrigin)
	}

	if !m.GetCacheMock.invocationsDone() && afterGetCacheCounter > 0 {
		m.t.Errorf("Expected %d calls to ProviderMock.GetCache at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCacheMock.expectedInvocations), m.GetCacheMock.expectedInvocationsOrigin, afterGetCacheCounter)
	}
}

type mProviderMockGetEmbeddingDimensionality struct {
	optional           bool
	mock               *ProviderMock
	defaultExpectation *ProviderMockGetEmbeddingDimensionalityExpectation
	expectations       []*ProviderMockGetEmbeddingDimensionalityExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProviderMockGetEmbeddingDimensionalityExpectation specifies expectation struct of the Provider.GetEmbeddingDimensionality
type ProviderMockGetEmbeddingDimensionalityExpectation struct {
	mock *ProviderMock

	results      *ProviderMockGetEmbeddingDimensionalityResults
	returnOrigin string
	Counter      uint64
}

// ProviderMockGetEmbeddingDimensionalityResults contains results of the Provider.GetEmbeddingDimensionality
type ProviderMockGetEmbeddingDimensionalityResults struct {
	i1 int32
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetEmbeddingDimensionality *mProviderMockGetEmbeddingDimensionality) Optional() *mProviderMockGetEmbeddingDimensionality {
	mmGetEmbeddingDimensionality.optional = true
	return mmGetEmbeddingDimensionality
}

// Expect sets up expected params for Provider.GetEmbeddingDimensionality
func (mmGetEmbeddingDimensionality *mProviderMockGetEmbeddingDimensionality) Expect() *mProviderMockGetEmbeddingDimensionality {
	if mmGetEmbeddingDimensionality.mock.funcGetEmbeddingDimensionality != nil {
		mmGetEmbeddingDimensionality.mock.t.Fatalf("ProviderMock.GetEmbeddingDimensionality mock is already set by Set")
	}

	if mmGetEmbeddingDimensionality.defaultExpectation == nil {
		mmGetEmbeddingDimensionality.defaultExpectation = &ProviderMockGetEmbeddingDimensionalityExpectation{}
	}

	return mmGetEmbeddingDimensionality
}

// Inspect accepts an inspector function that has same arguments as the Provider.GetEmbeddingDimensionality
func (mmGetEmbeddingDimensionality *mProviderMockGetEmbeddingDimensionality) Inspect(f func()) *mProviderMockGetEmbeddingDimensionality {
	if mmGetEmbeddingDimensionality.mock.inspectFuncGetEmbeddingDimensionality != nil {
		mmGetEmbeddingDimensionality.mock.t.Fatalf("Inspect function is already set for ProviderMock.GetEmbeddingDimensionality")
	}

	mmGetEmbeddingDimensionality.mock.inspectFuncGetEmbeddingDimensionality = f

	return mmGetEmbeddingDimensionality
}

// Return sets up results that will be returned by Provider.GetEmbeddingDimensionality
func (mmGetEmbeddingDimensionality *mProviderMockGetEmbeddingDimensionality) Return(i1 int32) *ProviderMock {
	if mmGetEmbeddingDimensionality.mock.funcGetEmbeddingDimensionality != nil {
		mmGetEmbeddingDimensionality.mock.t.Fatalf("ProviderMock.GetEmbeddingDimensionality mock is already set by Set")
	}

	if mmGetEmbeddingDimensionality.defaultExpectation == nil {
		mmGetEmbeddingDimensionality.defaultExpectation = &ProviderMockGetEmbeddingDimensionalityExpectation{mock: mmGetEmbeddingDimensionality.mock}
	}
	mmGetEmbeddingDimensionality.defaultExpectation.results = &ProviderMockGetEmbeddingDimensionalityResults{i1}
	mmGetEmbeddingDimensionality.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetEmbeddingDimensionality.mock
}

// Set uses given function f to mock the Provider.GetEmbeddingDimensionality method
func (mmGetEmbeddingDimensionality *mProviderMockGetEmbeddingDimensionality) Set(f func() (i1 int32)) *ProviderMock {
	if mmGetEmbeddingDimensionality.defaultExpectation != nil {
		mmGetEmbeddingDimensionality.mock.t.Fatalf("Default expectation is already set for the Provider.GetEmbeddingDimensionality method")
	}

	if len(mmGetEmbeddingDimensionality.expectations) > 0 {
		mmGetEmbeddingDimensionality.mock.t.Fatalf("Some expectations are already set for the Provider.GetEmbeddingDimensionality method")
	}

	mmGetEmbeddingDimensionality.mock.funcGetEmbeddingDimensionality = f
	mmGetEmbeddingDimensionality.mock.funcGetEmbeddingDimensionalityOrigin = minimock.CallerInfo(1)
	return mmGetEmbeddingDimensionality.mock
}

// Times sets number of times Provider.GetEmbeddingDimensionality should be invoked
func (mmGetEmbeddingDimensionality *mProviderMockGetEmbeddingDimensionality) Times(n uint64) *mProviderMockGetEmbeddingDimensionality {
	if n == 0 {
		mmGetEmbeddingDimensionality.mock.t.Fatalf("Times of ProviderMock.GetEmbeddingDimensionality mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetEmbeddingDimensionality.expectedInvocations, n)
	mmGetEmbeddingDimensionality.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetEmbeddingDimensionality
}

func (mmGetEmbeddingDimensionality *mProviderMockGetEmbeddingDimensionality) invocationsDone() bool {
	if len(mmGetEmbeddingDimensionality.expectations) == 0 && mmGetEmbeddingDimensionality.defaultExpectation == nil && mmGetEmbeddingDimensionality.mock.funcGetEmbeddingDimensionality == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetEmbeddingDimensionality.mock.afterGetEmbeddingDimensionalityCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetEmbeddingDimensionality.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetEmbeddingDimensionality implements mm_ai.Provider
func (mmGetEmbeddingDimensionality *ProviderMock) GetEmbeddingDimensionality() (i1 int32) {
	mm_atomic.AddUint64(&mmGetEmbeddingDimensionality.beforeGetEmbeddingDimensionalityCounter, 1)
	defer mm_atomic.AddUint64(&mmGetEmbeddingDimensionality.afterGetEmbeddingDimensionalityCounter, 1)

	mmGetEmbeddingDimensionality.t.Helper()

	if mmGetEmbeddingDimensionality.inspectFuncGetEmbeddingDimensionality != nil {
		mmGetEmbeddingDimensionality.inspectFuncGetEmbeddingDimensionality()
	}

	if mmGetEmbeddingDimensionality.GetEmbeddingDimensionalityMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetEmbeddingDimensionality.GetEmbeddingDimensionalityMock.defaultExpectation.Counter, 1)

		mm_results := mmGetEmbeddingDimensionality.GetEmbeddingDimensionalityMock.defaultExpectation.results
		if mm_results == nil {
			mmGetEmbeddingDimensionality.t.Fatal("No results are set for the ProviderMock.GetEmbeddingDimensionality")
		}
		return (*mm_results).i1
	}
	if mmGetEmbeddingDimensionality.funcGetEmbeddingDimensionality != nil {
		return mmGetEmbeddingDimensionality.funcGetEmbeddingDimensionality()
	}
	mmGetEmbeddingDimensionality.t.Fatalf("Unexpected call to ProviderMock.GetEmbeddingDimensionality.")
	return
}

// GetEmbeddingDimensionalityAfterCounter returns a count of finished ProviderMock.GetEmbeddingDimensionality invocations
func (mmGetEmbeddingDimensionality *ProviderMock) GetEmbeddingDimensionalityAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEmbeddingDimensionality.afterGetEmbeddingDimensionalityCounter)
}

// GetEmbeddingDimensionalityBeforeCounter returns a count of ProviderMock.GetEmbeddingDimensionality invocations
func (mmGetEmbeddingDimensionality *ProviderMock) GetEmbeddingDimensionalityBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEmbeddingDimensionality.beforeGetEmbeddingDimensionalityCounter)
}

// MinimockGetEmbeddingDimensionalityDone returns true if the count of the GetEmbeddingDimensionality invocations corresponds
// the number of defined expectations
func (m *ProviderMock) MinimockGetEmbeddingDimensionalityDone() bool {
	if m.GetEmbeddingDimensionalityMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetEmbeddingDimensionalityMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetEmbeddingDimensionalityMock.invocationsDone()
}

// MinimockGetEmbeddingDimensionalityInspect logs each unmet expectation
func (m *ProviderMock) MinimockGetEmbeddingDimensionalityInspect() {
	for _, e := range m.GetEmbeddingDimensionalityMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ProviderMock.GetEmbeddingDimensionality")
		}
	}

	afterGetEmbeddingDimensionalityCounter := mm_atomic.LoadUint64(&m.afterGetEmbeddingDimensionalityCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetEmbeddingDimensionalityMock.defaultExpectation != nil && afterGetEmbeddingDimensionalityCounter < 1 {
		m.t.Errorf("Expected call to ProviderMock.GetEmbeddingDimensionality at\n%s", m.GetEmbeddingDimensionalityMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetEmbeddingDimensionality != nil && afterGetEmbeddingDimensionalityCounter < 1 {
		m.t.Errorf("Expected call to ProviderMock.GetEmbeddingDimensionality at\n%s", m.funcGetEmbeddingDimensionalityOrigin)
	}

	if !m.GetEmbeddingDimensionalityMock.invocationsDone() && afterGetEmbeddingDimensionalityCounter > 0 {
		m.t.Errorf("Expected %d calls to ProviderMock.GetEmbeddingDimensionality at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetEmbeddingDimensionalityMock.expectedInvocations), m.GetEmbeddingDimensionalityMock.expectedInvocationsOrigin, afterGetEmbeddingDimensionalityCounter)
	}
}

type mProviderMockListCaches struct {
	optional           bool
	mock               *ProviderMock
	defaultExpectation *ProviderMockListCachesExpectation
	expectations       []*ProviderMockListCachesExpectation

	callArgs []*ProviderMockListCachesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProviderMockListCachesExpectation specifies expectation struct of the Provider.ListCaches
type ProviderMockListCachesExpectation struct {
	mock               *ProviderMock
	params             *ProviderMockListCachesParams
	paramPtrs          *ProviderMockListCachesParamPtrs
	expectationOrigins ProviderMockListCachesExpectationOrigins
	results            *ProviderMockListCachesResults
	returnOrigin       string
	Counter            uint64
}

// ProviderMockListCachesParams contains parameters of the Provider.ListCaches
type ProviderMockListCachesParams struct {
	ctx     context.Context
	options *mm_ai.CacheListOptions
}

// ProviderMockListCachesParamPtrs contains pointers to parameters of the Provider.ListCaches
type ProviderMockListCachesParamPtrs struct {
	ctx     *context.Context
	options **mm_ai.CacheListOptions
}

// ProviderMockListCachesResults contains results of the Provider.ListCaches
type ProviderMockListCachesResults struct {
	cp1 *mm_ai.CacheListResult
	err error
}

// ProviderMockListCachesOrigins contains origins of expectations of the Provider.ListCaches
type ProviderMockListCachesExpectationOrigins struct {
	origin        string
	originCtx     string
	originOptions string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListCaches *mProviderMockListCaches) Optional() *mProviderMockListCaches {
	mmListCaches.optional = true
	return mmListCaches
}

// Expect sets up expected params for Provider.ListCaches
func (mmListCaches *mProviderMockListCaches) Expect(ctx context.Context, options *mm_ai.CacheListOptions) *mProviderMockListCaches {
	if mmListCaches.mock.funcListCaches != nil {
		mmListCaches.mock.t.Fatalf("ProviderMock.ListCaches mock is already set by Set")
	}

	if mmListCaches.defaultExpectation == nil {
		mmListCaches.defaultExpectation = &ProviderMockListCachesExpectation{}
	}

	if mmListCaches.defaultExpectation.paramPtrs != nil {
		mmListCaches.mock.t.Fatalf("ProviderMock.ListCaches mock is already set by ExpectParams functions")
	}

	mmListCaches.defaultExpectation.params = &ProviderMockListCachesParams{ctx, options}
	mmListCaches.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListCaches.expectations {
		if minimock.Equal(e.params, mmListCaches.defaultExpectation.params) {
			mmListCaches.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListCaches.defaultExpectation.params)
		}
	}

	return mmListCaches
}

// ExpectCtxParam1 sets up expected param ctx for Provider.ListCaches
func (mmListCaches *mProviderMockListCaches) ExpectCtxParam1(ctx context.Context) *mProviderMockListCaches {
	if mmListCaches.mock.funcListCaches != nil {
		mmListCaches.mock.t.Fatalf("ProviderMock.ListCaches mock is already set by Set")
	}

	if mmListCaches.defaultExpectation == nil {
		mmListCaches.defaultExpectation = &ProviderMockListCachesExpectation{}
	}

	if mmListCaches.defaultExpectation.params != nil {
		mmListCaches.mock.t.Fatalf("ProviderMock.ListCaches mock is already set by Expect")
	}

	if mmListCaches.defaultExpectation.paramPtrs == nil {
		mmListCaches.defaultExpectation.paramPtrs = &ProviderMockListCachesParamPtrs{}
	}
	mmListCaches.defaultExpectation.paramPtrs.ctx = &ctx
	mmListCaches.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListCaches
}

// ExpectOptionsParam2 sets up expected param options for Provider.ListCaches
func (mmListCaches *mProviderMockListCaches) ExpectOptionsParam2(options *mm_ai.CacheListOptions) *mProviderMockListCaches {
	if mmListCaches.mock.funcListCaches != nil {
		mmListCaches.mock.t.Fatalf("ProviderMock.ListCaches mock is already set by Set")
	}

	if mmListCaches.defaultExpectation == nil {
		mmListCaches.defaultExpectation = &ProviderMockListCachesExpectation{}
	}

	if mmListCaches.defaultExpectation.params != nil {
		mmListCaches.mock.t.Fatalf("ProviderMock.ListCaches mock is already set by Expect")
	}

	if mmListCaches.defaultExpectation.paramPtrs == nil {
		mmListCaches.defaultExpectation.paramPtrs = &ProviderMockListCachesParamPtrs{}
	}
	mmListCaches.defaultExpectation.paramPtrs.options = &options
	mmListCaches.defaultExpectation.expectationOrigins.originOptions = minimock.CallerInfo(1)

	return mmListCaches
}

// Inspect accepts an inspector function that has same arguments as the Provider.ListCaches
func (mmListCaches *mProviderMockListCaches) Inspect(f func(ctx context.Context, options *mm_ai.CacheListOptions)) *mProviderMockListCaches {
	if mmListCaches.mock.inspectFuncListCaches != nil {
		mmListCaches.mock.t.Fatalf("Inspect function is already set for ProviderMock.ListCaches")
	}

	mmListCaches.mock.inspectFuncListCaches = f

	return mmListCaches
}

// Return sets up results that will be returned by Provider.ListCaches
func (mmListCaches *mProviderMockListCaches) Return(cp1 *mm_ai.CacheListResult, err error) *ProviderMock {
	if mmListCaches.mock.funcListCaches != nil {
		mmListCaches.mock.t.Fatalf("ProviderMock.ListCaches mock is already set by Set")
	}

	if mmListCaches.defaultExpectation == nil {
		mmListCaches.defaultExpectation = &ProviderMockListCachesExpectation{mock: mmListCaches.mock}
	}
	mmListCaches.defaultExpectation.results = &ProviderMockListCachesResults{cp1, err}
	mmListCaches.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListCaches.mock
}

// Set uses given function f to mock the Provider.ListCaches method
func (mmListCaches *mProviderMockListCaches) Set(f func(ctx context.Context, options *mm_ai.CacheListOptions) (cp1 *mm_ai.CacheListResult, err error)) *ProviderMock {
	if mmListCaches.defaultExpectation != nil {
		mmListCaches.mock.t.Fatalf("Default expectation is already set for the Provider.ListCaches method")
	}

	if len(mmListCaches.expectations) > 0 {
		mmListCaches.mock.t.Fatalf("Some expectations are already set for the Provider.ListCaches method")
	}

	mmListCaches.mock.funcListCaches = f
	mmListCaches.mock.funcListCachesOrigin = minimock.CallerInfo(1)
	return mmListCaches.mock
}

// When sets expectation for the Provider.ListCaches which will trigger the result defined by the following
// Then helper
func (mmListCaches *mProviderMockListCaches) When(ctx context.Context, options *mm_ai.CacheListOptions) *ProviderMockListCachesExpectation {
	if mmListCaches.mock.funcListCaches != nil {
		mmListCaches.mock.t.Fatalf("ProviderMock.ListCaches mock is already set by Set")
	}

	expectation := &ProviderMockListCachesExpectation{
		mock:               mmListCaches.mock,
		params:             &ProviderMockListCachesParams{ctx, options},
		expectationOrigins: ProviderMockListCachesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListCaches.expectations = append(mmListCaches.expectations, expectation)
	return expectation
}

// Then sets up Provider.ListCaches return parameters for the expectation previously defined by the When method
func (e *ProviderMockListCachesExpectation) Then(cp1 *mm_ai.CacheListResult, err error) *ProviderMock {
	e.results = &ProviderMockListCachesResults{cp1, err}
	return e.mock
}

// Times sets number of times Provider.ListCaches should be invoked
func (mmListCaches *mProviderMockListCaches) Times(n uint64) *mProviderMockListCaches {
	if n == 0 {
		mmListCaches.mock.t.Fatalf("Times of ProviderMock.ListCaches mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListCaches.expectedInvocations, n)
	mmListCaches.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListCaches
}

func (mmListCaches *mProviderMockListCaches) invocationsDone() bool {
	if len(mmListCaches.expectations) == 0 && mmListCaches.defaultExpectation == nil && mmListCaches.mock.funcListCaches == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListCaches.mock.afterListCachesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListCaches.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListCaches implements mm_ai.Provider
func (mmListCaches *ProviderMock) ListCaches(ctx context.Context, options *mm_ai.CacheListOptions) (cp1 *mm_ai.CacheListResult, err error) {
	mm_atomic.AddUint64(&mmListCaches.beforeListCachesCounter, 1)
	defer mm_atomic.AddUint64(&mmListCaches.afterListCachesCounter, 1)

	mmListCaches.t.Helper()

	if mmListCaches.inspectFuncListCaches != nil {
		mmListCaches.inspectFuncListCaches(ctx, options)
	}

	mm_params := ProviderMockListCachesParams{ctx, options}

	// Record call args
	mmListCaches.ListCachesMock.mutex.Lock()
	mmListCaches.ListCachesMock.callArgs = append(mmListCaches.ListCachesMock.callArgs, &mm_params)
	mmListCaches.ListCachesMock.mutex.Unlock()

	for _, e := range mmListCaches.ListCachesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmListCaches.ListCachesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListCaches.ListCachesMock.defaultExpectation.Counter, 1)
		mm_want := mmListCaches.ListCachesMock.defaultExpectation.params
		mm_want_ptrs := mmListCaches.ListCachesMock.defaultExpectation.paramPtrs

		mm_got := ProviderMockListCachesParams{ctx, options}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListCaches.t.Errorf("ProviderMock.ListCaches got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCaches.ListCachesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.options != nil && !minimock.Equal(*mm_want_ptrs.options, mm_got.options) {
				mmListCaches.t.Errorf("ProviderMock.ListCaches got unexpected parameter options, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCaches.ListCachesMock.defaultExpectation.expectationOrigins.originOptions, *mm_want_ptrs.options, mm_got.options, minimock.Diff(*mm_want_ptrs.options, mm_got.options))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListCaches.t.Errorf("ProviderMock.ListCaches got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListCaches.ListCachesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListCaches.ListCachesMock.defaultExpectation.results
		if mm_results == nil {
			mmListCaches.t.Fatal("No results are set for the ProviderMock.ListCaches")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmListCaches.funcListCaches != nil {
		return mmListCaches.funcListCaches(ctx, options)
	}
	mmListCaches.t.Fatalf("Unexpected call to ProviderMock.ListCaches. %v %v", ctx, options)
	return
}

// ListCachesAfterCounter returns a count of finished ProviderMock.ListCaches invocations
func (mmListCaches *ProviderMock) ListCachesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCaches.afterListCachesCounter)
}

// ListCachesBeforeCounter returns a count of ProviderMock.ListCaches invocations
func (mmListCaches *ProviderMock) ListCachesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCaches.beforeListCachesCounter)
}

// Calls returns a list of arguments used in each call to ProviderMock.ListCaches.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListCaches *mProviderMockListCaches) Calls() []*ProviderMockListCachesParams {
	mmListCaches.mutex.RLock()

	argCopy := make([]*ProviderMockListCachesParams, len(mmListCaches.callArgs))
	copy(argCopy, mmListCaches.callArgs)

	mmListCaches.mutex.RUnlock()

	return argCopy
}

// MinimockListCachesDone returns true if the count of the ListCaches invocations corresponds
// the number of defined expectations
func (m *ProviderMock) MinimockListCachesDone() bool {
	if m.ListCachesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListCachesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListCachesMock.invocationsDone()
}

// MinimockListCachesInspect logs each unmet expectation
func (m *ProviderMock) MinimockListCachesInspect() {
	for _, e := range m.ListCachesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProviderMock.ListCaches at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListCachesCounter := mm_atomic.LoadUint64(&m.afterListCachesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListCachesMock.defaultExpectation != nil && afterListCachesCounter < 1 {
		if m.ListCachesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ProviderMock.ListCaches at\n%s", m.ListCachesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ProviderMock.ListCaches at\n%s with params: %#v", m.ListCachesMock.defaultExpectation.expectationOrigins.origin, *m.ListCachesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCaches != nil && afterListCachesCounter < 1 {
		m.t.Errorf("Expected call to ProviderMock.ListCaches at\n%s", m.funcListCachesOrigin)
	}

	if !m.ListCachesMock.invocationsDone() && afterListCachesCounter > 0 {
		m.t.Errorf("Expected %d calls to ProviderMock.ListCaches at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListCachesMock.expectedInvocations), m.ListCachesMock.expectedInvocationsOrigin, afterListCachesCounter)
	}
}

type mProviderMockName struct {
	optional           bool
	mock               *ProviderMock
	defaultExpectation *ProviderMockNameExpectation
	expectations       []*ProviderMockNameExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProviderMockNameExpectation specifies expectation struct of the Provider.Name
type ProviderMockNameExpectation struct {
	mock *ProviderMock

	results      *ProviderMockNameResults
	returnOrigin string
	Counter      uint64
}

// ProviderMockNameResults contains results of the Provider.Name
type ProviderMockNameResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmName *mProviderMockName) Optional() *mProviderMockName {
	mmName.optional = true
	return mmName
}

// Expect sets up expected params for Provider.Name
func (mmName *mProviderMockName) Expect() *mProviderMockName {
	if mmName.mock.funcName != nil {
		mmName.mock.t.Fatalf("ProviderMock.Name mock is already set by Set")
	}

	if mmName.defaultExpectation == nil {
		mmName.defaultExpectation = &ProviderMockNameExpectation{}
	}

	return mmName
}

// Inspect accepts an inspector function that has same arguments as the Provider.Name
func (mmName *mProviderMockName) Inspect(f func()) *mProviderMockName {
	if mmName.mock.inspectFuncName != nil {
		mmName.mock.t.Fatalf("Inspect function is already set for ProviderMock.Name")
	}

	mmName.mock.inspectFuncName = f

	return mmName
}

// Return sets up results that will be returned by Provider.Name
func (mmName *mProviderMockName) Return(s1 string) *ProviderMock {
	if mmName.mock.funcName != nil {
		mmName.mock.t.Fatalf("ProviderMock.Name mock is already set by Set")
	}

	if mmName.defaultExpectation == nil {
		mmName.defaultExpectation = &ProviderMockNameExpectation{mock: mmName.mock}
	}
	mmName.defaultExpectation.results = &ProviderMockNameResults{s1}
	mmName.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmName.mock
}

// Set uses given function f to mock the Provider.Name method
func (mmName *mProviderMockName) Set(f func() (s1 string)) *ProviderMock {
	if mmName.defaultExpectation != nil {
		mmName.mock.t.Fatalf("Default expectation is already set for the Provider.Name method")
	}

	if len(mmName.expectations) > 0 {
		mmName.mock.t.Fatalf("Some expectations are already set for the Provider.Name method")
	}

	mmName.mock.funcName = f
	mmName.mock.funcNameOrigin = minimock.CallerInfo(1)
	return mmName.mock
}

// Times sets number of times Provider.Name should be invoked
func (mmName *mProviderMockName) Times(n uint64) *mProviderMockName {
	if n == 0 {
		mmName.mock.t.Fatalf("Times of ProviderMock.Name mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmName.expectedInvocations, n)
	mmName.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmName
}

func (mmName *mProviderMockName) invocationsDone() bool {
	if len(mmName.expectations) == 0 && mmName.defaultExpectation == nil && mmName.mock.funcName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmName.mock.afterNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Name implements mm_ai.Provider
func (mmName *ProviderMock) Name() (s1 string) {
	mm_atomic.AddUint64(&mmName.beforeNameCounter, 1)
	defer mm_atomic.AddUint64(&mmName.afterNameCounter, 1)

	mmName.t.Helper()

	if mmName.inspectFuncName != nil {
		mmName.inspectFuncName()
	}

	if mmName.NameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmName.NameMock.defaultExpectation.Counter, 1)

		mm_results := mmName.NameMock.defaultExpectation.results
		if mm_results == nil {
			mmName.t.Fatal("No results are set for the ProviderMock.Name")
		}
		return (*mm_results).s1
	}
	if mmName.funcName != nil {
		return mmName.funcName()
	}
	mmName.t.Fatalf("Unexpected call to ProviderMock.Name.")
	return
}

// NameAfterCounter returns a count of finished ProviderMock.Name invocations
func (mmName *ProviderMock) NameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmName.afterNameCounter)
}

// NameBeforeCounter returns a count of ProviderMock.Name invocations
func (mmName *ProviderMock) NameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmName.beforeNameCounter)
}

// MinimockNameDone returns true if the count of the Name invocations corresponds
// the number of defined expectations
func (m *ProviderMock) MinimockNameDone() bool {
	if m.NameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.NameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.NameMock.invocationsDone()
}

// MinimockNameInspect logs each unmet expectation
func (m *ProviderMock) MinimockNameInspect() {
	for _, e := range m.NameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ProviderMock.Name")
		}
	}

	afterNameCounter := mm_atomic.LoadUint64(&m.afterNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.NameMock.defaultExpectation != nil && afterNameCounter < 1 {
		m.t.Errorf("Expected call to ProviderMock.Name at\n%s", m.NameMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcName != nil && afterNameCounter < 1 {
		m.t.Errorf("Expected call to ProviderMock.Name at\n%s", m.funcNameOrigin)
	}

	if !m.NameMock.invocationsDone() && afterNameCounter > 0 {
		m.t.Errorf("Expected %d calls to ProviderMock.Name at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.NameMock.expectedInvocations), m.NameMock.expectedInvocationsOrigin, afterNameCounter)
	}
}

type mProviderMockSupportsFileType struct {
	optional           bool
	mock               *ProviderMock
	defaultExpectation *ProviderMockSupportsFileTypeExpectation
	expectations       []*ProviderMockSupportsFileTypeExpectation

	callArgs []*ProviderMockSupportsFileTypeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProviderMockSupportsFileTypeExpectation specifies expectation struct of the Provider.SupportsFileType
type ProviderMockSupportsFileTypeExpectation struct {
	mock               *ProviderMock
	params             *ProviderMockSupportsFileTypeParams
	paramPtrs          *ProviderMockSupportsFileTypeParamPtrs
	expectationOrigins ProviderMockSupportsFileTypeExpectationOrigins
	results            *ProviderMockSupportsFileTypeResults
	returnOrigin       string
	Counter            uint64
}

// ProviderMockSupportsFileTypeParams contains parameters of the Provider.SupportsFileType
type ProviderMockSupportsFileTypeParams struct {
	fileType artifactpb.FileType
}

// ProviderMockSupportsFileTypeParamPtrs contains pointers to parameters of the Provider.SupportsFileType
type ProviderMockSupportsFileTypeParamPtrs struct {
	fileType *artifactpb.FileType
}

// ProviderMockSupportsFileTypeResults contains results of the Provider.SupportsFileType
type ProviderMockSupportsFileTypeResults struct {
	b1 bool
}

// ProviderMockSupportsFileTypeOrigins contains origins of expectations of the Provider.SupportsFileType
type ProviderMockSupportsFileTypeExpectationOrigins struct {
	origin         string
	originFileType string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSupportsFileType *mProviderMockSupportsFileType) Optional() *mProviderMockSupportsFileType {
	mmSupportsFileType.optional = true
	return mmSupportsFileType
}

// Expect sets up expected params for Provider.SupportsFileType
func (mmSupportsFileType *mProviderMockSupportsFileType) Expect(fileType artifactpb.FileType) *mProviderMockSupportsFileType {
	if mmSupportsFileType.mock.funcSupportsFileType != nil {
		mmSupportsFileType.mock.t.Fatalf("ProviderMock.SupportsFileType mock is already set by Set")
	}

	if mmSupportsFileType.defaultExpectation == nil {
		mmSupportsFileType.defaultExpectation = &ProviderMockSupportsFileTypeExpectation{}
	}

	if mmSupportsFileType.defaultExpectation.paramPtrs != nil {
		mmSupportsFileType.mock.t.Fatalf("ProviderMock.SupportsFileType mock is already set by ExpectParams functions")
	}

	mmSupportsFileType.defaultExpectation.params = &ProviderMockSupportsFileTypeParams{fileType}
	mmSupportsFileType.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSupportsFileType.expectations {
		if minimock.Equal(e.params, mmSupportsFileType.defaultExpectation.params) {
			mmSupportsFileType.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSupportsFileType.defaultExpectation.params)
		}
	}

	return mmSupportsFileType
}

// ExpectFileTypeParam1 sets up expected param fileType for Provider.SupportsFileType
func (mmSupportsFileType *mProviderMockSupportsFileType) ExpectFileTypeParam1(fileType artifactpb.FileType) *mProviderMockSupportsFileType {
	if mmSupportsFileType.mock.funcSupportsFileType != nil {
		mmSupportsFileType.mock.t.Fatalf("ProviderMock.SupportsFileType mock is already set by Set")
	}

	if mmSupportsFileType.defaultExpectation == nil {
		mmSupportsFileType.defaultExpectation = &ProviderMockSupportsFileTypeExpectation{}
	}

	if mmSupportsFileType.defaultExpectation.params != nil {
		mmSupportsFileType.mock.t.Fatalf("ProviderMock.SupportsFileType mock is already set by Expect")
	}

	if mmSupportsFileType.defaultExpectation.paramPtrs == nil {
		mmSupportsFileType.defaultExpectation.paramPtrs = &ProviderMockSupportsFileTypeParamPtrs{}
	}
	mmSupportsFileType.defaultExpectation.paramPtrs.fileType = &fileType
	mmSupportsFileType.defaultExpectation.expectationOrigins.originFileType = minimock.CallerInfo(1)

	return mmSupportsFileType
}

// Inspect accepts an inspector function that has same arguments as the Provider.SupportsFileType
func (mmSupportsFileType *mProviderMockSupportsFileType) Inspect(f func(fileType artifactpb.FileType)) *mProviderMockSupportsFileType {
	if mmSupportsFileType.mock.inspectFuncSupportsFileType != nil {
		mmSupportsFileType.mock.t.Fatalf("Inspect function is already set for ProviderMock.SupportsFileType")
	}

	mmSupportsFileType.mock.inspectFuncSupportsFileType = f

	return mmSupportsFileType
}

// Return sets up results that will be returned by Provider.SupportsFileType
func (mmSupportsFileType *mProviderMockSupportsFileType) Return(b1 bool) *ProviderMock {
	if mmSupportsFileType.mock.funcSupportsFileType != nil {
		mmSupportsFileType.mock.t.Fatalf("ProviderMock.SupportsFileType mock is already set by Set")
	}

	if mmSupportsFileType.defaultExpectation == nil {
		mmSupportsFileType.defaultExpectation = &ProviderMockSupportsFileTypeExpectation{mock: mmSupportsFileType.mock}
	}
	mmSupportsFileType.defaultExpectation.results = &ProviderMockSupportsFileTypeResults{b1}
	mmSupportsFileType.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSupportsFileType.mock
}

// Set uses given function f to mock the Provider.SupportsFileType method
func (mmSupportsFileType *mProviderMockSupportsFileType) Set(f func(fileType artifactpb.FileType) (b1 bool)) *ProviderMock {
	if mmSupportsFileType.defaultExpectation != nil {
		mmSupportsFileType.mock.t.Fatalf("Default expectation is already set for the Provider.SupportsFileType method")
	}

	if len(mmSupportsFileType.expectations) > 0 {
		mmSupportsFileType.mock.t.Fatalf("Some expectations are already set for the Provider.SupportsFileType method")
	}

	mmSupportsFileType.mock.funcSupportsFileType = f
	mmSupportsFileType.mock.funcSupportsFileTypeOrigin = minimock.CallerInfo(1)
	return mmSupportsFileType.mock
}

// When sets expectation for the Provider.SupportsFileType which will trigger the result defined by the following
// Then helper
func (mmSupportsFileType *mProviderMockSupportsFileType) When(fileType artifactpb.FileType) *ProviderMockSupportsFileTypeExpectation {
	if mmSupportsFileType.mock.funcSupportsFileType != nil {
		mmSupportsFileType.mock.t.Fatalf("ProviderMock.SupportsFileType mock is already set by Set")
	}

	expectation := &ProviderMockSupportsFileTypeExpectation{
		mock:               mmSupportsFileType.mock,
		params:             &ProviderMockSupportsFileTypeParams{fileType},
		expectationOrigins: ProviderMockSupportsFileTypeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSupportsFileType.expectations = append(mmSupportsFileType.expectations, expectation)
	return expectation
}

// Then sets up Provider.SupportsFileType return parameters for the expectation previously defined by the When method
func (e *ProviderMockSupportsFileTypeExpectation) Then(b1 bool) *ProviderMock {
	e.results = &ProviderMockSupportsFileTypeResults{b1}
	return e.mock
}

// Times sets number of times Provider.SupportsFileType should be invoked
func (mmSupportsFileType *mProviderMockSupportsFileType) Times(n uint64) *mProviderMockSupportsFileType {
	if n == 0 {
		mmSupportsFileType.mock.t.Fatalf("Times of ProviderMock.SupportsFileType mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSupportsFileType.expectedInvocations, n)
	mmSupportsFileType.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSupportsFileType
}

func (mmSupportsFileType *mProviderMockSupportsFileType) invocationsDone() bool {
	if len(mmSupportsFileType.expectations) == 0 && mmSupportsFileType.defaultExpectation == nil && mmSupportsFileType.mock.funcSupportsFileType == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSupportsFileType.mock.afterSupportsFileTypeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSupportsFileType.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SupportsFileType implements mm_ai.Provider
func (mmSupportsFileType *ProviderMock) SupportsFileType(fileType artifactpb.FileType) (b1 bool) {
	mm_atomic.AddUint64(&mmSupportsFileType.beforeSupportsFileTypeCounter, 1)
	defer mm_atomic.AddUint64(&mmSupportsFileType.afterSupportsFileTypeCounter, 1)

	mmSupportsFileType.t.Helper()

	if mmSupportsFileType.inspectFuncSupportsFileType != nil {
		mmSupportsFileType.inspectFuncSupportsFileType(fileType)
	}

	mm_params := ProviderMockSupportsFileTypeParams{fileType}

	// Record call args
	mmSupportsFileType.SupportsFileTypeMock.mutex.Lock()
	mmSupportsFileType.SupportsFileTypeMock.callArgs = append(mmSupportsFileType.SupportsFileTypeMock.callArgs, &mm_params)
	mmSupportsFileType.SupportsFileTypeMock.mutex.Unlock()

	for _, e := range mmSupportsFileType.SupportsFileTypeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmSupportsFileType.SupportsFileTypeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSupportsFileType.SupportsFileTypeMock.defaultExpectation.Counter, 1)
		mm_want := mmSupportsFileType.SupportsFileTypeMock.defaultExpectation.params
		mm_want_ptrs := mmSupportsFileType.SupportsFileTypeMock.defaultExpectation.paramPtrs

		mm_got := ProviderMockSupportsFileTypeParams{fileType}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.fileType != nil && !minimock.Equal(*mm_want_ptrs.fileType, mm_got.fileType) {
				mmSupportsFileType.t.Errorf("ProviderMock.SupportsFileType got unexpected parameter fileType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSupportsFileType.SupportsFileTypeMock.defaultExpectation.expectationOrigins.originFileType, *mm_want_ptrs.fileType, mm_got.fileType, minimock.Diff(*mm_want_ptrs.fileType, mm_got.fileType))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSupportsFileType.t.Errorf("ProviderMock.SupportsFileType got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSupportsFileType.SupportsFileTypeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSupportsFileType.SupportsFileTypeMock.defaultExpectation.results
		if mm_results == nil {
			mmSupportsFileType.t.Fatal("No results are set for the ProviderMock.SupportsFileType")
		}
		return (*mm_results).b1
	}
	if mmSupportsFileType.funcSupportsFileType != nil {
		return mmSupportsFileType.funcSupportsFileType(fileType)
	}
	mmSupportsFileType.t.Fatalf("Unexpected call to ProviderMock.SupportsFileType. %v", fileType)
	return
}

// SupportsFileTypeAfterCounter returns a count of finished ProviderMock.SupportsFileType invocations
func (mmSupportsFileType *ProviderMock) SupportsFileTypeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSupportsFileType.afterSupportsFileTypeCounter)
}

// SupportsFileTypeBeforeCounter returns a count of ProviderMock.SupportsFileType invocations
func (mmSupportsFileType *ProviderMock) SupportsFileTypeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSupportsFileType.beforeSupportsFileTypeCounter)
}

// Calls returns a list of arguments used in each call to ProviderMock.SupportsFileType.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSupportsFileType *mProviderMockSupportsFileType) Calls() []*ProviderMockSupportsFileTypeParams {
	mmSupportsFileType.mutex.RLock()

	argCopy := make([]*ProviderMockSupportsFileTypeParams, len(mmSupportsFileType.callArgs))
	copy(argCopy, mmSupportsFileType.callArgs)

	mmSupportsFileType.mutex.RUnlock()

	return argCopy
}

// MinimockSupportsFileTypeDone returns true if the count of the SupportsFileType invocations corresponds
// the number of defined expectations
func (m *ProviderMock) MinimockSupportsFileTypeDone() bool {
	if m.SupportsFileTypeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SupportsFileTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SupportsFileTypeMock.invocationsDone()
}

// MinimockSupportsFileTypeInspect logs each unmet expectation
func (m *ProviderMock) MinimockSupportsFileTypeInspect() {
	for _, e := range m.SupportsFileTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProviderMock.SupportsFileType at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSupportsFileTypeCounter := mm_atomic.LoadUint64(&m.afterSupportsFileTypeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SupportsFileTypeMock.defaultExpectation != nil && afterSupportsFileTypeCounter < 1 {
		if m.SupportsFileTypeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ProviderMock.SupportsFileType at\n%s", m.SupportsFileTypeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ProviderMock.SupportsFileType at\n%s with params: %#v", m.SupportsFileTypeMock.defaultExpectation.expectationOrigins.origin, *m.SupportsFileTypeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSupportsFileType != nil && afterSupportsFileTypeCounter < 1 {
		m.t.Errorf("Expected call to ProviderMock.SupportsFileType at\n%s", m.funcSupportsFileTypeOrigin)
	}

	if !m.SupportsFileTypeMock.invocationsDone() && afterSupportsFileTypeCounter > 0 {
		m.t.Errorf("Expected %d calls to ProviderMock.SupportsFileType at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SupportsFileTypeMock.expectedInvocations), m.SupportsFileTypeMock.expectedInvocationsOrigin, afterSupportsFileTypeCounter)
	}
}

type mProviderMockUpdateCache struct {
	optional           bool
	mock               *ProviderMock
	defaultExpectation *ProviderMockUpdateCacheExpectation
	expectations       []*ProviderMockUpdateCacheExpectation

	callArgs []*ProviderMockUpdateCacheParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProviderMockUpdateCacheExpectation specifies expectation struct of the Provider.UpdateCache
type ProviderMockUpdateCacheExpectation struct {
	mock               *ProviderMock
	params             *ProviderMockUpdateCacheParams
	paramPtrs          *ProviderMockUpdateCacheParamPtrs
	expectationOrigins ProviderMockUpdateCacheExpectationOrigins
	results            *ProviderMockUpdateCacheResults
	returnOrigin       string
	Counter            uint64
}

// ProviderMockUpdateCacheParams contains parameters of the Provider.UpdateCache
type ProviderMockUpdateCacheParams struct {
	ctx       context.Context
	cacheName string
	options   *mm_ai.CacheUpdateOptions
}

// ProviderMockUpdateCacheParamPtrs contains pointers to parameters of the Provider.UpdateCache
type ProviderMockUpdateCacheParamPtrs struct {
	ctx       *context.Context
	cacheName *string
	options   **mm_ai.CacheUpdateOptions
}

// ProviderMockUpdateCacheResults contains results of the Provider.UpdateCache
type ProviderMockUpdateCacheResults struct {
	cp1 *mm_ai.CacheResult
	err error
}

// ProviderMockUpdateCacheOrigins contains origins of expectations of the Provider.UpdateCache
type ProviderMockUpdateCacheExpectationOrigins struct {
	origin          string
	originCtx       string
	originCacheName string
	originOptions   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateCache *mProviderMockUpdateCache) Optional() *mProviderMockUpdateCache {
	mmUpdateCache.optional = true
	return mmUpdateCache
}

// Expect sets up expected params for Provider.UpdateCache
func (mmUpdateCache *mProviderMockUpdateCache) Expect(ctx context.Context, cacheName string, options *mm_ai.CacheUpdateOptions) *mProviderMockUpdateCache {
	if mmUpdateCache.mock.funcUpdateCache != nil {
		mmUpdateCache.mock.t.Fatalf("ProviderMock.UpdateCache mock is already set by Set")
	}

	if mmUpdateCache.defaultExpectation == nil {
		mmUpdateCache.defaultExpectation = &ProviderMockUpdateCacheExpectation{}
	}

	if mmUpdateCache.defaultExpectation.paramPtrs != nil {
		mmUpdateCache.mock.t.Fatalf("ProviderMock.UpdateCache mock is already set by ExpectParams functions")
	}

	mmUpdateCache.defaultExpectation.params = &ProviderMockUpdateCacheParams{ctx, cacheName, options}
	mmUpdateCache.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateCache.expectations {
		if minimock.Equal(e.params, mmUpdateCache.defaultExpectation.params) {
			mmUpdateCache.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateCache.defaultExpectation.params)
		}
	}

	return mmUpdateCache
}

// ExpectCtxParam1 sets up expected param ctx for Provider.UpdateCache
func (mmUpdateCache *mProviderMockUpdateCache) ExpectCtxParam1(ctx context.Context) *mProviderMockUpdateCache {
	if mmUpdateCache.mock.funcUpdateCache != nil {
		mmUpdateCache.mock.t.Fatalf("ProviderMock.UpdateCache mock is already set by Set")
	}

	if mmUpdateCache.defaultExpectation == nil {
		mmUpdateCache.defaultExpectation = &ProviderMockUpdateCacheExpectation{}
	}

	if mmUpdateCache.defaultExpectation.params != nil {
		mmUpdateCache.mock.t.Fatalf("ProviderMock.UpdateCache mock is already set by Expect")
	}

	if mmUpdateCache.defaultExpectation.paramPtrs == nil {
		mmUpdateCache.defaultExpectation.paramPtrs = &ProviderMockUpdateCacheParamPtrs{}
	}
	mmUpdateCache.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateCache.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateCache
}

// ExpectCacheNameParam2 sets up expected param cacheName for Provider.UpdateCache
func (mmUpdateCache *mProviderMockUpdateCache) ExpectCacheNameParam2(cacheName string) *mProviderMockUpdateCache {
	if mmUpdateCache.mock.funcUpdateCache != nil {
		mmUpdateCache.mock.t.Fatalf("ProviderMock.UpdateCache mock is already set by Set")
	}

	if mmUpdateCache.defaultExpectation == nil {
		mmUpdateCache.defaultExpectation = &ProviderMockUpdateCacheExpectation{}
	}

	if mmUpdateCache.defaultExpectation.params != nil {
		mmUpdateCache.mock.t.Fatalf("ProviderMock.UpdateCache mock is already set by Expect")
	}

	if mmUpdateCache.defaultExpectation.paramPtrs == nil {
		mmUpdateCache.defaultExpectation.paramPtrs = &ProviderMockUpdateCacheParamPtrs{}
	}
	mmUpdateCache.defaultExpectation.paramPtrs.cacheName = &cacheName
	mmUpdateCache.defaultExpectation.expectationOrigins.originCacheName = minimock.CallerInfo(1)

	return mmUpdateCache
}

// ExpectOptionsParam3 sets up expected param options for Provider.UpdateCache
func (mmUpdateCache *mProviderMockUpdateCache) ExpectOptionsParam3(options *mm_ai.CacheUpdateOptions) *mProviderMockUpdateCache {
	if mmUpdateCache.mock.funcUpdateCache != nil {
		mmUpdateCache.mock.t.Fatalf("ProviderMock.UpdateCache mock is already set by Set")
	}

	if mmUpdateCache.defaultExpectation == nil {
		mmUpdateCache.defaultExpectation = &ProviderMockUpdateCacheExpectation{}
	}

	if mmUpdateCache.defaultExpectation.params != nil {
		mmUpdateCache.mock.t.Fatalf("ProviderMock.UpdateCache mock is already set by Expect")
	}

	if mmUpdateCache.defaultExpectation.paramPtrs == nil {
		mmUpdateCache.defaultExpectation.paramPtrs = &ProviderMockUpdateCacheParamPtrs{}
	}
	mmUpdateCache.defaultExpectation.paramPtrs.options = &options
	mmUpdateCache.defaultExpectation.expectationOrigins.originOptions = minimock.CallerInfo(1)

	return mmUpdateCache
}

// Inspect accepts an inspector function that has same arguments as the Provider.UpdateCache
func (mmUpdateCache *mProviderMockUpdateCache) Inspect(f func(ctx context.Context, cacheName string, options *mm_ai.CacheUpdateOptions)) *mProviderMockUpdateCache {
	if mmUpdateCache.mock.inspectFuncUpdateCache != nil {
		mmUpdateCache.mock.t.Fatalf("Inspect function is already set for ProviderMock.UpdateCache")
	}

	mmUpdateCache.mock.inspectFuncUpdateCache = f

	return mmUpdateCache
}

// Return sets up results that will be returned by Provider.UpdateCache
func (mmUpdateCache *mProviderMockUpdateCache) Return(cp1 *mm_ai.CacheResult, err error) *ProviderMock {
	if mmUpdateCache.mock.funcUpdateCache != nil {
		mmUpdateCache.mock.t.Fatalf("ProviderMock.UpdateCache mock is already set by Set")
	}

	if mmUpdateCache.defaultExpectation == nil {
		mmUpdateCache.defaultExpectation = &ProviderMockUpdateCacheExpectation{mock: mmUpdateCache.mock}
	}
	mmUpdateCache.defaultExpectation.results = &ProviderMockUpdateCacheResults{cp1, err}
	mmUpdateCache.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateCache.mock
}

// Set uses given function f to mock the Provider.UpdateCache method
func (mmUpdateCache *mProviderMockUpdateCache) Set(f func(ctx context.Context, cacheName string, options *mm_ai.CacheUpdateOptions) (cp1 *mm_ai.CacheResult, err error)) *ProviderMock {
	if mmUpdateCache.defaultExpectation != nil {
		mmUpdateCache.mock.t.Fatalf("Default expectation is already set for the Provider.UpdateCache method")
	}

	if len(mmUpdateCache.expectations) > 0 {
		mmUpdateCache.mock.t.Fatalf("Some expectations are already set for the Provider.UpdateCache method")
	}

	mmUpdateCache.mock.funcUpdateCache = f
	mmUpdateCache.mock.funcUpdateCacheOrigin = minimock.CallerInfo(1)
	return mmUpdateCache.mock
}

// When sets expectation for the Provider.UpdateCache which will trigger the result defined by the following
// Then helper
func (mmUpdateCache *mProviderMockUpdateCache) When(ctx context.Context, cacheName string, options *mm_ai.CacheUpdateOptions) *ProviderMockUpdateCacheExpectation {
	if mmUpdateCache.mock.funcUpdateCache != nil {
		mmUpdateCache.mock.t.Fatalf("ProviderMock.UpdateCache mock is already set by Set")
	}

	expectation := &ProviderMockUpdateCacheExpectation{
		mock:               mmUpdateCache.mock,
		params:             &ProviderMockUpdateCacheParams{ctx, cacheName, options},
		expectationOrigins: ProviderMockUpdateCacheExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateCache.expectations = append(mmUpdateCache.expectations, expectation)
	return expectation
}

// Then sets up Provider.UpdateCache return parameters for the expectation previously defined by the When method
func (e *ProviderMockUpdateCacheExpectation) Then(cp1 *mm_ai.CacheResult, err error) *ProviderMock {
	e.results = &ProviderMockUpdateCacheResults{cp1, err}
	return e.mock
}

// Times sets number of times Provider.UpdateCache should be invoked
func (mmUpdateCache *mProviderMockUpdateCache) Times(n uint64) *mProviderMockUpdateCache {
	if n == 0 {
		mmUpdateCache.mock.t.Fatalf("Times of ProviderMock.UpdateCache mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateCache.expectedInvocations, n)
	mmUpdateCache.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateCache
}

func (mmUpdateCache *mProviderMockUpdateCache) invocationsDone() bool {
	if len(mmUpdateCache.expectations) == 0 && mmUpdateCache.defaultExpectation == nil && mmUpdateCache.mock.funcUpdateCache == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateCache.mock.afterUpdateCacheCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateCache.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateCache implements mm_ai.Provider
func (mmUpdateCache *ProviderMock) UpdateCache(ctx context.Context, cacheName string, options *mm_ai.CacheUpdateOptions) (cp1 *mm_ai.CacheResult, err error) {
	mm_atomic.AddUint64(&mmUpdateCache.beforeUpdateCacheCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateCache.afterUpdateCacheCounter, 1)

	mmUpdateCache.t.Helper()

	if mmUpdateCache.inspectFuncUpdateCache != nil {
		mmUpdateCache.inspectFuncUpdateCache(ctx, cacheName, options)
	}

	mm_params := ProviderMockUpdateCacheParams{ctx, cacheName, options}

	// Record call args
	mmUpdateCache.UpdateCacheMock.mutex.Lock()
	mmUpdateCache.UpdateCacheMock.callArgs = append(mmUpdateCache.UpdateCacheMock.callArgs, &mm_params)
	mmUpdateCache.UpdateCacheMock.mutex.Unlock()

	for _, e := range mmUpdateCache.UpdateCacheMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmUpdateCache.UpdateCacheMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateCache.UpdateCacheMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateCache.UpdateCacheMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateCache.UpdateCacheMock.defaultExpectation.paramPtrs

		mm_got := ProviderMockUpdateCacheParams{ctx, cacheName, options}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateCache.t.Errorf("ProviderMock.UpdateCache got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateCache.UpdateCacheMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cacheName != nil && !minimock.Equal(*mm_want_ptrs.cacheName, mm_got.cacheName) {
				mmUpdateCache.t.Errorf("ProviderMock.UpdateCache got unexpected parameter cacheName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateCache.UpdateCacheMock.defaultExpectation.expectationOrigins.originCacheName, *mm_want_ptrs.cacheName, mm_got.cacheName, minimock.Diff(*mm_want_ptrs.cacheName, mm_got.cacheName))
			}

			if mm_want_ptrs.options != nil && !minimock.Equal(*mm_want_ptrs.options, mm_got.options) {
				mmUpdateCache.t.Errorf("ProviderMock.UpdateCache got unexpected parameter options, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateCache.UpdateCacheMock.defaultExpectation.expectationOrigins.originOptions, *mm_want_ptrs.options, mm_got.options, minimock.Diff(*mm_want_ptrs.options, mm_got.options))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateCache.t.Errorf("ProviderMock.UpdateCache got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateCache.UpdateCacheMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateCache.UpdateCacheMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateCache.t.Fatal("No results are set for the ProviderMock.UpdateCache")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmUpdateCache.funcUpdateCache != nil {
		return mmUpdateCache.funcUpdateCache(ctx, cacheName, options)
	}
	mmUpdateCache.t.Fatalf("Unexpected call to ProviderMock.UpdateCache. %v %v %v", ctx, cacheName, options)
	return
}

// UpdateCacheAfterCounter returns a count of finished ProviderMock.UpdateCache invocations
func (mmUpdateCache *ProviderMock) UpdateCacheAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCache.afterUpdateCacheCounter)
}

// UpdateCacheBeforeCounter returns a count of ProviderMock.UpdateCache invocations
func (mmUpdateCache *ProviderMock) UpdateCacheBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCache.beforeUpdateCacheCounter)
}

// Calls returns a list of arguments used in each call to ProviderMock.UpdateCache.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateCache *mProviderMockUpdateCache) Calls() []*ProviderMockUpdateCacheParams {
	mmUpdateCache.mutex.RLock()

	argCopy := make([]*ProviderMockUpdateCacheParams, len(mmUpdateCache.callArgs))
	copy(argCopy, mmUpdateCache.callArgs)

	mmUpdateCache.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateCacheDone returns true if the count of the UpdateCache invocations corresponds
// the number of defined expectations
func (m *ProviderMock) MinimockUpdateCacheDone() bool {
	if m.UpdateCacheMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateCacheMock.invocationsDone()
}

// MinimockUpdateCacheInspect logs each unmet expectation
func (m *ProviderMock) MinimockUpdateCacheInspect() {
	for _, e := range m.UpdateCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProviderMock.UpdateCache at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCacheCounter := mm_atomic.LoadUint64(&m.afterUpdateCacheCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCacheMock.defaultExpectation != nil && afterUpdateCacheCounter < 1 {
		if m.UpdateCacheMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ProviderMock.UpdateCache at\n%s", m.UpdateCacheMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ProviderMock.UpdateCache at\n%s with params: %#v", m.UpdateCacheMock.defaultExpectation.expectationOrigins.origin, *m.UpdateCacheMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCache != nil && afterUpdateCacheCounter < 1 {
		m.t.Errorf("Expected call to ProviderMock.UpdateCache at\n%s", m.funcUpdateCacheOrigin)
	}

	if !m.UpdateCacheMock.invocationsDone() && afterUpdateCacheCounter > 0 {
		m.t.Errorf("Expected %d calls to ProviderMock.UpdateCache at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateCacheMock.expectedInvocations), m.UpdateCacheMock.expectedInvocationsOrigin, afterUpdateCacheCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ProviderMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockChatWithCacheInspect()

			m.MinimockChatWithFilesInspect()

			m.MinimockCloseInspect()

			m.MinimockConvertToMarkdownWithCacheInspect()

			m.MinimockConvertToMarkdownWithoutCacheInspect()

			m.MinimockCreateCacheInspect()

			m.MinimockDeleteCacheInspect()

			m.MinimockEmbedTextsInspect()

			m.MinimockGetCacheInspect()

			m.MinimockGetEmbeddingDimensionalityInspect()

			m.MinimockListCachesInspect()

			m.MinimockNameInspect()

			m.MinimockSupportsFileTypeInspect()

			m.MinimockUpdateCacheInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ProviderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ProviderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockChatWithCacheDone() &&
		m.MinimockChatWithFilesDone() &&
		m.MinimockCloseDone() &&
		m.MinimockConvertToMarkdownWithCacheDone() &&
		m.MinimockConvertToMarkdownWithoutCacheDone() &&
		m.MinimockCreateCacheDone() &&
		m.MinimockDeleteCacheDone() &&
		m.MinimockEmbedTextsDone() &&
		m.MinimockGetCacheDone() &&
		m.MinimockGetEmbeddingDimensionalityDone() &&
		m.MinimockListCachesDone() &&
		m.MinimockNameDone() &&
		m.MinimockSupportsFileTypeDone() &&
		m.MinimockUpdateCacheDone()
}
